)
    {
       	/* get the sorting codes & if not equal, return the difference */
       	/* if we must ignore punc, then loop over them */
       	if (!cch1)
       	    compstrinfo1.priwt = compstrinfo1.secwt = 0;
       	else
       	{
       	    do
       	    {
                cch1 = GetSortWeightJ(&lpstr1, cch1, &compstrinfo1);
           		if ( (g_dwFlags & NORM_IGNORESYMBOLS) && 
           		    compstrinfo1.priwt>=0x1400 && 
           	        compstrinfo1.priwt<=0x54FF )
           		    compstrinfo1.priwt = compstrinfo1.secwt = 0;
       	    } while ( cch1 && compstrinfo1.priwt==0 );
       	}

       	if (!cch2)
       	    compstrinfo2.priwt = compstrinfo2.secwt = 0;

       	else {
       	    do
       	    {
                cch2 = GetSortWeightJ(&lpstr2, cch2, &compstrinfo2);
       		    if ( (g_dwFlags & NORM_IGNORESYMBOLS) && 
       		        compstrinfo2.priwt>=0x1400 && 
       		        compstrinfo2.priwt<=0x54FF)
       		    {
       		        compstrinfo2.priwt = compstrinfo2.secwt = 0;
       		    }
       	    } while ( cch2 && compstrinfo2.priwt==0 );
       	}

       	/* This exit path also used when just one string is empty */
       	if (compstrinfo1.priwt != compstrinfo2.priwt)
       	    return (compstrinfo1.priwt - compstrinfo2.priwt);

       	/* first order values same, so check 2nd, 3rd .. 6th for differences */
       	/* stop scanning when we reach an order where we have a previous diff */
       	if (compstrinfo1.secwt!=compstrinfo2.secwt)
       	{
       	    for( pbMasks=pbgMasks;(bFlgMask=pbMasks[1]) && bFlgMask!=b1stDiff;
       	        pbMasks+=4 )
       	    {
       		    if (bFlgMask & compstrinfo1.secflg)
       		    {
                    bWgtMask = pbMasks[0];
       		        bTemp = (compstrinfo1.secwt & bWgtMask) - 
       		            (compstrinfo2.secwt & bWgtMask);

       		        /* if we find a difference it must be the most important
       		         * so far so save it and remember which order it belongs
       		         * to - then stop
       		         */
                    if (bTemp)
           		    {
                        b1stDiffValue = bTemp;
                        b1stDiff = bFlgMask;
                        break;		/* move onto the next character pair */
                    }
                }
       	   }
       }
   }

   /* no 1st order diffs, so ret by 2nd..6th order diff */
   if (b1stDiff)
	   return (b1stDiffValue);

   return 0;
}

/***
* GetSortWeightJ - get the sort weight for Japan.
*               ( handles diacritical merging )
*Purpose:
*
*Entry:
*
*Exit:
*   returns TRUE  :
*           FALSE :
*Note:
*   Priwt : Word
*   Secwt : Byte, contains 2nd, 3rd .. 6th order sorting values
*   SecFlg: Byte, contains flags to say which orders to use
*
***********************************************************************/
PRIVATE int PASCAL NEAR GetSortWeightJ(
    LPBYTE FAR*plpstr1, int cch1, COMPSTRINGINFO FAR *pcompstrinfo)
{
    unsigned int Priwt, NextCh;
    BYTE Secwt, SecFlg;
    LPBYTE lpstr1 = *plpstr1;
    LPBYTE pbMasks;

    /* first pick up the next whole character */
    Priwt = *lpstr1++;
    cch1--;

    if (cch1 && isDbcsJ(Priwt, 0))
    {
    	Priwt = (Priwt << 8) + *lpstr1++;
    	cch1--;
    }

    /* if this a Kanji outside our tables force the correct values */
    if (Priwt >= 0x87A0)
    {
    	Priwt |= 0x4000;	/* 0x8nnn -> 0xCnnn, 9->D, E->E, F->F */
    	Secwt = 0x00;
    	SecFlg = 0x04;		/* for repeat character order */
    	goto AllDone;
    }

    /* Char can be sorted by table, so mask into range & get table values */
    Priwt &= 0x0FFF;		/* 0x00nn -> 0x00nn, 81->01, 82->02, 83->03 */

    Secwt  = pbSecWgt[Priwt];
    SecFlg = pbSecFlg[Priwt];
    Priwt  = (pbPriHi[Priwt] << 8) + pbPriLo[Priwt];

    /* Most characters now complete, but a few need extra processing */
    /* eg. Kana that can have Daku-ten or Handaku-ten, Cho-on or repeat chars */
    if ( (Priwt&0x00FF) != 0x00FF )
    	goto AllDone;

    Priwt &= 0xFF00;		/* mask off the special flag */

    /* If we have a Kana, test for following Daku-ten or Handaku-ten */
    if (Priwt >= 0x8700)
    {
       	if (cch1)
       	{
       	    NextCh = *lpstr1;
          	if (cch1>=2 && isDbcsJ(NextCh, 0))
       		NextCh = (NextCh << 8) + *(lpstr1+1);
       	    if (NextCh==0x00DE || NextCh==0x814A)
       	    {
           		lpstr1 += (NextCh==0x00DE) ? 1 : 2;
           		cch1 -= (NextCh==0x00DE) ? 1 : 2;
           		Secwt |= 0x01;
       	    }
       	    else if (NextCh==0x00DF || NextCh==0x814B)
       	    {
           		lpstr1 += (NextCh==0x00DF) ? 1 : 2;
           		cch1 -= (NextCh==0x00DF) ? 1 : 2;
           		Secwt |= 0x02;
       	    }
       	}
    	goto AllDone;
    }

    /* If not kana, must be Cho-on or a repeat character - try Kanji repeat */
    if (Priwt==0x3A00)
    {
    	if ( pcompstrinfo->priwt >= 0xC7A0 )	/* if prev was Kanji, use it */
    	    Priwt = pcompstrinfo->priwt;
		Secwt = pcompstrinfo->secwt | 0x08;	    /* with a repeat marker */
	    SecFlg = pcompstrinfo->secflg;
		goto AllDone;
    }

    /* Cho-on and Kana repeat chars only used if they actually follow a kana */
    if (pcompstrinfo->priwt<0x8700 || pcompstrinfo->priwt>0xB9FF)
		goto AllDone;

    /* Cho-on characters duplicate the vowel sound of the prev. charater */
    /* except when they follow a N, in which case they act like repeat */
    if ((Priwt==0x4400 || Priwt==0x3500) && pcompstrinfo->priwt<0xB900)
    {
		Priwt = ((pcompstrinfo->priwt % 5) << 8) + 0x8700;
		Secwt |= (pcompstrinfo->secwt&0x20);
    	SecFlg = 0x37;
		goto AllDone;
    }

    /* Kana repeat is the only special character left */
    /* second order values should be merged with those of previous character */
    Priwt = pcompstrinfo->priwt;
    Secwt = (pcompstrinfo->secwt&0xE4) | (Secwt&0x1B); /* merge minus some bits */
	SecFlg = pcompstrinfo->secflg;

AllDone:	/* we have the full 50-on sorting values now */

    /* mask off any bits that we want to ignore during this compare */
    if (g_dwFlags & ~NORM_IGNORESYMBOLS)
    {
    	//Special kludges to make some pairs of full-pitch chars that
    	//sort as different chars both convert to the same half-pitch char
    	if (g_dwFlags & NORM_IGNOREWIDTH)
    	{
    	    if (SecFlg==0x22 && (Secwt&0x40))
        		Secwt = 0x04;
    	    if (Priwt==0x3500)
        		Priwt = 0x4400;
    	}
    	for (pbMasks=pbIgnore; *pbMasks; pbMasks+=4)
    	{
    	    unsigned int nIgnore;
    	    
     	    nIgnore = (pbMasks[2] << 8) + pbMasks[3];
    	    if( (g_dwFlags & nIgnore) && (SecFlg&pbMasks[1]) )
    	    {
        		Secwt &= ~pbMasks[0];
        		SecFlg &= ~pbMasks[1];
    	    }
    	}
    }

    pcompstrinfo->priwt    = Priwt;
    pcompstrinfo->secwt    = Secwt;
    pcompstrinfo->secflg   = SecFlg;
    *plpstr1 = lpstr1;
    return(cch1);
}

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\btree\btkey.cpp ===
/*****************************************************************************
 *                                                                            *
 *  BTKEY.C                                                                   *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1989 - 1994.                          *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  Functions to deal with (i.e. size, compare) keys of all types.            *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  BinhN                                                     *
 *                                                                            *
 *****************************************************************************/

/*****************************************************************************
 *
 *  Revision History:  Created 05/11/89 by JohnSc
 *
 *  08/21/90  JohnSc autodocified
 *   3/05/97     erinfox Change errors to HRESULTS
 *
 *****************************************************************************/

static char s_aszModule[] = __FILE__;	/* For error report */

#include <mvopsys.h>
#include <orkin.h>
#include <iterror.h>
#include <string.h>
#include <misc.h>
#include <wrapstor.h>
#include <mvdbcs.h>
#include <mvsearch.h>
#include "common.h"
#include <_mvutil.h>




// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// When ligature tables are implemented again, take this out !!!!!!!!!!
//#define NOCHARTABLES_FIXME

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!




/*****************************************************************************
 *                                                                            *
 *                               Macros                                       *
 *                                                                            *
 *****************************************************************************/


#define StCopy(st1, st2)        (ST)QVCOPY((st1), (st2), (LONG)*(st2))

#define CbLenSt(st)             ((WORD)*(st))


/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	SHORT PASCAL FAR | WCmpKey |
 *		Compare two keys.
 *
 *	@parm	KEY | key1 |
 *		the UNCOMPRESSED keys to compare
 *
 *	@parm	KEY | key2 |
 *		the UNCOMPRESSED keys to compare
 *
 *	@parm	QBTHR | qbthr |
 *		qbthr->bth.rgchFormat[0]  - key type
 *		[qbthr->???               - other info ???]
 *
 *	@rdesc	-1 if key1 < key2; 0 if key1 == key2; 1 if key1 > key2
 *		args OUT:   [if comparing compressed keys, change state in qbthr->???]
 *
 *	@comm	Might be best to have this routine assume keys are expanded
 *		and do something else to compare keys in the scan routines.
 *		We're assuming fixed length keys are SZs.  Alternative
 *		would be to use a memcmp() function.
 *
 ***************************************************************************/

PUBLIC SHORT PASCAL FAR WCmpKey(KEY key1, KEY key2, QBTHR qbthr)
{
	SHORT   w;
	LONG	l;
	KT    kt = (KT)qbthr->bth.rgchFormat[ 0 ];
	LONG  l1, l2;


	switch (kt) {

#ifdef FULL_BTREE // {
		case KT_VSTI:
		{
			SZ sz1, sz2;

			WORD wl1,wl2;
			BYTE far *qbLigatures = NULL;
			wl1=(WORD)FoFromSz((SZ)key1).dwOffset;

			sz1 = (SZ)key1;
			ADVANCE_FO(sz1);
			key1 = (KEY)sz1;

			wl2=(WORD)FoFromSz((SZ)key2).dwOffset;

			sz2 = (SZ)key2;
			ADVANCE_FO(sz2);
			key2 = (KEY)sz2;

			if (qbthr->lrglpCharTab)
				qbLigatures=(BYTE FAR *)((LPCHARTAB)*qbthr->lrglpCharTab)->lpLigature;
			w=WCmpiSnn((SZ)key1, (SZ)key2, qbLigatures , wl1, wl2);
			break;
		}
		case KT_SZDEL:      // assume keys have been expanded for delta codeds
		case KT_SZDELMIN:
		case KT_SZ:

		case KT_SZMIN:
		case '1': case '2': case '3': case '4': case '5': // assume null term
		case '6': case '7': case '8': case '9': case 'a':
		case 'b': case 'c': case 'd': case 'e': case 'f':
			w = STRCMP((char *)key1, (char *)key2);
			break;

		case KT_SZI:
			w = WCmpiSz((SZ)key1, (SZ)key2,
			    (BYTE FAR *)((LPCHARTAB)*qbthr->lrglpCharTab)->lpLigature);
			break;

		case KT_SZISCAND:
			w = WCmpiScandSz((SZ)key1, (SZ)key2);
			break;

		case KT_SZMAP:

#ifdef NOCHARTABLES_FIXME
		w=STRCMP((SZ)key1, (SZ)key2);
#else
		if (PRIMARYLANGID(LANGIDFROMLCID(qbthr->bth.lcid)) == LANG_JAPANESE)
			w = StringJCompare (0L, (SZ)key1, STRLEN((char *)key1),
				(SZ)key2, STRLEN((char *)key2));
		else
			w = StrFntMappedLigatureComp((SZ)key1, (SZ)key2,
				qbthr->lrglpCharTab);

#endif
			break;
#endif // }

		case KT_EXTSORT:
			if (qbthr->pITSortKey == NULL ||
				FAILED(qbthr->pITSortKey->Compare((LPCVOID) key1,
												  (LPCVOID) key2,
													&l, NULL)))
			{
				l = 0;
				ITASSERT(FALSE);
			}

			// Reduce the long -/0/+ result to a word -/0/+.
			w = (SHORT) ((LOWORD(l) & 0x7fff) | ((LOWORD(l) >> 1) & 0x7fff) | HIWORD(l));
			break;

#ifdef FULL_BTREE // {
		case KT_ST:
		case KT_STMIN:
		case KT_STDEL:
		case KT_STDELMIN:
			w = WCmpSt((ST)key1, (ST)key2);
			break;
#endif // }

		case KT_LONG:
			l1 = *(LONG FAR *)key1;
			l2 = *(LONG FAR *)key2;
			if (l1 < l2)
			  w = -1;
			else if (l2 < l1)
			  w = 1;
			else
			  w = 0;
			break;
		}

	return w;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	SHORT PASCAL FAR | CbSizeKey |
 *		Return the key size (compressed or un-) in bytes 
 *
 *	@parm	KEY | key 
 *	@parm	QBTHR | qbthr
 *	@parm	BOOL | fCompressed |
 *		 TRUE to get the compressed size,
 *		FALSE to get the uncompressed size.
 *
 *	@rdesc	size of the key in bytes
 *
 *	@comm	It's impossible to tell how much suffix was discarded for
 *		the KT_*MIN key types.
 *
 ***************************************************************************/

PUBLIC SHORT PASCAL CbSizeKey(KEY key, QBTHR qbthr, BOOL  fCompressed)
{
	SHORT cb;
	DWORD dwKeySize;

	KT  kt = (KT)qbthr->bth.rgchFormat[ 0 ];


	switch(kt) {
#ifdef FULL_BTREE // {
		case KT_SZ:
		case KT_SZMIN:
		case KT_SZI:
		case KT_SZISCAND:
		case KT_SZMAP:
			cb = STRLEN((char *)key) + 1;
			break;

		case KT_VSTI:
		 	cb = (SHORT)LenSzFo((LPBYTE)key) + (SHORT)FoFromSz((LPBYTE)key).dwOffset;
			break;
		
		case KT_SZDEL:
		case KT_SZDELMIN:
			if (fCompressed)
				cb = 1 + STRLEN((char *)key + 1) + 1;
			else 
				cb = *(QB)key + STRLEN((char *)key + 1) + 1;
			break;

		case KT_ST:
		case KT_STMIN:
		case KT_STI:
			cb = CbLenSt((ST)key) + 1/* ? */;
			break;

		case KT_STDEL:
		case KT_STDELMIN:
			if (fCompressed) 
				cb = 1 + CbLenSt((ST)key + 1);
			else
				cb = *(QB)key + CbLenSt((ST)key + 1) + 1;
			break;
#endif // }
		case KT_EXTSORT:
			if (qbthr->pITSortKey == NULL ||
				FAILED(qbthr->pITSortKey->GetSize((LPCVOID) key, &dwKeySize)))
			{
				dwKeySize = 0;
				ITASSERT(FALSE);
			}

			// Key size can't exceed 32K - 1.  Such a key never should have been
			// allowed in to begin with.  We'll assert for the debug version.
			// We'll use 32K - 1 for the size for now, but there's a pretty
			// good chance a GP fault will occur if the sort object
			// ever has to visit parts of the key at 32K and beyond!
			if (dwKeySize <= 0x7fff)
				cb = (SHORT) dwKeySize;
			else
			{
				cb = 0x7fff;
				ITASSERT(FALSE);
			}
			break;

		case KT_LONG:
			cb = sizeof(LONG);
			break;

		case '1': case '2': case '3': case '4': case '5':
		case '6': case '7': case '8': case '9':
			cb = kt - '0';
			break;
			
		case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
			cb = kt - 'a' + 10;
			break;
	}

	return cb;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	BOOL FAR PASCAL | FIsPrefix |
 *		Determines whether string key1 is a prefix of key2.
 *
 *	@parm	HBT | hbt |
 *		handle to a btree with string keys
 *
 *	@parm	KEY | key1 |
 *		Uncompressed key
 *
 *	@parm	KEY | key2 |
 *		Uncompressed key
 *
 *	@rdesc	TRUE if the string key1 is a prefix of the string key2
 *		FALSE if it isn't or if hbt doesn't contain string keys
 *
 *	@comm	Bugs: Doesn't work on STs yet
 *
 *		Method: temporarily shortens the second string so it can
 *		compare prefixes
 *
 ***************************************************************************/

PUBLIC BOOL FAR PASCAL FIsPrefix(HBT hbt, KEY key1, KEY key2)
{
	QBTHR qbthr;
	KT    kt;
	BOOL  f;
    ERRB  errb;
	HRESULT	hr;

#ifdef FULL_BTREE 
	SHORT   cb1, cb2;
	unsigned char c;
#endif


	if ((qbthr = (QBTHR) _GLOBALLOCK(hbt)) == NULL) 
	{
	    SetErrCode (&errb, E_INVALIDARG);
        return(FALSE);
	}
	assert(qbthr != NULL);

	kt = (KT)qbthr->bth.rgchFormat[ 0 ];

	switch(kt) {
#ifdef FULL_BTREE // {
		case KT_SZ:
		case KT_SZMIN:
		case KT_SZI:
		case KT_SZISCAND:
		case KT_SZDEL:
		case KT_SZDELMIN:
		case KT_SZMAP:
			/* both keys assumed to have been decompressed */
			cb1 = STRLEN((char *)key1);
			cb2 = STRLEN((char *)key2);
			break;

		case KT_ST:
		case KT_STMIN:
		case KT_STI:
		case KT_STDEL:
		case KT_STDELMIN:
			/* STs unimplemented */
			SetErrCode (&errb, E_NOTSUPPORTED);
			_GLOBALUNLOCK(hbt);
			return FALSE;
			break;
#endif // }
		case KT_EXTSORT:
			if (qbthr->pITSortKey == NULL ||
				FAILED(hr = qbthr->pITSortKey->IsRelated((LPCVOID) key1,
														 (LPCVOID) key2,
									(DWORD) IITSK_KEYRELATION_PREFIX, NULL)))
			{
				ITASSERT(FALSE);
				f = FALSE;
			}
			else
				f = (GetScode(hr) == S_OK);

			_GLOBALUNLOCK(hbt);
			return (f);
			break;

		case KT_LONG:
		case '1': case '2': case '3': case '4': case '5':
		case '6': case '7': case '8': case '9':
		case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
		default:
			/* prefix doesn't make sense */
			SetErrCode (&errb, E_NOTSUPPORTED);
			_GLOBALUNLOCK(hbt);
			return FALSE;
			break;
	}
#ifdef FULL_BTREE // {

	// The length check and truncation method works as long as
	// ligatures aren't involved.  We won't worry about this for
	// IT 4.0 because the CharTab KTs won't be used.
	if (cb1 > cb2) {
		_GLOBALUNLOCK(hbt);
		return FALSE;
	}

	// Truncate longer string (key2).
	c = ((SZ)key2)[ cb1 ];
	((SZ)key2)[ cb1 ] = '\0';

	switch (kt)
	{
		case KT_SZ:
		case KT_SZMIN:
		case KT_SZDEL:
		case KT_SZDELMIN:
			f = STRCMP((char *)key1, (char *)key2) <=0;
			break;

		case KT_SZI:
			f = WCmpiSz((SZ)key1, (SZ)key2,
			    (BYTE FAR *) (*((LPCHARTAB FAR *)qbthr->lrglpCharTab))->lpLigature) <= 0;
			break;

		case KT_SZISCAND:
			f = WCmpiScandSz((SZ)key1, (SZ)key2) <= 0;
			break;

		case KT_SZMAP:

#ifdef NOCHARTABLES_FIXME
			
			f=(STRCMP((SZ)key1, (SZ)key2) <= 0);
#else
	        if (PRIMARYLANGID(LANGIDFROMLCID(qbthr->bth.lcid)) == LANG_JAPANESE)
    			f = (StringJCompare (0L, (SZ)key1, STRLEN((char *)key1),
    			    (SZ)key2, STRLEN((char *)key2)) <= 0);
	        else
    			f = (StrFntMappedLigatureComp((SZ)key1,
    				(SZ)key2, qbthr->lrglpCharTab) <= 0);

#endif
			break;
		default:
			assert(FALSE);
			break;
	}

	// Restore the longer string.
	((SZ)key2)[ cb1 ] = c;

	_GLOBALUNLOCK(hbt);
	return f;
#endif // }
}

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\btree\btktlong.c ===
/*****************************************************************************
 *                                                                            *
 *  BTKTLONG.C                                                                *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1989 - 1994.                          *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  Functions for LONG keys.                                                  *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  BinhN                                                     *
 *                                                                            *
 *****************************************************************************/

static char s_aszModule[] = __FILE__;   /* For error report */

#include <mvopsys.h>
#include <orkin.h>
#include <iterror.h>
#include <misc.h>
#include <wrapstor.h>
#include <_mvutil.h>


/***************************************************************************
 *
 *      @doc    INTERNAL
 *
 *      @func   BK FAR PASCAL | BkScanLInternal |
 *              Scan an internal node for a LONG key and return child BK.
 *
 *      @parm   BK | bk |
 *              BK of internal node to scan
 *
 *      @parm   KEY | key |
 *              key to search for
 *
 *      @parm   SHORT | wLevel |
 *              level of btree bk lives on
 *
 *      @parm   QBTHR | qbthr |
 *              btree header containing cache, and btree specs
 *
 *      @rdesc  bk of subtree that might contain key; bkNil on error
 *              args OUT:   qbthr->qCache - bk's block will be cached
 *
 *              Side Effects:   bk's block will be cached
 *
 *      @comm   Method: Should use binary search.  Doesn't, yet.
 *
 ***************************************************************************/

PUBLIC BK FAR PASCAL BkScanLInternal(BK bk, KEY key, SHORT wLevel,
	QBTHR qbthr, QW  qiKey, PHRESULT phr)
{
	QCB qcb;
	QB  q;
	SHORT cKeys;
	LONG dwKeyVal;
	
	dwKeyVal = *(LONG FAR *)key;

	if ((qcb = QFromBk(bk, wLevel, qbthr, phr)) == NULL)
	{
		return bkNil;
	}
	q     = qcb->db.rgbBlock;
	cKeys = qcb->db.cKeys;
	bk    = SWAPLONG(*(LPUL)q);
	q    += sizeof(BK);

	while (cKeys-- > 0)
	{

		if (dwKeyVal >= (LONG) SWAPLONG(*(LPUL)q))
		{
			q += sizeof(LONG);
			bk = SWAPLONG(*(LPUL)q);
			q += sizeof(BK);
		}
		else
			break;
	}

	if (qiKey != NULL)
	{
		*qiKey = (WORD)(q - (QB)qcb->db.rgbBlock);
	}

	return bk;
}

/***************************************************************************
 *
 *      @doc    INTERNAL
 *
 *      @func   HRESULT FAR PASCAL | RcScanLLeaf |
 *              Scan a leaf node for a key and copy the associated data.
 *
 *      @parm   BK | bk |
 *              the leaf block
 *
 *      @parm   KEY | key |
 *              the key we're looking for
 *
 *      @parm   SHORT | wLevel |
 *              the level of leaves (unnecessary)
 *
 *      @parm   QBTHR | qbthr |
 *              the btree header
 *
 *      @rdesc  ERR_SUCCESS if found; ERR_NOTEXIST if not found
 *              args OUT:   qRec  - if found, record gets copied into this buffer
 *              qbtpos - pos of first key >= key goes here
 *
 *      @comm   If we are scanning for a key greater than any key in this
 *              block, the pos returned will be invalid and will point just
 *              past the last valid key in this block.
 *
 *              Method: Should use binary search if fixed record size.  Doesn't, yet.
 *
 ***************************************************************************/

PUBLIC HRESULT FAR PASCAL RcScanLLeaf(BK bk, KEY key, SHORT wLevel,
	QBTHR qbthr, QV qRec, QBTPOS qbtpos)
{
	QCB   qcb;
	QB    qb;
	SHORT   cKey;
	HRESULT    rc;
	LONG  dwKeyVal;
    HRESULT  errb;
	
	dwKeyVal = *(LONG FAR *)key;
	
	
	if ((qcb = QFromBk(bk, wLevel, qbthr, &errb)) == NULL)
	{
		return (errb);
	}

	rc = E_NOTEXIST;

	qb  = qcb->db.rgbBlock + 2 * sizeof(BK);

	for (cKey = 0; cKey < qcb->db.cKeys; cKey++)
	{
		LONG dwVal = (LONG)GETLONG ((LPUL)qb);
		if (dwKeyVal > dwVal)
		{
			// still looking for key
			qb += sizeof(LONG);
			qb += CbSizeRec(qb, qbthr);
		}
		else if (dwKeyVal < dwVal)
		{
			// key not found
			break;
		}
		else
		{
			// matched the key
			if (qRec != NULL)
			{
				qb += sizeof(LONG);
				QVCOPY(qRec, qb, (LONG)CbSizeRec(qb, qbthr));
			}

			rc = S_OK;
			break;
		}
	}

	if (qbtpos != NULL)
	{
		qbtpos->bk = bk;
		qbtpos->iKey = (WORD)(qb - (QB)qcb->db.rgbBlock);
		qbtpos->cKey = cKey;
	}

	return rc;
}


/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\btree\btktext.cpp ===
/*****************************************************************************
 *                                                                            *
 *  BTKTEXT.C                                                                 *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1997.								  *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  Functions for external sort keys.									      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  BillA                                                     *
 *                                                                            *
 *****************************************************************************/

static char s_aszModule[] = __FILE__;  /* For error report */

#include <mvopsys.h>

#ifdef _MAC
#include <winnls.h>
#endif

#include <orkin.h>
#include <string.h>
#include <misc.h>
#include <iterror.h>
#include <itsort.h>
#include <wrapstor.h>
#include <mvdbcs.h>
#include <mvsearch.h>
#include <_mvutil.h>
#include "common.h"



 
 
/***************************************************************************
 *
 * @doc  INTERNAL
 * 
 * @func BK FAR PASCAL | BkScanExtSortInternal |
 *    Scan an internal node for an external sort key and return child BK.
 *
 * @parm BK | bk |
 *    BK of internal node to scan
 *
 * @parm KEY | key |
 *    key to search for
 *
 * @parm SHORT | wLevel |
 *    level of btree bk lives on
 *
 * @parm QBTHR | qbthr |
 *    btree header containing cache, and btree specs
 *
 * @parm QW | qiKey |
 *    address of an int or NULL to not get it
 *
 * @rdesc   bk of subtree that might contain key; bkNil on error
 *    args OUT:   qbthr->qCache - bk's block will be cached
 *    qiKey       - index into rgbBlock of first key >= key
 *
 *    Side Effects:   bk's block will be cached
 *
 ***************************************************************************/

PUBLIC BK FAR PASCAL BkScanExtSortInternal(BK bk, KEY key, SHORT wLevel,
   QBTHR qbthr, QW qiKey, LPVOID lpv)
{
    QCB qcb;                // Pointer to cache block
    QB  qb;                 // Pointer to block buffer
    SHORT cKeys;            // Number of keys in the block

    if ((qcb = QFromBk(bk, wLevel, qbthr, (PHRESULT) lpv)) == NULL)
    {
        return bkNil;
    }

    qb    = qcb->db.rgbBlock;  // Block buffer
    cKeys = qcb->db.cKeys;     // Number of keys in the block

    bk = (BK)GETLONG(qb);           // Get leaf block number 
    qb += sizeof(DWORD);

    while (cKeys-- > 0)
    {
		LONG	lResult;

		// NOTE (billa): This won't work on the Mac unless a method is added
		// to IITSortKey to swap dwords and words if necessary.  Mikkya
		// made an explicit decision to omit this from the initial
		// version of IITSortKey (6/4/97).
		if (qbthr->pITSortKey == NULL ||
			FAILED(qbthr->pITSortKey->Compare((LPCVOID) key, (LPCVOID) qb,
															&lResult, NULL)))
		{
			return bkNil;
		}

        if (lResult >= 0)
        {
			DWORD	cbKey;

			if (qbthr->pITSortKey == NULL ||
				FAILED(qbthr->pITSortKey->GetSize((LPCVOID) qb, &cbKey)))
			{
				return bkNil;
			}

            qb += cbKey;
            bk = (BK)GETLONG(qb);
            qb += sizeof(DWORD);
        }
        else
            break;
    }

    if (qiKey != NULL)
    {
        *qiKey = (WORD)(qb - (QB)qcb->db.rgbBlock);
    }

    return bk;
}

/***************************************************************************
 *
 * @doc  INTERNAL
 *
 * @func HRESULT FAR PASCAL | RcScanExtSortLeaf |
 *    Scan a leaf node for an external sort key and copy the associated data.
 *
 * @parm BK | bk |
 *    the leaf block
 *
 * @parm KEY | key |
 *    the key we're looking for
 *
 * @parm SHORT | wLevel |
 *    the level of leaves (unnecessary)
 *
 * @parm QBTHR | qbthr |
 *    the btree header
 *
 * @parm QV | qRec |
 *    if found, record gets copied into this buffer
 *
 * @parm QTPOS | qbtpos |
 *    pos of first key >= key goes here
 *
 * @rdesc   ERR_SUCESS if found; ERR_NOTEXIST if not found
 *    If we are scanning for a key greater than any key in this
 *    block, the pos returned will be invalid and will point just
 *    past the last valid key in this block.
 *
 ***************************************************************************/

PUBLIC HRESULT FAR PASCAL RcScanExtSortLeaf(BK bk, KEY key, SHORT wLevel,
   QBTHR qbthr, QV qRec, QBTPOS qbtpos)
{
    QCB   qcb;
    QB	  qb;
    HRESULT    rc;
    SHORT i;
    SHORT cKeys;      // Number of keys in the block
    QB    qbSaved = NULL;
    DWORD   cbLength, cbLengthSaved = 0;
    HRESULT  errb;


    if ((qcb = QFromBk(bk, wLevel, qbthr, &errb)) == NULL)
    {
        return errb;
    }

    rc = E_NOTEXIST;

    qb = qcb->db.rgbBlock + 2 * sizeof(BK);
    cKeys = qcb->db.cKeys; 
    
    for (i= 0; i < cKeys; i++)
    {
		LONG	lResult;

		// NOTE (billa): This won't work on the Mac unless a method is added
		// to IITSortKey to swap dwords and words if necessary.  Mikkya
		// made an explicit decision to omit this from the initial
		// version of IITSortKey (6/4/97).
		if (qbthr->pITSortKey == NULL ||
			FAILED(qbthr->pITSortKey->GetSize((LPCVOID) qb, &cbLength)) ||
			FAILED(qbthr->pITSortKey->Compare((LPCVOID) key, (LPCVOID) qb,
															&lResult, NULL)))
		{
			return rc;
		}

         
	    if (lResult > 0) /* still looking for key */
	    {
	       qb += cbLength;
	       qb += CbSizeRec(qb, qbthr);
	    }
	    else if (lResult < 0) /* key not found */
	    {
	        break;
	    }
	    else /* matched the key */
	    {
	        if (qRec != NULL)
			{
				qb += cbLength;
	            QVCOPY(qRec, qb, (LONG)CbSizeRec(qb, qbthr));
			}

	        rc = S_OK;
	        break;
	    }
	}

	if (qbtpos != NULL)
	{
	    qbtpos->bk   = bk;
	    qbtpos->cKey = i;
	    qbtpos->iKey = (int)(qb - (QB)qcb->db.rgbBlock);
	}

   return rc;
}



PUBLIC VOID EXPORT_API PASCAL FAR BtreeSetExtSort(HBT hbt,
												  IITSortKey *pITSortKey)
{
    if (hbt != NULL && pITSortKey != NULL)
	{
		QBTHR qbthr;

		qbthr = (QBTHR) _GLOBALLOCK(hbt);

		if (qbthr->pITSortKey != NULL)
			qbthr->pITSortKey->Release();

		(qbthr->pITSortKey = pITSortKey)->AddRef();

		_GLOBALUNLOCK(hbt);
	}
	else
	{
		ITASSERT(FALSE);
	}
}


PUBLIC VOID EXPORT_API PASCAL FAR BtreeGetExtSort(HBT hbt,
												  IITSortKey **ppITSortKey)
{
	if (ppITSortKey != NULL)
	{
		// Set to NULL in case we can't set it properly because the hbt is NULL.
		*ppITSortKey = NULL;

		if (hbt != NULL)
		{
		    QBTHR qbthr;

			qbthr = (QBTHR) _GLOBALLOCK(hbt);

			if ((*ppITSortKey = qbthr->pITSortKey) != NULL)
				(*ppITSortKey)->AddRef();

			_GLOBALUNLOCK(hbt);
		}
		else
		{
			ITASSERT(FALSE);
		}
	}
	else
	{
		ITASSERT(FALSE);
	}
}


/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\btree\btktsz.c ===
/*****************************************************************************
 *                                                                            *
 *  BTKTSZ.C                                                                  *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1990 - 1994.                          *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  Functions for SZ (0-terminated string) keys.                              *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  BinhN                                                     *
 *                                                                            *
 *****************************************************************************/

static char s_aszModule[] = __FILE__;	/* For error report */

#include <mvopsys.h>
#include <orkin.h>
#include <misc.h>
#include <iterror.h>
#include <string.h>
#include <wrapstor.h>
#include <_mvutil.h>


/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	BK FAR PASCAL | BkScanSzInternal |
 *		Scan an internal node for a key and return child BK.
 *
 *	@parm	BK | bk |
 *		BK of internal node to scan
 *
 *	@parm	KEY | key |
 *		key to search for
 *
 *	@parm	SHORT | wLevel |
 *		level of btree bk lives on
 *
 *	@parm	QBTHR | qbthr |
 *		btree header containing cache, and btree specs
 *
 *	@parm	QW | qiKey |
 *		address of an int or NULL to not get it
 *
 *	@rdesc	bk of subtree that might contain key; bkNil on error
 *		args OUT:   qbthr->qCache - bk's block will be cached
 *		qiKey       - index into rgbBlock of first key >= key
 *
 *		Side Effects:   bk's block will be cached
 *
 ***************************************************************************/

PUBLIC BK FAR PASCAL BkScanSzInternal(BK bk, KEY key, SHORT wLevel,
	QBTHR qbthr, QW qiKey, PHRESULT phr)
{
	QCB qcb;
	QB  q;
	SHORT cKeys;
	
	if ((qcb = QFromBk(bk, wLevel, qbthr, phr)) == NULL)
		return bkNil;

	q     = qcb->db.rgbBlock;
	cKeys = qcb->db.cKeys;
	
	
	bk = (BK)GETLONG(q);
	q += sizeof(BK);

	while (cKeys-- > 0)
	{
		if (STRCMP((SZ)key, (SZ)q) >= 0)
		{
			q += lstrlen((SZ)q) + 1;
			bk = (BK)GETLONG(q);
			q += sizeof(BK);
		}
		else
			break;
	}

	if (qiKey != NULL)
		*qiKey = (WORD)(q - (QB)qcb->db.rgbBlock);

	return bk;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HRESULT FAR PASCAL | RcScanSzLeaf |
 *		Scan a leaf node for a key and copy the associated data.
 *
 *	@parm	BK | bk |
 *		the leaf block
 *
 *	@parm	KEY | key |
 *		the key we're looking for
 *
 *	@parm	SHORT | wLevel |
 *		the level of leaves (unnecessary)
 *
 *	@parm	QBTHR | qbthr |
 *		the btree header
 *
 *	@parm	QV | qRec |
 *		if found, record gets copied into this buffer
 *
 *	@parm	QTPOS | qbtpos |
 *		pos of first key >= key goes here
 *
 *	@rdesc	ERR_SUCCESS if found; ERR_NOEXIST if not found
 *		If we are scanning for a key greater than any key in this
 *		block, the pos returned will be invalid and will point just
 *		past the last valid key in this block.
 *
 ***************************************************************************/

PUBLIC HRESULT FAR PASCAL RcScanSzLeaf(BK bk, KEY key, SHORT wLevel,
	QBTHR qbthr, QV qRec, QBTPOS qbtpos)
{
	QCB   qcb;
	SZ    sz;
	int   w;
	SHORT cKey;
	QB    qb;
	HRESULT    rc;
    HRESULT  errb;
	

	if ((qcb = QFromBk(bk, wLevel, qbthr, &errb)) == NULL)
		return errb;
	
	rc = E_NOTEXIST;

	sz = qcb->db.rgbBlock + 2 * sizeof(BK);

	for (cKey = 0; cKey < qcb->db.cKeys; cKey++)
	{
		w = STRCMP((SZ)key, sz);

		if (w > 0) /* still looking for key */
		{
			sz += STRLEN(sz) + 1;
			sz += CbSizeRec(sz, qbthr);
		}
		else if (w < 0) /* key not found */
			break;
		else /* matched the key */
		{
			if (qRec != NULL)
			{
			    qb = (QB)sz + STRLEN(sz) + 1;
			    QVCOPY(qRec, qb, (LONG)CbSizeRec(qb, qbthr));
			}

			rc = S_OK;
			break;
		}
	}

	if (qbtpos != NULL)
	{
		qbtpos->bk   = bk;
		qbtpos->cKey = cKey;
		qbtpos->iKey = (int)((QB)sz - (QB)qcb->db.rgbBlock);
	}

	return rc;;
}

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\btree\btktszis.c ===
/******************************************************************************
 *                                                                            *
 *  BTKTSZIS.C                                                                *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1989 - 1994.                          *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  Functions for SZISCAND (0-terminated case insensitive Scandinavian        *
 *  string keys.                                                              *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  BinhN                                                     *
 *                                                                            *
 ******************************************************************************/

static char s_aszModule[] = __FILE__;	/* For error report */

#include <mvopsys.h>
#include <misc.h>
#include <iterror.h>
#include <orkin.h>
#include <wrapstor.h>
#include <_mvutil.h>


/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	BK FAR PASCAL | BkScanSziScandInternal |
 *		Scan an internal node for a key and return child BK.
 *
 *	@parm	BK | bk |
 *		BK of internal node to scan
 *
 *	@parm	KEY | key |
 *		key to search for
 *
 *	@parm	SHORT | wLevel |
 *		level of btree bk lives on
 *
 *	@parm	QBTHR | qbthr |
 *		btree header containing cache, and btree specs
 *		qbthr->qCache  bk's block will be cached
 *
 *	@parm	QW | qiKey |
 *		address of an int or NULL to not get it
 *
 *	@rdesc	bk of subtree that might contain key; bkNil on error
 *		qiKey         - index into rgbBlock of first key >= key
 *		Side Effects:   bk's block will be cached
 *
 ***************************************************************************/

PUBLIC BK FAR PASCAL BkScanSziScandInternal(BK bk, KEY key, SHORT wLevel,
	QBTHR qbthr, QW qiKey, PHRESULT phr)
{
	QCB qcb;
	QB  q;
	SHORT cKeys;

	if ((qcb = QFromBk(bk, wLevel, qbthr, phr)) == NULL)
	{
		return bkNil;
	}
	q     = qcb->db.rgbBlock;
	cKeys = qcb->db.cKeys;
	
	
	bk = (BK)GETLONG(q);
	q += sizeof(BK);

	while (cKeys-- > 0)
	{
		if (WCmpiScandSz((SZ)key, (SZ)q) >= 0)
		{
			q += STRLEN((SZ)q) + 1;
			bk = (BK)GETLONG(q);
			q += sizeof(BK);
		}
		else
			break;
	}

	if (qiKey != NULL)
	{
		*qiKey = (WORD)(q - (QB)qcb->db.rgbBlock);
	}

	return bk;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HRESULT FAR PASCAL | RcScanSziScandLeaf |
 *		Scan a leaf node for a key and copy the associated data.
 *
 *	@parm	BK | bk |
 *		the leaf block
 *
 *	@parm	KEY | key |
 *		the key we're looking for
 *
 *	@parm	SHORT | wLevel |
 *		the level of leaves (unnecessary)
 *
 *	@parm	QBTHR | qbthr |
 *		the btree header
 *
 *	@parm	QV | qRec |
 *		if found, record gets copied into this buffer
 *
 *	@parm	QTPOS | qbtpos |
 *		pos of first key >= key goes here
 *
 *	@rdesc	ERR_SUCCESS if found; ERR_NOTEXIST if not found
 *		NOTE: If we are scanning for a key greater than any key in this
 *		block, the pos returned will be invalid and will point just
 *		past the last valid key in this block.
 *
 *
 ***************************************************************************/
PUBLIC HRESULT FAR PASCAL RcScanSziScandLeaf(BK bk, KEY  key,
	SHORT wLevel, QBTHR qbthr, QV qRec, QBTPOS qbtpos)
{
	QCB   qcb;
	SZ    sz;
	SHORT   w, cKey;
	QB    qb;
	HRESULT    rc;
    HRESULT  errb;
	

	if ((qcb = QFromBk(bk, wLevel, qbthr, &errb)) == NULL)
	{
		return errb;
	}
	
	rc = E_NOTEXIST;

	sz = qcb->db.rgbBlock + 2 * sizeof(BK);

	for (cKey = 0; cKey < qcb->db.cKeys; cKey++)
	{
		w = WCmpiScandSz((SZ)key, sz);

		if (w > 0) /* still looking for key */
		{
			sz += STRLEN(sz) + 1;
			sz += CbSizeRec(sz, qbthr);
		}
		else if (w < 0) /* key not found */
		{
			break;
		}
		else /* matched the key */
		{
			if (qRec != NULL)
			{
				qb = (QB)sz + STRLEN(sz) + 1;
				QVCOPY(qRec, qb, (LONG)CbSizeRec(qb, qbthr));
			}

			rc = S_OK;
			break;
		}
	}

	if (qbtpos != NULL)
	{
		qbtpos->bk   = bk;
		qbtpos->cKey = cKey;
		qbtpos->iKey = (int)((QB)sz - (QB)qcb->db.rgbBlock);
	}

	return rc;
}

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\btree\btktszi.c ===
/*****************************************************************************
 *                                                                            *
 *  BTKTSZI.C                                                                 *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1989 - 1994.                          *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  Functions for SZI (0-terminated case insensitive string) keys.            *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  UNDONE                                                    *
 *                                                                            *
 *****************************************************************************/

static char s_aszModule[] = __FILE__;	/* For error report */

#include <mvopsys.h>
#include <orkin.h>
#include <misc.h>
#include <iterror.h>
#include <wrapstor.h>
#include <mvsearch.h>
#include <_mvutil.h>
#include "common.h"


/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	BK FAR PASCAL | BkScanSziInternal |
 *		Scan an internal node for a key and return child BK.
 *
 *	@parm	BK | bk |
 *		BK of internal node to scan
 *
 *	@parm	KEY | key |
 *		key to search for
 *
 *	@parm	SHORT | wLevel |
 *		level of btree bk lives on
 *
 *	@parm	QBTHR | qbthr |
 *		btree header containing cache, and btree specs
 *
 *	@parm	QW | qiKey |
 *		address of an int or NULL to not get it
 *
 *	@parm	QBTHR | qbthr |
 *		qbthr->qCache - bk's block will be cached
 *
 *	@parm	QW | qiKey |
 *		index into rgbBlock of first key >= key
 *
 *	@rdesc	bk of subtree that might contain key; bkNil on error
 *		Side Effects:   bk's block will be cached
 *
 ***************************************************************************/

PUBLIC BK FAR PASCAL BkScanSziInternal(BK bk, KEY key, SHORT wLevel,
	QBTHR qbthr, QW qiKey, PHRESULT phr)
{
	QCB qcb;
	QB  q;
	SHORT cKeys;
    LPB   lpLigatureTable;

	
	if ((qcb = QFromBk(bk, wLevel, qbthr, phr)) == NULL)
	{
		return bkNil;
	}
	q     = qcb->db.rgbBlock;
	cKeys = qcb->db.cKeys;
	
	
	bk = (BK)GETLONG(q);
	q += sizeof(BK);
    lpLigatureTable =  (LPB)(((LPCHARTAB)*qbthr->lrglpCharTab)->lpLigature);

	while (cKeys-- > 0)
	{
		if (WCmpiSz((SZ)key, (SZ)q, lpLigatureTable) >= 0)
		{
			q += STRLEN((SZ)q) + 1;
			bk = GETLONG(q);
			q += sizeof(BK);
		}
		else
			break;
	}

	if (qiKey != NULL)
	{
		*qiKey = (WORD)(q - (QB)qcb->db.rgbBlock);
	}

	return bk;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HRESULT FAR PASCAL | RcScanSziLeaf |
 *		Scan a leaf node for a key and copy the associated data.
 *
 *	@parm	BK | bk |
 *		the leaf block
 *
 *	@parm	KEY | key |
 *		the key we're looking for
 *
 *	@parm	SHORT | wLevel |
 *		the level of leaves (unnecessary)
 *
 *	@parm	QBTHR | qbthr |
 *		the btree header
 *
 *	@parm	QV | qRec |
 *		if found, record gets copied into this buffer
 *
 *	@parm	QTPOS | qbtpos |
 *		pos of first key >= key goes here
 *
 *	@rdesc	ERR_SUCCESS if found; ERR_NOTEXIST if not found
 *		If we are scanning for a key greater than any key in this
 *		block, the pos returned will be invalid and will point just
 *		past the last valid key in this block.
 *
 ***************************************************************************/

PUBLIC HRESULT FAR PASCAL RcScanSziLeaf( BK bk, KEY key, SHORT wLevel,
	QBTHR qbthr, QV qRec, QBTPOS qbtpos)
{
	QCB   qcb;
	SZ    sz;
	SHORT   w, cKey;
	QB    qb;
	HRESULT    rc;
    HRESULT  errb;
    LPB   lpLigatureTable;
	

	if ((qcb = QFromBk(bk, wLevel, qbthr, &errb)) == NULL) {
		return errb;
	}
	
	rc = E_NOTEXIST;

	sz = qcb->db.rgbBlock + 2 * sizeof(BK);
    lpLigatureTable =  (LPB)(((LPCHARTAB)*qbthr->lrglpCharTab)->lpLigature);

	for (cKey = 0; cKey < qcb->db.cKeys; cKey++)
	{
		w = WCmpiSz((SZ)key, sz, lpLigatureTable);

		if (w > 0) /* still looking for key */
		{
			sz += STRLEN(sz) + 1;
			sz += CbSizeRec(sz, qbthr);
		}
		else if (w < 0) /* key not found */
		{
			break;
		}
		else /* matched the key */
		{
			if (qRec != NULL)
			{
			  qb = (QB)sz + STRLEN(sz) + 1;
			  QVCOPY(qRec, qb, (LONG)CbSizeRec(qb, qbthr));
			}

			rc = S_OK;
			break;
		}
	}

	if (qbtpos != NULL)
	{
		qbtpos->bk   = bk;
		qbtpos->cKey = cKey;
		qbtpos->iKey = (int)((QB)sz - (QB)qcb->db.rgbBlock);
	}

	return rc;
}

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\btree\btmapwr.c ===
/*****************************************************************************
 *                                                                            *
 *  BTMAPWR.C                                                                 *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1989 - 1994.                          *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  Routines to write btree map files.                                        *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  UNDONE                                                    *
 *                                                                            *
 *****************************************************************************/

/*****************************************************************************
 *
 *  Revision History:  Created 10/20/89 by KevynCT
 *
 *  08/21/90  JohnSc autodocified
 *   3/05/97     erinfox Change errors to HRESULTS
 *
 *****************************************************************************/

static char s_aszModule[] = __FILE__;	/* For error report */

#include <mvopsys.h>
#include <orkin.h>
#include <iterror.h>
#include <misc.h>
#include <wrapstor.h>
#include <_mvutil.h>


/*----------------------------------------------------------------------------*
 | Private functions                                                          |
 *----------------------------------------------------------------------------*/

/***************************************************************************
 *
- Function:     HmapbtCreateHbt(hbt)
-
 * Purpose:      Create a HMAPBT index struct of a btree.
 *
 * ASSUMES
 *   args IN:    hbt - the btree to map
 *
 * PROMISES
 *   returns:    the map struct
 * +++
 *
 * Method:       Traverse leaf nodes of the btree.  Store BK and running
 *               total count of previous keys in the map array.
 *
 ***************************************************************************/
HMAPBT HmapbtCreateHbt(HBT hbt, PHRESULT phr)
{

	QBTHR     qbthr;
	BK        bk;
	QCB       qcb;
	WORD      wLevel, cBk;
	LONG      cKeys;
	QMAPBT    qb;
	QMAPREC   qbT;
	HANDLE    gh;

	if ((qbthr = _GLOBALLOCK(hbt)) == NULL)
	{
	    SetErrCode (phr, E_INVALIDARG);
        return(NULL);
	}
    
	/*   If the btree exists but is empty, return an empty map   */
	if((wLevel = qbthr->bth.cLevels) == 0)
	{
		gh =  _GLOBALALLOC(GMEM_ZEROINIT|GMEM_SHARE| GMEM_MOVEABLE,
		    LcbFromBk(0));
		qb = (QMAPBT) _GLOBALLOCK(gh);
		qb->cTotalBk = 0;
		_GLOBALUNLOCK(gh);
		_GLOBALUNLOCK(hbt);
		return gh;
	}
	--wLevel;

	if (qbthr->ghCache == NULL && RcMakeCache( qbthr) != S_OK )
	{
exit0:
		_GLOBALUNLOCK(hbt);
		return NULL;
	}

	qbthr->qCache = _GLOBALLOCK(qbthr->ghCache);

	if ((gh =  _GLOBALALLOC(GMEM_ZEROINIT|GMEM_SHARE| GMEM_MOVEABLE,
	    LcbFromBk(qbthr->bth.bkEOF))) == NULL)
	{
exit1:
        _GLOBALUNLOCK (qbthr->ghCache);
        goto exit0;
	}

	qb    = (QMAPBT) _GLOBALLOCK(gh);

	qbT   = qb->table;
	cBk   = 0;
	cKeys = 0;


	for (bk = qbthr->bth.bkFirst ; ; bk = BkNext( qcb))
	{
		if (bk == bkNil)
			break;

		if ((qcb = QFromBk( bk, wLevel, qbthr, phr)) == NULL )
		{
			_GLOBALUNLOCK(gh);
			_GLOBALFREE(gh);
			goto exit1;
		}

		cBk++;
		qbT->cPreviousKeys = cKeys;
		qbT->bk = bk;
		qbT++;
		cKeys += qcb->db.cKeys;
	}

	qb->cTotalBk = cBk;
	_GLOBALUNLOCK(gh);

	if ((gh = _GLOBALREALLOC(gh, LcbFromBk( cBk), 0)) == NULL)
    {
        SetErrCode (phr, E_OUTOFMEMORY);
        _GLOBALFREE(gh);
        goto exit1;
    }    

	_GLOBALUNLOCK(hbt);
	return gh;
}

void DestroyHmapbt(HMAPBT hmapbt)
{
	if(hmapbt != NULL)
		_GLOBALFREE(hmapbt);
}

/*--------------------------------------------------------------------------*
 | Public functions                                                         |
 *--------------------------------------------------------------------------*/


/***************************************************************************
 *
- Function:     RcCreateBTMapHfs(hfs, hbt, szName)
-
 * Purpose:      Create and store a btmap index of the btree hbt, putting
 *               it into a file called szName in the file system hfs.
 *
 * ASSUMES
 *   args IN:    hfs     - file system where lies the btree
 *               hbt     - handle of btree to map
 *               szName  - name of file to store map file in
 *
 * PROMISES
 *   returns:    rc
 *   args OUT:   hfs - map file is stored in this file system
 *
 ***************************************************************************/
PUBLIC HRESULT PASCAL FAR RcCreateBTMapHfs(HFS hfs, HBT hbt, LPSTR szName)
{

	HF      hf;
	HMAPBT  hmapbt;
	QMAPBT  qmapbt;
	BOOL    fSuccess;
	LONG    lcb;
    HRESULT    errb;

	if((hfs == NULL) || (hbt == NULL))
		return (E_INVALIDARG);
		
	if ((hmapbt = HmapbtCreateHbt(hbt, &errb)) == NULL)
		return (errb);

	if ((hf = HfCreateFileHfs(hfs, szName, fFSOpenReadWrite, &errb)) == hfNil)
	{
exit0:
    	DestroyHmapbt(hmapbt);
        return(errb);
	}
	
	qmapbt = (QMAPBT) _GLOBALLOCK(hmapbt);

	lcb = LcbFromBk(qmapbt->cTotalBk);
	FoSeekHf(hf, foNil, wFSSeekSet, &errb);
	fSuccess = (LcbWriteHf(hf, (QV)qmapbt, lcb, &errb) == lcb);

	_GLOBALUNLOCK(hmapbt);
	if(!fSuccess)
	{
		RcAbandonHf(hf);
		goto exit0;
    }
    
	if((fSuccess = RcCloseHf (hf)) != S_OK )
	{
		RcUnlinkFileHfs(hfs, szName);
		SetErrCode (&errb, (HRESULT) fSuccess);
		goto exit0;
	}
	DestroyHmapbt(hmapbt);
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\btree\btktvsti.c ===
/*****************************************************************************
 *                                                                            *
 *  BTKTVSTI.C                                                                 *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1989 - 1994.                          *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  Functions for VSTI (Variable length previxed pascal strings               *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  davej                                                     *
 *                                                                            *
 ******************************************************************************

 Format for a key & record is:
 
 KEY:

 Key Length		[Variable 1 or 2]
 Key String		[<Length> chars]

 RECORD:

 File Offset	[Variable 3, 4, 5, or 6]
 File Length	[Variable 1, 2, 3, 4, or 5]
 File Flags		1

static char s_aszModule[] = __FILE__;	/* For error report */

#include <mvopsys.h>
#include <orkin.h>
#include <misc.h>
#include <iterror.h>
#include <wrapstor.h>
#include <mvsearch.h>
#include <_mvutil.h>
#include "common.h"


/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	BK FAR PASCAL | BkScanVstiInternal |
 *		Scan an internal node for a key and return child BK.
 *
 *	@parm	BK | bk |
 *		BK of internal node to scan
 *
 *	@parm	KEY | key |
 *		key to search for
 *
 *	@parm	SHORT | wLevel |
 *		level of btree bk lives on
 *
 *	@parm	QBTHR | qbthr |
 *		btree header containing cache, and btree specs
 *
 *	@parm	QW | qiKey |
 *		address of an int or NULL to not get it
 *
 *	@parm	QBTHR | qbthr |
 *		qbthr->qCache - bk's block will be cached
 *
 *	@parm	QW | qiKey |
 *		index into rgbBlock of first key >= key
 *
 *	@rdesc	bk of subtree that might contain key; bkNil on error
 *		Side Effects:   bk's block will be cached
 *
 ***************************************************************************/

PUBLIC BK FAR PASCAL BkScanVstiInternal(BK bk, KEY key, SHORT wLevel,
	QBTHR qbthr, QW qiKey, PHRESULT phr)
{
	QCB qcb;
	QB  q;
	SHORT cKeys;
    LPB   lpLigatureTable;
	WORD 	wStringLen;
	WORD	wStringLenComp;
	WORD	wLongLen;
	FILEOFFSET fo;
	
	fo=FoFromSz((LPBYTE)key);
	wStringLen=(WORD)fo.dwOffset;

	ADVANCE_FO((LPBYTE)key);
	
	if ((qcb = QFromBk(bk, wLevel, qbthr, phr)) == NULL)
	{
		return bkNil;
	}
	q     = qcb->db.rgbBlock;
	cKeys = qcb->db.cKeys;
	
	
	bk = (BK)GETLONG(q);
	q += sizeof(BK);

	lpLigatureTable =  (!qbthr->lrglpCharTab)?NULL:(LPB)(((LPCHARTAB)*qbthr->lrglpCharTab)->lpLigature);

	while (cKeys-- > 0)
	{
		fo=FoFromSz((LPBYTE)q);
		wStringLenComp=(WORD)fo.dwOffset;
		wLongLen=LenSzFo((LPBYTE)q);			// Length of variable length 'long'
	
    	if (WCmpiSnn((SZ)key, (SZ)(q+wLongLen), lpLigatureTable,wStringLen, wStringLenComp) >= 0)
		{
			q += wStringLenComp + wLongLen;
			bk = (BK)GETLONG(q);
			q += sizeof(BK);
		}
		else
			break;
	}

	if (qiKey != NULL)
	{
		*qiKey = (WORD)(q - (QB)qcb->db.rgbBlock);
	}

	return bk;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HRESULT FAR PASCAL | RcScanVstiLeaf |
 *		Scan a leaf node for a key and copy the associated data.
 *
 *	@parm	BK | bk |
 *		the leaf block
 *
 *	@parm	KEY | key |
 *		the key we're looking for
 *
 *	@parm	SHORT | wLevel |
 *		the level of leaves (unnecessary)
 *
 *	@parm	QBTHR | qbthr |
 *		the btree header
 *
 *	@parm	QV | qRec |
 *		if found, record gets copied into this buffer
 *
 *	@parm	QTPOS | qbtpos |
 *		pos of first key >= key goes here
 *
 *	@rdesc	ERR_SUCCESS if found; ERR_NOTEXIST if not found
 *		If we are scanning for a key greater than any key in this
 *		block, the pos returned will be invalid and will point just
 *		past the last valid key in this block.
 *
 ***************************************************************************/

PUBLIC HRESULT FAR PASCAL RcScanVstiLeaf( BK bk, KEY key, SHORT wLevel,
	QBTHR qbthr, QV qRec, QBTPOS qbtpos)
{
	QCB   qcb;
	SZ    sz;
	SHORT   w, cKey;
	QB    qb;
	HRESULT    rc;
    HRESULT  errb;
    LPB   lpLigatureTable;
	WORD 	wStringLen;
	WORD	wStringLenComp;
	WORD	wLongLen;
	
	if ((qcb = QFromBk(bk, wLevel, qbthr, &errb)) == NULL) {
		return errb;
	}
	
	wStringLen=(WORD)FoFromSz((LPBYTE)key).dwOffset;
	ADVANCE_FO((LPBYTE)key);
	
	rc = E_NOTEXIST;

	sz = qcb->db.rgbBlock + 2 * sizeof(BK);
    lpLigatureTable =  (!qbthr->lrglpCharTab)?NULL:(LPB)(((LPCHARTAB)*qbthr->lrglpCharTab)->lpLigature);


	for (cKey = 0; cKey < qcb->db.cKeys; cKey++)
	{
		wStringLenComp=(WORD)FoFromSz((LPBYTE)sz).dwOffset;
		wLongLen=LenSzFo((LPBYTE)sz);			// Length of variable length 'long'

		w = WCmpiSnn((SZ)key, sz+wLongLen, lpLigatureTable, wStringLen, wStringLenComp);

		if (w > 0) /* still looking for key */
		{
			sz += wLongLen+wStringLenComp;
			sz += CbSizeRec(sz, qbthr);
		}
		else if (w < 0) /* key not found */
		{
			break;
		}
		else /* matched the key */
		{
			if (qRec != NULL)
			{
			  qb = (QB)sz + wLongLen + wStringLenComp;
			  QVCOPY(qRec, qb, (LONG)CbSizeRec(qb, qbthr));
			}

			rc = S_OK;
			break;
		}
	}

	if (qbtpos != NULL)
	{
		qbtpos->bk   = bk;
		qbtpos->cKey = cKey;
		qbtpos->iKey = (int)((QB)sz - (QB)qcb->db.rgbBlock);
	}

	return rc;
}

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\btree\btree.cpp ===
/*****************************************************************************
 *                                                                            *
 *  BTREE.C                                                                   *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1989 - 1994.                          *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  Btree manager general functions: open, close, etc.                        *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  BinhN                                                     *
 *                                                                            *
 *****************************************************************************/

/*****************************************************************************
 *
 *  Revision History:  Created 02/10/89 by JohnSc
 *
 *   2/10/89 johnsc   created: stub version
 *   3/10/89 johnsc   use FS files
 *   8/21/89 johnsc   autodocified
 *  11/08/90 JohnSc   added a parameter to RcGetBtreeInfo() to get block size
 *  11/29/90 RobertBu #ifdef'ed out a dead routine
 *  12/14/90 JohnSc   added VerifyHbt()
 *   3/05/97     erinfox Change errors to HRESULTS
 *
 *****************************************************************************/

static char s_aszModule[] = __FILE__;   /* For error report */

#include <mvopsys.h>
#include <string.h>
#include <orkin.h>
#include <misc.h>
#include <iterror.h>
#include <wrapstor.h>
#include <mvsearch.h>
#include <_mvutil.h>
#include "common.h"


/***************************************************************************
 *
- Function:     RcMakeCache(qbthr)
-
 * Purpose:      Allocate a btree cache with one block per level.
 *
 * ASSUMES
 *   args IN:    qbthr - no cache
 *
 * PROMISES
 *   returns:    S_OK, or errors
 *   args OUT:   qbthr->ghCache is allocated; qbthr->qCache is NULL
 *
 ***************************************************************************/
HRESULT PASCAL FAR RcMakeCache(QBTHR qbthr)
{
	SHORT i;

	/* Sanity check */
	if (qbthr == NULL)
		return (E_INVALIDARG); 
		
	/* Allocate the memory */
		
	if (qbthr->bth.cLevels > 0)
	{
	    // would it work to just alloc 0 bytes???
		qbthr->ghCache = _GLOBALALLOC(GMEM_ZEROINIT|GMEM_SHARE| GMEM_MOVEABLE,
		    (LONG)qbthr->bth.cLevels * CbCacheBlock(qbthr) );

	if (qbthr->ghCache == NULL)
		return (E_OUTOFMEMORY);

	qbthr->qCache = (QB) _GLOBALLOCK(qbthr->ghCache);

	/* Initialize the flags */

	for (i = 0; i < qbthr->bth.cLevels; i++)
		QCacheBlock(qbthr, i)->bFlags = (BYTE)0;

	_GLOBALUNLOCK(qbthr->ghCache);
    }
	else {
		qbthr->ghCache = NULL;
	}

	qbthr->qCache = NULL;

	return (S_OK);
}

/***************************************************************************
 *
 *                           Public Routines
 *
 ***************************************************************************/


/***************************************************************************
 *
- Function:     HbtCreateBtreeSz(sz, qbtp)
-
 * Purpose:      Create and open a btree.
 *
 * ASSUMES
 *   args IN:    sz    - name of the btree
 *               qbtp  - pointer to btree params: NO default because we
 *                       need an HFS.
 *                               The bFlags param contains HFILE_SYSTEM for the 
 *                                               system btree, but none of the btree code should
 *                                               care whether or not it is a system file.
 *
 * PROMISES
 *   returns:    handle to the new btree
 *
 * Note:         KT supported:  KT_SZ, KT_LONG, KT_SZI, KT_SZISCAND.
 * +++
 *
 * Method:       Btrees are files inside a FS.  The FS directory is a
 *               special file in the FS.
 *
 ***************************************************************************/
HBT FAR PASCAL HbtCreateBtreeSz(LPSTR sz,BTREE_PARAMS FAR *qbtp, PHRESULT phr)
{
	HF    hf;
	HBT   hbt;
	QBTHR qbthr;


	/* see if we support key type */

	if (qbtp == NULL ||
        (
#ifdef FULL_BTREE // {
            qbtp->rgchFormat[0] != KT_SZ
			    &&
            qbtp->rgchFormat[0] != KT_VSTI
			    &&
			qbtp->rgchFormat[0] != KT_SZI
			    &&
			qbtp->rgchFormat[0] != KT_SZMAP
			    &&
			qbtp->rgchFormat[0] != KT_SZISCAND
				&&
#endif // }
			qbtp->rgchFormat[0] != KT_LONG
			    &&
			qbtp->rgchFormat[0] != KT_EXTSORT) )
	{
		SetErrCode(phr, E_INVALIDARG);
		return NULL;
	}


	/* allocate btree handle struct */

	if (( hbt =  _GLOBALALLOC(GMEM_ZEROINIT|GMEM_SHARE| GMEM_MOVEABLE,
	    (LONG)sizeof( BTH_RAM) ) ) == NULL ) {
		SetErrCode(phr, E_OUTOFMEMORY);
		return NULL;
	}                                                                                                                                                                           

	qbthr = (QBTHR) _GLOBALLOCK(hbt);

	/* initialize bthr struct */

	qbtp->rgchFormat[ wMaxFormat ] = '\0';
	lstrcpy(qbthr->bth.rgchFormat, qbtp->rgchFormat[0] == '\0'
			      ? rgchBtreeFormatDefault : qbtp->rgchFormat);

	switch (qbtp->rgchFormat[ 0 ])
	{
#ifdef FULL_BTREE // {
		case KT_SZ:
			qbthr->BkScanInternal = BkScanSzInternal;
			qbthr->RcScanLeaf     = RcScanSzLeaf;
			break;

		case KT_VSTI:
			qbthr->BkScanInternal = BkScanVstiInternal;
			qbthr->RcScanLeaf     = RcScanVstiLeaf;
			break;

		case KT_SZI:
			qbthr->BkScanInternal = BkScanSziInternal;
			qbthr->RcScanLeaf     = RcScanSziLeaf;
			break;

		case KT_SZISCAND:
			qbthr->BkScanInternal = BkScanSziScandInternal;
			qbthr->RcScanLeaf     = RcScanSziScandLeaf;
			break;

		case KT_SZMAP:
			qbthr->BkScanInternal = BkScanCMapInternal ;
			qbthr->RcScanLeaf     = RcScanCMapLeaf; 
			break;
#endif // }
		case KT_LONG:
			qbthr->BkScanInternal = BkScanLInternal;
			qbthr->RcScanLeaf     = RcScanLLeaf;
			break;

		case KT_EXTSORT:
			qbthr->BkScanInternal = BkScanExtSortInternal ;
			qbthr->RcScanLeaf     = RcScanExtSortLeaf; 
			break;

		default:
			/* unsupported KT */
			SetErrCode(phr, E_INVALIDARG);
			goto error_return;
			break;
	}

	/* create the btree file */

	if (!FHfValid(hf = HfCreateFileHfs(qbtp->hfs, sz, qbtp->bFlags, phr)))
	{
		goto error_return;
	}

	
	qbthr->bth.wMagic     = wBtreeMagic;
	qbthr->bth.bVersion   = bBtreeVersion;

	qbthr->bth.bFlags     = qbtp->bFlags | fFSDirty;
	qbthr->bth.cbBlock    = qbtp->cbBlock ? qbtp->cbBlock : cbBtreeBlockDefault;

	qbthr->bth.bkFirst    =
	qbthr->bth.bkLast     =
	qbthr->bth.bkRoot     =
	qbthr->bth.bkFree     = bkNil;
	qbthr->bth.bkEOF      = (BK)0;

	qbthr->bth.cLevels    = 0;
	qbthr->bth.lcEntries  = (LONG)0;

	qbthr->bth.dwCodePageID			= qbtp->dwCodePageID;
	qbthr->bth.lcid					= qbtp->lcid;
	qbthr->bth.dwExtSortInstID		= qbtp->dwExtSortInstID;
	qbthr->bth.dwExtSortKeyType		= qbtp->dwExtSortKeyType;

	qbthr->hf             = hf;
	qbthr->cbRecordSize   = 0;
	qbthr->ghCache        = NULL;
	qbthr->qCache         = NULL;
	qbthr->lrglpCharTab   = NULL;
	qbthr->pITSortKey	  = NULL;

	LcbWriteHf(qbthr->hf, &(qbthr->bth), (LONG)sizeof(BTH), phr ); /* why??? */

	_GLOBALUNLOCK(hbt);
	return hbt;

error_return:
	_GLOBALUNLOCK(hbt);
	_GLOBALFREE(hbt);
	return NULL;
}

/***************************************************************************
 *
- Function:     RcDestroyBtreeSz(sz, hfs)
-
 * Purpose:      destroy an existing btree
 *
 * Method:       look for file and unlink it
 *
 * ASSUMES
 *   args IN:    sz - name of btree file
 *               hfs - file system btree lives in
 *   state IN:   btree is closed (if not data will be lost)
 *
 * PROMISES
 *   returns:    S_OK or errors
 *
 * Notes:        FS directory btree never gets destroyed: you just get rid
 *               of the whole fs.
 *
 ***************************************************************************/
HRESULT FAR PASCAL RcDestroyBtreeSz(LPSTR sz, HFS hfs)
{
	return (RcUnlinkFileHfs(hfs, sz));
}

/***************************************************************************
 *
 * Function:     HbtOpenBtreeSz(sz, hfs, bFlags)
 *
 * Purpose:      open an existing btree
 *
 * ASSUMES
 *   args IN:    sz        - name of the btree (ignored if isdir is set)
 *               hfs       - hfs btree lives in
 *               bFlags    - open mode, isdir flag
 *	 args OUT:
 *				 phr       - error code
 *
 * PROMISES
 *   returns:    handle to the open btree or NULL on failure
 *               isdir flag set in qbthr->bth.bFlags if indicated
 *
 ***************************************************************************/
HBT FAR PASCAL HbtOpenBtreeSz(LPWSTR sz, HFS hfs, BYTE bFlags, PHRESULT phr)
{
	HF              hf;
	QBTHR   qbthr;
	HBT         hbt;
	LONG    lcb;
    HRESULT      rc;


	/* allocate struct */

	if ((hbt =  _GLOBALALLOC(GMEM_ZEROINIT|GMEM_SHARE| GMEM_MOVEABLE,
	    (LONG)sizeof(BTH_RAM))) == NULL)
	{
		SetErrCode(phr, E_OUTOFMEMORY);
		return NULL;
	}
	qbthr = (QBTHR) _GLOBALLOCK(hbt);

	/* open btree file */

	if (!FHfValid(hf = HfOpenHfs(hfs, sz, bFlags, phr)))
	{
exit0:
		_GLOBALUNLOCK (hbt);
		_GLOBALFREE(hbt);

		return 0;
	}

	/* read header from file */

	lcb = LcbReadHf(hf, &(qbthr->bth), (LONG)sizeof( BTH), phr);

	/* MAC swapping stuffs */

    if (qbthr->bth.wMagic == SWAPWORD(wBtreeMagic))
    {
	    qbthr->bth.wMagic = SWAPWORD(qbthr->bth.wMagic);
	    qbthr->bth.cbBlock = SWAPWORD(qbthr->bth.cbBlock);
	    qbthr->bth.bkFirst = SWAPLONG(qbthr->bth.bkFirst);
	    qbthr->bth.bkLast = SWAPLONG(qbthr->bth.bkLast);
	    qbthr->bth.bkRoot = SWAPLONG(qbthr->bth.bkRoot);
	    qbthr->bth.bkFree = SWAPLONG(qbthr->bth.bkFree);
	    qbthr->bth.bkEOF = SWAPLONG(qbthr->bth.bkEOF);
	    qbthr->bth.cLevels = SWAPWORD(qbthr->bth.cLevels);
	    qbthr->bth.lcEntries = SWAPLONG(qbthr->bth.lcEntries);
		qbthr->bth.dwCodePageID = SWAPLONG(qbthr->bth.dwCodePageID);
		qbthr->bth.lcid = SWAPLONG(qbthr->bth.lcid);
		qbthr->bth.dwExtSortInstID = SWAPLONG(qbthr->bth.dwExtSortInstID);
		qbthr->bth.dwExtSortKeyType = SWAPLONG(qbthr->bth.dwExtSortKeyType);
     }

	if (lcb != (LONG)sizeof(BTH))
	{
exit1:
		RcCloseHf(hf);
		goto exit0;
	}

	if (qbthr->bth.wMagic != wBtreeMagic)
	{
	     // check magic number
		SetErrCode(phr, E_FILEINVALID);
		goto exit1;
	}

	if (qbthr->bth.bVersion != bBtreeVersion)
	{
	    // support >1 vers someday
		SetErrCode(phr, E_BADVERSION);
		goto exit1;
	}

	/* initialize stuff */

	if ((rc = RcMakeCache(qbthr)) != S_OK)
	{
	    SetErrCode (phr, rc);
		goto exit1;
	}

	qbthr->hf = hf;
	qbthr->cbRecordSize = 0;

	switch (qbthr->bth.rgchFormat[0])
	{
#ifdef FULL_BTREE // {
		case KT_SZ:
			qbthr->BkScanInternal = BkScanSzInternal;
			qbthr->RcScanLeaf                = RcScanSzLeaf;
			break;

		case KT_SZI:
			qbthr->BkScanInternal = BkScanSziInternal;
			qbthr->RcScanLeaf                = RcScanSziLeaf;
			break;
		
		case KT_VSTI:
			qbthr->BkScanInternal = BkScanVstiInternal;
			qbthr->RcScanLeaf     = RcScanVstiLeaf;
			break;

		case KT_SZISCAND:
			qbthr->BkScanInternal = BkScanSziScandInternal;
			qbthr->RcScanLeaf                = RcScanSziScandLeaf;
			break;

		case KT_SZMAP:
			qbthr->BkScanInternal = BkScanCMapInternal ;
			qbthr->RcScanLeaf     = RcScanCMapLeaf; 
			break;
#endif // }
		case KT_LONG:
			qbthr->BkScanInternal = BkScanLInternal;
			qbthr->RcScanLeaf     = RcScanLLeaf;
			break;

		case KT_EXTSORT:
			qbthr->BkScanInternal = BkScanExtSortInternal ;
			qbthr->RcScanLeaf     = RcScanExtSortLeaf; 
			break;

		default: // unsupported KT
			SetErrCode(phr, E_INVALIDARG);
			goto exit1;
			break;
	}

	assert(! ( qbthr->bth.bFlags & ( fFSDirty) ) );

	if ((bFlags | qbthr->bth.bFlags) & ( fFSReadOnly | fFSOpenReadOnly ))
	{
		qbthr->bth.bFlags |= fFSOpenReadOnly;
	}

	_GLOBALUNLOCK(hbt);
	return hbt;
}


/***************************************************************************
 *
 * Function:     GetBtreeParams(hbt, qbtp)
 *
 * Purpose:      open an existing btree
 *
 * ASSUMES
 *   args IN:    hbt       - handle to btree info
 *	 args OUT:
 *               qbtp	   - Btree params (key type info, etc.).  All members
 *							 of the structure are set EXCEPT for the hfs.
 *
 * PROMISES
 *   returns:    nothing
 *
 ***************************************************************************/
VOID FAR PASCAL GetBtreeParams(HBT hbt, BTREE_PARAMS FAR *qbtp)
{
	if (hbt != NULL && qbtp != NULL)
	{
	    QBTHR qbthr;

		qbthr = (QBTHR) _GLOBALLOCK(hbt);

		// Copy btree info to BTREE_PARMS.
		qbtp->cbBlock = qbthr->bth.cbBlock;
		qbtp->dwCodePageID = qbthr->bth.dwCodePageID;
		qbtp->lcid = qbthr->bth.lcid;
		qbtp->dwExtSortInstID = qbthr->bth.dwExtSortInstID;
		qbtp->dwExtSortKeyType = qbthr->bth.dwExtSortKeyType;
		qbtp->bFlags = qbthr->bth.bFlags;
		lstrcpy(qbtp->rgchFormat, qbthr->bth.rgchFormat);

		_GLOBALUNLOCK(hbt);
	}
	else
	{
		ITASSERT(FALSE);
	}
}


/***************************************************************************
 *
- Function:        RcCloseOrFlushHbt(hbt, fClose)
-
 * Purpose:      Close or flush the btree.  Flush only works for directory
 *               btree. (Is this true?  If so, why?)
 *
 * ASSUMES
 *   args IN:    hbt
 *               fClose - TRUE to close the btree, FALSE to flush it
 *
 * PROMISES
 *   returns:    rc
 *   args OUT:   hbt - the btree is still open and cache still exists
 *
 * NOTE:         This function gets called by RcCloseOrFlushHfs() even if
 *               there was an error (just to clean up memory.)
 *
 ***************************************************************************/
HRESULT FAR PASCAL RcCloseOrFlushHbt(HBT hbt, BOOL fClose)
{
	QBTHR qbthr;
	HF    hf;
	int fRet;
	HANDLE hnd;
    HRESULT   errb;


	if (hbt == 0)
		return (E_INVALIDARG);

	qbthr = (QBTHR) _GLOBALLOCK(hbt);
	fRet = S_OK;
	hf = qbthr->hf;

	if (qbthr->ghCache != NULL)
	{
		qbthr->qCache = (QB) _GLOBALLOCK(qbthr->ghCache);
	}

	fRet = S_OK;

	if (qbthr->bth.bFlags & fFSDirty)
	{
		assert(!( qbthr->bth.bFlags & ( fFSReadOnly | fFSOpenReadOnly) ) );

		if (qbthr->ghCache != NULL &&
		    (fRet = RcFlushCache(qbthr)) != S_OK)
		{
exit0:
			/* Close/flush the B-tree */
			
			// Previously
			//if ((fRet = RcCloseOrFlushHf(hf, fClose,
			//      qbthr->bth.bFlags & fFSOptCdRom ? sizeof(BTH):0))!= S_OK) 

			if (fClose)
				fRet=RcCloseHf(hf);
			else
				fRet=RcFlushHf(hf);

			if ((fRet!=S_OK) || (fClose))
			/* Release the memory */
			{       if ((hnd = qbthr->ghCache) != NULL)
				{
					while ((GlobalFlags(hnd) & GMEM_LOCKCOUNT) > 0)
						_GLOBALUNLOCK(hnd);
					if (fClose)
					{
						_GLOBALFREE(hnd);
						qbthr->ghCache = 0;
					}
				}
			}
			else
			{
				if (qbthr->ghCache)
				{       _GLOBALUNLOCK(qbthr->ghCache);
					qbthr->qCache=NULL;
				}
			}

			// Before we free the BTHR, we need to release any sort object we're
			// holding onto.
			if (fClose && qbthr->pITSortKey != NULL)
			{
				qbthr->pITSortKey->Release();
				qbthr->pITSortKey = NULL;
			}

			_GLOBALUNLOCK(hbt);
			if (fClose)
				_GLOBALFREE(hbt);

			return fRet;
		}

		qbthr->bth.bFlags &= ~(fFSDirty);

		if (!FoEquals(FoSeekHf(hf, foNil, wFSSeekSet, &errb),foNil))
			goto exit0;

		LcbWriteHf(hf, &(qbthr->bth), (LONG)sizeof(BTH), &errb);
	}
	goto exit0;
}

/***************************************************************************
 *
- Function:              RcCloseBtreeHbt(hbt)
-
 * Purpose:      Close an open btree.  If it's been modified, save changes.
 *
 * ASSUMES
 *   args IN:    hbt
 *
 * PROMISES
 *   returns:    S_OK or error
 *
 ***************************************************************************/
HRESULT FAR PASCAL RcCloseBtreeHbt(HBT hbt)
{
	return RcCloseOrFlushHbt(hbt, TRUE);
}

#ifdef DEADROUTINE
/***************************************************************************
 *
- Function:     RcFlushHbt(hbt)
-
 * Purpose:      Write any btree changes to disk.
 *               Btree stays open, cache remains.
 *
 * ASSUMES
 *   args IN:    hbt
 *
 * PROMISES
 *   returns:    rc
 *
 ***************************************************************************/
HRESULT FAR PASCAL RcFlushHbt(HBT hbt)
{
	return RcCloseOrFlushHbt(hbt, FALSE);
}
#endif
/***************************************************************************
 *
- Function:     HRESULT RcFreeCacheHbt(hbt)
-
 * Purpose:      Free the btree cache.
 *
 * ASSUMES
 *   args IN:    hbt - ghCache is NULL or allocated; qCache not locked
 *
 * PROMISES
 *   returns:    S_OK or errors 
 *   args OUT:   hbt - ghCache is NULL; qCache is NULL
 *
 ***************************************************************************/
HRESULT FAR PASCAL RcFreeCacheHbt(HBT hbt)
{
	QBTHR qbthr;
	HRESULT    rc = S_OK;

	
	if (hbt == NULL)
	{
		return E_INVALIDARG;
	}
	qbthr = (QBTHR) _GLOBALLOCK(hbt);

	if (qbthr->ghCache != NULL) {
		qbthr->qCache = (QB) _GLOBALLOCK(qbthr->ghCache);
		rc = RcFlushCache(qbthr);
		_GLOBALUNLOCK(qbthr->ghCache);
		_GLOBALFREE(qbthr->ghCache);
		qbthr->ghCache = NULL;
		qbthr->qCache = NULL;
	}

	_GLOBALUNLOCK(hbt);
	return rc;
}
/***************************************************************************
 *
- Function:     RcGetBtreeInfo(hbt, qchFormat, qlcKeys)
-
 * Purpose:      Return btree info: format string and/or number of keys
 *
 * ASSUMES
 *   args IN:    hbt
 *               qchFormat - pointer to buffer for fmt string or NULL
 *               qlcKeys   - pointer to long for key count or NULL
 *               qcbBlock  - pointer to int for block size in bytes or NULL
 *
 * PROMISES
 *   returns:    rc
 *   args OUT:   qchFormat - btree format string copied here
 *               qlcKeys   - gets number of keys in btree
 *               qcbBlock  - gets number of bytes in a block
 *
 ***************************************************************************/
HRESULT FAR PASCAL RcGetBtreeInfo(HBT hbt, LPBYTE qchFormat,
    QL qlcKeys, QW qcbBlock)
{
	QBTHR qbthr;


	if ((qbthr = (QBTHR) _GLOBALLOCK(hbt)) == NULL)
	return(E_INVALIDARG);
	
	if (qchFormat != NULL)
		STRCPY ((char *) qchFormat, qbthr->bth.rgchFormat);

	if (qlcKeys != NULL)
		*(LPUL)qlcKeys = qbthr->bth.lcEntries;

	if (qcbBlock != NULL)
		*qcbBlock = qbthr->bth.cbBlock;

	_GLOBALUNLOCK(hbt);
	return S_OK;
}
/***************************************************************************
 *
- Function:     RcAbandonHbt(hbt)
-
 * Purpose:      Abandon an open btree.  All changes since btree was opened
 *               will be lost.  If btree was opened with a create, it is
 *               as if the create never happened.
 *
 * ASSUMES
 *   args IN:    hbt
 *
 * PROMISES
 *   returns:    rc
 * +++
 *
 * Method:       Just abandon the file and free memory.
 *
 ***************************************************************************/
PUBLIC HRESULT PASCAL FAR EXPORT_API RcAbandonHbt(HBT hbt)
{
	QBTHR qbthr;
	int fRet;

	/* Sanity check */
	if ((qbthr = (QBTHR) _GLOBALLOCK(hbt)) == NULL)
       return(E_INVALIDARG);
       

	if (qbthr->ghCache != NULL)
		_GLOBALFREE(qbthr->ghCache);

	fRet = RcAbandonHf(qbthr->hf);

	_GLOBALUNLOCK(hbt);
	_GLOBALFREE(hbt);

	return fRet;
}

#if 0
/*************************************************************************
 *      @doc    API
 *      
 *      @func   PASCAL FAR | DiskBtreeCreate |
 *              Given a pointer to the B-tree ofthe file system, the fucntion
 *              will copy it to a disk file.
 *
 *      @parm   QBTHR | qbt |
 *              Pointer to the B-tree structure
 *
 *      @parm   LPSTR | szFilename |
 *              Disk filename
 *
 *      @rdesc  S_OK if succeeded, else various Rc errors
 *
 *      @comm   The current assumption is that the whole B-tree is less
 *                      64K. It is assume that the whole structure will reside
 *                      in memory at runtime.
 *************************************************************************/
HRESULT EXPORT_API PASCAL FAR DiskBtreeCreate (QBTHR qbt, LPSTR szFilename)
{
#ifdef MOSMAP // {
	// Disable function
	return ERR_FAILED;
#else // } {
	DWORD  dwbtSize;                /* Total size of B-tree */
	WORD   wBlockSize;      /* Size of a B-tree block */
	int    fRet;                    /* Return error value */ 
	HANDLE hbtBuf;                  /* Handle to B-tree memory buffer */
	QB     qbtBuf;       /* pointer to B-tree memory buffer */ 
	int    hFile;                   /* temp file handle */
	
	/* Calculate the size of the B-tree buffer */
	wBlockSize = qbt->bth.cbBlock;
	dwbtSize = qbt->bth.bkEOF *  wBlockSize;
		
		if (dwbtSize >= 0xffff)
			return ERR_FAILED;
			
	/* Allocate a buffer to hold the data */
	if ((hbtBuf =  _GLOBALALLOC(GMEM_ZEROINIT|GMEM_SHARE | GMEM_MOVEABLE, dwbtSize)) == NULL) {
		return E_OUTOFMEMORY;
	}
		qbtBuf = (QB)_GLOBALLOCK (hbtBuf);
		
		/* We can read everything at once into memory. First seek to the
		 * correct position
		 */
	if (DwSeekHf(qbt->hf, (LONG)sizeof(BTH), wFSSeekSet) != sizeof(BTH)) {
		fRet = ERR_SEEK_FAILED;
exit0:
		_GLOBALUNLOCK (hbtBuf);
		_GLOBALFREE (hbtBuf);
		return fRet;
	}
		
	/* Read in the whole B-tree */
	if (LcbReadHf(qbt->hf, qbtBuf, dwbtSize) != (LONG)dwbtSize) {
			fRet = ERR_FAILED;
		goto exit0;
	}
	
	/* Open the disk file */
		if ((hFile = _lcreat (szFilename, 0)) == HFILE_ERROR) {
		fRet = ERR_FILECREAT_FAILED;
		goto exit0;
	}
		
		/* Write the B-tree file header. Set bFlags = !fCompressed */
		qbt->bth.bFlags = 0;
		if ((_lwrite (hFile, (QB)&qbt->bth, sizeof(BTH))) != sizeof(BTH)) {
			fRet = ERR_CANTWRITE;
exit1:
		_lclose (hFile);
		goto exit0;
		}
		
		/* Write the whole B-tree */
		if ((_lwrite (hFile, qbtBuf, (WORD)dwbtSize)) != (WORD)dwbtSize) {
			fRet = ERR_CANTWRITE;
			goto exit1;
		}       
	
	fRet = S_OK;
	goto exit0;
#endif //}
}
 
/*************************************************************************
 *      @doc    API
 *
 *      @func   HBT PASCAL FAR | DiskBtreeLoad |
 *              :Load a B-tree structure saved on disk into memroy
 *
 *      @parm   LPSTR | szFilename | 
 *              Disk filename
 *
 *      @rdesc  The function returns a handle to the B-tree in memory
 *                      if succeeded, 0 otherwise
 * 
 *      @comm   The current assumption is that the whole B-tree is less
 *                      64K. It is assume that the whole structure will reside
 *                      in memory at runtime.
 *************************************************************************/

HBT EXPORT_API PASCAL FAR DiskBtreeLoad (LPSTR szFilename)
{
	int    hFile;                   /* File handle */
	BTH    btHeader;                /* B-tree header */ 
	HANDLE hbt = 0;         /* Handle to B-tree structure */
	DWORD  dwbtSize;                /* Size of B-tree */
	QBTHR  qbt;                             /* Pointer to B-tree structure */
	HRESULT     fRet;                    /* Error return code */
	
	/* Open the file */
	if ((hFile = _lopen ((QB)szFilename, OF_READ)) == HFILE_ERROR) {
		SetErrCode (ERR_NOTEXIST);
		return NULL;
	}
	
	/* Read in the header */
	if ((_lread (hFile, (QB)&btHeader, sizeof (BTH))) != sizeof (BTH)) {
		fRet = ERR_CANTREAD;
exit0:
		SetErrCode (fRet);
		_lclose (hFile);
		return hbt;
	}

	/* MAC swapping stuffs */

	btHeader.wMagic = SWAPWORD(btHeader.wMagic);
	btHeader.cbBlock = SWAPWORD(btHeader.cbBlock);
	btHeader.bkFirst = SWAPLONG(btHeader.bkFirst);
	btHeader.bkLast = SWAPLONG(btHeader.bkLast);
	btHeader.bkRoot = SWAPLONG(btHeader.bkRoot);
	btHeader.bkFree = SWAPLONG(btHeader.bkFree);
	btHeader.bkEOF = SWAPLONG(btHeader.bkEOF);
	btHeader.lcEntries = SWAPLONG(btHeader.lcEntries);
	btHeader.dwCodePageID = SWAPLONG(btHeader.dwCodePageID);
	btHeader.lcid = SWAPLONG(btHeader.lcid);
	btHeader.dwExtSortInstID = SWAPLONG(btHeader.dwExtSortInstID);
	btHeader.dwExtSortKeyType =	SWAPLONG(btHeader.dwExtSortKeyType);

	/* Check for validity */
	if (btHeader.wMagic != wBtreeMagic) {     // check magic number
		fRet = ERR_INVALID;
		goto exit0;
		}

	if (btHeader.bVersion != bBtreeVersion)  {// Check version
		fRet = E_BADVERSION;
		goto exit0;
	}
	
	dwbtSize = btHeader.bkEOF *  btHeader.cbBlock;
	
	/* Currently we do not support a B-tree larger than 64K */
	
	if (dwbtSize >= 0xffff) {
		fRet = ERR_NOTSUPPORTED;
		goto exit0;
	}
	
	/* Allocate the block of memory for the B-tree */
	if ((hbt =  _GLOBALALLOC (GMEM_ZEROINIT | GMEM_SHARE | GMEM_MOVEABLE, sizeof (BTH_RAM) + dwbtSize)) == NULL) {
		fRet = E_OUTOFMEMORY;
		goto exit0;
	}
	
	qbt = (QBTHR)_GLOBALLOCK (hbt);
	
	/* Initialize the structure */
	qbt->bth = btHeader;
	qbt->ghCache = hbt;
	qbt->qCache = (QB)qbt + sizeof (BTH_RAM); 
	
	/* Read in the B-tree */
	if ((_lread (hFile, qbt->qCache, (WORD)dwbtSize)) != dwbtSize) {
		fRet = ERR_CANTREAD;
		_GLOBALUNLOCK (hbt);
		_GLOBALFREE (hbt);
		hbt = 0;
		goto exit0;
	}
	_GLOBALUNLOCK (hbt);
	fRet = S_OK;
	goto exit0; 
}

/*************************************************************************
 *      @doc    API
 *
 *      @func   VOID PASCAL FAR | DiskBtreeFree |
 *              Free the in-memroy B-tree
 *
 *      @parm   HBT | hbt | 
 *              Handle to the B-tree structure
 *
 *************************************************************************/
VOID EXPORT_API PASCAL FAR DiskBtreeFree (HBT hbt)
{
	if (hbt) {
		_GLOBALUNLOCK (hbt);
		_GLOBALFREE (hbt);
	}
}
#endif // if 0

#ifdef _DEBUG
/***************************************************************************
 *
- Function:     VerifyHbt(hbt)
-
 * Purpose:      Verify the consistency of an HBT.  The main criterion
 *               is whether an RcAbandonHbt() would succeed.
 *
 * ASSUMES
 *   args IN:    hbt
 *
 * PROMISES
 *   state OUT:  Asserts on failure.
 *
 * Note:         hbt == NULL is considered OK.
 * +++
 *
 * Method:       Check the qfshr and cache memory.  Check the HF.
 *
 ***************************************************************************/
PUBLIC VOID PASCAL FAR EXPORT_API VerifyHbt(HBT hbt)
{
	QBTHR qbthr;


	if (hbt == NULL) return;

	qbthr = (QBTHR) _GLOBALLOCK(hbt);
	assert(qbthr != NULL);

	VerifyHf(qbthr->hf);
	_GLOBALUNLOCK(hbt);
}
#endif // _DEBUG

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\btree\btlookup.c ===
/*****************************************************************************
 *                                                                            *
 *  BTLOOKUP.C                                                                *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1989 - 1994.                          *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *   Btree lookup and helper functions.                                       *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  UNDONE                                                    *
 *                                                                            *
 *****************************************************************************/

static char s_aszModule[] = __FILE__;   /* For error report */

#include <mvopsys.h>
#include <orkin.h>
#include <misc.h>
#include <iterror.h>
#include <wrapstor.h>
#include <_mvutil.h>


/***************************************************************************
 *
 *                      Private Functions
 *
 ***************************************************************************/

/***************************************************************************
 *
 *      @doc    INTERNAL
 *
 *      @func   SHORT PASCAL FAR | CbSizeRec |
 *              Get the size of a record.
 *
 *      @parm   QV | qRec |
 *              the record to be sized
 *
 *      @parm   QBTHR | qbthr |
 *              btree header containing record format string
 *
 *      @rdesc  size of the record in bytes
 *              If we've never computed the size before, we do so by looking
 *              at the record format string in the btree header.  If the
 *              record is fixed size, we store the size in the header for
 *              next time.  If it isn't fixed size, we have to look at the
 *              actual record to determine its size.
 *
 ***************************************************************************/

PUBLIC SHORT PASCAL FAR CbSizeRec(QV qRec, QBTHR qbthr)
{
	CHAR  ch;
	QCH   qchFormat = qbthr->bth.rgchFormat;
	SHORT   cb = 0;
	BOOL  fFixedSize;
	LPBYTE lpb;

	if (qbthr->cbRecordSize)
		return qbthr->cbRecordSize;

	fFixedSize = TRUE;

	for (qchFormat++; ch = *qchFormat; qchFormat++)
	{
		switch (ch)
		{
			case '0': case '1': case '2': case '3': case '4':
			case '5': case '6': case '7': case '8': case '9':
			  cb += ch - '0';
			  break;

			case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
			  cb += ch + 10 - 'a';
			  break;

			case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
			  cb += ch + 10 - 'A';
			  break;

			// Variable length File Offset value (minimum 3 bytes)
			case FMT_VNUM_FO:
			  lpb=((LPBYTE)qRec)+cb;
			  cb++;
			  while ((*(lpb++))&0x80)
				cb++;

			  fFixedSize = FALSE;
			  break;
			
			case FMT_BYTE_PREFIX:
			  cb += sizeof(BYTE) + *((QB)qRec + cb);
			  fFixedSize = FALSE;
			  break;

			case FMT_WORD_PREFIX:
			  cb += sizeof(SHORT) + *((QW)qRec + cb);
			  fFixedSize = FALSE;
			  break;

			case FMT_SZ:
			  cb += (SHORT) STRLEN((QB)qRec + cb) + 1;
			  fFixedSize = FALSE;
			  break;

			default:
			  /* error */
			  assert(FALSE);
			  break;
		}
	}

	if (fFixedSize)
	{
		qbthr->cbRecordSize = cb;
	}

	return cb;
}

/***************************************************************************
 *
 *      @doc    INTERNAL
 *
 *      @func   BOOL PASCAL FAR | FReadBlock |
 *              Read a block from the btree file into the cache block.
 *
 *      @parm   QCB | qcb |
 *              qcb->bk        - bk of block to read
 *              qcb->db     - receives block read in from file
 *              qcb->bFlags - fCacheValid flag set, all others cleared
 *
 *      @parm   QBTHR | qbthr |
 *              qbthr->cbBlock - size of disk block to read
 *
 *      @rdesc  S_OK or other errors
 *
 *              Notes: Doesn't know about real cache, just this block
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR FReadBlock(QCB qcb, QBTHR qbthr)
{
	LONG  l;
    HRESULT  errb;
	FILEOFFSET foSeek;

	if (qcb->bk >= qbthr->bth.bkEOF)
	{
		return E_ASSERT;
	}

	foSeek=FoFromBk(qcb->bk, qbthr);
	if (!FoEquals(FoSeekHf(qbthr->hf, foSeek, wFSSeekSet, &errb),foSeek))
	{
		return (E_FILESEEK);
	}

	l = qbthr->bth.cbBlock;
	errb = S_OK;
    
	if (LcbReadHf(qbthr->hf, &(qcb->db), (LONG)qbthr->bth.cbBlock,
	    &errb) != l)
	{
		if (errb == S_OK)
			return (E_FILEINVALID);		
		return errb;
	}
	qcb->bFlags = fCacheValid;
	qcb->db.cbSlack = SWAPWORD(qcb->db.cbSlack);
	qcb->db.cKeys = SWAPWORD(qcb->db.cKeys);

	return (S_OK);
}

/***************************************************************************
 *
 *      @doc    INTERNAL
 *
 *      @func   HRESULT PASCAL FAR | RcWriteBlock |
 *              Write a cached block to a file.
 *
 *      @parm   QCB | qcb |
 *              qcb->db the block to write
 *              qcb->bk bk of block to write
 *
 *      @parm   QBTHR | qbthr |
 *              qbthr->hf we write to this file
 *
 *      @rdesc  S_OK or other errors
 *              Side Effects: Fatal exit on read or seek failure.
 *
 *              Note: Don't reset dirty flag, because everyone who wants
 *              that done does it themselves. (?)
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR  RcWriteBlock(QCB qcb, QBTHR qbthr)
{
#ifdef MOSMAP // {
	// Disable function
	return ERR_NOTSUPPORTED;
#else // } {
    HRESULT errb;
    FILEOFFSET foSeek;
	
	if (qcb->bk >= qbthr->bth.bkEOF)
		return E_ASSERT;
	if ((qcb->db.cbSlack  > qbthr->bth.cbBlock) || (qcb->db.cbSlack<0))
		return E_ASSERT;
#if 0
	if (qcb->db.cKeys*8+qcb->db.cbSlack > qbthr->bth.cbBlock)
		return E_ASSERT;
#endif
	

	foSeek=FoFromBk(qcb->bk, qbthr);
    errb = S_OK;             
	if (!FoEquals(FoSeekHf(qbthr->hf, foSeek, wFSSeekSet, &errb),foSeek) )
	{
		return(errb);
	}

	LcbWriteHf(qbthr->hf, &(qcb->db), (LONG)qbthr->bth.cbBlock, &errb);
	
	return errb;
#endif //}
}

/***************************************************************************
 *
 *      @doc    INTERNAL
 *
 *      @func   QCB PASCAL FAR | QFromBk |
 *              Convert a BK into a pointer to a cache block.  Cache the
 *              block at the given level, if it isn't there already.
 *
 *      @parm   BK | bk |
 *              BK to convert
 *
 *      @parm   SHORT | wLevel |
 *              btree level
 *      @parm   QBTHR | qbthr |
 *              Ptr to B-tree struct. State in: btree cache is locked
 *
 *      @rdesc  pointer to the cache block, with all fields up to date
 *              or NULL on I/O error
 *              state OUT:  block will be in cache at specified level; cache locked
 *
 ***************************************************************************/

PUBLIC QCB PASCAL FAR QFromBk(BK bk, SHORT wLevel, QBTHR qbthr, PHRESULT phr)
{
	QCB  qcb;
    HRESULT   fRet;

	if (wLevel < 0 || wLevel >= qbthr->bth.cLevels || bk >= qbthr->bth.bkEOF)
	{
		SetErrCode (phr, E_ASSERT);
		return(NULL);
	}
	

	qcb = QCacheBlock(qbthr, wLevel);

	if (!(qcb->bFlags & fCacheValid) || bk != qcb->bk)
	{
		/* requested block is not cached */

		if ((qcb->bFlags & fCacheDirty) && (qcb->bFlags & fCacheValid))
		{
			if ((fRet = RcWriteBlock(qcb, qbthr)) != S_OK)
			{
			    SetErrCode (phr, fRet);
				return NULL;
			}
		}

		qcb->bk = bk;
		if ((fRet = FReadBlock(qcb, qbthr)) != S_OK)
		{
			SetErrCode (phr, fRet);
			return NULL;
		}                               
	}
	return qcb;
}


/***************************************************************************
 *
 *      @doc    INTERNAL
 *
 *      @func   HRESULT PASCAL FAR | RcFlushCache |
 *              Write out dirty cache blocks
 *
 *      @parm   QBTHR | qbthr |
 *              qCache is locked
 *
 *      @rdesc    rc
 *              state OUT:  btree file is up to date.  cache block dirty flags reset
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR RcFlushCache(QBTHR qbthr)
{
#ifdef MOSMAP // {
	// Disable function
	return ERR_SUCCESSS;
#else // } {
	SHORT   i;
	QB    qb;
	HRESULT    rc = S_OK;
    const SHORT iMax = qbthr->bth.cLevels;

    // We need to traverse this list in reverse order so the
    // nodes are actually written in numeric order
    qb = qbthr->qCache + CbCacheBlock(qbthr) * (iMax - 1);
	for (i = 0; i < iMax; i++, qb -= CbCacheBlock(qbthr))
	{

		if ((((QCB)qb)->bFlags & (fCacheDirty | fCacheValid)) ==
			(fCacheValid | fCacheDirty))
		{

			if ((rc = RcWriteBlock((QCB)qb, qbthr)) != S_OK)
				break;
			((QCB)qb)->bFlags &= ~fCacheDirty;
		}
	}

	return rc;
#endif //}
}

/***************************************************************************
 *
 *                      Public Functions
 *
 ***************************************************************************/

/***************************************************************************
 *
 *      @doc    INTERNAL
 *
 *      @func   HRESULT PASCAL FAR | RcLookupByKeyAux |
 *              Look up a key in a btree and retrieve the data.
 *              state IN:   cache is unlocked
 *
 *      @parm   HBT | hbt |
 *              btree handle
 *
 *      @parm   KEY | key |
 *              key we are looking up
 *
 *      @parm   QBTPOS | qbtpos |
 *              pointer to buffer for pos; use NULL if not wanted
 *
 *      @parm   QV | qData |
 *              pointer to buffer for record; NULL if not wanted
 *
 *      @parm   BOOL | fInsert |
 *              TRUE: if key would lie between two blocks, pos refers to proper
 *                      place to insert it
 *              FALSE: pos returned will be valid unless key > all keys in btree
 *
 *      @rdesc  S_OK if found, E_NOTEXIST if not found;
 *              other errors like ERR_MEMORY
 *              key found:
 *                      qbtpos  - btpos for this key
 *                      qData   - record for this key
 *
 *              key not found:
 *                      qbtpos  - btpos for first key > this key
 *                      qData   - record for first key > this key
 *
 *              key not found, no keys in btree > key:
 *                      qbtpos  - invalid (qbtpos->bk == bkNil)
 *                      qData   - undefined
 *      state OUT:  All ancestor blocks back to root are cached
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR RcLookupByKeyAux(HBT hbt, KEY key,
	QBTPOS qbtpos, QV qData, BOOL fInsert)
{
	QBTHR qbthr;
	SHORT   wLevel;
	BK    bk;
	HRESULT    rc;
	HRESULT  errb;


	if (hbt == NULL)
		return E_INVALIDARG;

	qbthr = _GLOBALLOCK(hbt);

	if (qbthr->bth.cLevels <= 0)
	{
		rc = E_NOTEXIST;
exit0:
		_GLOBALUNLOCK(hbt);
		return rc;
	}

	if (qbthr->ghCache == NULL)
	{

		if ((rc = RcMakeCache(qbthr)) != S_OK)
			goto exit0;
	}

	qbthr->qCache = _GLOBALLOCK(qbthr->ghCache);

	/* Look in the top level */
	
	for (wLevel = 0, bk = qbthr->bth.bkRoot;
		bk != bkNil && wLevel < qbthr->bth.cLevels - 1; wLevel++)
	{
		bk = qbthr->BkScanInternal(bk, key, wLevel, qbthr, NULL, &errb);                
	}

	if (bk == bkNil)
	{
		rc = E_NOTEXIST;
exit1:
		_GLOBALUNLOCK(qbthr->ghCache);
		goto exit0;
	}
	
	if (((rc = qbthr->RcScanLeaf(bk, key, wLevel, qbthr,
		qData, qbtpos)) == E_NOTEXIST) &&
		qbtpos != NULL && !fInsert)
	{
	QCB qcb;        

		errb = S_OK; 
		qcb = QFromBk(qbtpos->bk, (SHORT)(qbthr->bth.cLevels - 1),
		    qbthr, &errb);
		if (errb != S_OK)
            rc = errb;

		if (qcb != NULL)
		{
			if (qcb != NULL && qbtpos->cKey == qcb->db.cKeys)
			{
				if (qbtpos->bk == qbthr->bth.bkLast)
				{
					qbtpos->bk = bkNil;
				}
				else {
					qbtpos->bk = SWAPLONG(BkNext(qcb));
					qbtpos->cKey = 0;
					qbtpos->iKey = 2 * sizeof(BK);
				}
			}
		}
	}

	goto exit1;
}

/***************************************************************************
 *
 *      @doc    INTERNAL
 *
 *      @func   WORD PASCAL FAR | WGetNextNEntries |
 *              Get a series of keys, data, or both from btree
 *
 *      @parm   HBT | hbt | B-tree handle
 *
 *      @parm   WORD | wFlags |
 *              Any one of the following flags (they may be combined, in which case
 *              the data will be of the form [Key Flag]* (keys and flags interleaved).
 *
 *      @flag GETNEXT_KEYS | Key fields will be returned
 *      @flag GETNEXT_RECS | Data records will be returned
 *      @flag GETNEXT_RESET | Ignore value in qbtpos and start from first entry
 *      @parm   WORD | wNumEntries | Max number of entries to retrieve.  It may
 *              be the case that fewer entries are returned.
 *
 *      @parm   QBTPOS | qbtpos |
 *              pointer to buffer containing starting point for retrieval, or NULL
 *              to start from the beginning and not care where we left off.  Call
 *              <f WGetNextN> multiple times to get the next items in the series
 *              if <P qbtpos> is valid.
 *
 *      @parm   QV | qvBuffer
 *              Pointer to buffer for record retrieved data.
 *
 *      @parm   LONG | lBufSize
 *              Maximum number of bytes contained in buffer.
 *
 *      @parm   PHRESULT | lpErrb
 *              Error return code.  Valid if returned value not equal to <P wNumEntries>.
 *
 *      @rdesc  Number of entries returned in buffer.
 *
 ***************************************************************************/

WORD PASCAL FAR wGetNextNEntries(HBT hbt, WORD wFlags, WORD wNumEntries, QBTPOS qbtpos, 
	QV qvBuffer, LONG lBufSize, PHRESULT phr)
{
	QBTHR   qbthr;
	BK      bk;
	QCB     qcb;
	SHORT   cbKey, cbRec;
	QB      qb;
	QB              qbBuffer=(QB)qvBuffer;
	HRESULT      rc;
	int             iKeyCurrent;
	int             cKey;
	WORD    wEntriesFilled=0;

	if (hbt == NULL)
	{       SetErrCode(phr,E_INVALIDARG);
		return wEntriesFilled;
	}

	qbthr = _GLOBALLOCK(hbt);

	if (qbthr->bth.lcEntries == (LONG)0)
	{
		SetErrCode(phr, E_NOTEXIST);
exit0:
		_GLOBALUNLOCK(hbt);
		return wEntriesFilled;
	}
	qbthr->qCache = _GLOBALLOCK(qbthr->ghCache);

	if (qbthr->ghCache == NULL)
	{
		if ((rc = RcMakeCache(qbthr)) != S_OK) 
		{       
			SetErrCode(phr, rc);
			goto exit0;
		}
	}

	if ((!qbtpos) || (wFlags&GETNEXT_RESET))        // Start from first
	{       if ((bk = qbthr->bth.bkFirst) == bkNil)
		{

			SetErrCode(phr, E_ASSERT);
exit1:
			_GLOBALUNLOCK(qbthr->ghCache);
			goto exit0;
		}
		if ((qcb = QFromBk(bk, (SHORT)(qbthr->bth.cLevels - 1), qbthr,
	    phr)) == NULL)
		{               
			goto exit1;
		}
		iKeyCurrent=2 * sizeof(BK);
		qb = qcb->db.rgbBlock + iKeyCurrent;
		cKey=0;
	}
	else    // Start from qbtpos
	{
		if (!FValidPos(qbtpos))
		{
			SetErrCode(phr,E_ASSERT);
			goto exit0;
		}
		bk=qbtpos->bk;
		if ((qcb = QFromBk(bk, (SHORT)(qbthr->bth.cLevels - 1),
		    qbthr, phr)) == NULL)
		{
			goto exit1;                     
		}
		
		if (qbtpos->cKey==qcb->db.cKeys)
		{
			SetErrCode(phr, E_NOTEXIST);
			goto exit1;
		}

		assert(qbtpos->cKey < qcb->db.cKeys);
		assert(qbtpos->cKey >= 0);
		assert(qbtpos->iKey >= 2 * sizeof(BK));
		assert(qbtpos->iKey <= (SHORT)(qbthr->bth.cbBlock - sizeof(DISK_BLOCK)));

		cKey=qbtpos->cKey;
		iKeyCurrent=qbtpos->iKey;
		qb = qcb->db.rgbBlock + iKeyCurrent;

	}

	// keep getting data and filling, and fix qbtpos to next valid spot
	while (wNumEntries--)
	{       
		cbKey = CbSizeKey((KEY)qb, qbthr, TRUE);        
		if (wFlags&GETNEXT_KEYS)
		{       
			if (cbKey>lBufSize)
			{
				break;
			}
			QVCOPY(qbBuffer, qb,(LONG)cbKey);
			qbBuffer+=cbKey;
			lBufSize-=cbKey;
		}
		iKeyCurrent+=cbKey;
		qb+=cbKey;
		cbRec = CbSizeRec(qb, qbthr);
		if (wFlags&GETNEXT_RECS)
		{
			if (cbRec>lBufSize)
			{       iKeyCurrent-=cbKey;
				lBufSize-=cbKey;
				break;                          
			}
			QVCOPY(qbBuffer,qb,(LONG)cbRec);
			qbBuffer+=cbRec;
			lBufSize-=cbRec;
		}
		iKeyCurrent+=cbRec;
		qb+=cbRec;

		wEntriesFilled++;
		cKey++;
		
		if (cKey>=qcb->db.cKeys)        // Must advance to next block!
		{
			BK bkNew = SWAPLONG(BkNext(qcb));
			if (bkNew == bkNil)     // Back up to last key in btree
			{       //cKey--;
				//iKeyCurrent-=cbKey+cbRec;
				break;
			}
			if ((qcb = QFromBk(bkNew, (SHORT)(qbthr->bth.cLevels - 1),
			    qbthr, phr)) == NULL)
			{
				goto exit1;
			}
			
			iKeyCurrent=2 * sizeof(BK);
			qb = qcb->db.rgbBlock + iKeyCurrent;
			cKey=0;
			bk=bkNew;
		}
	}

	if (qbtpos != NULL) 
	{
		qbtpos->bk = bk;
		qbtpos->iKey = iKeyCurrent;
		qbtpos->cKey = cKey;
	}
	
	goto exit1;

}

/***************************************************************************
 *
 *      @doc    INTERNAL
 *
 *      @func   HRESULT PASCAL FAR | RcFirstHbt |
 *              Get first key and record from btree.
 *
 *      @parm   HBT | hbt | B-tree handle
 *
 *      @parm   KEY | key |
 *              points to buffer big enough to hold a key (256 bytes is more
 *              than enough)
 *
 *      @parm   QV | qvRec
 *              pointer to buffer for record or NULL if not wanted
 *
 *      @parm   QBTPOS | qbtpos |
 *              pointer to buffer for btpos or NULL if not wanted
 *
 *      @rdesc  S_OK if anything found, else error code.
 *              key   - key copied here
 *              qvRec - record copied here
 *              qbtpos- btpos of first entry copied here
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR RcFirstHbt(HBT hbt, KEY key, QV qvRec, QBTPOS qbtpos)
{
	QBTHR qbthr;
	BK    bk;
	QCB   qcb;
	SHORT   cbKey, cbRec;
	QB    qb;
	HRESULT    rc;
    HRESULT  errb;


	if (hbt == NULL)
		return E_INVALIDARG;

	qbthr = _GLOBALLOCK(hbt);

	if (qbthr->bth.lcEntries == (LONG)0)
	{
		rc = E_NOTEXIST;

exit0:
		_GLOBALUNLOCK(hbt);
		return rc;
	}

	if ((bk = qbthr->bth.bkFirst) == bkNil)
	{
		rc = E_ASSERT;
		goto exit0;
	}

	if (qbthr->ghCache == NULL)
	{
		if ((rc = RcMakeCache(qbthr)) != S_OK) 
			goto exit0;
	}

	qbthr->qCache = _GLOBALLOCK(qbthr->ghCache);

	if ((qcb = QFromBk(bk, (SHORT)(qbthr->bth.cLevels - 1), qbthr,
	    &errb)) == NULL)
	{
		rc = errb;
exit1:
		_GLOBALUNLOCK(qbthr->ghCache);
		goto exit0;
	}

	qb = qcb->db.rgbBlock + 2 * sizeof(BK);

	cbKey = CbSizeKey((KEY)qb, qbthr, TRUE);
	if ((QV)key != NULL) QVCOPY((QV)key, qb, (LONG)cbKey);
	qb += cbKey;

	cbRec = CbSizeRec(qb, qbthr);
	if (qvRec != NULL)
		QVCOPY(qvRec, qb, (LONG)cbRec);

	if (qbtpos != NULL) 
	{
		qbtpos->bk = bk;
		qbtpos->iKey = 2 * sizeof(BK);
		qbtpos->cKey = 0;
	}

	rc = S_OK;
	goto exit1;
}

/***************************************************************************
 *
 *      @doc    INTERNAL
 *
 *      @func   HRESULT PASCAL FAR | RcLastHbt |
 *              Get last key and record from btree.
 *
 *      @parm   HBT | hbt | B-tree handle
 *
 *      @parm   KEY | key |
 *              points to buffer big enough to hold a key (256 bytes
 *              is more than enough)
 *
 *      @parm   QV | qvRec |
 *              points to buffer big enough for record
 *
 *      @rdesc  S_OK if anything found, else error code.
 *              key   - key copied here
 *              qvRec - record copied here
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR RcLastHbt(HBT hbt, KEY key, QV qvRec, QBTPOS qbtpos)
{
	QBTHR qbthr;
	BK    bk;
	QCB   qcb;
	SHORT   cbKey, cbRec, cKey;
	QB    qb;
	HRESULT    rc;
    HRESULT  errb;


	if (hbt == NULL)
		return E_INVALIDARG;

	qbthr = _GLOBALLOCK(hbt);

	if (qbthr->bth.lcEntries == (LONG)0)
	{
		rc = E_NOTEXIST;
exit0:
		_GLOBALUNLOCK(hbt);
		return rc;
	}

	if ((bk = qbthr->bth.bkLast) ==bkNil)
	{
		rc = E_ASSERT;
		goto exit0;
	}

	if (qbthr->ghCache == NULL)
	{
		if ((rc = RcMakeCache(qbthr)) != S_OK) 
			goto exit0;
	}

	qbthr->qCache = _GLOBALLOCK(qbthr->ghCache);

	if ((qcb = QFromBk(bk, (SHORT)(qbthr->bth.cLevels - 1),
	    qbthr, &errb)) == NULL)
	{
		rc = errb;
exit1:
		_GLOBALUNLOCK(qbthr->ghCache);
		goto exit0;
	}

	qb = qcb->db.rgbBlock + 2 * sizeof(BK);

	for (cKey = 0; cKey < qcb->db.cKeys - 1; cKey++)
	{
		qb += CbSizeKey((KEY)qb, qbthr, TRUE);
		qb += CbSizeRec(qb, qbthr);
	}
	
	cbKey = CbSizeKey((KEY)qb, qbthr, FALSE);
	if ((QV)key != NULL)
	    QVCOPY((QV)key, qb, (LONG)cbKey); // decompress

	cbRec = CbSizeRec(qb + cbKey, qbthr);
	if (qvRec != NULL)
		QVCOPY(qvRec, qb + cbKey, (LONG)cbRec);

	if (qbtpos != NULL)
	{
		qbtpos->bk = bk;
		qbtpos->iKey = (int)(qb - (QB)qcb->db.rgbBlock);
		qbtpos->cKey = cKey;
	}

	rc = S_OK;
	goto exit1;
}

/***************************************************************************
 *
 *      @doc    INTERNAL
 *
 *      @func   HRESULT FAR PASCAL | RcLookupByPos |
 *              Map a pos into a key and rec (both optional).
 *
 *      @parm   HBT | hbt |
 *              the btree
 *
 *      @parm   QBTPOS | qbtpos 
 *              pointer to pos
 *
 *      @rdesc  S_OK or errors
 *              key   - if not (KEY)NULL, key copied here, not to exceed iLen 
 *              qRec  - if not NULL, record copied here
 *
 ***************************************************************************/

PUBLIC HRESULT FAR PASCAL RcLookupByPos(HBT hbt, QBTPOS qbtpos,
	 KEY key, int   iLen, QV qRec)
{

	QBTHR qbthr;
	QCB   qcbLeaf;
	QB    qb;
	HRESULT    rc;
    HRESULT  errb;


	/* Sanity check */

	if (!FValidPos(qbtpos))
		return E_ASSERT;
	if (hbt == NULL)
		return E_INVALIDARG;

	qbthr = _GLOBALLOCK(hbt);

	if (qbthr->bth.cLevels <= 0)
	{
		rc = E_NOTEXIST;
exit0:
		_GLOBALUNLOCK(hbt);
		return rc;
	}

	if (qbthr->ghCache == NULL)
	{
		if ((rc = RcMakeCache(qbthr)) != S_OK)
			goto exit0;
	}

	qbthr->qCache = _GLOBALLOCK(qbthr->ghCache);
	if ((qcbLeaf = QFromBk(qbtpos->bk, (SHORT)(qbthr->bth.cLevels - 1),
	    qbthr, &errb)) == NULL)
	{

		rc = errb;
exit1:
		_GLOBALUNLOCK(qbthr->ghCache);
		goto exit0;
	}


	assert(qbtpos->cKey < qcbLeaf->db.cKeys);
	assert(qbtpos->cKey >= 0);
	assert(qbtpos->iKey >= 2 * sizeof(BK));
	assert(qbtpos->iKey <= (SHORT)(qbthr->bth.cbBlock - sizeof(DISK_BLOCK)));


	qb = qcbLeaf->db.rgbBlock + qbtpos->iKey;

	if (key != (KEY)NULL)
	{
		QVCOPY((QV)key, qb, (LONG)min(iLen,CbSizeKey((KEY)qb, qbthr, FALSE))); /* need to decompress */
		qb += CbSizeKey(key, qbthr, TRUE);
	}

	if (qRec != NULL)
	{
		QVCOPY(qRec, qb, (LONG)CbSizeRec(qb, qbthr));
	}

	rc = S_OK;
	goto exit1;
}

/***************************************************************************
 *
 *      @doc    INTERNAL
 *
 *      @func   HRESULT PASCAL FAR | RcNextPos |
 *              get the next record from the btree
 *              Next means the next key lexicographically from the key
 *              most recently inserted or looked up
 *              Won't work if we looked up a key and it wasn't there
 *
 *              STATE IN: a record has been read from or written to the file
 *                      since the last deletion
 *
 *
 *      @parm   HBT | hbt | B-tree handle
 *
 *      @rdesc  S_OK; E_NOTEXIST if no successor record
 *              args OUT:   key   - next key copied to here
 *                      qvRec - record gets copied here
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR RcNextPos(HBT hbt, QBTPOS qbtposIn, QBTPOS qbtposOut)
{
	LONG l;

	return RcOffsetPos(hbt, qbtposIn, (LONG)1, &l, qbtposOut);
}

/***************************************************************************
 *
 *      @dos    INTERNAL
 *
 *      @func   HRESULT PASCAL FAR | RcOffsetPos |
 *              pos, offset from the previous pos by specified amount. 
 *              If not possible (i.e. prev of first) return real amount offset
 *              and a pos.
 *
 *      @parm    HBT | hbt |
 *              handle to btree
 *
 *      @parm   QBTPOS | qbtposIn |
 *              position we want an offset from
 *
 *      @parm   LONGD | lcOffset |
 *              amount to offset (+ or - OK)
 *
 *      @rdesc  rc
 *              args OUT:   qbtposOut       - new position offset by *qcRealOffset
 *                      *qlcRealOffset  - equal to lcOffset if legal, otherwise
 *                      as close as is legal
 *
 ***************************************************************************/
PUBLIC HRESULT PASCAL FAR RcOffsetPos(HBT hbt, QBTPOS qbtposIn,
	LONG lcOffset, QL qlcRealOffset, QBTPOS qbtposOut)
{
	QBTHR   qbthr;
	HRESULT      rc = S_OK;
	SHORT     c;
	LONG    lcKey, lcDelta = (LONG)0;
	QCB     qcb;
	BK      bk;
	QB      qb;
    HRESULT    errb;

	if (!FValidPos(qbtposIn))
		return E_ASSERT;

	if (hbt == NULL || qlcRealOffset == NULL)
		return E_INVALIDARG;

	bk = qbtposIn->bk;

	qbthr = _GLOBALLOCK(hbt);

	if (qbthr->bth.cLevels <= 0)
	{
		rc = E_NOTEXIST;
exit0:
		_GLOBALUNLOCK(hbt);
		return rc;
	}

	if (qbthr->ghCache == NULL)
	{
		if ((rc = RcMakeCache(qbthr)) != S_OK)
		{
			goto exit0;
		}
	}

	qbthr->qCache = _GLOBALLOCK(qbthr->ghCache); // >>>>what if no entries??


	if ((qcb = QFromBk(qbtposIn->bk,
		(SHORT)(qbthr->bth.cLevels - 1), qbthr, &errb)) == NULL)
	{
		rc = errb;

exit1:
		_GLOBALUNLOCK(qbthr->ghCache);
		goto exit0;
	}

	lcKey = qbtposIn->cKey + lcOffset;

	/* chase prev to find the right block */
	while (lcKey < 0)
	{
		bk = SWAPLONG(BkPrev(qcb));
		if (bk == bkNil)
		{
			bk = qcb->bk;
			lcDelta = lcKey;
			lcKey = 0;
			break;
		}
		if ((qcb = QFromBk(bk, (SHORT)(qbthr->bth.cLevels - 1),
		    qbthr, &errb)) == NULL)
		{
			rc = errb; 
			goto exit1;
		}
		lcKey += qcb->db.cKeys;
	}

	/* chase next to find the right block */
	while (lcKey >= qcb->db.cKeys)
	{
		lcKey -= qcb->db.cKeys;
		bk = SWAPLONG(BkNext(qcb));
		if (bk == bkNil)
		{
			bk = qcb->bk;
			lcDelta = lcKey + 1;
			lcKey = qcb->db.cKeys - 1;
			break;
		}
		if ((qcb = QFromBk(bk, (SHORT)(qbthr->bth.cLevels - 1),
		    qbthr, &errb)) == NULL)
		{
			rc = errb;
			goto exit1;
		}
	}

	
	if (bk == qbtposIn->bk && lcKey >= qbtposIn->cKey)
	{
		c = (SHORT) qbtposIn->cKey;
		qb = qcb->db.rgbBlock + qbtposIn->iKey;
	}
	else
	{
		c = 0;
		qb = qcb->db.rgbBlock + 2 * sizeof(BK);
	}

	while ((LONG)c < lcKey)
	{
		qb += CbSizeKey((KEY)qb, qbthr, TRUE);
		qb += CbSizeRec(qb, qbthr);
		c++;
	}

	if (qbtposOut != NULL)
	{
		qbtposOut->bk = bk;
		qbtposOut->iKey = (int)(qb - (QB)qcb->db.rgbBlock);
		qbtposOut->cKey = c;
	}

	*qlcRealOffset = lcOffset - lcDelta;

	rc = (lcDelta ? E_NOTEXIST: S_OK);
	goto exit1;
}


/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\filesys\filesys.c ===
/*****************************************************************************
 *                                                                            *
 *  FILESYS.C                                                                 *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1995.                          		  *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  All main File System commands (opening, closing)				          *
 *	any given offset, or in a temp file.									  *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  davej                                                     *
 *****************************************************************************/

/*****************************************************************************
 *
 *  Created 07/17/95 - davej
 *           3/05/97     erinfox Change errors to HRESULTS
 *
 *****************************************************************************/

static char s_aszModule[] = __FILE__;    /* For error report */

#include <mvopsys.h>
#include <iterror.h>
#include <orkin.h>
#include <misc.h>
#include <wrapstor.h>
#include <_mvutil.h>

/*****************************************************************************
 *                                                                            *
 *                               Defines                                      *
 *                                                                            *
 *****************************************************************************/


/*****************************************************************************
 *                                                                            *
 *                               Prototypes                                   *
 *                                                                            *
 *****************************************************************************/

/***************************************************************************
 *                                                                           *
 *                         Private Functions                                 *
 *                                                                           *
 ***************************************************************************/

// FACCESS_READWRITE
// FACCESS_READ		
BOOL PASCAL FAR FHfsAccess(HFS hfs, BYTE bFlags)
{
	QFSHR   qfshr;
	BOOL 	bHasAccess=FALSE;
	if (hfs == NULL || (qfshr = _GLOBALLOCK(hfs)) == NULL)
	{
	    return FALSE;
	}

	if ((qfshr->fsh.bFlags&FSH_READWRITE) && (bFlags&FACCESS_READWRITE))
		bHasAccess=TRUE;
	if (bFlags&FACCESS_READ) 
		bHasAccess=TRUE;

	_GLOBALUNLOCK(hfs);
	return bHasAccess;
}

/***************************************************************************
 *
 *	@doc	PRIVATE
 *
 *	@func	HFS PASCAL NEAR | HfsOpenFileSysFmInternal |
 *		Open or Create a file system
 *
 *  @parm	FM | fmFileName |
 *		File name of file system to open or create (FM is identical to LPSTR)
 *
 *	@parm	BYTE | bFlags |
 *		Combinations of the FSH_ flags
 * 	@flag FSH_READWRITE	 	| (0x01)	FS will be updated
 *	@flag FSH_READONLY 	 	| (0x02)	FS will be read only, no updating
 *	@flag FSH_CREATE 	 	| (0x04)	Create a new FS
 *	@flag FSH_M14		 	| (0x08)	Not used really, since we return										
 *	@flag FSH_FASTUPDATE	| (0x10)	System Btree is not copied to temp file
 *											unless absolutely necessary
 *	@flag FSH_DISKBTREE		| (0x20)	System Btree is always copied to disk if
 *											possible for speed.  Btree may be very very
 *											large, and this is NOT recommended for on-line	
 *
 *	@parm	FS_PARAMS FAR * | lpfsp |
 *		File system initialization parameters (currently btree block size)
 *
 *  @parm	PHRESULT | lpErrb |
 *		Error return
 *
 *	@rdesc	Returns a valid HFS or NULL if an error.
 *
 ***************************************************************************/

HFS PASCAL NEAR HfsOpenFileSysFmInternal(FM fm,
    BYTE bFlags, FS_PARAMS FAR *qfsp, PHRESULT phr)
{
#ifdef MOSMAP // {
	// Disable function
	if (bFlags&(FSH_CREATE|FSH_READWRITE))
	{	
		SetErrCode (phr, ERR_NOTSUPPORTED);
		return NULL;
	}
#else // } {
	HFS           	hfs;
	QFSHR         	qfshr;
	BTREE_PARAMS  	btp;
	
	/* make file system header */

	if (( hfs =  _GLOBALALLOC(GMEM_ZEROINIT|GMEM_SHARE| GMEM_MOVEABLE,
	    (LONG)sizeof( FSHR) ) ) == NULL )
	{
		SetErrCode (phr, E_OUTOFMEMORY);
		return NULL;
	}

	qfshr = _GLOBALLOCK(hfs);

	_INITIALIZECRITICALSECTION(&qfshr->cs);

	// Copy File Moniker
	if ((qfshr->fm = FmCopyFm(fm, phr)) == fmNil)
	{
	 	SetErrCode(phr,E_OUTOFMEMORY);
		exit0:
			_DELETECRITICALSECTION(&qfshr->cs);
			_GLOBALUNLOCK(hfs);
			_GLOBALFREE(hfs);
			return 0;
	}

	// Open or Create fid
	if (bFlags&FSH_CREATE)
		qfshr->fid = FidCreateFm(qfshr->fm, wReadWrite, wReadWrite, phr);	
	else
		qfshr->fid = FidOpenFm(qfshr->fm,
            (WORD)((bFlags & FSH_READONLY)?(wReadOnly | wShareRead) : (wReadWrite | wShareNone)), phr);
	if (qfshr->fid == fidNil)
	{
		exit1:
			//FreeListDestroy(qfshr->hfl);
			SetErrCode(phr,E_NOPERMISSION);
			DisposeFm(qfshr->fm);
			goto exit0;		
	}

	qfshr->hsfbFirst=NULL;
	qfshr->hsfbSystem=NULL;

	// Initialize global SubFile header blocks array - shared by everyone :-)
	// So we take multi-threading precautions
	if (!_INTERLOCKEDINCREMENT(&mv_gsfa_count))
	{
		HANDLE hSfa;
		
		mv_gsfa_count=1L;
		mv_gsfa=NULL;
		_INITIALIZECRITICALSECTION(&mv_gsfa_cs);

		if (((hSfa=_GLOBALALLOC(GMEM_ZEROINIT|GMEM_MOVEABLE|GMEM_SHARE,sizeof(SF)*MAXSUBFILES))==NULL) || 
			((mv_gsfa=(SF FAR *)_GLOBALLOCK(hSfa))==NULL))
		{
			if (hSfa)
				_GLOBALFREE(hSfa);
			SetErrCode (phr, E_OUTOFMEMORY);
			exit2:
				if (!(_INTERLOCKEDDECREMENT(&mv_gsfa_count)))
				{
					if (mv_gsfa)
					{
					 	_GLOBALUNLOCK(GlobalHandle(mv_gsfa));
						_GLOBALFREE(GlobalHandle(mv_gsfa));
						mv_gsfa=NULL;
					}
					_DELETECRITICALSECTION(&mv_gsfa_cs);
					mv_gsfa_count=-1L;
				}
				goto exit1;
		}
		mv_gsfa[0].hsfb=(HSFB)-1;				
	}
	
	if (bFlags&(FSH_READWRITE|FSH_DISKBTREE))
	{	
		// If we are ambitious, we can try lower scratch sizes, but if we are that low
		// on memory, chances are we are just going to fail a few steps from here.
		HANDLE hBuf;
		if (!(hBuf=_GLOBALALLOC(GMEM_ZEROINIT|GMEM_MOVEABLE|GMEM_SHARE,(DWORD)SCRATCHBUFSIZE)))
		{	
			SetErrCode(phr, E_OUTOFMEMORY);
			goto exit2;
		}	

		if (!(qfshr->sb.lpvBuffer=_GLOBALLOCK(hBuf)))
		{
			_GLOBALFREE(hBuf);
			goto exit2;
		}
		qfshr->sb.lcbBuffer=(LONG)SCRATCHBUFSIZE;
		_INITIALIZECRITICALSECTION(&qfshr->sb.cs);
	}

	if (!(bFlags&FSH_CREATE))
	{
	 	BYTE bFlagsBtree=0L;

	 	if ((LcbReadFid(qfshr->fid, &qfshr->fsh,(LONG)sizeof(FSH), 
	 		phr)) != (LONG)sizeof(FSH)) 
		{
			SetErrCode (phr, E_FILEINVALID);	
			exit3:
				if (bFlags&(FSH_READWRITE|FSH_DISKBTREE))
					_DELETECRITICALSECTION(&qfshr->sb.cs);
				if (qfshr->sb.lpvBuffer)
				{	
					if (!(bFlags&(FSH_READWRITE|FSH_DISKBTREE)))
						_DELETECRITICALSECTION(&qfshr->sb.cs);
					_GLOBALUNLOCK(GlobalHandle(qfshr->sb.lpvBuffer));
					_GLOBALFREE(GlobalHandle(qfshr->sb.lpvBuffer));
				}
				RcCloseFid(qfshr->fid);
				if (bFlags&FSH_CREATE)
					RcUnlinkFm(qfshr->fm);
				goto exit2;
		}
		/* Handle MAC swapping */

        if (qfshr->fsh.wMagic == SWAPWORD(wFileSysMagic))
        {
		    qfshr->fsh.wMagic = SWAPWORD(qfshr->fsh.wMagic);
		    qfshr->fsh.foDirectory.dwOffset = SWAPLONG(qfshr->fsh.foDirectory.dwOffset);
		    qfshr->fsh.foDirectory.dwHigh = SWAPLONG(qfshr->fsh.foDirectory.dwHigh);
		    qfshr->fsh.foFreeList.dwOffset = SWAPLONG(qfshr->fsh.foFreeList.dwOffset);
		    qfshr->fsh.foFreeList.dwHigh = SWAPLONG(qfshr->fsh.foFreeList.dwHigh);
		    qfshr->fsh.foEof.dwOffset = SWAPLONG(qfshr->fsh.foEof.dwOffset);	
		    qfshr->fsh.foEof.dwHigh = SWAPLONG(qfshr->fsh.foEof.dwHigh);	
        }
	    qfshr->fsh.bFlags=(qfshr->fsh.bFlags&(~(FSH_READWRITE|FSH_READONLY)))|bFlags;


		if (qfshr->fsh.wMagic != wFileSysMagic)
		{
	        SetErrCode (phr, E_FILEINVALID);	
			goto exit3;
		}
		if (qfshr->fsh.bVersion != bFileSysVersion) 
		{
			if (qfshr->fsh.bVersion == bFileSysVersionOld)
			{
				qfshr->fsh.bFlags|=FSH_M14;
				SetErrCode(phr, E_BADVERSION); // Try another error specially for M14?
				goto exit3;
			}
			else
			{
				SetErrCode(phr, E_BADVERSION);
				goto exit3;
			}
		}
		// Open Free List if r/w mode
		if (bFlags&FSH_READWRITE)
		{	
			if ((!FoEquals(FoSeekFid(qfshr->fid,qfshr->fsh.foFreeList,wSeekSet,
				phr),qfshr->fsh.foFreeList))	||
				((qfshr->hfl=FreeListInitFromFid( qfshr->fid, phr ))==NULL))
			{
			 	goto exit3;	
			}
		}

		// Open Btree making temp file for btree
		//if ((qfshr->hbt = HbtOpenBtreeSz(NULL, hfs,
		//	(BYTE)((qfshr->fsh.bFlags&FSH_READONLY?HFOPEN_READ:HFOPEN_READWRITE)|HFOPEN_SYSTEM),
		//	NULL, phr)) == NULL) 

		// Open Btree, temp only gets made if necessary

		bFlagsBtree|=HFOPEN_SYSTEM;
		if (qfshr->fsh.bFlags&FSH_READONLY)
		{
		 	bFlagsBtree|=HFOPEN_READ;
			if (qfshr->fsh.bFlags&FSH_DISKBTREE)
				bFlagsBtree|=HFOPEN_FORCETEMP;
		}
		else
		{
		 	bFlagsBtree|=HFOPEN_READWRITE;
		 	if (qfshr->fsh.bFlags&FSH_FASTUPDATE)
				bFlagsBtree|=HFOPEN_NOTEMP;
		}
		
		//if ((qfshr->hbt = HbtOpenBtreeSz(NULL, hfs,
		//	(BYTE)((qfshr->fsh.bFlags&FSH_READONLY?HFOPEN_READ:
		//	((qfshr->fsh.bFlags&FSH_FASTUPDATE)?HFOPEN_NOTEMP:0)|HFOPEN_READWRITE)|
		//	HFOPEN_SYSTEM),
		//	NULL, phr)) == NULL) 

		if ((qfshr->hbt = HbtOpenBtreeSz(NULL, hfs, bFlagsBtree, phr))==NULL)		
		{
			exit4:
				if (qfshr->hfl)
					FreeListDestroy(qfshr->hfl);
				goto exit3;
		}
	}
	else
	{
        WORD wFreeListSize = wDefaultFreeListSize;
        if ((qfsp) && (qfsp->wFreeListSize))
            wFreeListSize = qfsp->wFreeListSize;
        
		qfshr->fsh.wMagic       = wFileSysMagic;
		qfshr->fsh.bVersion     = bFileSysVersion;
		qfshr->fsh.bFlags       = FSH_READWRITE;
		qfshr->fsh.foFreeList.dwOffset   = sizeof(FSH);	// Free list directly after header
		qfshr->fsh.foFreeList.dwHigh = 0L;
		qfshr->fsh.foDirectory = foNil; // Filled in with system file start
		if (bFlags&FSH_READWRITE)
		{	if ((qfshr->hfl=FreeListInit(wFreeListSize, phr))==NULL)
			{
		 		goto exit3;
			}
		}
		qfshr->fsh.foEof.dwOffset = sizeof(FSH)+FreeListSize(qfshr->hfl,phr);  // Free starts here

		qfshr->fsh.foEof.dwHigh = 0L;

		/* build btree directory */
		btp.hfs       = hfs;
		btp.bFlags    = HFOPEN_READWRITE|HFOPEN_SYSTEM;
		if (qfsp != NULL)
		{
			btp.cbBlock = qfsp->cbBlock;
		}
		else
		{
			btp.cbBlock = cbBtreeBlockDefault;
		}
		lstrcpy(btp.rgchFormat, "VOO1"); //  "VY", KT_VSTI, FMT_VNUM_FO, FMT_VNUM_LCB, file byte // 'VOL1' works too

		qfshr->hbt = HbtCreateBtreeSz(NULL, &btp, phr);
		if (qfshr->hbt == NULL) 
		{
			goto exit4;
		}
	}

	// NO harm writing out file system file so far (???)
	//LSeekFid(qfshr->fid, 0L, wSeekSet, phr);
	//LcbWriteFid(qfshr->fid, &qfshr->fsh, sizeof(FSH), phr);
	//Lcb ... also no need to write it out yet!

	/* return handle to file system */
	_GLOBALUNLOCK(hfs);
	return hfs;

#endif //}
}

/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	HFS PASCAL FAR | HfsCreateFileSysFm |
 *		Creates a new file system
 *
 *  @parm	FM | fmFileName |
 *		File name of file system to open or create (FM is same as LPSTR)
 *
 *	@parm	FS_PARAMS FAR * | lpfsp |
 *		File system initialization parameters (currently btree block size)
 *
 *  @parm	PHRESULT | lpErrb |
 *		Error return
 *
 *	@rdesc	Returns a valid HFS or NULL if an error.
 *
 ***************************************************************************/

PUBLIC HFS PASCAL FAR EXPORT_API HfsCreateFileSysFm(FM fm,
    FS_PARAMS FAR *qfsp, PHRESULT phr)
{
 	return HfsOpenFileSysFmInternal(fm,FSH_CREATE|FSH_READWRITE,qfsp,phr);
}

/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	HFS PASCAL FAR | HfsOpenFm |
 *		Open an existing file system
 *
 *  @parm	FM | fmFileName |
 *		File name of file system to open (FM is same as LPSTR)
 *
 *	@parm	BYTE | bFlags |
 *		Any of the FSH_ flags
 * 	@flag FSH_READWRITE	 	| (BYTE)0x01	FS will be updated
 *	@flag FSH_READONLY 	 	| (BYTE)0x02	FS will be read only, no updating
 *	@flag FSH_M14		 	| (BYTE)0x08	Not used really, since we return										
 *	@flag FSH_FASTUPDATE	| (BYTE)0x10	System Btree is not copied to temp file
 *											unless absolutely necessary
 *	@flag FSH_DISKBTREE		| (BYTE)0x20	System Btree is always copied to disk if
 *											possible for speed.  Btree may be very very
 *											large, and this is NOT recommended for on-line	
 *
 *  @parm	PHRESULT | lpErrb |
 *		Error return
 *
 *	@rdesc	Returns a valid HFS or NULL if an error.
 *
 ***************************************************************************/

PUBLIC	HFS PASCAL FAR EXPORT_API HfsOpenFm(FM fm, BYTE bFlags,
	PHRESULT phr)
{
	if (bFlags&FSH_CREATE)
	{
	 	SetErrCode(phr, E_INVALIDARG);
		return NULL;
	}
	return HfsOpenFileSysFmInternal(fm,bFlags,NULL,phr);
}

/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	HRESULT PASCAL FAR | RcCloseHfs |
 *		Close an opened File System
 *
 *  @parm	HFS | hfs |
 *		Handle of opened file system
 *
 *	@rdesc	Returns S_OK if closed OK, else an error
 *
 *	@comm
 *		state IN:   
 *		state OUT:
 *		Notes:      
 *
 ***************************************************************************/

HRESULT PASCAL FAR RcCloseHfs(HFS hfs)
{
	QFSHR   qfshr;
	HRESULT    errb;

	if (hfs == NULL || (qfshr = _GLOBALLOCK(hfs)) == NULL)
	{
	    return(E_INVALIDARG);
	}
    
	if (!mv_gsfa_count)
		return E_ASSERT;

	_ENTERCRITICALSECTION(&qfshr->cs);

	// We need to:
	// 	(1) close all subfiles if any open
	//	(2) close the btree
	//  (3) r/w write free list
	//  (4) r/w write header

	RcCloseEveryHf(hfs);

	//while (qfshr->hsfbFirst)
	//{
	// 	qfshr->hsfbFirst=HsfbCloseHsfb(qfshr->hsfbFirst, &errb);
	//	if (errb.err!=S_OK)
	//		break;
	//}
	
	if ((errb = RcCloseOrFlushHbt(qfshr->hbt, TRUE)) != S_OK)
	{
		/* out of disk space, internal error, or out of file handles. */
		if (errb != E_HANDLE)
		{
			/* attempt to invalidate FS by clobbering magic number */
			LSeekFid(qfshr->fid, 0L, wSeekSet, NULL);
			qfshr->fsh.wMagic = 0;
			LcbWriteFid(qfshr->fid, &qfshr->fsh, (LONG)sizeof(FSH), NULL);
		}
	}
	else
	{
		if (qfshr->fsh.bFlags & FSH_READWRITE)
		{
			FoSeekFid(qfshr->fid, qfshr->fsh.foFreeList, wSeekSet, NULL);
			FreeListWriteToFid(qfshr->hfl, qfshr->fid, NULL);
			FreeListDestroy(qfshr->hfl);

			if (LSeekFid(qfshr->fid, 0L, wSeekSet, &errb) == 0L)
			{
    			LcbWriteFid(qfshr->fid, &qfshr->fsh, (LONG)sizeof(FSH), &errb);
			}			
		}
	}
	
	// Remove our access to the global subfile handle object
	if (!(_INTERLOCKEDDECREMENT(&mv_gsfa_count)))
	{
		// Last person using subfile array deletes it too!
		// Can we use the GlobalHandle function OK in all environments?
		_GLOBALUNLOCK(GlobalHandle(mv_gsfa));
		_GLOBALFREE(GlobalHandle(mv_gsfa));
		mv_gsfa=NULL;
		mv_gsfa_count=-1L;
		_DELETECRITICALSECTION(&mv_gsfa_cs);
	}
	
	RcCloseFid(qfshr->fid);
	
	_LEAVECRITICALSECTION(&qfshr->cs);
	_DELETECRITICALSECTION(&qfshr->cs);
	if (qfshr->sb.lpvBuffer)
	{
		_DELETECRITICALSECTION(&qfshr->sb.cs);
		_GLOBALUNLOCK(GlobalHandle(qfshr->sb.lpvBuffer));
		_GLOBALFREE(GlobalHandle(qfshr->sb.lpvBuffer));
	}
	DisposeFm(qfshr->fm);
	_GLOBALUNLOCK(hfs);
	_GLOBALFREE(hfs);
	
	return errb;
}

/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	HRESULT PASCAL FAR | RcFlushHfs |
 *		Write all temporary info in file system to FS file
 *
 *  @parm	HFS | hfs |
 *		Handle of opened file system
 *
 *	@rdesc	Returns S_OK if closed OK, else an error
 *
 *	@comm
 *		state IN:   
 *		state OUT:
 *		Notes:      
 *
 ***************************************************************************/

HRESULT PASCAL FAR RcFlushHfs(HFS hfs)
{
	QFSHR   qfshr;
	HRESULT    errb;
	//HSFB hsfbCursor;
	HRESULT rc=S_OK;
	 	

	if (hfs == NULL || (qfshr = _GLOBALLOCK(hfs)) == NULL)
	{
	    return(E_INVALIDARG);
	}
    
	_ENTERCRITICALSECTION(&qfshr->cs);

	// We need to:
	// 	(1) close all subfiles if any open
	//	(2) close the btree
	//  (3) r/w write free list
	//  (4) r/w write header
	
	RcFlushEveryHf(hfs);
	
	/*
	hsfbCursor=qfshr->hsfbFirst;
	while (hsfbCursor)
	{
	 	HSFB hsfbNext=NULL;
		QSFB qsfb;

		if (!(qsfb = _GLOBALLOCK(hsfbCursor)))
		{
		    rc=E_OUTOFMEMORY;
			exit1:
				_LEAVECRITICALSECTION(&qfshr->cs);
				_GLOBALUNLOCK(hfs);
				return rc;
		}

    	hsfbNext=qsfb->hsfbNext;
	
	 	if ((rc=RcFlushHsfb(hsfbCursor))!=S_OK)
		{
			_GLOBALUNLOCK(hsfbCursor);
			goto exit1;
		}
		_GLOBALUNLOCK(hsfbCursor);
		hsfbCursor=hsfbNext;		
	}
	*/

	if ((rc = RcCloseOrFlushHbt(qfshr->hbt, FALSE)) != S_OK)
	{
		/* out of disk space, internal error, or out of file handles. */
		if (rc != E_HANDLE)
		{
			/* attempt to invalidate FS by clobbering magic number */
			LSeekFid(qfshr->fid, 0L, wSeekSet, NULL);
			qfshr->fsh.wMagic = 0;
			LcbWriteFid(qfshr->fid, &qfshr->fsh, (LONG)sizeof(FSH), NULL);
		}
	}
	else
	{
		if (qfshr->fsh.bFlags & FSH_READWRITE)
		{
			FoSeekFid(qfshr->fid, qfshr->fsh.foFreeList, wSeekSet, NULL);
			FreeListWriteToFid(qfshr->hfl, qfshr->fid, NULL);
		
			if (LSeekFid(qfshr->fid, 0L, wSeekSet, &errb) == 0L)
			{
    			LcbWriteFid(qfshr->fid, &qfshr->fsh, (LONG)sizeof(FSH), &errb);
			}

			FidFlush(qfshr->fid);
		}
	}
	
	_LEAVECRITICALSECTION(&qfshr->cs);	
	_GLOBALUNLOCK(hfs);
	return rc;
}


/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	HRESULT PASCAL FAR | RcDestroyFileSysFm |
 *		Deletes a closed file system (removes it from the disk)
 *
 *  @parm	FM | fmFileName |
 *		Name of file to destroy	(FM is same as LPSTR)
 *
 *	@rdesc	Returns S_OK if deleted
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API RcDestroyFileSysFm(FM fm)
{
#ifdef MOSMAP // {
	// Disable function
	return ERR_NOTSUPPORTED;
#else // } {
    HRESULT   errb;
	FSH fsh;
	FID fid = FidOpenFm(fm, wReadOnly, &errb);


	if (fid == fidNil)
	    return errb;

	if (LcbReadFid (fid, &fsh, (LONG)sizeof(FSH), &errb) != (LONG)sizeof(FSH))
	{
		RcCloseFid(fid);
		return E_FILEINVALID;
	}

	if (fsh.wMagic != wFileSysMagic)
	{
		RcCloseFid(fid);
		return E_FILEINVALID;
	}

	/* REVIEW: unlink all tmp files for open files? assert count == 0? */

	RcCloseFid(fid); /* I'm not checking this return code out of boredom */

	return (RcUnlinkFm( fm) );
#endif //}
}

#define MAGIC_FSFILEFIND 0x22334455

/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	HRESULT PASCAL FAR | RcFindFirstFile |
 *		Finds the first file equal to or after the given filename.  This function
 *		will always find a filename unless the given search filename is past all
 *		files in the file system.
 *
 *  @parm	LPCSTR | szFileName |
 *		Name of file to look for.  OK to use partial filenames, since the 
 *		first file equal to or after the given filename in the directory
 *		will be found.
 *
 *	@parm 	LPFSFILEFIND |lpfsfilefind|
 *		This structure will be filled with information like file length, 
 *		permission attributes, and file name.  It will also be passed to
 *		RcFindNextFile to get the next filename.
 *
 *	@rdesc	Returns S_OK if successful.
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API RcFindFirstFile(HFS hfs, LPCSTR szFilename, FSFILEFIND * pfind)
{
 	QFSHR  	qfshr;
	HRESULT rc = S_OK;
	KEY key;
	BTPOS btpos;
	FILE_REC fr;
	
 	if ((szFilename==NULL) || (pfind==NULL) || (hfs == NULL) || ((qfshr = _GLOBALLOCK(hfs)) == NULL))
	    return E_INVALIDARG;	    
	
	key = NewKeyFromSz(szFilename);	
	
	_ENTERCRITICALSECTION(&qfshr->cs);
	
	RcLookupByKeyAux(qfshr->hbt, key, &btpos, &fr, FALSE);
	if (btpos.bk == bkNil)
	{	rc=E_NOTEXIST;
		goto exit1;
	}

	GetFrData(&fr);
	pfind->btpos=btpos;
	pfind->foSize=fr.foSize;
	pfind->foStart=fr.foStart;
	pfind->bFlags=fr.bFlags;
	pfind->hfs=hfs;
	pfind->magic=MAGIC_FSFILEFIND;
	
	RcLookupByPos( qfshr->hbt, &btpos, (KEY)pfind->szFilename, 256, &fr );
	//GetFrData(&fr);
	
	{	DWORD dwLen;
		int iOffset;
		LPSTR szCursor;
		
		dwLen=FoFromSz(pfind->szFilename).dwOffset;
		iOffset=LenSzFo(pfind->szFilename);
		szCursor=pfind->szFilename;
		while (dwLen--)
		{	*szCursor=*(szCursor+iOffset);
			szCursor++;
		}
		*szCursor=0x00;
	}
exit1:
	_LEAVECRITICALSECTION(&qfshr->cs);	
	DisposeMemory((LPSTR)key);
	_GLOBALUNLOCK(hfs);
	return rc;
}

/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	HRESULT PASCAL FAR | RcFindNextFile |
 *		Finds the next file in the file system directory. 
 *
 *	@parm 	LPFSFILEFIND |lpfsfilefind|
 *		This structure will be filled with information like file length, 
 *		permission attributes, and file name.  It must have already been filled
 *		by RcFindFirstFile before calling this function.
 *
 *	@rdesc	Returns S_OK if successful
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API RcFindNextFile(FSFILEFIND * pfind)
{
	QFSHR  	qfshr;
	HRESULT rc = S_OK;
	BTPOS btNewPos;
	FILE_REC fr;
	
	if ((!pfind) || (pfind->magic!=MAGIC_FSFILEFIND))
		return E_INVALIDARG;

	if ((pfind->hfs == NULL) || ((qfshr = _GLOBALLOCK(pfind->hfs)) == NULL))
	    return E_INVALIDARG;	    
	
	_ENTERCRITICALSECTION(&qfshr->cs);
	
	if (RcNextPos( qfshr->hbt, &pfind->btpos, &btNewPos )==E_NOTEXIST)
	{	
		rc=E_NOTEXIST;
		goto exit1;
	}

	pfind->btpos=btNewPos;

	RcLookupByPos( qfshr->hbt, &pfind->btpos, (KEY)pfind->szFilename, 256, &fr );
	GetFrData(&fr);
	
	pfind->foSize=fr.foSize;
	pfind->bFlags=fr.bFlags;
	
	{	LPSTR szCursor;
		DWORD dwLen;
		int iOffset;
		
		dwLen=FoFromSz(pfind->szFilename).dwOffset;
		iOffset=LenSzFo(pfind->szFilename);
		szCursor=pfind->szFilename;
		while (dwLen--)
		{	*szCursor=*(szCursor+iOffset);
			szCursor++;
		}
		*szCursor=0x00;
	}

exit1:
	_LEAVECRITICALSECTION(&qfshr->cs);	
	_GLOBALUNLOCK(pfind->hfs);
	return rc;
}






/***************************************************************************
 *
 *	@doc	PRIVATE
 *
 *	@func	HFREELIST PASCAL FAR | FreeListInitFromFid |
 *		Initialize a freelist structure from a fid image.  Fid image is
 *		always in Intel byte ordering format.
 *
 *	@parm	FID | fid |
 *		File id
 *
 *	@parm	PHRESULT | lpErrb |
 *		Error code return - S_OK or E_OUTOFMEMORY
 *
 *	@rdesc	Returns handle to a FREELIST, otherwise NULL if error.
 *
 ***************************************************************************/

PUBLIC HFREELIST PASCAL FAR EXPORT_API FreeListInitFromFid( FID fid, PHRESULT lpErrb )
{
 	FREELISTHDR freehdr;

	QFREELIST qFreeList;
	HFREELIST hFreeList = NULL;
	WORD wMaxBlocks;
	WORD wNumBlocks;
	DWORD dwLostBytes;

	assert(fid!=fidNil);

	if (LcbReadFid(fid, &freehdr, sizeof(FREELISTHDR), lpErrb)!=sizeof(FREELISTHDR))
	{
	 	return NULL;
	}
	
	wMaxBlocks = freehdr.wMaxBlocks;
	wNumBlocks = freehdr.wNumBlocks;
	dwLostBytes = freehdr.dwLostBytes;
		
	//wMaxBlocks = qFreeListMem->flh.wMaxBlocks;
	//wNumBlocks = qFreeListMem->flh.wNumBlocks;

	// Mac-ify
	wMaxBlocks = SWAPWORD(wMaxBlocks);
	wNumBlocks = SWAPWORD(wNumBlocks);
	dwLostBytes = SWAPLONG(dwLostBytes);
	
	assert( wMaxBlocks );
	
	if (!(hFreeList=_GLOBALALLOC(GMEM_ZEROINIT| GMEM_MOVEABLE,
		sizeof(FREEITEM)*wMaxBlocks+sizeof(FREELISTHDR))))
	{	
		SetErrCode(lpErrb,E_OUTOFMEMORY);
		return NULL;
	}

	if (!(qFreeList=_GLOBALLOCK(hFreeList)))
	{	
		SetErrCode(lpErrb,E_OUTOFMEMORY);
		goto exit1;
	}

	qFreeList->flh.wMaxBlocks=wMaxBlocks;
	qFreeList->flh.wNumBlocks=wNumBlocks;
	qFreeList->flh.dwLostBytes=dwLostBytes;

	LcbReadFid( fid, qFreeList->afreeitem, sizeof(FREEITEM) * wMaxBlocks, lpErrb);
	
#ifdef _BIG_E	
	{
		QFREEITEM qCurrent = qFreeList->afreeitem;
		WORD wBlock;
	
		for (wBlock=0;wBlock<wNumBlocks;wBlock++)
		{
	 	 	qCurrent->foStart.dwOffset = SWAPLONG(qCurrent->foStart.dwOffset);
			qCurrent->foStart.dwHigh = SWAPLONG(qCurrent->foStart.dwHigh);
			qCurrent->foBlock.dwOffset = SWAPLONG(qCurrent->foBlock.dwOffset);
			qCurrent->foBlock.dwHigh = SWAPLONG(qCurrent->foBlock.dwHigh);	
		}
	}
#endif // _BIG_E
	
	_GLOBALUNLOCK(hFreeList);

	return hFreeList;

	exit1:
		_GLOBALFREE(hFreeList);
		return NULL;
}

/***************************************************************************
 *
 *	@doc	PRIVATE
 *
 *	@func	HRESULT PASCAL FAR | FreeListWriteToFid |
 *		Write to fid with freelist data.  Call FreeListSize first
 *		to make sure the space is large enough.  Memory image will always
 *		be in Intel byte ordering format.
 *
 *	@parm	HFREELIST | hFreeList |
 *		List to retrieve
 *
 *	@parm	FID | fid |
 *		FID to contain free list data
 *
 *	@parm	PHRESULT | lpErrb |
 *		Error return
 *
 *	@rdesc	Number of bytes written
 *
 ***************************************************************************/

PUBLIC LONG	PASCAL FAR EXPORT_API FreeListWriteToFid( HFREELIST hFreeList, FID fid, PHRESULT lpErrb )
{
	QFREELIST qFreeList;
	WORD wMaxBlocks;
	WORD wNumBlocks;
	DWORD dwLostBytes;
	LONG lcbSize;
	LONG lcbWritten=0L;

	assert(fid!=fidNil);
	assert(hFreeList);
	
	if (!(qFreeList = _GLOBALLOCK(hFreeList)))
	{	SetErrCode(lpErrb, E_OUTOFMEMORY);
		goto exit0;
	}
	
	wMaxBlocks=qFreeList->flh.wMaxBlocks;
	wNumBlocks=qFreeList->flh.wNumBlocks;
	dwLostBytes=qFreeList->flh.dwLostBytes;
	
	lcbSize = sizeof(FREELISTHDR) + wMaxBlocks * sizeof(FREEITEM);

#ifdef _BIG_E	
	{
		QFREEITEM qCurrent;
		WORD wBlock;
		HANDLE hMem;
		QFREELIST qFreeListMem;
	
		if (!(hMem = _GLOBALALLOC(GMEM_MOVEABLE, lcbSize)))
		{
		 	SetErrCode(lpErrb, E_OUTOFMEMORY);
			goto exit0;
		}

		qFreeListMem = (QFREELIST)_GLOBALLOCK(hMem);
		qCurrent = qFreeListMem->afreeitem;
		
		qFreeListMem->flh.wNumBlocks = SWAPWORD( qFreeList->flh.wNumBlocks );
		qFreeListMem->flh.wMaxBlocks = SWAPWORD( qFreeList->flh.wMaxBlocks );
		qFreeListMem->flh.dwLostBytes = SWAPLONG( qFreeList->flh.dwLostBytes );

		
		for (wBlock=0;wBlock<wNumBlocks;wBlock++)
		{
	 	 	qCurrent->foStart.dwOffset = SWAPLONG(qCurrent->foStart.dwOffset);
			qCurrent->foStart.dwHigh = SWAPLONG(qCurrent->foStart.dwHigh);
			qCurrent->foBlock.dwOffset = SWAPLONG(qCurrent->foBlock.dwOffset);
			qCurrent->foBlock.dwHigh = SWAPLONG(qCurrent->foBlock.dwHigh);
		}

		lcbWritten=LcbWriteFid(fid, qFreeListMem, lcbSize, lpErrb);

		_GLOBALUNLOCK(hMem);
		_GLOBALFREE(hMem);
	}
#else
		lcbWritten=LcbWriteFid(fid, qFreeList, lcbSize, lpErrb);
#endif // _BIG_E
	
	_GLOBALUNLOCK(hFreeList);

	exit0:
		return lcbWritten;
 	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\btree\btmaprd.c ===
/*****************************************************************************
 *                                                                            *
 *  BTMAPRD.C                                                                 *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1989 - 1994.                          *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  Routines to read btree map files.                                         *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  UNDONE                                                    *
 *                                                                            *
 *****************************************************************************/

/*****************************************************************************
 *
 *  Revision History:  Created 12/15/89 by KevynCT
 *
 *  08/21/90  JohnSc autodocified
 *   3/05/97     erinfox Change errors to HRESULTS
 *
 *****************************************************************************/

static char s_aszModule[] = __FILE__;   /* For error report */

#include <mvopsys.h>
#include <orkin.h>
#include <iterror.h>
#include <misc.h>
#include <wrapstor.h>
#include <_mvutil.h>


/*----------------------------------------------------------------------------*
 | Public functions                                                           |
 *----------------------------------------------------------------------------*/

/***************************************************************************
 *
- Function:     HmapbtOpenHfs(hfs, szName)
-
 * Purpose:      Returns an HMAPBT for the btree map named szName.
 *
 * ASSUMES
 *   args IN:    hfs     - file system wherein lives the btree map file
 *               szName  - name of the btree map file
 *
 * PROMISES
 *   returns:    NULL on error (call RcGetFSError()); or a valid HMAPBT.
 * +++
 *
 * Method:       Opens the file, allocates a hunk of memory, reads the
 *               file into the memory, and closes the file.
 *
 ***************************************************************************/
HMAPBT FAR PASCAL HmapbtOpenHfs(HFS hfs, LPWSTR szName, PHRESULT phr)
{
	HF      hf;
	HMAPBT  hmapbt;
	QMAPBT  qmapbt;
	FILEOFFSET foSize;
	
	if(hfs == NULL)
	{
		SetErrCode (phr, E_INVALIDARG);
		return NULL;
	}

	hf = HfOpenHfs(hfs, szName, fFSOpenReadOnly, phr);
	if(hf == hfNil)
		return NULL;

	foSize = FoSizeHf(hf, phr);
	if (foSize.dwHigh)
	{
exit0:
	RcCloseHf(hf);
	return(NULL);
    }
	
	if ((hmapbt =  _GLOBALALLOC(GMEM_ZEROINIT|GMEM_SHARE| GMEM_MOVEABLE,
	    foSize.dwOffset)) == NULL)
    {
	SetErrCode (phr, E_OUTOFMEMORY);
	goto exit0;
    }
		

	qmapbt = (QMAPBT) _GLOBALLOCK(hmapbt);
	FoSeekHf(hf, foNil, wFSSeekSet, phr);
	if(LcbReadHf( hf, qmapbt, (LONG)foSize.dwOffset, phr) != (LONG)foSize.dwOffset )
	{
	SetErrCode (phr, E_FILEINVALID);
		_GLOBALUNLOCK(hmapbt);
		_GLOBALFREE(hmapbt);
	goto exit0;
	}
	else
	{

		/* Swap the data for MAC */
#ifdef _BIG_E
		int i;
		QMAPREC qMapRec;

		qmapbt->cTotalBk = SWAPWORD(qmapbt->cTotalBk);
		for(i =qmapbt->cTotalBk, qMapRec = qmapbt->table; i >0; i--)
		{
			qMapRec->cPreviousKeys = SWAPLONG(qMapRec->cPreviousKeys);
			qMapRec->bk = SWAPLONG(qMapRec->bk);
			qMapRec++;
		}
#endif
		_GLOBALUNLOCK(hmapbt);
	}
	RcCloseHf(hf);
	return hmapbt;
}

/***************************************************************************
 *
- Function:     RcCloseHmapbt(hmapbt)
-
 * Purpose:      Get rid of a btree map.
 *
 * ASSUMES
 *   args IN:    hmapbt  - handle to the btree map
 *
 * PROMISES
 *   returns:    rc
 *   args OUT:   hmapbt  - no longer valid
 * +++
 *
 * Method:       Free the memory.
 *
 ***************************************************************************/
HRESULT FAR PASCAL RcCloseHmapbt(HMAPBT hmapbt)
{
	if(hmapbt != NULL)
	{
		_GLOBALFREE(hmapbt);
		return S_OK;
	}
	else
		return (E_INVALIDARG);
}

/***************************************************************************
 *
- Function:     RcIndexFromKeyHbt(hbt, hmapbt, ql, key)
-
 * Purpose:      
 *
 * ASSUMES
 *   args IN:    hbt     - a btree handle
 *               hmapbt  - map to hbt
 *               key     - key
 *   globals IN: 
 *   state IN:   
 *
 * PROMISES
 *   returns:    rc
 *   args OUT:   ql      - gives you the ordinal of the key in the btree
 *                         (i.e. key is the (*ql)th in the btree)
 * +++
 *
 * Method:       Looks up the key, uses the btpos and the hmapbt to
 *               determine the ordinal.
 *
 ***************************************************************************/
HRESULT FAR PASCAL RcIndexFromKeyHbt(HBT hbt, HMAPBT hmapbt, QL ql, KEY key)
{

	BTPOS     btpos;
	QMAPBT    qmapbt;
	HRESULT        fRet;
	SHORT     i;

	if(( hbt == NULL) || ( hmapbt == NULL ) )
		return (E_INVALIDARG);

	qmapbt = (QMAPBT) _GLOBALLOCK(hmapbt);
	if(qmapbt->cTotalBk == 0)
	{
		fRet = E_FAIL;
exit0:
	_GLOBALUNLOCK (hmapbt);
		return fRet;
	}

	if ((fRet = RcLookupByKey(hbt, key, &btpos, NULL)) == S_OK) 
	{
	for(i = 0; i < qmapbt->cTotalBk; i++)
	{
		if (qmapbt->table[i].bk == btpos.bk)
		    break;
	}
	
	if (i == qmapbt->cTotalBk)
		{
		/* Something is terribly wrong, if we are here */
		fRet = E_ASSERT;
		goto exit0;
		}

	*ql = qmapbt->table[i].cPreviousKeys + btpos.cKey;
	}
	goto exit0;
}


/***************************************************************************
 *
- Function:     RcKeyFromIndexHbt(hbt, hmapbt, key, li)
-
 * Purpose:      Gets the (li)th key from a btree.
 *
 * ASSUMES
 *   args IN:    hbt     - btree handle
 *               hmapbt  - map to the btree
 *               li      - ordinal
 *
 * PROMISES
 *   returns:    rc
 *   args OUT:   key     - (li)th key copied here on success
 * +++
 *
 * Method:       We roll our own btpos using the hmapbt, then use
 *               RcLookupByPos() to get the key.
 *
 ***************************************************************************/
HRESULT FAR PASCAL RcKeyFromIndexHbt( HBT hbt,  HMAPBT hmapbt, 
    KEY key, int iLen, LONG li)
{
	BTPOS        btpos;
	BTPOS        btposNew;
	QMAPBT       qmapbt;
	SHORT        i;
	LONG         liDummy;
    HRESULT           fRet;

	if ((hbt == NULL) || (hmapbt == NULL))
		return E_INVALIDARG;

	/* Given index N, get block having greatest PreviousKeys < N.
	 * Use linear search for now.
	 */

	qmapbt = (QMAPBT) _GLOBALLOCK(hmapbt);
	if(qmapbt->cTotalBk == 0)
	{
		_GLOBALUNLOCK(hmapbt);
		return (E_FAIL);
    }

	for(i = 0 ;; i++)
	{
		if(i + 1 >= qmapbt->cTotalBk)
		    break;
		if(qmapbt->table[i+1].cPreviousKeys >= li)
		    break;
	}

	btpos.bk   = qmapbt->table[i].bk;
	btpos.cKey = 0;
	btpos.iKey = 2 * sizeof(BK);  /* start at the zero-th key */

	_GLOBALUNLOCK(hmapbt);

	/*
	 * Scan the block for the n-th key
	 */

	if ((fRet = RcOffsetPos( hbt, &btpos,
	(LONG)(li - qmapbt->table[i].cPreviousKeys),
	&liDummy, &btposNew)) != S_OK)
		return fRet;

	return RcLookupByPos(hbt, &btposNew, key, iLen, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\btree\globdata.c ===
static char s_aszModule[] = __FILE__;	/* For error report */

#include <mvopsys.h>

#ifndef _MAC
#include <dos.h>
#endif

#if 0
#include <winmm.h>
#else
#include <mmsystem.h>
#endif // _NT

#include <orkin.h>
#include <iterror.h>
#include <misc.h>
#include <wrapstor.h>
#include <_mvutil.h>


/* Put all functions into the same segment to avoid memory fragmentation
 * and load time surplus for the MAC
 */
// #pragma code_seg ("MVFS")

#ifndef _MAC
/***************************************************************************
 *
 *		                           Global Data
 *
 ***************************************************************************/

/* these arrays get indexed by wRead and wWrite |ed together */

WORD _rgwOpenMode[] = {
	(WORD)-1,
	OF_READ,
	OF_WRITE,
	OF_READWRITE,
	};

WORD _rgwPerm[] =
	{
	(WORD)-1,
	_A_RDONLY,
	_A_NORMAL,
	_A_NORMAL,
	};

/*****************************************************************************
 *
 *       RcFromLoadLibErr
 *
 *       This table maps errors from Window's LoadLibrary to HRESULT values.
 *
 *****************************************************************************/
HRESULT	RcFromLoadLibErr[HINSTANCE_ERROR] = {
	E_BADVERSION,     //0
	E_FAIL,         //1
	E_NOTEXIST,       //2
	E_NOTEXIST,       //3
	E_FAIL,         //4
	E_NOPERMISSION,	//5
	E_FAIL,         //6
	E_FAIL,         //7
	E_OUTOFMEMORY,         //8
	E_FAIL,         //9
	E_BADVERSION,     //10
	E_BADVERSION,     //11
	E_BADVERSION,     //12
	E_BADVERSION,     //13
	E_BADVERSION,     //14
	E_BADVERSION,     //15
	E_BADVERSION,     //16
	E_FAIL,         //17
	E_FAIL,         //18
	E_BADVERSION,     //19
	E_BADVERSION,     //20
	E_BADVERSION,     //21
	E_FAIL,         //22
	E_FAIL,         //23
	E_FAIL,         //24
	E_FAIL,         //25
	E_FAIL,         //26
	E_FAIL,         //27
	E_FAIL,         //28
	E_FAIL,         //29
	E_FAIL,         //30
	E_FAIL          //31
};

#endif

WORD _rgwShare[] =
	{
	OF_SHARE_EXCLUSIVE,
	OF_SHARE_DENY_WRITE,
	OF_SHARE_DENY_READ,
	OF_SHARE_DENY_NONE,
	};

HANDLE        hMmsysLib = NULL;       // handle to the loaded mmio library
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\filesys\subfile.c ===
/*****************************************************************************
 *                                                                            *
 *  VFILE.C                                                                   *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1995.                                 *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  "Virtual File" functions - Actual data may reside in a parent file at     *
 *	any given offset, or in a temp file.									  *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  davej                                                     *
 *****************************************************************************
 * Notes: 
 *
 *  #ifndef ITWRAP added around all calls that have a wrapped implementation
 *  (wrapstor.lib provides calls into the InfoTech IStorage/IStream 
 *   implementation)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  Created 07/17/95 - davej
 *
 *****************************************************************************/

static char s_aszModule[] = __FILE__;    /* For error report */

#include <mvopsys.h>
#include <iterror.h>
#include <orkin.h>
#include <misc.h>
#include <wrapstor.h>
#include <_mvutil.h>

/*****************************************************************************
 *                                                                            *
 *                               Globals                                      *
 *                                                                            *
 *****************************************************************************/

SF FAR * mv_gsfa = NULL;			// Subfile headers (better/faster than globalalloc'ing them)
LONG mv_gsfa_count = -1L;			// User count, equals number of MV titles opened or -1 for not init
CRITICAL_SECTION mv_gsfa_cs; 		// Ensure accessing the array is OK in multi-threaded environment

/*****************************************************************************
 *                                                                            *
 *                               Defines                                      *
 *                                                                            *
 *****************************************************************************/

/*****************************************************************************
 *                                                                            *
 *                               Prototypes                                   *
 *                                                                            *
 *****************************************************************************/

#ifdef _DEBUGMVFS
void DumpMV_GSFA(void);
#endif
/***************************************************************************
 *                                                                           *
 *                         Private Functions                                 *
 *                                                                           *
 ***************************************************************************/

/***************************************************************************
 *
 *	@doc	PRIVATE
 *
 *	@func	int PASCAL NEAR | SFHeaderSize |
 *		Get the 'extra' header size for a sub file (the part that lives with
 *		the file data itself)
 *
 *  @parm	QSFH | qsfh |
 *		Pointer to subfile header block (contains file length and flags)
 *
 *	@rdesc	Return the number of bytes of header that exist before the 
 *		file data
 *
 *	@comm
 *		Currently this only returns zero, but if at the file's starting location,
 *		there exists a header, (check the <p qsfh> <e bFlags> element to determine
 *		the number of bytes being used for the file header.
 *
 ***************************************************************************/
 
int PASCAL NEAR SFHeaderSize(QSFH qsfh)
{
 	return 0; // based on the qsfh->bFlags value, determine header size, or
 			  // if other header info exists before the file data	
}

/***************************************************************************
 *
 *	@doc	PRIVATE
 *
 *	@func	FILEOFFSET PASCAL NEAR | GetFreeBlock |
 *		Get the file offset of a free block of the given size
 *
 *  @parm	QFSHR | qfshr |
 *		Pointer to file system header
 *
 *  @parm	FILEOFFSET | foBlockSize |
 *		Size of block to retrieve offset to
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	Returns valid file offset, or foNil if an error occurs
 *
 *	@comm
 *		state IN:   
 *		state OUT:	Free list no longer contains the given block
 *		Notes:      
 *
 ***************************************************************************/
 
FILEOFFSET PASCAL NEAR GetFreeBlock(QFSHR qfshr,FILEOFFSET foBlock,PHRESULT phr)
{					
	HRESULT errb;
	FILEOFFSET foStart;
	
	assert(qfshr->hfl);		

	foStart = FreeListGetBestFit(qfshr->hfl,foBlock,&errb);
	if (errb!=S_OK)
	{
	 	FILEOFFSET foLastBlock;
		FILEOFFSET foLastBlockSize;
	 	
	 	// If last free list block goes to end of file, start there
		// Last block is automatically removed in the GetLastBlock call
		if (FreeListGetLastBlock(qfshr->hfl,&foLastBlock,&foLastBlockSize,qfshr->fsh.foEof)==S_OK)
		{
			foStart=foLastBlock;
			qfshr->fsh.foEof=FoAddFo(foLastBlock,foBlock);
		}
		else
		{
			// otherwise allocate it from end
			foStart=qfshr->fsh.foEof;
			qfshr->fsh.foEof=FoAddFo(qfshr->fsh.foEof,foBlock);					
		}
	}
	
	return foStart;
}


/***************************************************************************
 *
 *	@doc	PRIVATE
 *
 *	@func	short PASCAL NEAR | GetNewHf |
 *		Get a new handle to a subfile.  These handles are actually 
 *		indices into the mv_gsfa global array.
 *
 *  @parm	LPCSTR | szFilename |
 *		Filename to use for hashing an Hf index
 *
 *	@rdesc	Returns valid index of a subfile, or hfNil for error
 *
 *	@comm
 *		Array is not modified, so calling twice will give same index
 *
 ***************************************************************************/

static int giMaxSubFiles=MAXSUBFILES;

short PASCAL NEAR GetNewHf(LPCSTR szFilename)
{
	int iLen;
	unsigned short i,uiStart=0;
	int iMaxFilled;

	iMaxFilled=giMaxSubFiles-1;
	
	_ENTERCRITICALSECTION(&mv_gsfa_cs);

	assert(mv_gsfa);
	assert(mv_gsfa_count);

	iLen=(szFilename)?min(8,lstrlen(szFilename)):0;
	while (iLen--)
	{
	 	uiStart=(uiStart<<1)^(*(szFilename++));
	}
	i=uiStart%=giMaxSubFiles;
	
	while (mv_gsfa[i].hsfb)
	{
	 	i=(i+1)%giMaxSubFiles;
		if (!(--iMaxFilled))
		{	
			// Increase our space!
			HANDLE hNew;
			
			giMaxSubFiles+=64;
			_GLOBALUNLOCK(GlobalHandle(mv_gsfa));
			if ((hNew=_GLOBALREALLOC(GlobalHandle(mv_gsfa),sizeof(SF)*giMaxSubFiles,GMEM_MOVEABLE|GMEM_ZEROINIT))==NULL)
			{
				giMaxSubFiles-=64;
				i=0;
				break;			
			}
			mv_gsfa=(SF FAR *)_GLOBALLOCK(hNew);
			i=uiStart%giMaxSubFiles;
			iMaxFilled=giMaxSubFiles-1;
		}
	}

	_LEAVECRITICALSECTION(&mv_gsfa_cs);

#ifdef _DEBUGMVFS	
	DPF2("GetNewHf: subfile '%s' is hf %d\n", (szFilename) ? szFilename : "NULL", i);
	DumpMV_GSFA();
#endif
	return i;
}

/***************************************************************************
 *
 *	@doc	PRIVATE
 *
 *	@func	KEY PASCAL FAR | NewKeyFromSz |
 *		Convert a filename to a Key type for the file system btree.  Currently
 *		a key type is a variable byte length size followed by the chars. 
 *
 *  @parm	LPCSTR | szName |
 *		Name to convert
 *
 *	@rdesc	Returns valid KEY.
 *
 *	@comm
 *		state IN:   
 *		state OUT:	String is allocated in the global string memory area
 *		Notes:  Must call DisposeMemory((LPSTR)key) when finished using.
 *
 ***************************************************************************/

KEY PASCAL FAR EXPORT_API NewKeyFromSz(LPCSTR sz)
{
	int iLLen;
	LPSTR szKey;
	FILEOFFSET foLen;
	
	foLen.dwHigh=0;
	foLen.dwOffset=lstrlen(sz);
	
	szKey=NewMemory((WORD)(foLen.dwOffset+5));
	iLLen=FoToSz(foLen, szKey);
	lstrcpy(szKey+iLLen,sz);
	return (KEY)szKey;
}

// Returns number of bytes used in the fr struct
// Sets fr.szData to the File Offset, Length, and status byte

/***************************************************************************
 *
 *	@doc	PRIVATE
 *
 *	@func	WORD PASCAL NEAR | SetFrData |
 *		Set the szData field of pfr to the start, size, and byte values.
 *
 *  @parm	FILE_REC FAR * | pfr |
 *		Pointer to FILE_REC structure
 *
 *  @parm	FILEOFFSET | foStart |
 *		Starting address of a file
 *
 *  @parm	FILEOFFSET | foSize |
 *		Size of a file
 *
 *  @parm	BYTE | bFlags |
 *		The file flags (not used at the moment)
 *
 *	@rdesc	Returns the number of bytes used in the fr struct after FILEOFFSETs
 *		are converted to their equivalent variable-length byte values.  This is
 *		the amount of space the filerec takes in the system btree.
 *
 *	@comm
 *		<p pfr> is set to the foStart, foSize, and bFlags values.  The
 *		<e szData> field of <p pfr> is set to the compressed version of the
 *		data (3 to 19 bytes in size for the three fields).
 *
 ***************************************************************************/

WORD PASCAL NEAR SetFrData(FILE_REC FAR * pfr, FILEOFFSET foStart, FILEOFFSET foSize, BYTE bFlags)
{
	WORD wTotalLen;

	assert(pfr);
	wTotalLen=FoToSz(foStart, pfr->szData);
	wTotalLen+=FoToSz(foSize, pfr->szData+wTotalLen);
	pfr->szData[wTotalLen++]=(char)bFlags;
	pfr->foStart=foStart;
	pfr->foSize=foSize;
	pfr->bFlags=bFlags;
	return wTotalLen;
}


/***************************************************************************
 *
 *	@doc	PRIVATE
 *
 *	@func	WORD PASCAL NEAR | GetFrData |
 *		Get the size, start, and flags fields from the szData field of the
 *		FILE_REC.
 *
 *  @parm	FILE_REC FAR * | pfr |
 *		Pointer to FILE_REC structure
 *
 *	@rdesc	nothing.
 *
 *	@comm
 *		All the fields are set based on the szData compressed 
 *		version of the offset, size, and flags from the <p pfr> <e szData> field.
 *
 ***************************************************************************/

void PASCAL FAR EXPORT_API GetFrData(FILE_REC FAR *pfr)
{
	LPSTR szCursor;
	
	assert(pfr);
	szCursor=pfr->szData;
	pfr->foStart=FoFromSz(szCursor);
	ADVANCE_FO(szCursor);
	pfr->foSize=FoFromSz(szCursor);
	ADVANCE_FO(szCursor);
	pfr->bFlags=*szCursor;
}

/***************************************************************************
 *
 *	@doc	PRIVATE
 *
 *	@func	HF PASCAL NEAR | HfOpenFileHfsInternal |
 *		Open or Create a non-system subfile.  Use the public HfOpenHfs, 
 *		HfCreateFileHfs, and HfOpenHfsReserve functions, not this one.
 *
 *  @parm	HFS | hfs|
 *		File system for this sub file.
 *
 *  @parm	LPCSTR | szFilename |
 *		Name of file
 *
 *  @parm	BYTE | bFlags |
 *		Any of the following HFOPEN_ flags (except for HFOPEN_SYSTEM)
 *	@flag	HFOPEN_READWRITE 	| (0x01)	Open a file for reading and writing.
 *	@flag	HFOPEN_READ 		| (0x02)	Open a file for reading only.
 *	@flag	HFOPEN_CREATE		| (0x04)	Create a new file, or truncate an 
 * 											existing file.
 *	@flag	HFOPEN_NOTEMP		| (0x10)	If file is opened for read/write, do
 *											not make a temporary file if possible,
 *											so edits to the file are made directly
 *											in the file system.
 *	@flag	HFOPEN_FORCETEMP	| (0x20)	A temp file is always created (space
 *											permitting) in read-only mode.
 *	@flag	HFOPEN_ENABLELOGGING| (0x40)	Logging usage of this file will be 
 *											enabled.											
 *
 *  @parm	FILEOFFSET | foReserve |
 *		When creating or opening a r/w file, reserve this amount of space
 *		for the file in the file system.
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	Returns a valid HF, or hfNil if an error.
 *
 *	@comm
 *		state IN:   
 *		state OUT:  Valid HF 
 *
 ***************************************************************************/
#ifndef ITWRAP
HF PASCAL NEAR HfOpenFileHfsInternal(HFS hfs, LPCSTR sz,
    BYTE bFlags, FILEOFFSET foReserve, PHRESULT phr)
{
#ifdef MOSMAP // {
	// Disable function
	if (bFlags & (HFOPEN_CREATE|HFOPEN_READWRITE))
	{	
		SetErrCode (phr, ERR_NOTSUPPORTED);
		return hfNil ;
	}
#else // } {
	DWORD   hf;
	QSFB	qsfb;
	QFSHR  	qfshr;
	HRESULT		rc;
	FILE_REC fr;
	BOOL    bShouldInsert=FALSE;
	HSFB 	hsfbFound=NULL;  
	KEY key;
	
	if (hfs == NULL || (qfshr = _GLOBALLOCK(hfs)) == NULL)
	{
	    SetErrCode (phr, E_INVALIDARG);
        return hfNil;
	}
  
  	_ENTERCRITICALSECTION(&qfshr->cs);  
	key = NewKeyFromSz(sz);	
	
	if (bFlags&HFOPEN_CREATE)
	{	bFlags|=HFOPEN_READWRITE;
	 	if (bFlags&HFOPEN_READ)
		{
			SetErrCode(phr, E_INVALIDARG);
			goto error_return;
		}
	}
	
	// Reserving space implies no temporary file if possible
	if (!FoIsNil(foReserve))
	{
	 	bFlags|=HFOPEN_NOTEMP;
	}
	else // Conversly, reserving NO space implies a temporary file
	{	
	   bFlags&=~HFOPEN_NOTEMP;
	}

	assert(!(bFlags&HFOPEN_SYSTEM));

	// make sure file system is writable
	if ((bFlags&(HFOPEN_CREATE|HFOPEN_READWRITE)) && (qfshr->fsh.bFlags&FSH_READONLY))
	{
		SetErrCode (phr, E_NOPERMISSION);
		goto error_return;
	}

	rc = RcLookupByKey(qfshr->hbt, key, NULL, &fr);
	
	// File already opened and being written to for first time
	// or file locked, then we exit with E_NOPERMISSION
	if (rc==S_OK)
	{
	 	GetFrData(&fr);
		if ((fr.bFlags&SFH_INVALID) || ((fr.bFlags&SFH_LOCKED) && (bFlags&HFOPEN_READWRITE)))
		{	
			SetErrCode(phr, E_NOPERMISSION);
			goto error_return;
		}
	}
	
	if (bFlags&HFOPEN_CREATE)
	{
		if (rc == S_OK)
		{
			// Already exists, let's truncate to zero!!!
			assert(!FoIsNil(fr.foStart));
			//SetErrCode(phr,ERR_EXIST);
			//goto error_return;
		}
		else
		{
		 	// *** OK, Create node with '-1' for 'exclusive'
			SetFrData(&fr,foNil,foNil,SFH_INVALID);
			bShouldInsert = TRUE;				
		}
	}
	else 
	{
		if (rc!=S_OK)
		{
			SetErrCode(phr, rc);
			goto error_return;
		}
	}

	if ((hf=(DWORD)GetNewHf(sz))== hfNil)
	{	
		SetErrCode(phr, ERR_NOHANDLE);		// Out of file handles
		goto error_return;
	}

	mv_gsfa[hf].foCurrent=foNil;

	// Look for file block in opened file list
	if (!(fr.bFlags&SFH_INVALID))
	{	
	 	HSFB hsfb = qfshr->hsfbFirst;
		QSFB qsfb;
		HSFB hsfbNext;

		while ((hsfb) && (!hsfbFound))
		{
		 	qsfb=(QSFB)_GLOBALLOCK(hsfb);

			if (FoEquals(qsfb->foHeader,fr.foStart))
			{
				hsfbFound=hsfb;
			}
			hsfbNext=qsfb->hsfbNext;
			_GLOBALUNLOCK(hsfb);
			hsfb=hsfbNext;
		}
	}

	if (!hsfbFound)
	{
		// Create new subfile block
		FILEOFFSET foExtraSize=foNil;
		
		mv_gsfa[hf].hsfb =  _GLOBALALLOC(GMEM_ZEROINIT|GMEM_SHARE| GMEM_MOVEABLE,
			          (ULONG)sizeof(SFB) + ( sz == NULL ? 0 : lstrlen(sz)));
		qsfb = (QSFB)_GLOBALLOCK(mv_gsfa[hf].hsfb);

		if (mv_gsfa[hf].hsfb == NULL)
		{
			SetErrCode (phr, E_OUTOFMEMORY);
			goto error_return;
		}
 
 		lstrcpy(qsfb->rgchKey, sz);
		qsfb->bOpenFlags=bFlags;
		
		qsfb->foHeader=fr.foStart;
		if (bFlags&HFOPEN_ENABLELOGGING)
			qsfb->sfh.bFlags|=SFH_LOGGING;

		qsfb->hfs = hfs;
		qsfb->wLockCount=1;
		
		if (!FoIsNil(qsfb->foHeader))
		{
			qsfb->sfh.foBlockSize=fr.foSize;
			qsfb->sfh.bFlags=fr.bFlags;
		}
		
		// If given foReserve, try to reserve space if file already lives in fs,
		// or allocate space now for all of reserve, and give it to file
		// if we can't reserve, then even though notemp is specified, a temp will
		// be created at write time, so force it to temp here in that case.

		if (!FoIsNil(foReserve))
		{
			assert(qfshr->hfl);
		
		 	if (FoCompare(foReserve,qsfb->sfh.foBlockSize)>0)
		 	{
				if (!(FoIsNil(qsfb->foHeader)))
				{
					// If file exists already, try to extend file
					foExtraSize = FreeListGetBlockAt(qfshr->hfl,FoAddFo(qsfb->foHeader,qsfb->sfh.foBlockSize),phr);
					// VFileOpen will handle things properly if file fits or not
					if (FoCompare(FoAddFo(qsfb->sfh.foBlockSize,foExtraSize),foReserve)<0)
					{
					 	bFlags&=(~HFOPEN_NOTEMP);
					}
				}
				else
				{
					// New file, try to get free space for file
					// We reserve amount we want plus subfile file header size
					qsfb->foHeader=GetFreeBlock(qfshr,FoAddDw(foReserve,SFHeaderSize(&qsfb->sfh)),NULL);
					foExtraSize=foReserve;
				}
			}
		}
	
		if ((bFlags&HFOPEN_READ) || (bFlags&HFOPEN_NOTEMP))
		{	
			if (bFlags&HFOPEN_CREATE)
			{
				qsfb->hvf=VFileOpen(qfshr->fid,FoAddDw(qsfb->foHeader,SFHeaderSize(&qsfb->sfh)),
					foNil,FoAddFo(qsfb->sfh.foBlockSize,foExtraSize),
					((bFlags&HFOPEN_READWRITE)?VFOPEN_READWRITE:VFOPEN_READ)|VFOPEN_ASFID,&qfshr->sb,phr);
			}
			else
			{
				qsfb->hvf=VFileOpen(qfshr->fid,FoAddDw(qsfb->foHeader,SFHeaderSize(&qsfb->sfh)),
					qsfb->sfh.foBlockSize,foExtraSize,
					((bFlags&HFOPEN_READWRITE)?VFOPEN_READWRITE:VFOPEN_READ)|VFOPEN_ASFID,&qfshr->sb,phr);
			}
		}
		else
		{
			if (bFlags&HFOPEN_CREATE)
			{
				qsfb->hvf=VFileOpen(qfshr->fid,FoAddDw(qsfb->foHeader,SFHeaderSize(&qsfb->sfh)),
					foNil,FoAddFo(qsfb->sfh.foBlockSize,foExtraSize),VFOPEN_ASTEMP|VFOPEN_READWRITE,&qfshr->sb,phr);
			}
			else
			{
				qsfb->hvf=VFileOpen(qfshr->fid,FoAddDw(qsfb->foHeader,SFHeaderSize(&qsfb->sfh)),
					qsfb->sfh.foBlockSize,foExtraSize,VFOPEN_ASTEMP|VFOPEN_READWRITE,&qfshr->sb,phr);
			}
		}
		
		if (!qsfb->hvf)
		{	
			SetErrCode(phr, ERR_NOHANDLE); 
			exit1:
				_GLOBALUNLOCK(mv_gsfa[hf].hsfb);
				_GLOBALFREE(mv_gsfa[hf].hsfb);
				mv_gsfa[hf].hsfb=NULL;
				goto error_return;
		}
		
		// Extend block size to account for any extra allocation we did
		qsfb->sfh.foBlockSize=FoAddFo(qsfb->sfh.foBlockSize,foExtraSize);

		qsfb->hsfbNext = qfshr->hsfbFirst;
		qfshr->hsfbFirst = mv_gsfa[hf].hsfb;
	
		if (bShouldInsert)
		{	
			SetFrData(&fr,foNil,foNil,SFH_INVALID);
			//fr.lifBase=lifNil;
			if ((rc = RcInsertHbt(qfshr->hbt, key, &fr))!=S_OK)
			{	// some other error!
			 	VFileAbandon(qsfb->hvf);
				VFileClose(qsfb->hvf);				
				goto exit1;			 	
			}
		}
	
	}
	else
	{	
		// Ignoring reserve if found, we could call VFileSetEOF though ?!?

		if (bFlags & HFOPEN_READWRITE)
		{
			// Trying to write to a file that's already opened for read
			SetErrCode(phr, E_NOPERMISSION);
			goto error_return;		 	
		}
				
		mv_gsfa[hf].hsfb=hsfbFound;
		qsfb = (QSFB)_GLOBALLOCK(mv_gsfa[hf].hsfb);
		qsfb->wLockCount++;		
	}

	_GLOBALUNLOCK(mv_gsfa[hf].hsfb);

	// File header always in RAM, so we never place it into the temp file

	DisposeMemory((LPSTR)key);
	_LEAVECRITICALSECTION(&qfshr->cs);
	_GLOBALUNLOCK(hfs);

#ifdef _DEBUGMVFS	
	DPF2("HfOpenInternal: hf=%d, sz='%s'\n", hf, sz);
	DumpMV_GSFA();
#endif

	return (HF)hf;

error_return:
	DisposeMemory((LPSTR)key);
	_LEAVECRITICALSECTION(&qfshr->cs);
	_GLOBALUNLOCK(hfs);
	return hfNil;
#endif //}
}
#endif
	
/***************************************************************************
 *
 *	@doc	PRIVATE
 *
 *	@func	HF PASCAL NEAR | HfOpenSystemFileHfsInternal |
 *		Open or Create a system subfile.  Not for civilians.
 *
 *  @parm	HFS | hfs|
 *		File system for this sub file.
 *
 *  @parm	BYTE | bFlags |
 *		Any of the following HFOPEN_ flags (HFOPEN_SYSTEM required)
 *	@flag	HFOPEN_READWRITE 	| (0x01)	Open a file for reading and writing.
 *	@flag	HFOPEN_READ 		| (0x02)	Open a file for reading only.
 *	@flag	HFOPEN_CREATE		| (0x04)	Create a new file, or truncate an 
 * 											existing file.
 *	@flag	HFOPEN_SYSTEM		| (0x08)	Open or create a system file.  Only one
 *											system file is permitted per file system,
 *											and it is the system directory btree.
 *	@flag	HFOPEN_NOTEMP		| (0x10)	If file is opened for read/write, do
 *											not make a temporary file if possible,
 *											so edits to the file are made directly
 *											in the file system.
 *	@flag	HFOPEN_FORCETEMP	| (0x20)	A temp file is always created (space
 *											permitting) in read-only mode.
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	Returns a valid HF, or hfNil if an error.
 *
 ***************************************************************************/
#ifndef ITWRAP
HF PASCAL NEAR HfOpenSystemFileHfsInternal(HFS hfs, BYTE bFlags, PHRESULT phr)
{
#ifdef MOSMAP // {
	// Disable function
	if (bFlags & (HFOPEN_CREATE|HFOPEN_READWRITE))
	{	
		SetErrCode (phr, ERR_NOTSUPPORTED);
		return hfNil ;
	}
#else // } {
	DWORD   hf;
	QSFB	qsfb;
	QFSHR  	qfshr;
	//BOOL    bShouldInsert=FALSE;
	HSFB hsfbFound=NULL;  // when valid, use this instead of new one		

	if (hfs == NULL || (qfshr = _GLOBALLOCK(hfs)) == NULL)
	{
	    SetErrCode (phr, E_INVALIDARG);
        return hfNil;
	}
    
	_ENTERCRITICALSECTION(&qfshr->cs);

	if (bFlags&HFOPEN_CREATE)
	{	bFlags|=HFOPEN_READWRITE;
	 	if (bFlags&HFOPEN_READ)
		{
			SetErrCode(phr, E_INVALIDARG);
			goto error_return;
		}
	}
	assert(bFlags&HFOPEN_SYSTEM);

	if ((bFlags&(HFOPEN_CREATE|HFOPEN_READWRITE)) && (qfshr->fsh.bFlags & FSH_READONLY))
	{
		SetErrCode (phr, E_NOPERMISSION);
		goto error_return;
	}

	if ((hf=GetNewHf(NULL))== hfNil)
	{	
		SetErrCode(phr, ERR_NOHANDLE); 	// Out of file handles
		goto error_return;
	}

	// qfshr->fsh.foDirectory is used for system file offset

 	// Only one system file allowed
 	if (bFlags&HFOPEN_CREATE)
 	{	if (!FoIsNil(qfshr->fsh.foDirectory))
		{
			SetErrCode(phr, ERR_EXIST);
			goto error_return;
		}
	}
	else if (FoIsNil(qfshr->fsh.foDirectory))
	{
	 	SetErrCode(phr, E_NOTEXIST);
		goto error_return;
	}

	if (qfshr->hsfbSystem)
	{
	 	if (bFlags&HFOPEN_READWRITE)
		{
		 	SetErrCode (phr, E_NOPERMISSION);
			goto error_return;
		}
		qsfb = (QSFB)_GLOBALLOCK(qfshr->hsfbSystem);
		qsfb->wLockCount++;
	}
	else
	{
		qfshr->hsfbSystem =  _GLOBALALLOC(GMEM_ZEROINIT|GMEM_SHARE| GMEM_MOVEABLE,
		          (ULONG)sizeof(SFB) );
	
		if (qfshr->hsfbSystem == NULL)
		{
			SetErrCode (phr, E_OUTOFMEMORY);
			goto error_return;
		}
		qsfb = (QSFB)_GLOBALLOCK(qfshr->hsfbSystem);

		qsfb->bOpenFlags=bFlags;

		qsfb->foHeader = qfshr->fsh.foDirectory;
		
		qsfb->hfs = hfs;
		qsfb->wLockCount=1;
		qsfb->hsfbNext=NULL; // always since only one sys file
		if (!FoIsNil(qsfb->foHeader))
		{
		 	qsfb->sfh=qfshr->fsh.sfhSystem;
		}
	
		// System file, only time we open it to Tempfile is if READWRITE & !NOTEMP
				
		if ((bFlags&HFOPEN_READWRITE) && (!(bFlags&HFOPEN_NOTEMP)))
			qsfb->hvf=VFileOpen(qfshr->fid,FoAddDw(qsfb->foHeader,SFHeaderSize(&qsfb->sfh)),qsfb->sfh.foBlockSize,foNil,
				VFOPEN_ASTEMP|VFOPEN_READWRITE,&qfshr->sb,phr);
		else
			qsfb->hvf=VFileOpen(qfshr->fid,FoAddDw(qsfb->foHeader,SFHeaderSize(&qsfb->sfh)),qsfb->sfh.foBlockSize,foNil,
				((bFlags&HFOPEN_READWRITE)?VFOPEN_READWRITE:VFOPEN_READ)|((bFlags&HFOPEN_FORCETEMP)?VFOPEN_ASTEMP:VFOPEN_ASFID),
				&qfshr->sb,phr);
		
	}
	
	_GLOBALUNLOCK(qfshr->hsfbSystem);
	
	mv_gsfa[hf].foCurrent=foNil;
	mv_gsfa[(DWORD)hf].hsfb = qfshr->hsfbSystem;
	
	// File header always in RAM, so we never place it into the temp file

	_LEAVECRITICALSECTION(&qfshr->cs);
	_GLOBALUNLOCK(hfs);

#ifdef _DEBUGMVFS	
	DPF2("HfOpenSystemInternal: hf=%d, bflags=%d\n", hf, bFlags);
	DumpMV_GSFA();
#endif

	return (HF)hf;

error_return:
	_LEAVECRITICALSECTION(&qfshr->cs);
	_GLOBALUNLOCK(hfs);
	return hfNil;
#endif //}
}
#endif

/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	HF PASCAL FAR | HfOpenHfs |
 *		Open (or create) a subfile that lives in the file system.
 *
 *  @parm	HFS | hfs|
 *		File system.
 *
 *  @parm	LPCSTR | szFilename |
 *		Name of file (length limited to 1/2 the block size given when creating
 *		the file system)
 *
 *  @parm	BYTE | bFlags |
 *		Any of the following HFOPEN_ flags
 *	@flag	HFOPEN_READWRITE 	| (0x01)	Open a file for reading and writing.
 *	@flag	HFOPEN_READ 		| (0x02)	Open a file for reading only.
 *	@flag	HFOPEN_CREATE		| (0x04)	Create a new file, or truncate an 
 * 											existing file.
 *	@flag	HFOPEN_NOTEMP		| (0x10)	If file is opened for read/write, do
 *											not make a temporary file if possible,
 *											so edits to the file are made directly
 *											in the file system.
 *	@flag	HFOPEN_FORCETEMP	| (0x20)	A temp file is always created (space
 *											permitting) in read-only mode.
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	Returns a valid HF, or hfNil if an error.
 *
 ***************************************************************************/
#ifndef ITWRAP
PUBLIC HF PASCAL FAR EXPORT_API HfOpenHfs(HFS hfs, LPCSTR sz,
    BYTE bFlags, PHRESULT phr)
{
	if (!(bFlags&HFOPEN_SYSTEM))
	{
		return HfOpenFileHfsInternal(hfs,sz,bFlags,foNil,phr);
	}
	else
	{
	 	return HfOpenSystemFileHfsInternal(hfs,bFlags,phr);
	}
}
#endif
/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	HF PASCAL FAR | HfCreateFileHfs |
 *		Create a subfile that lives in the file system.  If file already 
 *		exists, it will be truncated to zero first.  This API is left in 
 *		for compatibility - HfOpenHfs may be called with the HFOPEN_CREATE
 *		flag instead.
 *
 *  @parm	HFS | hfs |
 *		File system.
 *
 *  @parm	LPCSTR | szFilename |
 *		Name of file (length limited to 1/2 the block size given when creating
 *		the file system)
 *
 *  @parm	BYTE | bFlags |
 *		Any of the following HFOPEN_ flags (HFOPEN_CREATE implied)
 *	@flag	HFOPEN_READWRITE 	| (0x01)	Open a file for reading and writing.
 *	@flag	HFOPEN_READ 		| (0x02)	Open a file for reading only.
 *	@flag	HFOPEN_CREATE		| (0x04)	Create file (implied)
 *	@flag	HFOPEN_NOTEMP		| (0x10)	If file is opened for read/write, do
 *											not make a temporary file if possible,
 *											so edits to the file are made directly
 *											in the file system.
 *	@flag	HFOPEN_FORCETEMP	| (0x20)	A temp file is always created (space
 *											permitting) in read-only mode.
 *	@flag	HFOPEN_ENABLELOGGING| (0x40)	Logging usage of this file will be 
 *											enabled.											
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	Returns a valid HF, or hfNil if an error.
 *
 ***************************************************************************/
#ifndef ITWRAP
PUBLIC HF PASCAL FAR EXPORT_API HfCreateFileHfs(HFS hfs, LPCSTR sz,
    BYTE bFlags, PHRESULT phr)
{
	bFlags|=HFOPEN_CREATE;
	if (!(bFlags&HFOPEN_SYSTEM))
	{
		return HfOpenFileHfsInternal(hfs,sz,bFlags,foNil,phr);
	}
	else
	{
	 	return HfOpenSystemFileHfsInternal(hfs,bFlags,phr);
	}
}
#endif
/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	HF PASCAL FAR | HfOpenHfsReserve |
 *		Create or open a subfile that lives in the file system, and reserve
 *		some space for the file.  If creating a file, the space is reserved
 *		directly in the file system, and all data is written directly to the
 *		file system.
 *
 *  @parm	HFS | hfs |
 *		File system.
 *
 *  @parm	LPCSTR | szFilename |
 *		Name of file (length limited to 1/2 the block size given when creating
 *		the file system)
 *
 *  @parm	BYTE | bFlags |
 *		Any of the following HFOPEN_ flags:
 *	@flag	HFOPEN_READWRITE 	| (0x01)	Open a file for reading and writing.
 *	@flag	HFOPEN_READ 		| (0x02)	Open a file for reading only.
 *	@flag	HFOPEN_CREATE		| (0x04)	Create a new file, or truncate an 
 * 											existing file.
 *	@flag	HFOPEN_NOTEMP		| (0x10)	If file is opened for read/write, do
 *											not make a temporary file if possible,
 *											so edits to the file are made directly
 *											in the file system.
 *	@flag	HFOPEN_FORCETEMP	| (0x20)	A temp file is always created (space
 *											permitting) in read-only mode.
 *
 *  @parm	FILEOFFSET | foReserve |
 *		Number of bytes to reserve in the file system.  If opening a file
 *		in r/w mode, and the requested space cannot be reserved, the file
 *		will be copied to a temp file transparently.
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	Returns a valid HF, or hfNil if an error.
 *
 *	@comm
 *		Just leave the HFOPEN_NOTEMP and HFOPEN_FORCETEMP flags alone for
 *		the default behavior.
 *		
 *
 ***************************************************************************/
#ifndef ITWRAP
PUBLIC HF PASCAL FAR EXPORT_API HfOpenHfsReserve(HFS hfs, LPCSTR sz,
    BYTE bFlags, FILEOFFSET foReserve, PHRESULT phr)
{
	if (!(bFlags&HFOPEN_SYSTEM))
	{
	 	return HfOpenFileHfsInternal(hfs,sz,bFlags,foReserve,phr);
	}
	else
	{	
		SetErrCode(phr, E_INVALIDARG);
		return hfNil;
	}
	
}
#endif
/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	HRESULT PASCAL FAR | RcCopyDosFileHfs |
 *		Create or open a subfile that lives in the file system, and reserve
 *		some space for the file.  If creating a file, the space is reserved
 *		directly in the file system, and all data is written directly to the
 *		file system.
 *
 *  @parm	HFS | hfs |
 *		File system to receive file.
 *
 *  @parm	LPCSTR | szFsFilename |
 *		Name of file used in the file system (any length is OK -- name does not
 *		have to match the DOS filename).  Max length of filename is 64K.
 *
 *  @parm	LPCSTR | szDosFilename |
 *		Pathname of file to copy.
 *
 *	@parm	BYTE | bExtraFlags |
 *		Set to zero for normal files.  Use HFOPEN_ENABLELOGGING to enable file
 *		for logging.
 *
 *  @parm	PROGFUNC | lpfnProg |
 *		Progress callback function (parameter passed to function is always zero).
 *		Function returns non-zero to interrupt and cancel copy operation.
 *
 *	@rdesc	Returns S_OK if all is OK, else the error code.
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API RcCopyDosFileHfs(HFS hfs, LPCSTR szFsFilename, LPCSTR szDosFilename, BYTE bExtraFlags, PROGFUNC lpfnProg)
{
#ifdef MOSMAP // {
    // Disable function
    return ERR_NOTSUPPORTED;
#else // } {
	FID fidSource;
	HRESULT errb;
	FILEOFFSET foSize;
	FILEOFFSET foTemp;
	DWORD dwT;
	HF hfDest;
	QFSHR qfshr;
	HRESULT rc=S_OK;

	if (szDosFilename==NULL || hfs == NULL || (qfshr = _GLOBALLOCK(hfs)) == NULL)
	{
	    return E_INVALIDARG;
	}  
	
	if ((fidSource=FidOpenFm((FM)szDosFilename,wReadOnly,&errb))==fidNil)
	{
		rc=errb;
		exit0:
			_GLOBALUNLOCK(hfs);
			return rc;
	}
	
	foSize=FoSeekFid(fidSource,foNil,wSeekEnd,&errb);
	FoSeekFid(fidSource,foNil,wSeekSet,&errb);
	
	// insert only the extra flags that we allow here...
	bExtraFlags&=HFOPEN_ENABLELOGGING;

#ifndef ITWRAP
	if ((hfDest=HfOpenFileHfsInternal(hfs,(szFsFilename)?szFsFilename:szDosFilename,
		(BYTE)(HFOPEN_READWRITE|HFOPEN_CREATE|bExtraFlags),
		foSize,&errb))==(HF)hfNil)
#else
	// erinfox: I'm not sure if this is going to work!
	if ((hfDest=HfOpenHfsReserve(hfs,(szFsFilename)?szFsFilename:szDosFilename,
		(BYTE)(HFOPEN_READWRITE|HFOPEN_CREATE|bExtraFlags),
		foSize,&errb))==(HF)hfNil)
#endif
	{
	 	rc=errb;
	 	exit1:
	 		RcCloseFid(fidSource);
			goto exit0;
	}

	_ENTERCRITICALSECTION(&qfshr->sb.cs);

	foTemp.dwHigh=0;

    do
    {
        // perform a progress callback
        if (lpfnProg)  
        {
            if ((*lpfnProg)(0)!=0) 
            {
                rc=E_INTERRUPT;
				exit2:	
					_LEAVECRITICALSECTION(&qfshr->sb.cs);
                    RcCloseHf(hfDest);
					goto exit1;
            }
        }
						  
        if (!foSize.dwHigh)
	        dwT = min((DWORD)qfshr->sb.lcbBuffer, foSize.dwOffset);
		else
			dwT=qfshr->sb.lcbBuffer;

        if (LcbReadFid( fidSource, qfshr->sb.lpvBuffer, (LONG)dwT, &errb) != (LONG)dwT )
        {
            rc=errb;
            break;
        }

        if (LcbWriteHf( hfDest, qfshr->sb.lpvBuffer, (LONG)dwT, &errb) != (LONG)dwT )
        {
            rc=errb;
            break;
        }

        foTemp.dwOffset=dwT;
        foSize=FoSubFo(foSize,foTemp);
    }
    while (!FoIsNil(foSize));

    goto exit2;

#endif // } MOSMAP
}


/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	LONG PASCAL FAR | LcbReadHf |
 *		Read data from a subfile.
 *
 *  @parm	HF | hf |
 *		Handle to a valid subfile.
 *
 *  @parm	LPVOID | lpvBuffer |
 *		Buffer to receive data (>64K OK)
 *
 *  @parm	LONG | lcb |
 *		Number of bytes to read
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	Returns the number of bytes read.  If not lcb, an error occurred.
 *
 *	@comm
 *		The file pointer is incremented by the number of bytes read.  Files
 *		may be larger than 4 gigs, but only 2 gigs at a time maximum can be read.
 *
 ***************************************************************************/
#ifndef ITWRAP
PUBLIC LONG PASCAL FAR EXPORT_API LcbReadHf(HF hf, LPVOID lpvBuffer,
	LONG lcb, PHRESULT phr)
{
 	QSFB	qsfb;
	LONG	lRead=0L;
	QFSHR 	qfshr;

	assert(mv_gsfa);
	assert(mv_gsfa_count);

	if (!FHfValid(hf))
	{
	 	SetErrCode(phr, E_INVALIDARG);
		return 0L;
	}

	if (mv_gsfa[(DWORD)hf].hsfb == NULL || (qsfb = _GLOBALLOCK(mv_gsfa[(DWORD)hf].hsfb)) == NULL)
	{
	    SetErrCode (phr, E_INVALIDARG);
        return 0L;
	}
    
	assert(qsfb->hvf);

	if (qsfb->hfs == NULL || (qfshr = _GLOBALLOCK(qsfb->hfs)) == NULL)
	{
	    SetErrCode (phr, E_INVALIDARG);
        goto exit1;
	}
    
	
	_ENTERCRITICALSECTION(&qfshr->cs);

	lRead = VFileSeekRead(qsfb->hvf, mv_gsfa[(DWORD)hf].foCurrent, lpvBuffer, lcb, phr);
	mv_gsfa[(DWORD)hf].foCurrent=FoAddDw(mv_gsfa[(DWORD)hf].foCurrent,lRead);

	_LEAVECRITICALSECTION(&qfshr->cs);
	_GLOBALUNLOCK(qsfb->hfs);

exit1:	
	_GLOBALUNLOCK(mv_gsfa[(DWORD)hf].hsfb);

	return lRead;
}
#endif
/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	LONG PASCAL FAR | LcbWriteHf |
 *		Write data to a subfile
 *
 *  @parm	HF | hf |
 *		Handle to a valid subfile.
 *
 *  @parm	LPVOID | lpvBuffer |
 *		Buffer to receive data (>64K OK)
 *
 *  @parm	LONG | lcb |
 *		Number of bytes to write
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	Returns the number of bytes written.  If not lcb, an error occurred.
 *
 *	@comm
 *		File pointer is incremented by the number of bytes written.  Only 2 gigs
 *		maximum at one time can be read, but files can be larger than 4 gigs.
 *
 ***************************************************************************/
#ifndef ITWRAP
PUBLIC LONG PASCAL FAR EXPORT_API LcbWriteHf(HF hf, LPVOID lpvBuffer,
	LONG lcb, PHRESULT phr)
{
 	QSFB	qsfb;
	LONG	lWrote=0L;
	QFSHR 	qfshr;

	assert(mv_gsfa);
	assert(mv_gsfa_count);

	if (!FHfValid(hf))
	{
	 	SetErrCode(phr, E_INVALIDARG);
		return 0L;
	}

	if (mv_gsfa[(DWORD)hf].hsfb == NULL || (qsfb = _GLOBALLOCK(mv_gsfa[(DWORD)hf].hsfb)) == NULL)
	{
	    SetErrCode (phr, E_INVALIDARG);
        return 0L;
	}
    
	if (qsfb->bOpenFlags&HFOPEN_READ)
	{
	 	SetErrCode(phr, E_NOPERMISSION);
		goto exit1;
	}

	if (qsfb->hfs == NULL || (qfshr = _GLOBALLOCK(qsfb->hfs)) == NULL)
	{
	    SetErrCode (phr, E_INVALIDARG);
        goto exit1;
	}
    
	assert(qsfb->hvf);
	
	_ENTERCRITICALSECTION(&qfshr->cs);
	
	lWrote = VFileSeekWrite(qsfb->hvf, mv_gsfa[(DWORD)hf].foCurrent, lpvBuffer, lcb, phr);
	mv_gsfa[(DWORD)hf].foCurrent=FoAddDw(mv_gsfa[(DWORD)hf].foCurrent,lWrote);
	
	_LEAVECRITICALSECTION(&qfshr->cs);
	_GLOBALUNLOCK(qsfb->hfs);
	
	exit1:
		_GLOBALUNLOCK(mv_gsfa[(DWORD)hf].hsfb);
		return lWrote;
}
#endif
/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	FILEOFFSET PASCAL FAR | FoSeekHf |
 *		Seeks to a location in the subfile (replaces LSeekHf).  To seek
 *		beyond 4 gigs, use pdwHigh.
 *
 *  @parm	HF | hf |
 *		Handle to a valid subfile.
 *
 *  @parm	FILEOFFSET | foOffset |
 *		File offset to seek to.  For standard 4-byte offsets, the .dwHigh 
 *		member of foOffset should be zero.  When seeking from current
 *		position, and the seek is negative, remember that dwHigh should
 *		also be 0xffff.  Just treat the dwHigh and dwOffset members of
 *		foOffset as the High and Low DWORDS of a quad word.
 *
 *  @parm	WORD | wOrigin |
 *		wFSSeekSet (0), wFSSeekCur (1), or wFSSeekEnd (2).  When Cur or End, 
 *		dwOffset is treated as signed.
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	Returns the offset actually pointed to in the file after seeking.
 *
 *	@comm
 *		The file pointer moved to the given offset, and pdwHigh is
 *		set to the high dword if not NULL.
 *
 ***************************************************************************/
#ifndef ITWRAP
PUBLIC FILEOFFSET PASCAL FAR EXPORT_API FoSeekHf(HF hf, FILEOFFSET foOffset, 
	WORD wOrigin, PHRESULT phr)
{
 	assert(mv_gsfa);
	assert(mv_gsfa_count);
	
	if (phr)
		phr->err=S_OK;

	switch (wOrigin)
	{
	 	case wFSSeekSet:
			mv_gsfa[(DWORD)hf].foCurrent=foOffset;
			break;
		case wFSSeekCur:
			mv_gsfa[(DWORD)hf].foCurrent=FoAddFo(mv_gsfa[(DWORD)hf].foCurrent,foOffset);
			break;
		case wFSSeekEnd:
		{	
			QSFB	qsfb;			
			if (mv_gsfa[(DWORD)hf].hsfb == NULL)
			{
			    SetErrCode (phr, E_INVALIDARG);
				return mv_gsfa[(DWORD)hf].foCurrent;
			}
			if ((qsfb = _GLOBALLOCK(mv_gsfa[(DWORD)hf].hsfb)) == NULL)
			{   SetErrCode (phr, E_OUTOFMEMORY);
				return mv_gsfa[(DWORD)hf].foCurrent;
			}			
    		assert(qsfb->hvf);
			mv_gsfa[(DWORD)hf].foCurrent=FoAddFo(VFileGetSize(qsfb->hvf,phr),foOffset);
			_GLOBALUNLOCK(mv_gsfa[(DWORD)hf].hsfb);
			break;
		}
		default:
			SetErrCode(phr,E_INVALIDARG);
	}
	
	return mv_gsfa[(DWORD)hf].foCurrent;
}
#endif
/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	FILEOFFSET PASCAL FAR | FoTellHf |
 *		Returns position of file pointer.  Replaces LTellHf.  This function
 *		just looks up the file pointer value, so it is fast and can be 
 *		called any time.
 *
 *  @parm	HF | hf |
 *		Handle to a valid subfile.
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	Returns the file pointer for the given subfile.
 *
 ***************************************************************************/

PUBLIC FILEOFFSET PASCAL FAR EXPORT_API FoTellHf(HF hf, PHRESULT phr)
{
 	assert(mv_gsfa);
	assert(mv_gsfa_count);

	return mv_gsfa[(DWORD_PTR)hf].foCurrent;
}

/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	FILEOFFSET PASCAL FAR | FoSizeHf |
 *		Returns size of the subfile.  Replaces LSizeHf.
 *
 *  @parm	HF | hf |
 *		Handle to a valid subfile.
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	Returns the size of a subfile.  
 *
 ***************************************************************************/
#ifndef ITWRAP
PUBLIC FILEOFFSET PASCAL FAR EXPORT_API FoSizeHf(HF hf, PHRESULT phr)
{
 	QSFB	qsfb;
	FILEOFFSET foSize=foNil;

 	assert(mv_gsfa);
	assert(mv_gsfa_count);

	if (mv_gsfa[(DWORD)hf].hsfb == NULL || (qsfb = _GLOBALLOCK(mv_gsfa[(DWORD)hf].hsfb)) == NULL)
	{
	    SetErrCode (phr, E_INVALIDARG);
        return foNil;
	}
    
    assert(qsfb->hvf);

	foSize = VFileGetSize(qsfb->hvf, phr);
	
	_GLOBALUNLOCK(mv_gsfa[(DWORD)hf].hsfb);

	return foSize;
}
#endif
/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	FILEOFFSET PASCAL FAR | FoOffsetHf |
 *		Returns offset into the M20 of the subfile. 
 *
 *  @parm	HF | hf |
 *		Handle to a valid subfile.
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	Returns the size of a subfile.  
 *
 ***************************************************************************/

PUBLIC FILEOFFSET PASCAL FAR EXPORT_API FoOffsetHf(HF hf, PHRESULT phr)
{
 	QSFB	qsfb;
	FILEOFFSET foOffset=foNil;

 	assert(mv_gsfa);
	assert(mv_gsfa_count);

	if (mv_gsfa[(DWORD_PTR)hf].hsfb == NULL || (qsfb = _GLOBALLOCK(mv_gsfa[(DWORD_PTR)hf].hsfb)) == NULL)
	{
	    SetErrCode (phr, E_INVALIDARG);
        return foNil;
	}
    
    assert(qsfb->hvf);
	foOffset = qsfb->foHeader;
	
	_GLOBALUNLOCK(mv_gsfa[(DWORD_PTR)hf].hsfb);

	return foOffset;
}


/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	BOOL PASCAL FAR | FEofHf |
 *		Checks the file pointer for End Of File.
 *
 *  @parm	HF | hf |
 *		Handle to a valid subfile.
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	Returns TRUE if the file pointer is at or beyond the size of
 *		the file, else FALSE.
 *
 ***************************************************************************/

PUBLIC BOOL PASCAL FAR EXPORT_API FEofHf(HF hf, PHRESULT phr)
{
 	QSFB	qsfb;
	FILEOFFSET foSize=foNil;

 	assert(mv_gsfa);
	assert(mv_gsfa_count);

	if (mv_gsfa[(DWORD_PTR)hf].hsfb == NULL || (qsfb = _GLOBALLOCK(mv_gsfa[(DWORD_PTR)hf].hsfb)) == NULL)
	{
	    SetErrCode (phr, E_INVALIDARG);
        return FALSE;
	}
    
    assert(qsfb->hvf);

	foSize = VFileGetSize(qsfb->hvf, phr);
	
	_GLOBALUNLOCK(mv_gsfa[(DWORD_PTR)hf].hsfb);

	return (FoCompare(mv_gsfa[(DWORD_PTR)hf].foCurrent,foSize)>=0);
}

// Returns TRUE if size changed OK

/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	BOOL PASCAL FAR | FChSizeHf |
 *		Change the size of the subfile
 *
 *  @parm	HF | hf |
 *		Handle to a valid subfile.
 *
 *  @parm	FILEOFFSET | foNewSize |
 *		New size of file
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	Returns TRUE if file size changed OK, FALSE otherwise.
 *
 *	@comm
 *		File pointer is not adjusted if size falls below current
 *		current file position.
 *
 ***************************************************************************/

PUBLIC BOOL PASCAL FAR EXPORT_API FChSizeHf(HF hf, FILEOFFSET foSize, PHRESULT phr)
{
 	QSFB	qsfb;
	HRESULT		rc;
	QFSHR 	qfshr;
	
 	assert(mv_gsfa);
	assert(mv_gsfa_count);

	if (mv_gsfa[(DWORD_PTR)hf].hsfb == NULL || (qsfb = _GLOBALLOCK(mv_gsfa[(DWORD_PTR)hf].hsfb)) == NULL)
	{
	    SetErrCode (phr, E_INVALIDARG);
        return FALSE;
	}
    
    assert(qsfb->hvf);

	if (qsfb->hfs == NULL || (qfshr = _GLOBALLOCK(qsfb->hfs)) == NULL)
	{
	    SetErrCode (phr, E_INVALIDARG);
        goto exit1;
	}

	_ENTERCRITICALSECTION(&qfshr->cs);

	rc=VFileSetEOF(qsfb->hvf, foSize);

	_LEAVECRITICALSECTION(&qfshr->cs);
	_GLOBALUNLOCK(qsfb->hfs);

	if (rc!=S_OK)
		SetErrCode(phr, rc);


exit1:
	_GLOBALUNLOCK(mv_gsfa[(DWORD_PTR)hf].hsfb);

	return (rc==S_OK);	
}


/***************************************************************************
 *
 *	@doc	PRIVATE
 *
 *	@func	HRESULT PASCAL NEAR | HsfbRemove |
 *		Remove the subfile header block.  Multiple HFs can reference a single
 *		subfile block, so the block should not be removed unless the lock
 *		count has been decremented to zero.
 *
 *  @parm	HSFB | hsfb |
 *		Handle to a valid subfile block
 *
 *	@rdesc	Returns S_OK if block removed OK.
 *
 *	@comm
 *		hsfb is removed from linked list
 *
 ***************************************************************************/

HRESULT PASCAL NEAR EXPORT_API HsfbRemove(HSFB hsfb)
{
	QSFB qsfb;
	QFSHR  	qfshr;
	HRESULT rc=S_OK;
	
	if (hsfb == NULL || (qsfb = _GLOBALLOCK(hsfb)) == NULL)
	{
	    return E_INVALIDARG;	    
	}

	if (qsfb->hvf)
	{
	 	return E_NOPERMISSION;
	}
	
	if (!(qsfb->bOpenFlags&HFOPEN_SYSTEM))
	{
		HFS	hfs;
		HSFB hsfbNext;
		
		hfs=qsfb->hfs;
		if (hfs == NULL || (qfshr = _GLOBALLOCK(hfs)) == NULL)
		{
		    _GLOBALUNLOCK(hsfb);
			return E_INVALIDARG;
		}

		_ENTERCRITICALSECTION(&qfshr->cs);

		hsfbNext=qsfb->hsfbNext;

		if (qfshr->hsfbFirst==hsfb)
		{
		 	qfshr->hsfbFirst=hsfbNext;
		}
		else
		{	
			HSFB hsfbCursor = qfshr->hsfbFirst;
			QSFB qsfbCursor;
		
			while (hsfbCursor)
			{	HSFB hsfbTemp;

			 	qsfbCursor=(QSFB)_GLOBALLOCK(hsfbCursor);
			
				if (qsfbCursor->hsfbNext==hsfb)
				{
					qsfbCursor->hsfbNext=hsfbNext;
					_GLOBALUNLOCK(hsfbCursor);
					break;
				}
			
				hsfbTemp=qsfbCursor->hsfbNext;
				_GLOBALUNLOCK(hsfbCursor);
				hsfbCursor=hsfbTemp;
			}
		
			// The block should always be in the list!
			assert(hsfbCursor);
		}
	
		_LEAVECRITICALSECTION(&qfshr->cs);    
		_GLOBALUNLOCK(hfs);
	}

	_GLOBALUNLOCK(hsfb);
	_GLOBALFREE(hsfb);

	return rc;
}
		
/***************************************************************************
 *
 *	@doc	PRIVATE
 *
 *	@func	HSFB PASCAL NEAR | HsfbCloseHsfb |
 *		Close the actual file associated with this block.  This should only
 *		be done once the reference count reaches zero.
 *
 *  @parm	HSFB hsfb
 *		Handle to a valid subfile.
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	Returns the next subfile block in the linked list of subfile
 *		blocks.
 *
 ***************************************************************************/

HSFB PASCAL NEAR EXPORT_API HsfbCloseHsfb(HSFB hsfbFirst, PHRESULT phr)
{	
	QSFB qsfb;
	HRESULT errb;
	HRESULT rc=S_OK;
	HSFB hsfbNext=NULL;
	
	if (hsfbFirst == NULL || (qsfb = _GLOBALLOCK(hsfbFirst)) == NULL)
	{
	    SetErrCode(phr,E_OUTOFMEMORY);
		return NULL;
	}

    
	if (qsfb->hvf==NULL)
	{
	 	SetErrCode(phr,E_INVALIDARG);
		exit1:
			_GLOBALUNLOCK(hsfbFirst);
			return NULL;		
	}
	
	hsfbNext=qsfb->hsfbNext;
	
	// If Read Only, the close is easy
	if (qsfb->bOpenFlags&HFOPEN_READ)
	{
	 	if ((rc=VFileClose(qsfb->hvf))!=S_OK)
		{
		 	VFileAbandon(qsfb->hvf);
			if ((rc=VFileClose(qsfb->hvf))!=S_OK)
			{	
				SetErrCode(phr,rc);
				goto exit1;
			}
		}
		qsfb->hvf=NULL;
	}
	else
	{
	 	FILEOFFSET foSize=VFileGetSize(qsfb->hvf,&errb);			
		HFS hfs;
		QFSHR qfshr;

		hfs=qsfb->hfs;

		if (hfs == NULL || (qfshr = _GLOBALLOCK(hfs)) == NULL)
		{
		    SetErrCode(phr,E_OUTOFMEMORY);
			goto exit1;
		}
		_ENTERCRITICALSECTION(&qfshr->cs);
    
		// Closing a read/write file...
		if (VFileGetFlags(qsfb->hvf,&errb)&VFF_FID)
		{	
			FILEOFFSET foLeftOver;
		
			// If file lives in FS,
			if ((rc=VFileClose(qsfb->hvf))!=S_OK)
			{
				SetErrCode(phr,rc);
				_GLOBALUNLOCK(hfs);
				_LEAVECRITICALSECTION(&qfshr->cs);
		 		goto exit1;
			}
			qsfb->hvf=NULL;

			foLeftOver=FoSubFo(qsfb->sfh.foBlockSize,foSize);
			assert(qfshr->hfl);
		
			// Send left over to free list
			if (!FoEquals(foLeftOver,foNil))
			{
			 	FreeListAdd(qfshr->hfl,FoAddDw(FoAddFo(qsfb->foHeader,foSize),SFHeaderSize(&qsfb->sfh)),
					foLeftOver);
			}
		}
		else
		{
		 	// If file lives in temp file
			// Find free spot for file
			if (qsfb->bOpenFlags&HFOPEN_READWRITE)
			{
				assert(qfshr->hfl);

				if (!FoIsNil(qsfb->foHeader)) // File already lives in FS
				{
				 	if (FoCompare(foSize,qsfb->sfh.foBlockSize)<=0)
					{
					 	// It fits back into old slot!!!
						FILEOFFSET foLeftOver=FoSubFo(qsfb->sfh.foBlockSize,foSize);
						if (!FoIsNil(foLeftOver))
						{
							FreeListAdd(qfshr->hfl,
								FoAddDw(FoAddFo(qsfb->foHeader,foSize),SFHeaderSize(&qsfb->sfh)),
								foLeftOver);
						}
					}
					else
					{
						FreeListAdd(qfshr->hfl,qsfb->foHeader,
							FoAddDw(qsfb->sfh.foBlockSize,SFHeaderSize(&qsfb->sfh)));
						qsfb->foHeader=GetFreeBlock(qfshr,FoAddDw(foSize,SFHeaderSize(&qsfb->sfh)),NULL);
					}
				}
				else
				{
					qsfb->foHeader=GetFreeBlock(qfshr,FoAddDw(foSize,SFHeaderSize(&qsfb->sfh)),NULL);
				}

				VFileSetBase(qsfb->hvf,qfshr->fid,FoAddDw(qsfb->foHeader,SFHeaderSize(&qsfb->sfh)),foSize);
			}
			else
				VFileAbandon(qsfb->hvf);

			VFileClose(qsfb->hvf);
			qsfb->hvf=NULL;
		}
		
		// Update structs
		qsfb->sfh.foBlockSize=foSize;

		// Update btree if necessary (always for now)
		if (!(qsfb->bOpenFlags&HFOPEN_SYSTEM))
		{	
			FILE_REC fr;
			KEY key = NewKeyFromSz(qsfb->rgchKey);	
			
			qsfb->sfh.bFlags&=(~SFH_INVALID);
			SetFrData(&fr,qsfb->foHeader,qsfb->sfh.foBlockSize,qsfb->sfh.bFlags);
			
			//fr.lifBase=qsfb->foHeader.lOffset;
			if ((rc = RcUpdateHbt(qfshr->hbt, key, &fr))!=S_OK)
			{
		 		// Can't update btree???  What now???
				if ((rc = RcUpdateHbt(qfshr->hbt, key, &fr))!=S_OK)
				{
				 	// Place breakpoint above... this should never happen.
				}
			
			}
			DisposeMemory((LPSTR)key);					
		}
		else
		{
			qfshr->fsh.foDirectory=qsfb->foHeader;
			qfshr->fsh.sfhSystem=qsfb->sfh;
		}
		
		_LEAVECRITICALSECTION(&qfshr->cs);
	
		_GLOBALUNLOCK(hfs);			
	}
	
	_GLOBALUNLOCK(hsfbFirst);

	return hsfbNext;
}

/***************************************************************************
 *
 *	@doc	PRIVATE
 *
 *	@func	HRESULT PASCAL NEAR | RcFlushHsfb |
 *		Flush the subfile block by ensuring the file it refers to is copied
 *		into the file system, and the btree entry is up to date with the 
 *		current file size.
 *
 *  @parm	HF | hsfb |
 *		Handle to a valid subfile block.
 *
 *	@rdesc	Returns S_OK if subfile flushed OK.
 *
 ***************************************************************************/

HRESULT PASCAL NEAR EXPORT_API RcFlushHsfb(HSFB hsfbFirst)
{	
	QSFB qsfb;
	HRESULT errb;
	HRESULT rc=S_OK;
	
	if (hsfbFirst == NULL || (qsfb = _GLOBALLOCK(hsfbFirst)) == NULL)
	{
	    rc=E_OUTOFMEMORY;
		return rc;
	}

    if (qsfb->hvf==NULL)
	{
	 	rc=E_INVALIDARG;
		exit1:
	 		_GLOBALUNLOCK(hsfbFirst);
			return rc;		
	}
	
	// If Read Only, the flush is easy

	if (qsfb->bOpenFlags&HFOPEN_READ)
	{
			goto exit1;
	}
	else
	{
	 	FILEOFFSET foSize=VFileGetSize(qsfb->hvf,&errb);			
		HFS hfs;
		QFSHR qfshr;

		hfs=qsfb->hfs;

		if (hfs == NULL || (qfshr = _GLOBALLOCK(hfs)) == NULL)
		{
		    rc=E_OUTOFMEMORY;
			goto exit1;
		}

		_ENTERCRITICALSECTION(&qfshr->cs);
	
		// Copy r/w temp file to file system if needed
		// Closing a read/write file...
		if (VFileGetFlags(qsfb->hvf,&errb)&VFF_FID)
		{	
			// Leave extra large block allocated to this file if there already
		}
		else
		{
		 	// If file lives in temp file
			// Find free spot for file
			assert(qfshr->hfl);

			if (!FoIsNil(qsfb->foHeader)) // File already lives in FS
			{
			 	if (FoCompare(foSize,qsfb->sfh.foBlockSize)<=0)
				{
				 	// It fits back into old slot!!!					
				}
				else
				{
					FILEOFFSET foExtraBytes;
					FreeListAdd(qfshr->hfl,qsfb->foHeader,
						FoAddDw(qsfb->sfh.foBlockSize,SFHeaderSize(&qsfb->sfh)));
					qsfb->foHeader=GetFreeBlock(qfshr,FoAddDw(foSize,SFHeaderSize(&qsfb->sfh)),NULL);
					foExtraBytes=FreeListGetBlockAt(qfshr->hfl,FoAddFo(qsfb->foHeader,foSize),NULL);
					qsfb->sfh.foBlockSize=FoAddFo(foSize,foExtraBytes);					
				}
			}
			else
			{
				qsfb->foHeader=GetFreeBlock(qfshr,FoAddDw(foSize,SFHeaderSize(&qsfb->sfh)),NULL);
				if (!FoIsNil(qsfb->foHeader))
					qsfb->sfh.foBlockSize=foSize;
			}
			VFileSetBase(qsfb->hvf,qfshr->fid,FoAddDw(qsfb->foHeader,SFHeaderSize(&qsfb->sfh)),qsfb->sfh.foBlockSize);			
		}
		
		// Update btree if necessary (always for now)
		if (!(qsfb->bOpenFlags&HFOPEN_SYSTEM))
		{	
			FILE_REC fr;
			KEY key = NewKeyFromSz(qsfb->rgchKey);	
			
			// Update with proper file size instead of allocated size, in case we crash,
			// then this is the true file size at this moment.
			qsfb->sfh.bFlags&=(~SFH_INVALID);
			SetFrData(&fr,qsfb->foHeader,foSize,qsfb->sfh.bFlags); // 0 flag now, since file is no longer invalid
			
			rc = RcUpdateHbt(qfshr->hbt, key, &fr);
			
			DisposeMemory((LPSTR)key);					
		}
		else
		{
			qfshr->fsh.foDirectory=qsfb->foHeader;
			qfshr->fsh.sfhSystem=qsfb->sfh;
			// Update with proper file size instead of allocated size, in case we crash,
			// then this is the true file size at this moment.
			qfshr->fsh.sfhSystem.foBlockSize=foSize;
		}
		
		FidFlush(qfshr->fid);
		
		_LEAVECRITICALSECTION(&qfshr->cs);			
		_GLOBALUNLOCK(hfs);			
	}
	
	_GLOBALUNLOCK(hsfbFirst);

	return rc;
}

/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	HRESULT PASCAL FAR | RcAbandonHf |
 *		Abandon the creation of a new subfile.  
 *
 *  @parm	HF | hf |
 *		Handle to a valid subfile.
 *
 *	@rdesc	Returns S_OK if file creation abandonded OK.
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API RcAbandonHf(HF hf)
{
 	QSFB	qsfb;
	HFS		hfs;
	QFSHR  	qfshr;			
	
 	assert(mv_gsfa);
	assert(mv_gsfa_count);

	if (mv_gsfa[(DWORD_PTR)hf].hsfb == NULL || (qsfb = _GLOBALLOCK(mv_gsfa[(DWORD_PTR)hf].hsfb)) == NULL)
	{
	    return E_OUTOFMEMORY;
	}

    hfs=qsfb->hfs;
	if (hfs == NULL || (qfshr = _GLOBALLOCK(hfs)) == NULL)
	{
		_GLOBALUNLOCK(mv_gsfa[(DWORD_PTR)hf].hsfb);
		return E_OUTOFMEMORY;
	}
    
    _ENTERCRITICALSECTION(&qfshr->cs);
    assert(qsfb->hvf);

	qsfb->wLockCount--;
	
	if (!qsfb->wLockCount)
	{	
		// We should free the hsfb
		if(qsfb->bOpenFlags&HFOPEN_READWRITE)
		{
		 	FILE_REC fr;
			KEY key;
			
			assert(qsfb->hvf);
	
			VFileAbandon(qsfb->hvf);  // Should abandon automatically do close too?
			VFileClose(qsfb->hvf);
			qsfb->hvf=NULL;
			key = NewKeyFromSz(qsfb->rgchKey);
			
			// Do error checking here to signal if Abandon fails???

			// Remove from btree if we just now inserted it
			
			RcLookupByKey(qfshr->hbt, key, NULL, &fr);
			GetFrData(&fr);
			
			if (fr.bFlags&SFH_INVALID)
			{
				RcDeleteHbt(qfshr->hbt, key);
			}
	
			DisposeMemory((LPSTR)key);
			_GLOBALUNLOCK(mv_gsfa[(DWORD_PTR)hf].hsfb);
			HsfbRemove(mv_gsfa[(DWORD_PTR)hf].hsfb);
		}
		else
		{
		 	_GLOBALUNLOCK(mv_gsfa[(DWORD_PTR)hf].hsfb);
			_GLOBALFREE(mv_gsfa[(DWORD_PTR)hf].hsfb);
		}
	}
	else
	{
	 	// subfile block still valid, since it has a lock count
	 	_GLOBALUNLOCK(mv_gsfa[(DWORD_PTR)hf].hsfb);
	}
	
	_LEAVECRITICALSECTION(&qfshr->cs);
    _GLOBALUNLOCK(hfs);
	
	// This hf is no longer valid
	mv_gsfa[(DWORD_PTR)hf].hsfb=NULL;

#ifdef _DEBUGMVFS	
	DPF2("HfAbandon: hf=%d, %d\n", hf, 0);
	DumpMV_GSFA();
#endif

	return S_OK;	
}

/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	HRESULT PASCAL FAR | RcFlushHf |
 *		Flush the subfile by ensuring it is written in the file system
 *
 *  @parm	HF | hf |
 *		Handle to a valid subfile.
 *
 *	@rdesc	Returns S_OK if flushed OK.
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API RcFlushHf(HF hf)
{
 	QSFB	qsfb;
	HRESULT		rc=S_OK;
	
 	assert(mv_gsfa);
	assert(mv_gsfa_count);

	if (mv_gsfa[(DWORD_PTR)hf].hsfb == NULL || (qsfb = _GLOBALLOCK(mv_gsfa[(DWORD_PTR)hf].hsfb)) == NULL)
	{
	    return E_INVALIDARG;
	}

	if (qsfb->bOpenFlags&HFOPEN_READWRITE)
	{
		// Copy back to M20 file if necessary
		// Update btree info
		
		rc=RcFlushHsfb(mv_gsfa[(DWORD_PTR)hf].hsfb);
		

	}
	
	_GLOBALUNLOCK(mv_gsfa[(DWORD_PTR)hf].hsfb);

	return (rc);
}

/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	HRESULT PASCAL FAR | RcCloseEveryHf |
 *		Close every opened subfile.  This should only be used in emergency
 *		cases to safely close all subfiles.  Ideally, the calling application
 *		should close the subfiles as necessary, and never call this function.
 *
 *  @parm	HFS | hfs |
 *		Handle to a valid file system
 *
 *	@rdesc	Returns S_OK if all files closed OK.
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API RcCloseEveryHf(HFS hfs)
{
	QFSHR   qfshr;
	HRESULT    errb;
	HRESULT		rc = S_OK;
	
	if (hfs == NULL || (qfshr = _GLOBALLOCK(hfs)) == NULL)
	{
	    return(E_INVALIDARG);
	}
    _ENTERCRITICALSECTION(&qfshr->cs);
	
	while (qfshr->hsfbFirst)
	{
	 	HSFB hsfbNext;
		
		errb=S_OK;
	 	hsfbNext=HsfbCloseHsfb(qfshr->hsfbFirst, &errb);
		
		if (errb==S_OK)
		{
			int q;
			rc=HsfbRemove(qfshr->hsfbFirst); 	// destroys handle too			
			
			// now remove from our global array	any left over references
			for (q=1;q<giMaxSubFiles;q++)
				if (mv_gsfa[q].hsfb==qfshr->hsfbFirst)
				{
					mv_gsfa[q].hsfb=NULL;
					mv_gsfa[q].foCurrent=foNil;
				}
		}

		qfshr->hsfbFirst=hsfbNext;
	}

	_LEAVECRITICALSECTION(&qfshr->cs);
			
	_GLOBALUNLOCK(hfs);
#ifdef _DEBUGMVFS	
	DPF2("RcCloseEveryHf: hfs=%d, %d\n", hfs, 0);
	DumpMV_GSFA();
#endif

	return S_OK;
}


#ifdef _DEBUGMVFS
void DumpMV_GSFA(void)
{
	int q;
	QSFB qsfb;
	HANDLE h;
	QFSHR qfshr;
	
	if (mv_gsfa == NULL)
	{
		DPF2("mv_gsfa is EMPTY (%d, %d)\n",0,0);
		return;
	}

	DPF2("mv_gsfa_count=%ld, giMaxSubfiles=%ld\n", mv_gsfa_count, giMaxSubFiles);
	for (q=1;q<giMaxSubFiles;q++)
		if ((h = mv_gsfa[q].hsfb) && (qsfb = _GLOBALLOCK(h)))
		{
			if (qfshr = _GLOBALLOCK(qsfb->hfs))
			{
				DPF4("mv_gsfa[%d]: qsfb->hfs=%ld ,qfshr->fid=%ld, wLock=%ld\n", \
					q, qsfb->hfs, qfshr->fid, qsfb->wLockCount);
				_GLOBALUNLOCK(qsfb->hfs);				
			}
			_GLOBALUNLOCK(h);
		}
}
#endif
/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	HRESULT PASCAL FAR | RcFlushEveryHf |
 *		Flush every opened subfile.  This should only be used in emergency
 *		cases to flush all subfiles.  
 *
 *  @parm	HFS | hfs |
 *		Handle to a valid file system
 *
 *	@rdesc	Returns S_OK if all files flushed OK.
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API RcFlushEveryHf(HFS hfs)
{
	QFSHR   qfshr;
	HSFB 	hsfbCursor;
	HRESULT		rc = S_OK;

	if (hfs == NULL || (qfshr = _GLOBALLOCK(hfs)) == NULL)
	{
	    return(E_INVALIDARG);
	}
    
	_ENTERCRITICALSECTION(&qfshr->cs);
	
	hsfbCursor=qfshr->hsfbFirst;
	while (hsfbCursor)
	{
	 	HSFB hsfbNext=NULL;
		QSFB qsfb;

		if (!(qsfb = _GLOBALLOCK(hsfbCursor)))
		{
		    rc=E_OUTOFMEMORY;
			exit1:
				_LEAVECRITICALSECTION(&qfshr->cs);
				_GLOBALUNLOCK(hfs);
				return rc;
		}

    	hsfbNext=qsfb->hsfbNext;
		
	 	if ((rc=RcFlushHsfb(hsfbCursor))!=S_OK)
		{
			_GLOBALUNLOCK(hsfbCursor);			
			goto exit1;
		}
	
		_GLOBALUNLOCK(hsfbCursor);
		
		hsfbCursor=hsfbNext;		
	}
	goto exit1;
}

/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	HRESULT PASCAL FAR | RcCloseHf |
 *		Close the subfile.  All data is written back into the file system
 * 		and the directory btree is updated with the file's size.
 *
 *  @parm	HF | hf |
 *		Handle to a valid subfile
 *
 *	@rdesc	Returns S_OK if all files closed OK.
 *
 ***************************************************************************/
#ifndef ITWRAP
PUBLIC HRESULT PASCAL FAR EXPORT_API RcCloseHf(HF hf)
{
 	QSFB	qsfb;
	QFSHR  	qfshr;
	FILEOFFSET foSize=foNil;
	HRESULT		rc=S_OK;
	BOOL 	bFreeBlock=FALSE;
	HFS		hfs;

 	assert(mv_gsfa);
	assert(mv_gsfa_count);

	if (mv_gsfa[(DWORD)hf].hsfb == NULL || (qsfb = _GLOBALLOCK(mv_gsfa[(DWORD)hf].hsfb)) == NULL)
	{
	    return E_INVALIDARG;
	}

	hfs=qsfb->hfs;

	if (hfs == NULL || (qfshr = _GLOBALLOCK(hfs)) == NULL)
	{
	    _GLOBALUNLOCK(mv_gsfa[(DWORD)hf].hsfb);
        return E_INVALIDARG;
	}
	
	_ENTERCRITICALSECTION(&qfshr->cs);

	assert(qsfb->hvf);

	qsfb->wLockCount--;

	if (!qsfb->wLockCount)
	{
		HRESULT errb;
		_GLOBALUNLOCK(mv_gsfa[(DWORD)hf].hsfb);
		errb.err=S_OK;
		HsfbCloseHsfb(mv_gsfa[(DWORD)hf].hsfb, &errb);

		rc=errb.err;
		if (rc==S_OK)
		{
			rc=HsfbRemove(mv_gsfa[(DWORD)hf].hsfb); 	// destroys handle too
			mv_gsfa[(DWORD)hf].hsfb=NULL;
		}		
	}
	else
	{
		_GLOBALUNLOCK(mv_gsfa[(DWORD)hf].hsfb);	
		mv_gsfa[(DWORD)hf].hsfb=NULL;	
	}

	_LEAVECRITICALSECTION(&qfshr->cs);
	_GLOBALUNLOCK(hfs);
#ifdef _DEBUGMVFS	
	DPF2("RcCloseHf: hfs=%d, hf=%d\n", hfs, hf);
	DumpMV_GSFA();
#endif

	return (rc);
}
#endif

/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	HRESULT PASCAL FAR | RcUnlinkFileHfs |
 *		Remove a subfile from the file system.  The file should not be opened
 *		by any other processes when it is removed.
 *
 *  @parm	HFS | hfs |
 *		Handle to a valid file system
 *
 *	@parm	LPCSTR | szFileName |
 *		Name of file in file system to remove
 *
 *	@rdesc	Returns S_OK if file deleted OK.
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API RcUnlinkFileHfs(HFS hfs, LPCSTR sz)
{
#ifdef MOSMAP // {
	// Disable function
	return (ERR_NOTSUPPORTED);
#else // } {
	QFSHR     qfshr;
	FILE_REC  fr;
    HRESULT      errb;
    KEY 	key;
	HRESULT		rc=S_OK;

	if (hfs == NULL || (qfshr = _GLOBALLOCK(hfs)) == NULL)
	{
	    return SetErrCode (&errb, E_INVALIDARG); 
	}
    
	key = NewKeyFromSz(sz);
		
	if (qfshr->fsh.bFlags & FSH_READONLY)
	{
		rc=SetErrCode (&errb, E_NOPERMISSION);
		exit0:
			DisposeMemory((LPSTR)key);
			_GLOBALUNLOCK(hfs);
			return rc;
	}

	_ENTERCRITICALSECTION(&qfshr->cs);
	// check for File In Use ???

	/* look it up to get the file base offset */
	if ((rc = RcLookupByKey (qfshr->hbt, key, NULL, &fr)) != S_OK)
	{
		exit1:
			_LEAVECRITICALSECTION(&qfshr->cs);
			goto exit0;
	}		

	GetFrData(&fr);
	if (fr.bFlags&SFH_LOCKED)
	{	rc=SetErrCode(&errb, E_NOPERMISSION);
		goto exit1;
	}

	assert(qfshr->hfl);
	if ((rc = RcDeleteHbt (qfshr->hbt, key)) == S_OK)
	{
		/* put the file block on the free list */
		//SFH sfh;
		
		FreeListAdd(qfshr->hfl,fr.foStart,fr.foSize);
		
		//if ((FoEquals(FoSeekFid(qfshr->fid, fr.fo, wSeekSet, &errb),fr.fo)) &&
		//	(LcbWriteFid(qfshr->fid, &sfh,sizeof(SFH),&errb)==sizeof(SFH)))
		//{
		//	FreeListAdd(qfshr->hfl,fr.fo,(LONG)sfh.foBlockSize);
		//}		
	}
	
	DisposeMemory((LPSTR)key);
	_LEAVECRITICALSECTION(&qfshr->cs);
	_GLOBALUNLOCK(hfs);
	return rc;
#endif //}
}


/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	HRESULT PASCAL FAR | SetFileFlags |
 *		Set the Logging or Locking state of a file
 *
 *  @parm	HFS | hfs |
 *		Handle to a valid file system
 *
 *	@parm	LPCSTR | szFileName |
 *		Name of file in file system to set bits of
 *
 *	@parm	BYTE | bFlags |
 *		SFH_LOGGING or SFH_LOCKED
 *
 *	@rdesc	Returns S_OK if flags set OK
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API SetFileFlags(HFS hfs, LPCSTR sz, BYTE bFlags)
{
#ifdef MOSMAP // {
	// Disable function
	return (ERR_NOTSUPPORTED);
#else // } {
	QFSHR     qfshr;
	FILE_REC  fr;
    HRESULT      errb;
    KEY 	key;
	HRESULT		rc=S_OK;

	if (hfs == NULL || (qfshr = _GLOBALLOCK(hfs)) == NULL)
	{
	    return SetErrCode (&errb, E_INVALIDARG); 
	}
    
	key = NewKeyFromSz(sz);
		
	if (qfshr->fsh.bFlags & FSH_READONLY)
	{
		rc=SetErrCode (&errb, E_NOPERMISSION);
		exit0:
			DisposeMemory((LPSTR)key);
			_GLOBALUNLOCK(hfs);
			return rc;
	}

	_ENTERCRITICALSECTION(&qfshr->cs);
	// check for File In Use ???

	/* look it up to get the file base offset */
	if ((rc = RcLookupByKey (qfshr->hbt, key, NULL, &fr)) != S_OK)
	{
		_LEAVECRITICALSECTION(&qfshr->cs);
		goto exit0;
	}		

	GetFrData(&fr);

	fr.bFlags=fr.bFlags&(~SFH_FILEFLAGS);
	bFlags&=SFH_FILEFLAGS;
	fr.bFlags|=bFlags;

	SetFrData(&fr,fr.foStart,fr.foSize,fr.bFlags);
	
	//fr.lifBase=qsfb->foHeader.lOffset;
	if ((rc = RcUpdateHbt(qfshr->hbt, key, &fr))!=S_OK)
	{
 		// Can't update btree???  What now???
	}
	
	DisposeMemory((LPSTR)key);
	_LEAVECRITICALSECTION(&qfshr->cs);
	_GLOBALUNLOCK(hfs);
	return rc;
#endif //}
}

/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	BYTE PASCAL FAR | GetFileFlags |
 *		Get the Logging or Locking state of a file
 *
 *  @parm	HFS | hfs |
 *		Handle to a valid file system
 *
 *	@parm	LPCSTR | szFileName |
 *		Name of file in file system to set bits of
 *
 *	@parm	PHRESULT | phr |
 *		Error return code
 *
 *	@rdesc	Returns zero or any combination of SFH_LOGGING and SFH_LOCKED
 *
 ***************************************************************************/

PUBLIC BYTE PASCAL FAR EXPORT_API GetFileFlags(HFS hfs, LPCSTR sz, PHRESULT phr)
{
#ifdef MOSMAP // {
	// Disable function
	return (ERR_NOTSUPPORTED);
#else // } {
	QFSHR     qfshr;
	FILE_REC  fr;
    KEY 	key;
	HRESULT		rc;
	
	*phr=S_OK;

	if (hfs == NULL || (qfshr = _GLOBALLOCK(hfs)) == NULL)
	{
	    SetErrCode (phr, E_INVALIDARG); 
		return 0;
	}
    
	key = NewKeyFromSz(sz);
		
	if (qfshr->fsh.bFlags & FSH_READONLY)
	{
		SetErrCode (phr, E_NOPERMISSION);
		exit0:
			DisposeMemory((LPSTR)key);
			_GLOBALUNLOCK(hfs);
			return 0;
	}

	_ENTERCRITICALSECTION(&qfshr->cs);
	// check for File In Use ???

	/* look it up to get the file base offset */
	if ((rc = RcLookupByKey (qfshr->hbt, key, NULL, &fr)) != S_OK)
	{
		_LEAVECRITICALSECTION(&qfshr->cs);
		SetErrCode(phr,rc);
		goto exit0;
	}		

	GetFrData(&fr);

	fr.bFlags=fr.bFlags&(~SFH_FILEFLAGS);
	
	DisposeMemory((LPSTR)key);
	_LEAVECRITICALSECTION(&qfshr->cs);
	_GLOBALUNLOCK(hfs);
	return fr.bFlags;

#endif //}
}

			

/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	BOOL PASCAL FAR | FAccessHfs |
 *		Check whether a sub file has specific attributes.
 *
 *  @parm	HFS | hfs |
 *		Handle to a valid file system
 *
 *	@parm	LPCSTR | szFileName |
 *		Name of subfile to check
 *
 *	@parm	BYTE | bFlags |
 *		Any one of the following attributes:
 * 	@flag FACCESS_EXISTS		| Does the file exist?
 * 	@flag FACCESS_READWRITE		| Can we open the file for read/write?
 * 	@flag FACCESS_READ			| Can we open the file for reading?
 * 	@flag FACCESS_LIVESINFS		| Does the file live in the file system now?
 * 	@flag FACCESS_LIVESINTEMP	| Does the file live in a temporary file on th HD now?
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	Returns TRUE if the file has the given attribute.  Error code
 *		will not be S_OK if an error occurred.
 *
 ***************************************************************************/
#ifndef ITWRAP
PUBLIC BOOL PASCAL FAR EXPORT_API FAccessHfs( HFS hfs, LPCSTR szName, BYTE bFlags, PHRESULT phr)
{
	QFSHR     qfshr;
	FILE_REC  fr;
	KEY		  key;
	BOOL	  bSuccess=FALSE;
    HRESULT		  rc;

    //SetErrCode (phr, S_OK); 
		
	if (hfs == NULL || (qfshr = _GLOBALLOCK(hfs)) == NULL)
	{
	    SetErrCode (phr, E_INVALIDARG); 
		return bSuccess;
	}
    
	key = NewKeyFromSz(szName);
	
	_ENTERCRITICALSECTION(&qfshr->cs);
	rc = RcLookupByKey (qfshr->hbt, key, NULL, &fr);
	_LEAVECRITICALSECTION(&qfshr->cs);

	if (rc==S_OK)
	{
		if (bFlags&FACCESS_EXISTS)
			bSuccess=TRUE;
		else
		{
			HSFB hsfbCursor;
			// Look up subfile block and check for permissions
			hsfbCursor = qfshr->hsfbFirst;
			while (hsfbCursor)
			{
			 	HSFB hsfbNext;
				QSFB qsfb;

				if (!(qsfb = _GLOBALLOCK(hsfbCursor)))
				{
				    SetErrCode(phr,E_OUTOFMEMORY);
					goto exit1;				
				}

				hsfbNext=qsfb->hsfbNext;

			 	if (FoEquals(qsfb->foHeader,fr.foStart))
			 	{	
		 			// Cannot open for read/write...
					
					if ((!(qsfb->bOpenFlags&HFOPEN_READWRITE)) && (bFlags&FACCESS_READ))
					{
						// Can open for read
						bSuccess=TRUE; 	
					}
					else if (bFlags&(FACCESS_LIVESINFS|FACCESS_LIVESINTEMP))
					{
						// find out where this opened file lives
						DWORD dwVFileFlags = VFileGetFlags(qsfb->hvf,NULL);
						if (((dwVFileFlags&VFF_TEMP) && (bFlags&FACCESS_LIVESINTEMP)) ||
							((dwVFileFlags&VFF_FID) && (bFlags&FACCESS_LIVESINFS)))
							bSuccess=TRUE;
						else
						{	
							if (phr)
								phr->err=E_NOPERMISSION;	// reason for no access
						}
					}
					else
					{	if (phr)
							phr->err=E_NOPERMISSION;	
					}		
					_GLOBALUNLOCK(hsfbCursor);
					goto exit1;
				}
 	
			 	_GLOBALUNLOCK(hsfbCursor);
				hsfbCursor=hsfbNext;		
			}

			// File is not currently opened
			if (bFlags&(FACCESS_READ|FACCESS_READWRITE))
				bSuccess=TRUE;
			else
			{	
				if (phr)
					phr->err=E_NOPERMISSION;
			}
			
		}
	}
	else
	{
	 	if (phr)
			phr->err=E_NOTEXIST;	
	}	
	exit1:
		DisposeMemory((LPSTR)key);
		_GLOBALUNLOCK(hfs);
		return bSuccess;
}
#endif
/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	HRESULT PASCAL FAR | RcRenameFileHfs |
 *		Rename a subfile in the file system.  The subfile must not currently
 *		be in use.
 *
 *  @parm	HFS | hfs |
 *		Handle to a valid file system
 *
 *	@parm	LPCSTR | szOld |
 *		Current file name
 *
 *	@parm	LPCSTR | szNew |
 *		New file name
 *
 *	@rdesc	Returns S_OK if the file was renamed OK.
 *		E_NOPERMISSION if file is in use, or file system is read-only.
 *      rcExists if file named szOld already exists in FS
 *      rcNoExists if file named szNew doesn't exist in FS
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL PASCAL EXPORT_API RcRenameFileHfs(HFS hfs, LPCSTR szOld, LPCSTR szNew)
{
#ifdef MOSMAP // {
	// Disable function
	return ERR_NOTSUPPORTED;
#else // } {
	QFSHR     qfshr;
	FILE_REC  fr;
    HRESULT        rc;
	HSFB 	  hsfbCursor;
	KEY		  keyOld,keyNew;

	if (hfs == NULL || (qfshr = _GLOBALLOCK(hfs)) == NULL)
	{
	    return(E_INVALIDARG);
	}

	if (qfshr->fsh.bFlags & FSH_READONLY)
	{
		rc=E_NOPERMISSION;
		exit0:
			_GLOBALUNLOCK(hfs);
			return rc;
	}

	keyOld = NewKeyFromSz(szOld);
	keyNew = NewKeyFromSz(szNew);
	
	_ENTERCRITICALSECTION(&qfshr->cs);

	if ((rc = RcLookupByKey (qfshr->hbt, keyOld, NULL, &fr))
	    != S_OK)
	{
		goto exit1;
	}
	
	// Make sure file is not already opened by anyone
	hsfbCursor = qfshr->hsfbFirst;
	while (hsfbCursor)
	{
	 	HSFB hsfbNext;
		QSFB qsfb;

		if (!(qsfb = _GLOBALLOCK(hsfbCursor)))
		{
		    rc=E_OUTOFMEMORY;
			RcDeleteHbt( qfshr->hbt, keyNew);
			goto exit1;				
		}

		hsfbNext=qsfb->hsfbNext;

	 	if (FoEquals(qsfb->foHeader,fr.foStart))
	 	{	
	 		rc = E_NOPERMISSION;
			_GLOBALUNLOCK(hsfbCursor);
			goto exit1;
		}
 	
	 	_GLOBALUNLOCK(hsfbCursor);
		hsfbCursor=hsfbNext;		
	}

	if ((rc = RcInsertHbt( qfshr->hbt, keyNew, &fr)) != S_OK )
	{
		goto exit1;
	}

	if ((rc = RcDeleteHbt(qfshr->hbt, keyOld) != S_OK))
	{
		// can't delete the old, so just delete the new and hope for
		// the best!
		if ((rc = RcDeleteHbt( qfshr->hbt, keyNew)) == S_OK)
			rc = E_FAIL;
	}

exit1:
	DisposeMemory((LPSTR)keyOld);
	DisposeMemory((LPSTR)keyNew);

	_LEAVECRITICALSECTION(&qfshr->cs);
	goto exit0;
#endif // }  MOSMAP
}


/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	BOOL PASCAL FAR | FHfValid |
 *		Check for validity of a subfile handle
 *
 *  @parm	HF | hf |
 *		Handle to a subfile
 *
 *	@rdesc	Returns TRUE if the subfile is valid.
 *
 ***************************************************************************/
#ifndef ITWRAP
BOOL PASCAL FAR EXPORT_API FHfValid( HF hf)
{
 	return ((mv_gsfa) && (mv_gsfa_count) && ((WORD)hf<giMaxSubFiles) && (hf) && (mv_gsfa[(DWORD)hf].hsfb))?TRUE:FALSE;	
}
#endif // !ITWRAP

/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	HFS PASCAL FAR | HfsGetFromHf |
 *		Get the file system handle of a given subfile.
 *
 *  @parm	HF | hf |
 *		Handle to a subfile
 *
 *	@rdesc	Returns the subfile's parent file system handle, or NULL.
 *
 ***************************************************************************/

HFS	PASCAL FAR EXPORT_API HfsGetFromHf( HF hf )
{
  	HFS hfs=NULL;
  	QSFB qsfb;

  	assert(mv_gsfa);
	assert(mv_gsfa_count);

	if ((mv_gsfa[(DWORD_PTR)hf].hsfb) && (qsfb = _GLOBALLOCK(mv_gsfa[(DWORD_PTR)hf].hsfb)))
	{
		hfs=qsfb->hfs;
		_GLOBALUNLOCK(mv_gsfa[(DWORD_PTR)hf].hsfb);	
	}
	return hfs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\filesys\vfile.c ===
/*****************************************************************************
 *                                                                            *
 *  VFILE.C                                                                   *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1995.                                 *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  "Virtual File" functions - Actual data may reside in a parent file at     *
 *	any given offset, or in a temp file.									  *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  davej                                                     *
 *****************************************************************************/

/*****************************************************************************
 *
 *  Created 07/17/95 - davej
 *
 *****************************************************************************/

static char s_aszModule[] = __FILE__;    /* For error report */

#include <mvopsys.h>
#include <iterror.h>
#include <orkin.h>
#include <misc.h>
#include <wrapstor.h>
#include <_mvutil.h>


/*****************************************************************************
 *                                                                            *
 *                               Defines                                      *
 *                                                                            *
 *****************************************************************************/


/*****************************************************************************
 *                                                                            *
 *                               Prototypes                                   *
 *                                                                            *
 *****************************************************************************/

HRESULT PASCAL NEAR RcCopyFileBuf(FID fidDst, FID fidSrc, FILEOFFSET foSize, PROGFUNC lpfnProg, 
	LPVOID lpvMem, LONG lBufSize);

/***************************************************************************
 *                                                                           *
 *                         Private Functions                                 *
 *                                                                           *
 ***************************************************************************/



/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HVF PASCAL FAR | VFileOpen |
 *		Open a virtual file
 *
 *  @parm	FID | fidParent |
 *		Parent file where virtual file may live
 *
 *	@parm	FILEOFFSET | foBase |
 *		Base location in parent file
 *
 *	@parm	FILEOFFSET | foBlock |
 *		Size of file in parent file
 *
 *	@parm	FILEOFFSET | foExtra |
 *		Extra amount file may grow before no more room in parent file
 *
 *	@parm	DWORD | dwFlags |
 *		Any VFOPEN_ flags
 *
 *	@parm 	LPSHAREDBUFFER | lpsb |
 *		Buffer to use when copying temp files around
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	Returns a HVF or NULL
 *
 ***************************************************************************/

PUBLIC HVF FAR EXPORT_API VFileOpen( FID fidParent,
	FILEOFFSET foBase, FILEOFFSET foBlock, FILEOFFSET foExtra, DWORD dwFlags, 
	LPSHAREDBUFFER lpsb, PHRESULT phr )
{	
	HVF hvf=NULL;
	QVFILE qvf;

	assert(dwFlags&(VFOPEN_READ|VFOPEN_READWRITE));
	assert(dwFlags&(VFOPEN_ASFID|VFOPEN_ASTEMP));
	assert((dwFlags&(VFOPEN_READ|VFOPEN_READWRITE))!=(VFOPEN_READ|VFOPEN_READWRITE));
	assert((dwFlags&(VFOPEN_ASFID|VFOPEN_ASTEMP))!=(VFOPEN_ASFID|VFOPEN_ASTEMP));
	
	if (!(hvf=_GLOBALALLOC(GMEM_ZEROINIT| GMEM_MOVEABLE,
		sizeof(VFILE))))
	{	
		SetErrCode(phr, E_OUTOFMEMORY);
		goto exit0;
	}

	if (!(qvf=_GLOBALLOCK(hvf)))
	{	
		SetErrCode(phr, E_OUTOFMEMORY);
		goto exit1;
	}

	_INITIALIZECRITICALSECTION(&qvf->cs);
	
	qvf->fidParent=fidNil;
	qvf->fidTemp=fidNil;
	qvf->fmTemp=fmNil;
	qvf->lpsb=lpsb;
	
	if ( (fidParent!=fidNil) && (!FoEquals(FoAddFo(foBlock,foExtra),foNil)) )
	{	
		qvf->foEof=foBlock;
		qvf->foCurrent=foNil;
		qvf->fidParent=fidParent;
		qvf->foBase=foBase;
		qvf->foBlock=FoAddFo(foBlock,foExtra);
		qvf->fidTemp=fidNil;
		qvf->fmTemp=fmNil;
		qvf->dwFlags=VFF_FID;
		
	 	if (dwFlags&VFOPEN_READWRITE)
			qvf->dwFlags|=VFF_READWRITE;
		else
			qvf->dwFlags|=VFF_READ;

		if (dwFlags&VFOPEN_ASTEMP)
		{ 	
			// Convert to temp file
			VFileSetTemp(hvf);
		}
	}
	else
	{
	 	if (dwFlags&VFOPEN_ASTEMP)
		{
			if (dwFlags&VFOPEN_READ)
			{	
				SetErrCode(phr, E_INVALIDARG);
				goto exit2;
			}
			
			// Opening as temp, no parent
			if ((qvf->fmTemp=FmNewTemp(NULL, phr))!=fmNil)
			{
			 	if ((qvf->fidTemp=FidCreateFm(qvf->fmTemp,wReadWrite,wReadWrite,phr))!=fidNil)
				{	
					  qvf->dwFlags=VFF_TEMP|VFF_READWRITE;
				}
				else
				{	
					DisposeFm(qvf->fmTemp);
					qvf->fmTemp=fmNil;			   	
					SetErrCode(phr, E_HANDLE);
					goto exit2;				
				}
			}
			else
			{	
				SetErrCode(phr, E_OUTOFMEMORY);
				goto exit2;			
			}
		}
		else
		{
			SetErrCode(phr, E_INVALIDARG);
			goto exit2;
		}	
	}
	
	
	_GLOBALUNLOCK(hvf);
	return hvf;

	exit2:
		_DELETECRITICALSECTION(&qvf->cs);
		_GLOBALUNLOCK(hvf);
	exit1:
		_GLOBALFREE(hvf);
	exit0:
		return NULL;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HRESULT PASCAL FAR | VFileSetTemp |
 *		Force vfile's data to reside in a temp file
 *
 *  @parm	HVF | hvf |
 *		Handle to virtual file
 *
 *	@rdesc	Returns various ERR_ messages, or S_OK
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API VFileSetTemp( HVF hvf )
{
 	QVFILE qvf;
	HRESULT errb;

	errb=S_OK;

	assert(hvf);
	if (!(qvf=_GLOBALLOCK(hvf)))
	{	
		SetErrCode(&errb, E_OUTOFMEMORY);
		goto exit0;
	}

	_ENTERCRITICALSECTION(&qvf->cs);

	if (qvf->dwFlags&VFF_FID)
	{
		assert(qvf->fmTemp==fmNil);

		if ((qvf->fmTemp=FmNewTemp(NULL, &errb))!=fmNil)
		{
		 	if ((qvf->fidTemp=FidCreateFm(qvf->fmTemp,wReadWrite,wReadWrite,&errb))!=fidNil)
			{	
				// Transfer qvf->foEof bytes from parent to temp
				
				_ENTERCRITICALSECTION(&qvf->lpsb->cs);
				
				if (!FoEquals(FoSeekFid(qvf->fidParent,qvf->foBase,wSeekSet,&errb),qvf->foBase))
				{
				 	exit2:
						_LEAVECRITICALSECTION(&qvf->lpsb->cs);
					   	RcCloseFid(qvf->fidTemp);
						qvf->fidTemp=fidNil;
						RcUnlinkFm(qvf->fmTemp);					
						DisposeFm(qvf->fmTemp);
						qvf->fmTemp=fmNil;
					   	goto exit1;					
				}
				
				
				if (RcCopyFileBuf(qvf->fidTemp,qvf->fidParent, qvf->foEof, NULL, 
					qvf->lpsb->lpvBuffer,qvf->lpsb->lcbBuffer)==S_OK)
				{
				   	qvf->dwFlags=(qvf->dwFlags&(~VFF_FID))|VFF_TEMP;
					qvf->foCurrent=qvf->foEof;
				}
				else
				{  
					goto exit2;
				}
				_LEAVECRITICALSECTION(&qvf->lpsb->cs);				   	
			}
			else
			{	
				DisposeFm(qvf->fmTemp);
				qvf->fmTemp=fmNil;			   	
				goto exit1;
			}
		}
		else
		{
			goto exit1;			 	
		}
	}

	exit1:
		_LEAVECRITICALSECTION(&qvf->cs);
		_GLOBALUNLOCK(hvf);	
	exit0:
		return errb;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HRESULT PASCAL FAR | VFileSetBase |
 *		Moves file's data from temporary file into parent's file
 *
 *  @parm	HVF | hvf |
 *		Handle to virtual file
 *
 *  @parm	FID | fidParent |
 *		Parent file to move data into
 *
 *	@parm	FILEOFFSET | foBase |
 *		Base location in parent file
 *
 *	@parm	FILEOFFSET | foBlock |
 *		Largest area in parent file we are allowed to write to
 *
 *	@rdesc	Returns a S_OK or error
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API VFileSetBase( HVF hvf, FID fid, FILEOFFSET foBase, FILEOFFSET foBlock)
{
 	QVFILE qvf;
	HRESULT errb;

	errb=S_OK;

	assert(hvf);
	if (!(qvf=_GLOBALLOCK(hvf)))
	{	
		SetErrCode(&errb, E_OUTOFMEMORY);
		goto exit0;
	}

	_ENTERCRITICALSECTION(&qvf->cs);

	if (qvf->dwFlags&VFF_TEMP)
	{	
		if (FoCompare(qvf->foEof,foBlock)<=0)
		{
			// Transfer file
			if (!FoEquals((qvf->foCurrent=FoSeekFid(qvf->fidTemp, foNil, wSeekSet, &errb)),foNil))
			{
			 	goto exit1;
			}

			qvf->foBase=foBase;
			qvf->foBlock=foBlock;
			qvf->fidParent=fid;

			_ENTERCRITICALSECTION(&qvf->lpsb->cs);
				
			if (!FoEquals(FoSeekFid(qvf->fidParent,qvf->foBase,wSeekSet,&errb),qvf->foBase))
			{
			 	exit2:
			 		_LEAVECRITICALSECTION(&qvf->lpsb->cs);
					goto exit1;
			}

			if (RcCopyFileBuf(qvf->fidParent, qvf->fidTemp, qvf->foEof, NULL, 
				qvf->lpsb->lpvBuffer,qvf->lpsb->lcbBuffer)==S_OK)
			{
				qvf->dwFlags=(qvf->dwFlags&(~VFF_TEMP))|VFF_FID;
				RcCloseFid(qvf->fidTemp);
				qvf->fidTemp=fidNil;				
				RcUnlinkFm(qvf->fmTemp);									
				DisposeFm(qvf->fmTemp);
				qvf->fmTemp=fmNil;			   	
				qvf->foCurrent=qvf->foEof;
			}
			else
			{
				goto exit2;				
			}
			_LEAVECRITICALSECTION(&qvf->lpsb->cs);			
		}
		else
		{
		 	// Parent Filespace too small for temp file
			SetErrCode(&errb, E_OUTOFRANGE);
		}
	}
	else
		// Can only set the base of a temp file
		SetErrCode(&errb, E_ASSERT);

	exit1:
 		_LEAVECRITICALSECTION(&qvf->cs);
		_GLOBALUNLOCK(hvf);	
	exit0:
		return errb;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HRESULT PASCAL FAR | VFileSetEOF |
 *		Sets the size of the virtual file (and moves it into a temp file if
 *		necessary)
 *
 *  @parm	HVF | hvf |
 *		Handle to virtual file
 *
 *  @parm	FILEOFFSET | foEof |
 *		New End Of File position
 *
 *	@rdesc	Returns a S_OK or error
 *
 *	@comm
 *		May write out as far as foEof without causing a transfer
 *		from Parent file to Temp file
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API VFileSetEOF( HVF hvf, FILEOFFSET foEof )
{
 	QVFILE qvf;
	HRESULT rc = S_OK;

	assert(hvf);
	if (!(qvf=_GLOBALLOCK(hvf)))
	{	
		rc=E_OUTOFMEMORY;
		goto exit0;
	}

	if (qvf->dwFlags&VFF_FID)
	{
	 	if (FoCompare(foEof,qvf->foBlock)>0)
		{
		 	// Must transfer to temp file first
			if ((rc=VFileSetTemp(hvf))!=S_OK)
				goto exit1;
		}
		else
		{
		 	// Just update pointer
			qvf->foEof = foEof;			
		}
	}

	if (qvf->dwFlags&VFF_TEMP)
	{
		if (foEof.dwHigh==0)
		{
			if ((rc=RcChSizeFid(qvf->fidTemp, foEof.dwOffset)) == S_OK)
			{
			 	qvf->foEof=foEof;
			}
		}
		else
		{
		 	// There is not ChSizeFid for super long files
		 	qvf->foEof=foEof; 
		}	
	}

	exit1:
		_GLOBALUNLOCK(hvf);	
	exit0:
		return rc;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	FILEOFFSET PASCAL FAR | VFileGetSize |
 *		Get the file size		
 *
 *  @parm	HVF | hvf |
 *		Handle to virtual file
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	File Size in bytes, if zero, check phr
 *
 ***************************************************************************/

PUBLIC FILEOFFSET PASCAL FAR EXPORT_API VFileGetSize( HVF hvf, PHRESULT phr )
{
 	QVFILE qvf;
	FILEOFFSET foSize=foNil;

	assert(hvf);
	
	if (!(qvf=_GLOBALLOCK(hvf)))
	{	
		SetErrCode(phr, E_OUTOFMEMORY);
		goto exit0;
	}

	foSize=qvf->foEof;

	_GLOBALUNLOCK(hvf);	
	exit0:
		return foSize;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	DWORD PASCAL FAR | VFileGetFlags |
 *		Get the file VFF_ flags
 *
 *  @parm	HVF | hvf |
 *		Handle to virtual file
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	Any combination of VFF_ flags
 *
 ***************************************************************************/

PUBLIC DWORD PASCAL FAR EXPORT_API VFileGetFlags( HVF hvf, PHRESULT phr )
{
 	QVFILE qvf;
	DWORD dwFlags=0L;
	
	assert(hvf);
	
	if (!(qvf=_GLOBALLOCK(hvf)))
	{	
		SetErrCode(phr, E_OUTOFMEMORY);
		goto exit0;
	}

	dwFlags=qvf->dwFlags;

	_GLOBALUNLOCK(hvf);	
	exit0:
		return dwFlags;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	LONG PASCAL FAR | VFileSeekRead |
 *		Read data from a location in the file
 *
 *  @parm	HVF | hvf |
 *		Handle to virtual file
 *
 *  @parm	FILEOFFSET | foSeek |
 *		Seek location before read
 *
 *	@parm	LPVOID | lpvBuffer |
 *		Buffer for read data
 *
 *	@parm	DWORD | dwcb |
 *		Number of bytes to read
 *
 *	@parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	Number of bytes read.  If != dwcb, check phr
 *
 ***************************************************************************/

PUBLIC LONG PASCAL FAR EXPORT_API VFileSeekRead( HVF hvf, FILEOFFSET foSeek, LPVOID lpvBuffer, 
	DWORD dwcb, PHRESULT phr )
{
 	QVFILE qvf;
	LONG lTotalRead=0L;

	assert(hvf);
	
	if (!(qvf=_GLOBALLOCK(hvf)))
	{	
		SetErrCode(phr, E_OUTOFMEMORY);
		goto exit0;
	}

	_ENTERCRITICALSECTION(&qvf->cs);
				   	
	if (qvf->dwFlags&VFF_FID)
	{	
		if (FoCompare(foSeek,qvf->foBlock)< 0)
		{
			DWORD dwCanRead;
			FILEOFFSET foSeeked;
			
			if (qvf->dwFlags&VFF_FID)
			{
				if (FoCompare(FoAddDw(foSeek,dwcb),qvf->foBlock)<0)
					dwCanRead=FoSubFo(FoAddDw(foSeek,dwcb),foSeek).dwOffset;
				else
					dwCanRead=FoSubFo(qvf->foBlock,foSeek).dwOffset;
			}
			else
			{
				dwCanRead = dwcb;				
			}

			if (dwCanRead!=dwcb)
				SetErrCode(phr, E_FILEREAD);

			foSeeked=FoAddFo(qvf->foBase,foSeek);
			
			if (!FoEquals(FoSeekFid(qvf->fidParent, foSeeked, wSeekSet, phr),foSeeked))
			{	
				goto exit1;
			}
			
			lTotalRead=LcbReadFid(qvf->fidParent,lpvBuffer,dwCanRead,phr);
			
			// Try twice to read, in case it's a simple error that reading a second time
			// will help
			if (lTotalRead!=(long)dwCanRead)
			{
				if (!FoEquals(FoSeekFid(qvf->fidParent, foSeeked, wSeekSet, phr),foSeeked))
				{	
				 	goto exit1;
				}
				lTotalRead=LcbReadFid(qvf->fidParent,lpvBuffer,dwCanRead,phr);
			}
		}
		else
		{
			SetErrCode(phr, E_FILESEEK);
			goto exit1;
		}
	}
	else
	{
		// Seek and read from temp file
		if (!FoEquals(qvf->foCurrent,foSeek))
		{
			if ( (FoCompare(foSeek,qvf->foCurrent)<0) && (qvf->dwFlags&VFF_DIRTY))
			{
				qvf->dwFlags&=(~VFF_DIRTY);
				// call DOS file commit to correct DOS bug?
			}
			
			if (!FoEquals((qvf->foCurrent=FoSeekFid(qvf->fidTemp, foSeek, wSeekSet, phr)),foSeek))
			{
			 	goto exit1;
			}			
		}

		lTotalRead=LcbReadFid(qvf->fidTemp,lpvBuffer,dwcb,phr);		
		qvf->foCurrent=FoAddDw(qvf->foCurrent,lTotalRead);
	}

	exit1:
		_LEAVECRITICALSECTION(&qvf->cs);
		_GLOBALUNLOCK(hvf);	
	exit0:
		return lTotalRead;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	LONG PASCAL FAR | VFileSeekWrite |
 *		Write data to a location in the file
 *
 *  @parm	HVF | hvf |
 *		Handle to virtual file
 *
 *  @parm	FILEOFFSET | foSeek |
 *		Seek location before write
 *
 *	@parm	LPVOID | lpvBuffer |
 *		Buffer to write
 *
 *	@parm	DWORD | dwcb |
 *		Number of bytes to write
 *
 *	@parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	Number of bytes written.  If != lcb, check phr
 *
 ***************************************************************************/

PUBLIC LONG PASCAL FAR EXPORT_API VFileSeekWrite( HVF hvf, FILEOFFSET foSeek, LPVOID lpvBuffer, 
	DWORD dwcb, PHRESULT phr )
{
 	QVFILE qvf;
	LONG lWritten=0L;

	assert(hvf);
	
	if (!(qvf=_GLOBALLOCK(hvf)))
	{	
		SetErrCode(phr, E_OUTOFMEMORY);
		goto exit0;
	}

	_ENTERCRITICALSECTION(&qvf->cs);
				   	
	if (qvf->dwFlags&VFF_READWRITE)
	{
		DWORD dwCanWrite;
		
		if (qvf->dwFlags&VFF_FID)
		{
		 	if (FoCompare(FoAddDw(foSeek,dwcb),qvf->foBlock)<0)
				dwCanWrite=FoSubFo(FoAddDw(foSeek,dwcb),foSeek).dwOffset;
			else
				dwCanWrite=FoSubFo(qvf->foBlock,foSeek).dwOffset;
		}
		else
		{
			dwCanWrite=dwcb;
		}

		
		if ((qvf->dwFlags&VFF_FID) && ((long)dwCanWrite < (long)dwcb))
		{
			// Transfer to temp file first
			if ((*phr=VFileSetTemp(hvf))!=S_OK)
				goto exit1;
			dwCanWrite=dwcb;
		}

		if (qvf->dwFlags&VFF_FID)
		{	
			FILEOFFSET foSeeked;
			
			assert(FoCompare(foSeek,qvf->foBlock) < 0);

			foSeeked=FoAddFo(qvf->foBase,foSeek);
			
			if (!FoEquals(FoSeekFid(qvf->fidParent, foSeeked, wSeekSet, phr),foSeeked))
			{	
			 	goto exit1;
			}
			
			lWritten=LcbWriteFid(qvf->fidParent,lpvBuffer,dwCanWrite,phr);

			foSeek=FoAddDw(foSeek,lWritten);
			if (FoCompare(foSeek,qvf->foEof)>0)
				qvf->foEof=foSeek;
			
		}
		else
		{
			// Seek and write to temp file
			if (!FoEquals(qvf->foCurrent,foSeek))
			{	
				if ((FoCompare(foSeek,qvf->foCurrent)<0) && (qvf->dwFlags&VFF_DIRTY))
				{
					qvf->dwFlags&=(~VFF_DIRTY);
					// call DOS file commit to correct DOS bug?
				}
			
				if (!FoEquals((qvf->foCurrent=FoSeekFid(qvf->fidTemp, foSeek, wSeekSet, phr)),foSeek))
				{
				 	goto exit1;
				}
			}

			lWritten=LcbWriteFid(qvf->fidTemp,lpvBuffer,dwcb,phr);		
			qvf->foCurrent=FoAddDw(qvf->foCurrent,lWritten);
			if (FoCompare(qvf->foCurrent,qvf->foEof)>0)
				qvf->foEof=qvf->foCurrent;

			// Just used in case of DOS non-flushing bug
			qvf->dwFlags|=VFF_DIRTY;			
		}
	}
	else
	{
		SetErrCode(phr, E_NOPERMISSION);
	}

	exit1:
		_LEAVECRITICALSECTION(&qvf->cs);				   	
		_GLOBALUNLOCK(hvf);	
	exit0:
		return lWritten;
}


/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	LONG PASCAL FAR | VFileClose |
 *		Close a virtual file (file should reside in parent before closing)
 *
 *  @parm	HVF | hvf |
 *		Handle to virtual file
 *
 *	@rdesc	S_OK or E_FILECLOSE if data resides in temp file
 *
 *	@comm
 *		<p hvf> Invalid if successful
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API VFileClose( HVF hvf )
{
 	QVFILE qvf;
	HRESULT rc = S_OK;

	assert(hvf);
	
	if (!(qvf=_GLOBALLOCK(hvf)))
	{	
		rc=E_OUTOFMEMORY;
		goto exit0;
	}

	if (qvf->dwFlags&VFF_FID)
	{
		assert(qvf->fmTemp==fmNil);
		assert(qvf->fidTemp==fidNil);

		_DELETECRITICALSECTION(&qvf->cs);
		_GLOBALUNLOCK(hvf);
		_GLOBALFREE(hvf);
		return rc;
	}
	else
	{
		// Call VFileSetBase to place file back into parent, or
		// Call VFileAbandon first, then close since we are trying to close a
		// vfile that still resides in a temp file, and not in a valid parent
		rc=E_FILECLOSE;
		goto exit1;
	}
	
	exit1:
		_GLOBALUNLOCK(hvf);	
	exit0:
		return rc;

}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	LONG PASCAL FAR | VFileAbandon |
 *		Removes temporary file, and sets file's data to be in old parent
 *		file location.  Should only call if hvf needs closing, but the data
 *		is not to be transferred back into a parent file
 *
 *  @parm	HVF | hvf |
 *		Handle to virtual file
 *
 *	@rdesc	S_OK or E_ASSERT if data already resides in parent
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API VFileAbandon( HVF hvf )
{
 	QVFILE qvf;
	HRESULT rc = S_OK;

	assert(hvf);
	
	if (!(qvf=_GLOBALLOCK(hvf)))
	{	
		rc=E_OUTOFMEMORY;
		goto exit0;
	}

	if (qvf->dwFlags&VFF_TEMP)
	{
		RcCloseFid(qvf->fidTemp);
		qvf->fidTemp=fidNil;				
		RcUnlinkFm(qvf->fmTemp);					
		DisposeFm(qvf->fmTemp);
		qvf->fmTemp=fmNil;			   	
		qvf->dwFlags=(qvf->dwFlags&(~VFF_TEMP))|VFF_FID;
	}
	else
	{
		// Can't abandon an Fid, since Abandon means to abondon 
		// the Temp file

		rc=E_ASSERT;
	}
		
	_GLOBALUNLOCK(hvf);	
	exit0:
		return rc;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HRESULT PASCAL FAR | RcCopyFileBuf |
 *		Copy a file using buffer that must be passed in by user
 *
 *  @parm	FID | fidDst |
 *		Destination file fid
 *
 *  @parm	FID | fidSrc |
 *		Source file fid
 *
 *  @parm	FILEOFFSET | foSize |
 *		Number of bytes to copy
 *
 *  @parm	PROGFUNC | lpfnProg |
 *		Progress callback function (may be NULL).  Callback should return non-zero 
 *		to cancel copy operation.
 *
 *  @parm	LPVOID | lpvBuf |
 *		Buffer to use during copy
 *
 *  @parm	LONG | lcbBuf |
 *		Size of lpvBuf
 *
 *	@rdesc	S_OK, ERR_INTERRUPT or any file error.  File pointers in 
 *		fidDst and fidSrc must be pre-positioned before calling.
 *
 ***************************************************************************/

HRESULT PASCAL NEAR RcCopyFileBuf(FID fidDst, FID fidSrc, FILEOFFSET foSize, PROGFUNC lpfnProg, LPVOID lpvBuf, LONG lcbBuf)
{
#ifdef MOSMAP // {
    // Disable function
    return ERR_NOTSUPPORTED;
#else // } {
    QB     qb = (QB)lpvBuf;
    DWORD  dwT, dwChunk=(DWORD)lcbBuf;
    HRESULT   errb;
	FILEOFFSET foTemp;

	assert(lpvBuf);
	assert(lcbBuf);

    errb = S_OK;
	foTemp.dwHigh=0;		

    do
    {
        // perform a progress callback
        if (lpfnProg != NULL)  
        {
            if ((*lpfnProg)(0)!=0) 
            {
                return E_INTERRUPT;
            }
        }

        if (!foSize.dwHigh)
	        dwT = min(dwChunk, foSize.dwOffset);
		else
			dwT=dwChunk;

        if (LcbReadFid( fidSrc, qb, (LONG)dwT, &errb) != (LONG)dwT )
        {
            dwT = (DWORD)-1L;
            break;
        }

        if (LcbWriteFid( fidDst, qb, (LONG)dwT, &errb) != (LONG)dwT )
        {
            dwT = (DWORD)-1L;
            break;
        }

        foTemp.dwOffset=dwT;
        foSize=FoSubFo(foSize,foTemp);
    }
    while (!FoIsNil(foSize));

    return errb;
#endif //}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\util\dynarray.c ===
/*************************************************************************
*                                                                        *
*  DYNARRAY.C                                                            *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1994-1995                         *
*  All Rights reserved.                                                  *
*                                                                        *
* This library implements a robust dynamic array scheme. It replaces the *
* old DRG structure and should probably also replace the MR.             *
* The total size of the array is NOT limited to 64K since it uses        *
* Binh's threaded block memory manager to add new elements. Therefore it *
* should work correctly on both 16- and 32-bit platforms for any number  *
* of elements.                                                           *
*                                                                        *                                                                   *
* Items in the array are assumed to be of a fixed size, which is defined *
* when the array is first initialized.  To speed up the common operation *
* of forward enumeration, the next element function/macro is provided.   *
*                                                                        *                                                                        *
* There are two types of lists possible:  normal, and single-block       *
* Use single-block for better space and possible more efficient time     *
* usage when you know that your entire array will fit within a block.    *
* Allocations beyond the one block limit will return NULL.               *
*                                                                        *                                                                    *
* The first member of any element in the array MUST be an LPVOID.        *                                                                                                                                   *
* UNIMPLEMENTED: Insert into, delete                                     *
**************************************************************************
*                                                                        *
**************************************************************************
*                                                                        *
*  Written By   : KevynCT                                                *
*  Current Owner: KevynCT                                                *
*                                                                        *
**************************************************************************/
#include <mvopsys.h>
#include <orkin.h>
#include <mem.h>
#include <_mvutil.h>
#include <dynarray.h>

#ifdef _DEBUG
static BYTE NEAR s_aszModule[] = __FILE__;
#endif

#define DYN_ARRAY_IS_SINGLEBLOCK(lpdl) ((lpdl)->dwFlags & DYN_ARRAY_SINGLEBLOCK)
#define DYN_ARRAY_SINGLEBLOCK_NEXT(lpdl, lpFoo) (((LPBYTE)lpFoo) + ((lpdl)->cbFoo))

#define DYN_ARRAY_SIZEOF_NEXT(lpdl)     ( DYN_ARRAY_IS_SINGLE_BLOCK(lpdl) ? 0: sizeof(LPVOID))
#define NEXT_POINTER(lpFoo)     (*(LPVOID FAR *)(lpFoo))


/// These are macros defined in the include file
/*************************************************************************
 *  @doc    INTERNAL RETRIEVAL
 *
 *  @func   DWORD | DynArrayGetNumElts |
 *    Return the number of elements currently in the list
 *
 *  @parm   LPDL | lpdl |
 *      Pointer to DynArray struct
 *
 *    @rdesc  None
 *
 *    @comm    
 *       
 *                Probably a macro
 *************************************************************************/
/*************************************************************************
 *  @doc    INTERNAL RETRIEVAL
 *
 *  @func   LPVOID | DynArrayGetFirstElt |
 *    Return a pointer to the head of the list
 *
 *  @parm   LPDL | lpdl |
 *      Pointer to DynArray struct
 *
 *    @rdesc  
 *
 *    @comm    
 *       
 *               Probably a macro
 *************************************************************************/
/*************************************************************************
 *  @doc    INTERNAL RETRIEVAL
 *
 *  @func   LPVOID |  DynArrayGetCurElt |
 *    Returns the "current" element in the list
 *
 *  @parm   LPDL | lpdl |
 *      Pointer to DynArray struct
 *
 *    @rdesc  A valid pointer, or NULL if no current element has been set
 *
 *    @comm    
 *       Any operation ending in "Elt" will set the current elt pointer
 *               Probably a macro
 *************************************************************************/
/*************************************************************************
 *  @doc    INTERNAL RETRIEVAL
 *
 *  @func   VOID | DynArraySetCurElt |
 *    Set the "current" element in the list
 *
 *  @parm   LPDL | lpdl |
 *      Pointer to DynArray struct
 *                      LPVOID | lpvo |
 *              Pointer to a valid list element returned by one of the other
 *    element functions.
 *
 *    @rdesc  None
 *
 *    @comm    
 *       Probably a macro
 * 
 *************************************************************************/
#ifdef SINGLE_BLOCK
BOOL PASCAL FAR DynArraySingleBlockInit(LPDL lpdl, DWORD BlockSize, WORD wElemSize, DWORD dwFlags)
{
	if (lpdl && BlockSize && wElemSize)
	{
		MEMSET(lpdl, 0, sizeof(DL));
		// single-block linked list
		if (lpdl->lpBlockHead = BlockInitiate (BlockSize, wElemSize, 1, 0))
		{
			lpdl->lpFooHead = BlockGetElement(lpdl->lpBlockHead);
			lpdl->lpFooFree = lpdl->lpFooHead;
			lpdl->cbFoo = wElemSize;
			lpdl->cFooPerBlock = BLOCKMGR_BLOCKSIZE(lpdl->lpBlockHead) / wElemSize;
			lpdl->dwFlags = dwFlags | DYN_ARRAY_SINGLEBLOCK;
			return TRUE;
		}
	}

	return FALSE;
}
#endif

/*************************************************************************
 *  @doc    INTERNAL RETRIEVAL
 *
 *  @func   BOOL PASCAL FAR | DynArrayInit |
 *     Initializes the given DynArray struct to prepare the DynArray for use.
 *
 *  @parm   LPDL | lpdl |
 *      Pointer to uninitialized DynArray struct
 *
 *                      DWORD | BlockSize |
 *              The size of each block in bytes
 *
 *                      WORD | cMaxBlock |
 *              The maximum number of blocks to be allowed
 *
 *                      WORD | wElemSize |
 *              The fixed size of each element of the array
 *
 *                      DWORD | dwFlags |
 *              Specifies attributes of the list
 *
 *    @rdesc  TRUE if successful, NULL otherwise
 *
 *    @comm    
 *       
 * 
 *************************************************************************/
BOOL PASCAL FAR DynArrayInit(LPDL lpdl, DWORD BlockSize, WORD cMaxBlock, WORD wElemSize, DWORD dwFlags)
{
	if (lpdl && BlockSize && wElemSize && cMaxBlock)
	{
		MEMSET(lpdl, 0, sizeof(DL));
		if (lpdl->lpBlockHead = BlockInitiate (BlockSize, wElemSize, cMaxBlock, 0))
		{
			lpdl->lpFooHead = NULL;
			lpdl->lpFooFree = lpdl->lpFooHead;
			lpdl->cbFoo = wElemSize;
			lpdl->cFooPerBlock = (WORD) BLOCKMGR_BLOCKSIZE(lpdl->lpBlockHead) / wElemSize;
			lpdl->dwFlags = dwFlags;
			return TRUE;
		}
	}

	return FALSE;
}

#ifdef SINGLE_BLOCK
LPVOID PASCAL FAR DynArraySingleBlockAppendElt(lpdl)
{
	Assert(lpdl);   
	Assert(lpdl->lpFooFree);
	Assert(lpdl->dwFlags & DYN_ARRAY_SINGLEBLOCK);

	lpdl->lpFooCache = lpdl->lpFooFree;
	lpdl->lpFooFree = BlockGetElement(lpdl->lpBlockHead);
	lpdl->cFoo++;

	return lpFoo->lpFooCache;

}
#endif

/*************************************************************************
 *  @doc    INTERNAL RETRIEVAL
 *
 *  @func   LPVOID PASCAL FAR | DynArrayAppendElt |
 *     Appends a new element to the end of the list
 *
 *  @parm   LPDL | lpdl |
 *      Pointer to DynArray struct
 *
 *    @rdesc Returns a pointer to the newly created elt, or NULL on failure
 *
 *    @comm    
 *       
 * 
 *************************************************************************/
LPVOID PASCAL FAR DynArrayAppendElt(LPDL lpdl)
{
	LPVOID lpFooNext;

	Assert(lpdl);   
//	Assert(lpdl->lpFooFree);

	// lpFooFree is always non-NULL and points to the next free element in the list.  if this will be the last element in 
	// a block, then lpFooFree->lpNext will be NULL, and we will need to allocate the next block and link it into the list

	if (lpFooNext = BlockGetElement(lpdl->lpBlockHead))
	{   
		if (!lpdl->lpFooHead)
		{
			lpdl->lpFooHead = lpFooNext;
			lpdl->lpFooFree = lpFooNext;
		}
		else
		{
			NEXT_POINTER(lpdl->lpFooFree) = lpFooNext;
		}
				
		lpdl->lpFooFree = lpFooNext;
		lpdl->lpFooCache = lpdl->lpFooFree;
		lpdl->cFoo++;
		NEXT_POINTER(lpdl->lpFooFree) = NULL;

		return lpdl->lpFooCache;
		
	}
	return NULL;
}

#ifdef SINGLE_BLOCK
INLINE LPVOID PASCAL FAR DynArraySingleBlockGetOrdinalElt(LPDL lpdl, DWORD dwEltIndex)
{
	LPVOID lpv;

	Assert(lpdl);   
	Assert(lpdl->dwFlags & DYN_ARRAY_SINGLEBLOCK);

	if (dwEltIndex < lpdl->cFoo)
	{
		return (((LPBYTE)lpdl->lpFooHead) + (dwEltIndex % lpdl->cFooPerBlock) * lpdl->cbFoo);
	}
	return NULL;
}
#endif

/*************************************************************************
 *  @doc    INTERNAL RETRIEVAL
 *
 *  @func   LPVOID PASCAL FAR | DynArrayGetOrdinalElt |
 *     Retrieve pointer to the start of i-th element in the list (starting at zero)
 *
 *  @parm   LPDL | lpdl |
 *      Pointer to DynArray struct
 *                      DWORD | dwEltIndex |
 *              Index of element to retrieve
 *
 *    @rdesc  Pointer to elt if successful, NULL otherwise
 *
 *    @comm    
 *  Finds N-th element in the linked list.  Zero is first element
 *  Use this only if the list was NOT created insertable, i.e. append-only       
 * 
 *************************************************************************/
LPVOID PASCAL FAR DynArrayGetOrdinalElt(LPDL lpdl, DWORD dwEltIndex)
{
	LPBYTE lpb;

	Assert(lpdl);   

	if (dwEltIndex < lpdl->cFoo)
	{
		// the faster way: calc the block number and the offset within the block, and go directly there.                            
		if (lpb = BlockGetOrdinalBlock(lpdl->lpBlockHead, (WORD)(dwEltIndex / lpdl->cFooPerBlock)))
			return (lpdl->lpFooCache = (lpb + (dwEltIndex % lpdl->cFooPerBlock) * lpdl->cbFoo));
	}
	return NULL;
}

#if 0
/*************************************************************************
 *  @doc    INTERNAL RETRIEVAL
 *
 *  @func   LPVOID PASCAL FAR | DynArrayInsertableGetElt |
 *      Retrieve pointer to the start of i-th element in the list (starting at zero)
 *
 *  @parm   LPDL | lpdl |
 *      Pointer to DynArray struct
 *                      DWORD | dwEltIndex |
 *              Index of element to retrieve
 *
 *    @rdesc  Pointer to elt if successful, NULL otherwise
 *
 *    @comm    
 *  Finds N-th element in the linked list.  Zero is first element
 *  Use this only if the list was NOT created insertable, i.e. append-only       
 * 
 *************************************************************************/
LPVOID PASCAL FAR DynInsertableListGetElt(LPDL lpdl, DWORD dwEltIndex)
{
	LPVOID lpv;

	Assert(lpdl);   

	// need to find it the long way since pointers may no longer be contiguous within a block after an insertion.
	for (lpv = lpdl->lpFooHead; dwEltIndex && lpv; lpv = NEXT_POINTER(lpThis), dwEltIndex--)
		;

	if (lpv) lpdl->lpFooCache = lpv;
	return lpv;     
}

#endif

#ifdef SINGLE_BLOCK
INLINE LPVOID PASCAL FAR DynArraySingleBlockNextElt(LPDL lpdl)
{
	Assert(lpdl);
	Assert(lpdl->lpFooCache);
	Assert(lpdl->dwFlags & DYN_ARRAY_SINGLEBLOCK);

	return (lpdl->lpFooCache = DYN_ARRAY_SINGLEBLOCK_NEXT(lpdl, lpdl->lpFooCache));
}
#endif
#if 0
/*************************************************************************
 *  @doc    INTERNAL RETRIEVAL
 *
 *  @func   LPVOID PASCAL FAR | DynArrayNextElt |
 *     Get next element in list after the current one.
 *
 *  @parm   LPDL | lpdl |
 *      Pointer to DynArray struct
 *
 *    @rdesc  Pointer to  elt  if successful, NULL otherwise
 *
 *    @comm    
 *        Responsibility of caller to know when current element is NULL
 *    This function will execute quickly.
 *
 *************************************************************************/
_inline LPVOID PASCAL FAR DynArrayNextElt(LPDL lpdl)
{
	Assert(lpdl);
	Assert(lpdl->lpFooCache);

	return (lpdl->lpFooCache = NEXT_POINTER(lpdl->lpFooCache));
}
#endif
#if 1
/*************************************************************************
 *  @doc    INTERNAL RETRIEVAL
 *
 *  @func   LPVOID PASCAL FAR | DynArrayClearElt |
 *     Zero-inits the current element, but does not harm NEXT link of the elt.
 *
 *  @parm   LPDL | lpdl |
 *      Pointer to DynArray struct
 *
 *    @rdesc Pointer to current element if there is one, NULL otherwise.
 *
 *    @comm    
 *       
 * 
 *************************************************************************/

LPVOID PASCAL FAR DynArrayClearElt(LPDL lpdl)
{
	Assert(lpdl);   

	if (lpdl->lpFooCache)
	{
		MEMSET((LPBYTE)(lpdl->lpFooCache) + sizeof(LPVOID), 0, lpdl->cbFoo - sizeof(LPVOID));
		return lpdl->lpFooCache;
	}
	return NULL;
}
#endif

/*************************************************************************
 *  @doc    INTERNAL RETRIEVAL
 *
 *  @func   VOID PASCAL FAR | DynArrayFree |
 *     Free any memory that was allocated for the given dynlist over the
 *  course of its life.
 *
 *  @parm   LPDL | lpdl |
 *      Pointer to uninitialized DynArray struct
 *
 *    @rdesc None
 *
 *    @comm    
 *       
 * 
 *************************************************************************/
VOID PASCAL FAR DynArrayFree(LPDL lpdl)
{
	Assert(lpdl);   

	BlockFree(lpdl->lpBlockHead);
	MEMSET(lpdl, 0, sizeof(DL));
}

/*************************************************************************
 *  @doc    INTERNAL RETRIEVAL
 *
 *  @func   VOID PASCAL FAR | DynArrayReset |
 *    Pretend we never added any elements to this list, but don't free mem.
 *
 *  @parm   LPDL | lpdl |
 *      Pointer to uninitialized DynArray struct
 *
 *    @rdesc  None
 *
 *    @comm    
 *       
 * 
 *************************************************************************/
VOID PASCAL FAR DynArrayReset(LPDL lpdl)
{
	Assert(lpdl);   

	BlockReset(lpdl->lpBlockHead);
	lpdl->lpFooHead = NULL;
	lpdl->lpFooFree = lpdl->lpFooHead;
	lpdl->cFoo = 0;
}

// UNIMPLEMENTED:  DELETE and INSERT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\util\bfnew.c ===
#include <mvopsys.h>
#include <orkin.h>
#include <mem.h>
#include "bfnew.h"

#if defined(_DEBUG)
static char * s_aszModule = __FILE__;   /* For error report */
#endif

#ifndef MAXWORD
#define MAXWORD ((WORD)0xffff)
#endif

/***************************************************************************
 *
 -  Name        DynBufferAlloc
 -
 *  Purpose
 *    Creates a new buffer.
 *
 *  Arguments
 *    int cIncr:     Minimum increment size for this buffer.
 *
 *  Returns
 *    Pointer to a new buffer.  Returns pNil on OOM.
 *
 *  +++
 *
 *  Notes
 *
 ***************************************************************************/
LPBF DynBufferAlloc( DWORD cIncr )
{
	LPBF pbf;
	HANDLE hnd;

	if ((hnd = _GLOBALALLOC ((GMEM_MOVEABLE|GMEM_ZEROINIT), sizeof (BF) )) == NULL)
		return NULL;

	pbf = (LPBF)_GLOBALLOCK (hnd);
	pbf->hnd = hnd;

	pbf->cIncr = cIncr;
	pbf->cbMax = cIncr;
	pbf->cbSize = 0;

	if ((pbf->hBuf = _GLOBALALLOC (GMEM_MOVEABLE | GMEM_ZEROINIT,
		(LONG)cIncr)) == 0) {
		_GLOBALUNLOCK( hnd);
		_GLOBALFREE (hnd);
		return NULL;
	}

	pbf->qBuffer = _GLOBALLOCK (pbf->hBuf);
	return pbf;
}

// inserts the given data at the byte position given by the argument.
// returns a pointer to the buffer at that byte position if successful.
LPBYTE DynBufferInsert(LPBF lpbf, DWORD lib, LPBYTE qbData, SHORT cbData)
{
	LPBYTE lpbInsert;
	//LPBYTE lpbCur;
	int cbSizeOld = lpbf->cbSize;

	// grow the buffer by cbData bytes
	if ((cbData == 0) || !DynBufferEnsureAdd(lpbf, cbData))
		return NULL;
	
	assert( lpbf->cbMax >= lpbf->cbSize + cbData );

	// note that we set these vars here, since DynBufferEnsure may cause a resize
	lpbInsert = (LPBYTE)(lpbf->qBuffer) + lib;
 	//lpbCur = (LPBYTE)(lpbf->qBuffer) + cbSizeOld;  // first byte of expanded buffer

	// shift the existing data down if necessary
	//if (lpbCur != lpbInsert)
		MEMMOVE(lpbInsert + cbData, lpbInsert, cbSizeOld - lib);

	// bring in new stuff if necessary
	if (qbData)
		MEMCPY(lpbInsert, qbData, cbData);

	lpbf->cbSize += cbData;
	return lpbInsert;

}

/***************************************************************************
 *
 -  Name        DynBufferAppend
 -
 *  Purpose
 *    Adds data to a buffer.
 *
 *  Arguments
 *    PBF   -- pointer to buffer.
 *    QV    -- pointer to data to copy.
 *    WORD -- amount of data to copy.
 *
 *  Returns
 *    rcOutOfMemory if we run out of memory
 *    rcFailure if we try to add more than 64K bytes of data to the
 *       buffer
 *    rcSuccess otherwise.
 *
 *  +++
 *
 *  Notes
 *
 ***************************************************************************/
LPBYTE DynBufferAppend(LPBF lpbf, LPBYTE qData, DWORD cb )
{

	if (!DynBufferEnsureAdd(lpbf, cb))
		return NULL;

	assert( lpbf->cbMax >= lpbf->cbSize + cb );

	if (qData)
		MEMCPY ((LPBYTE)lpbf->qBuffer + lpbf->cbSize, qData, cb);

	lpbf->cbSize += cb;
	return((LPBYTE)(lpbf->qBuffer));
}

// Ensures that there is space in the buffer to
// add <w> bytes
BOOL InternalEnsureAdd(LPBF lpbf, DWORD w)
{

#ifndef _WIN32
	if (lpbf->cbSize > 0xffff - w)
		return FALSE;
#endif

	if (w > lpbf->cIncr)
		lpbf->cbMax += w;
	else
		lpbf->cbMax += lpbf->cIncr;

	_GLOBALUNLOCK (lpbf->hBuf);

	if ((lpbf->hBuf =_GLOBALREALLOC (lpbf->hBuf,
		(LONG)lpbf->cbMax, GMEM_MOVEABLE | GMEM_ZEROINIT)) == 0) 
	{
		lpbf->qBuffer = NULL;
		return FALSE;
	}
	lpbf->qBuffer = _GLOBALLOCK (lpbf->hBuf);

	return TRUE;
}

/***************************************************************************
 *
 -  Name        DynBufferFree
 -
 *  Purpose
 *    Frees an allocated buffer.
 *
 *  Arguments
 *    Pointer to buffer.
 *
 *  Returns
 *    nothing.
 *
 *  +++
 *
 *  Notes
 *    See also EmptyPbf, which empties the buffer but leaves it available
 *    for re-use.
 *
 ***************************************************************************/
VOID DynBufferFree( LPBF pbf )
{
	HANDLE hnd;

	if (pbf == 0)
		return;

	if (hnd = pbf->hBuf)
	{
		_GLOBALUNLOCK (hnd);
		_GLOBALFREE(hnd);
	}
	if (hnd = pbf->hnd)
	{
		_GLOBALUNLOCK(hnd);
		_GLOBALFREE (hnd);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\breakers\engstem.cpp ===
/*************************************************************************
*  @doc SHROOM EXTERNAL API                                              *
*																		 *
*  ENGSTEM.CPP                                                           *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1997                              *
*  All Rights reserved.                                                  *
*                                                                        *
*  This file contains the implementation of CITEngStemmer methods.       *
*  CITEngStemmer is a pluggable word stemer object.					     *
*  Although all the word breaking interface methods that accept text	 *
*  require it to be Unicode, CITEngStemmer still only supports ANSI		 *
*  internally.															 *
*																	     *
**************************************************************************
*                                                                        *
*  Written By   : Bill Aloof	                                         *
*  Current Owner: billa		                                             *
*                                                                        *
**************************************************************************/

#include <mvopsys.h>

#ifdef _DEBUG
static char s_aszModule[] = __FILE__;   /* For error report */
#endif

#include <atlinc.h>	    // includes for ATL. 
#include <_mvutil.h>
#include <mem.h>
#include <orkin.h>
#include <mvsearch.h>
#include "common.h"
#include <iterror.h>
#include <itstem.h>
#include <itwbrkid.h>
#include "engstem.h"

										

//---------------------------------------------------------------------------
//						Constructor and Destructor
//---------------------------------------------------------------------------


CITEngStemmer::CITEngStemmer()
{
	ClearMembers();
	m_hmem1 = m_hmem2 = NULL;
	m_cbBuf1Cur = m_cbBuf2Cur = 0;
}

CITEngStemmer::~CITEngStemmer()
{
	Close();
}


//---------------------------------------------------------------------------
//						IStemmer Method Implementations
//---------------------------------------------------------------------------


/********************************************************************
 * @method    STDMETHODIMP | IStemmer | Init |
 *     Gives the stemmer object a chance to initialize itself beyond
 *	   what it did during IPersistStreamInit::InitNew or ::Load.
 * @parm ULONG | ulMaxTokenSize | Max term length requested by caller
 * @parm BOOL* | pfLicense | Whether the stemmer is subject to a license
 *
 * @rvalue E_POINTER | pfLicense was NULL
 *
 ********************************************************************/
STDMETHODIMP
CITEngStemmer::Init(ULONG ulMaxTokenSize, BOOL *pfLicense)
{
	HRESULT	hr;
	
	if (pfLicense == NULL)
		return (SetErrReturn(E_POINTER));

	// If we haven't been initialized yet (i.e. no call was made to either
	// IPersistStreamInit::InitNew or Load), we'll initialize ourselves now.
	// This allows Tripoli clients to use us without any code changes on their
	// part.  If we have already been initialized, the caller has had a chance
	// to correctly set the lcid, so we check it now; otherwise, we want to
	// still give the caller a chance to set it correctly.
	if (m_fInitialized)
		hr = (PRIMARYLANGID(LANGIDFROMLCID(m_stemctl.lcid)) == LANG_ENGLISH ?
																S_OK : E_FAIL);
	else
		hr = InitNew();
		
	if (SUCCEEDED(hr))
		*pfLicense = FALSE;
				
	// NOTE: We don't support internal truncation of terms based on
	// ulMaxTokenSize.  This is OK since the word sink is supposed to be
	// prepared to have to truncate anyway.

	return (hr);
}


/********************************************************************
 * @method    STDMETHODIMP | IStemmer | StemWord |
 *     stems the input word and calls the methods of IStemSink with the results. 
 *	   
 * @parm WCHAR const | *pwcInBuf | Input Unicode word.
 * @parm ULONG | cwc | count of Unicode characters in the input word.
 * @parm IStemSink | *pStemSink | Pointer to the stemmer sink.
 * 
 * 
 * 
 * @rvalue E_WORDTOOLONG | cwc is larger than 0x7FFF
 * @rvalue E_POINTER | Either the input buffer or *pStemSink is NULL. 
 * @rvalue S_OK | The operation completed successfully. 
 *
 ********************************************************************/
STDMETHODIMP
CITEngStemmer::StemWord(WCHAR const *pwcInBuf, ULONG cwc, IStemSink *pStemSink)
{
	HRESULT		hr = S_OK;

	if (pwcInBuf == NULL || pStemSink == NULL)
		return (SetErrReturn(E_POINTER));

	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	if (PRIMARYLANGID(LANGIDFROMLCID(m_stemctl.lcid)) != LANG_ENGLISH)
		return (SetErrReturn(E_FAIL));
			
	if (cwc > 0x7FFF)
		return (SetErrReturn(E_WORDTOOLONG));
		
	m_cs.Lock();

	// We allocate enough space for a worst case Unicode ---> MBCS conversion
	// and allow an extra word for a length prefix that we will add later.
	// This is probably overly cautious because we shouldn't be seeing any
	// DBCS anyway (we're an English stemmer).
	if (SUCCEEDED(hr = ReallocBuffer(&m_hmem1, &m_cbBuf1Cur,
								(sizeof(WCHAR) * cwc) + sizeof(WORD))))
	{
		LPBYTE	lpbRawWord;
		
		lpbRawWord = (LPBYTE) _GLOBALLOCK(m_hmem1);

		// REVIEW (billa): Need to make sure that the word being stemmed is in
		// lower case.

		// Convert the raw word to ANSI.
		if ((*((WORD *)lpbRawWord) =
					(WORD) WideCharToMultiByte(m_stemctl.dwCodePageID, NULL, 
				  			pwcInBuf, cwc, (char *)lpbRawWord + sizeof(WORD),
				  			(m_cbBuf1Cur - sizeof(WORD)), NULL, NULL)) > 0)
		{
			
			// We want the buffer we allocate for the stemmed word to be larger
			// than the raw word length so that we can handle the rare case
			// where the stemmed word has grown.  We can just use the raw word
			// buffer size because it included a lot of extra padding.
			if (SUCCEEDED(hr = ReallocBuffer(&m_hmem2, &m_cbBuf2Cur,
															m_cbBuf1Cur)))
			{		
				LPBYTE	lpbStemWord;
				
				lpbStemWord = (LPBYTE) _GLOBALLOCK(m_hmem2);
				
 				if (SUCCEEDED(hr = FStem(lpbStemWord, lpbRawWord)))
 				{
 					WCHAR	*lpwchStem;
 					DWORD	cwchStem;
 					DWORD	cbStemWord;
 					
 					_GLOBALUNLOCK(m_hmem1);
					cwchStem = cbStemWord = (DWORD)(*((WORD *)lpbStemWord));
  					hr = ReallocBuffer(&m_hmem1, &m_cbBuf1Cur,
  												sizeof (WCHAR) * cbStemWord);
  					
  					// Relock buffer even if we've failed the realloc
  					// so that the unlock we do later is valid.  An
  					// unconditional relock is OK because ReallocBuffer
  					// won't invalidate the original m_hmem1 if it fails. 
  					lpwchStem = (WCHAR *) _GLOBALLOCK(m_hmem1);
  					
  					// Convert the stem word back to Unicode so that we can
					// call the stem sink.
					if ((cwchStem =
							MultiByteToWideChar(m_stemctl.dwCodePageID, NULL, 
								(LPCSTR)lpbStemWord + sizeof(WORD), cbStemWord, 
													lpwchStem, cwchStem)) > 0)
					{
						// Send the raw word to the word sink.
						hr = pStemSink->PutWord(lpwchStem, cwchStem);
					}
					else
						hr = E_UNEXPECTED;
				}
 				
 				_GLOBALUNLOCK(m_hmem2);
			}
		}
		else
			hr = E_UNEXPECTED;

		_GLOBALUNLOCK(m_hmem1);
	}

	m_cs.Unlock();

	return (hr);
}

/*****************************************************************
 * @method    STDMETHODIMP | IStemmer | GetLicenseToUse |
 * 
 * Not yet implemented
 *
 ****************************************************************/
STDMETHODIMP
CITEngStemmer::GetLicenseToUse(WCHAR const **ppwcsLicense)
{
	return (E_NOTIMPL);
}


//---------------------------------------------------------------------------
//						IStemmerConfig Method Implementations
//---------------------------------------------------------------------------


/*****************************************************************
 * @method    STDMETHODIMP | IStemmerConfig | SetLocaleInfo |
 * Sets locale information that affects the stemming
 * behavior of IStemmer::StemWord.
 * @parm DWORD | dwCodePageID | ANSI code page no. specified at build time.
 * @parm LCID | lcid | Win32 locale identifier specified at build time.
 *
 * @rvalue S_OK | Locale described by the parameters is supported
 * @rvalue E_INVALIDARG | Locale described by the parameters is not supported. 
 * 
 *
 ****************************************************************/
STDMETHODIMP
CITEngStemmer::SetLocaleInfo(DWORD dwCodePageID, LCID lcid)
{
	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));
		
	if (PRIMARYLANGID(LANGIDFROMLCID(lcid)) != LANG_ENGLISH)
		return (SetErrReturn(E_INVALIDARG));

	m_cs.Lock();

	m_stemctl.dwCodePageID = dwCodePageID;
	m_stemctl.lcid = lcid;
	m_fDirty = TRUE;

	m_cs.Unlock();

	return (S_OK);
}


/*****************************************************************
 * @method    STDMETHODIMP | IStemmerConfig | GetLocaleInfo |
 * Gets locale information that affects the stemming
 * behavior of IStemmer::StemWord.
 * @parm DWORD | *pdwCodePageID | Pointer to code page identifier
 * @parm LCID | *plcid | Pointer to Win32 locale identifier.
 *
 * @rvalue S_OK | Locale described by the parameters is supported
 * @rvalue E_INVALIDARG | Locale described by the parameters is not supported. 
 * 
 *
 ****************************************************************/
STDMETHODIMP
CITEngStemmer::GetLocaleInfo(DWORD *pdwCodePageID, LCID *plcid)
{
	if (pdwCodePageID == NULL || plcid == NULL)
		return (SetErrReturn(E_POINTER));

	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	m_cs.Lock();

	*pdwCodePageID = m_stemctl.dwCodePageID;
	*plcid = m_stemctl.lcid;

	m_cs.Unlock();

	return (S_OK);
}

/*****************************************************************
 * @method    STDMETHODIMP | IStemmerConfig | SetControlInfo |
 * Sets information that controls certain aspects of stemming. 
 * 
 * @parm DWORD | grfStemFlags | Flags that control stemming behavior. 
 * @parm DWORD | dwReserved | Reserved for future use. 
 *
 * @rvalue S_OK | The operation completed successfully. 
 * 
 * @comm
 * In the future, additional information may be passed in through
 * dwReserved.
 ****************************************************************/

STDMETHODIMP
CITEngStemmer::SetControlInfo(DWORD grfStemFlags, DWORD dwReserved)
{
	DWORD	grfFlagsUnsupported;

	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	grfFlagsUnsupported = ~(0);

	if ((grfStemFlags & grfFlagsUnsupported) != 0)
		return (SetErrReturn(E_INVALIDARG));

	m_cs.Lock();

	m_stemctl.grfStemFlags = grfStemFlags;
	m_fDirty = TRUE;

	m_cs.Unlock();

	return (S_OK);
}


/*****************************************************************
 * @method    STDMETHODIMP | IStemmerConfig | GetControlInfo |
 * Gets information that controls stemming behavior. 
 * 
 * @parm DWORD | *pgrfStemFlags | Pointer to flags that control stemming behavior. 
 * @parm DWORD | *pdwReserved | Reserved for future use. 
 *
 * @rvalue S_OK | The operation completed successfully. 
 * 
 ****************************************************************/
STDMETHODIMP
CITEngStemmer::GetControlInfo(DWORD *pgrfStemFlags, DWORD *pdwReserved)
{
	if (pgrfStemFlags == NULL)
		return (SetErrReturn(E_POINTER));

	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	*pgrfStemFlags = m_stemctl.grfStemFlags;

	return (S_OK);
}


/*****************************************************************
 * @method STDMETHODIMP | IStemmerConfig | LoadExternalStemmerData |
 * Loads external stemmer data, such as word part lists. 
 *
 * @parm IStream | *pStream | Pointer to stream object containing 
 * stenner data. 
 * @parm DWORD | dwExtDataType | Data type. 
 * 
 * @comm
 * Not implemented yet. 
 ****************************************************************/
STDMETHODIMP
CITEngStemmer::LoadExternalStemmerData(IStream *pStream, DWORD dwExtDataType)
{
	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	return (E_NOTIMPL);
}


//---------------------------------------------------------------------------
//						IPersistStreamInit Method Implementations
//---------------------------------------------------------------------------


STDMETHODIMP
CITEngStemmer::GetClassID(CLSID *pclsid)
{
	if (pclsid == NULL)
		return (SetErrReturn(E_POINTER));

	*pclsid = CLSID_ITEngStemmer;
	return (S_OK);
}


STDMETHODIMP
CITEngStemmer::IsDirty(void)
{
	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	return (m_fDirty ? S_OK : S_FALSE);
}


STDMETHODIMP
CITEngStemmer::Load(IStream *pStream)
{
	HRESULT	hr;
	DWORD	dwVersion;
	DWORD	grfPersistedItems;
	DWORD	cbRead;

	if (pStream == NULL)
		return (SetErrReturn(E_POINTER));

	// Lock before checking m_fInitialized to make sure we don't compete
	// with a call to ::InitNew.
	m_cs.Lock();

	if (m_fInitialized)
		return (SetErrReturn(E_ALREADYOPEN));

	if (SUCCEEDED(hr = pStream->Read((LPVOID) &dwVersion, sizeof(DWORD),
																&cbRead)) &&
		SUCCEEDED(hr = ((cbRead == sizeof(DWORD)) ? S_OK : E_BADFORMAT)) &&
		SUCCEEDED(hr = ((dwVersion == VERSION_ENGSTEMMER) ? S_OK :
															E_BADVERSION)) &&
		SUCCEEDED(hr = pStream->Read((LPVOID) &grfPersistedItems,
													sizeof(DWORD), &cbRead)) &&
		SUCCEEDED(hr = ((cbRead == sizeof(DWORD)) ? S_OK : E_BADFORMAT)) &&
		grfPersistedItems != 0)
	{
		if ((grfPersistedItems & ITSTDBRK_PERSISTED_STEMCTL) != 0)
		{
			if (SUCCEEDED(hr =
					pStream->Read((LPVOID) &m_stemctl, sizeof(STEMCTL), &cbRead)))
				hr = ((cbRead == sizeof(STEMCTL)) ? S_OK : E_BADFORMAT);
		}
		else
		{
			// It is a surprise not to find the STEMCTL structure in the stream,
			// but we can continue on because we will initialize the structure
			// with good defaults before we exit this routine.
			ITASSERT(FALSE);
		}

	}

	if (SUCCEEDED(hr))
	{
		if ((grfPersistedItems & ITSTDBRK_PERSISTED_STEMCTL) == 0)
		{
			InitStemCtl();

			// Set flag in case we're asked to save.
			grfPersistedItems |= ITSTDBRK_PERSISTED_STEMCTL;
		}

		m_grfPersistedItems = grfPersistedItems;
		m_fInitialized = TRUE;
	}
	else
		// Free any peristed items which may have been loaded successfully.
		Close();

	m_cs.Unlock();
	return (hr);
}


STDMETHODIMP
CITEngStemmer::Save(IStream *pStream, BOOL fClearDirty)
{
	HRESULT	hr;
	DWORD	dwVersion;
	DWORD	cbWritten;

	if (pStream == NULL)
		return (SetErrReturn(E_POINTER));

	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	m_cs.Lock();

	dwVersion = VERSION_ENGSTEMMER;
	if (SUCCEEDED(hr = pStream->Write((LPVOID) &dwVersion, sizeof(DWORD),
															&cbWritten)) &&
		SUCCEEDED(hr = pStream->Write((LPVOID) &m_grfPersistedItems,
												sizeof(DWORD), &cbWritten)))
	{
		if ((m_grfPersistedItems & ITSTDBRK_PERSISTED_STEMCTL) != 0)
			hr = pStream->Write((LPVOID) &m_stemctl, sizeof(STEMCTL),
																&cbWritten);
		else
		{
			// We should always be writing the STEMCTL structure, but if for
			// some reason the flag to write it is not set, we can still continue
			// because at load time we will tolerate the absence of the struct.
			ITASSERT(FALSE);
		}

	}

	if (SUCCEEDED(hr) && fClearDirty)
		m_fDirty = FALSE;

	m_cs.Unlock();

	return (hr);
}


STDMETHODIMP
CITEngStemmer::GetSizeMax(ULARGE_INTEGER *pcbSizeMax)
{
	return (E_NOTIMPL);
}


STDMETHODIMP
CITEngStemmer::InitNew(void)
{
	// Lock before checking m_fInitialized to make sure we don't compete
	// with a call to ::Load.
	m_cs.Lock();

	if (m_fInitialized)
		return (SetErrReturn(E_ALREADYOPEN));

	InitStemCtl();
	m_grfPersistedItems |= ITSTDBRK_PERSISTED_STEMCTL;
	m_fInitialized = TRUE;

	m_cs.Unlock();
	return (S_OK);
}


//---------------------------------------------------------------------------
//						Private Method Implementations
//---------------------------------------------------------------------------


HRESULT
CITEngStemmer::ReallocBuffer(HGLOBAL *phmemBuf, DWORD *pcbBufCur, DWORD cbBufNew)
{
	HRESULT hr = S_OK;

	m_cs.Lock();

	hr = ReallocBufferHmem(phmemBuf, pcbBufCur, max(cbBufNew, cbAnsiBufInit));

	m_cs.Unlock();

	return (hr);
}


void
CITEngStemmer::ClearMembers(void)
{
	MEMSET(&m_stemctl, NULL, sizeof(STEMCTL));
	m_fInitialized = m_fDirty = FALSE;
	m_grfPersistedItems = 0;
}


void
CITEngStemmer::InitStemCtl(void)
{
	m_stemctl.dwCodePageID = GetACP();
	
	// If the user default language is not English, we'll store the
	// value and check it in IStemmer::Init and ::StemWord.
	m_stemctl.lcid = GetUserDefaultLCID();
	m_stemctl.grfStemFlags = 0;
}


void
CITEngStemmer::Close(void)
{
	if (m_hmem1 != NULL)
	{
		_GLOBALFREE(m_hmem1);
		m_hmem1 = NULL;
		m_cbBuf1Cur = 0;
	}

	if (m_hmem2 != NULL)
	{
		_GLOBALFREE(m_hmem2);
		m_hmem2 = NULL;
		m_cbBuf2Cur = 0;
	}

	ClearMembers();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\util\blockmgr.c ===
/*************************************************************************
*                                                                        *
*  BLOCKMGR.C                                                            *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   Memory block management.                                             *
*   Consider the case of creating a string table.                        *
*      1/ First we have to allocate a block of memory                    *
*      2/ Then we copy all the strings into the block, until we run out  *
*         space.                                                         *
*      3/ Either we will increase the size of the memory block (using    *
*         _frealloc(), which requires the block's size < 64K, or _halloc *
*         which require huge pointers, or we allocate another block of   *
*         memory, and connected the 2nd block to the 1st block           *
*                                                                        *
*   The purpose of this module is to providesimple interface when        *
*   handling memory block in the second scenario.                        *
*                                                                        *
*   The block manager will allocate one initiale memory block, and as    *
*   memory need arises, more block of memory are allocated transparently *
*   An example of how to use the memory block manager would be:          *
*                                                                        *
*        lpBlock = BlockInitiate (BlockSize, wElemSize);                 *
*        for (i = 0; condition; i++) {                                   *
*            if ((Array[i] = BlockCopy (lpBlock, Buffer, BufLen))        *
*                == NULL)                                                *
*               Error();                                                 *
*        }                                                               *
*                                                                        *
*   Advantages:                                                          *
*     - Caller doesn't have to worry about how much room is left         *
*     - We can use the maximum memory space if needed to                 *
*     - We don't have to use huge pointers                               *
*                                                                        *
*   Comments:                                                            *
*     This scheme doesn't assume how memory are used/referenced. To      *
*     satisfy all the needs, the memory blocks have to be locked         *
*     permanently. This may cause OOM problems when the memory is        *
*     extremely fragmented, and garbage collection is hampered by not    *
*     being able to move the block around. The problem is minimized if   *
*     the block's size is large (ie. minimize fragmentation), which is   *
*     usually the case                                                   *
*     Anyway, loking and unlocking problem should go away on 32-bit      *
*     and above system                                                   *
**************************************************************************
*                                                                        *
*  Written By   : Binh Nguyen                                            *
*  Current Owner: Binh Nguyen                                            *
*                                                                        *
**************************************************************************/

#include <mvopsys.h>
#include <misc.h>
#include <memory.h>     // For _fmemcpy
#include <mem.h>
#include <_mvutil.h>

#ifdef _DEBUG
static  BYTE s_aszModule[] = __FILE__;  // Used by error return functions.
#endif

/* Stamp to do some limited validation checking */
#define    BLOCK_STAMP    1234

/*************************************************************************
 *
 *                    INTERNAL PRIVATE FUNCTIONS
 *  All of them should be declared near
 *************************************************************************/
PRIVATE int PASCAL NEAR BlockInitialize (LPBLK, BLOCK FAR *);

/*************************************************************************
 *
 *                    INTERNAL PUBLIC FUNCTIONS
 *  All of them should be declared far, and included in some include file
 *************************************************************************/
PUBLIC LPB PASCAL FAR BlockReset (LPV);
PUBLIC VOID PASCAL FAR BlockFree (LPV);
PUBLIC LPV PASCAL FAR BlockInitiate (DWORD, WORD, WORD, int);
PUBLIC LPV PASCAL FAR BlockCopy (LPV, LPB, DWORD, WORD);
PUBLIC LPV PASCAL FAR BlockGetElement(LPV);
PUBLIC int PASCAL FAR BlockGrowth (LPV);
PUBLIC LPB PASCAL FAR BlockGetLinkedList(LPV);
PUBLIC LPV PASCAL FAR GlobalLockedStructMemAlloc (DWORD);
PUBLIC VOID PASCAL FAR GlobalLockedStructMemFree (HANDLE FAR *);

/*************************************************************************
 *  @doc    INTERNAL RETRIEVAL
 *
 *  @func   VOID PASCAL NEAR | BlockThreadElement |
 *      This function will thread all the elements of a memory block
 *      into a linked list
 *
 *  @parm   LPB | lpbBuf |
 *      Pointer to memory buffer
 *
 *  @parm   DWORD | BufSize |
 *      Total buffer's size
 *
 *  @parm   WORD | wElemSize |
 *      Element's size
 *************************************************************************/
PRIVATE VOID PASCAL NEAR BlockThreadElement (LPB lpbBuf, DWORD BufSize,
    WORD wElemSize)
{
    register DWORD cElem;

    if (wElemSize == 0)
        return;

    for (cElem = BufSize / wElemSize; cElem > 1; cElem --)
    {
        *(LPB UNALIGNED *UNALIGNED)lpbBuf = lpbBuf + wElemSize;
        lpbBuf += wElemSize;
    }
    *(LPB UNALIGNED *UNALIGNED)lpbBuf = NULL;
}

/*************************************************************************
 *  @doc    INTERNAL RETRIEVAL
 *
 *  @func   int PASCAL FAR | BlockGrowth |
 *      Create another memory block and link it into the block list
 *
 *  @parm   LPBLK | lpBlockHead |
 *      Pointer to block manager node
 *
 *    @rdesc    S_OK, or E_OUTOFMEMORY, or E_INVALIDARG
 *
 *    @comm    This function should be called externally only in the case
 *        of running out of threaded data.
 *************************************************************************/
PUBLIC int PASCAL FAR BlockGrowth (LPBLK lpBlockHead)
{
    BLOCK FAR *lpBlock;
    DWORD BlockSize;

    if (lpBlockHead == NULL)
        return E_INVALIDARG;

    BlockSize = lpBlockHead->cBytePerBlock;

    /* Check to see if we already allocate the block. This happens
     * after calling BlockReset(), all the blocks are still there
     * unused and linked together
     */
    if (lpBlockHead->lpCur->lpNext == NULL)
    {
        /* Ensure that we did not pass the limit number of blocks allowed */

        if (lpBlockHead->cCurBlockCnt >= lpBlockHead->cMaxBlock)
            return E_OUTOFMEMORY;
        lpBlockHead->cCurBlockCnt ++;

        if (lpBlockHead->fFlag & USE_VIRTUAL_MEMORY)
        {
#ifndef _MAC // {_MAC
            DWORD size = (DWORD)(BlockSize + sizeof(BLOCK));
            
            if ((lpBlock =  _VIRTUALALLOC(NULL, size, MEM_COMMIT,
				PAGE_READWRITE)) == NULL)
            {
                return E_OUTOFMEMORY;
            }
            _VIRTUALLOCK(lpBlock, size);
#endif // } _MAC
        }
        else 
        {
            /* Allocate a new block */
            if ((lpBlock = GlobalLockedStructMemAlloc 
                ((DWORD)(BlockSize + sizeof(BLOCK)))) == NULL)
            {
                return E_OUTOFMEMORY;
            }
            
        }
        lpBlock->wStamp = BLOCK_STAMP;
    }
    else
        lpBlock = lpBlockHead->lpCur->lpNext;

    /* Link the block into the list */
    lpBlockHead->lpCur->lpNext = lpBlock;

    if (lpBlockHead->fFlag & THREADED_ELEMENT)
    {
        BlockThreadElement ((LPB)lpBlock + sizeof(BLOCK),
            BlockSize, lpBlockHead->wElemSize);
    }

    /* Update all information */
    return BlockInitialize (lpBlockHead, lpBlock);
}

/*************************************************************************
 *    @doc    INTERNAL RETRIEVAL
 *
 *    @func    int PASCAL NEAR | BlockInitialize |
 *        Iniitalize the fields of the block manager structure
 *
 *    @parm    LPBLK | lpBlockHead |
 *        Pointer to the block manager structure
 *
 *    @parm    BLOCK FAR * | lpBlock |
 *        Pointer to the block of memory
 *
 *    @rdesc    S_OK if succeeded, else other errors
 *************************************************************************/
PRIVATE int PASCAL NEAR BlockInitialize (LPBLK lpBlockHead, BLOCK FAR *lpBlock)
{
    /* Validity check */
    if (lpBlockHead == NULL || lpBlock == NULL)
        return E_INVALIDARG;

    /* Update all information */
    lpBlockHead->lpCur = lpBlock;
    lpBlockHead->lpbCurLoc = (LPB)lpBlock + sizeof(BLOCK);
    lpBlockHead->lTotalSize += lpBlockHead->cBytePerBlock + sizeof(BLOCK);

    /* If the memory block is threaded, then set cByteLeft = 0. This
     * to ensure that whoever use threaded blocks have to manage their
     * own linked list blocks, and ensure that calls to BlockGetElement()
     * will ultimately fail
     */

    lpBlockHead->cByteLeft = (lpBlockHead->fFlag & THREADED_ELEMENT) ?
        0 : lpBlockHead->cBytePerBlock;
    return S_OK;
}

/*************************************************************************
 *    @doc    INTERNAL RETRIEVAL
 *
 *    @func    LPB PASCAL FAR | BlockReset |
 *        Reset the block manager, ie. just start from beginning without
 *        releasing the memory blocks
 *
 *    @parm    LPBLK | lpBlockHead |
 *        Pointer to the block manager structure
 *
 *    @rdesc    Pointer to start of the buffer, or NULL if errors. This is to
 *        ensure that if the block is threaded, we returned the pointer of
 *        the first element in the list
 *************************************************************************/
PUBLIC LPB PASCAL FAR BlockReset (LPBLK lpBlockHead)
{
    /* Check for block validity */
    if (lpBlockHead == NULL || lpBlockHead->wStamp != BLOCK_STAMP)
        return NULL;

    /* Update all information, start from the beginning of the list */

    lpBlockHead->lpCur = lpBlockHead->lpHead;
    lpBlockHead->lpbCurLoc = (LPB)lpBlockHead->lpCur + sizeof(BLOCK);
    lpBlockHead->lTotalSize = lpBlockHead->cBytePerBlock + sizeof(BLOCK);

    /* Do the threading if necessary */
    if ((lpBlockHead->fFlag & THREADED_ELEMENT))
    {
        BlockThreadElement(lpBlockHead->lpbCurLoc, lpBlockHead->cBytePerBlock,
            lpBlockHead->wElemSize);

        /* Ensure that BlockGetElement() will fail, ie. the user must
         * handle the linked list of elements himself.
         */
        lpBlockHead->cByteLeft = 0;
    }
    else
        lpBlockHead->cByteLeft = lpBlockHead->cBytePerBlock;
    return lpBlockHead->lpbCurLoc;
}

/*************************************************************************
 *    @doc    INTERNAL RETRIEVAL
 *
 *    @func    VOID PASCAL FAR | BlockFree |
 *        Free the block manager strucutre and all the memory blocks 
 *        associated with it
 *
 *    @parm    LPBLK | lpBlockHead |
 *        Pointer to block manager structure
 *************************************************************************/
PUBLIC VOID PASCAL FAR BlockFree (LPBLK lpBlockHead)
{
    BLOCK FAR *lpBlock;
    BLOCK FAR *lpNextBlock;

    /* Check for block validity */
    if (lpBlockHead == NULL || lpBlockHead->wStamp != BLOCK_STAMP)
        return;

    /* Free all memory block associated with the block manager */
    for (lpBlock = lpBlockHead->lpHead; lpBlock; lpBlock = lpNextBlock)
    {
        lpNextBlock = lpBlock->lpNext;

        /* Only free the block if it is valid */
        if (lpBlock->wStamp == BLOCK_STAMP)
        {
            if (lpBlockHead->fFlag & USE_VIRTUAL_MEMORY)
            {
#ifndef _MAC // { _MAC
                _VIRTUALUNLOCK (lpBlock, lpBlockHead->cBytePerBlock +
                    sizeof(BLOCK));
                _VIRTUALFREE (lpBlock, 0L, (MEM_DECOMMIT | MEM_RELEASE));
#endif  // } _MAC
            }
        
            else
                GlobalLockedStructMemFree ((LPV)lpBlock);
        }
    }

    /* Free the block manager */
    GlobalLockedStructMemFree((LPV)lpBlockHead);
}

/*************************************************************************
 *    @doc    INTERNAL RETRIEVAL
 *
 *    @func    LPV PASCAL FAR | BlockInitiate |
 *        Initiate and allocate memory block for block management
 *
 *    @parm    DWORD | BlockSize |
 *        Block's size. The block size should less than 0xffff - 16 -
 *        sizeof(BLOCK) for 16-bit build
 *
 *    @parm    WORD | wElemSize |
 *        Size of an element, useful for fixed size data structure
 *
 *    @parm    WORD | cMaxBlock
 *        Maximum number of blocks that can be allocated. 0 means 64K
 *
 *    @parm    int | flag |
 *         - THREADED_ELEMENT : if the elements are to be threaded together into a
 *        linked list
 *         - USE_VIRTUAL_MEMORY : if virtual memory is to be used
 *
 *    @rdesc    Return pointer to a block management structure, or NULL
 *        if OOM
 *************************************************************************/
PUBLIC LPV PASCAL FAR BlockInitiate (DWORD BlockSize, WORD wElemSize,
    WORD cMaxBlock, int flag)
{
    LPBLK    lpBlockHead;
    BLOCK FAR *lpBlock;

    /* Check for valid size. We add
     *    - sizeof(BLOCK)
     *    - 16 bytes to ensure that we never cross the 64K limit boundary
     */

#ifndef _32BIT
    if (BlockSize >= (unsigned)0xffff - sizeof(BLOCK) - 16)
        return NULL;
#endif

    /* Allocate a block head. All fields are zero's except when
     * initialized
     */

    if ((lpBlockHead = GlobalLockedStructMemAlloc(sizeof(BLOCK_MGR))) == NULL)
        return NULL;

    /* Allocate a memory block */
    if (flag & USE_VIRTUAL_MEMORY)
    {
#ifndef _MAC // { _MAC
        DWORD size = (DWORD)(BlockSize + sizeof(BLOCK));
        
        if ((lpBlockHead->lpHead = lpBlock = 
            _VIRTUALALLOC(NULL, size, MEM_COMMIT, PAGE_READWRITE)) == NULL)
        {
            GlobalLockedStructMemFree((LPV)lpBlockHead);
            return NULL;
        }
        if (_VIRTUALLOCK(lpBlock, size) == 0)
        	GetLastError();
#endif  // } _MAC

    }
    else
    {
        if ((lpBlockHead->lpHead = lpBlock = 
            GlobalLockedStructMemAlloc((DWORD)(BlockSize +
            sizeof(BLOCK)))) == NULL)
        {
            GlobalLockedStructMemFree((LPV)lpBlockHead);
            return NULL;
        }
    }
    lpBlock->wStamp = BLOCK_STAMP;

    /* Initialization block manager structure */

    lpBlockHead->wStamp = BLOCK_STAMP;
    lpBlockHead->lpCur = lpBlock;
    lpBlockHead->cByteLeft = lpBlockHead->cBytePerBlock = BlockSize;
    lpBlockHead->lpbCurLoc = (LPB)lpBlock + sizeof(BLOCK);
    lpBlockHead->wElemSize = wElemSize;
    lpBlockHead->lTotalSize = BlockSize + sizeof(BLOCK);
    if (cMaxBlock == 0)
        lpBlockHead->cMaxBlock = 0xffff;
    else
        lpBlockHead->cMaxBlock = cMaxBlock;

    lpBlockHead->cCurBlockCnt = 1;    /* We have 1 block in the list */

    if ((lpBlockHead->fFlag = (WORD)flag) & THREADED_ELEMENT)
    {
        BlockThreadElement (lpBlockHead->lpbCurLoc, BlockSize, wElemSize);
    }
    return lpBlockHead;
}


/*************************************************************************
 *    @doc    INTERNAL RETRIEVAL
 *
 *    @func    LPV PASCAL FAR | BlockCopy |
 *        Copy a buffer into the memory block. The function will allocate
 *        more memory if needed
 *
 *    @parm    LPBLK | lpBlockHead |
 *        Pointer to manager block
 *
 *    @parm    LPB | Buffer |
 *        Buffer to be copied:  if this is NULL, the alloc is done, but
 *        no copy is performed.
 *
 *    @parm    DWORD | BufSize |
 *        Size of the buffer
 *
 *    @parm    WORD | wStartOffset |
 *        Offset of the start of the buffer. Extra memory is needed to
 *        accomodate the offset. This is needed because we use have
 *        {structure+buffer} structure. The starting offset would be
 *        the size of the structure
 *
 *    @rdesc
 *        Return pointer to the {structure+buffer} memory block, or NULL
 *        if OOM or bad argument
 *************************************************************************/
PUBLIC LPV PASCAL FAR BlockCopy (LPBLK lpBlockHead, LPB Buffer,
    DWORD BufSize, WORD wStartOffset)
{
    LPB lpbRetBuf;
    DWORD wTotalLength = BufSize + wStartOffset;

#ifdef _DEBUG
    if (lpBlockHead == NULL || lpBlockHead->wStamp != BLOCK_STAMP ||
        BufSize == 0)
        return NULL;
#endif

    // Block 4-byte alignement
    wTotalLength = (wTotalLength + 3) & (~3);

    /* Check for room */
    if (wTotalLength > lpBlockHead->cByteLeft)
    {
        if (BlockGrowth (lpBlockHead) != S_OK ||
            (wTotalLength > lpBlockHead->cByteLeft))
        return NULL;
    }
    
    lpbRetBuf = lpBlockHead->lpbCurLoc;

    /* Do the copy */
    if (Buffer)
        MEMCPY (lpbRetBuf + wStartOffset, Buffer, BufSize);

    /* Update the pointer and the number of bytes left */
    lpBlockHead->lpbCurLoc += wTotalLength;
    lpBlockHead->cByteLeft -= wTotalLength;
    return (LPV)lpbRetBuf;
}

/*************************************************************************
 *    @doc    INTERNAL RETRIEVAL
 *
 *    @func    LPB PASCAL FAR | BlockGetLinkedList |
 *        Return the pointer to the linked list of the element
 *
 *    @parm    LPBLK | lpBlockHead |
 *        Pointer to block manager structure
 *
 *    @rdesc    NULL if bad argument, else pointer to the linked list. One
 *        possible bad argument is that the block is not marked as threaded
 *        in BlockInitiate()
 *************************************************************************/
PUBLIC LPB PASCAL FAR BlockGetLinkedList(LPBLK lpBlockHead)
{
    if (lpBlockHead == NULL || lpBlockHead->wStamp != BLOCK_STAMP ||
        (lpBlockHead->fFlag & THREADED_ELEMENT) == 0)
        return NULL;
    return lpBlockHead->lpbCurLoc;
}


/*************************************************************************
 *    @doc    INTERNAL RETRIEVAL
 *
 *    @func    LPV PASCAL FAR | BlockGetElement |
 *        The function returns the pointer to the current element in the
 *        buffer
 *
 *    @parm    LPBLK | lpBlockHead |
 *        Pointer to block manager structure
 *
 *    @rdesc    pointer to current element, or NULL if OOM
 *
 *    @comm    After the call, all offsets/pointers are updated preparing
 *        for the next call
 *************************************************************************/
PUBLIC LPV PASCAL FAR BlockGetElement(LPBLK lpBlockHead)
{
    LPB lpbRetBuf;
    WORD wElemSize;

#ifdef _DEBUG
    if (lpBlockHead == NULL || lpBlockHead->wStamp != BLOCK_STAMP) 
        return NULL;
#endif

    if ((wElemSize = lpBlockHead->wElemSize) == 0)
        return NULL;

    /* Check for room */
    if (wElemSize > lpBlockHead->cByteLeft)
    {
        if ((BlockGrowth (lpBlockHead) != S_OK) ||
            wElemSize > lpBlockHead->cByteLeft) 
        return NULL;
    }

    /* Get the returned pointer */
    lpbRetBuf = lpBlockHead->lpbCurLoc;

    /* Update the current pointer and the number of bytes left */
    lpBlockHead->lpbCurLoc += wElemSize;
    lpBlockHead->cByteLeft -= wElemSize;
    return (LPV)lpbRetBuf;
}

/*************************************************************************
 *    @doc    INTERNAL INDEX RETRIEVAL
 *
 *    @func    LPV PASCAL FAR | GlobalLockedStructMemAlloc |
 *        This function allocates and return a pointer to a block of
 *        memory. The first element of the structure must be the handle
 *        to this block of memory
 *
 *    @parm    WORD | size |
 *        Size of the structure block.
 *
 *    @rdesc    NULL if OOM, or pointer to the structure
 *************************************************************************/
PUBLIC LPV PASCAL FAR GlobalLockedStructMemAlloc (DWORD size)
{
    HANDLE hMem;
    HANDLE FAR *lpMem;

    if ((hMem = _GLOBALALLOC(DLLGMEM_ZEROINIT, (DWORD)size)) == 0)
        return NULL;

    lpMem = (HANDLE FAR *)_GLOBALLOCK(hMem);
    *lpMem = hMem;
    return (LPV)lpMem;
}

/*************************************************************************
 *    @doc    INTERNAL INDEX RETRIEVAL
 *
 *    @func    LPV PASCAL FAR | GlobalLockedStructMemFree |
 *        This function free the block of memory pointed by lpMem. The
 *        assumption here is that the 1st field of the block is the
 *        handle to the block of memory. 
 *
 *    @parm    WORD FAR * | lpMem |
 *        Pointer to the block of memory to be freed
 *************************************************************************/
PUBLIC VOID PASCAL FAR GlobalLockedStructMemFree (HANDLE FAR *lpMem)
{
    HANDLE hMem;

    if (lpMem == NULL || (hMem = (HANDLE)*lpMem) == 0)
        return;

    _GLOBALUNLOCK(hMem);
    _GLOBALFREE(hMem);
}


/*************************************************************************
 *  @doc    INTERNAL RETRIEVAL
 *
 *  @func   int PASCAL FAR | BlockGetOrdinalBlock |
 *     Retrieve pointer to the start of i-th block that was allocated (starting at zero)
 *
 *  @parm   LPBLK | lpBlockHead |
 *      Pointer to block manager node
 *
 *    @rdesc  Pointer to first elt in block if successful, NULL otherwise
 *
 *    @comm    
 *       This is used to get fast random access to the i-th elt in
 *  an append-only linked list.
 *************************************************************************/
PUBLIC LPB PASCAL FAR BlockGetOrdinalBlock (LPBLK lpBlockHead, WORD iBlock)
{
    LPBLOCK lpBlock;

    if (lpBlockHead == NULL || lpBlockHead->wStamp != BLOCK_STAMP)
        return NULL;
    
    for (lpBlock = lpBlockHead->lpHead; iBlock && lpBlock; lpBlock = lpBlock->lpNext, iBlock--)
        ;
    return ((LPB)lpBlock + sizeof(BLOCK));

}

PUBLIC LPVOID PASCAL FAR BlockGetBlock (LPBLK lpBlockHead, DWORD dwSize)
{
    LPB  lpbRetBuf;

#ifdef _DEBUG
    if (lpBlockHead == NULL || lpBlockHead->wStamp != BLOCK_STAMP) 
        return NULL;
#endif

    // 4-byte alignment
    dwSize = (dwSize + 3) & (~3);

    /* Check for room */
    if (dwSize > lpBlockHead->cByteLeft)
    {
        if ((BlockGrowth (lpBlockHead) != S_OK) ||
            dwSize > lpBlockHead->cByteLeft) 
        return NULL;
    }

    /* Get the returned pointer */
    lpbRetBuf = lpBlockHead->lpbCurLoc;

    /* Update the current pointer and the number of bytes left */
    lpBlockHead->lpbCurLoc += dwSize;
    lpBlockHead->cByteLeft -= dwSize;
    return (LPV)lpbRetBuf;
}

VOID PASCAL FAR SetBlockCount (LPBLK lpBlock, WORD count)
{
    lpBlock->cMaxBlock = count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\breakers\convert.c ===
/*************************************************************************
*                                                                        *
*  CONVERT.C                                                             *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   Different data type breakers module                                  * 
*                                                                        *
*   Most of the data typre breakers deal with transformation an number   *
*   to some strings that we are able to compare and search for. A full   *
*   description of the encoding technique is described in field.doc.     *
*                                                                        *
*   An encoded number has the following fields:                          *
*   +------+------  ---+------+----------+---------------------------+   *
*   | Len  | Data Type | Sign | Exponent |         Mantissa          |   *
*   +------+-----------+------+----------+---------------------------+   *
*   2 byte    2 byte   1 byte   3 byte           Variable                   *
*   Data type: Differentiate between different "numbers" generated from  *
*              different data type breakers                              *
*   Sign byte: POSITIVE ('2') or NEGATIVE ('1')                          *
*   Exponent : 500 Bias                                                  *
*   Mantissa : Variable length, contains the "description" of the number *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Released by Development:     (date)                                   *
*                                                                        *
*************************************************************************/
#include <mvopsys.h>

#include <mvsearch.h>
#include "common.h"

#ifdef _DEBUG
PRIVATE BYTE NEAR s_aszModule[] = __FILE__; // Used by error return functions.
#endif

/* Short cut macros */
#define IS_DIGIT(p) (p >= '0' && p <= '9')

/* Location of different fields of the normalized number */
#define SIGN_BYTE       4
#define EXPONENT_BYTE   5
#define MANTISSA_BYTE   8

/* Size of fields */
#define EXPONENT_FLD_SIZE   3

/* Bias & limit of exponents we can handle */
#define EXPONENT_BIAS   500
#define MAX_EXPONENT    999

/* The following table is used to calculate the 9-complement of a
   digit. The 9-complement is defined as
       digit + complement = 9
   The table is indexed by the value of the digit
 */
PRIVATE BYTE ConvertTable[]= {
    '9',
    '8',
    '7',
    '6',
    '5',
    '4',
    '3',
    '2',
    '1',
    '0',
};

/* Number of days in regular years */
BYTE DayInRegYear[] = {
    0,
    31, // January
    28, // February
    31, // March
    30, // April
    31, // May
    30, // June
    31, // July
    31, // August
    30, // September
    31, // October
    30, // November
    31, // December
};

/* Number of days in leap years */
BYTE DayInLeapYear[] = {
    0,
    31, // January
    29, // February
    31, // March
    30, // April
    31, // May
    30, // June
    31, // July
    31, // August
    30, // September
    31, // October
    30, // November
    31, // December
};

/*
    The following constants are calculated in two ways: 
    1) days = <num-of-leap-years>*<leap-days> + <num-norm-years>*<norm-days>
    Ex:  Days400Years = 97*366 + 303*365 = 35502+110595 = 146097
    2) days = <num-years>*<norm-days> + <extra-days>
    Ex:  Days400Years = 400*365 + 97 = 146000 + 97 = 146097
    The credit goes to Paul Cisek
*/
#define DAYS_IN_400_YEARS   146097  /* Days in every 400 years */
#define DAYS_IN_100_YEARS   36524   /* Days in every 100 years */

/*************************************************************************
 *
 *                       API FUNCTIONS
 *  All these functions must be exported in a .DEF file
 *************************************************************************/

PUBLIC ERR EXPORT_API FAR PASCAL FBreakDate(LPBRK_PARMS);
PUBLIC ERR EXPORT_API FAR PASCAL FBreakTime(LPBRK_PARMS);
PUBLIC ERR EXPORT_API FAR PASCAL FBreakNumber(LPBRK_PARMS);
PUBLIC ERR EXPORT_API FAR PASCAL FBreakEpoch(LPBRK_PARMS);

/*************************************************************************
 *
 *                    INTERNAL GLOBAL FUNCTIONS
 *  Those functions should be declared FAR to cause less problems with
 *  with inter-segment calls, unless they are explicitly known to be
 *  called from the same segment. Those functions should be declared
 *  in an internal include file
 *************************************************************************/
VOID PUBLIC FAR PASCAL LongToString (DWORD, WORD, int, LSZ);
PUBLIC ERR FAR PASCAL DateToString (DWORD, DWORD, DWORD, int, LSZ);

/*************************************************************************
 *
 *                    INTERNAL PRIVATE FUNCTIONS
 *  All of them should be declared near
 *************************************************************************/

PRIVATE LSZ PASCAL NEAR ScanNumber (LPDW, LPDW, LPDW, LPDW, LSZ, int FAR *);
PRIVATE VOID PASCAL NEAR SetExponent (LSZ, int, int);
PRIVATE LSZ PASCAL NEAR StringToLong (LSZ, LPDW);
PRIVATE ERR PASCAL NEAR DataCollect (LPIBI, LPB, CB, LCB);
PRIVATE LSZ PASCAL NEAR SkipBlank(LSZ);
PRIVATE BOOL PASCAL NEAR WildCardByteCheck (LSZ, WORD);
PRIVATE BOOL PASCAL NEAR IsBlank(BYTE);

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   ERR PASCAL NEAR | DataCollect |
 *      This function will collect all the characters and save them
 *      in the raw word buffer. The buffer will be 0-terminated. The
 *      main reason we have to collect the data is because there is
 *      no guarantee that the breaker will get a whole entry at a time.
 *
 *  @parm   _LPIBI | lpibi |
 *      Pointer to Internal Breaker Info structure. This must be non-null
 *      It's left to the caller to do the checking
 *
 *  @parm   LPB | lpbInBuf |
 *      Pointer to input buffer to be copied. It must be non-null.
 *      It's left to the caller to do the checking
 *
 *  @parm   CB | cbInBufSize |
 *      Size of input buffer
 *
 *  @parm   LCB | lcbInBufOffset |
 *      Offset of the "word". This variable is only used for the
 *      INITIAL_STATE
 *
 *  @rdesc  S_OK if succeeded, other errors in failed
 *
 *  @comm   No sanity check is done since it assumes that the caller will
 *      do appropriate checking
 *************************************************************************/
PRIVATE ERR PASCAL NEAR DataCollect (_LPIBI lpibi, LPB lpbInBuf,
    register CB cbInBufSize, LCB lcbInBufOffset)
{
    register LPB lpbRawWord;    // Pointer to input buffer
    register LPB lpbBufLimit;   // Limit of buffer. This is for quick check

    if (lpibi->state == INITIAL_STATE)
    {
        /*
         *  This is the beginning of a new datum. Do the initialization,
         *  change state, then copy the string
         */
        *(LPW)lpibi->astRawWord = 0;        // Set the word length = 0
        lpibi->lcb = lcbInBufOffset;        // Remember the offset 
        lpibi->state = COLLECTING_STATE;    // Change the state to collect data
    }

    /* Collect the data */

    /*
     *  Initialize variables
     */

    lpbBufLimit = &lpibi->astRawWord[CB_MAX_WORD_LEN];
    lpbRawWord = &lpibi->astRawWord[GETWORD(lpibi->astRawWord) + 2];

    /* Update string length */
    *(LPW)lpibi->astRawWord += (BYTE)cbInBufSize;

    /* Check for long string */
    if (lpbRawWord + cbInBufSize >= lpbBufLimit) {
        /* Reset the state */
        *(LPW)lpibi->astRawWord = 0;
        lpibi->state = INITIAL_STATE;
        return E_WORDTOOLONG;
    }

    /* Copy the string */
    while (cbInBufSize > 0) {
        *lpbRawWord ++ = *lpbInBuf++;
        cbInBufSize --;
    }
    *lpbRawWord = 0; // Zero terminated string for future use
    return S_OK;
}

/*************************************************************************
 *  @doc    API INDEX RETRIEVAL
 *
 *  @func   ERR FAR PASCAL | FBreakDate |
 *      Convert a string of date into normalized dates. The input
 *      format for date must be
 *          mm/dd/yyyyy[B]
 *      where
 *          m: month
 *          d: day
 *          y: year
 *          B: if B.C. date
 *      All three fields must be present. The date will be converted into
 *      number of days. Only one date will be processed.
 *
 *  @parm   LPBRK_PARMS | lpBrkParms |
 *      Pointer to structure containing all the parameters needed for
 *      the breaker. They include:
 *      1/ Pointer to the InternalBreakInfo. Must be non-null
 *      2/ Pointer to input buffer containing the word stream. If it is
 *          NULL, then do the transformation and flush the buffer
 *      3/ Size of the input bufer
 *      4/ Offset in the source text of the first byte of the input buffer
 *      5/ Pointer to user's parameter block for the user's function
 *      6/ User's function to call with words. The format of the call should
 *      be (*lpfnfOutWord)(BYTE *RawWord, BYTE *NormWord, LCB lcb,
 *          LPV lpvUser)
 *      The function should return S_OK if succeeded.
 *      The function can be NULL
 *      7/ Pointer to stop word table. This table contains stop words specific
 *      to this breaker. If this is non-null, then the function
 *      will flag errors for stop word present in the query
 *      8/ Pointer to character table. If NULL, then the default built-in
 *      character table will be used
 *
 *  @rdesc
 *      The function returns S_OK if succeeded. The failure's causes
 *      are:
 *  @flag   E_BADFORMAT | Bad user's format
 *  @flag   E_WORDTOOLONG | Word too long
 *  @flag   E_INVALIDARG | Bad argument (eg. lpBrkParms = NULL)
 *
 *  @comm   For this function to successfully performed, the caller must
 *      make sure to flush the breaker properly after every date
 *************************************************************************/
PUBLIC ERR EXPORT_API FAR PASCAL FBreakDate(LPBRK_PARMS lpBrkParms)
{
    DWORD day;          // Number of days
    DWORD year;         // Number of years
    DWORD month;        // Number of months
    LPB lpbRawWord;     // Collection buffer pointer
    ERR fRet;           // Returned code
    LPB lpbResult;      // Pointer to result buffer

    /* Breakers parameters break out */

    _LPIBI lpibi;       // Pointer to internal breaker info
    LPB lpbInBuf;       // Pointer to input buffer to be scanned
    CB cbInBufSize;     // Number of bytes in input buffer
    LCB lcbInBufOffset; // Offset of the start of the datum from the buffer
    LPV lpvUser;        // User's lpfnfOutWord parameters
    FWORDCB lpfnfOutWord;   // User's function to be called with the result
    _LPSIPB lpsipb;     // Pointer to stopword
    int NumCount;       // Number of arguments we get
    LPB lpbWordStart;   // Word's start

    /*
     *  Initialize variables and sanity checks
     */

    if (lpBrkParms == NULL ||
        (lpibi = lpBrkParms->lpInternalBreakInfo) == NULL) {
        return E_INVALIDARG;
    }

    /* The following variables can be 0 or NULL */

    lpbInBuf = lpBrkParms->lpbBuf;
    cbInBufSize = lpBrkParms->cbBufCount;
    lcbInBufOffset = lpBrkParms->lcbBufOffset;
    lpvUser = lpBrkParms->lpvUser;
    lpfnfOutWord = lpBrkParms->lpfnOutWord;
    lpsipb = lpBrkParms->lpStopInfoBlock;

    if (lpbInBuf != NULL) {
        /* This is the collection state. Keep accumulating the input
        data into the buffer
        */
        return (DataCollect(lpibi, lpbInBuf, cbInBufSize,
            lcbInBufOffset));
    }

    lpbRawWord = &lpibi->astRawWord[2];

    /* Check for wildcard characters */
    if (WildCardByteCheck (lpbRawWord, *(LPW)lpibi->astRawWord))
        return E_WILD_IN_DTYPE;

    for (;;)
    {
        /* Skip all beginning junks */
        lpbWordStart = lpbRawWord = SkipBlank(lpbRawWord);
        if (*lpbRawWord == 0)
        {
            fRet = S_OK;
            goto ResetState;
        }

        /* Initialize variables */
        fRet = E_BADFORMAT;       // Default return
        month = year = day = 0;

        /* Assume that we have year only */
        lpbRawWord = ScanNumber (&year, &day, &month, NULL,
            lpbRawWord, &NumCount);
        
        if (NumCount == 3)
        {
            /* We have complete date, exchange the values of month and year,
               since the format is mm/dd/yy */
            DWORD tmp;

            tmp = year;
            year = month;
            month = tmp;
        }
        else if (NumCount != 1)
            goto ResetState;

        /* Set pointer to result buffer */
        lpbResult = lpibi->astNormWord;

        /* Convert the date into string format, store it in lpbResult */
        if ((DateToString (year, month, day,
            ((*lpbRawWord | 0x20) == 'b' ? (int)NEGATIVE : (int)POSITIVE),
            lpbResult)) != S_OK)
        {
            goto ResetState;
        }

        /* Skip the terminating 'b' if necessary */
        if ((*lpbRawWord | 0x20) == 'b')
            lpbRawWord++;

        /* Make sure that we have nothing else after it */
        if (!IsBlank(*lpbRawWord))
            goto ResetState;

        /* Set the word length */
        *(LPW)lpibi->astRawWord = (WORD)(lpbRawWord - lpbWordStart);

        /* Check for stop word if required */
        if (lpsipb)
        {
            if (lpsipb->lpfnStopListLookup(lpsipb, lpbResult) == S_OK)
            {
                fRet = S_OK;         // Ignore stop word
                continue;
            }
        }

        /* Invoke the user's function with the result */
        if (lpfnfOutWord)
            fRet = (ERR)((*lpfnfOutWord)(lpibi->astRawWord, lpbResult,
                (DWORD)(lpibi->lcb + (lpbWordStart - lpibi->astRawWord -2)), lpvUser));
        if (fRet != S_OK)
            goto ResetState;
    }

ResetState:
    /* Reset the state */
    *(LPW)lpibi->astRawWord = 0;
    lpibi->state = INITIAL_STATE;
    return (fRet);
}

/*************************************************************************
 *  @doc    API INDEX RETRIEVAL
 *
 *  @func   ERR FAR PASCAL | FBreakTime |
 *      Convert string of time into normalized time. The input
 *      format for time must be
 *          hh:mm:ss:dd[P]
 *      where
 *          h: hour
 *          m: minute
 *          s: second
 *          d: hundredths of second
 *      All first four fields must be present. The time will be converted
 *      into hundredths of seconds. Only one time will be processed
 *  
 *  @parm   LPBRK_PARMS | lpBrkParms |
 *      Pointer to structure containing all the parameters needed for
 *      the breaker. They include:
 *      1/ Pointer to the InternalBreakInfo. Must be non-null
 *      2/ Pointer to input buffer containing the word stream. If it is
 *          NULL, then do the transformation and flush the buffer
 *      3/ Size of the input bufer
 *      4/ Offset in the source text of the first byte of the input buffer
 *      5/ Pointer to user's parameter block for the user's function
 *      6/ User's function to call with words. The format of the call should
 *      be (*lpfnfOutWord)(BYTE *RawWord, BYTE *NormWord, LCB lcb,
 *          LPV lpvUser)
 *      The function should return S_OK if succeeded.
 *      The function can be NULL
 *      7/ Pointer to stop word table. This table contains stop words specific
 *      to this breaker. If this is non-null, then the function
 *      will flag errors for stop word present in the query
 *      8/ Pointer to character table. If NULL, then the default built-in
 *      character table will be used
 *
 *  @rdesc
 *      The function returns S_OK if succeeded. The failure's causes
 *      are:
 *  @flag   E_BADFORMAT | Bad user's format
 *  @flag   E_WORDTOOLONG | Word too long
 *  @flag   E_INVALIDARG | Bad argument (eg. lpBrkParms = NULL)
 *
 *  @comm   For this function to successfully performed, the caller must
 *      make sure to flush the breaker properly after every time
 *************************************************************************/
PUBLIC ERR EXPORT_API FAR PASCAL FBreakTime(LPBRK_PARMS lpBrkParms)
{
    DWORD hour;         // Number of hours
    DWORD minute;       // Number of minutes
    DWORD second;       // Number of seconds
    DWORD hundredth;    // Number of hundreths of second
    ERR fRet;           // Returned code
    LPB lpbRawWord;     // Collection buffer pointer
    LPB lpbResult;      // Pointer to result buffer
    LPB lpbWordStart;   // Word's start

    /* Breakers parameters break out */

    _LPIBI lpibi;       // Pointer to internal breaker info
    LPB lpbInBuf;       // Pointer to input buffer to be scanned
    CB cbInBufSize;     // Number of bytes in input buffer
    LCB lcbInBufOffset; // Offset of the start of the datum from the buffer
    LPV lpvUser;        // User's lpfnfOutWord parameters
    FWORDCB lpfnfOutWord;   // User's function to be called with the result
    _LPSIPB lpsipb;     // Pointer to stopword
    int NumCount;       // Number of arguments we get

    /*
     *  Initialize variables and sanity checks
     */

    if (lpBrkParms == NULL ||
        (lpibi = lpBrkParms->lpInternalBreakInfo) == NULL) {
        return E_INVALIDARG;
    }

    /* The following variables can be 0 or NULL */

    lpbInBuf = lpBrkParms->lpbBuf;
    cbInBufSize = lpBrkParms->cbBufCount;
    lcbInBufOffset = lpBrkParms->lcbBufOffset;
    lpvUser = lpBrkParms->lpvUser;
    lpfnfOutWord = lpBrkParms->lpfnOutWord;
    lpsipb = lpBrkParms->lpStopInfoBlock;

    if (lpbInBuf != NULL) {
        /* This is the collection state. Keep accumulating the input
        data into the buffer
        */
        return (DataCollect(lpibi, lpbInBuf, cbInBufSize,
            lcbInBufOffset));
    }

    /* Do the transformation and flush the result */

    lpbRawWord = &lpibi->astRawWord[2];

    /* Check for wildcard characters */
    if (WildCardByteCheck (lpbRawWord, *(LPW)lpibi->astRawWord))
        return E_WILD_IN_DTYPE;

    for (;;) {
        /* Skip all beginning junks */
        lpbWordStart = lpbRawWord = SkipBlank(lpbRawWord);

        if (*lpbRawWord == 0) {
            fRet = S_OK;
            goto ResetState;
        }

        lpbResult = lpibi->astNormWord;
        fRet = E_BADFORMAT;

        hour = minute = second = hundredth = 0;

        /* Scan hour, minute, second, hundreth */
        lpbRawWord = ScanNumber (&hour, &minute, &second, &hundredth,
            lpbRawWord, &NumCount);
        
        /* NumCount == 2 : HH:MM format
         * NumCount == 3 : HH:MM:SS format 
         * NumCount == 4 : HH:MM:SS:HH format */

        if (NumCount < 2 || NumCount > 4) 
            goto ResetState;

        /* Make sure that we have nothing else after it */
        if (!IsBlank(*lpbRawWord))
            goto ResetState;

    #if 0   // PM format currently is not spec' ed
        if ((*lpbRawWord | 0x20) == 'p') {
            /* Deal with PM time. Note: if we have P.M., this is time
               and not duration. So:
               - If hour < 12, add 12 hours
               - If hour >= 24, round it off to 24 hours format
            */
            if (hour >= 24)
                hour = hour % 24 + 12;
            if (hour < 12)
                hour += 12;
        }
    #endif

        /* Set the word length */
        *(LPW)lpibi->astRawWord = (WORD)(lpbRawWord - lpbWordStart);

        /* Convert the time into hundredth of seconds */
        hundredth += (((hour * 60) + minute) * 60 + second) * 100;

        LongToString (hundredth, TIME_FORMAT, POSITIVE, lpbResult);

        /* Check for stop word if required */
        if (lpsipb)
        {
            if (lpsipb->lpfnStopListLookup(lpsipb, lpbResult) == S_OK)
            {
                fRet = S_OK;         // Ignore stop word
                continue;
            }
        }

        fRet = S_OK;

        /* Invoke the user's function with the result */
        if (lpfnfOutWord)
            fRet = (ERR)((*lpfnfOutWord)(lpibi->astRawWord, lpbResult,
                (DWORD)(lpibi->lcb + (lpbWordStart - lpibi->astRawWord -2)), lpvUser));
        if (fRet != S_OK)
            goto ResetState;
    }

ResetState:
    /* Reset the state */
    *(LPW)lpibi->astRawWord = 0;
    lpibi->state = INITIAL_STATE;
    return (fRet);
}

/*************************************************************************
 *  @doc    API INDEX RETRIEVAL
 *
 *  @func   ERR FAR PASCAL | FBreakNumber |
 *      Normalize an ASCII number. The input format of the number must be
 *          [+-]nnnn.nnn[E[+-]eee]
 *      where
 *          n: digit
 *          e: exponent
 *      The total exponent must be less than 499. No space is allowed
 *      between the fields
 *  
 *  @parm   LPBRK_PARMS | lpBrkParms |
 *      Pointer to structure containing all the parameters needed for
 *      the breaker. They include:
 *      1/ Pointer to the InternalBreakInfo. Must be non-null
 *      2/ Pointer to input buffer containing the word stream. If it is
 *          NULL, then do the transformation and flush the buffer
 *      3/ Size of the input bufer
 *      4/ Offset in the source text of the first byte of the input buffer
 *      5/ Pointer to user's parameter block for the user's function
 *      6/ User's function to call with words. The format of the call should
 *      be (*lpfnfOutWord)(BYTE *RawWord, BYTE *NormWord, LCB lcb,
 *          LPV lpvUser)
 *      The function should return S_OK if succeeded.
 *      The function can be NULL
 *      7/ Pointer to stop word table. This table contains stop words specific
 *      to this breaker. If this is non-null, then the function
 *      will flag errors for stop word present in the query
 *      8/ Pointer to character table. If NULL, then the default built-in
 *      character table will be used
 *
 *  @rdesc
 *      The function returns S_OK if succeeded. The failure's causes
 *      are:
 *  @flag   E_BADFORMAT | Bad user's format
 *  @flag   E_WORDTOOLONG | Word too long
 *  @flag   E_INVALIDARG | Bad argument (eg. lpBrkParms = NULL)
 *
 *  @comm   For this function to successfully performed, the caller must
 *      make sure to flush the breaker properly after every number
 *************************************************************************/
PUBLIC ERR EXPORT_API FAR PASCAL FBreakNumber(LPBRK_PARMS lpBrkParms)
{
    int exponent;       // Exponent to be emitted
    int exp;            // Exponent get from the input data
    LPB lpStart;        // Starting of mantissa string
    DWORD   tmp;        // Temporary scratch 
    LPB lpbRawWord;     // Collection buffer pointer
    register LSZ lpbResult; // Pointer to result buffer
    LSZ Result;         // Beginning of result buffer (quick access)
    ERR fRet;           // Return code

    /* Breakers parameters break out */

    _LPIBI lpibi;       // Pointer to internal breaker info
    LPB lpbInBuf;       // Pointer to input buffer to be scanned
    CB cbInBufSize;     // Number of bytes in input buffer
    LCB lcbInBufOffset; // Offset of the start of the datum from the buffer
    LPV lpvUser;        // User's lpfnfOutWord parameters
    FWORDCB lpfnfOutWord;   // User's function to be called with the result
    _LPSIPB lpsipb;     // Pointer to stopword
    LPB lpbWordStart;   // Word's start

    /*
     *  Initialize variables and sanity checks
     */

    if (lpBrkParms == NULL ||
        (lpibi = lpBrkParms->lpInternalBreakInfo) == NULL) {
        return E_INVALIDARG;
    }

    /* The following variables can be 0 or NULL */

    lpbInBuf = lpBrkParms->lpbBuf;
    cbInBufSize = lpBrkParms->cbBufCount;
    lcbInBufOffset = lpBrkParms->lcbBufOffset;
    lpvUser = lpBrkParms->lpvUser;
    lpfnfOutWord = lpBrkParms->lpfnOutWord;
    lpsipb = lpBrkParms->lpStopInfoBlock;

    if (lpbInBuf != NULL) {
        /* This is the collection state. Keep accumulating the input
        data into the buffer
        */
        return (DataCollect(lpibi, lpbInBuf, cbInBufSize,
            lcbInBufOffset));
    }

    lpbRawWord = &lpibi->astRawWord[2];

    /* Check for wildcard characters */
    if (WildCardByteCheck (lpbRawWord, *(LPW)lpibi->astRawWord))
        return E_WILD_IN_DTYPE;

    for (;;)
    {
        Result = lpibi->astNormWord;
        lpbResult = &Result[2];

        /* Skip all beginning junks */
        lpbWordStart = lpbRawWord = SkipBlank(lpbRawWord);

        if (*lpbRawWord == 0) {
            fRet = S_OK;
            goto ResetState;
        }

        fRet = E_BADFORMAT;   // Default error

        exponent = exp = 0;

        *lpbResult++ = 1;
        *lpbResult++ = NUMBER_FORMAT;

        /* Get the sign */
        if (*lpbRawWord == '-')
        {
            *lpbResult = NEGATIVE;
            lpbRawWord++;
        }
        else
        {
            *lpbResult = POSITIVE;
            if (*lpbRawWord == '+') lpbRawWord++;   // Skip the sign
        }

        /* Allow the form .01, ie. integral not needed */
        if (!IS_DIGIT(*lpbRawWord) && *lpbRawWord != '.')
            goto ResetState;

        /* Get the integral part */
        lpStart = lpbResult = &Result[MANTISSA_BYTE];

        while (*lpbRawWord == '0')  // skip all leading 0
            lpbRawWord++;

        /* The scanner accepts ',' as part of the number. This should be
        country specific (ie. scanned and checked by UI), but since nobody is
        doing the checking now, I have to do it here by just acceopting the ','.
        What it means is that entry like ,,,,1,,,2,, will be accepted. It is
        possible to do better checking, but is it necessary?
        */
        while (IS_DIGIT(*lpbRawWord) || *lpbRawWord == ',') {
            if (*lpbRawWord != ',') {
                *lpbResult++ = *lpbRawWord;
                exponent++;
            }
            lpbRawWord++;
        }

        if (*lpbRawWord == 0)
            goto Done;

        /* Get the fractional part */
        if (*lpbRawWord == '.') {
            *lpbRawWord++;
            while (*lpbRawWord == '0') {

                /* Handle the '0' for of 0.000001 for example */
                if (exponent <= 0)
                    exponent--;
                else
                    *lpbResult++ = *lpbRawWord;
                lpbRawWord++;
            }

            /* Just copy the remaining digits */

            while (IS_DIGIT(*lpbRawWord)) 
                *lpbResult++ = *lpbRawWord++;
        }

        if (*lpbRawWord == 0)
            goto Done;

        /* Check for exponent */
        if (*lpbRawWord == 'E' || *lpbRawWord == 'e') {
            lpbRawWord++;
            if (*lpbRawWord == '-') {
                exp = -1;
                lpbRawWord++;
            }
            else  {
                exp = 1;
                if (*lpbRawWord == '+')
                    lpbRawWord++;
            }

            /* Scan the exponent */
            if ((lpbRawWord = (LPB)StringToLong(lpbRawWord, &tmp)) == NULL)
                goto ResetState;
            exp *= (int)tmp;
        }

    Done:

        /* Set the word length */
        *(LPW)lpibi->astRawWord = (WORD)(lpbRawWord - lpbWordStart);

        /* Make sure that we have nothing else after it */
        if (!IsBlank(*lpbRawWord))
            goto ResetState;

        exponent += exp + EXPONENT_BIAS - 1;
        if (exponent > MAX_EXPONENT || exponent < 0) {
            fRet = E_BADVALUE;
            goto ResetState;
        }

        if (lpbResult <= lpStart) {
            /* No significant digit, ie. 0 */
            exponent = 0;
            Result[SIGN_BYTE] = POSITIVE;
            *lpbResult++ = '0';
        }
        *lpbResult = 0;

        /* Write the ascii exponent */
        SetExponent(&Result[MANTISSA_BYTE]-1, exponent, EXPONENT_FLD_SIZE - 1);

        if (Result[SIGN_BYTE] == NEGATIVE)  { /* Negative number */
            /* Complement the result */
            for (lpbResult = &Result[EXPONENT_BYTE]; *lpbResult; lpbResult++)
                *lpbResult = ConvertTable[*lpbResult - '0'];
        }

        /* Remove trailing 0's */
        for (--lpbResult; *lpbResult == '0' && lpbResult > lpStart; lpbResult--)
            *lpbResult = 0;

        /* Set the word length */
        *(LPW)Result = (BYTE) (lpbResult - Result);

        /* Check for stop word if required */
        if (lpsipb) {
            if (lpsipb->lpfnStopListLookup(lpsipb, Result) == S_OK)
            {
                fRet = S_OK;         // Ignore stop word
                continue;
            }
        }

        /* Invoke the user's function with the result */
        fRet = S_OK;
        if (lpfnfOutWord)
            fRet = (ERR)((*lpfnfOutWord)(lpibi->astRawWord, Result,
                (DWORD)(lpibi->lcb + (lpbWordStart - lpibi->astRawWord -2)), lpvUser));
        if (fRet != S_OK)
            goto ResetState;
    }

ResetState:
    /* Reset the state */
    *(LPW)lpibi->astRawWord = 0;
    lpibi->state = INITIAL_STATE;
    return (fRet);
}

/*************************************************************************
 *  @doc    API INDEX RETRIEVAL
 *
 *  @func   ERR FAR PASCAL | FBreakEpoch |
 *      Normalize an epoch. The input format of the epoch must be
 *      is:
 *          nnnnnn...nnnnnn[B]
 *      where
 *          n: digit
 *      The total exponent must be less than 499. No space is allowed between
 *      the fields
 *  
 *  @parm   LPBRK_PARMS | lpBrkParms |
 *      Pointer to structure containing all the parameters needed for
 *      the breaker. They include:
 *      1/ Pointer to the InternalBreakInfo. Must be non-null
 *      2/ Pointer to input buffer containing the word stream. If it is
 *          NULL, then do the transformation and flush the buffer
 *      3/ Size of the input bufer
 *      4/ Offset in the source text of the first byte of the input buffer
 *      5/ Pointer to user's parameter block for the user's function
 *      6/ User's function to call with words. The format of the call should
 *      be (*lpfnfOutWord)(BYTE *RawWord, BYTE *NormWord, LCB lcb,
 *          LPV lpvUser)
 *      The function should return S_OK if succeeded.
 *      The function can be NULL
 *      7/ Pointer to stop word table. This table contains stop words specific
 *      to this breaker. If this is non-null, then the function
 *      will flag errors for stop word present in the query
 *      8/ Pointer to character table. If NULL, then the default built-in
 *      character table will be used
 *
 *  @rdesc
 *      The function returns S_OK if succeeded. The failure's causes
 *      are:
 *  @flag   E_BADFORMAT | Bad user's format
 *  @flag   E_WORDTOOLONG | Word too long
 *  @flag   E_INVALIDARG | Bad argument (eg. lpBrkParms = NULL)
 *
 *  @comm   For this function to successfully performed, the caller must
 *      make sure to flush the breaker properly after every epoch
 *************************************************************************/
PUBLIC ERR EXPORT_API FAR PASCAL FBreakEpoch(LPBRK_PARMS lpBrkParms)
{
    int exponent;
    int exp;
    LPB lpStart;
    LPB lpbRawWord;     // Collection buffer pointer
    register LSZ lpbResult;
    LSZ Result;
    ERR fRet;
    /* Breakers parameters break out */

    _LPIBI lpibi;
    LPB lpbInBuf;
    CB cbInBufSize;
    LCB lcbInBufOffset;
    LPV lpvUser;
    FWORDCB lpfnfOutWord;
    _LPSIPB lpsipb;
    LPB lpbWordStart;   // Word's start

    /*
     *  Initialize variables
     */

    if (lpBrkParms == NULL ||
        (lpibi = lpBrkParms->lpInternalBreakInfo) == NULL)
        return E_INVALIDARG;

    lpbInBuf = lpBrkParms->lpbBuf;
    cbInBufSize = lpBrkParms->cbBufCount;
    lcbInBufOffset = lpBrkParms->lcbBufOffset;
    lpvUser = lpBrkParms->lpvUser;
    lpfnfOutWord = lpBrkParms->lpfnOutWord;
    lpsipb = lpBrkParms->lpStopInfoBlock;

    if (lpbInBuf != NULL) {
        /* This is the collection state. Keep accumulating the input
        data into the buffer
        */
        return (DataCollect(lpibi, lpbInBuf, cbInBufSize,
            lcbInBufOffset));
    }

    lpbRawWord = &lpibi->astRawWord[2];

    /* Check for wildcard characters */
    if (WildCardByteCheck (lpbRawWord, *(LPW)lpibi->astRawWord))
        return E_WILD_IN_DTYPE;

    for (;;) {
        /* Skip all beginning junks */
        lpbWordStart = lpbRawWord = SkipBlank(lpbRawWord);

        if (*lpbRawWord == 0) {
            fRet = S_OK;
            goto ResetState;
        }

        Result = lpibi->astNormWord;
        lpbResult = &Result[2];

        fRet = E_BADFORMAT;

        exponent = exp = 0;

        *lpbResult++ = 1;
        *lpbResult++ = EPOCH_FORMAT;

        /* If it is not a digit then just return E_BADFORMAT */
        if (!IS_DIGIT(*lpbRawWord))
            goto ResetState;

        /* Get the integral part */
        lpStart = lpbResult = &Result[MANTISSA_BYTE];

        while (*lpbRawWord == '0')  // skip all leading 0
            lpbRawWord++;

        /* The scanner accepts ',' as part of the number. This should be
        country specific (ie. scanned and checked by UI), but since nobody is
        doing the checking now, I have to do it here by just acceopting the ','.
        What it means is that entry like ,,,,1,,,2,, will be accepted. It is
        possible to do better checking, but is it necessary?
        */
        while (IS_DIGIT(*lpbRawWord) || *lpbRawWord == ',') {
            if (*lpbRawWord != ',') {
                *lpbResult++ = *lpbRawWord;
                exponent++;
            }
            lpbRawWord++;
        }

        /* Check for the last 'B' */
        Result[SIGN_BYTE] = ((*lpbRawWord | 0x20) == 'b') ?
            (BYTE)NEGATIVE : (BYTE)POSITIVE;

        /* Skip the terminating 'b' if necessary */
        if ((*lpbRawWord | 0x20) == 'b')
            lpbRawWord++;

        /* Make sure that we have nothing else after it */
        if (!IsBlank(*lpbRawWord))
            goto ResetState;

        /* Set the word length and offset */
        *(LPW)lpibi->astRawWord = (WORD)(lpbRawWord - lpbWordStart);

        exponent += exp + EXPONENT_BIAS - 1;
        if (exponent > MAX_EXPONENT || exponent < 0) {
            fRet = E_BADVALUE;
            goto ResetState;
        }

        if (lpbResult <= lpStart) {
            /* No significant digit, ie. 0 */
            exponent = 0;
            Result[SIGN_BYTE] = POSITIVE;
            *lpbResult++ = '0';
        }
        *lpbResult = 0;

        SetExponent(&Result[MANTISSA_BYTE]-1, exponent, EXPONENT_FLD_SIZE-1);

        if (Result[SIGN_BYTE] == NEGATIVE)  { /* Negative number */
            for (lpbResult = &Result[EXPONENT_BYTE]; *lpbResult; lpbResult++)
                *lpbResult = ConvertTable[*lpbResult - '0'];
        }

        /* Remove trailing 0's */
        for (--lpbResult; *lpbResult == '0' && lpbResult > lpStart; lpbResult--)
            *lpbResult = 0;

        /* Set the word length */
        *(LPW)Result = (WORD) (lpbResult - Result);

        /* Check for stop word if required */
        if (lpsipb) {
            if (lpsipb->lpfnStopListLookup(lpsipb, Result) == S_OK)
            {
                fRet = S_OK;         // Ignore stop word
                continue;
            }
        }

        /* Invoke the user's function with the result */
        fRet = S_OK;
        if (lpfnfOutWord)
            fRet = (ERR)((*lpfnfOutWord)(lpibi->astRawWord, Result,
                (DWORD)(lpibi->lcb + (lpbWordStart - lpibi->astRawWord -2)), lpvUser));
        if (fRet != S_OK)
            goto ResetState;
    }

ResetState:
    /* Reset the state */
    *(LPW)lpibi->astRawWord = 0;
    lpibi->state = INITIAL_STATE;
    return (fRet);
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   ERR FAR PASCAL | DateToString |
 *      Given a date in numerical value of year, month, and days, this
 *      function will return a string containing the normalized form of
 *      the date (converted into number of days)
 *
 *  @parm   DWORD | year |
 *      Numerical year
 *
 *  @parm   DWORD | month |
 *      Numerical month
 *
 *  @parm   DWORD | day |
 *      Numerical months
 *
 *  @parm   int | fSign |
 *      Either POSITIVE, or NEGATIVE
 *
 *  @parm   LSZ | lszResult |
 *      Buffer for the normalized result
 *
 *  @rdesc
 *      The function returns S_OK if succeeded. The failure's causes
 *      are:
 *  @flag   S_OK | if S_OK.
 *  @flag   E_BADVALUE| if the date is ill-formed
 *************************************************************************/
PUBLIC ERR FAR PASCAL DateToString (DWORD year, DWORD month, DWORD day,
    int fSign, LSZ lszResult)
{
    register BYTE *pDayInMonth; // Pointer to number of days in month
    register DWORD i;           // Scratch variable
    DWORD tmpYear;              // Scratch variable

    /* Check for date consistency. Note that invidual parameter can
       be 0, but not all of them
    */
    if ((year | month | day) == 0) 
        return E_BADVALUE;

    /* Check for leap year */
    if ((year % 4 != 0) || ((year % 100 == 0) && (year % 400 != 0))) {
        /* Not a leap year */
        pDayInMonth = DayInRegYear;
    }
    else // Leap year
        pDayInMonth = DayInLeapYear;

    /* Check for date validity */
    if (month > 12 || day > pDayInMonth[month] || year > MAX_YEAR)
        return E_BADVALUE;

    /* Convert the date to number of days */
    if (month > 0) {
        year --;
    }

    if (day > 0) {
        if (month == 0)
            return E_BADVALUE;
        month --;
    }

    for (i = 1; i <= month; i++)
        day += pDayInMonth[i];

    /*  One way for year to be >= MAX_YEAR at this point is that the user
        types in mm/dd/0. By decrementing year above, we make it > MAX_YEAR
    */
    if (year < MAX_YEAR) {
        /* Convert <year> into <days> */

        day += year/400 * DAYS_IN_400_YEARS;
        year = year % 400;
        day += year/100 * DAYS_IN_100_YEARS;
        year = year % 100;

        for (tmpYear = 0; tmpYear <= year; tmpYear++) {
            if ((tmpYear % 4 != 0) ||
                ((tmpYear % 100 == 0) && (tmpYear % 400 != 0))) {
                /* Not a leap year */
                day += 365;
            }
            else
                day += 366;
        }
    }

    LongToString (day, DATE_FORMAT, fSign, lszResult);
    return S_OK;
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   VOID FAR PASCAL | LongToString |
 *      Given a DWORD number, the function will convert it into a
 *      normalized string.
 *
 *  @parm   DWORD | Number |
 *      The number in unsigned format
 *
 *  @parm   WORD | FormatStamp |
 *      The number stamp, which states the data type of the number
 *
 *  @parm   WORD | Sign |
 *      Value: POSITIVE, or NEGATIVE
 *
 *  @parm   LSZ | lszResult |
 *      Buffer to receive the result
 *
 *************************************************************************/

VOID PUBLIC FAR PASCAL LongToString (DWORD Number, WORD FormatStamp,
    int Sign, LSZ lszResult)
{
    BYTE Buffer[CB_MAX_WORD_LEN];   // Scratch buffer containing the "number"
    register LSZ lsz;               // Scratch pointer
    int Exponent;                   // Number's exponent
    LPB lpbStart;                   // Beginnning of lszResult

#ifdef TEST
    printf ("Convert %ld ,", Number);
#endif
    /* Remember where we start, and leave room for the word's length */
    lpbStart = lszResult;
    lszResult += sizeof(WORD);

    /* Set the format */
    *lszResult++ = 1;
    *lszResult = (BYTE)FormatStamp;
    lszResult ++;

    /*
        Handle 0 case. 0 will be represented as 0 exponent,
        and 0 mantissa
    */
    if (Number == 0) {
        *lszResult ++ = POSITIVE;

        /* 3 zero for exponent, and 1 for matissa */

        *(DWORD FAR *)lszResult = 0x30303030;   // "0000"
        lszResult += sizeof (DWORD);
        *lszResult = 0;
        *lpbStart = (BYTE)(lszResult - lpbStart);
        return;
    }

    *lszResult++ = (BYTE)Sign;
    Exponent = EXPONENT_BIAS;

    lsz = &Buffer[CB_MAX_WORD_LEN - 1];
    *lsz-- = 0; // Terminated 0
    while (Number) {
        *lsz-- = (BYTE)(Number % 10 + '0');
        Number /= 10;
        Exponent ++;
    }

    SetExponent(lsz, Exponent, EXPONENT_FLD_SIZE-1);
    lsz -= 2;

    /* Copy the string over */
    if (Sign == POSITIVE) {
        while (*lszResult = *lsz++)
            lszResult++;
    }
    else {
        while (*lsz)
            *lszResult++ = ConvertTable [*lsz++ - '0'];
        *lszResult = 0;
    }

    /* Remove trailing 0's */
    while (*--lszResult == '0')
        *lszResult = 0;
    *(LPW)lpbStart = (WORD)(lszResult - lpbStart);
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   LSZ PASCAL NEAR | StringToLong |
 *      The function reads in a string of digits and convert them into
 *      a DWORD. The function will move the input pointer correspondingly
 *
 *  @parm   LSZ | lszBuf |
 *      Input buffer containing the string of digit
 *  @parm   LPDW  | lpValue |
 *      Pointer to a DWORD that receives the result
 *
 *  @rdesc  NULL, if there is no digit. The new position of the input
 *      buffer pointer
 *************************************************************************/
PRIVATE LSZ PASCAL NEAR StringToLong (LSZ lszBuf, LPDW lpValue)
{
    register DWORD Result;  // Returned result
    register int i;         // Scratch variable
    char fGetDigit;         // Flag to mark we do get a digit

    /* Skip all blanks, tabs, <CR> */
    lszBuf = SkipBlank(lszBuf);

    Result = fGetDigit = 0;


    /* The credit of this piece of code goes to Leon */
    while (i = *lszBuf - '0', i >= 0 && i <= 9) {
        fGetDigit = TRUE;
        Result = Result * 10 + i;
        lszBuf++;
    }
    *lpValue = Result;
    return (fGetDigit ? lszBuf : NULL);
}


/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   LSZ PASCAL NEAR  | ScanNumber |
 *      The function reads in a string of digits of the format
 *          nnnn/nnnn/nnnn
 *      where:
 *          n  : digits
 *          Any non-digit delimiter can be used.
 *      It then breaks the string into invidual numbers. The input
 *      pointer will advance accordingly
 *
 *  @parm   LSZ  | lszBuf |
 *      Input buffer containing the string of digit
 *
 *  @parm   LPDW | lpNum1 |
 *      Pointer to DWORD that will receive the 1st result
 *
 *  @parm   LPDW | lpNum2 |
 *      Pointer to DWORD that will receive the 2nd result
 *
 *  @parm   LPDW | lpNum3 |
 *      Pointer to DWORD that will receive the 3rd result
 *
 *  @parm   LPDW | lpNum4 |
 *      Pointer to DWORD that will receive the 4th result
 *
 *  @rdesc
 *      NULL, if there is not enough digits to be processed
 *      The new position of the input buffer pointer
 *************************************************************************/
PRIVATE LSZ PASCAL NEAR ScanNumber (LPDW lpNum1, LPDW lpNum2,
    LPDW lpNum3, LPDW lpNum4, LSZ lszInBuf, int FAR *lpArgCount)
{
    LSZ lszStart;

    lszStart = lszInBuf;    // Save initial offset

    /*  Scan 1st number */
    if ((lszInBuf = StringToLong (lszInBuf, lpNum1)) == NULL) {
        *lpArgCount = 0;
        return lszStart;
    }

    /* We get at least one argument */
    *lpArgCount = 1;
    if (lpNum2 == NULL || *lszInBuf == 0 || (*lszInBuf | 0x20) == 'b' ||
        *lszInBuf == ' ' || *lszInBuf == '\t' || *lszInBuf == '\r' ||
        *lszInBuf == '\n')
        return lszInBuf;

    if (*lszInBuf != '/' && *lszInBuf != ':')
        return lszInBuf;

    lszStart = ++lszInBuf; // Skip delimiter

    if (!IS_DIGIT(*lszInBuf)) {
        *lpArgCount = 0;    // Make sure that we have error
        return lszInBuf;
    }

    /*  Scan 2nd number */
    if ((lszInBuf = StringToLong (lszInBuf, lpNum2)) == NULL) 
        return lszStart;

    *lpArgCount = 2;
    if (lpNum3 == NULL || *lszInBuf == 0)
        return lszInBuf;

    if (*lszInBuf != '/' && *lszInBuf != ':')
        return lszInBuf;

    lszStart = ++lszInBuf; // Skip delimiter

    if (!IS_DIGIT(*lszInBuf)) {
        *lpArgCount = 0;    // Make sure that we have error
        return lszInBuf;
    }

    /*  Scan 3rd number */
    if ((lszInBuf = StringToLong (lszInBuf, lpNum3)) == NULL) 
        return lszStart;

    *lpArgCount = 3;
    if (lpNum4 == NULL || *lszInBuf == 0)
        return lszInBuf;

    if (*lszInBuf != '/' && *lszInBuf != ':')
        return lszInBuf;

    lszStart = ++lszInBuf; // Skip delimiter

    if (!IS_DIGIT(*lszInBuf)) {
        *lpArgCount = 0;    // Make sure that we have error
        return lszInBuf;
    }

    /*  Scan 4th number */
    if ((lszInBuf = StringToLong (lszInBuf, lpNum4)) == NULL) 
        return lszStart;

    *lpArgCount = 4;
    return lszInBuf;
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   VOID PASCAL NEAR | SetExponent |
 *      Given a buffer and a numerical exponent, ths function will
 *      write the exponent in its ASCII form into the buffer. The
 *      beginning of the exponent will be padded with '0' if necessary
 *      The writing is done from right to left, and is controlled
 *      by level, which is also a zero-based index into the exponent buffer
 *      (where to put the digit)
 *
 *  @parm   LSZ | pBuf |
 *      Buffer that will contain the ASCII exponent
 *
 *  @parm   int | exponent |
 *      Numerical exponent
 *
 *  @parm   int | level |
 *      Length of buffer (also controlling the level of recursion)
 *************************************************************************/
PRIVATE VOID PASCAL NEAR SetExponent (LSZ pBuf, int exponent, int level)
{
    int exp;

    if (level < 0)
        return;
    *pBuf = (char)(exponent - (exp = (exponent / 10)) * 10 + '0');
    SetExponent (pBuf - 1, exp, level - 1);
}


/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   LSZ PASCAL NEAR | SkipBlank |
 *      Skip any blank, tab, CR, newline
 *
 *  @parm   LSZ | lpBuf |
 *      Input zero-terminated string buffer pointer
 *
 *  @rdesc  Advance the pointer to the non-blank character. 
 *************************************************************************/
PRIVATE LSZ PASCAL NEAR SkipBlank(LSZ lpBuf)
{
    while (*lpBuf == ' ' || *lpBuf == '\t' || *lpBuf == '\r' ||
        *lpBuf == '\n')
        lpBuf++;
    return lpBuf;
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   BOOL PASCAL NEAR | IsBlank |
 *      Check to see the current char is a blank, tab, CR, newline
 *      0 is consider to be a blank
 *
 *  @parm   BYTE | bCur |
 *      Current byte
 *
 *  @rdesc  TRUE if it is
 *************************************************************************/
PRIVATE BOOL PASCAL NEAR IsBlank(BYTE bCur)
{
    return (bCur == ' ' || bCur == '\t' || bCur == '\r' ||
        bCur == '\n' || bCur == 0);
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   LSZ PASCAL NEAR | WildCardByteCheck |
 *      Check for wildcard character in the string
 *
 *  @parm   LSZ | lpBuf |
 *      Input zero-terminated string buffer pointer
 *
 *  @parm   WORD | cbBufSize |
 *      Size of input string
 *
 *  @rdesc  0 if there is no wildcard character
 *************************************************************************/
PRIVATE BOOL PASCAL NEAR WildCardByteCheck (LSZ lpBuf, WORD cbBufSize)
{
    while (cbBufSize > 0 && *lpBuf != WILDCARD_STAR)
    {
        lpBuf++;
        cbBufSize--;
    }
    return (cbBufSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\breakers\engstem.h ===
// ENGSTEM.H:  Definition of CITEngStemmer object implementation.

#ifndef __ENGSTEM_H__
#define __ENGSTEM_H__

#include "verinfo.h"


#define VERSION_ENGSTEMMER		(MAKELONG(MAKEWORD(0, rapFile), MAKEWORD(rmmFile, rmjFile)))


// Group of flags that indicate what data has been persisted to the
// stemmer's stream.
#define	ITSTDBRK_PERSISTED_STEMCTL		0x00000001


// Stemmer control structure that contains information that can
// vary how words are stemmed.
typedef struct _stemctl
{
	DWORD	dwCodePageID;
	LCID	lcid;
	DWORD	grfStemFlags;
} STEMCTL;


class CITEngStemmer : 
	public IStemmer,
	public IStemmerConfig,
	public IPersistStreamInit,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CITEngStemmer,&CLSID_ITEngStemmer>
{
public:
    CITEngStemmer();
	virtual ~CITEngStemmer();


BEGIN_COM_MAP(CITEngStemmer)
	COM_INTERFACE_ENTRY(IStemmer)
	COM_INTERFACE_ENTRY(IStemmerConfig)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
END_COM_MAP()

DECLARE_REGISTRY(CLSID_ITEngStemmer, "ITIR.EngStemmer.4", "ITIR.EngStemmer", 0, THREADFLAGS_BOTH )

	// IStemmer methods
	STDMETHOD(Init)(ULONG ulMaxTokenSize, BOOL *pfLicense);
    STDMETHOD(GetLicenseToUse)(WCHAR const **ppwcsLicense);
	STDMETHOD(StemWord)(WCHAR const *pwcInBuf, ULONG cwc, IStemSink *pStemSink);

	// IStemmerConfig methods
	STDMETHOD(SetLocaleInfo)(DWORD dwCodePageID, LCID lcid);
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid);
	STDMETHOD(SetControlInfo)(DWORD grfBreakFlags, DWORD dwReserved);
	STDMETHOD(GetControlInfo)(DWORD *pgrfBreakFlags, DWORD *pdwReserved);
	STDMETHOD(LoadExternalStemmerData)(IStream *pStream, DWORD dwExtDataType);
	
	// IPersistStreamInit methods
	STDMETHOD(GetClassID)(CLSID *pclsid);
	STDMETHOD(IsDirty)(void);
	STDMETHOD(Load)(IStream *pStream);
	STDMETHOD(Save)(IStream *pStream, BOOL fClearDirty);
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSizeMax);
	STDMETHOD(InitNew)(void);

private:
	// Private methods
	void	ClearMembers(void);
	void	InitStemCtl(void);
	void	Close(void);
	HRESULT	ReallocBuffer(HGLOBAL *phmemBuf, DWORD *cbBufCur, DWORD cbBufNew);

	// Private data members
	BOOL		m_fInitialized;
	BOOL		m_fDirty;
	DWORD		m_grfPersistedItems;
	STEMCTL		m_stemctl;
	HGLOBAL		m_hmem1;
	HGLOBAL		m_hmem2;
	DWORD		m_cbBuf1Cur;
	DWORD		m_cbBuf2Cur;
  _ThreadModel::AutoCriticalSection m_cs;      // Critical section obj.
};


// Initial size of Ansi string buffers.
#define	cbAnsiBufInit	256


#endif	// __ENGSTEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\breakers\breaker.c ===
/*************************************************************************
*                                                                        *
*  BREAKER.C                                                             *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   Word breaker module                                                  *
* 	This module provides word-breaking routines applicable to the ANSI   *
* 	character-set.  This means American English.                         *
* 	Note that ANSI does not mean ASCII.                                  *
*                                                                        *
*   WARNING: Tab setting is 4 for this file                              *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Released by Development:     (date)                                   *
*                                                                        *
*************************************************************************/
#include <verstamp.h>
SETVERSIONSTAMP(MVBK);

#include <mvopsys.h>

#include <iterror.h>
#include <mvsearch.h>
#include "common.h"

/* Macros to access structure's members */

#define	CP_CLASS(p)	(((LPCMAP)p)->Class & 0xff)
#define	CP_NORMC(p)	(((LPCMAP)p)->Norm)

/*************************************************************************
 *
 *	                  INTERNAL PRIVATE FUNCTIONS
 *	All of them should be declared near
 *************************************************************************/
PRIVATE ERR NEAR PASCAL WordBreakStem(LPBRK_PARMS, WORD);
PRIVATE int PASCAL NEAR LigatureMap(BYTE c, LPB lpbNormWord,
	LPCMAP lpCharPropTab, LPB lpbLigatureTab, WORD wcLigature);


/*************************************************************************
 *
 *	            SINGLE TO DOUBLE-WIDTH KATAKANA MAPPING ARRAY
 *
 *************************************************************************/

// Single-Width to Double-Width Mapping Array
//
static const int mtable[][2]={
   {129,66},{129,117},{129,118},{129,65},{129,69},{131,146},{131,64},
   {131,66},{131,68},{131,70},{131,72},{131,131},{131,133},{131,135},
   {131,98},{129,91},{131,65},{131,67},{131,69},{131,71},{131,73},
   {131,74},{131,76},{131,78},{131,80},{131,82},{131,84},{131,86},
   {131,88},{131,90},{131,92},{131,94},{131,96},{131,99},{131,101},
   {131,103},{131,105},{131,106},{131,107},{131,108},{131,109},
   {131,110},{131,113},{131,116},{131,119},{131,122},{131,125},
   {131,126},{131,128},{131,129},{131,130},{131,132},{131,134},
   {131,136},{131,137},{131,138},{131,139},{131,140},{131,141},
   {131,143},{131,147},{129,74},{129,75} };


/*************************************************************************
 *	@doc	API INDEX RETRIEVAL
 *
 *	@func	LPIBI FAR PASCAL | BreakerInitiate |
 *		Allocates a breaker parameter block. This parameter block keeps
 *		track of the breaker's "global" variables.
 *
 *	@rdesc	NULL if the call fails (ie. no more memory)
 *		a pointer to the block if it succeeds.
 *************************************************************************/

PUBLIC LPIBI EXPORT_API FAR PASCAL BreakerInitiate(void)
{
	_LPIBI	lpibi;
	register HANDLE	hibi;

	if ((hibi = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT,
		sizeof(IBI))) == NULL) {
		return NULL;
	}
	//
	//	All variables not explicitly initialized are assumed to be
	//	initialized as zero.
	//
	lpibi = (_LPIBI)GlobalLock(hibi);
	lpibi->hibi = hibi;
	return lpibi;
}

/*************************************************************************
 *	@doc	API INDEX RETRIEVAL
 *
 *	@func	void FAR PASCAL | BreakerFree |
 *		Frees a word-breaker parameter block.
 *
 *	@parm	LPIBI | lpibi |
 *		Pointer to the InternalBreakInfo Structure containing all the
 *		informations about states
 *************************************************************************/
PUBLIC void EXPORT_API FAR PASCAL BreakerFree(_LPIBI lpibi)
{
	HANDLE	hibi;
	/* Do sanity check */
	if (lpibi == NULL)
		return;

	hibi = lpibi->hibi;
	GlobalUnlock(hibi);
	GlobalFree(hibi);
}

//	-	-	-	-	-	-	-	-	-

//	Break words out from a block of standard text characters.
//
//	This routine is incredibly important.  Any change in the performance
//	of this function will have immediate and obvious influence upon the
//	performance of the indexing system as a whole.  Consequently, the
//	function should be very fast.
//
//	This function uses a simple state machine to try to achieve the
//	necessary speed.  It's in a different loop depending upon what kind
//	of characters it's trying to find, and it uses "goto" statements to
//	shift back and forth between "states".
//

/*************************************************************************
 *	@doc	API RETRIEVAL INDEX
 *
 *	@func	ERR | FBreakWords |
 *		This function break a string into a sequence of words.
 *
 *	@parm	LPBRK_PARMS | lpBrkParms |
 *		Pointer to structure containing all the parameters needed for
 *		the breaker. They include:
 *		1/ Pointer to the InternalBreakInfo
 *		2/ Pointer to input buffer containing the word stream
 *		3/ Size of the input bufer
 *		4/ Offset in the source text of the first byte of the input buffer
 *		5/ Pointer to user's parameter block for the user's function
 *		6/ User's function to call with words. The format of the call should
 *		be (*lpfnfOutWord)(BYTE *RawWord, BYTE *NormWord, LCB lcb,
 *			LPV lpvUser)
 *		The function should return S_OK if succeeded
 *		The function can be NULL
 *		7/ Pointer to stop word table. This table contains stop words specific
 *		to this breaker. If this is non-null, then the function
 *		will flag errors for stop word present in the query
 *		8/ Pointer to character table. If NULL, then the default built-in
 *		character table will be used
 *
 *	@rdesc
 *		The function returns S_OK if succeeded. The failure's causes
 *		are:
 *	@flag	E_WORDTOOLONG | Word too long
 *	@flag	errors | returned by the lpfnfOutWord
 *************************************************************************/

PUBLIC ERR EXPORT_API FAR PASCAL FBreakWords(LPBRK_PARMS lpBrkParms)
{
	return (WordBreakStem(lpBrkParms, FALSE));
}

#if 0
/*************************************************************************
 *	@doc	API RETRIEVAL INDEX
 *
 *	@func	ERR | FBreakAndStemWords |
 *		This function breaks a string into a sequence of words and
 *		stems each resulting word
 *
 *	@parm	LPBRK_PARMS | lpBrkParms |
 *		Pointer to structure containing all the parameters needed for
 *		the breaker. They include:
 *		1/ Pointer to the InternalBreakInfo
 *		2/ Pointer to input buffer containing the word stream
 *		3/ Size of the input bufer
 *		4/ Offset in the source text of the first byte of the input buffer
 *		5/ Pointer to user's parameter block for the user's function
 *		6/ User's function to call with words. The format of the call should
 *		be (*lpfnfOutWord)(BYTE *RawWord, BYTE *NormWord, LCB lcb,
 *			LPV lpvUser)
 *		The function should return S_OK if succeeded
 *		The function can be NULL
 *		7/ Pointer to stop word table. This table contains stop words specific
 *		to this breaker. If this is non-null, then the function
 *		will flag errors for stop word present in the query
 *		8/ Pointer to character table. If NULL, then the default built-in
 *		character table will be used
 *
 *	@rdesc
 *		The function returns S_OK if succeeded. The failure's causes
 *		are:
 *	@flag	E_WORDTOOLONG | Word too long
 *	@flag	Other errors | returned by the lpfnfOutWord
 *************************************************************************/

PUBLIC ERR EXPORT_API FAR PASCAL FBreakAndStemWords(LPBRK_PARMS lpBrkParms)
{
	return (WordBreakStem(lpBrkParms, TRUE));
}
#endif


PUBLIC ERR EXPORT_API FAR PASCAL BreakerVersion (void)
{
	return	CHARTABVER;
}

// This exists only to enable MVJK to link statically.
// We must have the same function names for the static build.
PUBLIC ERR FAR PASCAL FBreakStems(LPBRK_PARMS lpBrkParms)
{
	return E_NOTSUPPORTED;
}

// This exists only to enable MVJK to link statically.
// We must have the same function names for the static build.
PUBLIC ERR FAR PASCAL FSelectWord (LPCSTR pBuffer, DWORD dwCount,
    DWORD dwOffset, LPDWORD pStart, LPDWORD pEnd)
{
	return E_NOTSUPPORTED;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	ERR | WordBreakStem |
 *		This function breaks a string into a sequence of words and
 *		stems each resulting word
 *
 *	@parm	BYTE | fStem |
 *		If set, stem the word
 *
 *	@rdesc
 *		The function returns S_OK if succeeded. The failure's causes
 *		are:
 *	@flag	E_WORDTOOLONG | Word too long
 *	@flag	Other errors | returned by the lpfnfOutWord
 *************************************************************************/

PRIVATE ERR NEAR PASCAL WordBreakStem(LPBRK_PARMS lpBrkParms, WORD fStem)
{
	register LPB lpbRawWord;	// Pointer to RawWord buffer
	register LPB lpbNormWord;	// Pointer to NormWord buffer
	LPCMAP lpCharPropTab;		// Pointer to the char property table
	LPB	lpbInBuffer;			// Buffer to groot through.
	LPB	lpbRawWordLimit;		// Limit of RawWord buffer
#if 0
	LPB	lpbNormWordLimit;		// Limit of NormWord buffer
#endif
	BYTE	bCurChar;			// Current character.
	BYTE	fScan = TRUE;
	ERR	 fRet;
#if 0
	BYTE	astStemmed[CB_MAX_WORD_LEN + 2]; // Temporary buffer for stemming
#endif
	LPB		lpbLigature = NULL;
	WORD	wcLigature = 0;
	LPCHARTAB lpCharTab;
	LPB		astNormWord;
	LPB		astRawWord;
	BYTE	fAcceptWildCard;

	/* Breakers parameters break out */

	_LPIBI lpibi;
	LPB lpbInBuf;
	CB cbInBufSize;
	LCB lcbInBufOffset;
	LPV lpvUser;
	FWORDCB lpfnfOutWord;
	_LPSIPB lpsipb;
	LPCMAP lpCMap = NULL;

	/*
	 *	Initialize variables
	 */

	if (lpBrkParms == NULL ||
		(lpibi = lpBrkParms->lpInternalBreakInfo) == NULL)
		return E_INVALIDARG;

	astNormWord = (LPB)lpibi->astNormWord;
	astRawWord = (LPB)lpibi->astRawWord;

	lpbInBuf = lpBrkParms->lpbBuf;
	lpvUser = lpBrkParms->lpvUser;
	lpfnfOutWord = lpBrkParms->lpfnOutWord;
	lpsipb = lpBrkParms->lpStopInfoBlock;
	fAcceptWildCard = (BYTE)(lpBrkParms->fFlags & ACCEPT_WILDCARD);

	/*
	 *	Restore to the proper state.  This is in place to handle
	 *	words that cross block boundaries, and to deal with explicit
	 *	buffer-flush commands.
	 */
	if ((lpbInBuffer = lpbInBuf) != NULL) {

		cbInBufSize = lpBrkParms->cbBufCount;
		lcbInBufOffset = lpBrkParms->lcbBufOffset;

		if (lpCharTab = lpBrkParms->lpCharTab) {
			lpCMap = (LPCMAP)(lpCharTab->lpCMapTab);
			lpbLigature = lpCharTab->lpLigature;
			wcLigature = lpCharTab->wcLigature;
		}
      else {
         return(E_INVALIDARG);
      }

		lpbRawWordLimit = (LPB)&astRawWord[CB_MAX_WORD_LEN];

		switch (lpibi->state) {
		    case SCAN_WHITE_STATE:
				goto ScanWhite;	// Running through white space.
		    case SCAN_WORD_STATE:
				lpbRawWord = (LPB)&astRawWord[GETWORD(astRawWord)+2];
				lpbNormWord = (LPB)&astNormWord[GETWORD(astNormWord)+2];
				goto ScanWord;	// Found one 'a'..'z', collecting.

		    case SCAN_NUM_STATE:
				lpbRawWord = (LPB)&astRawWord[GETWORD(astRawWord)+2];
				lpbNormWord = (LPB)&astNormWord[GETWORD(astNormWord)+2];
				goto ScanNumber;// Found one '0'..'9', collecting.
				
			case SCAN_LEADBYTE_STATE:
				lpbRawWord = (LPB)&astRawWord[GETWORD(astRawWord)+2];
				lpbNormWord = (LPB)&astNormWord[GETWORD(astNormWord)+2];
				goto ScanLeadByte; 

			case SCAN_SBKANA_STATE:
				lpbRawWord = (LPB)&astRawWord[GETWORD(astRawWord)+2];
				lpbNormWord = (LPB)&astNormWord[GETWORD(astNormWord)+2];
				goto ScanSbKana; 
		}
	}
	else {
		cbInBufSize = fScan = 0;
		switch (lpibi->state) {
		    case SCAN_WHITE_STATE:
				return S_OK;	// Still stuck in white space.
		    case SCAN_WORD_STATE:
				goto FlushWord;	// Flush a word.
		    case SCAN_NUM_STATE:
				goto FlushNumber;	// Flush a number.
            case SCAN_LEADBYTE_STATE:
                goto ScanLeadByte;
            case SCAN_SBKANA_STATE:
                goto ScanSbKana;
		}
	}
	//
	//	W H I T E - S P A C E   S T A T E
	//
	//	While in this state the code is hunting through white-space,
	//	searching for an alpha character or a digit character.  If
	//	it finds one, it initializes the word and goes to either the
	//	word-collection state or the number-collection state.
	//
ScanWhite:
	for (; cbInBufSize; cbInBufSize--, lpbInBuffer++) {
		//
		//	Get the character and its class.
		//

		switch (CP_CLASS(&lpCMap[*lpbInBuffer])) {
			case CLASS_WILDCARD:
				if (fAcceptWildCard == FALSE)
					continue;
			case CLASS_TYPE: // Found the 1st byte of the special string
			case CLASS_CHAR: //	Found a non-normalized char
			case CLASS_NORM: //	Found a normalized character
            case CLASS_LIGATURE: // Found a ligature

			//	jump to the word-collection state.
				lpibi->lcb = (DWORD)(lcbInBufOffset +
					(lpbInBuffer - lpbInBuf));
				lpbRawWord = (LPB)&astRawWord[2];
				lpbNormWord = (LPB)&astNormWord[2];
				goto ScanWord;

			case CLASS_DIGIT: //	Found a digit.
				lpibi->lcb = (DWORD)(lcbInBufOffset +
					(lpbInBuffer - lpbInBuf));
				lpibi->cbNormPunctLen = lpibi->cbRawPunctLen = 0;
				lpbRawWord = (LPB)&astRawWord[2];
				lpbNormWord = (LPB)&astNormWord[2];
				goto ScanNumber;
				
            case CLASS_LEADBYTE:
                lpibi->lcb = (DWORD)(lcbInBufOffset +
                (lpbInBuffer - lpbInBuf));
                lpbRawWord = (LPB)&astRawWord[2];
                lpbNormWord = (LPB)&astNormWord[2];
                *(LPW)astNormWord = *(LPW)astRawWord = 0;
                goto ScanLeadByte;
            case CLASS_SBKANA:  
                lpibi->lcb = (DWORD)(lcbInBufOffset +
                (lpbInBuffer - lpbInBuf));
                *(LPW)astNormWord = *(LPW)astRawWord = 0;
                lpbRawWord = (LPB)&astRawWord[2];
                lpbNormWord = (LPB)&astNormWord[2];
            goto ScanSbKana;
		}
	}
	//
	//	If I run out of data, set things up so I'll come back
	//	to this state if the user provides more data.
	//
	lpibi->state = SCAN_WHITE_STATE;
	return S_OK;

ScanWord:
	//
	//	W O R D   S T A T E
	//
	//	While in this state the code is attempting to append alpha
	//	and digit characters to the alpha character it's already
	//	found.  Apostrophes are stripped.
	//
	for (; cbInBufSize; cbInBufSize--, lpbInBuffer++) {
		//
		//	Get the character and its class.
		//
		lpCharPropTab = &lpCMap[bCurChar = *lpbInBuffer];
		switch (CP_CLASS(lpCharPropTab)) {
			case CLASS_NORM :
			case CLASS_DIGIT :
            case CLASS_CHAR:
			//
			//	Found a normalized character or a digit.
			//	Append it to the output buffer.
			//
				if (lpbRawWord >= lpbRawWordLimit)
					return (E_WORDTOOLONG);
				*lpbRawWord++ = bCurChar;
    			*lpbNormWord++ = CP_NORMC(&lpCMap[bCurChar]);
				break;
			
			case CLASS_LIGATURE:
			//
			//	Found an ligature character.  Normalize
			//	it and append it to the output buffer.
			//
				if (lpbRawWord >= lpbRawWordLimit)
					return (E_WORDTOOLONG);
				*lpbRawWord++ = bCurChar;
				lpbNormWord += LigatureMap (bCurChar, lpbNormWord,
					lpCMap, lpbLigature, wcLigature);
				break;
				
			case CLASS_STRIP:
			//
			//	Found an apostrophe or somesuch.  Ignore
			//	this character, but increment the word length,
			//	since it counts as part of the un-normalized
			//	word's length.
			//
				if (lpbRawWord >= lpbRawWordLimit)
					return (E_WORDTOOLONG);
				*lpbRawWord++ = bCurChar;
				break;

			case CLASS_TYPE :
				/* Set the flag to remind us to get the
					second byte.
				*/
				lpibi->fGotType = TRUE;
				*lpbRawWord++ = *lpbNormWord++ = bCurChar;
				break;

			case CLASS_WILDCARD:
			//
			//	Found a wildcard character
			//	Append it to the output buffer if we accept wildcard
			//
				if (fAcceptWildCard) {
					if (lpbRawWord >= lpbRawWordLimit)
						return (E_WORDTOOLONG);
					*lpbRawWord++ = bCurChar;
					*lpbNormWord++ = bCurChar;
					break;
				}
			
			default:
				if (lpibi->fGotType == TRUE) {
					lpibi->fGotType = FALSE;

					/* Found a the 2nd byte of a special type
						Append it to the output buffer. */

					*lpbRawWord++ = *lpbNormWord++ = bCurChar;
					break;
				}
			//
			//	Found something weird, or I have been ordered
			//	to flush the output buffer.  Flush the output
			//	buffer and go back to the "grooting through
			//	white space" state (#0).
			//
FlushWord:	
				if (fScan)
				{
				/* Recalculate the length only if scanning */
					*(LPW)astRawWord = (WORD)(lpbRawWord -
						(LPB)&astRawWord[2]);
					*(LPW)astNormWord = (WORD)(lpbNormWord -
						(LPB)&astNormWord[2]);
				}

				/* Check for stop word if required */
				if (lpsipb)
				{
					if (lpsipb->lpfnStopListLookup(lpsipb,
						astNormWord) == S_OK)
					{
						goto ScanWhite;	// Ignore stop words
					}
				}
#if 0

				if (fStem)
				{
    				/* Do stemming if requested */
					if (FStem(astStemmed, astNormWord) == S_OK)
					{
						MEMCPY(astNormWord, astStemmed, GETWORD(astStemmed)
							+ sizeof(WORD));
					}
				}
#endif

				/* Execute user's function */
				if (*lpfnfOutWord && (fRet = (*lpfnfOutWord)(astRawWord,
					lpibi->astNormWord, lpibi->lcb, lpvUser)) != S_OK)
					return fRet;
				goto ScanWhite;
		}
	}
	//
	//	If I run out of data, set things up so I'll come back
	//	to this state if the user provides more data.  If they
	//	just want me to flush, I come back to the "flush a
	//	word" state (#1f), since at this time I already have
	//	a valid word, since I got an alpha-char in state #0,
	//	and may have gotten more since.
	//
	lpibi->state = SCAN_WORD_STATE;
	*(LPW)astRawWord = (WORD)(lpbRawWord - (LPB)&astRawWord[2]);
	*(LPW)astNormWord = (WORD)(lpbNormWord - (LPB)&astNormWord[2]);
	return S_OK;


ScanLeadByte:
   if(!cbInBufSize)
   {
      // no character - we may have lost a DBC
      //
   	  lpibi->state = SCAN_WHITE_STATE;
      *(LPW)astNormWord = *(LPW)astRawWord = 0;
	   return S_OK;
   }

   if(!GETWORD(astNormWord))
   {
      // process lead byte
      //
      *(LPW)astNormWord = *(LPW)astRawWord = 1;
      astNormWord[2] = *lpbInBuffer++;
      --cbInBufSize;
   }

   if(!cbInBufSize)
   {
      // no more characters - set up state so we come back to get trail byte.
      //
   	lpibi->state = SCAN_LEADBYTE_STATE;
	   return S_OK;
   }

   // process trail byte
   //
   *(LPW)astNormWord = *(LPW)astRawWord = 2;
   astNormWord[3] = *lpbInBuffer++;
   --cbInBufSize;

   // flush the DBC
   //
   if (*lpfnfOutWord &&
	   (fRet = (*lpfnfOutWord)(astRawWord,astNormWord, lpibi->lcb,lpvUser))
	   != S_OK)
		return fRet;

   if(!cbInBufSize)
   {
      // no more characters - we have already flushed our DBC so we will just
      // set the state back to scanning for white space.
      //
   	lpibi->state = SCAN_WHITE_STATE;
	   return S_OK;
   }

   // all done - go back to scanning white space.
   //
	goto ScanWhite;

ScanSbKana:
   if(!cbInBufSize)
   {
      // Buffer is empty.  Flush the buffer if we are holding a character.
      //
      if(GETWORD(astNormWord))
      {
         if (*lpfnfOutWord &&
	         (fRet = (*lpfnfOutWord)(astRawWord,astNormWord, lpibi->lcb,lpvUser))
	         != S_OK)
		      return fRet;
      }

      lpibi->state = SCAN_WHITE_STATE;
      *(LPW)astNormWord = *(LPW)astRawWord = 0;
	  return S_OK;
   }

   // Note: The basic algorithm (including the mapping table) used here to
   // convert half-width Katakana characters to full-width Katakana appears
   // in the book "Understanding Japanese Information Systems" by
   // O'Reily & Associates.

   
   // If the RawWord buffer is empty then we will process this as a first 
   // character (we are not looking for an diacritic mark).
   //
   if(!GETWORD(astRawWord))
   {
      // Verify that we have a half-width Katakana character.  This check is
      // a good safeguard against erroneous information in a user defined
      // charmap.  
      //
      if(*lpbInBuffer >= 161 && *lpbInBuffer <= 223)
      {
         // We have a half-width Katakana character. Now compute the equivalent
         // full-width character via the mapping table.
         //
         astNormWord[2] = (BYTE)(mtable[*lpbInBuffer-161][0]);
         astNormWord[3] = (BYTE)(mtable[*lpbInBuffer-161][1]);
         *(LPW)astNormWord = 2;
      }
      else
      {
         // This is an error condition.  For some reason the charmap has 
         // *lpbInBuffer tagged as CLASS_SBKANA when in fact it's not
         // a single byte Katakana character.  This is probably the result
         // of an improperly formed user defined charmap.
         // 
         // Since there's no way to determine the real class of this character
         // we will send it to the bit bucket.
         //
         lpbInBuffer++;
         cbInBufSize--;
         *(LPW)astNormWord = *(LPW)astRawWord = 0;
 	      lpibi->state = SCAN_WHITE_STATE;
      	goto ScanWhite;
      }
      *(LPW)astRawWord = 1;         // we have processed one character so far
      astRawWord[2] = *lpbInBuffer; // we will need the original character later
      lpbInBuffer++;
      cbInBufSize--;
   }

   // Check if we have more characters in the buffer.
   //
   if(!cbInBufSize)
   {
      // Return because the buffer is empty.
	  //
	  lpibi->state = SCAN_SBKANA_STATE;
     return S_OK;
   }

   // check if the second character is nigori mark.
   //
   if(*lpbInBuffer == 222)                
   {
      // see if we have a half-width katakana that can be modified by nigori.
      //
      if((astRawWord[1] >= 182 && astRawWord[1] <= 196) || 
         (astRawWord[1] >= 202 && astRawWord[1] <= 206) || (astRawWord[1] == 179))
      {
         // transform kana into kana with maru
         //
         if((astNormWord[2] >= 74 && astNormWord[2] <= 103) ||
             (astNormWord[2] >= 110 && astNormWord[2] <= 122))
             astNormWord[2]++;
         else if(astNormWord[2] == 131 && astNormWord[3] == 69)
            astNormWord[3] = 148;


         // set the word lengths and advance the buffer.
         //
         *(LPW)astNormWord=2;
         *(LPW)astRawWord =2;            
         lpbInBuffer++;
         cbInBufSize--;
      }
   }

   // check if following character is maru mark
   //
   else if(*lpbInBuffer==223)
   {
      // see if we have a half-width katakana that can be modified by maru.
      //
      if((astRawWord[2] >= 202 && astRawWord[2] <= 206))
      {
         // transform kana into kana with nigori
         //
         if(astNormWord[3] >= 110 && astNormWord[3] <= 122)
            astNormWord[3]+=2;

         // set the word lengths and advance the buffer.
         //
         *(LPW)astNormWord=2;
         *(LPW)astRawWord=2;
         lpbInBuffer++;
         cbInBufSize--;
      }
   }

   // Note: If the character at *lpbInBuffer wasn't a diacritic mark, then it
   //       will be processed when ScanWhite is re-entered.
   //
   // Another note:  The above code only combines diacritic marks with
   //                single-width Katakana characters that can be modifed
   //                by these marks (not all can).  If we happen to encounter
   //                a situation where the diacritic can't be combined 
   //                into the character, we let the character continue
   //                back to ScanWhite where it will be re-sent to 
   //                ScanSbKana, however this time it will be a first
   //                character and be converted into its stand-alone
   //                full-width equivalent (maru and nigori have full-width 
   //                character equilalents that contain just the mark).
 
   // flush the buffer
   //
   if (*lpfnfOutWord &&
	   (fRet = (*lpfnfOutWord)(astRawWord,astNormWord, lpibi->lcb,lpvUser)) 
	   != S_OK)
		return fRet;

   // reset word lengths and return to scanning for white space.
   //
   *(LPW)astNormWord = *(LPW)astRawWord = 0;
 	lpibi->state = SCAN_WHITE_STATE;

   // Return if buffer is empty
   //
   if(!cbInBufSize)
	   return S_OK;

   // all done - go back to scanning white space.
   //
	goto ScanWhite;


ScanNumber:
	//
	//	N U M B E R   S T A T E
	//
	//	While in this state the code is attempting to append alpha
	//	and digit characters to the digit character it's already
	//	found.  This state is more complex than the word grabbing
	//	state, because it deals with slashes and hyphens in a weird
	//	way.  They're allowed in a number unless they appear at the
	//	end.  Extra variables have to account for these conditions.
	//
	for (; cbInBufSize; cbInBufSize--, lpbInBuffer++) {
		//
		//	Get the character and its class.
		//
		lpCharPropTab = &lpCMap[bCurChar = *lpbInBuffer];
		switch (CP_CLASS(lpCharPropTab)) {
			case CLASS_DIGIT :
			case CLASS_NORM :
			case CLASS_CHAR:
			//
			//	Found a normalized character or a digit.
			//	Append it to the output buffer.
			//
				if (lpbRawWord >= lpbRawWordLimit)
					return (E_WORDTOOLONG);
				*lpbRawWord++ = bCurChar;
    			*lpbNormWord++ = CP_NORMC(&lpCMap[bCurChar]);
				lpibi->cbRawPunctLen = 0;
				lpibi->cbNormPunctLen = 0;
				break;

			case CLASS_LIGATURE:
			//
			//	Found an ligature character.  Normalize
			//	it and append it to the output buffer.
			//
				if (lpbRawWord >= lpbRawWordLimit)
					return (E_WORDTOOLONG);
				*lpbRawWord++ = bCurChar;
				lpbNormWord += LigatureMap (bCurChar, lpbNormWord,
					lpCMap, lpbLigature, wcLigature);
				lpibi->cbRawPunctLen = 0;
				lpibi->cbNormPunctLen = 0;
				break;
				
			case CLASS_NKEEP:
			//
			//	Found a hyphen or a slash.  These are kept
			//	as part of the number unless they appear at
			//	the end of the number.
			//
				if (lpbRawWord >= lpbRawWordLimit)
					return (E_WORDTOOLONG);
				*lpbRawWord++ = bCurChar;
				*lpbNormWord++= bCurChar;
				lpibi->cbRawPunctLen++;
				lpibi->cbNormPunctLen++;
				break;

			case CLASS_NSTRIP:
			//
			//	Found a comma or somesuch.  Ignore this
			//	character, but increment the word length,
			//	since it counts as part of the un-normalized
			//	number's length.
			//
				if (lpbRawWord >= lpbRawWordLimit)
					return (E_WORDTOOLONG);
				*lpbRawWord++= bCurChar;
				lpibi->cbRawPunctLen++;
				break;

			case CLASS_CONTEXTNSTRIP:
			//
			//	Found special character used for number separator. This
			//	may be a space in French, ie. 100 000. The problem here
			//	is that we must differentiate it from a regular word
			//	separator. In the meantime, ignore this character, but
			//	increment the word length
			//
				if (lpbRawWord >= lpbRawWordLimit)
					return (E_WORDTOOLONG);
				*lpbRawWord++= bCurChar;
				lpibi->cbRawPunctLen++;
				cbInBufSize--;
				lpbInBuffer++;
				goto ScanSeparator; // Found a "possible" separator
				break;

			case CLASS_WILDCARD:
			//
			//	Found a wildcard character
			//	Append it to the output buffer if we accept wildcard
			//
				if (fAcceptWildCard) {
					if (lpbRawWord >= lpbRawWordLimit)
						return (E_WORDTOOLONG);
					*lpbRawWord++ = bCurChar;
					*lpbNormWord++ = bCurChar;
					break;
				}

			default:
			//
			//	Found something weird, or I have been ordered
			//	to flush the output buffer.  Flush the output
			//	buffer and go back to the "grooting through
			//	white space" state (#0).
			//
			//	This is a little more complicated than the
			//	analogous routine for dealing with words.
			//	This has to deal with words that have some
			//	number of trailing punctuation characters.
			//	These need to be stripped from the word, and
			//	the un-normalized word length value needs to
			//	be adjusted as well.
			//
FlushNumber:	
				if (fScan)
				{
    				/* Recalculate the length only if scanning */
					*(LPW)astRawWord = (WORD)(lpbRawWord -
						(LPB)&astRawWord[2] -
						lpibi->cbRawPunctLen);
					*(LPW)astNormWord = (WORD)(lpbNormWord -
						(LPB)&astNormWord[2] -
						lpibi->cbNormPunctLen);
				}

				/* Check for stop word if required */
				if (lpsipb)
				{
					if (lpsipb->lpfnStopListLookup(lpsipb,
						astNormWord) == S_OK)
					{
						goto ScanWhite;	// Ignore stop words
					}
				}

				if (*lpfnfOutWord && (fRet = (*lpfnfOutWord)(astRawWord,
					astNormWord, lpibi->lcb, lpvUser)) != S_OK)
					return fRet;
				goto ScanWhite;
		}
	}
	//
	//	If I run out of data, set things up so I'll come back
	//	to this state if the user provides more data.  If they
	//	just want me to flush, I come back to the "flush a
	//	number" state (#2f), since at this time I already have
	//	a valid word, since I got an digit-char in state #0,
	//	and may have gotten more since.
	//
	lpibi->state = SCAN_NUM_STATE;
	*(LPW)astRawWord = (WORD)(lpbRawWord - (LPB)&astRawWord[2]);
	*(LPW)astNormWord = (WORD)(lpbNormWord - (LPB)&astNormWord[2]);
	return S_OK;

ScanSeparator:
	//	S E P A R A T O R   S T A T E
	//
	//	This state deals with special character used to separate digits
	//	of numbers. Example:
	//		100 000		' ' is used to separate the digits in French(??)
	//	In some sense, comma belongs to this class, when we
	//	deal with US numbers. Because of compability with Liljoe, they
	//	are set to be CLASS_NSTRIP. The rules to distinguish between
	//	a digit separator from regular word separator is: If there is a
	//	digit thats follows, then this is a digit separator, else it is
	//	a regular word separator
	//		
	if (cbInBufSize) {
		//
		//	Get the character and its class.
		//
		lpCharPropTab = &lpCMap[bCurChar = *lpbInBuffer];
		if (CP_CLASS(lpCharPropTab) == CLASS_DIGIT) {

			/* The followed character is a digit, so this must be a digit
			 * separator. Continue to get the number */

			goto ScanNumber;
		}
		else {
			/* Back out the change since this is a word separator */

			lpbRawWord--;
			*(LPW)astRawWord = (WORD)(lpbRawWord -
				(LPB)&astRawWord[2]);
			lpibi->cbRawPunctLen--;
			goto FlushNumber;
		}
	}
	//
	//	If I run out of data, set things up so I'll come back
	//	to this state if the user provides more data.
	//
	lpibi->state = SCAN_SEP_STATE;
	*(LPW)astRawWord = (WORD)(lpbRawWord - (LPB)&astRawWord[2]);
    *(LPW)astNormWord = (WORD)(lpbNormWord - (LPB)&astNormWord[2]);
	return S_OK;
}

PRIVATE int PASCAL NEAR LigatureMap(BYTE c, LPB lpbNormWord,
	LPCMAP lpCMap, LPB lpbLigatureTab, WORD wcLigature)
{
	for (;wcLigature > 0; wcLigature --) { 
		if (*lpbLigatureTab == c) {
			*lpbNormWord++ = CP_NORMC(&lpCMap[lpbLigatureTab[1]]);
			*lpbNormWord++ = CP_NORMC(&lpCMap[lpbLigatureTab[2]]);
			return 2;
		}
		lpbLigatureTab += 3;
	}

	/* Not a ligature */
	*lpbNormWord++ = CP_NORMC(&lpCMap[c]);
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\breakers\stdbrkr.h ===
// STDBRKR.H:  Definition of CITStdBreaker breaker object implementation.

#ifndef __STDBRKR_H__
#define __STDBRKR_H__

#include <itwbrk.h>
#include <itwbrkid.h>
#include "verinfo.h"


#define VERSION_STDBRKR		(MAKELONG(MAKEWORD(0, rapFile), MAKEWORD(rmmFile, rmjFile)))


// Group of flags that indicate what data has been persisted to the
// breaker's stream.
#define	ITSTDBRK_PERSISTED_BRKCTL		0x00000001
#define	ITSTDBRK_PERSISTED_CHARTABLE	0x00000002
#define	ITSTDBRK_PERSISTED_STOPWORDLIST	0x00000004
#define	ITSTDBRK_PERSISTED_STEMMER		0x00000008

// Max number of stop words allowed.
#define ITSTDBRK_STOPHASH_SIZE			211		// A good prime number for supporting
												// up to about 2000 stop words.

// Breaker control structure that contains information that can
// vary how text words are interpreted and broken.
typedef struct _brkctl
{
	DWORD	dwCodePageID;
	LCID	lcid;
	DWORD	dwBreakWordType;
	DWORD	grfBreakFlags;
} BRKCTL;


// Word callback function param struct that is passed to StdBreakerWordFunc,
// which wraps the IWordSink implementation as far as the internal
// word breaking functions are concerned.
typedef struct _wrdfnpm
{
	PIWRDSNK	piwrdsnk;
	DWORD		dwCodePageID;
	HGLOBAL		hmemUnicode;
	DWORD		cbBufUnicodeCur;
	LPBYTE		lpbBuf;				// MBCS text buffer.
} WRDFNPM;


class CITStdBreaker : 
	public IWordBreaker,
	public IWordBreakerConfig,
	public IPersistStreamInit,
	public IITStopWordList,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CITStdBreaker,&CLSID_ITStdBreaker>
{
public:
    CITStdBreaker();
	virtual ~CITStdBreaker();


BEGIN_COM_MAP(CITStdBreaker)
	COM_INTERFACE_ENTRY(IWordBreaker)
	COM_INTERFACE_ENTRY(IWordBreakerConfig)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY(IITStopWordList)
END_COM_MAP()

DECLARE_REGISTRY(CLSID_ITStdBreaker, "ITIR.StdWordBreaker.4", "ITIR.StdWordBreaker", 0, THREADFLAGS_BOTH )

	// IWordBreaker methods
	STDMETHOD(Init)(BOOL fQuery, ULONG ulMaxTokenSize, BOOL *pfLicense);
	STDMETHOD(BreakText)(TEXT_SOURCE *pTextSource, IWordSink *pWordSink,
											IPhraseSink *pPhraseSink);
	STDMETHOD(ComposePhrase)(WCHAR const *pwcNoun, ULONG cwcNoun,
						WCHAR const *pwcModifier, ULONG cwcModifier,
						ULONG ulAttachmentType, WCHAR *pwcPhrase,
												ULONG *pcwcPhrase);
    STDMETHOD(GetLicenseToUse)(WCHAR const **ppwcsLicense);

	// IWordBreakerConfig methods
	STDMETHOD(SetLocaleInfo)(DWORD dwCodePageID, LCID lcid);
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid);
	STDMETHOD(SetBreakWordType)(DWORD dwBreakWordType);
	STDMETHOD(GetBreakWordType)(DWORD *pdwBreakWordType);
	STDMETHOD(SetControlInfo)(DWORD grfBreakFlags, DWORD dwReserved);
	STDMETHOD(GetControlInfo)(DWORD *pgrfBreakFlags, DWORD *pdwReserved);
	STDMETHOD(LoadExternalBreakerData)(IStream *pStream, DWORD dwExtDataType);
	STDMETHOD(SetWordStemmer)(REFCLSID rclsid, IStemmer *pStemmer);
	STDMETHOD(GetWordStemmer)(IStemmer **ppStemmer);

	// IITStopWordList methods.	
	STDMETHOD(AddWord)(WCHAR const *pwcInBuf, ULONG cwc);
	STDMETHOD(LookupWord)(WCHAR const *pwcInBuf, ULONG cwc);

	// IPersistStreamInit methods
	STDMETHOD(GetClassID)(CLSID *pclsid);
	STDMETHOD(IsDirty)(void);
	STDMETHOD(Load)(IStream *pStream);
	STDMETHOD(Save)(IStream *pStream, BOOL fClearDirty);
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSizeMax);
	STDMETHOD(InitNew)(void);

private:
	// Private methods
	HRESULT StopListOp(WCHAR const *pwcInBuf, ULONG cwc, BOOL fAddWord);
	HRESULT	ReallocBuffer(HGLOBAL *phmemBuf, DWORD *cbBufCur, DWORD cbBufNew);
	void	ClearMembers(void);
	void	InitBrkCtl(void);
	void	Close(void);

	// Private data members
	BOOL		m_fInitialized;
	BOOL		m_fDirty;
	BOOL		m_fQueryContext;
	DWORD		m_grfPersistedItems;
	BRKCTL		m_brkctl;
	HGLOBAL		m_hmemAnsi;
	DWORD		m_cbBufAnsiCur;
	LPCTAB		m_lpctab;
	LPSIPB		m_lpsipb;
	PISTEM		m_pistem;
	CLSID		m_clsidStemmer;
    _ThreadModel::AutoCriticalSection m_cs;      // Critical section obj.
};


// Initial size of Ansi string buffers.
#define	cbAnsiBufInit	256


#endif	// __STDBRKR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\breakers\stdbrkr.cpp ===
/*************************************************************************
*  @doc SHROOM EXTERNAL API                                              *
*																		 *
*  STDBRKR.CPP                                                           *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1997                              *
*  All Rights reserved.                                                  *
*                                                                        *
*  This file contains the implementation of CITStdBreaker methods.       *
*  CITStdBreaker is a pluggable word breaker object that can optionally  *
*  use a character class table and stop word list during its breaking	 *
*  operations.  Although all the word breaking interface methods		 *
*  that accepts text require it to be Unicode, CITStdBreaker still only	 *
*  support MBCS internally.												 *
*																	     *
**************************************************************************
*                                                                        *
*  Written By   : Bill Aloof	                                         *
*  Current Owner: billa		                                             *
*                                                                        *
**************************************************************************/
#include <mvopsys.h>

#ifdef _DEBUG
static char s_aszModule[] = __FILE__;   /* For error report */
#endif

#ifdef IA64
#include <itdfguid.h> 
#endif

#include <atlinc.h>	    // includes for ATL. 
#include <_mvutil.h>
#include <mem.h>
#include <orkin.h>
#include <mvsearch.h>
#include "common.h"
#include <iterror.h>
#include <itwbrk.h>
#include <itwbrkid.h>
#include "stdbrkr.h"

										
HRESULT FAR PASCAL StdBreakerWordFunc(LST lstRawWord, LST lstNormWord,
										DWORD dwWordOffset, LPVOID lpvUser);


//---------------------------------------------------------------------------
//						Constructor and Destructor
//---------------------------------------------------------------------------


CITStdBreaker::CITStdBreaker()
{
	ClearMembers();
	m_hmemAnsi = NULL;
	m_cbBufAnsiCur = 0;
	m_pistem = NULL;
}

CITStdBreaker::~CITStdBreaker()
{
	Close();
}


//---------------------------------------------------------------------------
//						IWordBreaker Method Implementations
//---------------------------------------------------------------------------


/********************************************************************
 * @method    STDMETHODIMP | IWordBreaker | Init |
 *     Gives the breaker object a chance to initialize itself beyond
 *	   what it did during IPersistStreamInit::InitNew or ::Load.
 * @parm BOOL | fQuery | TRUE means breaker context is query processing
 * @parm ULONG | ulMaxTokenSize | Max term length requested by caller
 * @parm BOOL* | pfLicense | Whether the breaker is subject to a license
 *
 * @rvalue E_POINTER | pfLicense was NULL
 *
 ********************************************************************/
STDMETHODIMP
CITStdBreaker::Init(BOOL fQuery, ULONG ulMaxTokenSize, BOOL *pfLicense)
{
	HRESULT	hr = S_OK;
	
	// NOTE: We don't check m_fInitialized here because we consider ourselves
	// adequately initialized once IPersistStreamInit::InitNew or ::Load
	// has been called.
	if (pfLicense == NULL)
		return (SetErrReturn(E_POINTER));

	// If we haven't been initialized yet (i.e. no call was made to either
	// IPersistStreamInit::InitNew or Load), we'll initialize ourselves now.
	// This allows Tripoli clients to use us without any code changes on their
	// part.
	if (!m_fInitialized)
		hr = InitNew();

	if (SUCCEEDED(hr) && m_pistem != NULL)
		hr = m_pistem->Init(ulMaxTokenSize, pfLicense);
		
	if (SUCCEEDED(hr))
	{
		if (m_fQueryContext = fQuery)
			MVCharTableSetWildcards(m_lpctab);
		
		// We set *pfLicense only if the stemmer didn't.
		if (m_pistem == NULL)
			*pfLicense = FALSE;
	}

	// NOTE: We don't support caller-specified internal truncation of terms
	// based on ulMaxTokenSize.  The breaker routines have a hard-coded
	// maximum of CB_MAX_WORD_LEN.  This is OK since the word sink is supposed
	// to be prepared to have to truncate anyway.

	return (hr);
}


/********************************************************************
 * @method    STDMETHODIMP | IWordBreaker | BreakText |
 * Parses text to find both individual tokens and noun phrases, then 
 * calls methods of IWordSink and IPhraseSink with the results.  
 *	   
 * @parm TEXT_SOURCE | *pTextSource | Source of the UniCode text.
 * @parm IWordSink | *pWordSink | Pointer to the word sink. 
 * @parm IPhraseSink | *pPhraseSink | Pointer to the phrase sink. 
 *      (Not supported at this time.)
 *
 * @rvalue S_OK | The operation completed successfully. 
 * @rvalue E_POINTER | The text source is null. 
 * @rvalue E_INVALIDARG | The word sink is NULL. 
 * @rvalue E_NOTOPEN | 
 * @rvalue E_OUTOFMEMORY | There was not enough memory to complete the operation. 
 * 
 * @comm
 * The raw text in pTextSource is parsed by the word breaker until no 
 * more text is available to refill the buffer.  At this point, BreakText returns S_OK.
 * 
 *
 ********************************************************************/
STDMETHODIMP
CITStdBreaker::BreakText(TEXT_SOURCE *pTextSource, IWordSink *pWordSink,
											IPhraseSink *pPhraseSink)
{
	HRESULT		hr = S_OK;
	LPIBI		lpibi = NULL;

	if (pTextSource == NULL)
		return (SetErrReturn(E_POINTER));

	// We treat a NULL pWordSink different than a NULL pTextSource
	// to indicate to the caller that we can't do anything meaningful
	// without a pWordSink because we don't do phrase breaking.
	if (pWordSink == NULL)
		return (SetErrReturn(E_INVALIDARG));

	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	m_cs.Lock();

	if ((lpibi = BreakerInitiate()) != NULL)
	{
		BRK_PARMS	bkp;
		WRDFNPM		wrdfnpm;

		// Set up word callback wrapper params.
		MEMSET(&wrdfnpm, NULL, sizeof(WRDFNPM));
		wrdfnpm.piwrdsnk = pWordSink;
		wrdfnpm.dwCodePageID = m_brkctl.dwCodePageID;

		// Set up breaker params that will get passed to FBreakX.
		bkp.lpInternalBreakInfo = lpibi;
		bkp.lcbBufOffset = 0;
		bkp.lpvUser = (LPVOID) &wrdfnpm;
		bkp.lpfnOutWord = StdBreakerWordFunc;
		bkp.lpStopInfoBlock = m_lpsipb;
		bkp.lpCharTab = m_lpctab;
		bkp.fFlags =
			((m_brkctl.grfBreakFlags & IITWBC_BREAK_ACCEPT_WILDCARDS) != 0 ?
														ACCEPT_WILDCARD : 0);

		// Loop to break text.
		do
		{
			DWORD	cbAnsi;
			DWORD	cwch;

			// Make the ANSI buffer big enough to handle all DBCS in case
			// that's what we get when converting from Unicode.
			cbAnsi = sizeof(WCHAR) *
						(cwch = (pTextSource->iEnd - pTextSource->iCur));

			if (SUCCEEDED(hr =
					ReallocBuffer(&m_hmemAnsi, &m_cbBufAnsiCur, cbAnsi)))
			{
				bkp.lpbBuf = (LPBYTE) _GLOBALLOCK(m_hmemAnsi);

				if ((bkp.cbBufCount =
						WideCharToMultiByte(m_brkctl.dwCodePageID, NULL, 
						  (LPCWSTR) &pTextSource->awcBuffer[pTextSource->iCur],
									cwch, (char *) bkp.lpbBuf, m_cbBufAnsiCur,
															NULL, NULL)) > 0)
				{
					// StdBreakerWordFunc needs the MBCS buffer to compute an
					// accurate word offset into the Unicode buffer.
					wrdfnpm.lpbBuf = bkp.lpbBuf;
					
					switch (m_brkctl.dwBreakWordType)
					{
						case IITWBC_BREAKTYPE_TEXT:
							if (SUCCEEDED(hr = FBreakWords(&bkp)))
							{
					            /* Flush the word breaker */
					            bkp.lpbBuf = NULL;
					            bkp.cbBufCount = 0;
					            hr = FBreakWords(&bkp);
							}
							break;

						case IITWBC_BREAKTYPE_NUMBER:
							if (SUCCEEDED(hr = FBreakNumber(&bkp)))
							{
					            /* Flush the word breaker */
					            bkp.lpbBuf = NULL;
					            bkp.cbBufCount = 0;
					            hr = FBreakNumber(&bkp);
							}
							break;

						case IITWBC_BREAKTYPE_DATE:
							if (SUCCEEDED(hr = FBreakDate(&bkp)))
							{
					            /* Flush the word breaker */
					            bkp.lpbBuf = NULL;
					            bkp.cbBufCount = 0;
					            hr = FBreakDate(&bkp);
							}
							break;

						case IITWBC_BREAKTYPE_TIME:
							if (SUCCEEDED(hr = FBreakTime(&bkp)))
							{
					            /* Flush the word breaker */
					            bkp.lpbBuf = NULL;
					            bkp.cbBufCount = 0;
					            hr = FBreakTime(&bkp);
							}
							break;

						case IITWBC_BREAKTYPE_EPOCH:
							if (SUCCEEDED(hr = FBreakEpoch(&bkp)))
							{
					            /* Flush the word breaker */
					            bkp.lpbBuf = NULL;
					            bkp.cbBufCount = 0;
					            hr = FBreakEpoch(&bkp);
							}
							break;

						default:
							ITASSERT(FALSE);
							hr = E_UNEXPECTED;
							break;
					};
				}
				else
					hr = E_UNEXPECTED;

				_GLOBALUNLOCK(m_hmemAnsi);
			}

			// Advance cur to end just in case the caller cares about this
			// being the case when we ask for more characters.			
			pTextSource->iCur = pTextSource->iEnd;

		} while (SUCCEEDED(hr) &&
				 SUCCEEDED(pTextSource->pfnFillTextBuffer(pTextSource)));

		// Free any buffer that the word callback wrapper may have allocated.
		if (wrdfnpm.hmemUnicode != NULL)
			_GLOBALFREE(wrdfnpm.hmemUnicode);
	}
	else
		hr = E_OUTOFMEMORY;

	if (lpibi != NULL)
		BreakerFree(lpibi);

	m_cs.Unlock();

	return (hr);
}


/********************************************************************
 * @method    STDMETHODIMP | IWordBreaker | ComposePhrase |
 *  Converts a noun and modifier back into a linguistically correct source phrase.  
 *  
 *
 * @parm WCHAR const | *pwcNoun | Pointer to the word being modified. 
 * @parm ULONG | cwcNoun | The count of characters in pwcNoun.
 * @parm WCHAR const | *pwcModifier | Points to the word modifying pwcNoun
 * @parm ULONG | cwcModifier | Length of pwcModifier
 * @parm ULONG | ulAttachmentType | A wordbreaker-specific value which a 
 *         wordbreaker can use to store additional information about the method of composition.
 * @parm WCHAR | *pwcPhrase | Pointer to a buffer in which to store the composed phrase
 * @parm ULONG | *pcwcPhrase | [in]  length in characters of the pwcPhrase buffer. 
 *              [out] the actual length of the composed phrase. If 
 *              WBREAK_E_BUFFER_TOO_SMALL is returned, then on output pcwcPhrase 
 *              contains the required length of pwcPhrase. 
 * 
 * @rvalue S_OK | The object was successfully created
 * @rvalue E_INVALIDARG | The argument was not valid
 * @rvalue E_NOTINIT | 
 * @rvalue E_OUTOFMEMORY | 
 *
 * @comm
 * Not implemented
 ********************************************************************/
STDMETHODIMP
CITStdBreaker::ComposePhrase(WCHAR const *pwcNoun, ULONG cwcNoun,
						WCHAR const *pwcModifier, ULONG cwcModifier,
						ULONG ulAttachmentType, WCHAR *pwcPhrase,
												ULONG *pcwcPhrase)
{
	return (E_NOTIMPL);
}


/********************************************************************
 * @method    STDMETHODIMP | IWordBreaker | GetLicenseToUse |
 * Returns a pointer to the license information provided by the vendor  
 * of this specific implementation of the IWordBreaker interface.  
 *
 * @parm WCHAR const | **ppwcsLicense | Pointer to the license information.
 *
 * @rvalue E_POINTER | ppwcsLicense is null. 
 ********************************************************************/
STDMETHODIMP
CITStdBreaker::GetLicenseToUse(WCHAR const **ppwcsLicense)
{
	HRESULT	hr;
	
	if (ppwcsLicense == NULL)
		return (SetErrReturn(E_POINTER));
		
	if (m_pistem != NULL)
		hr = m_pistem->GetLicenseToUse(ppwcsLicense);
	else
		hr = E_NOTIMPL;
		
	return (hr);
}


//---------------------------------------------------------------------------
//						IWordBreakerConfig Method Implementations
//---------------------------------------------------------------------------


/********************************************************************
 * @method    STDMETHODIMP | IWordBreakerConfig | SetLocaleInfo|
 * Sets locale information for the word breaker. 
 * 
 *
 * @parm DWORD | dwCodePageID | ANSI code page no. specified at build time.
 * @parm LCID | lcid | Win32 locale identifier specified at build time. 
 *
 * @rvalue E_NOTOPEN | [?] is not initialized.
 * @rvalue S_OK | The locale described by the parameters is supported. 
 *
 ********************************************************************/
STDMETHODIMP
CITStdBreaker::SetLocaleInfo(DWORD dwCodePageID, LCID lcid)
{
	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	m_cs.Lock();

	m_brkctl.dwCodePageID = dwCodePageID;
	m_brkctl.lcid = lcid;
	m_fDirty = TRUE;

	m_cs.Unlock();

	return (S_OK);
}


/*****************************************************************
 * @method    STDMETHODIMP | IWordBreakerConfig | GetLocaleInfo|
 * Retrieves locale information. 
 *
 * @parm DWORD | *pdwCodePageID | Pointer to ANSI code page no. specified at build time.
 * @parm LCID | *plcid | Pointer to Win32 locale identifier specified at build time. 
 *
 * @rvalue E_POINTER | Either the code page pointer or the locale identifier is null. 
 * @rvalue E_NOTOPEN | [?] is not initialized.
 * @rvalue S_OK | The operation completed successfully. 
  * 
 ****************************************************************/
STDMETHODIMP
CITStdBreaker::GetLocaleInfo(DWORD *pdwCodePageID, LCID *plcid)
{
	if (pdwCodePageID == NULL || plcid == NULL)
		return (SetErrReturn(E_POINTER));

	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	m_cs.Lock();

	*pdwCodePageID = m_brkctl.dwCodePageID;
	*plcid = m_brkctl.lcid;

	m_cs.Unlock();

	return (S_OK);
}


/*****************************************************************
 * @method    STDMETHODIMP | IWordBreakerConfig | SetBreakWordType|
 * Sets the type of words the breaker should expect
 * to see in all subsequent calls to IWordBreaker::BreakText. 
 *
 * @parm DWORD | dwBreakWordType | Specifies the type for break words. 
 *  Can be one of IITWBC_BREAKTYPE_TEXT, IITWBC_BREAKTYPE_NUMBER, 
 *  IITWBC_BREAKTYPE_DATE, IITWBC_BREAKTYPE_TIME, IITWBC_BREAKTYPE_EPOCH. 
 * 
 *
 * @rvalue E_INVALIDARG | Invalid break word type.
 * @rvalue S_OK | The operation completed successfully. 
 *****************************************************************/ 
STDMETHODIMP
CITStdBreaker::SetBreakWordType(DWORD dwBreakWordType)
{
	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	switch (dwBreakWordType)
	{
		case IITWBC_BREAKTYPE_TEXT:
		case IITWBC_BREAKTYPE_NUMBER:
		case IITWBC_BREAKTYPE_DATE:
		case IITWBC_BREAKTYPE_TIME:
		case IITWBC_BREAKTYPE_EPOCH:
			break;

		default:
			return (SetErrReturn(E_INVALIDARG));
	};

	m_cs.Lock();

	m_brkctl.dwBreakWordType = dwBreakWordType;
	m_fDirty = TRUE;

	m_cs.Unlock();

	return (S_OK);
}


/*****************************************************************
 * @method    STDMETHODIMP | IWordBreakerConfig | GetBreakWordType|
 * Retrieves the type of words the breaker expects to see in  
 * calls to IWordBreaker::BreakText. 
 *
 * @parm DWORD | *pdwBreakWordType | Pointer to the type for break words. 
 *  Can be one of IITWBC_BREAKTYPE_TEXT (0), IITWBC_BREAKTYPE_NUMBER (1), 
 *  IITWBC_BREAKTYPE_DATE (2), IITWBC_BREAKTYPE_TIME (3), IITWBC_BREAKTYPE_EPOCH (4). 
 * 
 *
 * @rvalue E_POINTER | Break word type is null.
 * @rvalue S_OK | The operation completed successfully. 
 *****************************************************************/ 
STDMETHODIMP
CITStdBreaker::GetBreakWordType(DWORD *pdwBreakWordType)
{
	if (pdwBreakWordType == NULL)
		return (SetErrReturn(E_POINTER));

	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	*pdwBreakWordType = m_brkctl.dwBreakWordType;

	return (S_OK);
}


/*****************************************************************
 * @method    STDMETHODIMP | IWordBreakerConfig | SetControlInfo |
 * Sets information that controls certain aspects of word breaking. 
 *
 * @parm DWORD | grfBreakFlags | Can be: IITWBC_BREAK_ACCEPT_WILDCARDS 
 *    (0x00000001), to interpret wild card characters as such; and
 *     IITWBC_BREAK_AND_STEM (0x00000002), stem words after breaking. 
 * @parm DWORD | dwReserved |Reserved for future use. 
 *
 * @rvalue E_INVALIDARG | Invalid control flag.
 * @rvalue S_OK | The operation completed successfully. 
 *****************************************************************/ 
STDMETHODIMP
CITStdBreaker::SetControlInfo(DWORD grfBreakFlags, DWORD dwReserved)
{
	DWORD	grfFlagsUnsupported;

	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	grfFlagsUnsupported = ~(IITWBC_BREAK_ACCEPT_WILDCARDS);

	if ((grfBreakFlags & grfFlagsUnsupported) != 0)
		return (SetErrReturn(E_INVALIDARG));

	m_cs.Lock();

	m_brkctl.grfBreakFlags = grfBreakFlags;
	m_fDirty = TRUE;

	m_cs.Unlock();

	return (S_OK);
}


/*****************************************************************
 * @method    STDMETHODIMP | IWordBreakerConfig | GetControlInfo |
 * Retrieves information about word breaker control flags. 
 *
 * @parm DWORD | *pgrfBreakFlags | Pointer to breaker control flags. 
 * @parm DWORD | *pdwReserved |Reserved for future use. 
 *
 * @rvalue E_POINTER | Break flags are not set (pgrfBreakFlags is null).
 * @rvalue S_OK | The operation completed successfully. 
 *****************************************************************/ 
STDMETHODIMP
CITStdBreaker::GetControlInfo(DWORD *pgrfBreakFlags, DWORD *pdwReserved)
{
	if (pgrfBreakFlags == NULL)
		return (SetErrReturn(E_POINTER));

	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	*pgrfBreakFlags = m_brkctl.grfBreakFlags;

	return (S_OK);
}


/*****************************************************************
 * @method    STDMETHODIMP | IWordBreakerConfig | LoadExternalBreakerData |
 * Loads word breaker data from an external source, such as a table 
 * containing char-by-char break information or a list of stop words. 
 *
 * @parm IStream | *pStream | Pointer to external source of data. 
 * @parm DWORD | dwExtDataType | Specifies the type of data in the stream. 
 *
 * @rvalue E_POINTER | pStream is null.
 * @rvalue E_NOTOPEN | The stream has not been initialized. 
 * @rvalue S_OK | The operation completed successfully.
 *
 * @comm 
 * Although the format of the data in the stream is entirely
 * implementation-specific, this interface does define a couple
 * of general types for that data which can be passed in
 * dwStreamDataType:
 *		IITWBC_EXTDATA_CHARTABLE
 *		IITWBC_EXTDATA_STOPWORDLIST
 *
 *****************************************************************/ 
STDMETHODIMP
CITStdBreaker::LoadExternalBreakerData(IStream *pStream, DWORD dwExtDataType)
{
	HRESULT	hr;
	HFPB	hfpb;
	LPCTAB	lpctab;
	LPSIPB	lpsipb;
	
	if (pStream == NULL)
		return (SetErrReturn(E_POINTER));
		
	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	m_cs.Lock();
		
	if ((hfpb = FpbFromHf((HF) pStream, &hr)) != NULL)
	{
		switch (dwExtDataType)
		{
			case IITWBC_EXTDATA_CHARTABLE:
			
				// Load the external character table.
				lpctab = MVCharTableLoad(hfpb, NULL, &hr);
	
				if (SUCCEEDED(hr))
				{
					ITASSERT(lpctab != NULL);
					m_fDirty = TRUE;
					m_grfPersistedItems |= ITSTDBRK_PERSISTED_CHARTABLE;
					if (m_fQueryContext)
						MVCharTableSetWildcards(lpctab);
 
 					// Dispose of any pre-existing char table.
					MVCharTableDispose(m_lpctab);
					m_lpctab = lpctab;
				}
				break;
						
			case IITWBC_EXTDATA_STOPWORDLIST:
				// We should at least have an internal default char table.
				ITASSERT(m_lpctab != NULL);
				
				// Init the in-memory stop word list and load the external
				// list.
				if ((lpsipb = MVStopListInitiate(ITSTDBRK_STOPHASH_SIZE,
															&hr)) != NULL &&
					SUCCEEDED(hr = MVStopListLoad(hfpb, lpsipb, NULL,
													FBreakWords, m_lpctab)))
				{
					m_fDirty = TRUE;
					m_grfPersistedItems |= ITSTDBRK_PERSISTED_STOPWORDLIST;

					MVStopListDispose(m_lpsipb);
					m_lpsipb = lpsipb;
				}
				break;
				
			default:
				hr = E_INVALIDARG;
				break;
		};
		
		FreeHfpb(hfpb);
	}
	
	m_cs.Unlock();

	return (hr);
}


/*****************************************************************
 * @method    STDMETHODIMP | IWordBreakerConfig | SetWordStemmer |
 * Allows you to associate a stemmer with the word breaker. 
 *
 * @parm REFCLSID | rclsid | Class identifier for the stemmer. 
 * @parm IStemmer | *pStemmer | Pointer to the stemmer. 
 *
 * @rvalue E_NOTOPEN | [?] has not been initialized. 
 * @rvalue S_OK | The operation completed successfully. 
 *
 * @comm
 * The 	breaker takes responsibility for calling IPersistStreamInit::Load/Save
 * when it is loaded/saved if the stemmer supports that interface.
 *****************************************************************/ 
STDMETHODIMP
CITStdBreaker::SetWordStemmer(REFCLSID rclsid, IStemmer *pStemmer)
{
	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	m_cs.Lock();
	
	if (m_pistem != NULL)
		m_pistem->Release();
		
	if ((m_pistem = pStemmer) != NULL)
	{
		m_pistem->AddRef();
		
		ITASSERT(rclsid != GUID_NULL);
		m_clsidStemmer = rclsid;

		m_fDirty = TRUE;
	}

	SetGrfFlag(&m_grfPersistedItems,
				ITSTDBRK_PERSISTED_STEMMER, m_pistem != NULL);
	
	m_cs.Unlock();

	return (S_OK);
}


/*****************************************************************
 * @method    STDMETHODIMP | IWordBreakerConfig | GetWordStemmer |
 * Indicates whether or not a stemmer is associated with the word breaker. 
 *
 * @parm IStemmer | **ppStemmer | Pointer to the stemmer. 
 *
 * @rvalue E_POINTER | No stemmer has been associated (ppStemmer is NULL). 
 * @rvalue E_NOTOPEN | [?] has not been initialized. 
 * @rvalue S_OK | The operation completed successfully. 
 *
 * @comm
 * The 	breaker takes responsibility for calling IPersistStreamInit::Load/Save
 * when it is loaded/saved if the stemmer supports that interface.
 *****************************************************************/ 
STDMETHODIMP
CITStdBreaker::GetWordStemmer(IStemmer **ppStemmer)
{
	if (ppStemmer == NULL)
		return (SetErrReturn(E_POINTER));
		
	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));
		
	if ((*ppStemmer = m_pistem) != NULL)
		m_pistem->AddRef();

	return (m_pistem != NULL ? S_OK : S_FALSE);
}


//---------------------------------------------------------------------------
//						IITStopWordList Method Implementations
//---------------------------------------------------------------------------


/*****************************************************************
 * @method    STDMETHODIMP | IITStopWordList | AddWord |
 * Adds a word to the stop word list. 
 *
 * @parm WCHAR const | *pwcInBuf | Pointer to the input buffer. 
 * @parm ULONG | cwc | Length of word (count of wide characters). 
 *
 * @rvalue S_OK | The operation completed successfully. 
 *
 *****************************************************************/ 
STDMETHODIMP
CITStdBreaker::AddWord(WCHAR const *pwcInBuf, ULONG cwc)
{
	return (StopListOp(pwcInBuf, cwc, TRUE));
}


/*****************************************************************
 * @method    STDMETHODIMP | IITStopWordList | LookupWord |
 * Looks up a word in the stop word list. 
 *
 * @parm WCHAR const | *pwcInBuf | Pointer to the input buffer. 
 * @parm ULONG | cwc | Length of word (count of wide characters). 
 *
 * @rvalue S_OK | The operation completed successfully. 
 *
 *****************************************************************/ 
STDMETHODIMP
CITStdBreaker::LookupWord(WCHAR const *pwcInBuf, ULONG cwc)
{
	return (StopListOp(pwcInBuf, cwc, FALSE));
}



//---------------------------------------------------------------------------
//						IPersistStreamInit Method Implementations
//---------------------------------------------------------------------------


STDMETHODIMP
CITStdBreaker::GetClassID(CLSID *pclsid)
{
	if (pclsid == NULL)
		return (SetErrReturn(E_POINTER));

	*pclsid = CLSID_ITStdBreaker;
	return (S_OK);
}


STDMETHODIMP
CITStdBreaker::IsDirty(void)
{
	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	return (m_fDirty ? S_OK : S_FALSE);
}


STDMETHODIMP
CITStdBreaker::Load(IStream *pStream)
{
	HRESULT	hr;
	DWORD	dwVersion;
	DWORD	grfPersistedItems;
	DWORD	cbRead;

	if (pStream == NULL)
		return (SetErrReturn(E_POINTER));

	// Lock before checking m_fInitialized to make sure we don't compete
	// with a call to ::InitNew.
	m_cs.Lock();

	if (m_fInitialized)
		return (SetErrReturn(E_ALREADYOPEN));

	if (SUCCEEDED(hr = pStream->Read((LPVOID) &dwVersion, sizeof(DWORD),
																&cbRead)) &&
		SUCCEEDED(hr = ((cbRead == sizeof(DWORD)) ? S_OK : E_BADFORMAT)) &&
		SUCCEEDED(hr = ((dwVersion == VERSION_STDBRKR) ? S_OK :
															E_BADVERSION)) &&
		SUCCEEDED(hr = pStream->Read((LPVOID) &grfPersistedItems,
													sizeof(DWORD), &cbRead)) &&
		SUCCEEDED(hr = ((cbRead == sizeof(DWORD)) ? S_OK : E_BADFORMAT)))
	{
		if (grfPersistedItems != 0)
		{
			HFPB	hfpb = NULL;

			if ((grfPersistedItems & ITSTDBRK_PERSISTED_BRKCTL) != 0)
			{
				if (SUCCEEDED(hr =
						pStream->Read((LPVOID) &m_brkctl, sizeof(BRKCTL), &cbRead)))
					hr = ((cbRead == sizeof(BRKCTL)) ? S_OK : E_BADFORMAT);
			}
			else
			{
				// We have an inconsistent persistent state.  The only way
				// we should have no BRKCTL is if we have no persistent
				// state at all (except for version number and persistent
				// flags which we've already loaded).
				ITASSERT(FALSE);
				hr = E_UNEXPECTED;
			}

			if (SUCCEEDED(hr) &&
				(hfpb = FpbFromHf((HF) pStream, &hr)) != NULL)
			{
				// Load the character table if one is there; otherwise just
				// use the internal default table.
				if ((grfPersistedItems & ITSTDBRK_PERSISTED_CHARTABLE) != 0)
					m_lpctab = MVCharTableIndexLoad(hfpb, NULL, &hr);
				else
					m_lpctab = MVCharTableGetDefault(&hr);
			}

			if (SUCCEEDED(hr) &&
				(grfPersistedItems & ITSTDBRK_PERSISTED_STOPWORDLIST) != 0)
			{
				// Load the stop word list.
				if ((m_lpsipb =	MVStopListInitiate(ITSTDBRK_STOPHASH_SIZE,
																&hr)) != NULL)
					hr = MVStopListIndexLoad(hfpb, m_lpsipb, NULL);
			}

			if (hfpb != NULL)
				FreeHfpb(hfpb);
			
			if (SUCCEEDED(hr) &&
				(grfPersistedItems & ITSTDBRK_PERSISTED_STEMMER) != 0)
			{
				IPersistStreamInit	*pipstmi;
				
				ITASSERT(m_pistem == NULL);
				
				// Instantiate and load the stemmer if it
				// implements IPersistStreamInit.
				if (SUCCEEDED(hr = ReadClassStm(pStream, &m_clsidStemmer)) &&
					SUCCEEDED(hr = CoCreateInstance(m_clsidStemmer, NULL,
													CLSCTX_INPROC_SERVER,
										IID_IStemmer, (LPVOID *)&m_pistem)) &&
					SUCCEEDED(m_pistem->QueryInterface(IID_IPersistStreamInit,
															(LPVOID *)&pipstmi)))
				{
					hr = pipstmi->Load(pStream);
					pipstmi->Release();
				}
			}
		}
		else
		{
			// If there were no persisted items (we release one beta version
			// without pluggable breakers where we had dummy instance data
			// where this was true) then we should just behave like we're being
			// created anew.
			hr = InitNew();
		}
	}

	if (SUCCEEDED(hr))
	{
		// We don't want to assign an incorrect grfPersistedItems if
		// we ended up calling InitNew.
		if (!m_fInitialized)
		{
			m_grfPersistedItems = grfPersistedItems;
			m_fInitialized = TRUE;
		}
	}
	else
		// Free any peristed items which may have been loaded successfully.
		Close();

	m_cs.Unlock();
	return (hr);
}


STDMETHODIMP
CITStdBreaker::Save(IStream *pStream, BOOL fClearDirty)
{
	HRESULT	hr;
	DWORD	dwVersion;
	DWORD	cbWritten;

	if (pStream == NULL)
		return (SetErrReturn(E_POINTER));

	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));

	m_cs.Lock();

	dwVersion = VERSION_STDBRKR;
	if (SUCCEEDED(hr = pStream->Write((LPVOID) &dwVersion, sizeof(DWORD),
																&cbWritten)) &&
		SUCCEEDED(hr = pStream->Write((LPVOID) &m_grfPersistedItems,
												sizeof(DWORD), &cbWritten)))
	{
		HFPB	hfpb = NULL;

		if ((m_grfPersistedItems & ITSTDBRK_PERSISTED_BRKCTL) != 0)
			hr = pStream->Write((LPVOID) &m_brkctl, sizeof(BRKCTL), &cbWritten);
		else
		{
			// We should always be writing the BRKCTL structure, but if for some
			// reason the flag to write it is not set, we can still continue
			// because at load time we will tolerate the absence of the struct.
			ITASSERT(FALSE);
		}

		if (SUCCEEDED(hr) &&
			(hfpb = FpbFromHf((HF) pStream, &hr)) != NULL &&
			(m_grfPersistedItems & ITSTDBRK_PERSISTED_CHARTABLE) != 0)
		{
			// Save char table.
			if (m_lpctab != NULL)
				hr = MVCharTableFileBuild(hfpb, m_lpctab, NULL);
			else
			{
				ITASSERT(FALSE);
				hr = E_UNEXPECTED;
			}
		}

		if (SUCCEEDED(hr) &&
			(m_grfPersistedItems & ITSTDBRK_PERSISTED_STOPWORDLIST) != 0)
		{
			// Save stop word list.
			if (m_lpsipb != NULL)
				hr = MVStopFileBuild(hfpb, m_lpsipb, NULL);
			else
			{
				ITASSERT(FALSE);
				hr = E_UNEXPECTED;
			}
		}

		if (hfpb != NULL)
			FreeHfpb(hfpb);
		
		if (SUCCEEDED(hr) &&
			(m_grfPersistedItems & ITSTDBRK_PERSISTED_STEMMER) != 0)
		{
			IPersistStreamInit	*pipstmi;
			
			ITASSERT(m_pistem != NULL);
			
			// Write the stemmer's CLSID and save the stemmer if it
			// implements IPersistStreamInit.
			if (SUCCEEDED(hr = WriteClassStm(pStream, m_clsidStemmer)) &&
				SUCCEEDED(m_pistem->QueryInterface(IID_IPersistStreamInit,
													(LPVOID *) &pipstmi)))
			{
				hr = pipstmi->Save(pStream, fClearDirty);
				pipstmi->Release();
			}
		}
	}

	if (SUCCEEDED(hr) && fClearDirty)
		m_fDirty = FALSE;

	m_cs.Unlock();

	return (hr);
}


STDMETHODIMP
CITStdBreaker::GetSizeMax(ULARGE_INTEGER *pcbSizeMax)
{
	return (E_NOTIMPL);
}


STDMETHODIMP
CITStdBreaker::InitNew(void)
{
	HRESULT	hr = S_OK;
	
	// Lock before checking m_fInitialized to make sure we don't compete
	// with a call to ::Load.
	m_cs.Lock();

	if (m_fInitialized)
		return (SetErrReturn(E_ALREADYOPEN));

	InitBrkCtl();
	m_grfPersistedItems |= ITSTDBRK_PERSISTED_BRKCTL;

	// Get the default char table in case we're never asked to load an
	// external one.  If we do load an external one, we'll properly
	// discard this one.  We don't set the persisted flag for the
	// char table because we don't need to persist the internal default.
	m_lpctab = MVCharTableGetDefault(&hr);

	// Initialize the stop word list so that stop words can be added
	// programmatically if a client desires.
	if (SUCCEEDED(hr))
		m_lpsipb = MVStopListInitiate(ITSTDBRK_STOPHASH_SIZE, &hr);

	if (SUCCEEDED(hr))
		m_fInitialized = m_fDirty = TRUE;
	else
		Close();

	m_cs.Unlock();
	return (hr);
}


//---------------------------------------------------------------------------
//						Private Method Implementations
//---------------------------------------------------------------------------


HRESULT
CITStdBreaker::StopListOp(WCHAR const *pwcInBuf, ULONG cwc, BOOL fAddWord)
{
	HRESULT	hr;
	DWORD	cbAnsi;
	
	if (pwcInBuf == NULL)
		return (E_POINTER);
 
	if (!m_fInitialized)
		return (SetErrReturn(E_NOTOPEN));
		
	if (m_lpsipb == NULL)
		return (SetErrReturn(E_NOTINIT));
		
	m_cs.Lock();
		
 	cbAnsi = (sizeof(WCHAR) * cwc) + sizeof(WORD);
 	
	if (SUCCEEDED(hr =
			ReallocBuffer(&m_hmemAnsi, &m_cbBufAnsiCur, cbAnsi)))
	{
		char	*lpchBuf;
		
		lpchBuf = (char *) _GLOBALLOCK(m_hmemAnsi);

		if ((*((WORD *)lpchBuf) = (WORD) (
				WideCharToMultiByte(m_brkctl.dwCodePageID, NULL, pwcInBuf, cwc,
								lpchBuf + sizeof(WORD), cbAnsi - sizeof(WORD),
															NULL, NULL))) > 0)
		{
			if (fAddWord)
				hr = MVStopListAddWord(m_lpsipb, (LPBYTE)lpchBuf);
			else
				hr = MVStopListLookup(m_lpsipb, (LPBYTE)lpchBuf);
		}
		else
			hr = E_UNEXPECTED;
			
		_GLOBALUNLOCK(m_hmemAnsi);
	}
	
	m_cs.Unlock();

	return (hr);
}


HRESULT
CITStdBreaker::ReallocBuffer(HGLOBAL *phmemBuf, DWORD *pcbBufCur, DWORD cbBufNew)
{
	HRESULT hr = S_OK;

	m_cs.Lock();

	hr = ReallocBufferHmem(phmemBuf, pcbBufCur, max(cbBufNew, cbAnsiBufInit));

	m_cs.Unlock();

	return (hr);
}


void
CITStdBreaker::ClearMembers(void)
{
	MEMSET(&m_brkctl, NULL, sizeof(BRKCTL));
	m_fInitialized = m_fDirty = m_fQueryContext = FALSE;
	m_grfPersistedItems = 0;
	m_lpctab = NULL;
	m_lpsipb = NULL;
	m_clsidStemmer = GUID_NULL;
}


void
CITStdBreaker::InitBrkCtl(void)
{
	m_brkctl.dwCodePageID = GetACP();
	m_brkctl.lcid = GetUserDefaultLCID();
	m_brkctl.dwBreakWordType = IITWBC_BREAKTYPE_TEXT;
	m_brkctl.grfBreakFlags = 0;
}


void
CITStdBreaker::Close(void)
{
	m_cs.Lock();
	
	if (m_hmemAnsi != NULL)
	{
		_GLOBALFREE(m_hmemAnsi);
		m_hmemAnsi = NULL;
		m_cbBufAnsiCur = 0;
	}
	
	if (m_pistem != NULL)
	{
		m_pistem->Release();
		m_pistem = NULL;
	}

	MVCharTableDispose(m_lpctab);
	MVStopListDispose(m_lpsipb);

	ClearMembers();
	
	m_cs.Unlock();
}


//---------------------------------------------------------------------------
//								Utility Functions
//---------------------------------------------------------------------------


//	(6/19/97): BillA, JohnRush, and MikkyA all agreed that we would stop storing
//	offset and length information in the index because the new HTML-based
//	display engines don't allow our clients to find words using that information
//	anyway.
//
//	However, the above decision doesn't eliminate the need to accurately
//	correlate offsets into the MBCS text buffer with offsets into the original
//	Unicode buffer.  This is needed by the query parsing code at runtime.
//	The method for achieving offset correlation is simple: call
//	MultiByteToWideChar on the MBCS text buffer up to dwWordOffset to get
//	back the equivalent Unicode offset which we will pass to the word sink.
//
//	NOTE: The above method will work as long as the breaker code is using
//	the same lead byte table as the system conversion function.  For now,
//	our clients will be responsible for making sure the character table
//	is consistent with the system's lead byte table.  In the future, we
//	probably should make the breaker explicitly set the lead bytes in the
//	character table using the system's lead byte table.
//
//	In the case of single byte characters, the offset and length information
//	automatically correlates between MBCS and Unicode because it is essentially
//	stated in characters, not bytes.
//
HRESULT FAR PASCAL StdBreakerWordFunc(LST lstRawWord, LST lstNormWord,
										DWORD dwWordOffset, LPVOID lpvUser)
{
	HRESULT	hr;
	DWORD	cbAnsi;
	DWORD	cwch;
	DWORD	cwchRaw;
	DWORD	iwchWordOffset = dwWordOffset;
	WCHAR	*lpwchBuf;
	WRDFNPM	*pwrdfnpm;

	if (lstRawWord == NULL || lstNormWord == NULL || lpvUser == NULL)
		return (E_POINTER);

	pwrdfnpm = (WRDFNPM *) lpvUser;


	// We will set up the Unicode buffer to have as many characters as there are
	// bytes in the Ansi string since we don't know how much, if any, DBCS chars
	// there are in the Ansi string.
	cwch = cbAnsi = (DWORD)(*((WORD *)lstNormWord));
	cwchRaw = (DWORD)(*((WORD *)lstRawWord));

	// Set up Unicode buffer for the normalized word.
	if (SUCCEEDED(hr = ReallocBufferHmem(&pwrdfnpm->hmemUnicode,
									 &pwrdfnpm->cbBufUnicodeCur,
									 sizeof(WCHAR) * cwch)))
	{
		lpwchBuf = (WCHAR *) _GLOBALLOCK(pwrdfnpm->hmemUnicode);

		// Compute the Unicode offset that corresponds to the
		// MBCS-based dwWordOffset.  We pass lpwchBuf as a valid placeholder
		// buffer (in case non-NULL is required), but nothing will get
		// written to it.
		iwchWordOffset = MultiByteToWideChar(pwrdfnpm->dwCodePageID, NULL,
									(LPCSTR) pwrdfnpm->lpbBuf, dwWordOffset,
																lpwchBuf, 0);
											
		// Convert the normalized word to Unicode.
		if ((cwch = MultiByteToWideChar(pwrdfnpm->dwCodePageID, NULL, 
										(LPCSTR) &lstNormWord[sizeof(WORD)],
												cbAnsi, lpwchBuf, cwch)) > 0 &&
			pwrdfnpm->piwrdsnk != NULL)
		{
			// Send the normalized word to the word sink.
			hr = pwrdfnpm->piwrdsnk->PutAltWord(lpwchBuf, cwch, cwchRaw,
															iwchWordOffset);
		}
		else
			hr = E_UNEXPECTED;

		_GLOBALUNLOCK(pwrdfnpm->hmemUnicode);
	}

	cwch = cbAnsi = cwchRaw;

	// Set up Unicode buffer for the raw word.
	if (SUCCEEDED(hr) &&
		SUCCEEDED(hr = ReallocBufferHmem(&pwrdfnpm->hmemUnicode,
									 &pwrdfnpm->cbBufUnicodeCur,
									 sizeof(WCHAR) * cwch)))
	{
		lpwchBuf = (WCHAR *) _GLOBALLOCK(pwrdfnpm->hmemUnicode);

		// Convert the raw word to Unicode.
		if ((cwch = MultiByteToWideChar(pwrdfnpm->dwCodePageID, NULL, 
										(LPCSTR) &lstRawWord[sizeof(WORD)],
											cbAnsi, lpwchBuf, cwch)) > 0 &&
			pwrdfnpm->piwrdsnk != NULL)
		{
			// Send the raw word to the word sink.
			hr = pwrdfnpm->piwrdsnk->PutWord(lpwchBuf, cwch, cwchRaw,
															iwchWordOffset);
		}
		else
			hr = E_UNEXPECTED;

		_GLOBALUNLOCK(pwrdfnpm->hmemUnicode);
	}

	return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\combine.c ===
//#define _DUMPALL
#include <mvopsys.h>
#include <mem.h>
#include <memory.h>
#include <orkin.h>
#ifdef DOS_ONLY
#include <assert.h>
#endif	// DOS_ONLY
#include <mvsearch.h>
#include "common.h"
#include "search.h"

#ifdef _DEBUG
static BYTE NEAR s_aszModule[] = __FILE__;	/* Used by error return functions.*/
#endif

typedef int (PASCAL NEAR * FCMP)(LPV, LPV);

#define	MAX_HEAP_ENTRIES	0xffff/sizeof(LPV)	// Maximum entries for heap sort
#define	MIN_HEAP_ENTRIES	100		// Minimum entries for heap sort

/*************************************************************************
 *
 * 	                  INTERNAL GLOBAL FUNCTIONS
 *************************************************************************/

PUBLIC HRESULT PASCAL NEAR OrHandler(LPQT, _LPQTNODE, LPITOPIC, LPV, int);
PUBLIC HRESULT PASCAL NEAR AndHandler(LPQT, _LPQTNODE, LPITOPIC, LPV, int);
PUBLIC HRESULT PASCAL NEAR NotHandler(LPQT, _LPQTNODE, LPITOPIC, LPV, int);
PUBLIC HRESULT PASCAL NEAR NearHandler(LPQT, _LPQTNODE, LPITOPIC, LPV, int);
PUBLIC HRESULT PASCAL NEAR PhraseHandler(LPQT, _LPQTNODE, LPITOPIC, LPV, int);
PUBLIC VOID PASCAL NEAR RemoveUnmarkedTopicList (LPQT, _LPQTNODE, BOOL);
PUBLIC VOID PASCAL NEAR RemoveUnmarkedNearTopicList (_LPQT, _LPQTNODE);
PUBLIC VOID PASCAL NEAR MergeOccurence(LPQT, LPITOPIC , LPITOPIC);
PUBLIC VOID PASCAL NEAR SortResult (LPQT, _LPQTNODE, WORD);
PUBLIC VOID PASCAL NEAR NearHandlerCleanUp (LPQT, _LPQTNODE);
PUBLIC HRESULT PASCAL NEAR TopicListSort (_LPQTNODE, BOOL);

/*************************************************************************
 *	                       GLOBAL VARIABLES 
 *************************************************************************/
extern FNHANDLER HandlerFuncTable[];

/*************************************************************************
 *
 *	                  INTERNAL PRIVATE FUNCTIONS
 *	All of them should be declared near
 *************************************************************************/

PRIVATE VOID PASCAL NEAR RemoveQuery(LPQT, _LPQTNODE);
PUBLIC HRESULT PASCAL NEAR ProximityCheck(LPITOPIC, LPIOCC, WORD);
PRIVATE HRESULT PASCAL NEAR HandleNullNode(LPQT, _LPQTNODE , _LPQTNODE, int);
PRIVATE VOID PASCAL NEAR RemoveUnmarkedOccList (LPQT, LPITOPIC, LPIOCC, int);
PRIVATE VOID PASCAL NEAR OccurenceSort (LPQT, LPITOPIC);
PRIVATE int PASCAL NEAR FRange(DWORD, DWORD, WORD);
PRIVATE HRESULT PASCAL NEAR InsertMarker (LPQT, LPITOPIC);
PRIVATE LPIOCC PASCAL NEAR FindMarker (LPIOCC);
PRIVATE HRESULT PASCAL NEAR NearListMatch (LPIOCC, LPIOCC, WORD);
PRIVATE VOID PASCAL NEAR HeapUp (LPITOPIC far*, WORD, FCMP);
PRIVATE VOID PASCAL NEAR HeapDown (LPITOPIC far*, int, FCMP);
PRIVATE int PASCAL NEAR TopicWeightCompare (LPV, LPV);
PRIVATE int PASCAL NEAR HitCountCompare (LPV, LPV);

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	HRESULT PASCAL NEAR | OrHandler |
 *		Handle ORing the strings
 *
 *	@parm	int | fOperationType |
 *		Tell what kinds of operations we are dealing with
 *
 *	@parm	_LPQTNODE | lpResQtNode |
 *		The query node structure that we add the result to
 *
 *	@parm	LPV | lpStruct |
 *		Vanilla pointers to different types of structures we are dealing with.
 *		The contents of those pointers are determined by the value of
 *		fOperationType, for EXPRESSION_TERM, this is a LPIOCC, for
 *		EXPRESSION_EXPRESSION, this is a_LPQTNODE
 *
 *	@rdesc	S_OK : if the operation has been carried
 *			E_FAIL  : if some errors happened (out-of-memory)
 *
 *	@comm	The implementation is straightforward:
 *************************************************************************/
PUBLIC HRESULT PASCAL NEAR OrHandler(_LPQT lpQueryTree, _LPQTNODE lpResQtNode,
	LPITOPIC lpResTopicList, LPV lpStruct, int fOperationType)
{
	_LPQTNODE	lpCurQtNode;
	LPITOPIC	lpCurTopicList;
	LPITOPIC	lpNextTopicList;

	switch (fOperationType) {
		case EXPRESSION_TERM:
			/* We are adding a new occurence into a TopicID list. This can
			only happens when we are loading the infos for a query's
			TERM_NODE node
			*/

			RET_ASSERT(lpResTopicList);

			/* Adding the new occurence to the TopicID list */
			return OccNodeInsert(lpQueryTree, lpResTopicList, (LPIOCC)lpStruct);
			break;

		case EXPRESSION_EXPRESSION:
			lpCurQtNode = (_LPQTNODE)lpStruct;
			/* Handle different variations of:
				(EXPRESSION_NODE | NULL_NODE) or (NULL_NODE | EXPRESSION_NODE)
			*/
			if (HandleNullNode(lpQueryTree, lpResQtNode, lpCurQtNode, OR_OP))
				return S_OK;

			/* Make sure that we are pointing to the right place to search
			*/
			lpQueryTree->lpTopicStartSearch = lpResQtNode->lpTopicList;

			/* Thread the TopicID List and add them to lpResQtNode */
			for (lpCurTopicList = QTN_TOPICLIST(lpCurQtNode); lpCurTopicList;
				lpCurTopicList = lpNextTopicList) {

				lpNextTopicList = lpCurTopicList->pNext;

				/* Find the location of the TopicID List in the query. */
				if ((lpResTopicList = TopicNodeSearch(lpQueryTree, lpResQtNode,
					lpCurTopicList->dwTopicId)) == NULL){

					/* The list doesn't exist yet, so we just transfer the
					new TopicID list to lpResQtNode
					*/

					RemoveNode(lpQueryTree, (LPV) lpCurQtNode, NULL,
						(LPSLINK) lpCurTopicList, (TOPICLIST_NODE | DONT_FREE));
					TopicNodeInsert (lpQueryTree, lpResQtNode, lpCurTopicList);
				}
				else {
					/* Merging two TopicList together by adding the new
					occurence list to the old result doc list
					*/
					MergeOccurence(lpQueryTree, lpResTopicList, lpCurTopicList);
					/* Remove the now empty TopicList */
					RemoveNode(lpQueryTree, (LPV) lpCurQtNode, NULL,
						(LPSLINK) lpCurTopicList, TOPICLIST_NODE);
				}
			}

			/* Assure that all nodes are transferred */
			RET_ASSERT (QTN_TOPICLIST(lpCurQtNode) == NULL) ;
			break;
	}
	return S_OK;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	PUBLIC HRESULT PASCAL NEAR | AndHandler |
 *		Handle Anding the strings
 *
 *	@parm	_LPQTNODE | lpResQtNode |
 *		The query structure that we add the result to
 *
 *	@parm	LPITOPIC | lpResTopicList |
 *		The TopicList structure that we add the result to
 *
 *	@parm	LPV | lpStruct |
 *		Vanilla pointers to different types of structures we are dealing with.
 *		The contents of those pointers are determined by the value of
 *		fOperationType, for EXPRESSION_TERM, this is a LPIOCC, for
 *		EXPRESSION_EXPRESSION, this is a_LPQTNODE
 *
 *	@parm int | fOperationType |
 *		Tell what kinds of nodes we are handling, query-occurence or
 *		query-query
 *
 *	@rdesc	S_OK : if the operation has been carried
 *			errors  : if some errors happened (out-of-memory)
 *************************************************************************/

PUBLIC HRESULT PASCAL NEAR AndHandler(_LPQT lpQueryTree, _LPQTNODE lpResQtNode,
	LPITOPIC lpResTopicList, LPV lpStruct, int fOperationType)
{
	_LPQTNODE lpCurQtNode;
	LPITOPIC lpTopicNode1;
	LPITOPIC lpTopicNode2;
	LPITOPIC lpNextTopic1;
	LPITOPIC lpNextTopic2;
    LPITOPIC lpPrev;
	long fResult;

	switch (fOperationType) {
		case EXPRESSION_TERM:
			RET_ASSERT (lpResTopicList);

			((LPIOCC)lpStruct)->fFlag |= TO_BE_KEPT;
			lpResTopicList->fFlag |= TO_BE_KEPT;

			/* Adding the new occurence to the TopicID list */
			return OccNodeInsert(lpQueryTree, lpResTopicList, (LPIOCC)lpStruct);

		case EXPRESSION_EXPRESSION:

			/* Doing an AND combination is equivalent to merging the
			 * two lists together for same doc ID 
			 */

			lpCurQtNode = (_LPQTNODE)lpStruct;
			if (HandleNullNode(lpQueryTree, lpResQtNode, lpCurQtNode, AND_OP))
				return S_OK;

			/* Initialize variables */
			lpTopicNode1 = QTN_TOPICLIST(lpResQtNode);
			lpTopicNode2 = QTN_TOPICLIST(lpCurQtNode);

            lpPrev = NULL;
			while (lpTopicNode1 && lpTopicNode2)
            {

				/* Get the next nodes */
				lpNextTopic1 = lpTopicNode1->pNext;
				lpNextTopic2 = lpTopicNode2->pNext;

				if ((fResult = lpTopicNode1->dwTopicId -
					lpTopicNode2->dwTopicId) == 0)
                {

					/* The TopicIds match */

					/* Merge the occurrences together */
					MergeOccurence (lpQueryTree, lpTopicNode1, lpTopicNode2);
                    lpPrev = lpTopicNode1;
					lpTopicNode1 = lpNextTopic1;
					lpTopicNode2 = lpNextTopic2;
				}
				else if (fResult < 0)
                {
					/* List 1 < List 2 */
					/* Remove Topic node 1*/
					TopicNodeFree(lpQueryTree, lpResQtNode, lpPrev, lpTopicNode1);
					lpTopicNode1 = lpNextTopic1;

				}
				else
                {
					/* List 1 > List 2 */
					lpTopicNode2 = lpNextTopic2;
				}
			}

			/* Free remaining doc list */
			while (lpTopicNode1)
            {
				/* Get the next nodes */
				lpNextTopic1 = lpTopicNode1->pNext;

				/* Remove Topic node 1*/
				TopicNodeFree(lpQueryTree, lpResQtNode, lpPrev, lpTopicNode1);
 				lpTopicNode1 = lpNextTopic1;
			}


			/* Free doc 2 list */
			RemoveQuery(lpQueryTree, lpCurQtNode);
			if (QTN_TOPICLIST(lpResQtNode) == NULL)
				QTN_NODETYPE(lpResQtNode) = NULL_NODE;
			return S_OK;

		default: /* Weird parameters */
			RET_ASSERT(UNREACHED);
	}
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	PUBLIC HRESULT PASCAL NEAR | NotHandler |
 *		Handle NOT the strings
 *
 *	@parm	_LPQTNODE | lpResQtNode |
 *		The query structure that we add the result to
 *
 *	@parm	LPITOPIC | lpResTopicList |
 *		The TopicList structure that we add the result to
 *
 *	@parm	LPV | lpStruct |
 *		Vanilla pointers to different types of structures we are dealing with.
 *		The contents of those pointers are determined by the value of
 *		fOperationType, for EXPRESSION_TERM, this is a LPIOCC, for
 *		EXPRESSION_EXPRESSION, this is a_LPQTNODE
 *
 *	@parm int | fOperationType  |
 *		Tell what kinds of nodes we are handling, query-occurence or
 *		query-query
 *
 *	@rdesc	S_OK : if the operation has been carried
 *			errors  : if some errors happened (out-of-memory)
 *************************************************************************/

PUBLIC HRESULT PASCAL NEAR NotHandler(_LPQT lpQueryTree, _LPQTNODE lpResQtNode,
	LPITOPIC lpResTopicList, LPV lpStruct, int fOperationType)
{
	_LPQTNODE	lpCurQtNode;
	LPITOPIC lpTopicNode1;
	LPITOPIC lpTopicNode2;
	LPITOPIC lpNextTopic1;
	LPITOPIC lpNextTopic2;
    LPITOPIC lpPrev;

	long fResult;

	switch (fOperationType) {
		case EXPRESSION_TERM:
			RET_ASSERT(UNREACHED);
			break;

		case EXPRESSION_EXPRESSION:
			lpCurQtNode = (_LPQTNODE)lpStruct;
			if (HandleNullNode(lpQueryTree, lpResQtNode,
				lpCurQtNode, NOT_OP))
				return S_OK;

			/* Initialize variables */
			lpTopicNode1 = QTN_TOPICLIST(lpResQtNode);
			lpTopicNode2 = QTN_TOPICLIST(lpCurQtNode);

            lpPrev = NULL;
			while (lpTopicNode1 && lpTopicNode2) {

				/* Get the next nodes */
				lpNextTopic1 = lpTopicNode1->pNext;
				lpNextTopic2 = lpTopicNode2->pNext;

				if ((fResult = lpTopicNode1->dwTopicId -
					lpTopicNode2->dwTopicId) == 0) {

					/* The TopicIds match */
					TopicNodeFree(lpQueryTree, lpResQtNode, lpPrev, lpTopicNode1);
					lpTopicNode1 = lpNextTopic1;
					lpTopicNode2 = lpNextTopic2;

				}
				else if (fResult < 0) {

					/* List 1 < List 2 */
                    lpPrev = lpTopicNode1;
					lpTopicNode1 = lpNextTopic1;
				}
				else {

					/* List 1 > List 2 */
					lpTopicNode2 = lpNextTopic2;
				}
			}

			/* Free doc 2 list */
			RemoveQuery(lpQueryTree, lpCurQtNode);

			if (QTN_TOPICLIST(lpResQtNode) == NULL)
				QTN_NODETYPE(lpResQtNode) = NULL_NODE;
			return S_OK;

		default: /* Weird parameters */
			RET_ASSERT(UNREACHED);
	}
	return S_OK;
}

/*************************************************************************
 *	NEARHANDLER Description
 *
 *	Sematics:
 *		The current chosen sematics is:
 *			A near B near C   --> (A near B) and (B near C)
 *		Other possible sematics of NEAR for (A near B near C) are:
 *			- A and B anc C must be near each other
 *			- Any two of A or B or C can be near each other
 *
 *	Observation:
 *		With the above semantics, we notice that only the last word (ie. B)
 *		has meaning in the comparison with C.
 *
 *	Implementation:
 *		A special node will be used to differentiate between occurrences
 *		coming from A and from B. Only the ones from B will be used in the
 *		combination with C. Consider the following example (ProxDist = 5):
 *			A		B		C
 *			10		15		5	(the numbers are word counts)
 *			14		18		16
 *		After combining A and B we will end up with:
 *			15
 *			18
 *			M <- marker separates occurrences from A and B
 *			10
 *			14
 *		After that we only combine B's terms with C's terms. The result will
 *		look like:
 *			16
 *			M <- marker separates occurrences from B and C
 *			15
 *			18
 *			M <- marker separates occurrences from A and B
 *			10
 *			14
 *		Note that C's 5 is dropped since there is no match with B, even
 *		that A's 10 matches it.
 *		After sorting and getting rid of the marker nodes, the final result
 *		will look as followed:
 *			10  14  15  16  18
 *************************************************************************/

PRIVATE HRESULT PASCAL NEAR NearHandlerInsert (_LPQT lpQueryTree,
	LPITOPIC lpResTopicList, LPIOCC lpStartOcc, LPIOCC lpCurOcc)
{
	HRESULT	fRet = FALSE;

	if (!(lpCurOcc->fFlag & IS_MARKER_NODE) &&
		(fRet = NearListMatch(lpCurOcc, lpStartOcc, lpQueryTree->wProxDist))) {
		/* Insert the occurrence node */
		lpCurOcc->pNext = lpResTopicList->lpOccur;
		lpResTopicList->lpOccur = lpCurOcc;
		lpResTopicList->lcOccur ++;
	}
	else {
		/* Remove the occurrence node */
		RemoveNode(lpQueryTree, (LPV) NULL, (LPSLINK)NULL,
			(LPSLINK) lpCurOcc, OCCURENCE_NODE);
	}
	return (fRet);
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	LPIOCC PASCAL NEAR | FindMarker |
 *		Given a starting occurrence node, traverse it and find the first
 *		marker node
 *
 *	@parm	LPIOCC | lpStartOcc |
 *		Starting node
 *
 *	@rdesc	The marker node
 *************************************************************************/
PRIVATE LPIOCC PASCAL NEAR FindMarker (LPIOCC lpStartOcc)
{
	LPIOCC	lpCurOcc;

	for (lpCurOcc = lpStartOcc; lpCurOcc; lpCurOcc = lpCurOcc->pNext) {
		if (lpCurOcc->fFlag & IS_MARKER_NODE)
			break;
	}
	return lpCurOcc;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	HRESULT PASCAL NEAR | InsertMarker |
 *		This function will insert a marker node at the beginning of
 *		lpResTopicList->lpOccur
 *
 *	@parm	LPQT | lpQueryTree |
 *		Pointer to query tree where all globals are
 *
 *	@parm	LPITOPIC | lpResTopicList |
 *		Pointer to TopicId node
 *
 *  @rdesc  S_OK
 *************************************************************************/
PRIVATE HRESULT PASCAL NEAR InsertMarker (LPQT lpQueryTree, LPITOPIC lpResTopicList)
{
	LPMARKER	lpMark;

	/* Do some preparations by allocating marker nodes */
	if ((lpResTopicList->fFlag & HAS_MARKER) == FALSE) {
		if (!(lpMark = (LPMARKER)OccNodeAllocate(lpQueryTree)))
			return E_TOOMANYTOPICS;
		lpMark->fFlag |= (IS_MARKER_NODE | TO_BE_KEPT);

		/* Link the markers together with the nodes */
		lpMark->pNext = lpResTopicList->lpOccur;
		lpResTopicList->lpOccur = (LPIOCC)lpMark;

		/* Link with the next marker */
		lpMark->pNextMark = (LPMARKER)FindMarker (lpMark->pNext);

		/* Mark that we already has a marker */
		lpResTopicList->fFlag |= HAS_MARKER;

		/* Increment lcOccur, since this node will be removed
		 * like a regular occurrence node */
		lpResTopicList->lcOccur ++;
	}
	return S_OK;
}

/*************************************************************************
 *	@doc	INTERNAL
 *	
 *	@func	HRESULT PASCAL NEAR | NearListMatch |
 *		Traverse a list and match all nodes against lpCurOcc
 *
 *	@parm	LPIOCC | lpCurOcc |
 *		Occurrence node to be compared with
 *
 *	@parm	LPIOCC | lpStartOcc |
 *		Start of the occurrence list
 *
 *	@parm	WORD | wProxDist |
 *		Proximity distance
 *
 *	@rdesc
 *		return TRUE if the the node matches
 *************************************************************************/
PRIVATE HRESULT PASCAL NEAR NearListMatch (LPIOCC lpCurOcc,
	LPIOCC lpStartOcc, WORD wProxDist)
{
	LPIOCC	lpResOcc;
	BOOL	fMatch = FALSE;

	for (lpResOcc = lpStartOcc; lpResOcc; lpResOcc = lpResOcc->pNext) {
		if (lpResOcc->fFlag & IS_MARKER_NODE)
			break;
		if (!FRange(lpResOcc->dwCount, lpCurOcc->dwCount,
			wProxDist)) {
			lpResOcc->fFlag |= TO_BE_KEPT;
			fMatch = TRUE;
		}
	}
	if (fMatch)
		lpCurOcc->fFlag |= TO_BE_KEPT;
	return fMatch;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	VOID PASCAL FAR | NearHandlerTopicCleanUp |
 *		Clean up a TopicList by going thru each sequence of occurrence 
 *		delimited by marker, do the check again and remove all extra
 *		occurrences
 *
 *	@parm	_LPQT | lpQueryTree |
 *		Pointer to query tree
 *
 *	@parm	_LPQTNODE | lpResQtNode |
 *		Pointer to result query node
 *
 *	@parm	LPITOPIC | lpCurTopic |
 *		Current doc id
 *************************************************************************/
PUBLIC HRESULT PASCAL FAR NearHandlerTopicCleanUp (_LPQT lpQueryTree,
	_LPQTNODE lpResQtNode, LPITOPIC lpCurTopic)
{
	LPMARKER	lpMarkStart;
	LPMARKER	lpCurMark;
	LPIOCC		lpCurOcc;
	LPIOCC		lpStartOcc;
	BOOL		fDone;

	/* Find the first marker */
	lpMarkStart = (LPMARKER)FindMarker(lpCurTopic->lpOccur);

	if (lpMarkStart == NULL) {
		/* This branch has been cleaned up of marker nodes */
		return E_FAIL;
	}

	/* The first occurrences from the start to lpMarkStart must be 
	 * TO_BE_KEPT, so we don't have to check them since they just
	 * freshly came from a near handler. All we have to do
	 * is set the flag */

	for (lpCurOcc = lpCurTopic->lpOccur; lpCurOcc && !(lpCurOcc->fFlag &
		IS_MARKER_NODE); lpCurOcc = lpCurOcc->pNext)
		lpCurOcc->fFlag |= TO_BE_KEPT;

	if (lpMarkStart->pNextMark == NULL) {
		/* Simple A NEAR B, just set the flag */
		for (lpCurOcc = lpMarkStart->pNext; lpCurOcc && !(lpCurOcc->fFlag &
			IS_MARKER_NODE); lpCurOcc = lpCurOcc->pNext)
			lpCurOcc->fFlag |= TO_BE_KEPT;
	}
	else {

		/* Complex NEAR terms, such as: A NEAR B NEAR C */

		lpStartOcc = lpMarkStart->pNext;
		lpCurMark = lpMarkStart->pNextMark;

		fDone = FALSE;
		for (;lpCurMark; lpCurMark = lpCurMark->pNextMark)
		{
			for (lpCurOcc = lpCurMark->pNext;
				lpCurOcc && !(lpCurOcc->fFlag & IS_MARKER_NODE);
				lpCurOcc = lpCurOcc->pNext) {

				if (NearListMatch (lpCurOcc, lpStartOcc,
					lpQueryTree->wProxDist) == FALSE)
				{
					fDone = TRUE;
				}
			}
			lpStartOcc = lpCurMark->pNext;
			if (fDone)
				break;
		}
	}

	/* Clear up all the marker node flag to ensure that they will be
 	 * removed */

	 while (lpMarkStart) {
		lpMarkStart->fFlag &= ~(TO_BE_KEPT | IS_MARKER_NODE);
		lpMarkStart = lpMarkStart->pNextMark;
	 }
	 return S_OK;
}

PUBLIC VOID PASCAL NEAR NearHandlerCleanUp (_LPQT lpQueryTree,
	_LPQTNODE lpResQtNode)
{
	LPITOPIC		lpCurTopic;

	for (lpCurTopic = QTN_TOPICLIST(lpResQtNode); lpCurTopic;
		lpCurTopic = lpCurTopic->pNext) {

		if (NearHandlerTopicCleanUp (lpQueryTree, lpResQtNode,
			lpCurTopic) == S_OK) {
			RemoveUnmarkedOccList(lpQueryTree, lpCurTopic,
				lpCurTopic->lpOccur, TRUE);
		}
	}
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	PUBLIC HRESULT PASCAL NEAR | NearHandler |
 *		Handle NEAR operation
 *
 *	@parm	_LPQTNODE | lpResQtNode |
 *		The query structure that we add the result to
 *
 *	@parm	LPITOPIC | lpResTopicList |
 *		The TopicList structure that we add the result to
 *
 *	@parm	LPV | lpStruct |
 *		Vanilla pointers to different types of structures we are dealing with.
 *		The contents of those pointers are determined by the value of
 *		fOperationType, for EXPRESSION_TERM, this is a LPIOCC, for
 *		EXPRESSION_EXPRESSION, this is a_LPQTNODE
 
 *	@parm int | fOperationType |
 *		Tell what kinds of nodes we are handling, query-occurence or
 *		query-query
 *
 *	@rdesc	S_OK : if the operation has been carried
 *			errors  : if some errors happened (out-of-memory)
 *************************************************************************/
PUBLIC HRESULT PASCAL NEAR NearHandler(_LPQT lpQueryTree, _LPQTNODE lpResQtNode,
	LPITOPIC lpResTopicList, LPV lpStruct, int fOperationType)
{
	_LPQTNODE	lpCurQtNode;	/* Current query tree node */
	LPITOPIC		lpCurTopicList;	/* Current TopicId node */
	LPITOPIC		lpNextTopicList;
	LPIOCC		lpCurOcc;
	LPIOCC		lpStartOcc;

    LPITOPIC    lpPrevRes;
    LPSLINK     lpTmp;      //erinfox


	switch (fOperationType) {
		case EXPRESSION_TERM:
			/* Insert a marker node if necessary */
			if (InsertMarker (lpQueryTree, lpResTopicList) != S_OK)
				return E_TOOMANYTOPICS;

			/* Look for the starting point */
			lpStartOcc = FindMarker(lpResTopicList->lpOccur);

			RET_ASSERT(lpStartOcc);

			/* Handle the near operation */
			if (NearHandlerInsert (lpQueryTree, lpResTopicList, lpStartOcc->pNext,
				(LPIOCC)lpStruct))
				lpResTopicList->fFlag |= TO_BE_KEPT;
			break;

		case EXPRESSION_EXPRESSION:
			lpCurQtNode = (_LPQTNODE)lpStruct;
			if (HandleNullNode(lpQueryTree, lpResQtNode,
				lpCurQtNode, NEAR_OP))
				return S_OK;

			/* Now doing the real jobs */

			/* Make sure that we are pointing to the right place to search
			*/
			lpQueryTree->lpTopicStartSearch = lpResQtNode->lpTopicList;

			/* First check the coming data from lpCurTopicList.
			 * If there isn't an equivalent TopicId in QTN_TOPICLIST(lpResQtNode),
			 * then remove it
			 */
			for (lpCurTopicList = QTN_TOPICLIST(lpCurQtNode); lpCurTopicList;
				lpCurTopicList = lpNextTopicList) {

				lpNextTopicList = lpCurTopicList->pNext;

				/* Find the location of the TopicID List in the query. */
				if ((lpResTopicList = TopicNodeSearch(lpQueryTree,
					lpResQtNode, lpCurTopicList->dwTopicId)) == NULL) {

					/* Can't find equivalent TopicId in the result list, just
					remove lpCurTopicList
					*/
					TopicNodeFree(lpQueryTree, lpCurQtNode, NULL, lpCurTopicList);
					continue;
				}

				/* An equivalent TopicId is found */
				/* Insert a marker node if necessary */
				if (InsertMarker (lpQueryTree, lpResTopicList) != S_OK)
					return E_TOOMANYTOPICS;

				/* Look for the starting point */
				RET_ASSERT(lpResTopicList->lpOccur)

				lpStartOcc = FindMarker(lpResTopicList->lpOccur);
				lpStartOcc = lpStartOcc->pNext; // Skip marker node

				for (lpCurOcc = lpCurTopicList->lpOccur; lpCurOcc;
					lpCurOcc = lpCurTopicList->lpOccur) {

					/* "Unlink" lpCurOcc */
					lpCurTopicList->lpOccur = lpCurOcc->pNext;

					/* Handle the near operation */
					if (NearHandlerInsert (lpQueryTree, lpResTopicList,
						lpStartOcc, lpCurOcc)) {
						lpResTopicList->fFlag |= TO_BE_KEPT;
					}
				}

				RET_ASSERT(lpCurTopicList->lpOccur == NULL);
				RemoveNode(lpQueryTree, (LPV) lpCurQtNode, NULL,
					(LPSLINK) lpCurTopicList, TOPICLIST_NODE);

				if (lpResTopicList->lpOccur->fFlag & IS_MARKER_NODE) {
					/* We didn't find any match, remove this TopicList */
                    
                    // erinfox - I don't know lpPrevRes for lpResTopicList, so I get it here
	                for (lpPrevRes = NULL, lpTmp = (LPSLINK)lpResQtNode->lpTopicList; lpTmp;
		                lpTmp = lpTmp->pNext) 
                    {
		                if (lpTmp == (LPSLINK)lpResTopicList)
			                break;
		                lpPrevRes = (LPITOPIC) lpTmp;
                    }

					TopicNodeFree(lpQueryTree, lpResQtNode, lpPrevRes, lpResTopicList);
				}
				else {
					/* Remove all unmarked occurrences, but don't
					 * reset the TO_BE_KEPT flag */
					RemoveUnmarkedOccList(lpQueryTree, lpResTopicList,
						lpResTopicList->lpOccur, FALSE);
				}
			}
			RemoveQuery(lpQueryTree, lpCurQtNode);

			if (QTN_TOPICLIST(lpResQtNode) == NULL)
				QTN_NODETYPE(lpResQtNode) = NULL_NODE;
			return S_OK;
			break;
	}
	return S_OK;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	PUBLIC HRESULT PASCAL NEAR | PhraseHandler |
 *		Handle PHRASE operation
 *
 *	@parm	_LPQTNODE | lpResQtNode |
 *		The query structure that we add the result to
 *
 *	@parm	LPITOPIC | lpResTopicList |
 *		The TopicList structure that we add the result to
 *
 *	@parm	LPV | lpStruct |
 *		Vanilla pointers to different types of structures we are dealing with.
 *		The contents of those pointers are determined by the value of
 *		fOperationType, for EXPRESSION_TERM, this is a LPIOCC, for
 *		EXPRESSION_EXPRESSION, this is a_LPQTNODE
 *
 *	@parm int | fOperationType |
 *		Tell what kinds of nodes we are handling, query-occurence or
 *		query-query
 *
 *	@rdesc	S_OK : if the operation has been carried
 *			errors  : if some errors happened (out-of-memory)
 *************************************************************************/
PUBLIC HRESULT PASCAL NEAR PhraseHandler(_LPQT lpQueryTree, _LPQTNODE lpResQtNode,
	LPITOPIC lpResTopicList, LPIOCC lpCurOcc, int fOperationType)
{
	LPIOCC	lpResOcc;
	BOOL		fResult = 0;
	LPIOCC	lpStartOcc = NULL;

	RET_ASSERT(fOperationType == EXPRESSION_TERM);

	/* Start at the beginning if necessary */
	if ((lpResOcc = lpQueryTree->lpOccStartSearch) == NULL)
		lpResOcc = lpResTopicList->lpOccur;

	for (; lpResOcc; lpResOcc = lpResOcc->pNext) {
		if ((lpResOcc->fFlag & TO_BE_SKIPPED) == 0) {

			if ((fResult = (int)(lpCurOcc->dwCount - lpResOcc->dwCount))
				== 1) {

				/* The nodes are consecutive, mark them TO_BE_KEPT */

				 lpResOcc->fFlag |= TO_BE_KEPT | TO_BE_SKIPPED;
				 lpResOcc->fFlag &= ~TO_BE_COMPARED;

				 lpCurOcc->fFlag |= TO_BE_KEPT | TO_BE_SKIPPED |
					 TO_BE_COMPARED;
				 lpResTopicList->fFlag |= TO_BE_KEPT;
				 break;
			}

			/* Reset lpStartOcc */
			lpStartOcc = NULL;

			if (fResult <= 0) {
			/* CurOcc is less than what is in the result list */
				break;
			}
		}
		else {
			/* Get a skipped node. Mark the assumed starting node */
			if (lpStartOcc == NULL) {
				lpStartOcc = lpResOcc;
			}
		}
	}

	if (fResult == 1) {
		/* Add this node, and mark the starting point for next search */
		lpQueryTree->lpOccStartSearch = lpCurOcc->pNext = lpResOcc->pNext;
		lpResOcc->pNext = lpCurOcc;
		lpResTopicList->lcOccur ++;

		/* Mark all previous nodes TO_BE_KEPT */
		if (lpStartOcc) {
			for (; lpStartOcc != lpCurOcc; lpStartOcc = lpStartOcc->pNext)
				lpStartOcc->fFlag |= TO_BE_KEPT;
		}
	}
	else {
		RemoveNode(lpQueryTree, (LPV) NULL, (LPSLINK)NULL,
			(LPSLINK) lpCurOcc, OCCURENCE_NODE);
	}

	return S_OK;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	VOID PASCAL NEAR | MergeOccurence |
 *		Merge two occurences lists together
 *
 *	@parm	_LPQT | lpQueryTree |
 *		Pointer to query tree (where global variables are)
 *
 *	@parm	LPITOPIC | lpResTopicList |
 *		Resulting TopicList that has the merged occurence list
 *
 *	@parm	LPITOPIC | lpCurTopicList |
 *		TopicList that has the occurrence list to be merged to the
 *		resulting list
 *************************************************************************/
PUBLIC VOID PASCAL NEAR MergeOccurence(_LPQT lpQueryTree,
	LPITOPIC lpResTopicList, LPITOPIC lpCurTopicList)
{
	register LPIOCC lpTmpOcc;
	register LPIOCC lpNextOcc;

	/* Reset lpOccStartSearch */
	lpQueryTree->lpOccStartSearch = NULL;

	for (lpTmpOcc = lpCurTopicList->lpOccur; lpTmpOcc; lpTmpOcc = lpNextOcc){
		lpNextOcc = lpTmpOcc->pNext;
		OccNodeInsert(lpQueryTree, lpResTopicList, lpTmpOcc);
	}
	lpCurTopicList->lpOccur = NULL;
	lpCurTopicList->lcOccur = 0;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	VOID PASCAL NEAR | RemoveUnmarkedTopicList |
 *		Remove all the TopicLists that are not marked TO_BE_KEPT
 *
 *	@parm	_LPQT | lpQueryTree |
 *		Pointer to query tree (for globasl variables)
 *
 *	@parm	_LPQTNODE | lpQtNode |
 *		Query tree node to be checked
 *
 *	@parm	HRESULT | fKeepOccurence |
 *		If 0, then check and remove all occurrences nodes that are not
 *		marked TO_BE_KEPT
 *************************************************************************/

PUBLIC VOID PASCAL NEAR RemoveUnmarkedTopicList (_LPQT lpQueryTree,
	_LPQTNODE lpQtNode, BOOL fKeepOccurence)
{
	register LPITOPIC lpTopicList;
	register LPITOPIC lpNextTopicList;

    // erinfox: add to keep track of previous node
    register LPITOPIC lpPrev;

	/* Traverse the doclist */
	for (lpPrev = NULL, lpTopicList = QTN_TOPICLIST(lpQtNode); lpTopicList;
		lpTopicList = lpNextTopicList) {

		lpNextTopicList = lpTopicList->pNext;
		if ((lpTopicList->fFlag & TO_BE_KEPT) == 0) {
			/* Free the doc node and its occurences list */
			TopicNodeFree(lpQueryTree, lpQtNode, lpPrev, lpTopicList);
		}
		else {
			lpTopicList->fFlag &= ~(TO_BE_KEPT | HAS_MARKER);	// Reset the flag

			if (!fKeepOccurence) {
				/* Check the occurences list, and free all nodes that
				 * are not marked TO_BE_KEPT
				 */
				RemoveUnmarkedOccList(lpQueryTree, lpTopicList,
					lpTopicList->lpOccur, TRUE);
				if (lpTopicList->lpOccur == NULL) {
					RemoveNode(lpQueryTree, (LPV) lpQtNode, NULL,
						(LPSLINK) lpTopicList, TOPICLIST_NODE);
				}
			}
            lpPrev = lpTopicList;

		}
	}
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	VOID PASCAL NEAR | RemoveUnmarkedNearTopicList |
 *		Remove all the TopicLists that are not marked TO_BE_KEPT
 *
 *	@parm	_LPQT | lpQueryTree |
 *		Pointer to query tree (for globasl variables)
 *
 *	@parm	_LPQTNODE | lpQtNode |
 *		Query tree node to be checked
 *
 *	@parm	BOOL | fKeepOccurence |
 *		If 0, then check and remove all occurrences nodes that are not
 *		marked TO_BE_KEPT
 *************************************************************************/

PUBLIC VOID PASCAL NEAR RemoveUnmarkedNearTopicList (_LPQT lpQueryTree,
	_LPQTNODE lpQtNode)
{
	register LPITOPIC lpTopicList;
	register LPITOPIC lpNextTopicList;
	LPIOCC lpMark;

    // erinfox - add to keep track of previous node
    register LPITOPIC lpPrev;

	/* Traverse the doclist */
	for (lpPrev = NULL, lpTopicList = QTN_TOPICLIST(lpQtNode); lpTopicList;
		lpTopicList = lpNextTopicList) {

		lpNextTopicList = lpTopicList->pNext;
		if ((lpTopicList->fFlag & TO_BE_KEPT) == 0) {
			/* Free the doc node and its occurences list */
			TopicNodeFree(lpQueryTree, lpQtNode, lpPrev, lpTopicList);
		}
		else {
			// Reset the flag
			lpTopicList->fFlag &= ~(TO_BE_KEPT | HAS_MARKER);

			/* Find the marker */
			lpMark = FindMarker(lpTopicList->lpOccur);
			RemoveUnmarkedOccList(lpQueryTree, lpTopicList,
				lpTopicList->lpOccur, TRUE);

			/* Remove all unmarked occurrences between this marker and
			 * the next one */
			if (lpMark)
				RemoveUnmarkedOccList(lpQueryTree, lpTopicList,
				lpMark->pNext, TRUE);
            lpPrev = lpTopicList;
		}

	}
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	PASCAL NEAR | MarkTopicList |
 *		Mark all TopicId nodes in a doc list TO_BE_KEPT
 *
 *	@parm	_LPQTNODE | lpQtNode |
 *		Pointer to the query tree node that contains the doc list
 *************************************************************************/
PUBLIC VOID PASCAL NEAR MarkTopicList (_LPQTNODE lpQtNode)
{
	register LPITOPIC lpTopicList;

	for (lpTopicList = QTN_TOPICLIST(lpQtNode); lpTopicList;
		lpTopicList = lpTopicList->pNext) {
		lpTopicList->fFlag |= TO_BE_KEPT;
	}
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	VOID PASCAL NEAR | RemoveUnmarkedOccList |
 *		Remove all the occurrence nodes that are not marked TO_BE_KEPT
 *
 *	@parm	LPQT | lpQueryTree |
 *		Pointer to query tree (for global variables)
 *
 *	@parm	int | fResetFlag |
 *		Do we reset the TO_BE_KEPT flag ?
 *
 *	@parm	LPIOCC | lpTopicList |
 *		Pointer to Topic list to be checked
 *
 *	@parm	LPIOCC | lpOccList |
 *		Pointer to occurrence list to be checked
 *************************************************************************/
PRIVATE VOID PASCAL NEAR RemoveUnmarkedOccList (LPQT lpQueryTree,
	LPITOPIC lpTopicList, LPIOCC lpOccList, int fResetFlag)
{
	register LPIOCC lpNextOccList;
	register LPIOCC lpPrevOccList;

	lpPrevOccList = NULL;
	for (;lpOccList && !(lpOccList->fFlag & IS_MARKER_NODE);
		lpOccList = lpNextOccList) {

		lpNextOccList = lpOccList->pNext;
		if ((lpOccList->fFlag & TO_BE_KEPT) == 0) {
			RemoveNode(lpQueryTree, (LPV) lpTopicList, (LPSLINK)lpPrevOccList,
				(LPSLINK) lpOccList, OCCURENCE_NODE);
		}
		else if (fResetFlag) {
			lpOccList->fFlag &= ~TO_BE_KEPT;	// Reset the flag
			if (lpOccList->fFlag & TO_BE_COMPARED)
				lpOccList->fFlag &= ~TO_BE_SKIPPED;
			lpPrevOccList = lpOccList;
		}
	}
	
	/* Reset the flag of the marker node */
	if (lpOccList)
		lpOccList->fFlag &= ~TO_BE_KEPT;
}


/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	VOID PASCAL NEAR | CleanMarkedOccList |
 *		Clean all the occurrence nodes from TO_BE_KEPT
 *
 *	@parm	LPIOCC | lpTopicList |
 *		Pointer to Topic list to be checked
 *************************************************************************/
VOID PASCAL FAR CleanMarkedOccList (LPITOPIC lpTopicList)
{
	register LPIOCC lpCurOcc;

	for (;lpTopicList; lpTopicList = lpTopicList->pNext)
	{
		for (lpCurOcc = lpTopicList->lpOccur; lpCurOcc;
			lpCurOcc = lpCurOcc->pNext)
		{
			lpCurOcc->fFlag &= ~TO_BE_KEPT;
		}
	}
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	HRESULT PASCAL NEAR | HandleNullNode |
 *		Handle NULL query node. This is an optimization which will
 *		save processing time.
 *
 *	@parm	LPQT | lpQueryTree |
 *		Pointer to query tree (for global variables)
 *
 *	@parm	_LPQTNODE | lpResQtNode |
 *		Pointer to result query tree node
 *
 *	@parm	_LPQTNODE | lpCurQtNode |
 *		Pointer to query tree node
 *
 *	@parm	int | Operator |
 *		What operator are we dealing with
 *
 *	@rdesc	FALSE, if no optimization can be done, TRUE otherwise
 *************************************************************************/
PRIVATE HRESULT PASCAL NEAR HandleNullNode(LPQT lpQueryTree,
	_LPQTNODE lpResQtNode, _LPQTNODE lpCurQtNode, int Operator)
{
	_LPQTNODE lpChild;

	if (QTN_NODETYPE(lpResQtNode) != NULL_NODE &&
		QTN_NODETYPE(lpCurQtNode) != NULL_NODE)
		return FALSE;

	if (Operator == NOT_OP) {
		if (QTN_NODETYPE(lpResQtNode) == NULL_NODE) {
			/* NULL ! a = NULL */
			RemoveQuery(lpQueryTree, lpCurQtNode);
			QTN_NODETYPE(lpCurQtNode) = NULL_NODE;
			return TRUE;
		}
		else if (QTN_NODETYPE(lpCurQtNode) == NULL_NODE) {
			/* a ! NULL = a */
			return TRUE;
		}
		return FALSE;
	}

	lpChild = QTN_NODETYPE(lpResQtNode) == NULL_NODE ?
		lpCurQtNode : lpResQtNode;

	switch (Operator) {
		case AND_OP: // a & NULL = NULL
		case NEAR_OP: // a # NULL = NULL
		case PHRASE_OP:	// a + NULL = NULL ??
			RemoveQuery(lpQueryTree, lpChild);
			QTN_NODETYPE(lpChild) = NULL_NODE;
			return TRUE;

		case OR_OP: // a | NULL = a
			if (QTN_NODETYPE(lpResQtNode) == NULL_NODE) {
				*lpResQtNode = *lpChild;
				QTN_NODETYPE(lpChild) = NULL_NODE;
				QTN_LEFT(lpChild) = QTN_RIGHT(lpChild) = NULL;
				QTN_TOPICLIST(lpChild) = NULL;
			}
			return TRUE;
	}
	return FALSE;
}

PRIVATE int PASCAL NEAR FRange(DWORD dwCount1, DWORD dwCount2, WORD cProxDist) 
{
	long fResult;
	int fRet = 1;

	fResult = dwCount1 - dwCount2;
	if (fResult < 0) {
		fRet = -1;
		fResult = -fResult;
	}
	if (fResult != 0 && fResult <= (long)cProxDist)
		return 0;
	else
		return fRet;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	VOID PASCAL NEAR | RemoveQuery |
 *		Remove all doc nodes for a query node
 *
 *	@parm	LPQT | lpQueryTree |
 *		Pointer to query tree (for global variables)
 *
 *	@parm	_LPQTNODE | lpCurQtNode |
 *		Pointer to query tree node to be cleared
 *************************************************************************/
PRIVATE VOID PASCAL NEAR RemoveQuery(LPQT lpQueryTree, _LPQTNODE lpCurQtNode)
{
	register LPITOPIC lpCurTopicList;
	register LPITOPIC lpNextTopicList;

	/* Remove all occurences of all doclist */
	if ((lpCurTopicList = QTN_TOPICLIST(lpCurQtNode)) == NULL)
		return;
	for (; lpCurTopicList; lpCurTopicList = lpNextTopicList) 
    {
		lpNextTopicList = lpCurTopicList->pNext;
		TopicNodeFree(lpQueryTree, lpCurQtNode, NULL, lpCurTopicList);
	}
	QTN_TOPICLIST(lpCurQtNode) = NULL;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	VOID PASCAL NEAR | SortResult |
 *		Sort the results according to flag
 *
 *	@parm	_LPQT | lpQueryTree |
 *		Pointer to query tree (containing globals)
 *
 *	@parm	_LPQTNODE | lpQtNode |
 *		Pointer to query node
 *
 *	@parm	WORD | fFlag |
 *		Tell how to sort the result:
 *	@flag	ORDERED_BASED |
 *		Everything is ordered TopicId, hit offsets
 *	@flag	HIT_COUNT_BASED |
 *		The doc id with most hit will be returned first
 *	@flag	WEIGHT_BASED |
 *		The topicId with most weight will be returned first
 *************************************************************************/
PUBLIC VOID PASCAL NEAR SortResult (_LPQT lpQueryTree, _LPQTNODE lpQtNode,
	WORD fFlag)
{
	register LPITOPIC	lpTopic;

	switch (fFlag) {
		case ORDERED_BASED:
			for (lpTopic = lpQtNode->lpTopicList; lpTopic; lpTopic = lpTopic->pNext)
				OccurenceSort (lpQueryTree, lpTopic);
			break;

		case HIT_COUNT_BASED:
		case WEIGHT_BASED:
			TopicListSort (lpQtNode, fFlag);
			break;
	}

#if defined(_DEBUG) && defined(SIMILARITY) && defined(_DUMPALL)
	{
		int i;

	_DPF1("Sort total: %lu\n", lpQtNode->cTopic);

	for (i = 0, lpTopic = lpQtNode->lpTopicList; lpTopic && i < 10; lpTopic = lpTopic->pNext, i++) 
	{
		_DPF2("Topic %lu (%u)\n", lpTopic->dwTopicId, lpTopic->wWeight);
	}
	}
#endif
}

PRIVATE HRESULT PASCAL NEAR TopicListInsertionSort (_LPQTNODE lpQtNode, BOOL fFlag)
{
	LPITOPIC	lpPrevTopic;
	LPITOPIC	lpCurTopic;
	LPITOPIC	lpNextTopic;
	LPITOPIC	lpTmpTopic;
	FCMP   fCompare;

	if (fFlag == HIT_COUNT_BASED)
		fCompare = HitCountCompare;
	else
		fCompare = TopicWeightCompare;
	for (lpCurTopic = lpQtNode->lpTopicList; lpCurTopic; lpCurTopic = lpNextTopic) {
		if (lpNextTopic = lpCurTopic->pNext) {
			if ((*fCompare) (lpCurTopic, lpNextTopic) < 0) {
				/* Out of order sequence */

				/* Unlink the out of order node */
				lpCurTopic->pNext = lpNextTopic->pNext;

				/* Do an insertion sort */
				for (lpPrevTopic = NULL, lpTmpTopic = lpQtNode->lpTopicList;;
					lpTmpTopic = lpTmpTopic->pNext) {

					if ((*fCompare) (lpTmpTopic, lpNextTopic) < 0) {
						/* We just pass the insertion point */
						if (lpPrevTopic == NULL) {
							lpNextTopic->pNext = lpQtNode->lpTopicList;
							lpQtNode->lpTopicList = lpNextTopic;
						}
						else {
							lpNextTopic->pNext = lpPrevTopic->pNext;
							lpPrevTopic->pNext = lpNextTopic;
						}
						break;
					}
					lpPrevTopic = lpTmpTopic;
				}

				/* Reset lpNextTopic */
				lpNextTopic = lpCurTopic;
			}
		}
	}
	return S_OK;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	VOID PASCAL NEAR | TopicListSort |
 *		Sort the results according to flag
 *
 *	@parm	_LPQT | lpQueryTree |
 *		Pointer to query tree (containing globals)
 *
 *	@parm	_LPQTNODE | lpQtNode |
 *		Pointer to query node
 *
 *	@parm	WORD | fFlag |
 *		Tell how to sort the result:
 *	@flag	HIT_COUNT_BASED |
 *		The doc id with most hit will be returned first
 *	@flag	WEIGHT_BASED |
 *		The topicId with most weight will be returned first
 *************************************************************************/
HRESULT PASCAL NEAR TopicListSort (_LPQTNODE lpQtNode, BOOL fFlag)
{
	HANDLE	hHeap;		/* Handle to heap block */
	LPITOPIC far *lrgHeap;	/* Pointer to heap block */
	TOPIC_LIST	Dummy;		/* Dummy node to speed up search, compare */
	LPITOPIC	lpCurTopic;	/* Current Topic node */
	LPITOPIC	lpNextTopic;	/* Next Topic node */
	LPITOPIC	lpInsertPt;	/* Current insertion point */
	WORD cLastItem;
	WORD MaxItem;
	LPITOPIC far * lpPQNode;
	LPITOPIC lpTopNode;
	LPITOPIC lpNextNode;
	WORD	wCurWeight;
	FCMP   fCompare;

	/* Allocate the heap */
	if (lpQtNode->cTopic > MAX_HEAP_ENTRIES)
		MaxItem = MAX_HEAP_ENTRIES;
	else
		MaxItem = (WORD)lpQtNode->cTopic + 1;

	/* If the list is short, we can use insertion sort since it is faster
	 * then preparing and use heap sort
	 */
	if (MaxItem <= 20)
		return TopicListInsertionSort (lpQtNode, fFlag);

	if ((hHeap = _GLOBALALLOC(DLLGMEM, MaxItem * sizeof(LPV))) == NULL) {

		/* We run out of memory for the heap. Try a smaller size */
		if ((hHeap = _GLOBALALLOC(DLLGMEM,
			(MaxItem = MIN_HEAP_ENTRIES)* sizeof(LPV))) == NULL) {

			/* We really run out of memory, so just do a regular
			 * insertion sort. It is slow but at least something
			 * works
			 */
			 return TopicListInsertionSort (lpQtNode, fFlag);
		}
	}

	MaxItem --;	/* Since node 0 is used for sentinel */

	lrgHeap = (LPITOPIC far *)_GLOBALLOCK (hHeap);

	/* Initialize of Dummy  */
	Dummy.wWeight = 0xffff; // Maximum weigth for sentinel
	Dummy.pNext = NULL;

	/* Set the sentinel */
	lrgHeap[0] = &Dummy;

	/* Initialize the variables */
	lpInsertPt = &Dummy;
	lpCurTopic = lpQtNode->lpTopicList;
	if (fFlag == HIT_COUNT_BASED)
		fCompare = HitCountCompare;
	else           
		fCompare = TopicWeightCompare;

	while (lpCurTopic) {

		lpPQNode = &lrgHeap[1];

		for (cLastItem = 1; lpCurTopic && cLastItem <= MaxItem;
			cLastItem++, lpPQNode++) {
			lpNextTopic = lpCurTopic->pNext;
			*lpPQNode = lpCurTopic;
			lpCurTopic->pNext = NULL;
			lpCurTopic = lpNextTopic;
			HeapUp (lrgHeap, cLastItem, fCompare);
		}

		cLastItem--;

		/* Set up the last pointer */

		for (; cLastItem > 0;) {
			lpTopNode = lrgHeap[1];

			/* Get the new node's weight */
			wCurWeight = lpTopNode->wWeight;

			/* Insert into the resulting list in decreasing order */

			if (wCurWeight > lpInsertPt->wWeight) {

				/* Start from the beginning of the list */
				lpInsertPt = &Dummy; 
			}

			while (lpNextNode = lpInsertPt->pNext) {
				if (lpNextNode->wWeight < wCurWeight)
					break;
				lpInsertPt = lpNextNode;
			}
			lpTopNode->pNext = lpInsertPt->pNext;
			lpInsertPt->pNext = lpTopNode;
			lpInsertPt = lpTopNode;

			lrgHeap[1] = lrgHeap[cLastItem--];

			HeapDown (lrgHeap, cLastItem, fCompare);
		}
	}

	/* Update the pointer to the sorted list */
	lpQtNode->lpTopicList = Dummy.pNext;

	/* Release the memory */
	_GLOBALUNLOCK(hHeap);
	_GLOBALFREE(hHeap);

	return S_OK;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	VOID PASCAL NEAR | OccurenceSort |
 *		Sort all the occurrences depending on their offsets. If two
 *		occurrences have the same offset, ie. they must be identical
 *		then one will be removed. Simple insertion sort is used since
 *		it it expected that most of the time we will have less than
 *		15 occurences per TopicId
 *
 *	@func	_LPQT | lpQueryTree |
 *		Pointer to query tree structure where all globals are
 *
 *	@func	LPITOPIC | lpTopic |
 *		Pointer to doclist with the occurrence list to be sorted
 *************************************************************************/
PRIVATE VOID PASCAL NEAR OccurenceSort (_LPQT lpQueryTree, LPITOPIC lpTopic)
{
	LPIOCC	lpPrevOcc;
	LPIOCC	lpCurOcc;
	LPIOCC	lpNextOcc;
	LPIOCC	lpTmpOcc;
	int		fResult;

	for (lpCurOcc = lpTopic->lpOccur; lpCurOcc; lpCurOcc = lpNextOcc) {
		if (lpNextOcc = lpCurOcc->pNext) {
			if ((fResult = OccCompare(lpCurOcc, lpNextOcc)) <= 0) {
				/* Out of order sequence */

				/* Unlink the out of order node */
				lpCurOcc->pNext = lpNextOcc->pNext;

				if (fResult == 0) {
					/* Duplicate data, just free the node */
					lpNextOcc->pNext = (LPIOCC)lpQueryTree->lpOccFreeList;
					lpQueryTree->lpOccFreeList = (LPSLINK)lpNextOcc;
					lpTopic->lcOccur--;

					/* Reset lpNextOcc */
					lpNextOcc = lpCurOcc;
					continue;
				}

				/* Do an insertion sort */
				for (lpPrevOcc = NULL, lpTmpOcc = lpTopic->lpOccur;;
					lpTmpOcc = lpTmpOcc->pNext) {

					if (lpTmpOcc != NULL &&
						(fResult = OccCompare(lpNextOcc, lpTmpOcc)) == 0) {
						/* Duplicate data, just free the node */
						lpNextOcc->pNext = (LPIOCC)lpQueryTree->lpOccFreeList;
						lpQueryTree->lpOccFreeList = (LPSLINK)lpNextOcc;
						lpTopic->lcOccur--;
						break;
					}

					if (lpTmpOcc == NULL || fResult > 0) {
						/* We just pass the insertion point */
						if (lpPrevOcc == NULL) {
							lpNextOcc->pNext = lpTopic->lpOccur;
							lpTopic->lpOccur = lpNextOcc;
						}
						else {
							lpNextOcc->pNext = lpPrevOcc->pNext;
							lpPrevOcc->pNext = lpNextOcc;
						}
						break;
					}
					lpPrevOcc = lpTmpOcc;
				}

				/* Reset lpNextOcc */
				lpNextOcc = lpCurOcc;
			}
		}
	}
}

PRIVATE int PASCAL NEAR TopicWeightCompare (LPITOPIC lpTopic1, LPITOPIC lpTopic2)
{
	if (lpTopic1->wWeight > lpTopic2->wWeight)
    {
		return 1;
    }
    else if (lpTopic1->wWeight < lpTopic2->wWeight)
    {
        return -1;
    }
    else   // must be equal
    {
        if (lpTopic1->lcOccur >= lpTopic2->lcOccur)
            return 1;

        return -1;
    }
}

PRIVATE int PASCAL NEAR HitCountCompare (LPITOPIC lpTopic1, LPITOPIC lpTopic2)
{
	if (lpTopic1->lcOccur >= lpTopic2->lcOccur)
		return 1;
	return -1;
}

PRIVATE VOID PASCAL NEAR HeapUp (LPITOPIC far * lrgHeap, WORD ChildIndex,
	FCMP fCompare)
{
	WORD	ParentIndex;
	LPITOPIC far *	lplpvParent;
	LPITOPIC far *	lplpvChild;
	LPITOPIC 	lpSaved;
	LPITOPIC 	lpvParent;


	lplpvChild = &lrgHeap [ChildIndex];
	ParentIndex = ChildIndex/2;
	lpSaved = *lplpvChild;

	while (ParentIndex) {
		lplpvParent = &lrgHeap[ParentIndex];
		lpvParent = *lplpvParent;
		if ((*fCompare)((LPV)lpvParent, (LPV)lpSaved) > 0)
			break;
		*lplpvChild = lpvParent;
		lplpvChild = lplpvParent;
		ParentIndex /= 2;
	}; 
	*lplpvChild = lpSaved;
}

PRIVATE VOID PASCAL NEAR HeapDown (LPITOPIC far * lrgHeap, int MaxChildIndex,
	FCMP fCompare)
{
	int ChildIndex;
	LPITOPIC far * lplpvParent;
	LPITOPIC far * lplpvChild;
	LPITOPIC lpTopicChild;
	LPITOPIC lpTopicChild2;
	LPITOPIC lpSaved;

	lpSaved = *(lplpvParent = &lrgHeap[1]);
	ChildIndex = 2;

	for (; ChildIndex <= MaxChildIndex; ) {

		lplpvChild = &lrgHeap[ChildIndex];
		lpTopicChild = *lplpvChild;

		/* Find the minimum of the two children */
		if (ChildIndex < MaxChildIndex &&
			(lpTopicChild2 = *(lplpvChild + 1))) {
			if ((*fCompare)((LPV)lpTopicChild, (LPV)lpTopicChild2) < 0) {
				lplpvChild++;
				ChildIndex ++;
			}
		}

		if ((*fCompare)((LPV)lpSaved, (LPV)*lplpvChild) > 0)
			break;

		/* Replace the node */
		*lplpvParent = *lplpvChild;
		lplpvParent = lplpvChild;
		ChildIndex *= 2;
	}
	*lplpvParent = lpSaved;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\common\ftsmain.c ===
//	-	-	-	-	-	-	-	-	-

//	LIBMAIN.C
//
//	This file contains the default forms of the DLL library initialization
//	and cleanup functions.

//	-	-	-	-	-	-	-	-	-

#include <mvopsys.h>
#include <mvsearch.h>


#ifndef _NT
PRIVATE HANDLE NEAR s_hModule;

//	-	-	-	-	-	-	-	-	-

PUBLIC	BOOL FAR PASCAL LibMain(
	HANDLE	hModule,
	CB	cbHeapSize,
	LSZ	lszCmdLine)
{
	s_hModule = hModule;
	return TRUE;
}

#else

PUBLIC	BOOL FAR PASCAL LibMain( HANDLE	hModule, BOOL bAttaching)
{
	return TRUE;
}
#endif

#ifdef _NT

BOOL  WINAPI DllMain( hinstDll, fdwReason, lpvReserved )
	HINSTANCE   hinstDll;		/* Handle for our convenience */
	DWORD       fdwReason;		/* Why we are called */
	LPVOID      lpvReserved;	/* Additional details of why we are here */
{

    switch( fdwReason )
    {
    case  DLL_PROCESS_ATTACH:
        LibMain( hinstDll, 0 );
        break;

    case  DLL_PROCESS_DETACH:
        break;
    }

    return  TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\common\common.h ===
/*************************************************************************
*                                                                        *
*  COMMON.H                                                             *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1992                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   All typedefs and defines needed for internal indexing and retrieval  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Released by Development:     (date)                                   *
*                                                                        *
*************************************************************************/

#ifndef __FTSCOMMON_H__
#define __FTSCOMMON_H__

#include <_mvutil.h>

// Critical structures that gets messed up in /Zp8
#pragma pack(1)


/*************************************************************************
 *                          Basic defines.
 *************************************************************************/

#if defined( __cplusplus )
extern "C" {
#endif

/*
 *	Various files stamps.
 *	This is to distinguish one file's type from another
 */
#define		INDEX_STAMP			0x0000
#define		CATALOG_STAMP		0x1111
#define		STOP_STAMP			0x2222
//#define		GROUP_STAMP			0x3333
#define		WHEEL_STAMP			0x4444
#define		CHRTAB_STAMP		0x5555
#define		OPTAB_STAMP			0x6666

/*
 *	Various subfiles' default names
 */
#define     SZ_DEFAULT_INDEXNAME    "|MVINDEX"
#define     SZ_DEFAULT_CATNAME      "|CATALOG"
#define     SZ_DEFAULT_STOPNAME	    "|MVSTOP"
#define     SZ_DEFAULT_GROUPNAME    "|MVGROUP"
#define     SZ_DEFAULT_CHARTABNAME  "|MVCHARTAB"
#define     SZ_DEFAULT_WWBTREE_NAME "|MVWWHEEL.WWT"
#define     SZ_DEFAULT_WWMAP_NAME   "|MVWWHEEL.WWM"
#define     SZ_DEFAULT_OPTABNAME    "|MVOPTAB"

#define	cbitWORD    (CBIT)16        // Number of bits in a word.
#define	cbitBYTE    (CBIT)8         // Number of bits in a byte.

typedef	WORD	CSKP;
typedef	CSKP FAR * LPCSKP;
typedef	CSKP FAR * SPCSKP;

#define	CSKP_IGNORE	((CSKP)0)	// If the skip count is zero, don't
                                 //  decrement it, just use the current
                                 //  length until you run out of stuff.
#define	CSKP_MAX		((CSKP)-1)	// Largest possible skip count.
#define	CSKP_MIN		((CSKP)1)	// Smallest meaningful skip count.
                                 //  Zero is reserved for something else.

#define KEEP_SEARCHING  ((int)-1)
#define STRING_MATCH    0
#define NOT_FOUND   1

/*************************************************************************
 *                          Typedef
 *************************************************************************/

typedef HANDLE          GHANDLE;
//typedef HANDLE          HFS;
typedef GHANDLE         HIDX;
typedef unsigned short  USHORT;
//typedef BYTE NEAR *     NRGB;           // Pointers to unsigned characters.
typedef BYTE FAR *      LRGB;
//typedef BYTE HUGE *     HRGB;
typedef BYTE NEAR *     NST;            // Pascal-style strings.
typedef DWORD FAR *     LPDW;
typedef DWORD FAR *     LRGDW;
typedef VOID  FAR *     LPV;            // Pointer to void
typedef VOID  FAR* FAR* LPLPV;          // Pointer to far pointer
typedef WORD  FAR *     LPW;
typedef GHANDLE	HBI;
typedef WORD            OCCIF;
//typedef GHANDLE         HF;


/************************************************************************
 *
 *              Character Mapping Table Structure
 *
 ************************************************************************/

typedef struct
{
    WORD  Class;        // Action controlled class
    WORD  SortOrder;    // Sorting order
    BYTE  Norm;         // Normalized character (for search)
    BYTE  WinCaseSensitiveNorm; // For text copy
    BYTE  MacDisplay;   // Mac's display
    BYTE  MacCaseSensitiveNorm; // For text copy
    BYTE  MacToWin;     // Mapping back from Mac to Win
    BYTE  Pad1;         // Padding purpose for dword alignment
} CHARMAP, FAR *LPCMAP;


/*************************************************
 *  Character related information table structure
 *  Must match the one in mvfs\btpriv.h
 *************************************************/

typedef struct CHARTAB
{
    HANDLE hStruct;               // Handle to this structure
    LPV    lpLigature;            // Ligature table
    HANDLE hLigature;             // Handle to ligature table
    LPCMAP lpCMapTab;             // Character mapping table
    WORD   wcLigature;            // Number of ligature entries
    WORD   wcTabEntries;          // Number of table entries
    WORD   fFlag;                 // Various flags
    WORD   Pad;                   // Padding to make DWORD align
} CHARTAB, FAR *LPCHARTAB;

#define     DEF_LIGATURE_COUNT  5   // Default number of ligature entries

/* Operator table support */
typedef struct OPSYM {
    LPB OpName;             /* Operator name */
    WORD OpVal;             /* Operator value */
} OPSYM, FAR *LPOPSYM;

/* Number of entries in the default OperatorArray */
#define OPERATOR_ENTRY_COUNT    7

/* Size of the buffer used for Operator table */
#define OPTABLE_SIZE    100

typedef struct OPTABLE
{
    LPB lpbOptable;     /* Pointer operator symbol table buffer */
    HANDLE hOpTab;      /* Handle to table buffer */
    LPOPSYM lpOpsymTab; /* Pointer to operator symbol table */
    HANDLE hOpSym;      /* Handle to operator symbol table */
    HANDLE hStruct;     /* Handle to this structure */
    WORD cbLeft;        /* Byte left in the buffer */
    WORD wsize;         /* Size of the table */
    WORD cEntry;        /* Number of operator entries */
    BYTE fFlag[OPERATOR_ENTRY_COUNT];
} OPTABLE, FAR *_LPOPTAB;

/* Functions' types */

typedef ERR    (FAR PASCAL * FWORDCB)(LST, LST, DWORD, LPV);

#define ACCEPT_WILDCARD     1
/* Functions' types */

typedef ERR     (FAR PASCAL * FWORDCB)(LST, LST, DWORD, LPV);
typedef ERR     (FAR PASCAL * BREAKER_FUNC) (LPBRK_PARMS);
typedef LPIBI   (FAR PASCAL * BREAKER_INIT)(VOID);
typedef short   (FAR PASCAL * ICMPWORDS)(LST, LST);
typedef void    (FAR PASCAL * BREAKER_FREE)(LPIBI);

/* Breaker's information structure. All scanning functions will
   be called indirectly through the functions pointers
*/

typedef ERR     (FAR PASCAL * FSTEM)(LST, LST);
typedef struct  BreakerInfo
{
    HANDLE          hbi;                // Handle to this structure.
    HANDLE          hModule;            // "LoadLibrary" handle.
    LPIBI           lpibi;              // Internal break info pointer.
    BREAKER_FUNC    lpfnFBreakWords;    // Pointer to word-breaker function
    BREAKER_FUNC    lpfnFBreakDate;     // Pointer to date-breaker function
    BREAKER_FUNC    lpfnFBreakNumber;   // Pointer to number-breaker function
    BREAKER_FUNC    lpfnFBreakEpoch;    // Pointer to epoch-breaker function
    BREAKER_FUNC    lpfnFBreakTime;     // Pointer to time-breaker function
    BREAKER_FREE    lpfnBreakerFree;    // Ptr to function freeing the breaker
    BREAKER_INIT    lpfnBreakerInit;    // Ptr to function initializing breaker
    FSTEM           lpfnFStem;          // Pointer to stemming function
    ICMPWORDS       lpfnICmpWords;      // Word comparison function
} BI, FAR *_LPBRKI;

// Information about these is kept on a per-topicID basis.

#define	OCCF_PER_TOPICID (OCCF_COUNT | OCCF_OFFSET | OCCF_LENGTH)

#define	CB_MAX_PACKED_OCC_SIZE (sizeof(OCC) + 8)
				// Largest possible packed (either sort-packed
				//  or byte-packed) occurence record.  This is
				//  equal to "sizeof(OCC)" plus one byte for
				//  each field in an OCC.

#define	CB_DEF_NODE_SIZE    ((WORD)4096)    // B-tree node size.

#define	DW_NIL_FIELD        ((DWORD)0L)     // Dead field-ID.

//	Compression-key defines.

//	The order of the following defines is important.

typedef	BYTE	CSCH;

#define	CSCH_NONE   ((CSCH)0x00)
                // Indicates default compression schemes,
                // which is the "bitstream" scheme.
                // --------
                // Delta-compression schemes:
                // --------
#define	CSCH_FIXED  ((CSCH)0x01)
                // If this is set, "nWidth" contains the
                //  number of bits that is used in all cases
                //  to store the delta.  If this bit is not
                //  set, the following bits are tested.  The
                //  value of this should be "one".
#define	CSCH_BELL   ((CSCH)0x02)
                // If this is set, the "bell curve" scheme is
                //  used, and "nWidth" contains the "center"
                //  value that the scheme will use.  If this
                //  bit is not set, the run will be compressed
                //  with bitstream encoding.  The value of
                //  this should be "two".
                // ----
                // If more delta compression scheme selectors
                //  are inserted here, they should use the
                //  least-significant un-used bits, in order.
                // --------
                // Other flags:
                // --------
#define	CSCH_UNARY  ((CSCH)0x80)
                // This is set if for the given word no more
                //  that one occurence of the word appears in
                //  any one topic.  The word can appear
                //  in more than one topic, it only needs
                //  to occur EXACTLY ONCE in each topic
                //  that it appears in.  The value of this
                //  bit should be set apart from the values
                //  for delta compression scheme selection.

// The width of the "center" value.
#define	CBIT_WIDTH_BITS	((CBIT)5)

// Index to different slot for compression scheme
#define	CKEY_TOPIC_ID	0
#define CKEY_OCC_COUNT  1
#define CKEY_OCC_BASE   2

typedef	struct	CompressionKey 
{
	CSCH	cschScheme;
	BYTE	ucCenter;
}	CKEY,
	FAR *LPCKEY;


//	Index b-tree node-ID.

typedef	DWORD   NID;        // Node-ID.
typedef	NID	FAR *LPNID;

#define	NID_NIL ((NID)-1L)

#define	CB_HUGE_BUF     (cbMAX_IO_SIZE) // A very large file buffer.
                                        // This is 32767, which is
                                        // not a power of two.

// These were used for version 8 and are no longer needed in v20

#define	MAX_WEIGHT		(WORD)-1	// The maximum weight

//	A couple of FBI utility defines.

#define	CB_BIG_BUF      ((CB)16384)     // A large file buffer.


// Maximum height of B-tree that we support

#define MAX_TREE_HEIGHT         10

typedef struct FILEDATA
{
    HFPB        fFile;              // Handle to file
    HANDLE      hMem;               // Handle to memory buffer
    LPB         pMem;               // Pointer to memory buffer
    LPB         pCurrent;           // Pointer to current position in buffer
    LONG        dwMax;              // Size of the buffer
    FILEOFFSET  foPhysicalOffset;   // The physical offset into the file that
                                    // pCurrent should be pointing to
    FILEOFFSET  foStartOffset;      // The physical offset into the file that
									// beginning of a FileWrite
    LONG        cbLeft;             // Number of bytes left in buffer
    char        ibit;               // Index of the current bit in the current
                                    // byte.  Used for bit-aligned compresssion
									// Must be signed!!
    BYTE        pad1;
    BYTE        pad2;
    BYTE        pad3;
} FILEDATA, FAR *PFILEDATA;


typedef struct NODEINFO
{
    HANDLE  hStruct;            // Handle to this structure. MUST BE 1ST!
    HFPB    hfpbIdx;            // Index file.
    FILEOFFSET nodeOffset;      // File offset of this node
    FILEOFFSET nextNodeOffset;  // Next node offset
    FILEOFFSET prevNodeOffset;  // Next node offset
	DWORD   dwBlockSize;        // Size of the block
    
    LPB     pTopNode;           // Pointer to the index top node.
    LPB     pStemNode;          // Pointer to stem buffer
    LPB     pLeafNode;          // Pointer to leaf buffer
    LPB     pDataNode;          // Pointer to data node
    
    HANDLE  hMem;               // Handle to the data buffer
    LPB     pBuffer;            // Pointer to the data
    LPB     pCurPtr;            // Pointer to the end of written data
    LPB     pMaxAddress;        // Maximum address of the block
    LONG    cbLeft;             // Number of bytes left in buffer
    
    // Buffer to hold the last word processed
    // Currently allocate dwMaxWLen + 50
    HANDLE  hLastWord;          // Handle to last word
    LPB     pLastWord; 
    
    // Buffer to hold the current word processed
    // Currently allocate dwMaxWLen + 50 + sizeof fields
    HANDLE  hTmp;
    LPB     pTmpResult;
    DWORD   dwDataSizeLeft;     // Number of data byte left
    
    USHORT  Slack;              // Amount of slack to leave
    char    ibit;               // Number of bit left. MUST BE SIGNED!
    BYTE    iLeafLevel;         // Index b-tree leaf level.
    BYTE    fFlag;
    BYTE    Pad;
} NODEINFO, FAR *PNODEINFO;

#define TO_BE_UPDATE            0x01

/*************************************************************************
 *
 *                   Index Structure
 *
 *************************************************************************/

//	Index header.  One of these records resides as the first thing in
//	any index.

typedef WORD    VER;            // Index version.  This is simply
                                //  a WORD because there's probably
                                //  no need to specify major and
                                //  minor version stuff.

#define	VERCURRENT	((VER)40)	// Current index-format version.
// #define	GROUPVER	((VER)20)	// Current group version
#define CHARTABVER  ((VER)20)   // Current chartable version

#define	cLOG_MAX	    1000        // Number of pre-calculated log values
#define FILE_HEADER     1024        // Size of the file header
#define FILE_BUFFER     0xFFFF      // Size of file buffers.  This mus be at
                                    // least as large as BTREE_NODE_SIZE.
#if 0
#define BTREE_NODE_SIZE 50 		    // Size of each B-Tree node
#define STEM_SLACK      10          // Slack space in stem nodes
#define LEAF_SLACK      10          // Slack space in leaf nodes
#else
#define BTREE_NODE_SIZE 0x1000      // Size of each B-Tree node
#define STEM_SLACK      64          // Slack space in stem nodes
#define LEAF_SLACK      128         // Slack space in leaf nodes
#endif
#define FOFFSET_SIZE    6
#define DATABLOCK_ALIGN 4           // This should never be 0


typedef	struct	IdxHeader20 
{
	unsigned short 	FileStamp;	    // Index stamp (WORD)
	VER		version;			    // Index format version number. (WORD)
	DWORD	lcTopics;               // The number of distinct topics
                                    // in the index.
	FILEOFFSET foIdxRoot;           // Physical address of top node in tree
	NID	    nidLast;                // Highest node-ID allocated. (DWORD)
    NID     nidIdxRoot;             // (DWORD)
	WORD 	cIdxLevels;             // Number of levels in the b-tree. (WORD)
	WORD	occf;                   // Occurence flags, tells me which (WORD)
                                    // occurence fields are kept.
	WORD	idxf;                   // Index flags, tells me which other (WORD)
								    // indexing options were selected.
	//
	//	Index b-tree compression keys.
	//
	CKEY	ckeyTopicId;            // 2-bytes
	CKEY	ckeyOccCount;           // 2-bytes
	CKEY	ckeyWordCount;
	CKEY	ckeyOffset;
    CKEY    ckeyUnused1;            // Future use
    CKEY    ckeyUnused2;            // Future use
    CKEY    ckeyUnused3;            // Future use
    CKEY    ckeyUnused4;            // Future use
    
    // Block size
    DWORD   dwBlockSize;        // Index block size

    //
	// Index statistics
    //
	DWORD dwMaxFieldId;         // Maximum field value
	DWORD dwMaxWCount;          // Maximum word count  value
	DWORD dwMaxOffset;          // Maximum offset value
	DWORD dwMaxWLen;            // Maximum word's length value
    DWORD dwTotalWords;         // Total indexed words
    DWORD dwUniqueWords;        // Total unique words
    DWORD dwTotal3bWordLen;     // Total of all words lengths > 2 bytes
    DWORD dwTotal2bWordLen;     // Total of all words lengths <= 2 bytes
    DWORD dwUniqueWordLen;      // Total of all unique words lengths
    DWORD dwSlackCount;         // Total slack reserved in data nodes
    DWORD dwMinTopicId;         // Minimum topic ID
    DWORD dwMaxTopicId;         // Maximum topic ID
    
    // Weight table
    FILEOFFSET WeightTabOffset;    // Weight table offset
    DWORD WeightTabSize;        // Weight table size

//	Superceded by dwCodePageID and lcid in file version 4.0.
//	DWORD dwLanguage;           // Language

    FILEOFFSET foFreeListOffset;     // Offset of the FreeList
    DWORD dwFreeListSize;       // Size of the FreeList.
                                // If High byte set, need to FreeListAdd().

	//--------------- New Members for Index File Version 4.0 ----------------
	DWORD	dwCodePageID;		// ANSI code page no. specified at build time
	LCID	lcid;				// WIN32 locale ID specified at build time
	DWORD	dwBreakerInstID;	// breaker instance that was used to parse
								// terms for the index at build time.
    
}	IH20,
	FAR *PIH20;


#define	CB_IDX_HEADER_SIZE	((CB)2048)	// Number of bytes allowed
								        //  for an IH record.  Excess

#if 0
typedef struct  LeafInfo 
{
    FILEOFFSET nodeOffset;  // Node I'm working on.
    LRGB    lrgbNode;       // Pointer to its bytes.
    LRGB    lrgbTopNode;    // Pointer to the index top node.
    LRGB    lrgbNodeBuf;    // Pointer to a pre-allocated node buffer I can use.
    HFPB    hfpbIdx;        // Index file.
    LPB     pMaxAddress;    // Maximum address we can reach
    LPB     pCurPtr;        // Current pointer to the buffer
    LPERRB  lperrb;
    DWORD   dwBlockSize;    // Index block size
    short   iLeafLevel;     // Index b-tree leaf level.
    WORD    wSlackSize;     // Slack size for each node
    BYTE    ibit;           // Bit index into it.
}   LI,
    FAR * SPLI, FAR *LPLI;
#endif



/*
 *	Using GMEM_SHARED assures that the memory is owned by the DLL and not
 *	the task. The piece of memory will be released only either the DLL or
 *	the system when the DLL's last instance is closed
 */
#ifndef _MAC
#define DLLGMEM                 (GMEM_MOVEABLE)
#define DLLGMEM_ZEROINIT        (GMEM_MOVEABLE | GMEM_ZEROINIT)
#else
#define DLLGMEM                 (GMEM_MOVEABLE | GMEM_SHARE)
#define DLLGMEM_ZEROINIT        (GMEM_MOVEABLE | GMEM_SHARE | GMEM_ZEROINIT | GMEM_PMODELOCKSTRATEGY)
#endif

PUBLIC VOID FAR PASCAL DisposeFpb (GHANDLE);

typedef ERR (PASCAL NEAR *FENCODE) (PFILEDATA, DWORD, int);
typedef ERR (PASCAL FAR *FDECODE) (PNODEINFO, CKEY, LPDW);


/* Compound file system related macros and typedef */

#define FS_SYSTEMFILE       1
#define FS_SUBFILE          2
#define REGULAR_FILE        3

/*************************************************************************
 *
 *                   Error Functions
 *
 *************************************************************************/

//#if defined(_DEBUG)
//#define	VSetUserErr(lperrb, errCode, iUserCode) DebugSetErr(lperrb, errCode, \
//    __LINE__, s_aszModule, iUserCode)
//#else
#define	VSetUserErr(lperrb, errCode, iUserCode) SetErr(lperrb, errCode)
//#endif


#ifndef DOS_ONLY
#define RET_ASSERT(ex)  if (!(ex)) return E_ASSERT;
#else
#define RET_ASSERT(ex)  assert((ex));
#endif
#define DO_ASSERT(ex)  if (!(ex)) { \
    DebugSetErr(lperrb, ERR_ASSERT, __LINE__, s_aszModule,0); \
    return FAIL; }

#define UNREACHED   FALSE		// We should never reach this code !!!
#define BAD_STATE   FALSE

#ifdef _DEBUG
#define	DB_ASSERT(p)	DO_ASSERT(p)
#else
#define DB_ASSERT(p)
#endif

/*************************************************************************
 *
 *                   HIGH LEVEL FILE SYSTEM I/O (IO.C)
 *
 *************************************************************************/

#define	cbIO_ERROR  ((WORD)-1)	        // Low-level I/O error return.
#define	cbMAX_IO_SIZE   ((WORD)32767)	// Largest physical I/O I can do.

#ifdef DLL	// {
#define LPF_HFCREATEFILEHFS	HfCreateFileHfs
#define LPF_RCCLOSEHFS          RcCloseHfs
#define LPF_HFOPENHFS           HfOpenHfs
#define LPF_RCCLOSEHF           RcCloseHf
#define LPF_LCBREADHF           LcbReadHf
#define LPF_LCBWRITEHF          LcbWriteHf
#define LPF_LSEEKHF             LSeekHf
#define LPF_RCFLUSHHF           RcFlushHf
#define LPF_GETFSERR            RcGetFSError
#define LPF_HFSOPENSZ           HfsOpenSz

#else

#define LPF_HFSCREATEFILESYS VfsCreate
#define LPF_HFCREATEFILEHFS     HfCreateFileHfs
#define LPF_HFSOPENSZ           HfsOpenSz
#define LPF_RCCLOSEHFS          RcCloseHfs
#define LPF_HFOPENHFS           HfOpenHfs
#define LPF_RCCLOSEHF           RcCloseHf
#define LPF_LCBREADHF           LcbReadHf
#define LPF_LCBWRITEHF          LcbWriteHf
#define LPF_LSEEKHF             LSeekHf
#define LPF_RCFLUSHHF           RcFlushHf
#define LPF_GETFSERR            RcGetFSError
#endif  //} LOMEM

/*********************************************************************
 *                                                                   *
 *                 COMMON FUNCTIONS PROTOTYPES                       * 
 *                                                                   *
 *********************************************************************/
 
PUBLIC BOOL PASCAL FAR StringDiff2 (LPB, LPB);
PUBLIC BOOL PASCAL FAR StrCmpPascal2 (LPB, LPB);
PUBLIC WORD PASCAL FAR CbByteUnpack(LPDW, LPB);
PUBLIC int PASCAL FAR NCmpS (LPB, LPB);
PUBLIC VOID PASCAL FAR FreeHandle (HANDLE);
PUBLIC LPV PASCAL FAR GlobalLockedStructMemAlloc (unsigned int);
PUBLIC LPV PASCAL FAR 
    DebugGlobalLockedStructMemAlloc (unsigned int, LSZ, WORD);
PUBLIC VOID PASCAL FAR GlobalLockedStructMemFree (LPV);
PUBLIC int PASCAL FAR StrNoCaseCmp (LPB, LPB, WORD);
PUBLIC LST PASCAL FAR ExtractWord(LST, LST, LPW);
PUBLIC ERR PASCAL FAR ReadStemNode (PNODEINFO,  int);
PUBLIC ERR PASCAL FAR ReadLeafNode (PNODEINFO,  int);
PUBLIC ERR PASCAL FAR ReadNewData(PNODEINFO pNodeInfo);
PUBLIC int PASCAL FAR StrCmpPascal2(LPB lpStr1, LPB lpStr2);
PUBLIC ERR PASCAL FAR FGetBits(PNODEINFO, LPDW, CBIT);
PUBLIC ERR PASCAL FAR GetBellDWord (PNODEINFO, CKEY, LPDW);
PUBLIC ERR PASCAL FAR GetBitStreamDWord (PNODEINFO, CKEY, LPDW);
PUBLIC ERR PASCAL FAR GetFixedDWord (PNODEINFO, CKEY, LPDW);
PUBLIC void PASCAL FAR IndexCloseFile(LPIDX  lpidx);
PUBLIC ERR PASCAL FAR TopNodeRead( LPIDX lpidx);
PUBLIC ERR PASCAL FAR ReadIndexHeader(HFPB, PIH20);
PUBLIC void FAR PASCAL TopNodePurge(LPIDX lpidx);
PUBLIC int PASCAL FAR ReadFileOffset (FILEOFFSET FAR *, LPB);
PUBLIC ERR PASCAL FAR CopyFileOffset (LPB pDest, FILEOFFSET fo);

#if defined(_DEBUG) && !defined(_MSDN) && !defined(MOSMAP)
#define GLOBALLOCKEDSTRUCTMEMALLOC(a) DebugGlobalLockedStructMemAlloc(a,s_aszModule,__LINE__)
#define ALLOCTEMPFPB(a,s) DebugAllocTempFPB(a,s,s_aszModule,__LINE__)
#else
#define GLOBALLOCKEDSTRUCTMEMALLOC(a) GlobalLockedStructMemAlloc(a)
#define ALLOCTEMPFPB(a,s) AllocTempFPB(a,s)
#endif

#define CB_MAX_PACKED_DWORD_LEN 5   // The maximum size (in bytes) of
                                    //  either a sort-packed or
                                    //  byte-packed DWORD.
//
//	Sorting routines
//

PUBLIC ERR PASCAL NEAR IndexSort (LPW, LPB, int);

PUBLIC BOOL FAR PASCAL LibMain(HANDLE, WORD, LSZ);

PUBLIC BOOL FAR PASCAL WEP(BOOL);

#define	FILE_HDR_SIZE   40
#define	CB_BREAKER_LEN  16  // Size in characters of the word breaker
                            //  filename.  This is not a path, since all
                            //  word breakers are assumed to reside in the
                            //  searcher system directory.


/*************************************************************************
 *
 *                Catalog related structures and defines
 *
 *************************************************************************/

/*	Useful catalog flags */
#define     CAT_SORTED          0x1     // All items are in increasing order

/* Catalog header size */
#define     CATALOG_HDR_SIZE    FILE_HDR_SIZE


/* Those data are to be written at the beginning of the catalog file */
#define CAT_HEADER_DATA \
    unsigned short  FileStamp;  /* Catalog version's number */ \
    VER     version;            /* Catalog format version number.*/ \
    unsigned short  wElemSize;  /* Size of each element. */ \
    DWORD   cElement;           /* Number of elements in the catalog */ \
    DWORD   dwFirstElem         /* First element in the list */ 

typedef struct CAT_HEADER 
{
    CAT_HEADER_DATA;
} CAT_HEADER;

#define CAT_COMMON_DATA \
    DWORD	dwCurElem;      /* Current element in the list */ \
    GHANDLE	hCat;           /* Handle to this structure */ \
    HANDLE	hfpbSysFile;    /* Pointer to system file info. */ \
    HANDLE	hfpbCatalog;    /* Pointer to catalog subfile info. */ \
    GHANDLE	hCatBuf;        /* Handle to catalog buffer */ \
    WORD	fCloseSysFile;  /* Flag telling to close the system file */ \
    LPB		lpCatBuf;       /* Pointer to catalog buffer */ \
    LPERRB	lperrb          /* Pointer to error buffer */ 


/* Catalog structure for retrieval */

typedef struct CAT_RETRIEV
{
    CAT_HEADER_DATA;
    CAT_COMMON_DATA;
} CAT_RETRIEV;

/* Catalog structure for indexing */

typedef struct CAT_INDEX {
    CAT_HEADER_DATA;		// Various catalog's important data
    CAT_COMMON_DATA;		

    /* Indexing specific fields */

    WORD	fFlags;         /* Various flags */ 
    WORD	ibBufOffset;    // Offset to the lpCatBuf buffer
    GHANDLE	hIndexArray;    // Handle to array of indices
    LPW		IndexArray;	    // Pointer to array of indices
    LSZ		aszTempFile;    // Name of the temporary catalog file
    HFILE 	hResultFile;    // Temporary result file DOS handle
    DWORD	lfoTmp;         // Tmp file offset
    BYTE	TmpFileNames[cbMAX_PATH];
                            // Buffer for various tmp files names
} CAT_INDEX;

typedef BOOL (PASCAL FAR *STRING_COMP)(LSZ, LSZ);
typedef int (PASCAL FAR *FCOMPARE) (LPB, LPB, LPV);


/*************************************************************************
 *
 *                   Stop File Structure
 *
 *************************************************************************/

#define     STOP_HDR_SIZE       FILE_HDR_SIZE

typedef struct STOP_HDR 
{
    unsigned short	FileStamp;  // File stamp
    VER     version;            // Version number
    DWORD   dwFileSize;         // File size
} STOP_HDR, FAR *LPSTOP;

/* Only allow 5K for stop words. This is roughly equivalent to 900 stop
 * words, which should be enough for most cases. This is just a arbitrary
 * limitation, and not the memory size allocated
 */
#define MAX_STOPWORD_BUFSIZE    (1024 * 5)

#define HASH_SIZE       23      // Hash Table buckets (some prime number)
#define WORDBUF_SIZE    1024    // Word buffer size
#define CB_STOP_BUF	((WORD)512) // Number of bytes read at a time
                                //  from the stop-word file.
#define MB_NEXT(p)      (((LPBLOCK )p)->lpNext)
#define MB_BUFFER(p)    (((LPBLOCK )p)->Buffer)

typedef struct CHAIN 
{
    struct  CHAIN UNALIGNED *UNALIGNED lpNext;
    DWORD   dwCount;        // How many times this word has been added
    BYTE    Word;           // Beginning of the buff
} CHAIN;

typedef CHAIN UNALIGNED * UNALIGNED LPCHAIN;

#define CH_NEXT(p)  (((LPCHAIN )p)->lpNext)
#define CH_WORD(p)  (((LPCHAIN )p)->Word)

typedef	struct StopInfo 
{
    GHANDLE	hStruct;	/* Handle to this structure. THIS MUST BE 1ST!! */
    LPV	lpBlkMgr;		/* Pointer to block manager */
    STOPLKUP	lpfnStopListLookup;
    LPCHAIN *HashTab;
    WORD cbTextUsed;	/* Length of all stop words */
    WORD wTabSize;
}   SIPB;

typedef SIPB FAR *_LPSIPB;

/*************************************************************************
 *
 *                   Word Wheel File Structure
 *
 *************************************************************************/

#define CB_WHEEL_BLOCK  1024    // Word wheel block size
#define NT_SZI  "i"             // Get from btree.h

#define LPF_HBTCREATEBTREESZ    HbtCreateBtreeSz
#define LPF_RCABANDONHBT        RcAbandonHbt
#define LPF_RCCLOSEBTREEHBT     RcCloseBtreeHbt
#define LPF_RCINSERTHBT         RcInsertHbt

//PUBLIC BOOL PASCAL FAR StringDiff (LPB, LPB);

/*************************************************************************
 *
 *                   CharTab File Structure
 *
 *************************************************************************/

#define CHARTAB_HDR_SIZE        FILE_HDR_SIZE

typedef struct CHARTAB_HDR {
    unsigned short	FileStamp;      // File stamp
    VER		version;                // Version number
    DWORD	dwTabSize;              // File size
    unsigned short	wcTabEntries;   // Character table entries
    unsigned short	wcLigature;     // Number of ligature entries
    unsigned short	fFlag;          // Various flag
} CHARTAB_HDR;

/* Default number of characters in the US character table */
#define MAX_CHAR_COUNT      256

/* Ligature flags */

#define USE_DEF_LIGATURE    1	// Use default ligature table
#define NO_LIGATURE         2	// No ligature
#define LIGATURE_PROVIDED   3	// Author provides ligature table

#define DEF_LIGATURE_COUNT  5	// Default number of ligature entries

#define OP_PROCESSED        1	/* This operator has been processed */

typedef struct OPTAB_HDR {
    unsigned short  FileStamp;  /* Operator file stamp */ 
    VER             version;    /* Version number */ 
    unsigned short  cEntry;	    /* Item's count */
    unsigned short  wSize;      /* Size of the table */
} OPTAB_HDR;

#define     OPTAB_HDR_SIZE      FILE_HDR_SIZE

/* Low level query operators */

#define UO_OR_OP                2
#define UO_AND_OP               3
#define UO_NOT_OP               4
#define UO_PHRASE_OP            5
#define UO_NEAR_OP              6
#define UO_RANGE_OP             7
#define UO_GROUP_OP             8
#define UO_FBRK_OP              11
#define UO_FIELD_OP             14


PUBLIC ERR PASCAL FAR EXPORT_API FStem (LPB lpbStemWord, LPB lpbWord);

/*************************************************************************
 *
 *                      Global Variables
 *
 *	Those variables should be read only
 *************************************************************************/

extern BYTE LigatureTable[];
extern OPSYM OperatorSymbolTable[]; 
extern OPSYM FlatOpSymbolTable[]; 
extern CHARMAP DefaultCMap[];

typedef ERR (PASCAL FAR *FDECODE) (PNODEINFO, CKEY, LPDW);
extern FDECODE DecodeTable[];

WORD  FAR PASCAL    GetMacWord (LPB);
WORD  FAR PASCAL    SwapWord (WORD);
DWORD FAR PASCAL    SwapLong (DWORD);
DWORD FAR PASCAL    GetMacLong (LPB);
int PASCAL FAR SwapBuffer (LPW, DWORD);

/* Mac handler */

#ifdef _BIG_E
#define SWAPBUFFER(a,b);    SwapBuffer(a,b);
#else
#define	SWAPBUFFER(a,b);
#endif

/*************************************************************************
 *                     Catalog's Retrieval API
 *************************************************************************/
PUBLIC LPCAT EXPORT_API PASCAL FAR CatalogOpen (HANDLE, LSZ, LPERRB);
PUBLIC ERR EXPORT_API PASCAL FAR CatalogLookUp (LPCAT, LPB, DWORD);
PUBLIC VOID EXPORT_API PASCAL FAR CatalogClose(LPCAT);

/*************************************************************************
 *                         Catalog Index API functions
 *************************************************************************/

PUBLIC LPCAT EXPORT_API PASCAL FAR CatalogInitiate (WORD, LPERRB);
PUBLIC ERR EXPORT_API PASCAL FAR CatalogAddItem (LPCAT, DWORD, LPB);
PUBLIC ERR EXPORT_API PASCAL FAR CatalogBuild (HFPB, LPCAT, LSZ, 
    INTERRUPT_FUNC, LPV);
PUBLIC VOID EXPORT_API PASCAL FAR CatalogDispose (LPCAT);


#if defined( __cplusplus )
}
#endif


// Critical structures that gets messed up in /Zp8
#pragma pack()
#endif /* __FTSCOMMON_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\encode.c ===
/*************************************************************************
*                                                                        *
*  ENCODE.C  	                                                         *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   General encoding & decoding techniques                               *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Released by Development:     (date)                                   *
*                                                                        *
*************************************************************************/
#include <mvopsys.h>
#include <mem.h>
#include <mvsearch.h>
#include "common.h"
#include "index.h"

/* Structure to access bits and bytes of a DWORD */
typedef struct {
	unsigned short w1;
	unsigned short w2;
} TWOWORD;

typedef struct {
	unsigned char b1;
	unsigned char b2;
	unsigned char b3;
	unsigned char b4;
} FOURBYTE;

typedef union {
	unsigned long dwVal;
	TWOWORD dw;
	FOURBYTE fb;
} WORDLONG;

#define	HI_WORD(p)	(((WORDLONG FAR *)&p)->dw.w2)
#define	LO_WORD(p)	(((WORDLONG FAR *)&p)->dw.w1)

#define	BYTE1(p)	(((WORDLONG FAR *)&p)->fb.b4)
#define	BYTE2(p)	(((WORDLONG FAR *)&p)->fb.b3)
#define	BYTE3(p)	(((WORDLONG FAR *)&p)->fb.b2)
#define	BYTE4(p)	(((WORDLONG FAR *)&p)->fb.b1)


/*************************************************************************
 *
 *	                  INTERNAL PRIVATE FUNCTIONS
 *
 *	All of them should be declared near
 *
 *************************************************************************/
PRIVATE LPB PASCAL NEAR LongValPack (LPB, DWORD);
PRIVATE LPB PASCAL NEAR LongValUnpack (LPB, LPDW);

/*************************************************************************
 *
 *	                  INTERNAL PUBLIC FUNCTIONS
 *
 *	All of them should be declared far, unless we know they belong to
 *	the same segment. They should be included in some include files
 *
 *************************************************************************/
PUBLIC CB PASCAL NEAR CbBytePack(LPB, DWORD);
PUBLIC CB PASCAL NEAR OccurrencePack (LPB, LPOCC, WORD);
PUBLIC CB PASCAL NEAR CbCopySortPackedOcc (LPB, LPB, WORD);
PUBLIC void PASCAL NEAR OccurrenceUnpack(LPOCC, LPB, OCCF);
PUBLIC CBIT PASCAL NEAR CbitBitsDw (DWORD);


/*************************************************************************
 *
 *	@doc	INTERNAL INDEX
 *
 *	@func	LPB PASCAL NEAR | LongValPack |
 *		The function packs and writes out an encoded 4-bytes value.
 *		The encoding scheme is as followed:
 *			- High 3 bit: used to tell how many bytes are to follow
 *			  the current byte
 *			- The packed value
 *		Ex:
 *			0x1		will be output as		0x1
 *			0x1F							0x1F
 *			0x2F							0x202F (0010 0000 0010 1111)
 *
 *	@parm	LPB | lpbOut |
 *		Pointer to the output buffer
 *
 *	@parm	DWORD | dwVal |
 *		4-bytes value to be packed and emitted
 *
 *	@rdesc
 *		The buffer pointer is advanced and returned.
 *
 *	@comm	No validity check is done for the the output buffer
 *************************************************************************/

PRIVATE LPB PASCAL NEAR LongValPack (LPB lpbOut, DWORD dwVal)
{
	if (HI_WORD(dwVal) > 0x1fff) {
		*lpbOut++ = 4 << 5;	// 4 bytes follow this byte
		goto Copy4Bytes;
	}
	if (HI_WORD(dwVal) > 0x001f) {
		BYTE1(dwVal) |= 3 << 5;	/* 3 bytes follows this byte */
		goto Copy4Bytes;
	}
	if (HI_WORD(dwVal) > 0 || LO_WORD(dwVal) > 0x1fff) {
		BYTE2(dwVal) |= 2 << 5;	/* 2 bytes follows this byte */
		goto Copy3Bytes;
	}
	if (LO_WORD(dwVal) > 0x001f) {
		BYTE3(dwVal) |= 1 << 5;	/* 1 bytes follows this byte */
		goto Copy2Bytes;
	}
	else
		goto Copy1Bytes;
Copy4Bytes:
	*lpbOut ++ = BYTE1(dwVal);
Copy3Bytes:
	*lpbOut ++ = BYTE2(dwVal);
Copy2Bytes:
	*lpbOut ++ = BYTE3(dwVal);
Copy1Bytes:
	*lpbOut ++ = BYTE4(dwVal);
	return lpbOut;
}

/*************************************************************************
 *
 *	@doc	INTERNAL INDEX
 *
 *	@func	LPB PASCAL NEAR | LongValUnpack |
 *		This is the reverse on LongValPack. Given a buffer containing
 *		a packed 4-byte value, the function will unpack and return the
 *		value. The pointer to the input buffer is updated and returned
 *
 *	@parm	LPB | lpbIn |
 *		Input buffer containing the packed value
 *
 *	@parm	LPDW | lpdw |
 *		Place to store the unpacked value
 *
 *	@rdesc	The new updated input buffer pointer
 *
 *	@comm	No validity check for lpbIn is done because of speed
 *
 *************************************************************************/

PRIVATE LPB PASCAL NEAR LongValUnpack (LPB lpbIn, LPDW lpdw)
{
	DWORD dwVal = 0;
	register int cbByteCopied;

	/* Get the number of bytes to be copied */
	cbByteCopied = *lpbIn >> 5;
	*lpbIn &= 0x1f;

	switch (cbByteCopied) {
		case 4:
			lpbIn++;
		case 3:
			BYTE1(dwVal) = *lpbIn++;
		case 2:
			BYTE2(dwVal) = *lpbIn++;
		case 1:
			BYTE3(dwVal) = *lpbIn++;
		case 0:
			BYTE4(dwVal) = *lpbIn++;
	}
	*lpdw = dwVal;
	return lpbIn;
}

/*************************************************************************
 *
 *	@doc	INTERNAL INDEX
 *
 *	@func	CB PASCAL NEAR | OccurrencePack |
 *		Packs and emits all occurrence's fields
 *
 *	@parm	LPB | lpbOut |
 *		Place to store the packed occurrence's fields
 *
 *	@parm	LPOCC | lpOccIn |
 *		Pointer to occurrence structure
 *
 *	@parm	WORD | occf |
 *		Occurrence flags telling which fields are present
 *
 *	@rdesc	The number of bytes written
 *
 *************************************************************************/

PUBLIC CB PASCAL NEAR OccurrencePack (register LPB lpbOut, LPOCC lpOccIn,
	register WORD occf)
{
	DWORD dwVal;
	LPB lpbSaved = lpbOut;
	
	while (occf) {
		if (occf & OCCF_FIELDID) {
			dwVal = lpOccIn->dwFieldId;
			occf &= ~OCCF_FIELDID;
		}
		else if (occf & OCCF_TOPICID) {
			dwVal = lpOccIn->dwTopicID;
			occf &= ~OCCF_TOPICID;
		}
		else if (occf & OCCF_COUNT) {
			dwVal = lpOccIn->dwCount;
			occf &= ~OCCF_COUNT;
		}
		else if (occf & OCCF_OFFSET) {
			dwVal = lpOccIn->dwOffset;
			occf &= ~OCCF_OFFSET;
		}
		else if (occf & OCCF_LENGTH) {
			dwVal = lpOccIn->wWordLen;
			occf &= ~OCCF_LENGTH;
		}
		else {
			break;
		}
		if (HI_WORD(dwVal) > 0x1fff) {
			*lpbOut++ = 4 << 5;	// 4 bytes follow this byte
			goto Copy4Bytes;
		}
		if (HI_WORD(dwVal) > 0x001f) {
			BYTE1(dwVal) |= 3 << 5;	/* 3 bytes follows this byte */
			goto Copy4Bytes;
		}
		if (HI_WORD(dwVal) > 0 || LO_WORD(dwVal) > 0x1fff) {
			BYTE2(dwVal) |= 2 << 5;	/* 2 bytes follows this byte */
			goto Copy3Bytes;
		}
		if (LO_WORD(dwVal) > 0x001f) {
			BYTE3(dwVal) |= 1 << 5;	/* 1 bytes follows this byte */
			goto Copy2Bytes;
		}
		else
			goto Copy1Bytes;
#if 1
	Copy4Bytes:
		*lpbOut ++ = BYTE1(dwVal);
	Copy3Bytes:
		*lpbOut ++ = BYTE2(dwVal);
	Copy2Bytes:
		*lpbOut ++ = BYTE3(dwVal);
	Copy1Bytes:
		*lpbOut ++ = BYTE4(dwVal);
	}
	return (CB)(lpbOut - lpbSaved);
#else
	Copy4Bytes:
		*(LPDW)lpbOut = dwVal;
		lpbOut += 4;
		continue;

	Copy3Bytes:
		*lpbOut ++ = BYTE2(dwVal);

	Copy2Bytes:
		*(LPW)lpbOut  = LO_WORD(dwVal);
		lpbOut += 2;
		continue;

	Copy1Bytes:
		*lpbOut ++ = BYTE4(dwVal);
		continue;
	}
#endif
	return (CB)(lpbOut - lpbSaved);
}

/*************************************************************************
 *	@doc	INTERNAL INDEX
 *
 *	@func	CB PASCAL NEAR | CbCopySortPackedOcc |
 *		Copy the packed occurrence structure
 *
 *	@parm	LPB | lpbDst |
 *		Pointer to destination buffer
 *	@parm	LPB | lpbSrc |
 *		Pointer to source buffer
 *	@parm	WORD | uiNumOcc |
 *		Number of occurrence fields (>= 1)
 *	@rdesc
 *		return the number of bytes copied
 *************************************************************************/

PUBLIC CB PASCAL NEAR CbCopySortPackedOcc (LPB lpbDst, LPB lpbSrc,
	WORD uiNumOcc)
{
	register int cbByteCopied;
	LPB lpbSaved = lpbDst;

	do {
		for (cbByteCopied = *lpbSrc >> 5; cbByteCopied >= 0; cbByteCopied--)
			*lpbDst++ = *lpbSrc++;
		uiNumOcc--;
	} while (uiNumOcc > 0);
	return (CB)(lpbDst - lpbSaved);
}

PUBLIC void PASCAL NEAR OccurrenceUnpack(LPOCC lpOccOut, 
	register LPB lpbIn, register OCCF occf)
{
	DWORD dwVal = 0;
	LPDW  lpdw;
	register int cbByteCopied;

	while (occf)
	{
        DWORD dwTmp;
        
		if (occf & OCCF_FIELDID) {
			lpdw = &lpOccOut->dwFieldId;
			occf &= ~OCCF_FIELDID;
		}
		else if (occf & OCCF_TOPICID) {
			lpdw = &lpOccOut->dwTopicID;
			occf &= ~OCCF_TOPICID;
		}
		else if (occf & OCCF_COUNT) {
			lpdw = &lpOccOut->dwCount;
			occf &= ~OCCF_COUNT;
		}
		else if (occf & OCCF_OFFSET) {
			lpdw = &lpOccOut->dwOffset;
			occf &= ~OCCF_OFFSET;
		}
		else if (occf & OCCF_LENGTH) {
			dwTmp = lpOccOut->wWordLen;
			lpdw = &dwTmp;
			occf &= ~OCCF_LENGTH;
		}
		else {
			break;
		}

		dwVal = 0;

		/* Get the number of bytes to be copied */
		cbByteCopied = *lpbIn >> 5;
		*lpbIn &= 0x1f;

#if 1
		switch (cbByteCopied) {
			case 4:
				lpbIn++;
			case 3:
				BYTE1(dwVal) = *lpbIn++;
			case 2:
				BYTE2(dwVal) = *lpbIn++;
			case 1:
				BYTE3(dwVal) = *lpbIn++;
			case 0:
				BYTE4(dwVal) = *lpbIn++;
		}
#else
		switch (cbByteCopied) {
			case 4:
				lpbIn++;

			case 3:
				dwVal = *(LPDW)lpbIn;
				lpbIn += 4;
				break;

			case 2:
				BYTE1(dwVal) = *lpbIn++;

			case 1:
				LO_WORD(dwVal) = *(LPW)lpbIn;
				lpbIn += 2;
				break;

			case 0:
				BYTE4(dwVal) = *lpbIn++;
		}
#endif
		*lpdw = dwVal;
	}
}

PUBLIC CBIT PASCAL NEAR CbitBitsDw (DWORD dwVal)
{
	register WORD wVal;			//Value to be scanned
	register WORD cBitCount;	// Number of bit

	if (HI_WORD(dwVal)) {
		/* We will look at the hi-word only, but add 16 to the result */
		cBitCount = 16;
		wVal = HI_WORD(dwVal);
	}
	else {
		/* We look at the lo-word only */
		cBitCount = 0;
		wVal = LO_WORD(dwVal);
	}

	/* Now do the shift */
	while (wVal) {
		cBitCount++;
		wVal >>= 1;
	}
	return cBitCount;
}

//	-	-	-	-	-	-	-	-	-

//	This function figures out how best to encode a set of values.  It
//	uses an array of statistics about the data in order to make this
//	determination.  The array conveys to the algorithm the number of
//	values that require a particular number of bits to represent.  For
//	the "fixed" and "bell" schemes, this is all the information that's
//	needed in order to make a judgment as to which scheme is best.
//
//	The inner workings of this are bitching hard to understand, so you
//	should probably read any occurence compression external documentation
//	you can find before you try to tackle this function.
//
//	-	-	-	-	-	-	-	-	-
//
//	Information about the "bitstream" scheme:
//
//	The number of bits necessary to encode the values using the
//	"bitstream" scheme is spoon-fed into the algorithm via a parameter,
//	because it's not possible to derive this value using the statistics
//	array.
//
//	-	-	-	-	-	-	-	-	-
//
//	Information about the "bell" scheme:
//
//	Here's a bell grid, which I hope will provide some documentation as
//	to the characteristics of the bell scheme.  It is possible to figure
//	out how many bits a given sample will take to encode, given a
//	particular bell "center" value, but the algorithm is complicated and
//	non-intuitive.
//
//				    Bell Center
//
//			0	1	2	3	4	5  ...	31
//		    +--------------------------------------------- ... ------
//		0   |	1(c)	2	3	4	5	6  ...	32
//		1   |	2(c)	2(c)	3	4	5	6  ...	32
//		2   |	4	3(c)	3(c)	4	5	6  ...	32
//   Size in	3   |	6	5	4(c)	4(c)	5	6  ...	32
//   bits of	4   |	8	7	6	5(c)	5(c)	6  ...	32
//   value to	5   |	10	9	8	7	6(c)	6(c) .. 32
//   encode	6   |	12	11	10	9	8	7(c) ..	32
//		7   |	14	13	12	11	10	9  ...	32
//		8   |	16	15	14	13	12	11 ...	32
//		9   |	18	17	16	15	14	13 ...	32
//		..  .	..	..	..	..	..	.. ...	..
//		32  |	64	63	62	61	60	59 ...	33(c)
//
//	The numbers in this table represent the number of bits necessary to
//	encode a given value, using a given bell center.  The "(c)" represents
//	the point of minimum waste.  There are two of these for each "center".
//	The waste at (c) is guaranteed to be exactly one bit.
//
//	It's would be possible for the bell center to be equal to 32, but this
//	would mess up my life since I only store center values in 5 bits, and
//	32 would take 6 bits.  Upon examination, though, it can be shown that
//	there are no cases where a ceiling value of 32 is any better than a
//	ceiling value of 31, so I can rule out 32.
//
//	-	-	-	-	-	-	-	-	-
//
//	Information about the "fixed" scheme:
//
//	The "center" as calculated by this algorithm is the number of bits
//	necessary to represent the largest value in the sample.
//
//	Since this value can be 32, but I'm only using 5 bits to store center
//	values, I subtract one from this value, which I will add back in
//	during decompression.  This means that I can't store zero, size
//	0 - 1 = -1, which is 31 if we've got a 5-bit quantity.  So I don't
//	allow the fixed scheme to use zero as a center.  If the best value
//	comes up as zero, I make it one instead.

//	-	-	-	-	-	-	-	-	-

PUBLIC void NEAR PASCAL VGetBestScheme(
	LPCKEY	lpckey,			// Output compression key.
	LRGDW	lrgdwStats,		// Each dword (N) in this array at
					//  a given array index (M) represents
					//  a count of the number of values in
					//  the sample that require M bits to
					//  store.  If (lrgdwStats[6] == 17),
					//  there were 17 values in the sample
					//  that required 6 bits to store.
	DWORD	lcbitRawBitstreamBits,	// This is lcbitBITSTREAM_ILLEGAL if
					//  bitstream packing is not allowed,
					//  else it is equal to the number of
					//  bits necessary to encode all of
					//  the values using bitstream
					//  encoding.
    int   fNoFixedScheme) // Set if we don't want fixed scheme
{
	register short	iStats;		// Scratch index.
	DWORD	argdwBellBits[		// This is used to compute bell
		cbitCENTER_MAX];	//  values.  Its sole purpose is to
					//  save a bunch of multiplies that
					//  I'd have to do if it didn't exist.
	DWORD	lcbitBell;		// Total number of bits used if I
					//  adopt the bell scheme to encode
					//  this sample.
	DWORD	lcbitFixed;		// Total number of bits used if I
					//  adopt the fixed scheme to encode
					//  this sample.
	DWORD	lcbitBitstream;		// Total number of bits used if I
					//  adopt the scheme scheme to encode
					//  this sample.
	DWORD	lcTotalEncodedValues;	// The total number of values that I
					//  have to encode.
	short	idwCeiling;		// The size of "lrgdwStats" if you
					//  trim off all of the high-end zero
					//  elements.
	short	idwBellCeiling;		// This is "idwCeiling" unless the
					//  value of "idwCeiling" is
					//  cbitCENTER_MAX, in which case
					//  it's "idwCeiling - 1".
	CBIT	cbitBellCenter;		// This will be the best "center"
					//  value found for the bell scheme.
	CBIT	cbitFixedCenter;	// This will be the "center" value for
					//  the "fixed" scheme.

	//
	//	Determine the value of "idwCeiling", which is used to trim off
	//	consecutive zero values at the top end of the statistics
	//	array.
	//
	for (iStats = cbitCENTER_MAX - 1; iStats >= 0; iStats--)
		if (lrgdwStats[iStats])
			break;
	idwCeiling = iStats + 1;
	//
	//	Initialize variables used in bell computation.
	//
	for (iStats = 0; iStats < idwCeiling; iStats++)
		argdwBellBits[iStats] = lrgdwStats[iStats] *
			(DWORD)(iStats * 2 + 1);
	lcbitBell = (DWORD)-1L;
	cbitBellCenter = 0;
	lcTotalEncodedValues = 0L;
	idwBellCeiling = (idwCeiling == cbitCENTER_MAX) ?
		cbitCENTER_MAX - 1 : idwCeiling;
	//
	//	Each pass through the following loop generates a value,
	//	"lcbitBellTotal", which is equal to the number of bits
	//	necessary to encode all of the values, using a "center" value
	//	equal to the loop index ("iStats").  This value is checked
	//	against "lcbitBell", if it's less it becomes the new
	//	"lcbitBell", and the center is stored in "cbitBellCenter".
	//
	for (iStats = 0; iStats < idwBellCeiling; iStats++) {
		DWORD	lcbitBellTotal;
		register short	i;

		lcTotalEncodedValues += lrgdwStats[iStats];
		lcbitBellTotal = 0L;
		for (i = 0; i <= iStats; i++) {	// Adjust values below center.
			lcbitBellTotal += argdwBellBits[i];
			argdwBellBits[i] += lrgdwStats[i];
		}
		for (; i < idwCeiling; i++) {	// Adjust values above center.
			argdwBellBits[i] -= lrgdwStats[i];
			lcbitBellTotal += argdwBellBits[i];
		}
		if (lcbitBellTotal < lcbitBell) {
			lcbitBell = lcbitBellTotal;
			cbitBellCenter = iStats;
		}
	}
	//
	//	As of this point the best bell center is stored in
	//	"cbitBellCenter", although given the obscurity of the logic in
	//	the above loop you might have to take my word for it.  The
	//	number of bits necessary to bell encode the values using
	//	"cbitBellCenter" as the center is in "lcbitBell".
	//
	//	This next bit of code figures out which scheme to use, and
	//	sets up the returned compression key ("lpckey") with this
	//	result.
	//
	lcbitBell += cbitWASTED_BELL;
	cbitFixedCenter = (idwCeiling <= 1) ? 1 : idwCeiling - 1;
	lcbitFixed = (DWORD)cbitFixedCenter *	// Get total "fixed" bits.
		lcTotalEncodedValues + cbitWASTED_FIXED;
	lcbitBitstream = (lcbitRawBitstreamBits ==
		lcbitBITSTREAM_ILLEGAL) ?
		(DWORD)-1L :			// Get total "bitstream" bits.
		lcbitRawBitstreamBits + cbitWASTED_BITSTREAM;
	if ((lcbitFixed <= lcbitBell && fNoFixedScheme == FALSE) &&
		(lcbitFixed <= lcbitBitstream)) {
		lpckey->cschScheme = CSCH_FIXED;		// Best scheme was
		lpckey->ucCenter =			//  "fixed".  Note
			(BYTE)(cbitFixedCenter - 1);	//  the "- 1".
	} else if (lcbitBitstream <= lcbitBell)
		lpckey->cschScheme = CSCH_NONE;		// Best scheme was
							//  "bitstream".
	else {
		lpckey->cschScheme = CSCH_BELL;		// Best scheme was
		lpckey->ucCenter =			//  "bell".
			(BYTE)cbitBellCenter;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\collect3.c ===
/*************************************************************************
*                                                                        *
*  COLLECT.C                                                             *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*                                                                        *
*  This modules is the first stage in the index building process.  The   *
*  primary functoin of stage 1 is to collect and sort all of the words   *
*  to be indexed.  Before processing can begin, the user must call       *
*  IndexInitiate to initialize the indexing variables (IPB).  Words are  *
*  added via a call to IndexAddWord and are stored in a Balanced Tree    *
*  until an OOM condition occurrs.  The tree is dumped and reset to      *
*  receive further words.                                                *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
**************************************************************************/
#include <mvopsys.h>
#include <mem.h>
#include <memory.h>
#include <math.h>
#include <orkin.h>
#include <mvsearch.h>
#include "common.h"
#include "index.h"

#ifdef _DEBUG
static BYTE NEAR s_aszModule[] = __FILE__;	/* Used by error return functions.*/
#endif


#define MAX_OCCDATA 5
#define ISBUFFER_SIZE 0xFFFC    // Size of OUTPUT buffers for collect2.c
                                // The output is DWORD aligned
                                // And the buffer *MUST* BE a multiple of 4
                                // Min size: size of largest index word

#define MIN_REQUIRED_MEM    0x400000    // 4-meg minimum

/*************************************************************************
 *
 *                   INTERNAL PUBLIC FUNCTIONS
 *
 * All of them should be declared far, unless we know they belong to
 * the same segment. They should be included in some include file
 *
 *************************************************************************/

PUBLIC VOID FAR PASCAL FreeISI (LPIPB);
PUBLIC void FAR PASCAL FreeEsi (LPIPB);

/*************************************************************************
 *
 *                   INTERNAL PRIVATE FUNCTIONS
 *
 *************************************************************************/

PRIVATE PBTNODE NEAR PASCAL AddNode (_LPIPB, LST, LPOCC, PHRESULT);
PRIVATE HRESULT NEAR PASCAL AddTopic (_LPIPB, PSTRDATA, LPOCC);
PRIVATE void NEAR PASCAL AddOccurrence (PTOPICDATA, POCCDATA, int);
PRIVATE HRESULT NEAR PASCAL WriteBuffer (_LPIPB, LPB);
PRIVATE HRESULT NEAR PASCAL TraverseWrite (_LPIPB, PBTNODE, int);
PRIVATE void NEAR PASCAL BalanceTree (LPISI, PBTNODE);
PRIVATE void NEAR PASCAL LeftRotate (LPISI, PBTNODE);
PRIVATE void NEAR PASCAL RightRotate (LPISI, PBTNODE);
PRIVATE HRESULT PASCAL NEAR IndexBlockAllocate (LPIPB lpipb, LONG lMemSize);
PRIVATE void NEAR PASCAL VerifyTree (PBTNODE pRoot);

/*************************************************************************
 *
 *                   PUBLIC API FUNCTIONS
 *
 * All of them should be declared far and included in some .DEF file
 *
 *************************************************************************/

PUBLIC   LPIPB EXPORT_API FAR PASCAL MVIndexInitiate(PINDEXINFO pIndexInfo,
	PHRESULT phr);
PUBLIC  void EXPORT_API FAR PASCAL MVIndexDispose (LPIPB);
PUBLIC  HRESULT EXPORT_API FAR PASCAL MVIndexAddWord (LPIPB, LST, LPOCC);
PUBLIC  LPDWORD EXPORT_API PASCAL FAR TotalIndexedWord (LPIPB);

/*************************************************************************
 *
 *                   INTERNAL PUBLIC FUNCTIONS
 *
 * All of them should be declared far and included in some .h file
 *
 *************************************************************************/

PUBLIC  HRESULT FAR PASCAL SortFlushISI (_LPIPB);
PUBLIC int FAR PASCAL CompareOccurrence (LPDW, LPDW, int);
PUBLIC int FAR PASCAL StrCmp2BytePascal (LPB, LPB);
PUBLIC HRESULT FAR PASCAL FlushTree (_LPIPB);


/*************************************************************************
 *
 * @doc  API EXTERNAL INDEXING
 *
 * @func LPIPB FAR PASCAL | MVIndexInitiate |
 *    The function allocates a index parameter block. The block is used
 *    in all places during indexing.  This function must be called
 *    prior to any other indexing funtion.
 *
 * @parm PINDEXINFO | pIndexInfo |
 *    Pointer to the index information data
 *
 * @parm PHRESULT | phr |
 *    Pointer to error buffer.
 *
 * @rdesc   Pointer to the block, or NULL if error. The error buffer
 *    contains the description of the error
 *
 *************************************************************************/
PUBLIC   LPIPB EXPORT_API FAR PASCAL MVIndexInitiate(PINDEXINFO pIndexInfo,
    PHRESULT phr)  
{
    _LPIPB   lpipb;             // Pointer to index paramet block
    HRESULT      fRet;

    // foNil should, of course, be nil
    // In this case foNil is only used by incremental update
    ITASSERT(0 == foNil.dwOffset && 0 == foNil.dwHigh);

    if (pIndexInfo == NULL)    
    {
        SetErrCode (phr, E_INVALIDARG);
        return(NULL);
    }
    
    // Allocate the block. All the fields are initialized to 0
    if ((lpipb = GlobalLockedStructMemAlloc (sizeof (IPB))) == NULL)
    {
        SetErrCode (phr, E_OUTOFMEMORY);
        return (NULL);
    }

    // Initialize "idxf", make sure that "occf" has "OCCF_TOPICID" set.
    lpipb->idxf = (WORD)(pIndexInfo->Idxf);
    lpipb->occf = (WORD)(pIndexInfo->Occf | OCCF_TOPICID);

    // Initialize some fields
    lpipb->dwLastIndexedTopic = (DWORD)-1;
    
    // Set the number of occurrence fields in the occurrence block
    
    if (pIndexInfo->Occf & OCCF_COUNT)
        lpipb->ucNumOccDataFields++;
    if (pIndexInfo->Occf & OCCF_OFFSET)
        lpipb->ucNumOccDataFields++;

    // Clear sort file handle
    lpipb->dwUniqueWord = 0;
    lpipb->esi.lpesbRoot = NULL;
    
    // Allocate all the necessary memory block
    if ((lpipb->dwMemAllowed = pIndexInfo->dwMemSize) < MIN_REQUIRED_MEM)
        lpipb->dwMemAllowed = MIN_REQUIRED_MEM;
    
    if ((fRet = IndexBlockAllocate (lpipb, lpipb->dwMemAllowed)) != S_OK)
    {
        SetErrCode (phr, fRet);
        GlobalLockedStructMemFree (lpipb);
        return (NULL);
    }

    if (pIndexInfo->dwBlockSize <= BTREE_NODE_SIZE)
        lpipb->BTreeData.Header.dwBlockSize = BTREE_NODE_SIZE;
    else
        lpipb->BTreeData.Header.dwBlockSize =  pIndexInfo->dwBlockSize;

	lpipb->BTreeData.Header.dwCodePageID = pIndexInfo->dwCodePageID;
	lpipb->BTreeData.Header.lcid = pIndexInfo->lcid;
	lpipb->BTreeData.Header.dwBreakerInstID = pIndexInfo->dwBreakerInstID;
    

	// Set the callback key
	lpipb->dwKey = CALLBACKKEY;


    return (lpipb);
}


/*************************************************************************
 *
 * @doc  API EXTERNAL INDEXING
 *
 * @func void FAR PASCAL | MVIndexDispose |
 *    Release all memory associated with the index parameter block.
 *    Must be called after indexing is complete.
 *
 * @parm _LPIPB | lpipb |
 *    Pointer to index parameter block
 *
 *************************************************************************/
PUBLIC   void EXPORT_API FAR PASCAL MVIndexDispose(_LPIPB lpipb)
{
    // Sanity check 
    if (lpipb == NULL)
        return;
    // Free all memory associated with internal sort 
    FreeISI(lpipb);

    // Free all memory associated with external sort 
    FreeEsi(lpipb);

    GlobalLockedStructMemFree (lpipb);
}


/*************************************************************************
 *
 * @doc  PRIVATE INDEXING
 *
 * @func VOID PASCAL NEAR | FreeISI |
 *      Free all blocks, and temporary file associated with the internal
 *      sort
 *
 * @parm _LPIPB | lpipb |
 *      Pointer to index parameter block
 *
 *************************************************************************/
PUBLIC VOID PASCAL NEAR FreeISI (_LPIPB lpipb)
{
    // Release temporary file buffer
    FreeHandle (lpipb->isi.hSortBuffer);
    lpipb->isi.hSortBuffer = NULL;
    if (lpipb->isi.hfpb)
    {
        FileClose (lpipb->isi.hfpb);
        lpipb->isi.hfpb = NULL;
    }

    if (lpipb->pDataBlock)
    {
        BlockFree (lpipb->pDataBlock);
        lpipb->pDataBlock = NULL;
    }
    if (lpipb->BTNodeBlock.pBlockMgr)
    {
        BlockFree (lpipb->BTNodeBlock.pBlockMgr);
        lpipb->BTNodeBlock.pBlockMgr = NULL;
        lpipb->BTNodeBlock.pFreeList = NULL;    // Free list of Btnode
    }
    if (lpipb->TopicBlock.pBlockMgr)
    {
        BlockFree (lpipb->TopicBlock.pBlockMgr);
        lpipb->TopicBlock.pBlockMgr = NULL;
        lpipb->TopicBlock.pFreeList = NULL;     // Free list of topic node
    }
    if (lpipb->OccBlock.pBlockMgr)
    {
        BlockFree (lpipb->OccBlock.pBlockMgr);
        lpipb->OccBlock.pBlockMgr = NULL;
        lpipb->OccBlock.pFreeList = NULL;       // Free list of occurrence nodes
    }
}


/*************************************************************************
 * @doc     API EXTERNAL INDEXING
 *
 * @func    HRESULT FAR PASCAL | MVIndexAddWord |
 *      This function will add a word into the index.
 *
 * @parm    LPIPB | lpipb |
 *      Index parameter block being operated on
 *
 * @parm    LST | lstWord |
 *      Word being indexed.  (Pascal style with 2-byte header)
 *
 * @parm LPOCC | lpocc |
 *      Occurence data associated with this word. It is assumed that the
 *      occurrence block contains NO UNINITIALIZED DATA, ie. non-used
 *      fields must be set to 0
 * 
 * @rdesc   S_OK, if successful, else other error
 *
 * @comm
 *      The data are copied into the buffer managed by the block manager
 *      and arranged as a Red/Black tree to speed sorting.
 *************************************************************************/

static OCC NullOcc =  { 0 };

PUBLIC   HRESULT EXPORT_API FAR PASCAL MVIndexAddWord (_LPIPB lpipb,
    LST lstWord, LPOCC lpOcc)
{
    // Local replacement variables
    ERRB  errb;                 // Pointer to error variable
    LPISI   pIsi;               // Internal Sort Information
    PBTNODE pRoot;              // Root of the Balanced Tree

    // Working variables
    PBTNODE pNode;              // Used to traverse the tree to find
                                // to find the insertion point
    PBTNODE FAR *ppNode;        // Used to add children to the tree
    int result;                 // String compare results
    int wLen;                   // Word length
    LST lstStart;               // Saved starting position
#ifdef _DEBUG
    char Buffer[200];
#endif
#ifdef _DEBUGREDBLACK
    int iLeft = 0;
    int iRight = 0;
#endif

    
    // Various flags
    int fCompareField;

    // Sanity check     
    if (lpipb == NULL)
        return(E_INVALIDARG);
        
    // Handle null case
    if (lstWord == NULL) 
        return(S_OK);

    fCompareField = lpipb->occf & OCCF_FIELDID;
    pIsi  = &lpipb->isi;        // Internal Sort Information
    pRoot = pIsi->pBalanceTree; // Root of the Balanced Tree

    // Working variables
    ppNode = NULL;              // Used to add children to the tree
    lstStart = lstWord;         // Saved starting position
    
    if (lpOcc == NULL)
        lpOcc = &NullOcc;

    // Get statistics
    lpipb->dwIndexedWord++;
    
    // Count unique TopicId's
    if (lpipb->dwLastIndexedTopic != lpOcc->dwTopicID)
    {
        lpipb->lcTopics++;
        lpipb->dwLastIndexedTopic = lpOcc->dwTopicID;
    }
    if (lpOcc->dwTopicID > lpipb->dwMaxTopicId)
    {
        lpipb->dwMaxTopicId = lpOcc->dwTopicID;
    }

    wLen = GETWORD((LPUW)(lstStart = lstWord));
    
    // Save statistical information about the total length of all words
    if (wLen > 2)
        lpipb->dwTotal3bWordLen += wLen; 
    else
        lpipb->dwTotal2bWordLen += wLen;
    lstWord += sizeof(WORD);
    
#ifdef _DEBUG
    if (wLen >= 200)
    {
        strncpy (Buffer, lstWord, 198);
        Buffer[199] = 0;
    }
    else
    {
        strncpy (Buffer, lstWord, wLen);
        Buffer[wLen] = 0;
    }
    // if (STRICMP (Buffer, "erin") == 0)
    //     _asm int 3;
#endif

    // Call the user callback every once in a while
    if (!(lpipb->dwIndexedWord % 65536L)
        && (lpipb->CallbackInfo.dwFlags & ERRFLAG_STATUS))
    {
        PFCALLBACK_MSG pCallbackInfo = &lpipb->CallbackInfo;
        CALLBACKINFO Info;
        HRESULT err;

        Info.dwPhase = 1;
        Info.dwIndex = lpipb->dwIndexedWord;
        err = (*pCallbackInfo->MessageFunc)
            (ERRFLAG_STATUS, pCallbackInfo->pUserData, &Info);
        if (S_OK != err)
            return (err);
    }

SubmitWord:

    // Is this the first word in the tree?
    if (pRoot == NULL)
    {
        if ((pRoot = AddNode (lpipb, lstStart, lpOcc, &errb)) == NULL)
            return (SetErrCode (NULL, E_OUTOFMEMORY));
            
        // Adjust tree data
        pRoot->color = BLACK;
        pRoot->pParent = NULL;
        pIsi->pBalanceTree = pRoot;
        
        // Set statistical info
        lpipb->dwByteCount = GETWORD ((LPUW)pRoot->StringData.pText);
        lpipb->dwMaxFieldId = pRoot->StringData.dwField;
        return (S_OK);
    }

    // Set traversal node to root node 
    pNode = pRoot;

    for (; ; )  // Traverse the tree forever
    {
        int len;                            // Used for string compare block
        LPB lpbWord1, lpbWord2;             // Used for string compare block
        PSTRDATA pString;

        /**********************************************
         *  This section of code does a string compare
         **********************************************/

        lpbWord1 = lstWord;
        pString = &pNode->StringData;
        lpbWord2 = pString->pText;

        // Get the minimum length
        
        if ((result = wLen - GETWORD ((LPUW)lpbWord2)) > 0) 
            len = GETWORD ((LPUW)lpbWord2);
        else 
            len = wLen;

        // Skip the lengths
        
        lpbWord2 += sizeof (WORD);
        
        // Start compare byte per byte
        for (; len > 0; len--, lpbWord1++, lpbWord2++) 
        {
            if (*lpbWord1 != *lpbWord2)
                break;
        }
        if (len != 0) 
            result = *lpbWord1 - *lpbWord2;
            
        
        /**********************************
         * COMPARE FIELDID AND WORD LENGTH
         **********************************/
         
        if (result == 0)
        {
            // If the WordLength and FieldId are the same as the current
            // nodes' then we update the current record
            
            if (fCompareField)
                result = lpOcc->dwFieldId - pString->dwField;
            if (result == 0)
                result = lpOcc->wWordLen - (WORD)pString->dwWordLength;
            if (result == 0)
            {
                if (AddTopic (lpipb, pString, lpOcc) == S_OK)
                    return (S_OK);
                
                // Add failed.  Flush the tree to disk & resubmit word 
                if ((result = FlushTree(lpipb)) == S_OK)
                {
                    pRoot = pIsi->pBalanceTree;
                    goto SubmitWord;
                }
                return (SetErrCode (NULL, (HRESULT)result));
            }
            
            // Fall through in case result is non-zero
        }
        
        // Descend tree or add new node
        if (result < 0)
        {
            if (pNode->pLeft != NULL) 
            {
                pNode = pNode->pLeft;
#ifdef _DEBUGREDBLACK
    iLeft++;
#endif

                continue;
            }
            else 
                ppNode = &pNode->pLeft;
        }
        else
        {
            if (pNode->pRight != NULL) 
            {
                pNode = pNode->pRight;
#ifdef _DEBUGREDBLACK
    iRight++;
#endif
                continue;
            }
            else
                ppNode = &pNode->pRight;
        }
      
#ifdef _DEBUGREDBLACK
   _DPF3("Added node '%s' at left %d, right %d\n", Buffer, iLeft, iRight);
#endif
        
        // Add the new node to the tree
        *ppNode = AddNode (lpipb, lstStart, lpOcc, &errb);
        // If node is NULL we will flush the tree and resubmit the word
        if (*ppNode == NULL)
        {
            if ((result = FlushTree(lpipb)) != S_OK)
                return (result);

            pRoot = pIsi->pBalanceTree;
            ppNode = NULL;
            goto SubmitWord;
        }
        (*ppNode)->pParent = pNode;
        
        // This is the only place that the nodes get balanced
        BalanceTree (pIsi, *ppNode);
#ifdef _DEBUGREDBLACK
        VerifyTree (pIsi->pBalanceTree);
#endif
        return (S_OK);
    }
}


/*************************************************************************
 * @doc  API EXTERNAL INDEXING
 *
 * @func LPDWORD PASCAL FAR | TotalIndexedWord |
 *    Return the total number of words indexed (for statistical purpose
 *    only)
 *
 * @parm LPIPB | lpipb |
 *    Pointer to index parameter block
 *
 * @rdesc   Return pointer to the total number of words indexed
 *************************************************************************/

PUBLIC LPDWORD PASCAL FAR TotalIndexedWord(_LPIPB lpipb)
{
   return (&lpipb->dwUniqueWord);
}


/*************************************************************************
 *
 * @doc  PRIVATE INDEXING
 *
 * @func void NEAR PASCAL | FreeEsi |
 *    Gets rid of all external-sort blocks attached to an IPB.
 *    These blocks are formed into a single linked list
 *    Also closes the file associated with the external sort.
 *
 * @parm _LPIPB | lpipb |
 *    Pointer to index parameter block where all the info is stored
 *
 *************************************************************************/    

PUBLIC VOID FAR PASCAL FreeEsi(_LPIPB lpipb)   
{
    LPESB lpesb;         /* Linked-list walk pointer. */
    LPESB lpesbNext;     /* Next ESB in chain. */
    LPESI lpesi;         /* Pointer to external sort info struct */
    
    /* Get pointer to the ESI block */
    lpesi = &lpipb->esi;
    
    for (lpesb = lpesi->lpesbRoot; lpesb != NULL; lpesb = lpesbNext) 
    {
       /* Get pointer to the next block */
       lpesbNext = lpesb->lpesbNext;

        if (lpesb->hMem)      
        {
            _GLOBALUNLOCK(lpesb->hMem);
            _GLOBALFREE(lpesb->hMem);
        }
       /* Free the block */
       GlobalLockedStructMemFree (lpesb);
    }
    lpesi->lpesbRoot = NULL;   /* No more chain. */
    lpesi->cesb = 0;        /* Everyone freed */

    // Delete the internal sorting result file
    if ((lpipb->idxf & KEEP_TEMP_FILE) == 0)
   	    FileUnlink (NULL, lpipb->isi.aszTempName, REGULAR_FILE);
}


/*************************************************************************
 *
 * @doc  PRIVATE INDEXING
 *
 * @func PBTNODE NEAR PASCAL | AddNode |
 *    Inserts a new node into the tree.
 *
 * @parm _LPIPB | lpipb |
 *    Pointer to index parameter block
 *
 * @parm LST | lpb |
 *    Word being indexed.
 *
 * @parm LPOCC | lpOcc |
 *    Pointer to occurrence data
 *
 * @parm PHRESULT | phr |
 *    Pointer to error structure 
 *
 * @rdesc   Pointer to the newly created node
 *
 * @comm
 *    The nodes parent pointer must be set externally.
 *
 *************************************************************************/

PBTNODE NEAR PASCAL AddNode (_LPIPB lpipb, LST lpbWord,
    LPOCC lpOcc, PHRESULT phr)
{
    // Local replacement variables
    LPV pDataBlock = lpipb->pDataBlock; // Pointer to Block Manager
    int occf = lpipb->occf;

    // Working variables
    PBTNODE    pNode;               // This will point to the new node
    PSTRDATA   pString;             // Pointer to string block
    PTOPICDATA pTopic;              // Pointer to topic block
    POCCDATA   pOcc;
    LPDW       lpDw;

    // Create space for new node & topic & occ & copy the string
#if 0
    if ((pNode = (PBTNODE)GetBlockNode (&lpipb->BTNodeBlock)) == NULL ||
        (pTopic = (PTOPICDATA)GetBlockNode (&lpipb->TopicBlock)) == NULL ||
#else
    if ((pNode = (PBTNODE)BlockGetBlock(pDataBlock, sizeof(BTNODE))) == NULL ||
        (pTopic = (PTOPICDATA)BlockGetBlock (pDataBlock, sizeof(TOPICDATA))) == NULL ||
#endif
        (pNode->StringData.pText = (LPB)BlockCopy (lpipb->pDataBlock,
            lpbWord, GETWORD((LPUW)lpbWord) + sizeof (SHORT), 0)) == NULL)
    {
        return (NULL);
    }

    pString = &pNode->StringData;
    /* Initialize all the fields */
    // Node Information. Parent field is set outside of this function

    pNode->pLeft = pNode->pRight = NULL;
    pNode->color = RED;
    
    /* Set the string fields */
    pString->pTopic = pString->pLastTopic = pTopic;       
    pString->dwTopicCount = 1;

    // It doesn't hurt to copy the data even if we don't use it
    // It also saves a compare just to set it
    pString->dwField = lpOcc->dwFieldId;
    pString->dwWordLength = lpOcc->wWordLen;
    
    // Set the topic fields data
    pTopic->pNext = NULL;
    pTopic->dwTopicId = lpOcc->dwTopicID;
    
    if (occf & (OCCF_COUNT | OCCF_OFFSET))
    {
#if 1
        if ((pOcc = (POCCDATA)BlockGetBlock (pDataBlock,
            sizeof(OCCDATA) * lpipb->ucNumOccDataFields)) == NULL)
            return(NULL);
#else
        if ((pOcc = (POCCDATA)GetBlockNode (&lpipb->OccBlock)) == NULL )
            return(NULL);
#endif
            
        // Set the occ fields
        pOcc->pNext = NULL;
        
        // Generate occ data block
        lpDw = pOcc->OccData;
        if (occf & OCCF_COUNT) 
            *lpDw++ = lpOcc->dwCount;
        if (occf & OCCF_OFFSET) 
            *lpDw = lpOcc->dwOffset;
        pTopic->pLastOccData = pTopic->pOccData = pOcc;
        pTopic->dwOccCount = 1;
    }
    else 
    {
        pTopic->pLastOccData = pTopic->pOccData = NULL;
        pTopic->dwOccCount = 0;
    }

    // Set Statistical information
    if (lpipb->dwMaxWLen < GETWORD ((LPUW)pString->pText))
        lpipb->dwMaxWLen = GETWORD ((LPUW)pString->pText);
    if (lpipb->dwMaxFieldId < pString->dwField)
        lpipb->dwMaxFieldId = pString->dwField;
    lpipb->dwUniqueWord++;
    lpipb->dwByteCount += GETWORD ((LPUW)pString->pText);

    return (pNode);
}


/*************************************************************************
 *
 * @doc  PRIVATE INDEXING
 *
 * @func int FAR PASCAL | CompareOccurrence |
 *    Compares two Occurrence data pointers starting from the first 
 *    element and continuing until the elements are unequal. 
 *
 * @parm LPB | lpStr1 |
 *    Pointer to the first Occurence to compare
 *
 * @parm LPB | pOcc2 |
 *    Pointer to the second Occurence to compare
 *
 * @parm int | max |
 *    The number of occurrence fields to compare
 *
 * @rdesc
 *      negative value : If pOcc1 is less than pOcc2
 *      0              : if pOcc1 is equal to pOcc2
 *      positive value : If pOcc1 is greater than pOcc2
 *
 * @comm
 *      The use of switch statment is for speed since this function is
 *      called for so many times
 *************************************************************************/

int FAR PASCAL CompareOccurrence (LPDW pOcc1, LPDW pOcc2, int max)
{
    int result;

    switch (max)
    {
        case 5:
            if (result = (int)(*pOcc1 - *pOcc2))
                return (result);
            pOcc1++;
            pOcc2++;
        case 4:
            if (result = (int)(*pOcc1 - *pOcc2))
                return (result);
            pOcc1++;
            pOcc2++;
        case 3:
            if (result = (int)(*pOcc1 - *pOcc2))
                return (result);
            pOcc1++;
            pOcc2++;
        case 2:
            if (result = (int)(*pOcc1 - *pOcc2))
                return (result);
            pOcc1++;
            pOcc2++;
        case 1:
            return ((int)(*pOcc1 - *pOcc2));

        default:
            // This can only an error, since we knows that max
            // can never be > 5
            return (0);
            
    }
}


/*************************************************************************
 *
 * @doc  INTERNAL INDEXING
 *
 * @func HRESULT | AddTopic |
 *    Inserts a new topic into a nodes topic list or a new occurrence
 *    if a topic with the same TopicId already exists.
 *
 * @parm _LPIPB | lpipb |
 *    Pointer to index parameter block
 *
 * @parm PSTRDATA | pString |
 *    Pointer to node structure
 *
 * @parm LPOCC | lpOcc |
 *    Pointer occurrence data
 *
 * @rdesc   S_OK, or errors if failed
 *
 *************************************************************************/

HRESULT NEAR PASCAL AddTopic (_LPIPB lpipb, PSTRDATA pString, LPOCC lpOcc)
{
    // Local replacement variables
    LPV pDataBlock = lpipb->pDataBlock;
    int  occf = lpipb->occf;
    DWORD dwNewTopicId = lpOcc->dwTopicID;
    POCCDATA pOcc;

    // Working variables
//    int topicCount;                     // Iterates through current topics
    PTOPICDATA pTopic, pPrevTopic;
    LPDW lpDw;
    int fResult;
    
    /* Set up a new occurrence block */
    if (occf & (OCCF_COUNT | OCCF_OFFSET))
    {
        if ((pOcc = (POCCDATA)BlockGetBlock (pDataBlock,
            sizeof(OCCDATA) * lpipb->ucNumOccDataFields)) == NULL)
            return (E_OUTOFMEMORY);

        lpDw = pOcc->OccData;
        if (occf & OCCF_COUNT) 
            *lpDw++ = lpOcc->dwCount;
        if (occf & OCCF_OFFSET) 
            *lpDw = lpOcc->dwOffset;
        pOcc->pNext = NULL;
    }
    else
        pOcc = NULL;
        
    // Check from last point of insertion 
    pTopic = pString->pLastTopic;

    if (pTopic->dwTopicId == dwNewTopicId)
    {
append_occ_info:
        // Match. We don't have to do anything. That's is the majority
        // of the case. Just add the occdata to the end
        if (pOcc)
        {
            pTopic->pLastOccData->pNext = pOcc;
            pTopic->pLastOccData = pOcc;
            pTopic->dwOccCount++;
        }
        goto Update;
    }

    if (pTopic->dwTopicId < dwNewTopicId)
    {
		// kevynct: scan ahead to insertion point.  Usually with sorted lists
		// this won't be far at all.		
		pPrevTopic = pTopic;
		if (pTopic->pNext)
		{
			for (; (fResult = pTopic->dwTopicId - dwNewTopicId) < 0 && pTopic->pNext;
				pPrevTopic = pTopic, pTopic = pTopic->pNext)
					; // empty loop!

			if (fResult == 0)
			{
				pString->pLastTopic = pTopic;
				goto append_occ_info;
			}
		}

        if ((pTopic = (PTOPICDATA)BlockGetBlock (pDataBlock,
            sizeof(TOPICDATA))) == NULL)
            return (E_OUTOFMEMORY);

        // Set the topic fields data    
        if (pOcc) 
        {
            pTopic->pLastOccData = pTopic->pOccData = pOcc;
            pTopic->dwOccCount = 1;
        }
        else
        {
            pTopic->pLastOccData = pTopic->pOccData = NULL;
            pTopic->dwOccCount = 0;
        }

        pTopic->dwTopicId = dwNewTopicId;

insert_middle_or_end:
        // Add to middle or end of list
        pTopic->pNext = pPrevTopic->pNext;
        pPrevTopic->pNext = pTopic;
        pString->dwTopicCount++;

        pString->pLastTopic = pTopic;
        goto Update;
    
    }
    
    // It means that topics are not inserted
    // in order. It can only happen if somebody is using the
    // indexer for some special, non-topic related index build

    // Move to the right node
    pPrevTopic = NULL;
    for (pTopic = pString->pTopic;
        (fResult = pTopic->dwTopicId - dwNewTopicId) < 0 && pTopic->pNext;
        pPrevTopic = pTopic, pTopic = pTopic->pNext);
    
    if (fResult == 0)
    {
        // Match. Just add the occdata to the end
        if (pOcc) 
        {
            pTopic->pLastOccData->pNext = pOcc;
            pTopic->pLastOccData = pOcc;
            pTopic->dwOccCount++;
        }
    }
    else
    {
        // A new topic node is needed
        if ((pTopic = (PTOPICDATA)BlockGetBlock (pDataBlock,
            sizeof(TOPICDATA))) == NULL)
            return (E_OUTOFMEMORY);

        // Set the topic fields data
    
        if (pOcc)
        {
            pTopic->pLastOccData = pTopic->pOccData = pOcc;
            pTopic->dwOccCount = 1;
        }
        else
        {
            pTopic->pLastOccData = pTopic->pOccData = NULL;
            pTopic->dwOccCount = 0;
        }
		pTopic->dwTopicId = dwNewTopicId;

        // Add to the beginning if empty
        if (pPrevTopic == NULL)
        {
            // Add to the beginning
            pTopic->pNext = pString->pTopic;
            pString->pTopic = pTopic;
            pString->dwTopicCount++;

			pString->pLastTopic = pTopic;
            goto Update;
        }

		goto insert_middle_or_end;
    }

Update:
    // Update statistical information
    if (lpipb->dwMaxWCount < lpOcc->dwCount)
        lpipb->dwMaxWCount = lpOcc->dwCount;
    if (lpipb->dwMaxOffset < lpOcc->dwOffset)
        lpipb->dwMaxOffset = lpOcc->dwOffset;

    return S_OK;
}


/*************************************************************************
 *
 * @doc  INTERNAL INDEXING
 *
 * @func int | StrCmp2BytePascal |
 *    Compares two Pascal style strings against eachother.
 *      The strings must have a 2 byte length field, *NOT* 1 byte.
 *
 * @parm LPB | lpStr1 |
 *    Pointer to string one
 *
 * @parm LPB | lpStr2 |
 *    Pointer to string two
 *
 * @rdesc
 *      negative value : If pOcc1 is less than pOcc2
 *      0              : if pOcc1 is equal to pOcc2
 *      positive value : If pOcc1 is greater than pOcc2
 *
 *************************************************************************/

int FAR PASCAL StrCmp2BytePascal(LPB lpStr1, LPB lpStr2)
{
    int fRet;
    int register len;

    // Get the minimum length
    if ((fRet = GETWORD ((LPUW)lpStr1) - GETWORD ((LPUW)lpStr2)) > 0) 
        len = GETWORD ((LPUW)lpStr2);
    else 
        len = GETWORD ((LPUW)lpStr1);

    // Skip the lengths */
    lpStr1 += sizeof (SHORT);
    lpStr2 += sizeof (SHORT);

    // Start compare byte per byte */
    for (; len > 0; len--, lpStr1++, lpStr2++) 
    {
        if (*lpStr1 != *lpStr2)
            break;
    }

    if (len == 0) 
        return (fRet);
    return (*lpStr1 - *lpStr2);
}


/*************************************************************************
 *
 * @doc  INTERNAL INDEXING
 *
 * @func HRESULT | FlushTree |
 *    Flushes the tree to disk.
 *
 * @parm _LPIPB | lpipb |
 *    Pointer to index parameter block
 *
 * @rdesc   S_OK, or errors if failed
 *
 * @comm
 *    This function holds the output file open until the tree has been
 *    completely written to disk.  The physical offset of the written
 *    data is stored in the ESB blocks so that the word can be merged 
 *    in the next index phase.
 *
 *************************************************************************/
PUBLIC HRESULT FAR PASCAL FlushTree(_LPIPB lpipb)
{
    // Local replacement variables
    LPISI pIsi = &lpipb->isi;
    LPESI pEsi = &lpipb->esi;
    PBTNODE pBalanceTree = pIsi->pBalanceTree;
    ERRB    errb;
    PHRESULT  phr = &errb;

    // Local working variables
    LPESB   pNewEsb;
    HRESULT     fRet;

    // Make sure that the tree actually has nodes
    if (pBalanceTree == NULL)
        return (S_OK);

    // Open output file & clear working variables
    if (pIsi->hfpb == NULL) 
    {                                        
        // Allocate output buffer   
        if ((pIsi->hSortBuffer = _GLOBALALLOC
            (DLLGMEM_ZEROINIT, ISBUFFER_SIZE)) == NULL)
            return (E_OUTOFMEMORY);
        pIsi->pSortBuffer = (LPB)_GLOBALLOCK (pIsi->hSortBuffer);

        // Get temp filename & open file
        GETTEMPFILENAME ((char)0, (LPB)"iso", (WORD)0, pIsi->aszTempName);
        if ((pIsi->hfpb = FileOpen (NULL, pIsi->aszTempName, 
            REGULAR_FILE, READ_WRITE, phr)) == NULL)
            return (*phr);
      
        pIsi->dwRecLength = 0;
        pEsi->cesb = 0;      
    }

    // Allocate new ESB structure & set starting values
    if ((pNewEsb = GlobalLockedStructMemAlloc (sizeof (ESB))) == NULL)
        return (E_OUTOFMEMORY);
        
    
    // Remember the starting offset
    pNewEsb->lfo = pIsi->lfo;

    // Reset the current insertion point
    pIsi->pCurPtr = pIsi->pSortBuffer;
    
    // Actually ouput the tree data
    if ((fRet = TraverseWrite(lpipb, pBalanceTree, 0)) != S_OK)
        return (fRet);
        
    // Flush remaining buffer to disk
    if ((fRet = WriteBuffer(lpipb, pIsi->pCurPtr)) != S_OK)
        return(fRet);

    // Set the ESB maximum record length
    pNewEsb->dwEsbSize = pIsi->dwMaxEsbRecSize;
    pIsi->dwMaxEsbRecSize = 0;
   
    // Store end offset in list
    pNewEsb->lfoMax = pIsi->lfo;
    
    // Update the fileoffset
    pIsi->lfo = pNewEsb->lfoMax;
    
    if (pEsi->lpesbRoot == NULL)
        pNewEsb->lpesbNext = NULL;
    else
        pNewEsb->lpesbNext = pEsi->lpesbRoot;
    pEsi->lpesbRoot = pNewEsb;
    pEsi->cesb++;

    // Reset tree heap & root node
    BlockReset (lpipb->pDataBlock);
    
    BlockReset (lpipb->BTNodeBlock.pBlockMgr);
    lpipb->BTNodeBlock.pFreeList =
        (PLIST)BlockGetLinkedList(lpipb->BTNodeBlock.pBlockMgr);
        
    BlockReset (lpipb->TopicBlock.pBlockMgr);
    lpipb->TopicBlock.pFreeList =
        (PLIST)BlockGetLinkedList(lpipb->TopicBlock.pBlockMgr);
        
    BlockReset (lpipb->OccBlock.pBlockMgr);
    lpipb->OccBlock.pFreeList =
        (PLIST)BlockGetLinkedList(lpipb->OccBlock.pBlockMgr);
    pIsi->pBalanceTree = NULL;

    return (S_OK);
}

/*************************************************************************
 *
 * @doc  INTERNAL INDEXING
 *
 * @func HRESULT | WriteBuffer |
 *      Physically writes buffer to disk. This will write from the beginning
 *      of the sort buffer to pStartRec. It then copies whatever left
 *      in the sort buffer back to the beginning of it
 *
 * @parm _LPIPB | lpipb |
 *      Pointer to index parameter block
 *
 * @parm LPB | copyEnd |
 *      Pointer to the end of the next block of data to copy
 *
 * @rdesc  S_OK or errors
 *************************************************************************/   

HRESULT NEAR PASCAL WriteBuffer (_LPIPB lpipb, LPB copyEnd)
{
    // Local replacement variables
    LPISI pIsi = &lpipb->isi;
    LPB   pSortBuffer;
    ERRB  errb;
    PHRESULT phr = &errb;

    DWORD cbWritten;    // Number of bytes to write to disk (bytes)
    DWORD cbCopied;      // Size of extra data to move to buffers front
    LPB   copyStart;

    
    pSortBuffer = (LPB)pIsi->pSortBuffer; 

    // Find what should be left in the buffer.
    // copyStart will pointer to the beginning of data to be recopied, ie.
    // the beginning of a record
    //   - if pIsi->pStartRec == -1 : there is no beginning of record
    //     so we have nothing to recopy
    //   - if pIsi->pStartRec == pSortBuffer, again the whole thing is
    //     to be written out, and there is nothing to recopy
    
    if ((copyStart = pIsi->pStartRec) == (LPB)-1 || copyStart == pSortBuffer)
        copyStart = copyEnd;
        
    if ((cbWritten = (DWORD)(copyStart - pSortBuffer)) == 0)
        return(S_OK);    // Nothing to copy
        
    cbCopied = (DWORD)(copyEnd - copyStart);

    // Update backpatching data
    if (pIsi->pStartRec == pSortBuffer)
    {
        pIsi->pStartRec = (LPB)-1; // The pointer is invalid
        pIsi->lfoRecBackPatch = pIsi->lfo; // Remember the place for backpatch
    }

    // Write the buffer to disk
    if (cbWritten != (DWORD)
        FileWrite(pIsi->hfpb, pSortBuffer, cbWritten, phr))
    {
        return (*phr);
    }
    pIsi->lfo = FoAddDw (pIsi->lfo, cbWritten);
    
    // Only copy if extra data exists
    if (cbCopied)
    {
        MEMMOVE(pSortBuffer, copyStart, cbCopied);
        if (pIsi->pStartRec == copyStart)
            pIsi->pStartRec = pSortBuffer;
    }
        
    // Reset pStartRec & pCurPtr
    pIsi->pCurPtr = pSortBuffer + cbCopied;
    return S_OK;
}


/*************************************************************************
 *
 * @doc  INTERNAL INDEXING
 *
 * @func HRESULT | TraverseWrite |
 *    Copies the node data to the output buffer.
 *
 * @parm _LPIPB | lpipb |
 *    Pointer to index parameter block
 *
 * @parm PBTNODE | node |
 *    Node to copy to buffer
 *
 * @parm   LPB | pBuffer |
 *    Buffer to copy node into
 *
 * @parm   int | Level |
 *    Current tree level (starting with 1)
 *
 * @rdesc   S_OK, or errors if failed
 *
 * @comm
 *    This is currently a recursive routine.  It should probably be
 *    changed to be non-recursive to save on speed at run-time.
 *
 *************************************************************************/

HRESULT NEAR PASCAL TraverseWrite (_LPIPB lpipb, PBTNODE node, int Level)
{
    // Local replacement pointers
    PSTRDATA pString = &node->StringData;
    LPISI    pIsi = &lpipb->isi;        // Internal sort information
    LPB      pText = pString->pText;    // The word string
    POCCDATA pOccData;
    WORD     ucNumOccDataFields = lpipb->ucNumOccDataFields;
    PTOPICDATA pTopic = pString->pTopic;
    ERRB     errb;
    PHRESULT   phr = &errb;

    // Working variables
    DWORD topicLoop, occLoop;           // Loop counters
    WORD wLength;                       // DWORD aligned length of string
    BYTE filledBuffer = 0;              // Count if record fills entire buffer
    LPB pBaseBuffer;                    // Start of entire buffer
    LPB pCurPtr;
    LPB pMaxPtr;
    HRESULT fRet;

    // Keep track of how deep the tree is
    if (Level > pIsi->DeepLevel)
        pIsi->DeepLevel = (BYTE) Level;

#ifdef _DEBUG
    if (Level >= 65)
    {   // This would be a HUGE tree!
        return SetErrCode (phr, E_ASSERT);
    }
#endif
    
    // Traverse the left sub tree
    if (node->pLeft != NULL) 
    {
       if ((fRet = TraverseWrite(lpipb, node->pLeft, Level + 1)) != S_OK)
           return(fRet);
    }

    /* Initialize */
    pBaseBuffer = (LPB)pIsi->pSortBuffer;
    pMaxPtr = pBaseBuffer + ISBUFFER_SIZE - sizeof(DWORD); // Leave some room
    pCurPtr = pIsi->pCurPtr;          // Get starting point
    
    // Reset the record length field
    pIsi->dwRecLength = 0;

    // Get the Pascal string length
    wLength = GETWORD ((LPUW)pText) + sizeof (SHORT);
	//wLength = (wLength + 3) & (~3);
    
    // Check for minimum room
    if (pMaxPtr <= pCurPtr + wLength + // String length
        sizeof (DWORD) + // Record length
        sizeof (DWORD) + // FieldId
        sizeof (WORD)  + // Word length
        sizeof (DWORD) ) // TopicCount
    {
        if ((fRet = WriteBuffer (lpipb, pCurPtr)) != S_OK)
            return fRet;
        pCurPtr = pIsi->pCurPtr;          // Reset insertion point
    }
    
    // Remember record length position  to be backpatched
    pIsi->pStartRec = pCurPtr;
    pCurPtr += sizeof (DWORD);

    MEMCPY(pCurPtr, pText, wLength);
    pCurPtr += wLength; // Add aligned offset
   
    // Copy the Word Length only if flag is set
    if (lpipb->occf & OCCF_LENGTH)
        pCurPtr += CbBytePack (pCurPtr, pString->dwWordLength);

    // Copy FieldId only if flag is set
    if (lpipb->occf & OCCF_FIELDID)
        pCurPtr += CbBytePack (pCurPtr, pString->dwField);

    // Topic Count
    if (lpipb->occf & OCCF_TOPICID)
        pCurPtr += CbBytePack (pCurPtr, pString->dwTopicCount);
    else
        pString->dwTopicCount = 0;

    // Add in all topics
    for (topicLoop = pString->dwTopicCount; topicLoop > 0; --topicLoop)
    {
        // Check buffer overflow
        if (pMaxPtr <= pCurPtr + sizeof (DWORD) // TopicId
            + sizeof (DWORD))        // Occurrence count
        {
            pIsi->dwRecLength += (DWORD)(pCurPtr - pIsi->pCurPtr);
            if ((fRet = WriteBuffer (lpipb, pCurPtr)) != S_OK)
                return fRet;
            pCurPtr = pIsi->pCurPtr;          // Reset insertion point
        }
        pCurPtr += CbBytePack (pCurPtr, pTopic->dwTopicId);
        
        if (occLoop = pTopic->dwOccCount)
        {
            
            pCurPtr += CbBytePack (pCurPtr, pTopic->dwOccCount);
            pOccData = pTopic->pOccData;

            // Add in all occurrence data
            for (occLoop = pTopic->dwOccCount; occLoop > 0; --occLoop)
            {
                LPDW lpDw;
                
                // Check buffer overflow
                if (pMaxPtr <= pCurPtr + MAX_OCCDATA * sizeof (DWORD))
                {
                    pIsi->dwRecLength += (DWORD)(pCurPtr - pIsi->pCurPtr);
                    if ((fRet = WriteBuffer (lpipb, pCurPtr)) != S_OK)
                        return fRet;
                    pCurPtr = pIsi->pCurPtr;          // Reset insertion point
                }
                
                lpDw = (LPDW)pOccData->OccData; 
                switch (ucNumOccDataFields)
                {
                    case 5:
                        pCurPtr += CbBytePack (pCurPtr, *lpDw++);
                    case 4:
                        pCurPtr += CbBytePack (pCurPtr, *lpDw++);
                    case 3:
                        pCurPtr += CbBytePack (pCurPtr, *lpDw++);
                    case 2:
                        pCurPtr += CbBytePack (pCurPtr, *lpDw++);
                    case 1:
                        pCurPtr += CbBytePack (pCurPtr, *lpDw++);
                }
                pOccData = pOccData->pNext;
            }
        }
        pTopic = pTopic->pNext;
    }

    // Update the record length
    pIsi->dwRecLength += (DWORD)(pCurPtr - pIsi->pCurPtr);
        
    // Keep track of the maximum record size for merging. 
    // - 1 for the current ESB. This helps speeding up the merging sequence
    //   since we don't have to worry about a record being split
    
    if (pIsi->dwRecLength > pIsi->dwMaxEsbRecSize)
        pIsi->dwMaxEsbRecSize = pIsi->dwRecLength;
        
    // Set record length
    if (pIsi->pStartRec != (LPB)-1)
    {
        // Everything is still in memory
        *(LPUL)pIsi->pStartRec = pIsi->dwRecLength;
    }
    else
    {
        // We have to do backpatching
        if (sizeof (DWORD) != FileSeekWrite (pIsi->hfpb, &pIsi->dwRecLength,
            pIsi->lfoRecBackPatch, sizeof (DWORD), phr))
            return *phr;
        FileSeek (lpipb->isi.hfpb, pIsi->lfo, 0, phr);
    }

    // Update the current insertion point, and prepare for the next record
    pIsi->pStartRec = pIsi->pCurPtr = pCurPtr;
    
    if (node->pRight != NULL)
        return TraverseWrite(lpipb, node->pRight, Level + 1);
    return(S_OK);
}



/*************************************************************************
 *
 *  @doc    INTERNAL INDEXING
 *
 *  @func   VOID NEAR PASCAL | BalanceTree |
 *      Balances the tree using a Red/Black algorithm.
 *
 *  @parm   LPISI | pIsi |
 *      Pointer to Internal sort data
 *
 *  @parm   PBTNODE | node |
 *      Pointer to the node that was just inserted
 *
 *  @comm
 *      This routine must be called after EVERY new node is inserted in
 *      the tree to maintain proper balance.
 *      A Red/Black tree must maintain the following conditions:
 *          Every node is colored either red or black
 *          Every leaf node must be black
 *          If a node is red, then both of its children must be black
 *          Every path from the root to a leaf must contain the same
 *              number of black nodes
 *
 *************************************************************************/
void NEAR PASCAL BalanceTree(LPISI pIsi, PBTNODE node)
{
    PBTNODE y;
    PBTNODE pParentNode;
    
    node->color = RED;
    while (node != pIsi->pBalanceTree && node->pParent->color == RED)
    {
        pParentNode = node->pParent;
        
        if (pParentNode != NULL && pParentNode->pParent != NULL &&
            pParentNode == pParentNode->pParent->pLeft)
        {
            y = pParentNode->pParent->pRight;
            if (y != NULL && y->color == RED)
            {
                pParentNode->color = BLACK;
                y->color = BLACK;
                pParentNode->pParent->color = RED;
                node = pParentNode->pParent;
                pParentNode = node->pParent;
            }
            else 
            {
                if (node == pParentNode->pRight)
                {
                    node = pParentNode;
                    // LeftRotate change the parent node
                    LeftRotate(pIsi, node);
                    pParentNode = node->pParent;
                }
                pParentNode->color = BLACK;
                pParentNode->pParent->color = RED;
                // RightRotate change the parent node
                RightRotate(pIsi, pParentNode);
                pParentNode = node->pParent;
            }
        } 
        else
        {
            if (pParentNode != NULL && pParentNode->pParent != NULL)
                y = pParentNode->pParent->pLeft;
            else
                y = NULL;
            if (y != NULL && y->color == RED)
            {
                pParentNode->color = BLACK;
                y->color = BLACK;
                pParentNode->pParent->color = RED;
                node = pParentNode->pParent;
                pParentNode = node->pParent;
            } 
            else
            {  
                if (node == pParentNode->pLeft)
                {
                    // RightRotate change the parent node
                    RightRotate(pIsi, node);
                    node->color = BLACK;
                    node = node->pRight;
                    pParentNode = node->pParent;
                }                                                                              
                pParentNode->color = BLACK;
                pParentNode->pParent->color = RED;
                
                // LeftRotste change the parent node
                LeftRotate(pIsi, pParentNode->pParent);
                pParentNode = node->pParent;
            }
        }
    }
    pIsi->pBalanceTree->color = BLACK;
}


/*************************************************************************
 *
 * @doc  INTERNAL INDEXING
 *
 * @func VOID NEAR PASCAL | LeftRotate |
 *    Rotates two nodes in the tree.
 *
 * @parm _LPIPB | lpipb |
 *    Pointer to index parameter block
 *
 * @parm   PBTNODE | node |
 *    The X node to process  (see notes)
 *
 * @comm
 *                     
 *    X               Y
 *   / \             / \
 *  a   Y    --->    X  c
 *     / \          / \
 *    b  c         a   b
 *************************************************************************/

void NEAR PASCAL LeftRotate(LPISI pIsi, PBTNODE node)
{
   PBTNODE y = node->pRight;

   node->pRight = y->pLeft;
   if (y->pLeft != NULL)
      y->pLeft->pParent = node;
   y->pParent = node->pParent;
   if (y->pParent == NULL)
      pIsi->pBalanceTree = y;
   else 
   {
      if (node == node->pParent->pLeft)
         node->pParent->pLeft = y;
      else
         node->pParent->pRight = y;
   }
   y->pLeft = node;
   node->pParent = y;
}


/*************************************************************************
 *
 * @doc  INTERNAL INDEXING
 *
 * @func VOID NEAR PASCAL | RightRotate |
 *    Rotates two nodes in the tree.
 *
 * @parm _LPIPB | lpipb |
 *    Pointer to index parameter block
 *
 * @parm   PBTNODE | node |
 *    The X node to process  (see notes)
 *
 * @comm
 *                      
 *     Y               X
 *    / \             / \
 *   X   c   --->    a   Y
 *  / \             / \
 * a  b            b  c
 *************************************************************************/

void NEAR PASCAL RightRotate(LPISI pIsi, PBTNODE node)
{
   PBTNODE y = node->pParent;

   y->pLeft = node->pRight;
   if (y->pLeft != NULL)
      y->pLeft->pParent = y;

   node->pParent = y->pParent;
   if (node->pParent == NULL)
      pIsi->pBalanceTree = node;
   else 
   {
      if (y == node->pParent->pLeft)
         node->pParent->pLeft = node;
      else
         node->pParent->pRight = node;
   }
   node->pRight = y;
   y->pParent = node;
}

/************************************************************************
 *  @doc    PRIVATE
 *  @func   HRESULT PASCAL NEAR | IndexBlockAllocate |
 *      Set the memory allocation based on the memory of the machine
 *  @parm   DWORD | dwmemSize |
 *      Memory allocated for the indexer
 *  @rdesc  S_OK, or E_OUTOFMEMORY
 ************************************************************************/

PRIVATE HRESULT PASCAL NEAR IndexBlockAllocate (_LPIPB lpipb, LONG lMemSize)
{
        
    if ((lpipb->pDataBlock =  BlockInitiate (MAX_BLOCK_SIZE, 0,
        (WORD)(lMemSize/MAX_BLOCK_SIZE), USE_VIRTUAL_MEMORY)) == NULL) 
        return(E_OUTOFMEMORY);
    return(S_OK);
}

#ifdef _DEBUGREDBLACK
/*
 *  @comm
 *      This routine must be called after EVERY new node is inserted in
 *      the tree to maintain proper balance.
 *      A Red/Black tree must maintain the following conditions:
 *          Every node is colored either red or black
 *          Every leaf node must be black
 *          If a node is red, then both of its children must be black
 *          Every path from the root to a leaf must contain the same
 *              number of black nodes
*/
void PreOrdTrav (PBTNODE pNode, int iLevel, char cChildType)
{
    if (pNode == NULL)
    {
        OutputDebugString ("*\n");
        return;
    }

    _DPF4 ("Chl: %c Col: %c Lev: %d\n", cChildType,
        pNode->color == RED ? 'R' : 'B', iLevel);

    iLevel++;
    PreOrdTrav (pNode->pLeft, iLevel, 'L');
    PreOrdTrav (pNode->pRight, iLevel, 'R');
}

void NEAR PASCAL VerifyTree (PBTNODE pRoot)
{

    PreOrdTrav (pRoot, 0, 'R');
    OutputDebugString ("End Tree\n");

}
#endif /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\delete.c ===
#include <mvopsys.h>
#include <mem.h>
#include <orkin.h>
#include <mvsearch.h>
#include "common.h"
#include "index.h"

#ifdef _DEBUG
static BYTE NEAR s_aszModule[] = __FILE__;	/* Used by error return functions.*/
#endif


extern FDECODE DecodeTable[];
extern DWORD argdwBits[];

typedef VOID (PASCAL NEAR *ENCODEDWORD) (PNODEINFO, DWORD, int);
PRIVATE VOID PASCAL NEAR EmitBitStreamDWord (PNODEINFO, DWORD, int);
PRIVATE VOID PASCAL NEAR EmitFixedDWord (PNODEINFO, DWORD, int);
PRIVATE VOID PASCAL NEAR EmitBellDWord (PNODEINFO, DWORD, int);

static ENCODEDWORD EncodeTable[] =
{
	EmitBitStreamDWord,
	EmitFixedDWord,
	EmitBellDWord,
	NULL,
};

#define EmitDword(p,dw,key) EncodeTable[(key).cschScheme]((p), (dw), (key).ucCenter)
#define FGetDword(a,b,c) (*DecodeTable[b.cschScheme])(a, b, c)

/*************************************************************************
 *
 *                    INTERNAL PRIVATE FUNCTIONS
 *
 *  All of them should be declared near
 *
 *************************************************************************/
PRIVATE int PASCAL NEAR TraverseLeafNode (_LPIPB, PNODEINFO,
    DWORD FAR *, DWORD);
PRIVATE int PASCAL NEAR DeleteTopicFromData (_LPIPB lpipb,
    FILEOFFSET dataOffset, DWORD FAR *, DWORD,
    LPDW pTopicIdArray, DWORD dwArraySize);
VOID PRIVATE PASCAL NEAR RemapData (_LPIPB, PNODEINFO, PNODEINFO,
    DWORD, DWORD);
VOID PRIVATE PASCAL NEAR EmitBits (PNODEINFO pNode, DWORD dwVal, BYTE cBits);
PRIVATE VOID PASCAL NEAR EmitBool (PNODEINFO pNode, BOOL fVal);

PUBLIC LONG PASCAL FAR CompareDWord (DWORD, DWORD, LPV lpParm);

/*************************************************************************
 *	@doc	API
 *  @func   HRESULT FAR PASCAL | MVIndexTopicDelete |
 *      Delete topics from an index
 *  @parm   HFPB | hSysFile |
 *      Handle to an opened system file, maybe NULL
 *  @parm   _LPIPB | lpipb |
 *      Pointer to index info. This structure is obtained through
 *      IndexInitiate()
 *  @parm   SZ | szIndexName |
 *      Name of the index. If hSysFile is NULL, this is a regular DOS file
 *      else it is a subfile of hSysFile
 *  @parm   DWORD FAR * | rgTopicId |
 *      Array of topic ids to be deleted from the index
 *  @parm   DWORD | dwCount |
 *      Number of elements in the array
 *  @rdesc  S_OK, or other errors
 *************************************************************************/
HRESULT PUBLIC EXPORT_API FAR PASCAL MVIndexTopicDelete (HFPB hSysFile,
    _LPIPB lpipb, SZ szIndexName, DWORD FAR * rgTopicId, DWORD dwCount)
{
    PNODEINFO pNodeInfo;
    int fRet;
    int cLevel;
    int cMaxLevel;
    WORD wLen;
    LPB pCur;
    
    if (lpipb == NULL || rgTopicId == NULL || dwCount == 0)
        return(E_INVALIDARG);
        
    // Set the bState
    lpipb->bState = DELETING_STATE;
        
    // Open the index file
    if ((fRet = IndexOpenRW(lpipb, hSysFile, szIndexName)) != S_OK)
    {
exit00:
        if (lpipb->idxf & IDXF_NORMALIZE)
        {
            FreeHandle (lpipb->wi.hSigma);
            FreeHandle (lpipb->wi.hLog);
            lpipb->wi.hSigma = lpipb->wi.hLog = NULL;
        }

        return(fRet);
    }
    
    // Allocate buffer
    if ((pNodeInfo = AllocBTreeNode (lpipb)) == NULL)
    {
        fRet = E_OUTOFMEMORY;
exit0:
        FileClose(lpipb->hfpbIdxFile);
        FreeBTreeNode (pNodeInfo);

        goto exit00;
    }
        
    if ((lpipb->hTmpBuf = _GLOBALALLOC (DLLGMEM_ZEROINIT,
        lpipb->BTreeData.Header.dwMaxWLen * 2)) == NULL)
        goto exit0;
    
    lpipb->pTmpBuf = (LPB)_GLOBALLOCK (lpipb->hTmpBuf);
    
    if (((lpipb->pIndexDataNode = 
        AllocBTreeNode (lpipb))) == NULL)    
    {
        fRet = E_OUTOFMEMORY;
exit1:
        _GLOBALUNLOCK(lpipb->hTmpBuf);
        _GLOBALFREE(lpipb->hTmpBuf);
        lpipb->hTmpBuf = NULL;
        goto exit0;
    }
        
    pNodeInfo->nodeOffset = lpipb->BTreeData.Header.foIdxRoot;
    cMaxLevel = lpipb->BTreeData.Header.cIdxLevels - 1;
    
    // Sort the incoming array
    if ((fRet = HugeDataSort((LPV HUGE*)rgTopicId, dwCount,
    	(FCOMPARE)CompareDWord, NULL, NULL, NULL)) != S_OK)
        goto exit1;
        
    // Move down the tree, based on the first offset of the block
    for (cLevel = 0; cLevel < cMaxLevel; cLevel++)
    {
        if ((fRet = ReadNewNode(lpipb->hfpbIdxFile, pNodeInfo,
            FALSE)) != S_OK)
        {
            _GLOBALUNLOCK(lpipb->hData);
            _GLOBALFREE(lpipb->hData);
            lpipb->hData = NULL;
exit2:
            FreeBTreeNode (lpipb->pIndexDataNode);
            lpipb->pIndexDataNode = NULL;
            goto exit1;
        }
        pCur = pNodeInfo->pBuffer + sizeof(WORD); // Skip cbLeft
        pCur = ExtractWord (lpipb->pTmpBuf, pCur, &wLen);
        pCur += ReadFileOffset (&pNodeInfo->nodeOffset, pCur);
    }
    
    // Handle leaf node
    while (!FoEquals (pNodeInfo->nodeOffset, foNil))
    {
        if ((fRet = ReadNewNode(lpipb->hfpbIdxFile, pNodeInfo,
            TRUE)) != S_OK)
			return fRet;
        if ((fRet = TraverseLeafNode (lpipb, pNodeInfo, rgTopicId, dwCount)) !=
            S_OK)
        {
            goto exit2;
        }
                
        ReadFileOffset (&pNodeInfo->nodeOffset, pNodeInfo->pBuffer);
    }
    fRet = S_OK;
    goto exit2;   
}

PRIVATE int PASCAL NEAR TraverseLeafNode (_LPIPB lpipb, PNODEINFO pNodeInfo,
    DWORD FAR *rgTopicId, DWORD dwCount)
{
    LPB pCur;
    LPB pMaxAddress;
    OCCF occf = lpipb->occf;
    WORD wLen;
    FILEOFFSET dataOffset;
    DWORD dataSize;
    BYTE  TopicCnt[20];
    BYTE  cbOldCount;
    BYTE  cbNewCount;
    ERRB  errb;
    BYTE  fChange = FALSE;
    HRESULT   fRet;
    
    pCur = pNodeInfo->pCurPtr;
    pMaxAddress = pNodeInfo->pMaxAddress;
    
    while (pCur < pMaxAddress)
    {
        DWORD dwTemp;
        DWORD dwTopicCount;
        DWORD dwOldTopicCount;
        LPB   pSaved;
        LPB   pTemp;
        
        pCur = ExtractWord (lpipb->pTmpBuf, pCur, &wLen);
        
        // Skip field id, topic count. fileoffset, datasize
        if (occf & OCCF_FIELDID)
            pCur += CbByteUnpack (&dwTemp, pCur); // FieldId
            
        pTemp = pSaved = pCur;  // Save the pointer to the topic count offset
        cbOldCount = (BYTE)CbByteUnpack (&dwTopicCount, pCur);
        pCur += cbOldCount;
        pCur += ReadFileOffset (&dataOffset, pCur);
        pCur += CbByteUnpack (&dataSize, pCur);
        
        if (dwTopicCount == 0)
            continue;
            
        dwOldTopicCount = dwTopicCount;
        if ((fRet = DeleteTopicFromData (lpipb, dataOffset, &dwTopicCount,
            dataSize, rgTopicId, dwCount)) != S_OK)
            return(fRet);
        
        if (dwOldTopicCount == dwTopicCount)
            continue;
        
        cbNewCount = (BYTE)CbBytePack (TopicCnt, dwTopicCount);

        // Update the topic count
        if (cbOldCount > cbNewCount)
		{
			TopicCnt[cbNewCount - 1] |= 0x80;	// Set the high bit
		}
        MEMCPY(pSaved, TopicCnt, cbNewCount);
		pSaved += cbNewCount;
        switch (cbOldCount - cbNewCount)
        {
            // Do we need 16 bytes to compress 4-bytes. YES!
            // Sometimes. we index/compress based on insufficient data
            // If subsequent updates contain value way larger than the
            // original data, then we may end up using 16 bytes to compress
            // 4 bytes!!
            case 16:
                *pSaved++ = 0x80; // Set the high bit
                break;
            case 15:
                *pSaved++ = 0x80; // Set the high bit
                break;
            case 14:
                *pSaved++ = 0x80; // Set the high bit
                break;
            case 13:
                *pSaved++ = 0x80; // Set the high bit
                break;
            case 12:
                *pSaved++ = 0x80; // Set the high bit
                break;
            case 11:
                *pSaved++ = 0x80; // Set the high bit
                break;
            case 10:
                *pSaved++ = 0x80; // Set the high bit
                break;
            case 9:
                *pSaved++ = 0x80; // Set the high bit
                break;
            case 7:
                *pSaved++ = 0x80; // Set the high bit
                break;
            case 6:
                *pSaved++ = 0x80; // Set the high bit
                break;
            case 5:
                *pSaved++ = 0x80; // Set the high bit
            case 4:
                *pSaved++ = 0x80; // Set the high bit
            case 3:
                *pSaved++ = 0x80; // Set the high bit
            case 2:
                *pSaved++ = 0x80; // Set the high bit
            case 1:
                *pSaved = 0x00; 
            case 0:
                break;
        }
#ifdef _DEBUG
        CbByteUnpack (&dwOldTopicCount, pTemp); // FieldId
        assert (dwOldTopicCount == dwTopicCount);
#endif
        
        fChange = TRUE; // The node have been changed
        
    }
    
    if (fChange == FALSE)
        return(S_OK);
        
    // Update the node
    if ((FileSeekWrite(lpipb->hfpbIdxFile,
        pNodeInfo->pBuffer, pNodeInfo->nodeOffset,
        lpipb->BTreeData.Header.dwBlockSize, &errb)) !=
        (LONG)lpipb->BTreeData.Header.dwBlockSize)
    {
        return(errb);
    }
    return(S_OK);
}

PRIVATE int PASCAL NEAR DeleteTopicFromData (_LPIPB lpipb,
    FILEOFFSET dataOffset, DWORD FAR * pTopicCount, DWORD dataSize,
    LPDW pTopicIdArray, DWORD dwArraySize)
{
    HRESULT fRet;
    ERRB errb;
    DWORD dwOldTopicCount;
    DWORD dwTopicId;
    DWORD dwTopicIdDelta;
    DWORD dwIndex;
    PNODEINFO pIndexDataNode = lpipb->pIndexDataNode;
    NODEINFO  CopyNode;
    PNODEINFO pCopyNode = &CopyNode;
    PIH20 pHeader = &lpipb->BTreeData.Header;
    OCCF occf = lpipb->occf;
    LPB  pStart;
    DWORD dwOldTopicId = 0;
    BYTE fetchOldData;
    BYTE fChanged;
    BYTE fNormalize = (lpipb->idxf & IDXF_NORMALIZE);
    
    // Make sure that we have enough memory to hold the data
    if (dataSize > pIndexDataNode->dwBlockSize)
    {
        _GLOBALUNLOCK (pIndexDataNode->hMem);
        if ((pIndexDataNode->hMem = _GLOBALREALLOC (pIndexDataNode->hMem,
            pIndexDataNode->dwBlockSize = dataSize, DLLGMEM_ZEROINIT)) == NULL)
            return(E_OUTOFMEMORY);
        
        pIndexDataNode->pBuffer = _GLOBALLOCK (pIndexDataNode->hMem);
    }
    
    // Read in the data
    if (FileSeekRead (lpipb->hfpbIdxFile, pIndexDataNode->pCurPtr =
        pIndexDataNode->pBuffer, dataOffset,
        dataSize, &errb) != (long)dataSize)
        return E_BADFILE;
        
    pIndexDataNode->pMaxAddress = pIndexDataNode->pBuffer + dataSize;    
	pIndexDataNode->ibit = cbitBYTE - 1;
    
    // Copy the prelimary node info
    CopyNode = *pIndexDataNode;
    
    dwOldTopicCount = *pTopicCount;
    dwTopicId = dwIndex = 0;
    fetchOldData = TRUE;
    fChanged = FALSE;
    
    while (dwOldTopicCount > 0)
    {
        DWORD dwTmp;
        
        if (fetchOldData)
        {
            // Byte align
            if (pIndexDataNode->ibit != cbitBYTE - 1)
            {
                pIndexDataNode->ibit = cbitBYTE - 1;
                pIndexDataNode->pCurPtr ++;
            }

            // Keep track of the starting position            
			pStart = pIndexDataNode->pCurPtr;
            if (fChanged == FALSE)
    			pCopyNode->pCurPtr = pIndexDataNode->pCurPtr;
            
            // Get the topicId from the index file
            if ((fRet = FGetDword(pIndexDataNode, pHeader->ckeyTopicId,
                &dwTopicIdDelta)) != S_OK)
                return fRet;
            dwTopicId += dwTopicIdDelta;
            fetchOldData = FALSE;
        }
        
        if (dwTopicId < pTopicIdArray[dwIndex])
        {
            if (fChanged == FALSE)
            {
    			if (fNormalize)
    			{
    				if ((fRet = FGetBits(pIndexDataNode, &dwTmp,
    					sizeof (USHORT) * cbitBYTE)) != S_OK)
    					return fRet;
    			}

                SkipOldData (lpipb, pIndexDataNode);
            }
            else
            {
                pIndexDataNode->pCurPtr = pStart;
                RemapData (lpipb, pCopyNode, pIndexDataNode,
                    dwTopicId, dwOldTopicId);
            }
            fetchOldData = TRUE;    
            dwOldTopicId = dwTopicId;
            dwOldTopicCount --;
            continue;
        }
        
        if (dwTopicId > pTopicIdArray[dwIndex])
        {
            if (dwIndex < dwArraySize - 1)
            {
                dwIndex++;
                continue;
            }
            
            if (fChanged == FALSE)
                return(S_OK);
                
            pIndexDataNode->pCurPtr = pStart;
            RemapData (lpipb, pCopyNode, pIndexDataNode,
                dwTopicId, dwOldTopicId);
            fetchOldData =TRUE;
            dwOldTopicId = dwTopicId;
            dwOldTopicCount --;
            continue;
        }
        
        // Both TopicId are equal. Ignore the current data
		fChanged = TRUE;	// We have changes
        if (fNormalize)
        {
            if ((fRet = FGetBits(pIndexDataNode, &dwTmp,
                sizeof (USHORT) * cbitBYTE)) != S_OK)
                return fRet;
        }

        if (occf & OCCF_HAVE_OCCURRENCE) 
        {
            if ((fRet = SkipOldData (lpipb, pIndexDataNode)) != S_OK)
                return(fRet);
        }
        
        (*pTopicCount)--;
        fetchOldData = TRUE;
		dwOldTopicCount--;
    }
    
    if (fChanged)
    {
        MEMSET(pCopyNode->pCurPtr, 0,
            (size_t) (pCopyNode->pMaxAddress - pCopyNode->pCurPtr));

        // Write out the new data
        if (FileSeekWrite (lpipb->hfpbIdxFile, pIndexDataNode->pBuffer, dataOffset,
            dataSize, &errb) != (long)dataSize)
            return errb;
    }
    return(S_OK);
}    

VOID PRIVATE PASCAL NEAR RemapData (_LPIPB lpipb, PNODEINFO pCopyNode,
    PNODEINFO pIndexDataNode, DWORD dwTopicId, DWORD dwOldTopicId)
{
    DWORD dwTmp;
    DWORD dwOccs;
    PIH20 pHeader = &lpipb->BTreeData.Header;
    OCCF  occf = lpipb->occf;
    
	 pIndexDataNode->ibit = cbitBYTE - 1;

    // Skip TopicIdDelta, since we already have TopicId
    FGetDword(pIndexDataNode, pHeader->ckeyTopicId, &dwTmp);
    
    EmitDword (pCopyNode, dwTopicId - dwOldTopicId, pHeader->ckeyTopicId);
    
    // EmitDword (pCopyNode, dwTopicDelta, pHeader->ckeyTopicId);
    if (lpipb->idxf & IDXF_NORMALIZE)
    {
        FGetBits(pIndexDataNode, &dwTmp, sizeof (USHORT) * cbitBYTE);
        EmitBits(pCopyNode, dwTmp, (BYTE)(sizeof (WORD) * cbitBYTE));
    }

    if ((occf & OCCF_HAVE_OCCURRENCE) == 0)
        return;
        
    // Get the number of occurrences
    FGetDword(pIndexDataNode, pHeader->ckeyOccCount, &dwOccs);
    EmitDword (pCopyNode, dwOccs, pHeader->ckeyOccCount);
    
    //
    //  One pass through here for each occurence in the
    //  current sub-list.
    //
    for (; dwOccs; dwOccs--)
    {
        //
        //  Keeping word-counts?  If so, get it.
        //
        if (occf & OCCF_COUNT) 
        {
            FGetDword(pIndexDataNode, pHeader->ckeyWordCount, &dwTmp);
            EmitDword(pCopyNode, dwTmp, pHeader->ckeyWordCount);
        }
        //
        //  Keeping byte-offsets?  If so, get it.
        //
        if (occf & OCCF_OFFSET) 
        {
            FGetDword(pIndexDataNode, pHeader->ckeyOffset, &dwTmp);
            EmitDword(pCopyNode, dwTmp, pHeader->ckeyOffset);
        }
    }
    if (pCopyNode->ibit != cbitBYTE - 1)
    {
        pCopyNode->ibit = cbitBYTE - 1;
        pCopyNode->pCurPtr ++;
    }
}    

PRIVATE VOID PASCAL NEAR EmitBitStreamDWord (PNODEINFO pNode, DWORD dw,
    int ckeyCenter)
{
    BYTE    ucBits;

    // Bitstream scheme.
    //
    //      This writes "dw" one-bits followed by a zero-bit.
    //
    for (; dw;)
    {
        if (dw < cbitBYTE * sizeof(DWORD))
        {
            ucBits = (BYTE)dw;
            dw = 0;
        }
        else
        {
            ucBits = cbitBYTE * sizeof(DWORD);
            dw -= cbitBYTE * sizeof(DWORD);
        }
        EmitBits(pNode, argdwBits[ucBits], (BYTE)ucBits);
    }
    EmitBool(pNode, 0);
}
    
PRIVATE VOID PASCAL NEAR EmitFixedDWord (PNODEINFO pNode, DWORD dw,
    int ckeyCenter)
{
	// This just writes "ckey.ucCenter" bits of data.
    EmitBits (pNode, dw, (BYTE)(ckeyCenter + 1));
}

PRIVATE VOID PASCAL NEAR EmitBellDWord (PNODEINFO pNode, DWORD dw,
    int ckeyCenter)
{
    BYTE ucBits;
    
    // The "BELL" scheme is more complicated.
    ucBits = (BYTE)CbitBitsDw(dw);
    
    if (ucBits <= ckeyCenter) 
    {
        //  
        //  Encoding a small value.  Write a zero, then write 
        // "ckey.ucCenter" bits of the value, which
        //  is guaranteed to be enough.
        //
        EmitBool(pNode, 0);
        EmitBits(pNode, dw, (BYTE)(ckeyCenter));
		return;
    }
    
    //
    //  Encoding a value that won't fit in "ckey.ucCenter" bits.
    //  "ucBits" is how many bits it will really take.
    //
    //  First, write out "ucBits - ckey.ucCenter"  one-bits.
    //
    EmitBits(pNode, argdwBits[ucBits - ckeyCenter],
        (BYTE)(ucBits - ckeyCenter));
    //
    // Now, write out the value in "ucBits" bits,
    // but zero the high-bit first.
    //
    EmitBits(pNode, dw & argdwBits[ucBits - 1], ucBits);
}


/*************************************************************************
 *
 * @doc  PRIVATE INDEXING
 *       
 * @func VOID | EmitBits |
 *    Writes a bunch of bits into the output buffer.
 *
 * @parm PNODEINFO | pNode |
 *    Pointer to the output data structure
 *
 * @parm DWORD | dwVal |
 *    DWORD value to write
 *
 * @parm BYTE | cbits |
 *    Number of bits to write from dwVal
 *************************************************************************/

PRIVATE VOID PASCAL NEAR EmitBits (PNODEINFO pNode, DWORD dwVal, BYTE cBits)
{
    BYTE    cbitThisPassBits;
    BYTE    bThis;

    // Loop until no bits left
    for (; cBits;) 
    {

        if (pNode->ibit < 0) 
        {
            pNode->pCurPtr++;
            pNode->ibit = cbitBYTE - 1;
        }
        cbitThisPassBits = (pNode->ibit + 1 < cBits) ?
            pNode->ibit + 1 : cBits;
        bThis = (pNode->ibit == cbitBYTE - 1) ?
            0 : *pNode->pCurPtr;
        bThis |= ((dwVal >> (cBits - cbitThisPassBits)) <<
            (pNode->ibit - cbitThisPassBits + 1));
        *pNode->pCurPtr = (BYTE)bThis;
        pNode->ibit -= cbitThisPassBits;
        cBits -= (BYTE)cbitThisPassBits;
    }
}


/*************************************************************************
 *
 * @doc  PRIVATE INDEXING
 *       
 * @func VOID | EmitBool |
 *    Writes a single bit into the output buffer.
 *
 * @parm PNODEINFO | pNode |
 *    Pointer to the output data structure
 *
 * @parm BOOL | dwVal |
 *    BOOL value to write
 *************************************************************************/

PRIVATE VOID PASCAL NEAR EmitBool (PNODEINFO pNode, BOOL fVal)
{

    if (pNode->ibit < 0) 
    {   // This byte is full, point to a new byte
        pNode->pCurPtr++;
        pNode->ibit = cbitBYTE - 1;
    }
    if (pNode->ibit == cbitBYTE - 1) // Zero out a brand-new byte.
        *pNode->pCurPtr = (BYTE)0;
    if (fVal)                               // Write my boolean.
        *pNode->pCurPtr |= 1 << pNode->ibit;
    pNode->ibit--;
}


PUBLIC LONG PASCAL FAR CompareDWord (DWORD dw1, DWORD dw2, LPV lpParm)
{
   return (dw1 - dw2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\filesort.c ===
#include <mvopsys.h>
#include <mem.h>
#include <memory.h>
#include <time.h>
#include "mvsearch.h"
#include "common.h"
#include "index.h"

#ifdef _DEBUG
static BYTE NEAR s_aszModule[] = __FILE__;	/* Used by error return functions.*/
#endif


#define FILEBUF_SIZE    0xff00
typedef struct HUGEARRAY
{
    HANDLE   hMem;
    LPB FAR *hrgStrArray;
    DWORD    dwCount;
    DWORD    dwSize;
    DWORD    dwBufCount;
    LPVOID   pBlockMgr;
    FCOMPARE lpfnCompare;
    LPVOID   lpSortParm;
    STATUS_FUNC PrintStatusFunc;
    INTERRUPT_FUNC lpfnInterrupt;
    LPVOID   lpInterruptParm;
    ESI      esi;
}   HUGEARRAY, FAR *PHUGEARRAY;

PUBLIC int PASCAL FAR CompareLine(LPB, LPB, LPVOID);

/*************************************************************************
 *
 *                    INTERNAL PRIVATE FUNCTIONS
 *  All of them should be declared near
 *************************************************************************/

PRIVATE HRESULT PASCAL FAR GetLine(LPFBI, LPB, LPV); 
PRIVATE HRESULT PASCAL NEAR PrioritySortList (HFPB, PHUGEARRAY, LPVOID);
PUBLIC HRESULT PASCAL FAR QueueCompare (LPESB, LPESB, WORD);
PRIVATE DWORD PASCAL NEAR EsbBlockFill (LPESI lpesi, LPESB lpesb,
    PHRESULT phr);
PRIVATE VOID PASCAL NEAR PriorityQueueUp (LPESB FAR *lrgPriorityQueue, 
    FCOMPARE fCompare, LPVOID lpParm, WORD index);
PRIVATE HRESULT PASCAL NEAR HugeArrayAddWord(HUGEARRAY FAR *phugeArray,
    LPB pLineBuf);
PRIVATE HRESULT NEAR PASCAL HugeArrayFlush (PHUGEARRAY pHugeArray);
PRIVATE HRESULT PASCAL NEAR FlushISI (PHUGEARRAY pHugeArray);
PRIVATE VOID PASCAL NEAR PriorityQueueFree (LPESI lpesi);

/*************************************************************************
 *  @doc    EXTERNAL API
 *  @func   HRESULT PASCAL FAR | FileSort |
 *      Given a text file, this function will sort all the lines into
 *      specified order. The text file will be overwritten and replaced
 *      by the new sorted file
 *  @parm   LPB | Filename | 
 *      File to be sorted. It will be overwritten/replaced with the new
 *      sorted file
 *  @parm   STATUS_FUNC | PrintStatusFunc |
 *      Callback messaging function to display status message
 *  @parm   INTERRUPT_FUNC | lpfnInterrupt |
 *      Callback interrupt function to stop the file sort. 
 *  @parm   LPVOID | lpInteruptParm |
 *      Parameter to interrupt function
 *  @parm   FNSORT | fnSort |
 *      Sorting function to be used for this file. If not specified
 *      the default sort function will be used, which consists of case
 *      sesitive comparison
 *  @parm   LPVOID | lpSortParm |
 *      Any extra information that may be needed by the sorting function
 *  @parm   BOOL | fUseSortFunc |   
 *      Flag to denote to use user sorting function if set
 *  @rdesc  S_OK or other errors
 *************************************************************************/
HRESULT EXPORT_API PASCAL FAR FileSort (HFPB hfpb, LPB Filename, 
    STATUS_FUNC PrintStatusFunc, INTERRUPT_FUNC lpfnInterrupt,
    LPV lpInterruptParm, FNSORT fnSort, LPVOID lpSortParm,
    FNSCAN fnScan, LPVOID lpScanParam)
{
    HRESULT fRet = S_OK;
    BYTE    OutputBuffer[cbMAX_PATH + 50];
    BYTE    count = 0;
    HFPB    hfpbIn;
    LPFBI   lpfbi;
    HANDLE  hBuf;
    LPB     pLineBuf;
    HUGEARRAY hugeArray;
    FNSCAN  fnScanInternal = GetLine;

    // Clear out all fields in hugeArray
    MEMSET (&hugeArray, 0, sizeof (HUGEARRAY));

    // Allocate a huge buffer to store the strings
    if ((hugeArray.hMem = _GLOBALALLOC (DLLGMEM_ZEROINIT,
        200000 * sizeof (LPB))) == NULL)
        return(E_OUTOFMEMORY);
        
    hugeArray.hrgStrArray = (LPB FAR *)_GLOBALLOCK (hugeArray.hMem);
    hugeArray.dwBufCount = hugeArray.dwCount = 0;
    hugeArray.dwSize = 200000;

    if ((hugeArray.pBlockMgr = BlockInitiate (FILEBUF_SIZE, 0, 0, 0)) == NULL) 
    {
        fRet = E_OUTOFMEMORY;
exit0:
        _GLOBALUNLOCK(hugeArray.hMem);
        _GLOBALFREE(hugeArray.hMem);
        return(fRet);
    }

    /* Set the comparison fucntion */
    if (fnSort)
    {
        hugeArray.lpfnCompare = (FCOMPARE) fnSort;
        hugeArray.lpSortParm = (LPVOID) lpSortParm;
    }
    else
    {
        hugeArray.lpfnCompare = CompareLine;
        hugeArray.lpSortParm = NULL;
    }
    hugeArray.PrintStatusFunc = PrintStatusFunc;
    hugeArray.lpfnInterrupt = lpfnInterrupt;
    hugeArray.lpInterruptParm = lpInterruptParm;
      
    /* Open the file */
    if ((hfpbIn = FileOpen (hfpb, Filename,
        hfpb == NULL ? REGULAR_FILE : FS_SUBFILE, READ, NULL)) == 0)
    {
        fRet = E_NOTEXIST;
exit1:
        BlockFree (hugeArray.pBlockMgr);
        goto exit0;
    }

    /* Allocate a file buffer associated with the input file */
    if ((lpfbi = FileBufAlloc (hfpbIn, FILEBUF_SIZE)) == NULL)
    {
        fRet = E_OUTOFMEMORY;

exit2: 
        FileClose (hfpbIn);
        goto exit1;
    }

    if ((hBuf = _GLOBALALLOC (DLLGMEM_ZEROINIT, 0xffff)) == NULL)
    {
        fRet = E_OUTOFMEMORY;
exit3:
        FileBufFree (lpfbi);
        goto exit2;
    }
    
    if (PrintStatusFunc)
    {
        wsprintf (OutputBuffer, "Sort file: %s", Filename);
        (*PrintStatusFunc)(OutputBuffer);
    }

    pLineBuf = (LPB)_GLOBALLOCK (hBuf);

    /* Set the scan fucntion */
    if (fnScan)
        fnScanInternal = fnScan;

    for (;;)
    {
        if ((++count & 0x7f) == 0)
        {
            if (lpfnInterrupt)
                (*lpfnInterrupt)(lpInterruptParm);
        }
        if ((fRet = (*fnScanInternal)(lpfbi, pLineBuf, NULL)) != S_OK)
        {
exit4:
            _GLOBALUNLOCK(hBuf);
            _GLOBALFREE(hBuf);
            goto exit3;
        }
        if (*(LPW)pLineBuf == 0)   /* EOF */
            break;
            
        if ((fRet = HugeArrayAddWord(&hugeArray, pLineBuf)) != S_OK)
            goto exit4;
    }

    // Sort and flush any records in the tree to disk
    fRet = HugeArrayFlush (&hugeArray);

	FileBufFree(hugeArray.esi.lpfbiTemp);
    FileClose (hugeArray.esi.hfpb);

    // Free all memory blocks. 
    BlockFree(hugeArray.pBlockMgr);
    FileBufFree (lpfbi);
    _GLOBALUNLOCK(hugeArray.hMem);
    _GLOBALFREE(hugeArray.hMem);
    _GLOBALUNLOCK(hBuf);
    _GLOBALFREE(hBuf);
    
    /* Close the input file */
    FileClose (hfpbIn);

    if (fRet != S_OK)
        return fRet;

    /* Now perform external sort */
    if (PrintStatusFunc)
        (*PrintStatusFunc)("Merge Sort Phase");
    
    if ((hfpbIn = FileOpen (hfpb, Filename,
        hfpb == NULL ? REGULAR_FILE : FS_SUBFILE, READ_WRITE, NULL)) == 0)
    {
        fRet = E_ASSERT;
        goto exit0;
    }

    fRet = PrioritySortList (hfpbIn, &hugeArray, lpSortParm);
    FileClose (hfpbIn);
    return fRet;
}


/*************************************************************************
 *  @doc    INTERNAL PRIVATE
 *  @func   HRESULT PASCAL FAR | GetLine |
 *      The function will extract a line from a text file. The output line
 *      will have the following format
 *      - 2 bytes: word length
 *      - The word it self
 *      - 0 terminated
 *  @parm   LPFBI | lpfbi |
 *      File buffer for flushing out the word
 *  @parm   LPB lpbOut |
 *      Buffer to contain the word. The following assumptions are made:
 *      - The size of the buffer is large enough to handle any line.
 *      There is no checking for buffer overflow
 *  @parm   LPV  | Not used
 *  @rdesc  S_OK or other errors
 *************************************************************************/
PRIVATE HRESULT PASCAL FAR GetLine(LPFBI lpfbi, LPB lpbOut, LPV lpv)
{
    LPB lpbLimit = lpfbi->lrgbBuf + lpfbi->cbBuf;
    LPB lpbIn = lpfbi->lrgbBuf + lpfbi->ibBuf;
    LPB lpbSaved = lpbOut;
    ERRB errb;

    *(LPW)lpbOut = 0;
    lpbOut += sizeof(WORD);

    for (;; lpbIn++)
    {
        if (lpbIn >= lpbLimit)
        {
            lpfbi->ibBuf = (WORD)(lpbIn - lpfbi->lrgbBuf);
            if (FileBufFill (lpfbi, &errb) == cbIO_ERROR)
                return errb;

            lpfbi->ibBuf = 0;
            lpbIn = lpfbi->lrgbBuf;
            lpbLimit = lpfbi->lrgbBuf + lpfbi->cbBuf;

            /* EOF */
            if (lpfbi->ibBuf == lpfbi->cbBuf)
            {
                break;
            }
        }

        /* Update the buffer */
        if ((*lpbOut++ = *lpbIn) == '\n')
        {
            lpbIn++;
            break;
        }
    }

    *lpbOut = 0;
    *(LPW)lpbSaved = (WORD)(lpbOut - lpbSaved - sizeof(WORD));
    lpfbi->ibBuf = (WORD)(lpbIn - lpfbi->lrgbBuf);
    return S_OK;
}

PRIVATE HRESULT PASCAL NEAR PrioritySortList (HFPB hfpb, PHUGEARRAY pHugeArray,
    LPVOID lpParm)
{
    LPFBI   lpfbiOut;
    HRESULT     fRet;
    LPESB   lpesb;  // Pointer to the current queue element.
    LST     lstWord;
    LPB     lpbCurPtr;
    LPB     lpbBufLimit;
    LPB     lpbBufStart;
    LPESI   lpesi;
    LPESB FAR *lrgPriorityQueue;
    WORD wLen;

    HANDLE  hQueue;             // Handle to the word-key queue, which
                                //  is allocated in global memory.

    /* Get the pointer to external sort info block */
    lpesi = &pHugeArray->esi;

    /* Open the internal sort file */
    if ((lpesi->hfpb = FileOpen (NULL, pHugeArray->esi.aszTempName,
        REGULAR_FILE, READ, NULL)) == 0)
        return(E_INVALIDARG);
        

    if ((lpfbiOut = FileBufAlloc (hfpb, FILEBUF_SIZE)) == NULL)
    {
        fRet = E_OUTOFMEMORY;
exit0:
        FileClose (lpesi->hfpb);
        FileUnlink (NULL, pHugeArray->esi.aszTempName, REGULAR_FILE);
        PriorityQueueFree(lpesi);
        return fRet;
    }

    /*
     * Allocate a priority queue array. The size of the array
     * is the number of external sort info blocks plus 1, since
     * location 0 is not used
     */
    if ((lpesi->hPriorityQueue = hQueue = _GLOBALALLOC (DLLGMEM_ZEROINIT,
        (DWORD)(lpesi->cesb + 1) * sizeof(LPB))) == NULL)
    {
        fRet = E_OUTOFMEMORY;
exit1:
        FileBufFree (lpfbiOut);
        goto exit0;
    }

    lrgPriorityQueue = lpesi->lrgPriorityQueue =
        (LPESB FAR *)_GLOBALLOCK(hQueue);

    /*  Queue initialization. */

    if ((fRet = PriorityQueueCreate (lpesi, (FCOMPARE)pHugeArray->lpfnCompare,
        lpParm)) != S_OK)
    {
exit03: 
        if (hQueue != NULL)
        {
            _GLOBALUNLOCK(hQueue);
            _GLOBALFREE(hQueue);
        }
        lpesi->hPriorityQueue = NULL;
        goto exit1;
    }

    /* Get the pointer to the I/O buffer. I am allocating 256 bytes
     * for data overflow, which should be more than enough to handle
     * a word. The usage of lpbBufLimit will decrease the number of
     * buffer overflow check
     */

    lpbBufLimit = (lpbCurPtr = lpfbiOut->lrgbBuf) + lpfbiOut->cbBufSize;// - 256;
    lpbBufStart = lpfbiOut->lrgbBuf;

    for (;lpesi->uiQueueSize;)
    {

        /*
         *  If here, the queue has something in it.  Grab
         *  the head of the queue and process. Remember that
         *  the first byte is only the record length
         */
        lpesb = (LPESB)lrgPriorityQueue[1];
        lstWord = (LST)lpesb->lrgbMem + lpesb->ibBuf;

        /* The first2 bytes are the word's length. */
        wLen = *(LPW)lstWord;

        if (lpbCurPtr + wLen >= lpbBufLimit)
        {
            lpfbiOut->ibBuf = (WORD) (lpbCurPtr - lpbBufStart);
            if ((fRet = FileBufFlush (lpfbiOut)) != S_OK)
                return fRet;
            lpbCurPtr = lpfbiOut->lrgbBuf;
        }
        MEMCPY (lpbCurPtr, lstWord + sizeof(WORD), wLen);
        lpbCurPtr += wLen;

    /*
     *  Get a new occurence to replace the one I pulled from
     *  the head of the queue.
     */
        if ((fRet = PriorityQueueRemove(lpesi,
            (FCOMPARE)pHugeArray->lpfnCompare, lpParm)) != S_OK)
            return fRet;
    }

    /* Update the offset, for flushing */
    lpfbiOut->ibBuf = (WORD)(lpbCurPtr - lpfbiOut->lrgbBuf);
    fRet = FileBufFlush (lpfbiOut);
    goto exit03;
}

PUBLIC int PASCAL FAR CompareLine (LPB lpb1, LPB lpb2, LPVOID lpUnused)
{

    register int diff;

    /* Skip word length */
    lpb1 += sizeof(WORD);
    lpb2 += sizeof(WORD);

    while (*lpb1 && *lpb2)
    {
        if (diff = *lpb1 - *lpb2 )
        {
            return diff;
        }
        lpb1++;
        lpb2++;
    }
    return *lpb1 - *lpb2;
}

PUBLIC HRESULT PASCAL FAR PriorityQueueCreate (LPESI lpesi, FCOMPARE fCompare,
    LPVOID lpParm)
{

    WORD    uiQueueSize;        /* Final queue size. */
    LPESB   lpesb;              /* Scratch pointer */
    HRESULT     fRet = S_OK;
    LPESB   FAR * lrgPriorityQueue = lpesi->lrgPriorityQueue;
    ERRB  errb;


    /*
     *  Initialize all ESB buffers.  
     */
    uiQueueSize = 0;
    for (lpesb = lpesi->lpesbRoot; lpesb != NULL;
        lpesb = lpesb->lpesbNext)
    {

        /* Allocate the buffer */

        if ((lpesb->hMem = _GLOBALALLOC (DLLGMEM, FILEBUF_SIZE)) == NULL)
        {
            PriorityQueueFree(lpesi);
            return SetErrCode (&errb, fRet = E_OUTOFMEMORY);
        }

        lpesb->lrgbMem = (LPB)_GLOBALLOCK(lpesb->hMem);

        /* Mimic an out-of-data to force reading */
        lpesb->ibBuf = lpesb->dwEsbSize = FILEBUF_SIZE;

        /* Read the data, lpesb->lfo, lpesb->ibBuf will be updated
         * by the call
         */
        if (EsbBlockFill (lpesi, lpesb, &errb) == cbIO_ERROR)
        {
            PriorityQueueFree(lpesi);
            return errb;
        }

        /* Sanity check, make sure that we didn't read pass the
         * block.
         */
        if (FoCompare(lpesb->lfo,lpesb->lfoMax)>0)
        {
            PriorityQueueFree(lpesi);
            return SetErrCode (&errb, E_ASSERT);
        }

        /* Update the priority queue */
        uiQueueSize ++;  // Grow queue.

        /* Add to the priority queue */
        lrgPriorityQueue[uiQueueSize] = lpesb;

        PriorityQueueUp (lrgPriorityQueue, fCompare, lpParm, uiQueueSize);
    }

    lpesi->uiQueueSize = uiQueueSize;
    return S_OK;
}

PRIVATE VOID PASCAL NEAR PriorityQueueFree (LPESI lpesi)
{
    LPESB   lpesb;              /* Scratch pointer */
    LPESB   lpesbNext;

    for (lpesb = lpesi->lpesbRoot; lpesb != NULL; lpesb = lpesbNext)
    {
        lpesbNext = lpesb->lpesbNext;
        _GLOBALUNLOCK(lpesb->hMem);
        _GLOBALFREE(lpesb->hMem);
		GlobalLockedStructMemFree (lpesb);
    }
}


/*************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   VOID | PriorityQueueUp | 
 *      The function restore the heap condition of a PQ, ie. the parent
 *      node must be less than the children. When a node is inserted
 *      at the bottom, the heap condition may be violated, if the node
 *      is smaller than its parent. In this case the nodes have to
 *      be switched
 *
 *  @parm   LPESB FAR * | lrgPriorityQueue | 
 *      PQ array
 *
 *  @parm   FCOMPARE | fCompare |
 *      Function used to compare the node
 *
 *  @parm   LPVOID | lpParm |
 *      Parameter to be used with fCompare
 *
 *  @parm   WORD | index |
 *      Index of the inserted node
 *
 *************************************************************************/

PRIVATE VOID PASCAL NEAR PriorityQueueUp (LPESB FAR *lrgPriorityQueue, 
    FCOMPARE fCompare, LPVOID lpParm, WORD index)
{
    LPESB   lpesbTemp;  /* Pointer to the inserted node */
    LPESB   lpesbHalf;  /* Pointer to the parent node */
    WORD    uiHalf;     /* Index of the parent's node */

    lpesbTemp = lrgPriorityQueue [index];

    uiHalf = index/2;
    lpesbHalf = lrgPriorityQueue [uiHalf];

    /* If the parent node is greated than the child, then exchange the
     * nodes, The condition uiHalf != index makes sure that we stop
     * at node 0 (top node)
     */
    while (uiHalf && (*fCompare)(lpesbHalf->lrgbMem + lpesbHalf->ibBuf,
        lpesbTemp->lrgbMem + lpesbTemp->ibBuf, lpParm) > 0)
    {
        lrgPriorityQueue [index] = lpesbHalf;
        index = uiHalf;
        uiHalf = index/2;
        lpesbHalf = lrgPriorityQueue [uiHalf];
    }
    lrgPriorityQueue[index] = lpesbTemp;
}

/*************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   VOID | PriorityQueueDown | 
 *      The function restore the heap condition of a PQ, ie. the parent
 *      node must be less than the children. When the top node is removed
 *      the heap condition may be violated, if the resulting node 
 *      is greater than its children. In this case the nodes have to
 *      be switched
 *
 *  @parm   LPESI | lpesi |
 *      Pointer to external sort info, which contains all info
 *
 *  @parm   FCOMPARE | fCompare |
 *      Function used to compare the node
 *
 *  @parm   LPVOID | lpParm |
 *      Parameter to be used with fCompare
 *
 *  @parm   WORD | index |
 *      Index of the inserted node
 *
 *************************************************************************/

PRIVATE VOID PriorityQueueDown (LPESI lpesi, FCOMPARE fCompare, LPVOID lpParm)
{
    LPESB FAR *lrgPriorityQueue;
    int CurIndex;
    int ChildIndex;
    int MaxCurIndex;
    int MaxChildIndex;
    LPESB lpesbSaved;
    LPESB lpesbTemp;
    LPESB lpesbChild;

    lrgPriorityQueue = lpesi->lrgPriorityQueue;
    lpesbSaved = lrgPriorityQueue[1];
    MaxCurIndex = (MaxChildIndex = lpesi->uiQueueSize) / 2;

    for (CurIndex = 1; CurIndex <= MaxCurIndex; CurIndex = ChildIndex)
    {

        /* Get child index */
        ChildIndex = CurIndex * 2;

        /* Find the minimum of the two children */
        if (ChildIndex < MaxChildIndex)
        {
            if ((lpesbTemp = lrgPriorityQueue[ChildIndex + 1]) != NULL)
            {

                lpesbChild = lrgPriorityQueue[ChildIndex];

                /* The two children exist. Take the smallest */
                 
                if ((*fCompare)(lpesbChild->lrgbMem + lpesbChild->ibBuf,
                    lpesbTemp->lrgbMem + lpesbTemp->ibBuf, lpParm) >= 0)
                    ChildIndex++;
            }
        }

        if (ChildIndex > MaxChildIndex) 
            break;

        /* If the parent's node is less than the child, then break
         * (heap condition met)
         */

        lpesbTemp = lrgPriorityQueue [ChildIndex];

        if ((*fCompare)(lpesbSaved->lrgbMem + lpesbSaved->ibBuf,
            lpesbTemp->lrgbMem + lpesbTemp->ibBuf, lpParm) < 0)
            break;

        /* Replace the node */
        lrgPriorityQueue [CurIndex] = lpesbTemp;
    }

    lrgPriorityQueue [CurIndex] = lpesbSaved;
}

PUBLIC HRESULT PASCAL FAR PriorityQueueRemove (LPESI lpesi, FCOMPARE fCompare,
    LPVOID lpParm)
{
    LPESB lpesb;
    LPB   lpbCurPtr;
    SHORT reclen;
    DWORD index;
    LPESB FAR *lrgPriorityQueue;
    ERRB  errb;
    
    /* Get all appropriate pointers */
    lpesb = (lrgPriorityQueue = lpesi->lrgPriorityQueue)[1];
    lpbCurPtr = lpesb->lrgbMem + (index = lpesb->ibBuf);

    reclen = *(LPW)lpbCurPtr + sizeof(WORD);   /* Current record's length */
    index += reclen;        /* Should point to location of next record */
    lpesb->ibBuf = index;

#ifdef _DEBUG
    /* Make sure that we did not pass the buffer's limit */
    if (index > lpesb->dwEsbSize) 
        return SetErrCode (&errb, E_ASSERT);
#endif

    /* Skip this record */
    lpbCurPtr += reclen;

    if (index < lpesb->dwEsbSize)
    {
        /* We may have some data left in the buffer, so check
         * the next record, make sure that it is complete. Refill the
         * buffer if necessary
         */

        if (index + *(LPW)lpbCurPtr + sizeof(WORD) > lpesb->dwEsbSize)
        {

            /* Fill the data buffer */
            if (EsbBlockFill (lpesi, lpesb, &errb) == cbIO_ERROR)
                return errb;
        }
    }
    else
    {
        /* Fill the data buffer */
        if (EsbBlockFill (lpesi, lpesb, &errb) == cbIO_ERROR)
            return errb;
    }

    /* Check for data */
    if (lpesb->ibBuf >= lpesb->dwEsbSize)
    {
        
        DWORD size;

        /* This block runs out of data, just replace it with the
         * last block in the array
         */
         lrgPriorityQueue[1] = lrgPriorityQueue [size = lpesi->uiQueueSize];
         lrgPriorityQueue [size--] = NULL;
         lpesi->uiQueueSize = size ;
    }

    /* Now fix the heap condition */
    PriorityQueueDown (lpesi, fCompare, lpParm);
    return S_OK;
}

PRIVATE DWORD PASCAL NEAR EsbBlockFill (LPESI lpesi, LPESB lpesb,
    PHRESULT phr) 
{
    LPB     lpbStart;
    LPB     lpbCurPtr;
    DWORD   cbByteRead;
    DWORD   cbByteLeft;

    lpbStart = lpesb->lrgbMem;
    lpbCurPtr = lpesb->lrgbMem + lpesb->ibBuf;

    /* Check to see how many bytes we have left */
    if (cbByteLeft = lpesb->dwEsbSize - lpesb->ibBuf)
    {
        /* We have some leftover data. Just copied them to the
         * beginning of the buffer
         */
        MEMCPY (lpbStart, lpbCurPtr, cbByteLeft);
        lpbStart += cbByteLeft;
    }

    /* Update the current index */
    lpesb->ibBuf = 0;

    /* Calculate how many bytes to be read in */

    cbByteRead = lpesb->dwEsbSize - cbByteLeft;
    if (FoCompare(FoSubFo(lpesb->lfoMax,lpesb->lfo),MakeFo(cbByteRead,0)) < 0)
        cbByteRead = (WORD)(DwSubFo(lpesb->lfoMax,lpesb->lfo));


    /* Update the size of the buffer */
    lpesb->dwEsbSize = (WORD)cbByteLeft;

    /* Read in new data */
    if (cbByteRead > 0)
    {
        if ((cbByteRead = FileSeekRead (lpesi->hfpb, lpbStart, lpesb->lfo,
            cbByteRead, phr)) == cbIO_ERROR)
            return cbIO_ERROR;

        /* Update the pointer */
        lpesb->lfo = FoAddDw(lpesb->lfo, cbByteRead);
        lpesb->dwEsbSize += (WORD)cbByteRead;
    }
    return cbByteRead;
}

PRIVATE HRESULT PASCAL NEAR HugeArrayAddWord(HUGEARRAY FAR *pHugeArray,
    LPB pLineBuf)
{
    HRESULT fRet;

    if (pHugeArray->dwCount >= pHugeArray->dwSize) 
    {
        if ((fRet = HugeArrayFlush (pHugeArray)) != S_OK)
            return(fRet);
    }

	// The +1 is for the extra 0 at the end of the line

    if ((pHugeArray->hrgStrArray[pHugeArray->dwCount] =
        (LPB)BlockCopy (pHugeArray->pBlockMgr, pLineBuf,
        *(LPW)pLineBuf + sizeof(WORD) + 1, 0)) == NULL)
    {
        if ((fRet = HugeArrayFlush (pHugeArray)) != S_OK)
            return(fRet);
            
        if ((pHugeArray->hrgStrArray[pHugeArray->dwCount] =
            (LPB)BlockCopy (pHugeArray->pBlockMgr, pLineBuf,
            *(LPW)pLineBuf + sizeof(WORD), 0)) == NULL)
        {
            return(E_ASSERT);
        }
    }
    pHugeArray->dwCount++;
    return(S_OK);
}    
/*************************************************************************
 *
 *  @doc    INTERNAL INDEXING
 *
 *  @func   HRESULT PASCAL FAR | HugeArrayFlush |
 *      This function will perform an internal sort on the huge
 *      array associated with pHugeArray, and then flush out the
 *      result onto the disk. An external sort element is created
 *      to record the position of the block in the disk
 *
 *  @parm   PHUGEARRAY | pHugeArray |
 *      Pointer to huge array struct
 *
 *  @rdesc  S_OK, or errors if failed
 *
 *************************************************************************/

PRIVATE HRESULT NEAR PASCAL HugeArrayFlush (PHUGEARRAY pHugeArray)
{
    LPESB   lpesb;      /* Pointer to a newly created external sort block */
    LPESI   lpesi;      /* Pointer to external sort info struct */
    HRESULT fRet;           /* Function return value */
    char TmpBuf[50];
    ERRB errb;

    /* If there is no data, then just return */
    if (pHugeArray->dwCount == 0)
        return S_OK;

    /* Print the status */
    if (pHugeArray->PrintStatusFunc)
    {
        pHugeArray->dwBufCount++;
        wsprintf (TmpBuf, "QuickSort %ld strings (set # %ld)",
            pHugeArray->dwCount, pHugeArray->dwBufCount);
        pHugeArray->PrintStatusFunc ((LPSTR)TmpBuf);
    }

    /* Sort the huge array */
    if ((fRet = HugeDataSort((LPVOID)pHugeArray->hrgStrArray,
        pHugeArray->dwCount, pHugeArray->lpfnCompare,
        pHugeArray->lpSortParm, pHugeArray->lpfnInterrupt,
        pHugeArray->lpInterruptParm)) != S_OK)
        return fRet;

    /* Get pointer to external sort info block */
    lpesi = &pHugeArray->esi;

    /*
     *  Create external sort temporary file, if the file doesn't
     *  already exist.  This is to store all the internal sort results
     */

    if (lpesi->hfpb == NULL)
    {

        /* Create the external sort temp file */

        (void)GETTEMPFILENAME((char)0, (LPB)"iso", (WORD)0,
            lpesi->aszTempName);

        if ((lpesi->hfpb = FileOpen (NULL, lpesi->aszTempName,
            REGULAR_FILE, READ_WRITE, &errb)) == NULL)
            return errb;

        /* Allocate a temporary I/O file buffer info */
        if ((lpesi->lpfbiTemp = FileBufAlloc(lpesi->hfpb, FILEBUF_SIZE)) == NULL)
            return SetErrCode (&errb, E_OUTOFMEMORY);

        SetFCallBack (lpesi->hfpb, pHugeArray->lpfnInterrupt,
            pHugeArray->lpInterruptParm);

    }

    /*
     *  Make a new ESB (external sort block) record. All fields are 0's
     */
    if ((lpesb = GlobalLockedStructMemAlloc (sizeof(ESB))) == NULL)
    {
        SetErrCode (&errb, E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    /* Add to the BEGINNING of the linked list */
    lpesb->lpesbNext = lpesi->lpesbRoot;
    lpesi->lpesbRoot = lpesb;

    /* Update the number of external sort blocks */
    lpesi->cesb++;

    /* Print the status */
    if (pHugeArray->PrintStatusFunc)
    {
        wsprintf (TmpBuf, "Write sorted strings");
        pHugeArray->PrintStatusFunc ((LPSTR)TmpBuf);
    }

    /* Do the flush. In case of error, we will just return, not worrying
     * about the allocated structure since it will be released by
     * IndexDispose()
     */
    fRet = FlushISI (pHugeArray);
    return fRet;
}


/*************************************************************************
 *  @doc    INTERNAL INDEXING
 *
 *  @func   HRESULT PASCAL NEAR | FlushISI |
 *      Write out the result of the internal sort to the disk. To save
 *      disk space, the data are semi-compacted. The external sort info
 *      structure's length associated with the data is updated.
 *
 *  @parm   PHUGEARRAY | pHugeArray |
 *      Pointer to index parameter block
 *
 *  @rdesc  S_OK, or errors if failed
 *************************************************************************/

PRIVATE HRESULT PASCAL NEAR FlushISI (PHUGEARRAY pHugeArray)
{
    LPFBI   lpfbiTemp;  /* Temporary file I/O buffer */
    LPESI   lpesi;      /* Pointer to external sort info */
    LPESB   lpesb;      /* Pointer to external sort block */
    LST     lstWord;    /* Pointer to word-occurence buffer */
    DWORD   i;          /* Scratch variable */
    WORD    wLen;       /* Length of the current word */
    LPB     lpbBuf;         /* Short cut of lpfbi->lpbCurPtr */
    DWORD   lcByteWritten;  /* How many bytes have been written */
    LPB     lpbBufLimit;    /* Buffer safety limit */
    LPB HUGE *hplpbRec; /* Pointer to key */
    HRESULT     fRet;

    /* Initialize the variables */
    lpesi = &pHugeArray->esi;
    lpesb = lpesi->lpesbRoot;
    lcByteWritten = 0;

    /* Remember the offset in the external sort temporary file at
     * which data for this ESB starts.
     */
    lpesb->lfo = lpesi->lfoTempOffset;

    /* Get pointer to output buffer */
    lpfbiTemp = lpesi->lpfbiTemp;

    /* Set the buffer limit. Leave some room for overflow */
    lpbBufLimit = (lpbBuf = lpfbiTemp->lrgbBuf) + FILEBUF_SIZE - sizeof(DWORD);

    /*
     *  Write out the sorted records to the temporary file space
     *  managed by the ESB.
     */

    for (i = pHugeArray->dwCount, hplpbRec = pHugeArray->hrgStrArray; i > 0; 
        i--, hplpbRec ++)				   
    {

        /* Get pointer to word data */
        lstWord = (LST)*hplpbRec;

        /* Get the word length */
        wLen = *(LPW)lstWord;
        
        if (lpbBuf + wLen >= lpbBufLimit)
        {
            // Buffer overflow. Record teh number of bytes written and
            // flush it.
            
            lcByteWritten += (lpfbiTemp->ibBuf = (WORD)(lpbBuf - lpfbiTemp->lrgbBuf));

            /*  Flush the buffer */

            if ((fRet = FileBufFlush(lpfbiTemp)) != S_OK)
                return fRet;

            /* Reset lpbBuf */
            lpbBuf = lpfbiTemp->lrgbBuf;
        }

        MEMCPY(lpbBuf, (LPB)lstWord, wLen + sizeof(WORD));
        lpbBuf += wLen + sizeof(WORD);
    }

    /*  Record the number of bytes emitted, and update ibBuf for flushing */
    lcByteWritten += (lpfbiTemp->ibBuf = (WORD)(lpbBuf - lpfbiTemp->lrgbBuf));

    /* Flush the buffer */
    if ((fRet = FileBufFlush(lpfbiTemp)) != S_OK)
    {
        return SetErrCode (NULL, fRet);
    }

    /* Update the fields of the external sort info */
    lpesb->lfoMax = (lpesi->lfoTempOffset =
        FoAddDw(lpesi->lfoTempOffset, lcByteWritten));

    /* Reset all the variables */
    pHugeArray->dwCount = 0; /* Index of the huge array */
    BlockReset(pHugeArray->pBlockMgr); /* Reset data space */

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\ftsearch.c ===
/*************************************************************************
*                                                                        *
*  SEARCH.C                                                              *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   Search Core Engine
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
**************************************************************************/
#include <verstamp.h>
SETVERSIONSTAMP(MVSR);

#include <mvopsys.h>
#include <mem.h>
#include <memory.h>
#ifdef DOS_ONLY
#include <stdio.h>
#include <assert.h>
#endif
#include <mvsearch.h>
#include <groups.h>
#include "common.h"
#include "search.h"

#ifdef _DEBUG
static BYTE NEAR s_aszModule[] = __FILE__;	/* Used by error return functions.*/
#endif

#if 0
#define KEEP_SEARCHING  ((int)-1)
#define STRING_MATCH    0
#define NOT_FOUND   1
#endif

#define KEEP_OCC        TRUE
#define RESET_OCC_FLAG  TRUE

typedef struct
{
    unsigned char b1;
    unsigned char b2;
} TWOBYTE;

#ifdef _BIG_E
#define BYTE1(p)    (((TWOBYTE FAR *)&p)->b1)
#define BYTE2(p)    (((TWOBYTE FAR *)&p)->b2)
#else
#define BYTE1(p)    (((TWOBYTE FAR *)&p)->b2)
#define BYTE2(p)    (((TWOBYTE FAR *)&p)->b1)
#endif

typedef HRESULT (PASCAL FAR *FDECODE) (PNODEINFO, CKEY, LPDW);

/*************************************************************************
 *                          EXTERNAL VARIABLES
 *  All those variables must be read only
 *************************************************************************/

extern OPSYM OperatorArray[]; 
extern FNHANDLER HandlerFuncTable[];
extern FDECODE DecodeTable[];

/*************************************************************************
 *
 *                       API FUNCTIONS
 *  Those functions should be exported in a .DEF file
 *************************************************************************/
PUBLIC LPIDX EXPORT_API FAR PASCAL MVIndexOpen (HFPB, LSZ, PHRESULT);
PUBLIC void EXPORT_API FAR PASCAL MVIndexClose (LPIDX);
PUBLIC LPHL EXPORT_API FAR PASCAL MVIndexSearch (LPIDX, LPQT,
    PSRCHINFO, LPGROUP, PHRESULT);
/*************************************************************************
 *
 *                    INTERNAL GLOBAL FUNCTIONS
 *  All of them should be declared far, unless they are known to be called
 *  in the same segment
 *************************************************************************/
VOID PASCAL FAR CleanMarkedOccList (LPITOPIC);
VOID PASCAL FAR TopicWeightCalc(LPITOPIC);
BOOL NEAR PASCAL FGroupLookup(LPGROUP, DWORD);
LPB PASCAL FAR NextChar (LPB pStr, BYTE prgbLeadByteTable[]);
__inline BOOL PASCAL FAR CompareChar (LPB pStr1, LPB pStr2, BYTE prgbLeadByteTable[]);

/*************************************************************************
 *
 *                    INTERNAL PRIVATE FUNCTIONS
 *  All of them should be declared near
 *************************************************************************/

#ifndef SIMILARITY
PUBLIC int PASCAL FAR CompareTerm(_LPQTNODE lpQtNode, LST lstTermWord,
    LST lstBtreeWord, DWORD dwBtreeFieldId, BYTE prgbLeadByteTable[]);
#else
PRIVATE int PASCAL NEAR CompareTerm(_LPQTNODE lpQtNode, LST lstTermWord,
    LST lstBtreeWord, DWORD dwBtreeFieldId, BYTE prgbLeadByteTable[]);
#endif


#ifndef SIMILARITY
PUBLIC HRESULT PASCAL FAR SkipOccList(_LPQT  lpqt, PNODEINFO pNodeInfo, DWORD dwOccs);
#else
PRIVATE HRESULT PASCAL NEAR SkipOccList(_LPQT  lpqt, PNODEINFO pNodeInfo, DWORD dwOccs);
#endif

PRIVATE HRESULT PASCAL NEAR FCaptureOccList(_LPIDX, LPRETV, PNODEINFO, DWORD, int,
    _LPQTNODE, int);
PRIVATE HRESULT PASCAL NEAR LoadNode (_LPQT, int, _LPQTNODE, _LPQTNODE,
    LPRETV, int, int);
PRIVATE int PASCAL NEAR WildCardCompare (LPB, LPB, BYTE []);
PRIVATE HRESULT PASCAL NEAR GetWordDataLocation  (_LPQT, LPRETV, 
    _LPQTNODE);
PRIVATE HRESULT PASCAL NEAR GetWordData (_LPQT, LPRETV,
    int, _LPQTNODE, _LPQTNODE, int, int);


#define FGetDword(a,b,c) (*DecodeTable[b.cschScheme])(a, b, c)

/*************************************************************************
 *  @doc    EXTERNAL API RETRIEVAL
 *  
 *  @func LPIDX FAR PASCAL | MVIndexOpen |
 *      Open an index file
 *  
 *  @parm   HANDLE | hfpbSysFile |
 *      If non-zero, this is the handle of an already opened system file
 *
 *  @parm   LSZ | lszFilename |
 *      If hpfbSysFile is non-zero, this is the index subfile filename.
 *      If it is 0, it is the filename of a regular DOS file
 *  
 *  @parm PHRESULT | phr |
 *      Pointer to error buffer. This error buffer will be used for all
 *      subsequential index retrieval related calls
 *  
 *  @rdesc  If succeeded, the function will return a pointer to index structure.
 *      If failed, it will return NULL, and the error buffer will contain the
 *      description of the error
 *************************************************************************/

PUBLIC LPIDX EXPORT_API FAR PASCAL MVIndexOpen (HFPB hfpbSysFile,
    LSZ lszFilename, PHRESULT  phr)
{
    _LPIDX  lpidx;      // Index information.
    HIDX    hidx;       // Handle to "lpidx".
    HRESULT     fRet;
    HANDLE  handle;
	LANGID	langidFull;
	LANGID	langidPrimary;

    /* Allocate an IDX structure */
    if ((hidx = _GLOBALALLOC(GMEM_MOVEABLE | GMEM_ZEROINIT, 
        sizeof(IDX))) == NULL) 
    {
        SetErrCode(phr, E_OUTOFMEMORY);
        return NULL;
    }
    lpidx = (_LPIDX)_GLOBALLOCK(hidx);
    lpidx->hStruct = hidx;

#if 0
    lpidx->lpfnfInterCb = lpfnfInterCb;
    lpidx->lpvCbParams = lpvCbParams;
#endif

    lpidx->lperrb = phr;

    /* Regular DOS file */
    if ((lpidx->hfpbIdxSubFile = (HFPB)FileOpen (hfpbSysFile, lszFilename,
        hfpbSysFile ? FS_SUBFILE : REGULAR_FILE, READ, phr)) == 0) 
    {
exit0:
        FreeHandle(hidx);
        return NULL;
    }
    

    if ((fRet = ReadIndexHeader(lpidx->hfpbIdxSubFile, &lpidx->ih)) != S_OK) 
    {
exit01: 
        SetErrCode (phr, fRet);
        IndexCloseFile(lpidx);
        goto exit0;
    }
    if (lpidx->ih.version != VERCURRENT || lpidx->ih.FileStamp != INDEX_STAMP) 
    {
        fRet = E_BADVERSION;
        goto exit01;
    }

    /* Set the slack size */
    lpidx->wSlackSize = LEAF_SLACK;

	langidPrimary = PRIMARYLANGID(langidFull = LANGIDFROMLCID(lpidx->ih.lcid));

    /* Build the Lead-Byte Table */
    if (langidPrimary == LANG_JAPANESE
        || langidPrimary == LANG_CHINESE
        || langidPrimary == LANG_KOREAN)
    {
        if (NULL == (handle = _GLOBALALLOC
            (GMEM_MOVEABLE | GMEM_ZEROINIT, 256)))
        {
            SetErrCode (phr, E_OUTOFMEMORY);
            fRet = E_OUTOFMEMORY;
            goto exit01;
        }
        lpidx->pLeadByteTable = (LPBYTE)_GLOBALLOCK (handle);
        lpidx->hLeadByteTable = handle;
        switch (langidPrimary)
        {
            case LANG_JAPANESE:
                MEMSET (lpidx->pLeadByteTable + 0x81, '\1', 0x1F);
                MEMSET (lpidx->pLeadByteTable + 0xE0, '\1', 0x1D);
                break;

			case LANG_CHINESE:
				switch (SUBLANGID(langidFull))
				{
				case SUBLANG_CHINESE_TRADITIONAL:
					MEMSET (lpidx->pLeadByteTable + 0x81, '\1', 0x7E);
					break;

				case SUBLANG_CHINESE_SIMPLIFIED:
				default:
					// Simplified Chinese and Korean have the same lead-bytes
					MEMSET (lpidx->pLeadByteTable + 0xA1, '\1', 0x5E);
					break;
				}
				break;

            case LANG_KOREAN:
				// Simplified Chinese and Korean have the same lead-bytes
                MEMSET (lpidx->pLeadByteTable + 0xA1, '\1', 0x5E);
                break;
        }
    }

    if ((fRet = TopNodeRead(lpidx)) != S_OK)
    {
        if (lpidx->pLeadByteTable)
        {
            _GLOBALUNLOCK (lpidx->hLeadByteTable);
            _GLOBALFREE (lpidx->hLeadByteTable);
        }
        goto exit01;
    }

	/* The the callback key */
	lpidx->dwKey = CALLBACKKEY;
    return (LPIDX)lpidx;
}

/*************************************************************************
 *  @doc    EXTERNAL API RETRIEVAL
 *  
 *  @func void FAR PASCAL | MVIndexClose |
 *      Close an index file, and release all allocated memory associated with
 *      the index
 *  
 *  @parm LPIDX | lpidx |
 *      Pointer to index information structure (got from IndexOpen())
 *************************************************************************/
//  Shuts down an index.
    
PUBLIC void EXPORT_API FAR PASCAL MVIndexClose(_LPIDX lpidx)
{
    if (lpidx == NULL)
        return;
    TopNodePurge(lpidx);
    IndexCloseFile(lpidx);
    if (lpidx->pLeadByteTable)
    {
        _GLOBALUNLOCK (lpidx->hLeadByteTable);
        _GLOBALFREE (lpidx->hLeadByteTable);
    }
    FreeHandle(lpidx->hStruct);
}

/*************************************************************************
 *  @doc    EXTERNAL API RETRIEVAL
 *  
 *  @func void FAR PASCAL | MVGetIndexInfoLpidx |
 *      Fills in an INDEXINFO struct given an LPIDX.  All members of the
 *		INDEXINFO struct are filled in except for dwMemSize.
 *  
 *  @parm LPIDX | lpidx |
 *      Pointer to index information structure (got from IndexOpen())
 *  @parm INDEXINFO* | lpindexinfo |
 *      Pointer to public index information structure.
 *************************************************************************/
PUBLIC void EXPORT_API PASCAL FAR MVGetIndexInfoLpidx(LPIDX lpidx,
													INDEXINFO *lpindexinfo)
{
	_LPIDX	_lpidx;
	
	if (lpidx == NULL || lpindexinfo == NULL)
		return;
		
	_lpidx = (_LPIDX) lpidx;
	
    lpindexinfo->dwBlockSize = _lpidx->ih.dwBlockSize;
    lpindexinfo->Occf = _lpidx->ih.occf;
    lpindexinfo->Idxf = _lpidx->ih.idxf;
	lpindexinfo->dwCodePageID = _lpidx->ih.dwCodePageID;
	lpindexinfo->lcid = _lpidx->ih.lcid;
	lpindexinfo->dwBreakerInstID = _lpidx->ih.dwBreakerInstID;
}

/*************************************************************************
 *  @doc    EXTERNAL API RETRIEVAL
 *  
 *  @func void FAR PASCAL | MVStopSearch |
 *      This function will stop the search process. Typically it can be
 *      only used in a multithreaded environment, where another thread
 *      will use the query structure, which is currently accessed by the
 *      the current search, to tell the search process to stop.
 *  
 *  @parm LPQT | lpqt |
 *      Pointer to the query structure used by MVIndexSearch()
 *************************************************************************/
PUBLIC VOID EXPORT_API FAR PASCAL MVStopSearch (_LPQT lpqt)
{
    lpqt->fInterrupt = (BYTE)E_INTERRUPT;
}    

/*************************************************************************
 *  @doc    EXTERNAL API RETRIEVAL
 *  
 *  @func void FAR PASCAL | MVSearchSetCallback |
 *      Set appropriate user's call back function to be called during the search.
 *      The user's function will be polled at interval. It should return
 *      S_OK if there is nothing to process, E_INTERRUPT to abort the
 *      search and dispose the search result, or ERR_TOOMANYDOCS to abort the
 *      search, but keep the partial result
 *  @parm   LPQT | lpqt |
 *      Pointer to query structure returned by MVQueryParse().
 *  @parm   PFCALLBACK_MSG | pfCallBackMsg |
 *      Pointer to call back structure
 *  @rdesc  Return S_OK if successful, or E_INVALIDARG if any parameter
 *      is NULL
 *************************************************************************/
PUBLIC HRESULT EXPORT_API FAR PASCAL MVSearchSetCallback (_LPQT lpqt,
    PFCALLBACK_MSG pfCallBackMsg)
{
    if (lpqt == NULL || pfCallBackMsg == NULL)    
        return(E_INVALIDARG);
    lpqt->cStruct.Callback = *pfCallBackMsg;
    return(S_OK);
}

/*************************************************************************
 *  @doc    EXTERNAL API RETRIEVAL
 *
 *  @func   LPHL FAR PASCAL | MVIndexSearch |
 *      Carry the search
 *
 *  @parm LPIDX | lpidx |
 *       Pointer to index information.
 *
 *  @parm   LPQT | lpqt |
 *      Pointer to query tree (returned by MVQueryParse())
 *
 *  @parm   PSRCHINFO | pSrchInfo |
 *      Pointer to search information data
 *
 *  @parm _LPGROUP | lpResGroup |
 *     Pointer to resulting group
 *
 *  @parm  PHRESULT | phr |
 *     Pointer to error buffer
 *
 *  @rdesc Pointer to hitlist structure if succeeded, even there is
 *      no hits (use MVHitListEntries() to find out how many hits have been
 *      returned). It will return NULL if failed. The error buffer
 *      (see IndexOpen()) will contain descriptions about the cause of
 *      the failure. There is one special case when the function returns
 *      a non-null pointer, even there is error, that is when it can't
 *      write the result to the disk, and everything is still in memory.
 *
 *************************************************************************/

PUBLIC LPHL EXPORT_API FAR PASCAL MVIndexSearch (_LPIDX lpidx,
  _LPQT lpqt, PSRCHINFO pSrchInfo, _LPGROUP lpResGroup, PHRESULT phr)
{
    HRESULT fRet;           // Return from this function.
    LPRETV  lpRetV;     // Retrieval memory/files.
    GHANDLE hRetv;
    OCCF    occf;       // Index occurence flags temporary variable.
    _LPHL   lphl;       // Pointer to hitlist
    _LPQTNODE   lpTreeTop;

    if (lpidx == NULL || lpqt == NULL || pSrchInfo == NULL)
    {
        /* We get some bad arguments!! */
        SetErrCode (phr, E_INVALIDARG);
        return NULL;
    }

    fRet = E_FAIL;      // Assume thing will go wrong
    
    // Transfer all the information about the index to the query tree
    lpqt->foIdxRoot = lpidx->ih.foIdxRoot;      /* Top node offset */
    lpqt->dwBlockSize = lpidx->ih.dwBlockSize;  /* Index block size */
    lpqt->cIdxLevels = lpidx->ih.cIdxLevels;         /* Index's depth */
    lpqt->occf = lpidx->ih.occf;
    lpqt->idxf = lpidx->ih.idxf;
    lpqt->foIdxRoot = lpidx->ih.foIdxRoot;
    lpqt->ckeyTopicId = lpidx->ih.ckeyTopicId;
    lpqt->ckeyOccCount = lpidx->ih.ckeyOccCount;
    lpqt->ckeyWordCount = lpidx->ih.ckeyWordCount;
    lpqt->ckeyOffset = lpidx->ih.ckeyOffset;
    if (lpqt->cQuery == 1)
	lpqt->fFlag |= ALL_ANDORNOT;

#if 1
	if (pSrchInfo->dwMemAllowed)
	{
        if (DO_FAST_MERGE(pSrchInfo, lpqt))
        {
		    SetBlockCount (lpqt->lpTopicMemBlock, (WORD)(pSrchInfo->dwMemAllowed /
			    (sizeof(TOPIC_LIST) * cTOPIC_PER_BLOCK)));

		    SetBlockCount (lpqt->lpOccMemBlock, 1);
        }
        else
        {
		    SetBlockCount (lpqt->lpTopicMemBlock, (WORD)(pSrchInfo->dwMemAllowed * 2 /
			    (5 * sizeof(TOPIC_LIST) * cTOPIC_PER_BLOCK)));

		    SetBlockCount (lpqt->lpOccMemBlock, (WORD)(pSrchInfo->dwMemAllowed * 3 /
			    (5 * sizeof(OCCURENCE) * cOCC_PER_BLOCK)));
        }
	}
#endif

    /* Allocate hitlist */
    if ((lphl = (_LPHL)GLOBALLOCKEDSTRUCTMEMALLOC(sizeof (HL))) == NULL) 
    {
        SetErrCode(phr, E_OUTOFMEMORY);
        return NULL;
    }
    lphl->lLastTopicId = 0xffffffff;
    lphl->lcMaxTopic = lpidx->ih.lcTopics;

    /* Allocate a return value structure */

    if ((hRetv = _GLOBALALLOC(GMEM_MOVEABLE | GMEM_ZEROINIT,
        sizeof(RETV))) == NULL)
    {
        SetErrCode(phr, E_OUTOFMEMORY);
exit0:
        if (fRet != S_OK && fRet != E_TOOMANYTOPICS)
        {
            MVHitListDispose(lphl);
            lphl = NULL;
        }
        return (LPHL)lphl;
    }

    lpRetV = (LPRETV)_GLOBALLOCK(hRetv);
    lpRetV->lpqt = lpqt;

    if ((fRet = TopNodeRead(lpidx)) != S_OK)
    {
        SetErrCode (phr, fRet);
exit02:
        FreeHandle(hRetv);
        goto exit0;
    }

    //
    //  Count the number of occurence fields present.  My retrieval
    //  occurence record is going to cost 4 bytes per field.
    //

    occf = lpqt->occf;
    for (lpRetV->cOccFields = 0; occf; lpRetV->cOccFields++)
        occf &= occf - 1;

    lpqt->dwOccSize = lpRetV->dwOccSize =
        sizeof(OCCURENCE) + lpRetV->cOccFields * sizeof (DWORD);

    lpRetV->fRank = ((pSrchInfo->Flag &
		(QUERYRESULT_RANK | QUERYRESULT_NORMALIZE)) != 0);

    // Set pointer to various buffer
    lpRetV->LeafInfo.pTopNode = lpidx->lrgbTopNode;
    lpRetV->LeafInfo.pStemNode = lpRetV->pNodeBuf;
    lpRetV->LeafInfo.pLeafNode = lpRetV->pNodeBuf;
    lpRetV->LeafInfo.pDataNode = lpRetV->pDataBuf;
    lpRetV->LeafInfo.hfpbIdx = lpidx->hfpbIdxSubFile;   // Index file to read from
    
    lpRetV->DataInfo.pTopNode = lpidx->lrgbTopNode;
    lpRetV->DataInfo.pStemNode = lpRetV->pNodeBuf;
    lpRetV->DataInfo.pLeafNode = lpRetV->pNodeBuf;
    lpRetV->DataInfo.pDataNode = lpRetV->pDataBuf;
    lpRetV->DataInfo.hfpbIdx = lpidx->hfpbIdxSubFile;   // Index file to read from
	lpRetV->lcid = lpidx->ih.lcid;
    lpRetV->pLeadByteTable = lpidx->pLeadByteTable;

    // Save search information
    lpRetV->SrchInfo = *pSrchInfo;
    if (pSrchInfo->dwValue == 0)
        lpRetV->SrchInfo.dwValue = (DWORD)(-1);
    else
        lpRetV->SrchInfo.dwValue = lpidx->ih.lcTopics/pSrchInfo->dwValue;
    
    if ( (fRet = ResolveTree(lpqt, lpTreeTop = lpqt->lpTopNode,
        lpRetV, E_FAIL)) != S_OK)
    {
        SetErrCode (phr, fRet);

        /* Free the Topic and Occurrence memory blocks since they are
         * not freed by QueryTreeFree(), or MVHitListDispose() at this
         * point
         */

        if (fRet != E_TOOMANYTOPICS)
        {
            BlockFree ((LPV)lpqt->lpTopicMemBlock);
            BlockFree ((LPV)lpqt->lpOccMemBlock);
            lpqt->lpTopicMemBlock = NULL;
            lpqt->lpOccMemBlock = NULL;
            goto exit02;
        }
    }

    if (lpqt->fFlag & HAS_NEAR_RESULT)
    {
        NearHandlerCleanUp (lpqt, lpTreeTop);
    }

    /* Create a group if requested */
    if ((pSrchInfo->Flag & QUERYRESULT_GROUPCREATE) && lpResGroup)
    {
        LPITOPIC    lpCurTopic;     /* Topic's current pointer */
        LPB         lpbGrpBitVect;
        DWORD       maxTopicId;
       /* Initialize the pointer */
        lpbGrpBitVect = lpResGroup->lpbGrpBitVect;

        maxTopicId = lpResGroup->dwSize * 8;
        for (lpCurTopic = QTN_TOPICLIST(lpTreeTop); lpCurTopic;
           lpCurTopic = lpCurTopic->pNext)
        {
            /* Set the bit */
            if (lpCurTopic->dwTopicId < maxTopicId)
            {
                lpbGrpBitVect[(DWORD)(lpCurTopic->dwTopicId / 8)] |= 1 <<
                   (lpCurTopic->dwTopicId % 8);
            }
        }
		lpResGroup->lcItem = lpTreeTop->cTopic;  // erinfox: this wasn't getting set!
    }
    
    if ((pSrchInfo->Flag & QUERYRESULT_UIDSORT) == 0)
    {

		// if we are skipping occurrence info, topic weights
		// will have already been calculated directly
		if (lpRetV->fRank && !DO_FAST_MERGE(pSrchInfo, lpqt))
			TopicWeightCalc(QTN_TOPICLIST(lpTreeTop));

        if (lpqt->fFlag & (HAS_NEAR_RESULT | ORDERED_BASED)) 
        {
            SortResult (lpqt, lpTreeTop, ORDERED_BASED);
            lpqt->fFlag &= ~(HAS_NEAR_RESULT | TO_BE_SORTED);
        }

        /* Sort the result depending on ranking or not */
        if (lpRetV->fRank)
            SortResult ((LPQT)lpqt, lpTreeTop, WEIGHT_BASED);
        else
            SortResult ((LPQT)lpqt, lpTreeTop, HIT_COUNT_BASED);
    } 

    /* Update HitList info structure, cut off the unwanted list */
    if (lphl->lpTopicList = lpTreeTop->lpTopicList)
        lphl->lcReturnedTopics = lphl->lcTotalNumOfTopics = lpTreeTop->cTopic;
        
    // Only return the number of topics that the user requested    
	// if dwTopicCount == 0, it means that the user wants to return all

	if (pSrchInfo->dwTopicCount != 0 &&
		pSrchInfo->dwTopicCount < lphl->lcReturnedTopics)
        lphl->lcReturnedTopics = pSrchInfo->dwTopicCount;

    lphl->lpOccMemBlock = lpqt->lpOccMemBlock;
    lphl->lpTopicMemBlock = lpqt->lpTopicMemBlock;

#if 1
    /* WARNING: The following code should be commented out for
     * diskless devices. No returned error is checked, since
     * if disk writes fail, everything is still in memory
     */

    if ((pSrchInfo->Flag & QUERYRESULT_IN_MEM) == 0)
    {
        if ((fRet = MVHitListFlush (lphl, lphl->lcReturnedTopics)) != S_OK)
            SetErrCode (phr, fRet);
    }
#endif
    goto exit02;
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   HRESULT PASCAL NEAR | ResolveTree |
 *      This function will read in the data from the index file for
 *      each word, and combine them according to the operators.
 *
 *  @func   _LPQT | lpqt |
 *      Index information
 *
 *  @parm   _LPQTNODE | lpQtNode |
 *      Query tree top node to be resolved
 *
 *  @parm   LPRETV | lpRetV |
 *      Returned values
 *
 *  @parm   int | fDivide |
 *      Divide the weight between occurences
 *
 *  @rdesc  S_OK, or other errors
 *************************************************************************/
PUBLIC HRESULT PASCAL NEAR ResolveTree(_LPQT lpqt, _LPQTNODE lpQtNode,
    LPRETV lpRetV, int fDivide)
{
    _LPQTNODE lpLeft;   /* Left node */
    _LPQTNODE lpRight;  /* Right node */
    WORD OpVal;         /* Operator value */
    WORD NodeType;      /* type of node */
    HRESULT fRet = S_OK;         /* Return value */
    HRESULT fOutOfMemory = S_OK;
    _LPQT lpQueryTree = lpRetV->lpqt;
    _LPQTNODE FAR *rgStack;
    HANDLE hStack;
    int StackTop = -1;
	
    /* Allocate a stack large enough to handle the tree's "recursion" */
    if ((hStack = _GLOBALALLOC(DLLGMEM_ZEROINIT, (LCB)lpQueryTree->TreeDepth *
        sizeof(_LPQTNODE))) == NULL)
        return E_OUTOFMEMORY;

    rgStack = (_LPQTNODE FAR *)_GLOBALLOCK(hStack);

    /* Traverse the tree */
    for (; lpQtNode;)
    {
        if (QTN_FLAG(lpQtNode) & PROCESSED)
        {
            /* This node has already been processed, just move up one
             * level, and continue the process
             */
            goto PopStack;
        }

        /* Handle TERM_NODE */

        if ((NodeType = QTN_NODETYPE(lpQtNode)) == TERM_NODE)
        {
            lpQueryTree->lpTopicStartSearch = NULL;
            lpQueryTree->lpOccStartSearch = NULL;
            if ((fRet = LoadNode (lpqt, OR_OP, NULL, lpQtNode,
                lpRetV, fDivide, fOutOfMemory)) != S_OK)
            {
                if (fRet != E_TOOMANYTOPICS)
                    goto Exit;

				fOutOfMemory = E_TOOMANYTOPICS;
				// kevynct: delay abort until processing of operator node
                // goto TooManyHits;
            }
            if (QTN_TOPICLIST(lpQtNode))
                QTN_NODETYPE(lpQtNode) = EXPRESSION_NODE;
            else
                QTN_NODETYPE(lpQtNode) = NULL_NODE;

            /* Mark that the node has been processed */
            QTN_FLAG(lpQtNode) |= PROCESSED;
            goto PopStack;
        }

        OpVal = lpQtNode->OpVal;
        if (NodeType == OPERATOR_NODE)
        {

            if ((QTN_FLAG(lpLeft = QTN_LEFT(lpQtNode)) & PROCESSED) == 0)
            {
                /* Resolve left tree if we have not resolve it yet
                 * Push the current node onto the stack, and process the
                 * left node
                 */
                rgStack[++StackTop] = lpQtNode;
                lpQtNode = lpLeft;
                continue;
            }

            /* Assertion for correctness */
            RET_ASSERT (QTN_NODETYPE(lpLeft) == EXPRESSION_NODE ||
                QTN_NODETYPE(lpLeft) == NULL_NODE);

            /* Binary operator. */

            /* Special cases */
            if (QTN_NODETYPE(lpLeft) == NULL_NODE)
            {
                switch (OpVal)
                {
                    case AND_OP: // NULL & a = NULL
                    case NEAR_OP: // NULL NEAR a = NULL
                    case PHRASE_OP: // NULL PHRASE a = NULL ??
                    case NOT_OP: // NULL not a = NULL
                        /*
                         * Change the sub-tree to a node and forget about
                         * the right sub-tree that is not processed yet
                         */
                        *lpQtNode = *lpLeft;
                        QTN_RIGHT(lpQtNode) = QTN_LEFT(lpQtNode) = NULL;
                        goto PopStack;
                }
            }

            // kevynct: Handle partial hit list:
			//
            // In case we run out of memory for the left tree, we can sometimes still
            // partially handle the right tree. For example, we keep going if AND-like op with 
			// right term node since this will likely at least increase chance of a smaller, more 
			// meaningful result.  For OR-like operators, we ignore right sub-tree altogether if 
			// we haven't already traversed it.
			//
			// In any case, if there was a partial hitlist this function will still return 
			// with E_TOOMANYTOPICS.

            if (fOutOfMemory)
			{
                switch (OpVal)
                {
					case OR_OP:
						// if right subtree already processed, keep it, since all memory
						// has already been allocated by this point and the handler will merely
						// combine.
						if (QTN_FLAG(QTN_RIGHT(lpQtNode)) & PROCESSED)
							break;
                        /*
                         * Change the sub-tree to a node and forget about
                         * the right sub-tree that is not processed yet
                         */
                        *lpQtNode = *lpLeft;
                        QTN_RIGHT(lpQtNode) = QTN_LEFT(lpQtNode) = NULL;
                        goto PopStack;

                    case AND_OP:
                    case NEAR_OP:
                    case PHRASE_OP:
                    case NOT_OP:
						// continue processing if right node is a single term OR we've already
						// processed it.  otherwise, another left node will get loaded later and we know we are
						// already oom.

						if ((QTN_FLAG(QTN_RIGHT(lpQtNode)) & PROCESSED)
							 || 
							 QTN_NODETYPE(QTN_RIGHT(lpQtNode)) == TERM_NODE)
							break;
						// warning: fallthru
					default:					
						goto TooManyHits;
                }
            }

            /* Make some preparations before resolving the right tree */

            lpQueryTree->lpTopicStartSearch = NULL;
            lpQueryTree->lpOccStartSearch = NULL;

            /* Do some preparations for NOT operator */
            if (OpVal == NOT_OP)
            {
                MarkTopicList(lpLeft);
            }

            if (OpVal != PHRASE_OP && OpVal != NEAR_OP &&
                (lpQueryTree->fFlag & TO_BE_SORTED))
            {

                if (lpQueryTree->fFlag & HAS_NEAR_RESULT)
                    NearHandlerCleanUp (lpQueryTree, lpLeft);

                /* We have to sort the left tree, which is the result of PHRASE,
                 * to remove redundancies. This step should only be done after
                 * we finishes processing ALL PHRASE terms. Same for NEAR
                 */

                lpQueryTree->fFlag &= ~TO_BE_SORTED;
                SortResult (lpQueryTree, lpLeft, ORDERED_BASED);
            }

            /* Resolve the right tree */
            if (QTN_NODETYPE(lpRight = QTN_RIGHT(lpQtNode)) == TERM_NODE)
            {

                /* Handle EXPRESSION_TERM */

                if ((fRet = LoadNode (lpqt, OpVal, lpLeft, lpRight,
                    lpRetV, fDivide, fOutOfMemory)) != S_OK)
                {
                    if (fRet != E_TOOMANYTOPICS)
                        goto Exit;

					fOutOfMemory = E_TOOMANYTOPICS;
					// kevynct: delay abort until processing of operator node
			        // goto TooManyHits;
                }

                switch (OpVal)
                {
                    case NEAR_OP:
                        RemoveUnmarkedNearTopicList(lpQueryTree, lpLeft);
                        lpQueryTree->fFlag |= TO_BE_SORTED | HAS_NEAR_RESULT;
                        break;

                    case PHRASE_OP:
                        RemoveUnmarkedTopicList(lpQueryTree, lpLeft, !KEEP_OCC);
                        lpQueryTree->fFlag |= TO_BE_SORTED;
                        break;

                    case AND_OP:
                        RemoveUnmarkedTopicList(lpQueryTree, lpLeft, KEEP_OCC);
                        CleanMarkedOccList (lpLeft->lpTopicList);
                        break;

                    case NOT_OP:
                        RemoveUnmarkedTopicList(lpQueryTree, lpLeft, KEEP_OCC);
                        break;
                }
                if (QTN_TOPICLIST(lpLeft))
                    QTN_NODETYPE(lpLeft) = EXPRESSION_NODE;
                else
                    QTN_NODETYPE(lpLeft) = NULL_NODE;

            }
            else
            {

                if ((QTN_FLAG(lpRight = QTN_RIGHT(lpQtNode)) &
                    PROCESSED) == 0)
                {

                    /* Resolve right tree if we have not resolved it yet
                     * Push the current node onto the stack, and process the
                     * left node
                     */

                    rgStack[++StackTop] = lpQtNode;
                    lpQtNode = lpRight;
                    continue;
                }

                /* Apply the operator */
                if ((fRet = (*HandlerFuncTable[OpVal])(lpQueryTree, 
                    lpLeft, NULL, (BYTE FAR *)lpRight,
                    EXPRESSION_EXPRESSION)) != S_OK)
                {

                    /* Copy the result, and release the nodes */
                    if (fRet != E_TOOMANYTOPICS)
                        goto Exit;

					// kevynct: we check for out of memory below
                }
                switch (OpVal)
                {
                    case NEAR_OP:
                        lpQueryTree->fFlag |=  HAS_NEAR_RESULT;
                        RemoveUnmarkedNearTopicList(lpQueryTree, lpLeft);      
                        break;

                    case PHRASE_OP:
                        RemoveUnmarkedTopicList(lpQueryTree, lpLeft, !KEEP_OCC);
                        break;

                    case NOT_OP:
                        RemoveUnmarkedTopicList(lpQueryTree, lpLeft, KEEP_OCC);
                        break;
                }
            }

            *lpQtNode = *lpLeft;    // Change the sub-tree to a node
            QTN_FLAG(lpQtNode) |= PROCESSED;
#if 0
            FreeHandle (lpLeft->hStruct);
            FreeHandle (lpRight->hStruct);
#endif
            QTN_LEFT(lpQtNode) = QTN_RIGHT(lpQtNode) = NULL;

			// kevynct: only quit if this error comes from processing a real operator node
			// since fOutOfMemory is not set in that case above, whereas it IS set
			// when processing term node.  Just a hack.
            if (fRet == E_TOOMANYTOPICS && !fOutOfMemory)
                goto TooManyHits;
        }
PopStack:
        if (StackTop >= 0)
        {
            lpQtNode = rgStack[StackTop];
            StackTop--;
        }
        else 
            break;

    }

	// kevynct: if we got this far, the tree was completed, but we may have only 
	// been processing a partial hitlist (e.g. multiple "and") so we need
	// to still notify of possible oom even though all cleanup has been done
	fRet = fOutOfMemory;

Exit:
    /* Release the stack */
    FreeHandle(hStack);
    return fRet;


TooManyHits:
    /* If we hit that label, it means that we have too many hits
     * lpQtNode is the left node, the right node has been
     * processed. What we have to do now is to keep the partial
     * result, and release all nodes
     */

    if (StackTop >= 0)
    {
        /* The root node is saved on the stack */
        lpLeft = QTN_LEFT(*rgStack);
        lpRight = QTN_RIGHT(*rgStack);
        QTN_LEFT(*rgStack) = QTN_RIGHT(*rgStack) = NULL;
        *rgStack[0] = *lpQtNode;
    }
    FreeHandle(hStack);
    return E_TOOMANYTOPICS;
}

VOID PASCAL FAR TopicWeightCalc(LPITOPIC  lpCurTopic)
{
    LPIOCC  lpCurOcc;
    WORD    wWeight;

    for (; lpCurTopic; lpCurTopic = lpCurTopic->pNext)
    {
        wWeight = 0;
        for (lpCurOcc = lpCurTopic->lpOccur; lpCurOcc;
            lpCurOcc = lpCurOcc->pNext)
        {
            if (wWeight > (WORD)(wWeight + lpCurOcc->wWeight))
			{
                wWeight = MAX_WEIGHT;
				break;
			}
            else
                wWeight += lpCurOcc->wWeight;
        }
        lpCurTopic->wWeight = wWeight;
    }
}


#if 0
/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   HRESULT FAR PASCAL | GetWordDataLocation |
 *      This function will search the index for the given word. It will
 *      return back information about:
 *      - The number of topics
 *      - The location of the data
 *      - The size of the data
 *      - Pointer to the next word (for wildcard search)
 *  @parm   _LPQT | lpqt |
 *      Pointer to index structure
 *  @parm   LPRETV | lpRetV |
 *      Pointer to "globals"
 *  @parm   _LPQTNODE | lpCurQtNode |
 *      Current node in the query tree
 *  @rdesc  S_OK or other errors
 *************************************************************************/
PRIVATE HRESULT NEAR PASCAL GetWordDataLocation (_LPQT lpqt,
    LPRETV lpRetV, _LPQTNODE lpCurQtNode)
{
    int     cLevel;
    int     cMaxLevel;
    int     fCheckFieldId;
    LST     lstSearchStr;
    LPB     lpCurPtr;        
    int     nCmp;
    HRESULT     fRet;
    int     f1stIsWild;
    LPB     lpMaxAddress;
    PNODEINFO    pLeafInfo = &lpRetV->LeafInfo;
    DWORD   dwTemp;
    LPB     astBTreeWord = lpRetV->pBTreeWord;
    WORD    wLen;
    DWORD   dwFieldID;
    ERRB    errb;

    BYTE lstModified[CB_MAX_WORD_LEN + sizeof (SHORT)];

    lstSearchStr = QTN_TOKEN(lpCurQtNode)->lpString;
    f1stIsWild = (lstSearchStr[2] == WILDCARD_CHAR ||
        lstSearchStr[2] == WILDCARD_STAR);

    pLeafInfo->nodeOffset = lpqt->foIdxRoot;
    pLeafInfo->iLeafLevel = lpqt->cIdxLevels - 1;
    pLeafInfo->dwBlockSize = lpqt->dwBlockSize;

    /* Copy and change all '*' and '?' to 0. This will
     * ensure that things gets compared correctly with
     * the top node's entries
     */
    MEMCPY (lstModified, lstSearchStr, 
        *((LPW)lstSearchStr) + sizeof (SHORT));
    for (nCmp = *((LPW)lstModified) + 1; nCmp > 2; nCmp--)
    {
        if (lstModified[nCmp] == '*' || lstModified[nCmp] == '?')
        {
            lstModified[nCmp] = 0;
            lstModified[0] = nCmp - 2;
        }
    }

    /*
     * Point node-resolution variables at the right things.  This
     * sets these up to read b-tree nodes.  Fields not set here are
     * set as appropriate elsewhere.
     */

    /* Set the flag */
    fCheckFieldId = ((lpqt->occf & OCCF_FIELDID) &&
        (lpCurQtNode->dwFieldId != DW_NIL_FIELD));

    astBTreeWord[0] = 0;
    cMaxLevel = lpqt->cIdxLevels - 1;

    /*
    First we have to find which tree level the word is in. The number of
    searches is equal to the number of tree levels at most. The
    structure of the directory node is a sequence of:
        - Words: PASCAL strings
        - Data offset: will tell us where is the
        offset of the record in the index file
    */
    for (cLevel = 0; cLevel < cMaxLevel ; cLevel++) 
    {
        //
        //  Get a node.
        //
        if ((fRet = ReadStemNode ((PNODEINFO)pLeafInfo, cLevel)) != S_OK)
        {
            return SetErrCode (&errb, fRet);
        }
        lpMaxAddress = pLeafInfo->pMaxAddress;
        lpCurPtr = pLeafInfo->pCurPtr;

        //
        //  Loop through it.  This compares the word I'm
        //  looking for against the word in the b-tree.
        //  If the word in the b-tree is >= the word I'm
        //  looking for, I'm done.
        //
        //  If I run off the end of the node, there can be
        //  no match for this term, so I skip the entire
        //  process.
        //
        for (;;)
        {
            
            if (lpCurPtr >= lpMaxAddress)
                return S_OK;
            lpCurPtr = ExtractWord(astBTreeWord, lpCurPtr, &wLen);

            /* Read in NodeId record */
            lpCurPtr += ReadFileOffset (&pLeafInfo->nodeOffset, lpCurPtr);

            if (f1stIsWild)
                break;

            if (StrCmpPascal2(lstModified, astBTreeWord) <= 0)
                break;

            // erinfox:
            // if stemming is turned on, there could be a case in which the stemmed
            // word is less than the search term, but the unstemmed word is greater.
            // if we don't check the unstemmed, we'll skip this node erroneously.
            if (fStemmed && StrCmpPascal2(lstModified, astBTreeWord) <= 0)
                break;

        }
    }
    
    /* At this point, pLeafInfo->nodeOffset is the node id of the leaf that
    is supposed to contain the searched word. Read in the leaf node
    */
    if ((fRet = ReadLeafNode ((PNODEINFO)pLeafInfo, cLevel)) != S_OK)
    {
        return fRet;
    }
    
    lpCurPtr = pLeafInfo->pCurPtr;
    lpMaxAddress = pLeafInfo->pMaxAddress;
    
    //
    //  Second step is to deal with the leaf node(s).  I'm going to
    //  find and capture some occurence lists.  I'll probably have to
    //  ignore some bogus ones first.
    //
    for (;;) 
    {
        // Check for out of data
        if (lpCurPtr >= lpMaxAddress)
        {
            // Get the offset of the next node
            ReadFileOffset (&pLeafInfo->nodeOffset, pLeafInfo->pBuffer);
            if (FoIsNil (pLeafInfo->nodeOffset))
                return S_OK;
                
            // Read the next node    
            if ((fRet = ReadStemNode ((PNODEINFO)pLeafInfo, cLevel))
                != S_OK)
            {
                return SetErrCode (&errb, fRet);
            }
            lpCurPtr = 
                pLeafInfo->pBuffer + FOFFSET_SIZE + sizeof (SHORT);
            lpMaxAddress = pLeafInfo->pMaxAddress;
        }
        
        // Extract the word
        lpCurPtr = ExtractWord(astBTreeWord, lpCurPtr, &wLen);
        
        // Save the word length
        lpCurQtNode->wRealLength = wLen;

        if (lpqt->occf & OCCF_FIELDID)
            lpCurPtr += CbByteUnpack (&dwFieldID, lpCurPtr);
            
        nCmp = CompareTerm (lpCurQtNode, astBTreeWord, fCheckFieldId ?
             dwFieldID : lpCurQtNode->dwFieldId, lpRetV->pLeadByteTable);
             
        switch (nCmp)
        {
            case KEEP_SEARCHING:
                // Skip TopicCount
                lpCurPtr += CbByteUnpack (&dwTemp, lpCurPtr);
                // Skip data offset
                lpCurPtr += FOFFSET_SIZE;
                // Skip DataSize
                lpCurPtr += CbByteUnpack (&dwTemp, lpCurPtr);
                break;

            case STRING_MATCH:
                lpCurPtr += CbByteUnpack (&lpCurQtNode->cTopic, lpCurPtr);
                lpCurPtr += ReadFileOffset (&lpCurQtNode->foData, lpCurPtr);
                lpCurPtr += CbByteUnpack (&lpCurQtNode->cbData, lpCurPtr);

                // Set FieldId to give back the field id
                lpCurQtNode->dwFieldId = dwFieldID;
                
                // Set return pointer to beginning of next node
                if (lpCurQtNode->iCurOff == 0)
                    lpCurQtNode->iCurOff = lpCurPtr - pLeafInfo->pBuffer;
                
                return S_OK;

            case NOT_FOUND: // No unconditional "break" above.
                return S_OK;
        }
    }
}
#endif

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   HRESULT FAR PASCAL | GetWordData |
 *      This function will search the index for the given word' data.
 *  @parm   _LPQT | lpqt |
 *      Pointer to index structure
 *  @parm   LPRETV | lpRetV |
 *      Pointer to "globals"
 *  @parm   _LPQTNODE | lpCurQtNode |
 *      Current node in the query tree containing important data
 *      - The number of topics
 *      - The location of the data
 *      - The size of the data
 *      - Pointer to the next word (for wildcard search)
 *  @rdesc  S_OK or other errors
 *************************************************************************/
PUBLIC HRESULT EXPORT_API FAR PASCAL GetWordData (_LPQT lpqt, LPRETV lpRetV, 
    int Operator, _LPQTNODE lpResQuery, _LPQTNODE lpQtNode, int fDivide, int fOutOfMemory)
{
    LPIOCC  lpOccur;        // The current occurence is collected into
                            //  here.
    DWORD   dwTopicIDDelta; // Topic-ID delta from previous sub-list.
    DWORD   dwOccs;         // Number of occurences in this sub-list.
    DWORD   dwTmp;          // Scratch variable.
    WORD    wWeight;        // Term-weight associated with this sub-list.
    DWORD   dwTopicID;      // TopicId 
    WORD    wImportance;
    DWORD   dwCount;        // Word count
    DWORD   dwOffset;       // Offset of the word
    DWORD   dwLength;       // Length of the word
    TOPIC_LIST FAR *lpResTopicList;  // Result TopicList
    HRESULT fRet;               // Returned value
    PNODEINFO pDataInfo;
    DWORD   dwTopicCount;
    _LPQT   lpQueryTree; // Query tree
    OCCF    occf;
    BYTE    fSkipOccList = FALSE;

    pDataInfo = &lpRetV->DataInfo;
    if ((pDataInfo->dwDataSizeLeft = lpQtNode->cbData) == 0)
        return(S_OK);    // There is nothing to process
        
    // Initialize variables
    occf = lpqt->occf;
    wImportance = QTN_TOKEN(lpQtNode)->wWeight;
    lpResTopicList = NULL;
    lpQueryTree = lpRetV->lpqt;
    dwTopicCount = lpQtNode->cTopic;
    wWeight = (WORD)(65535L/dwTopicCount);
    
    // Reset the topic count for lpQtNode so that is will not affect the
    // result in case that lpResQuery == NULL
    
    lpQtNode->cTopic = 0;
    
    if (lpResQuery == NULL)
        lpResQuery = lpQtNode;
        
    // Initialize the data buffer node values
    pDataInfo->pBuffer = pDataInfo->pDataNode;
    pDataInfo->nodeOffset = lpQtNode->foData;
    
    // Read the data block
    if ((fRet = ReadNewData(pDataInfo)) != S_OK)
        return(fRet);
        
    dwTopicID = 0L;         // Init occurence record
    dwLength = 0;

    //  One pass through here for each sublist in the Topiclist.

    for (; dwTopicCount; dwTopicCount--) 
    {
        
        /* Check for interrupt now and then */
        if ((++lpqt->cInterruptCount) == 0)
        {
            if (lpqt->fInterrupt == E_INTERRUPT)        
                return E_INTERRUPT;
            if (*lpqt->cStruct.Callback.MessageFunc &&
                (fRet = (*lpqt->cStruct.Callback.MessageFunc)(
                lpqt->cStruct.Callback.dwFlags,
                lpqt->cStruct.Callback.pUserData, NULL)) != S_OK)
                return(fRet);
        }
            
        // Byte align
        if (pDataInfo->ibit != cbitBYTE - 1)
        {
            pDataInfo->ibit = cbitBYTE - 1;
            pDataInfo->pCurPtr ++;
        }
        
        // Get value from which I will calculate current doc-ID.
        if ((fRet = FGetDword(pDataInfo, lpqt->ckeyTopicId,
            &dwTopicIDDelta)) != S_OK)
        {
exit0:
            return fRet;
        }

        dwTopicID += dwTopicIDDelta;
        //
        //  Get term-weight if present.  I'm going to get this
        //  even if I'm not doing ranking, because it's in the
        //  index, and I have to get around it somehow.
        //
        if (lpqt->idxf & IDXF_NORMALIZE) 
        {
            if ((fRet = FGetBits(pDataInfo, &dwTmp, sizeof (USHORT) * cbitBYTE))
                != S_OK)
                goto exit0;

            if (wImportance != MAX_WEIGHT)
                dwTmp = (dwTmp * wImportance) / 65535;
            wWeight = (WORD)dwTmp;
        }
        //
        //  If this search includes a group, and the doc is not in the
        //  group then ignore it
        fSkipOccList = (lpQueryTree->lpGroup &&
            FGroupLookup(lpQueryTree->lpGroup, dwTopicID) == FALSE);
        

		// erinfox: move test agains fSkipOccList outside
		if (!fSkipOccList)
		{
			if (/*!fSkipOccList && */((lpResTopicList = TopicNodeSearch (lpQueryTree,
				lpResQuery, dwTopicID)) == NULL))
			{
				/* Adding an new occurrence to a non-existing TopicList.  */
				/* Allocate the new TopicList only if it is an OR
				operator. This record should be skipped for all other
				operator
				*/
				if (Operator == OR_OP && !fOutOfMemory) 
				{
					if ((lpResTopicList = TopicNodeAllocate(lpQueryTree)) == NULL) 
					{
						fRet = E_TOOMANYTOPICS;
						goto exit0;
					}
					lpResTopicList->dwTopicId = dwTopicID;
					lpResTopicList->lpOccur = NULL;
					lpResTopicList->lcOccur = 0;
					lpResTopicList->wWeight = 0;              

					/* Add the new TopicID node into TopicList */
					TopicNodeInsert (lpQueryTree, lpResQuery, lpResTopicList);
				}
				else 
				{
					/* There is no corresponding Topic list. Consequently, we
					   don't need to read in the right node's data for
					   the following operators: AND, PHRASE, NEAR, NOT
					 */
					fSkipOccList = TRUE;
				}
			}
			else 
			{
				if (Operator == NOT_OP) 
				{
					/* Don't skip this Topic list since it also contains
					 * the right node's docId
					 */
					if (lpResTopicList)
						lpResTopicList->fFlag &= ~TO_BE_KEPT;
					fSkipOccList = TRUE;
				}
				else if (Operator == AND_OP && lpQueryTree->lpTopicStartSearch)
					lpQueryTree->lpTopicStartSearch->fFlag |= TO_BE_KEPT;
			}
		}
        lpQueryTree->lpOccStartSearch = NULL;

        if ((occf & (OCCF_OFFSET | OCCF_COUNT)) == 0)
            continue;
            
        //  Figure out how many occurences there are in this
        //  sub-list.
        //
        if ((fRet = FGetDword(pDataInfo, lpqt->ckeyOccCount,
            &dwOccs)) != S_OK) 
            goto exit0;

        if (fSkipOccList || fOutOfMemory)
        {
skip_occ_list:        
            if ((fRet = SkipOccList (lpqt, pDataInfo, dwOccs)) != S_OK)
                goto exit0;
            continue;
        }

        if ((lpqt->idxf & IDXF_NORMALIZE) == FALSE && lpRetV->fRank)
        {
            wWeight = (WORD)(wWeight * dwOccs);
        }

        //
        //  If I'm doing ranking, divide the weight for
        //  this topic amongst all the occurences in
        //  the topic if I need to.
        //
        if (lpRetV->fRank && fDivide)
        {
            if (dwOccs > 65535L)
                wWeight = 0;
            else if ((WORD)dwOccs > 1)
                wWeight /= (WORD)dwOccs;
        }

		// optimization for ISBU/IR:
		// if no highlighting info is needed, and this is not near-type query
		// then store the term weights in the topic list directly, and skip the occurrence
		// list completely.  If this is an AND or OR operator, then increment the existing 
		// weight since the occurrences are undergoing union.  NOT operator leaves 
		// current weight unchanged.

		if (DO_FAST_MERGE(&lpRetV->SrchInfo, lpqt))
			{
			if (lpResTopicList && (Operator == OR_OP || Operator == AND_OP) && lpRetV->fRank)
				lpResTopicList->wWeight = (WORD) min(MAX_WEIGHT, lpResTopicList->wWeight + wWeight * dwOccs);
			goto skip_occ_list;
			}
        
        //
        //  One pass through here for each occurence in
        //  this sub-list.  If this index doesn't really
        //  have sub-lists it will still make one pass
        //  through here anyway, at which time it will
        //  write the doc-ID and possibly the term-weight
        //  and field-ID, then drop out.
        //
        dwCount = 0L;
        dwOffset = 0L;
        
        for (; dwOccs; dwOccs--)
        {
			// interrupt about every 4096
			if ((dwOccs & 0x0FFF) == 0)
			{
				if (lpqt->fInterrupt == E_INTERRUPT)        
				{
					fRet = E_INTERRUPT;
					goto exit;
				}
				if (*lpqt->cStruct.Callback.MessageFunc &&
					(fRet = (*lpqt->cStruct.Callback.MessageFunc)(
					lpqt->cStruct.Callback.dwFlags,
					lpqt->cStruct.Callback.pUserData, NULL)) != S_OK)
					goto exit;
			}

            //  Get word-count, if present.
            //
            if ((lpOccur = OccNodeAllocate(lpQueryTree)) == NULL)
            {
                fRet = E_TOOMANYTOPICS;
                goto exit;
            }
            lpOccur->dwFieldId = lpQtNode->dwFieldId;
            lpOccur->cLength = lpQtNode->wRealLength;

			// If the caller requested term strings, put in the occurrence
			// record a pointer to the term that currently matches the query
			// we're gathering occurrence data for.            
   			if ((lpRetV->SrchInfo.Flag & QUERY_GETTERMS) != 0)
				lpOccur->lpvTerm = lpQtNode->lpvIndexedTerm;

            if (occf & OCCF_COUNT) 
            {
                if ((fRet = FGetDword(pDataInfo, lpqt->ckeyWordCount,
                    &dwTmp)) != S_OK)
                {
exit1:
                    /* Just release the occurence node */
                    lpOccur->pNext = (LPIOCC)lpQueryTree->lpOccFreeList;
                    lpQueryTree->lpOccFreeList = (LPSLINK)lpOccur;
                    goto exit0;
                }
                dwCount += dwTmp;
                lpOccur->dwCount = dwCount; // Needed for phrase and near
            }
            
            //  Get byte-offset, if present.
            //
            if (occf & OCCF_OFFSET) 
            {
                if ((fRet = FGetDword(pDataInfo, lpqt->ckeyOffset, &dwTmp))
                     != S_OK)
                {
                    goto exit1;
                }
                dwOffset += dwTmp;
                lpOccur->dwOffset = dwOffset;
            }
            //  Get term-weight, if present.
            //
            if (lpRetV->fRank)
            {
                if (!fDivide)
                    wWeight = 0;
                lpOccur->wWeight = wWeight;
            }
            
#ifndef CW
            if ((fRet = (*HandlerFuncTable[Operator])(lpQueryTree, 
                lpQtNode, lpResTopicList, (BYTE FAR *)lpOccur,

                EXPRESSION_TERM)) != S_OK)
            {
                goto exit;
            }
#else
            switch (Operator)
            {
                case NEAR_OP:
                    if ((fRet = NearHandler(lpQueryTree, 
                        lpQtNode, lpResTopicList, (BYTE FAR *)lpOccur,
                        EXPRESSION_TERM)) != S_OK)
                    {
                        goto exit;
                    }
                    break;

                case PHRASE_OP:
                    if ((fRet = PhraseHandler(lpQueryTree, 
                        lpQtNode, lpResTopicList, (BYTE FAR *)lpOccur,
                        EXPRESSION_TERM)) != S_OK)
                    {
                        goto exit;
                    }
                    break;

                case AND_OP:
                    if ((fRet = AndHandler(lpQueryTree, 
                        lpQtNode, lpResTopicList, (BYTE FAR *)lpOccur,
                        EXPRESSION_TERM)) != S_OK)
                    {
                        goto exit;
                    }
                    break;

                case NOT_OP:
                    if ((fRet = NotHandler(lpQueryTree, 
                        lpQtNode, lpResTopicList, (BYTE FAR *)lpOccur,
                        EXPRESSION_TERM)) != S_OK)
                    {
                        goto exit;
                    }
                    break;

                case OR_OP:
                    if ((fRet = OrHandler(lpQueryTree, 
                        lpQtNode, lpResTopicList, (BYTE FAR *)lpOccur,
                        EXPRESSION_TERM)) != S_OK)
                    {
                        goto exit;
                    }
                    break;

                default:
                    fRet = E_FAIL;
                    goto exit;
            }
#endif
        }
    }
    
    fRet = S_OK;

exit:
    /* Check to make sure that there are occurrences associcated with the
     * TopicList. The main reason for no occurrence is that the user hits
     * cancel when occurrences are being read in. Cancel will cause the
     * read to fail, and there is no occurrence associated with the Topic
     * List, which in turn, will cause hili code to fail. So, if there is
     * no occurrence, just remove the list
     */

    if (lpResTopicList && lpResTopicList->lcOccur == 0 
         &&
		!DO_FAST_MERGE(&lpRetV->SrchInfo, lpqt)
		 &&    
        (lpqt->occf & (OCCF_OFFSET | OCCF_COUNT)))
        RemoveNode(lpQueryTree, (LPV)lpResQuery, NULL,
            (LPSLINK)lpResTopicList, TOPICLIST_NODE);
    goto exit0;
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   HRESULT PASCAL NEAR | LoadNode |
 *      Load all the data related to a word from the index file,
 *      and apply the operator to them and the resulting data
 *
 *  @parm   _LPQT | lpqt |
 *      Index information
 *
 *  @parm   int | Operator |
 *      What operator we are dealing with
 *
 *  @parm   _LPQTNODE | lpResQuery |
 *      Resulting query node
 *
 *  @parm   _LPQTNODE | lpCurQtNode |
 *      Current query node
 *
 *  @parm   LPRETV | lpRetV |
 *      Returned result
 *
 *  @parm   int | fDivide |
 *      Divide the weight between occurences
 *
 *  @rdesc  S_OK if succeeded, errors otherwise
 *************************************************************************/

PRIVATE HRESULT PASCAL NEAR LoadNode (_LPQT lpqt, int Operator, 
    _LPQTNODE lpResQuery, _LPQTNODE lpCurQtNode, LPRETV lpRetV, int fDivide, int fOutOfMemory)
{
    int     cLevel;
    int     cMaxLevel;
    int     fCheckFieldId;
    LST     lstSearchStr;
    LPB     lpCurPtr;        
    int     nCmp;
    HRESULT     fRet;
    int     f1stIsWild;
    LPB     lpMaxAddress;
    PNODEINFO    pLeafInfo = &lpRetV->LeafInfo;
    DWORD   dwTemp;
    LPB     astBTreeWord = lpRetV->pBTreeWord;
    WORD    wLen;
    DWORD   dwFieldID;
    DWORD   dwTotalTopic;
    LPB     lstModified = lpRetV->pModifiedWord;
    BYTE    fStemmed;
    LPB     pBTreeWord;
    ERRB    errb;
	WORD    cByteMatched = 0;

    fStemmed = ((lpRetV->SrchInfo.Flag & STEMMED_SEARCH) != 0) &&
		(PRIMARYLANGID(LANGIDFROMLCID(lpRetV->lcid)) == LANG_ENGLISH);

    lstSearchStr = QTN_TOKEN(lpCurQtNode)->lpString;
    f1stIsWild = (lstSearchStr[2] == WILDCARD_CHAR ||
        lstSearchStr[2] == WILDCARD_STAR);

    // Make sure to turn of stemming if there is any wildcard characters
    
    for (nCmp = *((LPW)lstSearchStr) + 1; nCmp >= 2; nCmp--)
    {
        if (lstSearchStr[nCmp] == '*' || lstSearchStr[nCmp] == '?')
        {
            fStemmed = FALSE;
            break;
        }
    }

	// Turned off stemming for short words
	if (*(LPW)lstSearchStr < 3)
		fStemmed = FALSE;

    pLeafInfo->nodeOffset = lpqt->foIdxRoot;
    pLeafInfo->iLeafLevel = lpqt->cIdxLevels - 1;
    pLeafInfo->dwBlockSize = lpqt->dwBlockSize;

    if (fStemmed)
    {
        if ((fRet = ExtStemWord(lpRetV->SrchInfo.lpvIndexObjBridge,
        				&lpRetV->pStemmedQueryWord[0], lstSearchStr)) != S_OK)
        {
            return(fRet);
        }
        MEMCPY (lstModified, lpRetV->pStemmedQueryWord,
            *(LPW)lpRetV->pStemmedQueryWord + sizeof(WORD));
        pBTreeWord = lpRetV->pStemmedBTreeWord;

		for (nCmp = 2; nCmp <= *(LPW)lstModified+1; nCmp++)
		{
            if (lstModified[nCmp] == lstSearchStr[nCmp])
                cByteMatched++;
            else
                break;        
		}
    }
    else
    {
        // Restore the original word
        MEMCPY (lstModified, lstSearchStr, 
            *((LPW)lstSearchStr) + sizeof (SHORT));
        // Zero terminated for wildcard search    
        lstModified [*((LPW)lstModified) + 2] = 0;
        
        pBTreeWord = lpRetV->pBTreeWord;
    }
        
    /* Change all '*' and '?' to 0. This will
     * ensure that things gets compared correctly with
     * the top node's entries
     */
    for (nCmp = *((LPW)lstModified) + 1; nCmp >= 2; nCmp--)
    {
        if (lpRetV->pLeadByteTable
            && lpRetV->pLeadByteTable[lstModified[nCmp - 1]])
        {
            nCmp--;
        }
        else if (lstModified[nCmp] == '*' || lstModified[nCmp] == '?')
        {
            lstModified[nCmp] = 0;
            *(LPW)lstModified = nCmp - 2;
        }
    }

    /*
     * Point node-resolution variables at the right things.  This
     * sets these up to read b-tree nodes.  Fields not set here are
     * set as appropriate elsewhere.
     */

    /* Set the flag */
    fCheckFieldId = ((lpqt->occf & OCCF_FIELDID) &&
        (lpCurQtNode->dwFieldId != DW_NIL_FIELD));

    astBTreeWord[0] = 0;
    cMaxLevel = lpqt->cIdxLevels - 1;

    /*
    First we have to find which tree level the word is in. The number of
    searches is equal to the number of tree levels at most. The
    structure of the directory node is a sequence of:
        - Words: PASCAL strings
        - Data offset: will tell us where is the
        offset of the record in the index file
    */
    for (cLevel = 0; cLevel < cMaxLevel ; cLevel++) 
    {
        //
        //  Get a node.
        //
        if ((fRet = ReadStemNode ((PNODEINFO)pLeafInfo, cLevel)) != S_OK)
        {
            return SetErrCode (&errb, fRet);
        }
        lpMaxAddress = pLeafInfo->pMaxAddress;
        lpCurPtr = pLeafInfo->pCurPtr;

        //
        //  Loop through it.  This compares the word I'm
        //  looking for against the word in the b-tree.
        //  If the word in the b-tree is >= the word I'm
        //  looking for, I'm done.
        //
        //  If I run off the end of the node, there can be
        //  no match for this term, so I skip the entire
        //  process.
        //
        for (;;)
        {
            
            if (lpCurPtr >= lpMaxAddress)
                return S_OK;
            lpCurPtr = ExtractWord(astBTreeWord, lpCurPtr, &wLen);

            if (fStemmed)
            {
                if ((fRet = ExtStemWord(lpRetV->SrchInfo.lpvIndexObjBridge,
                						pBTreeWord, astBTreeWord)) != S_OK)
                    return(fRet);
            }
            
            /* Read in NodeId record */
            lpCurPtr += ReadFileOffset (&pLeafInfo->nodeOffset, lpCurPtr);

            if (f1stIsWild)
                break;
            if (StrCmpPascal2(lstModified, pBTreeWord) <= 0)
                break;

            // erinfox:
            // if stemming is turned on, there could be a case in which the stemmed
            // word is less than the search term, but the unstemmed word is greater.
            // if we don't check the unstemmed, we'll skip this node erroneously.
            if (fStemmed && StrCmpPascal2(lstModified, astBTreeWord) <= 0)
                break;
        }
    }
    
    /* At this point, pLeafInfo->nodeOffset is the node id of the leaf that
    is supposed to contain the searched word. Read in the leaf node
    */
    if ((fRet = ReadLeafNode ((PNODEINFO)pLeafInfo, cLevel)) != S_OK)
    {
        return fRet;
    }
    
    lpCurPtr = pLeafInfo->pCurPtr;
    lpMaxAddress = pLeafInfo->pMaxAddress;
    dwTotalTopic = 0;
    
    //
    //  Second step is to deal with the leaf node(s).  I'm going to
    //  find and capture some occurence lists.  I'll probably have to
    //  ignore some bogus ones first.
    //
    
    // Reset the word
    if (fStemmed)
    {
        MEMCPY (lstModified, lpRetV->pStemmedQueryWord,
            *(LPW)lpRetV->pStemmedQueryWord + sizeof(WORD));
    }
    else
    {
        MEMCPY (lstModified, lstSearchStr, 
            *((LPW)lstSearchStr) + sizeof (SHORT));
    }
        
    for (;;) 
    {
        // Check for out of data
        if (lpCurPtr >= lpMaxAddress)
        {
            // Get the offset of the next node
            ReadFileOffset (&pLeafInfo->nodeOffset, pLeafInfo->pBuffer);
            if (FoIsNil (pLeafInfo->nodeOffset))
            {
                lpCurQtNode->cTopic = dwTotalTopic;
                return S_OK;
            }
                
            // Read the next node    
            if ((fRet = ReadLeafNode ((PNODEINFO)pLeafInfo, cLevel))
                != S_OK)
            {
                return SetErrCode (&errb, fRet);
            }
            lpCurPtr = 
                pLeafInfo->pBuffer + FOFFSET_SIZE + sizeof (SHORT);
            lpMaxAddress = pLeafInfo->pMaxAddress;
        }
        
        /* Check for interrupt now and then */
        if ((++lpqt->cInterruptCount) == 0)
        {
            if (lpqt->fInterrupt == E_INTERRUPT)        
                return E_INTERRUPT;
            if (*lpqt->cStruct.Callback.MessageFunc &&
                (fRet = (*lpqt->cStruct.Callback.MessageFunc)(
                lpqt->cStruct.Callback.dwFlags,
                lpqt->cStruct.Callback.pUserData, NULL)) != S_OK)
                return(fRet);
        }
            
        // Extract the word
        lpCurPtr = ExtractWord(astBTreeWord, lpCurPtr, &wLen);
        
        if (fStemmed)
        {
            if ((fRet = ExtStemWord(lpRetV->SrchInfo.lpvIndexObjBridge,
            						pBTreeWord, astBTreeWord)) != S_OK)
                return(fRet);
        }
        
        // Save the word length
        lpCurQtNode->wRealLength = wLen;

        if (lpqt->occf & OCCF_FIELDID)
            lpCurPtr += CbByteUnpack (&dwFieldID, lpCurPtr);
            
        nCmp = CompareTerm (lpCurQtNode, lstModified, pBTreeWord, fCheckFieldId ?
             dwFieldID : lpCurQtNode->dwFieldId, lpRetV->pLeadByteTable);
             
        switch (nCmp)
        {
            case KEEP_SEARCHING:
                // Skip TopicCount
                lpCurPtr += CbByteUnpack (&dwTemp, lpCurPtr);
                // Skip data offset
                lpCurPtr += FOFFSET_SIZE;
                // Skip DataSize
                lpCurPtr += CbByteUnpack (&dwTemp, lpCurPtr);
                break;

            case STRING_MATCH:

                lpCurPtr += CbByteUnpack (&lpCurQtNode->cTopic, lpCurPtr);
                lpCurPtr += ReadFileOffset (&lpCurQtNode->foData, lpCurPtr);
                lpCurPtr += CbByteUnpack (&lpCurQtNode->cbData, lpCurPtr);

				// Check for Topic count. This can be 0 if the word has been deleted
				// from the index
				if (lpCurQtNode->cTopic == 0)
					break;
                
    			if (lpRetV->SrchInfo.Flag & LARGEQUERY_SEARCH) 
				{
	                // long search optimization: clip noise words.
                    // Johnms- eliminate frequent words.
                    // typically, you eliminate if in more than 1/7 of documents.
    	            if (lpRetV->SrchInfo.dwValue < lpCurQtNode->cTopic)
                        break;        
				}

				// Add the raw (i.e. unstemmed) term from the index that currently
				// matches the query term for this node to the query result term
				// dictionary, and pass a pointer to the term in the dictionary
				// to GetWordData so that it can add it to the occurrence records.
    			if ((lpRetV->SrchInfo.Flag & QUERY_GETTERMS) != 0 &&
					(fRet = ExtAddQueryResultTerm(
										lpRetV->SrchInfo.lpvIndexObjBridge,
										astBTreeWord,
										&lpCurQtNode->lpvIndexedTerm)) != S_OK)
				{
					return (fRet);
				}
				 
                // Save the info
                pLeafInfo->pCurPtr = lpCurPtr;
                
                if ((fRet = GetWordData (lpqt, lpRetV, 
                    Operator, lpResQuery, lpCurQtNode, fDivide,
					fOutOfMemory)) != S_OK)
                {
					// kevynct: no need to overwrite count on error since
					// we may be attempting to continue
					lpCurQtNode->cTopic += dwTotalTopic;
                    return(fRet);
                }

                // Accumulate the topic count, since cTopic will be destroyed
                // if there is more searches for this node (such as wildcard)

                dwTotalTopic += lpCurQtNode->cTopic;
                break;

            case NOT_FOUND: // No unconditional "break" above.
                if (fStemmed &&  (strncmp (lstSearchStr+ 2, pBTreeWord + 2,
                    cByteMatched) == 0))
                {
                    // Continue searching in case stemming is messed up
                    // by non-alphabetic word, such as the sequence:
                    // subtopic subtopic2 subtopics
					lpCurPtr += CbByteUnpack (&dwTemp, lpCurPtr);
					// Skip data offset
					lpCurPtr += FOFFSET_SIZE;
					// Skip DataSize
					lpCurPtr += CbByteUnpack (&dwTemp, lpCurPtr);
                       break;
                }
                lpCurQtNode->cTopic = dwTotalTopic;
                return S_OK;
        }
    }
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   int PASCAL NEAR | CompareTerm |
 *      This function compares two Pascal strings
 *
 *  @parm   _LPQTNODE FAR* | lpQtNode |
 *      Query tree node
 *
 *  @parm   LST | lstSrchStr |
 *      String to be searched 
 *
 *  @parm   LST | lstBtreeWord |
 *      The word from the b-tree.
 *
 *  @parm   DWORD | dwBtreeFieldId |
 *      The field-ID from the index b-tree. if it is DW_NIL_FIELD,
 *      then there is no need to check
 *
 *  @parm   DWORD | dwLanguage |
 *      The language of the index that we are searching
 *
 *  @rdesc 
 *      The returned values are:
 *  @flag   NOT_FOUND |
 *      The words do not match, and we have passed the interested point
 *  @flag   KEEP_SEARCHING |
 *      The words do not match, but we should continue the search for
 *      the match may be ahead
 *  @flag   STRING_MATCH | 
 *      The words match
 *************************************************************************/
#ifndef SIMILARITY
PUBLIC int PASCAL FAR CompareTerm(_LPQTNODE lpQtNode,LST lstTermWord,
    LST lstBtreeWord, DWORD dwBtreeFieldId, BYTE prgbLeadByteTable[])
#else
PRIVATE int PASCAL NEAR CompareTerm(_LPQTNODE lpQtNode, LST lstTermWord,
    LST lstBtreeWord, DWORD dwBtreeFieldId, BYTE prgbLeadByteTable[])
#endif
{
    int     nCmp;           // The result of compare
    BYTE FAR *lstTermHiWord;// Pointer to the hi term string 
    DWORD   dwTermFieldId;

    /* Get the variables */
    dwTermFieldId = lpQtNode->dwFieldId;

    switch (QTN_FLAG(lpQtNode))
    {
        case EXACT_MATCH:
        /*
         *  This is very straight, it just compares the two words.
         */
            if ((nCmp = StrCmpPascal2(lstTermWord, lstBtreeWord)) < 0)
            {
                /* lstTermWord > lstBtreeWord */
                return NOT_FOUND;
            }
            if (nCmp)
                return KEEP_SEARCHING;
            if (dwBtreeFieldId < dwTermFieldId)
                return KEEP_SEARCHING;
            if (dwBtreeFieldId == dwTermFieldId)
                return STRING_MATCH;
            if (dwBtreeFieldId > dwTermFieldId)
                return NOT_FOUND;
            break;

        case TERM_RANGE_MATCH:
        /*
         *  This makes sure that the b-tree word is between the
         *  two term words provided, and that the field-ID's
         *  match up.
         */
            lstTermHiWord = lpQtNode->lpHiString;
            if ((nCmp = StrCmpPascal2(lstTermWord, lstBtreeWord)) > 0)
            {
                /* lstTermWord < lstBtreeWord */
                return KEEP_SEARCHING;
            }
            if ((nCmp = StrCmpPascal2(lstTermHiWord, lstBtreeWord)) < 0)
            {
                /* lstTermHiWord > lstBtreeWord */
                return NOT_FOUND;
            }
            if (dwTermFieldId != dwBtreeFieldId)
                return KEEP_SEARCHING;
            break;

        case WILDCARD_MATCH:

            /* Zero-terminated lstBtreeWord */
            lstBtreeWord[*((LPW)lstBtreeWord) + sizeof (SHORT)] = 0;

            if ((nCmp = WildCardCompare
                (lstTermWord, lstBtreeWord, prgbLeadByteTable)) != STRING_MATCH)
                return nCmp;
            if (dwTermFieldId != dwBtreeFieldId)
                return KEEP_SEARCHING;
            break;

    }
    return STRING_MATCH;
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   HRESULT PASCAL NEAR | SkipOccList |
 *      This function will skip on occurence list in the index.
 *  @parm   _LPQT | lpqt |
 *      Pointer to Index information.
 *  @parm   PNODEINFO | pNodeInfo |
 *      Current leaf info.
 *  @parm   DWORD | dwOccs |
 *      Number of occurrences to be skipped
 *  @rdesc  S_OK if successfully skip the occurence list
 *************************************************************************/
#ifndef SIMILARITY
PUBLIC HRESULT PASCAL FAR SkipOccList(_LPQT  lpqt, PNODEINFO pNodeInfo, DWORD dwOccs)
#else
PRIVATE HRESULT PASCAL NEAR SkipOccList(_LPQT  lpqt, PNODEINFO pNodeInfo, DWORD dwOccs)
#endif
{
    DWORD   dwTmp;      // Trash variable.
    HRESULT fRet;           // Returned value

    //
    //  One pass through here for each occurence in the
    //  current sub-list.
    //
    for (; dwOccs; dwOccs--)
    {
        //
        //  Keeping word-counts?  If so, get it.
        //
        if (lpqt->occf & OCCF_COUNT) 
        {
            if ((fRet = FGetDword(pNodeInfo, lpqt->ckeyWordCount,
                &dwTmp))  != S_OK)
            {
                return fRet;
            }
        }
        //
        //  Keeping byte-offsets?  If so, get it.
        //
        if (lpqt->occf & OCCF_OFFSET) 
        {
            if ((fRet = FGetDword(pNodeInfo, lpqt->ckeyOffset,
                &dwTmp)) != S_OK)
            {
                return fRet;
            }
        }
    }
    return S_OK;
}


/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   BOOL FAR PASCAL | FGroupLookup |
 *      Given a item number, this function will check to see if the item
 *      belongs to a group or not.
 *
 *  @parm   LPGROUP | lpGroup |
 *      Pointer to the group to be checked
 *
 *  @parm   DWORD | dwTopicId |
 *      Item number to be checked
 *
 *  @rdesc  The function will return 0 if the item is not in the group,
 *      non-zero otherwise
 *************************************************************************/
BOOL NEAR PASCAL FGroupLookup(_LPGROUP lpGroup, DWORD dwTopicId)
{
    /* Check for empty group */
    if (lpGroup->lcItem == 0)
        return 0;

    if (dwTopicId < lpGroup->minItem || dwTopicId > lpGroup->maxItem)
        return 0;
#if 0

    // Currently the group always starts at 0., so there is no need
    // to recalculate dwTopicId as below

    dwTopicId -= (lpGroup->minItem / 8) * 8;
#endif

    return (lpGroup->lpbGrpBitVect[(DWORD)(dwTopicId / 8)] &
        (1 << (dwTopicId % 8)));
}


PRIVATE int PASCAL NEAR WildCardCompare
    (LPB pWildString, LPB pString, BYTE prgbLeadByteTable[])
{
    LPB pBack;
    unsigned int wMinLength = 0;
    int f1stIsWild;
    int fRet = KEEP_SEARCHING;
    int fGotWild = FALSE;

    pWildString += sizeof (SHORT);   /* Skip the length */
    f1stIsWild = (*pWildString == WILDCARD_CHAR ||
        *pWildString == WILDCARD_STAR);

    /* Calculate the minimum length of the string */
    // pback is used as temp here
    for (pBack = pWildString; *pBack; pBack++) 
    {
        if (prgbLeadByteTable && prgbLeadByteTable[*pBack])
        {
            wMinLength += 2;
            pBack++;
        }
        else if (*pBack != '*')
            wMinLength ++; 
    }

    if (wMinLength > *((LPW)pString))
    {
        if (f1stIsWild)
            return KEEP_SEARCHING;
    }

    pString += sizeof (SHORT);  /* Skip the length */

    pBack = NULL;   /* Reset pBack */
    for (;;)
    {
        switch (*pWildString)
        {
            case '?':
                if (*pString == 0)
                    return fRet;
                pWildString++;
                pString = NextChar (pString, prgbLeadByteTable);
                fGotWild = TRUE;
                break;

            case '*':
                fGotWild = TRUE;
                /* Optimization: *???? == * */
                for (; *pWildString; pWildString++)
                {
                    switch (*pWildString)
                    {
                        case '*': 
                            pBack = pWildString;
                        case '?':
                            continue;
                    }
                    break;
                }

                if (*pWildString == 0)
                {
                    /* Terminated by '*'. Match all */
                    return STRING_MATCH;
                }

                /* Skip the chars until we get a 1st match */
                while (*pString)
                {
                    if (!CompareChar (pString, pWildString, prgbLeadByteTable))
                        break;                        

                    pString = NextChar (pString, prgbLeadByteTable);                        
                }
                // This is inteded to fall through to continue processing

            default:
                if (!CompareChar (pString, pWildString, prgbLeadByteTable))
                {
                    if (*pString == 0)  /* We finish both strings */
                        return STRING_MATCH;
                    pString = NextChar (pString, prgbLeadByteTable);
                    pWildString = NextChar (pWildString, prgbLeadByteTable);
                    break;
                }
                else if (f1stIsWild || // *pWildString == 0 ||
                    // *pString < *pWildString
                    CompareChar (pString, pWildString, prgbLeadByteTable) < 0)
                {
                    fRet = KEEP_SEARCHING;
                }
                else if (fGotWild == FALSE)
                    fRet = NOT_FOUND;

                /* The chars do not match. Check to see for back up */
                if (!pBack || *pString == 0)
                {
                    return fRet;
                }

                /* Back up the string */
                pWildString = pBack;
                break;
        }
    }
}
/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   HRESULT FAR PASCAL | TopNodeRead |
 *      Makes sure the index b-tree top node is in memory.  Reads it if
 *      necessary.  The index file must be open and the index header must
 *      be in memory or this call will break.
 *
 *  @parm   _LPQT | lpidx |
 *      Index information.
 *
 *  @rdesc  S_OK, if succeeded, otherwise error values
 *************************************************************************/

PUBLIC HRESULT PASCAL FAR TopNodeRead( _LPIDX lpidx)
{
    DWORD dwBlockSize = lpidx->ih.dwBlockSize;
    
    if (lpidx->hTopNode != NULL)
        return S_OK;
    if ((lpidx->hTopNode = _GLOBALALLOC(GMEM_MOVEABLE, dwBlockSize)) == NULL)
    {
        return E_OUTOFMEMORY;
    }
    lpidx->lrgbTopNode = (LRGB)_GLOBALLOCK(lpidx->hTopNode);
    if (FileSeekRead 
        (lpidx->hfpbIdxSubFile, lpidx->lrgbTopNode, lpidx->ih.foIdxRoot, 
        dwBlockSize, lpidx->lperrb) != (long)dwBlockSize) 
    {
        TopNodePurge(lpidx);
        return E_ASSERT;
    }
    return S_OK;
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   void PASCAL FAR | TopNodePurge |
 *      Get rid of the index b-tree top node if it's in memory.
 *
 *  @parm   _LPIDX | lpidx |
 *      Pointer to index structure
 *************************************************************************/
PUBLIC void FAR PASCAL TopNodePurge(_LPIDX lpidx)
{
    if (lpidx->hTopNode == NULL)        // Already gone.
        return;
    FreeHandle(lpidx->hTopNode);
    lpidx->hTopNode = NULL;
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   void FAR PASCAL | IndexCloseFile |
 *      Close the index file. Error not checked since it is opened
 *      for read only
 *
 *  @parm   _LPIDX  | lpidx |
 *      Pointer to index structure
 *************************************************************************/
PUBLIC void PASCAL FAR IndexCloseFile(_LPIDX  lpidx)
{
    if (lpidx->hfpbIdxSubFile != NULL) 
    {
        FileClose(lpidx->hfpbIdxSubFile);
        lpidx->hfpbIdxSubFile = NULL;
    }

}


/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   LPB FAR PASCAL | NextChar |
 *      Get the next character in a string based on a DBCS lead-byte table
 *
 *  @parm   LPB | pStr |
 *      Pointer to character in a string to skip
 *
 *  @parm   BYTE * | prgbLeadByteTable |
 *      Array of DBCS lead bytes (assumed to have 256 elements)
 *      Each element should be set to 1 or 0 to indeicate if that index
 *      is considered a lead-byte.
 *
 *  @rdesc  Returns a pointer to the next character in pStr
 *************************************************************************/
LPB FAR PASCAL NextChar (LPB pStr, BYTE prgbLeadByteTable[])
{
    if (!prgbLeadByteTable)
        return (pStr + 1);
    if (prgbLeadByteTable[*pStr])
        return (pStr + 2);
    return (pStr + 1);
}


/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   BOOL FAR PASCAL | CompareChar |
 *      Compares the first character in pStr1 to the first
 *      character in pStr2, using the supplied DBCS lead-byte table.
 *
 *  @parm   LPB | pStr1 |
 *      Pointer to character in a string to compare
 *
 *  @parm   LPB | pStr2 |
 *      Pointer to character in a string to compare
 *
 *  @parm   BYTE * | prgbLeadByteTable |
 *      Array of DBCS lead bytes (assumed to have 256 elements).
 *      Each element should be set to 1 or 0 to indeicate if that index
 *      is considered a lead-byte.
 *
 *  @rdesc  The difference between the first bytes of pStr1 and pStr2.
 *      If the first bytes are equal and are lead bytes then the
 *      difference between the second bytes is returned.
 *************************************************************************/
__inline BOOL FAR PASCAL CompareChar
    (LPB pStr1, LPB pStr2, BYTE prgbLeadByteTable[])
{
    // Get rid of obvious mismatches
    if (*pStr1 != *pStr2)
        return (*pStr1 - *pStr2);
    // We now know the first bytes are equal.
    // If there is no lead byte table we have a match
    if (!prgbLeadByteTable)
        return (0);
    // If lead bytes, check the trail bytes
    if (prgbLeadByteTable[*pStr1])
        return (*(pStr1 + 1) - *(pStr2 + 1));
    // Not lead bytes then they must be equal
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\hitlist.c ===
#include <mvopsys.h>
#include <mem.h>
#if DOS_ONLY
#include <io.h>
#include <string.h>
#endif  // DOS_ONLY
#include <mvsearch.h>
#include <groups.h>
#include "common.h"
#include "search.h"
#include "httpsrch.h"

#ifdef _DEBUG
static BYTE NEAR s_aszModule[] = __FILE__;	/* Used by error return functions.*/
#endif

#define NOT_OPENED  NULL
#define CACHE_EMPTY ((DWORD)-1)

/*************************************************************************
 *
 *                       API FUNCTIONS
 *  Those functions should be exported in a .DEF file
 *************************************************************************/
PUBLIC HRESULT EXPORT_API FAR PASCAL MVHitListGetTopic (LPHL, DWORD, PTOPICINFO);
PUBLIC HRESULT EXPORT_API FAR PASCAL MVHitListGetHit (LPHL, PTOPICINFO, DWORD,
    LPHIT);
PUBLIC DWORD EXPORT_API PASCAL FAR MVHitListEntries (LPHL);
PUBLIC LONG EXPORT_API PASCAL FAR MVHitListMax(LPHL);
PUBLIC VOID EXPORT_API FAR PASCAL MVHitListDispose(LPHL);

/*************************************************************************
 *
 *                       INTERNAL PUBLIC FUNCTIONS
 *  Those functions should be prototyped in some include files
 *************************************************************************/
PUBLIC HRESULT PASCAL FAR OccListSave (LPITOPIC, LPDW, LPDW, HFPB, HFPB, int);

/*************************************************************************
 *  @doc    API RETRIEVAL
 *
 *  @func   HRESULT FAR PASCAL | MVHitListGetTopic |
 *      The function will return the data of the nth TOPIC. The total
 *      of TOPIC is given by lpHitList->lcReturnedTopics
 *
 *  @parm   LPHL | lpHitList |
 *      Pointer to a hitlist structure. This structure contains all
 *      the information necessary for the retrieval
 *
 *  @parm   PTOPICINFO | lpTopic |
 *      Pointer to a TOPIC structure to be filled
 *
 *  @parm   DWORD | TopicNumber |
 *      Which TOPIC we want to get. The number starts at 0
 *      
 *  @rdesc S_OK if ERR_SUCCESSed, other errors if failed
 *************************************************************************/
#define CNODE_IN_CACHE  100

PUBLIC HRESULT EXPORT_API FAR PASCAL MVHitListGetTopic (_LPHL lpHitList,
    DWORD TopicNumber, PTOPICINFO lpTopic)
{
    LPITOPIC lpTopicList;
    DWORD  TopicNumSaved = TopicNumber;
    ERRB   errb;
    DWORD  dwByteRead;

    if (lpHitList == NULL || lpTopic == NULL)
        return E_INVALIDARG;

    if (lpHitList->lcReturnedTopics == 0 ||
        lpHitList->lcReturnedTopics < TopicNumber)
        return E_INVALIDARG;

    if (lpHitList->hTopic == 0)
    {
        /* Everything is in memory */

        /* Find the starting pointer */
        if (lpHitList->lLastTopicId <= TopicNumber) {
            TopicNumber -= lpHitList->lLastTopicId;
            lpTopicList = lpHitList->lpLastTopic;
        }
        else
            lpTopicList = lpHitList->lpTopicList;

        if (lpTopicList == NULL)
            return E_ASSERT;

        /* Traverse to the right TopicList*/
        if (TopicNumber != 0)
        {
            for (;lpTopicList && TopicNumber > 0;
                lpTopicList = lpTopicList->pNext, TopicNumber--);
        }

        if (lpTopicList == NULL)
            return E_FAIL;
    }
    else 
    {
    
        /* Everything is saved in a temp file */

        /* Allocate a cache if needed */
        if (lpHitList->lpTopicCache == NULL)
        {
            if ((lpHitList->hTopicCache = _GLOBALALLOC(DLLGMEM,
                sizeof(TOPIC_LIST)*CNODE_IN_CACHE)) == NULL)
                return E_OUTOFMEMORY;
            lpHitList->lpTopicCache = (LPITOPIC)_GLOBALLOCK(lpHitList->hTopicCache);
            lpHitList->dwTopicCacheStart = lpHitList->dwOccCacheStart =
                lpHitList->dwCurTopic = CACHE_EMPTY;    // The cache is empty
            lpHitList->dwTopicInCacheCount = 0;
        }

        /* Fill up the cache if it is empty, or out of range */
        if (lpHitList->dwTopicCacheStart > TopicNumber || 
            (lpHitList->dwTopicCacheStart + lpHitList->dwTopicInCacheCount)
            <= TopicNumber) 
        {

            /* Fill up the cache */
            if ((dwByteRead = FileSeekRead(lpHitList->hTopic,
                lpHitList->lpTopicCache,
                MakeFo (sizeof (TOPIC_LIST)*TopicNumber, 0),
                sizeof(TOPIC_LIST) * CNODE_IN_CACHE, &errb)) == cbIO_ERROR)
                return errb;
            lpHitList->dwTopicInCacheCount = dwByteRead / sizeof(TOPIC_LIST);
            lpHitList->dwTopicCacheStart = TopicNumber;
        }
        lpTopicList = lpHitList->lpTopicCache + TopicNumber -
            lpHitList->dwTopicCacheStart;
    }

    /* Save the TopicList node address */
    lpTopic->lpTopicList = (LPV)lpTopicList;

    /* Copy the structure */
    lpTopic->dwTopicId = lpTopicList->dwTopicId;
    lpTopic->lcHits = lpTopicList->lcOccur;
    lpTopic->wWeight = lpTopicList->wWeight;

    /* Remember the last accessed topic */
    lpHitList->lpLastTopic = lpTopicList;
    lpHitList->lLastTopicId = TopicNumSaved;
    return S_OK;
}

/*************************************************************************
 *  @doc    API RETRIEVAL
 *
 *  @func   HRESULT FAR PASCAL | MVHitListGetTopicId |
 *      The function will return the data of the topic with doc id given.
 *      If it is in the hitlist.
 *  @parm   LPHL | lpHitList |
 *      Pointer to a hitlist structure. This structure contains all
 *      the information necessary for the retrieval
 *
 *  @parm   PTOPICINFO | lpTopic |
 *      Pointer to a TOPIC structure to be filled
 *
 *  @parm   DWORD | TopicId |
 *      Which TOPIC we want to get.
 *      
 *  @rdesc S_OK if ERR_SUCCESSed, other errors if failed
 *************************************************************************/
PUBLIC HRESULT EXPORT_API FAR PASCAL MVHitListGetTopicID (_LPHL lpHitList,
    DWORD TopicID, PTOPICINFO lpTopic)
{
    LPITOPIC lpTopicList;

    if (lpHitList == NULL || lpTopic == NULL)
        return E_INVALIDARG;

    /* Traverse to the right TopicList*/
    for ( lpTopicList = lpHitList->lpTopicList;
        (lpTopicList && (lpTopicList->dwTopicId != TopicID)) ;
        lpTopicList = lpTopicList->pNext);
    if (lpTopicList == NULL) return E_INVALIDARG;
    /* Save the TopicList node address */
    lpTopic->lpTopicList = (LPV)lpTopicList;

    /* Copy the structure */

    lpTopic->dwTopicId = lpTopicList->dwTopicId;
    lpTopic->lcHits = lpTopicList->lcOccur;
#ifdef _DEBUG
    lpTopic->wWeight = lpTopicList->wWeight;
#endif
    return S_OK;
}

/*************************************************************************
 *  @doc    API RETRIEVAL 
 *
 *  @func   HRESULT FAR PASCAL | MVHitListGetHit |
 *      The function will return the data of the nth hit.
 *
 *  @parm   LPHL | lpHitList |
 *      Pointer to a hitlist structure. This structure contains all
 *      the information necessary for the retrieval
 *
 *  @parm   PTOPICINFO | lpTopic |
 *      Pointer to the Topic list
 *
 *  @parm   LPHIT | lpHit |
 *      Pointer to a HIT structure to be filled
 *
 *  @parm   DWORD | HitNumber |
 *      Which HIT we want to get. The number starts at 0
 *
 *  @rdesc S_OK if ERR_SUCCESSed, E_FAIL if no such hit exists, or other
 *      errors if failed
 *************************************************************************/
PUBLIC HRESULT EXPORT_API FAR PASCAL MVHitListGetHit (_LPHL lpHitList, PTOPICINFO lpTopic,
    DWORD HitNumber, LPHIT lpHit)
{
    LPIOCC lpOccur;
    LPITOPIC lpTopicList;
    ERRB   errb;
    
    if (lpHitList == NULL || lpTopic == NULL || lpHit == NULL )
        return SetErrCode (&errb, E_INVALIDARG);

    if ((lpTopicList = lpTopic->lpTopicList) == NULL)
        return E_FAIL;

    if (HitNumber > lpTopicList->lcOccur)
        return SetErrCode (&errb, E_INVALIDARG);

    if (lpHitList->hOcc == NULL) {
        /* Everything is still in memory */
        if ((lpOccur = DL_OCCUR(lpTopicList)) == NULL)
            return SetErrCode (&errb, E_ASSERT);

        /* Traverse to the right occurrence */
        if (HitNumber != 0) {
            for (;lpOccur && HitNumber > 0; lpOccur = lpOccur->pNext,
                HitNumber--);
        }

        if (lpOccur == NULL) 
            return E_FAIL;
    }
    else {

        /* Allocate a cache if needed */

        if (lpHitList->lpOccCache == NULL) {
            if ((lpHitList->hOccCache = _GLOBALALLOC(DLLGMEM,
                sizeof(OCCURENCE) * CNODE_IN_CACHE)) == NULL)
                return E_OUTOFMEMORY;
            lpHitList->lpOccCache = (LPIOCC)_GLOBALLOCK(lpHitList->hOccCache);
            lpHitList->dwOccCacheStart =
                lpHitList->dwCurTopic = CACHE_EMPTY;    // The cache is empty
        }

        /* Fill up the cache if it is empty, or out of range */
        if (lpHitList->dwCurTopic != lpTopicList->dwTopicId ||
            lpHitList->dwOccCacheStart > HitNumber || 
            (lpHitList->dwOccCacheStart + CNODE_IN_CACHE) <= HitNumber) {

            /* Fill up the cache */
			/* NOTE: The following calculation uses the lpOccur fields as a DWORD not a POINTER */
			/*       the original author should have used a union to make the code clear. Once I*/
			/*       have converted the source to Win64 I should take time to clean this up RAK */
			// Win64 caution
            if ((FileSeekRead(lpHitList->hOcc, lpHitList->lpOccCache,
                MakeFo (HitNumber * sizeof(OCCURENCE) + (DWORD)
                (DWORD_PTR) (DL_OCCUR(lpTopicList)), 0), sizeof(OCCURENCE) * CNODE_IN_CACHE,
                &errb)) == cbIO_ERROR)
                return errb;

            /* Update the fields */

            lpHitList->dwOccCacheStart = HitNumber;
            lpHitList->dwCurTopic = lpTopicList->dwTopicId;
        }
        lpOccur = lpHitList->lpOccCache + HitNumber -
            lpHitList->dwOccCacheStart;
    }

    /* Copy the Occurrence structure */

    lpHit->dwOffset = lpOccur->dwOffset;
    lpHit->dwLength = lpOccur->cLength;
    lpHit->dwCount = lpOccur->dwCount;
    lpHit->dwFieldId = lpOccur->dwFieldId;
	lpHit->lpvTerm = lpOccur->lpvTerm;

    return S_OK;
}

/*************************************************************************
 *  @doc    API RETRIEVAL
 *
 *  @func   VOID FAR PASCAL | MVHitListDispose |
 *      Free all the memory associated with the hitlist
 *
 *  @parm   lpHitList | lpHitList |
 *      Pointer to a HitList (HL) structure
 *************************************************************************/
PUBLIC VOID EXPORT_API FAR PASCAL MVHitListDispose(_LPHL lpHitList)
{
    HANDLE hCache;

    if (lpHitList == NULL)
        return;
    
    if (lpHitList->lpMainHitList && lpHitList->lpUpdateHitList)
    {
        if (lpHitList->lpMainHitList->lpTopicMemBlock == 
            lpHitList->lpUpdateHitList->lpTopicMemBlock)
            lpHitList->lpMainHitList->lpTopicMemBlock =  NULL;
            
        if (lpHitList->lpMainHitList->lpOccMemBlock == 
        lpHitList->lpUpdateHitList->lpOccMemBlock)
            lpHitList->lpMainHitList->lpOccMemBlock =  NULL;
    }
    
    MVHitListDispose ((_LPHL)lpHitList->lpMainHitList);
    MVHitListDispose ((_LPHL)lpHitList->lpUpdateHitList);

    /* Free the Topic block */
    BlockFree ((LPV)lpHitList->lpTopicMemBlock);

    /* Free the occurrences block */
    BlockFree ((LPV)lpHitList->lpOccMemBlock);

    /* Free the Topic cache */
    if (hCache = lpHitList->hTopicCache) {
        _GLOBALUNLOCK(hCache);
        _GLOBALFREE(hCache);
    }

    /* Free Occ cache */
    if (hCache = lpHitList->hOccCache) {
        _GLOBALUNLOCK(hCache);
        _GLOBALFREE(hCache);
    }

    /* Kill the temp files */
    if (lpHitList->hTopic) {
        FileClose (lpHitList->hTopic);
        FileUnlink (NULL, lpHitList->lszTopicName, REGULAR_FILE);
    }

    if (lpHitList->hOcc) {
        FileClose (lpHitList->hOcc);
        FileUnlink (NULL, lpHitList->lszOccName, REGULAR_FILE);
    }

    /* Free HttpQ structure */
    if (lpHitList->lpHttpQ)
    {
        _GLOBALUNLOCK(((LPHTTPQ)(lpHitList->lpHttpQ))->hStrQuery);
        _GLOBALFREE(((LPHTTPQ)(lpHitList->lpHttpQ))->hStrQuery);
        GlobalLockedStructMemFree((LPV)lpHitList->lpHttpQ);
    }

    /* Free the structure */
    GlobalLockedStructMemFree((LPV)lpHitList);

}

/*************************************************************************
 *  @doc    API RETRIEVAL
 *
 *  @func DWORD FAR PASCAL | MVHitListEntries |
 *      This funtion returns the number of entries of a hitlist
 *
 *  @parm lpHitList | lpHitList |
 *      Pointer to hit list being queried.
 *
 *  @rdesc  Number of hitlist entries
 *************************************************************************/

PUBLIC DWORD EXPORT_API PASCAL FAR MVHitListEntries (_LPHL lpHitList)
{
    if (lpHitList == NULL)
        return 0;
    return lpHitList->lcReturnedTopics;
}

/*************************************************************************
 *
 *  @doc    API RETRIEVAL
 *
 *  @func HRESULT FAR PASCAL | MVHitListFlush |
 *      This function saves all the hitlist info onto the disk. The
 *      number of topics saved is indicated by the parameter. The remaining
 *      will be discarded
 *
 *  @parm LPHL  | lpHitList |
 *      Pointer to hit list being queried.
 *
 *  @parm   DWORD | cTopic |
 *      How many topics we want to save. If cTopic == 0 then we want to
 *      save all
 *
 *  @rdesc  S_OK, or other errors
 *
 *  @comm   The I/O buffers are allocated on the stack instead from 
 *      a regular _GlobalAlloc. The reason is that for large query (but
 *      necessary large result, such as A AND (B THRU Z)), we may run
 *      out of memory. Using stack space ensure that we have enough
 *      memory to do the write
 *************************************************************************/

#define IO_OCC_CNT      100
#define IO_TOPIC_CNT    100

HRESULT HttpSaveToBuffers(_LPHL lpHitList, DWORD cTopic, LPHTTPQ lpHttpQ);

PUBLIC HRESULT EXPORT_API PASCAL FAR MVHitListFlush (_LPHL lpHitList, DWORD cTopic)
{
    ERRB     errb;           /* Error buffer */
    HFPB     hTopic;         /* Topic's file handle */
    GHANDLE  hTopicBuf;      /* Handle to Topic buffer */
    LPITOPIC lpTopicBuf;     /* Pointer to Topic buffer */
    LPITOPIC lpDestTopic;    /* Destination Topic */
    HFPB     hOcc;           /* Occurrences' file handle */
    GHANDLE  hOccBuf;        /* Handle to occurence buffer */
    LPIOCC   lpOccBuf;       /* Pointer to Occurrence buffer */
    LPIOCC   lpDestOcc;      /* Destination occ */
    LPIOCC   lpCurOcc;       /* Current Occ ptr */
    DWORD    lfoOcc;         /* Starting offset of the occurrences */
    LPITOPIC lpCurTopic;     /* Topic's current pointer */
    HRESULT      fRet;           /* Returned value */
    int      cOccCnt;        /* Counter */
    int      cTopicCnt;      /* Counter */
    DWORD    cTopicSaved = cTopic;
    DWORD    cbWrite;

#ifdef DOS_ONLY
    LPB     lpTmp;
#endif


    // Sanity check 
    if (lpHitList == NULL)
        return E_INVALIDARG;

    // Search performed locally...
    if (lpHitList->lcReturnedTopics == 0)   
        return S_OK;

#ifdef DOS_ONLY
    if (lpTmp = _mktemp ("ocXXXXXX"))
        _fstrcpy (lpHitList->lszOccName, lpTmp);
#else
    /* Create a temporary filename for occurrence file */
    (void)GETTEMPFILENAME((char)0, (LPB)"occ", (WORD)0, lpHitList->lszOccName);
#endif

    /* Open the occurrence temp file */
    if ((lpHitList->hOcc = hOcc = FileOpen (NULL, lpHitList->lszOccName,
        REGULAR_FILE, OF_WRITE, &errb)) == 0)
    {
        return errb;
    }

#ifdef DOS_ONLY
    if (lpTmp = _mktemp ("doXXXXXX"))
        _fstrcpy (lpHitList->lszTopicName, lpTmp);
#else
    /* Create a temporary filename for doc file */
    (void)GETTEMPFILENAME((char)0, (LPB)"Topic", (WORD)0, lpHitList->lszTopicName);
#endif

    /* Open the doc temp file */
    if ((lpHitList->hTopic = hTopic = FileOpen (NULL, lpHitList->lszTopicName,
        REGULAR_FILE, OF_WRITE, &errb)) == 0)
    {
        fRet = errb;
exit0:
        if (fRet != S_OK)
        {
            FileClose (hOcc);
            FileUnlink (NULL, lpHitList->lszOccName, REGULAR_FILE);
            lpHitList->hOcc = 0;
        }
        return fRet;
    }

    /* Allocate I/O buffers for Topic and Occ lists. Since we seldom
     * used near memory, the following LocalAlloc should S_OK.
     * The reason we don't want to use far memory is that there is
     * a possibility that we ran out of far memory when we came to this
     * point (partial hit list). If so, we have to ensure that everything
     * get written to the disk so that memory can be freed, else nothing
     * will work in an OOM state
     */
    if ((hTopicBuf = LocalAlloc(LMEM_MOVEABLE, 
        sizeof(TOPIC_LIST) * IO_TOPIC_CNT)) == NULL)
    {
        fRet = E_OUTOFMEMORY;
exit01:
        if (fRet != S_OK)
        {
            FileClose (hTopic);
            FileUnlink (NULL, lpHitList->lszTopicName, REGULAR_FILE);
            lpHitList->hTopic = 0;
        }
        goto exit0;
    }

    lpTopicBuf = (LPITOPIC)LocalLock(hTopicBuf);

    if ((hOccBuf = LocalAlloc(LMEM_MOVEABLE,  sizeof(OCCURENCE) * IO_OCC_CNT))
        == NULL)
    {
        fRet = E_OUTOFMEMORY;
exit1:
        LocalUnlock(hTopicBuf);
        LocalFree(hTopicBuf);
        goto exit01;
    }

    lpOccBuf = (LPIOCC)LocalLock(hOccBuf);

    /* The remaining of the code consists of writing the info to the disk */

    /* Initialize the variables */

    lfoOcc = 0;
    lpCurTopic = lpHitList->lpTopicList;
    lpDestOcc = lpOccBuf;
    lpDestTopic = lpTopicBuf;
    cTopicCnt = IO_TOPIC_CNT;
    cOccCnt = IO_OCC_CNT;

    /* If cTopic == 0, decrementing it will change it to 0xffffffff,
     * which means take the whole list. 
     */
    do
    {
        DWORD_PTR dwStartOff;

        lpCurOcc = DL_OCCUR(lpCurTopic);
        dwStartOff = lfoOcc;

        for (; lpCurOcc; lpCurOcc = lpCurOcc->pNext)
        {
            *lpDestOcc++ = *lpCurOcc;
            if (--cOccCnt <= 0)
            {
                cbWrite = (DWORD)((LPB)lpDestOcc - (LPB)lpOccBuf);
                if ((DWORD)FileWrite (hOcc, lpOccBuf, cbWrite,
                    &errb) != cbWrite) 
                {
                    fRet = errb;
exit2:
                    LocalUnlock(hOccBuf);
                    LocalFree(hOccBuf);
                    goto exit1;
                }
                cOccCnt = IO_OCC_CNT;
                lpDestOcc = lpOccBuf;
            }

            /* Update the offset */
            lfoOcc += sizeof(OCCURENCE);
        }

        /* The next steps involves the saving of the lpOcc's offset
         * Note that the pointer must be saved and restored to ensure
         * that everything is intact in memory in case writing fails
         */
        lpCurOcc = DL_OCCUR(lpCurTopic);
        DL_OCCUR(lpCurTopic) = (LPIOCC)dwStartOff;
        *lpDestTopic++ = *lpCurTopic;
        DL_OCCUR(lpCurTopic) = lpCurOcc;


        if (--cTopicCnt <= 0) {
            cbWrite = (DWORD)((LPB)lpDestTopic - (LPB)lpTopicBuf);
            if ((DWORD)FileWrite(hTopic, lpTopicBuf, cbWrite, &errb) != cbWrite) 
            {
                fRet = errb;
                goto exit2;
            }
            cTopicCnt = IO_TOPIC_CNT;
            lpDestTopic = lpTopicBuf;
        }

        if ((lpCurTopic = lpCurTopic->pNext) == NULL)
            break;
    } while (--cTopic > 0);

    /* Write the remaining data to the disk */
    cbWrite = (DWORD)((LPB)lpDestTopic - (LPB)lpTopicBuf);
    if ((DWORD)FileWrite(hTopic, lpTopicBuf, cbWrite, &errb) != cbWrite) 
    {
        fRet = errb;
        goto exit2;
    }

    cbWrite = (DWORD)((LPB)lpDestOcc - (LPB)lpOccBuf);
    if ((DWORD)FileWrite(hOcc, lpOccBuf, cbWrite, &errb) != cbWrite)
    {
        fRet = errb;
        goto exit2;
    }
    /* At this point everything is saved to the disk, we can
     * get rid of all the memory block, and reset the fields
     * to NULL
     */
    BlockFree(lpHitList->lpOccMemBlock);        // Pointer to Occ memory block
    BlockFree(lpHitList->lpTopicMemBlock);      // Pointer to Topic memory block
    lpHitList->lpTopicMemBlock = lpHitList->lpOccMemBlock = NULL;
    lpHitList->lpTopicList = NULL;

    /* Update the number of topics left */

    if (cTopicSaved && lpHitList->lcReturnedTopics > cTopicSaved) {
        lpHitList->lcReturnedTopics = cTopicSaved;
    }

    fRet = S_OK;
    goto exit2;
}



#if 0
PUBLIC HRESULT PASCAL FAR OccListSave (LPIOCC lpCurOcc, LPIOCC lpOccBuf,
    HFPB hOcc, LPW lpwOccCnt, WORD MaxOcc, int fFlag)
{
    LPIOCC lpDestOcc;
    DWORD cbWritten = 0;
    WORD wOccCnt = *lpwOccCnt;
    HRESULT fRet;

    lpDestOcc = lpOccBuf + wOccCnt;

    for (lpCurOcc = DL_OCCUR(lpCurTopic); lpCurOcc; lpCurOcc =
        lpCurOcc->pNext) {

        *lpDestOcc++ = *lpCurOcc;
        if (++wOccCnt == MaxOcc) {
            if ((fRet = FileWrite(hOcc, lpOccBuf,
                (LPB)lpDestOcc - lpOccBuf)) != S_OK) {
                return fRet;
            }
            wOccCnt = 0;
            lpDestOcc = lpOccBuf;
        }

        /* Update number of bytes written */
        cbWritten += sizeof (OCCURENCE);
    }

    return S_OK;
}
#endif


/*************************************************************************
 *  @doc    API RETRIEVAL
 *
 *  @func int FAR PASCAL | MVHitListMax |
 *      This funtion returns the highest numbered entry
 *
 *  @parm lpHitList | lpHitList |
 *      Pointer to hit list being queried.
 *
 *************************************************************************/
PUBLIC LONG EXPORT_API FAR PASCAL MVHitListMax(_LPHL lpHitList)
{
    if (lpHitList == NULL)
        return 0;
    return lpHitList->lcMaxTopic;
}

/*************************************************************************
 *  @doc    RETRIEVAL
 *
 *  @func   HRESULT FAR PASCAL | MVHitListGroup |
 *      Given a hitlist, this function will create a group that contains
 *      all the TopicIds in the hitlist.
 *  @parm _LPGROUP | lpGroup |
 *     Pointer to a group tobe filled with data
 *  @parm   LPHL | lpHitList |
 *      Pointer to hitlist
 *  @rdesc  The function will return S_OK if ERR_SUCCESSed, else errors
 *      In case of S_OK, the group will be filled with new data
 *************************************************************************/
PUBLIC HRESULT EXPORT_API FAR PASCAL MVHitListGroup(_LPGROUP lpGroup,
    _LPHL lpHitList)
{
    register long i;
    long cTopicCount;
    PTOPICINFO lpTopic;
    HANDLE hTopic;
    DWORD dwTopicId ;
    LPB lpbGrpBitVect;
    HRESULT fRet = S_OK;
    ERRB  errb;

    /* Sanity check */
    if (lpHitList == NULL || lpGroup==NULL) 
    {
        return SetErrCode (&errb, E_INVALIDARG);
    }

    /* Allow empty hitlist */
    cTopicCount = lpHitList->lcReturnedTopics;

    /* Allocate a Topic structure */
    if ((hTopic = _GLOBALALLOC(DLLGMEM_ZEROINIT,
        sizeof(TOPICINFO))) == 0) 
    {
        return SetErrCode(&errb, E_OUTOFMEMORY);
    }

    lpTopic = (PTOPICINFO)_GLOBALLOCK(hTopic);

    lpGroup->lcItem = cTopicCount;

    /* Initialize variables */
    lpbGrpBitVect = lpGroup->lpbGrpBitVect;

    for ( i = 0; i < cTopicCount; i++) 
    {
        /* Get the Topic list */
        if ((fRet = MVHitListGetTopic(lpHitList, (DWORD)i, lpTopic)) != S_OK) 
            break;

        dwTopicId = lpTopic->dwTopicId;

        /* Set the bit */
        lpbGrpBitVect[dwTopicId / 8] |= 1 << (dwTopicId % 8);
    }

    /* Free allocated memory */
    _GLOBALUNLOCK(hTopic);
    _GLOBALFREE(hTopic);
    return fRet;
}

/*************************************************************************
 *  @doc    RETRIEVAL
 *
 *  @func   LPHL FAR PASCAL | MVHitListMerge |
 *      Given two hitlists, this function will merge them, as if lpHitList1
 *      came from a Main title, and lpHitList2 from an Update title, so all
 *      hits in lpHitList2 take priority over those in lpHitList1.
 *  @parm   PSCHRINFO | pSrchInfo |
 *      Search information
 *  @parm   LPHL | lpHitList1 |
 *      Pointer to hitlist (Main)
 *  @parm   LPHL | lpHitList1 |
 *      Pointer to another hitlist (Update)
 *  @rdesc  The function will return a merged hitlist, or NULL if error.
 *************************************************************************/

PUBLIC LPHL EXPORT_API FAR PASCAL MVHitListMerge(PSRCHINFO pSrchInfo,
    _LPHL lpHitListMain, _LPHL lpHitListUpdate, _LPGROUP lpIgnoreTopicGrp,
    DWORD fFlag, PHRESULT phr)
{
    _LPHL     lpHitListResult;
    LPITOPIC lpUpdateTopic;     /* Topic's current pointer */
    LPITOPIC lpMainTopic;       /* Topic's current pointer */
    LPITOPIC lpResultTopic;     /* Topic's current pointer */
    HRESULT      fRet;
    QTNODE   qtNode;

    if (lpHitListMain == NULL || lpHitListUpdate == NULL)   
    {
        SetErrCode (phr, E_INVALIDARG);
        return(NULL);
    }
        
    /* Allocate hitlist */
    if ((lpHitListResult = (_LPHL)GLOBALLOCKEDSTRUCTMEMALLOC(sizeof (HL))) == NULL) 
    {
        SetErrCode(phr, E_OUTOFMEMORY);
        return NULL;
    }
    
    lpUpdateTopic = lpHitListUpdate->lpTopicList;
    lpMainTopic = lpHitListMain->lpTopicList;
    lpResultTopic = NULL;
    lpHitListResult->lpMainHitList = lpHitListMain;
    lpHitListResult->lpUpdateHitList = lpHitListUpdate;
    lpHitListResult->lpOccMemBlock = 
        lpHitListResult->lpMainHitList->lpOccMemBlock;
    lpHitListResult->lpMainHitList->lpOccMemBlock = 
        lpHitListResult->lpUpdateHitList->lpOccMemBlock = NULL;
    lpHitListResult->lpTopicMemBlock = 
        lpHitListResult->lpUpdateHitList->lpTopicMemBlock;
    lpHitListResult->lpMainHitList->lpTopicMemBlock = 
        lpHitListResult->lpUpdateHitList->lpTopicMemBlock = NULL;
       
    for (; lpMainTopic; )
    {
        if (lpUpdateTopic == NULL ||
            lpMainTopic->dwTopicId < lpUpdateTopic->dwTopicId)
        {
            if (lpIgnoreTopicGrp && FGroupLookup(lpIgnoreTopicGrp,
                lpMainTopic->dwTopicId))
            {
                // Skip this unwanted old topic
                lpMainTopic = lpMainTopic->pNext;
                continue;
            }
            // Add the main list
            if (lpResultTopic == NULL)
            {
                lpHitListResult->lpTopicList = lpResultTopic = lpMainTopic;
            }
            else
                lpResultTopic->pNext = lpMainTopic;
            lpResultTopic = lpMainTopic;
            lpMainTopic = lpMainTopic->pNext;
            lpResultTopic->pNext = NULL;
        }
        else 
        {
            // Add the update list
            if (lpResultTopic == NULL)
                lpHitListResult->lpTopicList = lpUpdateTopic;
            else
                lpResultTopic->pNext = lpUpdateTopic;
            
            if (lpMainTopic->dwTopicId == lpUpdateTopic->dwTopicId)
                lpMainTopic = lpMainTopic->pNext;
            lpResultTopic = lpUpdateTopic;
            lpUpdateTopic = lpUpdateTopic->pNext;
            lpResultTopic->pNext = NULL;
        }
    }
    
    // Attach to the remaining list
    if (lpResultTopic == NULL)
        lpHitListResult->lpTopicList = lpUpdateTopic;
    else
        lpResultTopic->pNext = lpUpdateTopic;

    // Calculate the number of returned topics and the total of topics
    for (lpResultTopic  = lpHitListResult->lpTopicList; lpResultTopic;
        lpResultTopic = lpResultTopic->pNext)
    {
        lpHitListResult->lcTotalNumOfTopics++;
        if (lpResultTopic->dwTopicId > lpHitListResult->lcMaxTopic)
            lpHitListResult->lcMaxTopic = lpResultTopic->dwTopicId;
    }
    
    lpHitListResult->lcReturnedTopics = lpHitListResult->lcTotalNumOfTopics;
    
    // Remap the sorting order based on the number of hits    
    qtNode.lpTopicList = lpHitListResult->lpTopicList; 
    qtNode.cTopic = lpHitListResult->lcTotalNumOfTopics;
    TopicListSort (&qtNode, HIT_COUNT_BASED);
    lpHitListResult->lpTopicList = qtNode.lpTopicList;
    
    // Only return the number of topics that the user requested    
    if (pSrchInfo->dwTopicCount> 0 &&
        pSrchInfo->dwTopicCount < lpHitListResult->lcReturnedTopics)
        lpHitListResult->lcReturnedTopics = pSrchInfo->dwTopicCount;

    if ((fFlag & QUERYRESULT_IN_MEM) == 0)
    {
        if ((fRet = MVHitListFlush (lpHitListResult,
            lpHitListResult->lcReturnedTopics)) != S_OK)
        {
            SetErrCode (phr, fRet);
        }
    }
    return lpHitListResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\ftcommon.c ===
/*************************************************************************
*                                                                        *
*  FTCOMMON.C                                                            *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*       Routine common for both index & search                           *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
**************************************************************************/

#include <mvopsys.h>
#include <mem.h>
#include <mvsearch.h>
#include <groups.h>
#include <orkin.h>
#include "common.h"

static  BYTE NEAR s_aszModule[] = __FILE__;  // Used by error return functions.

/*************************************************************************
 *                          EXTERNAL VARIABLES
 *  All those variables must be read only
 *************************************************************************/

FDECODE DecodeTable[] =
{
    GetBitStreamDWord,
    GetFixedDWord,
    GetBellDWord,
};

/* 
 * The mask table. Its values correspond to the maximum number
 * we can get depending on how many bits are left in the byte.
 * For ease of usage, the table should be used starting at 1
 * intead of 0
 */
static BYTE NEAR BitLeftMask [] =
{
    0x00,
    0x01,
    0x03,
    0x07,
    0x0f,
    0x1f,
    0x3f,
    0x7f,
    0xff,
};

/*
 *  The bit mask table. This is used to speed up FGetBool()
 */
static BYTE BitMask [] =
{
    0x01,
    0x02,
    0x04,
    0x08,
    0x10,
    0x20,
    0x40,
    0x80,
};

/*************************************************************************
 *
 *                    INTERNAL GLOBAL FUNCTIONS
 *  All of them should be declared far, unless they are known to be called
 *  in the same segment
 *************************************************************************/
PUBLIC LST PASCAL FAR ExtractWord(LST, LST, LPW);
PUBLIC HRESULT PASCAL FAR ReadStemNode (PNODEINFO,  int);
PUBLIC HRESULT PASCAL FAR ReadLeafNode (PNODEINFO,  int);
PUBLIC int PASCAL FAR StrCmpPascal2(LPB lpStr1, LPB lpStr2);
PUBLIC HRESULT PASCAL FAR GetBellDWord (PNODEINFO, CKEY, LPDW);
PUBLIC HRESULT PASCAL FAR GetBitStreamDWord (PNODEINFO, CKEY, LPDW);
PUBLIC HRESULT PASCAL FAR GetFixedDWord (PNODEINFO, CKEY, LPDW);
PUBLIC HRESULT PASCAL FAR ReadNewData(PNODEINFO pNodeInfo);
PUBLIC int PASCAL FAR ReadFileOffset (FILEOFFSET FAR *, LPB);
PUBLIC HRESULT PASCAL FAR FGetBits(PNODEINFO, LPDW, CBIT);
PUBLIC HRESULT PASCAL FAR ReadIndexHeader(HFPB, PIH20);
PUBLIC HRESULT PASCAL FAR CopyFileOffset (LPB pDest, FILEOFFSET fo);
PUBLIC CB PASCAL FAR CbBytePack (LPB lpbOut, DWORD dwIn);

/*************************************************************************
 *
 *                    INTERNAL PRIVATE FUNCTIONS
 *  All of them should be declared near
 *************************************************************************/
PRIVATE HRESULT PASCAL NEAR FGetBool(PNODEINFO pNodeInfo);
PRIVATE HRESULT PASCAL NEAR FGetScheme(PNODEINFO, LPCKEY);

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   LST PASCAL FAR | ExtractWord |
 *      Extract a compacted word from the input buffer and store
 *      it as a Pascal string. 
 *
 *  @parm   LST | lstWord |
 *      Buffer in which to put the Pascal word.
 *
 *  @parm   LST | lstCurPtr |
 *      Current pointer to the source. The word here is compacted
 *  
 *  @parm   LPW | pWlen |
 *      pointer to word's length buffer to be udpated
 *
 *  @rdesc
 *      The function will return the new position of the source pointer
 *
 *  @comm 
 *      There is a trick in the compression. This function works on
 *      the assumption that the SAME buffer is used for lstWord on
 *      successive call to it. The first word is always whole. Subsequent
 *      words may be part of the 1st one
 *      Ex: "solid" and "solidarity" will be encoded as:
 *          [0:5]solid and [5:5]arity
 *      The first call will be made for "solid" which will fill lstWord
 *      with:
 *          5solid
 *      The next call will update the postfix and the word length
 *          10solidarity
 *      Note that "solid" is the remain of last call buffer
 *
 *      Note: Tehre is no error checking for speed
 *************************************************************************/
PUBLIC LST PASCAL FAR ExtractWord(LST lstWord, LST lstCurPtr,
    LPW pwRealLength)
{
    SHORT   cbPrefix;
    SHORT   cbPostfix;
    DWORD   dwPrefixLength;
    BYTE    fHasWordLength;

    // Get the prefix length
    lstCurPtr += CbByteUnpack (&dwPrefixLength, lstCurPtr);
    cbPostfix = (USHORT)dwPrefixLength - 1;
    cbPrefix = (*lstCurPtr) & 0x7f;
    fHasWordLength = (*lstCurPtr) & 0x80;
    lstCurPtr++;

    // Update word length
    *pwRealLength = *(PUSHORT)lstWord = (USHORT)(cbPrefix + cbPostfix);
    lstWord += sizeof(SHORT);

    // Copy postfix
    MEMCPY (lstWord + cbPrefix, lstCurPtr, cbPostfix);
    lstCurPtr += cbPostfix;

    if (fHasWordLength)
    {
    	lstCurPtr += CbByteUnpack(&dwPrefixLength, lstCurPtr);
    	*pwRealLength = (WORD)dwPrefixLength;
    }
    CbBytePack (lstWord + cbPrefix + cbPostfix, (DWORD)(*pwRealLength));
    return  lstCurPtr;
}

PUBLIC CB PASCAL NEAR CbBytePack (LPB lpbOut, DWORD dwIn)
{
	LPB     lpbOldOut;

	/* Save the old offset */
	lpbOldOut = lpbOut;

	do
    {
		*lpbOut = (BYTE)(dwIn & 0x7F);  /* Get 7 bits. */
		dwIn >>= 7;
		if (dwIn)
			*lpbOut |= 0x80;        /* To be continued... */
		lpbOut++;
	} while (dwIn);
	return (CB)(lpbOut - lpbOldOut);              /* Return compressed width */
}


int FAR PASCAL StrCmpPascal2(LPB lpStr1, LPB lpStr2)
{
    int fRet;
    int register len;

    // Get the minimum length
    if ((fRet = *(LPUW)lpStr1 -  *(LPUW)lpStr2 ) > 0)  
        len = *(LPUW)lpStr2;
    else 
        len = *(LPUW)lpStr1;

    // Skip the lengths */
    lpStr1 += sizeof (SHORT);
    lpStr2 += sizeof (SHORT);

    // Start compare byte per byte */
    for (; len > 0; len--, lpStr1++, lpStr2++) 
    {
        if (*lpStr1 != *lpStr2)
          break;
    }

    if (len == 0) 
    	return fRet;
    return (*lpStr1 - *lpStr2);
}


int PASCAL FAR ReadFileOffset (FILEOFFSET FAR *pFo, LPB pSrc)
{
    pFo->dwOffset = GETLONG ((LPUL)pSrc);
    pSrc += sizeof (DWORD);
    pFo->dwHigh = GETWORD ((LPUL)pSrc);

    return FOFFSET_SIZE;
}

PUBLIC HRESULT PASCAL FAR CopyFileOffset (LPB pDest, FILEOFFSET fo)
{

    *(LPUL)pDest = fo.dwOffset;
    pDest += sizeof (DWORD);
    *(LPUW)pDest = (WORD)fo.dwHigh;
    pDest += sizeof (WORD);
    return FOFFSET_SIZE;
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   HRESULT FAR PASCAL | ReadIndexHeader |
 *      Read the index header
 *
 *  @parm   HFPB | hfpb |
 *      Handle of index file
 *
 *  @parm   PIH20 | pHeader |
 *      Pointer to header info structure
 *
 *  @rdesc  S_OK if succeeded, errors otherwise
 *************************************************************************/
PUBLIC HRESULT FAR PASCAL ReadIndexHeader(HFPB hfpbSubFile, PIH20 pHeader)
{
    ERRB  errb;

    // foNil should, of course, be nil
    ITASSERT(0 == foNil.dwOffset && 0 == foNil.dwHigh);

    if (FileSeekRead(hfpbSubFile, pHeader, foNil,
    	sizeof(IH20), &errb) != sizeof(IH20))
    {
    	return errb;
    }

    /* Mac code. Those following lines will be optimized out */
    pHeader->FileStamp = SWAPWORD(pHeader->FileStamp);
    pHeader->version = SWAPWORD(pHeader->version);
    pHeader->lcTopics = SWAPLONG(pHeader->lcTopics);
    pHeader->foIdxRoot.dwOffset = SWAPLONG(pHeader->foIdxRoot.dwOffset);
    pHeader->foIdxRoot.dwHigh = SWAPLONG(pHeader->foIdxRoot.dwHigh);
    pHeader->nidLast = SWAPLONG(pHeader->nidLast);
    pHeader->nidIdxRoot = SWAPLONG(pHeader->nidIdxRoot);
    pHeader->cIdxLevels = SWAPWORD(pHeader->cIdxLevels);
    pHeader->occf = SWAPWORD(pHeader->occf);
    pHeader->idxf = SWAPWORD(pHeader->idxf);
 
    /* Index statistics */
    pHeader->dwMaxFieldId = SWAPLONG(pHeader->dwMaxFieldId);
    pHeader->dwMaxWCount = SWAPLONG(pHeader->dwMaxWCount);
    pHeader->dwMaxOffset = SWAPLONG(pHeader->dwMaxOffset);
    pHeader->dwMaxWLen = SWAPLONG(pHeader->dwMaxWLen);
    pHeader->dwBlockSize = SWAPLONG(pHeader->dwBlockSize);
    pHeader->dwMinTopicId = SWAPLONG(pHeader->dwMinTopicId);
    pHeader->dwMaxTopicId = SWAPLONG(pHeader->dwMaxTopicId);

	/* New members for index file version 4.0 */
    pHeader->dwCodePageID = SWAPLONG(pHeader->dwCodePageID);
    pHeader->lcid = SWAPLONG(pHeader->lcid);
    pHeader->dwBreakerInstID = SWAPLONG(pHeader->dwBreakerInstID);
 

    return S_OK;
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   HRESULT PASCAL FAR | ReadNewData|
 *      Read in mode data
 *
 *  @parm   PNODEINFO | pNodeInfo |
 *      Pointer to data node info
 *  @rdesc  S_OK if succesful, otherwise other errors
 *************************************************************************/
PUBLIC HRESULT PASCAL FAR ReadNewData(PNODEINFO pNodeInfo)
{
    ERRB   errb;
    DWORD  cbDataRead;
	LONG   cbRead;

    if ((cbDataRead = pNodeInfo->dwDataSizeLeft) == 0)
    	return(S_OK);    // Nothing else to read
	
    if (cbDataRead > FILE_BUFFER)
    	cbDataRead = FILE_BUFFER;

#if defined(_DEBUG) && defined(_DUMPALL)
	_DPF2("Data read @ %lu, size = %lu\n", pNodeInfo->nodeOffset.dwOffset, \
			cbDataRead);
#endif

    // Read the data block
    if ((cbRead = FileSeekRead (pNodeInfo->hfpbIdx, pNodeInfo->pBuffer,
    	pNodeInfo->nodeOffset, cbDataRead, &errb)) != (LONG)cbDataRead)
	{
		SetErrCode (&errb, E_ASSERT);
	}
	
    pNodeInfo->pMaxAddress = pNodeInfo->pBuffer + cbRead;
    pNodeInfo->dwDataSizeLeft -= cbRead;
    pNodeInfo->nodeOffset = FoAddDw(pNodeInfo->nodeOffset, cbRead);
    pNodeInfo->pCurPtr = pNodeInfo->pBuffer;
    pNodeInfo->ibit = cbitBYTE - 1;

    return S_OK;
}


/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   HRESULT PASCAL FAR | ReadLeafNode |
 *      Leaf node structure:
 *      Next block Ptr | CbLeft |* Word | PointerToNode *| Slack
 *          6b            2b    | Var   |    6b
 *
 *  @parm   PNODEINFO | pNodeInfo |
 *      Pointer to leaf info
 *
 *  @parm   HRESULT | cLevel |
 *      Level of the node. 0 is the top node
 *
 *  @rdesc  S_OK if succesful, otherwise other errors
 *************************************************************************/
PUBLIC HRESULT PASCAL FAR ReadLeafNode (PNODEINFO pNodeInfo, int cLevel)
{
    ERRB errb;

#if defined(_DEBUG) && defined(_DUMPALL)
	_DPF2("Leaf read @ %lu, size = %lu\n", pNodeInfo->nodeOffset.dwOffset, \
			pNodeInfo->dwBlockSize);
#endif
    pNodeInfo->pBuffer = pNodeInfo->pLeafNode;
    if (FileSeekRead (pNodeInfo->hfpbIdx, pNodeInfo->pBuffer,
    	pNodeInfo->nodeOffset, pNodeInfo->dwBlockSize,
    	&errb) != (long)pNodeInfo->dwBlockSize)
    {
    	return (errb);
    }
	
    // Remember to subtract cbLeft from the node size
    pNodeInfo->cbLeft = GETWORD((LPUW)(pNodeInfo->pBuffer + FOFFSET_SIZE));
    pNodeInfo->pCurPtr = pNodeInfo->pBuffer + FOFFSET_SIZE + sizeof(WORD);    
    pNodeInfo->pMaxAddress = pNodeInfo->pBuffer +
	                            pNodeInfo->dwBlockSize - pNodeInfo->cbLeft;
    return S_OK;
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   HRESULT PASCAL FAR | ReadStemNode |
 *      Read in a new node from the disk if it is not the top node.
 *      For the top node, just reset various pointers
 *      Stem node structure:
 *      CbLeft |* Word | PointerToNode *| Slack
 *       2b    | Var   |    6b
 *
 *  @parm   PNODEINFO | pNodeInfo |
 *      Pointer to leaf info
 *
 *  @parm   int | cLevel |
 *      Level of the node. 0 is the top node
 *
 *  @rdesc  S_OK if succesful, otherwise other errors
 *************************************************************************/
PUBLIC HRESULT PASCAL FAR ReadStemNode (PNODEINFO pNodeInfo, int cLevel)
{
    ERRB errb;
#if 0
    DWORD  cbLeft;
#endif

    if (cLevel == 0) 
    {   // The top node is buffered.
    	pNodeInfo->pBuffer = pNodeInfo->pTopNode;

    }
    else
    {   // The rest isn't.
#if defined(_DEBUG) && defined(_DUMPALL)
	_DPF2("Stem read @ %lu, size = %lu\n", pNodeInfo->nodeOffset.dwOffset, \
			pNodeInfo->dwBlockSize);
#endif

    	pNodeInfo->pBuffer = pNodeInfo->pStemNode;
    	if (FileSeekRead (pNodeInfo->hfpbIdx, pNodeInfo->pBuffer,
    	    pNodeInfo->nodeOffset, pNodeInfo->dwBlockSize,
    	    &errb) != (long)pNodeInfo->dwBlockSize)
    	{
    	    return (errb);
    	}
    	
    }
    // Remember to subtract cbLeft from the node size
#if 0
    pNodeInfo->pCurPtr = pNodeInfo->pBuffer + 
	CbByteUnpack (&cbLeft, pNodeInfo->pBuffer);
#else
    pNodeInfo->cbLeft = GETWORD(pNodeInfo->pBuffer);
    pNodeInfo->pCurPtr = pNodeInfo->pBuffer + sizeof(WORD);    
#endif        
    pNodeInfo->pMaxAddress = pNodeInfo->pBuffer +
	pNodeInfo->dwBlockSize - pNodeInfo->cbLeft;
    return S_OK;
}

PUBLIC HRESULT PASCAL FAR GetFixedDWord (PNODEINFO pNodeInfo, CKEY ckey, LPDW lpdw)
{
    return FGetBits(pNodeInfo, lpdw, (CBIT)(ckey.ucCenter + 1));
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   PUBLIC HRESULT PASCAL FAR | GetBellDWord |
 *      This function decode a dword encoded with the Bell scheme
 *
 *  @parm   PNODEINFO | pNodeInfo |
 *      Pointer to NODEINFO structure
 *
 *  @parm   CKEY | ckey |
 *      Decoding key
 *
 *  @parm   LPDW | lpdw |
 *      Place to store the result
 *
 *  @rdesc  S_OK if everything is OK, errors otherwise
 *
 *  @comm 
 *      The Bell compression scheme works as followed. If we have 1000
 *      numbers, 90% of them require 6 bits, and 10% require more than
 *      6 bits. In this case, ckey.ucCenter will be 6, ie. the minimum
 *      number of bits. The extra number of bits needed to store the
 *      extra numbers is stored as a series of 1's
 *          - First, we check the next bit. If it is 1, then extra bits
 *          are needed. We then keep reading all the 1's bits to know
 *          the number of extra bits needed
 *          - We then read the number using the number of bits needed
 *************************************************************************/
PUBLIC HRESULT PASCAL FAR GetBellDWord (PNODEINFO pNodeInfo, CKEY ckey, LPDW lpdw)
{
    register BYTE   bData;
    register int cBitLeft;
    register int cCount;
    HRESULT     fRet;
    LPB     lpbCurPtr;
    DWORD   dwVal;
    LPB     lpMaxAddress = pNodeInfo->pMaxAddress;
    int     tmp;
    DWORD   dwBlockSize = pNodeInfo->dwBlockSize;

    cCount = ckey.ucCenter;
    dwVal = 0L;

	if ((lpbCurPtr = pNodeInfo->pCurPtr) >= lpMaxAddress)
	{
		if ((fRet = ReadNewData (pNodeInfo)) != S_OK)
			return fRet;
		lpbCurPtr = pNodeInfo->pCurPtr;
		lpMaxAddress = pNodeInfo->pMaxAddress;
	}

    /* This is duplicate of FGetBool() to speed things up */

    /* Make copy of pNodeInfo->lrgbCurPtr and pNodeInfo->ibit to avoid indexed
     * references
     */
    bData = *lpbCurPtr;

    /* Check to make suere that we do have enough data */

    if ((cBitLeft = pNodeInfo->ibit) < 0)
    {
    	if (++lpbCurPtr >= lpMaxAddress) 
    	{
    	    if ((fRet = ReadNewData (pNodeInfo)) != S_OK)
    			return fRet;
    	    lpbCurPtr = pNodeInfo->pCurPtr;
    	    lpMaxAddress = pNodeInfo->pMaxAddress;
    	}
    	bData = *lpbCurPtr;
    	cBitLeft = cbitBYTE - 1;
    }

    if ((bData & BitMask[cBitLeft--]) > 0)
    {
    	/* Get the number of all extra bits */

    	for (;;)
    	{
    	    /* This is duplicate of FGetBool() to speed things up */

    	    if (cBitLeft < 0)
            {
        		if (++lpbCurPtr >= lpMaxAddress)
        		{
        		    if ((fRet = ReadNewData (pNodeInfo)) != S_OK)
            			return fRet;
        		    lpbCurPtr = pNodeInfo->pCurPtr;
        		    lpMaxAddress = pNodeInfo->pMaxAddress;
        		}
        		bData = *lpbCurPtr;
        		cBitLeft = cbitBYTE - 1;
    	    }

    	    if ((bData & BitMask[cBitLeft--]) > 0) 
        		cCount++;
    	    else 
        		break;
    	}

    	dwVal = (1L << cCount);

    }

    cBitLeft ++;

    if (cCount)
    {

    	/* Duplicate of FGetBits() to speed things up */
    	do
    	{
    	    if (cBitLeft <= 0)
    	    {
        		if (++lpbCurPtr >= lpMaxAddress)
        		{
        		    if ((fRet = ReadNewData (pNodeInfo)) != S_OK)
        			return fRet;
        		    lpbCurPtr = pNodeInfo->pCurPtr;
        		    lpMaxAddress = pNodeInfo->pMaxAddress;
        		}
        		cBitLeft = cbitBYTE;
        		bData = *lpbCurPtr;
    	    }

    	    if (cCount >= (tmp = cBitLeft))
    	    {
        		dwVal |= ((DWORD)(bData & BitLeftMask[cBitLeft]))
        		    << (cCount -= cBitLeft);
        		cBitLeft = 0;
    	    }
    	    else
    	    {
        		dwVal |= (((DWORD)(bData& BitLeftMask[tmp]))
        		    >> (cBitLeft -= cCount));
        		break;
    	    }
    	} while (cCount);
    }

    /* Update values */
    *lpdw = dwVal;
    pNodeInfo->ibit = cBitLeft - 1;

    pNodeInfo->pCurPtr = lpbCurPtr;
    return S_OK;
}

PUBLIC HRESULT PASCAL FAR GetBitStreamDWord (PNODEINFO pNodeInfo, CKEY ckey, LPDW lpdw)
{
    int fBit;
    *lpdw = 0;

    for (;;)
    {
	if ((fBit = FGetBool(pNodeInfo)) > 0) 
	    (*lpdw)++;
	else if (!fBit)
	    return S_OK;
	else
	    return E_FAIL;
    }
}


/*************************************************************************
 *
 *                    INTERNAL PRIVATE FUNCTIONS
 *  All of them should be declared near
 *************************************************************************/
 
//  Get a single bit from the index.

PRIVATE HRESULT PASCAL FAR FGetBool (
    PNODEINFO    pNodeInfo)       // Current leaf info.
{
    if ((short)pNodeInfo->ibit < 0)
    {
    	pNodeInfo->pCurPtr++;
    	pNodeInfo->ibit = cbitBYTE - 1;
    }
    return *pNodeInfo->pCurPtr & (1 << pNodeInfo->ibit--);
}

PRIVATE HRESULT PASCAL FAR FGetScheme(
    PNODEINFO    pNodeInfo,       // Current leaf info.
    LPCKEY  lpckey)     // Output buffer.
{
    int fSchemeBit;     // Scratch boolean.
    HRESULT fRet;

    lpckey->cschScheme = CSCH_NONE;
    if ((fSchemeBit = FGetBool(pNodeInfo)) == (int)-1)
    {
    	return E_FAIL;
    }
    if (fSchemeBit)
    	lpckey->cschScheme = CSCH_FIXED;
    else
    {
        if ((fSchemeBit = FGetBool(pNodeInfo)) == (int)-1) 
    	{
    	    return E_FAIL;
    	}
    	if (fSchemeBit)
    	    lpckey->cschScheme = CSCH_BELL;
    }
    if ((lpckey->cschScheme == CSCH_BELL) ||
    	(lpckey->cschScheme == CSCH_FIXED))
    {
    	DWORD   dwTmp;

    	if ((fRet = FGetBits(pNodeInfo, &dwTmp, 5)) != S_OK)
    	{
    	    return fRet;
    	}
    	lpckey->ucCenter = (BYTE)dwTmp;
    }
    return S_OK;
}

//  -   -   -   -   -   -   -   -   -

//  Get some number of bits from the index.  If this function were
//  faster life would be better.  It's called incredibly frequently.

PUBLIC HRESULT PASCAL FAR FGetBits(
    PNODEINFO    pNodeInfo,         // Current leaf info.
    LPDW    lpdw,                   // Output buffer.
    register CBIT cbit)             // How many bits to get.
{
    register BYTE cBitLeft;
    register BYTE tmp;
    LPB     lpbCurPtr;
    DWORD   dwVal;
//  HRESULT fRet;

    if (cbit == 0)
    {
    	*lpdw = 0;
    	return S_OK;
    }
    dwVal = 0;
    cBitLeft = pNodeInfo->ibit + 1;
    lpbCurPtr = pNodeInfo->pCurPtr;

    do 
    {
		HRESULT fRet;

    	if (cBitLeft <= 0) 
    	{
    	    lpbCurPtr++;
			if (lpbCurPtr >= pNodeInfo->pMaxAddress)
			{
				if ((fRet = ReadNewData (pNodeInfo)) != S_OK)
					return fRet;
				lpbCurPtr = pNodeInfo->pCurPtr;
			}

    	    cBitLeft = cbitBYTE;
    	}
    	if (cbit >= (CBIT)(tmp = cBitLeft)) 
    	{
    	    dwVal |= ((DWORD)(*lpbCurPtr & BitLeftMask[cBitLeft]))
    		<< (cbit -= cBitLeft);
    	    cBitLeft = 0;
    	}
    	else 
    	{
    	    dwVal |= (((DWORD)(*lpbCurPtr & BitLeftMask[tmp]))
    		>> (cBitLeft -= cbit));
    	    break;
    	}
    } while (cbit);

    /* Update values */
    *lpdw = dwVal;
    pNodeInfo->ibit = cBitLeft - 1;
    pNodeInfo->pCurPtr = lpbCurPtr;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\httpsrch.h ===
/* httpsrch.h */

//-----------------
// FULL TEXT SEARCH
//-----------------

// Variables used to echange information between server and client
#define	FTS_DOWNLOAD \
   LPBYTE  lpTopicBuf;			/* dest buffer for topics */ \
   LPBYTE  lpOccBuf;			/* dest buffer for occurences */ \
   DWORD   dwTopicBsize;		/* topic buffer size */ \
   DWORD   dwOccBsize;			/* Occurence buffer size */ \
   DWORD   lcTotalNumOfTopics;	/* The total number of topics returned */ \
   DWORD   lcReturnedTopics;	/* The total number of topics the user wants to get returned */ \
   DWORD   lcDownloadedTopics;	/* number of topics downloaded during the last request (HTTP) */ \
   DWORD   lcMaxTopic;          /* Max TopicId number (internal) */ \
   DWORD   lcMaxDownloadedTopic;/* Max TopicId number downloaded (HTTP) */ \
   DWORD   lLastTopicId;		/* Last accessed topicId */ \
   DWORD   dwStart;				/* first topic in the list to download for current result window */ \
   DWORD   dwCount;				/* how many topics to download for current result window & Offset in Occurence file (last) */ \
   DWORD   dwOccFileOffset   


typedef struct _httpFTS_TAG
{
   HANDLE   hStruct;	  // handle on this structure MUST be first field
 
   FTS_DOWNLOAD;		  // Client/Server info interface

   /* Info related to the query */

   HANDLE   hTitle;		  // virtual handle on the client side
   DWORD    dwFlags;
   HANDLE   hStrQuery;  // handle on the query string
   LPCSTR   lpstrQuery; // The Query
   LPVOID   lpGroup;	// LPGROUP lpGroup,
   WORD     wNear;
   WORD		pad;
   DWORD	dwCountQ;   // dwCount from the Query
   LPVOID   lpGroupHits;

   // Global result for this query
   DWORD    dwGStart;      // first topic in the list that has been downloaded from the beginning
   DWORD    dwGCount;      // how many topics have been downloaded from the beginning

} HTTPQ, *LPHTTPQ;

// parameters downloaded by the server: This structure MUST
// match exactly the "Partial download variables Section"
// in the above HTTPQ structure declaration.

typedef struct _httpFTS_VARTAG
{
	FTS_DOWNLOAD;

} VHTTPQ, *LPVHTTPQ;


#define DWNLD_TOPIC_SIZE	20000
#define DWNLD_OCC_SIZE		44000

// number of topics to download in a window of result

#define DWNLD_CNT			10

// comparison macros

#define MIN(a, b)  (((a) < (b)) ? (a) : (b)) 
#define MAX(a, b)  (((a) > (b)) ? (a) : (b)) 
#define ABS(x)	   ((x > 0) ? (x) : (-x))


//-----------------
// WORDWHEEL SEARCH
//-----------------

// Variables used to echange information between server and client
#define	WWS_DOWNLOAD \
   LPBYTE  lpGroupDestBuf;		/* dest buffer for the result group */ \
   DWORD   lcItemReturned;		/* number of items returned till now */ \
   DWORD   lcTotalNumOfItem;	/* The total number of Item */ \
   DWORD   lcDownloadedTopics;	/* number of topics downloaded during the last request (HTTP) */ \
   DWORD   lcMaxTopic;          /* Max TopicId number (internal) */ \
   DWORD   lcMaxDownloadedTopic;/* Max TopicId number downloaded (HTTP) */ \
   DWORD   lLastTopicId;		/* Last accessed topicId */ \
   DWORD   dwStart;				/* first topic in the list to download for current result window & how many topics to download for current result window & Offset in Occurence file (last) */ \
   DWORD   dwCount


typedef struct _httpWWS_TAG
{
   HANDLE   hStruct;	  // handle on this structure MUST be first field
 
   WWS_DOWNLOAD;		  // Client/Server info interface

   /* Info related to the query */

   HANDLE   hCww;		  // handle on client word wheel container
   DWORD    dwFlags;
   HANDLE   hStrQuery;    // handle on the query string
   LPCSTR   lpstrQuery;   // The Query
   LPVOID   lpGroup;	  // LPGROUP lpGroup,
   DWORD	dwCountQ;     // dwCount from the Query
   LPVOID   lpGroupHits;

   // Global result for this query
   DWORD    dwGStart;      // first topic in the list that has been downloaded from the beginning
   DWORD    dwGCount;      // how many topics have been downloaded from the beginning

} WW_HTTPQ, *LPWW_HTTPQ;

// parameters downloaded by the server: This structure MUST
// match exactly the "Partial download variables Section"
// in the above HTTPQ structure declaration.

typedef struct _httpWWS_VARTAG
{
	WWS_DOWNLOAD;

} WW_VHTTPQ, *LPWW_VHTTPQ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\icatalog.c ===
/*************************************************************************
*                                                                        *
*  ICATALOG.C                                                            *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   Catalog generating                                                   *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Revision History:                                                     *
*                                                                        *
**************************************************************************
*                                                                        *
*  Released by Development:     (date)                                   *
*                                                                        *
*************************************************************************/

#include <mvopsys.h>
#include <mem.h>
#include <memory.h>
#include <orkin.h>
#include <mvsearch.h>
#include "common.h"
#include "index.h"

#ifdef _DEBUG
static BYTE NEAR s_aszModule[] = __FILE__;	/* Used by error return functions.*/
#endif


#define CAT_BUF_SIZE    CB_HUGE_BUF // Catalog buffer's size

/*************************************************************************
 *
 *                       API FUNCTIONS
 *  Those functions should be exported in a .DEF file
 *************************************************************************/
PUBLIC LPCAT EXPORT_API PASCAL FAR CatalogInitiate (WORD, PHRESULT);
PUBLIC HRESULT EXPORT_API PASCAL FAR CatalogAddItem (LPCAT, DWORD, LPB);
PUBLIC HRESULT EXPORT_API PASCAL FAR CatalogBuild (HFPB, LPCAT, LSZ,
    INTERRUPT_FUNC, LPV);
PUBLIC VOID EXPORT_API PASCAL FAR CatalogDispose (LPCAT lpCat);

/*************************************************************************
 *
 *                    INTERNAL PRIVATE FUNCTIONS
 *  All of them should be declared near
 *************************************************************************/
PRIVATE HRESULT PASCAL NEAR CatalogFlush (CAT_INDEX FAR *);
PRIVATE HRESULT PASCAL NEAR CatalogSort (CAT_INDEX FAR *);
PRIVATE HRESULT PASCAL NEAR CatalogMerge (CAT_INDEX FAR *);

/*************************************************************************
 *  @doc    API INDEX
 *
 *  @func   LPCAT PASCAL FAR | CatalogInitiate |
 *      Create and initialize different structures and temporary files
 *      needed for the creation of a catalog
 *
 *  @parm   WORD | wElemSize |
 *      Size of each element in a catalog
 *
 *  @parm   PHRESULT | phr |
 *      Error buffer to be used in subsequent catalog related function calls
 *
 *  @rdesc NULL if failed. The error buffer will contain descriptions about
 *      the cause of the failure
 *************************************************************************/
PUBLIC LPCAT EXPORT_API PASCAL FAR CatalogInitiate (WORD wElemSize,
    PHRESULT phr)
{
    CAT_INDEX   FAR *lpCat;
    HANDLE  handle;         // Temporary variable

    //  Initialization phase.  Allocate memory, create temporary
    //  and permanent files.
    //
    if ((handle = _GLOBALALLOC(DLLGMEM_ZEROINIT,
        sizeof(CAT_INDEX))) == NULL) {
        SetErrCode(phr, E_OUTOFMEMORY);
        return NULL;
    }

    lpCat  = (LPCAT)_GLOBALLOCK(handle);
    lpCat->hCat = handle;
    lpCat->lperrb = phr;
    lpCat->wElemSize = wElemSize;
    lpCat->FileStamp = CATALOG_STAMP;
    lpCat->version = VERCURRENT;
    lpCat->dwCurElem = lpCat->dwFirstElem = (DWORD)-1;

    /* Assume that all incoming data are already sorted
       in ascending order
    */
    lpCat->fFlags = CAT_SORTED;
    lpCat->aszTempFile = lpCat->TmpFileNames;

    /* Create temp file */

    (void)GETTEMPFILENAME((char)0, (LSZ)"cat", (WORD)0,
        (LSZ)lpCat->aszTempFile);

    if ((lpCat->hResultFile = _lcreat (lpCat->aszTempFile, 0)) == (HFILE)-1) {

exit01:
        _GLOBALUNLOCK(lpCat->hCat);
        _GLOBALFREE(lpCat->hCat);
        return NULL;
    }

    /* Allocate memory */
    if ((handle = _GLOBALALLOC(DLLGMEM, CAT_BUF_SIZE)) == NULL) {
        SetErrCode(phr, E_OUTOFMEMORY);

        /* Remove temp file */
        _lclose(lpCat->hResultFile);
        FileUnlink(NULL,lpCat->aszTempFile,REGULAR_FILE);
        goto exit01;
    }

    lpCat->lpCatBuf = _GLOBALLOCK(lpCat->hCatBuf = handle);
    lpCat->ibBufOffset = 0;
    return lpCat;
}

/*************************************************************************
 *  @doc    API INDEX
 *  
 *  @func   HRESULT PASCAL FAR | CatalogAddItem |
 *      Add an item into the catalog
 *
 *  @parm   LPCAT | lpCat |
 *      Pointer to catalog structure (returned by CatalogInitiate())
 *
 *  @parm   DWORD | dwItemN |
 *      Item's id
 *  
 *  @parm   LPB | lpCatElement |
 *      Buffer contained the value of the catalog item. The size of this
 *      buffer is pre-determined in CatalogInitiate()
 *  
 *  @rdesc S_OK if succeeded. The error buffer provided in CatalogInitiate()
 *      will contain descriptions about the cause of the failure
 *  
 *  @xref   CatalogInitiate()
 *************************************************************************/
PUBLIC HRESULT EXPORT_API PASCAL FAR CatalogAddItem (CAT_INDEX FAR *lpCat,
    DWORD dwItemN, LPB lpCatElement)
{
    WORD wNewOffset;
    LPB lpBuf;

    /* Sanity check */
    if (lpCat == NULL || lpCatElement == NULL)
        return E_INVALIDARG;

    if (lpCat->dwFirstElem == (DWORD)-1) {
        lpCat->dwFirstElem = dwItemN;
    }
    else {
        if (dwItemN <= lpCat->dwCurElem) {
            /* The elements are not sorted */
            lpCat->fFlags &= ~CAT_SORTED;
            if (lpCat->dwFirstElem > dwItemN)
                lpCat->dwFirstElem = dwItemN;
        }
    }

    /* Check to see if we have enough room in the buffer. If not
     * just flush the buffer to make room for new data
     */
    if (lpCat->ibBufOffset + (wNewOffset  = lpCat->wElemSize +
        sizeof(DWORD)) >= CAT_BUF_SIZE) {
        if (CatalogFlush(lpCat) != S_OK)
            return E_FAIL;
    }

    /* Have enough room, just copy data */

    lpBuf = lpCat->lpCatBuf + lpCat->ibBufOffset;
    *(LPDW)lpBuf = dwItemN;
    lpBuf += sizeof (DWORD);
    MEMCPY(lpBuf, lpCatElement, lpCat->wElemSize);

    /* Only update buffer pointer if the last datum is not the
       same as this one
    */

    if (lpCat->dwCurElem != dwItemN) {
        lpCat->dwCurElem = dwItemN;
        lpCat->ibBufOffset += wNewOffset;
        lpCat->cElement ++;
    }
    return S_OK;
}

/*************************************************************************
 *  @doc    API INDEX
 *
 *  @func   int PASCAL FAR | CatalogBuild |
 *      Write the catalog as a subfile of the system file
 *
 *  @parm   HFPB | hfpbSysFile |
 *      If non-zero, this is the handle of an already opened system file
 *
 *  @parm LPCAT | lpCat |
 *      Pointer to catalog structure (returned by CatalogInitiate())
 *
 *  @parm   LSZ | lszFilename |
 *      If hpfbSysFile is non-zero, this is the name of the catalog's subfile
 *      else this is a regular DOS file
 *
 *  @rdesc S_OK if succeeded, other errors otherwise
 *      the failure
 *
 *  @xref   CatalogInitiate()
 *************************************************************************/
PUBLIC HRESULT EXPORT_API PASCAL FAR CatalogBuild (HFPB hfpbSysFile,
    CAT_INDEX FAR *lpCat, LSZ lszCatName, INTERRUPT_FUNC fnInterrupt,
    LPV lpParm)
{
    WORD cbBufSize;         // Buffer size
    WORD cbBytePerItem;     // Number of bytes per item
    WORD cItemRead;         // Number of items read at once
    int  cbRead;            // Number of bytes read at once
    HANDLE hResultBuf;      // Handle of temporary buffer
    LPB  lpbResultBuf;      // Temporary result buffer
    LPB  lpbCurItem;        // Pointer at current item
    LPB  lpbInBuf;          // Pointer for input buffer
    DWORD lfoFileOffset;    // Current offset in catalog subfile
    WORD cbTotalInBuf;      // Total number of bytes in tmpbuf
    PHRESULT phr;          // Error buffer
    HRESULT fRet;              // Return value
    BYTE Dummy[CATALOG_HDR_SIZE]; // Dummy buffer to write 0
    long LastItem;          // Last item
    long CurItem;           // Current item
    WORD wElemSize;         // Element size

    if (lpCat == NULL || lszCatName == NULL)
        return E_INVALIDARG;

    phr = lpCat->lperrb;
    fRet = E_FAIL;  // Default fRet

    /* Flush the catalog buffer */

    if ((fRet = CatalogFlush(lpCat)) != S_OK)
    {
        SetErrCode(phr, fRet);
        goto exit00;
    }

    /* Rewind the temp file */
    if (_llseek(lpCat->hResultFile, 0L, 0) == (LONG)-1)
    {
        SetErrCode(phr, E_FILESEEK);
        goto exit00;
    }
    
    /* Open system file & catalog subfile */
    if ((lpCat->hfpbCatalog = FileCreate(hfpbSysFile, lszCatName,
        hfpbSysFile ? FS_SUBFILE : REGULAR_FILE, phr)) == NULL)
    {
        goto exit00;
    }

    /* Inititalize various variables */
    cbBytePerItem = sizeof (DWORD) + (wElemSize = lpCat->wElemSize);
    cItemRead = CAT_BUF_SIZE / cbBytePerItem;
    cbBufSize = cItemRead * cbBytePerItem;
    LastItem = lpCat->dwFirstElem - 1;
    lpCat->cElement = 0;

    /* Allocate a temporary buffer */
    if ((hResultBuf = _GLOBALALLOC(DLLGMEM, CAT_BUF_SIZE)) == NULL)
    {
        SetErrCode(phr, E_OUTOFMEMORY);
        goto exit01;
    }
    lpbResultBuf = _GLOBALLOCK(hResultBuf);
    lfoFileOffset = 0;

    /* Reserve space for catalog information */
    lpbCurItem = lpbResultBuf +
        (cbTotalInBuf = CATALOG_HDR_SIZE);

    for (;;) {
        if (fnInterrupt != NULL) {

            /* Call user's interrupt functions */

            if ((fRet = (*fnInterrupt)(lpParm)) != S_OK)
            {
                SetErrCode(phr, fRet);
                goto FreeAll;
            }
        }

        /* Read in a block */
        if ((cbRead = _lread(lpCat->hResultFile, lpCat->lpCatBuf,
            cbBufSize)) == (LONG)-1)
        {
            SetErrCode(phr, E_FILEREAD);
            goto FreeAll;
        }

        if (cbRead == 0)    // EOF check
            break;

        for (lpbInBuf = lpCat->lpCatBuf; cbRead > 0;)
        {

            if ((LastItem > *(long far *)lpbInBuf))
            {
                SetErrCode(phr, E_ASSERT);
                goto FreeAll;
            }

            CurItem = *(LPDW)lpbInBuf;
            lpbInBuf += sizeof(DWORD);

            /* Fill up the "holes", ie. missing indices. For random access
               retrieval to work, all items need to be present. So if we
               only have keys 1 and 5, we have to fill in "holes" of key
               2, 3, 4.
            */

            while (LastItem < CurItem - 1)
            {

                /* If buffer is full, flush it to subfile */
                if (cbTotalInBuf + cbBytePerItem > cbBufSize)
                {
                    if (fnInterrupt != NULL)
                    {

                        /* Call user's interrupt functions */

                        if ((fRet = (*fnInterrupt)(lpParm)) != S_OK)
                        {
                            SetErrCode(phr, fRet);
                            goto FreeAll;
                        }
                    }

                    if (FileWrite(lpCat->hfpbCatalog, lpbResultBuf,
                        cbTotalInBuf,NULL) != cbTotalInBuf)
                    {
                        goto FreeAll;
                    }

                    /* Reset the variables */

                    lfoFileOffset += cbTotalInBuf;
                    lpbCurItem = lpbResultBuf;
                    cbTotalInBuf = 0;
                }

                /* Fill the missing element with -1 */
                MEMSET(lpbCurItem, (BYTE)-1, wElemSize);
                lpbCurItem += wElemSize;
                cbTotalInBuf += wElemSize;
                lpCat->cElement++;
                LastItem++;
            }

            /* If buffer is full, flush it to subfile */

            if (cbTotalInBuf + cbBytePerItem > cbBufSize)
            {
                if (FileWrite(lpCat->hfpbCatalog, lpbResultBuf,
                    cbTotalInBuf,NULL) != cbTotalInBuf)
                {
                    goto FreeAll;
                }

                /* Reset the variables */

                lfoFileOffset += cbTotalInBuf;
                lpbCurItem = lpbResultBuf;
                cbTotalInBuf = 0;
            }

            /* Copy the data */
            MEMCPY(lpbCurItem, lpbInBuf, wElemSize);

            /* Only update pointer if data indices are different */
            if (LastItem != CurItem)
            {
                lpbCurItem += wElemSize;
                cbTotalInBuf += wElemSize;
                LastItem = CurItem;
                lpCat->cElement++;
            }

            lpbInBuf += wElemSize;
            cbRead -= wElemSize + sizeof(DWORD);
        }
    }

    /* Flush the buffer */

    if (cbTotalInBuf > 0)
    {
        if (FileWrite(lpCat->hfpbCatalog, lpbResultBuf,
            cbTotalInBuf, phr) != cbTotalInBuf)
        {
            fRet = *phr;
            goto FreeAll;
        }
    }

    /* Write catalog header information. */

    MEMSET(Dummy, (BYTE)0, CATALOG_HDR_SIZE);

    /* Write all zero to the header */
    if (FileSeekWrite(lpCat->hfpbCatalog, Dummy, foNil,
        CATALOG_HDR_SIZE, phr) != CATALOG_HDR_SIZE)
    {
        fRet = *phr;
        goto FreeAll;
    }

    if (FileSeekWrite(lpCat->hfpbCatalog, lpCat, foNil,
        sizeof(CAT_HEADER),phr)!=sizeof (CAT_HEADER))
        fRet = *phr;

FreeAll:
    _GLOBALUNLOCK(hResultBuf);
    _GLOBALFREE(hResultBuf);

exit01:
    FileClose(lpCat->hfpbCatalog);
    
exit00:
    return fRet;
}

/*************************************************************************
 *  @doc    API INDEX
 *
 *  @func   VOID PASCAL FAR | CatalogDispose |
 *      Release all memories and temporary files associated with
 *      the catalog
 *
 *  @parm LPCAT | lpCat |
 *      Pointer to catalog structure (returned by CatalogInitiate())
 *************************************************************************/
PUBLIC VOID EXPORT_API PASCAL FAR CatalogDispose (CAT_INDEX FAR *lpCat)
{
    if (lpCat == NULL)
        return;
    if (lpCat->hResultFile) {
        _lclose(lpCat->hResultFile);
        FileUnlink(NULL,lpCat->aszTempFile,REGULAR_FILE);
    }

    /* Free catalog buffer */
    _GLOBALUNLOCK(lpCat->hCatBuf);
    _GLOBALFREE(lpCat->hCatBuf);

    /* Free temporary index array */
    if (lpCat->hIndexArray) {
        _GLOBALUNLOCK(lpCat->hIndexArray);
        _GLOBALFREE(lpCat->hIndexArray);
    }

    /* Free catalog structure */
    _GLOBALUNLOCK(lpCat->hCat);
    _GLOBALFREE(lpCat->hCat);
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   PRIVATE HRESULT PASCAL NEAR | CatalogFlush |
 *      Flush out the catalog buffer. The function will perform sort
 *      if necessary
 *
 *  @parm   CAT_INDEX FAR * | lpCat |
 *      Pointer to catalog buffer
 *************************************************************************/
PRIVATE HRESULT PASCAL NEAR CatalogFlush (CAT_INDEX FAR *lpCat)
{
    HRESULT fRet;  // Returned value

    fRet = S_OK;
    if (lpCat->ibBufOffset == 0) {
        /* There is nothing to flush */
        return S_OK;
    }

    /* Sort the temporary buffer if it is not already sorted */
    if ((lpCat->fFlags & CAT_SORTED) == 0) {
        if ((fRet = CatalogSort (lpCat)) != S_OK)
            return fRet;
    }

    /* Write the sorted result to the temp file */
    if ((fRet = CatalogMerge (lpCat)) != S_OK)
        return fRet;

    /* Reset various variables */
    lpCat->fFlags |= CAT_SORTED;
    lpCat->cElement = lpCat->ibBufOffset = 0;
    return S_OK;
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   PRIVATE HRESULT PASCAL NEAR | CatalogMerge |
 *      Flush out the catalog buffer by merging the catalog buffer
 *      with the already flushed data in the temp file
 *
 *  @parm   CAT_INDEX FAR * | lpCat |
 *      Pointer to catalog buffer
 *
 *  @rdesc  The function returns S_OK if succeeded
 *************************************************************************/
PRIVATE HRESULT PASCAL NEAR CatalogMerge (CAT_INDEX FAR *lpCat)
{
    HRESULT fRet;

    if (lpCat->fFlags & CAT_SORTED) {
    /* everything is still sorted. Just add the buffer to the
       end of the file
    */
        if (_lwrite(lpCat->hResultFile, lpCat->lpCatBuf,
            lpCat->ibBufOffset) != lpCat->ibBufOffset) {
            return E_DISKFULL;
        }
    }
    else {
        if ((fRet = IndexMergeSort ((HFILE FAR *)&lpCat->hResultFile,
            (LSZ)lpCat->aszTempFile, lpCat->IndexArray,
            lpCat->lpCatBuf, lpCat->wElemSize + sizeof(DWORD),
            (WORD)lpCat->cElement)) != S_OK)
            return fRet;
    }
    return S_OK;
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   PRIVATE HRESULT PASCAL NEAR | CatalogSort |
 *      Given the array  ofdata in lpCat->lpbCatBuf, the function will
 *      perform an "indirect" sort. First, an index array containing
 *      the offsets of the elements in the buffer will be created.
 *      The function then call IndexSort() to do the sorting
 *
 *  @parm   CAT_INDEX FAR * | lpCat |
 *      Pointer to catalog buffer
 *
 *  @rdesc  The function returns S_OK if succeeded
 *************************************************************************/
PRIVATE HRESULT PASCAL NEAR CatalogSort (CAT_INDEX FAR *lpCat)
{
    LPW lpIndexArray;
    int cbElement;
    register int i, j;
    WORD wElemSize;
    
    if (lpCat->hIndexArray == 0) {
        /* Allocate the index buffer */
        if ((lpCat->hIndexArray= _GLOBALALLOC(DLLGMEM,
            (cbElement = (CAT_BUF_SIZE / lpCat->wElemSize)*sizeof(WORD))))
            == NULL) {
            return E_OUTOFMEMORY;
        }
        lpCat->IndexArray = (LPW)_GLOBALLOCK(lpCat->hIndexArray);
    }

    /* Initialize the index array */
    cbElement = (WORD)lpCat->cElement;
    wElemSize = lpCat->wElemSize + sizeof(DWORD);

    for (j = 0, i = cbElement, lpIndexArray = lpCat->IndexArray;
        i > 0; i--, j += wElemSize) {
        *lpIndexArray++ = (WORD) j;
    }

    /* Do the sorting */
    if (IndexSort (lpCat->IndexArray, lpCat->lpCatBuf,
        cbElement) != S_OK)
        return E_FAIL;

    /* Update the current element to be the largest element.
       This will avoiding future sorting if this is the only time
       things get out of order (lpCat->fFlags CAT_SORTED will be
       set)
     */
    lpCat->dwCurElem = *(LPDW)(lpCat->lpCatBuf +
        lpCat->IndexArray[cbElement - 1]);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\index.h ===
/*************************************************************************
*                                                                        *
*  IINDEX.H                                                              *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
**************************************************************************/


/******************************************
 *          Internal sort stuff.
 ******************************************/
#ifdef _32BIT
#define MAX_BLOCK_SIZE  (DWORD)0x80000
#else
#define MAX_BLOCK_SIZE  (DWORD)0x0000FF00
#endif

typedef struct _list
{
    struct _list FAR * pNext;
} FAR *PLIST;

//  -   -   -   -   -   -   -   -   -

// Tree data types
typedef struct OCCDATA
{
    struct OCCDATA FAR *pNext;  // Linked-list chain
    DWORD  OccData[1];          // Array of n-DWORD
}   OCCDATA,
    FAR *POCCDATA;

typedef struct TOPICDATA
{
    struct TOPICDATA FAR *pNext;    // Linked-list chain               4
    DWORD dwOccCount;               // Count of occurrences in list    4
    DWORD dwTopicId;                  // TopicId for this topic            4
    POCCDATA pOccData;              // First OccData in list           4
    POCCDATA pLastOccData;          // Last inserted OccData           4
}   TOPICDATA,                      //                             =  20
    FAR *PTOPICDATA;

typedef struct STRDATA
{
    PTOPICDATA pTopic;      // First Topic in list               4
    PTOPICDATA pLastTopic;  // Last inserted Topic               4
    LPB   pText;            // Sort word as a Pascal string      4
    DWORD dwField;          // Field Id for the sort word        4
    DWORD dwTopicCount;     // Count of Topics in list           4
    DWORD dwWordLength;     // Word length (from OCC data)       4
}   STRDATA,                //                             =    24
    FAR *PSTRDATA;

typedef struct BTNODE 
{
    enum TREECOLOR {RED, BLACK} color;  // Color of node - for balancing 4
    struct BTNODE FAR *pParent;         // Pointer to parent node        4
    struct BTNODE FAR *pLeft;           // Pointer to left child node    4
    struct BTNODE FAR *pRight;          // Pointer to right child node   4
    STRDATA StringData;                 // Pointer to string data       24
}   BTNODE,                             //                      =       32
    FAR *PBTNODE;
    
    
typedef struct MERGEHEADER
{
    DWORD   dwRecordSize;
    LPB     lpbWord;                    // Pascal string
    DWORD   dwFieldId;                  // Field Id
    DWORD   dwWordLength;               // Real life word length
    DWORD   dwStrLen;                   // Current string length
    DWORD   dwTopicCount;               // Topic count
    DWORD   dwLastTopicId;                // Last topic id
    PTOPICDATA pTopic;                  // Pointer to first Topic in list
    PTOPICDATA pLastTopic;              // Last inserted Topic 
    FILEOFFSET foTopicCount;            // Backpatching address
    LPB     pTopicCount;                // Pointer to topic count location
    BYTE    fEmitRecord;                // Flag to denote rec is emitted
    BYTE    Pad1;                       // Padding for DWORD aligned
} MERGEHEADER, FAR *PMERGEHEADER;


//  Typedefs for an external sort buffer.  Each of these has associated
//  with it a large (easily > 1meg) block of sorted words.  A few of
//  these words will end up in an internal buffer.  These external sort
//  buffers will be formed into a chain, one chain will have associated
//  with it in total all of the words that are going to be sorted.  A
//  merge will be performed on the words associated with the chain to
//  produce a final sorted list of words.

typedef struct  InternalSortInfo 
{
    HFPB    hfpb;           // Handle to temp file
    PBTNODE pBalanceTree;   // Root node of the balanced tree
    FILEOFFSET lfo;         // File offset
    FILEOFFSET lfoRecBackPatch;  // Backpatching record offset
    DWORD   dwRecLength;    // Record (data associated with 1 word) length
    HANDLE  hSortBuffer;    // Handle to sort buffer
    BYTE FAR *pSortBuffer;    // Memory buffer for file output
    BYTE FAR *pStartRec;      // Record start point in the buffer
    BYTE FAR *pCurPtr;        // Current insertion point in the buffer
    DWORD   dwMaxEsbRecSize; // Maximum record size of current ESB
    BYTE    DeepLevel;      // Deepest level of the tree
    BYTE    Pad1;
    BYTE    Pad2;
    BYTE    Pad3;
    BYTE    aszTempName[_MAX_PATH]; // Temp file for tree flush, ericjut: change from cbMAX_PATH to _MAX_PATH
}   ISI,
    FAR *LPISI;

typedef HANDLE  HESB;

typedef struct ExternalSortBuffer 
{
    HANDLE  hStruct;     // This structure's handle. MUST BE 1ST!!
    struct  ExternalSortBuffer FAR *lpesbNext;    // Next buffer in the list.
    FILEOFFSET lfo;     // This starts out as an offset in the
                        // temp file at which the first word
                        // associated with this buffer will
                        // be found.  As words are disposed
                        // of it will increment.
    FILEOFFSET lfoMax;  // This is the offset of the end of
                        // the area of the temp file that
                        // contains words for this external
                        // sort buffer.
    DWORD   dwEsbSize;  // Actual size of the internal buffer.
    DWORD   ibBuf;      // Pointer to the current record in
                        //  the internal buffer.
    HANDLE  hMem;       // Handle to buffered block.
    LRGB    lrgbMem;    // Pointer to buffered block.
}  ESB, FAR *LPESB;


//  -   -   -   -   -   -   -   -   -

//  Information about the external sort process as a while.

typedef struct  ExternalSortInfo 
{
    FILEOFFSET lfoTempOffset;   // Current size of the output file
    HFPB    hfpb;           // Handle to ouput file
    LPFBI   lpfbiTemp;      // Temp file buffer 
    DWORD   cesb;           // Number of ESB blocks allocated
    LPESB   lpesbRoot;      // First buffer in the external-buffer linked-list
    DWORD   cbEsbBuf;       // The size of each ESB buffer.
    DWORD   uiQueueSize;    // Priority queue's size 
    GHANDLE hPriorityQueue;         // Handle to Priority Queue
    LPESB   FAR *lrgPriorityQueue;  // Priority Queue
    
    // Output buffer handling
    HANDLE  hBuf;           // Handle to output buiffer
    LPB     pOutputBuffer;  // Pointer to output buffer
    DWORD   ibBuf;          // Buffer index
    WORD    fFlag;          // Various flag
    WORD    pad;
    LPB     lpbQueueStr [cbMAX_PATH];
    BYTE    aszTempName[_MAX_PATH]; // Temp sorted result name
}   ESI,
    FAR *LPESI;


//  Information kept that pertains directly to "tfc" term-weighting.

typedef float   SIGMA;
typedef SIGMA   HUGE *HPSIGMA;
typedef SIGMA   HUGE *HRGSIGMA;

typedef DWORD   LISIGMA;

#define LASTWORD_SIZE   1024        // Size of last word buffer in each node

typedef struct BTREEDATA
{
    // Array of tree blocks
    PNODEINFO   rgpNodeInfo[MAX_TREE_HEIGHT];   // Array of tree nodes
    PNODEINFO   rgpTmpNodeInfo[MAX_TREE_HEIGHT];   // Array of tree nodes
    
    FILEOFFSET  OffsetPointer;  // File offset of the last nodes 
                                // pointer to the next node (for traversal)
    IH20        Header;
    DWORD       NID;            // Number of nodes allocated

    FLOAT       rLogN;          // Used for term-weighting
    FLOAT FAR   *lrgrLog;       // This will be an array of numbers that
                                // contains a common weighting sub-expression
    BYTE        argbLog[cLOG_MAX];  // An array of 8-bit flags.  If one of
                                    // these is non-zero the corresponding
                                    // value in lrgrLog is valid

    BYTE        fOccfLength;    // Word Length field flag
    BYTE        padding[3];     // Maintain DWORD alignment

} BTREEDATA, FAR *PBTREEDATA;
#define lisigmaMAX  ((LISIGMA)524288L)  // This value is arbitrary
                        //  but should not be allowed
                        //  to grow, if possible.

typedef struct  WeightInfo 
{
    HRGSIGMA    hrgsigma;   // Pointer to array of sigma elements.
    HANDLE      hSigma;     // Handle to "hrgsigma".
    FLOAT FAR  *lrgrLog;    // Array of LOG values to speed up processing
    HANDLE      hLog;       // Handle to "
}   WI;


typedef struct BLKCOMBO
{
    LPV    pBlockMgr;
    PLIST  pFreeList;
    DWORD  dwCount;
} BLKCOMBO, FAR *PBLKCOMBO;

typedef struct
{
    DWORD dwPhase;  // Current indexing phase
                    // 1: Collection phase
                    // 2: Sort and coalate phase
                    // 3: Permament index building phase
    DWORD dwIndex;  // Completion index
} CALLBACKINFO, FAR *PCALLBACKINFO;
//  -   -   -   -   -   -   -   -   -

//  Nerve information about the indexing process.  Most memory allocated
//  and files created are in some way attached to one of these.

typedef struct  IndexParamBlock 
{
    HANDLE  hStruct;            // This structure's handle. MUST BE 1ST
    DWORD  dwKey;               // Key for callback
    FCALLBACK_MSG CallbackInfo;     // User callback info
    
    //
    //  Miscellaneous.
    //
    WI    wi;                   // Term-weighting information.
    FILEOFFSET foMaxOffset;     // Maximum offset of the file (file size)
    
    // Useful information to be used
    DWORD lcTopics;             // The number of unique documents
    DWORD dwMaxTopicId;         // Use to hold compare value for lcTopics
    DWORD dwMemAllowed;         // Size of memory allocated for index
    DWORD dwMaxRecordSize;      // Maximum record size in collecting word
    DWORD dwMaxEsbRecSize;      // Current ESB maximum record size
    DWORD dwMaxWLen;            // Maximum word's length value
    DWORD dwLastIndexedTopic;   // For word collection
    HFREELIST hFreeList;        // Handle to the Index FreeList        
    //
    //  Callbacks.
    //
    FCOMPARE    lpfnCompare;    // Compare function for sort
    LPV         lpvSortParm;    // Sort parameters

    //  Sort information.
    //
    ISI     isi;                // Internal sort information.
    ESI     esi;                // External sort information.
 

    LPV     pDataBlock;         // Block manager for string
    BLKCOMBO BTNodeBlock;       // Block manager for btnode
    BLKCOMBO TopicBlock;        // Block manager for topic block
    BLKCOMBO OccBlock;          // Block manager for occurrence
    PLIST   pOccFreeList;       // Free list of occurrence nodes

    BTREEDATA BTreeData;        // BTree data info

    // Input/output file
    FILEDATA    InFile;         // File info for input file
    FILEDATA    OutFile;        // File info for output file    
    
    PNODEINFO pIndexDataNode;
    
    // Various buffer used for update
    HANDLE  hTmpBuf;            // Temp buf for word record
    LPB     pTmpBuf;
    LPB     pWord;              // Pointer to word record
    HFPB    hfpbIdxFile;
    
    HANDLE  hData;
    LPB     pDataBuffer;        // Buffer for new data
    DWORD   dwDataSize;         // Size of the buffer data
    
    DWORD   BitCount[7][33];    // Array to hold the bit count for bit 
                                // compression scheme.
                                // [0] = TopicID, [1] = OccCount, [2]-[6] = Occs
    
    // Statistics informations
    DWORD   dwIndexedWord;      // Total of indexed words (statistics)
    DWORD   dwUniqueWord;       // How many unique words indexed (statistics)
    DWORD   dwByteCount;        // How many bytes indexed (statistics)
    DWORD   dwOccOffbits;       // How many bits for offset (statistics)
    DWORD   dwOccExtbits;       // How many bits for extent (statistics)
    DWORD   dwMaxFieldId;       // Maximum field value
    DWORD   dwMaxWCount;        // Maximum word count value
    DWORD   dwMaxOffset;        // Maximum offset value
    DWORD   dwTotal3bWordLen;   // Total length of all words > 2 bytes
    DWORD   dwTotal2bWordLen;   // Total length of all words <= 2 bytes
    DWORD   dwTotalUniqueWordLen;  // Total length of all unique words
    
    CKEY    cKey[5];            // Compression keys (2-bytes * 5)
    
    // BYTE    ucNumOccFields;     // The number of bits set in "occf".
    WORD    idxf;                 // Index characteristic flags.
    WORD    occf;               // A flag byte that keeps track of
                                // which occurence element fields
                                // should be indexed.
    BYTE    ucNumOccDataFields; // The number of bits set that are saved in OCCDATA
    BYTE    fOccComp;             // Set to 1 if Occurrences need to be sorted
                                // in collect2.(They are added out of order)
    BYTE    cMaxLevel;
	BYTE    bState;
    BYTE    szEsiTemp[cbMAX_PATH];        // Temp ESI
}   IPB,
    FAR *_LPIPB;


// bState values

#define	INDEXING_STATE		0	// We are doing indexing
#define	UPDATING_STATE		1	// We are updating the index
#define	DELETING_STATE		2	// We are deleting data from teh index

//  -   -   -   -   -   -   -   -   -

//  These defines indicate how many bits per word occurence list are
//  wasted through the adoption of either the "fixed", "high bit
//  replacement" or "bitstream" compression schemes.  This wasted space
//  is wasted through the insertion of one or more flag bits into the
//  data-stream.

#define cbitWASTED_FIXED    (1 + CBIT_WIDTH_BITS)
                        // If the first bit is set, it means that the
                        //  "fixed" scheme was adopted, so the total
                        //  number of bits that was necessary to
                        //  indicate this was one.  More bits are
                        //  used to store the "width" value that is
                        //  associated with this scheme.  This has
                        //  been the most commonly used compression
                        //  scheme in practice.
#define cbitWASTED_BELL (2 + CBIT_WIDTH_BITS)
                        // If the first bit wasn't set, and the second
                        //  one was, it indicates that the "bell"
                        //  scheme was used.  The total wasted to
                        //  indicated this scheme was two bits, plus
                        //  the "width" value (the "center")
                        //  associated with this scheme.
#define cbitWASTED_BITSTREAM    (2)
                        // If neither the first bit nor the second bit
                        //  were set, the bitstream scheme was used.
                        //  The total wasted space was also two bits,
                        //  the same as for the "bell" scheme.  This
                        //  has been the least-used scheme in
                        //  practice.

#define lcbitBITSTREAM_ILLEGAL  ((DWORD)-1L)
                      // This value indicates that the function
                      //  is not allowed to select the "bitstream"
                      //  compression scheme.
                    
#define cbitCENTER_MAX      ((CBIT)33)
                      // Legal "center" values are 0..32.  This is
                      //  weird because you'd expect it to be
                      //  0..31 but it's not.

//  -   -   -   -   -   -   -   -   -

//  This structure is used in the occurence-list building phase of
//  indexing.  The structure includes information local to a single
//  occurence list.

typedef struct  OccurenceListInfo 
{
    DWORD   lcSublists; // The number of sub-lists in this
                     // occurence list.
    CKEY    ckey;       // The manner in which doc-ID deltas
                     // are compressed in this list.
}   OLI,
    FAR *LPOLI;

typedef struct MergeParams
{
	DWORD FAR *rgTopicId;
	DWORD dwCount;
	DWORD FAR *lpTopicIdLast;  // internal use, last position saved
} MERGEPARAMS, FAR *LPMERGEPARAMS;
//  -   -   -   -   -   -   -   -   -

//  Convert occurence list file to a final index file.

/*******************************************************************
 *                                                                 *
 *                      FUNCTIONS PROTOTYPES                       *
 *                                                                 *
 *******************************************************************/

/*********************************************************************
 *                                                                   *
 *                 SORT FUNCTIONS (SORT.C)                           *
 *                                                                   *
 *********************************************************************/

PUBLIC ERR PASCAL FAR HugeDataSort(LPV HUGE *, DWORD, FCOMPARE, LPV,
    INTERRUPT_FUNC, LPV);
PUBLIC VOID PASCAL FAR HugeInsertionSort (LPV HUGE *, DWORD, FCOMPARE, LPV);
PUBLIC ERR PASCAL FAR PriorityQueueRemove (LPESI, FCOMPARE, LPV);
PUBLIC ERR PASCAL FAR PriorityQueueCreate (LPESI, FCOMPARE, LPV);
PUBLIC ERR PASCAL NEAR IndexSort (LPW, LPB, int);
PUBLIC ERR PASCAL NEAR IndexMergeSort (HFILE FAR *, LSZ, LPW, LPB, int, int);

/*********************************************************************
 *                                                                   *
 *                 ENCODING FUNCTIONS (ENCODE.C)                     *
 *                                                                   *
 *********************************************************************/

PUBLIC CB PASCAL NEAR OccurrencePack (LPB, LPOCC, WORD);
PUBLIC VOID PASCAL NEAR OccurrenceUnpack(LPOCC, LPB, OCCF);
PUBLIC CB PASCAL NEAR CbCopySortPackedOcc (LPB, LPB, WORD);
PUBLIC CBIT PASCAL NEAR CbitBitsDw (DWORD);
PUBLIC void NEAR PASCAL VGetBestScheme(LPCKEY, LRGDW, DWORD, int);
PUBLIC CB PASCAL FAR CbBytePack(LPB, DWORD);

/*********************************************************************
 *                                                                   *
 *                      INDEXING FUNCTIONS                           *
 *                                                                   *
 *********************************************************************/

PUBLIC VOID PASCAL FAR FreeISI (LPIPB);
PUBLIC void NEAR PASCAL FreeEsi(LPIPB);
PUBLIC LCB FAR PASCAL LcbGetFreeMemory(LPERRB);
PUBLIC ERR FAR PASCAL SortFlushISI (_LPIPB);
PUBLIC int PASCAL FAR WordRecCompare(LPB, LPB, LPV);
PUBLIC  ERR FAR PASCAL MergeSortTreeFile (_LPIPB, LPMERGEPARAMS);
PUBLIC int FAR PASCAL CompareOccurrence (LPDW, LPDW, int);
PUBLIC int FAR PASCAL StrCmp2BytePascal (LPB, LPB);
ERR FAR PASCAL FlushTree(_LPIPB lpipb);
PUBLIC  ERR FAR PASCAL BuildBTree (HFPB, _LPIPB, LPB, HFPB, LPSTR);
PUBLIC ERR FAR PASCAL FWriteBits(PFILEDATA, DWORD, BYTE);
PUBLIC ERR PASCAL FAR IndexOpenRW (LPIPB, HFPB, LSZ);
PUBLIC PNODEINFO PASCAL FAR AllocBTreeNode (_LPIPB lpipb);
PUBLIC VOID PASCAL FAR FreeBTreeNode (PNODEINFO pNode);
PUBLIC ERR PASCAL FAR ReadNewNode (HFPB, PNODEINFO, int);
PUBLIC PNODEINFO PASCAL FAR AllocBTreeNode (_LPIPB lpipb);
PUBLIC ERR PASCAL FAR SkipOldData (_LPIPB, PNODEINFO);
PUBLIC ERR FAR PASCAL AllocSigmaTable (_LPIPB lpipb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\index3.c ===
#define VER3
/*************************************************************************
*                                                                        *
*  INDEX.C                                                               *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*  This is the second stage of the index building process.  After all    *
*  of the word have been add in stage 1, IndexBuild will be called.      *
*  IndexBuild starts the second stage.  We will merge-sort the temp file *
*  generated in phase 1 to create a second temp file to send to phase 3. * 
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
**************************************************************************/

#include <mvopsys.h>
#include <mem.h>
#include <memory.h>
#include <io.h>
#include <math.h>
#include <mvsearch.h>
#include <orkin.h>
#include "common.h"
#include "index.h"

#ifdef _DEBUG
static BYTE NEAR s_aszModule[] = __FILE__;	/* Used by error return functions.*/
#endif


#ifndef _32BIT
#define ESOUTPUT_BUFFER 0xFFFC  // Size of output file buffer
            // This must be at the size of the largest word + 12
            // or word + 14 if OCCF_LENGTH is set
#else
#define ESOUTPUT_BUFFER 0xFFFFC  // Size of output file buffer
            // This must be at the size of the largest word + 12
            // or word + 14 if OCCF_LENGTH is set
#endif

#define FLUSH_NEW_RECORD    1
#define FLUSH_EXCEPT_LAST   2

/*************************************************************************
 *
 *                    INTERNAL PRIVATE FUNCTIONS
 *
 *  All of them should be declared near
 *
 *************************************************************************/
PRIVATE HRESULT  NEAR PASCAL FillInputBuffer (LPESB, HFPB);
PRIVATE HRESULT  NEAR PASCAL ESFlushBuffer (LPESI);
PRIVATE HRESULT  NEAR PASCAL ESFillBuffer (_LPIPB, LPESB);
PRIVATE HRESULT  NEAR PASCAL ESMemory2Disk (_LPIPB, PMERGEHEADER, int);
PRIVATE HRESULT  NEAR PASCAL ProcessFiles (_LPIPB lpipb, LPMERGEPARAMS);
PRIVATE int  NEAR PASCAL CompareRecordBuffers (_LPIPB, LPB, LPB);
PRIVATE VOID NEAR PASCAL PQueueUp (_LPIPB, LPESB FAR *, LONG);
PRIVATE VOID NEAR PASCAL PQueueDown (_LPIPB);
PRIVATE PTOPICDATA PASCAL NEAR MergeTopicNode (PMERGEHEADER, PTOPICDATA, int);
PRIVATE VOID NEAR MergeOccurrence (PTOPICDATA, PTOPICDATA, int);
PRIVATE LPV PASCAL NEAR GetBlockNode (PBLKCOMBO lpBlockCombo);
PRIVATE VOID PASCAL NEAR SetQueue (LPESI pEsi);
PRIVATE HRESULT PASCAL NEAR ESBBlockAllocate (_LPIPB lpipb, DWORD lMemSize);
PRIVATE BOOL PASCAL LoadEsiTemp (_LPIPB lpipb, LPESI lpesi, LPB lpbEsiFile,
    LPB lpbIsiFile, PHRESULT phr);
PRIVATE VOID PASCAL NEAR SaveEsiTemp (LPIPB lpipb, LPESI lpesi);
PRIVATE VOID PASCAL NEAR UpdateEsiTemp (LPIPB lpipb);
PRIVATE BOOL PASCAL NEAR FindTopic(LPMERGEPARAMS lpmp, DWORD dwTopicId);

/*************************************************************************
 *
 *                    INTERNAL PUBLIC FUNCTIONS
 *
 *  All of them should be declared far, unless we know they belong to
 *  the same segment. They should be included in some include file
 *
 *************************************************************************/
PUBLIC HRESULT FAR PASCAL FlushTree(_LPIPB lpipb);
PUBLIC HRESULT FAR PASCAL MergeSortTreeFile (_LPIPB, LPMERGEPARAMS);
HRESULT FAR PASCAL AllocSigmaTable (_LPIPB lpipb);


/*************************************************************************
 *
 *  @doc    EXTERNAL API INDEX
 *
 *  @func   BOOL FAR PASCAL | MVIndexBuild |
 *      This function will build an index file based on the information
 *      collected in the Index parameter block.
 *
 *  @parm   HFPB | hSysFile |
 *      If it is non-null, it is the handle of an already opened system file.
 *      In this case the index is a subfile of the opened system file
 *      If it is 0, the index file is a regular DOS file
 *
 *  @parm   LPIPB | lpipb |
 *      Pointer to Index Parameter Block. This structure contains all the
 *      information necessary to build the index file
 *
 *  @parm   HFPB | hfpb |
 *      Index hfpb if pstrFile is NULL
 *
 *  @parm   LPSTR | pstrFile |
 *      Index filename if hfpb is NULL
 *
 *  @rdesc  S_OK, or other errors
 *
 *  @xref   MVIndexInitiate()
 *************************************************************************/
/*
 *      This operates in three main steps:
 *
 *      1.  Send finish to first phase to dump the buffer.  Then merge-sort
 *      that file into a temporary index.  Keep statistics on the information
 *      written to this temporary index.
 *
 *      2.  Analyze the statistics gathered during the temporary index
 *      building phase.  This analysis results in the choice of
 *      compression processes that will be used in the next step.
 *
 *      3.  Permanent index building phase.  During this phase, the
 *      temporary index is read, compressed like crazy, and written
 *      to a permanent index file.  Unlike the temporary index, the
 *      permanent index contains directory nodes as well as leaf
 *      nodes.
 *
 *************************************************************************/

PUBLIC  HRESULT EXPORT_API FAR PASCAL MVIndexBuild (HFPB hSysFile,
    _LPIPB lpipb, HFPB hfpb, LPSTR pstrFile)
{
    ERRB    errb;
    PHRESULT  phr = &errb;
    BYTE    bKeyIndex = CKEY_OCC_BASE;  // Index into cKey array for compression
    HRESULT     fRet;           // Return value from this function.
    DWORD   loop;

	// Sanity check 
	if (lpipb == NULL || (NULL == hfpb && NULL == pstrFile))
		return E_INVALIDARG;

    // Flush the internal sort
    // Flushes any records in the tree to disk
    fRet = FlushTree(lpipb);

    // Free all memory blocks
    FreeISI (lpipb);
    
    if (fRet != S_OK)
        return(fRet);
        
    // lpipb->lcTopics++;      // Adjust to base-1 from base-0
    
    if (lpipb->esi.cesb == 0) 
        // Nothing to process, there will be no index file
        return S_OK;

    if (lpipb->idxf & KEEP_TEMP_FILE)
        SaveEsiTemp (lpipb, &lpipb->esi);

    // If we're doing term-weighting, set up a huge array to contain the
    // sigma terms.  The size of the array depends on the total # of topics
    // We also create an array of LOG values to save calculations later
    if (lpipb->idxf & IDXF_NORMALIZE)
    {
        if ((fRet = AllocSigmaTable (lpipb)) != S_OK)
            return(fRet);
    }

    if ((fRet = MergeSortTreeFile (lpipb, NULL)) != S_OK)
        return SetErrCode (phr, fRet);
    if ((lpipb->idxf & KEEP_TEMP_FILE) == 0)
    	FileUnlink (NULL, lpipb->isi.aszTempName, REGULAR_FILE);

    // If we are doing term-weighting we have to square root all sigma values
    if (lpipb->idxf & IDXF_NORMALIZE)
    {
		// ISBU_IR_CHANGE not needed here 'cos computing sqrt is necessary in both cases
        for (loop = 0; loop < lpipb->dwMaxTopicId + 1; ++loop)
            lpipb->wi.hrgsigma[loop] = 
                (float)sqrt ((double)lpipb->wi.hrgsigma[loop]);
    }

    // Analyze data to get the best compression scheme
    // TopicId

	 // Note: We can't use fixed field compression for topic, since they
	 // can be modified by update. A fixed field format may become
	 // insufficient to store larger values of topic differences

    VGetBestScheme(&lpipb->cKey[CKEY_TOPIC_ID], 
        &lpipb->BitCount[CKEY_TOPIC_ID][0], lcbitBITSTREAM_ILLEGAL, TRUE);

    // Occurrence Count
    VGetBestScheme(&lpipb->cKey[CKEY_OCC_COUNT], 
        &lpipb->BitCount[CKEY_OCC_COUNT][0], lcbitBITSTREAM_ILLEGAL, TRUE);

    if (lpipb->occf & OCCF_COUNT)
    {
        VGetBestScheme(&lpipb->cKey[bKeyIndex],
            &lpipb->BitCount[bKeyIndex][0], lcbitBITSTREAM_ILLEGAL, TRUE);
        bKeyIndex++;
    }

    if (lpipb->occf & OCCF_OFFSET)
    {
        VGetBestScheme(&lpipb->cKey[bKeyIndex],
            &lpipb->BitCount[bKeyIndex][0], lcbitBITSTREAM_ILLEGAL, TRUE);
        bKeyIndex++;
    }

    if (lpipb->idxf & KEEP_TEMP_FILE)
        UpdateEsiTemp (lpipb);
    
    // Build the permanent index    
    fRet = BuildBTree(hSysFile, lpipb, lpipb->esi.aszTempName, hfpb, pstrFile);
    if (lpipb->idxf & IDXF_NORMALIZE)
    {
        FreeHandle (lpipb->wi.hSigma);
        FreeHandle (lpipb->wi.hLog);
    }
    return fRet;
}


/*************************************************************************
 *
 *  @doc    INDEX
 *
 *  @func   HRESULT NEAR PASCAL | FillInputBuffer |
 *      Fills the buffer by reading from the specified file.
 *
 *  @parm   PESB | pEsb |
 *      Pointer to external sort block to fill
 *
 *  @parm   HFPB | hFile |
 *      Handle to the input file
 *
 *  @rdesc  S_OK, or errors if failed
 *
 *************************************************************************/

HRESULT NEAR PASCAL FillInputBuffer(LPESB pEsb, HFPB hFile)
{
    ERRB errb;
    DWORD dwBytesRead;

    // Read in data
    if ((dwBytesRead = FileSeekRead (hFile, 
        (LPB)pEsb->lrgbMem, pEsb->lfo, pEsb->dwEsbSize, &errb)) == 0)
        return errb;
    
    // Update utility variables
    pEsb->lfo = FoAddDw(pEsb->lfo, dwBytesRead);
    pEsb->dwEsbSize = (CB)dwBytesRead;
    pEsb->ibBuf = 0;
    return S_OK;
}


/*************************************************************************
 *
 *  @doc    INDEX
 *
 *  @func   HRESULT NEAR PASCAL | ESFlushBuffer |
 *      Flushes the output buffer to disk and resets it.
 *
 *  @parm   LPESI | pEsi |
 *      Pointer to ESI block
 *
 *  @rdesc  S_OK, or errors if failed
 *
 *************************************************************************/

HRESULT NEAR PASCAL ESFlushBuffer(LPESI pEsi)
{
    ERRB errb;
    DWORD dwLen;

    dwLen = pEsi->ibBuf;
    if (dwLen != (DWORD)FileWrite (pEsi->hfpb, pEsi->pOutputBuffer,
        dwLen, &errb))
        return errb;

    pEsi->lfoTempOffset = FoAddDw (pEsi->lfoTempOffset, dwLen);
    pEsi->ibBuf = 0;
    return S_OK;
}


/*************************************************************************
 *
 *  @doc    INDEX
 *
 *  @func   HRESULT NEAR PASCAL | ESFillBuffer |
 *      Updates the input buffer with new data from the input file.
 *
 *  @parm   _LPIPB | lpipb |
 *      Pointer to index parameter block
 *
 *  @parm   LPESB | pEsb |
 *      Pointer to ESB block to be filled
 *
 *  @rdesc  S_OK, or other errors
 *************************************************************************/

HRESULT NEAR PASCAL ESFillBuffer(_LPIPB lpipb, LPESB pEsb) 
{
    DWORD dwBytesRead;
    DWORD dwExtra = pEsb->dwEsbSize - pEsb->ibBuf;
    ERRB  errb;

    // Read either the entire buffer size or whatever is left
    dwBytesRead = DwSubFo (pEsb->lfoMax, pEsb->lfo);
    
    if (dwBytesRead > pEsb->dwEsbSize - dwExtra)
        dwBytesRead = pEsb->dwEsbSize - dwExtra;

    // Save unproccessed information to beginning of buffer
    if (dwExtra)
        MEMMOVE ((LPB)pEsb->lrgbMem, pEsb->lrgbMem + pEsb->ibBuf, dwExtra);

    // Read in the new data
    if ((dwBytesRead = FileSeekRead (lpipb->isi.hfpb, (LPB)(pEsb->lrgbMem +
        dwExtra), pEsb->lfo, dwBytesRead, &errb)) == 0 &&
        errb != S_OK)
        return(errb);
        
    pEsb->lfo = FoAddDw(pEsb->lfo, dwBytesRead);
    pEsb->ibBuf = 0;
    pEsb->dwEsbSize = dwBytesRead + dwExtra;
    return(S_OK);
    
}


/*************************************************************************
 *
 *  @doc  INTERNAL INDEXING
 *
 *  @func HRESULT FAR PASCAL | MergeSortTree File |
 *    Sorts the file generated from the tree output into one
 *      list of sorted elements.
 *
 *  @parm _LPIPB | lpipb |
 *    Pointer to index parameter block
 *
 *************************************************************************/

PUBLIC HRESULT PASCAL FAR MergeSortTreeFile (_LPIPB lpipb, LPMERGEPARAMS lpmp)
{
    // Local replacement variables
    LPESI   pEsi;                       // Pointer to external sort info
    LPISI   pIsi;                       // Pointer to internal sort info
    HFPB    hInputFile;                 // Handle to input file
    ERRB     errb;
    PHRESULT   phr = &errb;
    DWORD   cesb;                       // Input buffer count
    LPESB   FAR* lrgPriorityQueue;      // Pointer to Priority Queue
    WORD    uiQueueSize = 0;            // Count of entries in Queue
    DWORD   dwBufferSize;

    // Working variables 
    HRESULT     fRet;
    LPESB   pEsb;       // Temp pointer to linked list

    // Sanity check
    if (lpipb == NULL)
        return E_INVALIDARG;

    // Variables initialization        
    pEsi = &lpipb->esi;         // Pointer to external sort info
    pIsi = &lpipb->isi;         // Pointer to internal sort info
    cesb = pEsi->cesb;          // Input buffer count
    
    // Open input file
    if ((pIsi->hfpb = FileOpen (NULL, pIsi->aszTempName,
        REGULAR_FILE, READ, phr)) == NULL)
        return *phr;
        
    hInputFile = pIsi->hfpb;

    // Allocate & fill input buffers
    for (pEsb = pEsi->lpesbRoot; pEsb != NULL; pEsb = pEsb->lpesbNext)
    {
        DWORD cbRead;

        dwBufferSize = (lpipb->dwMemAllowed * 6) / (8 * pEsi->cesb);
        
        // Alocate buffer space
        if ((pEsb->hMem = _GLOBALALLOC (DLLGMEM_ZEROINIT,
            dwBufferSize)) == NULL)
        {
            fRet = E_OUTOFMEMORY;
exit1:
            FreeEsi (lpipb);
            FileClose(hInputFile);
            pIsi->hfpb = NULL;
            return fRet;
        }
        pEsb->lrgbMem = (LRGB)_GLOBALLOCK (pEsb->hMem);

        if ((cbRead = DwSubFo(pEsb->lfoMax, pEsb->lfo)) > dwBufferSize)
            cbRead = dwBufferSize;

        // Fill buffer from disk
        if (FileSeekRead (hInputFile, pEsb->lrgbMem, pEsb->lfo, 
            cbRead, phr) != (LONG)cbRead)
        {
            fRet = *phr;
            _GLOBALUNLOCK(pEsb->hMem);
            _GLOBALFREE(pEsb->hMem);
            pEsb->hMem = NULL;
            goto exit1;
        }
        
        pEsb->dwEsbSize = cbRead;
        pEsb->ibBuf = 0;
        pEsb->lfo = FoAddDw (pEsb->lfo, cbRead);
    }

    // Allocate a priority queue array. The size of the array
    // is the number of external sort info blocks plus 1, since
    // location 0 is not used.
    if ((pEsi->hPriorityQueue = _GLOBALALLOC (DLLGMEM_ZEROINIT,
        (DWORD)(pEsi->cesb + 1) * sizeof (LPB))) == NULL) 
    {
        fRet = E_OUTOFMEMORY;
        goto exit1;
    }
    pEsi->lrgPriorityQueue = 
        (LPESB FAR *)_GLOBALLOCK (pEsi->hPriorityQueue);
    lrgPriorityQueue = pEsi->lrgPriorityQueue;

    // Attach input buffers to Priority Queue
    // Remebering to start at offset 1 NOT 0 (PQ's have a null 0 element)
    for (pEsb = pEsi->lpesbRoot; pEsb != NULL; pEsb = pEsb->lpesbNext)
    {
        lrgPriorityQueue[++uiQueueSize] = pEsb;
        PQueueUp (lpipb, lrgPriorityQueue, uiQueueSize);
    }
    pEsi->uiQueueSize = uiQueueSize;

    // Clear largest Record Size field
    // lpipb->dwMaxRecordSize = 0;

    fRet = ProcessFiles(lpipb, lpmp);
    _GLOBALUNLOCK (pEsi->hPriorityQueue);
    _GLOBALFREE (pEsi->hPriorityQueue);
    pEsi->hPriorityQueue = NULL;
    goto exit1;
}


/*************************************************************************
 *
 *  @doc    INDEX
 *
 *  @func   HRESULT NEAR PASCAL | ESMemory2Disk |
 *      Copies temp record to output buffer.
 *
 *  @parm   _LPIPB | lpipb |
 *      Pointer to index parameter block
 *
 *  @parm   PMERGEHEADER | pHeader |
 *      Pointer to header to flush
 *
 *  @parm   int | flag |
 *      - if FLUSH_NEW_RECORD, the flush is due to new record, we flush
 *        everything, else we may do a partial flush only
 *      - if FLUSH_EXCEPT_LAST, we don't flush the last topic
 *
 *  @rdesc  S_OK, or other errors
 *************************************************************************/
PRIVATE HRESULT NEAR PASCAL ESMemory2Disk
    (_LPIPB lpipb, PMERGEHEADER pHeader, int flag)
{
    // Local replacement variables
    LPESI   pEsi        = &lpipb->esi;
    LPB     pMax = pEsi->pOutputBuffer + ESOUTPUT_BUFFER - 2 * sizeof(DWORD);
    DWORD   dwOccCount;
    LPB     pOutputBuffer = pEsi->pOutputBuffer;
    ERRB     errb;
    PHRESULT   phr = &errb;
    HRESULT     fRet;
    BYTE    cNumOcc;
    OCCF    occf;

    // Working variables
    PTOPICDATA pTopic;          // Temp var to traverse the topic linked list
    DWORD   loop, sub;          // Various loop counters
    DWORD   dwTopicIdDelta;
    DWORD   OccDelta[5];        // Delta base for all occurrence data
    DWORD   LastOcc[5];
    FLOAT   rLog;               // (1/n)    - IDXF_NORMALIZE is set
    FLOAT   rLogSquared;        // (1/n)^2  - IDXF_NORMALIZE is set
    LPB     pStart;
    LPB     pCurPtr;

    // Set up pointers    
    pStart = pCurPtr = pOutputBuffer + pEsi->ibBuf;
        
    // Variable replacement
    occf = lpipb->occf;
    
    // Size of string
    loop = pHeader->dwStrLen;
    
    // Make sure the string, FileId, Topic Count and Record Size fit
    // We add in and extra DWORD for 5 byte compresssion problems and
    // to cover the Word Length if there is one.
    if ((pStart + loop + sizeof (DWORD) * 5) >= pMax)
    {
        if ((fRet = ESFlushBuffer (pEsi)) != S_OK)
            return(fRet);
            
        pStart = pCurPtr = pOutputBuffer;
    }

    if (pHeader->fEmitRecord == FALSE)
    {
        // If we never emitted the record header then we emitted now
        // Reset the flag
        pHeader->fEmitRecord = TRUE;
        
        // Skip record size field
        pCurPtr += sizeof (DWORD);

        // Pascal string
        MEMCPY (pCurPtr, pHeader->lpbWord, loop);
        pCurPtr += loop;

        // Word Length
        if (occf & OCCF_LENGTH)
            pCurPtr += CbBytePack (pCurPtr, pHeader->dwWordLength);

        // FieldId
        if (occf & OCCF_FIELDID)
            pCurPtr += CbBytePack (pCurPtr, pHeader->dwFieldId);

        // Topic Count
        if (flag & FLUSH_NEW_RECORD)
        {
            // This is the whole record. dwTopicCount value is correct
            SETLONG((LPUL)pCurPtr, pHeader->dwTopicCount);
        }
        else
        {
            // Save the offset for backpatching
            pHeader->foTopicCount = FoAddDw (pEsi->lfoTempOffset,
                (DWORD)(pCurPtr - pOutputBuffer));
            pHeader->pTopicCount = pCurPtr;
        }
        pCurPtr += sizeof(DWORD);

        // Write Record Length
        *(LPUL)pStart = (DWORD)(pCurPtr - pStart - sizeof (DWORD));

    }
    else if (flag & FLUSH_NEW_RECORD)
    {
        // We emit the record before, since pheader->fEmitRecord == TRUE
        // We need to backpatch the topic count
        if (FoCompare(pHeader->foTopicCount, pEsi->lfoTempOffset) >= 0)
        {
            // Everything is still in memory, just do local backpatch
            SETLONG((LPUL)(pHeader->pTopicCount), pHeader->dwTopicCount);
        }
        else
        {
            // Do backpatch in the file by seeking back to the right
            // place
            if (FileSeekWrite(pEsi->hfpb, &pHeader->dwTopicCount,
                pHeader->foTopicCount, sizeof(DWORD), phr) != sizeof(DWORD))
                return(*phr);
            
            // Restore the current file offset
            FileSeek(pEsi->hfpb, pEsi->lfoTempOffset, 0, phr);
        }
    }
    
    // Convert all occ data to delta values & compress them
    pTopic = pHeader->pTopic;
    cNumOcc = lpipb->ucNumOccDataFields;
    
    for (; pTopic;)
    {
        POCCDATA pOccData;
        PTOPICDATA pReleased;
        
        if ((flag & FLUSH_EXCEPT_LAST) && pTopic->pNext == NULL)
            break;
        
        // Set TopicId delta
        dwTopicIdDelta = pTopic->dwTopicId - pHeader->dwLastTopicId;
        pHeader->dwLastTopicId = pTopic->dwTopicId;

        // Save bit size to the statistics array
        lpipb->BitCount[CKEY_TOPIC_ID][CbitBitsDw (dwTopicIdDelta)] += 1;

        // Write TopicID Delta
        if (pCurPtr > pMax)
        {
            pEsi->ibBuf = (DWORD)(pCurPtr - pOutputBuffer);
            if ((fRet = ESFlushBuffer (pEsi)) != S_OK)
                return(fRet);
            pCurPtr = pOutputBuffer;
        }
        pCurPtr += CbBytePack (pCurPtr, dwTopicIdDelta);

        if (cNumOcc == 0)
        {
            pReleased = pTopic;
            pTopic = pTopic->pNext;
        
            // Add the released to the freed linked list
            pReleased->pNext = (PTOPICDATA)lpipb->TopicBlock.pFreeList;
            lpipb->TopicBlock.pFreeList = (PLIST)pReleased;
            lpipb->TopicBlock.dwCount--;
            continue;
        }
            
        if (dwOccCount = pTopic->dwOccCount)
        {
            
            // Reset count occdata delta for every new topic
            MEMSET (OccDelta, 0, 5 * sizeof (DWORD));
            MEMSET (LastOcc, 0, 5 * sizeof (DWORD));

            // Copy Occurrence Count
            if (pCurPtr > pMax)
            {
                pEsi->ibBuf = (DWORD)(pCurPtr - pOutputBuffer);
                if ((fRet = ESFlushBuffer (pEsi)) != S_OK)
                    return(fRet);
                pCurPtr = pOutputBuffer;
            }
            pCurPtr += CbBytePack (pCurPtr, dwOccCount);

            // Save bit size to the statistics array
            lpipb->BitCount[1][CbitBitsDw (dwOccCount)] += 1;

            // Repeat for each occurrence block
            for (pOccData = pTopic->pOccData,
                sub = dwOccCount; sub > 0 && pOccData; --sub)
            {
                LPDW lpDw;
                int  iIndex;
                POCCDATA pReleased;
                
                if (pCurPtr + 5 * sizeof(DWORD) > pMax)
                {
                    pEsi->ibBuf = (DWORD)(pCurPtr - pOutputBuffer);
                    if ((fRet = ESFlushBuffer (pEsi)) != S_OK)
                        return(fRet);
                    pStart = pCurPtr = pOutputBuffer;
                }
                
                lpDw = &pOccData->OccData[0];
                iIndex = CKEY_OCC_BASE;
                
                if (occf & OCCF_COUNT)
                {
                    // Convert each value to a delta value
                    OccDelta[iIndex] = *lpDw - LastOcc[iIndex];
                    LastOcc[iIndex] = *lpDw;
                    lpDw++;
                    
                    // Save to bit size to the statistics array
                    lpipb->BitCount[iIndex][CbitBitsDw (OccDelta[iIndex])] += 1;
                    
                    // Compress occurrence field to buffer
                    pCurPtr += CbBytePack (pCurPtr, OccDelta[iIndex]);
                    iIndex++;
                }
                
                if (occf & OCCF_OFFSET)
                {
                    // Convert each value to a delta value
                    OccDelta[iIndex] = *lpDw - LastOcc[iIndex];
                    LastOcc[iIndex] = *lpDw;
                    lpDw++;
                    
                    // Save to bit size to the statistics array
                    lpipb->BitCount[iIndex][CbitBitsDw (OccDelta[iIndex])] += 1;
                    
                    // Compress occurrence field to buffer
                    pCurPtr += CbBytePack (pCurPtr, OccDelta[iIndex]);
                    iIndex++;
                }
                
                pReleased = pOccData;
                pOccData = pOccData->pNext;
                pReleased->pNext = (POCCDATA)lpipb->OccBlock.pFreeList;
                lpipb->OccBlock.pFreeList = (PLIST)pReleased;
                lpipb->OccBlock.dwCount--;
            }
            
            // Check for mismatch between count and links
#ifdef _DEBUG
            if (sub)
                SetErrCode (phr, E_ASSERT);

            if (pOccData)
                SetErrCode (phr, E_ASSERT);
#endif
        }

        // Update the sigma values if we are doing term weighing
        // erinfox: remove test against flag. Sometimes sigma never
        // got calculated for a topic and that caused a divide by zero
        // later on.
        if ((lpipb->idxf & IDXF_NORMALIZE) /* && (flag & FLUSH_NEW_RECORD)*/)
        {
            
            if (pTopic->dwTopicId > lpipb->dwMaxTopicId)    
            {
                // Incease the size of the sigma table. This can happen when
                // updating with new topics
                _GLOBALUNLOCK (lpipb->wi.hSigma);
                if ((lpipb->wi.hSigma = _GLOBALREALLOC (lpipb->wi.hSigma,
                    (pTopic->dwTopicId + 1) * sizeof(float),
                    DLLGMEM_ZEROINIT)) == NULL)
                {
                    return (SetErrCode(phr, E_OUTOFMEMORY));
                }
                lpipb->wi.hrgsigma = (HRGSIGMA)_GLOBALLOCK(lpipb->wi.hSigma);
                lpipb->dwMaxTopicId =  pTopic->dwTopicId ;
            }
            
			if (lpipb->bState == INDEXING_STATE)
			{
#ifndef ISBU_IR_CHANGE
				FLOAT fOcc;

				if (pHeader->dwTopicCount >= cLOG_MAX)
				{
					// we have to guard against the possibility of the log resulting in 
					// a value <= 0.0. Very rare, but possible in the future. This happens
					// if dwTopicCount approaches or exceeds the N we are using (N == 100 million)
					if (pHeader->dwTopicCount >= cNintyFiveMillion)
						rLog = cVerySmallWt;	// log10(100 mil/ 95 mil) == 0.02
					else
						//rLog = (float) log10(cHundredMillion/(double)pHeader->dwTopicCount);
						rLog = (float) (8.0 - log10((double)pHeader->dwTopicCount));

					rLogSquared = rLog*rLog;
				}
				else
					rLogSquared = lpipb->wi.lrgrLog[(WORD)pHeader->dwTopicCount];

				// Update sigma value
				// NOTE : We are bounding dwOccCount by a value of eTFThreshold
				// The RHS of the equation below has an upperbound of 2 power 30.
				fOcc = (float) min(cTFThreshold, dwOccCount);
				lpipb->wi.hrgsigma[pTopic->dwTopicId] += (SIGMA) fOcc*fOcc*rLogSquared;
					//(SIGMA) (fOcc * fOcc * rLogSquared/(float)0xFFFF);
#else
				// Failed for update : UNDONE
				if (pHeader->dwTopicCount >= cLOG_MAX)
				{
					rLog =  (float)1.0 / (float)pHeader->dwTopicCount;
					rLogSquared = rLog * rLog;
				}
				else
					rLogSquared = lpipb->wi.lrgrLog[(WORD)pHeader->dwTopicCount];
				// Update sigma value
				lpipb->wi.hrgsigma[pTopic->dwTopicId] +=
					(SIGMA)(dwOccCount * dwOccCount) * rLogSquared;
#endif // ISBU_IR_CHANGE
			}
        }
        pReleased = pTopic;
        pTopic = pTopic->pNext;
        
        // Add the released to the freed linked list
        pReleased->pNext = (PTOPICDATA)lpipb->TopicBlock.pFreeList;
        lpipb->TopicBlock.pFreeList = (PLIST)pReleased;
        lpipb->TopicBlock.dwCount--;
    }

    pHeader->pTopic = pHeader->pLastTopic = pTopic;
    
    // Update output offset
    pEsi->ibBuf = (DWORD)(pCurPtr - pOutputBuffer);
    
    return(S_OK);
    
}


/*************************************************************************
 *
 *  @doc    INDEX
 *
 *  @func   HRESULT NEAR PASCAL | ProcessFiles |
 *      Sorts the file generated from the tree output into one
 *      list of sorted elements.
 *
 *  @parm   _LPIPB | lpipb |
 *      Pointer to index parameter block
 *
 *  @rdesc  S_OK, or errors if failed
 *
 *  @notes
 *      This function processed the input buffers and uses dynamic
 *      memory allocation to sort each word as it come in.  Once a
 *      word stops repeating, it is flush to disk and the memory is
 *      reset for the next word.
 *************************************************************************/

HRESULT NEAR PASCAL ProcessFiles(_LPIPB lpipb, LPMERGEPARAMS lpmp)
{
    // Local replacement variables
    LPISI pIsi = &lpipb->isi;
    LPESI pEsi = &lpipb->esi;
    LPESB FAR * lrgPriorityQueue = pEsi->lrgPriorityQueue;
    LONG    uiQueueSize = pEsi->uiQueueSize;
    LPB     pQueuePtr;
    WORD    cNumOcc = lpipb->ucNumOccDataFields;
    WORD    OccSize = sizeof(OCCDATA) - sizeof(DWORD) + cNumOcc *
            sizeof(DWORD);
    int     occf = lpipb->occf;
    LPB     pBufMax;
    HANDLE  hWord;
    LPB     lpbWord;
    DWORD dwUniqueTerm = 0;  // Used for calback function
#ifdef _DEBUG
    BYTE    astWord[300];
    BYTE    astLastWord[300];
#endif

    // Working variables
    PMERGEHEADER pHeader;               // Pointer to merge header
    LPESB   pEsb;                       // Temp ESB pointer
    PTOPICDATA pNewTopic;               // Used to create new topic
    DWORD   loop;                       // Temp loop counter
    HANDLE  hHeader;
    HFPB    hOutputFile;                // Handle to output file
    int     fRet;                       // Return value
    USHORT  uStringSize;                // Size of Psacal String
    ERRB     errb;
    PHRESULT   phr = &errb;

    static  long Count = 0;

    // Setup Block Manager
    if ((fRet = ESBBlockAllocate (lpipb, lpipb->dwMemAllowed / 4)) != S_OK)
        return(fRet);
        
    // Allocate output buffer
    if ((pEsi->hBuf = _GLOBALALLOC
        (DLLGMEM_ZEROINIT, ESOUTPUT_BUFFER)) == NULL)
    {
        fRet = E_OUTOFMEMORY;
exit1:
        return fRet;
    }
    
    pEsi->pOutputBuffer = (LPB)_GLOBALLOCK (pEsi->hBuf);
    pEsi->ibBuf = 0;

    // Create output file
    GETTEMPFILENAME ((char)0, "eso", 0, pEsi->aszTempName);
    
    if ((pEsi->hfpb = FileOpen(NULL, pEsi->aszTempName, 
        REGULAR_FILE, WRITE, &errb)) == NULL)
    {
        fRet = E_FILECREATE;
exit2:
        FreeHandle (pEsi->hBuf);
        pEsi->hBuf = NULL;
        goto exit1;
    }                                     
    hOutputFile = pEsi->hfpb;

    // Setup new record in memory
    if ((hHeader = _GLOBALALLOC 
        (DLLGMEM_ZEROINIT, sizeof (MERGEHEADER))) == NULL)
    {
        fRet = E_OUTOFMEMORY;
exit3:
        FileClose (hOutputFile);
        goto exit2;
    }
    pHeader = (PMERGEHEADER)_GLOBALLOCK (hHeader);
    
    // Allocate buffer for a word, which include 64K + sizeof(WORD) + slack
    if ((hWord = _GLOBALALLOC(DLLGMEM_ZEROINIT, 0x10004)) == NULL)
    {
exit4:
        _GLOBALUNLOCK(hHeader);
        _GLOBALFREE (hHeader);
        goto exit3;
    }
        
    pHeader->lpbWord = lpbWord = (LPB)_GLOBALLOCK(hWord);

#ifdef _DEBUG
    astWord[0] = 0;
#endif

    // Process all input buffers
    do
    {
        DWORD dwWordLength;
        DWORD dwFieldId;
        LPB  lpStart;
        DWORD dwTopicCount;

#ifdef _DEBUG
        Count++;
#endif

        // Grab smallest record and send to buffer
        pEsb = lrgPriorityQueue[1];
        
        // Set the fill limit
        pBufMax = pEsb->lrgbMem + pEsb->dwEsbSize - 256;
        
        if ((pQueuePtr = pEsb->lrgbMem + pEsb->ibBuf) >= pBufMax)
    	{
        	if ((fRet = ESFillBuffer (lpipb, pEsb)) != S_OK)
                goto exit4;
                
        	pQueuePtr = pEsb->lrgbMem;
    	}

        // Save the record beginning
        pQueuePtr += sizeof(DWORD);
        lpStart = pQueuePtr;
        
        // Get string
        uStringSize = GETWORD ((LPUW)pQueuePtr) + sizeof (SHORT);

        pQueuePtr += uStringSize;
#ifdef _DEBUG
        if (pQueuePtr > pEsb->lrgbMem + pEsb->dwEsbSize)
            SetErrCode (phr, E_ASSERT);
#endif

        if (occf & OCCF_LENGTH)
            pQueuePtr += CbByteUnpack (&dwWordLength, pQueuePtr);
        else
            dwWordLength = 0;
            
#ifdef _DEBUG
        if (pQueuePtr >= pEsb->lrgbMem + pEsb->dwEsbSize)
            SetErrCode (phr, E_ASSERT);
#endif
        if (occf & OCCF_FIELDID)
            pQueuePtr += CbByteUnpack (&dwFieldId, pQueuePtr);
        else
            dwFieldId = 0;
            
#ifdef _DEBUG
        if (pQueuePtr > pEsb->lrgbMem + pEsb->dwEsbSize)
            SetErrCode (phr, E_ASSERT);
#endif
        // Is the word in the buffer equal to the new word?
        // If it is not then flush the old word
        if (*(LPUW)pHeader->lpbWord)
        {
            fRet = (StrCmp2BytePascal (pHeader->lpbWord, lpStart)
                || dwWordLength > pHeader->dwWordLength);
            if (fRet == 0)  // Same word, reduce the unique words count
                lpipb->dwUniqueWord--;
            if (fRet || dwFieldId > pHeader->dwFieldId)
            {
#if defined(_DEBUG) && !defined(_MAC)
                // Word out of order
                if (StrCmp2BytePascal (pHeader->lpbWord, lpStart) > 0)
                    assert(FALSE);
#endif
                if ((fRet = ESMemory2Disk (lpipb, pHeader, TRUE)) != S_OK)
                    return(fRet);

                // Reset pHeader
                MEMSET (pHeader, 0, sizeof (MERGEHEADER));

                // Set the word buffer
                pHeader->lpbWord = lpbWord;
#ifdef _DEBUG
                STRCPY(astLastWord, astWord);
#endif
                // Call the user callback every once in a while
                if (!(++dwUniqueTerm % 8192L)
                    && (lpipb->CallbackInfo.dwFlags & ERRFLAG_STATUS))
                {
                    PFCALLBACK_MSG pCallbackInfo = &lpipb->CallbackInfo;
                    CALLBACKINFO Info;

                    Info.dwPhase = 2;
                    Info.dwIndex = (DWORD)((float)dwUniqueTerm / lpipb->dwUniqueWord * 100);
                    fRet = (*pCallbackInfo->MessageFunc)
                        (ERRFLAG_STATUS, pCallbackInfo->pUserData, &Info);
                    if (S_OK != fRet)
                        goto exit5;
                }
            }
        }

        // Update the data
        pHeader->dwFieldId = dwFieldId;
        pHeader->dwWordLength = dwWordLength;
        pHeader->dwStrLen = uStringSize;
            
        // Copy word and header info
        MEMCPY (pHeader->lpbWord, (LPB)lpStart, uStringSize);
#ifdef _DEBUG
        if (uStringSize >= 300)
            uStringSize = 300;
        MEMCPY (astWord, lpStart + 2, uStringSize - 2);
        astWord[uStringSize - 2] = 0;
        //if (STRCMP(astWord, "87db") == 0)
        //   _asm int 3;
#endif

        pQueuePtr += CbByteUnpack (&dwTopicCount, pQueuePtr);
        pHeader->dwTopicCount += dwTopicCount;

#ifdef _DEBUG
        if (pQueuePtr > pEsb->lrgbMem + pEsb->dwEsbSize)
            SetErrCode (phr, E_ASSERT);
#endif
        pNewTopic = NULL;
                
        // Copy topic(s) to memory
        for (loop = dwTopicCount; loop > 0; loop--)
        {
			DWORD dwTopicId;

            // Get the topic id
            pQueuePtr += CbByteUnpack (&dwTopicId, pQueuePtr);

			// kevynct: if there is a to-delete list, and this topic is on it, skip it
			if (lpmp && FindTopic(lpmp, dwTopicId))
			{
	            // Get the occ count
		        if (cNumOcc)
			    {
				    DWORD dwOccCount;
					DWORD dwT;
                
					pQueuePtr += CbByteUnpack (&dwOccCount, pQueuePtr);
#ifdef _DEBUG
	                if (pQueuePtr > pEsb->lrgbMem + pEsb->dwEsbSize)
		                SetErrCode (phr, E_ASSERT);
#endif
			        for (; dwOccCount > 0; dwOccCount--)
					{
	                    // Fill up the buffer if run out of data
		                if (pQueuePtr >= pBufMax)
			        	{
				        	pEsb->ibBuf = (DWORD)(pQueuePtr - pEsb->lrgbMem);
					    	if ((fRet = ESFillBuffer (lpipb, pEsb)) != S_OK)
						        goto exit5;
                     		pQueuePtr = pEsb->lrgbMem;
                		}
					
	                    switch (cNumOcc)
		                {
			                case 5:
				                pQueuePtr += CbByteUnpack (&dwT, pQueuePtr);
					        case 4:
						        pQueuePtr += CbByteUnpack (&dwT, pQueuePtr);
							case 3:
								pQueuePtr += CbByteUnpack (&dwT, pQueuePtr);
	                        case 2:
		                        pQueuePtr += CbByteUnpack (&dwT, pQueuePtr);
			                case 1:
				                pQueuePtr += CbByteUnpack (&dwT, pQueuePtr);
					    }
                    
#ifdef _DEBUG
	                    if (pQueuePtr > pEsb->lrgbMem + pEsb->dwEsbSize)
		                    SetErrCode (phr, E_ASSERT);
#endif
					} // end occ loop
				}	// end if occ non-zero

				pHeader->dwTopicCount--;
				continue;
			}	// end of to-delete condition

            // Allocate a topicdata node
            if ((pNewTopic == NULL) &&
                (pNewTopic = GetBlockNode (&lpipb->TopicBlock)) == NULL)
            {
                if ((fRet = ESMemory2Disk(lpipb, pHeader, FLUSH_EXCEPT_LAST)) != S_OK)
                {
exit5:
                    _GLOBALUNLOCK(hWord);
                    _GLOBALFREE(hWord);
                    goto exit4;
                }
                
                if ((pNewTopic = GetBlockNode (&lpipb->TopicBlock)) == NULL)
                {
                    // Extremely weird, since we just release a bunch of
                    // memory
                    fRet = E_ASSERT;
                    goto exit5;
                }
            }

			pNewTopic->dwTopicId = dwTopicId;

#ifdef _DEBUG
            if (pQueuePtr > pEsb->lrgbMem + pEsb->dwEsbSize)
                SetErrCode (phr, E_ASSERT);
#endif
            // Set the other fields
            pNewTopic->pOccData = pNewTopic->pLastOccData = NULL;

            // Get the occ count
            if (cNumOcc)
            {
                DWORD dwOccCount;
                POCCDATA pOccData;
                LPDW lpDw;
                
                pQueuePtr += CbByteUnpack (&pNewTopic->dwOccCount,
                    pQueuePtr);

#ifdef _DEBUG
                if (pQueuePtr > pEsb->lrgbMem + pEsb->dwEsbSize)
                    SetErrCode (phr, E_ASSERT);
#endif
                for (dwOccCount = pNewTopic->dwOccCount; dwOccCount > 0;
                    dwOccCount--)
                {
                    // Get all occ fields
                    if ((pOccData = (POCCDATA)GetBlockNode
                        (&lpipb->OccBlock)) == NULL )
                    {
                        if ((fRet = ESMemory2Disk(lpipb, pHeader,
                            FLUSH_EXCEPT_LAST)) != S_OK)
                            goto exit5;
                        
                        if ((pOccData =
                            (POCCDATA)GetBlockNode(&lpipb->OccBlock)) == NULL)
                        {
                            // Extremely weird, since we just release a bunch of
                            // memory, unless there are so many duplicates of the same word
							// in the topic

                            fRet = E_TOOMANYDUPS;
                            goto exit5;
                        }
                    }
                    
                    // Fill up the buffer if run out of data
                    if (pQueuePtr >= pBufMax)
                	{
                    	pEsb->ibBuf = (DWORD) (pQueuePtr - pEsb->lrgbMem);
                    	if ((fRet = ESFillBuffer (lpipb, pEsb)) != S_OK)
                            goto exit5;
                    	pQueuePtr = pEsb->lrgbMem;
                	}

                    lpDw = (LPDW)&pOccData->OccData;
                    switch (cNumOcc)
                    {
                        case 5:
                            pQueuePtr += CbByteUnpack (lpDw++, pQueuePtr);
                        case 4:
                            pQueuePtr += CbByteUnpack (lpDw++, pQueuePtr);
                        case 3:
                            pQueuePtr += CbByteUnpack (lpDw++, pQueuePtr);
                        case 2:
                            pQueuePtr += CbByteUnpack (lpDw++, pQueuePtr);
                        case 1:
                            pQueuePtr += CbByteUnpack (lpDw++, pQueuePtr);
                    }
                    
#ifdef _DEBUG
                    if (pQueuePtr > pEsb->lrgbMem + pEsb->dwEsbSize)
                        SetErrCode (phr, E_ASSERT);
#endif
                    // Attach to the linked list
                    // Note that we are assumimg that the occurrences are
                    // already sorted, so no checking is done here
                    if (pNewTopic->pOccData == NULL)
                    {
                        pNewTopic->pLastOccData = pNewTopic->pOccData
                            = pOccData;
                    }
                    else 
                    {
                        // Add to the end of the linked list
                        pNewTopic->pLastOccData->pNext = pOccData;
                        pNewTopic->pLastOccData = pOccData;
                    }
                    pOccData->pNext = NULL;
                }
            }
            
            if (pNewTopic = MergeTopicNode (pHeader, pNewTopic, cNumOcc))
                pHeader->dwTopicCount --;
        }
        
        // Update the offset
        pEsb->ibBuf = (DWORD) (pQueuePtr - pEsb->lrgbMem);
      
        // If next record doesn't fit in buffer
        // Then reset to beginning and load data
        if (pEsb->dwEsbSize - pEsb->ibBuf <= sizeof(DWORD) ||
            pEsb->dwEsbSize -  pEsb->ibBuf <= GETLONG((LPUL)pQueuePtr) + 
            2 * sizeof(DWORD))
        {
        	if ((fRet = ESFillBuffer (lpipb, pEsb)) != S_OK)
                goto exit4;
        }

        // Adjust priority queue
        if (uiQueueSize > 1)
        { 
            if (DwSubFo (pEsb->lfo, pEsb->lfoMax) != 0 &&
                pEsb->ibBuf >= pEsb->dwEsbSize)
            {
                // Replace first record with last
                lrgPriorityQueue[1] = lrgPriorityQueue[uiQueueSize];
                lrgPriorityQueue[uiQueueSize] = NULL;
                uiQueueSize--;
                pEsi->uiQueueSize = uiQueueSize;
            }
#if 0
            else
            {   // If the stream still has input add it back into the Queue
                lrgPriorityQueue[uiQueueSize] = pEsb;
                PQueueUp(lpipb, lrgPriorityQueue, uiQueueSize);
            }
#endif
            PQueueDown(lpipb);  // Maintain sort order
        }
        else if (DwSubFo (pEsb->lfo, pEsb->lfoMax) != 0 &&
            pEsb->ibBuf >=  pEsb->dwEsbSize)
        {
            uiQueueSize--;
            pEsi->uiQueueSize = uiQueueSize;
            if ((fRet = ESMemory2Disk (lpipb, pHeader, FLUSH_NEW_RECORD)) != S_OK)
                return(fRet);
        }
    } while (uiQueueSize);

    fRet = ESFlushBuffer(pEsi);
    goto exit5;
}
                                             

BOOL PASCAL NEAR FindTopic(LPMERGEPARAMS lpmp, DWORD dwTopicId)
{
	register LPDW lpdw;
	LPDW lpdwMac;

    Assert(lpmp->dwCount > 0);
	Assert(lpmp->lpTopicIdLast >= lpmp->rgTopicId);
	Assert(lpmp->lpTopicIdLast < lpmp->rgTopicId + lpmp->dwCount);

	if (lpmp->rgTopicId[0] > dwTopicId 
         || 
         *(lpdwMac = lpmp->rgTopicId + lpmp->dwCount - 1) < dwTopicId)
		return FALSE;

    if (*lpmp->lpTopicIdLast == dwTopicId)
        return TRUE;

	if (*lpmp->lpTopicIdLast > dwTopicId)
	{
		// re-start at the beginning
		lpmp->lpTopicIdLast = lpmp->rgTopicId;
	}
	
	for (lpdw = lpmp->lpTopicIdLast; lpdw < lpdwMac + 1; lpdw++)
		if (*lpdw == dwTopicId)
		{
			lpmp->lpTopicIdLast = lpdw;
			return TRUE;
		}

	return FALSE;
}

/*************************************************************************
 *
 *  @doc  INTERNAL INDEXING
 *
 *  @func int | CompareRecordBuffers |
 *    Called from PQueueUp/Down to sort the input buffers based first
 *    upon the string's, then TopicID's, then word length's, etc.
 *
 *  @parm _LPIPB | lpipb |
 *    Pointer to the index parameter block
 *
 *  @parm LPB | pBuffer A |
 *    Pointer to the first input buffer
 *
 *  @parm   LPB | pBuffer B |
 *      Pointer to the second input buffer
 *
 *  @rdesc
 *      If pBufferA < pBufferB  return < 0
 *      If pBufferA == pBufferB return = 0
 *      If pBufferA > pBufferB  return > 0
 *************************************************************************/

int PASCAL NEAR CompareRecordBuffers (_LPIPB lpipb, LPB pBufferA, LPB pBufferB)
{
    // Local Replacement Variables 
    int     occf = lpipb->occf;
    int     cNumOcc = lpipb->ucNumOccDataFields;
    DWORD   dwOccMin;

    // Working Variables
    int     fRet;            
    int     Len;
    DWORD   dwDataA;
    DWORD   dwDataB;

    pBufferA += sizeof (DWORD);  // Skip record length
    pBufferB += sizeof (DWORD);  // Skip record length
    
    // Compare Pascal strings
    if ((fRet = StrCmp2BytePascal(pBufferA, pBufferB)) != 0)
        return fRet;
        
    pBufferA += (Len = GETWORD ((LPUW)pBufferA) + sizeof (SHORT));
    pBufferB += Len;
    
    // Strings equal - compare FieldIds
    // Compare Word Lengths
    if (occf & OCCF_LENGTH)
    {
        pBufferA += CbByteUnpack (&dwDataA, pBufferA);
        pBufferB += CbByteUnpack (&dwDataB, pBufferB);
        if ((fRet = (int)(dwDataA - dwDataB)) != 0)
            return fRet;
    }

    if (occf & OCCF_FIELDID)
    {
        pBufferA += CbByteUnpack (&dwDataA, pBufferA);
        pBufferB += CbByteUnpack (&dwDataB, pBufferB);
        if ((fRet = (int)(dwDataA - dwDataB)) != 0)
            return fRet;
    }

    
    // Skip topic count
    pBufferA += CbByteUnpack (&dwDataA, pBufferA);
    pBufferB += CbByteUnpack (&dwDataB, pBufferB);
    
    // Compare 1st topic Id
    pBufferA += CbByteUnpack (&dwDataA, pBufferA);
    pBufferB += CbByteUnpack (&dwDataB, pBufferB);
    if ((fRet = (int)(dwDataA - dwDataB)) != 0)
        return fRet;
        
    // Get the occurrence count    
    pBufferA += CbByteUnpack (&dwDataA, pBufferA);
    pBufferB += CbByteUnpack (&dwDataB, pBufferB);
    
    if ((fRet = (int)(dwDataA - dwDataB)) < 0)
        dwOccMin = dwDataA;
    else    
        dwOccMin = dwDataB;
    for (; dwOccMin; dwOccMin--)
    {
        switch (cNumOcc)
        {
            case 5:
                pBufferA += CbByteUnpack (&dwDataA, pBufferA);
                pBufferB += CbByteUnpack (&dwDataB, pBufferB);
                if ((fRet = (int)(dwDataA - dwDataB)) != 0)
                    return fRet;
                break;
            case 4:
                pBufferA += CbByteUnpack (&dwDataA, pBufferA);
                pBufferB += CbByteUnpack (&dwDataB, pBufferB);
                if ((fRet = (int)(dwDataA - dwDataB)) != 0)
                    return fRet;
                break;
            case 3:
                pBufferA += CbByteUnpack (&dwDataA, pBufferA);
                pBufferB += CbByteUnpack (&dwDataB, pBufferB);
                if ((fRet = (int)(dwDataA - dwDataB)) != 0)
                    return fRet;
                break;
            case 2:
                pBufferA += CbByteUnpack (&dwDataA, pBufferA);
                pBufferB += CbByteUnpack (&dwDataB, pBufferB);
                if ((fRet = (int)(dwDataA - dwDataB)) != 0)
                    return fRet;
                break;
            case 1:
                pBufferA += CbByteUnpack (&dwDataA, pBufferA);
                pBufferB += CbByteUnpack (&dwDataB, pBufferB);
                if ((fRet = (int)(dwDataA - dwDataB)) != 0)
                    return fRet;
                break;
        }
    }
    return fRet;
}


/*************************************************************************
 *
 *  @doc  INTERNAL INDEXING
 *
 *  @func VOID | PQueueUp | 
 *    The function restores the heap condition of a PQ, ie. the parent
 *    node must be less than the children. When the top node is inserted
 *    the heap condition may be violated if the resulting node 
 *    is smaller than its parent. In this case the nodes have to
 *    be switched.
 *
 *  @parm LPESI | lpesi |
 *    Pointer to external sort info, which contains all info
 *
 *  @parm   LONG | index |
 *    Index of the inserted node
 *
 *************************************************************************/

VOID PASCAL NEAR PQueueUp 
    (_LPIPB lpipb, LPESB FAR *lrgPriorityQueue, LONG index)
{
    LPESB lpesbTemp;      // Pointer to the inserted node
    LPESB lpesbHalf;      // Pointer to the parent node
    WORD  uiHalf;         // Index of the parent's node

    lpesbTemp = lrgPriorityQueue [index];

    if ((uiHalf = (WORD) (index/2)) == 0)
        return;
    lpesbHalf = lrgPriorityQueue [uiHalf];

    /* If the parent node is greated than the child, then exchange the
     * nodes, The condition uiHalf != index makes sure that we stop
     * at node 0 (top node)
     */
    while (uiHalf && CompareRecordBuffers (lpipb, (LPB)lpesbHalf->lrgbMem + 
        lpesbHalf->ibBuf, (LPB)lpesbTemp->lrgbMem + lpesbTemp->ibBuf) > 0)
    {
        lrgPriorityQueue [index] = lpesbHalf;
        index = uiHalf;
        uiHalf = (WORD)(index/2);
        lpesbHalf = lrgPriorityQueue [uiHalf];
    }
    lrgPriorityQueue[index] = lpesbTemp;
#if BINHN
    SetQueue (&lpipb->esi);
#endif
}


/*************************************************************************
 *
 *  @doc  INTERNAL INDEXING
 *
 *  @func VOID | PQueueDown | 
 *    The function restores the heap condition of a PQ, ie. the parent
 *    node must be less than the children. When the top node is removed
 *    the heap condition may be violated if the resulting node 
 *    is greater than its children. In this case the nodes have to
 *    be switched.
 *
 *  @parm LPESI | lpesi |
 *    Pointer to external sort info, which contains all info
 *
 *************************************************************************/

PRIVATE VOID PASCAL NEAR PQueueDown (_LPIPB lpipb)
{
    LPESI lpesi = &lpipb->esi;
    LPESB FAR *lrgPriorityQueue;
    int CurIndex;
    int ChildIndex;
    int MaxCurIndex;
    int MaxChildIndex;
    LPESB lpesbSaved;
    LPESB lpesbTemp;
    LPESB lpesbChild;

    lrgPriorityQueue = lpesi->lrgPriorityQueue;
    lpesbSaved = lrgPriorityQueue[1];
    MaxCurIndex = (MaxChildIndex = lpesi->uiQueueSize) / 2;

    for (CurIndex = 1; CurIndex <= MaxCurIndex; CurIndex = ChildIndex) 
    {
        // Get child index 
        ChildIndex = CurIndex * 2;
        // Find the minimum of the two children 
        if (ChildIndex < MaxChildIndex) 
        {
            if ((lpesbTemp = lrgPriorityQueue[ChildIndex + 1]) != NULL) 
            {
                lpesbChild = lrgPriorityQueue[ChildIndex];

                // The two children exist. Take the smallest 
                if (CompareRecordBuffers 
                    (lpipb, (LPB)lpesbChild->lrgbMem + lpesbChild->ibBuf,
                    (LPB)lpesbTemp->lrgbMem + lpesbTemp->ibBuf) >= 0)
                    ChildIndex++;
            }
        }

        // If the parent's node is less than the child, then break
        // (heap condition met)
        if (ChildIndex > MaxChildIndex) 
            break;
       
        lpesbTemp = lrgPriorityQueue [ChildIndex];

        if (CompareRecordBuffers (lpipb, (LPB)lpesbSaved->lrgbMem + 
            lpesbSaved->ibBuf, (LPB)lpesbTemp->lrgbMem+lpesbTemp->ibBuf) < 0)
            break;

        // Replace the node 
        lrgPriorityQueue [CurIndex] = lpesbTemp;
    }
    lrgPriorityQueue [CurIndex] = lpesbSaved;
#if _BINHN
    SetQueue (lpesi);
#endif
}


PRIVATE PTOPICDATA PASCAL NEAR MergeTopicNode (PMERGEHEADER pHeader,
    PTOPICDATA pNewTopic, int cNumOcc)
{
    // PTOPICDATA pLastTopic;
    PTOPICDATA pTopic, pPrevTopic;
    int fResult;
    
    if ((pTopic = pHeader->pLastTopic) == NULL) 
    {
        // The list is empty
        pHeader->pTopic = pHeader->pLastTopic = pNewTopic;
        pNewTopic->pNext = NULL;
        return(NULL);
        
    }
    
    fResult = pTopic->dwTopicId - pNewTopic->dwTopicId;
    
    if (fResult < 0)
    {
        // New node. Add to the end
        pNewTopic->pNext = NULL;
        pHeader->pLastTopic->pNext = pNewTopic;
        pHeader->pLastTopic = pNewTopic;
        
        // Reset pNewTopic for next node allocation
        return NULL;
    }
    
    if (fResult == 0)
    {
        // Same topic. Return pNewTopic for reuse
        if (cNumOcc)
        	MergeOccurrence (pTopic, pNewTopic, cNumOcc);
        return(pNewTopic);
    }
    
    // If we get to this point, the list is out of order
    // Try to find the insertion point		
    pTopic = pHeader->pTopic;
    pPrevTopic = NULL;
     
    for (; pTopic->pNext; pTopic = pTopic->pNext)
    {
        if (pTopic->dwTopicId >= pNewTopic->dwTopicId)
        {
            /* We pass the inserted point */
            break;
        }
        pPrevTopic = pTopic;
    }
    
    if (pTopic->dwTopicId == pNewTopic->dwTopicId)
    {
        // Same topic. Return pNewTopic for reuse
        if (cNumOcc)
        	MergeOccurrence (pTopic, pNewTopic, cNumOcc);
        return(pNewTopic);
    }
    
    // Handle empty case
    if (pPrevTopic == NULL)
    {
        /* Insert at the beginning */
        pNewTopic->pNext = pHeader->pTopic;
        pHeader->pTopic = pNewTopic;
    }
    
    else
    {
        /* Inserted at the middle or the end */
        pNewTopic->pNext = pPrevTopic->pNext;
        pPrevTopic->pNext = pNewTopic;
    }
    
    // Update the last topic
    while (pTopic->pNext)
    {
        pTopic = pTopic->pNext;
    }
    pHeader->pLastTopic = pTopic;
    return(NULL);
}    

/*************************************************************************
 *  @doc    PRIVATE
 *  @func   void | MergeOccurrence |
 *      Merge the occurrence by adding them in order
 *************************************************************************/
PRIVATE VOID NEAR MergeOccurrence (PTOPICDATA pOldTopic,
    PTOPICDATA pNewTopic, int cOccNum)
{
    ERRB errb;
    
    if (CompareOccurrence (&pOldTopic->pLastOccData->OccData[0],
        &pNewTopic->pOccData->OccData[0], cOccNum) <= 0)
    {
        // The whole last list is less than the current list. This is
        // what I expect
        // We just linked the 2 lists together
        pOldTopic->pLastOccData->pNext = pNewTopic->pOccData;
        pOldTopic->pLastOccData = pNewTopic->pLastOccData;
        pOldTopic->dwOccCount += pNewTopic->dwOccCount;
        return;
    }
    
    // The current list is less than the old list.
    // This is weird, but still we can handle it
    if (CompareOccurrence (&pNewTopic->pOccData->OccData[0],
        &pOldTopic->pOccData->OccData[0], cOccNum) <= 0)
    {
        pNewTopic->pLastOccData->pNext = pOldTopic->pOccData;
        pOldTopic->pOccData = pNewTopic->pOccData;
        pOldTopic->dwOccCount += pNewTopic->dwOccCount;
        return;
    }
    
    SetErrCode (&errb, E_ASSERT);
}    

/*====================================================================*/
#ifdef BINHN
PRIVATE VOID PASCAL NEAR SetQueue (LPESI pEsi)
{
    unsigned int i = 0;
    LPESB FAR *lrgPriorityQueue;
    
    lrgPriorityQueue = pEsi->lrgPriorityQueue;
    for (i = 0; i < 20 && i < pEsi->cesb ; i++)
    {
         if (lrgPriorityQueue[i])
            pEsi->lpbQueueStr[i] = lrgPriorityQueue[i]->lrgbMem +
            lrgPriorityQueue[i]->ibBuf + 6;
    }
    
}
#endif
    
/************************************************************************
 *  @doc    PRIVATE
 *  @func   HRESULT PASCAL NEAR | ESBBlockAllocate |
 *      Set the memory allocation based on the memory of the machine
 *  @parm   DWORD | lMemSize |
 *      Memory allocated for the indexer
 *  @rdesc  S_OK, or E_OUTOFMEMORY
 ************************************************************************/

PRIVATE HRESULT PASCAL NEAR ESBBlockAllocate (_LPIPB lpipb, DWORD lMemSize)
{
    DWORD dwTopicSize;
    DWORD dwOccSize;
    WORD OccNodeSize = sizeof (OCCDATA) - 1 + sizeof(DWORD) *
        lpipb->ucNumOccDataFields; // About 24bytes
        
    OccNodeSize = (OccNodeSize + 3) & ~3;

    /* The memory is for topic block and occurrence blocks, which
     * should be in the ratio 1:1.5 
     */
    dwTopicSize = (lMemSize * 2) / 5;
    dwOccSize = lMemSize - dwTopicSize;
    
#if 0
    /* Don't do anything if things are too small */
    if (dwTopicSize < MAX_BLOCK_SIZE || dwOccSize < MAX_BLOCK_SIZE)
        return(E_OUTOFMEMORY);
#endif
        
    // Allocate a block manager for topic node 
    
    if ((lpipb->TopicBlock.pBlockMgr = 
        BlockInitiate ((MAX_BLOCK_SIZE * sizeof(TOPICDATA)/sizeof(TOPICDATA)),
            sizeof(TOPICDATA),
            (WORD)(dwTopicSize/MAX_BLOCK_SIZE),
            USE_VIRTUAL_MEMORY | THREADED_ELEMENT)) == NULL)
    { 
exit2:
        return SetErrCode (NULL, E_OUTOFMEMORY);
    }
    lpipb->TopicBlock.pFreeList =
        (PLIST)BlockGetLinkedList(lpipb->TopicBlock.pBlockMgr);
    
    // Allocate a block manager for occ node 
    if ((lpipb->OccBlock.pBlockMgr =
        BlockInitiate((MAX_BLOCK_SIZE * OccNodeSize)/OccNodeSize,
        OccNodeSize, (WORD)(lMemSize / MAX_BLOCK_SIZE), 
        USE_VIRTUAL_MEMORY | THREADED_ELEMENT)) == NULL)
    { 
        BlockFree(lpipb->BTNodeBlock.pBlockMgr);
        lpipb->BTNodeBlock.pBlockMgr = NULL;
        goto exit2;
    }
    lpipb->OccBlock.pFreeList = (PLIST)BlockGetLinkedList(lpipb->OccBlock.pBlockMgr);
    
    return (S_OK);
}

PRIVATE LPV PASCAL NEAR GetBlockNode (PBLKCOMBO pBlockCombo)
{
    PLIST pList;
    
    if (pBlockCombo->pFreeList == NULL)
    {
        if ((BlockGrowth (pBlockCombo->pBlockMgr) != S_OK))
            return (NULL);
        pBlockCombo->pFreeList =
            (PLIST)BlockGetLinkedList(pBlockCombo->pBlockMgr);
    }
    pList = pBlockCombo->pFreeList;
    pBlockCombo->pFreeList = pList->pNext;
    pBlockCombo->dwCount ++;
    // pList->pNext = NULL;
    return (pList);
}

/*************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL FAR PASCAL | BuildIndexFile |
 *      This function is for debugging purpose only. In normal indexing,
 *      it will never be called. Since collecting words and indexing can
 *      take a long time, debugging the index phase can become a hassle that
 *      take several hours per shot. To minimize the index time for debugging,
 *      all the intermediate files are saved, which are:
 *          - the internal sorted result file, which contains all words and
 *          their occurrences sorted
 *          - the external sorted result file, which is a snap shot of the
 *          ESI structures and its ESB blocks
 *      The only steps left will be processing the occurrence list and doing
 *      permanent index
 *
 *      To use the function, add the following lines in the app:
 *
 *      extern HRESULT PASCAL FAR BuildIndexFile (LPSTR, LPSTR, LPSTR, WORD, WORD,
 *      WORD, INTERRUPT_FUNC, VOID FAR *, STATUS_FUNC, VOID FAR*, PHRESULT);
 *
 *      int fDotest;
 *
 *      if (fDotest) {
 *          return BuildIndexFile ((LPSTR)"c:/tmp/test.mvb!MVINDEX",
 *              (LPSTR)"c:/tmp/esi.tmp", (LPSTR)"c:/tmp/iso.tmp",
 *              OCCF_TOPICID, IDXF_NORMALIZE, 0, (INTERRUPT_FUNC)lpfnInterruptFunc,
 *              (LPV)NULL,
 *              (STATUS_FUNC)lpfnStatusFunc, (LPV)hwndGlobal,
 *              NULL);
 *      }
 *
 *  @parm   HFPB | hfpb |
 *      HFPB for index file if pstrIndexFile is NULL
 *
 *  @parm   LPB | pstrIndexFile |
 *      The .MVB + index file, usually with the format TEST.MVB!MVINDEX
 *
 *  @parm   LPB | lpbEsiFile |
 *      The external sort info file
 *
 *  @parm   LPB | lpbIsiFile |
 *      The internal sorted info filename
 *
 *  @parm   PINDEXINFO | pIndexInfo |
 *      IndexInfo
 *
 *  @rdesc  S_OK if succeeded, else other non-zero error codes
 *************************************************************************/

PUBLIC HRESULT PASCAL EXPORT_API FAR BuildIndexFile
    (HFPB hfpb, LPSTR pstrIndexFile,
    LPB lpbEsiFile, LPB lpbIsiFile, PINDEXINFO pIndexInfo)
{
    _LPIPB lpipb;
    LPESI lpesi;
    BOOL fRet;
    ERRB errb;
    DWORD loop;
    FLOAT rLog;
    BYTE  bKeyIndex = 0;

    if ((lpipb = MVIndexInitiate(pIndexInfo, NULL)) == NULL)
        return E_FAIL;

    lpesi = &lpipb->esi;

    if (LoadEsiTemp (lpipb, lpesi, lpbEsiFile, lpbIsiFile, NULL) != S_OK)
    {
        fRet = E_FAIL;
exit0:
        MVIndexDispose (lpipb);
        return fRet;
    }

    if (lpipb->idxf & IDXF_NORMALIZE)
    {
        // Allocate a huge buffer to contain all the sigma terms
        if ((lpipb->wi.hSigma = _GLOBALALLOC (DLLGMEM_ZEROINIT,
            (LCB)((lpipb->dwMaxTopicId + 1) * sizeof (SIGMA)))) == NULL)
            return SetErrCode (&errb, E_OUTOFMEMORY);
        lpipb->wi.hrgsigma = (HRGSIGMA)_GLOBALLOCK (lpipb->wi.hSigma);

        // Small buffer containing pre-calculated values
        if ((lpipb->wi.hLog = _GLOBALALLOC (DLLGMEM_ZEROINIT,
            (CB)(cLOG_MAX * sizeof (FLOAT)))) == NULL)
            {
                SetErrCode (&errb, (HRESULT)(fRet = E_OUTOFMEMORY));
                FreeHandle (lpipb->wi.hSigma);
                goto exit0;
            }
        lpipb->wi.lrgrLog = (FLOAT FAR *)_GLOBALLOCK (lpipb->wi.hLog);
        // Initialize the array
        for (loop = cLOG_MAX - 1; loop > 0; --loop)
        {
#ifndef ISBU_IR_CHANGE
			rLog = (float) log10(cHundredMillion/(double)loop);
#else
			rLog = (float)1.0 / (float)loop;
#endif	// ISBU_IR_CHANGE
            lpipb->wi.lrgrLog[loop] = rLog * rLog;
        }
    }

    if ((fRet = MergeSortTreeFile (lpipb, NULL)) != S_OK)
        return SetErrCode (&errb, (HRESULT)fRet);
    if ((lpipb->idxf & KEEP_TEMP_FILE) == 0)
    	FileUnlink (NULL, lpipb->isi.aszTempName, REGULAR_FILE);

    // If we are doing term-weighting we have to square root all sigma values
    if (lpipb->idxf & IDXF_NORMALIZE)
    {
		// ISBU_IR_CHANGE not necessary 'cos sqrt computation is necessary in both cases
        for (loop = 0; loop < lpipb->dwMaxTopicId + 1; ++loop)
            lpipb->wi.hrgsigma[loop] = 
                (float)sqrt ((double)lpipb->wi.hrgsigma[loop]);
    }

    // Analyze data to get the best compression scheme
    // TopicId
    VGetBestScheme(&lpipb->cKey[CKEY_TOPIC_ID], 
        &lpipb->BitCount[CKEY_TOPIC_ID][0], lcbitBITSTREAM_ILLEGAL, TRUE);
    // Occurrence Count
    VGetBestScheme(&lpipb->cKey[CKEY_OCC_COUNT], 
        &lpipb->BitCount[CKEY_OCC_COUNT][0], lcbitBITSTREAM_ILLEGAL, TRUE);

    if (lpipb->occf & OCCF_COUNT)
    {
        VGetBestScheme(&lpipb->cKey[bKeyIndex],
            &lpipb->BitCount[bKeyIndex][0], lcbitBITSTREAM_ILLEGAL, TRUE);
        bKeyIndex++;
    }

    if (lpipb->occf & OCCF_OFFSET)
    {
        VGetBestScheme(&lpipb->cKey[bKeyIndex],
            &lpipb->BitCount[bKeyIndex][0], lcbitBITSTREAM_ILLEGAL, TRUE);
        bKeyIndex++;
    }

    // Call the user callback every once in a while
    if (lpipb->CallbackInfo.dwFlags & ERRFLAG_STATUS)
    {
        PFCALLBACK_MSG pCallbackInfo = &lpipb->CallbackInfo;
        CALLBACKINFO Info;

        Info.dwPhase = 2;
        Info.dwIndex = 100;
        fRet = (*pCallbackInfo->MessageFunc)
            (ERRFLAG_STATUS, pCallbackInfo->pUserData, &Info);
        if (S_OK != fRet)
            goto exit0;
    }
    
    // Build the permanent index    
    fRet = BuildBTree(NULL, lpipb, lpipb->esi.aszTempName, hfpb, pstrIndexFile);
    if (lpipb->idxf & IDXF_NORMALIZE)
    {
        FreeHandle (lpipb->wi.hLog);
        FreeHandle (lpipb->wi.hSigma);
    }
    goto exit0;
}

PRIVATE VOID PASCAL NEAR SaveEsiTemp (_LPIPB lpipb, LPESI lpesi)
{
    GHANDLE hfpb;
    LPESB lpesb;
    char szEsi[100];

    GETTEMPFILENAME ((char)0, "foo", 0, szEsi);
    if ((hfpb = FileOpen(NULL, szEsi, REGULAR_FILE, READ_WRITE, NULL)) == NULL) 
        return;

    FileWrite(hfpb, lpipb, sizeof(IPB), NULL);

    for (lpesb = lpesi->lpesbRoot; lpesb; lpesb = lpesb->lpesbNext)
    {
        if (FileWrite(hfpb, lpesb, sizeof(ESB), NULL) != sizeof(ESB))
        {
            FileClose (hfpb);
            FileUnlink (NULL, szEsi, REGULAR_FILE);
            return;
        }
    }
    FileClose (hfpb);
    MEMCPY (lpipb->szEsiTemp, szEsi, 100);
}

PRIVATE VOID PASCAL NEAR UpdateEsiTemp (_LPIPB lpipb)
{
    GHANDLE hfpb;

    if ((hfpb = FileOpen(NULL, lpipb->szEsiTemp, REGULAR_FILE,
        READ_WRITE, NULL)) == NULL) 
        return;

    FileWrite(hfpb, lpipb, sizeof(IPB), NULL);
    FileClose (hfpb);
}

PRIVATE BOOL PASCAL LoadEsiTemp (_LPIPB lpipb, LPESI lpesi, LPB lpbEsiFile,
    LPB lpbIsiFile, PHRESULT phr)
{
    LPESB lpesb;
    HFILE  hFile;
    ESB	esb;
    HANDLE hesb;
    HRESULT fRet;
    IPB ipb;
    LPISI pIsi = &lpipb->isi;         // Pointer to internal sort info

    /* Copy the internal sort info filename */
    MEMCPY (pIsi->aszTempName, lpbIsiFile, lstrlen(lpbIsiFile));

    /* Read in the external sort buffer info */

    if ((hFile = _lopen (lpbEsiFile, READ)) == HFILE_ERROR)
        return E_NOTEXIST;

    /* Read old IPB info */
    _lread (hFile, &ipb, sizeof(IPB));

    /* Transfer meaningful data */

    lpipb->dwIndexedWord = ipb.dwIndexedWord;
    lpipb->dwUniqueWord = ipb.dwUniqueWord;
    lpipb->dwByteCount = ipb.dwByteCount;
    lpipb->dwOccOffbits = ipb.dwOccOffbits;
    lpipb->dwOccExtbits = ipb.dwOccExtbits;
    lpipb->dwMaxFieldId = ipb.dwMaxFieldId;
    lpipb->dwMaxWCount = ipb.dwMaxWCount;
    lpipb->dwMaxOffset = ipb.dwMaxOffset;
    lpipb->dwTotal3bWordLen = ipb.dwTotal3bWordLen;
    lpipb->dwTotal2bWordLen = ipb.dwTotal2bWordLen;
    lpipb->dwTotalUniqueWordLen = ipb.dwTotalUniqueWordLen;
    lpipb->lcTopics = ipb.lcTopics;
    lpipb->dwMaxTopicId = ipb.dwMaxTopicId;
    // lpipb->dwMemAllowed = ipb.dwMemAllowed;
    lpipb->dwMaxRecordSize = ipb.dwMaxRecordSize;
    lpipb->dwMaxEsbRecSize = ipb.dwMaxEsbRecSize;
    lpipb->dwMaxWLen = ipb.dwMaxWLen;
    lpipb->idxf = ipb.idxf;
    
    while ((_lread (hFile, &esb, sizeof(ESB))) == sizeof(ESB))
    {
        if ((hesb = _GLOBALALLOC(GMEM_MOVEABLE | GMEM_ZEROINIT,
            sizeof(ESB))) == NULL) {
                
            fRet = SetErrCode (phr,E_OUTOFMEMORY);
exit0:
            _lclose (hFile);
            return fRet;
        }

        lpesb = (LPESB)_GLOBALLOCK (hesb);

        /* Copy the ESB information */
        *lpesb = esb;

        /* Update the structure */
        lpesb->hStruct = hesb;

        lpesb->lpesbNext = lpesi->lpesbRoot;
        lpesi->lpesbRoot= lpesb;
        lpesi->cesb ++;
    }
    _lclose (hFile);

    fRet = S_OK;
    goto exit0;

}

HRESULT FAR PASCAL AllocSigmaTable (_LPIPB lpipb)
{
    ERRB errb;
    DWORD loop;
	float rLog;

    
    if ((lpipb->wi.hSigma = _GLOBALALLOC (DLLGMEM_ZEROINIT,
        (LCB)((lpipb->dwMaxTopicId + 1) * sizeof (SIGMA)))) == NULL)
        return SetErrCode (&errb, E_OUTOFMEMORY);
    lpipb->wi.hrgsigma = (HRGSIGMA)_GLOBALLOCK (lpipb->wi.hSigma);

    if ((lpipb->wi.hLog = _GLOBALALLOC (DLLGMEM_ZEROINIT,
        (CB)(cLOG_MAX * sizeof (FLOAT)))) == NULL)
    {
        FreeHandle (lpipb->wi.hSigma);
        return SetErrCode (&errb, E_OUTOFMEMORY);
    }
    lpipb->wi.lrgrLog = (FLOAT FAR *)_GLOBALLOCK (lpipb->wi.hLog);
    // Initialize the array
    for (loop = cLOG_MAX - 1; loop > 0; --loop)
    {
#ifndef ISBU_IR_CHANGE
		rLog = (float) log10(cHundredMillion/(double)loop);
#else
        rLog = (float)1.0 / (float)loop;
#endif	// ISBU_IR_CHANGE
        lpipb->wi.lrgrLog[loop] = rLog * rLog;
    }
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\optable.c ===
/*************************************************************************
*                                                                        *
*  CHARTAB.C                                                             *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*    Character table indexing and retrieval. The reasons this module is  *
*    not put together with ansiusa are:                                  *
*       - Like stop words, this involves indexing and retrieval          *
*       - It is word breaker independent                                 *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: Binh Nguyen                                            *
*                                                                        *
*************************************************************************/
#include <mvopsys.h>
#include <mem.h>
#include <memory.h>
#include <mvsearch.h>
#include "common.h"
#include "search.h"

#ifdef _DEBUG
static BYTE NEAR s_aszModule[] = __FILE__;	/* Used by error return functions.*/
#endif


#define         SLASH                           '/'
#define         RETURN                          '\r'
#define         NEWLINE                         '\n'

/* The order of the functions are relevant, since they will be indirectly
 * called through the operators themselves. A change in the order of
 * the functions whould be accompanied by a similar change in the value
 * of the operator
 * The operator's definition is put here to make sure that things match
 * between mvsearch.h and the order of the functions
 */

#define    AND_OP           0
#define    OR_OP            1
#define    NOT_OP           2
#define    PHRASE_OP        3
#define    NEAR_OP          4
#define    RANGE_OP         5
#define    GROUP_OP         6
#define    FIELD_OP         7
#define    BRKR_OP          8

#define    OPERATOR_ENTRY_COUNT    7

/* This array describes all the operators and their values. The index
 * of the entries is defined as the order of the operator's intrinsic
 * values, ie: AND_OP, OR_OP, etc
 */

OPSYM OperatorSymbolTable[OPERATOR_ENTRY_COUNT] = {
    "\3AND",       UO_AND_OP,      // AND_OP,    0
    "\2OR",        UO_OR_OP,       // OR_OP,     1
    "\3NOT",       UO_NOT_OP,      // NOT_OP,    2
    "\4NEAR",      UO_NEAR_OP,     // NEAR_OP,   4
    "\4THRU",      UO_RANGE_OP,    // RANGE_OP,  5
    "\4VFLD",      UO_FIELD_OP,    // FIELD_OP,  7
    "\5DTYPE",     UO_FBRK_OP,     // Breaker operator
};

OPSYM FlatOpSymbolTable[OPERATOR_ENTRY_COUNT] = {
    "\4VFLD",     UO_FIELD_OP,    // FIELD_OP, 7
    "\5DTYPE",    UO_FBRK_OP,        // Breaker operator
    "",            0,                // Filler
    "",            0,                // Filler
    "",            0,                // Filler
    "",            0,                // Filler
    "",            0,                // Filler
};

PUBLIC HRESULT PASCAL NEAR OrHandler(LPQT, _LPQTNODE, LPITOPIC, LPV, int);
PUBLIC HRESULT PASCAL NEAR AndHandler(LPQT, _LPQTNODE, LPITOPIC, LPV, int);
PUBLIC HRESULT PASCAL NEAR NotHandler(LPQT, _LPQTNODE, LPITOPIC, LPV, int);
PUBLIC HRESULT PASCAL NEAR NearHandler(LPQT, _LPQTNODE, LPITOPIC, LPV, int);
PUBLIC HRESULT PASCAL NEAR PhraseHandler(LPQT, _LPQTNODE, LPITOPIC, LPV, int);
PUBLIC VOID PASCAL NEAR NearHandlerCleanUp (LPQT, _LPQTNODE);


FNHANDLER HandlerFuncTable[] = {
    AndHandler,
    OrHandler,
    NotHandler,
    PhraseHandler,
    NearHandler,
    NULL,
};

WORD OperatorAttributeTable[] = {
    BINARY_OP | COMMUTATIVE | ZERO,                             // AND_OP
    BINARY_OP | COMMUTATIVE | ASSOCIATIVE | ZERO,   // OR_OP
    BINARY_OP,                                      // NOT_OP
    BINARY_OP,                                      // PHRASE_OP
    BINARY_OP | COMMUTATIVE,                        // NEAR_OP
    BINARY_OP,                                      // RANGE_OP
    UNARY_OP,                                       // GROUP_OP
    UNARY_OP,                                       // FIELD_OP
};


/*************************************************************************
 *
 *                           API FUNCTIONS
 *      Those functions should be exported in a .DEF file
 *************************************************************************/
PUBLIC LPOPTAB EXPORT_API PASCAL FAR MVOpTableLoad (LSZ, PHRESULT);
PUBLIC VOID EXPORT_API PASCAL FAR MVOpTableDispose (LPOPTAB);
PUBLIC HRESULT EXPORT_API PASCAL FAR MVOpTableFileBuild(HFPB, LPOPTAB, LSZ);
PUBLIC LPOPTAB EXPORT_API FAR PASCAL MVOpTableIndexLoad(HANDLE, LSZ, PHRESULT);


/*************************************************************************
 *
 *                        INTERNAL PRIVATE FUNCTIONS
 *      All of them should be declared near
 *************************************************************************/
PRIVATE VOID PASCAL NEAR StripCRLF (LPB, WORD);
PRIVATE HRESULT PASCAL NEAR GetOperator (LPB FAR *, LSZ, _LPOPTAB);
PRIVATE VOID PASCAL NEAR GetWord (LSZ FAR *, LST);
PRIVATE HRESULT PASCAL NEAR OperatorAdd (LST, int, _LPOPTAB);
PRIVATE WORD PASCAL NEAR OperatorFind (LST, LPOPSYM, int);
PRIVATE VOID PASCAL NEAR OpSymTabInit(LPOPSYM, LPB, WORD);


/*************************************************************************
 *      @doc    INTERNAL
 *
 *      @func   VOID PASCAL NEAR | GetWord |
 *              This function will scan and get a word from the input buffer
 *
 *      @parm   LSZ FAR | *lplszBuf |
 *              Pointer to input buffer. The content will be updated on exit
 *
 *      @parm   LST | lstWord |
 *              Buffer to received parsed word
 *************************************************************************/
PRIVATE VOID PASCAL NEAR GetWord (LSZ FAR *lplszBuf, LST lstWord)
{
    LST  lstWordStart;
    LSZ  lszBuf = *lplszBuf;

    /* Remember the beginning of the word */
    lstWordStart = lstWord++;

    /* Skip all beginning blanks */
    while (*lszBuf == ' ')
	lszBuf++;

    /* Now keep accumulating the word's characters */
    for (;;) {
	switch (*lszBuf) {
	    case 0:
	    case ' ':
		goto exit0;

	    case '/':
		if (*(lszBuf + 1) == '/') { 
		    /* Skip the inline comment */
		    while (*lszBuf)
			lszBuf++;
		    goto exit0;
		}

	    default:
		*lstWord++ = *lszBuf++;
	}
    }

exit0:
    *lplszBuf = lszBuf;
    *lstWordStart = (BYTE)(lstWord - lstWordStart - 1);
}

/*************************************************************************
 *      @doc    INTERNAL
 *
 *      @func   WORD PASCAL NEAR | OperatorFind |
 *              Check to see if a word is an US operator. If it is, then return
 *              the entry index into the US operator table
 *
 *      @parm   LST | lstWord |
 *              Word to be checked
 *
 *      @parm   LPOPSYM | lpOpSym |
 *              Pointer to operator synbol table to be checked
 *
 *      @parm   int | cEntries |
 *              Number of entries in the table
 *
 *      @rdesc  If found, return the index of that enry, -1 otherwise
 *************************************************************************/
PRIVATE WORD PASCAL NEAR OperatorFind (LST lstWord, LPOPSYM lpOpSym,
    int cEntries)
{
    WORD wLen;
    int i;

    for (i = 0; i < cEntries; i++)
    {
	if ((wLen = lpOpSym->OpName[0]) &&
	    StrNoCaseCmp (lstWord + 1, lpOpSym->OpName + 1, wLen) == 0)
	{

	    /* Match! return the index of the operator */

	    return (WORD) i;
	}
	lpOpSym++;
    }
    return (WORD)-1;
}

/*************************************************************************
 *      @doc    INTERNAL
 *
 *      @func   VOID PASCAL NEAR | StripCRLF |
 *              This function will change all CR, LF in the input buffer into
 *              0, all tabs into blank
 *
 *      @parm   LPB | lpbBuf |
 *              Input buffer
 *
 *      @parm   WORD | BufSize |
 *              Length of the buffer
 *************************************************************************/
PRIVATE VOID PASCAL NEAR StripCRLF (LPB lpbBuf, WORD BufSize)
{
    for (; BufSize > 0; BufSize --)
    {
	switch (*lpbBuf)
	{
	    case RETURN:
	    case NEWLINE:
		*lpbBuf = 0;
		break;
	    case '\t':
		*lpbBuf = ' ';
		break;
	}
	lpbBuf++;
    }
}




/************************************************************************
 *
 *                      OPERATOR TABLE SUPPORT
 *
 ************************************************************************/

/*************************************************************************
 *      @doc API INDEX RETRIEVAL
 *
 *      @func int FAR PASCAL | MVOpTableLoad |
 *              Read a operator list from an external file. 
 *
 *      @parm LSZ | lszOpfile |
 *              Operator list filename
 *
 *      @parm PHRESULT | phr |
 *              Pointer to error buffer.
 *
 *      @rdesc  Pointer to new operator table is succeeded, NULL otherwise
 *************************************************************************/
PUBLIC LPOPTAB EXPORT_API PASCAL FAR MVOpTableLoad (LSZ lszOpFile, PHRESULT phr)
{
    HFILE   hFile;                  /* handle of operator file */
    _LPOPTAB lpOpTabStruct; /* Pointer to Optab structure */
    DWORD   dwFileSize;             /* Operator filesize */
    HANDLE  hBuf;                   /* Handle to input buffer */
    BYTE    lstWord[CB_MAX_WORD_LEN];
    LPB     lpbInBuf;               /* Pointer to input buffer */
    LPB     lpbBufLimit;    /* Pointer to input buffer end */
    HANDLE  hOpTab;                 /* Handle to OpTable structure */
    HRESULT     fRet = E_FAIL;
    int     i;                              /* Scratch variable */

    /* Sanity check */
    if (lszOpFile == NULL) {
	SetErrCode (phr, E_INVALIDARG);
	return NULL;
    }

    lpOpTabStruct = NULL; /* Default return value */

    /* Open the operator file */
    if ((hFile = _lopen (lszOpFile, READ)) == HFILE_ERROR) {
	SetErrCode (phr, E_NOTEXIST);
	return NULL;
    }

    /* Get the file size to determine the size of the buffer. I
     * expect the file size to be less than 500 bytes, since it should
     * only content operators and their substitutes. I arbitrarily
     * set the maximum file size to be 0xfffe
     */
    if ((dwFileSize = _llseek (hFile, 0L, 2)) == HFILE_ERROR) {
	fRet = SetErrCode(phr, E_FILESEEK);
exit00:
	
	_lclose(hFile); // Error not checked since read only
	if (fRet != S_OK && hOpTab) {
	    /* Free the structure */
	    MVOpTableDispose(lpOpTabStruct);
	    lpOpTabStruct = NULL;
	}
	return (LPOPTAB)lpOpTabStruct;
    }

    if (dwFileSize == 0 || dwFileSize > 0xfffe) {
	/* The file is too large, something must be wrong */
	fRet = SetErrCode (phr, E_BADFORMAT);
	goto exit00;
    }

    /* Allocate a buffer for the input stream */
    if ((hBuf = _GLOBALALLOC(DLLGMEM, dwFileSize + 1)) == NULL) {
	fRet = SetErrCode (phr, E_OUTOFMEMORY);
	goto exit00;
    }
    lpbInBuf = (LPB)_GLOBALLOCK(hBuf);

    /* Allocate an operator table structure */
    if ((hOpTab = _GLOBALALLOC(DLLGMEM_ZEROINIT, sizeof(OPTABLE)
	+ OPTABLE_SIZE)) == NULL) {
	fRet = SetErrCode (phr, E_OUTOFMEMORY);
exit01:
	_GLOBALUNLOCK(hBuf);
	_GLOBALFREE(hBuf);
	goto exit00;
    }

    /* Initialize all the fields. All unmentioned fields should be 0 */
    lpOpTabStruct = (_LPOPTAB)_GLOBALLOCK(hOpTab);
    lpOpTabStruct->cbLeft = lpOpTabStruct->wsize = OPTABLE_SIZE;
    lpOpTabStruct->lpbOptable = (LPB)(lpOpTabStruct) + sizeof(OPTABLE);
    lpOpTabStruct->hStruct = hOpTab;

    /* Fill up the buffer */
    if (_llseek (hFile, 0L, 0) == HFILE_ERROR) {
	fRet = SetErrCode(phr, E_FILESEEK);
	goto exit01;
    }

    if (_lread(hFile, lpbInBuf, (WORD)dwFileSize) != (WORD)dwFileSize) {
	fRet = SetErrCode (phr, E_FILEREAD);
	goto exit01;
    }

    /* Zero-terminated the buffer */
    *(lpbBufLimit = &lpbInBuf[(WORD)dwFileSize]) = 0;

    /* Change all CR-LF into 0 for parsing */
    StripCRLF (lpbInBuf, (WORD)dwFileSize);

    /* Extract the operators, doing it line by line */

    while (lpbInBuf < lpbBufLimit) {
	if (*lpbInBuf == 0) {
	    /* Skip the remains of the old line */
	    lpbInBuf++;
	    continue;
	}

	if ((fRet = GetOperator(&lpbInBuf, lstWord,
	    lpOpTabStruct)) != S_OK) {
	    SetErrCode (phr, fRet);
	    goto exit01;
	}
    }

    /* Go through the default operator table and add all the
     * remaining operators */
    for (i = 0, lpbInBuf = lpOpTabStruct->fFlag; i < OPERATOR_ENTRY_COUNT;
	lpbInBuf++, i++) {
	if ((*lpbInBuf & OP_PROCESSED) == 0) {
	    /* This operator has no equivalent */
	    if ((fRet = OperatorAdd (OperatorSymbolTable[i].OpName,
		OperatorSymbolTable[i].OpVal, lpOpTabStruct)) != S_OK) {
		SetErrCode (phr, fRet);
		goto exit01;
	    }
	}
    }

    /* Re-adjust the filesize */
    lpOpTabStruct->wsize -= lpOpTabStruct->cbLeft;
    lpOpTabStruct->cbLeft = 0;;

    /* Allocate a operator symbol table */
    if ((lpOpTabStruct->hOpSym = _GLOBALALLOC(DLLGMEM_ZEROINIT,
	(lpOpTabStruct->cEntry + 1) * sizeof(OPSYM))) == NULL) {
	fRet = SetErrCode (phr, E_OUTOFMEMORY);
	goto exit01;
    }
    lpOpTabStruct->lpOpsymTab = (LPOPSYM)_GLOBALLOCK(lpOpTabStruct->hOpSym);
    OpSymTabInit(lpOpTabStruct->lpOpsymTab, lpOpTabStruct->lpbOptable,
	lpOpTabStruct->cEntry);
    fRet = S_OK;
    goto exit01;
}

/*************************************************************************
 *      @doc    API INDEX
 *
 *      @func HRESULT PASCAL FAR | MVOpTableFileBuild |
 *              Incorporate the Operator word list into the system file
 *
 *      @parm   HFPB | hpfbSysFile |
 *              Handle to system file. It is non-zero, then the system file is
 *              already open, else the function will open the system file
 *
 *      @parm _LPOPTAB | lpOptab |
 *              Pointer to operator structure
 *
 *      @parm LSZ | lszFilename |
 *              If hpfbSysFile is non-zero, this is the name of the Operator's
 *              subfile else this is the combined filename with the format
 *              "dos_filename[!Operator_filename]"
 *              If the subfile's name is not specified, the default Operator's file
 *              name will be used. The '!' is not part of the subfile's name
 *
 *      @rdesc S_OK if succeeded, or other errors
 *************************************************************************/
PUBLIC HRESULT EXPORT_API PASCAL FAR MVOpTableFileBuild (HFPB hfpbSysFile,
    _LPOPTAB lpOpTab, LSZ lszFilename)
{
    HFPB hfpbOp;                    // Pointer to final optab file 
    HRESULT fRet = E_FAIL;
    OPTAB_HDR OpTab_hdr;
    BYTE Dummy[OPTAB_HDR_SIZE]; // Dummy buffer to write 0
    ERRB errb;


    /* Sanity check */
    if (lpOpTab == NULL)
	return E_INVALIDARG;

    if (lpOpTab->cEntry == 0)
	return E_FAIL; /* Nothing to build */


    if ((hfpbOp = FileCreate(hfpbSysFile, lszFilename,
		hfpbSysFile ? FS_SUBFILE : REGULAR_FILE, &errb)) == 0)
	return errb;

    /* Write out the stop file header */
    OpTab_hdr.FileStamp = OPTAB_STAMP;
    OpTab_hdr.version = VERCURRENT;
    OpTab_hdr.wSize = lpOpTab->wsize;
    OpTab_hdr.cEntry = lpOpTab->cEntry;

    MEMSET(Dummy, (BYTE)0, OPTAB_HDR_SIZE);

    /* Write all zero to the header */
    if (FileSeekWrite(hfpbOp, Dummy, foNil, OPTAB_HDR_SIZE,
	&errb) != OPTAB_HDR_SIZE)
    {
	fRet = errb;
exit01:
	FileClose(hfpbOp);
	
	return fRet;
    }

    /* Write the file header */
    if (FileSeekWrite(hfpbOp, &OpTab_hdr, foNil, sizeof(OPTAB_HDR),
	&errb) != sizeof(OPTAB_HDR))
    {
	fRet = errb;
	goto exit01;
    }


    /* Write out the buffer */
    if (FileSeekWrite(hfpbOp, lpOpTab->lpbOptable, MakeFo(OPTAB_HDR_SIZE,0),
	lpOpTab->wsize,&errb) != (LONG)lpOpTab->wsize)
    {
	fRet = errb;
	goto exit01;
    }

    fRet = S_OK;
    goto exit01;
}

/*************************************************************************
 *      @doc    INTERNAL
 *
 *      @func   HRESULT PASCAL NEAR | GetOperator |
 *              This function will extract all operators belonged to the same line
 *              The format of the line is:
 *                      Op  [replacing Op] [replacing Op] ...
 *              where the first Op is an US operator. All replacing Ops are 
 *              the US Op's equivalent
 *
 *      @parm   LPB FAR * | lplszBuf |
 *              Pointer to a buffer. The content of this pointer will be updated
 *
 *      @parm   LSZ | lstWord |
 *              Buffer to received parsed words
 *
 *      @parm   _LPOPTAB | lpOpTabStruct |
 *              Pointer to OpTab structure
 *
 *      @rdesc  S_OK if succeeded, other errors otherwise
 *************************************************************************/
PRIVATE HRESULT PASCAL NEAR GetOperator (LPB FAR *lplszBuf, LSZ lstWord,
    _LPOPTAB lpOpTabStruct)
{
    LSZ  lszBuf = *lplszBuf;
    WORD OpIndex;
    HRESULT  fRet;

    /* Get the first US operator */
    GetWord(lplszBuf, lstWord);

    if (*lstWord == 0) /* There is no US operator in this line */
	return S_OK;

    /* Look for the operator in the default table */
    if ((OpIndex = OperatorFind(lstWord, OperatorSymbolTable,
	OPERATOR_ENTRY_COUNT)) == (WORD)-1)
	return E_BADFORMAT;

    /* Set flag to mark that we already have an equivalent operator.
     * Set the flag early has an special effect. This can turn off
     * the recognition of an operator in case there is no equivalent
     * operator. Ex:
     *      AND
     * Since there is no equivalent operator, no new entry is added.
     * And since the flag is set, the US entry will not be added, ie.
     * AND now will be treated as regular word
     */
    lpOpTabStruct->fFlag[OpIndex] |= OP_PROCESSED;

    for (;;) {
	/* Insert the new operator into the operator table. There
	 * is no check for duplicate operators */
	GetWord(lplszBuf, lstWord);
	if (*lstWord == 0)
	    break;
	if ((fRet = OperatorAdd (lstWord,
	    OperatorSymbolTable[OpIndex].OpVal,
	    lpOpTabStruct)) != S_OK) {
	    return fRet;
	}
    }
    return S_OK;
}

/*************************************************************************
 *      @doc    INTERNAL
 *
 *      @func   HRESULT PASCAL NEAR | OperatorAdd |
 *              Add an operator symbol and its value into the operator symbol
 *              table
 *
 *      @parm   LST | lstWord |
 *              Buffer contining the operator symbol
 *
 *      @parm   int | OpVal | 
 *              Value of the operator
 *
 *      @parm   _LPOPTAB | lpOpTabStruct |
 *              Pointer to operator table structure
 *
 *      @rdesc  S_OK if succeeded, other errors otherwise
 *************************************************************************/
PRIVATE HRESULT PASCAL NEAR OperatorAdd (LST lstWord, int OpVal, 
    _LPOPTAB lpOpTabStruct)
{
    HANDLE hBuf;    /* Handle to new reallocated structure */
    WORD size;              /* Extra bytes needed */
    LST lstBuf;             /* Scratch buffer pointer */
    WORD i;                 /* Scratch index variable */

    /* Ensure that we have enough room. We need
     *   - 1 byte for the word length
     *   - *lstWord byte for the word
     *   - 2 byte for Operator value
     */
    if (lpOpTabStruct->cbLeft < (size = *lstWord + 3)) {
	_GLOBALUNLOCK(hBuf = lpOpTabStruct->hStruct);
	if ((hBuf = _GLOBALREALLOC(hBuf, 
	    sizeof(OPTABLE) + lpOpTabStruct->wsize + size,
	    DLLGMEM_ZEROINIT)) == NULL)  
	    return E_OUTOFMEMORY;
	lpOpTabStruct = (_LPOPTAB)_GLOBALLOCK(hBuf);

	/* Re-initialize all the fields */

	lpOpTabStruct->hStruct = hBuf;
	lpOpTabStruct->cbLeft += size;
	lpOpTabStruct->wsize += size;
	lpOpTabStruct->lpbOptable = (LPB)(lpOpTabStruct) + sizeof(OPTABLE);
    }

    /* Copy the terms */
    lstBuf = lpOpTabStruct->lpbOptable + lpOpTabStruct->wsize -
	lpOpTabStruct->cbLeft;
    for (i = *lstWord + 1; i > 0; i--)
	*lstBuf++ = *lstWord++;
    *(LPW)lstBuf = (WORD) OpVal;
    lpOpTabStruct->cbLeft -= size;
    lpOpTabStruct->cEntry ++;
    return S_OK;
}


/*************************************************************************
 *      @doc    API INDEX RETRIEVAL
 *
 *      @func   VOID EXPORT_API PASCAL FAR | MVOpTableDispose |
 *              Release all the memory associated with the Operator table
 *
 *      @parm   _LPOPTAB | lpOpTabStruct |
 *              Pointer to an operator table structure returned by OpTableLoad()
 *              or OpTableIndexLoad()
 *************************************************************************/
PUBLIC VOID EXPORT_API PASCAL FAR MVOpTableDispose (_LPOPTAB lpOpTabStruct)
{
    HANDLE hTmp;

    if (lpOpTabStruct == NULL)
	return;

    /* Free the symbol table */
    if (hTmp = lpOpTabStruct->hOpSym) {
	FreeHandle(hTmp);
    }

    /* Free the buffer */
    if (hTmp = lpOpTabStruct->hOpTab) {
	FreeHandle(hTmp);
    }

    /* Free the structure */
    if (hTmp = lpOpTabStruct->hStruct) {
	FreeHandle(hTmp);
    }
}

/*************************************************************************
 *      @doc    API RETRIEVAL
 *
 *      @func   _LPOPTAB FAR PASCAL | MVOpTableIndexLoad |
 *              This function will load a operator table from a system file.
 *
 *      @parm   HANDLE | hfpbSysFile |
 *              If non-zero, this is the handle of an already opened system file
 *
 *      @parm   LSZ | lszFilename |
 *              If hpfbSysFile is non-zero, this is the name of the OpTab's subfile
 *              else this is the combined filename with the format
 *              "dos_filename[OpTab_filename]"
 *              If the subfile's name is not specified, the default OpTab's file
 *              name will be used
 *
 *      @parm   PHRESULT | phr |
 *              Pointer to error buffer
 *
 *      @rdesc  If succeeded, the function will return a pointer the loaded
 *              OpTab, else NULL. The error buffer will contain information
 *              about the cause of the failure
 *
 *      @comm   About ligature table, there are some assumptions:
 *              If hLigature == 0 {
 *                      if (wcLigature == 0)
 *                              There is no ligature table
 *                      else
 *                              We use the default ligature table. There is no need
 *                              to write out the table data
 *              }
 *              else
 *                      The author provides a ligature table.
 *************************************************************************/
PUBLIC LPOPTAB EXPORT_API FAR PASCAL MVOpTableIndexLoad(HANDLE hfpbSysFile,
    LSZ lszFilename, PHRESULT phr)
{
    HANDLE hfpbOpTabFile;
    OPTAB_HDR FAR *lpOpTabHdr;
    OPTAB_HDR OpTabHdr;
    _LPOPTAB        lpOpTabStruct = 0;
    DWORD   dwSize;
    HANDLE  hOpTab;
    WORD    OpTabBufSize;
    lpOpTabHdr = &OpTabHdr;


    /* Open subfile, (and system file if necessary) */
    if ((hfpbOpTabFile = (HANDLE)FileOpen(hfpbSysFile,
	lszFilename, hfpbSysFile ? FS_SUBFILE : REGULAR_FILE,
		READ, phr)) == 0) {
exit0:
	return (LPOPTAB)lpOpTabStruct;
    }

    /* Read in the header file, and make sure that is a OpTab file */
    if (FileSeekRead(hfpbOpTabFile, (LPV)lpOpTabHdr, foNil,
	sizeof(OPTAB_HDR), phr) != sizeof(OPTAB_HDR)) {
exit1:
	/* Close the subfile */
	FileClose(hfpbOpTabFile);

	/* Close the system file if we open it, the handle will be
	 * released in the process */

	goto exit0;
    }

    /* Check to see if the data read in is valid */
    if (lpOpTabHdr->FileStamp !=  OPTAB_STAMP ||    // File stamp
	lpOpTabHdr->version != VERCURRENT) {            // Version number
	SetErrCode(phr, E_BADVERSION);
	goto exit1;
    }

    /* Allocate memory for the operator table, which includes:
     *    - Operator table buffer
     *    - Operator symbol table
     *    - The structure itself
     * Currently, we can combine all the memory togother under the
     * assumption that the table will be small enough (< 64K)
     */
    dwSize = lpOpTabHdr->wSize + (lpOpTabHdr->cEntry + 1) * sizeof (OPSYM) +
	sizeof(OPTABLE);
    if (dwSize > 0xffff || (hOpTab = _GLOBALALLOC(GMEM_MOVEABLE | GMEM_ZEROINIT,
	dwSize)) == 0) {
	SetErrCode (phr, E_OUTOFMEMORY);
	goto exit1;
    }

    lpOpTabStruct = (_LPOPTAB)_GLOBALLOCK(hOpTab);

    /* Initialize the fields of the structure */
    lpOpTabStruct->hStruct = hOpTab;
    lpOpTabStruct->cEntry = lpOpTabHdr->cEntry;
    OpTabBufSize = lpOpTabStruct->wsize = lpOpTabHdr->wSize;
    lpOpTabStruct->lpbOptable = (LPB)lpOpTabStruct + sizeof(OPTABLE);
    lpOpTabStruct->lpOpsymTab = (LPOPSYM)(lpOpTabStruct->lpbOptable +
	OpTabBufSize);

    /* Read in the operator table data */
    if (FileSeekRead(hfpbOpTabFile,
	(LPV)lpOpTabStruct->lpbOptable, MakeFo(OPTAB_HDR_SIZE,0),
	OpTabBufSize, phr) != OpTabBufSize) {
	SetErrCode(phr, E_FILEREAD);
	MVOpTableDispose(lpOpTabStruct);
	lpOpTabStruct = NULL;
	goto exit1;
    }

    /* Initialize the symbol table */
    OpSymTabInit(lpOpTabStruct->lpOpsymTab, lpOpTabStruct->lpbOptable,
	lpOpTabStruct->cEntry);
    goto exit1;
}

/*************************************************************************
 *      @doc    API RETRIEVAL
 *
 *      @func   _LPOPTAB FAR PASCAL | MVOpTableGetDefault |
 *              This function will load the default US operator table
 *
 *
 *      @rdesc  If succeeded, the function will return a pointer the loaded
 *              OpTab, else NULL if out of memory
 *************************************************************************/
PUBLIC LPOPTAB EXPORT_API FAR PASCAL MVOpTableGetDefault(PHRESULT phr)
{
    _LPOPTAB        lpOpTabStruct = 0;
    HANDLE  hOpTab;


    /* Allocate memory for the operator table, which includes:
     *    - Operator symbol table
     *    - The structure itself
     */
    if ((hOpTab = _GLOBALALLOC(DLLGMEM_ZEROINIT, sizeof(OPTABLE))) == 0) {
	SetErrCode (phr, E_OUTOFMEMORY);
	return NULL;
    }

    lpOpTabStruct = (_LPOPTAB)_GLOBALLOCK(hOpTab);

    /* Initialize the fields of the structure */
    lpOpTabStruct->hStruct = hOpTab;
    lpOpTabStruct->cEntry = OPERATOR_ENTRY_COUNT;
    lpOpTabStruct->lpbOptable = NULL;
    lpOpTabStruct->lpOpsymTab = (LPOPSYM)(OperatorSymbolTable);

    return (LPOPTAB)lpOpTabStruct;
}

PRIVATE VOID PASCAL NEAR OpSymTabInit(LPOPSYM lpOpSymTab,
    LPB lpbOpTable, WORD cEntry)
{
    for (; cEntry > 0; cEntry--) {
	lpOpSymTab->OpName = lpbOpTable;
	lpbOpTable += *lpbOpTable + sizeof(BYTE);
	lpOpSymTab->OpVal = GETWORD(lpbOpTable);
	lpbOpTable += sizeof(unsigned short);
	lpOpSymTab++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\qtparse.c ===
/************************************************************************y
*                                                                        *
*  QTPARSE.C                                                             *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   This module contains the functions needed to build a binary          *
*   query tree used in search. It is specific to parsing only. All       *
*   functions' purpose is to build and optimize the query tree before    *
*   it is used for search.                                               *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
*************************************************************************/

#include <mvopsys.h>
#include <mem.h>
#include <memory.h>
#ifdef DOS_ONLY
#include <stdio.h>
#include <assert.h>
#endif
#include <mvsearch.h>
#include "common.h"
#include "search.h"

int Debug = 1;
#ifdef _DEBUG
static BYTE NEAR s_aszModule[] = __FILE__;	/* Used by error return functions.*/
#endif

/*************************************************************************
 *                          EXTERNAL VARIABLES
 *  All those variables must be read only
 *************************************************************************/

extern FNHANDLER HandlerFuncTable[];// Pointer to operator handlers
extern WORD OperatorAttributeTable[]; 
extern OPSYM OperatorSymbolTable[]; 

/*************************************************************************
 *
 *                         INTERNAL GLOBAL FUNCTIONS
 *
 *************************************************************************/

PUBLIC LPQT PASCAL NEAR QueryTreeAlloc(void);
PUBLIC HRESULT PASCAL NEAR QueryTreeAddToken (_LPQT, int, LST, DWORD, BOOL);
PUBLIC LPQT PASCAL NEAR QueryTreeBuild (LPQI);

#if defined(_DEBUG) && DOS_ONLY
PUBLIC HRESULT PASCAL NEAR PrintTree (_LPQTNODE ,
    HRESULT (PASCAL NEAR *)(BYTE FAR *));
PUBLIC VOID PASCAL NEAR PrintStr (char FAR *);
PUBLIC HRESULT PASCAL FAR PrintList(LPQT);
#endif  // DOS_ONLY && _DEBUG
/*************************************************************************
 *
 *                    INTERNAL PRIVATE FUNCTIONS
 *  All of them should be declared near
 *************************************************************************/

#ifndef SIMILARITY
PUBLIC STRING_TOKEN FAR *PASCAL AllocWord(_LPQT lpQueryTree, LST lstWord);
#else
PRIVATE STRING_TOKEN FAR *PASCAL NEAR AllocWord(_LPQT lpQueryTree, LST lstWord);
#endif

PRIVATE HRESULT PASCAL NEAR CheckTree (_LPQTNODE, PHRESULT);
PRIVATE HRESULT PASCAL NEAR DoNullTermOpt (_LPQTNODE );
PRIVATE HRESULT NEAR DoTermTermOpt (_LPQTNODE);
PRIVATE HRESULT NEAR PASCAL DoAssociativeOpt (_LPQTNODE );
PRIVATE HRESULT PASCAL NEAR TreeBuild(_LPQT);
PRIVATE HRESULT PASCAL NEAR QueryTreeOptim (_LPQTNODE );
PRIVATE HRESULT PASCAL NEAR PrintQueryNode (BYTE FAR *);
PRIVATE HRESULT PASCAL NEAR PrintTopicListNode (LPQT, BYTE FAR *);
PRIVATE HRESULT PASCAL NEAR PrintOccurNode(LPQT, OCCURENCE FAR *);
PRIVATE VOID PASCAL NEAR PrintOperator (int);
PRIVATE HRESULT PASCAL NEAR RemoveRedundancy (_LPQTNODE, int);
PRIVATE VOID PASCAL NEAR GetTreeDepth (_LPQTNODE lpQtNode, int FAR * MaxLevel,
    int Level);

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   LPQT PASCAL FAR | QueryTreeAlloc |
 *      The function allocates a query tree structure and initializes
 *      different variables needed to build the query tree. 
 *
 *  @rdesc  Pointer to query tree structure if succeeded, NULL if
 *      out-of-memory
 *************************************************************************/
PUBLIC LPQT PASCAL NEAR QueryTreeAlloc()
{
    _LPQT   lpQueryTree;

    /* Allocate query buffer */
    if ((lpQueryTree =
        (_LPQT)GLOBALLOCKEDSTRUCTMEMALLOC(sizeof(QTREE))) == NULL)
        return NULL;

    /* Allocate room for string block */

    if ((lpQueryTree->lpStringBlock = BlockInitiate (STRING_BLOCK_SIZE,
        0, 0, 0)) == NULL)
    {
exit0:
        GlobalLockedStructMemFree((LPV)lpQueryTree);
        return NULL;
    }

    /* Allocate room for query tree nodes */
    if ((lpQueryTree->lpNodeBlock = BlockInitiate (QUERY_BLOCK_SIZE,
        sizeof(QTNODE), 0, 0)) == NULL)
    {
exit1:
        BlockFree((LPV)lpQueryTree->lpStringBlock);
        goto exit0;
    }

    /* Allocate room for Topic nodes */
    if ((lpQueryTree->lpTopicMemBlock = BlockInitiate(sizeof(TOPIC_LIST)*
        cTOPIC_PER_BLOCK, sizeof(TOPIC_LIST), 0, 1)) == NULL)
    {

exit2:
        BlockFree((LPV)lpQueryTree->lpNodeBlock);
        goto exit1;
    }

    /* Allocate room for Occurrence nodes */
    if ((lpQueryTree->lpOccMemBlock = BlockInitiate(sizeof(OCCURENCE)*
        cOCC_PER_BLOCK, sizeof(OCCURENCE), 0, 1)) == NULL)
    {
#ifndef SIMILARITY
exit3:
#endif
        BlockFree((LPV)lpQueryTree->lpTopicMemBlock);
        goto exit2;
    }

#ifndef SIMILARITY
    /* Allocate room for word info block */
    if ((lpQueryTree->lpWordInfoBlock = BlockInitiate (sizeof(WORDINFO) 
		* cWordsPerToken, sizeof(WORDINFO), 0, 0)) == NULL)
    {        
		BlockFree((LPV)lpQueryTree->lpOccMemBlock);
        goto exit3;
    }
#endif

    /* Initialize various fields */
    lpQueryTree->cQuery = 0;
    lpQueryTree->lpOccFreeList =
        (LPSLINK)BlockGetLinkedList(lpQueryTree->lpOccMemBlock);
    lpQueryTree->lpTopicFreeList =
        (LPSLINK)BlockGetLinkedList(lpQueryTree->lpTopicMemBlock);
    lpQueryTree->lpStrList = NULL;
    return (LPQT)lpQueryTree;
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   HRESULT FAR PASCAL | QueryTreeAddToken |
 *      This will create a query node from the information, and add it to
 *      the query tree. The input data must be in postfix format
 *
 *  @parm   _LPQT | lpQueryTree |
 *      Pointer to QueryTree
 *
 *  @parm   int | TokenType |
 *      either TERM_TOKEN, or operator value (OR_OP, AND_OP, etc)
 *
 *  @parm   LST | lpWord |
 *      pointer to Pascal string (for TERM_TOKEN)
 *
 *  @parm   DWORD | dwOffset |
 *      Offset from the beginning of the query
 *
 *  @parm   BOOL | fWildChar |
 *      TRUE if the string is terminated with '*'
 *
 *
 *  @rdesc S_OK  if succeeded, else error codes
 *************************************************************************/
PUBLIC HRESULT PASCAL NEAR QueryTreeAddToken (_LPQT lpQueryTree,
    int TokenType, LST pWord, DWORD dwOffset, BOOL fWildChar)
{
    _LPQTNODE lpQtNode;

    if (++lpQueryTree->cQuery == MAX_QUERY_NODE)
        return E_TREETOOBIG;

    /* Allocate the node */
    if ((lpQtNode = BlockGetElement(lpQueryTree->lpNodeBlock)) == NULL)
        return E_OUTOFMEMORY;

    // For future uses      
    lpQtNode->dwMaxTopicId = 0;
    lpQtNode->dwMinTopicId = (DWORD)-1;
            
    if ((QTN_OPVAL(lpQtNode) = (WORD)TokenType) == TERM_TOKEN)
    {
        if ((QTN_TOKEN(lpQtNode) = AllocWord(lpQueryTree, pWord)) == NULL)
            return E_OUTOFMEMORY;
        QTN_NODETYPE(lpQtNode) = TERM_NODE;
        QTN_OPVAL(lpQtNode) = OR_OP;    // For OrHandler()
        QTN_FIELDID(lpQtNode) = lpQueryTree->dwFieldId;
        QTN_GROUP(lpQtNode) = lpQueryTree->lpGroup;
        QTN_DTYPE(lpQtNode) = lpQueryTree->wBrkDtype;
    }
    else if ((QTN_OPVAL(lpQtNode) = (WORD)TokenType) == STOP_OP)
    {
        // erinfox: mark STOPWORD as a STOP_NODE
        QTN_NODETYPE(lpQtNode) = STOP_NODE;
    }
    else
    {
        QTN_NODETYPE(lpQtNode) = OPERATOR_NODE;
        QTN_PARMS(lpQtNode) = (LPV)pWord;
    }
    QTN_OFFSET(lpQtNode) = (WORD)dwOffset;
    QTN_FLAG(lpQtNode)= fWildChar ? WILDCARD_MATCH: EXACT_MATCH;
        

    /* Link the node into the linked list */
    QTN_PREV(lpQtNode) = lpQueryTree->lpTopNode;
    if (lpQueryTree->lpTopNode) 
        QTN_NEXT(lpQueryTree->lpTopNode) = lpQtNode;
    lpQueryTree->lpTopNode = lpQtNode;
    return S_OK;
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   VOID PASCAL NEAR | SetQueryWeight |
 *      The function sets the weights of invidual words in the query
 *      The formula used in the computation is:
 *          weight = 0.5 + 0.5 * wc / maxwc (0.5 < w <= 1)
 *      or with the normalization
 *          weight = 32767 (1 + wc / maxwc) (32767 < w <= 65534)
 *      where:
 *          wc: the word occurrence's count
 *          maxwc: maximum word occurrence's count
 *
 *  @parm   LPQT | lpQueryInfo |
 *      Pointer to QueryInfo struct where globals are
 *
 *************************************************************************/
VOID PASCAL NEAR SetQueryWeight (LPQI lpQueryInfo)
{
    STRING_TOKEN FAR *lpStrList;    /* Pointer to strings table */
    WORD MaxWc;         /* Maximum word count */

    lpStrList = ((_LPQT)lpQueryInfo->lpQueryTree)->lpStrList;

    /* Calculate maxwc */
    for (MaxWc = 1; lpStrList; lpStrList = lpStrList->pNext)
    {
        if (MaxWc < lpStrList->cUsed)
            MaxWc = lpStrList->cUsed;
    }

    /* Calculate invidual word weights */
    for (lpStrList = ((_LPQT)lpQueryInfo->lpQueryTree)->lpStrList;
        lpStrList; lpStrList = lpStrList->pNext) {
        lpStrList->wWeight = 32767 + (32767/MaxWc)*lpStrList->cUsed;
    }
 }

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   LPQT FAR PASCAL | QueryTreeBuild |
 *      The function build a query tree to be used later for the retrieval
 *      process. The input data for it comes from calls of QueryTreeAddToken()
 *
 *  @parm   LPQT | lpQueryInfo |
 *      Pointer to QueryInfo struct where globals are
 *
 *  @rdesc NULL if failed, a pointer to the top of the query tree
 *************************************************************************/
PUBLIC LPQT PASCAL NEAR QueryTreeBuild(LPQI lpQueryInfo)
{
    _LPQT lpQueryTree = lpQueryInfo->lpQueryTree;
    PHRESULT phr = lpQueryInfo->lperrb;
    _LPQTNODE lpTreeTop;

    if (lpQueryTree->cQuery == 0 ||
        ( (lpQueryTree->cQuery == 1) && (lpQueryTree->lpTopNode->OpVal == STOP_OP)) )
    {
        SetErrCode(phr, E_NULLQUERY);
        return NULL;
    }

    /* Set the query words weights */
    SetQueryWeight (lpQueryInfo);

    /* Build the tree */
    TreeBuild (lpQueryTree);
    lpTreeTop = lpQueryTree->lpTopNode;


    if (lpQueryTree->cQuery > 1 && S_OK != CheckTree(lpTreeTop, phr))
    {
        return (NULL);
    }


#if defined(_DEBUG) && DOS_ONLY
    if (Debug)
    {
        printf ("\n*** Tree infix form ***\n");
        PrintTree (lpTreeTop, PrintQueryNode);
        printf ("\n");
    }
#endif  // DOS_ONLY && _DEBUG

    /* Remove all redundant words */
    if (lpQueryTree->fFlag & (ALL_AND | ALL_OR)) 
      while (RemoveRedundancy (lpTreeTop, 0) == S_OK);

    
    /* Keep doing optimization until nothing can't be done anymore */
    while (QueryTreeOptim (lpTreeTop) == S_OK);

#if defined(_DEBUG) && DOS_ONLY
    if (Debug)
    {
        printf ("\n*** Tree infix form after optimization ***\n");
        PrintTree (lpTreeTop, PrintQueryNode);
        printf ("\n");
    }
#endif  // DOS_ONLY && _DEBUG
    return (lpQueryTree);
}

/*************************************************************************
 * @doc  INTERNAL
 *
 * @func HRESULT PASCAL NEAR | RemoveRedundancy |
 *    This function will remove any repeated term in the query for all
 *    OR or all AND queries. This will speed up the search since there is
 *    no need to load the same term again only to throw it away.
 *
 * @parm _LPQTNODE | lpTreeTop |
 *    Top node of the binary tree.
 *
 *  @rdesc  S_OK if some terms get removed, E_FAIL otherwise
 *************************************************************************/
#define  MAX_CHECKED_LEVEL 50   // Maximum traversed tree levels

PRIVATE HRESULT PASCAL NEAR RemoveRedundancy (_LPQTNODE lpTreeTop, int level)
{
   _LPQTNODE lpQtNode;
   
   if (level >= MAX_CHECKED_LEVEL ||   /* Stack overflow */
      QTN_NODETYPE(lpTreeTop) != OPERATOR_NODE)   /* Term node */
      return E_FAIL;

   /* Handle the right tree */
   if (QTN_NODETYPE (lpQtNode = QTN_RIGHT(lpTreeTop)) == OPERATOR_NODE) 
   {
      RemoveRedundancy (lpQtNode, level + 1);
   }
   else if ( (QTN_NODETYPE(lpQtNode) == TERM_NODE) && QTN_TOKEN(lpQtNode)->cUsed > 1)
   {
        /* We don't have to retrieve this node, so we
         * can ignore it. By doing that, we can ignore
         * the operator that accoampanies the node
         */

        /* Update the word count */
        QTN_TOKEN(lpQtNode)->cUsed--;

      *lpTreeTop = *QTN_LEFT(lpTreeTop);
      return S_OK;
   }

   /* Handle the left tree */
   if (QTN_NODETYPE (lpQtNode = QTN_LEFT(lpTreeTop)) == OPERATOR_NODE) 
   {
      RemoveRedundancy (lpQtNode, level + 1);
   }
   else if ((QTN_NODETYPE(lpQtNode) == TERM_NODE) && QTN_TOKEN(lpQtNode)->cUsed > 1)
   {
        /* We don't have to retrieve this node, so we
         * can ignore it. By doing that, we can ignore
         * the operator that accoampanies the node
         */

        /* Update the word count */
        QTN_TOKEN(lpQtNode)->cUsed--;

      *lpTreeTop = *QTN_RIGHT(lpTreeTop);
      return S_OK;
   }
    return E_FAIL;
}

 
/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   STRING_TOKEN FAR *PASCAL NEAR | AllocWord |
 *      Allocate a word memory and structure
 *
 *  @parm   _LPQT | lpQueryTree |
 *      Pointer to query tree structure (for globals)
 *
 *  @parm   LST | lstWord |
 *      Word to be copied
 *
 *  @rdesc  Pointer to structure if succeeded
 *************************************************************************/
#ifndef SIMILARITY
PUBLIC STRING_TOKEN FAR *PASCAL AllocWord(_LPQT lpQueryTree, LST lstWord)
#else
PRIVATE STRING_TOKEN FAR *PASCAL NEAR AllocWord(_LPQT lpQueryTree, LST lstWord)
#endif
{
    STRING_TOKEN FAR *pTmp;

    pTmp = lpQueryTree->lpStrList;
    while (pTmp)
    {
        if (!StringDiff2 (lstWord, pTmp->lpString)) 
        {
            pTmp->cUsed ++;
            return (pTmp);
        }
        pTmp = pTmp->pNext;
    }

    /* The word doesn't exist yet, so create it. Add an extra byte
     * to make it 0's teminated to help WildCardCompare()
     */
    if ((pTmp = (STRING_TOKEN FAR *)BlockCopy (lpQueryTree->lpStringBlock,
        lstWord, *((LPW)lstWord) + 3, sizeof (STRING_TOKEN))) == NULL)
        return NULL;

    /* Set all the fields */
    pTmp->cUsed = 1;
    pTmp->lpString = (char FAR *)pTmp + sizeof(STRING_TOKEN);
#ifndef SIMILARITY
	pTmp->lpwi = NULL;		// List of word data for this token
	pTmp->dwTopicCount = 0;
#endif


    /* Add the word to the string list */
    pTmp->pNext = lpQueryTree->lpStrList;
    lpQueryTree->lpStrList = pTmp;
    return pTmp;
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   PRIVATE PASCAL NEAR | TreeBuild |
 *      Build the infix form tree from the postfix form. 
 *
 *  @parm   _LPQT | lpQueryTree |
 *      Pointer to query tree
 *************************************************************************/
PRIVATE HRESULT PASCAL NEAR TreeBuild (_LPQT lpQueryTree)
{
    _LPQTNODE rgNodeStack[STACK_SIZE];  /* Stack to help the conversion */
    _LPQTNODE lpStackTop = NULL;        /* Pointer to stop of stack */
    int StackTop = -1;                  /* Current stack top index */
    _LPQTNODE lpPrevNode;
    _LPQTNODE lpQtNode;
    int TreeDepth;

#if 0
    /* First optimzation step: Remove all duplicate words for all AND
     * or all OR querys
     */
    if (lpQueryTree->fFlag & (ALL_AND | ALL_OR))
    {
        for (lpQtNode = lpQueryTree->lpTopNode; lpQtNode;
            lpQtNode = lpPrevNode)
        {
            lpPrevNode = QTN_PREV(lpQtNode);

            /* Ignore operator node */
            if (QTN_NODETYPE(lpQtNode) == OPERATOR_NODE) 
                continue;

            /* Check to see if we have to retrieve this node */
            if (QTN_TOKEN(lpQtNode)->cUsed > 1)
            {

                /* We don't have to retrieve this node, so we
                 * can ignore it. By doing that, we can ignore
                 * the operator that accoampanies the node
                 */

                /* Update the word count */
                QTN_TOKEN(lpQtNode)->cUsed--;

                /* Remove the two nodes */
                if ((lpStartQtNode = QTN_NEXT(QTN_NEXT(lpQtNode))) == NULL)
                {
                    /* Remove the two beginning nodes by just
                     * resetting the starting node
                     */
                    lpQueryTree->lpTopNode = lpPrevNode;
                    QTN_NEXT(lpPrevNode) = NULL;
                }
                else
                {
                    QTN_PREV(lpStartQtNode) = lpPrevNode;
                    QTN_NEXT(lpPrevNode) = lpStartQtNode;
                }

                /* Update number of query nodes */
                lpQueryTree->cQuery -= 2;
            }
        }
    }
#endif


    for (lpQtNode = lpQueryTree->lpTopNode; lpQtNode;
        lpQtNode = lpPrevNode)
    {
        lpPrevNode = QTN_PREV(lpQtNode);

        QTN_RIGHT(lpQtNode) = QTN_LEFT(lpQtNode) = NULL;

        if (QTN_NODETYPE(lpQtNode) == OPERATOR_NODE)
        {
            /* Push the operator onto the stack */
            if (lpStackTop)
            {
                if (QTN_RIGHT(lpStackTop) == NULL)
                    QTN_RIGHT(lpStackTop) = lpQtNode;
                else
                {
                    QTN_LEFT(lpStackTop) = lpQtNode;
                    StackTop--;
                }
            }
            lpStackTop = rgNodeStack[++StackTop] = lpQtNode;
        }
        else
        {
            /* Handle term node. lpStackTop points to the operator node */

            if (lpStackTop)
            {
                if (QTN_RIGHT(lpStackTop) == NULL)
                    QTN_RIGHT(lpStackTop) = lpQtNode;
                else
                {
                    QTN_LEFT(lpStackTop) = lpQtNode;
                    if (--StackTop < 0)
                        lpStackTop = NULL;
                    else
                        lpStackTop = rgNodeStack[StackTop];
                }
            }
        }
    }

    /* Calculate the tree depth. This is helpful when we resolve the 
     * tree by avoiding a too deep recursion level.
     */
    TreeDepth = 0;
#if 0
    for (lpQtNode = lpQueryTree->lpTopNode; lpQtNode;
        lpQtNode = QTN_LEFT(lpQtNode))
    {
        TreeDepth ++;
    }
#else
    GetTreeDepth (lpQueryTree->lpTopNode, &TreeDepth, 1);
#endif
    lpQueryTree->TreeDepth = (TreeDepth < STACK_SIZE) ? STACK_SIZE : TreeDepth;
    return S_OK;
}

PRIVATE VOID PASCAL NEAR GetTreeDepth (_LPQTNODE lpQtNode, int FAR * pMaxLevel,
    int Level)
{
    if (QTN_LEFT(lpQtNode))
        GetTreeDepth (QTN_LEFT(lpQtNode), pMaxLevel, Level + 1);
    if (Level > *pMaxLevel)
        *pMaxLevel = Level;

    if (QTN_RIGHT(lpQtNode))
        GetTreeDepth (QTN_RIGHT(lpQtNode), pMaxLevel, Level + 1);
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   HRESULT PASCAL NEAR | QueryTreeOptim |
 *      Do optimizations to the query tree. The optimization is done
 *      based on the characteristics of the operators, such as
 *      COMMUTATIVITY, etc
 *
 *  @parm   _LPQTNODE | lpQtNode |
 *      Pointer to the top of the binary query tree
 *
 *  @rdesc  S_OK, if some optimization has been performed, E_FAIL
 *      otherwise
 *************************************************************************/
PRIVATE HRESULT PASCAL NEAR QueryTreeOptim (_LPQTNODE lpQtNode)
{
    register _LPQTNODE lpLeft;
    register _LPQTNODE lpRight;
    int OpVal;
    HRESULT fRet = E_FAIL;

    if (QTN_NODETYPE(lpQtNode) == NULL_NODE ||
        QTN_NODETYPE(lpQtNode) == TERM_NODE)
        return E_FAIL;

    /* Handle unary operator */
    if (OperatorAttributeTable[OpVal = QTN_OPVAL(lpQtNode)] & UNARY_OP) 
        return E_FAIL;

    lpLeft = QTN_LEFT(lpQtNode);
    lpRight = QTN_RIGHT(lpQtNode);

    // erinfox:
    // Look for STOP word nodes. If the operator is AND or NEAR,
    // change it to OR. Set node to NULL for all operators.
    // (X AND STOPWORD) becomes (X OR NULL) so it will evaluate to X.
    //
    if (QTN_NODETYPE(lpLeft) == STOP_NODE)
    {
        if (AND_OP == OpVal || NEAR_OP == OpVal)
            lpQtNode->OpVal = OR_OP;

        QTN_NODETYPE(lpLeft) = NULL_NODE;
    }
    else if (QTN_NODETYPE(lpRight) == STOP_NODE)
    {
        if (AND_OP == OpVal || NEAR_OP == OpVal)
            lpQtNode->OpVal = OR_OP;

        QTN_NODETYPE(lpRight) = NULL_NODE;
    }
  
    /* Handle leaf-leaf case */
    if (QTN_NODETYPE(lpLeft) == TERM_NODE &&
        QTN_NODETYPE(lpRight) == TERM_NODE)
    {
        return DoTermTermOpt (lpQtNode);
    }

    /* Handle NULL_NODE leaf */
    if (QTN_NODETYPE(lpLeft) == NULL_NODE ||
        QTN_NODETYPE(lpRight) == NULL_NODE)
    {
        return DoNullTermOpt (lpQtNode);
    }

    if ((OperatorAttributeTable[OpVal] & ASSOCIATIVE) &&
        (QTN_NODETYPE(lpLeft) == TERM_NODE ||
        QTN_NODETYPE(lpRight) == TERM_NODE))
    {

        /* One TERM_NODE and one OPERATOR_NODE */
        if (DoAssociativeOpt (lpQtNode) == S_OK)
            return S_OK;
    }

    if (QTN_NODETYPE(lpLeft) == OPERATOR_NODE)
    {
        if (QueryTreeOptim (lpLeft) == S_OK)
            fRet = S_OK;
    }
    
    if (QTN_NODETYPE(lpRight) == OPERATOR_NODE)
    {
        if (QueryTreeOptim (lpRight) == S_OK)
            fRet = S_OK;
    }

    /* Handle leaf-op case */
    if (OperatorAttributeTable[QTN_OPVAL(lpQtNode)] & COMMUTATIVE)
    {
        if (QTN_NODETYPE(lpLeft) == TERM_NODE)
        {
        /* Exchange the branches so that we do the sub-tree first */
            QTN_LEFT(lpQtNode) = lpRight;
            QTN_RIGHT(lpQtNode) = lpLeft;
            return S_OK;
        }
    }
    return fRet;
}

/*************************************************************************
 *  HRESULT NEAR PASCAL DoAssociativeOpt (_LPQTNODE lpQtNode)
 *  
 *  Description:
 *      This function will try to reduce the number of node processed
 *      by applying the law of associativity of the operator.
 *          a * (a * b) = (a * a) * b = a * b
 *      The process is simplified by the following observations:
 *      1/ Only OR and AND are associative. So the top node must be
 *         AND or OR
 *      2/ They are also commutative, ie. we can switch the right for
 *         the left sub-tree without causing any error
 *                  (a or b)  = (b or a)
 *                  (a and b) = (b and a)
 *          This helps simplify different possible scenario
 *      3/ The OPERATOR_NODE Q4 may be any binary operator. Depending on
 *          its value, we may have different result. The notation is based
 *          on the picture below
 *
 *          We have the following cases:
 *              1/ a and (T * a) = (T * a)
 *              2/ a or (T or a) = (T or a)
 *              3/ a or (T * a) : Unchanged (*: Non OR operator)
 *          We can argue that a or (T * a) = a, since (T * a) is a subset of
 *          a, but considering the following scenario:
 *              b + a : b is highlited
 *              a or (b + a) : b should be still highlited, ie. all the info
 *          about b should not be thrown away
 *
 *      The following picture describes of what is happening
 *
 *                     or                      and
 *                   /   \                    /   \
 *           Q1:  a   Q4: and    ---->  Q3: Tree    a  : Q2
 *                       /   \
 *                Q3:  Tree    a  Q2
 *
 *      Q1: the first level term node
 *      Q2: the second level term node that match Q1
 *      Q3: the second level sub-tree
 *      Q4: the first level sub-tree
 *
 *  Parameter:
 *      _LPQTNODE lpQtNode: Pointer to a query node. We are sure to have
 *      one TERM_NODE and one OPERATOR_NODE
 *  Returned Values:
 *      S_OK: If some optimization has been done
 *      E_FAIL: otherwise
 *************************************************************************/
PRIVATE HRESULT NEAR PASCAL DoAssociativeOpt (_LPQTNODE lpQtNode)
{
    _LPQTNODE Q1;
    _LPQTNODE Q3 = NULL;
    _LPQTNODE Q4;
    int SubTreeOpVal;

    /* TERM_NODE is Q1, OPERATOR_NODE Q4 (see above picture) */
    if (QTN_NODETYPE(QTN_LEFT(lpQtNode)) == TERM_NODE)
    {
        Q1 = QTN_LEFT(lpQtNode);
        Q4 = QTN_RIGHT(lpQtNode);
    }
    else
    {
        Q1 = QTN_RIGHT(lpQtNode);
        Q4 = QTN_LEFT(lpQtNode);
    }
    SubTreeOpVal = QTN_OPVAL(Q4);

    /* UNDONE: UNARY_OP not supported */
    if (OperatorAttributeTable[SubTreeOpVal] & UNARY_OP) 
        return E_FAIL;

    /* Find the common TERM_NODE */
    if (QTN_NODETYPE(QTN_LEFT(Q4)) == TERM_NODE &&
        QTN_TOKEN(Q1) == QTN_LEFT(Q4)->u.pToken)
    {
        Q3 = QTN_RIGHT(Q4);
    }
    else if (QTN_NODETYPE(QTN_RIGHT(Q4)) == TERM_NODE &&
        QTN_TOKEN(Q1) == QTN_RIGHT(Q4)->u.pToken)
    {
        Q3 = QTN_LEFT(Q4);
    }
    if (Q3 != NULL)
    {
        /* We got a match, just do the optimization */

        if (QTN_OPVAL(lpQtNode) == OR_OP && SubTreeOpVal != OR_OP)
        {
            /* case 3/ a or (T * a) : Unchanged (*: Non OR operator) */
                return E_FAIL;  /* Unchanged */
        }

        /* Other cases */

        *lpQtNode = *Q4;    /* Move up the sub-tree */
        return S_OK;
    }
    return E_FAIL;
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   HRESULT NEAR PASCAL | DoNullTermOpt |
 *      Optimize node that has a NULL child
 *
 *  @parm   _LPQTNODE | lpQtNode |
 *      Pointer to query tree node to be optimized
 *
 *  @rdesc  S_OK if some optimization has been done.
 *************************************************************************/
PRIVATE HRESULT NEAR PASCAL DoNullTermOpt (register _LPQTNODE lpQtNode)
{
    register _LPQTNODE lpChild;
    _LPQTNODE lpLeft;
    _LPQTNODE lpRight;
    HRESULT fOptimize = E_FAIL;

    lpLeft = QTN_LEFT(lpQtNode);
    lpRight = QTN_RIGHT(lpQtNode);

    if (QTN_OPVAL(lpQtNode) == NOT_OP)
    {
        if (QTN_NODETYPE(lpLeft) == NULL_NODE)
        {
            /* NULL ! a = NULL */
            *lpQtNode = *lpLeft;
            fOptimize = S_OK;
        }
        else if (QTN_NODETYPE(lpRight) == NULL_NODE)
        {
            /* a ! NULL = a */
            *lpQtNode = *lpLeft;
            fOptimize = S_OK;
        }
        if (fOptimize) 
            QTN_LEFT(lpQtNode) = QTN_RIGHT(lpQtNode) = NULL;
        return fOptimize;
    }

    lpChild = QTN_NODETYPE(lpLeft = QTN_LEFT(lpQtNode)) == NULL_NODE ?
        (lpRight = QTN_RIGHT(lpQtNode)) : lpLeft;

    switch (QTN_OPVAL(lpQtNode))
    {
        case AND_OP: // a & NULL = NULL
        case NEAR_OP: // a # NULL = NULL
        case PHRASE_OP: // a + NULL = NULL ??
            QTN_NODETYPE(lpQtNode) = NULL_NODE;
            fOptimize = S_OK;
            break;

        case OR_OP: // a | NULL = a
            *lpQtNode = *lpChild;
            fOptimize = S_OK;
            break;
    }
    if (fOptimize)
    {
        QTN_LEFT(lpQtNode) = QTN_RIGHT(lpQtNode) = NULL;
    }
    return fOptimize;
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   HRESULT NEAR | DoTermTermOpt |
 *      This function optimizes a node that has two TERM nodes for
 *      children
 *
 *  @parm   _LPQTNODE | lpQtNode |
 *      Node to be optimized
 *
 *  @rdesc  S_OK if some optimization is done
 *************************************************************************/
PRIVATE HRESULT NEAR DoTermTermOpt (register _LPQTNODE lpQtNode)
{
    register _LPQTNODE lpLeft = QTN_LEFT(lpQtNode);
    register _LPQTNODE lpRight = QTN_RIGHT(lpQtNode);
    HRESULT fOptimize = E_FAIL;

    if (lpRight->u.pToken == lpLeft->u.pToken &&
        lpRight->dwFieldId == lpLeft->dwFieldId)
    {
        /* Same strings */
        switch (QTN_OPVAL(lpQtNode))
        {
            case OR_OP: /* a | a = a */
            case AND_OP: /* a & a */
                *lpQtNode = *lpRight;
                fOptimize = S_OK;
                break;

            case NOT_OP: /* a ! a = 0 */
                QTN_NODETYPE(lpQtNode) = NULL_NODE;
                fOptimize = S_OK;
                break;
        }
        if (fOptimize == S_OK)
        {
            QTN_LEFT(lpQtNode) = QTN_RIGHT(lpQtNode) = NULL;
        }
    }

    else
    {
        /* Different strings. The least we can do is to change their order of
        retrieval. The string that has wild char should be fetched last (ie. be
        the right leaf to have minimal impact on memory
        */
        if (OperatorAttributeTable[QTN_OPVAL(lpQtNode)] & COMMUTATIVE)
        {
            if (QTN_FLAG(lpLeft) == WILDCARD_MATCH)
            {
                QTN_LEFT(lpQtNode) = lpRight;
                QTN_RIGHT(lpQtNode) = lpLeft;
            }
        }
    }

    return fOptimize;
}

PRIVATE HRESULT PASCAL NEAR CheckTree (_LPQTNODE lpQtNode, PHRESULT phr)
{
    _LPQTNODE lpLeft;
    _LPQTNODE lpRight;
    HRESULT fRet;
    BOOL fAllStopWords = TRUE;

    if (QTN_NODETYPE(lpQtNode) != OPERATOR_NODE)
        return SetErrCode(phr, E_ASSERT);

    lpLeft = QTN_LEFT(lpQtNode);
    lpRight = QTN_RIGHT(lpQtNode);

    /* Handle THRU operator */
    if (QTN_OPVAL(lpQtNode) == RANGE_OP)
    {
        // erinfox: Better error message if STOP_NODE
        if (QTN_NODETYPE(lpLeft) == STOP_NODE)
            return VSetUserErr(phr, E_STOPWORD, QTN_OFFSET(lpLeft));

        if (QTN_NODETYPE(lpRight) == STOP_NODE)
            return VSetUserErr(phr, E_STOPWORD, QTN_OFFSET(lpRight));

        // Otherwise report bad range operator
        if (QTN_NODETYPE(lpLeft) != TERM_NODE ||
            QTN_FLAG(lpLeft) == WILDCARD_MATCH) 
            return VSetUserErr(phr, E_BADRANGEOP, QTN_OFFSET(lpLeft));

        if (QTN_NODETYPE(lpRight) != TERM_NODE ||
            QTN_FLAG(lpRight) == WILDCARD_MATCH) 
            return VSetUserErr(phr, E_BADRANGEOP, QTN_OFFSET(lpRight));

        /* The dtypes must match when using THRU */
        if (QTN_DTYPE(lpLeft) != QTN_DTYPE(lpRight))
            return VSetUserErr(phr, E_UNMATCHEDTYPE, QTN_OFFSET(lpLeft));

        /* Switch the order of the nodes if necessary */
        if (NCmpS(QTN_TOKEN(lpRight)->lpString,  
			QTN_TOKEN(lpLeft)->lpString) < 0)
        {

            /* Left string > Right string, exchange the two */

            _LPQTNODE lpTmp = lpLeft;
            lpLeft = lpRight;
            lpRight = lpTmp;
        }

        /* Copy the left node into the operator */

        *lpQtNode = *lpLeft;

        /* Change the type of term matching */
        QTN_FLAG(lpQtNode) = TERM_RANGE_MATCH;
        QTN_HITERM(lpQtNode) = QTN_TOKEN(lpRight)->lpString;

        return S_OK;
    }
    
    // erinfox: used to report and error for (SW and term), but BS wants it to
    // be just "term". We delay handling this until tree optimization time
#if 0
    if (QTN_OPVAL(lpQtNode) == AND_OP)
    {
        // erinfox: Better error message if NULL_NODE
        if (QTN_NODETYPE(lpLeft) == NULL_NODE)
            return VSetUserErr(phr, E_STOPWORD, QTN_OFFSET(lpLeft));

        if (QTN_NODETYPE(lpRight) == NULL_NODE)
            return VSetUserErr(phr, E_STOPWORD, QTN_OFFSET(lpRight));
    }
#endif
    if (lpLeft && QTN_NODETYPE(lpLeft) != TERM_NODE)
    {
        // erinfox: add check against STOP_NODE
        if (QTN_NODETYPE(lpLeft) != STOP_NODE)   // Neither term nor SW
        {
            fRet = CheckTree(lpLeft, phr);
            if (fRet != S_OK)
            {
                if (fRet != E_NULLQUERY)     // E_NULLQUERY is legit
                    return VSetUserErr(phr, fRet, QTN_OFFSET(lpLeft));
            }
            else
                fAllStopWords = FALSE;        // We found a term when recursing

        }
    }
    else
        fAllStopWords = FALSE;      // It's a term node so it can't be a stopword


    if (lpRight && QTN_NODETYPE(lpRight) != TERM_NODE)
    {
        if (QTN_NODETYPE(lpRight) != STOP_NODE)
        {
            fRet = CheckTree(lpRight, phr);
            if (fRet != S_OK)
            {
                if (fRet != E_NULLQUERY)
                    return VSetUserErr(phr, fRet, QTN_OFFSET(lpRight));
            }
            else
                fAllStopWords = FALSE;
        }
    }
    else
        fAllStopWords = FALSE;

    if (fAllStopWords)
        return VSetUserErr(phr, E_NULLQUERY, 0);

    return S_OK;
}

#if defined(_DEBUG) && DOS_ONLY
PUBLIC HRESULT PASCAL NEAR PrintTree (_LPQTNODE  lpQtNode,
    HRESULT (PASCAL NEAR *fpFunction)(BYTE FAR *))
{
    if (QTN_NODETYPE(lpQtNode) != TERM_NODE)
        printf ("(");
    if (QTN_LEFT(lpQtNode))
        PrintTree (QTN_LEFT(lpQtNode), fpFunction);
    (*fpFunction)((BYTE FAR *)lpQtNode);
    if (QTN_RIGHT(lpQtNode))
        PrintTree (QTN_RIGHT(lpQtNode), fpFunction);
    if (QTN_NODETYPE(lpQtNode) != TERM_NODE)
        printf (")");
    return S_OK;
}

PRIVATE HRESULT PASCAL NEAR PrintTopicListNode (_LPQT lpQueryTree,
    BYTE FAR *lpVanilla)
{
    LPITOPIC lpTopicList;
    OCCURENCE FAR *lpOccur;
    DWORD i;

    for (lpTopicList = QTN_TOPICLIST(lpVanilla); lpTopicList;
        lpTopicList=lpTopicList->pNext)
    {
        lpOccur = lpTopicList->lpOccur;
        for (i = 1; lpOccur; i++, lpOccur = lpOccur->pNext)
        {
            printf ("D:%4ld", lpTopicList->dwTopicId);
            PrintOccurNode(lpQueryTree, lpOccur);
            printf ("\n");
        }
    }
    return S_OK;
}

PRIVATE HRESULT PASCAL NEAR PrintOccurNode(_LPQT lpQueryTree,
    OCCURENCE FAR *lpOccur)
{
    printf (",%5ld", lpOccur->dwCount);
    printf (",%5ld", lpOccur->dwOffset);
    printf (",%5d", lpOccur->wWeight);
    return S_OK;
}

PRIVATE HRESULT PASCAL NEAR PrintQueryNode (BYTE FAR *lpVanilla)
{
    _LPQTNODE lpQtNode = (_LPQTNODE )lpVanilla;

    if (QTN_NODETYPE(lpQtNode) == TERM_NODE)
        PrintStr(QTN_TOKEN(lpQtNode)->lpString);
    else if (QTN_NODETYPE(lpQtNode) == OPERATOR_NODE)
    {
        putchar(' ');
        PrintOperator(QTN_OPVAL(lpQtNode));
        putchar(' ');
    }
    else if (QTN_NODETYPE(lpQtNode) == NULL_NODE)
        printf ("NULL");
    return S_OK;
}

PUBLIC VOID PASCAL NEAR PrintStr (char FAR *lstWord)
{
    int nLength = *lstWord++;

    for (; nLength > 0; nLength--, lstWord++)
        putchar (*lstWord);
}

/*
    Debugging routines
*/
PUBLIC HRESULT PASCAL FAR PrintList(_LPQT lpQueryTree)
{
    STRING_TOKEN FAR *pStr;
    _LPQTNODE lpQtNode = lpQueryTree->lpTopNode;

    if (Debug == 0)
        return S_OK;
    printf ("*** STRING LIST ***\n");
    if (pStr = lpQueryTree->lpStrList)
    {
        while (pStr)
        {
            PrintStr (pStr->lpString);
            printf ("\n");
            pStr = pStr->pNext;
        }
    }
    printf ("\n** Expression postfix form\n");
    while (QTN_PREV(lpQtNode))
        lpQtNode = QTN_PREV(lpQtNode);

    while (lpQtNode)
    {
        if (QTN_NODETYPE(lpQtNode) == TERM_NODE)
        {
            PrintStr(QTN_TOKEN(lpQtNode)->lpString);
            putchar(' ');
        }
        else
        {
            PrintOperator(QTN_OPVAL(lpQtNode));
            putchar(' ');
        }
        lpQtNode = QTN_NEXT(lpQtNode);
    }
    printf ("\n");
    return S_OK;
}

PRIVATE VOID PASCAL NEAR PrintOperator (int OpVal)
{
    switch (OpVal)
    {
        case AND_OP:
            printf ("AND");
            break;
        case OR_OP:
            printf ("OR");
            break;
        case NEAR_OP:
            printf ("NEAR");
            break;
        case PHRASE_OP:
            printf ("PHRASE");
            break;
        case GROUP_OP:
            printf ("GROUP");
            break;
        case FIELD_OP:
            printf ("VFLD");
            break;
        case BRKR_OP:
            printf ("DTYPE");
            break;
        case NOT_OP:
            printf ("NOT");
            break;
        case RANGE_OP:
            printf ("THRU");
            break;
    }
}

#endif  // DOS_ONLY && _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\scatalog.c ===
/*************************************************************************
*                                                                        *
*  SCATALOG.C	                                                         *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   Catalog retrieval                                                    *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Released by Development:     (date)                                   *
*                                                                        *
*************************************************************************/

#include <mvopsys.h>
#include <mem.h>
#include <mvsearch.h>
#include "common.h"
#include "search.h"

#ifdef _DEBUG
static BYTE NEAR s_aszModule[] = __FILE__;	/* Used by error return functions.*/
#endif

/*************************************************************************
 *
 *	                     API FUNCTIONS
 *	Those functions should be exported in a .DEF file
 *************************************************************************/
PUBLIC LPCAT EXPORT_API PASCAL FAR CatalogOpen (GHANDLE, LSZ, PHRESULT);
PUBLIC HRESULT EXPORT_API PASCAL FAR CatalogLookUp (LPCAT, LPB, DWORD);
PUBLIC DWORD EXPORT_API PASCAL FAR Catalog1stItemId(LPCAT);
PUBLIC DWORD EXPORT_API PASCAL FAR CatalogItemCount(LPCAT);
PUBLIC VOID EXPORT_API PASCAL FAR CatalogClose(LPCAT);

#define	cELEMENT_READ	100

/*************************************************************************
 *	@doc	API RETRIEVAL
 *
 *	@func	LPCAT PASCAL FAR | CatalogOpen |
 *		Open the catalog, allocate memory to handle future catalog's
 *		searches
 *
 *	@parm	HANDLE | hfpbSysFile |
 *		If non-zero, this is the handle of an already opened system file
 *
 *	@parm	LSZ | lszFilename |
 *		If hpfbSysFile is non-zero, this is the name of the catalog's subfile
 *		else this is the combined filename with the format
 *		"dos_filename[!catalog_filename]"
 *		If the subfile's name is not specified, the default catalog's file
 *		name will be used. The '!' is not part of the subfile's name
 *
 *	@parm PHRESULT | phr |
 *		Error buffer to be used in subsequent catalog retrieval function calls
 *
 *	@rdesc Pointer to catalog structure if succeeded, NULL if failed. In
 *		case of failure, the error buffer will contain descriptions about
 *		the cause of the failure
 *************************************************************************/

PUBLIC LPCAT EXPORT_API PASCAL FAR CatalogOpen (GHANDLE hfpbSysFile,
	LSZ lszCatName, PHRESULT phr)
{
	CAT_RETRIEV	FAR *lpCat;
	GHANDLE	handle;			// Temporary variable
	GHANDLE	hfpbCatFile;
	HFPB hfpb = NULL;

	/* Open subfile, (and system file if necessary) */

	if ((hfpbCatFile = (GHANDLE)FileOpen(hfpb,
		lszCatName,  FS_SUBFILE, READ, phr)) == 0)
	{
		return NULL;
	}

	/*	Initialization phase.  */

	if ((handle = _GLOBALALLOC(GMEM_MOVEABLE | GMEM_ZEROINIT,
		sizeof(CAT_RETRIEV))) == NULL) {
		SetErrCode(phr, E_OUTOFMEMORY);
exit00:
		FileClose(hfpbCatFile);
		if (hfpb) {
			/* FileClose will free hfpb */
			FileClose (hfpb);
			hfpb = 0;
		}
//		FreeTempFPB(hfpb);
		return NULL;
	}

	lpCat  = (CAT_RETRIEV FAR *)_GLOBALLOCK(handle);
	lpCat->hCat = handle;
	lpCat->lperrb = phr;
	lpCat->hfpbSysFile = (HFPB)hfpb;
	lpCat->hfpbCatalog = (HFPB)hfpbCatFile;
	lpCat->dwCurElem = (DWORD)-1;

	/* Read in the catalog information header */

	if (FileSeekRead (lpCat->hfpbCatalog, lpCat, foNil,
		sizeof(CAT_HEADER), phr) == cbIO_ERROR) 
	{
exit01:
		FreeHandle(lpCat->hCat);
		goto exit00;
	}

	/* MAC codes. They will optimizaed out for Windows */

	lpCat->FileStamp = SWAPWORD(lpCat->FileStamp);
	lpCat->version = SWAPWORD(lpCat->version);
	lpCat->wElemSize = SWAPWORD(lpCat->wElemSize);
	lpCat->cElement = SWAPLONG(lpCat->cElement);
	lpCat->dwFirstElem = SWAPLONG(lpCat->dwFirstElem);

	/* Check for file validity */

	if (lpCat->FileStamp != CATALOG_STAMP || 
		(lpCat->version <7 || lpCat->version > VERCURRENT)) {
		SetErrCode(phr, E_BADVERSION);
		goto exit01;
	}

	/* Allocate cache */
	if ((lpCat->hCatBuf = _GLOBALALLOC(GMEM_MOVEABLE,
		lpCat->wElemSize * cELEMENT_READ)) == NULL) {
		SetErrCode(phr, E_OUTOFMEMORY);
		goto exit01;
	}

	lpCat->lpCatBuf = _GLOBALLOCK(lpCat->hCatBuf);
	return lpCat;
}

/*************************************************************************
 *	@doc	API RETRIEVAL
 *
 *	@func	HRESULT PASCAL FAR | CatalogLookUp |
 *		Look for the value of a catalog's item
 *
 *	@parm LPCAT | lpCat |
 *		Pointer to catalog structure (returned by CatalogOpen())
 *
 *	@parm LPB | lpBuffer |
 *		Buffer to store the retrieved value of the catalog's item
 *
 *	@parm DWORD | dwItem |
 *		Catalog's item number
 *
 *	@rdesc S_OK if succeeded, else other errors. In case of E_FAIL,
 *		the error buffer provided in CatalogOpen() will contain
 *		descriptions about the cause of the failure
 *
 *	@xref	CatalogOpen()
 *************************************************************************/

PUBLIC HRESULT EXPORT_API PASCAL FAR CatalogLookUp (CAT_RETRIEV FAR *lpCat,
	LPB lpBuffer, DWORD dwItem)
{
	register WORD  i;
	register WORD  wElemSize;
	DWORD lfo;
	WORD  fUpdateCache;
	LPB   lpb;
	PHRESULT phr;
#if 0
	int fRet;
#endif

	if (lpCat == NULL || lpBuffer == NULL) {
		return E_INVALIDARG;
	}

	phr = lpCat->lperrb;
	if (dwItem < lpCat->dwFirstElem ||
		dwItem >= lpCat->dwFirstElem + lpCat->cElement) {
		return E_OUTOFRANGE;
	}

	/* We have to get new data if the item is out-of-range, or if
	   there is nothing in the cache yet
	 */

	fUpdateCache = ((lpCat->dwCurElem == -1) ||
		(dwItem < lpCat->dwCurElem) ||
		(dwItem >= lpCat->dwCurElem + (DWORD)cELEMENT_READ)) ;

	wElemSize = lpCat->wElemSize;

	if (fUpdateCache) {
		lpCat->dwCurElem = dwItem;

		/* Calculate the starting file offset */
		lfo = CATALOG_HDR_SIZE +
			(dwItem - lpCat->dwFirstElem) * wElemSize;

		/* Fill up the cache buffer */
		if ((i = (WORD)FileSeekRead(lpCat->hfpbCatalog, lpCat->lpCatBuf, 
		    MakeFo (lfo, 0), (WORD)(wElemSize * cELEMENT_READ), 
		    phr)) == cbIO_ERROR) {
			return E_FAIL;
		}

#if 0
		/* Do MAC swaps */
		if ((wElemSize & 1) == 0) { /* Make sure that it is an even number */

			if ((fRet = SwapBuffer ((LPW)lpCat->lpCatBuf,
				(DWORD)i)) != S_OK)
				return fRet;
		}
#endif

	}

	/* Now transfer the data */
	lpb = lpCat->lpCatBuf + (dwItem - lpCat->dwCurElem) * wElemSize;
	for (i = 0; i < wElemSize; i++)
		*lpBuffer ++ = *lpb++;
	return S_OK;
}

/*************************************************************************
 *	@doc	API RETRIEVAL
 *
 *	@func	VOID PASCAL FAR | CatalogClose |
 *		Close a catalog and release all memory associated with it
 *
 *	@parm LPCAT | lpCat |
 *		Pointer to catalog structure (returned by CatalogOpen())
 *
 *	@xref	CatalogOpen()
 *************************************************************************/

PUBLIC VOID EXPORT_API PASCAL FAR CatalogClose(CAT_RETRIEV FAR *lpCat)
{
	if (lpCat == NULL)
		return;

	FileClose(lpCat->hfpbCatalog);


	/* Free catalog buffer */

	if (lpCat->hCatBuf) 
		FreeHandle(lpCat->hCatBuf);

	/* Free catalog structure */

	if (lpCat->hCat) 
		FreeHandle(lpCat->hCat);
}

/*************************************************************************
 *	@doc	API RETRIEVAL
 *
 *	@func	DWORD PASCAL FAR | Catalog1stItemId |
 *		Return the catalog's first item's id 
 *
 *	@parm LPCAT | lpCat |
 *		Pointer to catalog structure (returned by CatalogOpen())
 *
 *	@rdesc The first item's id is returned, -1 if error
 *
 *	@xref	CatalogOpen()
 *************************************************************************/
PUBLIC DWORD EXPORT_API PASCAL FAR Catalog1stItemId(CAT_RETRIEV FAR *lpCat)
{
	return (lpCat == NULL? -1L: lpCat->dwFirstElem);
}

/*************************************************************************
 *	@doc	API RETRIEVAL
 *
 *	@func	DWORD PASCAL FAR | CatalogItemCount |
 *		Return the catalog's total number of item.
 *
 *	@parm LPCAT | lpCat |
 *		Pointer to catalog structure (returned by CatalogOpen())
 *
 *	@rdesc The total number of items in the catalog is returned, -1 if
 *		error
 *
 *	@xref	CatalogOpen()
 *************************************************************************/
PUBLIC DWORD EXPORT_API PASCAL FAR CatalogItemCount(CAT_RETRIEV FAR *lpCat)
{
	return (lpCat == NULL ? -1L : lpCat->cElement);
}

/*************************************************************************
 *	@doc	API RETRIEVAL
 *
 *	@func	WORD PASCAL FAR | CatalogItemSize |
 *		Return the catalog item's size.
 *
 *	@parm LPCAT | lpCat |
 *		Pointer to catalog structure (returned by CatalogOpen())
 *
 *	@rdesc Return the catalog item's size, -1 if error
 *
 *	@xref	CatalogOpen()
 *************************************************************************/
PUBLIC DWORD EXPORT_API PASCAL FAR CatalogItemSize(CAT_RETRIEV FAR *lpCat)
{
	return (lpCat == NULL ? -1L : lpCat->wElemSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\qtlist.c ===
/*************************************************************************
*                                                                        *
*  QTLIST.C                                                              *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   Tree and list structures handler                                     *
*                                                                        *
**************************************************************************
*                                                                        *
*  Written By   : Binh Nguyen                                            *
*  Current Owner: Binh Nguyen                                            *
*                                                                        *
**************************************************************************
*                                                                        *
*  Released by Development:     (date)                                   *
*                                                                        *
*************************************************************************/

#include <mvopsys.h>
#include <mem.h>
#ifdef DOS_ONLY
#include <stdio.h>
#include <assert.h>
#endif
#include <mvsearch.h>
#include "common.h"
#include "search.h"

/*************************************************************************
 *
 *	                  INTERNAL GLOBAL FUNCTIONS
 *	All of them should be declared far, unless they are known to be called
 *	in the same segment
 *************************************************************************/

PUBLIC LPITOPIC PASCAL NEAR TopicNodeAllocate(LPQT);
PUBLIC VOID PASCAL NEAR TopicNodeFree (LPQT, _LPQTNODE, LPITOPIC, LPITOPIC);
PUBLIC LPIOCC PASCAL NEAR OccNodeAllocate(LPQT);
PUBLIC LPITOPIC  PASCAL NEAR TopicNodeSearch(LPQT, _LPQTNODE, DWORD);
PUBLIC LPIOCC  PASCAL NEAR OccNodeSearch(LPQT, LPITOPIC , LPIOCC );
PUBLIC HRESULT PASCAL NEAR OccNodeInsert(LPQT, LPITOPIC, LPIOCC);
PUBLIC VOID NEAR FreeTopicList(LPITOPIC lpTopicList);
PUBLIC VOID PASCAL NEAR RemoveNode(LPQT, LPV, LPSLINK, LPSLINK, int);
PUBLIC int PASCAL NEAR OccCompare(LPIOCC, LPIOCC);


/*************************************************************************
 *	@doc	API RETRIEVAL
 *
 *	@func	VOID FAR PASCAL | MVQueryFree |
 *		Free all the memory used in the query. WARNING: THERE ARE
 *		2 MEMORY BLOCKS THAT SHOULD NOT BE FREED, IE. THE TOPIC AND
 *		OCCURRENCE NODES MEMORY BLOCKS. THEY ARE USED AND RELEASED
 *		BY THE HISTLIST ROUTINES
 *
 *	@parm	LPQT | lpQueryTree |
 *		Pointer to query tree
 *
 *************************************************************************/
PUBLIC VOID EXPORT_API PASCAL FAR MVQueryFree(_LPQT lpQueryTree)
{
	/* Sanity check */
	if (lpQueryTree == NULL)
		return;

	/* Free the parser nodes memory block */
	BlockFree((LPV)lpQueryTree->lpNodeBlock);

	/* Free the string memory block */
	BlockFree((LPV)lpQueryTree->lpStringBlock);

#ifndef SIMILARITY
	/* Free the string memory block */
	BlockFree((LPV)lpQueryTree->lpWordInfoBlock);
#endif

	/* Free query tree */
	GlobalLockedStructMemFree((LPV)lpQueryTree);
}

/*************************************************************************
 *	@doc	INTERNAL RETRIEVAL
 *	
 *	@func	LPITOPIC PASCAL NEAR | TopicNodeAllocate |
 *		Allocate a new TOPIC_LIST node
 *
 *	@parm	_LPQT | lpQueryTree |
 *		Pointer to query tree
 *
 *	@rdesc
 *		Pointer to new node if succeeded, NULL otherwise
 *************************************************************************/
PUBLIC LPITOPIC PASCAL NEAR TopicNodeAllocate(_LPQT lpQueryTree)
{
	LPITOPIC lpNode;			// Ptr to an internal Topic node
	LPSLINK lpTopicFreeList;	// Ptr to the Topic free memory pool 
	LPBLK lpBlockHead;

	if (lpQueryTree->lpTopicFreeList == NULL) {
		/* Allocate a big block of TOPIC */
		if (BlockGrowth(lpBlockHead = lpQueryTree->lpTopicMemBlock) != S_OK)
			return NULL;
		lpQueryTree->lpTopicFreeList = (LPSLINK)BlockGetLinkedList(lpBlockHead);
	}
	lpTopicFreeList = lpQueryTree->lpTopicFreeList;

	/* Allocate from the free list */
	lpNode = (LPITOPIC)lpTopicFreeList;
	lpQueryTree->lpTopicFreeList = lpTopicFreeList->pNext;
	lpNode->pNext = NULL;
	lpNode->fFlag = 0;
	return lpNode;
}

/*************************************************************************
 *	@doc	INTERNAL RETRIEVAL
 *	
 *	@func	LPIOCC PASCAL NEAR | OccNodeAllocate |
 *		Allocate a new OCCURENCE node
 *
 *	@parm	_LPQT | lpQueryTree |
 *		Pointer to query tree
 *
 *	@rdesc
 *		Pointer to new node if succeeded, NULL otherwise
 *************************************************************************/
PUBLIC LPIOCC PASCAL NEAR OccNodeAllocate(_LPQT lpQueryTree)
{
	LPIOCC lpNode;			// Pointer to occurence node
	LPSLINK lpOccFreeList;	// Pointer to occurence free list
	LPBLK lpBlockHead;

	if (lpQueryTree->lpOccFreeList == NULL)
	{
		// Check to see if we are running out of blocks	before we do allocation
		lpBlockHead = lpQueryTree->lpOccMemBlock;

		if (lpBlockHead->cCurBlockCnt >= lpBlockHead->cMaxBlock)
		{
			// OK, we ran out of blocks, let's borrow from the topic list
			if (((LPBLK)(lpQueryTree->lpTopicMemBlock))->cMaxBlock >
				((LPBLK)(lpQueryTree->lpTopicMemBlock))->cCurBlockCnt)
			{
				((LPBLK)(lpQueryTree->lpTopicMemBlock))->cMaxBlock--;
				lpBlockHead->cMaxBlock++;
			}
		}

		/* Allocate a big block of Occ */

		if (BlockGrowth(lpBlockHead) != S_OK)
			return NULL;
		lpQueryTree->lpOccFreeList = (LPSLINK)BlockGetLinkedList(lpBlockHead);
	}
	lpOccFreeList = lpQueryTree->lpOccFreeList;

	/* Allocate from the free list */
	lpNode = (LPIOCC )lpOccFreeList;
	lpQueryTree->lpOccFreeList = lpOccFreeList->pNext;
	lpNode->pNext = NULL;
	lpNode->fFlag = 0;
	return lpNode;
}

/*************************************************************************
 *	@doc	INTERNAL RETRIEVAL
 *	
 *	@func	VOID PASCAL NEAR | RemoveNode |
 *		This function will unlink a single linked node from a list.
 *		This node may be a doc node or an occurence node. This node
 *		is added to the free pool
 *
 *	@parm	_LPQT | lpQueryTree |
 *		Pointer to query tree's containing globals
 *
 *	@parm	LPV | lpRoot |
 *		Pointer to either a Topic node or an occurence node, depending
 *		on the value of fNodeType
 *
 *	@parm	LPSLINK | lpPrevNode |
 *		Node previous to node to be removed, or NULL
 *
 *	@parm	LPSLINK | lpRemovedNode |
 *		Node to be removed
 *
 *	@parm	int | fNodeType | Tell what kind of node we are dealing with
 *************************************************************************/
PUBLIC VOID PASCAL NEAR RemoveNode(_LPQT lpQueryTree, LPV lpRoot,
	LPSLINK lpPrevNode, LPSLINK lpRemovedNode, int fNodeType)
{
	if (lpRoot) {
		/* The node came from an existing list. We
	 	   have to look for its position and unlink it
		*/
		if (lpPrevNode == NULL) {
			/* Start from the beginning and look for the specific node */

			switch (fNodeType & NODE_TYPE_MASK) {
				case TOPICLIST_NODE :
					lpPrevNode = (LPSLINK)(((_LPQTNODE)lpRoot)->lpTopicList);
					break;
				case OCCURENCE_NODE :
					lpPrevNode = (LPSLINK)(((LPITOPIC)lpRoot)->lpOccur);
					break;
			}
		}

		if (lpPrevNode != lpRemovedNode) {
			while (lpPrevNode->pNext && lpPrevNode->pNext != lpRemovedNode)
				lpPrevNode = lpPrevNode->pNext;
		}

		if (lpPrevNode == lpRemovedNode) {
			/* This is the first node, just set the list to NULL */
			switch (fNodeType & NODE_TYPE_MASK) {
				case TOPICLIST_NODE :
					((_LPQTNODE)lpRoot)->lpTopicList=(LPITOPIC)lpRemovedNode->pNext;
					break;
				case OCCURENCE_NODE :
					((LPITOPIC)lpRoot)->lpOccur=(LPIOCC)lpRemovedNode->pNext;
					break;
			}
		}
		else {
			/* Unlink the node */
			lpPrevNode->pNext = lpRemovedNode->pNext;
		}
	}

	if ((fNodeType & DONT_FREE) == 0) {
		/* Add the free node to FreeList */
		switch (fNodeType & NODE_TYPE_MASK) {
			case TOPICLIST_NODE :
				lpRemovedNode->pNext = lpQueryTree->lpTopicFreeList;
				lpQueryTree->lpTopicFreeList = lpRemovedNode;
				if (lpQueryTree->lpTopicStartSearch == (LPITOPIC)lpRemovedNode)
					lpQueryTree->lpTopicStartSearch = NULL;
				if (lpRoot)
					((_LPQTNODE)lpRoot)->cTopic--;
				break;
			case OCCURENCE_NODE :
				lpRemovedNode->pNext = lpQueryTree->lpOccFreeList;
				lpQueryTree->lpOccFreeList = lpRemovedNode;
				if (lpQueryTree->lpOccStartSearch == (LPIOCC)lpRemovedNode)
					lpQueryTree->lpOccStartSearch = NULL;
				if (lpRoot)
					((LPITOPIC)lpRoot)->lcOccur--;
				break;
		}
	}
}

/*************************************************************************
 *	@doc	INTERNAL RETRIEVAL
 *
 *	@func	HRESULT PASCAL NEAR | OccNodeInsert |
 *		Purpose add a Occurrence node into the TopicList's occurrence list.
 *		The function assumes that lpOccStartSearch is pointing to the place
 *		to insert the node (non NULL). This is a single linked list
 *		insertion.
 *		On exit, lpOccStartSearch will be updated
 *
 *	@parm	LPQT | lpQueryTree |
 *		Pointer to query tree struct containing globals
 *
 *	@parm	LPITOPIC | lpTopicList | 
 *		Pointer to doclist
 *
 *	@parm	LPIOCC | lpInsertedOcc |
 *		Occ node to be inserted into the list
 *
 *	@rdesc	S_OK, if the node is successfully added to the list,
 *		FAILED otherwise
 *************************************************************************/
PUBLIC HRESULT PASCAL NEAR OccNodeInsert(_LPQT lpQueryTree, LPITOPIC lpTopicList,
	LPIOCC lpInsertedOcc)
{
	LPIOCC lpCurOcc;	// Starting node for searching 
	LPIOCC lpPrevOcc;
	int   fResult;

	if (lpTopicList->lpOccur == NULL) {
		lpTopicList->lpOccur = lpInsertedOcc;
	}
	else {
		/* SORTED VERSION */
		lpCurOcc = lpQueryTree->lpOccStartSearch;

		if (lpCurOcc == NULL || OccCompare (lpCurOcc, lpInsertedOcc) < 0) {
			/* Out of sequence, start from beginning and look for
			 * appropriate location
		 	 */
			lpCurOcc = lpTopicList->lpOccur;
		}

		for (lpPrevOcc = NULL; lpCurOcc; lpCurOcc = lpCurOcc->pNext) {
			if ((fResult = OccCompare (lpCurOcc, lpInsertedOcc)) <= 0)
				break;
			lpPrevOcc = lpCurOcc;
		}

		if (fResult == 0) {
			/* Duplicate data, just free the node */
			lpInsertedOcc->pNext = (LPIOCC)lpQueryTree->lpOccFreeList;
			lpQueryTree->lpOccFreeList = (LPSLINK)lpInsertedOcc;
			return S_OK;
		}

		if (lpPrevOcc == NULL) {
			/* Insert at the beginning */
			lpInsertedOcc->pNext = lpTopicList->lpOccur;
			lpTopicList->lpOccur = lpInsertedOcc;
		}
		else {
			/* Insert at the middle or end */
			lpInsertedOcc->pNext = lpPrevOcc->pNext;
			lpPrevOcc->pNext = lpInsertedOcc;
		}
	}
	lpTopicList->lcOccur ++;

	/* Update lpOccStartSearch */
	lpQueryTree->lpOccStartSearch = lpInsertedOcc;
	return S_OK;
}

/*************************************************************************
 *	@doc	INTERNAL RETRIEVAL
 *
 *	@func	HRESULT PASCAL NEAR | TopicNodeInsert |
 *		Purpose add a TopicList node into the query node 's TopicList. The
 *		function assumes that lpTopicStartSearch is pointing to the place
 *		to insert the node (non NULL). This is a single linked list
 *		insertion.
 *		On exit, lpTopicStartSearch will be updated
 *
 *	@parm	LPQT | lpQueryTree |
 *		Pointer to query tree struct containing globals
 *
 *	@parm	_LPQTNODE | lpQtNode | 
 *		Pointer to query tree node
 *
 *	@parm	LPITOPIC | lpInsertedTopic |
 *		Topic node to be inserted into the list
 *
 *	@rdesc	S_OK, if the node is successfully added to the list,
 *		FAILED otherwise
 *************************************************************************/
PUBLIC HRESULT PASCAL NEAR TopicNodeInsert (_LPQT lpQueryTree,
	_LPQTNODE lpQtNode, LPITOPIC lpInsertedTopic)
{
	LPITOPIC lpCurTopic;	// Starting node for searching 
	LPITOPIC lpPrevTopic;

	if (lpQtNode->lpTopicList == NULL) {
		lpQtNode->lpTopicList = lpInsertedTopic;
	}
	else {
		lpCurTopic = lpQueryTree->lpTopicStartSearch;
		if (lpCurTopic == NULL || lpCurTopic->dwTopicId >= lpInsertedTopic->dwTopicId)
			lpCurTopic = lpQtNode->lpTopicList;

		for (lpPrevTopic = NULL; lpCurTopic; lpCurTopic = lpCurTopic->pNext) {
			if (lpCurTopic->dwTopicId >= lpInsertedTopic->dwTopicId) {
				/* We pass the inserted point */
				break;
			}
			lpPrevTopic = lpCurTopic;
		}
		if (lpPrevTopic == NULL) {
			/* Insert at the beginning */
			lpInsertedTopic->pNext = lpQtNode->lpTopicList;
			lpQtNode->lpTopicList = lpInsertedTopic;
		}
		else {
			/* Inserted at the middle or the end */
			lpInsertedTopic->pNext = lpPrevTopic->pNext;
			lpPrevTopic->pNext = lpInsertedTopic;
		}
	}

	/* Update lpTopicStartSearch */
	lpQueryTree->lpTopicStartSearch = lpInsertedTopic;
	lpQtNode->cTopic++;
	return S_OK;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	VOID PASCAL NEAR | TopicNodeFree |
 *		Free a doc node and its occurrences list
 *
 *	@parm	_LPQT | lpQueryTree |
 *		Pointer to query tree struct (for globals)
 *
 *	@parm	_LPQTNODE | lpQtNode |
 *		Pointer to query tree node where the Topic node belongs to
 *
 *	@parm	LPITOPIC | lpTopicList |
 *		Topic node to be free
 *************************************************************************/
PUBLIC VOID PASCAL NEAR TopicNodeFree (_LPQT lpQueryTree,
	_LPQTNODE lpQtNode, LPITOPIC lpPrev, LPITOPIC lpTopicList)
{
	register LPSLINK	lpTmp;

    // erinfox - comment out because we pass in as parameter
	// register LPSLINK	lpPrev;   


    /* Free all the occurences nodes */
	if (lpTmp = (LPSLINK)lpTopicList->lpOccur) {

		/* Traverse to the occurence list */
		while (lpTmp->pNext)
			lpTmp = lpTmp->pNext;

		/* Free the occurrence list */
		lpTmp->pNext = lpQueryTree->lpOccFreeList;
		lpQueryTree->lpOccFreeList = (LPSLINK)lpTopicList->lpOccur;
	}

// we pass in lpPrev so we don't have to traverse the linked list again
#if 0
	/* Free the doc list */
	for (lpPrev = NULL, lpTmp = (LPSLINK)lpQtNode->lpTopicList; lpTmp;
		lpTmp = lpTmp->pNext) {
		if (lpTmp == (LPSLINK)lpTopicList)
			break;
		lpPrev = lpTmp;
	}
#endif

    if (lpPrev == NULL) {
		/* Remove the first node */
		lpQtNode->lpTopicList = (LPITOPIC)lpTopicList->pNext;
	}
	else {
		/* Remove middle or end node */
		lpPrev->pNext = lpTopicList->pNext;
	}

	if (lpQueryTree->lpTopicStartSearch == (LPITOPIC)lpTopicList)
		lpQueryTree->lpTopicStartSearch = lpPrev;

	lpTopicList->pNext = (LPITOPIC)lpQueryTree->lpTopicFreeList;
	lpQueryTree->lpTopicFreeList = (LPSLINK)lpTopicList;
	lpQtNode->cTopic --;
}

/*************************************************************************
 *	@doc	INTERNAL RETRIEVAL
 *
 *	@func	LPITOPIC  PASCAL NEAR | TopicNodeSearch |
 *		This function handles the search for a TopicId node in a query node
 *		The assumptions made are:
 *		- TopicId nodes read from the index file are already sorted
 *		- The series of nodes we are looking for is also sorted (since they
 *		  are read from the index file)
 *		Ex: For A and B, all the nodes of A are sorted. As we read in each
 *		node of B, they are also sorted
 *		In this case the search will be fast, since we don't have to start
 *		from the beginning.
 *		An exception happens when the index is sorted with fields, but then
 *		retrieved ignoring field. Everytime when a new field occurs, the new
 *		TopicId may be less than the one in lpTopicStartSearch, which demand the
 *		search to start from the beginning
 *
 *	@parm	_LPQT | lpQueryTree |
 *		Pointer to query tree structure containing globals
 *
 *	@parm	_LPQTNODE | lpQtNode |
 *		The query node we are searching on
 *
 *	@parm	DWORD | dwTopicID |
 *		The TopicId we are looking for
 *
 *	@rdesc	The list of the sorted nodes is a single linked list.
 *		If the node is found:
 *			- The function returns a pointer to that node
 *			- lpQueryTree->lpTopicSearchStart points to the node before
 *		the returned node
 *		If the node is not found,
 *			- The function returns NULL
 *			- lpQueryTree->lpTopicStartSearch will point to the node before
 *			the one that cause failure
 *
 *************************************************************************/
PUBLIC LPITOPIC  PASCAL NEAR TopicNodeSearch(_LPQT lpQueryTree,
	_LPQTNODE lpQtNode, DWORD dwTopicID)
{
	register LPITOPIC lpStartSearch;

	if ((lpStartSearch = lpQueryTree->lpTopicStartSearch) == NULL ||
		(lpStartSearch->dwTopicId > dwTopicID))
	{

		/* We begin the search at the beginning of the TopicList. */
		lpStartSearch = lpQtNode->lpTopicList;
	}

	for (; lpStartSearch; lpStartSearch = lpStartSearch->pNext) {
		if (lpStartSearch->dwTopicId == dwTopicID)
		{
			/* Update the starting search pointer */
			lpQueryTree->lpTopicStartSearch = lpStartSearch;
			return lpStartSearch;
		}
		if (lpStartSearch->dwTopicId > dwTopicID) {
			/* We pass the wanted node, let's break out of the loop */
			break;
		}
		/* Update the starting search pointer */
		lpQueryTree->lpTopicStartSearch = lpStartSearch;

	}
	return NULL;
}

/*************************************************************************
 *	PUBLIC int PASCAL NEAR OccCompare(LPIOCC lpOccur1,
 *		LPIOCC lpOccur2)
 *
 *	Description:
 *		Compare two occurrence nodes
 *
 *	Returned Values:
 *		= 0 : if the nodes are equal
 *		> 0 : if lpOccur2 > lpOccur1
 *		< 0 : if lpOccur2 < lpOccur1
 *************************************************************************/
PUBLIC int PASCAL NEAR OccCompare(LPIOCC lpOccur1, LPIOCC lpOccur2)
{
	int fReturn;

	if (fReturn = (int)(lpOccur2->dwCount - lpOccur1->dwCount))
		return fReturn;
	if (fReturn = (int)(lpOccur2->cLength - lpOccur1->cLength))
		return fReturn;
	return ((int)(lpOccur2->dwOffset - lpOccur1->dwOffset));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\search.h ===
/*************************************************************************
*                                                                        *
*  ISEARCH.H                                                             *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1992                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   Common defines internal to the searcher.  None of this stuff is      *
*   available outside the search engine.                                 *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Released by Development:     (date)                                   *
*                                                                        *
*************************************************************************/

// Critical structures that gets messed up in /Zp8
#pragma pack(1)

#define occifNONE       0x0000      // No flags.
#define occifEOF        0x0001      // End of file.
#define occifWRITTEN    0x0002      // This occurrence has been written.
#define occifMATCH      0x0004      // This occurrence is a match.
#define occifHAS_MATCH  0x0008      // Don't do combination this pass.


/**************************************************************************
 *
 *                    SYMBOLS STRUCTURE
 *
 **************************************************************************/

#define cWordsPerToken 5  // a guess at average number of stemmed or wildcard variants
typedef struct WORDINFO
{
	struct WORDINFO FAR *pNext;

	// Term frequency
    DWORD cTopic;

    // Word data information
    FILEOFFSET foData;
    DWORD cbData;
	WORD wRealLength;           // Real word length
} WORDINFO, FAR *LPWORDINFO;


typedef struct STRING_TOKEN {
    struct STRING_TOKEN FAR *pNext;
    LPB     lpString;		// String itself
    WORD    cUsed;          // Times this string appears in the query 
    WORD    wWeight;        // Weight of the word
	WORD	wWeightRemain;	// Sum of term weights AFTER this one in the list
	LPWORDINFO lpwi;		// List of word data for this token
	DWORD	dwTopicCount;
} STRING_TOKEN;

/* Set the default size of a string block. Assuming that a word length
 * is 6, allocate enough memory for 20 words
 */

#define STRING_BLOCK_SIZE   (sizeof(STRING_TOKEN) + 6) * 20

/* String flags */

#define EXACT_MATCH             0x01
#define WILDCARD_MATCH          0x02
#define TERM_RANGE_MATCH        0x03

/**************************************************************************
 *
 *                     QUERY TREE STRUCTURE & FUNCTIONS
 *
 **************************************************************************/

#define MAX_QUERY_NODE  0xFFFF  // Maximum number of tokens in a query

#define TOPICLIST_NODE  0x01    // The node is a topicId node
#define OCCURENCE_NODE  0x02    // The node is an occurrence node
#define NODE_TYPE_MASK  0x0f

#define DONT_FREE       0x10    // Don't free the node after unlink
#define STACK_SIZE      15      // Maximum level of stack

//  This is an information buffer structure that you pass to "HitListGetTopic"
//  which fills in its fields.  You can look at the fields not marked as
//  "internal", and also pass it to other API functions.

#define TOPIC_INFO  \
    WORD    wWeight;        /* Topicument-weight. */ \
    DWORD   dwTopicId;        /* Topic-ID associated with this hit. */ \
    DWORD   lcOccur         /* Number of occurrences (hits) */ 

typedef struct SNGLINK 
{
    struct SNGLINK FAR *pNext;
} SGNLINK, FAR *LPSLINK;

// Internal Occurrence structure
// Be careful when changing the fields of it. See MARKER struct below

typedef struct OCCURENCE
{
    struct OCCURENCE FAR *pNext;
    WORD    fFlag;              /* Various flags */
    WORD    cLength;            /* Word length */
    DWORD   dwCount;            /* Word Count, needed for phrase */
    DWORD   dwOffset;           /* Word offset, needed for hilite */
    DWORD   dwFieldId;          /* Field id  (_DEBUG only) */
    WORD    wWeight;            /* Hit weight */
	LPVOID	lpvTerm;			/* Pointer to a term in WORD-prefix length
								 *	Unicode format, i.e. a "wide ST".
								 */
#if defined (_MIPS) || defined (ppc)
    WORD    wPad;
	DWORD	dwPad;
#endif
} OCCURENCE, FAR *LPIOCC;

/* Marker node. Be careful when changing the fields of it.
 *   1/ The size of it must be <= the size of an OCCURENCE
 *   2/ Location of pNext and fFlag must be the same between the two
 *      structure */

typedef struct MARKER 
{
    struct  OCCURENCE FAR *pNext;
    WORD    fFlag;              /* Various flags */
    WORD    Unused;             /* Unused */
    struct MARKER FAR *pPrevMark;   /* Previous marker */
    struct MARKER FAR *pNextMark;   /* Next marker */
} MARKER, FAR *LPMARKER;

/* Occurrence flags */
#define TO_BE_KEPT      0x01
#define TO_BE_SKIPPED   0x02
#define TO_BE_COMPARED  0x04
#define IS_LAST_NODE    0x08
#define IS_MARKER_NODE  0x10

/* Internal Topic List structure */
typedef struct TOPIC_LIST 
{
    struct  TOPIC_LIST FAR * pNext;
    LPIOCC  lpOccur;            // Pointer to occurrence lists
    unsigned short fFlag;       // Various flags, such as TO_BE_KEPT
    TOPIC_INFO;
} TOPIC_LIST;

typedef TOPIC_LIST FAR *LPITOPIC;

/* TopicId node flags */
#define TO_BE_KEPT      0x01
#define HAS_MARKER      0x02
#define IS_MARKER_NODE  0x10
#define WRITTEN_TO_DISK 0x20

#define DL_NEXT(p)  (((LPITOPIC)p)->pNext)
#define DL_OCCUR(p) (((LPITOPIC)p)->lpOccur)

/* QueryInfo flags */

#define IN_PHRASE       0x0001
#define FREE_CHARTAB    0x0002
#define FORCED_PHRASE   0x0004
#define CW_PHRASE       0x0010  // Must match COMPOUNDWORD_PHRASE in medv20.h

/*  Query info node */
typedef struct QueryInfo 
{
    LPB     lpbQuery;           // Query expression bytes.
    LPB     pWhitespace;        // Working variable for implicit phrase
    LPQT    lpQueryTree;        // Query tree.
    LPV     lpStack;            // Pointer to operator's stack
    DWORD   dwOffset;           // Current offset
    BREAKER_FUNC    lpfnBreakFunc;
    LPSIPB  lpStopListInfo;     // Associated stop list info
    LPCHARTAB lpCharTab;        // Pointer to character table
    LPOPSYM lpOpSymTab;         // Operator symbol table
    LPERRB  lperrb;             // Error buffer
    DWORD   fFlag;              // Flag
    WORD    cOpEntry;           // Number of operator entries
	WORD    Pad;
}   QUERY_INFO,
    FAR *LPQI;

/* Parameter of an unary operator */
typedef union NodeParm 
{
    VOID FAR *lpStruct;
    DWORD dwValue;
} NODE_PARM;

/* Query Tree nodes */

#define OPERATOR_NODE       1   // Operator
#define TERM_NODE           2   // A string to be searched for
#define NULL_NODE           3   // A string that can't be found
#define EXPRESSION_NODE     4   // The node contains the result
#define STOP_NODE           5   // A stop word

typedef struct QTNODE 
{
    struct QTNODE FAR *pNext;
    struct QTNODE FAR *pPrev;
    LPITOPIC lpTopicList;       /* Topic linked list */
    union 
    {
    STRING_TOKEN FAR *pToken;   /* Word associated with this node */
    WORD     wProxDist;     /* Proximity distance */
    VOID FAR *lpStruct;     /* Structure associated with unary op */
    } u;
    DWORD cTopic;               // Number of TopicId lists of this node
		// This number will change when merging
		// gets involved 
		
    // Max and Min topic id. This is useful for speeding up retrieval
    DWORD dwMaxTopicId;         // Max topic Id in the list
    DWORD dwMinTopicId;         // Min topic id in the list
    
    // Word data information
    FILEOFFSET foData;
    DWORD cbData;

    /* Characteristics associated with the node */

    LPB  lpHiString;            /* Hi limit of the string (for THRU) */
    LPGROUP lpGroup;            /* Group associated with this node */
    DWORD dwFieldId;            /* FieldID associated with term */
    
    WORD NodeType;              /* What type (operator, term, etc) */
    WORD OpVal;                 /* Operator value */
    WORD iCurOff;               // Offset to the beginning of the word
    WORD wRealLength;           // Real word length
	LPVOID	lpvIndexedTerm;		/* Pointer to the term in the index that
								 * currently matches this node.  The term's
								 * string is in WORD-prefix length Unicode
								 *	format, i.e. a "wide ST".
								 */
    
    // General info
    WORD fFlag;                 /* Various flags */
    WORD Offset;                /* Offset from the beginning of the query */
    WORD wBrkDtype;             /* Breaker's dtype (for THRU) */
    WORD Pad;
} QTNODE, FAR *_LPQTNODE;

#define QTN_LEFT(p)     (((QTNODE FAR *)p)->pPrev)
#define QTN_RIGHT(p)    (((QTNODE FAR *)p)->pNext)
#define QTN_PREV(p)     (((QTNODE FAR *)p)->pPrev)
#define QTN_NEXT(p)     (((QTNODE FAR *)p)->pNext)

#define QTN_NODETYPE(p) (((QTNODE FAR *)p)->NodeType)
#define QTN_OPVAL(p)    (((QTNODE FAR *)p)->OpVal)
#define QTN_TOPICLIST(p)  (((QTNODE FAR *)p)->lpTopicList)
#define QTN_TOKEN(p)    (((QTNODE FAR *)p)->u.pToken)
#define QTN_PARMS(p)    (((QTNODE FAR *)p)->u.lpStruct)
#define QTN_FLAG(p)     (((QTNODE FAR *)p)->fFlag)
#define QTN_HITERM(p)   (((QTNODE FAR *)p)->lpHiString)
#define QTN_OFFSET(p)   (((QTNODE FAR *)p)->Offset)
#define QTN_FIELDID(p)  (((QTNODE FAR *)p)->dwFieldId)
#define QTN_DTYPE(p)    (((QTNODE FAR *)p)->wBrkDtype)
#define QTN_GROUP(p)    (((QTNODE FAR *)p)->lpGroup)


/* Block of query's nodes. We allocate 16 nodes per block */
#define QUERY_BLOCK_SIZE    sizeof(QTNODE)*16

#define cTOPIC_PER_BLOCK  500
#define cOCC_PER_BLOCK  1000

/* Query tree's flags */

#define TO_BE_SORTED    0x0001
#define HAS_NEAR_RESULT 0x0002
#define ALL_OR          0x0004
#define ALL_AND         0x0008
#define PROCESSED       0x0010
#define ALL_ANDORNOT	0x0020


/* Query tree structure */
typedef struct QTREE 
{
    CUSTOMSTRUCT cStruct;       /* Structure's handle, MUST BE 1ST FIELD!! */
    LONG    cQuery;             /* Note: this can't be unsigned */
    DWORD   dwcOccFields;       /* Occurence fields count */
    DWORD   dwOccSize;          /* Occurence node size */
    
    /* Unary operator related fields */
    LPGROUP lpGroup;            /* Group associated with all terms */
    DWORD   dwFieldId;          /* Field-ID assigned to all followed terms.*/
    WORD    wProxDist;          /* Proximity distance */
    WORD    iDefaultOp;         /* Default operator. */
    WORD    wBrkDtype;          /* Breaker's dtype (for THRU) */
    WORD    fFlag;              /* Various querytree flags */

    /* String table */
    LPV     lpStringBlock;      /* String's memory block */
    STRING_TOKEN FAR *lpStrList;/* Pointer to strings table */

	LPV		lpWordInfoBlock;

    /* Topic list related global variables */
    LPV     lpTopicMemBlock;      /* Pointer to Topic memory block */
    LPITOPIC  lpTopicStartSearch;   /* Starting node for searching  */
    LPSLINK lpTopicFreeList;      /* Pointer to free doc list */
	DWORD   dwTopicNodeCnt;

    /* Occ list related global variables */
    LPV     lpOccMemBlock;      /* Pointer to Occ memory block */
    LPIOCC  lpOccStartSearch;   /* Starting occurrence for searching  */
    LPSLINK lpOccFreeList;      /* Pointer to free occurrence list */
	DWORD   dwOccNodeCnt;
    
    /* Buffer for the tree's nodes */
    LPV     lpNodeBlock;        /* Nodes memory block */
    _LPQTNODE lpTopNode;        /* Pointer to top node */
    
    /* Index information */
    FILEOFFSET foIdxRoot;       /* Top node offset */
    DWORD   dwBlockSize;        /* Index block size */
    WORD    TreeDepth;          /* Depth of tree */
    WORD    cIdxLevels;         /* Index's depth */
    OCCF    occf;
    IDXF    idxf;
    CKEY    ckeyTopicId;        // 2-bytes
    CKEY    ckeyOccCount;       // 2-bytes
    CKEY    ckeyWordCount;
    CKEY    ckeyOffset;
    
    /* MAGIC value... */
    LONG    magic;              
    
    /* Interrupt flag for online use. Online apps don't have callbacks
     * so we have to provide an API to set this flag
     */
    BYTE    cInterruptCount;       /* Interrupt checking */
    BYTE    fInterrupt;
	/* Similarity stuff */
	LPV		lpDocScores;
}   QTREE,
    FAR *_LPQT;

#define HQUERY_MAGIC    0x04121956

// This defines the "type" of word term node.
#define TERM_EXACT      1       // "Standard" term.
#define TERM_PREFIX     2       // "Wildcard" term.
#define TERM_RANGE      3       // Range term.  This says "give me everything
		//  between some low bound and some high
		//  bound."

/*  
 *  This defines the value or type of operator node. It corresponds to
 *  the OpVal field of struct OPSYM
*/

#define AND_OP              0       // AND    operator
#define OR_OP               1       // OR     operator
#define NOT_OP              2       // NOT    operator
#define PHRASE_OP           3       // PHRASE operator
#define NEAR_OP             4       // NEAR   operator
#define MAX_DEFAULT_OP      OR_OP   // Maximum value of default operator

#define RANGE_OP            5
#define GROUP_OP            6
#define FIELD_OP            7
#define BRKR_OP             8
#define MAX_OPERATOR        8

#define STOP_OP             9       // stop word

#define QUOTE       50
#define RIGHT_PAREN 51
#define LEFT_PAREN  52
#define TERM_TOKEN  53

/* Operator type */
#define BINARY_OP   0x01
#define UNARY_OP    0x02
#define PARSE_TOKEN 0x04

/* Operator attribute */
#define COMMUTATIVE 0x10    // a * b = b * a
#define ASSOCIATIVE 0x20    // a * (b * c) = (a * b) * c
#define ZERO        0x40    // a * a = a

extern WORD OperatorAttributeTable[]; 
/*
 *  Those are properties of a binary node expression.
 */
#define EXPRESSION_TERM         1   // One branch is an expression, one
		    // is a term
#define EXPRESSION_EXPRESSION   2   // Both branches are expressions

#if 1
typedef ERR (PASCAL NEAR *FNHANDLER) (LPQT, _LPQTNODE, LPITOPIC, LPV, int);
#else
typedef ERR (PASCAL NEAR *FNHANDLER) (LPQT, LPV, LPV, LPV, int);
#endif

#define     ORDERED_BASED       1   // Based on topicId numbered
#define     HIT_COUNT_BASED     2   // Based doc's hit count
#define     WEIGHT_BASED        3   // based on doc's weight

typedef struct RetVars 
{
    LPQT    lpqt;               // Pointer to query tree for global variables
    LPBYTE  pLeadByteTable;     // Pointer to lead byte table for DBCS
    DWORD   dwTopicCount;       // Number of topics
    DWORD   dwFieldID;          // Current fieldid
    DWORD   cOccFields;
    DWORD   dwOccSize;
    LPB     lpbCur;
    NODEINFO LeafInfo;
    NODEINFO DataInfo;
    SRCHINFO SrchInfo;          // Search information

	LCID	lcid;				// WIN32 locale ID specified at build time
    
    WORD    wWordLength;        // Word length
    WORD    fFlag;              // General flags
    BYTE    pBTreeWord[CB_MAX_WORD_LEN];         // Buffer for the decoded word 
    BYTE    pModifiedWord[CB_MAX_WORD_LEN];      // Buffer for the modified word
    BYTE    pStemmedBTreeWord[CB_MAX_WORD_LEN];  // Stemmed BTree word
    BYTE    pStemmedQueryWord[CB_MAX_WORD_LEN];  // Stemmed searched word
    BYTE    fRank;              // If non-zero the result is ranked.
    BYTE    pNodeBuf[BTREE_NODE_SIZE];   // Generic b-tree node buffer.
    BYTE    pDataBuf[FILE_BUFFER];
}   RETV,
    FAR *LPRETV;
    
/**************************************************************************
 *
 *                     OPEN INDEX STRUCTURE
 *
 **************************************************************************/

typedef struct Idx 
{
    GHANDLE hStruct;        // Handle to this structure.
    DWORD dwKey;
    FCALLBACK_MSG Callback;

    LPBYTE  pLeadByteTable; // Pointer to table of DBCS lead bytes
    HANDLE  hLeadByteTable;
    IH20    ih;             // Index header.
    HFPB    hfpbIdxSubFile; // Index file handle.  If this is NULL, the
			    			//  index isn't open, else it is.
    //HFPB    hfpbSysFile;  // Handle of Index File system
    GHANDLE hTopNode;       // Handle to "lrgbTopNode".
    LRGB    lrgbTopNode;    // Pointer to the index top node.
    FLOAT   fSigmaTable;    // Sigma table
    HANDLE  hSigma;         // Handle of sigma table
    LPERRB  lperrb;         // Pointer to error block
    WORD    wSlackSize;     // Size of slack in a node
    WORD    Pad;
}   IDX,
    FAR *_LPIDX;            // The "_" indicates that this is
		//  a private structure that needs
		//  to be available publicly.  The
		//  public will call this an "LPIDX".

/*************************************************************************
 *
 *               Hitlist structure
 *
 *************************************************************************/

typedef struct  HitList
{
    GHANDLE hStruct;            // Structure's handle. MUST BE 1ST FIELD
    DWORD   lcReturnedTopics;   // The number of Topics returned. (what the user wants)
    DWORD   lcTotalNumOfTopics; // The total number of topics hit by the query.
    LPITOPIC  lpTopicList;      // Starting of TopicList
    LPBLK   lpOccMemBlock;      // Pointer to Occ memory block
    LPBLK   lpTopicMemBlock;    // Pointer to Topic memory block

    /* All the following fields are for internal use only */

    LPVOID  lpHttpQ;              // for online search only
    DWORD   lcMaxTopic;           // Max TopicId number (internal)
    LPITOPIC  lpLastTopic;        // Last accessed Topic pointer (internal)
    DWORD   lLastTopicId;         // Last accessed TopicId (internal)

    /* Topic list cache */
    GHANDLE hTopic;               // Handle to Topic file 
    GHANDLE hTopicCache;          // Handle to Topic cache
    LPITOPIC  lpTopicCache;       // Cache for Topic info
    DWORD   dwTopicCacheStart;    // Starting Topic number if the cache
    DWORD   dwTopicInCacheCount;  // Number of topic currently in cache

    /* Occurrence cache */
    GHANDLE hOcc;               // Handle to occurrences file 
    GHANDLE hOccCache;          // Handle to Occ cache
    DWORD   dwCurTopic;         // Current doc that the hit list belongs to
    LPIOCC  lpOccCache;         // Cache for Occ info
    DWORD   dwOccCacheStart;    // Starting Occ number if the cache

    /* Various hitlist info for hitlist merge */
    struct  HitList FAR * lpMainHitList;
    struct  HitList FAR * lpUpdateHitList;
    
    BYTE    lszTopicName[cbMAX_PATH]; // Topic filename
    BYTE    lszOccName[cbMAX_PATH];   // Occ filename
}   HL, FAR *_LPHL;

#define DO_FAST_MERGE(pSrch, lpqt) (((pSrch)->Flag & QUERYRESULT_SKIPOCCINFO) && ((lpqt)->fFlag & ALL_ANDORNOT))


/*************************************************************************
 *
 *                      Global Variables
 *
 *  Those variables should be read only
 *************************************************************************/
extern FNHANDLER HandlerFuncTable[];
extern OPSYM OperatorSymbolTable[]; 
extern OPSYM FlatOpSymbolTable[]; 
extern BYTE LigatureTable[];

/*************************************************************************
 *
 *                      Functions Prototypes
 *
 *************************************************************************/

/* qtparse.c */

PUBLIC LPQT PASCAL NEAR QueryTreeAlloc(void);
PUBLIC ERR PASCAL NEAR QueryTreeAddToken (_LPQT, int, LST, DWORD, BOOL);
PUBLIC LPQT PASCAL NEAR QueryTreeBuild (LPQI);
#if defined(_DEBUG) && DOS_ONLY
PUBLIC ERR PASCAL FAR PrintList(LPQT);
#endif

/* search.c */
PUBLIC ERR PASCAL NEAR ResolveTree(LPIDX, _LPQTNODE, LPRETV, BOOL);
PUBLIC BOOL NEAR PASCAL FGroupLookup(LPGROUP, DWORD);

/* qtlist */
PUBLIC TOPIC_LIST FAR* PASCAL NEAR TopicNodeAllocate(LPQT);
PUBLIC VOID PASCAL NEAR TopicNodeFree (LPQT, _LPQTNODE, LPITOPIC, LPITOPIC);
PUBLIC ERR PASCAL NEAR TopicNodeInsert (LPQT, _LPQTNODE, LPITOPIC);
PUBLIC LPITOPIC  PASCAL NEAR TopicNodeSearch(LPQT, _LPQTNODE, DWORD);
PUBLIC LPIOCC PASCAL NEAR OccNodeAllocate(LPQT);
PUBLIC LPIOCC  PASCAL NEAR OccNodeSearch(LPQT, LPITOPIC , LPIOCC );
PUBLIC ERR PASCAL NEAR OccNodeInsert(LPQT, LPITOPIC, LPIOCC);
PUBLIC int PASCAL NEAR OccCompare(LPIOCC, LPIOCC);
PUBLIC VOID PASCAL NEAR RemoveNode(LPQT, LPV, LPSLINK, LPSLINK, int);
PUBLIC VOID PASCAL NEAR FreeTree (_LPQTNODE);

/* combine.c */
PUBLIC VOID PASCAL NEAR RemoveUnmarkedTopicList (LPQT, _LPQTNODE, BOOL);
PUBLIC VOID PASCAL NEAR RemoveUnmarkedNearTopicList (_LPQT, _LPQTNODE);
PUBLIC VOID PASCAL NEAR MarkTopicList (_LPQTNODE);
PUBLIC VOID PASCAL NEAR MergeOccurence(LPQT, LPITOPIC , LPITOPIC);
PUBLIC VOID PASCAL NEAR SortResult (LPQT, _LPQTNODE, WORD);

PUBLIC ERR PASCAL NEAR OrHandler(LPQT, _LPQTNODE, LPITOPIC, LPV, int);
PUBLIC ERR PASCAL NEAR AndHandler(LPQT, _LPQTNODE, LPITOPIC, LPV, int);
PUBLIC ERR PASCAL NEAR NotHandler(LPQT, _LPQTNODE, LPITOPIC, LPV, int);
PUBLIC ERR PASCAL NEAR NearHandler(LPQT, _LPQTNODE, LPITOPIC, LPV, int);
PUBLIC ERR PASCAL NEAR PhraseHandler(LPQT, _LPQTNODE, LPITOPIC, LPV, int);
PUBLIC VOID PASCAL NEAR NearHandlerCleanUp (LPQT, _LPQTNODE);
PUBLIC ERR PASCAL NEAR TopicListSort (_LPQTNODE lpQtNode, BOOL fFlag);


// Critical structures that gets messed up in /Zp8
#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\permind2.c ===
/*************************************************************************
*                                                                        *
*  PERMIND2.C                                                            *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*  This is the final stage of the index building process.  This module   *
*  converts the input data into a permanent B-Tree file.                 *
*                                                                        *
*  Stem node structure:                                                  *
*  CbLeft |* Word | PointerToNode *| Slack                               *
*                                                                        *
*  Leaf node structure:                                                  *
*  NxtBlkPtr|CbLeft|*Word|FieldId|TopicCnt|PointerToNode|DataSize*|Slack *
*                                                                        *
*  Data node structure:                                                  *
*  |* Topic | OccBlkCnt |* OccBlk *| *| Slack                            *
*                                                                        *
*  Fields between |* *| repeat based on count values                     *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
**************************************************************************/

#include <mvopsys.h>
#include <mem.h>
#include <memory.h>
#include <math.h>
#include <orkin.h>
#include <mvsearch.h>
#include "common.h"
#include "index.h"

#ifdef _DEBUG
static BYTE NEAR s_aszModule[] = __FILE__;	/* Used by error return functions.*/
#endif


/*************************************************************************
 *
 *                   PRIVATE PUBLIC FUNCTIONS
 *
 * All of them should be declared far, unless we know they belong to
 * the same segment. They should be included in some include file
 *
 *************************************************************************/

PUBLIC HRESULT FAR PASCAL BuildBTree (HFPB, _LPIPB, LPB, HFPB, LPSTR);
PUBLIC PNODEINFO FAR PASCAL AllocBTreeNode (_LPIPB);
PUBLIC VOID PASCAL FAR FreeBTreeNode (PNODEINFO pNode);
PUBLIC int  FAR PASCAL PrefixCompressWord (LPB, LPB, LPB, int);
PUBLIC HRESULT FAR PASCAL FWriteBits(PFILEDATA, DWORD, BYTE);
PUBLIC DWORD FAR PASCAL WriteDataNode (_LPIPB, DWORD, PHRESULT);

/*************************************************************************
 *
 *                   PRIVATE PRIVATE FUNCTIONS
 *
 *************************************************************************/

PRIVATE HRESULT NEAR PASCAL AddRecordToLeaf (_LPIPB);
PRIVATE HRESULT NEAR PASCAL AddRecordToStem (_LPIPB, LPB);
PRIVATE int NEAR PASCAL CompressDword (PFILEDATA, DWORD);
PRIVATE HRESULT NEAR PASCAL WriteStemNode (_LPIPB, PNODEINFO);
PRIVATE HRESULT NEAR PASCAL WriteLeafNode (_LPIPB);
PRIVATE HRESULT NEAR PASCAL FlushAllNodes (_LPIPB);
// Compression functions
// PRIVATE HRESULT NEAR PASCAL FAddDword (PFILEDATA, DWORD, CKEY);
PRIVATE HRESULT NEAR PASCAL FWriteBool(PFILEDATA, BOOL);


// This table is used to avoid the calculation "(1L << v) - 1".  Instead
// you say "argdwBits[v]", which should be faster.  The table is useful
// other places, too.
DWORD argdwBits[] =
{
    0x00000000,     0x00000001,     0x00000003,     0x00000007,
    0x0000000F,     0x0000001F,     0x0000003F,     0x0000007F,
    0x000000FF,     0x000001FF,     0x000003FF,     0x000007FF,
    0x00000FFF,     0x00001FFF,     0x00003FFF,     0x00007FFF,
    0x0000FFFF,     0x0001FFFF,     0x0003FFFF,     0x0007FFFF,
    0x000FFFFF,     0x001FFFFF,     0x003FFFFF,     0x007FFFFF,
    0x00FFFFFF,     0x01FFFFFF,     0x03FFFFFF,     0x07FFFFFF,
    0x0FFFFFFF,     0x1FFFFFFF,     0x3FFFFFFF,     0x7FFFFFFF,
    0xFFFFFFFF,
};

PRIVATE HRESULT PASCAL NEAR WriteBitStreamDWord (PFILEDATA, DWORD, int);
PRIVATE HRESULT PASCAL NEAR WriteFixedDWord (PFILEDATA, DWORD, int);
PRIVATE HRESULT PASCAL NEAR WriteBellDWord (PFILEDATA, DWORD, int);

FENCODE EncodeTable[] =
{
	WriteBitStreamDWord,
	WriteFixedDWord,
	WriteBellDWord,
	NULL,
};


#define FAddDword(p,dw,key)   (EncodeTable[(key).cschScheme]((p), (dw), (key).ucCenter))
#define SAFE_SLACK  256

/*************************************************************************
 *
 * @doc  PRIVATE INDEXING
 *       
 * @func HRESULT | BuildBTree |
 *    Allocates required memory and opens input files to create a B-Tree.
 *    Parses incoming words and calls AddRecordToLeaf to process them.
 * 
 * @parm HFPB | hfpbSysFile |
 *    If not NULL, handle to an already opened sysfile
 *
 * @parm _LPIPB | lpipb |
 *    Pointer to the index parameter block
 *
 * @parm LPB | lpszTemp |
 *    Filename of the temporary input file
 *
 * @parm LPB | lpszPerm |
 *    Filename of the permanent B-Tree file
 *
 * @rdesc  Returns S_OK on success or errors if failed
 *
 *************************************************************************/

HRESULT FAR PASCAL BuildBTree (HFPB hfpbFileSys, _LPIPB lpipb,
    LPB lpszTemp, HFPB hfpbPerm, LPSTR lszFilename/*IStream *pistmPerm*/)
{
    PFILEDATA   pOutFile;                   // Pointer to output data
    PFILEDATA   pInFile;                    // Pointer to input data
    DWORD       dwBytesRead = 0;            // Checks for EOF
    DWORD       dwLeftover;                 // Used to adjust input buffer
    PBTREEDATA  pTreeData = &lpipb->BTreeData; // Structure defining BTree
    PIH20       pHeader = &pTreeData->Header; // Replacement variable
    HRESULT     fRet;                       // Return value
    PNODEINFO   pNode;                      // Pointer to current input node
    ERRB        errb= S_OK;
    PHRESULT      phr = &errb;
    int         iIndex;                     // Index into the compressed key
    DWORD       dwUniqueTerm = 0;           // Callback variable
	BOOL        fOpenedFile;				// TRUE if we have to close the file

    // Open input file
    pInFile = &lpipb->InFile;
    if ((pInFile->fFile = FileOpen (NULL, lpszTemp,
    	REGULAR_FILE, READ, phr)) == NULL)
        return *phr;

    // Allocate input buffer
    pInFile->dwMax = FILE_BUFFER;
    if ((pInFile->hMem =      
        _GLOBALALLOC (DLLGMEM_ZEROINIT, pInFile->dwMax + SAFE_SLACK)) == NULL)
    {
        fRet = E_OUTOFMEMORY;
exit0:
        FileClose (pInFile->fFile);
        if ((lpipb->idxf & KEEP_TEMP_FILE) == 0)
            FileUnlink (NULL, lpszTemp, REGULAR_FILE);
        return fRet;
    }
    pInFile->pMem = _GLOBALLOCK (pInFile->hMem);
    pInFile->pCurrent = pInFile->pMem;

    pOutFile = &lpipb->OutFile;

	/* Open subfile if necessary, (and system file if necessary) */
	pOutFile->fFile = hfpbPerm;
    if ((fOpenedFile = FsTypeFromHfpb(hfpbPerm) != FS_SUBFILE) &&
		(pOutFile->fFile = (HANDLE)FileOpen
			(hfpbPerm, lszFilename, hfpbPerm ? FS_SUBFILE : REGULAR_FILE,
			READ, phr)) == 0)
	{
        SetErrCode (&fRet, E_FILENOTFOUND);
exit1:
        FreeHandle (pInFile->hMem);
        goto exit0;
    }

    // Allocate output buffer, at least enough for one block
    pOutFile->dwMax = FILE_BUFFER;
	if (pOutFile->dwMax < (LONG)lpipb->BTreeData.Header.dwBlockSize)
		pOutFile->dwMax = lpipb->BTreeData.Header.dwBlockSize;
    if ((pOutFile->hMem = _GLOBALALLOC (DLLGMEM_ZEROINIT,
    	pOutFile->dwMax + SAFE_SLACK)) == NULL)
    {
        fRet = E_OUTOFMEMORY;
exit2:
		if (fOpenedFile)
			FileClose (hfpbPerm);
        goto exit1;
    }
    pOutFile->pMem = _GLOBALLOCK (pOutFile->hMem);
    
    // Skip 1K to hold header infomation
    pOutFile->pCurrent = pOutFile->pMem + FILE_HEADER;
    pOutFile->cbLeft = pOutFile->dwMax - FILE_HEADER;
    pOutFile->foPhysicalOffset.dwOffset = FILE_HEADER;
    pOutFile->ibit = cbitBYTE - 1;

    // Allocate first leaf node
    if ((pTreeData->rgpNodeInfo[0] = AllocBTreeNode (lpipb)) == NULL)
    {
        fRet = E_OUTOFMEMORY;
exit3:
        FreeHandle (pOutFile->hMem);
        goto exit2;
    }
    pHeader->nidLast = 1;
    pHeader->cIdxLevels = 1;

    // pNode points to the leaf node structure
    pNode = pTreeData->rgpNodeInfo[0];
    pNode->Slack = LEAF_SLACK;
    
    // Set the bytes left in node block
    pNode->cbLeft = lpipb->BTreeData.Header.dwBlockSize - FOFFSET_SIZE -
		 sizeof(WORD);

    // Set the word length flag
    if (lpipb->occf & OCCF_LENGTH)
        pTreeData->fOccfLength = 1;
        
#if 0
    // Save some math time if we're doing term-weighting
	if (lpipb->idxf & IDXF_NORMALIZE) 
	{
		MEMSET (pTreeData->argbLog, (BYTE)0, cLOG_MAX * sizeof (BYTE));
		if ((hLog = _GLOBALALLOC (GMEM_MOVEABLE,
			(CB)(cLOG_MAX * sizeof (FLOAT)))) == NULL) 
		{
            fRet = E_OUTOFMEMORY;
            goto exit3;
		}
		pTreeData->lrgrLog = (float FAR *)_GLOBALLOCK (hLog);
    }
    else
        hLog = NULL;
#endif

    // Load the input buffer & repeat until all records are processed
    pInFile->dwMax = pInFile->cbLeft = 
        FileRead (pInFile->fFile, pInFile->pMem, pInFile->dwMax, phr);
    do
    {
        // Call the user callback every once in a while
        if (!(++dwUniqueTerm % 8192L)
            && (lpipb->CallbackInfo.dwFlags & ERRFLAG_STATUS))
        {
            PFCALLBACK_MSG pCallbackInfo = &lpipb->CallbackInfo;
            CALLBACKINFO Info;

            Info.dwPhase = 3;
            Info.dwIndex = (DWORD)((float)dwUniqueTerm / lpipb->dwUniqueWord * 100);
            fRet = (*pCallbackInfo->MessageFunc)
                (ERRFLAG_STATUS, pCallbackInfo->pUserData, &Info);
            if (S_OK != fRet)
                goto exit4;
        }

        if ((fRet = AddRecordToLeaf (lpipb)) != S_OK)
            goto exit4;

        // pInFile->pCurrent points to the record size
        // 256 is just an arbitrary number of slack to minimize out of data

		// kevynct: pCurrent points to a record length which does not include
		// the DWORD record len size, so we add this when checking.  Actually, we
		// add twice that to be safe.        
        if (pInFile->cbLeft <= SAFE_SLACK ||
            (LONG)(GETLONG ((LPUL)(pInFile->pCurrent)) + 2 * sizeof(DWORD)) >= pInFile->cbLeft)
        {
            MEMMOVE (pInFile->pMem, pInFile->pCurrent, pInFile->cbLeft);
            if ((pInFile->cbLeft += FileRead (pInFile->fFile, pInFile->pMem + 
                pInFile->cbLeft, pInFile->dwMax - pInFile->cbLeft, phr)) < 0) 
            {
                fRet = *phr;
exit4:
                // Free log block used for term-weighting
#if 0
                FreeHandle (hLog);
#endif
                
                // Free all node blocks
                dwLeftover = 0;
                while (pTreeData->rgpNodeInfo[dwLeftover] != NULL)
                {
                    FreeBTreeNode(pTreeData->rgpNodeInfo[dwLeftover++]);
                }
                goto exit3;
            } 

            pInFile->dwMax = pInFile->cbLeft;
            pInFile->pCurrent = pInFile->pMem;
        }
    } while (fRet == S_OK && pInFile->cbLeft);

    // Flush anything left in the output buffer
    if ((fRet = FlushAllNodes (lpipb)) != S_OK)
        goto exit4;

    
    // Write out the sigma table
    if (lpipb->idxf & IDXF_NORMALIZE)
    {
        pHeader->WeightTabOffset = pOutFile->foPhysicalOffset;
        pHeader->WeightTabSize = (LCB)((lpipb->dwMaxTopicId + 1) *
            sizeof (SIGMA));
        if (FileWrite (pOutFile->fFile, lpipb->wi.hrgsigma,
            pHeader->WeightTabSize, phr) != (LONG)pHeader->WeightTabSize)
        {
            fRet = *phr;
            goto exit4;
        }
        pOutFile->foStartOffset = FoAddDw(pOutFile->foStartOffset,
            pHeader->WeightTabSize);
    }

    // Copy info to header
    pHeader->FileStamp = INDEX_STAMP;
    pHeader->version = VERCURRENT;
    pHeader->occf = lpipb->occf;
    pHeader->idxf = lpipb->idxf;
    pHeader->lcTopics = lpipb->lcTopics;
    pHeader->dwMaxTopicId = lpipb->dwMaxTopicId;
    pHeader->dwMaxFieldId = lpipb->dwMaxFieldId;
    
    pHeader->dwMaxWCount  = lpipb->dwMaxWCount;
    pHeader->dwMaxOffset  = lpipb->dwMaxOffset;
    pHeader->dwMaxWLen    = lpipb->dwMaxWLen;
    pHeader->dwTotalWords = lpipb->dwIndexedWord;  // Total indexed words
    pHeader->dwUniqueWords = lpipb->dwUniqueWord;  // Total unique words
    pHeader->dwTotal2bWordLen = lpipb->dwTotal2bWordLen;
    pHeader->dwTotal3bWordLen = lpipb->dwTotal3bWordLen;
    pHeader->dwUniqueWordLen = lpipb->dwTotalUniqueWordLen;
    
    pHeader->ckeyTopicId    = lpipb->cKey[CKEY_TOPIC_ID];
    pHeader->ckeyOccCount = lpipb->cKey[CKEY_OCC_COUNT];
    iIndex = CKEY_OCC_BASE;
    if (pHeader->occf & OCCF_COUNT)
        pHeader->ckeyWordCount = lpipb->cKey[iIndex++];
    if (pHeader->occf & OCCF_OFFSET)
        pHeader->ckeyOffset    = lpipb->cKey[iIndex];

    if (FileSeekWrite (pOutFile->fFile, (LPB)pHeader, MakeFo (0, 0),
        sizeof (IH20), phr) != sizeof (IH20))
    {
        fRet = *phr;
        goto exit4;
    }
        
    // Call the user callback every once in a while
    if (lpipb->CallbackInfo.dwFlags & ERRFLAG_STATUS)
    {
        PFCALLBACK_MSG pCallbackInfo = &lpipb->CallbackInfo;
        CALLBACKINFO Info;

        Info.dwPhase = 3;
        Info.dwIndex = 100;
        fRet = (*pCallbackInfo->MessageFunc)
            (ERRFLAG_STATUS, pCallbackInfo->pUserData, &Info);
        if (S_OK != fRet)
            goto exit4;
    }
    fRet = S_OK;
    goto exit4;
} /* BuildBTree */


/*************************************************************************
 *
 * @doc  PRIVATE INDEXING
 *       
 * @func HRESULT | AddRecordToLeaf |
 *    Add the record pointed to by pDtreeData->OutFile->pCurrent to the B-Tree
 *    contained in the structure.
 *
 * @parm _LPIPB | lpipb |
 *    Pointer to the index parameter block
 *
 * @rdesc  Returns S_OK on success or errors if failed
 *
 *************************************************************************/
#ifdef _DEBUG
	static BYTE LastWord[4000] = {0};
	static BYTE CurWord[4000] = {0};
#endif

HRESULT PASCAL AddRecordToLeaf (_LPIPB lpipb)
{
    // Local Replacement Variables
    PBTREEDATA pTreeData    = &lpipb->BTreeData;
    PFILEDATA   pOutFile    = &lpipb->OutFile;           // Output data
    PFILEDATA   pInFile     = &lpipb->InFile;           // Input data
    HFPB        fOutput     = pOutFile->fFile;               // Output file
    HFPB        fInput      = lpipb->InFile.fFile;       // Input file
    LPB         pInCurPtr   = lpipb->InFile.pCurrent;    // Input buffer
    PNODEINFO   pNode;
    LPB         lpbWord;        // Pointer to the word string
    OCCF        occf        = lpipb->occf;
    
    // Working Variables
    DWORD   dwTopicCount;       // Number of topic in record
    DWORD   dwFieldId;
    DWORD   dwBlockSize;        // Size of the entire occ block
    LPB     pDest;
	WORD    uStringSize;
    ERRB    errb;


    // We always start from the leaf node
    pNode = pTreeData->rgpNodeInfo[0];

    // Set pointer to working buffer
    pDest = pNode->pTmpResult;
    
    // Advance input buffer to the word string
    pInCurPtr += sizeof (DWORD);
    lpbWord = pInCurPtr;

    // Insert the word into the buffer
    pDest += PrefixCompressWord (pDest, pInCurPtr,
    	pNode->pLastWord, pTreeData->fOccfLength);
    
    // Get the word length
    uStringSize = GETWORD((LPUW)pInCurPtr);
    lpipb->dwTotalUniqueWordLen += uStringSize;
    
    // Adjust for the word length storage
    uStringSize += sizeof(SHORT);
    
    // Skip the word
    pInCurPtr += uStringSize;
    
#ifdef _DEBUG
	STRCPY (LastWord, CurWord);
	MEMCPY (CurWord, lpbWord + 2, GETWORD((LPUW)lpbWord));
	CurWord[GETWORD((LPUW)lpbWord)] = 0;
	if (STRCMP (LastWord, CurWord) > 0)
		SetErrCode (NULL, E_ASSERT);
	// if (STRCMP (CurWord, "forbidden") == 0)
	//	_asm int 3;
#endif
    
    // If OccfLength is set skip it now 
    // (It has already been appended to the compressed word)
    if (pTreeData->fOccfLength)
        pInCurPtr += CbByteUnpack(&dwBlockSize, pInCurPtr);

    // Copy the FieldID
    if (occf & OCCF_FIELDID)
    {
        CbByteUnpack (&dwFieldId, pInCurPtr);
        do {
            *pDest++ = *pInCurPtr;
        } while (*pInCurPtr++ & 0x80);
    }

    // Get Topic Count
#if 0
    CbByteUnpack (&dwTopicCount, pInCurPtr);
    do 
    {
        *pDest++ = *pInCurPtr;
    } while (*pInCurPtr++ & 0x80);
#else
    dwTopicCount = GETLONG((LPUL)pInCurPtr);
    pInCurPtr += sizeof(DWORD);
    pDest += CbBytePack(pDest, dwTopicCount);
#endif

    // Check to see if this entry will fit in the leaf node
    // We can't write the data block until we know where the entry
    // will be stored.  We must add in FOFFSET_SIZE to our current location
    // to determine size.  We ignore the block size field, so we might encroach
    // on the slack by a few bytes.
    if (pNode->cbLeft - pNode->Slack < (SHORT)(pDest -pNode->pTmpResult +FOFFSET_SIZE))
    {
		HRESULT fRet;

        if ((fRet = AddRecordToStem (lpipb, lpbWord)) != S_OK)
            return(fRet);
            
        // If the prefix count is zero, no problem
        // Else we have to re-copy the word, since we are in a new leaf node
        if (0 != pNode->pTmpResult[1])
        {
            dwBlockSize = PrefixCompressWord (pNode->pTmpResult, lpbWord, 
                pNode->pLastWord, pTreeData->fOccfLength);
            pDest = pNode->pTmpResult + dwBlockSize;
            if (occf & OCCF_FIELDID)
                pDest += CbBytePack (pDest, dwFieldId);
            pDest += CbBytePack (pDest, dwTopicCount);
        }
    }
    // Save new word as last word
    MEMCPY (pNode->pLastWord, lpbWord, uStringSize + 2);

    // Set pointer to beginning of data block
    pDest += CopyFileOffset (pDest, pOutFile->foPhysicalOffset);
                         
    // Update the bytes left
    pInFile->cbLeft -= (LONG) (pInCurPtr - pInFile->pCurrent);
#ifdef _DEBUG
    if (pInFile->cbLeft <= 0)
        SetErrCode (NULL, E_ASSERT);
#endif
    
    // Compress data block to output buffer and store it's compressed size
    pInFile->pCurrent = pInCurPtr;
    if ((dwBlockSize = WriteDataNode (lpipb, dwTopicCount, &errb)) == 0)
        return errb;
    pDest += CbBytePack (pDest, dwBlockSize);

    // Copy the temp buffer to the real node
    dwBlockSize = (DWORD)(pDest - pNode->pTmpResult);
    MEMCPY (pNode->pCurPtr, pNode->pTmpResult, dwBlockSize);
    pNode->pCurPtr += dwBlockSize;
    pNode->cbLeft -= (WORD)dwBlockSize;

    return S_OK;
}


/*************************************************************************
 *
 * @doc  PRIVATE INDEXING
 *
 * @func DWORD | AddRecordToStem |
 *    Add a key to a stem node, creating/flushing nodes as necessary.
 *
 * @parm LPB | lpbWord |
 *    The word to add the the stem node (last word in the full leaf node)
 *
 *  @rdesc  S_OK if successful, or errors if failed
 *
 *************************************************************************/

HRESULT PASCAL AddRecordToStem (_LPIPB lpipb, LPB lpbWord)
{
    SHORT       CurLevel = 0;
    PNODEINFO   pStemNode;
    PNODEINFO   pLastNode;

    PBTREEDATA pTreeData = &lpipb->BTreeData;    
    PNODEINFO   pLeafNode = pTreeData->rgpNodeInfo[0];
    LPB         pLastWord;
    int         cbTemp;
    ERRB        errb = S_OK;
    HRESULT         fRet;

    // Move up through stem nodes until space can be found/made
    pStemNode = pLeafNode;
    do
    {
        pLastWord = pStemNode->pLastWord;
        pStemNode = pTreeData->rgpNodeInfo[++CurLevel];
        if (pStemNode == NULL)
        {   // Create a new stem node
            if ((pStemNode = pTreeData->rgpNodeInfo[CurLevel] = 
                AllocBTreeNode (lpipb)) == NULL)
                return SetErrCode (NULL, E_OUTOFMEMORY);
            pStemNode->Slack = STEM_SLACK;
            pStemNode->cbLeft = lpipb->BTreeData.Header.dwBlockSize
				- sizeof(WORD);
            if (++pTreeData->Header.cIdxLevels > MAX_TREE_HEIGHT)
				return E_TREETOOBIG;
        }
        pTreeData->Header.nidLast++;
    } while (pStemNode->cbLeft - pStemNode->Slack < 
        (SHORT)(GETWORD ((LPUW)pLastWord) + sizeof (SHORT) + FOFFSET_SIZE));
        
    // Work back down through the nodes clearing them to disk
    while (CurLevel > 1)
    {
        pLastNode = pTreeData->rgpNodeInfo[--CurLevel];
        pLastWord = pLastNode->pLastWord;
        // Copy word to stem node
        if ((cbTemp = PrefixCompressWord (pStemNode->pCurPtr, pLastWord, 
            pStemNode->pLastWord, pTreeData->fOccfLength)) == 0)
        {
            return errb;
        }
        pStemNode->pCurPtr += cbTemp;
        
        // Update the last word in the stem node
        MEMCPY (pStemNode->pLastWord, pLastWord, GETWORD((LPUW)pLastWord)+ 2*sizeof(WORD));
        
        // Set pointer in stem node
        CopyFileOffset (pStemNode->pCurPtr,
			lpipb->OutFile.foPhysicalOffset);
        pStemNode->pCurPtr += FOFFSET_SIZE;
        pStemNode->cbLeft -= FOFFSET_SIZE + cbTemp;
#ifdef _DEBUG
        if (pStemNode->cbLeft <= 0)
            SetErrCode (NULL, E_ASSERT);
#endif

        pStemNode = pTreeData->rgpNodeInfo[CurLevel];
        if ((fRet = WriteStemNode (lpipb, pStemNode)) != S_OK)
            return(fRet);
            
    }
        
    // Clear the leaf node into the first stem node & reset it
        
    // Copy last word to stem node
    if ((cbTemp = PrefixCompressWord (pStemNode->pCurPtr, 
        pLeafNode->pLastWord, pStemNode->pLastWord, 
        pTreeData->fOccfLength)) == 0)
    {
        return errb;
    }
    pStemNode->pCurPtr += cbTemp;
    pStemNode->cbLeft -= cbTemp;
#ifdef _DEBUG
    if (pStemNode->cbLeft <= 0)
        SetErrCode (NULL, E_ASSERT);
#endif


    // Update the last word in the stem node
    MEMCPY (pStemNode->pLastWord, pLeafNode->pLastWord,
		GETWORD((LPUW)(pLeafNode->pLastWord))+2*sizeof(WORD));
        
    // Set pointer to the leaf node
    CopyFileOffset (pStemNode->pCurPtr, lpipb->OutFile.foPhysicalOffset);
    pStemNode->pCurPtr += FOFFSET_SIZE;
    pStemNode->cbLeft -= FOFFSET_SIZE;
#ifdef _DEBUG
    if (pStemNode->cbLeft <= 0)
        SetErrCode (NULL, E_ASSERT);
#endif

    // Flush leaf node to output buffer and reset it
    return WriteLeafNode (lpipb);
}


/*************************************************************************
 *
 * @doc  PRIVATE INDEXING
 *
 * @func int | CompressDword |
 *    Compresses the input stream into the output buffer using a high
 *    bit encoding method.  If the buffer is full it will be flushed to
 *    a file.
 *
 * @parm PFILEDATA | pOutput |
 *    Pointer to output buffer info
 *
 * @parm LPDWORD | pSrc |
 *    Pointer to the uncompressed input stream
 *
 *  @rdesc  Returns the number of compressed bytes buffered
 *
 *************************************************************************/

int PASCAL CompressDword (PFILEDATA pOutput, DWORD dwValue)
{
    LPB     pDest = pOutput->pCurrent;
    int     cBytes = 0;         // Count of compressed bytes
    ERRB    errb;

    // Any room left in output buffer?
    if (sizeof(DWORD) * 2 >= pOutput->cbLeft)
    {
        DWORD dwSize;
        
        FileWrite (pOutput->fFile, pOutput->pMem,
            (dwSize = (DWORD)(pDest - pOutput->pMem)), &errb);
        pDest = pOutput->pMem;
        pOutput->cbLeft = pOutput->dwMax;
        pOutput->foStartOffset = FoAddDw(pOutput->foStartOffset, dwSize);
    }

    while (dwValue)
    {
        *pDest = (BYTE)(dwValue & 0x7F);
        cBytes++;
        dwValue >>= 7;
        if (dwValue != 0)
            *pDest |= 0x80;
        pDest++;
    }
    pOutput->pCurrent = pDest;
    pOutput->foPhysicalOffset = 
        FoAddDw (pOutput->foPhysicalOffset, (DWORD)cBytes);
    pOutput->cbLeft -= cBytes;
#ifdef _DEBUG
    if (pOutput->cbLeft <= 0)
        SetErrCode (NULL, E_ASSERT);
#endif
    return cBytes;
}


/*************************************************************************
 *
 *  @doc  PRIVATE INDEXING
 *
 *  @func   DWORD | WriteDataNode |
 *      Compresses the input stream into the output buffer. If the buffer
 *      is full it will be flushed to a file.
 *
 *  @parm   _LPIPB | lpipb |
 *      Pointer to global buffer
 *
 *  @parm   DWORD | dwTopicCount |
 *      The number of topics in the input stream
 *
 *  @parm   PHRESULT | phr |
 *      Error buffer
 *
 *  @rdesc  Returns the number of compressed bytes written
 *
 *************************************************************************/

PUBLIC DWORD PASCAL FAR WriteDataNode (_LPIPB lpipb,
    DWORD dwTopicCount, PHRESULT phr)
 {
    // Local replacement Variables
    PBTREEDATA pTreeData = &lpipb->BTreeData;
    PFILEDATA pOutput    = &lpipb->OutFile;  // Output data structure
    PFILEDATA pInFile    = &lpipb->InFile;  // Input data structre
    HFPB      fFile      = pOutput->fFile;  // Output file handle

    // Working Variables
    DWORD dwBlockSize;          // Size of block to compress
    DWORD dwEncodedSize = 0;    // Size of encoded block
    DWORD dwTopicIdDelta;       // Really only used for weight values
    DWORD TopicLoop;
    DWORD dwSlackSize;
    DWORD loop;
    DWORD dwTemp;
    FILEOFFSET foStart;         // Physical beginning of bit compression block
    FLOAT rTerm;                // Only used when IDXF_NORMALIZE is set
    FLOAT rWeight;              // Only used when IDXF_NORMALIZE is set
    WORD  wWeight;              // Only used when IDXF_NORMALIZE is set
    DWORD dwTopicId = 0;          // Only used when IDXF_NORMALIZE is set
    int   cbTemp;               // # of compressed bytes that uncompressed
    OCCF  occf = lpipb->occf;
    HRESULT   fRet;

    foStart = pOutput->foPhysicalOffset;
	wWeight = 0;	// UNDONE: Don't need it

    for (TopicLoop = dwTopicCount; TopicLoop > 0; --TopicLoop)
    {
        // Move to the byte boundary
        if (pOutput->ibit != cbitBYTE - 1)
        {
            pOutput->ibit = cbitBYTE - 1;
   
            if (--pOutput->cbLeft)
            {
                pOutput->pCurrent++;
                pOutput->foPhysicalOffset = FoAddDw (pOutput->foPhysicalOffset, 1);
            }
            else
            {
                if (FileWrite (pOutput->fFile, pOutput->pMem,
                    dwTemp = (DWORD)(pOutput->pCurrent - pOutput->pMem), phr) != (LONG)dwTemp)
                    return(0);
                pOutput->pCurrent = pOutput->pMem;
                pOutput->cbLeft = pOutput->dwMax;
                pOutput->foStartOffset = FoAddDw(pOutput->foStartOffset, dwTemp);
#ifdef _DEBUG
                MEMSET (pOutput->pMem, 0, pOutput->dwMax);
#endif
            }
        }
        // Store TopicId as necessary
        if (pInFile->cbLeft < 2 * sizeof (DWORD))
        {
            MEMMOVE (pInFile->pMem, pInFile->pCurrent, pInFile->cbLeft);
            pInFile->cbLeft += FileRead (pInFile->fFile, pInFile->pMem + pInFile->cbLeft,
                pInFile->dwMax - pInFile->cbLeft, phr);
            pInFile->dwMax = pInFile->cbLeft;
            pInFile->pCurrent = pInFile->pMem;
        }
        cbTemp = CbByteUnpack (&dwTopicIdDelta, pInFile->pCurrent);
        dwTopicId += dwTopicIdDelta;  // Get the real TopicID
        if ((fRet = FAddDword (pOutput, dwTopicIdDelta,
            lpipb->cKey[CKEY_TOPIC_ID])) != S_OK)
        {
            SetErrCode(phr, fRet);
            return(0);
            
        }
            
        pInFile->pCurrent += cbTemp;
        pInFile->cbLeft -= cbTemp;
        
        if (occf & OCCF_HAVE_OCCURRENCE)
        {
            
            // Get number of occ data records for this topic
            if (pInFile->cbLeft < 2 * sizeof (DWORD))
            {
                MEMMOVE (pInFile->pMem, pInFile->pCurrent, pInFile->cbLeft);
                pInFile->cbLeft += FileRead (pInFile->fFile,
                    pInFile->pMem + pInFile->cbLeft,
                    pInFile->dwMax - pInFile->cbLeft, phr);
                pInFile->dwMax = pInFile->cbLeft;
                pInFile->pCurrent = pInFile->pMem;
            }
            cbTemp = CbByteUnpack (&dwBlockSize, pInFile->pCurrent);
            pInFile->pCurrent += cbTemp;
            pInFile->cbLeft -= cbTemp;
        }

        // If we are term weighing we have to calculate the weight
        if (lpipb->idxf & IDXF_NORMALIZE)
        {
#ifndef ISBU_IR_CHANGE
			// log10(x/y) == log10 (x) - log10 (y). Since x in our case is a known constant,
			// 100,000,000, I'm replacing that with its equivalent log10 value of 8.0 and subtracting
			// the log10(y) from it
			rTerm = (float) (8.0 - log10((double) dwTopicCount));
			// In extreme cases, rTerm could be 0 or even -ve (when dwTopicCount approaches or 
			// exceeds 100,000,000)
			if (rTerm <= (float) 0.0)
				rTerm = cVerySmallWt;	// very small value. == log(100 mil/ 95 mil)
			// NOTE : rWeight for the doc term would be as follows:
			//	rWeight = float(min(4096, dwBlockSize)) * rTerm / lpipb->wi.hrgsigma[dwTopicId]
			//
			// Since rTerm needs to be recomputed again for the query term weight computation,
			// and since rTerm will be the same value for the current term ('cos N and n of log(N/n)
			// are the same (N = 100 million and n is whatever the doc term freq is for the term),
			// we will factor in the second rTerm at index time. This way, we don't have to deal
			// with rTerm at search time (reduces computation and query time shortens)
			//
			// MV 2.0 initially did the same thing. However, BinhN removed the second rTerm
			// because he decided to remove the rTerm altogether from the query term weight. He
			// did that to keep the scores reasonably high.

			rWeight = ((float) min(cTFThreshold, dwBlockSize)) * rTerm * rTerm / lpipb->wi.hrgsigma[dwTopicId];
			// without the additional rTerm, we would probably be between 0.0 and 1.0
			if (rWeight > rTerm)
				wWeight = 0xFFFF;
			else
				wWeight = (WORD) ((float)0xFFFF * rWeight / rTerm);
#else
            rTerm = (float) (65535.0 * 8) / (float)dwTopicCount;
            
            rWeight = (float)dwBlockSize * rTerm / lpipb->wi.hrgsigma[dwTopicId];
            if (rWeight >= 65535.0)
                wWeight = 65335;
            else
                wWeight = (WORD)rWeight;    
#endif // ISBU_IR_CHANGE

            // Write the weight to the output buffer
            if ((fRet = FWriteBits (&lpipb->OutFile, (DWORD)wWeight, 
                (BYTE)(sizeof (WORD) * cbitBYTE))) != S_OK)
            {
                SetErrCode (phr, fRet);
                return(0);
            }
        }

        // Don't do anything else if there is nothing else to do!!!
        if ((occf & OCCF_HAVE_OCCURRENCE) == 0)
            continue;
            
        // Write the OccCount
        if ((fRet = FAddDword (pOutput, dwBlockSize,
            lpipb->cKey[CKEY_OCC_COUNT])) != S_OK) 
        {
            SetErrCode (phr, fRet);
            return(0);
        }

        // Encode the occ block
        for (loop = dwBlockSize; loop > 0; loop--)
        {
            int iIndex;
            
            iIndex = CKEY_OCC_BASE;
            
            // Make sure input buffer holds enough data
            if (pInFile->cbLeft < 5 * sizeof (DWORD))
            {
                MEMMOVE (pInFile->pMem, pInFile->pCurrent, pInFile->cbLeft);
                pInFile->cbLeft += FileRead (pInFile->fFile,
                    pInFile->pMem + pInFile->cbLeft,
                    pInFile->dwMax - pInFile->cbLeft, phr);
                pInFile->dwMax = pInFile->cbLeft;
                pInFile->pCurrent = pInFile->pMem;
            }

            if (occf & OCCF_COUNT)
            {
                cbTemp = CbByteUnpack (&dwTemp, pInFile->pCurrent);
                pInFile->pCurrent += cbTemp;
                pInFile->cbLeft -= cbTemp;
                if ((fRet = FAddDword (pOutput, dwTemp, lpipb->cKey[iIndex])) !=
                    S_OK)
                {
                    SetErrCode (phr, fRet);
                    return(0);
                }
				iIndex++;
            }
            if (occf & OCCF_OFFSET)
            {
                cbTemp = CbByteUnpack (&dwTemp, pInFile->pCurrent);
                pInFile->pCurrent += cbTemp;
                pInFile->cbLeft -= cbTemp;
                if ((fRet = FAddDword (pOutput, dwTemp, lpipb->cKey[iIndex])) !=
                    S_OK)
                {
                    SetErrCode (phr, fRet);
                    return(0);
                }
            }
        }
    }
    // Advance to next byte (we are partially through a byte now)
    pOutput->ibit = cbitBYTE - 1;
    pOutput->pCurrent++;
    pOutput->foPhysicalOffset = FoAddDw (pOutput->foPhysicalOffset, 1);
    pOutput->cbLeft--;
#ifdef _DEBUG
    if (pOutput->cbLeft <= 0)
        SetErrCode (NULL, E_ASSERT);
#endif
    dwEncodedSize += DwSubFo (pOutput->foPhysicalOffset, foStart);
        
    // Leave slack space, but not for uncommon words
    if (dwTopicCount <= 2)
        dwSlackSize = 0;
    else
        dwSlackSize = dwEncodedSize / 10;

    dwEncodedSize += dwSlackSize;
    // Keep a running total of all allocated slack space
    pTreeData->Header.dwSlackCount += dwSlackSize;

    while (dwSlackSize)
    {
        if (pOutput->cbLeft < (LONG)dwSlackSize)
        {   // The slack block doesn't fit in the output buffer
            // Write as much as we can then flush the buffer and write the rest
            // MEMSET (pOutput->pCurrent, 0, pOutput->cbLeft);
            DWORD dwSize;
            
            dwSlackSize -= pOutput->cbLeft;
            if (0 == FileWrite  (fFile, pOutput->pMem,
                dwSize = pOutput->dwMax, phr))
            {
                return 0;
            }
            pOutput->pCurrent = pOutput->pMem;
            pOutput->foPhysicalOffset = 
                FoAddDw (pOutput->foPhysicalOffset, pOutput->cbLeft);
            pOutput->cbLeft = pOutput->dwMax;
            pOutput->foStartOffset = FoAddDw(pOutput->foStartOffset, dwSize);
        }
        else
        {   // The slack fits, no problems
            MEMSET (pOutput->pCurrent, 0, dwSlackSize);
            pOutput->pCurrent += dwSlackSize;
            pOutput->foPhysicalOffset = 
                FoAddDw (pOutput->foPhysicalOffset, dwSlackSize);
            pOutput->cbLeft -= dwSlackSize;
#ifdef _DEBUG
            if (pOutput->cbLeft <= 0)
                SetErrCode (NULL, E_ASSERT);
#endif
            dwSlackSize = 0;
        }
    }
    return dwEncodedSize;
}


/*************************************************************************
 *
 * @doc  PRIVATE INDEXING
 *
 * @func void | WriteStemNode |
 *    Flushes a stem node in the BTree to the output buffer.  Once flushed,
 *    the node is reset to the beginning and filled with zeros.
 *
 * @parm _LPIPB | lpipb |
 *    Pointer the IPB structure
 *
 * @parm PNODEINFO | pNode |
 *    Pointer to the node to flush
 *
 *************************************************************************/

PRIVATE HRESULT PASCAL WriteStemNode (_LPIPB lpipb, PNODEINFO pNode)
{
    // Local Replacement Variable
    PBTREEDATA pTreeData = &lpipb->BTreeData;
    PFILEDATA pOutput = &lpipb->OutFile; // Output structure
    LPB     pDest;                      // Output buffer
    LPB     pStart = pNode->pBuffer;       // Start of node buffer

    // Local Working Variables
    DWORD   dwBytesLeft;                // Bytes left to write
    ERRB    errb;

#if 0    // Use 2-bytes for cbLeft to simplify the work of update
    // Compress CbLeft to output buffer
    dwBytesLeft = lpipb->BTreeData.Header.dwBlockSize - FOFFSET_SIZE - 
        CompressDword (pOutput, (DWORD)pNode->cbLeft);
#else
    *(LPUW)(pOutput->pCurrent) = (WORD)pNode->cbLeft;
    pOutput->pCurrent += sizeof(WORD);
    pOutput->cbLeft -= sizeof(WORD);
    pOutput->foPhysicalOffset = 
        FoAddDw (pOutput->foPhysicalOffset, (DWORD)sizeof(WORD));
    dwBytesLeft = lpipb->BTreeData.Header.dwBlockSize - sizeof(WORD);
#endif
    pDest = pOutput->pCurrent;

    // Keep a running total of all allocated slack space
    pTreeData->Header.dwSlackCount += pNode->cbLeft;

    // This is why the buffer must be >= BTREE_NODE_SIZE
    // This could be put in a loop to avoid that restriction, but it
    // is probably not worth it.  (See also WriteLeafNode)
    if (pOutput->cbLeft < (LONG)dwBytesLeft)
    {
        LONG dwSize;
        if (FileWrite (pOutput->fFile,
            pOutput->pMem, dwSize = (DWORD)(pDest - pOutput->pMem), &errb) != dwSize)
            return(errb);
            
        pDest = pOutput->pMem;
        pOutput->cbLeft = pOutput->dwMax;
        pOutput->foStartOffset = FoAddDw(pOutput->foStartOffset, dwSize);
    }
    MEMCPY (pDest, pStart, dwBytesLeft);
    pOutput->foPhysicalOffset = 
        FoAddDw (pOutput->foPhysicalOffset, dwBytesLeft);
    pOutput->cbLeft -= dwBytesLeft;
#ifdef _DEBUG
    if (pOutput->cbLeft <= 0)
        SetErrCode (NULL, E_ASSERT);
#endif
    // Set the external variable
    pOutput->pCurrent = pDest + dwBytesLeft;

    // Set to all zeros so we know when we have reached the end of data later
    MEMSET (pNode->pBuffer, 0, lpipb->BTreeData.Header.dwBlockSize);
    pNode->cbLeft = lpipb->BTreeData.Header.dwBlockSize - sizeof(WORD);
	pNode->pCurPtr = pNode->pBuffer;
    *(PUSHORT)pNode->pLastWord = 0;
    return(S_OK);
    
}


/*************************************************************************
 *
 *  @doc  PRIVATE INDEXING
 *
 *  @func void | WriteLeafNode |
 *    Flushes a leaf node in the BTree to the output buffer.  Once flushed,
 *    the node is reset to the beginning and filled with zeros.
 *
 *  @parm   _LPIPB | lpipb |
 *      Pointer to index block
 *
 *  @rdesc S_OK or other errors
 *************************************************************************/

PRIVATE HRESULT PASCAL NEAR WriteLeafNode (_LPIPB lpipb)
{
    // Local Replacement Variables
    PBTREEDATA pTreeData = &lpipb->BTreeData;
    PFILEDATA   pOutput = &lpipb->OutFile;       // Output data structure
    LPB         pDest   = pOutput->pCurrent;    // Output buffer
    FILEOFFSET  OffsetPointer = pTreeData->OffsetPointer;
    FILEOFFSET  foPhysicalOffset = pOutput->foPhysicalOffset;
    PNODEINFO   pNode   = pTreeData->rgpNodeInfo[0];  // Leaf node
    LPB         pStart  = pNode->pBuffer;          // Beginning of the node buffer
    // Working Variables
    DWORD       dwLeft;
    FILEOFFSET  StartOffset;            // Physical offset of the begining
                                        // of the output buffer
    ERRB        errb;

    // Backpatch the current offset to the last nodes pointer
    if (!FoIsNil (OffsetPointer))
    {
        // Is the backpatch location in the output buffer?
        if (FoCompare (OffsetPointer, 
            (StartOffset = FoSubFo (foPhysicalOffset,
            MakeFo ((DWORD)(pDest - pOutput->pMem), 0)))) >= 0)
        {
            CopyFileOffset (pOutput->pMem + DwSubFo 
                (OffsetPointer, StartOffset), foPhysicalOffset);
        }
        else
        {
            if (FileSeekWrite (pOutput->fFile, &foPhysicalOffset, 
                OffsetPointer, sizeof (DWORD), &errb) !=
                sizeof (DWORD))
                return(errb);
                
            FileSeek (pOutput->fFile, StartOffset, 0, NULL);
        }
    }
    // Set the backpatch location for next time
    pTreeData->OffsetPointer = foPhysicalOffset;

    // Skip the record pointer for this record (will be backpatched next time)

    if (pOutput->cbLeft <= 0 )
    {
        LONG dwSize;
    
        if (FileWrite (pOutput->fFile, pOutput->pMem,
            dwSize = (DWORD)(pDest - pOutput->pMem), &errb) != dwSize)
            return(errb);
            
        pDest = pOutput->pMem;
        pOutput->cbLeft = pOutput->dwMax;
        pOutput->foStartOffset = FoAddDw(pOutput->foStartOffset, dwSize);
    }
    MEMSET (pDest, 0, FOFFSET_SIZE);
    pOutput->cbLeft -= FOFFSET_SIZE;
#ifdef _DEBUG
    if (pOutput->cbLeft <= 0)
        SetErrCode (NULL, E_ASSERT);
#endif
    pOutput->pCurrent = pDest + FOFFSET_SIZE;
    pOutput->foPhysicalOffset = FoAddDw (foPhysicalOffset, FOFFSET_SIZE);

#if 0    // Use 2-bytes for cbLeft to simplify the work of update
    // Compress CbLeft to output buffer
    dwLeft = lpipb->BTreeData.Header.dwBlockSize - FOFFSET_SIZE - 
        CompressDword (pOutput, (DWORD)pNode->cbLeft);
#else
    *(LPUW)(pOutput->pCurrent) = (WORD)pNode->cbLeft;
    pOutput->foPhysicalOffset = 
        FoAddDw (pOutput->foPhysicalOffset, (DWORD)sizeof(WORD));
    pOutput->cbLeft -= sizeof(WORD);
    dwLeft = lpipb->BTreeData.Header.dwBlockSize - FOFFSET_SIZE - sizeof(WORD);
    pOutput->pCurrent += sizeof(WORD);
#endif
    pDest = pOutput->pCurrent;

    // Keep a running total of all allocated slack space
    pTreeData->Header.dwSlackCount += pNode->cbLeft;
    
    // This is why the buffer must be >= BTREE_NODE_SIZE
    // This could be put in a loop to avoid that restriction, but it
    // is probably not worth it.  (See also WriteStemNode)
    if (pOutput->cbLeft < (LONG)dwLeft)
    {
        LONG dwSize;
        if (FileWrite (pOutput->fFile, pOutput->pMem,
            dwSize = (DWORD)(pDest - pOutput->pMem), &errb) != dwSize)
            return(errb);
            
        pDest = pOutput->pMem;
        pOutput->cbLeft = pOutput->dwMax;
        pOutput->foStartOffset = FoAddDw(pOutput->foStartOffset, dwSize);
    }
    MEMCPY (pDest, pStart, dwLeft);
    pOutput->foPhysicalOffset = 
        FoAddDw (pOutput->foPhysicalOffset, dwLeft);
    pOutput->cbLeft -= dwLeft;
#ifdef _DEBUG
    if (pOutput->cbLeft <= 0)
        SetErrCode (NULL, E_ASSERT);
#endif
    pOutput->pCurrent = pDest + dwLeft;

    // Reset buffer back to beginning
    MEMSET (pNode->pBuffer, 0, lpipb->BTreeData.Header.dwBlockSize);
    pNode->pCurPtr = pNode->pBuffer;
    
    // Set the bytes left in node block
    pNode->cbLeft = lpipb->BTreeData.Header.dwBlockSize -
		FOFFSET_SIZE - sizeof(WORD);
    *(PUSHORT)pNode->pLastWord = 0;
    return(S_OK);
    
}


/*************************************************************************
 * @doc  PRIVATE INDEXING
 *
 * @func PNODEINFO | AllocBTreeNode |
 *    Allocates memory for the node structure as well as the data buffer
 *    contained in the structure.
 *
 * @parm _LPIPB | lpipb |
 *    Pointer to index parameter block 
 *
 * @rdesc  Returns a pointer to the newly allocated node
 *************************************************************************/

PUBLIC PNODEINFO PASCAL FAR AllocBTreeNode (_LPIPB lpipb)
{
    PNODEINFO pNode;

    // Allocate node structure
    if ((pNode =  GlobalLockedStructMemAlloc (sizeof (NODEINFO))) == NULL)
    {
exit0:
        SetErrCode (NULL, E_OUTOFMEMORY);
        return NULL;
    }

    // Allocate data buffer
    if ((pNode->hMem = 
        _GLOBALALLOC (DLLGMEM_ZEROINIT, 
        pNode->dwBlockSize = lpipb->BTreeData.Header.dwBlockSize)) == NULL)
    {
exit1:
        GlobalLockedStructMemFree(pNode);
        goto exit0;
    }
    pNode->pCurPtr = pNode->pBuffer = (LPB)_GLOBALLOCK (pNode->hMem);

	// Allocate a buffer with the maximum word length, which is the block
	// size

    if ((pNode->hLastWord =
        _GLOBALALLOC (DLLGMEM_ZEROINIT, pNode->dwBlockSize)) == NULL)
    {
exit2:
        FreeHandle (pNode->hMem);
        goto exit1;
    }
    pNode->pLastWord = (LPB)_GLOBALLOCK (pNode->hLastWord);

	// Alllocate temporary result buffer.

    if ((pNode->hTmp =
        _GLOBALALLOC (DLLGMEM_ZEROINIT, pNode->dwBlockSize)) == NULL)
    {
        FreeHandle (pNode->hLastWord);
        goto exit2;
    }
    pNode->pTmpResult = (LPB)_GLOBALLOCK (pNode->hTmp);
    
    return pNode;
}


/*************************************************************************
 * @doc  PRIVATE INDEXING
 *
 * @func VOID | FreeBTreeNode |
 *    Free all memory allocated for the node
 *
 * @parm PNODEINFO | pNode |
 *    BTree node to be freed
 *************************************************************************/

PUBLIC VOID PASCAL FAR FreeBTreeNode (PNODEINFO pNode)
{
	if (pNode == NULL)
		return;
	FreeHandle (pNode->hTmp);
    FreeHandle (pNode->hMem);
    FreeHandle (pNode->hLastWord);
    GlobalLockedStructMemFree(pNode);
}

/*************************************************************************
 *
 * @doc  PRIVATE INDEXING
 *
 * @func HRESULT | PrefixCompressWord |
 *    Adds a word to a record based on the last word in the node.
 *
 * @parm LPB | pDest |
 *    Pointer to the destination buffer
 *
 * @parm LPB | lpbWord |
 *    Pointer to the word string to add to node. The format is:
 *		- 2-byte: string length
 *		- n-byte: the string itself
 *		- cbBytePack: real word length
 *
 * @parm LPB | pLastWord |
 *    Pointer to the last word entered in the destination buffer
 *
 * @parm int | fOccfLengthSet |
 *    Set to 1 if OCCF_LENGTH field is set, else 0
 *
 * @parm PHRESULT | pErrb |
 *    Pointer to error structure
 *
 * @rdesc returns number of bytes written to the destination buffer
 * @rcomm   
 *      Strings are compressed based on how many beginning bytes 
 *      (prefix) it has in common woth the previous word. The format is
 *      - String's length : 2-byte CbPacked
 *      - Prefix length : 1-byte (0 - 127). If the high bit is set
 *          another word length is to follow the word
 *      - Word : n-byte without the prefix
 *      - Word's real length - 2-byte CbPacked: only exist if the
 *        prefix length high bit is set
 *************************************************************************/

PUBLIC int PASCAL FAR PrefixCompressWord 
    (LPB pDest, LPB lpbWord, LPB pLastWord, int fOccfLengthSet)
{
    // Working Variables
    int  bPrefix;               // The number of prefix bytes that match
    unsigned int wPostfix;      // Bytes left over that don't match
    USHORT  cbMinWordLen;       // Smallest word size between the two words
    LPB     pStart = pDest;     // Starting position
    DWORD   dwRealLength;		// The real length of the word


	// Get the minimum word length
    wPostfix = GETWORD ((LPUW)lpbWord);
    if ((cbMinWordLen = GETWORD ((LPUW)pLastWord)) > wPostfix)
    	cbMinWordLen = (USHORT) wPostfix;
        
    // Add one to adjust for two byte word headers (saves an add in the loop)
    cbMinWordLen++;

    for (bPrefix = 2; bPrefix <= cbMinWordLen; bPrefix++) 
    {
        if (lpbWord[bPrefix] != pLastWord[bPrefix])
            break;
    }
    // Adjust back to the real value
    bPrefix -= 2;

    // Prefix must be <= 127 (high bit is used to indicate fOccfLength field)
    if (bPrefix > 127)
        bPrefix = 127;

    cbMinWordLen = (USHORT) wPostfix;	// Save the word length
    wPostfix -= bPrefix;
    
    // Add wLen to wPostfix to get total byte count then write it.
    // The extra byte is for the prefix byte
    pDest += (USHORT)CbBytePack (pDest, (DWORD)(wPostfix + 1));

    // If WordLen == string length then don't write WordLen
    if (fOccfLengthSet)
    {
    	CbByteUnpack (&dwRealLength, lpbWord + sizeof(WORD) + cbMinWordLen );
        if (dwRealLength == cbMinWordLen)
        	fOccfLengthSet = FALSE;
    }

    // Write prefix size
    // If fOccfLengthSet is set, set high bit of bPrefix
    if (fOccfLengthSet)
        *pDest = bPrefix | 0x80;
    else
        *pDest = (BYTE) bPrefix;
    pDest++;

    // Copy the postfix string over
    MEMCPY (pDest, lpbWord + (bPrefix + sizeof (SHORT)), wPostfix);
    pDest += wPostfix;

    // if fOccfLengthSet is set append WordLen to end of word
    // (WordLen field follows word in input stream)
    if (fOccfLengthSet)
        pDest += CbBytePack (pDest, dwRealLength);

    return (int)(pDest - pStart);
}                                       


/*************************************************************************
 *
 * @doc  PRIVATE INDEXING
 *
 * @func void | FlushAllNodes |
 *    Flushes the remaining nodes to disk when the tree is completely built.
 *
 * @parm _LPIPB | lpipb |
 *    Pointer to index block
 *
 * @rdesc S_OK on success or errors if failed
 *
 *************************************************************************/

HRESULT PASCAL FlushAllNodes (_LPIPB lpipb)
{
    PBTREEDATA  pTreeData = &lpipb->BTreeData;
    PFILEDATA   pOutput = &lpipb->OutFile;

    PNODEINFO   pLeafNode;
    PNODEINFO   pStemNode;
    int         WordSize;
    BYTE        curLevel = 0;
    ERRB        errb = S_OK;
    HRESULT         fRet;

    pStemNode = pTreeData->rgpNodeInfo[0];

    while (pTreeData->rgpNodeInfo[++curLevel] != NULL)
    {
        pLeafNode = pStemNode;        
        pStemNode = pTreeData->rgpNodeInfo[curLevel];

        if ((WordSize = PrefixCompressWord (pStemNode->pCurPtr, 
            pLeafNode->pLastWord, pStemNode->pLastWord, 
            pTreeData->fOccfLength)) == 0)
        {
            return errb;
        }
        // Save new word as last word
        MEMCPY (pStemNode->pLastWord, pLeafNode->pLastWord,
            GETWORD ((LPUW)pLeafNode->pLastWord) + 2);

        pStemNode->pCurPtr += WordSize;
        pStemNode->cbLeft -= WordSize;
#ifdef _DEBUG
        if (pOutput->cbLeft <= 0)
            SetErrCode (NULL, E_ASSERT);
#endif

        CopyFileOffset (pStemNode->pCurPtr,
			lpipb->OutFile.foPhysicalOffset);
        pStemNode->pCurPtr += FOFFSET_SIZE;
        pStemNode->cbLeft -= FOFFSET_SIZE;
#ifdef _DEBUG
        if (pOutput->cbLeft <= 0)
            SetErrCode (NULL, E_ASSERT);
#endif

        if (curLevel == 1)
        {
            if ((fRet = WriteLeafNode (lpipb)) != S_OK)
                return(fRet);
        }
        else
        {
            if ((fRet = WriteStemNode (lpipb, pLeafNode)) != S_OK)
                return(fRet);
        }
    }
    // Set the pointer to the top stem node
    pTreeData->Header.foIdxRoot = pOutput->foPhysicalOffset;
    pTreeData->Header.nidIdxRoot = pOutput->foPhysicalOffset.dwOffset;

    if (curLevel == 1)
    {
        if ((fRet = WriteLeafNode (lpipb)) != S_OK)
            return(fRet);
    }
    else 
    {
        if ((fRet = WriteStemNode (lpipb, pStemNode)) != S_OK)
            return(fRet);
    }
            
    {
        LONG dwSize;
        
        // Flush the output buffer
        if (FileWrite (pOutput->fFile, pOutput->pMem,
            dwSize = (DWORD)(pOutput->pCurrent - pOutput->pMem), &errb) != dwSize)
            return(errb);
        pOutput->foStartOffset = FoAddDw(pOutput->foStartOffset, dwSize);
    }
    
    return S_OK;
}

PRIVATE HRESULT PASCAL NEAR WriteBitStreamDWord (PFILEDATA pOutput, DWORD dw,
    int ckeyCenter)
{
    BYTE    ucBits;
    HRESULT     fRet;

    // Bitstream scheme.
    //
    //      This writes "dw" one-bits followed by a zero-bit.
    //
    for (; dw;)
    {
        if (dw < cbitBYTE * sizeof(DWORD))
        {
          
            ucBits = (BYTE)dw;
            dw = 0;
        }
        else
        {
            ucBits = cbitBYTE * sizeof(DWORD);
            dw -= cbitBYTE * sizeof(DWORD);
        }
        if ((fRet = FWriteBits(pOutput, argdwBits[ucBits], 
    		(BYTE)ucBits)) != S_OK)
            return fRet;
  }
    return FWriteBool(pOutput, 0);
}
    
PRIVATE HRESULT PASCAL NEAR WriteFixedDWord (PFILEDATA pOutput, DWORD dw,
    int ckeyCenter)
{
	// This just writes "ckey.ucCenter" bits of data.
    return (FWriteBits (pOutput, dw, (BYTE)(ckeyCenter + 1)));
}

PRIVATE HRESULT PASCAL NEAR WriteBellDWord (PFILEDATA pOutput, DWORD dw,
    int ckeyCenter)
{
    BYTE ucBits;
    HRESULT fRet;
    
    // The "BELL" scheme is more complicated.
    ucBits = (BYTE)CbitBitsDw(dw);
    
    if (ucBits <= ckeyCenter) 
    {
        //  
        //  Encoding a small value.  Write a zero, then write 
        // "ckey.ucCenter" bits of the value, which
        //  is guaranteed to be enough.
        //
        if ((fRet = FWriteBool(pOutput, 0)) != S_OK)
            return fRet;
        return FWriteBits(pOutput, dw, (BYTE)(ckeyCenter));
    }
    
    //
    //  Encoding a value that won't fit in "ckey.ucCenter" bits.
    //  "ucBits" is how many bits it will really take.
    //
    //  First, write out "ucBits - ckey.ucCenter"  one-bits.
    //
    if ((fRet = FWriteBits(pOutput, argdwBits[ucBits -
        ckeyCenter], (BYTE)(ucBits - ckeyCenter))) != S_OK)
        return fRet;
    //
    // Now, write out the value in "ucBits" bits,
    // but zero the high-bit first.
    //
    return FWriteBits(pOutput, dw & argdwBits[ucBits - 1], ucBits);
}


/*************************************************************************
 *
 * @doc  PRIVATE INDEXING
 *       
 * @func HRESULT | FWriteBits |
 *    Writes a bunch of bits into the output buffer.
 *
 * @parm PFILEDATA | pOutput |
 *    Pointer to the output data structure
 *
 * @parm DWORD | dwVal |
 *    DWORD value to write
 *
 * @parm BYTE | cbits |
 *    Number of bits to write from dwVal
 *
 * @rdesc  Returns S_OK on success or errors if failed
 *
 *************************************************************************/

PUBLIC HRESULT FAR PASCAL FWriteBits (PFILEDATA pOutput, DWORD dwVal, BYTE cBits)
{
    BYTE    cbitThisPassBits;
    BYTE    bThis;
    ERRB    errb;
    static DWORD Count = 0;

    // Loop until no bits left
    for (; cBits;) 
    {

        if (pOutput->ibit < 0) 
        {
            pOutput->pCurrent++;
            pOutput->foPhysicalOffset = 
                FoAddDw (pOutput->foPhysicalOffset, 1);
            pOutput->cbLeft--;
#ifdef _DEBUG
            if (pOutput->cbLeft <= 0)
                SetErrCode (NULL, E_ASSERT);
#endif
            
            // Room left in output buffer?
            if (pOutput->cbLeft <= 256)
            {
                LONG dwSize;
                
                if (FileWrite (pOutput->fFile, pOutput->pMem,
                    dwSize = (DWORD)(pOutput->pCurrent - pOutput->pMem), &errb) !=
                    dwSize)
                    return(errb);
                    
                pOutput->cbLeft = pOutput->dwMax;
                pOutput->pCurrent = pOutput->pMem;
                pOutput->foStartOffset = FoAddDw(pOutput->foStartOffset,
                    dwSize);
#ifdef _DEBUG
                // MEMSET (pOutput->pMem, 0, pOutput->dwMax);
				// Count++;
				// if (!FoEquals(pOutput->foStartOffset, pOutput->foPhysicalOffset))
				// 	_asm int 3;
#endif
            }
            pOutput->ibit = cbitBYTE - 1;
        }
        else 
        { // Write some bits.
            cbitThisPassBits = (pOutput->ibit + 1 < cBits) ?
                pOutput->ibit + 1 : cBits;
            bThis = (pOutput->ibit == cbitBYTE - 1) ?
                0 : *pOutput->pCurrent;
            bThis |= ((dwVal >> (cBits - cbitThisPassBits)) <<
                (pOutput->ibit - cbitThisPassBits + 1));
            *pOutput->pCurrent = (BYTE)bThis;
            pOutput->ibit -= cbitThisPassBits;
            cBits -= (BYTE)cbitThisPassBits;
        }
    }
    return S_OK;
}


/*************************************************************************
 *
 * @doc  PRIVATE INDEXING
 *       
 * @func HRESULT | FWriteBool |
 *    Writes a single bit into the output buffer.
 *
 * @parm PFILEDATA | pOutput |
 *    Pointer to the output data structure
 *
 * @parm BOOL | dwVal |
 *    BOOL value to write
 *
 * @rdesc  Returns S_OK on success or errors if failed
 *
 *************************************************************************/

PRIVATE HRESULT NEAR PASCAL FWriteBool (PFILEDATA pOutput, BOOL fVal)
{
   HRESULT  fRet = E_FAIL;
   ERRB errb;

    if (pOutput->ibit < 0) 
    {   // This byte is full, point to a new byte
        pOutput->pCurrent++;
        pOutput->foPhysicalOffset = 
            FoAddDw (pOutput->foPhysicalOffset, 1);
        pOutput->cbLeft--;
#ifdef _DEBUG
        if (pOutput->cbLeft <= 0)
            SetErrCode (NULL, E_ASSERT);
#endif
        
        // Room left in output buffer?
        if (pOutput->cbLeft <= sizeof(DWORD))
        {
            LONG dwSize;
            if (FileWrite (pOutput->fFile, pOutput->pMem,
                dwSize = (DWORD)(pOutput->pCurrent - pOutput->pMem), &errb) != dwSize)
                return(errb);
                
            pOutput->pCurrent = pOutput->pMem;
            pOutput->cbLeft = pOutput->dwMax;
            pOutput->foStartOffset = FoAddDw(pOutput->foStartOffset, dwSize);
#ifdef _DEBUG
            MEMSET (pOutput->pMem, 0, pOutput->dwMax);
#endif
        }
        pOutput->ibit = cbitBYTE - 1;
    }
    if (pOutput->ibit == cbitBYTE - 1) // Zero out a brand-new byte.
        *pOutput->pCurrent = (BYTE)0;
    if (fVal)                               // Write my boolean.
        *pOutput->pCurrent |= 1 << pOutput->ibit;
    pOutput->ibit--;
    return S_OK;                         // Fine.
}


HRESULT PASCAL FAR BuildBtreeFromEso (HFPB hfpb,
    LPSTR pstrFilename, LPB lpbEsiFile,
    LPB lpbEsoFile, PINDEXINFO pIndexInfo) 
{
    _LPIPB lpipb;
    HRESULT  fRet;
    ERRB errb;
    BYTE  bKeyIndex = 0;
    IPB   ipb;
    HFILE hFile;

    if ((lpipb = MVIndexInitiate(pIndexInfo, NULL)) == NULL)
        return E_OUTOFMEMORY;

    /* Read in the external sort buffer info */

    if ((hFile = _lopen (lpbEsiFile, READ)) == HFILE_ERROR)
        return E_NOTEXIST;

    /* Read old IPB info */
    _lread (hFile, &ipb, sizeof(IPB));

    /* Transfer meaningful data */

    lpipb->dwIndexedWord = ipb.dwIndexedWord;
    lpipb->dwUniqueWord = ipb.dwUniqueWord;
    lpipb->dwByteCount = ipb.dwByteCount;
    lpipb->dwOccOffbits = ipb.dwOccOffbits;
    lpipb->dwOccExtbits = ipb.dwOccExtbits;
    lpipb->dwMaxFieldId = ipb.dwMaxFieldId;
    lpipb->dwMaxWCount = ipb.dwMaxWCount;
    lpipb->dwMaxOffset = ipb.dwMaxOffset;
    lpipb->dwTotal3bWordLen = ipb.dwTotal3bWordLen;
    lpipb->dwTotal2bWordLen = ipb.dwTotal2bWordLen;
    lpipb->dwTotalUniqueWordLen = ipb.dwTotalUniqueWordLen;
    lpipb->lcTopics = ipb.lcTopics;
    lpipb->dwMaxTopicId = ipb.dwMaxTopicId;
    // lpipb->dwMemAllowed = ipb.dwMemAllowed;
    lpipb->dwMaxRecordSize = ipb.dwMaxRecordSize;
    lpipb->dwMaxEsbRecSize = ipb.dwMaxEsbRecSize;
    lpipb->dwMaxWLen = ipb.dwMaxWLen;
    lpipb->idxf = ipb.idxf;
    if (lpipb->idxf & IDXF_NORMALIZE)
    {
        if ((lpipb->wi.hSigma = _GLOBALALLOC (DLLGMEM_ZEROINIT,
            (LCB)((lpipb->dwMaxTopicId + 1) * sizeof (SIGMA)))) == NULL)
            return SetErrCode (&errb, E_OUTOFMEMORY);
        lpipb->wi.hrgsigma = (HRGSIGMA)_GLOBALLOCK (lpipb->wi.hSigma);

        if ((lpipb->wi.hLog = _GLOBALALLOC (DLLGMEM_ZEROINIT,
            (CB)(cLOG_MAX * sizeof (FLOAT)))) == NULL)
		{
			SetErrCode (&errb, (HRESULT)(fRet = E_OUTOFMEMORY));
exit1:
			FreeHandle (lpipb->wi.hSigma);
			MVIndexDispose (lpipb);
			return fRet;
		}
#if 0
        lpipb->wi.lrgrLog = (FLOAT FAR *)_GLOBALLOCK (lpipb->wi.hLog);
        // Initialize the array
        for (loop = cLOG_MAX - 1; loop > 0; --loop)
        {
            rLog = (FLOAT)1.0 / (float)loop;
            lpipb->wi.lrgrLog[loop] = rLog * rLog;
        }
#endif
    }


    
    // Build the permanent index    
    fRet = BuildBTree(NULL, lpipb, lpbEsoFile, hfpb, pstrFilename);
    if (lpipb->idxf & IDXF_NORMALIZE)
    {
        FreeHandle (lpipb->wi.hLog);
        goto exit1;
    }
    fRet = S_OK;
    goto exit1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\parser.c ===
/*************************************************************************
*                                                                        *
*  PARSER.C                                                              *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   Boolean & Flat parser                                                *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
**************************************************************************/


#include <mvopsys.h>
#include <mem.h>
#include <memory.h>
#ifdef DOS_ONLY // {
#ifdef _DEBUG
#include <stdio.h>
#include <assert.h>
#endif
#endif // } _DEBUG && DOS_ONLY
#include <mvsearch.h>
#include "common.h"
#include "search.h"

#ifdef _DEBUG
static BYTE NEAR s_aszModule[] = __FILE__;	/* Used by error return functions.*/
#endif

#ifdef _DEBUG
int Debug;
#endif


#define NEWLINE     '\n'
#define CRETURN     '\r'

typedef struct
{
    LPB OpName;
    DWORD dwOffset;
    USHORT OpVal;
} STACK_NODE;

typedef struct OPSTACK
{
    BYTE DefaultOpVal;
    int Top;
    char cParentheses;
    char cQuotes;
    char fRequiredOp;
    char fRequiredTerm;
    STACK_NODE Stack[STACK_SIZE];
}   OPSTACK,
    FAR * _LPSTACK;

/*************************************************************************
 *                          EXTERNAL VARIABLES
 *  All those variables must be read only
 *************************************************************************/

extern OPSYM OperatorSymbolTable[]; 
extern BYTE LigatureTable[];

/*************************************************************************
 *
 *                       API FUNCTIONS
 *  Those functions should be exported in a .DEF file
 *************************************************************************/

PUBLIC LPQT EXPORT_API FAR PASCAL MVQueryParse(LPPARSE_PARMS, PHRESULT);

/*************************************************************************
 *
 *                    INTERNAL PRIVATE FUNCTIONS
 *  All of them should be declared near
 *************************************************************************/
PRIVATE VOID PASCAL NEAR LowLevelTransformation (LPQI, CB, LPOPSYM, int, LPSIPB);
static LSZ PASCAL NEAR StringToLong (LSZ, LPDW);
PRIVATE char NEAR is_special_char (BYTE, LPQI, BYTE);
PRIVATE HRESULT PASCAL NEAR StackAddToken (LPQI, int, LST, DWORD, BOOL);
PRIVATE HRESULT PASCAL NEAR PushOperator (LPQI, int, DWORD);
PRIVATE int PASCAL NEAR GetType(LPQI, char FAR *);
PRIVATE HRESULT PASCAL NEAR StackFlush (LPQI);
PRIVATE BOOL PASCAL NEAR ChangeToOpSym (LPOPSYM, int, LPB, int);
PRIVATE HRESULT PASCAL NEAR CopyNode (_LPQT lpQt, _LPQTNODE FAR *plpQtNode,
    _LPQTNODE lpSrcNode);
__inline BOOL IsCharWhitespace (BYTE cVal);


/*************************************************************************
 *
 *                    INTERNAL GLOBAL FUNCTIONS
 *  All of them should be declared far, unless they are known to be called
 *  in the same segment
 *************************************************************************/
PUBLIC HRESULT PASCAL FAR EXPORT_API FCallBack (LST lstRawWord, LST lstNormWord,
    LFO lfoWordOffset, LPQI lpQueryInfo);

/*************************************************************************
 *  @doc    API RETRIEVAL
 *  
 *  @func   LPQT FAR PASCAL | MVQueryParse |
 *      Given a query, this function will parse and build a query expression
 *      according to the parameters specifications
 *  
 *  @parm   LPPARSE_PARMS | lpParms |
 *      Pointer to a structure containing all parameters necessary
 *      for the parsing.
 *
 *  @parm   PHRESULT | phr |
 *      Error buffer
 *
 *  @rdesc NULL if failed, else pointer to a query expression if succeeded. 
 *      This pointer will be used in subsequent calls to IndexSearch()
 *************************************************************************/

PUBLIC  LPQT EXPORT_API FAR PASCAL MVQueryParse (LPPARSE_PARMS lpParms,
    PHRESULT phr)
{
    HRESULT    fRet;        // Return value.
    HANDLE  hqi;            // Handle to "lpqi".
    HANDLE  hibi;           // Handle to internal breaker info
    HANDLE  hQuery;         // Handle to secondary query buffer
    GHANDLE hStack;         // Handle to stack buffer
    LPQI    lpQueryInfo;    // Query information.
    LPB     lpbQueryBuf;    // Copy of query's buffer
    _LPSTACK    lpStack;    // Postfix stack pointer
    char    Operator;       // Operator
    WORD    i,j;            // Scratch variables
    _LPQT   lpQueryTree;    // Query tree pointer
    _LPOPTAB lpOpTab;       // Operator table structure
    NODE_PARM parms;        // Parameter of unary operator
    LPB     lpbTemp;        // Temporary pointer
    DWORD   dwOffset;       // Offset from the beginning of the query
    BOOL    fFlatQuery;     // Is it QuickKey search?


    /* LPPARSE_PARMS structure break-out variables */
    LPCSTR lpbQuery;           // Query buffer
    DWORD cbQuery;          // Query length
    WORD cProxDist;         // Proximity distance
    WORD cDefOp;            // Default operator
    PEXBRKPM pexbrkpm;    	// External breaker param struct.
    LPGROUP lpGroup;        // Group

    lpbQuery = lpParms->lpbQuery;
    cbQuery = lpParms->cbQuery;
    cProxDist = lpParms->cProxDist;
    cDefOp = lpParms->cDefOp;
    pexbrkpm = lpParms->pexbrkpm;
    lpGroup = lpParms->lpGroup;

    /* The bit is used to tell search that QuickKeys is used. In
     * QuickKeys, operators are treated like regular words
     */
    cDefOp = lpParms->cDefOp & ~TL_QKEY;
    fFlatQuery = lpParms->cDefOp & TL_QKEY;

    if (pexbrkpm == NULL)
    {
        SetErrCode(phr, E_BADBREAKER);
        return NULL;
    }

    if (cbQuery == 0 || lpbQuery == NULL) {
        SetErrCode(phr, E_NULLQUERY);
        return NULL;
    }
    if (cDefOp > MAX_DEFAULT_OP)
    {
        SetErrCode(phr, E_INVALIDARG);
        return NULL;
    }

    lpQueryTree = NULL;
    hqi = hibi = hQuery = hStack = NULL;

    /*  Allocate query info. */

    if ((hqi = (GHANDLE)_GLOBALALLOC(GMEM_MOVEABLE | GMEM_ZEROINIT,
        (LCB)sizeof(QUERY_INFO))) == NULL)
    {
        fRet = SetErrCode(phr, E_OUTOFMEMORY);
        goto ErrFreeAll;
    }
    lpQueryInfo = (LPQI)_GLOBALLOCK(hqi);
    lpQueryInfo->lperrb = phr;
    lpQueryInfo->fFlag |= (DWORD)(lpParms->wCompoundWord & CW_PHRASE);

    /* Set the flat query operator symbol table */
    if (fFlatQuery)
    {
        lpQueryInfo->lpOpSymTab = FlatOpSymbolTable;
        cDefOp = OR_OP;
    }
    else if ((lpOpTab = (_LPOPTAB)lpParms->lpOpTab) == NULL ||
        lpOpTab->lpOpsymTab == NULL)
    {
        /* Use default operator table */
        lpQueryInfo->lpOpSymTab = OperatorSymbolTable;
        lpQueryInfo->cOpEntry = OPERATOR_ENTRY_COUNT;
    }
    else
    {
        /* Get the operators' count */
        lpQueryInfo->lpOpSymTab = lpOpTab->lpOpsymTab;
        lpQueryInfo->cOpEntry = lpOpTab->cEntry;
    }

	// Initialize breaker param to break words as text.
	pexbrkpm->dwBreakWordType = 0;

    /* Allocate a stack for postfix operators handler */
    if ((hStack = (GHANDLE)_GLOBALALLOC(GMEM_MOVEABLE | GMEM_ZEROINIT,
        (LCB)sizeof(OPSTACK))) == NULL)
    {
        fRet = SetErrCode(phr, E_OUTOFMEMORY);
        goto ErrFreeAll;
    }
    lpStack = (_LPSTACK)_GLOBALLOCK(hStack);
    lpStack->DefaultOpVal = (BYTE)cDefOp;
    lpStack->fRequiredOp = lpStack->fRequiredTerm = 0;
    lpStack->cParentheses = lpStack->cQuotes = 0;
    lpStack->Top = -1;
    lpQueryInfo->lpStack = (LPV)lpStack;

    /* Allocate a query tree */
    if ((lpQueryTree = (_LPQT)QueryTreeAlloc()) == NULL)
    {
        fRet = SetErrCode(phr, E_OUTOFMEMORY);
        goto ErrFreeAll;
    }

    /* Associate the query tree with the query. In the future, this will
     * ensure the capability to have several queries and query trees
     * at once
     */
    lpQueryInfo->lpQueryTree = (LPQT)lpQueryTree;

    /* Default arguments */

    lpQueryTree->iDefaultOp = (BYTE)cDefOp;
    lpQueryTree->lpGroup = lpGroup;         // Use default Group
    lpQueryTree->dwFieldId = DW_NIL_FIELD;  // No fieldid search
    lpQueryTree->cStruct.dwKey = CALLBACKKEY;

    /* Suppose that we have all OR or all AND query */
    lpQueryTree->fFlag |= (ALL_OR | ALL_AND);
	lpQueryTree->fFlag |= ALL_ANDORNOT;

    if (cProxDist == 0)
        lpQueryTree->wProxDist = DEF_PROX_DIST;
    else
        lpQueryTree->wProxDist = cProxDist;

    /* Copy the query into a temporary buffer since we are going to make
    change to it
    */
    if ((hQuery = _GLOBALALLOC(DLLGMEM_ZEROINIT, (LCB)cbQuery + 2)) == NULL)
    {
        SetErrCode(phr, E_OUTOFMEMORY);
        FreeHandle(hqi);
        return NULL;
    }
    lpbQueryBuf = lpQueryInfo->lpbQuery = (LPB)_GLOBALLOCK(hQuery);
    lpbQueryBuf[cbQuery] = ' '; // Add a space to help LowLeveltransformation
    lpbQueryBuf[cbQuery + 1] = 0; // Zero-terminated string (safety bytes)
    MEMCPY(lpbQueryBuf, lpbQuery, cbQuery);

    /* Change to low level query */
    LowLevelTransformation (lpQueryInfo, (CB)(cbQuery + sizeof(SHORT)),
        (LPOPSYM)lpQueryInfo->lpOpSymTab, lpQueryInfo->cOpEntry, pexbrkpm);

    /* Do the parsing */
    for (i = 0; i < cbQuery; )
    {
        if ((Operator = is_special_char(lpbQueryBuf[i],
            lpQueryInfo, (BYTE)(lpQueryInfo->fFlag & IN_PHRASE))) != -1)
        {
            dwOffset = i;
            i++;
            switch (Operator)
            {
				// A stopword. We want to add it
                // to tree, but not shove it on to operator stack
                case STOP_OP:
                    if ((fRet = StackAddToken(lpQueryInfo, STOP_OP,
                        NULL, dwOffset, 0)) != S_OK)
                    {
                        fRet = VSetUserErr(phr, fRet, (WORD)(i-1));
                        goto ErrFreeAll;
                    }

                    continue;

                case QUOTE:
                    /* Mark the beginning and end of phrase, so that words
                    that looks like operators inside phrase will not be changed
                    to operator
                    */
                    if (fFlatQuery == FALSE)
                        lpQueryInfo->fFlag ^= IN_PHRASE;
                    break;

                
                case GROUP_OP:
                    /* The argument is a FAR pointer */
                    lpQueryTree->lpGroup =
                        (LPGROUP) (*((UNALIGNED void **)(&lpbQueryBuf[i])));
                    i += sizeof(void *);
                    continue;

                case FIELD_OP: 
                    /* The argument is an ASCII string number */
                    if ((lpbTemp = StringToLong(&lpbQueryBuf[i],
                        &lpQueryTree->dwFieldId)) == NULL)
                    {
                        /* Missing argument */
						fRet = VSetUserErr(phr, E_BADVALUE, i);
                        goto ErrFreeAll;
                    };
                    i += (WORD)(lpbTemp - (LPB)&lpbQueryBuf[i]);    // Move pointer
				    lpQueryTree->fFlag &= ~(ALL_OR | ALL_AND | ALL_ANDORNOT);
                    continue;

                case BRKR_OP :
                    /* The argument is an ASCII string number */
                    if ((lpbTemp = StringToLong(&lpbQueryBuf[i],
                        &parms.dwValue)) == NULL)
                    {
                        /* Missing argument */
                        fRet = VSetUserErr(phr, E_BADVALUE, i);
                        goto ErrFreeAll;
                    };

                    /* Make sure that we got a breaker function */

                    if ((WORD)parms.dwValue > (WORD)MAXNUMBRKRS)
                    {
                        fRet = VSetUserErr(phr, E_BADVALUE, i);
                        goto ErrFreeAll;
                    }
                    else
                    	pexbrkpm->dwBreakWordType = parms.dwValue;

                    i += (WORD)(lpbTemp - (LPB)&lpbQueryBuf[i]); // Move pointer

                    /* Save the breaker type info */
                    lpQueryTree->wBrkDtype = (WORD)parms.dwValue;

                    continue;

            }

            if ((fRet = StackAddToken(lpQueryInfo, Operator,
                (LST)&parms.lpStruct, dwOffset, 0)) != S_OK)
            {
                fRet = VSetUserErr(phr, fRet, (WORD)(i-1));
                goto ErrFreeAll;
            }
        }
        else
        {
            /* Find the next special character */
            for (j = i + 1; j < cbQuery; j++)
            {
                if (fFlatQuery == FALSE &&
                    is_special_char((BYTE)lpbQueryBuf[j], lpQueryInfo,
                    (BYTE)(lpQueryInfo->fFlag & IN_PHRASE)) != -1)
                    break;
            }
            
            //
            //  Word-break between here and there.
            //
            pexbrkpm->lpbBuf = lpbQueryBuf + i;
            pexbrkpm->cbBufCount = j - i;
            pexbrkpm->lpvUser = lpQueryInfo;
            pexbrkpm->lpfnOutWord = (FWORDCB)FCallBack;
            pexbrkpm->fFlags = ACCEPT_WILDCARD;
            // Set this for compound word-breaking. If this is set
            // we can use implicit phrase when we get the first term
            lpQueryInfo->fFlag &= ~FORCED_PHRASE;
            lpQueryInfo->pWhitespace = NULL;
            lpQueryInfo->dwOffset = i;

            if ((fRet = ExtBreakText(pexbrkpm)) != S_OK)
            {
                fRet = SetErrCode(phr, fRet);
                goto ErrFreeAll;
            }

            // Turn off the Forced Phrase if it is set
            if (lpQueryInfo->fFlag & FORCED_PHRASE)
            {
                lpQueryInfo->fFlag &= ~FORCED_PHRASE;
                if (S_OK != (fRet = StackAddToken
                    (lpQueryInfo, QUOTE, NULL, cbQuery, FALSE)))
                {
                    fRet = SetErrCode(phr, fRet);
                    goto ErrFreeAll;
                }
            }

            i = j;
        }
    }

    /* Set the position of pointer to report missing term at
    the end of the query. -1 since the offset starts at 0
    */
    lpQueryInfo->dwOffset = cbQuery - 1;

    fRet = E_FAIL;

    /* Flush all operators on the stack into the query tree, and
     * build the binary query tree
     */

    if ((fRet = StackFlush(lpQueryInfo)) == S_OK)
    {
        LPQT lpTempQT;

        if ((lpTempQT = QueryTreeBuild(lpQueryInfo)) != NULL)
        {
            lpQueryTree = lpTempQT;
            fRet = S_OK;
        }
        else
        {
            fRet = *phr;
        }
    }
    else
    {
        VSetUserErr(phr, fRet, (WORD)lpQueryInfo->dwOffset);
    }

ErrFreeAll:
    /* Free query info */
    if (hqi)
    {
        FreeHandle(hqi);
    };

    /* Free internal query buffer info */
    if (hQuery)
    {
        FreeHandle(hQuery);
    };

    /* Free internal stack buffer info */
    if (hStack)
    {
        FreeHandle(hStack);
    };

    if (fRet == S_OK)
        return lpQueryTree;
    else
    {
        if (lpQueryTree)
        {
            BlockFree(lpQueryTree->lpStringBlock);
#ifndef SIMILARITY
			BlockFree(lpQueryTree->lpWordInfoBlock);
#endif
            BlockFree(lpQueryTree->lpOccMemBlock);
            BlockFree(lpQueryTree->lpTopicMemBlock);
            BlockFree(lpQueryTree->lpNodeBlock);

            /* Free Query tree block */
            FreeHandle ((HANDLE)lpQueryTree->cStruct.dwReserved);
        }
        return NULL;
    }
}

/*************************************************************************
 *  @doc    INTERNAL
 *  
 *  @func   HRESULT PASCAL FAR | FCallBack |
 *      This call back function is called by various breakers after
 *      fetching a token. The token is checked for wild char presence
 *
 *  @parm   LST | lstRawWord |
 *      Pointer to unnormalized string
 *
 *  @parm   LST | lstNormWord |
 *      Pointer to normalized string. This pascal string's size should be
 *      at least *lstNormWord+2
 *
 *  @parm   LFO | lfoWordOffset |
 *      Offset into the query buffer. It is used to mark the location
 *      where an parsing error has occurred
 *
 *  @parm   LPQI | lpqi |
 *      Pointer to query info structure. This has all "global" variables
 *
 *  @rdesc  S_OK if succeeded, else various errors.
 *************************************************************************/
PUBLIC HRESULT PASCAL FAR EXPORT_API FCallBack (LST lstRawWord, LST lstNormWord,
    LFO lfoWordOffset, LPQI lpqi)
{
    BYTE WordType;  // Type of the token
    BOOL fWildChar; // Flag for wild char presence
    HRESULT fRet;   // Return value
    register int i;

#ifdef _DEBUG
    char szWord[1024] = {0};
    // erinfox: GETWORD byte-swaps on Mac and causes crash
    MEMCPY (szWord, lstNormWord + sizeof (WORD), *(LPW)(lstNormWord));
    OutputDebugString ("|");
    OutputDebugString (szWord);
    OutputDebugString ("|\n");
#endif /* _DEBUG */

    /*
     *  A token is a TERM_TOKEN if
     *      - If doesn't match any description for operators
     *      - Or it is inside a phrase
     *  For term, we have to check for wild chars
     */
    if ((lpqi->fFlag & IN_PHRASE) ||
        (WordType = (BYTE) GetType(lpqi, lstNormWord)) == TERM_TOKEN)
    {
        WordType = TERM_TOKEN;

        /* Add extra 0 to make sure that AllocWord() gets the needed 0
         * for WildCardCompare()
         */
        lstNormWord[*(LPW)(lstNormWord) + 2] = 0;

        /* Regular expression search accepted */

        fWildChar = FALSE;
        if ((lpqi->fFlag & IN_PHRASE) == FALSE)
        {

            BYTE fGetStar = FALSE;
            BYTE fAllWild = TRUE;   // Assume all wildcard chars

            for (i = *(LPW)(lstNormWord) + 1; i > 1; i--)
            {
                if (lstNormWord[i] == WILDCARD_STAR)
                {
                    fWildChar = TRUE;
                    fGetStar = TRUE;
                }
                else if (lstNormWord[i] == WILDCARD_CHAR)
                {
                    fWildChar = TRUE;
                }
                else
                    fAllWild = FALSE;
            }
            if (fGetStar && fAllWild)
            {
                return VSetUserErr(lpqi->lperrb, E_ALL_WILD,
                    (WORD)lfoWordOffset);
            }
        }
    }

    /*
    Okay, here's the implicit phrase scheme.
    We keep a pointer the the next whitespace.  There are 3 conditions
    that we must handle.  All of this conditions must also check to make
    sure that explicit phrasing is not on.
    1) Phrasing is not on and term does not contain wildcard(s):
        TURN ON
    2) Term that comes after the whitespace pointer:
        TURN OFF, THEN ON
    3) Term contains wildcard(s):
        TURN OFF

    Note: We need to make sure that phrasing is turned off before we enter
    this callback and turned back off once we are done.
    */

    // Make sure we are not in a normal (explicit) phrase
    // And that the user asked for implicit phrasing
    if (!(lpqi->fFlag & IN_PHRASE) && (lpqi->fFlag & CW_PHRASE))
    {
        LPB pWhitespace = lpqi->pWhitespace;
        LPB pTerm = lpqi->lpbQuery + lfoWordOffset + lpqi->dwOffset;

        // Condition 1.  We have a term and phrase is off
        if (!(lpqi->fFlag & FORCED_PHRASE) && FALSE == fWildChar)
        {
            lpqi->fFlag |= FORCED_PHRASE;
            if ((fRet = StackAddToken(lpqi, QUOTE, NULL,
                lfoWordOffset ? lfoWordOffset - 1 : 0, FALSE)) != S_OK)
	        {
                return VSetUserErr(lpqi->lperrb, fRet, (WORD)lfoWordOffset);
            }
        } 
        // Condition 2 or 3
        else if (lpqi->fFlag & FORCED_PHRASE)
        {
            // Condition 3.  Wildcard and phrase is already on
            if (TRUE == fWildChar)
            {
                lpqi->fFlag &= ~FORCED_PHRASE;
                if ((fRet = StackAddToken(lpqi, QUOTE, NULL, lfoWordOffset
                    + *(LPW)(lstRawWord), fWildChar)) != S_OK)
                {
                    return VSetUserErr(lpqi->lperrb, fRet, (WORD)lfoWordOffset);
                }
            }
            // Condition 2.  Term comes after the whitespace pointer
            else if (pWhitespace < pTerm)
            {
                // Turn phrase off
                if ((fRet = StackAddToken(lpqi, QUOTE, NULL,
                    (DWORD)(pWhitespace - lpqi->lpbQuery), fWildChar)) != S_OK)
                {
                    return VSetUserErr(lpqi->lperrb, fRet, (WORD)lfoWordOffset);
                }
                // Turn phrase on
                if ((fRet = StackAddToken(lpqi, QUOTE, NULL,
                    (DWORD)(pWhitespace - lpqi->lpbQuery), fWildChar)) != S_OK)
                {
                    return VSetUserErr(lpqi->lperrb, fRet, (WORD)lfoWordOffset);
                }
            }
        }

        // Find the next whitespace
        if (pWhitespace < pTerm + *(LPW)(lstRawWord))
        {
            pWhitespace = pTerm + *(LPW)(lstRawWord);
            // There is always a space at the end of the query, so the
            // *pWhitespace check is just a extra safety margin.
            while (*pWhitespace && 
                !(IsCharWhitespace (*pWhitespace)))
            {
                pWhitespace++;
            }
            // Save variable
            lpqi->pWhitespace = pWhitespace;
        }
	}

    /* Add the token */
    if ((fRet = StackAddToken(lpqi, WordType, lstNormWord,
        lfoWordOffset, fWildChar)) != S_OK)
    {
        return VSetUserErr(lpqi->lperrb, fRet, (WORD)lfoWordOffset);
    }

    return S_OK;
}

/*************************************************************************
 *  @doc    INTERNAL
 *  
 *  @func   HRESULT PASCAL NEAR | PushOperator |
 *      Push an operator onto the stack. This is done in two steps:
 *      - Pop all operators on the stack into the query tree
 *      - Then push the new operator onto the stack
 *
 *  @parm   LPQI | lpQueryInfo |
 *      Pointer to query tree. This has all global informations
 *
 *  @parm   int | OpValue |
 *      Operator to be pushed onto the stack
 *
 *  @parm   DWORD | dwOffset |
 *      Offset from the beginning of the query
 *
 *  @rdesc  S_OK if succeeded, errors otherwise
 *************************************************************************/
PRIVATE HRESULT PASCAL NEAR PushOperator (LPQI lpQueryInfo, int OpValue,
    DWORD dwOffset)
{
    HRESULT fRet;
    _LPSTACK lpStack = (_LPSTACK)lpQueryInfo->lpStack;
    _LPQT lpQueryTree = lpQueryInfo->lpQueryTree;
    WORD opVal;

    if (OpValue < MAX_OPERATOR)
    {
        while (lpStack->Top >= 0 &&
            (opVal = lpStack->Stack[lpStack->Top].OpVal) <= MAX_OPERATOR) {
            if ((fRet = QueryTreeAddToken(lpQueryTree, opVal,
                NULL, lpStack->Stack[lpStack->Top].dwOffset, 0)) != S_OK)
                return fRet;
            lpStack->Top--;
        }
    }

    if (++lpStack->Top == STACK_SIZE)
        return E_TOODEEP;

    lpStack->Stack[lpStack->Top].OpVal = (BYTE)OpValue;
    lpStack->Stack[lpStack->Top].OpName = (OpValue < MAX_OPERATOR ?
        OperatorSymbolTable[OpValue].OpName: NULL);
    lpStack->Stack[lpStack->Top].dwOffset = dwOffset;
    return (S_OK);
}

/*************************************************************************
 *  @doc    INTERNAL
 *  
 *  @func   HRESULT NEAR PASCAL | StackAddToken |
 *      This function will:
 *      - Add a term into the query tree. It also creates and add the
 *      default operator into the stack if necessary to compensate for
 *      missing operators between two terms
 *
 *  @parm   LPQI | lpQueryInfo |
 *      Pointer to query info
 *
 *  @parm   int | OpValue |
 *      Operator/term to be added onto the stack/query
 *
 *  @parm   LST | p |
 *      Name of the token. For term, this is the word itself
 *
 *  @parm   HRESULT | fWildChar |
 *      Wild char flag for terms
 *
 *  @rdesc  S_OK if succeeded, errors otherwise
 *************************************************************************/
PRIVATE HRESULT NEAR PASCAL StackAddToken (LPQI lpQueryInfo, int OpValue,
    LST p, DWORD dwOffset, BOOL fWildChar)
{
    HRESULT   fRet;
    _LPQT lpQueryTree = lpQueryInfo->lpQueryTree;
    _LPSTACK lpStack = (_LPSTACK)lpQueryInfo->lpStack;
    WORD opVal;

    // erinfox: add code to handle adding a NULL token
    switch (OpValue)
    {
        case TERM_TOKEN:
        case STOP_OP:       // Null term/token, like a stopword
            /*  If an operator is needed between this term and the previous
             *  one, then insert an operator
             */
            if (lpStack->fRequiredOp)
            {
                if ((fRet = PushOperator(lpQueryInfo, 
                    lpStack->DefaultOpVal, dwOffset)) != S_OK)
                    return fRet;
            }

            /* Add the term into the query tree */
            lpStack->fRequiredOp = TRUE;
            if ((fRet = QueryTreeAddToken(lpQueryTree, OpValue,
                p, dwOffset, fWildChar)) != S_OK)
                return fRet;
            lpStack->fRequiredTerm = FALSE;
            break;

        case QUOTE:
            if (lpStack->cQuotes == 0)
            {

                /* This is the first quote */
                if (lpStack->fRequiredOp)
                {
                    if ((fRet = PushOperator(lpQueryInfo,
                        lpStack->DefaultOpVal, dwOffset)) != S_OK)
                        return fRet;
                    lpStack->fRequiredOp = FALSE;
                }

                if ((fRet = PushOperator(lpQueryInfo, OpValue, dwOffset)) != S_OK)
                    return fRet;

                /* Change the default operator */
                lpStack->DefaultOpVal = PHRASE_OP;
				lpQueryTree->fFlag &= ~(ALL_OR | ALL_AND | ALL_ANDORNOT);
                lpStack->cQuotes++;
                lpStack->fRequiredTerm = TRUE;
            }
            else
            {
                /* Check for term inside quotes */
                if (lpStack->fRequiredTerm)
                    return E_EXPECTEDTERM;

                lpStack->cQuotes--;
                while ((opVal = lpStack->Stack[lpStack->Top].OpVal) != QUOTE)
                {
                    if ((fRet = QueryTreeAddToken(lpQueryTree,
                        opVal, NULL, lpStack->Stack[lpStack->Top].dwOffset,
                        fWildChar)) != S_OK)
                        return fRet;
                    lpStack->Top--;
                }
                lpStack->Top --;    // Pop the quote

                /* Change the default operator */
                lpStack->DefaultOpVal= (BYTE)lpQueryTree->iDefaultOp;
                lpStack->fRequiredOp = TRUE;
            }
            break;

        case LEFT_PAREN:
            if (lpStack->fRequiredOp)
            {
                if ((fRet = PushOperator(lpQueryInfo,
                    lpStack->DefaultOpVal, dwOffset)) != S_OK)
                    return fRet;
                lpStack->fRequiredOp = FALSE;
            }
            lpStack->cParentheses ++;
            lpStack->fRequiredTerm = TRUE;
            if ((fRet = PushOperator(lpQueryInfo, OpValue, dwOffset)) != S_OK)
                return fRet;
            break;

        case RIGHT_PAREN:
            if (lpStack->cParentheses == 0)
            {
                return (E_MISSLPAREN);
            }

            /* Check for term inside parentheses */
            if (lpStack->fRequiredTerm)
                return E_EXPECTEDTERM;

            lpStack->cParentheses --;
            while ((opVal = lpStack->Stack[lpStack->Top].OpVal) != LEFT_PAREN)
            {
                if ((fRet = QueryTreeAddToken(lpQueryTree, opVal,
                    NULL, lpStack->Stack[lpStack->Top].dwOffset,
                    0)) != S_OK)
                    return fRet;
                lpStack->Top--;
            }
            lpStack->Top --;
            lpStack->fRequiredOp = TRUE;
            break;

        default:    /* Operator */
            /* Check for Unary operator */
            if (OperatorAttributeTable[OpValue] & UNARY_OP)
            {

				lpQueryTree->fFlag &= ~(ALL_OR | ALL_AND | ALL_ANDORNOT);

                /* Add the unary operator into the query tree */
                return QueryTreeAddToken(lpQueryTree, OpValue, p, dwOffset, 0);
            }

            if (OpValue != AND_OP)
                lpQueryTree->fFlag &= ~ ALL_AND;
            if (OpValue != OR_OP)
                lpQueryTree->fFlag &= ~ ALL_OR;
			if (OpValue != AND_OP && OpValue != OR_OP && OpValue != NOT_OP)
				lpQueryTree->fFlag &= ~ ALL_ANDORNOT;

            if (lpStack->fRequiredOp == FALSE)
            {
                return E_EXPECTEDTERM;
            }
            lpStack->fRequiredOp = FALSE;
            lpStack->fRequiredTerm = TRUE;
            if ((fRet = PushOperator(lpQueryInfo, OpValue,
                dwOffset)) != S_OK)
                return fRet;
    }
    return S_OK;
}

/*************************************************************************
 *  @doc    INTERNAL
 *  
 *  @func   HRESULT PASCAL NEAR | StackFlush |
 *      Flush all the operators on the stacks into the query expression
 *
 *  @parm   LPQI | lpQueryInfo |
 *      Pointer to query info structure, which contains all "global"
 *      variables
 *
 *  @rdesc  S_OK if succeeded, errors otherwise
 *************************************************************************/
PRIVATE HRESULT PASCAL NEAR StackFlush (LPQI lpQueryInfo)
{
    _LPSTACK lpStack = lpQueryInfo->lpStack;
    HRESULT fRet;

    /* Check for parentheses */
    if (lpStack->cParentheses)
    {
        return (E_MISSRPAREN);
    }

    /* Check for mismatch quotes */
    if (lpStack->cQuotes)
    {
        return (E_MISSQUOTE); 
    }
    
	/* Check for missing term */
    if (lpStack->fRequiredTerm) 
        return (E_EXPECTEDTERM);
   
    while (lpStack->Top >= 0)
    {
        if ((fRet = QueryTreeAddToken (lpQueryInfo->lpQueryTree,
            lpStack->Stack[lpStack->Top].OpVal, NULL,
            lpStack->Stack[lpStack->Top].dwOffset, 0)) != S_OK)
                return fRet;
        lpStack->Top --;
    }

#if defined(_DEBUG) && DOS_ONLY
    PrintList(lpQueryInfo->lpQueryTree);
#endif

    return (S_OK);
}


/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   char NEAR | is_special_char |
 *      Check to see if a character is the low level symbol of an
 *      operator. If it is , then return its internal representation
 *
 *  @parm   BYTE | c |
 *      Character to be checked
 *
 *  @parm   LPQI | lpQueryInfo |
 *      Pointer to query info structure, where all "global variables"
 *      reside
 *
 *  @parm   BYTE | fInPhrase |
 *      Flag to determine that we are inside a phrase or not
 *
 *  @rdesc  Return the internal representation of the operator, or -1
 *************************************************************************/
PRIVATE char NEAR is_special_char (BYTE c, LPQI lpQueryInfo, BYTE fInPhrase)
{
    LPOPSYM   lpOpSymTab;
    WORD cOpEntry;

#if 0
    LPCMAP lpMapTab;
    lpMapTab = (LPCMAP)lpQueryInfo->lpCharTab->lpCMapTab;
#endif
    lpOpSymTab = lpQueryInfo->lpOpSymTab;
    cOpEntry = lpQueryInfo->cOpEntry;

    if (!(fInPhrase & IN_PHRASE))
    {
        if (c == '(')
            return LEFT_PAREN;
        if (c == ')')
            return RIGHT_PAREN;

#if 0
		// REVIEW (billa): I disabled this switch test because it doesn't
		// seem to be necessary.  All the operators have values <= 14,
		// which should never conflict with the three char classes tested.
		
        /* Check for one-byte operator */
        switch ((lpMapTab+c)->Class)
        {
            case CLASS_CHAR:
            case CLASS_NORM:
            case CLASS_DIGIT:
                return -1;
                break;
        }
#endif

#if 0
        for (; cOpEntry > 0; cOpEntry--, lpOpSymTab++)
        {
            if (lpOpSymTab->OpName[0] == 1 &&
                lpOpSymTab->OpName[1] == c)
            {
                c = (BYTE)lpOpSymTab->OpVal;
                break;
            }
        }
#endif

        switch (c)
        {
            case UO_AND_OP:
                return AND_OP;
            case UO_OR_OP:
                return OR_OP;
            case UO_NOT_OP:
                return NOT_OP;
            case UO_PHRASE_OP:
                return PHRASE_OP;
            case UO_NEAR_OP:
                return NEAR_OP;
            case UO_RANGE_OP:
                return RANGE_OP;
            case UO_GROUP_OP:
                return GROUP_OP;
            case UO_FIELD_OP:
                return FIELD_OP;
            case UO_FBRK_OP:
                return BRKR_OP;
            case STOP_OP:
                return STOP_OP;
        }
    }
    if (c == '\"')
        return QUOTE;
    return -1;
}

PRIVATE int PASCAL NEAR GetType(LPQI lpQueryInfo, char FAR *p)
{
    LPOPSYM lpOpSymTab;
    WORD cOpEntry;

    cOpEntry = lpQueryInfo->cOpEntry;
    lpOpSymTab = lpQueryInfo->lpOpSymTab;

    for (; cOpEntry > 0; lpOpSymTab++, cOpEntry--)
    {
        if (!StringDiff2(p, lpOpSymTab->OpName))
        {
            switch (lpOpSymTab->OpVal)
            {
                case UO_AND_OP:
                    return AND_OP;
                case UO_OR_OP:
                    return OR_OP;
                case UO_NOT_OP:
                    return NOT_OP;
                case UO_PHRASE_OP:
                    return PHRASE_OP;
                case UO_NEAR_OP:
                    return NEAR_OP;
                case UO_RANGE_OP:
                    return RANGE_OP;
                case UO_GROUP_OP:
                    return GROUP_OP;
                case UO_FBRK_OP:
                    return BRKR_OP;
                case UO_FIELD_OP:
                    return FIELD_OP;
                default:
                    RET_ASSERT(UNREACHED);
            }
        }
    }
    return (TERM_TOKEN);
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   VOID PASCAL NEAR | LowLevelTransformation |
 *      This function will transform a high level query to a low level
 *      one. The change consists changing the operator's names to token
 *
 *  @parm   LPQI | lpQueryInfo |
 *      The query info structure where all variables can be found
 *
 *  @parm   CB | cb |
 *      How many bytes are there in the query
 *
 *  @parm   LPOPSYM | lpOpSymTab |
 *      Operator symbol table
 *
 *  @parm   int | cOpEntry |
 *      Number of operators' entry
 *
 *  @parm   LPSIPB | lpsipb |
 *      Pointer to stoplist info block
 *************************************************************************/
// erinfox: I added lpsipb here so we can transform stop words
PRIVATE VOID PASCAL NEAR LowLevelTransformation (LPQI lpQueryInfo,
    register CB cb, LPOPSYM lpOpSymTab, int cOpEntry, PEXBRKPM pexbrkpm)
{
    BYTE fPhrase = FALSE;       // Are we in a PHRASE
    BYTE fNeedOp = FALSE;       // Flag to denote an operator is needed
    BYTE fSkipArg = FALSE;      // Flag to skip an argument
    LPB  lpLastOp = NULL;       // Location to insert the operator
    LPB  lpLastWord = NULL;     // Beginning of the last word
    LPB lpbQuery = lpQueryInfo->lpbQuery;
    int wLen = 0;               // Last word's length
    BYTE WordToCheck[CB_MAX_WORD_LEN];       // Buffer containing word to check as stopword

    for (; cb > 1; cb--, lpbQuery++)
    {
        switch (*lpbQuery)
        {
			case 0:
				return;

            case '"':   // Check for phrase 
                /* Set (or unset) the phrase flag */
                if ((fPhrase = (BYTE)!fPhrase) == FALSE)
                {
                /* We just got out of a phrase, don't convert the
                 * last word in the phrase, which may be an operator
                 * format, by resetting the word length to 0, and the
                 * pointer to NULL
                 */
                    wLen = 0;
                    lpLastWord = NULL;
                }

                /* Fall through */

            case ' ':
            case '\t':
            case NEWLINE:
            case CRETURN:
                break;

            default: /* Regular character */
                /* Check for special characters */
                if (is_special_char(*lpbQuery, lpQueryInfo,
                    (BYTE)(lpQueryInfo->fFlag & IN_PHRASE)) != -1)
                {
                    break;
                }

#if 0
                /* Check for single character operator */
                if (fPhrase == FALSE)
                {

                    /* Scan for operator, and change it to symbol
                    if only we are not in a phrase */

                    if (ChangeToOpSym(lpOpSymTab, cOpEntry,
                        lpbQuery, 1) == TRUE) 
                        break;
                }
#endif
                
                if (lpLastWord == NULL) 
                    lpLastWord = lpbQuery;
                wLen++;

                /* This continue is important. This is the only way
                 * to accumulate a word */

                continue;

        } /* End switch */

        if (wLen == 0)
            continue;

        if (fSkipArg == TRUE)
        {
            /* Reset the flag, and skip this argument */
            fSkipArg = FALSE;
            lpLastWord = NULL;
            wLen = 0;
            continue;
        }

        if (fPhrase == FALSE)
        {

            /* Scan for operator, and change it to symbol
            if only we are not in a phrase */

            if (ChangeToOpSym(lpOpSymTab, cOpEntry, lpLastWord,
                wLen) == TRUE)
            {
                /* We got an operator, but don't change the
                   value of fNeedOp for FBRK or FIELD, since
                   they have no effect on the boolean grammar
                */
                if (*lpLastWord == UO_FBRK_OP ||
                    *lpLastWord == UO_FIELD_OP)
                {
                    fSkipArg = TRUE;
                }
            }
            // Check to see if it's a stopword
            else if (pexbrkpm)
            {
                MEMCPY(WordToCheck+2, lpLastWord, wLen);
                *(LPW) WordToCheck = (WORD) wLen;

                // yes, so replace it with STOP_OP
                if (S_OK == ExtLookupStopWord(pexbrkpm->lpvIndexObjBridge,
                												WordToCheck))
                {
                    *lpLastWord++ = (BYTE) STOP_OP;
                    for (--wLen; wLen > 0; wLen--)
                        *lpLastWord++ = ' ';
                }


            }
        }

        /* Reset pointer */
        lpLastWord = NULL;
        wLen = 0;
    }
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   BOOL PASCAL NEAR | ChangeToOpSym  |
 *      This function will look for operators, then rewrite them into
 *      their abbreviated form
 *
 *  @parm   LPOPSYM | lpOpSymTab |
 *      Pointer to operator table
 *
 *  @parm   int | cOpEntry |
 *      Number of operators' entries
 *
 *  @parm   LPB | pWord |
 *      Word to be checked and modified
 *
 *  @parm   int | wLen |
 *      Length of the word
 *
 *  @rdesc
 *      TRUE if the word is an operator, and is rewritten, FALSE otherwise
 *************************************************************************/
PRIVATE BOOL PASCAL NEAR ChangeToOpSym (LPOPSYM pOptable, int cOpEntry,
    LPB pWord, int wLen)
{
    for (; cOpEntry > 0; pOptable++, cOpEntry--)
    {
        if ((WORD)wLen == pOptable->OpName[0])
        {

            if (StrNoCaseCmp (pWord, pOptable->OpName + 1, (WORD)wLen) == 0)
            {

                /* Match! Change to operator symbol and pad with blank */

                *pWord++ = (BYTE)pOptable->OpVal;
                for (--wLen; wLen > 0; wLen--)
                    *pWord++ = ' ';
                return TRUE;
            }
        }
    }
    return FALSE;
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   LSZ PASCAL NEAR | StringToLong |
 *      The function reads in a string of digits and convert them into
 *      a DWORD. The function will move the input pointer correspondingly
 *
 *  @parm   LSZ | lszBuf |
 *      Input buffer containing the string of digit with no sign
 *
 *  @parm   LPDW  | lpValue |
 *      Pointer to a DWORD that receives the result
 *
 *  @rdesc  NULL, if there is no digit, else the new position of the input
 *      buffer pointer
 *************************************************************************/
static LSZ PASCAL NEAR StringToLong (LSZ lszBuf, LPDW lpValue)
{
    register DWORD Result;  // Returned result
    register int i;         // Scratch variable
    char fGetDigit;         // Flag to mark we do get a digit

    /* Skip all blanks, tabs */
    while (*lszBuf == ' ' || *lszBuf == '\t')
        lszBuf++;

    Result = fGetDigit = 0;

    if (*lszBuf >= '0' && *lszBuf <= '9')
    {
        fGetDigit = TRUE;

        /* The credit of this piece of code goes to Leon */
        while (i = *lszBuf - '0', i >= 0 && i <= 9)
        {
            Result = Result * 10 + i;
            lszBuf++;
        }
    }
    *lpValue = Result;
    return (fGetDigit ? lszBuf : NULL);
}


int PASCAL FAR QueryTreeCopyBufPointer (_LPQT lpSrcQT, _LPQT lpDestQT)
{
    if (lpSrcQT == NULL || lpDestQT == NULL)
        return(E_INVALIDARG);
        
    lpDestQT->lpTopicStartSearch = NULL;
    lpDestQT->lpTopicFreeList = lpSrcQT->lpTopicFreeList;

    /* Occ list related global variables */
    lpDestQT->lpOccStartSearch = NULL;   /* Starting occurrence for searching  */
    lpDestQT->lpOccFreeList = lpSrcQT->lpOccFreeList;
    return(S_OK);
}

LPQT QueryTreeDuplicate (_LPQT lpSrcQT, PHRESULT phr)
{
    _LPQT lpDupQT;
    HRESULT fRet;
	HANDLE hndSaved;
    
    // Allocate the new query tree
    if ((lpDupQT = (_LPQT)GLOBALLOCKEDSTRUCTMEMALLOC(sizeof(QTREE))) == NULL)
    {
        SetErrCode(phr, E_OUTOFMEMORY);
exit0:
        return lpDupQT;
    }

	hndSaved = *(HANDLE FAR *)lpDupQT;

    // Copy all the info from the old QT    
    *lpDupQT = *lpSrcQT;

	*(HANDLE FAR *)lpDupQT = hndSaved;

    lpDupQT->lpTopNode = NULL;
    
    // Copy the tree
    if ((fRet = CopyNode (lpSrcQT, &lpDupQT->lpTopNode,
        lpSrcQT->lpTopNode)) != S_OK)
    {
        SetErrCode (phr, fRet);
        GlobalLockedStructMemFree((LPV)lpDupQT);
        lpDupQT = NULL;
    }
    goto exit0;
}

PRIVATE HRESULT PASCAL NEAR CopyNode (_LPQT lpQt, _LPQTNODE FAR *plpQtNode,
    _LPQTNODE lpSrcNode)
{
    int fRet;
    _LPQTNODE lpQtNode;
    
    if (lpSrcNode == NULL)
    {
        *plpQtNode = NULL;
        return(S_OK);
    }
    /* Allocate the node */
    if ((lpQtNode = BlockGetElement(lpQt->lpNodeBlock)) == NULL)
        return E_OUTOFMEMORY;
    
    // Copy the node    
    *lpQtNode = *lpSrcNode;        

    *plpQtNode = lpQtNode;
    
    // Copy the left child
    if ((fRet = CopyNode (lpQt, &QTN_LEFT(lpQtNode), QTN_LEFT(lpSrcNode))) !=
        S_OK)
        return(fRet);
    return CopyNode (lpQt, &QTN_RIGHT(lpQtNode), QTN_RIGHT(lpSrcNode));
}

VOID PASCAL FAR DuplicateQueryTreeFree(_LPQT lpQT)
{
    if (lpQT)
        GlobalLockedStructMemFree((LPV)lpQT);
}

__inline BOOL IsCharWhitespace (BYTE cVal)
{
    return
        (' ' == cVal || '\t' == cVal || NEWLINE == cVal || CRETURN == cVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\similar.c ===
//#define _DUMPALL
/*************************************************************************
*                                                                        *
*  SIMILAR.C                                                             *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1996                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent:                                                        *
*																		 *
*   Search Core Engine: Find Similar functionality						 * 
*                                                                        *
**************************************************************************
*                                                                        
*	Revision History:
*
*	09/24/96 kevynct	Started from algorithm notes (4 hrs)
*	09/25/96 kevynct 	Implemented skeleton of ProcessSimilarityTerm  (1 hr)
*	09/26/96 kevynct	More work on inner loop and relevant list (5 hrs)
*	09/27/96 kevynct	Query parsing, weighting, and sorting (6 hrs)
*	10/01/96 kevynct	Incorporate into MV2.0b	(10 min)
*	10/02/96 kevynct	Clean-up query code, start resolve query code (4 hrs)
*	10/03/96 kevynct	Resolve query code (2 hrs)
*	10/11/96 kevynct	Start bucket routines (2 hrs)
*   10/13/96 kevynct	Finish bucket routines, write node processor, cleanup (6 hrs)
*	10/14/96 kevynct	Clean-up, remove compilation errors, debugging (6 hrs)
*	10/24/96 kevynct	Convert to two-phase query resolution (3 hrs)
*	10/25/96 kevynct	Fix sort by cTopics, debug new query resolution, try new weighting (2 hrs)
*	11/26/96 kevynct	Testing, fix and improve weighting and accumulation: aliases, digits (8 hrs)
*	12/2/96	 kevynct	More weighting tests (8 hrs)
*	Work remaining:
*
*   Investigate field and stemming support
*	
*	Use probabilistic upperbounds for pruning.  Remove single-term nodes after each term process
*	Test current bucket method vs. exact scores w/ heap
*	
**************************************************************************
*
*	Current Owner: KevynCT                                               
*                                                                        
**************************************************************************/

#include <mvopsys.h>
#include <mem.h>
#include <memory.h>
#include <orkin.h>
#include <mvsearch.h>
#include <math.h>
#include <groups.h>
#include "common.h"
#include "search.h"

#ifdef _DEBUG
static  BYTE  NEAR s_aszModule[] = __FILE__;  // Used by error return functions.
#endif

#define FGetDword(a,b,c) (*DecodeTable[b.cschScheme])(a, b, c)
#define IS_DIGIT(p) ((p) >= '0' && (p) <= '9')
// these are in case the doc scoring is approximate: they tell which
// direction to err on the side of.
#define ROUND_DOWN 0
#define ROUND_UP 1

#define SCORE_BLOCK_SIZE 32
#define NUM_SCORE_BLOCKS (MAX_WEIGHT/SCORE_BLOCK_SIZE)

typedef struct tagDocScoreList {
	HANDLE hMem;
	int cScoresLeft;
	int iBucketLowest;
	int iHighestScore;
	int rgiScores[NUM_SCORE_BLOCKS + 1];
} DSL, FAR *_LPDSL;

PUBLIC HRESULT PASCAL FAR SkipOccList(_LPQT  lpqt, PNODEINFO pNodeInfo, DWORD dwOccs); // ftsearch.c
PUBLIC int PASCAL FAR CompareTerm(_LPQTNODE lpQtNode,
    LST lstTermWord, LST lstBtreeWord, DWORD dwBtreeFieldId, char []); // ftsearch.c
PUBLIC STRING_TOKEN FAR *PASCAL AllocWord(_LPQT lpQueryTree, LST lstWord); // qtparse.c



__inline LPVOID InitDocScoreList(int cScores);
__inline void FreeDocScoreList(LPV lpDocScores);
__inline int GetMaxDocScore(_LPDSL lpDocScores);
__inline int GetMinDocScore(_LPDSL lpDocScores, BOOL fRoundUp);
BOOL UpdateDocScoreList(_LPDSL lpDocScores, int iOldScore, int i);
__inline BOOL IsDocScoreListFull(_LPDSL lpdsl);
__inline WORD AddWeights(DWORD w1, DWORD w2);
int GetSortedDocScore(_LPDSL lpDocScores, int iThis, BOOL fRoundUp);
#if defined(_DEBUG)
BOOL DumpDocScoreList(_LPDSL lpdsl, PSRCHINFO pSrchInfo);
#endif
__inline void MergeWordInfoCounts(WORDINFO FAR *lpwiDest, WORDINFO FAR *lpwiSrc);

PRIVATE LPQT TokenizeFlatQuery(LPPARSE_PARMS lpParms, PSRCHINFO pSrchInfo, PHRESULT phr);
PRIVATE HRESULT PASCAL NEAR ResolveFlatQuery(_LPQT lpqt,	_LPQTNODE lpCurQtNode, LPRETV lpRetV);
PRIVATE HRESULT GetWordInfoList(_LPQT lpqt, STRING_TOKEN FAR *lpStrToken, _LPQTNODE lpCurQtNode, LPRETV lpRetV);
PRIVATE VOID PASCAL SortStringWeights(_LPQT lpQueryTree);
PRIVATE VOID PASCAL SetStringWeights (LPQI lpQueryInfo);
PUBLIC HRESULT PASCAL FAR EXPORT_API FFlatCallBack (LST lstRawWord, LST lstNormWord,
    LFO lfoWordOffset, LPQI lpqi);

__inline LPVOID InitDocScoreList(int cScores)
{
	_LPDSL lpdsl;

	if ((lpdsl = (_LPDSL)GlobalLockedStructMemAlloc(sizeof(DSL))) == NULL)
        return NULL;

	lpdsl->cScoresLeft = cScores;
	lpdsl->iHighestScore = 0;
	lpdsl->iBucketLowest = -1;
	return (LPV)lpdsl;
}

__inline void FreeDocScoreList(LPV lpDocScores)
{
	if ((_LPDSL)lpDocScores)
		GlobalLockedStructMemFree((_LPDSL)lpDocScores);
}

__inline int GetMaxDocScore(_LPDSL lpDocScores)
{
	return lpDocScores->iHighestScore;
}
	
__inline int GetMinDocScore(_LPDSL lpDocScores, BOOL fRoundUp)
{
	if (lpDocScores->iBucketLowest >= 0)
		return (lpDocScores->iBucketLowest + !!fRoundUp) * SCORE_BLOCK_SIZE;

	return 0;
}

int GetSortedDocScore(_LPDSL lpdsl, int cThis, BOOL fRoundUp)
{
	LPINT lpi, lpiFirst;

	if (lpdsl->iHighestScore < 0)
		return 0;

	lpiFirst= &lpdsl->rgiScores[0];

    for (lpi = &lpdsl->rgiScores[lpdsl->iHighestScore/SCORE_BLOCK_SIZE]; 
	 lpi >= lpiFirst; cThis -= *lpi, lpi--)
	{
		if (cThis <= *lpi)
			return ((lpi - lpiFirst) + !!fRoundUp) * SCORE_BLOCK_SIZE;
	}
	return (!!fRoundUp * SCORE_BLOCK_SIZE);
}

#if defined(_DEBUG)
BOOL DumpDocScoreList(_LPDSL lpdsl, PSRCHINFO pSrchInfo)
{
	LPINT lpi, lpiMax;
	int iT = 0;
	int i;

	lpi = &lpdsl->rgiScores[0];
	lpiMax = lpi + NUM_SCORE_BLOCKS;
	for (i = 0;lpi < lpiMax;lpi++, i++)
	{
		if (*lpi)
		{
			_DPF2("Score %d (count %d)\n", i, *lpi);
		}
		iT += *lpi;
	}
	_DPF1("%d topics in scorelist\n", iT);

	return TRUE;

}
#endif

BOOL UpdateDocScoreList(_LPDSL lpdsl, int iOldScore, int iScore)
{
	int iThis = iScore/SCORE_BLOCK_SIZE;
	int iOld = iOldScore/SCORE_BLOCK_SIZE;
	
	if (lpdsl->cScoresLeft <= 0)
	{
		// already full, figure out which buckets need updating
		if (iThis > lpdsl->iBucketLowest)
		{
			// if we're updating an existing entry, remove that
			// otherwise remove the lowest one
			if (iOld >= lpdsl->iBucketLowest)
				lpdsl->rgiScores[iOld]--;
			else
				lpdsl->rgiScores[lpdsl->iBucketLowest]--;

			// then make sure lowest one is still non-empty; if not,
			// revise upwards
			if (lpdsl->rgiScores[lpdsl->iBucketLowest] <= 0)
			{
    			for (lpdsl->iBucketLowest++; lpdsl->iBucketLowest <= iThis; lpdsl->iBucketLowest++)
    				if (lpdsl->rgiScores[lpdsl->iBucketLowest]) 
						break;
add_new_doc:
				if (lpdsl->iBucketLowest >= 0)
					lpdsl->iBucketLowest = min(lpdsl->iBucketLowest, iThis);
				else
					lpdsl->iBucketLowest = iThis;
			}

			// then add the new entry
			lpdsl->rgiScores[iThis]++;
update_highest_score:		
			if (iScore > lpdsl->iHighestScore)
				lpdsl->iHighestScore = iScore;

#if defined(_DEBUG) && defined(_DUMPALL)
			//DumpDocScoreList(lpdsl, NULL);
#endif		 
			Assert(lpdsl->rgiScores[lpdsl->iHighestScore/SCORE_BLOCK_SIZE] >= 0);
			return TRUE;
		}
		else
		if (iThis == lpdsl->iBucketLowest)
			goto update_highest_score;

		Assert(lpdsl->rgiScores[lpdsl->iHighestScore/SCORE_BLOCK_SIZE] >= 0);
		return FALSE;
    }

	// doc score list is not yet full, so automatically add if new,
	// remove old if update
	if (iOld >= lpdsl->iBucketLowest)
		lpdsl->rgiScores[iOld]--;
	else
		lpdsl->cScoresLeft--;
	goto add_new_doc;
}

__inline BOOL IsDocScoreListFull(_LPDSL lpdsl)
{
	return (lpdsl->cScoresLeft <= 0);
}

__inline WORD AddWeights(DWORD w1, DWORD w2)
{
	return (WORD)min(MAX_WEIGHT, w1 + w2);
}

/*************************************************************************
 *  @doc    EXTERNAL API RETRIEVAL
 *
 *  @func   LPHL FAR PASCAL | MVIndexFindSimilar |
 *      Given a query which probably represents a document text stream, returns 
 *  a hitlist containing topics which are determined to be similar to the query 
 *  using nearest-neighbour searching.
 *
 *  @parm LPIDX | lpidx |
 *       Pointer to index information.
 *
 *  @parm   LPQT | lpqt |
 *      Pointer to query tree (returned by MVQueryParse())
 *
 *  @parm   PSRCHINFO | pSrchInfo |
 *      Pointer to search information data
 *
 *  @parm _LPGROUP | lpResGroup |
 *     Pointer to resulting group
 *
 *  @parm LPVOID | pCallback |
 *     Pointer to callback struct FCALLBACK_MSG (optional)
 *
 *  @parm  PHRESULT | phr |
 *     Pointer to error buffer
 *
 *  @rdesc Pointer to hitlist structure if succeeded, even there is
 *      no hits (use MVHitListEntries() to find out how many hits have been
 *      returned). It will return NULL if failed. The error buffer
 *      (see IndexOpen()) will contain descriptions about the cause of
 *      the failure. There is one special case when the function returns
 *      a non-null pointer, even there is error, that is when it can't
 *      write the result to the disk, and everything is still in memory.
 *
 *************************************************************************/
// bugbug: handle wildcards
PUBLIC LPHL EXPORT_API FAR PASCAL MVIndexFindSimilar (_LPIDX lpidx,
  LPPARSE_PARMS lpParms, PSRCHINFO pSrchInfo, _LPGROUP lpResGroup, 
  LPVOID pCallback, PHRESULT phr)
{
    HRESULT fRet;           // Return from this function.
    LPRETV  lpRetV;     // Retrieval memory/files.
    GHANDLE hRetv;
    //OCCF    occf;       // Index occurence flags temporary variable.
    _LPHL   lphl;       // Pointer to hitlist
    _LPQTNODE   lpTreeTop;
	HANDLE hTreeTop = NULL;
	_LPQT lpqt;

    if (lpidx == NULL || lpParms == NULL || pSrchInfo == NULL)
    {
        /* We get some bad arguments!! */
        SetErrCode (phr, E_INVALIDARG);
        return NULL;
    }

	if (NULL == (lpqt = TokenizeFlatQuery(lpParms, pSrchInfo, phr)))
	{
		// errb was set
        return NULL;
	}

    fRet = E_FAIL;      // Assume thing will go wrong
    
    // Transfer all the information about the index to the query tree
    lpqt->foIdxRoot = lpidx->ih.foIdxRoot;      /* Top node offset */
    lpqt->dwBlockSize = lpidx->ih.dwBlockSize;  /* Index block size */
    lpqt->cIdxLevels = lpidx->ih.cIdxLevels;         /* Index's depth */
    lpqt->occf = lpidx->ih.occf;
    lpqt->idxf = lpidx->ih.idxf;
    lpqt->foIdxRoot = lpidx->ih.foIdxRoot;
    lpqt->ckeyTopicId = lpidx->ih.ckeyTopicId;
    lpqt->ckeyOccCount = lpidx->ih.ckeyOccCount;
    lpqt->ckeyWordCount = lpidx->ih.ckeyWordCount;
    lpqt->ckeyOffset = lpidx->ih.ckeyOffset;

	if (pSrchInfo->dwMemAllowed)
	{
		// allocate document result list
		// no occurrence info is returned for similarity query
		SetBlockCount (lpqt->lpTopicMemBlock, (WORD)(pSrchInfo->dwMemAllowed /
			(sizeof(TOPIC_LIST) * cTOPIC_PER_BLOCK)));

		SetBlockCount (lpqt->lpOccMemBlock, 1);
	}

	if (pCallback)
		MVSearchSetCallback(lpqt, pCallback);

    /* Allocate hitlist */
    if ((lphl = (_LPHL)GlobalLockedStructMemAlloc(sizeof (HL))) == NULL) 
    {
		fRet = E_OUTOFMEMORY;
        SetErrCode(phr, fRet);
exit00:
		if (lpqt)
		{
			FreeDocScoreList(lpqt->lpDocScores);
			MVQueryFree(lpqt);
		}

        if (lphl && fRet != S_OK && fRet != E_TOOMANYTOPICS)
        {
            MVHitListDispose(lphl);
            lphl = NULL;
        }
        return (LPHL)lphl;
    }
    lphl->lLastTopicId = 0xffffffff;
    lphl->lcMaxTopic = lpidx->ih.lcTopics;

    /* Allocate a return value structure */

    if ((hRetv = _GLOBALALLOC(GMEM_MOVEABLE | GMEM_ZEROINIT,
        sizeof(RETV))) == NULL)
    {
       SetErrCode(phr, E_OUTOFMEMORY);
		goto exit00;
    }

    lpRetV = (LPRETV)_GLOBALLOCK(hRetv);
    lpRetV->lpqt = lpqt;

    if ((fRet = TopNodeRead(lpidx)) != S_OK)
    {
        SetErrCode (phr, fRet);
exit02:
        FreeHandle(hRetv);
        goto exit00;
    }


    //
    //  Count the number of occurence fields present.  My retrieval
    //  occurence record is going to cost 4 bytes per field.
    //

    //occf = lpqt->occf;
    //for (lpRetV->cOccFields = 0; occf; lpRetV->cOccFields++)
	//        occf &= occf - 1;

    lpqt->dwOccSize = lpRetV->dwOccSize = 0;
        //sizeof(OCCURENCE) + lpRetV->cOccFields * sizeof (DWORD);

    lpRetV->fRank = TRUE; //((pSrchInfo->Flag &
		//(QUERYRESULT_RANK | QUERYRESULT_NORMALIZE)) != 0);

    // Set pointer to various buffer
    lpRetV->LeafInfo.pTopNode = lpidx->lrgbTopNode;
    lpRetV->LeafInfo.pStemNode = lpRetV->pNodeBuf;
    lpRetV->LeafInfo.pLeafNode = lpRetV->pNodeBuf;
    lpRetV->LeafInfo.pDataNode = lpRetV->pDataBuf;
    lpRetV->LeafInfo.hfpbIdx = lpidx->hfpbIdxSubFile;   // Index file to read from
    
    lpRetV->DataInfo.pTopNode = lpidx->lrgbTopNode;
    lpRetV->DataInfo.pStemNode = lpRetV->pNodeBuf;
    lpRetV->DataInfo.pLeafNode = lpRetV->pNodeBuf;
    lpRetV->DataInfo.pDataNode = lpRetV->pDataBuf;
    lpRetV->DataInfo.hfpbIdx = lpidx->hfpbIdxSubFile;   // Index file to read from
	lpRetV->lcid = lpidx->ih.lcid;
    
    // Save search information
    lpRetV->SrchInfo = *pSrchInfo;
    if (pSrchInfo->dwValue == 0)
        lpRetV->SrchInfo.dwValue = (DWORD)(-1);
    else
        lpRetV->SrchInfo.dwValue = lpidx->ih.lcTopics/pSrchInfo->dwValue;

	// this is a dummy node that we pass in to hold all term results
    if ((lpTreeTop = (_LPQTNODE)_GLOBALLOCK( \
		hTreeTop = _GLOBALALLOC(GHND, sizeof (QTNODE)))) == NULL) 
    {
        SetErrCode(phr, fRet = E_OUTOFMEMORY);
        goto exit02;
    }
	QTN_FLAG(lpTreeTop) = EXACT_MATCH;
	lpTreeTop->pNext = NULL;
	lpTreeTop->pPrev = NULL;
    lpTreeTop->lpTopicList = NULL;

    if ( (fRet = ResolveFlatQuery(lpqt, lpTreeTop, lpRetV)) != S_OK)
    {
        SetErrCode (phr, fRet);

        /* Free the Topic and Occurrence memory blocks since they are
         * not freed by QueryTreeFree(), or MVHitListDispose() at this
         * point
         */

        if (fRet != E_TOOMANYTOPICS)
        {
	
			BlockFree ((LPV)lpqt->lpTopicMemBlock);
			BlockFree ((LPV)lpqt->lpOccMemBlock);
			lpqt->lpTopicMemBlock = NULL;
			lpqt->lpOccMemBlock = NULL;
exit03:
			if (hTreeTop)
			{
				_GLOBALUNLOCK(hTreeTop);
				_GLOBALFREE(hTreeTop);
			}
			goto exit02;
      }
    }

    /* Create a group if requested */
    if ((pSrchInfo->Flag & QUERYRESULT_GROUPCREATE) && lpResGroup)
    {
        LPITOPIC    lpCurTopic;     /* Topic's current pointer */
        LPB         lpbGrpBitVect;
        DWORD       maxTopicId;
        
       /* Initialize the pointer */
        lpbGrpBitVect = lpResGroup->lpbGrpBitVect;

        maxTopicId = lpResGroup->dwSize * 8;
        for (lpCurTopic = QTN_TOPICLIST(lpTreeTop); lpCurTopic;
           lpCurTopic = lpCurTopic->pNext)
        {
            /* Set the bit */
            if (lpCurTopic->dwTopicId < maxTopicId)
            {
                lpbGrpBitVect[(DWORD)(lpCurTopic->dwTopicId / 8)] |= 1 <<
                   (lpCurTopic->dwTopicId % 8);
            }
        }
    }
    
    if ((pSrchInfo->Flag & QUERYRESULT_UIDSORT) == 0)
    {

        /* Sort the result depending on ranking or not */
        if (lpRetV->fRank)
            SortResult ((LPQT)lpqt, lpTreeTop, WEIGHT_BASED);
        else
            SortResult ((LPQT)lpqt, lpTreeTop, HIT_COUNT_BASED);
    } 

    /* Update HitList info structure, cut off the unwanted list */
    if (lphl->lpTopicList = lpTreeTop->lpTopicList)
        lphl->lcReturnedTopics = lphl->lcTotalNumOfTopics = lpTreeTop->cTopic;
        
    // Only return the number of topics that the user requested    
	// if dwTopicCount == 0, it means that the user wants to return all

	if (pSrchInfo->dwTopicCount != 0 &&
		pSrchInfo->dwTopicCount < lphl->lcReturnedTopics)
        lphl->lcReturnedTopics = pSrchInfo->dwTopicCount;

    lphl->lpOccMemBlock = lpqt->lpOccMemBlock;
    lphl->lpTopicMemBlock = lpqt->lpTopicMemBlock;

#if 1
    /* WARNING: The following code should be commented out for
     * diskless devices. No returned error is checked, since
     * if disk writes fail, everything is still in memory
     */

    if ((pSrchInfo->Flag & QUERYRESULT_IN_MEM) == 0)
    {
        if ((fRet = MVHitListFlush (lphl, lphl->lcReturnedTopics)) != S_OK)
            SetErrCode (phr, fRet);
    }
#endif

	fRet = S_OK;
    goto exit03;
}

PRIVATE LPQT TokenizeFlatQuery(LPPARSE_PARMS lpParms, PSRCHINFO pSrchInfo, PHRESULT phr)
{
    HRESULT fRet;           // Return value.
    HANDLE  hqi;            // Handle to "lpqi".
    HANDLE  hibi;           // Handle to internal breaker info
    HANDLE  hQuery;         // Handle to secondary query buffer
    LPQI    lpQueryInfo;    // Query information.
    LPIBI   lpibi;          // Pointer to internal breaker info
    LPB     lpbQueryBuf;    // Copy of query's buffer
    _LPQT   lpQueryTree;    // Query tree pointer
    BRK_PARMS   brkParms;   // Breaker info parms
    LPCHARTAB lpCharTabInfo;// Pointer to character table's info

    /* LPPARSE_PARMS structure break-out variables */
    BYTE FAR CONST *lpbQuery;           // Query buffer
    DWORD cbQuery;          // Query length
    LPBRKLIST lpfnTable;    // DType function table
    LPGROUP lpGroup;        // Group

    lpbQuery = lpParms->lpbQuery;
    cbQuery = lpParms->cbQuery;
    lpfnTable = lpParms->lpfnTable;
    lpGroup = lpParms->lpGroup;

    if (lpfnTable == NULL)
    {
        SetErrCode(phr, E_BADBREAKER);
        return NULL;
    }

    if (cbQuery == 0 || lpbQuery == NULL) {
        SetErrCode(phr, E_NULLQUERY);
        return NULL;
    }

    lpQueryTree = NULL;
    hqi = hibi = hQuery = NULL;
	fRet = E_FAIL;

    if ((hqi = (GHANDLE)_GLOBALALLOC(GMEM_MOVEABLE | GMEM_ZEROINIT,
        (LCB)sizeof(QUERY_INFO))) == NULL)
    {
        fRet = SetErrCode(phr, E_OUTOFMEMORY);
        goto ErrFreeAll;
    }
    lpQueryInfo = (LPQI)_GLOBALLOCK(hqi);
    lpQueryInfo->lperrb = phr;
    lpQueryInfo->lpOpSymTab = NULL; // not used for similarity
	lpQueryInfo->cOpEntry = 0;

    /*  Allocate a breaker info block used by different breakers */
    if ((hibi = (GHANDLE)_GLOBALALLOC(GMEM_MOVEABLE | GMEM_ZEROINIT,
        (LCB)sizeof(IBI))) == NULL)
    {
        fRet = SetErrCode(phr, E_OUTOFMEMORY);
        goto ErrFreeAll;
    }
    lpibi = (LPBRKI)_GLOBALLOCK(hibi);

    /* Set the default breaker function, and stop list */
#ifndef CW
    lpQueryInfo->lpfnBreakFunc = lpfnTable[0].lpfnBreakFunc;
#endif
    lpQueryInfo->lpStopListInfo = lpfnTable[0].lpStopListInfo;

    if ((lpCharTabInfo = lpQueryInfo->lpCharTab =
        lpfnTable[0].lpCharTab) == NULL)
    {

        /* Default character and ligature tables */

        lpCharTabInfo = lpQueryInfo->lpCharTab = MVCharTableGetDefault (phr);
        if (lpCharTabInfo == NULL)
        {
            fRet = SetErrCode(phr, E_NOHANDLE);
            goto ErrFreeAll;
        }
        lpQueryInfo->fFlag |= FREE_CHARTAB;
    }
    
    /* Change the property of '*' and '?' to character */

    ((LPCMAP)lpCharTabInfo->lpCMapTab)['*'].Class = CLASS_WILDCARD;
    ((LPCMAP)lpCharTabInfo->lpCMapTab)['?'].Class = CLASS_WILDCARD;

    switch (lpCharTabInfo->fFlag)
    {
        case USE_DEF_LIGATURE:
            lpCharTabInfo->wcLigature = DEF_LIGATURE_COUNT;
            lpCharTabInfo->lpLigature = LigatureTable;
            break;

        case NO_LIGATURE:
            lpCharTabInfo->wcLigature = 0;
            lpCharTabInfo->lpLigature = NULL;
    }

	// not used for similarity
    lpQueryInfo->lpStack = NULL;

    /* Allocate a query tree */
    if ((lpQueryTree = (_LPQT)QueryTreeAlloc()) == NULL)
    {
        fRet = SetErrCode(phr, E_OUTOFMEMORY);
        goto ErrFreeAll;
    }

    /* Associate the query tree with the query. In the future, this will
     * ensure the capability to have several queries and query trees
     * at once
     */
    lpQueryInfo->lpQueryTree = (LPQT)lpQueryTree;

    /* Default arguments */

    lpQueryTree->iDefaultOp = (BYTE)OR_OP;
    lpQueryTree->lpGroup = lpGroup;         // Use default Group
    lpQueryTree->dwFieldId = 0;//DW_NIL_FIELD;  // No fieldid search
    lpQueryTree->cStruct.dwKey = CALLBACKKEY;

    lpQueryTree->fFlag = 0;
    lpQueryTree->wProxDist = 0;

	if (NULL == (lpQueryTree->lpDocScores = InitDocScoreList(pSrchInfo->dwTopicCount)))
	{
        fRet = SetErrCode(phr, E_OUTOFMEMORY);
        goto ErrFreeAll;
	}

    /* Copy the query into a temporary buffer since we are going to make
    change to it
    */
    if ((hQuery = _GLOBALALLOC(DLLGMEM_ZEROINIT, (LCB)cbQuery + 2)) == NULL)
    {
        SetErrCode(phr, E_OUTOFMEMORY);
        FreeHandle(hqi);
        return NULL;
    }
    lpbQueryBuf = lpQueryInfo->lpbQuery = (LPB)_GLOBALLOCK(hQuery);
    lpbQueryBuf[cbQuery] = ' '; // Add a space to help LowLeveltransformation
    lpbQueryBuf[cbQuery + 1] = 0; // Zero-terminated string (safety bytes)
    MEMCPY(lpbQueryBuf, lpbQuery, cbQuery);

    //
    //  Word-break between here and there.
    //

    brkParms.lpInternalBreakInfo = lpibi;
    brkParms.lpbBuf = lpbQueryBuf;
    brkParms.cbBufCount = cbQuery;
    brkParms.lcbBufOffset = 0;
    brkParms.lpvUser = lpQueryInfo;
    brkParms.lpfnOutWord = (FWORDCB)FFlatCallBack;
    brkParms.lpStopInfoBlock = lpQueryInfo->lpStopListInfo;
    brkParms.lpCharTab = lpQueryInfo->lpCharTab;
    brkParms.fFlags = ACCEPT_WILDCARD;

    if ((fRet = (*lpQueryInfo->lpfnBreakFunc)((LPBRK_PARMS)&brkParms))
        != S_OK)
    {
        fRet = SetErrCode(phr, (WORD)fRet);
        goto ErrFreeAll;
    }

    /* Flush the word breaker */
    brkParms.lpbBuf = NULL;
    brkParms.cbBufCount = 0;

    if ((fRet = (*lpQueryInfo->lpfnBreakFunc)((LPBRK_PARMS)&brkParms))
        != S_OK)
    {
        fRet = SetErrCode(phr, fRet);
        goto ErrFreeAll;
    }

    /* Set the position of pointer to report missing term at
    the end of the query. -1 since the offset starts at 0
    */
    lpQueryInfo->dwOffset = cbQuery - 1;

	fRet = S_OK;

ErrFreeAll:
    /* Free the charmap table */
    if (lpQueryInfo->fFlag & FREE_CHARTAB)
        MVCharTableDispose (lpQueryInfo->lpCharTab);

    /* Free query info */
    if (hqi)
    {
        FreeHandle(hqi);
    };

    /* Free internal breaker info */
    if (hibi)
    {
        FreeHandle(hibi);
    };

    /* Free internal query buffer info */
    if (hQuery)
    {
        FreeHandle(hQuery);
    };

    if (fRet == S_OK)
        return lpQueryTree;

    if (lpQueryTree)
    {
        BlockFree(lpQueryTree->lpStringBlock);
		BlockFree(lpQueryTree->lpWordInfoBlock);
        BlockFree(lpQueryTree->lpOccMemBlock);
        BlockFree(lpQueryTree->lpTopicMemBlock);
        BlockFree(lpQueryTree->lpNodeBlock);

		FreeDocScoreList(lpQueryTree->lpDocScores);
        /* Free Query tree block */
        FreeHandle ((HANDLE)lpQueryTree->cStruct.dwReserved);
    }
    return NULL;
}

/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   HRESULT FAR PASCAL | ProcessTerm |
 *      This function will search the index for the given word' data.
 *  @parm   _LPQT | lpqt |
 *      Pointer to index structure
 *  @parm   LPRETV | lpRetV |
 *      Pointer to "globals"
 *  @parm   _LPQTNODE | lpCurQtNode |
 *      Current node in the query tree containing important data
 *      - The number of topics
 *      - The location of the data
 *      - The size of the data
 *      - Pointer to the next word (for wildcard search)
 *  @rdesc  S_OK or other errors
 *************************************************************************/
PUBLIC HRESULT EXPORT_API FAR PASCAL ProcessTerm(_LPQT lpqt, LPRETV lpRetV, 
	_LPQTNODE lpResQuery, _LPQTNODE lpQtNode, STRING_TOKEN FAR *lpToken)
{
    DWORD   dwTopicIDDelta; // Topic-ID delta from previous sub-list.
    DWORD   dwOccs;         // Number of occurences in this sub-list.
    DWORD   dwTmp;          // Scratch variable.
    WORD    wWeight;        // Term-weight associated with this sub-list.
	WORD	wWeightMax;
    DWORD   dwTopicID;      // TopicId 
    WORD    wImportance;
    DWORD   dwLength;       // Length of the word
    TOPIC_LIST FAR *lpResTopicList;  // Result TopicList
    HRESULT fRet;               // Returned value
    PNODEINFO pDataInfo;
    DWORD   dwTopicCount;
    _LPQT   lpQueryTree; // Query tree
    OCCF    occf;
    BYTE    fSkipOccList = FALSE;
	_LPDSL	lpDocScores = (_LPDSL)(lpqt->lpDocScores);

    pDataInfo = &lpRetV->DataInfo;
    if ((pDataInfo->dwDataSizeLeft = lpQtNode->cbData) == 0)
        return(S_OK);    // There is nothing to process
        
    // Initialize variables
    occf = lpqt->occf;
    wImportance = QTN_TOKEN(lpQtNode)->wWeight;
    lpResTopicList = NULL;
    lpQueryTree = lpRetV->lpqt;
    dwTopicCount = lpQtNode->cTopic;
    wWeight = (WORD)(65535L/(lpToken ? lpToken->dwTopicCount : dwTopicCount));
    
    // Reset the topic count for lpQtNode so that is will not affect the
    // result in case that lpResQuery == NULL
    
    lpQtNode->cTopic = 0;
    
    if (lpResQuery == NULL)
        lpResQuery = lpQtNode;
        
    // Initialize the data buffer node values
    pDataInfo->pBuffer = pDataInfo->pDataNode;
    pDataInfo->nodeOffset = lpQtNode->foData;
    
    // Read the data block
    if ((fRet = ReadNewData(pDataInfo)) != S_OK)
        return(fRet);
        
    dwTopicID = 0L;         // Init occurence record
    dwLength = 0;

	// for each document in posting
    for (; dwTopicCount; dwTopicCount--) 
    {        
        /* Check for interrupt now and then */
        if ((++lpqt->cInterruptCount) == 0)
        {
            if (lpqt->fInterrupt == E_INTERRUPT)        
                return E_INTERRUPT;
            if (*lpqt->cStruct.Callback.MessageFunc &&
                (fRet = (*lpqt->cStruct.Callback.MessageFunc)(
                lpqt->cStruct.Callback.dwFlags,
                lpqt->cStruct.Callback.pUserData, NULL)) != S_OK)
                return(fRet);
        }
        
        // Byte align
        if (pDataInfo->ibit != cbitBYTE - 1)
        {
            pDataInfo->ibit = cbitBYTE - 1;
            pDataInfo->pCurPtr ++;
        }
        
        // Get value from which I will calculate current doc-ID.
        if ((fRet = FGetDword(pDataInfo, lpqt->ckeyTopicId,
            &dwTopicIDDelta)) != S_OK)
        {
exit0:
            return fRet;
        }

        dwTopicID += dwTopicIDDelta;
        //
        //  Get term-weight if present.  I'm going to get this
        //  even if I'm not doing ranking, because it's in the
        //  index, and I have to get around it somehow.
        //
        if (lpqt->idxf & IDXF_NORMALIZE) 
        {
            if ((fRet = FGetBits(pDataInfo, &dwTmp, sizeof (USHORT) * cbitBYTE))
                != S_OK)
                goto exit0;

            if (wImportance != MAX_WEIGHT)
                dwTmp = (dwTmp * wImportance) / 65535;

			// BUGBUG: we actually want the weights for all aliased terms
			// to be considered at once.
            wWeight = (WORD)dwTmp;
        }

		// always skip any occurrence info
        if (occf & (OCCF_OFFSET | OCCF_COUNT))
		{
			//  Figure out how many occurences there are in this
			//  sub-list.
			//
			if ((fRet = FGetDword(pDataInfo, lpqt->ckeyOccCount,
				&dwOccs)) != S_OK) 
				goto exit0;

			if ((fRet = SkipOccList (lpqt, pDataInfo, dwOccs)) != S_OK)
				goto exit0;
		}

        //  If this search includes a group, and the doc is not in the
        //  group then ignore it
        if (lpQueryTree->lpGroup 
			 && FGroupLookup(lpQueryTree->lpGroup, dwTopicID) == FALSE)
			 continue;

		// calculate relevance upper bound Dr = Ds + sum(Qi) for this document
	    if (lpResTopicList = TopicNodeSearch(lpQueryTree, lpResQuery, dwTopicID))
			wWeightMax = lpResTopicList->wWeight;
		else
			wWeightMax = 0;

		wWeightMax = AddWeights(wWeightMax, wWeight);
		wWeightMax = AddWeights(wWeightMax, QTN_TOKEN(lpQtNode)->wWeightRemain);
		if (wWeightMax < GetMinDocScore(lpDocScores, ROUND_DOWN)
			 && 
			IsDocScoreListFull(lpDocScores))
		{
			// do not alloc/ or remove D from result list if present
			if (lpResTopicList)
			{
				register LPITOPIC lpPrev, lpTmp;   

				// find lpPrev
				// UNDONE: look into removing necessity for this loop
				for (lpPrev = NULL, lpTmp = (LPITOPIC)lpQtNode->lpTopicList; lpTmp;
					lpTmp = lpTmp->pNext) {
					if (lpTmp == (LPITOPIC)lpResTopicList)
						break;
					lpPrev = lpTmp;
				}

				TopicNodeFree(lpQueryTree, lpResQuery, lpPrev, lpResTopicList);
#if defined(_DEBUG) && defined(_DUMPALL)
				_DPF3("Remove topic %lu, wWeightMax = %lu, MinDocScore = %u\n", dwTopicID, \
					wWeightMax, GetMinDocScore(lpDocScores, ROUND_DOWN));
#endif
			}
			// no need to update top-N docs since this wasn't one of them
			continue;
		}

		if (lpResTopicList)
		{
			WORD wOldWeight = lpResTopicList->wWeight;

			// Calc new Ds for this doc and if good enough for the club, ensure that
			// club invariant is maintained, else leave it since it could still become
			// a club member in the future
			lpResTopicList->wWeight = AddWeights(lpResTopicList->wWeight, wWeight);
			if (lpResTopicList->wWeight > GetMinDocScore(lpDocScores, ROUND_DOWN))
				UpdateDocScoreList(lpDocScores, wOldWeight, lpResTopicList->wWeight);

#if defined(_DEBUG) && defined(_DUMPALL)
			_DPF3("Update topic %lu, wWeightMax = %lu, wWeight = %u\n", dwTopicID, \
				wWeightMax, lpResTopicList->wWeight);
#endif

			continue;
		}

		// a new document counter: possible  club member, or not enough
		// total documents yet
		if ((lpResTopicList = TopicNodeAllocate(lpQueryTree)) == NULL) 
		{
			fRet = E_TOOMANYTOPICS;
			goto exit0;
		}
		lpResTopicList->dwTopicId = dwTopicID;
		lpResTopicList->lpOccur = NULL;
		lpResTopicList->lcOccur = 0;
		lpResTopicList->wWeight = wWeight;              

		/* Add the new TopicID node into TopicList */
		TopicNodeInsert (lpQueryTree, lpResQuery, lpResTopicList);
		UpdateDocScoreList(lpDocScores, -1, lpResTopicList->wWeight);

#if defined(_DEBUG) && defined(_DUMPALL)
		_DPF3("New topic %lu, wWeightMax = %lu, wWeight = %u\n", dwTopicID, \
			wWeightMax, lpResTopicList->wWeight);
#endif


    } // end for each topic in posting
    
    fRet = S_OK;

    return fRet;
}

PRIVATE HRESULT PASCAL NEAR ResolveFlatQuery(_LPQT lpqt, _LPQTNODE lpCurQtNode, LPRETV lpRetV)
{
    HRESULT     fRet;
    PNODEINFO    pLeafInfo = &lpRetV->LeafInfo;
    LPB     astBTreeWord = lpRetV->pBTreeWord;
    DWORD   dwTotalTopic;
    LPB     lstModified = lpRetV->pModifiedWord;
    ERRB    errb;
	WORD    cByteMatched = 0;
    STRING_TOKEN FAR *lpStrList;    /* Pointer to strings table */
	STRING_TOKEN FAR *lpPrev;    /* Pointer to strings table */
	_LPDSL	lpDocScores = (_LPDSL)(lpqt->lpDocScores);
	LPWORDINFO lpwiT;
	LPWORDINFO lpwiPrev;

	// first collect the word info for each token
    for (lpStrList = lpqt->lpStrList, lpPrev = NULL;
		lpStrList; lpStrList = lpStrList->pNext)
    {
		BOOL fNumber = TRUE;

		// accumulate the list of terms to have data read
		if ((fRet = GetWordInfoList(lpqt, lpStrList, lpCurQtNode, lpRetV)) != S_OK)
		{
			return SetErrCode (&errb, fRet);
		}

		// if no word info was available, remove the token from the list
		// it won't get freed until end of query, but who cares - it makes
		// the rest of the processing faster
		if (!lpStrList->lpwi)
		{
			if (lpPrev)
				lpPrev->pNext = lpStrList->pNext;
			else
				lpqt->lpStrList = lpStrList->pNext;
	
			// NOTE: lpPrev must remain unchanged when deleting!
			continue;
		}

		// cycle through all the instances of this term's lookalikes
		// (e.g. multiple aliases) and add up the total topic count
		// since we don't want to treat aliases as rare, even though
		// they may be.
		lpStrList->dwTopicCount = lpStrList->lpwi->cTopic;
		for (lpwiT = lpStrList->lpwi->pNext, lpwiPrev = NULL; lpwiT; 
		 lpwiPrev = lpwiT, lpwiT = lpwiT->pNext)
			lpStrList->dwTopicCount += lpwiT->cTopic;

		lpPrev = lpStrList;
	} // for next term
	
	// sort string list by descending term rarity
	SortStringWeights(lpqt);

	dwTotalTopic = 0;

    for (lpStrList = lpqt->lpStrList;
		lpStrList; lpStrList = lpStrList->pNext)
    {
		LPWORDINFO lpwiT;

		if (lpStrList->lpwi == NULL)
			continue;

#if defined(_DEBUG) && defined(_DUMPALL)
		{
		char szTemp[256];
		
		STRNCPY(szTemp, lpStrList->lpString + 2, *(LPWORD)lpStrList->lpString);
		szTemp[*(LPWORD)lpStrList->lpString] = 0;
		_DPF1("Term: '%s'\n", szTemp);
		}
#endif

		// We can terminate the query processing if the upper bound on the
		// smallest current doc score is lteq the current score of the R-th 
		// biggest doc score, since any further computation will at most 
		// result in a re-ordering of the bottom (N - R) documents.  
		// However, this leaves the remaining documents only partially 
		// sorted by relevancy, which may or may not be acceptable.

		if (AddWeights(GetMinDocScore(lpDocScores, ROUND_UP), 
			lpStrList->wWeightRemain) <= GetSortedDocScore(lpDocScores, 
			   (int)lpRetV->SrchInfo.dwTopicFullCalc, ROUND_DOWN))
			 break;

		lpqt->lpTopicStartSearch = NULL;
		lpqt->lpOccStartSearch = NULL;

		QTN_TOKEN(lpCurQtNode) = lpStrList;

		for (lpwiT = lpStrList->lpwi; lpwiT; lpwiT = lpwiT->pNext)
		{
			// TO DO: replace with WORDINFO in curqt node
            lpCurQtNode->cTopic = lpwiT->cTopic;
            lpCurQtNode->foData = lpwiT->foData;
            lpCurQtNode->cbData = lpwiT->cbData;
			lpCurQtNode->wRealLength = lpwiT->wRealLength;

            if ((fRet = ProcessTerm(lpqt, lpRetV, 
                NULL, lpCurQtNode, lpStrList)) != S_OK)
            {
				// kevynct: no need to overwrite count on error since
				// we may be attempting to continue
				lpCurQtNode->cTopic += dwTotalTopic;
                return(fRet);
            }

            // Accumulate the topic count, since cTopic will be destroyed
            // if there is more searches for this node (such as wildcard)
            dwTotalTopic += lpCurQtNode->cTopic;
		}
	}

	lpCurQtNode->cTopic = dwTotalTopic;

	return S_OK;
}

__inline void MergeWordInfoCounts(WORDINFO FAR *lpwiDest, WORDINFO FAR *lpwiSrc)
{
	lpwiDest->cTopic += lpwiSrc->cTopic;
}

// adds zero or more WORDINFO nodes for the passed-in string
PRIVATE HRESULT GetWordInfoList(_LPQT lpqt, STRING_TOKEN FAR *lpStrToken, _LPQTNODE lpCurQtNode, LPRETV lpRetV)
{
    int     cLevel;
    int     cMaxLevel;
    int     fCheckFieldId;
    LST     lstSearchStr;
    LPB     lpCurPtr;        
    int     nCmp;
    HRESULT     fRet;
    int     f1stIsWild;
    LPB     lpMaxAddress;
    PNODEINFO    pLeafInfo = &lpRetV->LeafInfo;
    DWORD   dwTemp;
    LPB     astBTreeWord = lpRetV->pBTreeWord;
    WORD    wLen;
    DWORD   dwFieldID;
    LPB     lstModified = lpRetV->pModifiedWord;
    BYTE    fStemmed;
    LPB     pBTreeWord;
    ERRB    errb;
	WORD    cByteMatched = 0;
	WORDINFO wi;
    LPWORDINFO lpwi;

	fStemmed = 0;

	lstSearchStr = lpStrToken->lpString;
	f1stIsWild = (lstSearchStr[2] == WILDCARD_CHAR ||
		lstSearchStr[2] == WILDCARD_STAR);

	// Make sure to turn of stemming if there is any wildcard characters

	for (nCmp = *((LPW)lstSearchStr) + 1; nCmp >= 2; nCmp--)
	{
		if (lstSearchStr[nCmp] == '*' || lstSearchStr[nCmp] == '?')
		{
			fStemmed = FALSE;
			break;
		}
	}

	// Turned off stemming for short words
	if (*(LPW)lstSearchStr < 3)
		fStemmed = FALSE;

	pLeafInfo->nodeOffset = lpqt->foIdxRoot;
	pLeafInfo->iLeafLevel = lpqt->cIdxLevels - 1;
	pLeafInfo->dwBlockSize = lpqt->dwBlockSize;

    // BUGBUG: we don't handle stemming for now.  
    MEMCPY (lstModified, lstSearchStr, 
        *((LPW)lstSearchStr) + sizeof (SHORT));
    // Zero terminated for wildcard search    
    lstModified [*((LPW)lstModified) + 2] = 0;
    
    pBTreeWord = lpRetV->pBTreeWord;
    
	/* Change all '*' and '?' to 0. This will
	 * ensure that things gets compared correctly with
	 * the top node's entries
	 */
	for (nCmp = *((LPW)lstModified) + 1; nCmp >= 2; nCmp--)
	{
		if (lstModified[nCmp] == '*' || lstModified[nCmp] == '?')
		{
			lstModified[nCmp] = 0;
			*(LPW)lstModified = nCmp - 2;
		}
	}

	/*
	 * Point node-resolution variables at the right things.  This
	 * sets these up to read b-tree nodes.  Fields not set here are
	 * set as appropriate elsewhere.
	 */

	/* Set the flag */
	fCheckFieldId = (lpqt->occf & OCCF_FIELDID) && (lpCurQtNode->dwFieldId != DW_NIL_FIELD);

	astBTreeWord[0] = 0;
	cMaxLevel = lpqt->cIdxLevels - 1;

	/*
	First we have to find which tree level the word is in. The number of
	searches is equal to the number of tree levels at most. The
	structure of the directory node is a sequence of:
		- Words: PASCAL strings
		- Data offset: will tell us where is the
		offset of the record in the index file
	*/
	for (cLevel = 0; cLevel < cMaxLevel ; cLevel++) 
	{
		//
		//  Get a node.
		//
		if ((fRet = ReadStemNode ((PNODEINFO)pLeafInfo, cLevel)) != S_OK)
		{
			return SetErrCode (&errb, fRet);
		}
		lpMaxAddress = pLeafInfo->pMaxAddress;
		lpCurPtr = pLeafInfo->pCurPtr;

		//
		//  Loop through it.  This compares the word I'm
		//  looking for against the word in the b-tree.
		//  If the word in the b-tree is >= the word I'm
		//  looking for, I'm done.
		//
		//  If I run off the end of the node, there can be
		//  no match for this term, so I skip the entire
		//  process.
		//
		for (;;)
		{            
			if (lpCurPtr >= lpMaxAddress)
				return S_OK;

			lpCurPtr = ExtractWord(astBTreeWord, lpCurPtr, &wLen);

			if (fStemmed)
			{
				if ((fRet = FStem (pBTreeWord, astBTreeWord)) !=
					S_OK)
					return(S_OK);
			}
        
			/* Read in NodeId record */
			lpCurPtr += ReadFileOffset (&pLeafInfo->nodeOffset, lpCurPtr);

			if (f1stIsWild)
				break;
			if (StrCmpPascal2(lstModified, pBTreeWord) <= 0)
				break;
		}
	}

	/* At this point, pLeafInfo->nodeOffset is the node id of the leaf that
	is supposed to contain the searched word. Read in the leaf node
	*/
	if ((fRet = ReadLeafNode ((PNODEINFO)pLeafInfo, cLevel)) != S_OK)
	{
		return fRet;
	}

	lpCurPtr = pLeafInfo->pCurPtr;
	lpMaxAddress = pLeafInfo->pMaxAddress;

	//
	//  Second step is to deal with the leaf node(s).  I'm going to
	//  find and capture some occurence lists.  I'll probably have to
	//  ignore some bogus ones first.
	//

	// Reset the word
	if (fStemmed)
	{
		MEMCPY (lstModified, lpRetV->pStemmedQueryWord,
			*(LPW)lpRetV->pStemmedQueryWord + sizeof(WORD));
	}
	else
	{
		MEMCPY (lstModified, lstSearchStr, 
			*((LPW)lstSearchStr) + sizeof (SHORT));
	}
    
	for (;;) 
	{
		// Check for out of data
		if (lpCurPtr >= lpMaxAddress)
		{
			// Get the offset of the next node
			ReadFileOffset (&pLeafInfo->nodeOffset, pLeafInfo->pBuffer);
			if (FoIsNil (pLeafInfo->nodeOffset))
			{
				return S_OK;
			}
            
			// Read the next node    
			if ((fRet = ReadLeafNode ((PNODEINFO)pLeafInfo, cLevel))
				!= S_OK)
			{
				return SetErrCode (&errb, fRet);
			}
			lpCurPtr = 
				pLeafInfo->pBuffer + FOFFSET_SIZE + sizeof (SHORT);
			lpMaxAddress = pLeafInfo->pMaxAddress;
		}
    
		/* Check for interrupt now and then */
		if ((++lpqt->cInterruptCount) == 0)
		{
			if (lpqt->fInterrupt == E_INTERRUPT)        
				return E_INTERRUPT;
			if (*lpqt->cStruct.Callback.MessageFunc &&
				(fRet = (*lpqt->cStruct.Callback.MessageFunc)(
				lpqt->cStruct.Callback.dwFlags,
				lpqt->cStruct.Callback.pUserData, NULL)) != S_OK)
				return(fRet);
		}
        
		// Extract the word
		lpCurPtr = ExtractWord(astBTreeWord, lpCurPtr, &wLen);
    
		if (fStemmed)
		{
			if ((fRet = FStem (pBTreeWord, astBTreeWord)) != S_OK)
				return(fRet);
		}

		if (lpqt->occf & OCCF_FIELDID)
			lpCurPtr += CbByteUnpack (&dwFieldID, lpCurPtr);
        
		nCmp = CompareTerm (lpCurQtNode, lstModified, pBTreeWord, fCheckFieldId ?
			 dwFieldID : lpCurQtNode->dwFieldId, lpRetV->pLeadByteTable);

		switch (nCmp)
		{
			case KEEP_SEARCHING:
				// Skip TopicCount
				lpCurPtr += CbByteUnpack (&dwTemp, lpCurPtr);
				// Skip data offset
				lpCurPtr += FOFFSET_SIZE;
				// Skip DataSize
				lpCurPtr += CbByteUnpack (&dwTemp, lpCurPtr);
				break;

			case STRING_MATCH:

				lpCurPtr += CbByteUnpack (&wi.cTopic, lpCurPtr);
				lpCurPtr += ReadFileOffset (&wi.foData, lpCurPtr);
				lpCurPtr += CbByteUnpack (&wi.cbData, lpCurPtr);
				wi.wRealLength = wLen;// BUGBUG doublecheck this

				// Check for Topic count. This can be 0 if the word has been deleted
				// from the index
				if (wi.cTopic == 0)
					break;

				// long search optimization: clip noise words.
				// Johnms- eliminate frequent words.
				// typically, you eliminate if in more than 1/7 of documents.

				if ((lpRetV->SrchInfo.Flag & LARGEQUERY_SEARCH)
					 &&
					 lpRetV->SrchInfo.dwValue < wi.cTopic
					)
				{
					break;
				}

				// allocate WORDINFO node
				if ((lpwi = BlockGetElement(lpqt->lpWordInfoBlock)) == NULL)
					return E_OUTOFMEMORY;

				*lpwi = wi;

				lpwi->pNext = lpStrToken->lpwi;
				lpStrToken->lpwi = lpwi;

				// Save the info
				pLeafInfo->pCurPtr = lpCurPtr;
            	break;

			case NOT_FOUND: // No unconditional "break" above.
				if (fStemmed &&  (strncmp (lstSearchStr+ 2, pBTreeWord + 2,
					cByteMatched) == 0))
				{
					// Continue searching in case stemming is messed up
					// by non-alphabetic word, such as the sequence:
					// subtopic subtopic2 subtopics
					lpCurPtr += CbByteUnpack (&dwTemp, lpCurPtr);
					// Skip data offset
					lpCurPtr += FOFFSET_SIZE;
					// Skip DataSize
					lpCurPtr += CbByteUnpack (&dwTemp, lpCurPtr);
					   break;
				}
				return S_OK;
		}
	}

}

/*************************************************************************
 *  @doc    INTERNAL
 *  
 *  @func   HRESULT PASCAL FAR | FFlatCallBack |
 *      This call back function is called by various breakers after
 *      fetching a token. The token is checked for wild char presence
 *
 *  @parm   LST | lstRawWord |
 *      Pointer to unnormalized string
 *
 *  @parm   LST | lstNormWord |
 *      Pointer to normalized string. This pascal string's size should be
 *      at least *lstNormWord+2
 *
 *  @parm   LFO | lfoWordOffset |
 *      Offset into the query buffer. It is used to mark the location
 *      where an parsing error has occurred
 *
 *  @parm   LPQI | lpqi |
 *      Pointer to query info structure. This has all "global" variables
 *
 *  @rdesc  S_OK if succeeded, else various errors.
 *************************************************************************/
PUBLIC HRESULT PASCAL FAR EXPORT_API FFlatCallBack (LST lstRawWord, LST lstNormWord,
    LFO lfoWordOffset, LPQI lpqi)
{
    /* Add extra 0 to make sure that AllocWord() gets the needed 0
     * for WildCardCompare()
     */
    lstNormWord[*(LPW)(lstNormWord) + 2] = 0;

	// add the token to the string list
    if (AllocWord(lpqi->lpQueryTree, lstNormWord) == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}

// for now, perform simple insertion sort on the string list
// bugbug: use heapsort or faster method for long lists
// for now, we sort by total topic count decreasing (rare terms first)
PRIVATE VOID PASCAL SortStringWeights(_LPQT lpQueryTree)
{
    STRING_TOKEN FAR *pStr, *pStrNext, *pT, *pTPrev;
	STRING_TOKEN FAR *pStrHead = lpQueryTree->lpStrList;
	DWORD dwSum, dwT;
	DWORD dwMaxWeight;
	WORD wWeightT;
	int nCmp;
    FLOAT   rLog;             
    FLOAT   rLogSquared;
	FLOAT   rSigma;
	FLOAT	rTerm;
	BOOL	fNormalize = FALSE; // Normalize was for testing only.

	if (fNormalize)
	{
		rSigma = (float)0.0;

		// for each term:
		for (pStr = pStrHead; pStr; pStr = pStr->pNext)
		{
			FLOAT fOcc;

			// we have to guard against the possibility of the log resulting in 
			// a value <= 0.0. Very rare, but possible in the future. This happens
			// if dwTopicCount approaches or exceeds the N we are using (N == 100 million)
			if (pStr->dwTopicCount >= cNintyFiveMillion)
				rLog = cVerySmallWt;	// log10(100 mil/ 95 mil) == 0.02
			else
				//rLog = (float) log10(cHundredMillion/(double)pHeader->dwTopicCount);
				rLog = (float) (8.0 - log10((double)pStr->dwTopicCount));

			rLogSquared = rLog*rLog;

			// Update sigma value
			// NOTE : We are bounding dwOccCount by a value of eTFThreshold
			// The RHS of the equation below has an upperbound of 2 power 30.
			fOcc = (float) min(cTFThreshold, pStr->cUsed);
			rSigma += fOcc*fOcc*rLogSquared;
		}

		rSigma = (float)sqrt(rSigma);
	}

	// calculate final weights and corrections
	dwSum = dwMaxWeight = 0L;
	for (pStr = pStrHead; pStr; pStr = pStr->pNext, nCmp++)
	{
		BOOL fNumber;

		// once sigma is known, each term's proper weight can be calculated
        if (fNormalize)
        {			
			FLOAT rWeight;
			
			// log10(x/y) == log10 (x) - log10 (y). Since x in our case is a known constant,
			// 100,000,000, I'm replacing that with its equivalent log10 value of 8.0 and subtracting
			// the log10(y) from it
			rTerm = (float) (8.0 - log10((double) pStr->dwTopicCount));
			// In extreme cases, rTerm could be 0 or even -ve (when dwTopicCount approaches or 
			// exceeds 100,000,000)
			if (rTerm <= (float) 0.0)
				rTerm = cVerySmallWt;	// very small value. == log(100 mil/ 95 mil)
			// NOTE : rWeight for the doc term would be as follows:
			//	rWeight = float(min(4096, dwBlockSize)) * rTerm / lpipb->wi.hrgsigma[dwTopicId]
			//
			// Since rTerm needs to be recomputed again for the query term weight computation,
			// and since rTerm will be the same value for the current term ('cos N and n of log(N/n)
			// are the same (N = 100 million and n is whatever the doc term freq is for the term),
			// we will factor in the second rTerm at index time. This way, we don't have to deal
			// with rTerm at search time (reduces computation and query time shortens)
			//
			// MV 2.0 initially did the same thing. However, BinhN removed the second rTerm
			// because he decided to remove the rTerm altogether from the query term weight. He
			// did that to keep the scores reasonably high.

			rWeight = ((float) min(cTFThreshold, pStr->cUsed)) 
				* rTerm * rTerm / rSigma;
			// without the additional rTerm, we would probably be between 0.0 and 1.0
			if (rWeight > rTerm)
				wWeightT = 0xFFFF;
			else
				wWeightT = (WORD) ((float)0xFFFF * rWeight / rTerm);

        }
		else
			wWeightT = 65535;

		pStr->wWeight = (WORD)(16383 + 49152 / pStr->dwTopicCount);

		// perform any special weight adjustments here
		// BUGBUG: use NextChar here, and use charmap here
		// numbers four digits or less get downgraded
		fNumber = TRUE;
		for (nCmp = *((LPWORD)pStr->lpString) + 1; nCmp >= 2; nCmp--)
			if (nCmp > 5 || !IS_DIGIT(pStr->lpString[nCmp]))
			{
				fNumber = FALSE;
				break;
			}

		if (fNumber)
			pStr->wWeight = pStr->wWeight / 256;

		//pStr->wTermWeight = (WORD)(pStr->wWeight * wWeightT / 65535L);

		dwMaxWeight = max(dwMaxWeight, pStr->wWeight);
		dwSum += pStr->wWeight;
	}

	// now sort 'em
	for (pStr = pStrHead; pStr;)
	{
		if (NULL == (pStrNext = pStr->pNext))
			break;

		if (pStrNext->wWeight <= pStr->wWeight)
		{
			pStr = pStr->pNext;
			continue;
		}

		// find element in already-sorted section
		for (pT = pStrHead, pTPrev = NULL; pT; pTPrev = pT, pT = pT->pNext)
		{
			if (pT->wWeight <= pStrNext->wWeight)
			{
				pStr->pNext = pStrNext->pNext;
				pStrNext->pNext = pT;

				if (pTPrev)
					pTPrev->pNext = pStrNext;
				else
					pStrHead = pStrNext;

				break;
			}
		}
	}

	dwT = 0;
	for (pStr = pStrHead; pStr; pStr = pStr->pNext)
	{
		dwT += pStr->wWeight;
		
		if (dwSum > dwT)
			pStr->wWeightRemain = AddWeights(0, (WORD)((dwSum - dwT) * 65535.0 / dwSum));	
		else
			pStr->wWeightRemain = 1;
	}

	lpQueryTree->lpStrList = pStrHead;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\stem.c ===
/*************************************************************************
*                                                                        *
*  STEM.C                                                                *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   This module contains the functions to strip off the suffix of a word *
*   It is based on the research paper of  Dr. Porter, pulished in        *
*             An algorithm for suffix stripping                          *
*          Program, Vol.14, no.3,pp 130-137, July 1980                   *
*                                                                        *
*  Description:                                                          *
*                                                                        *
*   The full description of the algorithm can be found in that document  *
*   Basically, the algorithm consists of:                                *
*      - Matching the suffix from a table of suffixes                    *
*      - Applies the rule that comes with the suffix                     *
*      - If the rule matches, then change the suffix to the new one      *
*                                                                        *
*  Comments:                                                             *
*                                                                        *
*     1/ There are some misconceptions about stripping the suffix        *
*     People are thinking in term of super-smart algorithm that can      *
*     strip a word to its stem. The fact is that it is not necessarily   *
*     true. For example, DIED is strippe to DI, but not DIE.             *
*                                                                        *
*     2/ The current code is SLOW, but it easy to understand in term     *
*     of implementation, since it is straigthforward from the algorithm  *
*     description. The impact on runtime is nothing. On compiled time    *
*     stemming 5,000,000 words will take less than 1 hour, which is      *
*     acceptable, since a project that large requires 1-2 days to        *
*     compile.                                                           *
*                                                                        *
*     To improve the speed (up to 2 times), we can scan the suffix       *
*     if one letter doesn't match we can jump pass all stem that have    *
*     this letter                                                        *
*   WARNING: Tab setting is 4 for this file                              *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
**************************************************************************/
#include <mvopsys.h>
#include <memory.h>
#include <mvsearch.h>
#include "common.h"


#define VOWEL       0
#define CONSONANT   1
#define MIXED       2

#define	MIN_LENGTH_FOR_STEM	3

/* Rule table structure */

typedef struct RULE
{
    LPB szInitSuffix;           // Initial suffix
    LPB szNewSuffix;            // New suffix
    LPB szCondition;            // Stemming condition
    short NextTable;            // Next table to jump to
} RULE, FAR *LPRULE;

/* The conventional letter  used for the stemming condition are:
 *
 *  '1':    Measure == 1
 *  '2':    Measure > 1
 *  'd':    Double consonant at the end (*d in the document)
 *  'o':    Form cvc , and 2nd c is not W, X or Y (*o in the document)
 *  'p':    Measure > 0
 *  's':    Remove the last consonant (used with 'd')
 *  'v':    Word contains vowels (*v* in the document)
 *  '*':    Terminated with the next letter (*S in the document)
 *  '&':    AND operation
 *  '|':    OR operation
 *  '!':    NOT operation
 * The rule operation is based on a postfix notation, so "m=1 and *o*" is 
 * described as "1o&"
 */

RULE RuleTab0[] =
{
    "\4sses",       "\2ss",     NULL,   1,
    "\3ies",        "\1i",      NULL,   1,
    "\2ss",         "\2ss",     NULL,   1,
    "\1s",          "\0",       NULL,   1,
    NULL,           NULL,       NULL,   1,
};

RULE RuleTab1[] =
{
    "\3eed",        "\2ee",     "p",    3,
    "\2ed",         "\0",       "v",    2,
    "\3ing",        "\0",       "v",    2,
    NULL,           NULL,       NULL,   3,
};

RULE RuleTab2[] =
{
    "\2at",         "\3ate",    NULL,   3,
    "\2bl",         "\3ble",    NULL,   3,
    "\2iz",         "\3ize",    NULL,   3,

    /* The following szNewSuffix has a negative \377
     * (-1) length. It is to be used to reduce a
     * double consonant ending to single consonant
     */

    "\0",           "\377\0",   "*l*s|*z|!d&s", 3,
    "\0",           "\1e",      "1o&",  3,
    NULL,           NULL,       NULL,   3,
};

RULE RuleTab3[] =
{
    "\1y",          "\1i",      "v",    4,
    NULL,           NULL,       NULL,   4,
};

RULE RuleTab4[] =
{
    "\7ational",    "\3ate",    "p",    5,
    "\6tional",     "\4tion",   "p",    5,
    "\4enci",       "\4ence",   "p",    5,
    "\4anci",       "\4ance",   "p",    5,
    "\4izer",       "\3ize",    "p",    5,
    "\4abli",       "\4able",   "p",    5,
    "\4alli",       "\2al",     "p",    5,
    "\5entli",      "\3ent",    "p",    5,
    "\3eli",        "\1e",      "p",    5,
    "\5ousli",      "\3ous",    "p",    5,
    "\7ization",    "\3ize",    "p",    5,
    "\5ation",      "\3ate",    "p",    5,
    "\4ator",       "\3ate",    "p",    5,
    "\5alism",      "\2al",     "p",    5,
    "\7iveness",    "\3ive",    "p",    5,
    "\7fulness",    "\3ful",    "p",    5,
    "\7ousness",    "\3ous",    "p",    5,
    "\5aliti",      "\2al",     "p",    5,
    "\5iviti",      "\3ive",    "p",    5,
    "\6biliti",     "\3ble",    "p",    5,
    NULL,           NULL,       NULL,   5,
};

RULE RuleTab5[] =
{
    "\5icate",      "\2ic",     "p",    6,
    "\5ative",      "\0",       "p",    6,
    "\5alize",      "\2al",     "p",    6,
    "\5iciti",      "\2ic",     "p",    6,
    "\4ical",       "\2ic",     "p",    6,
    "\3ful",        "\0",       "p",    6,
    "\4ness",       "\0",       "p",    6,
    NULL,           NULL,       NULL,   6,
};

RULE RuleTab6[] =
{
    "\2al",         "\0",       "2",    7,
    "\4ance",       "\0",       "2",    7,
    "\4ence",       "\0",       "2",    7,
    "\2er",         "\0",       "p",    7,
    "\2ic",         "\0",       "2",    7,
    "\4able",       "\0",       "2",    7,
    "\4ible",       "\0",       "2",    7,
    "\3ant",        "\0",       "2",    7,
    "\5ement",      "\0",       "2",    7,
    "\4ment",       "\0",       "2",    7,
    "\3ent",        "\0",       "2",    7,
    "\3ion",        "\0",       "2*s*t|&",      7,
    "\2ou",         "\0",       "2",    7,
    "\3ism",        "\0",       "2",    7,
    "\3ate",        "\0",       "2",    7,
    "\3iti",        "\0",       "2",    7,
    "\3ous",        "\0",       "2",    7,
    "\3ive",        "\0",       "2",    7,
    "\3ize",        "\0",       "2",    7,
    NULL,           NULL,       NULL,   7,
};


RULE RuleTab7[] =
{
    "\1e",          "\0",       "2",    8,
    "\1e",          "\0",       "1o!&", 8,
    NULL,           NULL,       NULL,   8,
};

RULE RuleTab8[] =
{
    "\2ll",         "\1l",      "2",    9,
    "\0",           "\377\0",   "2*l&d&s",  9,
    NULL,           NULL,       NULL,   9,
};

char CharTypeTab[] =
{
    VOWEL,      //a
    CONSONANT,  //b
    CONSONANT,  //c
    CONSONANT,  //d
    VOWEL,      //e
    CONSONANT,  //f
    CONSONANT,  //g
    CONSONANT,  //h
    VOWEL,      //i
    CONSONANT,  //j
    CONSONANT,  //k
    CONSONANT,  //l
    CONSONANT,  //m
    CONSONANT,  //n
    VOWEL,      //o
    CONSONANT,  //p
    CONSONANT,  //q
    CONSONANT,  //r
    CONSONANT,  //s
    CONSONANT,  //t
    VOWEL,      //u
    CONSONANT,  //v
    CONSONANT,  //w
    CONSONANT,  //x
    MIXED,      //y, consonant, but may be vowel if after consonant
    CONSONANT,  //z
};

LPRULE RuleTables[] =
{
    RuleTab0,
    RuleTab1,
    RuleTab2,
    RuleTab3,
    RuleTab4,
    RuleTab5,
    RuleTab6,
    RuleTab7,
    RuleTab8,
    NULL,
};

/*************************************************************************
 *
 *                    INTERNAL PRIVATE FUNCTIONS
 *  All of them should be declared near
 *************************************************************************/
int PRIVATE PASCAL NEAR MeasureCalc (LPB, int);
int PRIVATE PASCAL NEAR ConditionMet (LPB, LPB, LPB, int);
int PRIVATE PASCAL NEAR SuffixMatch (LPB lpbWord, LPB lpSuffix);
HRESULT PRIVATE PASCAL NEAR MarkType (LPB, LPB, int);


/*************************************************************************
 *
 *  @doc    API INDEX RETRIEVAL
 *
 *  @func   HRESULT PASCAL FAR | FStem |
 *      This function will strip the suffix from a word, ie, "stem" it
 *
 *  @parm   LPB | lpbStemWord |
 *      Buffer to contain the stemmed word
 *
 *  @parm   LPB | lpbWord |
 *      Word to be stemmed
 *
 *  @rdesc  S_OK if succeeded, or E_INVALIDARG if the null argument is
 *      passed
 *
 *  @comm   The word passed must have all the letters in lower case for
 *      The function to work with. WARNING: There is no checking about
 *      case, so thing can go wrong if the word contains upper case letter
 *      or non alphabetic letter.
 *
 *************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API FStem (LPB lpbStemWord, LPB lpbWord)
{
    register int wLength;   // Length of the word
    register int i;         // Scratch variable
    LPRULE lpRuleTab;       // Pointer to rule table
    LPRULE lpRule;          // Pointer to rule
    int wLengthSaved;
    int wNewSuffixLength;   // This must be signed!
    int wInitSuffixLength;
    char lpbWordType [CB_MAX_WORD_LEN];
    LPB szInitSuffix;
    LPB szNewSuffix;
    int TableIndex;         // For debugging purpose only
    int RuleIndex;          // For debugging purpose only
    LPB lpbTmp;
    
    if (lpbWord == NULL)
        return E_INVALIDARG;
    
    wLength = (*(LPW)lpbWordType = *((LPW)lpbWord));
    if (wLength >= CB_MAX_WORD_LEN)
        return(E_WORDTOOLONG);
        

    /* Copy the word over */
    MEMCPY (lpbStemWord, lpbWord, wLength + 2);

    /* Don't do any stemming for words <= 3 bytes */
    if (wLength <= MIN_LENGTH_FOR_STEM)
        return S_OK;

    /* Mark the type of each letter to be consonant or vowel */
    if (MarkType (lpbStemWord+2, lpbWordType+2, wLength) != S_OK)
    {
        /* We got some non alphabetic characters. Just return */
        return S_OK;
    }

        
    /* Traverse all the tables and check for stemming conditions */

    for (TableIndex = 0, lpRuleTab = RuleTables[0]; lpRuleTab;)
    {

        /* Check for each rule */

        for (RuleIndex = 0, lpRule = lpRuleTab;
            szInitSuffix = lpRule->szInitSuffix; lpRule++, RuleIndex++)
        {

            szNewSuffix = lpRule->szNewSuffix;

            /* The casting is needed to make wNewSuffixLength signed */
            wNewSuffixLength = (char)*szNewSuffix++;

            wInitSuffixLength = (char)*szInitSuffix++;

            /* Check for condition match */

            if (wLength >= wInitSuffixLength)
            {
                
                lpbTmp = lpbStemWord + wLength + 2 - wInitSuffixLength;
                /* Compare the suffixes */

                for (i = wInitSuffixLength;
                    i > 0 && (*lpbTmp == *szInitSuffix);
                    i--, lpbTmp++, szInitSuffix++);

                /* Restore szInitSuffix */
                szInitSuffix = lpRule->szInitSuffix;

                if (i != 0) // String comparison fails
                    continue;

                /* Save the word length */
                wLengthSaved = wLength;

                /* Update word length since we don't include the suffix
                 * length in our computation
                 */
                wLength -= wInitSuffixLength;


                /* Now check the stemming condition */

                if (ConditionMet (lpbStemWord, lpbWordType,
                    lpRule->szCondition, wLength))
                {

                    /* Rule applies, change to the new suffix */

                    if (wNewSuffixLength > 0)
                    {

                        MEMCPY (&lpbStemWord[wLength+2], szNewSuffix,
                            wNewSuffixLength);

                        /* Update the word type */

                        MarkType (szNewSuffix,
                            lpbWordType + wLength + 2, wNewSuffixLength);
                    }

                    /* Update the word length
                     * The check for wLength is necessary since we don't
                     * want to strip evething
                     */

                    if (wLength + wNewSuffixLength > 0)
                        *(LPW)lpbStemWord = (wLength += wNewSuffixLength);

					if (wLength <= MIN_LENGTH_FOR_STEM)
						goto Done;

                    break;
                }
                else
                {

                    /* Rule doesn't apply, Restore the word length */
                    wLength = wLengthSaved;
                }
            }
        }

        /* Go to the next table */
        lpRuleTab = RuleTables [TableIndex = lpRule->NextTable];
    }

	Done:
    lpbStemWord[*((LPW)lpbStemWord)+2] = 0;
    return S_OK;
}

/*************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   int PASCAL NEAR | MeasureCalc |
 *      Calculate the measure of a word. The measure is defined as
 *      the pair (VC), where V is the vowels, and C consonants. A word
 *      is described as [C](VC)m[V], where the first C and the last V are
 *      optional. m is the measure of the word (or part of word without
 *      the suffix). Example:
 *          architect: m = 3 (arch, it, ect)
 *          convention: m = 3 (onv, ent, ion)
 *          lie: m = 0, since the first consonant, and the last vowels
 *              don't count
 *
 *  @parm   LPB | lpbWordType |
 *      Buffer containing word type
 *
 *  @parm   int | wLength |
 *      The length of the word
 *
 *  @rdesc  Return the measure of the word
 *
 *************************************************************************/

int PRIVATE PASCAL NEAR MeasureCalc (LPB lpbWordType, register int wLength)
{
    register int cMeasure;

#if 0
    /* Safety chck
     * IFdef out for speed. This is a internal function
     */
    if (lpbWordType == NULL)
        return 0;
#endif

    /* Initialize the word measure */
    cMeasure = 0;

    /* Skip the beginning consonants */

    for (;wLength > 0 && *lpbWordType == CONSONANT; wLength--, lpbWordType++);

    /* Get the vowel/consonant pairs */
    while (wLength > 0)
    {

        /* Get all the vowels */
        for (; wLength > 0 && *lpbWordType == VOWEL; wLength--, lpbWordType++);

        if (wLength > 0)
        {
            cMeasure ++;

            /* Get all the consonants */
            for (; wLength > 0 && *lpbWordType == CONSONANT;
                wLength--, lpbWordType++);
        }
    }
    return cMeasure;
}

/*************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   int PASCAL NEAR | ConditionMet |
 *      This fuction check the condition to be met by a particular
 *      suffix.
 *
 *  @parm   LPB | lpbWord |
 *      Buffer contains the word to be stemmed> This is a 2-byte prefixed
 *      pascal string
 *
 *  @parm   LPB | lpbWordType |
 *      Buffer containing the type of each letter of the word. This
 *      is a parallel buffer
 *
 *  @parm   LPB | szCondition |
 *      Condtion in postfix form
 *
 *  @parm   int | wLength |
 *      Length of the word
 *
 *  @rdesc  TRUE, if the condition is met, FALSE otherwise
 *
 *************************************************************************/

int PRIVATE PASCAL NEAR ConditionMet (LPB lpbWord, LPB lpbWordType,
    LPB szCondition, int wLength)
{
    int StackIndex;
    int Stack[4];
    int wLengthSaved;
    int LastByte;
    LPB lpbTmp;
    LPB lpbTmpType;

    if (szCondition == NULL)
        return TRUE;

    /* Initialize variables
     * Note: The original codes are written for a 1-byte length preceded
     * string. The new format is 2-byte preceded string. To minimize the
     * change, lpbTmp is used, and points to the 2nd byte
     */

    StackIndex = -1;
    lpbTmp = lpbWord + 1;
    lpbTmpType = lpbWordType + 1;
    LastByte = lpbTmp[wLength];

    while (*szCondition)
    {
        switch (*szCondition)
        {
            case '*':   // *S in the document

                /* Check to see if the stem ends with the next letter */

                Stack[++StackIndex] =
                    (LastByte == *(++szCondition));
                break;

            case 'd':   // *d in the document

                /* Check to see if the stem ends with a double consonant */

                Stack[++StackIndex] = (wLength > 2 &&
                    LastByte == lpbTmp[wLength - 1] &&
                    lpbTmpType[wLength] == CONSONANT);
                break;

            case 's':   // Remove the last consonant
                if (Stack[0])
                {
                    lpbTmp[wLength] = 0;
                    wLength --;
                    *(LPW)lpbWordType = *(LPW)lpbWord = (WORD) wLength;
                }
                break;

            case 'v':   // *v* in the document

                /* Check to see if the word has a vowel */

                wLengthSaved = wLength; /* Save the length */

                for (; wLength &&
                    lpbTmpType[wLength] != VOWEL; wLength--);

                Stack[++StackIndex] = wLength > 0;

                /* Restore the word length */
                wLength = wLengthSaved;
                break;

            case 'o':
                /* *o in the document, ie.
                    - The word ends with the form cvc
                    - The second c is not W, X, Y
					The +2 is for skipping the word length
                 */
                Stack[++StackIndex] = (wLength >= 3) &&
                    (lpbWordType[wLength + 1] == CONSONANT) &&
                    (lpbWordType[wLength] == VOWEL) &&
                    (lpbWordType[wLength - 1] == CONSONANT) &&
                    (LastByte != 'w' && LastByte != 'x' && LastByte != 'y');
                break;

            /* The conditions below test Measure. If they fails, then
             * the whole condition fails. ie. there is no need to test
             * any other conditions. There is no need to save the result
             * on the stack
             */

            case 'p':   // Measure > 0
                if ((Stack[++StackIndex] =
                    MeasureCalc (lpbWordType+2, wLength) > 0) == FALSE)
                    return FALSE;
                break;

            case '2':   // Measure > 1
                if ((Stack[++StackIndex] =
                    MeasureCalc (lpbWordType+2, wLength) > 1) == FALSE)
                    return FALSE;
                break;

            case '1':   // Measure == 1
                if ((Stack[++StackIndex] =
                    MeasureCalc (lpbWordType+2, wLength) == 1) == FALSE)
                    return FALSE;
                break;

            /* The next conditions are operators combination */

            case '|':
                
                /* OR the result of the top 2 stack entries */

                Stack[StackIndex-1] |= Stack[StackIndex];
                StackIndex--;
                break;

            case '&':
                
                /* AND the result of the top 2 stack entries */

                Stack[StackIndex-1] &= Stack[StackIndex];
                StackIndex--;
                break;

            case '!':
                
                /* NOT the result of the top stack entry */

                Stack[StackIndex] = !Stack[StackIndex];
                break;

            default:
                return FALSE;
        }
        szCondition++;
    }

    return Stack[0];
}

/*************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT PASCAL NEAR | MarkType |
 *      Marking the type of each letter of the word to be CONSONANT or
 *      VOWEL
 *
 *  @parm   LPB | lpbWord |
 *      Buffer containing the word
 *
 *  @parm   LPB | lpBufType |
 *      Buffer to contain the type of the letters
 *
 *  @parm   int | wLength |
 *      Length of the word
 *
 *************************************************************************/

HRESULT PRIVATE PASCAL NEAR MarkType (LPB lpbWord, LPB lpBufType, int wLength)
{
    for (; wLength > 0; lpBufType++, lpbWord++, wLength--)
    {

        /* Consider wildcard characters to be consonnant */
        if (*lpbWord == '?' || *lpbWord == '*')
        {
            *lpBufType = CONSONANT;
            continue;
        }

        if (*lpbWord < 'a' || *lpbWord > 'z')
            return E_FAIL;

        switch (CharTypeTab [*lpbWord - 'a'])
        {
            case CONSONANT:
                *lpBufType = CONSONANT;
                break;
            case VOWEL:
                *lpBufType = VOWEL;
                break;
            case MIXED:
                if (*(lpBufType - 1) == CONSONANT)
                    *lpBufType = VOWEL;
                else
                    *lpBufType = CONSONANT;
                break;
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\stopwd.c ===
/*************************************************************************
*                                                                        *
*  STOP.C                                                                *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   Stop list indexing and retrieval                                     *
*                                                                        *
**************************************************************************
*                                                                        *
*  Written By   : Binh Nguyen                                            *
*  Current Owner: Binh Nguyen                                            *
*                                                                        *
*************************************************************************/
#include <mvopsys.h>
#include <orkin.h>
#include <mem.h>
#include <memory.h>
#include <io.h>
#include <mvsearch.h>
#include "common.h"

#ifdef _DEBUG
static BYTE NEAR s_aszModule[] = __FILE__;	/* Used by error return functions.*/
#endif

#define cbSTOP_BUF  ((CB)512)   // Number of bytes read at a time
                                //  from the stop-word file.
/*************************************************************************
 *
 *                       API FUNCTIONS
 *  Those functions should be exported in a .DEF file
 *************************************************************************/
PUBLIC  HRESULT EXPORT_API FAR PASCAL MVStopListAddWord(LPSIPB, LST);
PUBLIC  HRESULT EXPORT_API FAR PASCAL MVStopListIndexLoad (HFPB, LPSIPB, LSZ);
PUBLIC  LPSIPB EXPORT_API FAR PASCAL MVStopListInitiate(WORD, PHRESULT);
PUBLIC  void EXPORT_API FAR PASCAL MVStopListDispose(LPSIPB);

PUBLIC  HRESULT EXPORT_API FAR PASCAL MVStopListLoad(HFPB, LPSIPB, LSZ,
													BREAKER_FUNC, LPV);
PUBLIC  HRESULT EXPORT_API PASCAL FAR MVStopFileBuild (HFPB, LPSIPB, LSZ);
PUBLIC LPCHAIN EXPORT_API FAR PASCAL MVStopListFind(_LPSIPB lpsipb, LST lstWord);

/*************************************************************************
 *
 *                    INTERNAL PRIVATE FUNCTIONS
 *  All of them should be declared near
 *************************************************************************/

PRIVATE WORD NEAR PASCAL GetHashKey (WORD, LST);

/*************************************************************************
 *
 *                    INTERNAL PUBLIC FUNCTIONS
 *  All of them should be declared far, and included in some include file
 *************************************************************************/

PUBLIC HRESULT FAR PASCAL FStopCallback(LST, LST, LFO, LPV);

/*************************************************************************
 *  @doc    API RETRIEVAL
 *
 *  @func LPSIPB FAR PASCAL | MVStopListInitiate |
 *      Create and initiate a stop-word information structure
 *
 *  @parm PHRESULT | phr |
 *      Pointer to error buffer.
 *
 *	@parm WORD | wTabSize |
 *      Table size in DWORD. The process of stop word checking will
 *      be faster with larger values of dwTabSize.
 *
 *  @rdesc  the pointer to the stop-list structure if succeeded,
 *      NULL if failed. The error buffer will contain descriptions about
 *      the cause of the failure
 *************************************************************************/

PUBLIC  LPSIPB EXPORT_API FAR PASCAL MVStopListInitiate(WORD wTabSize,
    PHRESULT phr)
{
    _LPSIPB lpsipb;

    if (wTabSize < HASH_SIZE)    
        wTabSize = HASH_SIZE;
        
    /* Allocate a StopInfo structure */
    if ((lpsipb = (_LPSIPB)GLOBALLOCKEDSTRUCTMEMALLOC(sizeof(SIPB) +
        wTabSize * sizeof(LPB))) == NULL)
    {
exit00:
        SetErrCode(phr, E_OUTOFMEMORY);
        return NULL;
    }

    lpsipb->HashTab = (LPCHAIN FAR *)((LPB)lpsipb + sizeof(SIPB));
    
    /* Allocate a word block buffer */
    if ((lpsipb->lpBlkMgr = BlockInitiate (WORDBUF_SIZE, 0, 0, 0)) == NULL)
    {
        GlobalLockedStructMemFree((LPV)lpsipb);
        goto exit00;
    }

    lpsipb->wTabSize = wTabSize;      /* Size of hash table */
    lpsipb->lpfnStopListLookup = MVStopListLookup;
    return (LPSIPB)lpsipb;
}

/*************************************************************************
 *  @doc    API RETRIEVAL
 *
 *  @func HRESULT FAR PASCAL | MVStopListAddWord |
 *      Add a word to a stop list
 *
 *  @parm LPSIPB | lpsipb |
 *      Pointer to stop-word information structure
 *
 *  @parm LST | lstWord |
 *      Pointer to 2-byte length preceded Pascal word to be added
 *      into the stop-word list
 *
 *  @rdesc  S_OK if succeeded
 *************************************************************************/

PUBLIC HRESULT EXPORT_API FAR PASCAL MVStopListAddWord(_LPSIPB lpsipb, LST lstWord)
{
    WORD    wHash;
    LPCHAIN lpChain;
    WORD    wByteUsed;

    // Sanity check
    if (lpsipb == NULL || lstWord == NULL)    
        return(E_INVALIDARG);
        
    /* Look for the word. If it is already there then just
     * return S_OK, don't add it into the list
     */
    if (lpChain = MVStopListFind (lpsipb, lstWord))
    {
        // Don't add if already there.
        lpChain->dwCount++;
        return S_OK;
    }

    wByteUsed = *(LPUW)lstWord + 2;
    
#ifndef _32BIT
    if (lpsipb->cbTextUsed + wByteUsed > MAX_STOPWORD_BUFSIZE) {
        /* There are too many stop words */
        return ERR_TOOMANYSTOPS;
    }
#endif

    lpsipb->cbTextUsed += wByteUsed ;

    /* Copy the word into the word buffer block */
    if ((lpChain = (LPCHAIN)BlockCopy (lpsipb->lpBlkMgr, lstWord, wByteUsed,
        sizeof(CHAIN) - 1)) == NULL)
        return E_OUTOFMEMORY;

	lpChain->dwCount = 0;

    /* Compute hash key */
    wHash = GetHashKey(lpsipb->wTabSize, lstWord);

    /* Add the word to the hash table  */
    CH_NEXT(lpChain) = lpsipb->HashTab[wHash];  
    lpsipb->HashTab[wHash] = lpChain;
 
    return S_OK;             // Function worked.
}

/*************************************************************************
 *  @doc    API RETRIEVAL
 *
 *  @func void FAR PASCAL | MVStopListDispose |
 *      Frees memory associated with a stop list.
 *
 *  @parm LPSIPB | lpsipb |
 *      Pointer to stop-word information structure
 *************************************************************************/

PUBLIC void EXPORT_API FAR PASCAL MVStopListDispose (_LPSIPB lpsipb)
{
    if (lpsipb == NULL)
        return;

    /* Free the word buffer */
    BlockFree(lpsipb->lpBlkMgr);

    /* Free the stop info structure */
    GlobalLockedStructMemFree((LPV)lpsipb);
}


/*************************************************************************
 *  @doc    API RETRIEVAL
 *
 *  @func HRESULT FAR PASCAL | MVStopListIndexLoad |
 *      Read a stop-word list stored in the subfile/dos file.
 *
 *  @parm HFPB | hfpb |
 *      Handle to input file.  Can be mvfs subfile or separate dos file.
 *  
 *  @parm LPSIPB | lpsipb |
 *      Pointer to stop-word information structure
 *  
 *  @parm LPIDX | lpidx |
 *      Pointer to index structure
 *  
 *  @parm LSZ | lszWordBreaker |
 *      Word breaker to be used
 *  
 *  @rdesc  S_OK if succeeded, other errors if failed.
 *************************************************************************/
/*
 The strings are stored in the file in a sequence of pascal strings
 */

PUBLIC HRESULT EXPORT_API FAR PASCAL MVStopListIndexLoad (HFPB hfpbSysFile,
    _LPSIPB lpsipb, LSZ lszStopFile)
{
    BYTE    argbInBuf[CB_STOP_BUF];
    FILEOFFSET lfo;
	FILEOFFSET foStart;
    HFPB    hfpbSubFile;
	BOOL	fOpenedFile;
    HRESULT     fRet = S_OK;
    WORD    cbRead;
    int     fLast;
    LPSTOP  lpStopHdr;
    LPB     lpWord;
    WORD    wOffsetInBuf;
    WORD    wLen;
    ERRB    errb;
    
    /* Sanity check */
    if (lpsipb == NULL)
        return SetErrCode (NULL, E_INVALIDARG);

    /* Open the subfile */
    if ((fOpenedFile =
			FsTypeFromHfpb(hfpbSubFile = hfpbSysFile) != FS_SUBFILE) &&
		(hfpbSubFile = FileOpen
			(hfpbSysFile, lszStopFile, hfpbSysFile ? FS_SUBFILE : REGULAR_FILE,
			READ, &errb)) == NULL) 
    {
        return errb;
    }

	// If we didn't open the file, we need to find out where the file seek
	// pointer is initially so that we only seek relative to that starting
	// position (i.e. the caller owns the part of the file that comes before).
	foStart = (fOpenedFile ? MakeFo(0,0) :
				FileSeek (hfpbSubFile, MakeFo (0, 0), wFSSeekCur, &fRet));

    /* Read and check the file validity */
    if (FAILED(fRet) ||
		(cbRead = (WORD)FileSeekRead
			(hfpbSubFile, (LPV)(lpStopHdr = (LPSTOP)argbInBuf),
			FoAddFo(foStart, MakeFo(0, 0)), sizeof(STOP_HDR), &fRet))
												!= sizeof(STOP_HDR)) 
    {
exit01:
		// Close file only if we were the one's who opened it.
		if (fOpenedFile)     
			(void)FileClose(hfpbSubFile);       // Return value not checked
												// because the file is open
												//  for read-only.
        return fRet;
    } 

    /* MAC codes. They will be eliminated through optimization */
    
    lpStopHdr->FileStamp = SWAPWORD(lpStopHdr->FileStamp);
    lpStopHdr->version = SWAPWORD(lpStopHdr->version);
    lpStopHdr->dwFileSize = SWAPLONG(lpStopHdr->dwFileSize);


    if (lpStopHdr->FileStamp != STOP_STAMP ||
        lpStopHdr->version != VERCURRENT)
    {
        fRet = SetErrCode(&errb, E_BADVERSION);
        goto exit01;
    }

    /* Start at the beginning of the buffer */
    wOffsetInBuf = 0;

    for (lfo = FoAddFo(foStart, MakeFo(STOP_HDR_SIZE, 0));;)
    {
		LPB		lpbCur;
		WORD	cbReadOurs = 0;

        if ((cbRead = (WORD)FileSeekRead(hfpbSubFile,
            lpbCur = ((LPB)argbInBuf + wOffsetInBuf), lfo,
            CB_STOP_BUF - wOffsetInBuf, &errb)) == cbIO_ERROR) 
        {
            SetErrCode(&errb, fRet = E_FILEREAD);
            goto exit01;
        } 

        lfo = FoAddDw(lfo, (DWORD)cbRead);

		while (cbRead - cbReadOurs++ >= sizeof(WORD))
		{
			if (*((WORD UNALIGNED * UNALIGNED)lpbCur) == 0)
			{
				FILEOFFSET	foCur;

				// Get our current seek position.
				foCur = FileSeek (hfpbSubFile, MakeFo (0, 0), wFSSeekCur, &fRet);

				// We already advanced cbReadOurs by one in the loop
				// condition; advance it by one more to account for
				// the second byte of the NULL word.  Then we move
				// the seek pointer back by the difference so that we
				// don't leave it past the end of our data.
				FileSeek (hfpbSubFile, 
							FoSubFo(foCur, MakeFo(cbRead - ++cbReadOurs, 0)),
															wFSSeekSet, &fRet);
				ITASSERT(SUCCEEDED(fRet));
				cbRead = cbReadOurs;
				fLast = TRUE;
			}
			else
				lpbCur++;
		}

        cbRead += wOffsetInBuf; // Catch what's left from previous scan
        wOffsetInBuf = 0;

        /* Add the word into the stop word list */
        for (lpWord = argbInBuf; cbRead > 0;) 
        {

            /* If the whole word has been read in, just add it to the
            stop list, else we have to "reconstruct" it
            */
            // erinfox: we have to byte-swap on Mac
            *(WORD UNALIGNED * UNALIGNED)lpWord = SWAPWORD(*(WORD UNALIGNED * UNALIGNED)lpWord);

            wLen = *(LPUW)(lpWord) + 2;
            if (wLen <= cbRead)
            {
                
                /* Everything fits */
                if ((fRet = MVStopListAddWord(lpsipb, lpWord)) != S_OK)
                    goto exit01;
                cbRead -= wLen;
                lpWord += wLen; /* Move to next word */
            }
            else
            {
                /* Copy the word to the beginning of the buffer */
                MEMCPY(argbInBuf, lpWord, cbRead);
                wOffsetInBuf = cbRead;
                break;
            }
        }

        if (fLast)
            break;
    }
    fRet = S_OK; // Succeeded
    goto exit01;
}

/*************************************************************************
 *  @doc API INDEX RETRIEVAL
 *
 *  @func HRESULT FAR PASCAL | MVStopListLoad |
 *      Read a stop-word list from an external file. The file must have
 *      only one stop word per line, or else there is potential loss
 *      of stop words.
 *
 *  @parm LPSIPB | lpsipb |
 *      Pointer to stop-word information structure
 *
 *  @parm LSZ | lszStopFile |
 *      Stop word filename. This is a simple ASCII text file
 *
 *  @parm BREAKER_FUNC | lpfnBreakFunc |
 *      Word breaker to be used
 *
 *  @parm PHRESULT | phr |
 *      Pointer to error buffer.
 *
 *  @rdesc  S_OK if succeeded, other errors failed. 
 *************************************************************************/
PUBLIC HRESULT EXPORT_API FAR PASCAL MVStopListLoad(HFPB hfpbIn, _LPSIPB lpsipb,
    LSZ lszStopFile, BREAKER_FUNC lpfnBreakFunc,
    LPCHARTAB lpCharTab)
{
    BYTE    argbInBuf[cbSTOP_BUF];  // IO buffer
    HFPB    hfpb;					// File handle
	BOOL	fOpenedFile;
    _LPIBI  lpibi;                  // Pointer to internal breaker info
    HANDLE  hbi;                    // Handle to internal brekaer info
    HRESULT     fRet;               // Returned value
    BRK_PARMS brkParms;             // Breaker parameters structure
    LPB     lpStart;                // Beginning of strings to be parsed
    LPB     lpEnd;                  // End of strings to be parsed
    WORD    wStrLength;             // Bytes in string
    CB      cbTobeRead;             // Bytes to be read
    CB      cbRead;                 // Bytes actually read
    int     fLast;                  // TRUE if this is the last read
    int     fGetWord;               // TRUE if we get a whole word

    /* Sanity check */
    if (lpsipb == NULL || (lszStopFile == NULL && hfpbIn == NULL)
			|| lpfnBreakFunc == NULL)
        return E_INVALIDARG;

	if ((fOpenedFile = FsTypeFromHfpb(hfpb = hfpbIn) != FS_SUBFILE) &&
		(hfpb = (HANDLE)FileOpen
			(hfpbIn, lszStopFile, hfpbIn ? FS_SUBFILE : REGULAR_FILE,
			READ, &fRet)) == 0)
    {
        return (fRet);
    }

    /*  Allocate a breaker info block */

    if ((hbi = _GLOBALALLOC(DLLGMEM_ZEROINIT, (LCB)sizeof(IBI))) == NULL)
    {
        return E_OUTOFMEMORY;
    }
    lpibi = (_LPIBI)_GLOBALLOCK(hbi);

    /* Initialize variables */
    brkParms.lcbBufOffset = 0L;
    brkParms.lpInternalBreakInfo = lpibi;
    brkParms.lpvUser = lpsipb;
    brkParms.lpfnOutWord = (FWORDCB)FStopCallback;
    brkParms.lpStopInfoBlock = NULL;
    brkParms.lpCharTab = lpCharTab;

    cbTobeRead = cbSTOP_BUF;            // Read in a buffer whole
    lpStart = lpEnd = (LPB)argbInBuf;   // Start & End of string
    fGetWord = FALSE;                   // We didn't get any word yet
    wStrLength = 0;

    /* The idea is to break the file into sequences of lines, and pass
     * each line to the word breaker. The assumption made is that we
     * should only have one word per line, since various type breakers
     * can only handle one word a type.
     */

    for (;;)
    {
		cbRead = (WORD)FileRead(hfpb, lpEnd, cbTobeRead, &fRet);
        if (FAILED(fRet))
        {
exit01:
            /* Free breaker info block */
            _GLOBALUNLOCK(hbi);
            _GLOBALFREE(hbi);

            /* Close the file */
			if (fOpenedFile)
				FileClose(hfpb);
            return fRet;
        }
        else
            fLast = (cbRead != cbTobeRead);

        lpEnd = lpStart;
        cbRead += wStrLength;   // Get what left in buffer
        wStrLength = 0;

        while (cbRead != (CB)-1)
        {
            /* Break the buffer into lines */

            if (*lpEnd == '\r' || *lpEnd == '\n' || !cbRead)
            {
                if (wStrLength)
                {

                    /* Process the word we got */
                    brkParms.lpbBuf = lpStart;
                    brkParms.cbBufCount = wStrLength;

                    if ((fRet = (*lpfnBreakFunc)((LPBRK_PARMS)&brkParms))
                        != S_OK)
                        goto exit01;

                    /* Flush the breaker buffer */
                    brkParms.lpbBuf = NULL;
                    brkParms.cbBufCount = 0;
                    if ((fRet = (*lpfnBreakFunc)((LPBRK_PARMS)&brkParms))
                        != S_OK)
                        goto exit01;

                    wStrLength = 0;
                }
            }
            else
            {
                /* Update the pointer to the new word */
                if (wStrLength == 0)
                    lpStart = lpEnd;
                wStrLength++;   // Increase string's length
            }

            cbRead--;
            lpEnd++;
        }


        if (fLast)
            break;

        /* Now copy the partial string to the beginning of the buffer */
        MEMCPY(argbInBuf, lpStart, wStrLength);
        lpEnd = (lpStart = argbInBuf) + wStrLength;
        cbTobeRead = cbSTOP_BUF - wStrLength;   // Read in a buffer whole
    }

    if (wStrLength)
    {
        /* Flush the breaker buffer */
        brkParms.lpbBuf = NULL;
        brkParms.cbBufCount = 0;
        if ((fRet = (*lpfnBreakFunc)((LPBRK_PARMS)&brkParms)) != S_OK)
            goto exit01;
    }
    fRet = S_OK; // Succeeded
    goto exit01;
}


/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   WORD NEAR PASCAL | GetHashKey |
 *      Compute the hash key of a string. This key is used for indexing
 *      into the stop word hash table
 *  
 *  @parm   LST | lstWord |
 *      Pointer to a 2-byte length preceded Pascal-type string
 *
 *  @rdesc
 *      Return the index into the stop words hash table
 *************************************************************************/

PRIVATE WORD NEAR PASCAL GetHashKey (WORD hashSize, LST lstWord)
{
    register unsigned int wHash;
    register unsigned int nLength;

    wHash = 0;
    nLength = *(LPUW)lstWord;
    lstWord += sizeof(WORD);
    for (; nLength; nLength--)
    {
        wHash = (wHash << 1) | (wHash >> 15);
        wHash ^= *lstWord++;
    }
    wHash %= hashSize;
    return ((WORD)wHash);
}

/*************************************************************************
 *  @doc    API RETRIEVAL INDEX
 *
 *  @func   LPCHAIN FAR PASCAL | MVStopListFind |
 *      This looks for a word (lstWord) in a stop-word (lpsipb) 
 *
 *  @parm LPSIPB | lpsipb |
 *      Pointer to stop-word list structure
 *
 *  @parm LST | lstWord |
 *      Pointer to string to be looked for
 *
 *  @rdesc  Pointer to the node if found, NULL otherwise
 *************************************************************************/

PUBLIC LPCHAIN EXPORT_API FAR PASCAL MVStopListFind(_LPSIPB lpsipb, LST lstWord)
{
    WORD    wHash;      // Hash key
    LPCHAIN lpChain;    // Pointer to the word chain

    // Sanity check
    if (lpsipb == NULL || lstWord == NULL)    
        return(NULL);

    /* Compute hash key */
    wHash = GetHashKey(lpsipb->wTabSize, lstWord);
    lpChain = lpsipb->HashTab[wHash];
 
    while (lpChain)
    {
        if (!StringDiff2 (&CH_WORD(lpChain), lstWord))
            return (lpChain);
        lpChain = CH_NEXT(lpChain);
    }
    return (NULL);
}

 /*************************************************************************
 *  @doc    API RETRIEVAL INDEX
 *
 *  @func   HRESULT FAR PASCAL | MVStopListLookup |
 *      This looks for a word (lstWord) in a stop-word (lpsipb) 
 *
 *  @parm LPSIPB | lpsipb |
 *      Pointer to stop-word list structure
 *
 *  @parm LST | lstWord |
 *      Pointer to string to be looked for
 *
 *  @rdesc  S_OK if found, E_FAIL if not, or other errors
 *************************************************************************/

PUBLIC HRESULT EXPORT_API FAR PASCAL MVStopListLookup(_LPSIPB lpsipb, LST lstWord)
{
    WORD    wHash;      // Hash key
    LPCHAIN lpChain;        // Pointer to the word chain


    // Sanity check
    if (lpsipb == NULL || lstWord == NULL)    
        return(E_INVALIDARG);
        
    /* Compute hash key */
    wHash = GetHashKey(lpsipb->wTabSize, lstWord);
    lpChain = lpsipb->HashTab[wHash];

    while (lpChain)
    {
        if (!StringDiff2 (&CH_WORD(lpChain), lstWord))
            return (S_OK);
        lpChain = CH_NEXT(lpChain);
    }
    return (E_FAIL);
}

/*************************************************************************
 *  @doc    API INDEX
 *
 *  @func HRESULT PASCAL FAR | MVStopFileBuild |
 *      Incorporate the stop word list into the system file
 *
 *  @parm   HFPB | hpfbSysFile |
 *      If non-zero, handle to an opened system file.
 *
 *  @parm LPSIPB | lpsipb |
 *      Pointer to stop-word information structure
 *
 *  @parm LSZ | lszFilename |
 *      If hpfbSysFile is non-zero, this is the name of the stop's subfile
 *      else this is a regular DOS file
 *
 *  @rdesc S_OK if succeeded, E_FAIL if tehre is nothing to build
 *      or other errors
 *************************************************************************/
PUBLIC HRESULT EXPORT_API PASCAL FAR MVStopFileBuild (HFPB hfpbSysFile,
    _LPSIPB lpsipb, LSZ lszFilename)
{
    HFPB hfpbStop;          // Pointer to final index file info.
    HRESULT  fRet = S_OK;
    STOP_HDR Stop_hdr;
    HFPB hfpb = 0;
	BOOL fCreatedFile;
    BYTE Dummy[STOP_HDR_SIZE]; // Dummy buffer to write 0
    int i;
    LPCHAIN lpChain;
    LST lstWord;
    WORD wLen;
    CB cbByteLeft;
    GHANDLE hBuf;
    LPB lpbBuf;
    LPB lpbStart;
    LPB lpbLimit;
    ERRB errb;
    FILEOFFSET fo;
	FILEOFFSET foStart;

    /* Sanity check */
    if (lpsipb == NULL || (lszFilename == NULL && hfpbSysFile == NULL))
        return E_INVALIDARG;

    if (lpsipb->cbTextUsed == 0)
        return E_FAIL; /* Nothing to build */

    if ((fCreatedFile =
			FsTypeFromHfpb(hfpbStop = hfpbSysFile) != FS_SUBFILE) &&
		(hfpbStop = FileCreate(hfpbSysFile, lszFilename,
			hfpbSysFile ? FS_SUBFILE: REGULAR_FILE, &errb)) == 0)
        return errb;

	// If we didn't open the file, we need to find out where the file seek
	// pointer is initially so that we only seek relative to that starting
	// position (i.e. the caller owns the part of the file that comes before).
	foStart = (fCreatedFile ? MakeFo(0,0) :
				FileSeek (hfpbStop, MakeFo (0, 0), wFSSeekCur, &fRet));

	if (FAILED(fRet))
		goto exit01;

    /* Write out the stop file header */
    Stop_hdr.FileStamp = STOP_STAMP;
    Stop_hdr.version = VERCURRENT;
    Stop_hdr.dwFileSize = lpsipb->cbTextUsed;

    MEMSET(Dummy, 0, STOP_HDR_SIZE);

    /* Write all zeroes to the header area, which is larger than the
	 * STOP_HDR structure.
	 */
    if (FileSeekWrite (hfpbStop, Dummy, FoAddFo(foStart, MakeFo (0, 0)),
        STOP_HDR_SIZE, &errb) != STOP_HDR_SIZE) 
    {
        fRet = errb;
exit01:
		if (fCreatedFile)
	        FileClose (hfpbStop);
        return(fRet);
        
    }

    if (FileSeekWrite (hfpbStop,  &Stop_hdr, FoAddFo(foStart, MakeFo (0, 0)),
        sizeof (STOP_HDR), &errb) != sizeof (STOP_HDR)) 
    {
        fRet = errb;
        goto exit01;
    }


    /* Allocate a buffer to flush the data */
    if ((hBuf = _GLOBALALLOC (DLLGMEM, cbByteLeft = CB_HUGE_BUF)) == NULL)
    {
        SetErrCode (&errb, fRet = E_OUTOFMEMORY);
        goto exit01;
    }

    lpbBuf = lpbStart = (LPB)_GLOBALLOCK(hBuf);
    lpbLimit = lpbStart + CB_HUGE_BUF - CB_MAX_WORD_LEN;

    /* Seek the file to the correct offset */
    fo  = FoAddFo(foStart, MakeFo (STOP_HDR_SIZE, 0));
    
    if (!FoEquals (FileSeek (hfpbStop, fo, 0, &errb),  fo))
    {
        fRet = E_FILESEEK;
exit02:
        _GLOBALUNLOCK(hBuf);
        _GLOBALFREE(hBuf);
        goto exit01;
    }

    /* Write out the buffer */
    for (i = lpsipb->wTabSize - 1; i >= 0; i--)
    {
        for (lpChain = lpsipb->HashTab[i]; lpChain;
            lpChain = CH_NEXT(lpChain))
        {
            lstWord = &CH_WORD (lpChain);
            MEMCPY (lpbBuf, lstWord, wLen = *(WORD FAR *)lstWord + 2);
            lpbBuf += wLen;
            if (lpbBuf >= lpbLimit)
            {
                /* No more room, just flush the buffer */

                FileWrite(hfpbStop, lpbStart, (DWORD)(lpbBuf - lpbStart), &errb);
                if ((fRet = errb) != S_OK)
                    goto exit02;

                lpbBuf = lpbStart;
            }
        }
    }


    /*  Flush the buffer */
    FileWrite (hfpbStop, lpbStart, (DWORD)(lpbBuf - lpbStart), &errb);

    if ((fRet = errb) == S_OK)
	{
		/* Write a trailing 0 word (i.e. a NULL st) to mark
		 * the end of the word list.
		 */
		*((WORD *)lpbStart) = 0;
		FileWrite (hfpbStop, lpbStart, sizeof(WORD), &errb);
		fRet = errb;
	}

    goto exit02;
}

PUBLIC HRESULT FAR PASCAL FStopCallback(
    LST lstRawWord,
    LST lstNormWord,
    LFO lfoWordOffset,
    _LPSIPB lpsipb)
{
    return MVStopListAddWord(lpsipb, lstNormWord);
}


/*************************************************************************
 *  @doc    API RETRIEVAL
 *
 *  @func HRESULT FAR PASCAL | MVStopListEnumWords |
 *      Enumerate the words in a stop list, getting a pointer to each.
 *
 *  @parm LPSIPB | lpsipb |
 *      Pointer to stop-word information structure
 *
 *  @parm LST* | plstWord |
 *      Indirect Pointer to 2-byte length preceded Pascal word that is
 *      the next word identified by *pdwWordInfo and *ppvWordInfo.
 *
 *	@parm LONG* | plWordInfo |
 *		Pointer to information used to determine what the next word is
 *		in the stop word list.  Passing -1 along with NULL for *ppvWordInfo
 *		means start at the beginning.  On exit, this contains an appropriate
 *		value that can be passed in again to get the next word, provided
 *		that no intervening calls have been made to MVStopListAddWord.
 *
 *	@parm LPVOID* | ppvWordInfo |
 *		Indirect pointer to information used to determine what the next word is
 *		in the stop word list.  Passing NULL along with -1 for *plWordInfo
 *		means start at the beginning.  On exit, this contains an appropriate
 *		value that can be passed in again to get the next word, provided
 *		that no intervening calls have been made to MVStopListAddWord.
 *
 *  @rdesc  S_OK if succeeded
 *	@rdesc	E_OUTOFRANGE if there are no more words in the stop list.
 *************************************************************************/
PUBLIC HRESULT EXPORT_API FAR PASCAL MVStopListEnumWords(_LPSIPB lpsipb,
						LST *plstWord, LONG *plWordInfo, LPVOID *ppvWordInfo)
{
	LPCHAIN	lpchain = NULL;
	LONG	iHashChain;

	if (lpsipb == NULL || plstWord == NULL ||
		plWordInfo == NULL || ppvWordInfo == NULL)
		return (SetErrReturn(E_POINTER));

	iHashChain = *plWordInfo;

	// If after the last call to us, we were left sitting on a hash chain
	// element, just advance to the next one (which may be NULL).
	if ((lpchain = (LPCHAIN) *ppvWordInfo) != NULL)
		lpchain = CH_NEXT(lpchain);

	// If we're now sitting on a NULL hash chain (initial condition or we
	// reached the end of a previous chain), we need to find the beginning
	// of the next chain in the hash table.
	while (iHashChain < lpsipb->wTabSize - 1 && lpchain == NULL)
		lpchain = lpsipb->HashTab[++iHashChain];
	
	if (iHashChain >= lpsipb->wTabSize - 1 && lpchain == NULL)
		return (SetErrReturn(E_OUTOFRANGE));

	*plstWord = &CH_WORD(lpchain);
	*ppvWordInfo = (LPVOID)lpchain;
	*plWordInfo = iHashChain;

	return (S_OK);
}


/*************************************************************************
 *  @doc    API RETRIEVAL
 *
 *  @func HRESULT FAR PASCAL | MVStopListFindWordPtr |
 *      Find a word in the stop list and return a pointer to it.
 *
 *  @parm LPSIPB | lpsipb |
 *      Pointer to stop-word information structure
 *
 *  @parm LST | lstWord |
 *      Pointer to a 2-byte length preceded Pascal
 *      string containing the word to find.
 *
 *  @parm LST* | plstWordInList |
 *      On exit, indirect pointer to 2-byte length preceded Pascal
 *      string for the word that was found.
 *
 *  @rdesc  S_OK if succeeded
 *	@rdesc	E_NOTFOUND if the word isn't in the stop list
 *************************************************************************/
PUBLIC HRESULT EXPORT_API FAR PASCAL MVStopListFindWordPtr(_LPSIPB lpsipb,
											LST lstWord, LST *plstWordInList)
{
	HRESULT	hr = S_OK;
	LPCHAIN	lpchain;

	if ((lpchain = MVStopListFind(lpsipb, lstWord)) != NULL)
		*(LST UNALIGNED * UNALIGNED)plstWordInList = &CH_WORD(lpchain);
	else
		hr = E_NOTFOUND;

	return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\util.c ===
/*************************************************************************
*                                                                        *
*  UTIL.C    	                                                         *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   General purpose routines                                             *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Released by Development:     (date)                                   *
*                                                                        *
*************************************************************************/
#include <mvopsys.h>
#include <mem.h>
#include <mvsearch.h>
#include "common.h"

#ifdef _DEBUG
static BYTE NEAR s_aszModule[] = __FILE__;	/* Used by error return functions.*/
#endif


/*************************************************************************
 *
 * 	                  INTERNAL GLOBAL FUNCTIONS
 *	Those functions should be declared FAR to cause less problems with
 *	with inter-segment calls, unless they are explicitly known to be
 *	called from the same segment. Those functions should be declared
 *	in an internal include file
 *************************************************************************/
PUBLIC BOOL PASCAL FAR StringDiff (LPB, LPB);
PUBLIC BOOL PASCAL FAR StringDiff2 (LPB, LPB);
PUBLIC	WORD PASCAL FAR CbByteUnpack(LPDW, LPB);
PUBLIC int PASCAL FAR NCmpS (LPB, LPB);
PUBLIC int PASCAL FAR StrNoCaseCmp (LPB, LPB, WORD);
PUBLIC DWORD PASCAL FAR GetMacLong (LPB);
PUBLIC WORD PASCAL FAR GetMacWord (LPB);
PUBLIC DWORD PASCAL FAR SwapLong (DWORD);
PUBLIC WORD PASCAL FAR SwapWord (WORD);
PUBLIC int PASCAL FAR SwapBuffer (LPW, DWORD);

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	BOOL PASCAL FAR | StringDiff |
 *		Given two pascal strings, this function will check to see if
 *		they are identical
 *
 *	@parm	LPB | lpStr1 |
 *		First Pascal string
 *
 *	@parm	LPB | lpStr2 |
 *		Second Pascal string
 *
 *	@rdesc	TRUE if the 2 strings are different, else FALSE
 *
 *	@comm	This function is for speed so no strings validity is checked
 *************************************************************************/
PUBLIC BOOL PASCAL FAR StringDiff (LPB lpStr1, LPB lpStr2)
{
	register BYTE cByte;

	/* Check the strings' lengths. If they are different then done */
	if ((cByte = *lpStr1++) != *lpStr2++)
		return TRUE;

	/* Check invidual bytes */
	for (; cByte > 0; cByte--) {
		if (*lpStr1++ != *lpStr2++)
			return TRUE;
	}
	return FALSE;
}


/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	BOOL PASCAL FAR | StringDiff2 |
 *		Given two pascal strings, this function will check to see if
 *		they are identical.  Both strings must have 2 byte size fields
 *
 *	@parm	LPB | lpStr1 |
 *		First Pascal string
 *
 *	@parm	LPB | lpStr2 |
 *		Second Pascal string
 *
 *	@rdesc	TRUE if the 2 strings are different, else FALSE
 *
 *	@comm	This function is for speed so no strings validity is checked
 *************************************************************************/
PUBLIC BOOL PASCAL FAR StringDiff2 (LPB lpStr1, LPB lpStr2)
{
	register WORD cByte;

	/* Check the strings' lengths. If they are different then done */
    // erinfox: GETWORD byte-swaps on Mac
	if ((cByte = *(WORD UNALIGNED * UNALIGNED)(lpStr1)) != *(WORD UNALIGNED * UNALIGNED)(lpStr2))
		return TRUE;
    lpStr1 += sizeof (SHORT);
    lpStr2 += sizeof (SHORT);

	/* Check invidual bytes */
	for (; cByte > 0; cByte--) {
		if (*lpStr1++ != *lpStr2++)
			return TRUE;
	}
	return FALSE;
}


/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	WORD PASCAL FAR | CbByteUnpack |
 *		Unpack a number
 *
 *	@parm	LPDW | lpdwOut |
 *		Pointer to result number
 *
 *	@parm	LPB | lpbIn |
 *		Input compacted sequence of bytes
 *
 *	@rdesc	The function will return the number of bytes scanned. The
 *		content of lpdwOut is updated
 *************************************************************************/
PUBLIC	WORD PASCAL FAR CbByteUnpack(LPDW	lpdwOut, LPB lpbIn)
{
	register int cb = 1;
	register unsigned int cShift = 7;
	DWORD dwSave = 0;

	dwSave |= *lpbIn & 0x7F;
	while (*lpbIn & 0x80) {	/* Hi-bit set */
		lpbIn++;
		dwSave |= ((DWORD)(*lpbIn & 0x7F)) << cShift;
		cb++;
		cShift += 7;
	}
	*lpdwOut = dwSave;
	return((WORD) cb);
}


/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	int PASCAL FAR | NCmpS |
 *		This function will compare two pascal strings
 *
 *	@parm	LPB | lpStr1 |
 *		First Pascal string
 *
 *	@parm	LPB | lpStr2 |
 *		Second Pascal string
 *
 *	@rdesc	The returned values are:
 *		< 0 : lpStr1 < lpStr2
 *		= 0 : if the strings are identical
 *		> 0 : lpStr1 > lpStr2
 *
 *	@comm	This function is for speed so no strings validity is checked
 *************************************************************************/
PUBLIC int PASCAL FAR NCmpS (LPB lpStr1, LPB lpStr2)
{
	register int wlen;
	register int fRet;

	/* Get the minimum length */
	if ((fRet = *(LPUW)lpStr1 - *(LPUW)lpStr2) > 0) 
		wlen = *(LPUW)lpStr2;
	else 
		wlen = *(LPUW)lpStr1;

	/* Skip the lengths */
	lpStr1 += sizeof(WORD);
	lpStr2 += sizeof(WORD);

	/* Start compare byte per byte */
	for (; wlen > 0; wlen--, lpStr1++, lpStr2++) {
		if (*lpStr1 != *lpStr2)
			break;
	}

	if (wlen == 0) return fRet;
	return (*lpStr1 - *lpStr2);
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	int PASCAL FAR | StrNoCaseCmp |
 *		String compare with case insensitive
 *
 *	@parm	LPB | lpb1 |
 *		Pointer to string 1
 *
 *	@parm	LPB | lpb2 |
 *		Pointer to string 2
 *
 *	@parm	WORD | wLen |
 *		String length
 *
 *	@rdesc	0 if the 2 strings match, 1 if not
 *************************************************************************/
PUBLIC int PASCAL FAR StrNoCaseCmp (LPB lpb1, LPB lpb2, WORD wLen)
{
	int fRet;

	for (; wLen > 0; wLen--, lpb1++, lpb2++) {
		if ((fRet = ((*lpb1 | 0x20) != (*lpb2 | 0x20))))
			return fRet;
	}
	return 0;
}

PUBLIC VOID PASCAL FAR FreeHandle (HANDLE hd)
{
	if (hd) {
		_GLOBALUNLOCK(hd);
		_GLOBALFREE(hd);
	}
}

#if defined(_DEBUG) && !defined(_MSDN) && !defined(MOSMAP)
/*************************************************************************
 *	@doc	INTERNAL INDEX RETRIEVAL
 *
 *	@func	LPV PASCAL FAR | DebugGlobalLockedStructMemAlloc |
 *		This function allocates and return a pointer to a block of
 *		memory. The first element of the structure must be the handle
 *		to this block of memory
 *
 *	@parm	WORD | size |
 *		Size of the structure block.
 *
 *	@parm	LSZ | szFilename |
 *		Filename where the call is made
 *
 *	@parm	int | Line |
 *		Source line where the call is made
 *
 *	@rdesc	NULL if OOM, or pointer to the structure
 *************************************************************************/
PUBLIC LPV PASCAL FAR DebugGlobalLockedStructMemAlloc (unsigned int size,
	LSZ szFilename, WORD Line)
{
	HANDLE hMem;
	HANDLE FAR *lpMem;

	if ((hMem = _GlobalAlloc(DLLGMEM_ZEROINIT, (DWORD)size,
		szFilename, Line)) == 0)
		return NULL;

	lpMem = (HANDLE FAR *)_GLOBALLOCK(hMem);
	*lpMem = hMem;
	return (LPV)lpMem;
}
#endif

#if 0
/*************************************************************************
 *	@doc	INTERNAL INDEX RETRIEVAL
 *
 *	@func	BOOL PASCAL FAR | MapErr |
 *		Map an MVFS error to index/search error
 *
 *	@parm	WORD | error |
 *		mvfs error
 *
 *	@rdesc	Return indexer/searcher error
 *************************************************************************/
PUBLIC BOOL PASCAL FAR MapErr(WORD error)
{
	switch (error) {
		case ERR_FAILED:
			return FAIL;
		case ERR_SUCCESS:
			return SUCCEED;
		case ERR_EXIST:
			return ERR_EXIST;
		case ERR_INVALID:
		case ERR_INVALID_HANDLE:
			return ERR_INVALID_FS_FILE;
		case ERR_BADARG:
		case ERR_NOTSUPPORTED:
			return ERR_BADARG;
		case ERR_MEMORY:
			return ERR_MEMORY;
		case ERR_NOPERMISSION:
			return ERR_CANTWRITE;
		case ERR_BADVERSION:
			return ERR_BADVERSION;
		case ERR_DISKFULL:
			return ERR_DISKFULL;
		case ERR_NOHANDLE:
			return ERR_NOHANDLE;
		case ERR_BUFOVERFLOW:
			return ERR_TREETOOBIG;
		case ERR_ASSERT:
		default:
			return ERR_ASSERT;
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\update.c ===
/*************************************************************************
*                                                                        *
*  UPDATE.C                                                              *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
**************************************************************************/

#include <mvopsys.h>
#include <math.h>
#include <mem.h>
#include <orkin.h>
#include <mvsearch.h>
#include "common.h"
#include "index.h"

#ifdef _DEBUG
static BYTE NEAR s_aszModule[] = __FILE__;	/* Used by error return functions.*/
#endif


#define SAFE_SLACK  48      // Extra safety bytes
#define ESOUTPUT_BUFFER 0xFFFC  // Size of output file buffer
            // This must be at the size of the largest word + 12
            // or word + 14 if OCCF_LENGTH is set
#define ESINPUT_BUFFER  0x7FFC  // Size of input file buffers.
                                // Each ESB block get its own input buffer
                                // Min Size: Size of index word + ~8 bytes

#define NEW_NODE_ON_LEFT    0
#define NEW_NODE_ON_RIGHT   1

extern FENCODE EncodeTable[];
extern FDECODE DecodeTable[];

#define FAddDword(p,dw,key)   EncodeTable[(key).cschScheme]((p), (dw), (key).ucCenter)
#define FGetDword(a,b,c) (*DecodeTable[b.cschScheme])(a, b, c)

typedef struct WORDINFO
{
    DWORD dwWordLen;
    DWORD dwFieldId;
    DWORD dwNewTopicCount;
    DWORD dwIndexTopicCount;
    DWORD dwMergeTopicCount;
    DWORD dwOldTopicId;
    DWORD dwNewTopicId;
    DWORD dwIndexTopicId;
    DWORD dwDataSize;
    FILEOFFSET dataLocation;
    WORD  fFlag;
    WORD  pad;
} WORDINFO, FAR *PWORDINFO;

typedef struct FREEBLOCK
{
    DWORD dwBlockSize;
    FILEOFFSET foBlockOffset;
}FREEBLOCK, FAR *PFREEBLOCK;

BYTE EmptyWord[4] =  { 0 };

#ifdef _DEBUG
DWORD  dwOldDataLoss = 0;
DWORD  dwNewDataSize = 0;
DWORD  dwOldDataNeed = 0;
DWORD  dwNewNodeSize = 0;
#endif

// Flag to denote that the current entry is to be replaced by the new entry
// This happens when:
//   - A repeated entry in the leaf node
//   - The last entry in the stem node that has to be changed to the last
//     word of the leaf node

#define REPLACE_WORD_01        0x0001

// Flag to denote that the last word buffer actually contains the word
// before last. This is needed when we have to replace the last word
// with the new word. In this case we need the word before last to do
// compression

#define ONE_WORD_BEHIND_02     0x0002

// Flag to denote updating the offset field with the temp node offset

#define USE_TEMP_NODE_04       0x0004

// Flag to denote that only the node offset address is to be updated. Since
// this is a fixed record size, this will speed up the update.

#define UPDATE_NODE_ADDRESS_08    0x0008

// rgpTmpNodeInfo is the new right node if set, else it is the left node

#define USE_TEMP_FOR_RIGHT_NODE_10  0x0010

// Flag to denote that we have to skip the next word before inserting a new
// word. This happen when adding a new word to the end of the block, where
// pCurPtr is pointing to the beginning of the last word

#define SKIP_NEXT_WORD_20         0x0020

// Both nodes, rgpNodeInfo and rgpTmpNodeInfo are used as left and right
// children. This happens when a new top node is created

#define USE_BOTH_NODE_40          0x0040

/*************************************************************************
 *
 *                    INTERNAL PRIVATE FUNCTIONS
 *
 *  All of them should be declared near
 *
 *************************************************************************/
PRIVATE HRESULT  NEAR PASCAL ESFlushBuffer (LPESI);
PRIVATE HRESULT  NEAR PASCAL ESFillBuffer (_LPIPB, LPESB);
PRIVATE void NEAR PASCAL ESMemory2Disk (_LPIPB, PMERGEHEADER);
PRIVATE HRESULT  NEAR PASCAL ProcessFiles (_LPIPB lpipb, LPMERGEPARAMS);
PRIVATE int  NEAR PASCAL CompareRecordBuffers (_LPIPB, LPB, LPB);
PRIVATE VOID NEAR PASCAL PQueueUp (_LPIPB, LPESB FAR *, LONG);
PRIVATE VOID NEAR PASCAL PQueueDown (_LPIPB);
PRIVATE PTOPICDATA PASCAL NEAR MergeTopicNode (PMERGEHEADER, PTOPICDATA, int);
PRIVATE VOID NEAR MergeOccurrence (PTOPICDATA, PTOPICDATA, int);
PRIVATE HRESULT NEAR PASCAL UpdateIndexBTree (_LPIPB, HFPB, LPB, LPB);
VOID SetQueue (LPESI pEsi);
PRIVATE HRESULT NEAR PASCAL AddWordToBTree (_LPIPB, LPB, PWORDINFO);
PRIVATE HRESULT PASCAL NEAR NewDataInsert(LPIPB lpipb, PFILEDATA pInfile,
    PNODEINFO FAR *rgpNodeInfo, LPB pWord, PWORDINFO pWordInfo);
PRIVATE HRESULT PASCAL NEAR CreateNewNode(_LPIPB lpipb, int cLevel,
    int fIsStemNode, int fAfter);
PRIVATE PASCAL NEAR AddRecordToBTree (_LPIPB lpipb, LPB pWord,
    PWORDINFO pWordInfo, int cLevel, int fReplaceWord);
PRIVATE HRESULT PASCAL NEAR WriteNewDataRecord (_LPIPB, PWORDINFO);
PRIVATE HRESULT GetFreeBlock (_LPIPB, PFREEBLOCK, DWORD);
PRIVATE HRESULT PASCAL NEAR CopyBlockFile (PFILEDATA, HFPB, FILEOFFSET, DWORD);
PRIVATE HRESULT PASCAL FAR EmitOldData (_LPIPB, PNODEINFO, PWORDINFO);
PRIVATE HRESULT PASCAL FAR EmitNewData (_LPIPB, PWORDINFO, BOOL);
PRIVATE HRESULT PASCAL NEAR UpdateDataNode (_LPIPB lpipb, PWORDINFO pWordInfo);
PRIVATE int PASCAL NEAR SplitNodeAndAddData (_LPIPB lpipb, LPB pWord,
    PWORDINFO pWordInfo, int cLevel, int fFlag, int fIsStemNode);
PRIVATE int PASCAL NEAR CopyNewDataToStemNode (_LPIPB lpipb,
    PNODEINFO pTmpNode, LPB pWord, LPB pLastWord, int cLevel, int fFlag);
PRIVATE int PASCAL NEAR CopyNewDataToLeafNode (_LPIPB lpipb, PNODEINFO pTmpNode,
    PWORDINFO pWordInfo, LPB pWord, LPB pLastWord);
VOID GetLastWordInNode (_LPIPB lpipb, PNODEINFO pNodeinfo, BOOL flag);
PRIVATE HRESULT PASCAL FAR SkipNewData (_LPIPB lpipb, PWORDINFO pWordInfo);
HRESULT CheckLeafNode (PNODEINFO pNodeInfo, int occf);
HRESULT CheckStemNode (PNODEINFO pNodeInfo);
    

/*************************************************************************
 *
 *                    INTERNAL PUBLIC FUNCTIONS
 *
 *  All of them should be declared far, unless we know they belong to
 *  the same segment. They should be included in some include file
 *
 *************************************************************************/
HRESULT FAR PASCAL FlushTree(_LPIPB lpipb);
PUBLIC HRESULT  FAR PASCAL MergeSortTreeFile (_LPIPB, LPMERGEPARAMS);
PUBLIC HRESULT  FAR PASCAL FillInputBuffer (LPESB, HFPB);
PUBLIC VOID PASCAL FAR FreeBTreeNode (PNODEINFO pNode);
PUBLIC PNODEINFO PASCAL FAR AllocBTreeNode (_LPIPB lpipb);
PUBLIC PASCAL FAR PrefixCompressWord (LPB, LPB, LPB, int);
PUBLIC DWORD PASCAL FAR WriteDataNode (_LPIPB, DWORD, PHRESULT);
PUBLIC HRESULT PASCAL FAR IndexOpenRW (LPIPB, HFPB, LSZ);
PUBLIC HRESULT PASCAL FAR SkipOldData (_LPIPB, PNODEINFO);
PUBLIC LONG PASCAL FAR CompareDWord (DWORD, DWORD, LPV lpParm);

#ifdef _DEBUG
static  LONG Count = 0;
#endif

/*************************************************************************
 *
 *  @doc    EXTERNAL API INDEX
 *
 *  @func   HRESULT FAR PASCAL | MVIndexUpdate |
 *      This function will update an index file based on the information
 *      collected in the Index parameter block.
 *
 *  @parm   HFPB | hSysFile |
 *      System file handle.
 *      If it is 0, this function will open the system file
 *      specified in lszFilename, and then close it after finishing the
 *      index update. If the system file does not exist, then this function
 *      will create it.
 *      If it is non-zero, then the system file is already opened. Only the
 *      index sub-file needs to be created
 *
 *  @parm   LSZ  | lszFilename |
 *      Index filename.
 *      If hSysFile is non-zero, the format is: !index_filename
 *      if hSysFile is zero, the format is: dos_filename[!index_filename]
 *      If !index_filename is not specified, the default name will be used
 *      if hSysFile == 0 and there is no '!', this is a regular DOS file
 *
 *  @parm   LPIPB | lpipb |
 *      Pointer to Index Parameter Block. This structure contains all the
 *      information necessary to update the index file
 * *
 *  @rdesc  S_OK if succeeded, or other errors
 *
 *************************************************************************/
PUBLIC  HRESULT EXPORT_API FAR PASCAL MVIndexUpdate (HFPB hSysFile,
    _LPIPB lpipb, LSZ lszFilename)
{
	return MVIndexUpdateEx(hSysFile, lpipb, lszFilename, NULL, 0);
}


/*************************************************************************
 *
 *  @doc    EXTERNAL API INDEX
 *
 *  @func   HRESULT FAR PASCAL | MVIndexUpdateEx |
 *      This function will update an index file based on the information
 *      collected in the Index parameter block, and also will "pre-delete" the
 *		topics in the given list from the LPIPB before updating.  This function is useful
 *		in scenarios where new topics are continuously added into the index
 *		before knowledge of out-dated topics is available (e.g. netnews).
 *		This allows a single-pass update once the deletes are known.
 *
 *  @parm   HFPB | hSysFile |
 *      System file handle.
 *      If it is 0, this function will open the system file
 *      specified in lszFilename, and then close it after finishing the
 *      index update. If the system file does not exist, then this function
 *      will create it.
 *      If it is non-zero, then the system file is already opened. Only the
 *      index sub-file needs to be created
 *
 *  @parm   LSZ  | lszFilename |
 *      Index filename.
 *      If hSysFile is non-zero, the format is: !index_filename
 *      if hSysFile is zero, the format is: dos_filename[!index_filename]
 *      If !index_filename is not specified, the default name will be used
 *      if hSysFile == 0 and there is no '!', this is a regular DOS file
 *
 *  @parm   LPIPB | lpipb |
 *      Pointer to Index Parameter Block. This structure contains all the
 *      information necessary to update the index file
 *
 *  @parm   LPDW | lpdwTopicList |
 *      Pointer to DWORD array of topic UIDs to be deleted
 *
 *  @parm   DWORD | dwCount |
 *      The number of topics in the array
 * 
 *  @rdesc  S_OK if succeeded, or other errors
 *
 *************************************************************************/
PUBLIC  HRESULT EXPORT_API FAR PASCAL MVIndexUpdateEx (HFPB hSysFile,
    _LPIPB lpipb, LSZ lszFilename, DWORD FAR *rgTopicId, DWORD dwCount)
{
    ERRB    errb;
    PHRESULT  phr  = &errb;
    PFILEDATA   pOutFile;
	MERGEPARAMS mp;
    HRESULT     fRet;           // Return value from this function.

    // Flush the internal sort
    // Flushes any records in the tree to disk
    fRet = FlushTree(lpipb);

    // Free all memory blocks
    FreeISI (lpipb);
    
    if (fRet != S_OK)
        return(fRet);
        
    if (lpipb->esi.cesb == 0) 
        // Nothing to process, there will be no index file
        return S_OK;

    // Set the state flag
    lpipb->bState = UPDATING_STATE;
    
    // Open the index file
    if ((fRet = IndexOpenRW(lpipb, hSysFile, lszFilename)) != S_OK)
    {
exit00:
        if (lpipb->idxf & IDXF_NORMALIZE)
        {
            FreeHandle (lpipb->wi.hSigma);
            FreeHandle (lpipb->wi.hLog);
            lpipb->wi.hSigma = lpipb->wi.hLog = NULL;
        }

        return fRet;
    }
    
	if (rgTopicId && dwCount)
	{
		// Sort the incoming array
		if ((fRet = HugeDataSort((LPV HUGE*)rgTopicId, dwCount,
    		(FCOMPARE)CompareDWord, NULL, NULL, NULL)) != S_OK)
			goto exit00;

		mp.rgTopicId = rgTopicId;
		mp.dwCount = dwCount;
		mp.lpTopicIdLast = rgTopicId;
	}

	if ((fRet = MergeSortTreeFile (lpipb, (rgTopicId && dwCount) ? &mp: NULL)) != S_OK)
	{
    	FileClose(lpipb->hfpbIdxFile);
		fRet = SetErrCode (phr, fRet);
		goto exit00;
	}
    FileUnlink (NULL, lpipb->isi.aszTempName, REGULAR_FILE);
    
    // Open output file
    pOutFile = &lpipb->OutFile;
    if ((pOutFile->fFile = FileCreate  (NULL, lpipb->isi.aszTempName,
        REGULAR_FILE, phr)) == NULL)
    {
    	FileClose(lpipb->hfpbIdxFile);
        fRet = SetErrCode (phr, fRet);
        goto exit00;
    }

    // Allocate output buffer
    pOutFile->dwMax = FILE_BUFFER;
    pOutFile->cbLeft = FILE_BUFFER;
    if ((pOutFile->hMem = _GLOBALALLOC (DLLGMEM_ZEROINIT,
        pOutFile->dwMax + SAFE_SLACK)) == NULL)
    {
        fRet = E_OUTOFMEMORY;
exit0:
    	FileClose(lpipb->hfpbIdxFile);
        FileClose (pOutFile->fFile);
        FileUnlink (NULL, lpipb->isi.aszTempName, REGULAR_FILE);
        goto exit00;
    }
    pOutFile->pCurrent = pOutFile->pMem = _GLOBALLOCK (pOutFile->hMem);
    // Build the permanent index    
    fRet = UpdateIndexBTree(lpipb, hSysFile, lpipb->esi.aszTempName,
        lszFilename);
    _GLOBALUNLOCK(pOutFile->hMem);
    _GLOBALFREE(pOutFile->hMem);
    pOutFile->hMem = NULL;
    goto exit0;
}


/*************************************************************************
 *
 * @doc  PRIVATE INDEXING
 *       
 * @func HRESULT | UpdateIndexBTree |
 *    Allocates required memory and opens input files to create a B-Tree.
 *    Parses incoming words and calls AddRecordToBTree to process them.
 *
 * @parm _LPIPB | lpipb |
 *    Pointer to the index parameter block
 *
 * @parm LPB | lpszTemp |
 *    Filename of the temporary input file
 *
 * @parm LPB | szIndexFilename |
 *    Filename of the permanent B-Tree file
 *
 * @rdesc  Returns S_OK on success or errors if failed
 *
 *************************************************************************/

PRIVATE HRESULT NEAR PASCAL UpdateIndexBTree (_LPIPB lpipb, HFPB hSysFile,
    LPB lpszTemp, LPB szIndexFilename)
{
    PFILEDATA   pInFile;                    // Pointer to input data
    DWORD       dwBytesRead = 0;            // Checks for EOF
    PNODEINFO FAR * rgpNodeInfo;
    PNODEINFO FAR * rgpTmpNodeInfo;
    PNODEINFO   pIndexDataNode;
    ERRB        errb;
    PHRESULT      phr = &errb;
    PIH20       pHeader;
    int         cTreeLevel;
    int         iIndex;
    LPB         pWord;
    WORDINFO    WordInfo;
    OCCF        occf;
    HRESULT         fRet;                       // Return value
    FILEOFFSET  foFreeListOffset;            // File Offset where the FreeList will be saved.
    DWORD       dwSizeFreeList;                     // Size of the FreeList to be saved.


    rgpNodeInfo = lpipb->BTreeData.rgpNodeInfo;    
    rgpTmpNodeInfo = lpipb->BTreeData.rgpTmpNodeInfo;    
    
    MEMSET(&WordInfo, 0, sizeof(WORDINFO));
    
    // Open input file

    pInFile = &lpipb->InFile;
    if ((pInFile->fFile = FileOpen (NULL, lpszTemp, REGULAR_FILE,
        READ, phr)) == NULL)
        return *phr;

    // Allocate input buffer
    pInFile->dwMax = FILE_BUFFER;
    if ((pInFile->hMem =      
        _GLOBALALLOC (DLLGMEM_ZEROINIT, pInFile->dwMax + SAFE_SLACK)) == NULL)
    {
        fRet = E_OUTOFMEMORY;
exit0:
        FileClose (pInFile->fFile);
        FileUnlink (NULL, lpszTemp, REGULAR_FILE);
        return fRet;
    }
    pInFile->pMem = _GLOBALLOCK (pInFile->hMem);
    pInFile->pCurrent = pInFile->pMem;

    pHeader = &lpipb->BTreeData.Header;
    
    // Allocate BTree block.
    for (cTreeLevel = pHeader->cIdxLevels - 1; cTreeLevel >= 0; cTreeLevel --)
    {
        if ((rgpNodeInfo[cTreeLevel] = AllocBTreeNode (lpipb)) == NULL)
        {
            fRet = E_OUTOFMEMORY;
            goto exit2;
        }
        if ((rgpTmpNodeInfo[cTreeLevel] = AllocBTreeNode (lpipb)) == NULL)
        {
            fRet = E_OUTOFMEMORY;
            goto exit2;
        }
    }

    if (((lpipb->pIndexDataNode = pIndexDataNode =
        AllocBTreeNode (lpipb))) == NULL)    
    {
        fRet = E_OUTOFMEMORY;
        goto exit2;
    }
    
    // Reallocate a bigger buffer. BTREE_NODE_SIZE is only good for btree node
    _GLOBALUNLOCK (pIndexDataNode->hMem);
    _GLOBALFREE (pIndexDataNode->hMem);
    
    // Allocate 1M of memory for the data buffer
    if ((pIndexDataNode->hMem = _GLOBALALLOC (DLLGMEM_ZEROINIT,
        pIndexDataNode->dwBlockSize = FILE_BUFFER)) == NULL)
        goto exit2;
        
    pIndexDataNode->pCurPtr = pIndexDataNode->pBuffer =
        _GLOBALLOCK (pIndexDataNode->hMem);
    
    lpipb->pIndexDataNode->hfpbIdx = lpipb->hfpbIdxFile;   // Index file to read from
    
    // Remember the file offset of this node
    rgpNodeInfo[0]->nodeOffset = pHeader->foIdxRoot;
    
    // Read in data for the top stem node
    
    if ((fRet = ReadNewNode(lpipb->hfpbIdxFile, rgpNodeInfo[0],
        pHeader->cIdxLevels > 1 ? FALSE : TRUE)) != S_OK)
    {
exit2:
        FreeHandle (pInFile->hMem);
        for (cTreeLevel = pHeader->cIdxLevels - 1; cTreeLevel >= 0; cTreeLevel --)
        {
            FreeBTreeNode (rgpNodeInfo[cTreeLevel]);
            FreeBTreeNode (rgpTmpNodeInfo[cTreeLevel]);
        }
        goto exit0;
    }
    
    // Allocate temporary buffer for word. The buffer is allocated as followed:
    //  - Max word length  * 2: for maximum word length. Minimum is 256
    //  - 3 byte: word length
    //  - 5 byte: Field Id
    //  - 5 byte: Topic count
    //  - 6 byte: data pointer
    // iIndex is used as a tmp
    
    iIndex = (WORD)(lpipb->BTreeData.Header.dwMaxWLen * 2);
    if (iIndex < 1024)
        iIndex = 1024;
    iIndex += 3 + 5 + 5 + 6;
    if ((lpipb->hTmpBuf = _GLOBALALLOC (DLLGMEM_ZEROINIT, iIndex * 2)) == NULL)
    {
        fRet = E_OUTOFMEMORY;
        goto exit2;
    }
    lpipb->pTmpBuf = (LPB)_GLOBALLOCK (lpipb->hTmpBuf);
    lpipb->pWord = lpipb->pTmpBuf + iIndex;
    
    // Allocate a big buffer for data
    if ((lpipb->hData = _GLOBALALLOC(DLLGMEM_ZEROINIT,
        lpipb->dwDataSize = 0x80000)) == NULL)
    {
        fRet = E_OUTOFMEMORY;
        goto exit2;
    }
    lpipb->pDataBuffer= _GLOBALLOCK(lpipb->hData);
    
    // Load the input buffer & repeat until all records are processed
    pInFile->dwMax = pInFile->cbLeft = 
        FileRead (pInFile->fFile, pInFile->pMem, pInFile->dwMax, phr);
    fRet = S_OK;
    
    pWord = lpipb->pWord;
    occf  = lpipb->BTreeData.Header.occf;
    
    do
    {
        LPB pSrcPtr;
        WORD wLen;
        
        if (pInFile->cbLeft < CB_MAX_WORD_LEN * sizeof(DWORD) * 8)
        {
            MEMMOVE (pInFile->pMem, pInFile->pCurrent, pInFile->cbLeft);
            pInFile->cbLeft += FileRead (pInFile->fFile,
                pInFile->pMem + pInFile->cbLeft,
                pInFile->dwMax - pInFile->cbLeft, &errb);
            pInFile->dwMax = pInFile->cbLeft;
            pInFile->pCurrent = pInFile->pMem;
        }
        
        // Extract the word and its info
        pSrcPtr = pInFile->pCurrent + sizeof(DWORD); // Skip reclength
        
        // Copy the word
        MEMCPY (pWord, pSrcPtr, wLen = GETWORD((LPUW)pSrcPtr) + 2);
        pSrcPtr += GETWORD((LPUW)pSrcPtr) + 2;
        
        if (occf & OCCF_LENGTH)
        {
            pSrcPtr += CbByteUnpack(&WordInfo.dwWordLen, pSrcPtr);
            CbBytePack (pWord + wLen, WordInfo.dwWordLen);
        }
        else
        {
            WordInfo.dwWordLen = wLen - 2;
        }
        if (occf & OCCF_FIELDID)
            pSrcPtr += CbByteUnpack(&WordInfo.dwFieldId, pSrcPtr);
            
        WordInfo.dwNewTopicCount = GETLONG((LPUL)pSrcPtr);
        pSrcPtr += sizeof(DWORD);

        pInFile->pCurrent = pSrcPtr;
        pInFile->cbLeft = (LONG)(pInFile->dwMax - (pSrcPtr - pInFile->pMem));
        
#if 0
        if (STRNICMP(pWord+2, "cylindeeer", 10) == 0)
    		_asm int 3;
#endif            
#if 0    
        else            
        {
            SkipNewData (lpipb, &WordInfo);
            continue;
        }
#endif
        // Find/Add the record

        if ((fRet = AddWordToBTree (lpipb, pWord, &WordInfo)) != S_OK)
        {
exit3:
            _GLOBALUNLOCK (lpipb->hTmpBuf);
            _GLOBALFREE (lpipb->hTmpBuf);
            _GLOBALUNLOCK(lpipb->hData);
            _GLOBALFREE(lpipb->hData);
            FreeBTreeNode (lpipb->pIndexDataNode);
            lpipb->hData = lpipb->hTmpBuf = 0;
            goto exit2;
        }
        
        pSrcPtr = pInFile->pCurrent;

        // pInFile->pCurrent points to the record size
        
        if (pInFile->cbLeft <= SAFE_SLACK ||
            (LONG)GETLONG ((LPUL)pInFile->pCurrent) >= pInFile->cbLeft)
        {
            MEMMOVE (pInFile->pMem, pInFile->pCurrent, pInFile->cbLeft);
            if ((pInFile->cbLeft += FileRead (pInFile->fFile, pInFile->pMem + 
                pInFile->cbLeft, pInFile->dwMax - pInFile->cbLeft, phr)) < 0) 
            {
                fRet = *phr;
                goto exit3;
            } 

            pInFile->dwMax = pInFile->cbLeft;
            pInFile->pCurrent = pInFile->pMem;
        }
    } while (fRet == S_OK && pInFile->cbLeft);

    for (cTreeLevel = pHeader->cIdxLevels - 1; cTreeLevel >= 0; cTreeLevel --)
    {
        if (rgpNodeInfo[cTreeLevel]->fFlag == TO_BE_UPDATE) 
        {
            if ((FileSeekWrite(lpipb->hfpbIdxFile,
                rgpNodeInfo[cTreeLevel]->pBuffer,
                rgpNodeInfo[cTreeLevel]->nodeOffset,
                lpipb->BTreeData.Header.dwBlockSize, phr)) != (LONG)lpipb->BTreeData.Header.dwBlockSize)
            {
                
                fRet = *phr;
                goto exit3;
            }
        }
    }
    
    if (lpipb->idxf & IDXF_NORMALIZE)
    {
        LONG loop;
        
        for (loop  =  lpipb->dwMaxTopicId; loop >= 0; loop--)
        {
            lpipb->wi.hrgsigma[loop] = 
                (float)sqrt ((double)lpipb->wi.hrgsigma[loop]);
        }

        pHeader->WeightTabSize =  (lpipb->dwMaxTopicId + 1)* sizeof(float);
        
        if (FileSeekWrite (lpipb->hfpbIdxFile, lpipb->wi.hrgsigma,
            lpipb->foMaxOffset, pHeader->WeightTabSize, phr) !=
            (LONG)pHeader->WeightTabSize)
        {
            fRet = *phr;
            goto exit3;
        }
        pHeader->WeightTabOffset = lpipb->foMaxOffset;
    }
    
    // ERIC: 1/ Save the freelist info to the end of the file
    //       2/ Update the header with the new freelist offset/size
    if (lpipb->hFreeList)
    {
        LPBYTE lpbFreeList;

        dwSizeFreeList = FreeListSize(lpipb->hFreeList,phr);

        foFreeListOffset = FreeListGetBestFit(lpipb->hFreeList, MakeFo(dwSizeFreeList,0), phr);

        if (FoIsNil(foFreeListOffset))
            foFreeListOffset = lpipb->foMaxOffset;

        if((lpbFreeList = (LPBYTE) _GLOBALALLOCPTR(DLLGMEM_ZEROINIT, dwSizeFreeList)) == NULL)
            return E_OUTOFMEMORY;

        FreeListGetMem(lpipb->hFreeList, (LPVOID)lpbFreeList);
        FileSeekWrite (lpipb->hfpbIdxFile, (LPBYTE)lpbFreeList,
            foFreeListOffset, dwSizeFreeList, phr);
        if (FoEquals(foFreeListOffset, lpipb->foMaxOffset))
            dwSizeFreeList |= 0x80000000;
        FreeListDestroy(lpipb->hFreeList);
        lpipb->hFreeList = (HFREELIST) NULL;
        _GLOBALFREEPTR(lpbFreeList);
    }

    // Copy info to header
    if (pHeader->lcTopics < lpipb->lcTopics)
        pHeader->lcTopics = lpipb->lcTopics;

    if (pHeader->dwMaxFieldId < lpipb->dwMaxFieldId)
        pHeader->dwMaxFieldId = lpipb->dwMaxFieldId;
    if (pHeader->dwMaxWCount  < lpipb->dwMaxWCount)
        pHeader->dwMaxWCount  = lpipb->dwMaxWCount;
    if (pHeader->dwMaxOffset  < lpipb->dwMaxOffset)
        pHeader->dwMaxOffset  = lpipb->dwMaxOffset;
    if (pHeader->dwMaxWLen < lpipb->dwMaxWLen)
        pHeader->dwMaxWLen    = lpipb->dwMaxWLen;
    pHeader->dwMaxTopicId = lpipb->dwMaxTopicId;

    // ERIC: Garbage Collection
    pHeader->foFreeListOffset = foFreeListOffset;
    pHeader->dwFreeListSize = dwSizeFreeList;
    // END


    FileSeekWrite (lpipb->hfpbIdxFile, (LPB)pHeader,
        MakeFo (0, 0), sizeof (IH20), phr);
    fRet = S_OK;
    goto exit3;
}

/*********************************************************************
 *  @func   LPB PASCAL | AddWordToBTree |
 *      Find the location of a word in the index. This function also
 *      sets up all relevant data for the future update
 *
 *  @parm   LPIPB | lpipb |
 *      Pointer to index info
 *
 *  @parm   LPB | pWord |
 *      Word to be searched for. This is a 2-byte preceded Pascal string
 *
 *  @parm   PWORDINFO | pWordInfo |
 *      Pointer to word's info
 *
 *  @rdesc
 *      S_OK or other errors. In case of success, pWordInfo will
 *      be filled with useful data
 *********************************************************************/
PRIVATE HRESULT NEAR PASCAL AddWordToBTree (_LPIPB lpipb, LPB pWord,
    PWORDINFO pWordInfo)
{
    int     cLevel;
    LPB     lpCurPtr;        
    int     nCmp;
    HRESULT     fRet;
    WORD    RecSize = 0;
    LPB     lpMaxAddress;
    ERRB    errb;
    PHRESULT  phr = &errb;
    WORD    wWlen;
    PNODEINFO pNodeInfo;
    PNODEINFO pChildNode;
    LPB     pBTreeWord;
    int     cMaxLevel;
    FILEOFFSET nodeOffset;
    PNODEINFO FAR *rgpNodeInfo = lpipb->BTreeData.rgpNodeInfo;
    OCCF    occf = lpipb->occf;
    LONG    dwBlockSize = lpipb->BTreeData.Header.dwBlockSize;

#if 0
	Count++;
    if (STRNICMP(pWord+2, "approeeaching", 11) == 0 ||
        STRNICMP(pWord+2, "authenteeic", 11) == 0 ||
        STRNICMP(pWord+2, "eastleeand", 10) == 0)
		 _asm int 3;
#endif
    // Change to 0-based    
    cMaxLevel  = lpipb->BTreeData.Header.cIdxLevels - 1;

    // Remember the last level offset
    nodeOffset = rgpNodeInfo[0]->nodeOffset;
    
    /* Search in the stem nodes */
    for (cLevel = 0; cLevel < cMaxLevel ; cLevel++) 
    {
        //
        //  Set variables
        //
        pNodeInfo = rgpNodeInfo[cLevel];
        pChildNode = rgpNodeInfo[cLevel + 1];
        pChildNode->prevNodeOffset = foNil;
        pBTreeWord = pNodeInfo->pTmpResult;
        
        // Reload the node if neccessary
        if (!FoEquals(pNodeInfo->nodeOffset, nodeOffset))
        {
            if (pNodeInfo->fFlag == TO_BE_UPDATE) 
            {
                if ((FileSeekWrite(lpipb->hfpbIdxFile, pNodeInfo->pBuffer,
                    pNodeInfo->nodeOffset, dwBlockSize,
                    &errb)) != (LONG)dwBlockSize)
                    return(errb);
            }
            pNodeInfo->nodeOffset = nodeOffset;
            if ((fRet = ReadNewNode (lpipb->hfpbIdxFile, pNodeInfo,
                FALSE)) != S_OK)
            {
                return SetErrCode (phr, fRet);
            }
            pNodeInfo->fFlag = 0;
        }
        lpMaxAddress = pNodeInfo->pMaxAddress;

        lpCurPtr = pNodeInfo->pCurPtr; // points to the LAST ACCESSED word in the block
        
        // The format of the stem node
        //      cbLeft | (Word | PointerToNode) | Slack 

        while (lpCurPtr < lpMaxAddress - 1)
        {
            // Save the last location. This would be the insertion point for
            // update
            pNodeInfo->pCurPtr = lpCurPtr;
            
            // Reset the word length
            wWlen = 0;
            
            // Get the compressed word
            lpCurPtr = ExtractWord(pBTreeWord, lpCurPtr, &wWlen);

            /* Read in NodeId record */
            lpCurPtr += ReadFileOffset (&nodeOffset, lpCurPtr);

            if ((nCmp = StrCmpPascal2(pWord, pBTreeWord)) ==  0)
                nCmp = (int)((WORD)pWordInfo->dwWordLen - wWlen );
                
            if (nCmp > 0)
            {
                // We didn't find the location of the word yet
                // Continue searching
                
                if (lpCurPtr < pNodeInfo->pMaxAddress - 1)
                {
                    MEMCPY (pNodeInfo->pLastWord, pBTreeWord,
                    *(LPUW)pBTreeWord + sizeof(WORD));     // erinfox  RISC patch
                }
                pChildNode->prevNodeOffset = nodeOffset;
                continue;
            }
            
            // We found the location of the word
            break;
        }
    }

    // At this point, nodeOffset is the node id of the leaf that
    // is supposed to contain the searched word. 
    pNodeInfo = rgpNodeInfo[cMaxLevel];
    if (!FoEquals(pNodeInfo->nodeOffset, nodeOffset))
    {
        if (pNodeInfo->fFlag == TO_BE_UPDATE) 
        {
            if ((FileSeekWrite(lpipb->hfpbIdxFile, pNodeInfo->pBuffer,
                pNodeInfo->nodeOffset, dwBlockSize,
                phr)) != dwBlockSize)
                return(*phr);
        }
        pNodeInfo->nodeOffset = nodeOffset;
        if ((fRet = ReadNewNode (lpipb->hfpbIdxFile, pNodeInfo,
            TRUE)) != S_OK)
        {
            return SetErrCode (phr, fRet);
        }
        pNodeInfo->fFlag = 0;
        lpCurPtr = pNodeInfo->pCurPtr;
    }
    else
    {
        // Reset all data
        // lpCurPtr = pNodeInfo->pCurPtr = pNodeInfo->pBuffer + sizeof(WORD) + FOFFSET_SIZE;
        lpCurPtr = pNodeInfo->pCurPtr;
    }
    pBTreeWord = pNodeInfo->pTmpResult;
    lpMaxAddress = pNodeInfo->pMaxAddress;

	// Reset the last word
	*(LPWORD)pNodeInfo->pLastWord = 0;

    //  Leaf node structure:                                                  *
    //  (Word|FieldId|TopicCnt|PointerToNode|DataSize)*
    for (;;) 
    {
        DWORD dwFieldId;
        
        // Save the last location. This would be the insertion point for
        // update
        pNodeInfo->pCurPtr = lpCurPtr;
        
        if (lpCurPtr >= lpMaxAddress)
        {
            // Add to the end of the node
            if ((fRet = WriteNewDataRecord (lpipb, pWordInfo)) != S_OK)
                return(fRet);
            return AddRecordToBTree (lpipb, pWord, pWordInfo, cMaxLevel, 0);
        }
        
        // Get the compressed word
        lpCurPtr = ExtractWord(pBTreeWord, lpCurPtr, &wWlen);

        // Get fieldif and topic count        
        if (occf & OCCF_FIELDID)
            lpCurPtr += CbByteUnpack (&dwFieldId, lpCurPtr);
        lpCurPtr += CbByteUnpack (&pWordInfo->dwIndexTopicCount, lpCurPtr);
        
        // Get the data location and size
        lpCurPtr += ReadFileOffset (&pWordInfo->dataLocation, lpCurPtr);
        lpCurPtr += CbByteUnpack(&pWordInfo->dwDataSize, lpCurPtr);
        
        if ((nCmp = StrCmpPascal2(pWord, pBTreeWord)) == 0)
        {
            if (occf & OCCF_LENGTH)
                nCmp = (int)((WORD)pWordInfo->dwWordLen - wWlen);
            if (nCmp == 0 && (occf & OCCF_FIELDID))
                nCmp = (int)(pWordInfo->dwFieldId - dwFieldId);
        }
        
        if (nCmp > 0)
        {
            // We didn't find the location of the word yet
            // Continue searching
            MEMCPY (pNodeInfo->pLastWord, pBTreeWord,
                *(LPUW)pBTreeWord+sizeof(WORD) + sizeof(WORD));        // erinfox RISC patch
            continue;
        }
        if (nCmp == 0)
        {
            if ((fRet = UpdateDataNode (lpipb, pWordInfo)) != S_OK)
                return(fRet);
                
            return AddRecordToBTree (lpipb, pWord, pWordInfo, cMaxLevel,
                REPLACE_WORD_01);
        }
        else
        {
            if ((fRet = WriteNewDataRecord (lpipb, pWordInfo)) != S_OK)
                return(fRet);
            return AddRecordToBTree (lpipb, pWord, pWordInfo, cLevel, 0);
        }
        break;
    }
    return S_OK;
}


/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   HRESULT PASCAL | ReadNewNode |
 *      Read in a new node from the disk if it is not the top node.
 *      For the top node, just reset various pointers
 *
 *  @parm   PNODEINFO | pNodeInfo |
 *      Pointer to leaf info
 *
 *  @parm   int | fLeafNode|
 *      TRUE if this is a leaf node
 *
 *  @rdesc  S_OK if succesful, otherwise other errors. On exit,
 *      lpCurPtr wil point to the beginning of the 1st word in the
 *      node
 *
 *  @rcomm  The format of the leaf node is different from a stem node
 *  Stem node structure:                                                  *
 *  CbLeft |* Word | PointerToNode *| Slack                               *
 *                                                                        *
 *  Leaf node structure:                                                  *
 *  NxtBlkPtr|CbLeft|*Word|FieldId|TopicCnt|PointerToNode|DataSize*|Slack *
 *                                                                        *
 *************************************************************************/
PUBLIC HRESULT PASCAL FAR ReadNewNode (HFPB hfpb, PNODEINFO pNodeInfo,
    int fLeafNode)
{
    ERRB   errb;

    if (FileSeekRead (hfpb, pNodeInfo->pBuffer, pNodeInfo->nodeOffset,
        pNodeInfo->dwBlockSize, &errb) != (long)pNodeInfo->dwBlockSize)
        return E_BADFILE;
        
    pNodeInfo->pCurPtr = pNodeInfo->pBuffer;
    if (fLeafNode)
    {
        pNodeInfo->pCurPtr += ReadFileOffset (&pNodeInfo->nextNodeOffset,
            pNodeInfo->pBuffer);
    }
    else
        pNodeInfo->nextNodeOffset = foNil;
    pNodeInfo->cbLeft = *(LPUW)(pNodeInfo->pCurPtr);          // erinfox RISC patch
    pNodeInfo->pCurPtr += sizeof(WORD);
    pNodeInfo->pMaxAddress = pNodeInfo->pBuffer +  pNodeInfo->dwBlockSize -
        pNodeInfo->cbLeft;
    *(LPUW)(pNodeInfo->pLastWord) = *(LPUW)(pNodeInfo->pTmpResult) = 0;
    return S_OK;
}

PUBLIC HRESULT PASCAL FAR IndexOpenRW (_LPIPB lpipb, HFPB hfpbSysFile, LSZ lszFilename)
{
    HFPB   hfpb;   // Handle to system file
    HRESULT    fRet;
    ERRB   errb;
    PHRESULT phr = &errb;
    PIH20  pHeader;
    int    iIndex;
    LONG   i;

    // Check the existence of the file    
    if ((hfpb = FileOpen (hfpbSysFile, lszFilename,
        hfpbSysFile ? FS_SUBFILE : REGULAR_FILE, READ, phr)) == 0) 
    {
        return *phr;
    }
    
    FileClose (hfpb);
    
    // Reopen the file for read/write 
    lpipb->hfpbIdxFile = FileOpen (hfpbSysFile, lszFilename,
        hfpbSysFile ? FS_SUBFILE : REGULAR_FILE, READ_WRITE, phr);

    if ((fRet = ReadIndexHeader(lpipb->hfpbIdxFile,
        pHeader = &lpipb->BTreeData.Header)) != S_OK) 
    {
exit01: 
        SetErrCode (phr, fRet);
        FileClose(lpipb->hfpbIdxFile);
        return fRet;
    }
    
    if (pHeader->version != VERCURRENT || 
        pHeader->FileStamp != INDEX_STAMP) 
    {
        fRet = E_BADVERSION;
        goto exit01;
    }

	// incoming index and occurrence flags must match those in original index
   	if (pHeader->occf != lpipb->occf ||
		 pHeader->idxf != lpipb->idxf)
	{
		fRet = E_BADINDEXFLAGS;
		goto exit01;
	}

    // Update the compression key to be used by WriteDataNode later
    lpipb->cKey[CKEY_TOPIC_ID] = pHeader->ckeyTopicId;
    lpipb->cKey[CKEY_OCC_COUNT] = pHeader->ckeyOccCount;
    iIndex = CKEY_OCC_BASE;
    if (pHeader->occf & OCCF_COUNT)
        lpipb->cKey[iIndex++] = pHeader->ckeyWordCount;
    if (pHeader->occf & OCCF_OFFSET)
        lpipb->cKey[iIndex] = pHeader->ckeyOffset;
    
    // Update the maximum TopicId    
    if (pHeader->dwMaxTopicId < lpipb->dwMaxTopicId)
        pHeader->dwMaxTopicId = lpipb->dwMaxTopicId;
    else
        lpipb->dwMaxTopicId =  pHeader->dwMaxTopicId;

    
    // Get the file size. 
    lpipb->foMaxOffset = FileSize (lpipb->hfpbIdxFile, phr);
    if (lpipb->idxf & IDXF_NORMALIZE)
    {
        // Load the sigma table
        if (FoEquals(pHeader->WeightTabOffset, foNil))
        {
            fRet = SetErrCode (phr, E_ASSERT);
            goto exit01;
        }
        
        if ((fRet = AllocSigmaTable (lpipb)) != S_OK)
            goto exit01;

        if (FileSeekRead (lpipb->hfpbIdxFile, lpipb->wi.hrgsigma, 
            pHeader->WeightTabOffset, pHeader->WeightTabSize, phr) !=
            (LONG)pHeader->WeightTabSize)
        {
            fRet = errb;
            goto exit01;   
        }
        
        if (lpipb->bState == DELETING_STATE)
        {
            // Square the sigma table
            
            // erinfox: off by one bug. change i = lpipb->dwMaxTopicId + 1
            // to lpipb->dwMaxTopicId because we have only allocated 
            // (dwMaxTopicId + 1)*sizeof(float) bytes
            for (i = lpipb->dwMaxTopicId; i >= 0; i--)
            {
                lpipb->wi.hrgsigma[i] =  lpipb->wi.hrgsigma[i] *
                    lpipb->wi.hrgsigma[i];
            }
        }
    }

    /* ERIC */
    // Load or create a freelist (dwSize = 0)
    if (lpipb->bState == UPDATING_STATE)
    {
        if (pHeader->dwFreeListSize)    // If a freelist is existing, read it, otherwise, create it.
        {
            LPBYTE lpbFreeList;    

            if (pHeader->dwFreeListSize & 0x80000000)
            {
                pHeader->dwFreeListSize &= 0x7FFFFFFF;
                lpipb->foMaxOffset = FoSubFo(lpipb->foMaxOffset,MakeFo(pHeader->dwFreeListSize,0));
            }
            if(!(lpbFreeList = (LPBYTE) _GLOBALALLOCPTR(DLLGMEM_ZEROINIT, pHeader->dwFreeListSize)))
            {
                fRet = SetErrCode (phr, E_OUTOFMEMORY);
                goto exit01;
            }

            FileSeekRead (lpipb->hfpbIdxFile, (LPBYTE)lpbFreeList,
                        pHeader->foFreeListOffset, pHeader->dwFreeListSize, phr);

            lpipb->hFreeList = FreeListInitFromMem(lpbFreeList, phr );
            _GLOBALFREEPTR(lpbFreeList);
        }
        else
            lpipb->hFreeList = FreeListInit( wDefaultFreeListSize, phr);
    }

    return S_OK;
}


PRIVATE PASCAL NEAR AddRecordToBTree (_LPIPB lpipb, LPB pWord,
    PWORDINFO pWordInfo, int cLevel, int fFlag)
{
    
    PNODEINFO pNodeInfo;
    PNODEINFO pTmpNodeInfo;
    LPB  pInsertPtr;         // Pointer to insertion point
    LPB  pWordStorage;
    LPB  pLastWord;
    LPB  pBuffer;
    BYTE fIsStemNode;
    WORD wWLen;
    WORD wNewRecSize;        // New record size
    LONG cbByteMoved;        // Number of bytes moved to leave room for new rec
    OCCF occf = lpipb->occf; // Occurrence field flags
    BYTE fLength = occf & OCCF_LENGTH;
    WORD cbLeft;            // How many byte left in the current node?
    LONG dwBlockSize = lpipb->BTreeData.Header.dwBlockSize;
    BYTE cbSkip;
    BYTE fEndNode;
    ERRB errb;
    
    if (cLevel == -1)
    {
        // The tree's level has increased by one
        int i;
        
        if (lpipb->BTreeData.Header.cIdxLevels >= MAX_TREE_HEIGHT - 1)
			return E_TREETOOBIG;

        /* Move down the entries to make room for the top node */
        for (i = lpipb->BTreeData.Header.cIdxLevels; i > 0 ; i-- )
        {
            lpipb->BTreeData.rgpNodeInfo[i] = lpipb->BTreeData.rgpNodeInfo[i-1];
            lpipb->BTreeData.rgpTmpNodeInfo[i] = lpipb->BTreeData.rgpTmpNodeInfo[i-1];
        }
        
        // Increase tree level
        lpipb->BTreeData.Header.cIdxLevels ++;
        if ((pNodeInfo = lpipb->BTreeData.rgpNodeInfo[0] = AllocBTreeNode (lpipb)) == NULL)
            return(E_OUTOFMEMORY);
            
        if ((pTmpNodeInfo = lpipb->BTreeData.rgpTmpNodeInfo[0] = AllocBTreeNode (lpipb)) == NULL)
            return(E_OUTOFMEMORY);
        
        pWordStorage = (pBuffer = pNodeInfo->pBuffer) + sizeof(WORD);
        
        if (fFlag & USE_BOTH_NODE_40)
        {
            if (fFlag & USE_TEMP_FOR_RIGHT_NODE_10)
            {
                // Link to the left child node
                pWordStorage += PrefixCompressWord (pWordStorage,
                    lpipb->BTreeData.rgpNodeInfo[1]->pTmpResult,
                    EmptyWord, fLength);
                pWordStorage += CopyFileOffset (pWordStorage,
                    lpipb->BTreeData.rgpNodeInfo[1]->nodeOffset);
                
                // Link to the right child node
                pWordStorage += PrefixCompressWord (pWordStorage,
                    lpipb->BTreeData.rgpTmpNodeInfo[1]->pTmpResult,
                    lpipb->BTreeData.rgpNodeInfo[1]->pTmpResult, fLength);
                pWordStorage += CopyFileOffset (pWordStorage,
                    lpipb->BTreeData.rgpTmpNodeInfo[1]->nodeOffset);
            }
            else 
            {
                // Link to the left child node
                pWordStorage += PrefixCompressWord (pWordStorage,
                    lpipb->BTreeData.rgpTmpNodeInfo[1]->pTmpResult,
                    EmptyWord, fLength);
                pWordStorage += CopyFileOffset (pWordStorage,
                    lpipb->BTreeData.rgpTmpNodeInfo[1]->nodeOffset);
                
                // Link to the right child node
                pWordStorage += PrefixCompressWord (pWordStorage,
                    lpipb->BTreeData.rgpNodeInfo[1]->pTmpResult,
                    lpipb->BTreeData.rgpTmpNodeInfo[1]->pTmpResult, fLength);
                pWordStorage += CopyFileOffset (pWordStorage,
                    lpipb->BTreeData.rgpNodeInfo[1]->nodeOffset);
            }
        }
        else
        {
            // Link to the right child node
            pWordStorage += PrefixCompressWord (pWordStorage,
                pWord, EmptyWord, fLength);
            pWordStorage += CopyFileOffset (pWordStorage,
                lpipb->BTreeData.rgpTmpNodeInfo[1]->nodeOffset);
        }
             
        // Set all the parameter
        pNodeInfo->pCurPtr = pBuffer + sizeof(WORD);
        pNodeInfo->cbLeft = (LONG)(pBuffer - pWordStorage + dwBlockSize);
        pNodeInfo->pMaxAddress = pBuffer + dwBlockSize - pNodeInfo->cbLeft;
        SETWORD(pBuffer, (WORD)pNodeInfo->cbLeft);

            
        // Write out the new node    
        if ((FileSeekWrite(lpipb->hfpbIdxFile, pBuffer,
            lpipb->foMaxOffset, dwBlockSize, &errb)) != (LONG)dwBlockSize)
            return(errb);
            
        // Remember the offset of this node
        // Set the pointer to the top stem node
    
        lpipb->BTreeData.Header.foIdxRoot = pNodeInfo->nodeOffset =
            lpipb->foMaxOffset;
        lpipb->BTreeData.Header.nidIdxRoot = pNodeInfo->nodeOffset.dwOffset;
    
        lpipb->foMaxOffset = FoAddDw (lpipb->foMaxOffset, dwBlockSize);
#if 0
        return CheckStemNode (pNodeInfo);
#else
        return(S_OK);
#endif
    }
    
    
    // Initialize data
    pNodeInfo = lpipb->BTreeData.rgpNodeInfo[cLevel];
    pTmpNodeInfo = lpipb->BTreeData.rgpTmpNodeInfo[cLevel];
    pLastWord = pNodeInfo->pLastWord;
    pBuffer = pNodeInfo->pBuffer;
    if (fIsStemNode =  (cLevel < lpipb->BTreeData.Header.cIdxLevels - 1))
        cbSkip = sizeof(WORD);
    else
        cbSkip = sizeof(WORD) + FOFFSET_SIZE;
    
    fEndNode = (pNodeInfo->pCurPtr >= pNodeInfo->pMaxAddress);
    
    // Calculate how many byte left are there in the old node
    pInsertPtr = pNodeInfo->pCurPtr;         // Pointer to insertion point
    cbLeft = (WORD)pNodeInfo->cbLeft;
    
    // Handle special simple cases
    if (fFlag & UPDATE_NODE_ADDRESS_08)
    {
        // Skip the next word
        pInsertPtr = ExtractWord(pTmpNodeInfo->pTmpResult,
            pInsertPtr, &wWLen);
            
        if (fFlag & USE_TEMP_NODE_04)
        {
            CopyFileOffset (pInsertPtr,
                lpipb->BTreeData.rgpTmpNodeInfo[cLevel + 1]->nodeOffset);
        }
        else
        {
            CopyFileOffset (pInsertPtr,
                lpipb->BTreeData.rgpNodeInfo[cLevel + 1]->nodeOffset);
        }
#if 0
        return(fIsStemNode ? CheckStemNode (pNodeInfo) :
            CheckLeafNode (pNodeInfo, occf));
#else
        return(S_OK);
#endif
    }
    
    if (fFlag & (REPLACE_WORD_01 | SKIP_NEXT_WORD_20))
    {
        // We get more room from the replaced word
        DWORD dwTemp;
        
        // Skip the next word
        if (fFlag & SKIP_NEXT_WORD_20) 
        {
            pInsertPtr = ExtractWord(pLastWord, pInsertPtr, &wWLen);
        }
        else 
        {
            pInsertPtr = ExtractWord(pTmpNodeInfo->pTmpResult,
                pInsertPtr, &wWLen);
        }
            
        // Skip the data
        if (fIsStemNode)
            pInsertPtr += FOFFSET_SIZE;            
        else 
        {
            // Skip field id, topic count. fileoffset, datasize
            if (occf & OCCF_FIELDID)
                pInsertPtr += CbByteUnpack (&dwTemp, pInsertPtr); // FieldId
            if (occf & OCCF_TOPICID)
            {
                pInsertPtr += CbByteUnpack (&dwTemp, pInsertPtr);
                pInsertPtr += FOFFSET_SIZE;
                pInsertPtr += CbByteUnpack (&dwTemp, pInsertPtr);
            }
        }
        if (fFlag & SKIP_NEXT_WORD_20)
            pNodeInfo->pCurPtr = pInsertPtr;
        else
        {
            // Remove the old data
            MEMMOVE (pNodeInfo->pCurPtr, pInsertPtr, 
                cbByteMoved = (LONG)(pNodeInfo->pMaxAddress - pInsertPtr));
            pNodeInfo->pMaxAddress =
                (pInsertPtr = pNodeInfo->pCurPtr) + cbByteMoved;
			cbLeft = (WORD)(dwBlockSize - (pNodeInfo->pMaxAddress - pBuffer));
        }
        if (pInsertPtr >= pNodeInfo->pMaxAddress)
            fEndNode = TRUE;
    }
    
    //Calculate the approximate number of bytes needed for the 
    // new data by compress it to the temporary block
    
    if (fIsStemNode)    
    {
		if (pInsertPtr <= pNodeInfo->pBuffer + sizeof(WORD))
		{
			// This is the first word, there is no previous one
			*(LPWORD)pLastWord = 0;
		}
        wNewRecSize = (WORD) CopyNewDataToStemNode (lpipb, pTmpNodeInfo,
	  							pWord, pLastWord, cLevel, fFlag);
    }
    else
    {
		if (pInsertPtr <= pNodeInfo->pBuffer + sizeof(WORD) + FOFFSET_SIZE)
		{
			// This is the first word, there is no previous one
			*(LPWORD)pLastWord = 0;
		}
        wNewRecSize = (WORD) CopyNewDataToLeafNode (lpipb, pTmpNodeInfo,
            pWordInfo, pWord, pLastWord);
    }

    wNewRecSize -= cbSkip;
        
    // I reserved about 4 byte to ensure that when we have enough room
    // we do have enough room. Compression may change the size of the
    // record, causing us to run out of room when copying the new data
    // over
    
    if (cbLeft - sizeof(DWORD) > wNewRecSize)
    {
        // We have enough room for the new data. Just insert the new data
        pWordStorage = pTmpNodeInfo->pCurPtr;
        
        if (!fEndNode)
        {
            // We need to recompress the next word
            MEMCPY (pTmpNodeInfo->pTmpResult, pWord,
                *(LPUW)pWord + sizeof(WORD) + sizeof(WORD));  //erinfox RISC patch
            pInsertPtr = ExtractWord(pTmpNodeInfo->pTmpResult,
                pInsertPtr, &wWLen);
            cbByteMoved = PrefixCompressWord (pWordStorage,
                pTmpNodeInfo->pTmpResult, pWord, fLength);
            wNewRecSize += (WORD)cbByteMoved;
                
            // Reset the last word for pBTreeWord
            MEMCPY (pNodeInfo->pTmpResult, pLastWord, 
                *(LPUW)pLastWord + sizeof(WORD) + sizeof(WORD));         // erinfox RISC patch
        }

		// Make room for the new data
		if ((cbByteMoved = (LONG)(pNodeInfo->pMaxAddress - pInsertPtr)) <= 0)
			cbByteMoved = 0;
		else
			MEMMOVE(pNodeInfo->pCurPtr + wNewRecSize, pInsertPtr,
				cbByteMoved = (LONG)(pNodeInfo->pMaxAddress - pInsertPtr));
        
        // Copy the new data
        MEMCPY  (pNodeInfo->pCurPtr, pTmpNodeInfo->pBuffer + cbSkip,
             wNewRecSize);
        
        // Update data 
       
        pNodeInfo->pMaxAddress = pNodeInfo->pCurPtr + wNewRecSize +
            cbByteMoved;
        pNodeInfo->cbLeft = cbLeft = 
            (WORD)(dwBlockSize - (pNodeInfo->pMaxAddress - pBuffer));
        SETWORD(pNodeInfo->pBuffer + cbSkip - sizeof(WORD),
            (WORD)cbLeft);
        pNodeInfo->fFlag = TO_BE_UPDATE;

        // Change the parent node 
        if (fEndNode  && cLevel)
        {
            return (AddRecordToBTree (lpipb, pWord, pWordInfo, cLevel - 1,
                REPLACE_WORD_01));
        }
#if 0
        return(fIsStemNode ? CheckStemNode (pNodeInfo) :
            CheckLeafNode (pNodeInfo, occf));
#else
        return(S_OK);
#endif
        return S_OK;
    }
    
    // Case 3: Add to the middle. This is a complex one, since we have
    // to split the node into 2. 
    return(SplitNodeAndAddData (lpipb, pWord, pWordInfo, cLevel, fFlag,
        fIsStemNode));
}
 
PRIVATE int PASCAL NEAR SplitNodeAndAddData (_LPIPB lpipb, LPB pWord,
    PWORDINFO pWordInfo, int cLevel, int fFlag, int fIsStemNode)
{
    PNODEINFO pNodeInfo;
    PNODEINFO pTmpNodeInfo;
    LONG cbByteMoved;
    WORD leftSize;
    WORD rightSize;
    WORD wWLen;
    LPB  pInsertPtr;
    LPB  pWordStorage;
    int  cbSkip;
    DWORD dwBlockSize;
    HRESULT  fRet;
    BYTE fLength = lpipb->occf & OCCF_LENGTH;
    LPB  pLastWord;
    LPB  pTemp;
    LPB  pBuffer;
    
    
    if (fIsStemNode)
        cbSkip = 0;
    else    
        cbSkip = FOFFSET_SIZE;
 
    // Variable initialization
    pNodeInfo = lpipb->BTreeData.rgpNodeInfo[cLevel];
    pBuffer = pNodeInfo->pBuffer;
    pTmpNodeInfo = lpipb->BTreeData.rgpTmpNodeInfo[cLevel];
    pInsertPtr = pNodeInfo->pCurPtr;
    dwBlockSize =  lpipb->BTreeData.Header.dwBlockSize;
	pLastWord = pNodeInfo->pLastWord;

    // Calculate approximately the left & right side node sizes
    leftSize = (WORD)(pInsertPtr - pBuffer - cbSkip - sizeof(WORD));
    rightSize = (WORD)(pNodeInfo->pMaxAddress - pNodeInfo->pCurPtr);
    
    if (leftSize >= rightSize)
    {
        // We add to the right. The new data will be 1st
        // Example:
        // Add 4 into 1 2 3 5 --> 1 2 3 and 4 5
        if (fIsStemNode)    
        {
            CopyNewDataToStemNode (lpipb, pTmpNodeInfo,
                pWord, EmptyWord, cLevel, fFlag);
            pTemp = pTmpNodeInfo->pBuffer + sizeof(WORD);    
        }
        else
        {
            CopyNewDataToLeafNode (lpipb, pTmpNodeInfo,
                pWordInfo, pWord, EmptyWord);
            pTemp = pTmpNodeInfo->pBuffer + sizeof(WORD) +
                FOFFSET_SIZE;    
        }
        
        pWordStorage = pTmpNodeInfo->pCurPtr;    
        
        // Move back the pointer to the beginning of the word 
        // for future reference
        pTmpNodeInfo->pCurPtr = pTemp;
        
        if (rightSize > 0)
        {
        // Extract the word on the right of the insertion point
            MEMCPY (pTmpNodeInfo->pTmpResult, pWord,
                *(LPUW)pWord + sizeof(WORD));    // erinfox RISC patch
            pInsertPtr = ExtractWord(pTmpNodeInfo->pTmpResult,
                pInsertPtr, &wWLen);
            
            pWordStorage += PrefixCompressWord (pWordStorage,
                pTmpNodeInfo->pTmpResult, pWord, fLength);
                
            // Copy data on the right of the insertion point to the new node
            MEMCPY  (pWordStorage, pInsertPtr,
                cbByteMoved = (LONG)(pNodeInfo->pMaxAddress - pInsertPtr));
            pWordStorage += cbByteMoved;
        }

		pTmpNodeInfo->pMaxAddress = pWordStorage;
            
        // Update the right node
        SETWORD(pTmpNodeInfo->pBuffer + cbSkip,
                (WORD)(pTmpNodeInfo->cbLeft =
                (LONG)(dwBlockSize - (pWordStorage - pTmpNodeInfo->pBuffer))));
        pTmpNodeInfo->pMaxAddress = pTmpNodeInfo->pBuffer +
            dwBlockSize - pTmpNodeInfo->cbLeft;
#if 0
        if (fIsStemNode)
           CheckStemNode (pTmpNodeInfo);
        else
           CheckLeafNode (pTmpNodeInfo, lpipb->occf);
#endif
        MEMSET (pWordStorage, 0, pTmpNodeInfo->cbLeft);
        
        if ((fRet = CreateNewNode (lpipb, cLevel,
            fIsStemNode, NEW_NODE_ON_RIGHT)) != S_OK)
            return(fRet);
            
        // Update the left node
        pNodeInfo->fFlag = TO_BE_UPDATE;
        SETWORD(pBuffer + cbSkip, (WORD)(pNodeInfo->cbLeft = 
            (LONG)(dwBlockSize - (pNodeInfo->pCurPtr - pBuffer))));
#ifdef _DEBUG
        MEMSET (pNodeInfo->pCurPtr, 0, pNodeInfo->cbLeft);
#endif
        pNodeInfo->pMaxAddress = pBuffer + dwBlockSize - pNodeInfo->cbLeft;
        pNodeInfo->fFlag = TO_BE_UPDATE; 
        
#if 0
        if (fIsStemNode)
           CheckStemNode (pNodeInfo);
        else
           CheckLeafNode (pNodeInfo, lpipb->occf);
#endif
        
        if (cLevel == 0)
        {
            if (pNodeInfo->pCurPtr >= pNodeInfo->pMaxAddress - 1)
                pNodeInfo->pCurPtr = pNodeInfo->pBuffer + cbSkip + sizeof(WORD);
            GetLastWordInNode (lpipb, pNodeInfo, fIsStemNode);
            GetLastWordInNode (lpipb, pTmpNodeInfo, fIsStemNode);
            return AddRecordToBTree (lpipb, pWord, NULL, cLevel - 1,
                USE_BOTH_NODE_40 | USE_TEMP_FOR_RIGHT_NODE_10);
        }
        if (rightSize > 0)
        {
            if ((fRet = AddRecordToBTree (lpipb, pWord, NULL, cLevel - 1,
                USE_TEMP_NODE_04 | UPDATE_NODE_ADDRESS_08)) != S_OK)
				return fRet;
			return AddRecordToBTree (lpipb, pNodeInfo->pLastWord, NULL, cLevel - 1, 0);
        }
        
        if (fFlag & REPLACE_WORD_01)
        {
            // rightSize == 0 means that we are adding to the end of the block.
            // REPLACE_WORD means that we are replacing the same word, so basically
            // we have to add a new entry for the left block
		    if ((fRet = AddRecordToBTree (lpipb, pWord, NULL, cLevel - 1,
			    USE_TEMP_NODE_04 | REPLACE_WORD_01)) != S_OK)
                return fRet;

 			return AddRecordToBTree (lpipb, pNodeInfo->pLastWord, NULL,
                cLevel - 1, 0);
        }

		// Add to the end
		return AddRecordToBTree (lpipb, pWord, NULL, cLevel - 1,
			USE_TEMP_NODE_04 | SKIP_NEXT_WORD_20);
	}
    
    //**********************************************
    //
    // Add the new data to the end of the leftnode
    //
    //**********************************************
    // We add to the left. The new data will be last
    // Example:
    // Add 2 into 1 3 4 5 --> 1 2 and 3 4 5
    
    pTmpNodeInfo->pCurPtr = pWordStorage =
        pTmpNodeInfo->pBuffer + cbSkip + sizeof(WORD);

    // Copy the data on the left to the new node
    if (cbByteMoved = leftSize)
    {
        MEMCPY(pWordStorage, pBuffer + cbSkip + sizeof(WORD), cbByteMoved);
        pWordStorage += cbByteMoved;
    }
    
    // Emit new data
    pWordStorage += PrefixCompressWord (pWordStorage,
        pWord, pLastWord, lpipb->occf & OCCF_LENGTH);
        
    if (fIsStemNode)
    {
        if (fFlag & USE_TEMP_NODE_04)
        {
    		pWordStorage += CopyFileOffset (pWordStorage,
                lpipb->BTreeData.rgpTmpNodeInfo[cLevel+1]->nodeOffset);
        }
		else
		{
    		pWordStorage += CopyFileOffset (pWordStorage,
                lpipb->BTreeData.rgpNodeInfo[cLevel+1]->nodeOffset);
		}
    }
    else 
    {
        // Emit field id, topic count. fileoffset, datasize
        if (lpipb->occf & OCCF_FIELDID)
            pWordStorage += CbBytePack (pWordStorage, pWordInfo->dwFieldId);
            
        pWordStorage += CbBytePack (pWordStorage,
            pWordInfo->dwMergeTopicCount);
            
        pWordStorage += CopyFileOffset (pWordStorage, pWordInfo->dataLocation);
        pWordStorage += CbBytePack (pWordStorage, pWordInfo->dwDataSize);
    }
    
    SETWORD (pTmpNodeInfo->pBuffer + cbSkip,
        (WORD)(pTmpNodeInfo->cbLeft = (LONG)(pNodeInfo->dwBlockSize
        - (pWordStorage - pTmpNodeInfo ->pBuffer))));
        
	pTmpNodeInfo->pMaxAddress = pWordStorage;
    if ((fRet = CreateNewNode (lpipb, cLevel, fIsStemNode,
        NEW_NODE_ON_LEFT)) != S_OK)
        return(fRet);
    
    // Update the right node
    if (leftSize > 0)
    {
        MEMMOVE(pNodeInfo->pCurPtr = pBuffer + cbSkip + sizeof(WORD),
            pInsertPtr, (size_t)(pNodeInfo->pMaxAddress - pInsertPtr));
        pNodeInfo->pMaxAddress -= cbByteMoved;        
    
        // Reconstruct the 1st word in the node.
        if (fFlag & REPLACE_WORD_01)
        {
            MEMCPY (pTmpNodeInfo->pTmpResult, pWord,
                *(LPUW)pWord + sizeof(WORD) + sizeof(WORD));    // erinfox RISC patch
        }
        else
        {
            MEMCPY (pTmpNodeInfo->pTmpResult, pLastWord,
                *(LPUW)pLastWord + sizeof(WORD) + sizeof(WORD));   // erinfox RISC patch
        }
    }
    pInsertPtr = pNodeInfo->pCurPtr;
    pInsertPtr = ExtractWord(pTmpNodeInfo->pTmpResult, pTemp = pInsertPtr, &wWLen);
    cbByteMoved = (LONG)(pInsertPtr - pTemp);
    
    // Recompress the word using pLastWord of pTmpNodeInfo
    wWLen = (WORD) PrefixCompressWord (pTmpNodeInfo->pLastWord,
        pTmpNodeInfo->pTmpResult, EmptyWord, fLength);
        
    // Reserved room for the word 
    pWordStorage = pBuffer + cbSkip + sizeof(WORD);
    MEMMOVE (pWordStorage + wWLen, pInsertPtr,
        (size_t)(pNodeInfo->pMaxAddress - pInsertPtr));
    
    // Copy down the word
    MEMCPY(pWordStorage, pTmpNodeInfo->pLastWord, wWLen);
    pNodeInfo->pMaxAddress += wWLen - cbByteMoved;
    
    // Update the right node
    SETWORD(pBuffer + cbSkip,
        (WORD)(pNodeInfo->cbLeft =(WORD)(dwBlockSize -
        (pNodeInfo->pMaxAddress - pBuffer))));
    pNodeInfo->fFlag = TO_BE_UPDATE; 
#ifdef _DEBUG
    MEMSET (pNodeInfo->pMaxAddress, 0, pNodeInfo->cbLeft);
#endif
    if (cLevel == 0)
    {
        GetLastWordInNode (lpipb, pNodeInfo, fIsStemNode);
        GetLastWordInNode (lpipb, pTmpNodeInfo, fIsStemNode);
        return AddRecordToBTree (lpipb, pWord, NULL, cLevel - 1,
            USE_BOTH_NODE_40);
    }
    return AddRecordToBTree (lpipb, pWord, NULL, cLevel - 1,
        USE_TEMP_NODE_04);
        return(fRet);
}

VOID GetLastWordInNode (_LPIPB lpipb, PNODEINFO pNodeInfo, BOOL fIsStemNode)
{
    LPB pInsertPtr = pNodeInfo->pCurPtr;
    LPB pMaxAddress = pNodeInfo->pMaxAddress;
    WORD wWLen;
	DWORD dwTemp;
   
    MEMCPY (pNodeInfo->pTmpResult, EmptyWord, 4);

    while (pInsertPtr < pNodeInfo->pMaxAddress - 1)
    {
        pInsertPtr = ExtractWord(pNodeInfo->pTmpResult, pInsertPtr, &wWLen);
        if (!fIsStemNode)
        {
    		if (lpipb->occf & OCCF_FIELDID)
    			pInsertPtr += CbByteUnpack (&dwTemp, pInsertPtr);
    		if (lpipb->occf & OCCF_TOPICID)
    			pInsertPtr += CbByteUnpack (&dwTemp, pInsertPtr);// Topic count
        }
        pInsertPtr += FOFFSET_SIZE;		// FileOffset
        if (!fIsStemNode)
    		pInsertPtr += CbByteUnpack (&dwTemp, pInsertPtr);
    } 
}

PRIVATE HRESULT PASCAL NEAR CreateNewNode(_LPIPB lpipb, int cLevel,
    int fIsStemNode, int fAfter)
{
    PNODEINFO pNodeInfo;
    PNODEINFO pTmpNodeInfo;
    ERRB      errb;
    LONG      dwBlockSize = lpipb->BTreeData.Header.dwBlockSize;
    
    pNodeInfo = lpipb->BTreeData.rgpNodeInfo[cLevel];
    pTmpNodeInfo = lpipb->BTreeData.rgpTmpNodeInfo[cLevel];
    
#ifdef _DEBUG
    dwNewNodeSize += dwBlockSize;
#endif
    if (!fIsStemNode)
    {
        // Add the new node into the linked list
        if (fAfter)
            CopyFileOffset (pTmpNodeInfo->pBuffer, pNodeInfo->nextNodeOffset);
        else
            CopyFileOffset (pTmpNodeInfo->pBuffer, pNodeInfo->nodeOffset);
    }
        
    // Write out the new node    
    if ((FileSeekWrite(lpipb->hfpbIdxFile, pTmpNodeInfo->pBuffer,
        lpipb->foMaxOffset, dwBlockSize, &errb)) != (LONG)dwBlockSize)
        return(errb);
        
    // Remember the offset of this node
    pTmpNodeInfo->nodeOffset = lpipb->foMaxOffset;
    
    if (!fIsStemNode)
    {
        if (fAfter)
        {
            CopyFileOffset (pNodeInfo->pBuffer, lpipb->foMaxOffset);
            pNodeInfo->fFlag = TO_BE_UPDATE;
        }
        else
        {
        
            // Update the previous link
            if (!FoEquals(pNodeInfo->prevNodeOffset, foNil))
            {
                BYTE TempBuf[FOFFSET_SIZE + 1];
                
                CopyFileOffset (TempBuf,lpipb->foMaxOffset); 
                if ((FileSeekWrite(lpipb->hfpbIdxFile, TempBuf,
                    pNodeInfo->prevNodeOffset, FOFFSET_SIZE,
                    &errb)) != FOFFSET_SIZE)
                    return(errb);
            }
        }
    }
    
    lpipb->foMaxOffset = FoAddDw (lpipb->foMaxOffset, dwBlockSize);
    return(S_OK);
}    

PRIVATE HRESULT PASCAL NEAR WriteNewDataRecord (_LPIPB lpipb, PWORDINFO pWordInfo)
{
    PFILEDATA pOutFile = &lpipb->OutFile;
    DWORD dwBlockSize;
    ERRB  errb;
    HRESULT fRet;
    FREEBLOCK FreeBlock;

    // Reset the characteristic of the file
    pOutFile->pCurrent = pOutFile->pMem;
    pOutFile->cbLeft = pOutFile->dwMax;
    pOutFile->ibit = cbitBYTE - 1;
    FileSeek (pOutFile->fFile,
        pOutFile->foPhysicalOffset = foNil, 0, &errb);
    
    // Write out the data into the temp file
    if ((dwBlockSize = WriteDataNode (lpipb, 
        pWordInfo->dwMergeTopicCount = pWordInfo->dwNewTopicCount, &errb)) == 0)
        return errb;

     // Write out the output buffer
    if (FileWrite (pOutFile->fFile, pOutFile->pMem,
        (LONG)(pOutFile->pCurrent - pOutFile->pMem), &errb) !=
        (LONG) (pOutFile->pCurrent - pOutFile->pMem))
        return(errb);
   // if ((errb.err = FileFlush (pOutFile->fFile)) != S_OK)
   //     return(errb.err);
        
    pWordInfo->dwDataSize = dwBlockSize;
         
    // Find the smallest free block that fits the new data
    if (GetFreeBlock (lpipb, &FreeBlock, dwBlockSize) != S_OK)
    {
#ifdef _DEBUGFREE
    _DPF2("GetFreeBlock failed.  Requested %ld bytes, appending to EOF(%ld)\n", dwBlockSize, lpipb->foMaxOffset.dwOffset);
#endif
        // There is no free block large enough to store the data
        if ((fRet = CopyBlockFile (pOutFile, lpipb->hfpbIdxFile,
            lpipb->foMaxOffset, dwBlockSize)) != S_OK)
            return fRet;
        pWordInfo->dataLocation = lpipb->foMaxOffset;

        lpipb->foMaxOffset = FoAddDw (lpipb->foMaxOffset, dwBlockSize);

#ifdef _DEBUG
        dwNewDataSize += dwBlockSize;
#endif
        return(S_OK);
    }

    // There is a free block large enough to store the data
    if ((fRet = CopyBlockFile (pOutFile, lpipb->hfpbIdxFile,
        FreeBlock.foBlockOffset, dwBlockSize)) != S_OK)
        return fRet;

   pWordInfo->dataLocation = FreeBlock.foBlockOffset;

   return S_OK;
}

// erinfox: return a block from the free list if possible
PRIVATE HRESULT GetFreeBlock (_LPIPB lpipb, PFREEBLOCK pFreeBlock,
    DWORD dwBlockSize)
{
    FILEOFFSET foFreeListOffset;
    ERRB errb;

    // if it can't find a free block, it returns an error
    foFreeListOffset = FreeListGetBestFit(lpipb->hFreeList, MakeFo(dwBlockSize,0), &errb);
    if (FoIsNil(foFreeListOffset))
    {
        return errb;
    }

    pFreeBlock->foBlockOffset = foFreeListOffset;

    return S_OK;
}    

PRIVATE HRESULT PASCAL NEAR CopyBlockFile (PFILEDATA pFileData, HFPB hfpbDest,
    FILEOFFSET foOffset, DWORD dwBlockSize)
{
    LONG cbCopied;
    ERRB  errb;
    
    // Initialize variable
    errb = S_OK;
    
    // Seek to the right locations
    FileSeek (pFileData->fFile, foNil, 0, &errb);
    if (errb != S_OK)
        return(errb);
    FileSeek (hfpbDest, foOffset, 0, &errb);
    if (errb != S_OK)
        return(errb);
    
    // Do the copy
    while (dwBlockSize)
    {
        if ((cbCopied = dwBlockSize) > pFileData->dwMax)
            cbCopied = pFileData->dwMax;
        if (FileRead (pFileData->fFile, pFileData->pMem, cbCopied, &errb) !=
            cbCopied)
            return(E_FILEREAD);
        if (FileWrite(hfpbDest, pFileData->pMem, cbCopied, &errb) != cbCopied)
            return(E_FILEWRITE);
        dwBlockSize -= cbCopied;    
    }
    return(S_OK);
}

PRIVATE HRESULT PASCAL NEAR UpdateDataNode (_LPIPB lpipb, PWORDINFO pWordInfo)
{
    
    // Local replacement Variables
    PBTREEDATA pTreeData = &lpipb->BTreeData;
    PFILEDATA pOutFile   = &lpipb->OutFile;     // Output data structure
    PFILEDATA pInFile    = &lpipb->InFile;      // Input data structre
    HFPB      fFile      = pOutFile->fFile;      // Output file handle
    PNODEINFO pIndexDataNode = lpipb->pIndexDataNode;
    DWORD     dwNewDataSize;
    ERRB      errb;

    // Working Variables
    DWORD dwEncodedSize = 0;    // Size of encoded block
    DWORD dwTopicIdDelta;       // Really only used for weight values
    DWORD dwNewTopicId = 0;
    DWORD dwIndexTopicId = 0;
    DWORD dwNewTopicCount;
    DWORD dwIndexTopicCount;
    DWORD dwTopicCount;
    FILEOFFSET foStart;         // Physical beginning of bit compression block
    WORD  wWeight = 0;          // Only used when IDXF_NORMALIZE is set
    DWORD dwTopicId = 0;        // Only used when IDXF_NORMALIZE is set
    int   cbTemp;               // # of compressed bytes that uncompressed
    OCCF  occf = lpipb->occf;
    BYTE  fetchOldData;
    BYTE  fetchNewData;
    PIH20 pHeader = &lpipb->BTreeData.Header;
    HRESULT   fRet;

    // Initialize variables    
    wWeight = 0;    // UNDONE: Don't need it
    
    // Reset the file pointer
    FileSeek (pOutFile->fFile,
        foStart = pOutFile->foPhysicalOffset = foNil, 0, &errb);
    pOutFile->pCurrent = pOutFile->pMem;
    pOutFile->cbLeft = pOutFile->dwMax;
    pOutFile->ibit = cbitBYTE - 1;
    
    dwIndexTopicCount = pWordInfo->dwIndexTopicCount;
    dwNewTopicCount = pWordInfo->dwNewTopicCount;
    fetchOldData = fetchNewData = TRUE;
    pWordInfo->dwOldTopicId = pWordInfo->dwNewTopicId = dwTopicCount = 0;
    
    // Initialize pIndexDataNode structure 
    pIndexDataNode->nodeOffset = pWordInfo->dataLocation;
    pIndexDataNode->dwDataSizeLeft = pWordInfo->dwDataSize;
    
    if ((fRet = ReadNewData(pIndexDataNode)) !=  S_OK)
        return(fRet);
        
    while (dwIndexTopicCount && dwNewTopicCount)
    {
        // Get the topicId from the new file
        if (fetchNewData)
        {
            if (pInFile->cbLeft < 2 * sizeof (DWORD))
            {
                MEMMOVE (pInFile->pMem, pInFile->pCurrent, pInFile->cbLeft);
                pInFile->cbLeft += FileRead (pInFile->fFile, pInFile->pMem +
                    pInFile->cbLeft, pInFile->dwMax - pInFile->cbLeft,
                    &errb);
                pInFile->dwMax = pInFile->cbLeft;
                pInFile->pCurrent = pInFile->pMem;
            }
            cbTemp = CbByteUnpack (&dwTopicIdDelta, pInFile->pCurrent);
            pInFile->pCurrent += cbTemp;
            pInFile->cbLeft -= cbTemp;

            pWordInfo->dwNewTopicId = (dwNewTopicId += dwTopicIdDelta);
            fetchNewData = FALSE;
        }
        
        if (fetchOldData)
        {
            if (pIndexDataNode->ibit < cbitBYTE - 1)
            {
                pIndexDataNode->ibit = cbitBYTE - 1;
                pIndexDataNode->pCurPtr ++;
            }
            // Get the topicId from the index file
            if ((fRet = FGetDword(pIndexDataNode, pHeader->ckeyTopicId,
                &dwTopicIdDelta)) != S_OK)
                return fRet;
            pWordInfo->dwIndexTopicId = (dwIndexTopicId += dwTopicIdDelta);
            fetchOldData = FALSE;
        }
        
        if (dwIndexTopicId < dwNewTopicId)
        {
            if ((fRet = EmitOldData (lpipb, pIndexDataNode,
                pWordInfo)) != S_OK)
                return(fRet);
            fetchOldData = TRUE;    
            dwTopicCount++;
            dwIndexTopicCount --;
        }
        else if (dwIndexTopicId == dwNewTopicId)  
        {
            DWORD dwTmp;
            if (lpipb->idxf & IDXF_NORMALIZE)
            {
                if ((fRet = FGetBits(pIndexDataNode, &dwTmp,
                    sizeof (USHORT) * cbitBYTE)) != S_OK)
                    return fRet;
            }
    
            if (occf & OCCF_HAVE_OCCURRENCE) 
            {
                if ((fRet = SkipOldData (lpipb, pIndexDataNode)) != S_OK)
                    return(fRet);
            }
            fetchOldData = TRUE;    
            dwIndexTopicCount --;
            
            if ((fRet = EmitNewData (lpipb, pWordInfo, FALSE)) != S_OK)
                return(fRet);
            dwNewTopicCount --;
            fetchNewData = TRUE;    
            dwTopicCount++;
        }
        else 
        {
            if ((fRet = EmitNewData (lpipb, pWordInfo, TRUE)) != S_OK)
                return(fRet);
            dwNewTopicCount --;
            fetchNewData = TRUE;    
            pWordInfo->dwIndexTopicCount++;
            dwTopicCount++;
        }
    }
    while (dwIndexTopicCount)
    {
        if (fetchOldData)
        {
            if (pIndexDataNode->ibit < cbitBYTE - 1)
            {
                pIndexDataNode->ibit = cbitBYTE - 1;
                pIndexDataNode->pCurPtr ++;
            }
            
            // Get the topicId from the index file
            if ((fRet = FGetDword(pIndexDataNode, pHeader->ckeyTopicId,
                &dwTopicIdDelta)) != S_OK)
                return fRet;
            pWordInfo->dwIndexTopicId = (dwIndexTopicId += dwTopicIdDelta);
            fetchOldData = FALSE;
        }
        
        if ((fRet = EmitOldData (lpipb, pIndexDataNode,
            pWordInfo)) != S_OK)
            return(fRet);
        fetchOldData = TRUE;    
        dwIndexTopicCount --;
        dwTopicCount++;
    }
    while (dwNewTopicCount)
    {
        // Get the topicId from the new file
        if (fetchNewData)
        {
            if (pInFile->cbLeft < 2 * sizeof (DWORD))
            {
                MEMMOVE (pInFile->pMem, pInFile->pCurrent, pInFile->cbLeft);
                pInFile->cbLeft += FileRead (pInFile->fFile, pInFile->pMem +
                    pInFile->cbLeft, pInFile->dwMax - pInFile->cbLeft,
                    &errb);
                pInFile->dwMax = pInFile->cbLeft;
                pInFile->pCurrent = pInFile->pMem;
            }
            cbTemp = CbByteUnpack (&dwTopicIdDelta, pInFile->pCurrent);
			pInFile->pCurrent += cbTemp;
			pInFile->cbLeft -= cbTemp;
            pWordInfo->dwNewTopicId = (dwNewTopicId += dwTopicIdDelta);
            fetchNewData = FALSE;
        }
        
        if ((fRet = EmitNewData (lpipb, pWordInfo, TRUE)) != S_OK)
            return(fRet);
        fetchNewData = TRUE;    
        dwNewTopicCount --;
        dwTopicCount++;
        pWordInfo->dwIndexTopicCount++;
    }
    
    // Adjust for some bits used
    if (pOutFile->ibit < cbitBYTE - 1)
    {
        pOutFile->pCurrent++;
        pOutFile->cbLeft--;
        pOutFile->foPhysicalOffset = FoAddDw (pOutFile->foPhysicalOffset, 1);
    }

    // Flush the output buffer
    if (FileWrite (pOutFile->fFile, pOutFile->pMem,
        (LONG)(pOutFile->pCurrent - pOutFile->pMem), &errb) !=
        (LONG)(pOutFile->pCurrent - pOutFile->pMem))
        return(errb);
    
    dwNewDataSize = DwSubFo(pOutFile->foPhysicalOffset, foStart);
    if (pWordInfo->dwDataSize < dwNewDataSize)
    {
                
        // ERIC: Find the best fit block here
        //   - Add the block pointed by pWordInfo into the free list
        //   - Find a new block in the freelist
        //    if ((fRet = CopyBlockFile (pOutFile, lpipb->hfpbIdxFile,
        //      foNewDataOffset, dwNewDataSize)) != S_OK)
        // where foNewDataOffset may be the max offset or the freelist
        // block offset
        FILEOFFSET foOffset1, foNewDataOffset;
        WORD wNumBlocksTemp;
        WORD wMaxBlocksTemp;
        
        // Before adding that block to the FreeList,
        // look if we need to change the size of the FreeList
        
        QFREELIST qFreeList = _GLOBALLOCK(lpipb->hFreeList);
        wNumBlocksTemp = qFreeList->flh.wNumBlocks;
        wMaxBlocksTemp = qFreeList->flh.wMaxBlocks;
        _GLOBALUNLOCK(lpipb->hFreeList);
        
		// we use a count of two in the test below, in case not only old block is added but 
		// also an entry for the unused portion of the new block (later).
        if (wMaxBlocksTemp < 2 || wNumBlocksTemp >= wMaxBlocksTemp - 2)
        {
            HFREELIST hFreeListTemp;

			// if the free list can't grow, fall through to FreeListAdd, where the
			// smallest free entry will be overwritten and re-used
			if (wMaxBlocksTemp < MAXWORD - wDefaultFreeListSize)
			{
				hFreeListTemp = FreeListRealloc(lpipb->hFreeList, 
												(WORD)(wMaxBlocksTemp + wDefaultFreeListSize),
												&errb);
				if (errb != S_OK)
					return errb;
				lpipb->hFreeList = hFreeListTemp;
			}
        }

        FreeListAdd(lpipb->hFreeList, pWordInfo->dataLocation, MakeFo(pWordInfo->dwDataSize,0));
        foNewDataOffset = FreeListGetBestFit(lpipb->hFreeList, MakeFo(dwNewDataSize,0), &errb);

        if (FoIsNil(foNewDataOffset))
        {
#ifdef _DEBUGFREE
            _DPF2("UpdateDataNode: Grow from %ld to %ld failed: appending to EOF\n", pWordInfo->dwDataSize,\
                dwNewDataSize);
#endif
            foNewDataOffset = lpipb->foMaxOffset;
        }
        else
        {            
#ifdef _DEBUGFREE
            _DPF3("UpdateDataNode: Grow from %ld to %ld uses free block at %ld\n", pWordInfo->dwDataSize,\
                dwNewDataSize, foNewDataOffset.dwOffset );
#endif

            foOffset1 = FreeListGetBlockAt(lpipb->hFreeList, foNewDataOffset, &errb);
            if (FoCompare(foOffset1,MakeFo(sizeof(FREELIST),0)) > 0)
                FreeListAdd(lpipb->hFreeList, FoAddDw(foNewDataOffset,dwNewDataSize),
                            FoSubFo(foOffset1,MakeFo(dwNewDataSize,0)));
        }

        if ((fRet = CopyBlockFile (pOutFile, lpipb->hfpbIdxFile,
            foNewDataOffset, dwNewDataSize)) != S_OK)
            return fRet;

        pWordInfo->dataLocation = foNewDataOffset;


        //if ((fRet = CopyBlockFile (pOutFile, lpipb->hfpbIdxFile,
        //    lpipb->foMaxOffset, dwNewDataSize)) != S_OK)
        //    return fRet;
        //pWordInfo->dataLocation = lpipb->foMaxOffset;


        // ERIC: Only increase the size of the file if foMaxOffset is used
        if (FoEquals(foNewDataOffset,lpipb->foMaxOffset))
        {
            lpipb->foMaxOffset = FoAddDw (lpipb->foMaxOffset, dwNewDataSize);

#ifdef _DEBUG
            dwOldDataLoss += pWordInfo->dwDataSize;
            dwOldDataNeed += dwNewDataSize;
#endif        
        }

        pWordInfo->dwDataSize = dwNewDataSize;
    }
    else
    {
        if ((fRet = CopyBlockFile (pOutFile, lpipb->hfpbIdxFile,
            pWordInfo->dataLocation, dwNewDataSize)) != S_OK)
            return fRet;
    }
    
    pWordInfo->dwMergeTopicCount = dwTopicCount;
    return(S_OK);
}

PUBLIC HRESULT PASCAL FAR SkipOldData (_LPIPB lpipb, PNODEINFO pIndexDataNode)
{
    HRESULT fRet;
    DWORD dwOccs;
    DWORD   dwTmp;      // Trash variable.
    OCCF occf = lpipb->occf;
    PIH20 pHeader = &lpipb->BTreeData.Header;
    
    // Get the number of occurrences
    if ((fRet = FGetDword(pIndexDataNode, pHeader->ckeyOccCount,
        &dwOccs)) != S_OK) 
        return fRet;
    //
    //  One pass through here for each occurence in the
    //  current sub-list.
    //
    for (; dwOccs; dwOccs--)
    {
        //
        //  Keeping word-counts?  If so, get it.
        //
        if (occf & OCCF_COUNT) 
        {
            if ((fRet = FGetDword(pIndexDataNode, pHeader->ckeyWordCount,
                &dwTmp))  != S_OK)
            {
                return fRet;
            }
        }
        //
        //  Keeping byte-offsets?  If so, get it.
        //
        if (occf & OCCF_OFFSET) 
        {
            if ((fRet = FGetDword(pIndexDataNode, pHeader->ckeyOffset,
                &dwTmp)) != S_OK)
                return fRet;
        }
    }
    return S_OK;
}

PRIVATE HRESULT PASCAL FAR EmitNewData (_LPIPB lpipb, PWORDINFO pWordInfo,
    BOOL fnewData)
{
    DWORD dwTopicDelta;
    DWORD dwOccs = 0;
    DWORD dwTemp;
    WORD  wWeight = 0;
    PBTREEDATA pTreeData = &lpipb->BTreeData;
    PFILEDATA pInFile = &lpipb->InFile;
    PFILEDATA pOutFile = &lpipb->OutFile;
    OCCF occf = lpipb->occf;
    PIH20  pHeader = &lpipb->BTreeData.Header;
    int   cbTemp;
    ERRB  errb;
    HRESULT   fRet;
    
    // Set the delta
    dwTopicDelta = pWordInfo->dwNewTopicId - pWordInfo->dwOldTopicId;
    pWordInfo->dwOldTopicId = pWordInfo->dwNewTopicId;

    if (pOutFile->ibit < cbitBYTE - 1)
    {
        pOutFile->pCurrent++;
        pOutFile->cbLeft--;
        pOutFile->foPhysicalOffset = FoAddDw (pOutFile->foPhysicalOffset, 1);
        pOutFile->ibit = cbitBYTE - 1;
    }
   
    FAddDword (pOutFile, dwTopicDelta, pHeader->ckeyTopicId);
            
    if (occf & OCCF_HAVE_OCCURRENCE)
    {
        // Get number of occ data records for this topic
        if (pInFile->cbLeft < 2 * sizeof (DWORD))
        {
            MEMMOVE (pInFile->pMem, pInFile->pCurrent, pInFile->cbLeft);
            pInFile->cbLeft += FileRead (pInFile->fFile,
                pInFile->pMem + pInFile->cbLeft,
                pInFile->dwMax - pInFile->cbLeft, &errb);
            pInFile->dwMax = pInFile->cbLeft;
            pInFile->pCurrent = pInFile->pMem;
        }
        cbTemp = CbByteUnpack (&dwOccs, pInFile->pCurrent);
        pInFile->pCurrent += cbTemp;
        pInFile->cbLeft -= cbTemp;
    }
        
    // If we are term weighing we have to calculate the weight
    if (lpipb->idxf & IDXF_NORMALIZE)
    {
        FLOAT rLog;
        FLOAT rTerm;
        FLOAT rWeight;
		FLOAT fOcc;

#ifndef ISBU_IR_CHANGE
		rLog = (float) log10(cHundredMillion/(double)pWordInfo->dwIndexTopicCount);
		rTerm = rLog*rLog;
		if (fnewData)
		{
			fOcc = (float) min(cTFThreshold, dwOccs);
            // Add the new factor into the sigma term
            lpipb->wi.hrgsigma[pWordInfo->dwNewTopicId] *=
                lpipb->wi.hrgsigma[pWordInfo->dwNewTopicId];
            lpipb->wi.hrgsigma[pWordInfo->dwNewTopicId] += fOcc * fOcc * rTerm;
            lpipb->wi.hrgsigma[pWordInfo->dwNewTopicId] =
                (float)(sqrt((double)lpipb->wi.hrgsigma[pWordInfo->dwNewTopicId]));
		}

		// NOTE : The following weight computation, until the assignment to wWeight, is
		// very similar to the weight computation in WriteDataNode() of permind2.c file.
		// Read the explanation there for the hard coded figures and logic appearing below.
		rTerm = (float) (8.0 - log10((double)pWordInfo->dwIndexTopicCount));
		// In extreme cases, rTerm could be 0 or even -ve (when dwTopicCount approaches or 
		// exceeds 100,000,000)
		if (rTerm <= (float) 0.0)
			rTerm = cVerySmallWt;	// very small value. == log(100 mil/ 95 mil)

		rWeight = ((float) min(cTFThreshold, dwOccs)) * rTerm * rTerm / lpipb->wi.hrgsigma[pWordInfo->dwNewTopicId];
		// without the additional rTerm, we would probably be between 0.0 and 1.0
		if (rWeight > rTerm)
			wWeight = 0xFFFF;
		else
			wWeight = (WORD) ((float)0xFFFF * rWeight / rTerm);
#else
        rLog = (float)(1.0) / (float)pWordInfo->dwIndexTopicCount;
        rTerm = rLog * rLog;
        if (fnewData)
        {
            // Add the new factor into the sigma term
            lpipb->wi.hrgsigma[pWordInfo->dwNewTopicId] *=
                lpipb->wi.hrgsigma[pWordInfo->dwNewTopicId];
            lpipb->wi.hrgsigma[pWordInfo->dwNewTopicId] +=
                dwOccs * rTerm;
            lpipb->wi.hrgsigma[pWordInfo->dwNewTopicId] =
                (float)(sqrt((double)lpipb->wi.hrgsigma[pWordInfo->dwNewTopicId]));
        }
        rTerm = rTerm * (float)65535.0;
        
        rWeight = (float)dwOccs * rTerm /
            (float)(lpipb->wi.hrgsigma[pWordInfo->dwNewTopicId]);
        if (rWeight >= 65535.0)
            wWeight = 65335;
        else
            wWeight = (WORD)rWeight;    
#endif // ISBU_IR_CHANGE

        // Write the weight to the output buffer
        if ((fRet = FWriteBits (pOutFile, (DWORD)wWeight, 
            (BYTE)(sizeof (WORD) * cbitBYTE))) != S_OK)
            return fRet;
    }

    if ((occf & OCCF_HAVE_OCCURRENCE) == 0)
        return(S_OK);
        
    // Write the OccCount
    FAddDword (pOutFile, dwOccs, pHeader->ckeyOccCount);

    // Encode the occ block
    for (; dwOccs; dwOccs--)
    {
        // Make sure input buffer holds enough data
        if (pInFile->cbLeft < 5 * sizeof (DWORD))
        {
            MEMMOVE (pInFile->pMem, pInFile->pCurrent, pInFile->cbLeft);
            pInFile->cbLeft += FileRead (pInFile->fFile,
                pInFile->pMem + pInFile->cbLeft,
                pInFile->dwMax - pInFile->cbLeft, &errb);
            pInFile->dwMax = pInFile->cbLeft;
            pInFile->pCurrent = pInFile->pMem;
        }

        if (occf & OCCF_COUNT)
        {
            cbTemp = CbByteUnpack (&dwTemp, pInFile->pCurrent);
            pInFile->pCurrent += cbTemp;
            pInFile->cbLeft -= cbTemp;
            if ((fRet = FAddDword (pOutFile, dwTemp, pHeader->ckeyWordCount))
                != S_OK)
                return(fRet);
        }
                
        if (occf & OCCF_OFFSET)
        {
            cbTemp = CbByteUnpack (&dwTemp, pInFile->pCurrent);
            pInFile->pCurrent += cbTemp;
            pInFile->cbLeft -= cbTemp;
            if ((fRet = FAddDword (pOutFile, dwTemp, pHeader->ckeyOffset))
                != S_OK)
                return(fRet);
        }
    }
    return(S_OK);
}

PRIVATE HRESULT PASCAL FAR EmitOldData (_LPIPB lpipb, PNODEINFO pIndexDataNode,
    PWORDINFO pWordInfo)
{
    DWORD dwTopicDelta;
    DWORD dwOccs;
    DWORD dwTmp;
    WORD  wWeight = 0;
    PFILEDATA pOutFile = &lpipb->OutFile;
    OCCF occf = lpipb->occf;
    HRESULT   fRet;
    PIH20 pHeader = &lpipb->BTreeData.Header;
    
    if (pOutFile->ibit < cbitBYTE - 1)
    {
        pOutFile->pCurrent++;
        pOutFile->cbLeft--;
        pOutFile->foPhysicalOffset = FoAddDw (pOutFile->foPhysicalOffset, 1);
        pOutFile->ibit = cbitBYTE - 1;
    }
   
    // Set the delta
    dwTopicDelta = pWordInfo->dwIndexTopicId - pWordInfo->dwOldTopicId;
    pWordInfo->dwOldTopicId = pWordInfo->dwIndexTopicId;
    
    if ((fRet = FAddDword (pOutFile, dwTopicDelta,
        pHeader->ckeyTopicId)) != S_OK)
        return(fRet);
        
        
    // If we are term weighing we have to calculate the weight
    if (lpipb->idxf & IDXF_NORMALIZE)
    {
        if ((fRet = FGetBits(pIndexDataNode, &dwTmp, sizeof (USHORT) * cbitBYTE))
            != S_OK)
            return(fRet);
            
        // Write the weight to the output buffer
        if ((fRet = FWriteBits (pOutFile, (DWORD)wWeight, 
            (BYTE)(sizeof (WORD) * cbitBYTE))) != S_OK)
            return(fRet);
            
    }

    // Don't do anything else if there is nothing else to do!!!
    if ((occf & OCCF_HAVE_OCCURRENCE) == 0)
        return S_OK;
        
    if ((fRet = FGetDword(pIndexDataNode, pHeader->ckeyOccCount,
        &dwOccs)) != S_OK) 
        return fRet;

    // Write the OccCount
    if ((fRet = FAddDword (pOutFile, dwOccs,
        pHeader->ckeyOccCount)) != S_OK)
        return(fRet);

    // Encode the occ block
    for (; dwOccs; dwOccs--)
    {
        if (occf & OCCF_COUNT)
        {
            if ((fRet = FGetDword(pIndexDataNode, pHeader->ckeyWordCount,
                &dwTmp)) != S_OK) 
                return fRet;
            if ((fRet = FAddDword (pOutFile, dwTmp, pHeader->ckeyWordCount))
                != S_OK)
                return(fRet);

        }
        if (occf & OCCF_OFFSET)
        {
            if ((fRet = FGetDword(pIndexDataNode, pHeader->ckeyOffset,
                &dwTmp)) != S_OK) 
                return fRet;
            if ((fRet = FAddDword (pOutFile, dwTmp, pHeader->ckeyOffset))
                != S_OK)
                return(fRet);
        }
    }
    return(S_OK);
}


PRIVATE int PASCAL NEAR CopyNewDataToStemNode (_LPIPB lpipb,
    PNODEINFO pTmpNode, LPB pWord, LPB pLastWord, int cLevel, int fFlag)
{
    LPB  pWordStorage;
    
    /************************************************
     *     Emit the word data to the temp block
     ************************************************/
     
    pWordStorage = pTmpNode->pBuffer + sizeof(WORD);
    pWordStorage += PrefixCompressWord (pWordStorage,
        pWord, pLastWord, lpipb->occf & OCCF_LENGTH);

    // Emit fileoffset
    if (fFlag & USE_TEMP_NODE_04)
    {
        pWordStorage += CopyFileOffset (pWordStorage,
            lpipb->BTreeData.rgpTmpNodeInfo[cLevel+1]->nodeOffset);
    }
    else
    {
        pWordStorage += CopyFileOffset (pWordStorage,
            lpipb->BTreeData.rgpNodeInfo[cLevel+1]->nodeOffset);
    }
    pTmpNode->pCurPtr = pWordStorage;
    SETWORD (pTmpNode->pBuffer, (WORD)(lpipb->BTreeData.Header.dwBlockSize
        - (pWordStorage - pTmpNode->pBuffer)));
    return (int)(pWordStorage - pTmpNode->pBuffer);
}        

PRIVATE int PASCAL NEAR CopyNewDataToLeafNode (_LPIPB lpipb, PNODEINFO pTmpNode,
    PWORDINFO pWordInfo, LPB pWord, LPB pLastWord)
{
    LPB  pWordStorage;
    
    /************************************************
     *     Emit the word data to the temp block
     ************************************************/
     
    pWordStorage = pTmpNode->pBuffer + FOFFSET_SIZE + sizeof(WORD);
    pWordStorage += PrefixCompressWord (pWordStorage,
        pWord, pLastWord, lpipb->occf & OCCF_LENGTH);
        
    // Emit field id, topic count. fileoffset, datasize
    if (lpipb->occf & OCCF_FIELDID)
        pWordStorage += CbBytePack (pWordStorage, pWordInfo->dwFieldId);
        
    pWordStorage += CbBytePack (pWordStorage,
        pWordInfo->dwMergeTopicCount);
        
    pWordStorage += CopyFileOffset (pWordStorage, pWordInfo->dataLocation);
    pWordStorage += CbBytePack (pWordStorage, pWordInfo->dwDataSize);
    
    pTmpNode->pCurPtr = pWordStorage;
    SETWORD (pTmpNode->pBuffer + FOFFSET_SIZE,
        (WORD)(pTmpNode->cbLeft = (LONG)(lpipb->BTreeData.Header.dwBlockSize
        - (pWordStorage - pTmpNode->pBuffer))));
    return (int)(pWordStorage - pTmpNode->pBuffer);
}        

PRIVATE HRESULT PASCAL FAR SkipNewData (_LPIPB lpipb, PWORDINFO pWordInfo)
{
    DWORD dwOccs;
    DWORD dwTemp;
    PBTREEDATA pTreeData = &lpipb->BTreeData;
    PFILEDATA pInFile = &lpipb->InFile;
    PFILEDATA pOutFile = &lpipb->OutFile;
    OCCF occf = lpipb->occf;
    PIH20  pHeader = &lpipb->BTreeData.Header;
    int   cbTemp;
    ERRB    errb;
    
    // Don't do anything else if there is nothing else to do!!!
    if ((occf & OCCF_HAVE_OCCURRENCE) == 0)
        return S_OK;
        
    // Get number of occ data records for this topic
    if (pInFile->cbLeft < 2 * sizeof (DWORD))
    {
        MEMMOVE (pInFile->pMem, pInFile->pCurrent, pInFile->cbLeft);
        pInFile->cbLeft += FileRead (pInFile->fFile,
            pInFile->pMem + pInFile->cbLeft,
            pInFile->dwMax - pInFile->cbLeft, &errb);
        pInFile->dwMax = pInFile->cbLeft;
        pInFile->pCurrent = pInFile->pMem;
    }
    cbTemp = CbByteUnpack (&dwOccs, pInFile->pCurrent);
    pInFile->pCurrent += cbTemp;
    pInFile->cbLeft -= cbTemp;
            
    // Encode the occ block
    for (; dwOccs; dwOccs--)
    {
        // Make sure input buffer holds enough data
        if (pInFile->cbLeft < 5 * sizeof (DWORD))
        {
            MEMMOVE (pInFile->pMem, pInFile->pCurrent, pInFile->cbLeft);
            pInFile->cbLeft += FileRead (pInFile->fFile,
                pInFile->pMem + pInFile->cbLeft,
                pInFile->dwMax - pInFile->cbLeft, &errb);
            pInFile->dwMax = pInFile->cbLeft;
            pInFile->pCurrent = pInFile->pMem;
        }

        if (occf & OCCF_COUNT)
        {
            cbTemp = CbByteUnpack (&dwTemp, pInFile->pCurrent);
            pInFile->pCurrent += cbTemp;
            pInFile->cbLeft -= cbTemp;
        }
                
        if (occf & OCCF_OFFSET)
        {
            cbTemp = CbByteUnpack (&dwTemp, pInFile->pCurrent);
            pInFile->pCurrent += cbTemp;
            pInFile->cbLeft -= cbTemp;
        }
    }
    return(S_OK);
}

BYTE  CurrentWord [1000];
BYTE  LastWord [1000];

#if 0
HRESULT CheckStemNode (PNODEINFO pNodeInfo)
{
    LPB lpCurPtr;
    WORD wWlen;
    LPB lpMaxAddress = pNodeInfo->pMaxAddress;
    FILEOFFSET nodeOffset;
    
    lpCurPtr = pNodeInfo->pBuffer + sizeof(WORD);
    
    // Reset the last word
    *(LPWORD)LastWord = 0;
    
    do
    {
         lpCurPtr = ExtractWord(CurrentWord, lpCurPtr, &wWlen);
         if (StrCmpPascal2(LastWord, CurrentWord) >  0)
         {
            // _asm int 3;
            return(SetErrCode (NULL, ERR_FAILED));
         }
         lpCurPtr += ReadFileOffset (&nodeOffset, lpCurPtr);
         MEMCPY(LastWord, CurrentWord, wWlen + 2);
    } while (lpCurPtr < lpMaxAddress);
    return(S_OK);
}


HRESULT CheckLeafNode (PNODEINFO pNodeInfo, int occf)
{
    LPB lpCurPtr;
    WORD wWlen;
    LPB lpMaxAddress = pNodeInfo->pMaxAddress;
    FILEOFFSET nodeOffset;
    DWORD dwTmp;
    
    lpCurPtr = pNodeInfo->pBuffer + sizeof(WORD) + FOFFSET_SIZE;
    
    // Reset the last word
    *(LPWORD)LastWord = 0;
    
    do
    {
        lpCurPtr = ExtractWord(CurrentWord, lpCurPtr, &wWlen);
        if (StrCmpPascal2(LastWord, CurrentWord) >  0)
        {
            // _asm int 3;
           return(SetErrCode (NULL, ERR_FAILED));
        }
        
        MEMCPY(LastWord, CurrentWord, wWlen + 2);
        // Get fieldif and topic count        
        if (occf & OCCF_FIELDID)
            lpCurPtr += CbByteUnpack (&dwTmp, lpCurPtr);
        lpCurPtr += CbByteUnpack (&dwTmp, lpCurPtr);
        
        // Get the data location and size
        lpCurPtr += ReadFileOffset (&nodeOffset, lpCurPtr);
        lpCurPtr += CbByteUnpack(&dwTmp, lpCurPtr);
        
    } while (lpCurPtr < lpMaxAddress);
    return(S_OK);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\fts\search\sort.c ===
/*************************************************************************
*                                                                        *
*  SORT.C	                                                             *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   Various sorting routines                                             *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Released by Development:     (date)                                   *
*                                                                        *
*************************************************************************/
#include <mvopsys.h>
#include <mem.h>
#include <mvsearch.h>
#include <memory.h>
#ifdef DOS
#include <fcntl.h>
#include <sys/types.h>
#include <io.h>
#include <sys\stat.h>
#include <malloc.h>
#endif

#if 0
#include <time.h>
#endif

#include "common.h"
#include "index.h"
#ifdef _DEBUG
static BYTE NEAR s_aszModule[] = __FILE__;	/* Used by error return functions.*/
#endif



#define	cbMAX_ESB_BUF		(cbMAX_IO_SIZE) // The largest ESB buffer size 
#define	cbMIN_ESB_BUF		(2048) // The smallest ESB buffer size that won't
								//  cause an insane amount of disk thrashing.

#define	INSERTION_SIZE	15
#define	MAX_RECURSION	100
#define	MERGE_BUF_SIZE	((unsigned int) 60000)
#define	GREATER_INDEX(a,b) (a > b)

/*************************************************************************
 *
 * 	                  INTERNAL GLOBAL FUNCTIONS
 *
 *	Those functions should be declared FAR to cause less problems with
 *	with inter-segment calls, unless they are explicitly known to be
 *	called from the same segment
 *
 *************************************************************************/

PUBLIC HRESULT PASCAL FAR HugeDataSort (LPV HUGE *, DWORD, FCOMPARE, LPV,
	INTERRUPT_FUNC, LPV);
PUBLIC HRESULT PASCAL NEAR IndexSort (LPW, LPB, int);
PUBLIC HRESULT PASCAL NEAR IndexMergeSort (HFILE FAR *, LSZ, LPW, LPB, int, int);
PUBLIC int PASCAL FAR WordRecCompare (LPB, LPB, LPV);

/*************************************************************************
 *
 *	                  INTERNAL PRIVATE FUNCTIONS
 *
 *	All of them should be declared near
 *
 *************************************************************************/
PRIVATE HRESULT PASCAL FAR HugeQuickSort (LPV HUGE *, DWORD,
	DWORD, FCOMPARE, LPV, INTERRUPT_FUNC, LPV); 
PRIVATE HRESULT PASCAL NEAR IndexQuickSort (LPW , LPB , int, int, int);
PRIVATE VOID PASCAL NEAR InsertionSort (LPW, LPB, int);
CheckSort (WORD FAR *, char far *, unsigned int, unsigned int);
CheckSortedFile (HANDLE, int);

/*************************************************************************
 *
 *           I N T E R N A L   S O R T    M E T H O D S
 *
 *	Internal sorts are based on QuickSort combined with Insertion Sort
 *
 *************************************************************************/

/*************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HRESULT PASCAL FAR | HugeInsertionSort |
 *		The function performs a insertion on a huge array of pointers
 *		to data. The array is supposed to be semi-sorted into partitions
 *		of increasing order, and each partition's size is less than
 *		INSERTION_SIZE. If that condition is not met, we can end up
 *		with a long wait
 *
 *	@parm	LPV HUGE * | hrglpb |
 *		Huge array of pointers to data
 *
 *	@parm	DWORD | l |
 *		Left limit of partition
 *
 *	@parm	DWORD | r |
 *		Right limit of partition
 *
 *	@parm	FCOMPARE | Compare |
 *		Function to be used for data comparison
 *
 *	@parm	LPV | lpParm |
 *		Extra info needed by Compare
 *
 *************************************************************************/

PUBLIC VOID PASCAL FAR HugeInsertionSort (LPV HUGE *hrgLpb, DWORD elemcnt,
	FCOMPARE Compare, LPV lpParm)
{
	long i,j;
	LPV HUGE * pSortedElem;
	LPV HUGE * pPrevElem;
	LPV key;

	for (i = 1; i < (long)elemcnt; i++) {
		j = i - 1;
		pSortedElem = hrgLpb + i;
		pPrevElem = pSortedElem - 1;
		key = *pSortedElem;
		if ((*Compare)(*pPrevElem, key, lpParm) > 0) {

			/* Move everything forward */
			do {
				*pSortedElem-- = *pPrevElem--;
				j--;
			} while (j >= 0 && (*Compare)(*pPrevElem, key, lpParm) > 0);

			/* Do the insertion */
			*pSortedElem = key;
		}
	}
}

/*************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HRESULT PASCAL FAR | HugeQuickSort |
 *		The function performs a QuickSort on a huge array of pointers
 *		to data. The QuickSort algorithm is described in any textbook
 *		so it is not described here.
 *
 *	@parm	LPV HUGE * | hrglpb |
 *		Huge array of pointers to data
 *
 *	@parm	DWORD | l |
 *		Left limit of partition
 *
 *	@parm	DWORD | r |
 *		Right limit of partition
 *
 *	@parm	FCOMPARE | Compare |
 *		Function to be used for data comparison
 *
 *	@parm	LPV | lpParm |
 *		Extra info needed by Compare
 *
 *	@rdesc	S_OK or E_FAIL. The reason for failure is that the stack
 *		get overflown. This can be fixed easily by chaning the value
 *		of MAX_RECURSION
 *
 *	@comm	This function only does a partial QuickSort, ie. when the 
 *		sizes of all partitions are less than INSERTION_SIZE, it will
 *		stop and return a partially sorted array.
 *
 *		To reduce the chance of stack overflown, a private stack is used.
 *		which reduces the cost of recursion. If necessary this stack can
 *		be allocated separately using MemAlloc(), which will get rid of
 *		the stack overflown problem
 *
 *************************************************************************/

#define	TICK_COUNT	10

PRIVATE HRESULT PASCAL FAR HugeQuickSort (LPV HUGE * hrglpb, DWORD l,
	DWORD r, FCOMPARE Compare, LPV lpParm, INTERRUPT_FUNC lpfnfInterCb,
	LPV lpvInterCbParms)
{
	DWORD i,j;
	LPV medval;
	LPV HUGE * hrglpLeftArray;
	LPV HUGE * hrglpRightArray;
	LPV tmp;
	DWORD Stack[MAX_RECURSION * 2];
	DWORD FAR *pStack = Stack;
	DWORD FAR *pStackLimit = Stack + MAX_RECURSION * 2 - 2;
	HRESULT fCallBackRet;
	int TickCount = TICK_COUNT;
    ERRB  errb;

	*pStack++ = l;
	*pStack++ = r;

	while (pStack > Stack) {

		/* Execute user's status functions */
		if (TickCount == 0) {
			if (lpfnfInterCb != NULL &&
				(fCallBackRet = (*lpfnfInterCb)(lpvInterCbParms))
				!= S_OK)
			{
				SetErrCode(&errb, fCallBackRet);
				return fCallBackRet;
			}
			TickCount = TICK_COUNT;
		}
		TickCount--;

		j = r = *(--pStack);
		i = l = *(--pStack);
		medval = hrglpb[(l + r) / 2];
		hrglpLeftArray = hrglpb + l;
		hrglpRightArray = hrglpb + r;


		for (;;) {
			/* Find the left and right limits */
			while ((*Compare)(medval, *hrglpLeftArray, lpParm) > 0) {
				i++;
				hrglpLeftArray ++;
			}
			while ((*Compare) (*hrglpRightArray , medval, lpParm) > 0) {
				j--;
				hrglpRightArray -- ;
			}

			/* Exchange the data */
			if (i <= j) {
				tmp = *hrglpLeftArray;
				*hrglpLeftArray++ = *hrglpRightArray;
				*hrglpRightArray-- = tmp;
				i++;
				j--;
			}
			else
				break;	/* Get out of the loop */
		} 

		/* Do the "recursion", sort the left partition */

		if (l + INSERTION_SIZE < j ) {
			if (pStack >= pStackLimit) {
				return E_FAIL;
			}
			*pStack++ = l;
			*pStack++ = j;
		}

		/* Do the "recursion", sort the right partition */

		if (i + INSERTION_SIZE < r) {
			if (pStack >= pStackLimit) {
				return E_FAIL;
			}
			*pStack++ = i;
			*pStack++ = r;
		}
	}
	return S_OK;
}

/*************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HRESULT PASCAL FAR | HugeDataSort |
 *		The function "indirectly" sorts Array. There are two parts:
 *
 *			1/ First, it performs QuickSort 
 *			2/ Then it does an Insertion Sort to the semi-sorted array.
 *
 *		The rational begind the scheme is that we know that QuickSort is
 *		the fastest sorting method for large numbers of data, and Insertion
 *		Sort works best for small amount of data. Since QuickSort partitions
 *		the array into smaller ones, they suit Insertion Sort well. The idea
 *		of applying Insertion Sort to the whole partitioned array is due
 *		to R.Sedgewick, which will save some of the overhead that would be
 *		necessary if we apply straight insertion directly to each small
 *		partition (Knuth).
 *
 *	@parm	LPV HUGE * | hrglpb |
 *		Huge array of pointers to the items to be sorted. Since
 *		the size of items to be sorted is usually larger than 4 bytes
 *		using an index array to indirectly sort them will reduce the
 *		time to copy the items during sorting
 *
 *	@parm	DWORD | dwArraySize |
 *		Size of the array, which is 0 based, ie. the size is 256 for
 *		an array indexed from 0 to 255.
 *
 *	@parm	FCOMPARE | Compare |
 *		Function used to compare the data
 *
 *	@parm	LPV | lpParm | 
 *		Parameter to be used with Compare
 *
 *	@parm	INTERRUPT_FUNC | lpfnfInterCb |
 *		User's interrupt function
 *
 *	@parm	LPV | lpvInterCbParms |
 *		User's function parameters
 *
 *	@parm	PHRESULT | phr |
 *		Error buffer
 *
 *	@rdesc 
 *		S_OK if everything works. The only time that the sort may fail
 *		is that QuickSort reaches its recursion limit.
 *
 *	@comm
 *		1/ Using Insertion sort combined with QuickSort will improve the
 *		the sorting speed (25% over QuickSort alone)
 *
 *		2/ The size of the partitions affect the speed of Insertion sort.
 *		The maximum profit occurs when the size is about 15. Increase the
 *		size to lower the sort speed, decrease it will cause more recursion
 *		for QuickSort and can adversely affect the speed
 *
 *************************************************************************/

PUBLIC HRESULT PASCAL FAR HugeDataSort (LPV HUGE * hrglpb, DWORD dwArraySize,
	FCOMPARE Compare, LPV lpParm, INTERRUPT_FUNC lpfnfInterCb,
	LPV lpvInterCbParms)
{
	HRESULT fRet;

#if 0
	time_t SortTime;
	char buffer[50];

	SortTime = time (NULL);
#endif

	if (dwArraySize > INSERTION_SIZE)
	{
		if ((fRet = HugeQuickSort (hrglpb, 0L, dwArraySize - 1,
			Compare, lpParm, lpfnfInterCb, lpvInterCbParms)) != S_OK)
			return fRet;
	}
	HugeInsertionSort (hrglpb, dwArraySize, Compare, lpParm);
#if 0
	SortTime = time(NULL) - SortTime;
	wsprintf (buffer, "Sort time for %ld items: %ld\r\n",
		dwArraySize, (DWORD)SortTime);
	OutputDebugString (buffer);
#endif
	return S_OK;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	HRESULT PASCAL NEAR | IndexQuickSort |
 *		The function performs a quick-sort on an unsorted array. To speed
 *		up the sorting:
 *		- The sort is performed indirectly through an array of indices,
 *		  just cutting down the time of copying data
 *		- The function will terminate when the partitions' sizes reach
 *		  a limit (INSERTION_SIZE) to let an insertion sort finish the job
 *		- Instead of randomly choosing a pivot element for the sort, the
 *		  middle element of the partition is chosen. This will help
 *		  decreasing the problem QuickSort on sorting an already sorted
 *		  array.
 *
 *	@parm	LPW | IndexArray |
 *		Index array, containing offsets of the elements in Array
 *
 *	@parm	LPB | Array |
 *		Array containing the values of all elements
 *
 *	@parm	int | l |
 *		Leftmost, ie. smallest index
 *
 *	@parm	int | r |
 *		Rightmost, ie. largest index
 *
 *	@parm	int | level |
 *		Recursion level
 *
 *************************************************************************/
PRIVATE HRESULT PASCAL NEAR IndexQuickSort (LPW IndexArray,
	LPB Array, int l, int r, int level) 
{
	register int i,j;
	long medval;
	LPW pLArray;
	LPW pRArray;
	unsigned int tmp;

	if (level > MAX_RECURSION)
		return E_FAIL;
	i = l;
	j = r;
	medval = *(long far *)(Array + IndexArray[(l + r) / 2]);
	pLArray = IndexArray + l;
	pRArray = IndexArray + r;

	for (;;) {
		while (GREATER_INDEX(medval,  *(long far *)(Array + *pLArray))) {
			i++;
			pLArray ++;
		}
		while (GREATER_INDEX(*(long far *)(Array + *pRArray) , medval)) {
			j--;
			pRArray -- ;
		}
		if (i <= j) {
			tmp = *pLArray;
			*pLArray++ = *pRArray;
			*pRArray-- = (WORD) tmp;
			i++;
			j--;
		}
		else
			break;
	} 
	if (l + INSERTION_SIZE < j ) {
		if (IndexQuickSort (IndexArray, Array, l, j, level + 1) != S_OK)
			return E_FAIL;
	}
	if (i + INSERTION_SIZE < r) {
		if (IndexQuickSort (IndexArray, Array, i, r, level + 1) != S_OK)
			return E_FAIL;
	}
	return S_OK;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	VOID PASCAL NEAR | IndexInsertionSort |
 *		Given an array, the function will perform an insertion sort
 *		To speed up the process:
 *		- The sorting is done "indirectly" through an index array. All
 *		  data movements will be carried on this array, whose elements
 *		  size is DWORD
 *
 *	@parm	LPW	| IndexArray |
 *		Array containing offsets of the unsorted elements of Array
 *
 *	@parm	LPB | Array |
 *		Array containing the values of the elements to be sorted
 *
 *	@parm	int | elemcnt |
 *		Number of elements in the array
 *************************************************************************/
PRIVATE VOID PASCAL NEAR IndexInsertionSort (LPW IndexArray,
	LPB Array, int elemcnt)
{
	int i,j;
	LPW pSortedElem;
	LPW pPrevElem;
	unsigned int index;
	long key;

	for (i = 1; i < elemcnt; i++) {
		j = i - 1;
		pSortedElem = IndexArray + i;
		pPrevElem = pSortedElem - 1;
		key = *(long far *)(Array + (index = *pSortedElem));
		if (GREATER_INDEX(*(long far *)(Array + *pPrevElem) , key)) {

			/* Move everything forward */
			do {
				*pSortedElem-- = *pPrevElem--;
				j--;
			} while (j >= 0 && GREATER_INDEX(*(long far *)(Array+*pPrevElem),
				key));

			/* Do the insertion */
			*pSortedElem = (WORD) index;
		}
	}
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	HRESULT NEAR PASCAL  | SortIndex  |
 *		The function "indirectly" sorts Array. There are two parts:
 *
 *			1/ First, it performs QuickSort 
 *			2/ Then it does an Insertion Sort to the semi-sorted array.
 *
 *		The rational begind the scheme is that we know that QuickSort is
 *		the fastest sorting method for large numbers of data, and Insertion
 *		Sort works best for small amount of data. Since QuickSort partitions
 *		the array into smaller ones, they suit Insertion Sort well. The idea
 *		of applying Insertion Sort to the whole partitioned array is due
 *		to R.Sedgewick, which will save some of the overhead that would be
 *		necessary if we apply straight insertion directly to each small
 *		partition (Knuth).
 *
 *	@parm	LPW  | IndexArray |
 *		Index of indices of the items to be sorted. Since
 *		the size of items to be sorted is usually larger than 2 bytes
 *		using an index array to indirectly sort them will reduce the
 *		time to copy the items during sorting
 *
 *	@parm	LPB  | Array |
 *		Array of items to be sorted. Each items of the array
 *		may be several bytes long. The constraint is that they must
 *		begin with a key (long) to be used in sorting
 *
 *	@parm	int | elemcnt |
 *		The number of elements in the array
 *
 *	@rdesc 
 *		S_OK if everything works. The only time that the sort may fail
 *		is that QuickSort reaches its recursion limit.
 *
 *	@comm
 *		1/ Using Insertion sort combined with QuickSort will improve the
 *		the sorting speed (25% over QuickSort alone)
 *
 *		2/ The size of the partitions affect the speed of Insertion sort.
 *		The maximum profit occurs when the size is about 15. Increase the
 *		size to lower the sort speed, decrease it will cause more recursion
 *		for QuickSort and can adversely affect the speed
 *************************************************************************/
PUBLIC HRESULT PASCAL NEAR IndexSort (LPW IndexArray, LPB Array, int elemcnt)
{
	if (elemcnt > INSERTION_SIZE)  {
		if (IndexQuickSort (IndexArray, Array, 0, elemcnt-1, 1) != S_OK)
			return E_FAIL;
	}
	IndexInsertionSort (IndexArray, Array, elemcnt);
#ifdef TEST
	if (CheckSort (IndexArray, Array, 0, elemcnt - 1))
		return E_FAIL;
#endif
	return S_OK;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	HRESULT PASCAL NEAR | IndexMergeSort |
 *		Give a temp file and an array containing sorted data, the function
 *		performs a merge sort. The resulting sorted data will be written to
 *		a temporary file. To avoid too much I/O and files' handles usage
 *		the old temp file will be replaced by the new one.
 *
 *	@parm	HANDLE FAR * | lphDataFile |
 *		Pointer to handle to temporary file containing sorted data
 *		This handle value will be replaced by the new temp file handle
 *
 *	@parm	LSZ  | lpbDataFileName |
 *		Filename of the temporary input file. It will be replaced by the
 *		new temporary filename
 *
 *	@parm	LPW  | IndexArray |
 *		Array containing offsets of all items to be merged in ElemArry
 *
 *	@parm	LPB  | ElemArray |
 *		Array containing the items to be merged
 *
 *	@parm	int  | ElemSize |
 *		Size of each element
 *
 *	@parm	int  | ElemCnt |
 *		Number of elements in the array
 *
 *	@rdesc 0 if succeeded. If failed, the returned value is the error
 *		number describing the cause of the failure
 *
 *************************************************************************/
PUBLIC HRESULT PASCAL NEAR IndexMergeSort (HFILE FAR *lphDataFile,
	LSZ lpbDataFileName, LPW IndexArray, LPB ElemArray,
	int ElemSize, int ElemCnt)
{
	register int ArrayIndex;
	register WORD cElemRead;
	BYTE   tmpFileName[cbMAX_PATH];
	HFILE  hResFile;			// Result file handle
	LPB    lpbResBuf;			// Result buffer variant ptr
	LPB    lpbResultBuf;		// Result buffer
	LPB    lpbBufLimit;			// Limit of result buffer
	HANDLE hResBuf;				// Handle of result buffer
	LPB    lpbIn;				// Input buffer variant ptr
	LPB    lpbInBuf;			// Input buffer 
	LPB    lpbArray;			// Pointer to ElemArray item
	HANDLE hInBuf;				// Handle of input buffer
	WORD   cbRead;				// Number of bytes read
	WORD   BlockSize;			// Size of a block read
	HRESULT    fRet;				// Return value
	HFILE  hDataFile;			// Handle to data file
#ifdef DOS
	static int nCall = 0;

	nCall ++;
#endif

	/* Allocate a tmp result file */
	(void)GETTEMPFILENAME((char)0, (LSZ)"sor", (WORD)0,
		(LSZ)tmpFileName);

#ifdef DOS
	if ((hResFile = open (tmpFileName, O_CREAT | O_RDWR | O_BINARY,
		S_IWRITE)) == -1)  {
		printf ("Can't create temp file at calls %d\n", nCall);
		return E_FILECREATE;
	}

	/* Rewind the data file */
	if (lseek(hDataFile = *lphDataFile, 0L, 0) == -1) {
		printf ("Can't seek temp file at %d\n", nCall);
		return E_FILESEEK;
	}

	fRet = S_OK;

	/* Allocate result buffer */
	if ((lpbResultBuf = malloc(MERGE_BUF_SIZE)) == 0) {
		printf ("Out of memory for result buffer at calls %d\n", nCall);
		fRet = E_OUTOFMEMORY;

exit01:
		/* Remove temp file */
		if (fRet != S_OK) {
			close(hResFile);
			unlink(tmpFileName);
		}
		return fRet;
	}
	lpbBufLimit = (lpbResBuf = lpbResultBuf) + MERGE_BUF_SIZE - ElemSize;

	/* Allocate input buffer */
	if ((lpbInBuf = malloc(MERGE_BUF_SIZE)) == 0) {
		fRet = E_OUTOFMEMORY;

exit02:
		/* Free memory */
		free(lpbResultBuf);
		goto exit01;
	}
#else
	if ((hResFile = _lcreat (tmpFileName, 0)) == (HFILE)-1)  {
		return E_FILECREATE;
	}
	
	/* Rewind the data file */
	if (_llseek(hDataFile = *lphDataFile, 0L, 0) == (LONG)-1)
		return E_FILESEEK;

	fRet = S_OK;

	/* Allocate result buffer */
	if ((hResBuf = _GLOBALALLOC(DLLGMEM, MERGE_BUF_SIZE)) == 0) {
		fRet = E_OUTOFMEMORY;

exit01:
		/* Remove temp file */
		if (fRet != S_OK) {
			_lclose(hResFile);
			FileUnlink(NULL, tmpFileName, REGULAR_FILE);
		}
		return fRet;
	}
	lpbBufLimit = (lpbResBuf = lpbResultBuf = (LPB)_GLOBALLOCK(hResBuf)) +
		MERGE_BUF_SIZE - ElemSize;

	/* Allocate input buffer */
	if ((hInBuf = _GLOBALALLOC(DLLGMEM, MERGE_BUF_SIZE)) == 0) {
		fRet = E_OUTOFMEMORY;

exit02:
		/* Free memory */
		_GLOBALUNLOCK(hResBuf);
		_GLOBALFREE(hResBuf);
		goto exit01;
	}
	lpbInBuf = _GLOBALLOCK(hInBuf);
#endif // DOS

	BlockSize = (MERGE_BUF_SIZE / ElemSize) * ElemSize;
	ArrayIndex = 0;

	for (;;) {

		/* Read in a block of data */
#ifdef DOS
		if ((cbRead = read(hDataFile, lpbIn = lpbInBuf, BlockSize)) == 0)
			break;	// EOF reached
#else
		if ((cbRead = (WORD) _lread(hDataFile, lpbIn = lpbInBuf, BlockSize)) == 0)
			break;	// EOF reached
#endif

		if (cbRead == (WORD)-1) {	// Read error
			fRet = E_FILEREAD;
			goto exit02;
		}

		cElemRead = cbRead / ElemSize;	// How many elements read in

		/* Perform the sequential merging */

		for (; cElemRead > 0 && ArrayIndex < ElemCnt;) {

			/* Check for room */
			if (lpbResBuf >= lpbBufLimit) {

				/* Flush the buffer */
				if ((fRet = _lwrite(hResFile, lpbResultBuf,
					(WORD)(lpbResBuf - lpbResultBuf))) != S_OK) {
exit03:
					/* Free memory */
#ifdef DOS
					free(lpbInBuf);
#else
					_GLOBALUNLOCK(hInBuf);
					_GLOBALFREE(hInBuf);
#endif
					goto exit02;
				}

				/* Reset variables */
				lpbResBuf = lpbResultBuf;
			}

			/* Perform the comparison */

			if (*(long far *)lpbIn - *(long far *)(lpbArray = ElemArray +
				IndexArray[ArrayIndex]) > 0) {

				/* Input greater than ElemArray item, write ElemArray
				   item, and update index
				*/

				MEMCPY (lpbResBuf, lpbArray, ElemSize);
				ArrayIndex++;
				lpbResBuf += ElemSize;
			}
			else {

				/* Input smaller than ElemArray item, write input
				   item, and update cElemRead
				*/

				MEMCPY (lpbResBuf, lpbIn, ElemSize);
				cElemRead--;
				lpbIn += ElemSize;
				lpbResBuf += ElemSize;
			}
		}

		/* If we exit of the loop, then we run out of data either
		   from ElemArray or lpbInBuf. If it is lpbInBuf, then
		   loop back and read in new data, else break out of the loop
		*/
		if (ArrayIndex >= ElemCnt)
			break;
	}

	/* Flush out whatever is left */
	if (ArrayIndex < ElemCnt) {
		for (; ArrayIndex < ElemCnt;) {
			/* Check for room */
			if (lpbResBuf >= lpbBufLimit) {

				/* Flush the buffer */
				if ((fRet = _lwrite(hResFile, lpbResultBuf,
					(WORD)(lpbResBuf - lpbResultBuf))) != S_OK) 
					goto exit03;

				/* Reset variables */
				lpbResBuf = lpbResultBuf;
			}
			MEMCPY (lpbResBuf, ElemArray + IndexArray[ArrayIndex], ElemSize);
			ArrayIndex++;
			lpbResBuf += ElemSize;
		}
	}
	else {
		/* Flush out what currently in result buffer */
		if ((fRet = _lwrite(hResFile, lpbResultBuf,
			(WORD)(lpbResBuf - lpbResultBuf))) != S_OK) 
			goto exit03;

		/* Reset variables */
		lpbResBuf = lpbResultBuf;

		/* Flush what currently in the input buffer */
		if ((fRet = _lwrite(hResFile, lpbIn, cElemRead * ElemSize)) != S_OK)
			goto exit03;

		/* Copy whatever left in input file to result file */
		for (;;) {
#ifdef DOS
			if ((cbRead = read(hDataFile, lpbInBuf, BlockSize)) == 0)
				break;	// EOF reached
#else
			if ((cbRead = (WORD) _lread(hDataFile, lpbInBuf, BlockSize)) == 0)
				break;	// EOF reached
#endif
			if ((fRet = _lwrite(hResFile, lpbInBuf, cbRead)) != S_OK)
				goto exit03;
		}
	}

	/* Do final flush */
	if ((fRet = _lwrite(hResFile, lpbResultBuf,
		(WORD)(lpbResBuf - lpbResultBuf))) != S_OK) 
		goto exit03;

	/* Close and unlink the old data file */
#ifdef DOS
#ifdef TEST
	CheckSortedFile (hResFile, ElemSize);
#endif
	close(hDataFile);
	unlink(lpbDataFileName);
#else
	_lclose(hDataFile);
	FileUnlink(NULL, lpbDataFileName, REGULAR_FILE);
#endif

	/* Change information about the result file */
	lstrcpy (lpbDataFileName, (LSZ)tmpFileName);
	*lphDataFile = hResFile;
	goto exit03;
}

#if NOTUSED
/*************************************************************************
 *
 *	@doc	INTERNAL INDEXING
 *
 *	@func	PUBLIC int PASCAL FAR | WordRecCompare |
 *		The function compares two records, each having the lfollowing
 *		format:
 *		- A pascal (length-preceded) string
 *		- A series of occurrence' fields, which all have the length
 *		preceded compact format (ie. the 3 hit-bits contains the length
 *		of the number). The number of fields are given by cNumField
 *
 *	@parm	LPB | lpbWRec1 |
 *		Pointer to 1st record
 *
 *	@parm	LPB | lpbWRec2 |
 *		Pointer to 2nd record
 *
 *	@parm	LPB | lpcNumField |
 *		Number of occurrence's fields
 *
 *	@rdesc	The returned values are:
 *		< 0 : lpbWRec1 < lpbWRec2
 *		= 0 : lpbWRec1 = lpbWRec2
 *		> 0 : lpbWRec1 > lpbWRec2
 *
 *	@comm
 *		Due to speed efficiency, no record's validity is checked.
 *
 *************************************************************************/
PUBLIC int PASCAL FAR WordRecCompare (LPB lpbWRec1, LPB lpbWRec2,
	LPB lpcNumField)
{
	register int len;
	int fRet;
	LPB lpStr1, lpStr2;
   register int cNumField;
   
   cNumField = (int) *lpcNumField;
	/* Get pointer to pascal strings */
	lpStr1 = lpbWRec1;
	lpStr2 = lpbWRec2;

	/* Get pointer to occurrence list */
	lpbWRec1 += *lpbWRec1 + 1;
	lpbWRec2 += *lpbWRec2 + 1;

	/* Compare the Pascal string */

	/* Get the minimum length */
	if ((fRet = *lpStr1 - *lpStr2) > 0) 
		len = *lpStr2;
	else 
		len = *lpStr1;

	/* Skip the lengths */
	lpStr1++;
	lpStr2++;

	/* Start compare byte per byte */
	for (; len > 0; len--, lpStr1++, lpStr2++) {
		if (*lpStr1 != *lpStr2)
			break;
	}

	if (len == 0) {
		if (fRet)
			return fRet;
	}
	else {
		return (*lpStr1 - *lpStr2);
	}

	/* Compare the fields */
	do  {
		len = *lpbWRec1 >> 5;
		do {
			if (*lpbWRec1 != *lpbWRec2) {
				return (*lpbWRec1 - *lpbWRec2);
			}
			lpbWRec1++;
			lpbWRec2++;
			len--;
		} while (len >= 0);
		cNumField--;
	} while (cNumField > 0);
	return 0;
}
#endif // NOTUSED

#ifdef TEST
CheckSort (WORD FAR *IndexArray, char far *pArray,
	unsigned int start, unsigned int end)
{
	while (start < end) {
		if (*(long far *)(pArray + IndexArray[start]) >
			*(long far *)(pArray + IndexArray[start+1])) {
			return (1);
		}
		start++;
	}
	return 0;
}

static char *Buffer = NULL;

CheckSortedFile (HANDLE fhandle, int elemsize)
{
	long lastItem = 0;
	char far *lpbBuf;
	int cbRead;
	int Bufsize;

	if (lseek(fhandle, 0L, 0) == (LONG)-1)
		return E_FILESEEK;
	Bufsize = elemsize * 1000;
	if ((Buffer == NULL) && (Buffer = malloc (Bufsize)) == NULL)
		return 1;
	for (;;) {
		if ((cbRead = read (fhandle, Buffer, Bufsize)) <= 0)
			break;
		for (lpbBuf = Buffer; cbRead > 0; cbRead -= elemsize) {
			if (*(long far *)lpbBuf < lastItem) {
				printf ("MergeSort failed: last = %lx, cur= %lx\n",
					lastItem, *(long far *)lpbBuf);
				return 1;
			}
			lastItem = *(long far *)lpbBuf;
			lpbBuf += elemsize;
		}
	}
	return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\groups\groupimp.cpp ===
/*******************************************************
*   @doc SHROOM EXTERNAL API                           *
*                                                      *
*   GROUPIMP.CPP                                       *
*                                                      *
*   Copyright (C) Microsoft Corporation 1997           *
*   All rights reserved.                               *
*                                                      *
*   This file contains CITGroupLocal, the local        *
*   implementation of IITGroup.                        *
*                                                      *
********************************************************
*                                                      *
*   Author: Eric Rynes, with deep debt to Erin Foxford *
*           and her WWIMP.CPP code.                    *
*   Current Owner: a-ericry                            *
*                                                      *
*******************************************************/
#include <mvopsys.h>

#ifdef _DEBUG
static char s_aszModule[] = __FILE__;
#endif

#include <atlinc.h> 	// includes for ATL

// MediaView (InfoTech) includes
#include <groups.h>
#include <wwheel.h>  

#include "ITDB.h"
#include "itww.h"
#include "itquery.h"
#include "itgroup.h"
#include "groupimp.h"
#include <windows.h>
#include <ccfiles.h>

CITGroupLocal::~CITGroupLocal()
{
    Free();
}

/*******************************************************
*                                                     
*   @method STDMETHODIMP | IITGroup | Initiate |      
*                                                     
*   Creates and initializes a group.                  
*                                                     
*   @parm DWORD | lcGrpItem | Maximum number of items in the group.
*   @rvalue S_OK | The group was successfully created and initialized.  
*   @rvalue E_ALREADYINIT | The group already exists.  
*   @rvalue E_OUTOFMEMORY | Insufficient memory available for the operation
*                                                      *
*******************************************************/
STDMETHODIMP CITGroupLocal::Initiate(DWORD lcGrpItem)
{
	HRESULT hr = S_OK; // Note:  GroupInitiate takes phr as an "out" parameter,
	// then sends it to GroupCreate as an "in/out" parameter ("in" when successful).
	// Therefore, it must be initialized to S_OK.

	// Return error if client attempts to re-initiate a group.
	if (NULL != m_lpGroup)
		return E_ALREADYINIT;

    // HACK:  Apparently, groups are not growable by default (at present).
    // Client might need to initiate a group before knowing how many hits
    // s/he will get.  Eventually, the groupcom.c code will be changed to
    // make all groups "growable" by default.
    if (0 == lcGrpItem)
        m_lpGroup = GroupInitiate(LCBITGROUPMAX, &hr);
    else
        m_lpGroup = GroupInitiate(lcGrpItem, &hr);

	return hr;

}

/*******************************************************
*                                                      
*   @method STDMETHODIMP | IITGroup | CreateFromBitVector |
*		Creates a group from a bitvector.
*
*   @parm	LPBYTE | lpBits |
*		Pointer to bitfield
*   @parm   DWORD  | dwSize |
*		Number of bytes in bitfield.
*   @parm   DWORD  | dwItems |
*		Number of items (if not exactly dwSize*8). If dwItems==0, dwSize*8
*		is used.
*
*	@rvalue	S_OK | The group was successfully made from the bitvector
*	@rvalue E_OUTOFMEMORY | There is not enough memory to complete the operation.
*   @rvalue E_ALREADYINIT | The group already exists.
*
*************************************************************************/
STDMETHODIMP CITGroupLocal::CreateFromBitVector(LPBYTE lpBits, DWORD dwSize, DWORD dwItems)
{
    // Currently, GroupMake is not being called.  Before someone calls it,
	// its code should be cleaned up.  Specifically, its HRESULT communication
	// should be resolved, and whatever HRESULT/ERRB it sends to GroupCreate
	// should be initialized to S_OK.

	// Return error if client attempts to re-create a group (GroupMake
	// calls GroupCreate, then GroupTrimmed).
	if (NULL != m_lpGroup)
		return E_ALREADYINIT;

    m_lpGroup = GroupMake(lpBits, dwSize, dwItems);
	// Note:  GroupMake defines its own local ERRB variable, which it sends
	// (by reference) to GroupCreate in the PHRESULT parameter slot.

	return (NULL != m_lpGroup ? S_OK : E_OUTOFMEMORY);
	// GroupMake only calls GroupTrimmed when GroupMake receives a non-NULL
	// group from GroupCreate; when GroupTrimmed receives a non-NULL group,
	// it only returns S_OK or E_OUTOFMEMORY.
}

/*************************************************************************
*
*   @method STDMETHODIMP | IITGroup | CreateFromBuffer |
*      This function creates a group from a buffer.
*
*  @parm   HANDLE | h |
*      Handle to memory buffer containing raw group file data.
*
*  @rdesc  This method returns S_OK when successful. If the group already exists, it returns E_ALREADYINIT.
*       Other error codes are determined by the C function
*       GroupBufferCreate in file groupcom.c.
*
*************************************************************************/
STDMETHODIMP CITGroupLocal::CreateFromBuffer(HANDLE h)
{
	HRESULT hr = S_OK; // Note:  GroupCreate (called by GroupBufferCreate) takes phr
	// as an "in/out" parameter ("in" when successful).  Therefore, it must be
	// initialized to S_OK.

	// Return error if client attempts to re-create a group (GroupBufferCreate
	// calls GroupCreate).
	if (NULL != m_lpGroup)
		return E_ALREADYINIT;

    m_lpGroup = GroupBufferCreate(h, &hr);

	return hr;

}

/***********************************************************************
*
*   @method STDMETHODIMP | IITGroup | Open |
*       Opens the group using IStorage/IStream/GroupBufferCreate.
*
*   @parm IITDatabase* | lpITDB | Database interface pointer.
*   @parm LPCWSTR | lpszMoniker | Storage name.
*
*   @rvalue S_OK | The group was successfully opened from the database.
*   @rvalue E_ALREADYINIT | The group has already been initialized.
*   @rvalue E_FILEREAD | An error occurred reading from the group file.
*   @rvalue E_OUTOFMEMORY | An error occurred while allocating memory for the local buffer.
*   @comm Other error codes might be possible.  See IStorage methods
*       OpenStorage and OpenStream, and IStream methods Stat and Read.
*
***********************************************************************/
STDMETHODIMP CITGroupLocal::Open(IITDatabase* lpITDB, LPCWSTR lpszMoniker)
{
    HRESULT hr;
    IStorage* pSubStorage = NULL;
    IStream*  pStream = NULL;
    STATSTG   statstg;
    HANDLE    hBuffer; // GroupBufferCreate takes a HANDLE to a buffer
    DWORD     dwNumBytesRead = 0; // same type as ULONG,
    LPWSTR    szStorageName;
    // which is returned from pIStream->Read() 

    if (NULL != m_lpGroup)
        return E_ALREADYINIT;

    // Open substorage and pass to group
    szStorageName = new WCHAR [CCH_MAX_OBJ_NAME + CCH_MAX_OBJ_STORAGE + 1];
    WSTRCPY (szStorageName, SZ_GP_STORAGE);
    if (WSTRLEN (lpszMoniker) <= CCH_MAX_OBJ_NAME)
        WSTRCAT (szStorageName, lpszMoniker);
    else
    {
        MEMCPY (szStorageName, lpszMoniker, CCH_MAX_OBJ_NAME * sizeof (WCHAR));
        szStorageName [CCH_MAX_OBJ_NAME + CCH_MAX_OBJ_STORAGE] = (WCHAR)'\0';
    }

	hr = lpITDB->GetObjectPersistence(szStorageName, IITDB_OBJINST_NULL,
										(LPVOID *) &pSubStorage, FALSE);

	delete szStorageName;
    if (FAILED(hr))
        return hr;

    hr = pSubStorage->OpenStream(SZ_GROUP_MAIN, NULL, STGM_READ, 0, &pStream);

    pSubStorage->Release(); // we're done with the storage--release it
    if (FAILED(hr)) // error opening the stream
        return hr;

    hr = pStream->Stat(&statstg, STATFLAG_NONAME); // get the size of the stream
    if (FAILED(hr))
    {
        pStream->Release(); // release the stream
        return hr;
    }

    // allocate memory for statstg.cbSize bytes in hBuffer
    hBuffer = _GLOBALALLOC(GMEM_FIXED | GMEM_ZEROINIT, (statstg.cbSize).LowPart);
    if (NULL == hBuffer)
    {
        pStream->Release(); // release the stream
        return E_OUTOFMEMORY;
    }

    hr = pStream->Read((void *)hBuffer, (statstg.cbSize).LowPart, &dwNumBytesRead);

    pStream->Release(); // we're done with the stream--release it

    if (SUCCEEDED(hr) &&
		dwNumBytesRead != (statstg.cbSize).LowPart)
        hr = E_FILEREAD;

    if (SUCCEEDED(hr))
		m_lpGroup = GroupBufferCreate(hBuffer, &hr);

    _GLOBALFREE(hBuffer);

	return hr;

}

/*********************************************
*
*   @method STDMETHODIMP | IITGroup | Free |
*       Frees the memory allocated for a group.
*
*   @rvalue | S_OK | This method always returns S_OK.
*
*********************************************/
STDMETHODIMP CITGroupLocal::Free(void)
{
	if (NULL != m_lpGroup)
        GroupFree(m_lpGroup);

	m_lpGroup = NULL;
	return S_OK;

}

/*************************************************************************
*
*	@method STDMETHODIMP | IITGroup | CopyOutBitVector |
*		This function copies the bitfield data of one group out to another.
* 
*	@parm	IITGroup* | pIITGroup| 
*		(out) Pointer to destination group.
*
*	@rvalue S_OK | success
*   @rvalue E_NOTINIT | source (member variable) group is NULL
*
*************************************************************************/
STDMETHODIMP CITGroupLocal::CopyOutBitVector(IITGroup* pIITGroup)
{
	if (NULL == m_lpGroup)
		return E_NOTINIT;
 
    return pIITGroup->PutRemoteImageOfGroup(m_lpGroup);
}

/*************************************************************************
*
*  @method STDMETHODIMP | IITGroup | AddItem |
*		This function adds a group item number into the given group.
*
*	@parm	DWORD | dwGrpItem |
*		Group Item to be added into the group. The value of dwGrpItem must be
*		between 0 and 524280
*
*	@rvalue	S_OK | The item was successfully added to the group.
*   @rvalue E_NOTINIT | The group was not initialized, and no item
*       can be added to it.
*
*************************************************************************/
STDMETHODIMP CITGroupLocal::AddItem(DWORD dwGrpItem)
{
    if (NULL == m_lpGroup)
        return E_NOTINIT;

    return GroupAddItem(m_lpGroup, dwGrpItem);
}

/*************************************************************************
*
*	@method STDMETHODIMP | IITGroup | RemoveItem |
*		This function removes a group item number from the given group.
*
*	@parm	DWORD | dwGrpItem |
*		Item to be removed from the group.
*
*	@rvalue	S_OK | The item was successfully removed from the gruop.
*	@rvalue E_NOTINIT | The group was not initialized, and no item
*       can be removed from it.
*
*************************************************************************/
STDMETHODIMP CITGroupLocal::RemoveItem(DWORD dwGrpItem)
{
    if (NULL == m_lpGroup)
        return E_NOTINIT;

    return GroupRemoveItem(m_lpGroup, dwGrpItem);
}

/*************************************************************************
*
*  @method STDMETHODIMP | IITGroup | FindTopicNum |
*      Given a pointer to a group and a count to count from the first
*      topic number of the group (dwCount), this function returns the
*      topic number of the nth (dwCount) item of the list (counting from 0),
*      or -1 if not found
*
*  @parm DWORD | dwCount |
*      The index count in to the group. Count begins at zero.
*
*  @parm LPDWORD | lpdwOutputTopicNum |
*      (out) The topic number, or a pointer to -1 in case of error.
*
*  @rvalue S_OK | The operation completed successfully. 
*  @rvalue S_FALSE | The operation completed successfully, but the list contains fewer than dwCount items. 
*  @rvalue E_INVALIDARG | dwCount <gt>= m_lpGroup-<gt>lcItem
*  @rvalue E_NOTINIT | The target group is NULL. For other errors, see groupcom.c.
* 
*************************************************************************/
STDMETHODIMP CITGroupLocal::FindTopicNum(DWORD dwCount, LPDWORD lpdwOutputTopicNum)
{
	HRESULT hr = S_OK; // initialized just for safety's sake

	// Return error if client attempts to find a topic in a NULL (nonexistent) group.
	if (NULL == m_lpGroup)
		return E_NOTINIT;

	if (dwCount >= m_lpGroup->lcItem)
		return E_INVALIDARG;

    *lpdwOutputTopicNum = GroupFind(m_lpGroup, dwCount, &hr);

    if ((-1 == *lpdwOutputTopicNum) && (SUCCEEDED(hr))) // not found
        return S_FALSE;

	return hr;

}

/*************************************************************************
*
*  @method STDMETHODIMP | IITGroup | FindOffset |
*      Given a pointer to a group and a topic number,
*      this function finds the position of the item in the
*      group that has "dwTopicNum" as a topic number or -1 if error.
*      This is the counter-API of FindTopicNum().
*
*  @parm DWORD | dwTopicNum |
*      The index count in to the group. Count begins at zero.
*
*  @parm LPDWORD | lpdwOutputOffset |
*      (out) The position of the item in the group. In case of error,
*      this parameter returns a pointer to -1. If the dwTopicNum is not part of
*      the group, the rvalue is set to ERR_NOTEXIST and the function
*      returns the closest UID less than dwTopicNum. 
*
*  @rvalue S_OK | The operation completed successfully.
*  @rvalue E_NOTINIT | The target group (member variable) is NULL.
*  @rvalue E_INVALIDARG | dwTopicNum <gt> m_lpGroup-<gt>maxItemAllGroup. 
*
*  @comm   See GroupFindOffset in groupcom.c.
* 
*************************************************************************/
STDMETHODIMP CITGroupLocal::FindOffset(DWORD dwTopicNum, LPDWORD lpdwOutputOffset)
{
	HRESULT hr = S_OK; // initialized just for safety's sake

	// Return error if client attempts to find a position/offset in a NULL (nonexistent) group.
	if (NULL == m_lpGroup)
		return E_NOTINIT;

	if (dwTopicNum > m_lpGroup->maxItemAllGroup)
		return E_INVALIDARG;

    *lpdwOutputOffset = GroupFindOffset(m_lpGroup, dwTopicNum, &hr);

	return hr;

}

/*************************************************************************
*
*  @method STDMETHODIMP | IITGroup | GetSize |
*      This method retrieves the size of the bitvector in private member
*      variable m_lpGroup.
*
*  @parm LPDWORD | lpdwGrpSize |
*      (out) The maxItemAllGroup field of the group structure.
*      The total number of items (on and off) in the group. The
*      group contains no items, either "on" or "off," beyond this position.
*
*  @rvalue S_OK | The operation completed successfully. 
*  @rvalue E_NOTINIT | The group has not been initialized.
* 
*************************************************************************/
STDMETHODIMP CITGroupLocal::GetSize(LPDWORD lpdwGrpSize)
{
    if (NULL == m_lpGroup)
        return E_NOTINIT;

    *lpdwGrpSize = m_lpGroup->maxItemAllGroup;
    return S_OK;
}

/*************************************************************************
*
*	@method STDMETHODIMP | IITGroup | Trim |
*	Trims down the size of the group's bit vector.
*       For example, if the bitvector is all zeroes, the bitvector pointer
*       is set to NULL.
*
*	@rvalue S_OK | the group was successfully trimmed
*	@rvalue E_OUTOFMEMORY | out-of-memory
*   @rvalue E_NOTINIT | the group pointer is NULL
*
*************************************************************************/
STDMETHODIMP CITGroupLocal::Trim(void)
{
	// Return error if client attempts to trim a NULL (nonexistent) group.
	if (NULL == m_lpGroup)
		return E_NOTINIT;

    return GroupTrimmed(m_lpGroup);
}

/*************************************************************************
*
*	@method STDMETHODIMP | IITGroup | And |
*	   The function overwrites the member variable group with a new group
*      resulting from the ANDing of this group with an input group.
*
*	@parm	IITGROUP* | pIITGroup |
*		Interface pointer to the input group.
*
*   @rvalue S_OK | The operation completed successfully. 
*   @rvalue E_NOTINIT | m_lpGroup == NULL
*   @rvalue E_INVALIDARG | The input group is NULL
*
*   @comm See GroupAnd in groupcom.c for additional error conditions.
*   
*************************************************************************/
STDMETHODIMP CITGroupLocal::And(IITGroup* pIITGroup)
{
	HRESULT hr = S_OK;// Note:  GroupCreate (called by GroupCheckAndCreate,
    // within GroupAnd) takes phr as an "in/out" parameter ("in" when successful).
    // Therefore, hr1 must be initialized to S_OK.

	// Return error if client attempts to GroupAnd a NULL (nonexistent) group.
	if (NULL == m_lpGroup)
		return E_NOTINIT;

	if (NULL == pIITGroup)
		return E_INVALIDARG;

	if ((0 == m_lpGroup->maxItemAllGroup) || (0 == m_lpGroup->lcItem))
		return S_OK;

    _LPGROUP lpGroupIn = (_LPGROUP)pIITGroup->GetLocalImageOfGroup(); // access private member var.

    if ((0 == lpGroupIn->maxItemAllGroup) || (0 == lpGroupIn->lcItem))
        return GroupCopy(m_lpGroup, lpGroupIn);

    _LPGROUP ANDed_group = GroupAnd(m_lpGroup, lpGroupIn, &hr); // allocates memory!!

    if (FAILED(hr))
    {
        GroupFree(ANDed_group);
        return hr;
    }

    hr = GroupCopy(m_lpGroup, ANDed_group);
    GroupFree(ANDed_group);
    return hr;

}

/*************************************************************************
*
*	@method STDMETHODIMP | IITGroup | And |
*	   This function creates a new group resulting from the ANDing of the
*      member variable group with an input group.
*
*	@parm	IITGroup* | pIITGroupIn |
*		(in) Interface pointer to the input group.
*
*	@parm	IITGroup* | pIITGroupOut |
*		(out) Interface pointer to the output group. 
*
*   @rvalue S_OK | The operation completed successfully.
*   @rvalue E_NOTINIT | m_lpGroup == NULL
*   @rvalue E_INVALIDARG | The input group is NULL
*
*   @comm See GroupAnd in groupcom.c for additional error conditions.
*   
*************************************************************************/
STDMETHODIMP CITGroupLocal::And(IITGroup* pIITGroupIn, IITGroup* pIITGroupOut)
{
	HRESULT hr = S_OK;// Note:  GroupCreate (called by GroupCheckAndCreate,
    // within GroupAnd) takes phr as an "in/out" parameter ("in" when successful).
    // Therefore, it must be initialized to S_OK.

	// Return error if client attempts to GroupAnd a NULL (nonexistent) group.
	if (NULL == m_lpGroup)
		return E_NOTINIT;

	if (NULL == pIITGroupIn)
		return E_INVALIDARG;


	if ((0 == m_lpGroup->maxItemAllGroup) || (0 == m_lpGroup->lcItem))
        return pIITGroupOut->PutRemoteImageOfGroup(m_lpGroup);

    _LPGROUP lpGroupIn = (_LPGROUP)pIITGroupIn->GetLocalImageOfGroup(); // access private member var.

	if ((0 == lpGroupIn->maxItemAllGroup) || (0 == lpGroupIn->lcItem))
    {
        if (pIITGroupOut == pIITGroupIn)
            return S_OK;// avoid the overhead of the function call;
                        // client called a->And(b,b), which is equivalent to b->And(a)

     	return pIITGroupOut->PutRemoteImageOfGroup(lpGroupIn);
    }

    _LPGROUP ANDed_group = GroupAnd(m_lpGroup, lpGroupIn, &hr); // allocates memory!!

    if (FAILED(hr))
    {
        GroupFree(ANDed_group);
        return hr;
    }

    hr = pIITGroupOut->PutRemoteImageOfGroup(ANDed_group);
    GroupFree(ANDed_group);
    return hr;

}

/*************************************************************************
*
*	@method STDMETHODIMP | IITGroup | Or |
*		This function overwrites the member variable group with a new group
*       resulting from the ORing of this group with an input group.
*
*	@parm	IITGroup* | pIITGroup |
*		Interface pointer to the input group
*
*   @rvalue S_OK | The operation completed successfully.
*   @rvalue E_NOTINIT | m_lpGroup == NULL
*   @rvalue E_INVALIDARG | input group is NULL
*
*   @comm See GroupOr in groupcom.c for additional error conditions.
*
*************************************************************************/
STDMETHODIMP CITGroupLocal::Or(IITGroup* pIITGroup)
{
	HRESULT hr = S_OK; // Note:  GroupCreate (called by GroupOr)
    // takes phr as an "in/out" parameter ("in" when successful).  Therefore, it must
    // be initialized to S_OK.

	// Return error if client attempts to GroupOr a NULL (nonexistent) group.
	if (NULL == m_lpGroup)
		return E_NOTINIT;

	if (NULL == pIITGroup)
		return E_INVALIDARG;

    _LPGROUP lpGroupIn = (_LPGROUP)pIITGroup->GetLocalImageOfGroup();

	if ((0 == m_lpGroup->maxItemAllGroup) || (0 == m_lpGroup->lcItem))
        return GroupCopy(m_lpGroup, lpGroupIn); // copy lpGroupIn's bits into m_lpGroup

	if ((0 == lpGroupIn->maxItemAllGroup) || (0 == lpGroupIn->lcItem))
        return S_OK;

    _LPGROUP ORed_group = GroupOr(m_lpGroup, lpGroupIn, &hr); // allocates memory!!

    if (FAILED(hr))
    {
        GroupFree(ORed_group);
        return hr;
    }

    hr = GroupCopy(m_lpGroup, ORed_group);
    GroupFree(ORed_group);
    return hr;

}

/*************************************************************************
*
*	@method STDMETHODIMP | IITGroup | Or |
*	   This function creates a new group resulting from the ORing of the
*      member variable group with an input group.
*
*	@parm	IITGroup* | pIITGroupIn |
*		(in) Interface pointer to the input group. 
*
*	@parm	IITGroup* | pIITGroupOut |
*		(out) Interface pointer to the output group.
*
*   @rvalue S_OK | The operation completed successfully.
*   @rvalue E_NOTINIT | m_lpGroup is equal to NULL
*   @rvalue E_INVALIDARG | The input group is NULL
*
*   @comm See GroupOr in groupcom.c for additional error conditions.
*
*************************************************************************/
STDMETHODIMP CITGroupLocal::Or(IITGroup* pIITGroupIn, IITGroup* pIITGroupOut)
{
	HRESULT hr = S_OK;// Note:  GroupCreate (called by GroupDuplicate)
    // takes phr as an "in/out" parameter ("in" when successful).  Therefore, it
    // must be initialized to S_OK.

	// Return error if client attempts to GroupOr a NULL (nonexistent) group.
	if (NULL == m_lpGroup)
		return E_NOTINIT;

	if (NULL == pIITGroupIn)
		return E_INVALIDARG;

    _LPGROUP lpGroupIn = (_LPGROUP)pIITGroupIn->GetLocalImageOfGroup(); // access private member var.

	if ((0 == m_lpGroup->maxItemAllGroup) || (0 == m_lpGroup->lcItem))
        return pIITGroupOut->PutRemoteImageOfGroup(lpGroupIn);

	if ((0 == lpGroupIn->maxItemAllGroup) || (0 == lpGroupIn->lcItem))
        return pIITGroupOut->PutRemoteImageOfGroup(m_lpGroup);

    _LPGROUP ORed_group = GroupOr(m_lpGroup, lpGroupIn, &hr); // allocates memory!!

    if (FAILED(hr))
    {
        GroupFree(ORed_group);
        return hr;
    }

	hr = pIITGroupOut->PutRemoteImageOfGroup(ORed_group);
    GroupFree(ORed_group);
    return hr;

}

/*************************************************************************
*
*	@method STDMETHODIMP | IITGroup | Not |
*		This function overwrites the member variable group with the
*       "NOT" of itself.
*
*   @rvalue S_OK | The operation completed successfully.
*   @rvalue E_NOTINIT | m_lpGroup is equal to NULL
*
*   @comm See GroupNot in groupcom.c for additional error conditions.
*
*************************************************************************/
STDMETHODIMP CITGroupLocal::Not(void)
{
	HRESULT hr = S_OK;

	if (NULL == m_lpGroup)
		return E_NOTINIT;

	if ((0 == m_lpGroup->maxItemAllGroup) || (0 == m_lpGroup->lcItem))
		return S_OK;

    _LPGROUP NOTed_group = GroupNot(m_lpGroup, &hr); // allocates memory!!

    if (FAILED(hr))
    {
        GroupFree(NOTed_group);
        return hr;
    }

    hr = GroupCopy(m_lpGroup, NOTed_group);
    GroupFree(NOTed_group);
    return hr;

}

/*************************************************************************
*
*	@method STDMETHODIMP | IITGroup | Not |
*	   This function creates a new group equalling the "NOT"
*      of the member variable group.
*
*	@parm	IITGroup* | pIITGroupOut |
*		(out) Pointer to the output group.
*
*   @rvalue S_OK | The operation completed successfully.
*   @rvalue E_NOTINIT | m_lpGroup is equal to NULL
*
*   @comm See GroupOr in groupcom.c for additional error conditions.
*
*************************************************************************/
STDMETHODIMP CITGroupLocal::Not(IITGroup* pIITGroupOut)
{
	HRESULT hr = S_OK;

	if (NULL == m_lpGroup)
		return E_NOTINIT;

	if ((0 == m_lpGroup->maxItemAllGroup) || (0 == m_lpGroup->lcItem))
		return pIITGroupOut->PutRemoteImageOfGroup(m_lpGroup);

    _LPGROUP NOTed_group = GroupNot(m_lpGroup, &hr); // allocates memory!!

    if (FAILED(hr))
    {
        GroupFree(NOTed_group);
        return hr;
    }

    hr = pIITGroupOut->PutRemoteImageOfGroup(NOTed_group);
    GroupFree(NOTed_group);
	return hr;

}

/****************************************************
*
*   @method STDMETHODIMP | IITGroup | IsBitSet |
*
*   Determines whether the bit is set for the topic number
*   in question.
*
*   @parm DWORD | dwTopicNum | Query's topic number
*
*   @rvalue S_OK | true (bit is set)
*   @rvalue S_FALSE | false (bit is not set)
*
****************************************************/
STDMETHODIMP CITGroupLocal::IsBitSet(DWORD dwTopicNum)
{
	if (NULL == m_lpGroup)
		return E_NOTINIT;

    BOOL fRet = GroupIsBitSet(m_lpGroup, dwTopicNum);

	return (FALSE == fRet ? S_FALSE : S_OK);

}

/**********************************************************************************
*                                                                                 
*   @method STDMETHODIMP | IITGroup | CountBitsOn |                               
*                                                                                 
*   Determines the number of items in the group which are set (on).              
*                                                                                 
*   @parm LPDWORD | lpdwTotalNumBitsOn | (out) The number of items in the group which are set (on). 
*                                                                                 
*   @rvalue S_OK | This method always returns S_OK.                          
*                                                                                 
**********************************************************************************/
STDMETHODIMP CITGroupLocal::CountBitsOn(LPDWORD lpdwTotalNumBitsOn)
{
    *lpdwTotalNumBitsOn = LrgbBitCount(m_lpGroup->lpbGrpBitVect,
        m_lpGroup->dwSize);
	return S_OK;
}

/**********************************************************************************
*                                                                                
*   @method STDMETHODIMP | IITGroup | Clear|		                              
*                                                                                 
*   Sets all bits in the group to zero. This method turns all items "off" in a group. 
*   It is equivalent to calling RemoveItem on every item in the group. The group 
*   remains initialized, and its size (which can be retrieved using GetSize) remains 
*   unchanged. The memory owned by the group remains unchanged.
*                                                                                 
*   @rvalue E_OUTOFMEMORY | The group could not be manipulated because of
*   low memory conditions.
*   @rvalue S_OK | The operation was performed successfully .                      
*                                                                                 
**********************************************************************************/
STDMETHODIMP CITGroupLocal::Clear(void)
{
	HRESULT hr;

	if (NULL == m_lpGroup)
		return E_NOTINIT;

	if (m_lpGroup->lcItem > 0)
		MEMSET(m_lpGroup->lpbGrpBitVect, 0, (DWORD)m_lpGroup->dwSize);

    // add an item to the end of the group, which will
    // cause the group to be allocated to its full size.
    if (FAILED(hr = GroupAddItem(m_lpGroup, m_lpGroup->maxItemAllGroup - 1)))
        return hr;
    // this can only fail if we pass NULL.
    // fortunately, GroupRemoveItem does not trim the group.
    GroupRemoveItem(m_lpGroup,m_lpGroup->maxItemAllGroup - 1);
    m_lpGroup->lcItem  = 0;
    m_lpGroup->minItem = m_lpGroup->maxItem = 0;
    m_lpGroup->nCache  = 0;

    return S_OK;

}

/**********************************************************
*                                                         
*   @method _LPGROUP | IITGroup | GetLocalImageOfGroup |  
*                                                         
*   Returns an LPVOID pointer to an actual group (not an ITGroup).   
*   
*                                                         
*   @rvalue m_lpGroup | This method always returns an LPVOID pointer 
*    to the group. This pointer can be NULL. 
*   @comm This method will not work for group operations between  
*   different machines. A new version of GetLocalImageOfGroup needs 
*   to be created to handle the HTTP case.                    
*                                                         
**********************************************************/
STDMETHODIMP_(LPVOID) CITGroupLocal::GetLocalImageOfGroup(void)
{
    return (LPVOID)m_lpGroup;
}

/*************************************************************
*                                                           
*   @method _LPGROUP | IITGroup | PutRemoteImageOfGroup |    
*       Copies the bits from the input group into the        
*       private member variable group.  If the latter is     
*       NULL, space is allocated for it using the        
*       GroupDuplicate function in groupcom.c.               
*                                                            
*   @parm _LPGROUP | lpGroupIn |                             
*       The input group being assigned to the private        
*       member variable group.                               
*                                                            
*   @rvalue S_OK | The input group was successfully assigned.         
*   @rvalue E_INVALIDARG | The input group is a NULL pointer.
*   @comm See GroupDuplicate, GroupCopy in groupcom.c for    
*           any other possible return values.                
*                                                            
*************************************************************/
STDMETHODIMP CITGroupLocal::PutRemoteImageOfGroup(LPVOID lpGroupIn)
{
    HRESULT hr = S_OK; // Note:  GroupDuplicate takes phr as an "out" parameter,
	// then sends it to GroupCreate as an "in/out" parameter ("in" when successful).
	// Therefore, it must be initialized to S_OK.

    if (NULL == lpGroupIn)
        return E_INVALIDARG;

    if (NULL != m_lpGroup)
        return GroupCopy(m_lpGroup, (_LPGROUP)lpGroupIn); // simply copy the bitvector

    // NULL == m_lpGroup -- allocate memory for the group, initialize it
    m_lpGroup = GroupDuplicate((_LPGROUP)lpGroupIn, &hr);

    return hr;
}



/////////// GroupArray methods

STDMETHODIMP_(LPVOID) CITGroupArrayLocal::GetLocalImageOfGroup(void)
{
	HRESULT hr;

	// recalculate the group
	if (NULL == m_pGroup)
	{
		hr = CoCreateInstance(CLSID_IITGroupLocal, NULL, CLSCTX_INPROC_SERVER, 
				IID_IITGroup, (VOID **)&m_pGroup);
		if (FAILED(hr))
			return NULL;

		// passing LCBITGROUPMAX means a dynamically sized group
		if (!m_pGroup || FAILED(m_pGroup->Initiate(1)))
			return NULL;
	}

	ITASSERT(m_pGroup);
	if (m_fDirty)
	{
		DWORD dwT;
		int i;

		m_pGroup->Clear();
		for (i = 0, dwT = 1L; i < m_iEntryMax; i++, dwT <<= 1)
			if (dwT & m_rgfEntries)
			{
				if (m_iDefaultOp == ITGP_OPERATOR_AND)
					m_pGroup->And(m_rgpGroup[i]);
				else
					m_pGroup->Or(m_rgpGroup[i]);
			}

		m_fDirty = FALSE;
	}
	if (m_pGroup)
		return (LPVOID)(m_pGroup->GetLocalImageOfGroup());

	return NULL;
}

CITGroupArrayLocal::~CITGroupArrayLocal()
{
	DWORD dwT;
	int i;

	if (m_pGroup)
	{
		m_pGroup->Release();
		m_pGroup = NULL;
	}

	// now free all the groups we allocated in the array
	for (i = 0, dwT = 1L; i < m_iEntryMax; i++, dwT <<= 1)
		if (m_rgpGroup[i])
			m_rgpGroup[i]->Release();
}

/********************************************************************
 * @method    STDMETHODIMP | IITGroupArray | InitEntry |
 *     Adds a group to the group array
 * @parm IITDatabase* | piitDB | Pointer to the database object.
 * @parm LPCWSTR | lpszName | Name of group in the database to add.
 * @parm LONG& | lEntryNum | (out) The index of the new array
 * element.
 *
 * @rvalue E_OUTOFRANGE | No more array entries can be created.  The maximum is
 * ITGP_MAX_GROUPARRAY_ENTRIES
 * @rvalue E_BADPARAM | piitDB or lpszName was NULL
 * @rvalue E_GETLASTERROR | An I/O or transport operation failed.  Call the Win32
 * GetLastError function to retrieve the error code.
 * @rvalue STG_E_* | Any of the IStorage errors that could while opening a storage
 * @rvalue S_OK | The group was successfully opened
 * @comm When you call InitEntry, it doesn't mark the array entry as "set", it
 * just initializes a new array entry with the given group data and returns the index of
 * the new array entry.  All the group array
 * entries are initially "clear" until you set them with SetEntry.  Also, the default operator
 * for IITGroupArray is ITGP_OPERATOR_OR, the OR operator.
 *
 ********************************************************************/
STDMETHODIMP CITGroupArrayLocal::InitEntry(IITDatabase *piitDB, LPCWSTR lpwszName, LONG& lEntryNum)
{
	IITGroup *piitGroup;
	HRESULT hr;

	if (NULL == piitDB || NULL == lpwszName)
		return E_BADPARAM;

	if (m_iEntryMax >= ITGP_MAX_GROUPARRAY_ENTRIES - 1)
		return E_OUTOFRANGE;

	// open and add to the current array
	// UNDONE: this isn't as efficient as it could be
	hr = CoCreateInstance(CLSID_IITGroupLocal, NULL, CLSCTX_INPROC_SERVER, 
			IID_IITGroup, (VOID **)&piitGroup);

	if (FAILED(hr))
		return hr;

	m_rgpGroup[m_iEntryMax] = piitGroup;
	if (NULL == piitGroup)
		return E_OUTOFMEMORY;

	if (S_OK == (hr = piitGroup->Open(piitDB, lpwszName)))
	{
		lEntryNum = m_iEntryMax++;
		return S_OK;
	}

	piitGroup->Release();
	m_rgpGroup[m_iEntryMax] = NULL;

	return hr;
}
/********************************************************************
 * @method    STDMETHODIMP | IITGroupArray | InitEntry |
 *     Adds a group to the group array
 * @parm IITGroup* | piitGroup | Pointer to caller-owned group object
 * @parm LONG& | lEntryNum | (out) The index of the new array
 * element.
 *
 * @rvalue E_OUTOFRANGE | No more array entries can be created.  The maximum is
 * ITGP_MAX_GROUPARRAY_ENTRIES
 * @rvalue E_BADPARAM | piitGroup was NULL
 * @rvalue E_GETLASTERROR | An I/O or transport operation failed.  Call the Win32
 * GetLastError function to retrieve the error code.
 * @rvalue STG_E_* | Any of the IStorage errors that could occur while opening a storage.
 * @rvalue S_OK | The group was successfully opened.
 * @comm This must be the first method called after the object is instantiated.
 * When you call InitEntry, it doesn't mark the array entry as "set", it
 * just initializes a new array entry with the given group data and returns the index of
 * the new array entry.  All the group array
 * entries are initially "clear" until you set them with SetEntry.  Also, the default operator
 * for IITGroupArray is ITGP_OPERATOR_OR, the OR operator.
 *
 ********************************************************************/
STDMETHODIMP CITGroupArrayLocal::InitEntry(IITGroup *piitGroup, LONG& lEntryNum)
{
	if (m_iEntryMax >= ITGP_MAX_GROUPARRAY_ENTRIES - 1)
		return E_OUTOFRANGE;
	if (NULL == piitGroup)
		return E_BADPARAM;

	m_rgpGroup[m_iEntryMax] = piitGroup;
	piitGroup->AddRef();

	lEntryNum = m_iEntryMax++;
	return S_OK;
}

/********************************************************************
 * @method    STDMETHODIMP | IITGroupArray | SetEntry |
 *     Turns on the array element corresponding to the given entry number
 * @parm LONG | lEntryNum | The index into the array to mark as "on"
 *
 * @rvalue E_OUTOFRANGE | The given array index is too large
 * @rvalue S_OK | The operation completed successfully
 *
 ********************************************************************/
STDMETHODIMP CITGroupArrayLocal::SetEntry(LONG lEntryNum)
{
	DWORD dwT;

	if (lEntryNum >= m_iEntryMax)
		return E_OUTOFRANGE;

	if (lEntryNum == ITGP_ALL_ENTRIES)
	{
		m_rgfEntries = 0xFFFFFFFF;
		m_fDirty = TRUE;
		return S_OK;
	}

	dwT = 1L << lEntryNum;
	m_fDirty = !(m_rgfEntries & dwT);
	m_rgfEntries |= dwT;
	
	return S_OK;
}

/********************************************************************
 * @method    STDMETHODIMP | IITGroupArray | ClearEntry |
 *     Turns off the array element corresponding to the given entry number
 * @parm LONG | lEntryNum | The index into the array to mark as "off"
 *
 * @rvalue E_OUTOFRANGE | The given array index is too large
 * @rvalue S_OK | The operation was completed successfully
 *
 ********************************************************************/
STDMETHODIMP CITGroupArrayLocal::ClearEntry(LONG lEntryNum)
{
	DWORD dwT;

	if (lEntryNum >= m_iEntryMax)
		return E_OUTOFRANGE;

	if (lEntryNum == ITGP_ALL_ENTRIES)
	{
		m_rgfEntries = 0L;
		m_fDirty = TRUE;
		return S_OK;
	}

	dwT = 1L << lEntryNum;
	m_fDirty = !!(m_rgfEntries & dwT);
	m_rgfEntries &= ~dwT;
	
	return S_OK;
}

/********************************************************************
 * @method    STDMETHODIMP | IITGroupArray | SetDefaultOp |
 *     Set the default operator to be used between all the entries
 * in the group array.
 * @parm LONG | iDefaultOp | One of ITGP_OPERATOR_OR, ITGP_OPERATOR_AND
 *
 * @rvalue E_BADPARAM | An invalid operator was specified
 * @rvalue S_OK | The operation completed successfully
 *
 * @comm The default operator is used when the group array is treated
 * as an ordinary group by other objects.  In that case, the group array
 * appears to be a single group consisting of all the groups specified
 * with each entry, and OR'd r AND'd together.  Only one operator at a time
 * can be applied, and it must apply to all entries in the array.  To
 * perform more complex filter operations you can create group arrays using
 * other group arrays.
 ********************************************************************/
STDMETHODIMP CITGroupArrayLocal::SetDefaultOp(LONG iDefaultOp)
{
	if (iDefaultOp > ITGP_OPERATOR_AND)
		return E_BADPARAM;

	if (iDefaultOp != m_iDefaultOp)
	{
		m_iDefaultOp = iDefaultOp;
		m_fDirty = TRUE;
	}
	return S_OK;
}

/********************************************************************
 * @method    STDMETHODIMP | IITGroupArray | ToString |
 *     Returns a string representation of the group array.
 *
 * @parm LPWSTR * | ppwBuffer | (out) The string representation of the group array.
 *
 * @rvalue E_NOTIMPL | This method is currently only implemented for the HTTP
 * transport layer.
 * @rvalue S_OK | The operation completed successfully.
 *
 * @comm NOTE: This method is currently only implemented for the HTTP transport layer.
 *
 * The ToString method will allocate the memory for the returned string.
 * The caller must call CoTaskMemFree on the returned pointer when
 * finished with the string.
 *
 * The format of the string is:
 *		<lt>opcode-0<gt><lt>group-0<gt><lt>opcode-1<gt><lt>group-1<gt>...<lt>opcode-N<gt><lt>group-N<gt>
 *
 * where <lt>opcode-N<gt> is one of '&' (AND), '+' (OR) and
 * where <lt>group-N<gt> is the string representing the N-th entry in the group array. 
 * If the entry is itself a group array, the entry is delimited by [ and ].
 *
 * For example: &media1&media2&[+book1+book4+book9].
 *
 * Currently, it is assumed all the groups named in the string belong to the same
 * database.
 *
 ********************************************************************/
STDMETHODIMP CITGroupArrayLocal::ToString(LPWSTR *ppwBuffer)
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\groups\groupcom.c ===
/*************************************************************************
*                                                                        *
*  GROUPCOM.C                                                            *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   This module contains miscellaneous functions that are shared         *
*	 between index and search. Those modules can be related to stop      *
*   words, groups, word wheels, catalogs, etc. The purpose is to         *
*   share as much code as possible                                       *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: GarrG                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Released by Development:     (date)                                   *
*                                                                        *
*************************************************************************/

#include <verstamp.h>
SETVERSIONSTAMP(MVUT);

#include <mvopsys.h>
#include <misc.h>
#include <mem.h>
#include <iterror.h>
#include <wrapstor.h>
#include <mvsearch.h>
#include <groups.h>
#include <orkin.h>
#include <_mvutil.h>    // File System



#ifdef _DEBUG
static char s_aszModule[] = __FILE__;	// Used by error return functions.
#endif

#define	cbitWORD		(CBIT)16	   // Number of bits in a word.
#define	cbitBYTE		(CBIT)8		// Number of bits in a byte.

#define SETERR(a,b) (*a=b)

/*************************************************************************
 *
 *	                  INTERNAL PRIVATE FUNCTIONS
 *	All of them should be declared near
 *************************************************************************/

static _LPGROUP NEAR PASCAL GroupCheckAndCreate(_LPGROUP, _LPGROUP, PHRESULT);
static BOOL NEAR PASCAL GroupCheck (_LPGROUP lpGroup);

static int PASCAL NEAR HiBitSet (BYTE c)
{
	register int cBit = 7;
	
	while ((c & 128) == 0) 
	{
		c <<= 1;
		cBit--;
	}
	return cBit;
}

static int PASCAL NEAR LoBitSet (BYTE c)
{
	register int cBit = 0;
	
	while ((c & 1) == 0) 
	{
		c >>= 1;
		cBit++;
	}
	return cBit;
}


/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	BOOL NEAR PASCAL | GroupCheck |
 *		This function will check the validity of a given group
 *
 *	@parm	_LPGROUP | lpGroup |
 *		Pointer to group
 *
 *	@rdesc	Return S_OK if valid group, fail otherwize
 *************************************************************************/
static BOOL NEAR PASCAL GroupCheck (_LPGROUP lpGroup)
{
// Changing to a MACRO
//	if (lpGroup == NULL ||
//		(lpGroup->version < 7 || lpGroup->version > GROUPVER) ||
//		lpGroup->FileStamp != GROUP_STAMP)
//		return ERR_FAILED;
//	return S_OK;
    VALIDATE_GROUP(lpGroup);
}



/*************************************************************************
 *	@doc	API INDEX RETRIEVAL
 *
 *	@func	LPGROUP FAR PASCAL | GroupInitiate |
 *		This function creates and initializes a new group. The size of the
 *		group is based on the total number of items
 *
 *	@parm 	DWORD | lcGrpItem |
 *		The maximum number of items in the group. If lcGrpItem is equal
 *		to ITGROUPMAX, then the size of the group will grow
 *		as necessary to fit the GrpItem (up to that limit)
 *
 *	@parm	PHRESULT | phr |
 *		Error buffer
 *
 *	@rdesc	The function will return a pointer to the newly created group
 *		if succeeded, NULL otherwise. The error buffer will contain
 *		information about the cause of the failure
 *
 *************************************************************************/
PUBLIC	_LPGROUP FAR PASCAL GroupInitiate(DWORD lcGrpItem, PHRESULT phr)
{
	_LPGROUP lpGroup;
	DWORD size;
	BYTE fGroupExpandable;

	/* Check to see if ther are too many GrpItem or not */

	if (lcGrpItem > LCBITGROUPMAX) 
	{
		SetErrCode(phr, E_GROUPIDTOOBIG);
		return NULL;
	}

	if (fGroupExpandable = (BYTE)(lcGrpItem == LCBITGROUPMAX)) 
	{
		/* Expandable bitvector, start with one block */
		size = GROUP_BLOCK_SIZE;
	}
	else 
	{
		size = ((lcGrpItem + cbitBYTE - 1) / cbitBYTE) * sizeof(BYTE);
	}

	if ((lpGroup = GroupCreate(size, lcGrpItem, phr)) == NULL)
		return NULL;

	if (fGroupExpandable) 
	{
		lpGroup->wFlag |= GROUP_EXPAND;
		lpGroup->maxItem = 0;
	}
	else
		lpGroup->maxItem = lcGrpItem;
	lpGroup->minItem = LCBITGROUPMAX;
	return lpGroup;
}

/*************************************************************************
 *	@doc	API INDEX RETRIEVAL
 *
 *	@func	ERR FAR PASCAL | GroupAddItem |
 *		This function will add a group item number into the given group
 *
 *	@parm	LPGROUP | lpGroup |
 *		Pointer to group
 *
 *	@parm	DWORD | dwGrpItem |
 *		Group Item to be added into the group. The value must be
 *			0 << dwGrpItem < 524280
 *
 *	@rdesc	S_OK if succeeded. The function can fail if the GrpItem
 *		value is too large, ie. exceed the maximum value preset in
 *		lpGroup when calling GroupInitiate()
 *
 *	@xref	GroupInitiate()
 *************************************************************************/

PUBLIC	ERR FAR PASCAL GroupAddItem(_LPGROUP lpGroup,
	DWORD dwGrpItem)
{
	HANDLE hBitVect;
	DWORD size;
	BYTE bitSet;
	LPBYTE lpb;

	if (lpGroup == NULL) /* Safeguard check */
		return E_INVALIDARG;	// Bad argument

	if (dwGrpItem > LCBITGROUPMAX)
		return E_GROUPIDTOOBIG;

	if (dwGrpItem >= lpGroup->dwSize * cbitBYTE) 
	{
		if ((lpGroup->wFlag & GROUP_EXPAND) == 0)
			return E_GROUPIDTOOBIG;

		/* The BitVect needs to grow. Calculate the next needed size */
		size = ((dwGrpItem / (cbitBYTE * GROUP_BLOCK_SIZE)) + 1) * GROUP_BLOCK_SIZE;

		if (lpGroup->hGrpBitVect)
		{
			_GLOBALUNLOCK(lpGroup->hGrpBitVect);

			if ((hBitVect = lpGroup->hGrpBitVect =
				_GLOBALREALLOC(lpGroup->hGrpBitVect, size,
				DLLGMEM_ZEROINIT)) == NULL) 
				return E_OUTOFMEMORY;
		}
		else
		{
			if ((hBitVect = lpGroup->hGrpBitVect =
				_GLOBALALLOC(DLLGMEM_ZEROINIT,size))==NULL)
				return E_OUTOFMEMORY;
		}
		lpGroup->lpbGrpBitVect = (LPBYTE)_GLOBALLOCK(hBitVect);
		lpGroup->dwSize = size;
	}

	if (lpGroup->maxItemAllGroup <= dwGrpItem)
		lpGroup->maxItemAllGroup =  dwGrpItem+1;

	if (dwGrpItem > lpGroup->maxItem)
		lpGroup->maxItem = dwGrpItem;

	if (dwGrpItem < lpGroup->minItem)
		lpGroup->minItem = dwGrpItem;

	/* Set the bit */
	lpb = &lpGroup->lpbGrpBitVect[(UINT)(dwGrpItem / 8)];
	bitSet = 1 << (dwGrpItem % 8);

	if ((*lpb & bitSet) == 0) 
	{
		*lpb |= bitSet;
		lpGroup->lcItem ++;
	}

	lpGroup->nCache = 0;
	return S_OK;
}

/*************************************************************************
 *
 *	@doc	API INDEX RETRIEVAL
 *
 *	@func	ERR FAR PASCAL | GroupRemoveItem |
 *		This function will remove a group item number from the given group
 *
 *	@parm	LPGROUP | lpGroup |
 *		Pointer to group. Must be non-null
 *
 *	@parm	DWORD | dwGrpItem |
 *		Group Item to be removed from group.
 *
 *	@rdesc	S_OK if succeeded. The function can fail for bad argument
 *		(lpGroup == NULL)
 *
 *	@xref	GroupInitiate()
 *************************************************************************/

PUBLIC ERR FAR PASCAL GroupRemoveItem(_LPGROUP lpGroup,
	DWORD dwGrpItem)
{
	LPBYTE lpb;
	BYTE bitSet;

	if (lpGroup == NULL) /* Safeguard check */
		return E_INVALIDARG;	// Bad argument

	if (dwGrpItem < lpGroup->minItem || dwGrpItem > lpGroup->maxItem)
		return S_OK;

	/* Unset the bit */
	lpb = &lpGroup->lpbGrpBitVect[(UINT)(dwGrpItem / 8)];
	bitSet = (1 << (dwGrpItem % 8));
	
	/* Only update the bitvector and the item count if that item exists */
	if (*lpb & bitSet) 
	{
		*lpb &= ~bitSet;
		lpGroup->lcItem--;
	}
	lpGroup->nCache = 0;
	return S_OK;
}

/*************************************************************************
 *	@doc	API INDEX RETRIEVAL
 *
 *	@func	LPGROUP FAR PASCAL | GroupCreate |
 *		This function will create a new group according to the
 *		group size
 *
 *	@parm	DWORD | size |
 *		Size of group. In case the size is unknown, it should be set to be
 *		(dwMaxItemAllGroup / 8)
 *
 *	@parm	DWORD | dwMaxItemAllGroup |
 *		Maximum group item value that a set of group can have
 *
 *	@parm	PHRESULT | phr |
 *		Error buffer
 *
 *	@rdesc	The function will return a pointer to the newly created group
 *		if succeeded, NULL otherwise. The error buffer will contain
 *		information about the cause of the failure
 *************************************************************************/

PUBLIC _LPGROUP FAR PASCAL GroupCreate (DWORD size,
	DWORD dwMaxItemAllGroup, PHRESULT phr)
{
	HANDLE handle;
	_LPGROUP lpGroup;

	/* Allocate structure */
	if ((handle = _GLOBALALLOC(DLLGMEM_ZEROINIT,
		sizeof(_GROUP))) == NULL) 
	{
		SetErrCode(phr, E_OUTOFMEMORY);
		return NULL;
	}

	lpGroup = (_LPGROUP)_GLOBALLOCK(handle);
	lpGroup->dwSize = size;
	lpGroup->maxItemAllGroup = dwMaxItemAllGroup;
	lpGroup->hGroup = handle;
	lpGroup->FileStamp = GROUP_STAMP;
	lpGroup->version = GROUPVER;

	/* Allocate group BitVect */
    // +1 is added as a bug fix since in GroupFileBuild it sometimes writes out
    // an extra byte that has not been allocated.  This is the "safe" fix.
    // For post 2.0 we should remove this and do a real fix in GroupFileBuild
    if ((lpGroup->hGrpBitVect = handle = _GLOBALALLOC(GMEM_FIXED | GMEM_ZEROINIT,
		size+1)) == NULL) // WinNT4.0 seemed to mishandle moveable memory here
        // when this code was called through a COM wrapper and proxy layer.
        // Very bizarre (a-ericry, thoroughly discussed with kevynct, 3 Apr 97)
	{
		/* Out of memory. Free the allocated structure */
		_GLOBALUNLOCK(lpGroup->hGroup);
		_GLOBALFREE(lpGroup->hGroup);
		SetErrCode (phr, E_OUTOFMEMORY);
		return NULL;
	}
	lpGroup->lpbGrpBitVect = (LPBYTE)_GLOBALLOCK(handle);
	lpGroup->lperr = phr;
	return lpGroup;
}


/*************************************************************************
 *	@doc	API INDEX RETRIEVAL
 *
 *	@func	VOID FAR PASCAL | GroupFree |
 *		This function will free all memory associated with a group
 *
 *	@parm	LPGROUP | lpGroup |
 *		Pointer to group to be freed
 *************************************************************************/
PUBLIC	VOID FAR PASCAL GroupFree(_LPGROUP lpGroup)
{
	if (lpGroup == NULL)
		return;

	/* Free the memory */
	if (lpGroup->hGrpBitVect) 
	{
		_GLOBALUNLOCK(lpGroup->hGrpBitVect);
		_GLOBALFREE(lpGroup->hGrpBitVect);
	}
	_GLOBALUNLOCK(lpGroup->hGroup);
	_GLOBALFREE(lpGroup->hGroup);
}


// Saves the deltas between samples in high-bit 'nibble' compression.
// If the high bit of low nibble not set, value is 0-7, else
// value is 8-63 unless high nibble set, etc.
//
// [B x x x A x x x] [D x x x C x x x]...
//
#define COMPRESS_DELTA		0
#define COMPRESS_DELTA_INV 	1

// The Group RLE method should work by saving the lengths of runs of 
// consecutive 1's and runs of 0's.  So 00001111111001111 would be
// saved as the values 4,7,2,4 in the above nibble format.  Great 
// savings can be made if the bits are in large groups.

#define COMPRESS_GROUPRLE 	2

// We have room for 13 more types of compression if needed!

HANDLE NEAR PASCAL GroupCompressDelta(LPBYTE lpb, DWORD * pdwSize)
{
 	DWORD dwSize;
	DWORD dwNewSize=1;
	LPBYTE lpbCursor;
	DWORD dwBits;
	DWORD dwNumber;
	DWORD dwLastNumber;
	DWORD dwDelta;
	HANDLE hMem=NULL;
	LPBYTE lpbMem=NULL;
	WORD wShift=0;
	DWORD dwPartialDelta;
	WORD wCompressMode=COMPRESS_DELTA;
	DWORD dwSmallestSize;	
	BOOL bCountingOnes=FALSE;		// Used in GROUPRLE
	DWORD dwTotalCount=0;			// Used in GROUPRLE
	
	
	// See how much space we're going to take first for the various
	// compression schemes
	// if no scheme works, no need alloc mem!

	// COMPRESS_DELTA
	dwNumber=(DWORD)-1;
	dwLastNumber=0;
	dwSize=*pdwSize;
	lpbCursor=lpb;
	dwBits=0;
	while (dwSize--)
	{	WORD b;
		WORD wBit=0;
		b=(WORD)*lpbCursor;
		while (b)
		{	if (b&1)
			{	// add in bit number dwBits+wBit
				dwLastNumber=dwNumber;
				dwNumber=dwBits+wBit;
				dwDelta=dwNumber-dwLastNumber;
				
				do 
				{	
					dwPartialDelta=(dwDelta&0x7);
					if (dwDelta&0xfffffff8)
						dwPartialDelta|=0x8;
					dwNewSize++;
					dwDelta>>=3;
				} while (dwPartialDelta&0x8);				
			}
			b>>=1;
			wBit++;
		}
		lpbCursor++;
		dwBits+=8;
	}
	dwNewSize=(dwNewSize+1)/2;
	dwSmallestSize=dwNewSize;

	// COMPRESS_DELTA_INV
	dwNewSize=1;		// 1 for the compression code nibble
	dwNumber=(DWORD)-1;
	dwLastNumber=0;
	dwSize=*pdwSize;
	lpbCursor=lpb;
	dwBits=0;
	while (dwSize--)
	{	WORD b;
		WORD wBit=0;
		b=(WORD)(~(*lpbCursor))&0xff;
		while (b)
		{	if (b&1)
			{	// add in bit number dwBits+wBit
				dwLastNumber=dwNumber;
				dwNumber=dwBits+wBit;
				dwDelta=dwNumber-dwLastNumber;
				
				do 
				{	
					dwPartialDelta=(dwDelta&0x7);
					if (dwDelta&0xfffffff8)
						dwPartialDelta|=0x8;
					dwNewSize++;
					dwDelta>>=3;
				} while (dwPartialDelta&0x8);				
			}
			b>>=1;
			wBit++;
		}
		lpbCursor++;
		dwBits+=8;
		if ((dwNewSize+1)/2 > dwSmallestSize)
			break;
	}
	dwNewSize=(dwNewSize+1)/2;

	if (dwNewSize<dwSmallestSize)
	{	dwSmallestSize=dwNewSize;
		wCompressMode=COMPRESS_DELTA_INV;
	}
	
	// COMPRESS_GROUPRLE
	// Start by counting number of 0's, then alternate 1's, 0's, ...
	bCountingOnes=FALSE;
	dwTotalCount=0;

    dwNewSize=1;		// 1 for the compression code nibble
	dwNumber=(DWORD)-1;
	dwLastNumber=0;
	dwSize=*pdwSize;
	lpbCursor=lpb;
	while (dwSize--)
	{	WORD b;
		WORD wBit=0;
		b=(WORD)*lpbCursor;
		while (wBit<8)
		{	if (b&1)
			{	if (bCountingOnes)
					dwTotalCount++;
				else	// we were counting 0's, output zero count now
				{
					do 
					{	
						dwPartialDelta=(dwTotalCount&0x7);
						if (dwTotalCount&0xfffffff8)
							dwPartialDelta|=0x8;
						dwNewSize++;
						dwTotalCount>>=3;
					} while (dwPartialDelta&0x8);				
					bCountingOnes=TRUE;
					dwTotalCount=1;
				}
			}
			else
			{
			 	if (!bCountingOnes)
					dwTotalCount++;
				else
				{	// we were counting ones, output count of 1's now
				 	do 
					{	
						dwPartialDelta=(dwTotalCount&0x7);
						if (dwTotalCount&0xfffffff8)
							dwPartialDelta|=0x8;
						dwNewSize++;
						dwTotalCount>>=3;
					} while (dwPartialDelta&0x8);				
					bCountingOnes=FALSE;
					dwTotalCount=1;
				}
			}
			b>>=1;
			wBit++;
		}
		lpbCursor++;
		
		if ((dwNewSize+1)/2 > dwSmallestSize)
			break;
	}
	dwNewSize=(dwNewSize+1)/2;

	if (dwNewSize<dwSmallestSize)
	{	dwSmallestSize=dwNewSize;
		wCompressMode=COMPRESS_GROUPRLE;
	}

	// We now have the smallest size dwSmallestSize and 
	// compression format wCompressMode

	dwNewSize=dwSmallestSize;

	if (dwNewSize>=*pdwSize)
	{	
		*pdwSize=dwNewSize;
		return NULL;
	}

	hMem=_GLOBALALLOC(DLLGMEM_ZEROINIT,dwNewSize);
	lpbMem=(LPBYTE)_GLOBALLOCK(hMem);

	// Write compression code type nibble
	*lpbMem|=(BYTE)(wCompressMode&0xf);
	wShift=4;

	if ((wCompressMode==COMPRESS_DELTA) || (wCompressMode==COMPRESS_DELTA_INV))
	{
		dwNumber=(DWORD)-1;
		dwLastNumber=0;
		dwSize=*pdwSize;
		lpbCursor=lpb;
		dwBits=0;
		dwNewSize=1;

		while (dwSize--)
		{	WORD b;
			WORD wBit=0;
			b=(WORD)*lpbCursor;
			if (wCompressMode==COMPRESS_DELTA_INV)
				b=(~b)&0xff;
			while (b)
			{	if (b&1)
				{	// add in bit number dwBits+wBit
					dwLastNumber=dwNumber;
					dwNumber=dwBits+wBit;
					dwDelta=dwNumber-dwLastNumber;	// We could subt 1, but end case won't detect
													// if last nibble not filled.				
					do 
					{	
						dwPartialDelta=(dwDelta&0x7);
						if (dwDelta&0xfffffff8)
							dwPartialDelta|=0x8;
						*lpbMem|=(BYTE)(dwPartialDelta<<wShift);
						lpbMem+=(wShift>>2);
						wShift=4-wShift;
						dwNewSize++;
						dwDelta>>=3;
					} while (dwPartialDelta&0x8);				
				}
				b>>=1;
				wBit++;
			}
			lpbCursor++;
			dwBits+=8;
		}
		dwNewSize=(dwNewSize+1)/2;
	}
	else if (wCompressMode==COMPRESS_GROUPRLE)
	{
		bCountingOnes=FALSE;
		dwTotalCount=0;

	    dwNewSize=1;		// 1 for the compression code nibble
		dwNumber=(DWORD)-1;
		dwLastNumber=0;
		dwSize=*pdwSize;
		lpbCursor=lpb;
		while (dwSize--)
		{	WORD b;
			WORD wBit=0;
			b=(WORD)*lpbCursor;
			while (wBit<8)
			{	if (b&1)
				{	if (bCountingOnes)
						dwTotalCount++;
					else	// we were counting 0's, output zero count now
					{
						do 
						{	
							dwPartialDelta=(dwTotalCount&0x7);
							if (dwTotalCount&0xfffffff8)
								dwPartialDelta|=0x8;
							*lpbMem|=(BYTE)(dwPartialDelta<<wShift);
							lpbMem+=(wShift>>2);
							wShift=4-wShift;
							dwNewSize++;
							dwTotalCount>>=3;
						} while (dwPartialDelta&0x8);				
						
						bCountingOnes=TRUE;
						dwTotalCount=1;
					}
				}
				else
				{
				 	if (!bCountingOnes)
						dwTotalCount++;
					else
					{	// we were counting ones, output count of 1's now
					 	do 
						{	
							dwPartialDelta=(dwTotalCount&0x7);
							if (dwTotalCount&0xfffffff8)
								dwPartialDelta|=0x8;
							*lpbMem|=(BYTE)(dwPartialDelta<<wShift);
							lpbMem+=(wShift>>2);
							wShift=4-wShift;
							dwNewSize++;
							dwTotalCount>>=3;
						} while (dwPartialDelta&0x8);				
						
						bCountingOnes=FALSE;
						dwTotalCount=1;
					}
				}
				b>>=1;
				wBit++;
			}
			lpbCursor++;			
					
		}

		// Catch tail end if 1's at end (fixes bug848)
		if ((bCountingOnes) && (dwTotalCount))
		{	
			do 
			{	
				dwPartialDelta=(dwTotalCount&0x7);
				if (dwTotalCount&0xfffffff8)
					dwPartialDelta|=0x8;
				*lpbMem|=(BYTE)(dwPartialDelta<<wShift);
				lpbMem+=(wShift>>2);
				wShift=4-wShift;
				dwNewSize++;
				dwTotalCount>>=3;
			} while (dwPartialDelta&0x8);				
		}

		dwNewSize=(dwNewSize+1)/2;
	}
    *pdwSize=dwNewSize;
    _GLOBALUNLOCK (hMem);
    return hMem;
}
		 	

DWORD NEAR PASCAL GroupDecompressDelta(LPBYTE lpbDest, LPBYTE lpbSource, DWORD dwSize)
{
	DWORD dwNewSize=0;
	LPBYTE lpbCursor=lpbSource;
	WORD wShift=0;
	WORD wNibble;
	WORD  wCompressMode=0;
	DWORD dwTotalSize;
	DWORD dwNumber=(DWORD)-1;
		
	wCompressMode=(WORD)((*lpbSource)&0xf);
	wShift=4;

	if ((wCompressMode==COMPRESS_DELTA) || (wCompressMode==COMPRESS_DELTA_INV))
	{	
		DWORD dwDelta;
		WORD wShiftDelta=0;
		DWORD dwLastNumber;
	
		while (dwSize)
		{	// Get a delta
			dwDelta=0;
			wShiftDelta=0;
			do
			{	wNibble=((*lpbSource)>>wShift);
				dwDelta|=(wNibble&0x7)<<wShiftDelta;
				wShiftDelta+=3;
				lpbSource+=(wShift>>2);
				dwSize-=(wShift>>2);
				wShift=4-wShift;			
			} while (wNibble&0x8);
			dwLastNumber=dwNumber;
			dwNumber=dwLastNumber+dwDelta;

			// Set the dwNumber bit
            if (dwNumber!=(DWORD)-1)
			    *(lpbDest+(dwNumber>>3))|=(BYTE)(1<<(dwNumber&0x7));
		}

		dwTotalSize=(dwNumber+7)>>3;

		if (wCompressMode==COMPRESS_DELTA_INV) // invert entire group
		{	DWORD dwCt=dwTotalSize;
			BYTE * lpb=lpbDest;
			while (dwCt--)
			{	
			 	*lpb=~*lpb;
				lpb++;
			}
		}
	}
	else if (wCompressMode==COMPRESS_GROUPRLE)
	{
		DWORD dwRunSize;
		WORD wShiftRunSize=0;
		BOOL bExpandingOnes=0;
		
		dwNumber=0;
		while (dwSize)
		{	// Get a delta
			dwRunSize=0;
			wShiftRunSize=0;
			do
			{	wNibble=((*lpbSource)>>wShift);
				dwRunSize|=(wNibble&0x7)<<wShiftRunSize;
				wShiftRunSize+=3;
				lpbSource+=(wShift>>2);
				dwSize-=(wShift>>2);
				wShift=4-wShift;			
			} while (wNibble&0x8);

			// write dwRunSize 0's or 1's starting at dwNumber
			if (bExpandingOnes)
			{	while (dwRunSize--)
				{
					*(lpbDest+(dwNumber>>3))|=(BYTE)(1<<(dwNumber&0x7));
				 	dwNumber++;
				}
			}
			else
				dwNumber+=dwRunSize;
			
			bExpandingOnes=!bExpandingOnes;
		}
		dwTotalSize=(dwNumber+7)>>3;
	}
	
	return dwTotalSize;
}
			


/*************************************************************************
 *
 *	@doc	API INDEX RETRIEVAL
 *
 *	@func	PUBLIC int FAR PASCAL | GroupFileBuild |
 *		This function will save a group to a file. The file
 *		may be a regular DOS file, or a system .MVB subfile.
 *
 *	@parm	HFPB | hfpbSysFile |
 *		If non-zero, this is the handle of an already opened system file,
 *		the group file is a FS subfile
 *		If zero, the file is a regular DOS file
 *
 *	@parm	LPSTR | lszGrpFilename |
 *		Group's filename. It must be non-null
 *
 *	@parm	_LPGROUP | lpGroup |
 *		Pointer to a group. This group may come from GroupLoad(), or
 *		may be a result of groups' operations
 *
 *	@rdesc	S_OK if succeeded, else other error codes
 *
 *************************************************************************/

PUBLIC int FAR PASCAL EXPORT_API FAR GroupFileBuild
    (HFPB hfpbSysFile, LPSTR lszGrpFilename, _LPGROUP lpGroup)
{
	HFPB hfpbGroup;
	HRESULT fRet = S_OK;
	DWORD dwMinItem;
	DWORD dwMaxItem;
#if 0
	/* UNDONE:
	 *	All the #if 0 stuffs are ifdef out because at this point we don't
	 * support low end optimization yet
	 */
	LPBYTE lpbStart;
#endif
	LPBYTE lpbEnd;
	HRESULT hr;
	char ScratchBuf [GROUP_HDR_SIZE];

	/* Check for error */
	if (lszGrpFilename == NULL || lpGroup == NULL ||
		lpGroup->fFlag > TRIMMED_GROUP)
		return E_INVALIDARG;
		
	if ((hfpbGroup = FileCreate(hfpbSysFile,  lszGrpFilename,
		hfpbSysFile ? FS_SUBFILE : REGULAR_FILE, &hr)) == 0) {
		return hr;
	}

    // Check for zero length word wheels
    if (0 == lpGroup->lcItem)
    {
        // Free bit vector
        if (lpGroup->hGrpBitVect)
        {
		    _GLOBALUNLOCK (lpGroup->hGrpBitVect);
		    _GLOBALFREE (lpGroup->hGrpBitVect);
    		lpGroup->hGrpBitVect = 0;
        }
        // Reset internal variables
		lpGroup->lpbGrpBitVect = NULL;
        lpGroup->minItem = lpGroup->maxItem = lpGroup->dwSize = 0;
    }
	/* Do some optimizations for the group data space only if it has not
	 * been done yet, ie. fFlag == BITVECT_GROUP. The most saving will
	 * come from changing a bitmap group into a hilo group
	 */
	 
	dwMinItem = lpGroup->minItem;
	dwMaxItem = lpGroup->maxItem;
	
	if (lpGroup->fFlag == BITVECT_GROUP) {
		if (!lpGroup->lcItem || lpGroup->lcItem == dwMaxItem - dwMinItem + 1)
        {
			/* This is a hilo group */
			lpGroup->fFlag = HILO_GROUP;
			lpGroup->dwSize = 0;
		}
		else
        {
			/* Change into a TRIMMED_GROUP */
			lpbEnd = (LPBYTE)&lpGroup->lpbGrpBitVect [dwMaxItem / 8];
#if 0
			lpbStart = (LPBYTE)&lpGroup->lpbGrpBitVect [dwMinItem / 8];
			lpGroup->dwSize = (DWORD)(lpbEnd - lpbStart + 1);
#else
			lpGroup->dwSize = (DWORD)(lpbEnd - lpGroup->lpbGrpBitVect + 1);
#endif
			lpGroup->fFlag = TRIMMED_GROUP;
		}
	}
	
	lpGroup->FileStamp = GROUP_STAMP;
	lpGroup->version = GROUPVER;
	
	/* Nullify the file header space */

	MEMSET (ScratchBuf, 0, GROUP_HDR_SIZE);
	MEMCPY (ScratchBuf, lpGroup, sizeof(GROUP_HDR));

	// Write out header and data (either compressed or normal)
	{	DWORD dwNewSize=lpGroup->dwSize;
    	HANDLE hCompressed=NULL;
		LPBYTE lpbBitfield=(LPBYTE)lpGroup->lpbGrpBitVect;
		
		if ((lpGroup->dwSize) && 
			((lpGroup->fFlag==BITVECT_GROUP) || (lpGroup->fFlag==TRIMMED_GROUP)))
		{	
            // Special case if group is empty
            hCompressed=GroupCompressDelta((LPBYTE)lpGroup->lpbGrpBitVect,&dwNewSize);
		 	if (!hCompressed) // no savings
			{	
			    dwNewSize=lpGroup->dwSize;
			}
		}
		
		if (hCompressed)
		{
		 	if (lpGroup->fFlag==BITVECT_GROUP)
		 		((_LPGROUP)ScratchBuf)->fFlag=DISKCOMP_GROUP;
			else
		 		((_LPGROUP)ScratchBuf)->fFlag=DISKCOMP_TRIMMED_GROUP;
				
			lpbBitfield=(LPBYTE)_GLOBALLOCK(hCompressed);
		}
	
		((_LPGROUP)ScratchBuf)->dwSize=dwNewSize;
		
		if (FileSeekWrite(hfpbGroup, (LPVOID)ScratchBuf, foNil,
			GROUP_HDR_SIZE, NULL)==GROUP_HDR_SIZE)
	
		if (dwNewSize)
        {	
        	fRet = (DWORD)FileSeekWrite(hfpbGroup, 
			    (LPVOID)lpbBitfield, MakeFo(GROUP_HDR_SIZE,0),
			    dwNewSize, NULL) == dwNewSize ? S_OK : E_FAIL;
		}
		else if (lpGroup->fFlag != HILO_GROUP)
        {
			fRet = E_FAIL;
		}
		
		if (hCompressed)
		{	
			_GLOBALUNLOCK(hCompressed);
			_GLOBALFREE(hCompressed);
			hCompressed=NULL;
		}
	}

	if (FileClose(hfpbGroup) != S_OK)
		fRet = E_FAIL;

	return fRet;
}


/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	DWORD FAR PASCAL | LrgbBitCount |
 *		This function return the number of bits set in a BitVect
 *
 *	@parm	LPBYTE | lpbBitVect |
 *		Pointer to BitVect
 *
 *	@parm	DWORD | dwSize |
 *		Size of BitVect (in term of BYTE)
 *************************************************************************/
PUBLIC DWORD FAR PASCAL LrgbBitCount(LPBYTE lpbBitVect, DWORD dwSize)
{
	register BYTE bValue;			// Value of the current byte
	register WORD cwBitOn;			// Number of bits set 
	register DWORD lcTotalBitOn;	// Total number of bits set in the bitvector
	DWORD size = dwSize;

	/* Count how many bits are set. This correspond to the number
	   of GrpItem in the group
	*/
	lcTotalBitOn = 0;
	cwBitOn = 0;

	for (; size > 0 ; size--) 
	{
		bValue = *lpbBitVect++;	// Get the current word
		for (; bValue; cwBitOn++)
			bValue &= bValue - 1;

		/* Only do an add every 32K to save time */
		if (cwBitOn & 0x8000) {
			lcTotalBitOn += cwBitOn;
			cwBitOn = 0;
		}
	}

	lcTotalBitOn += cwBitOn;
	return lcTotalBitOn;
}


/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	DWORD FAR PASCAL | LrgbBitFind |
 *		This function returns the position of the specified bit
 *
 *	@parm	LPBYTE | lpbBitVect |
 *		Pointer to bitvector
 *
 *	@parm	DWORD | dwCount |
 *		The bit to count to (0 means first bit)
 *************************************************************************/
PUBLIC DWORD FAR PASCAL LrgbBitFind(LPBYTE lpbBitVect, DWORD dwCount, BYTE FAR *pHold)
{
	BYTE bValue;			// Value of the current byte
	BYTE bHold;
	LPBYTE  lpbBitVectSave	= lpbBitVect;		// save pointer to beginning
	DWORD	dwRval;

	dwCount++;			// switch from 0 based to 1 based

	while (dwCount) 
	{
		bValue = *lpbBitVect++;	// Get the current byte
		for (; bValue && dwCount; dwCount--) 
		{
			bHold = bValue;
			bValue &= bValue - 1;
		}
	}

	if (pHold) *pHold = bHold;
	dwRval = (DWORD) (((DWORD_PTR)lpbBitVect-(DWORD_PTR)lpbBitVectSave-1)*8);
	for (;bHold&&!(bHold&1);bHold>>=1)	
	{
		dwRval++;
		dwCount--;
	}

	return dwRval;
}


/*************************************************************************
 *	@doc	API INDEX RETRIEVAL
 *
 *	@func	int PASCAL FAR | GroupTrimmed |
 *		This function will trim down the size of the group's bit vector
 *
 *	@parm	_LPGROUP | lpGroup |
 *		Pointer to group
 *
 *	@rdesc	Return S_OK if a new trimmed group is created,
 *		E_OUTOFMEMORY in case of out-of-memory
 *************************************************************************/
int PASCAL FAR GroupTrimmed (_LPGROUP lpGroup)
{
	unsigned int cbSize;
	LPBYTE lpbBit;
	HANDLE hBitVect;
	LONG cItem;
	
	if (lpGroup == NULL)
		return E_INVALIDARG;

	if (lpGroup->fFlag == TRIMMED_GROUP ||
		(cbSize = (unsigned int)lpGroup->dwSize) == 0)
	{
		// reset group cache
		lpGroup->nCache = 0;
		return S_OK;
	}
	
	cItem = (LONG)(cbSize - 1) * 8;
	
	/* Truncate all 0's bytes at the high end of the bit vector */
	lpbBit = lpGroup->lpbGrpBitVect + cbSize - 1;
	while (cbSize > 0 && *lpbBit == 0) 
	{
		cbSize --;
		lpbBit--;
		cItem -= 8;
	}
	
	if (cbSize == 0) 
	{
		/* This is an empty group */
		lpGroup->dwSize = lpGroup->lcItem = 0;
		lpGroup->maxItem = lpGroup->minItem = 0;

		/* Release the memory block */
		_GLOBALUNLOCK (hBitVect = lpGroup->hGrpBitVect);
		_GLOBALFREE (hBitVect);
		lpGroup->hGrpBitVect = 0;
		lpGroup->lpbGrpBitVect = NULL;
		return S_OK;
	}
	
	/* Reset maxItem */
	lpGroup->maxItem = cItem + HiBitSet (*lpbBit);
	
	/* Reset minItem */
	cItem = -1;
	lpbBit = lpGroup->lpbGrpBitVect;
	while (*lpbBit == 0) 
	{
		lpbBit++;
		cItem += 8;
	}
	//assert (*lpbBit);
	
	lpGroup->minItem = cItem + LoBitSet (*lpbBit) + 1;
	
	_GLOBALUNLOCK (hBitVect =lpGroup->hGrpBitVect);

	/* Reallocate the size of the bitvector */
	if ((lpGroup->hGrpBitVect =
		_GLOBALREALLOC (hBitVect, (DWORD) cbSize, GMEM_MOVEABLE)) == NULL) 
	{
		lpGroup->lpbGrpBitVect = NULL;
		return E_OUTOFMEMORY;
	}
	/* Update pointer to the new bit vector */
	lpGroup->lpbGrpBitVect = _GLOBALLOCK(lpGroup->hGrpBitVect);

	lpGroup->lcItem = LrgbBitCount(lpGroup->lpbGrpBitVect, cbSize);
	lpGroup->fFlag  = TRIMMED_GROUP;
	lpGroup->dwSize = cbSize;
	lpGroup->nCache = 0;
	return S_OK;
}



/*************************************************************************
 *	@doc	API INDEX RETRIEVAL
 *
 *	@func	int PASCAL FAR | GroupMake |
 *		Creates a group from a bitvector.
 *
 *	@parm	LPBYTE | lpBits |
 *		Pointer to bitfield
 *  @parm   DWORD  | dwSize |
 *		Number of bytes in bitfield.
 *  @parm   DWORD  | dwItems |
 *		Number of items (if not exactly dwSize*8). If dwItems==0, dwSize*8
 *		will be used.
 *
 *	@rdesc	Return S_OK if a new trimmed group is created,
 *		E_OUTOFMEMORY in case of out-of-memory
 *************************************************************************/
_LPGROUP PASCAL FAR GroupMake (LPBYTE lpBits, DWORD dwSize, DWORD dwItems)
{
	_LPGROUP lpGroup;
	ERRB     err;
	
	if (dwItems==0) dwItems = dwSize*8;

	if ((lpGroup = GroupCreate(dwSize, dwItems, &err)) == NULL)
		return NULL;

	MEMCPY(lpGroup->lpbGrpBitVect,lpBits,dwSize);
	GroupTrimmed(lpGroup);
	
	return lpGroup;    // mv20c version had this return ERR_SUCCESS ?
}

/*************************************************************************
 *	@doc	API RETRIEVAL
 *
 *  @func   DWORD FAR PASCAL | GroupFind |
 *      Given a pointer to a group and a count to count from the first
 *      topic number of the group (dwCount), this function return the
 *      topic number of the nth (dwCount) item of the list (counting from 0),
 *      or -1 if not found
 *
 *  @parm LPGROUP | lpGroup |
 *      Pointer to the group
 *
 *  @parm DWORD | dwCount |
 *      The index count in to the group. Count is 0-based
 *
 *  @parm   PHRESULT | phr |
 *      Pointer to error buffer
 *
 *  @rdesc  The topic number, or -1 if not found or other errors. In case
 *      of error, phr will contain the error code
 * 
 *************************************************************************/
PUBLIC  DWORD EXPORT_API FAR PASCAL GroupFind(_LPGROUP lpGroup,
    DWORD dwCount, PHRESULT phr)
{
    DWORD dwRes;
    BYTE bHold;
    
    if (lpGroup == NULL || dwCount>=((_LPGROUP)lpGroup)->lcItem)
    {
        SetErrCode (phr, E_INVALIDARG);
        return ((DWORD)-1);
    }

	if (phr)
		*phr = S_OK;
    
    if (lpGroup->nCache && dwCount > lpGroup->dwCount)
    {
        dwRes = (DWORD)LrgbBitFind(lpGroup->lpbGrpBitVect+lpGroup->nCache, dwCount - lpGroup->dwCount,&bHold);
        if (dwRes!=(DWORD)-1)
            dwRes += ((DWORD)lpGroup->nCache)*8;
    }
    else
        dwRes = (DWORD)LrgbBitFind(lpGroup->lpbGrpBitVect, dwCount, &bHold);
    if (dwRes!=(DWORD)-1)
    {
        BYTE bValue;
        // save this latest position.
        lpGroup->nCache  = (UINT)(dwRes/8);
        lpGroup->dwCount = dwCount;
        bValue = *(lpGroup->lpbGrpBitVect + lpGroup->nCache);
        while (bValue && (bValue != bHold))
        {
            bValue &= bValue - 1;
            lpGroup->dwCount--;
        }
    }
    return dwRes;
}


/*************************************************************************
 *	@doc	API RETRIEVAL
 *
 *  @func   DWORD FAR PASCAL | GroupFindOffset |
 *      Given a pointer to a group and a topic number,
 *      this function return the position of the item in the
 *      group that has "dwTopicNum" as a topic number or -1 if error.
 *      This is the counter-API of GroupFind().
 *
 *  @parm LPGROUP | lpGroup |
 *      Pointer to the group
 *
 *  @parm DWORD | dwTopicNum |
 *      The index count in to the group. Count is 0-based
 *
 *  @parm   PHRESULT | phr |
 *      Pointer to error buffer
 *
 *  @rdesc  The position of the item in the group. Will return -1 if an
 *      error occured. If the dwTopicNum is not part of the group, the
 *      error flag will be set to ERR_NOTEXIST and the function will return
 *      the closest UID less than dwTopicNum. In case of error, phr will
 *      contain the error code
 * 
 *************************************************************************/
PUBLIC  DWORD EXPORT_API FAR PASCAL GroupFindOffset(_LPGROUP lpGroup,
    DWORD dwTopicNum, PHRESULT phr)
{
    DWORD dwRes, dwByteNum = (++dwTopicNum)/8;

    if (lpGroup == NULL || dwTopicNum > lpGroup->maxItemAllGroup)
    {
        SetErrCode (phr, E_INVALIDARG);
        return ((DWORD)-1);
    }

    // If the UID isn't in the group, ERR_NOTEXIT will be set, but we still continue the process
    // to get the nearest entry. This is done for WordWheelPrefix().
    if (phr)
        *phr = GroupIsBitSet(lpGroup, dwTopicNum - (DWORD)1) ? S_OK : E_NOTEXIST;

    if (lpGroup->nCache && dwTopicNum > ((DWORD)lpGroup->nCache) * 8)
    {
        dwRes = (DWORD)LrgbBitCount(lpGroup->lpbGrpBitVect+lpGroup->nCache, dwByteNum - lpGroup->nCache);
        if (dwRes!=(DWORD)-1)
            dwRes += lpGroup->dwCount;
    }
    else
        dwRes = (DWORD)LrgbBitCount(lpGroup->lpbGrpBitVect, dwByteNum);

    if (dwRes!=(DWORD)-1)
    {
        BYTE bShift = (BYTE) (dwTopicNum%8);
        BYTE bValue = *(lpGroup->lpbGrpBitVect + dwByteNum);
        BYTE bMask = 0xFF;

        // save this latest position.
        lpGroup->nCache  = (UINT)(dwTopicNum/8);
        lpGroup->dwCount = dwRes;

        if (bShift)
        {
            bMask >>= 8 - bShift;
            bValue &= bMask;
            dwRes += (DWORD) LrgbBitCount(&bValue, 1);
        }
    }
    else
        return dwRes; // Error.

	return dwRes - 1; // Let's keep it zero-based.
}


/*************************************************************************
 *	@doc	RETRIEVAL
 *
 *	@func	LPGROUP FAR PASCAL | GroupOr |
 *		The function will generate a new group resulting from the ORing 
 *		of two groups
 *	@parm	LPGROUP | lpGroup1 |
 *		Pointer to first group
 *
 *	@parm	LPGROUP | lpGroup2 |
 *		Pointer to second group
 *
 *	@parm	PHRESULT | lperr |
 *		Pointer to error buffer
 *
 *	@rdesc	If succeeded, the function will return a pointer the newly
 *		created group. The error buffer has the information about the
 *		cause of the failure
 *************************************************************************/
PUBLIC	_LPGROUP EXPORT_API FAR PASCAL GroupOr(_LPGROUP lpGroup1,
	_LPGROUP lpGroup2, PHRESULT lperr)
{
	_LPGROUP lpResGroup;
	LPBYTE lpbBitVect2;			// Pointer to Group bitmap 2
	LPBYTE lpbResBitVect;// Pointer to result Group bitmap
	register DWORD i;		// Counter

	/* Check for groups validity, and create a new one */
	if ((lpResGroup = GroupCheckAndCreate(lpGroup1, lpGroup2, lperr)) == NULL)
		return NULL;

	/* Initialize variables */
	lpbBitVect2 = lpGroup2->lpbGrpBitVect;
	lpbResBitVect = lpResGroup->lpbGrpBitVect;

	/* Copy Group 1's bit vector  */
	MEMCPY (lpbResBitVect, lpGroup1->lpbGrpBitVect, (UINT)lpGroup1->dwSize);

	/* Do the operation */
	for (i = lpGroup2->dwSize; i > 0; i--) 
	{
		*lpbResBitVect++ |= *lpbBitVect2++ ;
	}

	if (GroupTrimmed (lpResGroup) != S_OK) 
	{
		GroupFree (lpResGroup);
		lpResGroup = NULL;
	}
	return lpResGroup;
}


/*************************************************************************
 *	@doc	RETRIEVAL
 *
 *	@func	LPGROUP FAR PASCAL | GroupNot |
 *		The function will generate a new group resulting from the NOTing 
 *		of the given group
 *
 *	@parm	LPGROUP | lpGroup |
 *		Pointer to first group
 *
 *	@parm	PHRESULT | lperr |
 *		Pointer to error buffer
 *
 *	@rdesc	If succeeded, the function will return a pointer the newly
 *		created group. The error buffer has the information about the
 *		cause of the fialure
 *************************************************************************/
PUBLIC	_LPGROUP EXPORT_API FAR PASCAL GroupNot(_LPGROUP lpGroup,
	PHRESULT lperr)
{
	_LPGROUP lpResGroup;
	LPBYTE lpbBitVect;		// Pointer to Group bitmap 1
	LPBYTE lpbResBitVect;	// Pointer to result Group bitmap 1
	DWORD  dwSize;			// minimum size;
	register DWORD i;		// Counter
	ERR fRet;
	DWORD dwMaxItemAllGroup;

	/* Check for groups validity, and create a new one */
	if ((fRet = GroupCheck (lpGroup)) != S_OK) 
	{
		SetErrCode(lperr, fRet);
		return NULL;
	}
	
	/*****************************************************
	 *
	 * THERE ARE SOME COMPLICATIONS FOR GROUPNOT THAT WE
	 * HAVE TO CONSIDER:
	 *   - GROUPNOT SHOULD INCLUDE ALL THE ITEM THE GROUPS
	 *     SET.
	 *   - WHEN DOING THE NOT, ALL ITEMS > MAXITEM SHOULD
	 *     BE RESET TO ZERO, SINCE THEY ARE OUTSIDE OF THE
	 *     UNIVERSE.
	 *
	 *****************************************************/
	if (lpGroup->maxItemAllGroup==0)
		return GroupDuplicate (lpGroup, lperr);

	dwMaxItemAllGroup = lpGroup->maxItemAllGroup;

	if ((lpResGroup = GroupCreate(((dwMaxItemAllGroup + 7) / 8),dwMaxItemAllGroup, lperr)) == NULL)
		return NULL;

	/* Initialize variables */
	lpbBitVect = lpGroup->lpbGrpBitVect;
	lpbResBitVect = lpResGroup->lpbGrpBitVect;
	

	/* Do the operation */
	dwSize = min(lpGroup->dwSize,lpResGroup->dwSize);
	for (i = dwSize; i > 0; i--) 
	{
		*lpbResBitVect++ = ~*lpbBitVect ;
		lpbBitVect++;
	}

	/* Set all the remaining bits to 1. Note that after the operations
	 * all bits that followed the dwMaxItemAllGroup's bit are set. They
	 * should be dealt with properly
	 */
	if (i = lpResGroup->dwSize - dwSize) 
		MEMSET (lpbResBitVect, 0xff, i);

	/********************************************************
	 *
	 * THE NEXT STEP IS TO RESET ALL THE BITS OUTSIDE OF THE
	 * LIMITS TO 0'S
	 *
	 ********************************************************/

	// GarrG. 12-14-94. Subtracted one to really point to the last byte.
	if (lpGroup->maxItemAllGroup % 8)
	{
		lpbResBitVect += i-1;	// Move to the last byte
		i = 1 << (lpGroup->maxItemAllGroup % 8);
		// maxItemAllGroup is actually number, not the maximum index.
		// so I removed i <<= 1; -GarrG
		while (i <= 0x80) 
		{
			*lpbResBitVect &= ~i;
			i <<= 1;
		}
	}

	if ((fRet = GroupTrimmed (lpResGroup)) != S_OK) 
	{
		SetErrCode (lperr, fRet);
		GroupFree (lpResGroup);
		lpResGroup = NULL;
	}
	return lpResGroup;

}

/*************************************************************************
 *	@doc	RETRIEVAL
 *
 *	@func	LPGROUP FAR PASCAL | GroupAnd |
 *		The function will generate a new group resulting from the ANDing 
 *		of two groups
 *
 *	@parm	LPGROUP | lpGroup1 |
 *		Pointer to first group
 *
 *	@parm	LPGROUP | lpGroup2 |
 *		Pointer to second group
 *
 *	@parm	PHRESULT | lperr |
 *		Pointer to error buffer
 *
 *	@rdesc	If succeeded, the function will return a pointer the newly
 *		created group. The error buffer has the information about the
 *		cause of the fialure
 *************************************************************************/
PUBLIC	_LPGROUP EXPORT_API FAR PASCAL GroupAnd(_LPGROUP lpGroup1,
	_LPGROUP lpGroup2, PHRESULT lperr)
{
	_LPGROUP lpResGroup;
	LPBYTE lpbBitVect1;     // Pointer to Group bitmap 1
	LPBYTE lpbBitVect2;     // Pointer to Group bitmap 2
	LPBYTE lpbResBitVect;   // Pointer to result Group bitmap
	DWORD i;                // Counter
	DWORD dwMinOverlapTopic;
	DWORD dwMaxOverlapTopic;
	ERR fRet;

	/* Check for groups validity, and create a new one */
	if ((lpResGroup = GroupCheckAndCreate(lpGroup1, lpGroup2, lperr)) == NULL) 
		return NULL;

	if (lpGroup1->lcItem && lpGroup2->lcItem) 
	{

		/* Only do a GroupAND for non empty group */

		/* Get the overlap */
		if ((dwMinOverlapTopic = lpGroup1->minItem) < lpGroup2->minItem)
			dwMinOverlapTopic = lpGroup2->minItem;
		
		if ((dwMaxOverlapTopic = lpGroup1->maxItem) > lpGroup2->maxItem)
			dwMaxOverlapTopic = lpGroup2->maxItem;
		
		if (dwMinOverlapTopic <= dwMaxOverlapTopic) 
		{

			/* Change to bytes */
			dwMinOverlapTopic /= 8;
			dwMaxOverlapTopic /= 8;
			
			/* Initialize variables */
			
			lpbBitVect1 = &lpGroup1->lpbGrpBitVect [dwMinOverlapTopic];
			lpbBitVect2 = &lpGroup2->lpbGrpBitVect [dwMinOverlapTopic];
			lpbResBitVect = &lpResGroup->lpbGrpBitVect [dwMinOverlapTopic];
			
			for (i = dwMaxOverlapTopic - dwMinOverlapTopic + 1;
				i > 0; i--) 
			{
				*lpbResBitVect = *lpbBitVect1 & *lpbBitVect2;
				lpbResBitVect++;
				lpbBitVect1++;
				lpbBitVect2++;
			}
		}
	}

	if ((fRet = GroupTrimmed (lpResGroup)) != S_OK) 
	{
		SetErrCode (lperr, fRet);
		GroupFree (lpResGroup);
		lpResGroup = NULL;
	}
	return lpResGroup;
}

/*************************************************************************
 *	@doc	API RETRIEVAL
 *
 *	@func	_LPGROUP  | GroupDuplicate |
 *		This fucntion creates a copy for the specified group
 * 
 *	@parm	_LPGROUP | lpGroup| 
 *		Pointer to group to be duplicated
 *
 *	@parm	PHRESULT | lperr |
 *		A pointer to an error buffer, which will receive the error
 *		code in case that the function fails
 *
 *	@rdesc	Return a new copy of group if succeeded, NULL if failed
 *************************************************************************/

PUBLIC _LPGROUP PASCAL FAR GroupDuplicate (_LPGROUP lpGroup,
	PHRESULT lperr)
{
	_LPGROUP lpDupGroup;

	/* Safety check */
	if (lpGroup == NULL) 
	{
		SetErrCode (lperr, E_INVALIDARG);
		return NULL;
	}

	/* Create the group */
	if ((lpDupGroup = GroupCreate (lpGroup->dwSize, lpGroup->maxItemAllGroup,
		lperr)) == NULL)
		return NULL;


	/* Copy the information over */
	*(GROUP_HDR FAR *)lpDupGroup = *(GROUP_HDR FAR *)lpGroup;

	/* Check for empty group */
	if (lpGroup->hGrpBitVect) 
	{
		MEMCPY (lpDupGroup->lpbGrpBitVect, lpGroup->lpbGrpBitVect,
			lpGroup->dwSize);
	}
	else 
	{
		_GLOBALUNLOCK (lpDupGroup->hGrpBitVect);
		_GLOBALFREE (lpDupGroup->hGrpBitVect);
		lpDupGroup->hGrpBitVect = 0;
		lpDupGroup->lpbGrpBitVect = NULL;
	}
	return lpDupGroup;
}

/*************************************************************************
 *	@doc	API RETRIEVAL
 *
 *	@func	ERR _LPGROUP PASCAL FAR | GroupCopy |
 *		This fucntion copies the bitfield data of one group to another
 * 
 *	@parm	_LPGROUP | lpGroupDest| 
 *		Pointer to destination group
 *
 *	@parm	_LPGROUP | lpGroupSrc| 
 *		Pointer to source group
 *
 *	@rdesc	Returns S_OK if succeeded, an error otherwise
 *************************************************************************/

PUBLIC ERR PASCAL FAR GroupCopy (_LPGROUP lpGroupDst,
	_LPGROUP lpGroupSrc)
	
{
	ERR err=S_OK;
	HANDLE hNewGroupMem=NULL;
	
	// Safety check
	if ((lpGroupSrc == NULL) || (lpGroupDst==NULL))
	{
		return E_INVALIDARG;
	}

	if (lpGroupSrc->hGrpBitVect) // Source group is NOT empty
	{	
        if ((NULL == lpGroupDst->hGrpBitVect) || (NULL == lpGroupDst->lpbGrpBitVect)
            || (lpGroupDst->dwSize!=lpGroupSrc->dwSize))
		{
			if ((hNewGroupMem = _GLOBALALLOC(DLLGMEM_ZEROINIT,
				lpGroupSrc->dwSize)) == NULL)
				return E_OUTOFMEMORY;
		}           
	
		// Copy the information over
		*(GROUP_HDR FAR *)lpGroupDst = *(GROUP_HDR FAR *)lpGroupSrc;
		
		// Remove old info from Destination group and create new if
		// differing sizes
		if (hNewGroupMem)
		{
            if (NULL != lpGroupDst->hGrpBitVect)
            {
		 	    _GLOBALUNLOCK(lpGroupDst->hGrpBitVect);
			    _GLOBALFREE(lpGroupDst->hGrpBitVect);
            }
			lpGroupDst->hGrpBitVect = hNewGroupMem;
			lpGroupDst->lpbGrpBitVect = (LPBYTE)_GLOBALLOCK(hNewGroupMem);
		}
		
		// Copy actual bits
		MEMCPY (lpGroupDst->lpbGrpBitVect, lpGroupSrc->lpbGrpBitVect,
			lpGroupSrc->dwSize);
	}
	else
	{
		// Group is empty, make destination empty
		*(GROUP_HDR FAR *)lpGroupDst = *(GROUP_HDR FAR *)lpGroupSrc;
		
		// Remove old info from Destination group
		if (lpGroupDst->hGrpBitVect)
		{
		 	_GLOBALUNLOCK(lpGroupDst->hGrpBitVect);
			_GLOBALFREE(lpGroupDst->hGrpBitVect);
			lpGroupDst->hGrpBitVect=NULL;
			lpGroupDst->lpbGrpBitVect = NULL;
		}
	
	}

	return err;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	LPGROUP NEAR PASCAL | GroupCheckAndCreate |
 *		Given 2 groups, this function will check their validity, and if
 *		they are valid, create a new group
 *
 *	@parm	LPGROUP | lpGroup1 |
 *		Pointer to group 1
 *
 *	@parm	LPGROUP | lpGroup2 |
 *		Pointer to group 2
 *
 *	@parm	PHRESULT | lperr |
 *		Pointer to error buffer
 *
 *	@rdesc	The function will return a pointer to a newly created group if
 *		succeeded, NULL otherwise. The error buffer contains information
 *		about the cause of the failure
 *************************************************************************/

static _LPGROUP NEAR PASCAL GroupCheckAndCreate(_LPGROUP lpGroup1,
	_LPGROUP lpGroup2, PHRESULT lperr)
{

	DWORD dwSize;
	DWORD maxItemAllGroup;
	
	/* Check the validity of the groups */
	if (GroupCheck(lpGroup1) != S_OK || GroupCheck(lpGroup2) != S_OK) 
	{
		SetErrCode(lperr, E_BADVERSION);
		return NULL;
	}

	if ((dwSize = lpGroup1->dwSize) < lpGroup2->dwSize) 
	{
		dwSize = lpGroup2->dwSize;
	}

	if ((maxItemAllGroup = lpGroup1->maxItemAllGroup) <
		lpGroup2->maxItemAllGroup) 
	{
		maxItemAllGroup = lpGroup2->maxItemAllGroup;
	}
	/* Create a new Group */
	return (GroupCreate(dwSize, maxItemAllGroup, lperr));
}


/*************************************************************************
 *  @doc    EXTERNAL API
 *
 *  @func   _LPGROUP PASCAL FAR | GroupBufferCreate |
 *      This function will create group from a buffer
 *
 *  @parm   HANDLE | h |
 *      Handle to memory buffer containig raw group file data
 *
 *  @parm   PHRESULT | phr |
 *      Pointer to error buffer
 *
 *  @rdesc  If succeeded, the function will return a pointer to the loaded
 *      group, else NULL. The error buffer will contain information about
 *      the cause of the failure
 *************************************************************************/

_LPGROUP PASCAL FAR GroupBufferCreate (HANDLE h, PHRESULT phr)
{
    GROUP_HDR FAR *lpGroupHdr;
    GROUP_HDR GroupHdr;
    ERR       fRet;
    _LPGROUP    lpGroup = NULL;
    char cBitSet;   // This must be signed !!!
    LPBYTE lpGroupBitVect;
    DWORD 	dwStartByte;
    DWORD 	dwVectorSize;
    DWORD   dwCurMaxTopic;
    DWORD   dwBytes;
    LPBYTE  lp=NULL;

    lpGroupHdr = &GroupHdr;
    lp = (LPBYTE)_GLOBALLOCK(h);
	dwBytes = (DWORD) GlobalSize(h);

    fRet = E_BADFILE;

    if (dwBytes < sizeof(GROUP_HDR))
    {
        goto exit00;
    }

    MEMCPY (lpGroupHdr, lp, sizeof(GROUP_HDR));
    
    /* BigEndian codes. They will optimized out under Windows */

    lpGroupHdr->FileStamp = SWAPWORD(lpGroupHdr->FileStamp);
    lpGroupHdr->version = SWAPWORD(lpGroupHdr->version);
    lpGroupHdr->dwSize = SWAPLONG(lpGroupHdr->dwSize);
    lpGroupHdr->maxItem = SWAPLONG(lpGroupHdr->maxItem);
    lpGroupHdr->minItem = SWAPLONG(lpGroupHdr->minItem);
    lpGroupHdr->lcItem = SWAPLONG(lpGroupHdr->lcItem);
    lpGroupHdr->maxItemAllGroup = SWAPLONG(lpGroupHdr->maxItemAllGroup);
    lpGroupHdr->fFlag  = SWAPWORD(lpGroupHdr->fFlag);

    /* Set maxItemAllgroup and fFlag properly, since those fields
     * didn't exist before
     */
    if (lpGroupHdr->version < 9) 
    {
        lpGroupHdr->maxItemAllGroup = lpGroupHdr->dwSize * 8;
        lpGroupHdr->fFlag = BITVECT_GROUP;
    }

    /* Check to see if the data read in is valid */
    if (GroupCheck((_LPGROUP)lpGroupHdr) != S_OK) 
        goto exit00;

    if (lpGroupHdr->dwSize == 0 && lpGroupHdr->maxItem) 
        lpGroupHdr->dwSize = lpGroupHdr->maxItem / 8 + 1;

    /* Get the vector size. This is a shorthand version */
    dwVectorSize = lpGroupHdr->dwSize;

    /* Create a new group. It is assuming that GroupCreate() will
     * allocate enough memory to store all the data
     */
    if ((lpGroup = GroupCreate( (lpGroupHdr->maxItemAllGroup+7)>>3, //dwVectorSize,
        lpGroupHdr->maxItemAllGroup, phr)) == NULL) 
    {
        fRet = E_OUTOFMEMORY;
        goto exit00;
    }

    /* Copy the group header information */
    *(GROUP_HDR FAR *)lpGroup = *lpGroupHdr;

    if (lpGroup->fFlag == HILO_GROUP && lpGroup->minItem && lpGroup->maxItem) 
    {
        /* The work now is to set all the bits to 1. It is broken into 3 parts:
         *    - The beginning byte : which may not have all bit set
         *    - The ending byte : which may not have all bit set
         *    - Every byte between the above two: all bits are set
         */
        dwStartByte = (lpGroup->minItem / 8);

        lpGroupBitVect = lpGroup->lpbGrpBitVect + dwStartByte;
        dwCurMaxTopic = dwStartByte * 8;
        
        /* Set the beginning byte */
        
        cBitSet = (char)(lpGroup->minItem  - dwStartByte * 8);
        while (cBitSet < 8) 
        {
            *lpGroupBitVect |= 1 << cBitSet;
            cBitSet ++;
            // a-kevct: (MV1.3 #27) Changed test from >= to > condition 
            if (dwCurMaxTopic + cBitSet > lpGroup->maxItem)
            {   lpGroup->fFlag = TRIMMED_GROUP;
                goto DoneGroup;
            }
        }

        /* Set the body */
        MEMSET (lpGroupBitVect + 1, 0xff,
            dwVectorSize - dwStartByte - 2);
        
        /* Set the ending byte */
        lpGroupBitVect = lpGroup->lpbGrpBitVect + dwVectorSize - 1;
        cBitSet = (int)(lpGroup->maxItem  - (lpGroup->maxItem / 8) * 8);

        /* Note that in the following calculation, we end at 0. Suppose
         * that  maxItem = 8, then the 1st bit of the second byte must be set
         */
        while (cBitSet >= 0) 
        {
            *lpGroupBitVect |= 1 << cBitSet;
            cBitSet --;
        }
        lpGroup->fFlag = TRIMMED_GROUP;
    }
    else 
    {
        /* Seek to position from start of file */
        lp += GROUP_HDR_SIZE;
        if (dwBytes < (DWORD)(GROUP_HDR_SIZE+dwVectorSize))
            goto exit00;
        
        if (lpGroup->fFlag==DISKCOMP_GROUP)
		{	DWORD dwNewSize=GroupDecompressDelta((LPBYTE)lpGroup->lpbGrpBitVect,lp,dwVectorSize);
			lpGroup->fFlag=BITVECT_GROUP;
			dwVectorSize=lpGroup->dwSize=(lpGroupHdr->maxItemAllGroup+7)>>3;
		}
		else if (lpGroup->fFlag==DISKCOMP_TRIMMED_GROUP)
		{	DWORD dwNewSize=GroupDecompressDelta((LPBYTE)lpGroup->lpbGrpBitVect,lp,dwVectorSize);
			lpGroup->fFlag=TRIMMED_GROUP;
			dwVectorSize=lpGroup->dwSize=(lpGroupHdr->maxItemAllGroup+7)>>3;
		}
		else
			MEMCPY ((LPBYTE)lpGroup->lpbGrpBitVect,lp,dwVectorSize);

        /* This piece of code is to support old version of the
         * group format. It can be deleted after everybody has converted to the
         * new format
         */
        if (lpGroup->version < 9) 
        {
            if ((fRet = GroupTrimmed (lpGroup)) != S_OK) 
                goto exit00;
            dwVectorSize = lpGroup->dwSize;
        }
    }


DoneGroup:
#if 0
    if (lpGroup->lcItem != LrgbBitCount(lpGroup->lpbGrpBitVect,
        dwVectorSize)) 
        goto exit00;
#else
    lpGroup->lcItem = LrgbBitCount(lpGroup->lpbGrpBitVect,
        dwVectorSize); 
#endif

    fRet = S_OK;

exit00:
    /* Close the subfile */
    /* handle is allocated normally, so free normally */
    if (lp) _GLOBALUNLOCK(h);

    if (fRet == S_OK)
        return lpGroup;
    SetErrCode (phr, fRet);
    if (lpGroup)
        GroupFree (lpGroup);
    return NULL;
}


/*************************************************************************
 *	@doc	API RETRIEVAL
 *
 *  @func   DWORD FAR PASCAL | GroupIsBitSet |
 *      Given a pointer to a group and a topic number in the group,
 *	    this function will return TRUE if the bit is set or FALSE if
 *      the bit is not set.
 *
 *  @parm LPGROUP | lpGroup |
 *      Pointer to the group
 *
 *  @parm DWORD | dwTopicNum |
 *      The index count in to the group. dwTopicNum is 0-based
 *
 *  @rdesc  TRUE if the bit indecated by dwTopicNum is set or
 *      FALSE if the bit is not set.
 * 
 *************************************************************************/
PUBLIC BOOL EXPORT_API FAR PASCAL GroupIsBitSet 
    (_LPGROUP lpGroup, DWORD dwTopicNum)
{
    if (lpGroup == NULL
        || lpGroup->lcItem == 0
        || lpGroup->minItem > dwTopicNum
        || lpGroup->maxItem < dwTopicNum)
        {
            return (FALSE);
        }

    return GROUPISBITSET (lpGroup, dwTopicNum);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\groups\groupimp.h ===
// GROUPIMP.H:  Definition of CITGroupLocal

#ifndef __GROUPIMP_H__
#define __GROUPIMP_H__

#include "verinfo.h"

class CITGroupLocal :
	public IITGroup,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CITGroupLocal, &CLSID_IITGroupLocal>
{
	public:
        ~CITGroupLocal();
		CITGroupLocal() : m_lpGroup(NULL) {} // constructor--initialize member
											 // variable to NULL
	BEGIN_COM_MAP(CITGroupLocal)
		COM_INTERFACE_ENTRY(IITGroup)
	END_COM_MAP()

	DECLARE_REGISTRY(CLSID_IITGroupLocal, "ITIR.LocalGroup.4",
	                 "ITIR.LocalGroup", 0, THREADFLAGS_BOTH)

	// ITGroup methods (member functions) go here.  CITGroupLocal inherits
	// these methods from the pure, virtual functions of IITGroup.
	public:

		STDMETHOD(Initiate)(DWORD lcGrpItem);
		STDMETHOD(CreateFromBitVector)(LPBYTE lpBits, DWORD dwSize, DWORD dwItems);
		STDMETHOD(CreateFromBuffer)(HANDLE h);
        STDMETHOD(Open)(IITDatabase* lpITDB, LPCWSTR lpszMoniker);
		STDMETHOD(Free)(void);
		STDMETHOD(CopyOutBitVector)(IITGroup* pIITGroup);
        STDMETHOD(AddItem)(DWORD dwGrpItem);
        STDMETHOD(RemoveItem)(DWORD dwGrpItem);
		STDMETHOD(FindTopicNum)(DWORD dwCount, LPDWORD lpdwOutputTopicNum);
		STDMETHOD(FindOffset)(DWORD dwTopicNum, LPDWORD lpdwOutputOffset);
        STDMETHOD(GetSize)(LPDWORD lpdwGrpSize);
		STDMETHOD(Trim)(void);
		STDMETHOD(And)(IITGroup* pIITGroup);
		STDMETHOD(And)(IITGroup* pIITGroupIn, IITGroup* pIITGroupOut);
		STDMETHOD(Or)(IITGroup* pIITGroup);
		STDMETHOD(Or)(IITGroup* pIITGroupIn, IITGroup* pIITGroupOut);
		STDMETHOD(Not)(void);
		STDMETHOD(Not)(IITGroup* pIITGroupOut);
		STDMETHOD(IsBitSet)(DWORD dwTopicNum);
		STDMETHOD(CountBitsOn)(LPDWORD lpdwTotalNumBitsOn);
		STDMETHOD(Clear)(void);
        STDMETHOD_(LPVOID, GetLocalImageOfGroup)(void);
        STDMETHOD(PutRemoteImageOfGroup)(LPVOID lpGroupIn);

	// private data members
	private:

		_LPGROUP m_lpGroup;

};

class CITGroupArrayLocal :
	public IITGroupArray,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CITGroupArrayLocal, &CLSID_IITGroupArrayLocal>
{
	public:
		CITGroupArrayLocal(): m_pGroup(NULL), 
			m_fDirty(TRUE),
			m_iDefaultOp(ITGP_OPERATOR_OR),   // note that OR is the default operator
			m_iEntryMax(0),
			m_rgfEntries(0L){}; // constructor--initialize member

		~CITGroupArrayLocal();
											 // variable to NULL
		BEGIN_COM_MAP(CITGroupArrayLocal)
			COM_INTERFACE_ENTRY(IITGroup)
			COM_INTERFACE_ENTRY(IITGroupArray)
		END_COM_MAP()

		DECLARE_REGISTRY(CLSID_IITGroupArrayLocal, "ITIR.LocalGroupArray.4",
						 "ITIR.LocalGroupArray", 0, THREADFLAGS_BOTH)

	// ITGroup methods (member functions) go here.  CITGroupLocal inherits
	// these methods from the pure, virtual functions of IITGroup.
	public:

		// UNDONE: Currently most IITGroup interfaces are not supported.  We have only
		// put in enough support for xBookshelf.
		STDMETHOD(Initiate)(DWORD lcGrpItem) {return E_NOTIMPL;};
		STDMETHOD(CreateFromBitVector)(LPBYTE lpBits, DWORD dwSize, DWORD dwItems) {return E_NOTIMPL;};
		STDMETHOD(CreateFromBuffer)(HANDLE h) {return E_NOTIMPL;};
		STDMETHOD(Open)(IITDatabase* lpITDB, LPCWSTR lpszMoniker) {return E_NOTIMPL;};
		STDMETHOD(Free)(void) {return E_NOTIMPL;}
		STDMETHOD(CopyOutBitVector)(IITGroup* pIITGroup) {return E_NOTIMPL;}
		STDMETHOD(AddItem)(DWORD dwGrpItem){return E_NOTIMPL;}
		STDMETHOD(RemoveItem)(DWORD dwGrpItem){return E_NOTIMPL;} 
		STDMETHOD(FindTopicNum)(DWORD dwCount, LPDWORD lpdwOutputTopicNum){return E_NOTIMPL;}
		STDMETHOD(FindOffset)(DWORD dwTopicNum, LPDWORD lpdwOutputOffset){return E_NOTIMPL;}
		STDMETHOD(GetSize)(LPDWORD lpdwGrpSize){return E_NOTIMPL;}
		STDMETHOD(Trim)(void){return E_NOTIMPL;}
		STDMETHOD(And)(IITGroup* pIITGroup){return E_NOTIMPL;}
		STDMETHOD(And)(IITGroup* pIITGroupIn, IITGroup* pIITGroupOut){return E_NOTIMPL;}
		STDMETHOD(Or)(IITGroup* pIITGroup){return E_NOTIMPL;}
		STDMETHOD(Or)(IITGroup* pIITGroupIn, IITGroup* pIITGroupOut){return E_NOTIMPL;}
		STDMETHOD(Not)(void){return E_NOTIMPL;}
		STDMETHOD(Not)(IITGroup* pIITGroupOut){return E_NOTIMPL;}
		STDMETHOD(IsBitSet)(DWORD dwTopicNum){return E_NOTIMPL;}
		STDMETHOD(CountBitsOn)(LPDWORD lpdwTotalNumBitsOn){return E_NOTIMPL;}
		STDMETHOD(PutRemoteImageOfGroup)(LPVOID lpGroupIn){return E_NOTIMPL;}

		// UNDONE: The following are the only IITGroup methods currently supported.  Sort of lame, but
		// it is all the local code currently requires and time doesn't permit fully expanding this

		STDMETHOD_(LPVOID, GetLocalImageOfGroup)(void);
		STDMETHOD(Clear)(void) {return ClearEntry(ITGP_ALL_ENTRIES);}
	public:

		// ITGroupArray methods go here
		STDMETHOD(InitEntry)(IITDatabase *piitDB, LPCWSTR lpwszName, LONG& lEntryNum);
		STDMETHOD(InitEntry)(IITGroup *piitGroup, LONG& lEntryNum);
		STDMETHOD(SetEntry)(LONG lEntryNum);
		STDMETHOD(ClearEntry)(LONG lEntryNum);
		STDMETHOD(SetDefaultOp)(LONG iDefaultOp);
		STDMETHOD(ToString)(LPWSTR *ppwBuffer);

		// private data members
	private:

		LONG m_fDirty;
		LONG m_iEntryMax;
		LONG m_rgfEntries;  // 32-bit flag

		LONG m_iDefaultOp;
		IITGroup* m_rgpGroup[ITGP_MAX_GROUPARRAY_ENTRIES];
		IITGroup* m_pGroup;  // the composed group

};

#endif // __GROUPIMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\atlinc.h ===
// ATLINC.H:  Common includes used primarily for ATL

#ifndef __ATLINC_H__
#define __ATLINC_H__

#define _WIN32_WINNT 0x0400
#define _ATL_FREE_THREADED

#define _ATL_NO_UUIDOF 

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\assertf.h ===
/*****************************************************************************
*                                                                            *
*  ASSERTF.H                                                                 *
*                                                                            *
*  Copyright (C) Microsoft Corporation 1990.                                 *
*  All Rights reserved.                                                      *
*                                                                            *
******************************************************************************
*                                                                            *
*  Module Intent                                                             *
*                                                                            *
*  Interface to assertion macros.                                            *
*                                                                            *
******************************************************************************
*                                                                            *
*  Testing Notes                                                             *
*                                                                            *
******************************************************************************
*                                                                            *
*  Current Owner:                                                            *
*                                                                            *
******************************************************************************
*                                                                            *
*  Released by Development:                                                  *
*                                                                            *
*****************************************************************************/

/*****************************************************************************
*
*  Revision History:  Created 00/00/00 by God
*
*	 12/04/91 DAVIDJES  changed for LilJoe move to Orkin debugging technology
*
*****************************************************************************/

#include <orkin.h>

#ifndef _DEBUG

#define assert(f)

#ifndef MOS
#ifdef Assert
#undef Assert
#endif

#define Assert(f)
#endif

#define AssertF(f)
#define NotReached()
#define VerifyF(f)		  (f)
#define FVerifyF(f)		  (f)
#define Ensure( x1, x2 )  (x1)
#define Deny( x1, x2 )    (x1)
#define DoDebug(x)

#else

#ifndef MOS

#ifdef Assert
#undef Assert
#endif

// This is already defined in MOS' debug.h included in <orkin.h>
// 'assert' is then diverted to a more user friendly one in MOS' debug.lib
#define Assert(f)		assert(f)
#endif

#define AssertF(f)	assert(f)
#define NotReached()	assert(0)
#define VerifyF(f)	assert(f)
#define FVerifyF(f)	assert(f)
#define Ensure( x1, x2 )  assert((x1)==(x2))
#define Deny( x1, x2 )    assert((x1)!=(x2))
#define DoDebug(x)	(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\bfnew.h ===
/*****************************************************************************
*                                                                            *
*  BF.H                                                                      *
*                                                                            *
*  Copyright (C) Microsoft Corporation 1990.                                 *
*  All Rights reserved.                                                      *
*                                                                            *
******************************************************************************
*                                                                            *
*  Module Intent                                                             *
*    This module implements generic buffers that can expand to any size.     *
*                                                                            *
******************************************************************************
*                                                                            *
*  Testing Notes                                                             *
*                                                                            *
******************************************************************************
*                                                                            *
*  Current Owner:                                     *
*                                                                            *
******************************************************************************
*                                                                            *
*  Released by Development:     (date)                                       *
*                                                                            *
*****************************************************************************/


/*****************************************************************************
*                                                                            *
*                               Defines                                      *
*                                                                            *
*****************************************************************************/
#ifndef __BFNEW_H__ // {
#define __BFNEW_H__

#ifdef __cplusplus
extern "C" {
#endif

#define MINIMUM_ADD	0x100  // our threshold for small amounts

// String buffer
#define CALC_LENGTH					((WORD)0xffff)

/*****************************************************************************
*                                                                            *
*                               Typedefs                                     *
*                                                                            *
*****************************************************************************/

/* Structure for a generic, expandable buffer. */
typedef struct 
  {
  HANDLE hnd;
  DWORD  cIncr;
  HANDLE hBuf;
  DWORD  cbSize;              /* Number of bytes currently in buffer */
  DWORD  cbMax;               /* Amount allocated in qvBuffer        */
  LPVOID  qBuffer;
  } BF, FAR * LPBF, FAR * LPSB;  // a string buffer is a special case of a buffer

/*****************************************************************************
*                                                                            *
*                            Static Variables                                *
*                                                                            *
*****************************************************************************/

/*****************************************************************************
*                                                                            *
*                               Prototypes                                   *
*                                                                            *
*****************************************************************************/

/* Generic buffer interface */
#define DynBufferPtr(lpbf) ((LPBYTE)((lpbf)->qBuffer))
#define DynBufferLen(lpbf) ((lpbf)->cbSize)
#define DynBufferEmpty(lpbf) ((lpbf)->cbSize == 0)
#define DynBufferReset(lpbf) (MEMSET((lpbf)->qBuffer, 0, (lpbf)->cbSize), ((lpbf)->cbSize = 0))
#define DynBufferSetLength(lpbf, w) (((w) > (lpbf)->cbSize) ? DynBufferEnsureAdd(lpbf, (w) - (lpbf)->cbSize), ((lpbf)->cbSize = (w)) : ((lpbf)->cbSize = (w)))
#define DynBufferGetHandle(lpbf)  ((lpbf)->hBuf)
#define DynBufferNullifyHandle(lpbf) ((lpbf)->hBuf = NULL)
#define DynBufferEnsureAdd(lpbf, w) (((lpbf)->cbSize + (w) <= (lpbf)->cbMax) ? TRUE : InternalEnsureAdd(lpbf, w))


LPBF DynBufferAlloc(DWORD cbIncr);
LPBYTE DynBufferAppend(LPBF, LPBYTE, DWORD);
LPBYTE DynBufferInsert(LPBF lpbf, DWORD lib, LPBYTE qbData, SHORT cbData);
BOOL InternalEnsureAdd(LPBF, DWORD);


// Use these to append small amounts quickly, but since this doesn't check for
// overflow, the caller has to check this themselves if appropriate

#ifdef _DEBUG
#define Xassert(x) assert(x)
#else
#define Xassert(x) 0
#endif
#define DynBufferAppendByte(lpbf, b) \
(\
		*(((QB)(lpbf)->qBuffer) + (lpbf)->cbSize) = (b), \
	   	(lpbf)->cbSize++, \
		Xassert((lpbf)->cbSize <= (lpbf)->cbMax), \
		(lpbf)->qBuffer \
)
#define DynBufferAppendWord(lpbf, w) \
(\
		*(LPWORD)(((QB)(lpbf)->qBuffer) + (lpbf)->cbSize) = (w), \
	   	(lpbf)->cbSize += 2, \
		Xassert((lpbf)->cbSize <= (lpbf)->cbMax), \
		(lpbf)->qBuffer \
)

#define DynBufferAppendDword(lpbf, dw) \
(\
		*(LPDWORD)(((QB)(lpbf)->qBuffer) + (lpbf)->cbSize) = (dw), \
	   	(lpbf)->cbSize += 4, \
		Xassert((lpbf)->cbSize <= (lpbf)->cbMax), \
		(lpbf)->qBuffer \
)

#define DynBufferPeekByte(lpbf, lich, lpb) (((lich) >= 0 && (lich) < (lpbf)->cbSize) ? \
	(*(lpb) = *(((QB)(lpbf)->qBuffer) + (lich))), 1 : 0)

#define DynBufferUngetByte(lpbf, lpb) (((lpbf)->cbSize > 0) ? \
	(--(lpbf)->cbSize, *(lpb) = *(((QB)(lpbf)->qBuffer) + (lpbf)->cbSize)), 1 : 0)

#define DynBufferUngetWord(lpbf, lpw) (((lpbf)->cbSize > 1) ? \
	((lpbf)->cbSize -= 2, *(lpw) = *(LPWORD)(((QB)(lpbf)->qBuffer) + (lpbf)->cbSize)), 2 : 0)

VOID DynBufferFree(LPBF lpbf);

#define DynBufferGrow(lpbf, w)	DynBufferAppend(lpbf, NULL, w)
#ifdef _UNICODE
#define DynBufferAppendChar(lpbf, ch) DynBufferAppendWord(lpbf, (WORD)ch)
#else
#define DynBufferAppendChar(lpbf, ch) DynBufferAppendByte(lpbf, (BYTE)ch)
#endif

#ifdef __cplusplus
}
#endif

#endif // __BFNEW_H__ }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\address.h ===
#ifndef __ADDRESS_H__
#define __ADDRESS_H__

#pragma pack(1)		// avoid problems when Zp!=1

#ifndef MVADDR_DEFINED
#define MVADDR_DEFINED

#ifndef DWORD_NIL
#define DWORD_NIL ((DWORD)0xFFFFFFFF)
#endif

/////// MEDIAVIEW 2.0 ADDRESSES
// some of the following assume that the two addresses are in the same topic.
// but this is a valid assumption.  Note that the elements of the addresses, the
// TPID and TPO, are DWORDs, so arithmetic should be performed accordingly.
#define MVAddrFromTopicUID(lp, x)  ((lp)->tpid = (x), (lp)->tpo =  0L)
#define MVTopicUIDFromAddr(lp)   ((lp)->tpid)
#define MVAddrSame(mva1, mva2)  (((mva1).tpo == (mva2).tpo) && ((mva1).tpid == (mva2).tpid))
#define MVAddrCompare(x1, x2) (\
								((x1).tpid != (x2).tpid) ? \
                                    (((x1).tpid > (x2).tpid) ? 1 : -1) : \
                                    ( \
										((x1).tpo != (x2).tpo) ? (((x1).tpo > (x2).tpo) ? 1 : -1) : 0 \
									) \
                              )
#define MVAddrAssign(mva1, mva2)  ((mva1) = (mva2))
#define MVAddrSetNil(mva)  ((mva).tpo = DWORD_NIL, (mva).tpid = DWORD_NIL)
#define MVAddrAddOffset(mva, dw) ((mva).tpo += (dw), (mva))
#define MVAddrSetOffset(mva, dw) ((mva).tpo = (dw), (mva))
#define MVAddrDiff(mva1, mva2) ((LONG)((mva1).tpo - (mva2).tpo))
#define MVAddrSwap(mva)  (((mva).tpo) = SWAPLONG((mva).tpo), ((mva).tpid) = SWAPLONG((mva).tpid))
#define MVAddrGetTopicId(lpmva) ((DWORD)(((LPMVADDR)(lpmva))->tpid))
#define MVAddrGetTopicOffset(lpmva) ((DWORD)(((LPMVADDR)(lpmva))->tpo))
#define MVAddrSetTopic(lpmvaTopic, lpmva) (((LPMVADDR)(lpmvaTopic))->tpid = (lpmva)->tpid, (lpmvaTopic)->tpo = 0L)
#define MVAddrIsNil(mva) ((mva).tpo == DWORD_NIL && (mva).tpid == DWORD_NIL)
#define MVAddrMake(lp, dw1, dw2)  ((lp)->tpid = ((DWORD)(dw1)), (lp)->tpo = ((DWORD)(dw2)))

typedef DWORD TPID;	      // topic unique identifier
typedef DWORD TPO;   // offset into text of topic

typedef struct tagMVADDR {
	TPID tpid;
	TPO tpo;
} MVADDR, FAR *LPMVADDR;

#endif // MVADDR_DEFINED

typedef MVADDR  VA, FAR *QVA, FAR *LPVA;
typedef MVADDR  ADDR, FAR *QADDR, FAR *LPADDR;
typedef MVADDR  PA, FAR *QPA, FAR *LPPA;
#define vaNil DWORD_NIL
#define paNil DWORD_NIL

// for conversion purposes, mv1.4 VA becomes the same as mv1.4 ADDR
// and both of these contain a topic offset only

#define OffsetToVA(pva, off)  ((pva)->tpo = (off))
#define VAToOffset(pva) ((pva)->tpo)  // only valid within topics

typedef DWORD     OBJRG;
typedef OBJRG FAR *QOBJRG;
#define objrgNil  (OBJRG) -1

typedef DWORD    COBJRG;
typedef COBJRG FAR *QCOBJRG;
#define cobjrgNil (COBJRG) -1


#pragma pack()		// avoid problems when Zp!=1

#endif // !defined(__ADDRESS_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\ccfiles.h ===
// CCFILES.H
// Macro definition of file anmes used by itcc

// Unicode definitions

#ifndef __CCFILES_H__
#define __CCFILES_H__

// Character count for longest object prefix (NOT COUNTING NULL)
#define CCH_MAX_OBJ_STORAGE             10

#define SZ_OBJINST_STREAM               L"$OBJINST"
#define SZ_CATALOG_STORAGE              L"$CTCATALOG"
#define SZ_WW_STORAGE                   L"$WW"
#define SZ_GP_STORAGE                   L"$GP"
#define SZ_FI_STREAM                    L"$FI"

#define SZ_BTREE_BTREE                  L"BTREE"
#define SZ_BTREE_DATA                   L"DATA"
#define SZ_BTREE_HEADER                 L"PROPERTY"
#define SZ_WORDWHEEL_MAP                L"MAP"
#define SZ_WORDWHEEL_INDEX              L"INDEX"
#define SZ_WORDWHEEL_STOP               L"STOP"
#define SZ_GROUP_MAIN                   L"MAIN"

// ASCII Defintions
#define SZ_CATALOG_STORAGE_A            "$CTCATALOG"
#define SZ_WW_STORAGE_A                 "$WW"
#define SZ_GP_STORAGE_A                 "$GP"
#define SZ_FI_STREAM_A                  "$FI"

#define SZ_BTREE_BTREE_A                "BTREE"
#define SZ_BTREE_DATA_A                 "DATA"
#define SZ_BTREE_HEADER_A               "PROPERTY"
#define SZ_WORDWHEEL_MAP_A              "MAP"
#define SZ_WORDWHEEL_INDEX_A            "INDEX"
#define SZ_WORDWHEEL_STOP_A             "STOP"
#define SZ_GROUP_MAIN_A                 "MAIN"


#define CCH_MAX_OBJ_NAME                256

#endif /* __CCCFILES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\itcat.h ===
// ITCAT.H:	IITCatalog interface declaration

#ifndef __ITCAT_H__
#define __ITCAT_H__

#include <comdef.h>

// {F21B1A31-A9F2-11d0-A871-00AA006C7D01}
DEFINE_GUID(IID_IITCatalog,
0xf21b1a31, 0xa9f2, 0x11d0, 0xa8, 0x71, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#ifdef ITPROXY

// {F21B1A32-A9F2-11d0-A871-00AA006C7D01}
DEFINE_GUID(CLSID_IITCatalog,
0xf21b1a32, 0xa9f2, 0x11d0, 0xa8, 0x71, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daaa-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITCatalogLocal,
0x4662daaa, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY


// Forward declarations
interface IITDatabase;
interface IITResultSet;

DECLARE_INTERFACE_(IITCatalog, IUnknown)
{
	STDMETHOD(Open)(IITDatabase* lpITDB, LPCWSTR lpszwName = NULL) PURE;
	STDMETHOD(Close)(void) PURE;
	STDMETHOD(Lookup)(IITResultSet* pRSIn, IITResultSet* pRSOut = NULL) PURE;
	STDMETHOD(GetColumns)(IITResultSet* pRS) PURE;
};

typedef IITCatalog* LPITCATALOG;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\freelist.h ===
/***************************************************************************\
*
*  FREELIST.H
*
*  Copyright (C) Microsoft Corporation 1995.
*  All Rights reserved.
*
*****************************************************************************
*
*  Program Description: Private header for FREELIST Modules
*
*****************************************************************************
*
*  Revision History: Created 07/17/95 - davej
*
*
*****************************************************************************
*
*  Notes:  Free blocks are always kept in order by their starting position.
*
*****************************************************************************
*
*  Known Bugs: None
*
\***************************************************************************/

// If Critical structures get messed up in /Zp8, use:
// #pragma pack(1)

#ifndef __FREELIST_H__
#define __FREELIST_H__

#include <fileoff.h>
#include <iterror.h>


/***************************************************************************\
*
*                               Defines
*
\***************************************************************************/

typedef HANDLE HFREELIST;

/***************************************************************************\
*
*                               Types
*
\***************************************************************************/

/***************************************************************************\
*
*                           Free List Private Types
*
\***************************************************************************/



#ifdef __cplusplus
extern "C" {
#endif

#pragma pack(1)

typedef struct _freelist_stats
{
	DWORD dwBytesInFreeList;
	DWORD dwBytesLostForever;
	DWORD dwSmallestBlock;
	DWORD dwLargestBlock;
	WORD  wNumBlocks;
} FREELISTSTATS, FAR * LPFREELISTSTATS;

typedef struct _freelist_hr
{
	WORD wNumBlocks;			// Number of blocks in list
	WORD wMaxBlocks;			// Max number of blocks in list	
	DWORD dwLostBytes;			// Number of bytes totally lost forever
} FREELISTHDR;

typedef struct _freeitem
{
	FILEOFFSET foStart;			// Start of free block
	FILEOFFSET foBlock;			// Size of free block
} FREEITEM, FAR * QFREEITEM;

typedef struct _freelist
{	
	FREELISTHDR flh;
	FREEITEM afreeitem[1];
} FREELIST, FAR * QFREELIST;

#pragma pack()


HFREELIST 	PASCAL FAR FreeListInit			( WORD, LPERRB );
HFREELIST   PASCAL FAR FreeListRealloc      ( HFREELIST, WORD, LPERRB );
LONG 		PASCAL FAR FreeListSize			( HFREELIST, LPERRB );
LONG        PASCAL FAR FreeListBlockUsed    ( HFREELIST, LPERRB );
RC			PASCAL FAR FreeListDestroy		( HFREELIST );
RC			FAR FreeListAdd			        ( HFREELIST, FILEOFFSET, FILEOFFSET );
FILEOFFSET 	PASCAL FAR FreeListGetBestFit	( HFREELIST, FILEOFFSET, LPERRB );
FILEOFFSET	PASCAL FAR FreeListGetBlockAt	( HFREELIST, FILEOFFSET, LPERRB );
RC 			PASCAL FAR FreeListGetLastBlock	( HFREELIST, FILEOFFSET *, FILEOFFSET *, FILEOFFSET );

HFREELIST 	PASCAL FAR FreeListInitFromMem	( LPVOID, LPERRB );
RC 			PASCAL FAR FreeListGetMem		( HFREELIST, LPVOID );
LONG 		PASCAL FAR FreeListSizeFromMem	( LPVOID, LPERRB );

RC 			PASCAL FAR FreeListGetStats		( HFREELIST hFreeList, LPFREELISTSTATS lpStats);

/***************************************************************************
 *
 *	Cute little memory block manager incorporating the free list!
 *
 ***************************************************************************/

LPSTR 	PASCAL FAR EXPORT_API NewMemory( WORD wcbSize );
void 	PASCAL FAR EXPORT_API DisposeMemory( LPSTR lpMemory);
WORD 	PASCAL FAR EXPORT_API StatusOfMemory( void );


#ifdef __cplusplus
}
#endif


#endif // __FREELIST_H__


/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\font.h ===
#ifndef __FONT_H__
#define __FONT_H__

#ifdef __cplusplus
extern "C" {
#endif

/*****************************************************************************
*                                                                            *
*  FONT.H                                                                    *
*                                                                            *
*  Copyright (C) Microsoft Corporation 1990 - 1994.                          *
*  All Rights reserved.                                                      *
*                                                                            *
******************************************************************************
*                                                                            *
*  Module Intent                                                             *
*                                                                            *
*  Structures for font handling and export of FONTLYR.C APIs                 *
*                                                                            *
******************************************************************************
*                                                                            *
*  Current Owner: RHobbs                                                     *
*                                                                            *
*****************************************************************************/

/****************************************************************************
*                               Constants                                   *
*****************************************************************************/


#define coDEFAULT  RGB(1, 1, 0)

#define coBLACK    RGB(  0,   0,   0)
#define coBLUE     RGB(  0,   0, 255)
#define coCYAN     RGB(  0, 255, 255)
#define coGREEN    RGB(  0, 255,   0)
#define coMAGENTA  RGB(255,   0, 255)
#define coRED      RGB(255,   0,   0)
#define coYELLOW   RGB(255, 255,   0)
#define coWHITE    RGB(255, 255, 255)
#define coDARKBLUE		RGB(  0,   0, 128)
#define coDARKCYAN		RGB(  0, 128, 128)
#define coDARKGREEN		RGB(  0, 128,   0)
#define coDARKMAGENTA	RGB(128,   0, 128)
#define coDARKRED		RGB(128,   0,   0)
#define coDARKYELLOW	RGB(128, 128,   0)
#define coDARKGREY		RGB(128, 128, 128)
#define coLIGHTGRAY		RGB(192, 192, 192)

#define coNIL      ((DWORD)0x80000000L)



#define iFntNil     ((SHORT)-1) // Protect comparisons in WIN32
#define iFntDefault  0

#define idStyleNil       ((SHORT)0) 
#define idStyleDefault   idStyleNil     // The default style is...none
#define idStyleInternalIndexOrigin  1

#define FONT_CACHE_DEFAULT_SIZE 12   // Maximum previously created fonts are remembered.

/****************************************************************************
*                               TypeDefs                                    *
*****************************************************************************/

#pragma warning(disable : 4200)  // for zero-sized array
typedef struct kerntable_tag
  {
  short cKernPairs;
  short rgIndexToKernPairs[256];
  KERNINGPAIR rgKernPairs[0];
  } KERNTABLE, FAR *QKERNTABLE;
#pragma warning(default : 4200)

// Critical structure that gets messed up in /Zp8
#pragma pack(1)

#define FONT_FILE_HEADER_SIZE   40

typedef struct {
  SHORT  iFntNameCount;
  SHORT  iFntEntryCount;
  SHORT  iFntNameTabOff;            // MUST be the 3rd entry for backward comp.
  SHORT  iFntEntryTabOff;           // CF entry offset
  SHORT  iStyleEntryCount;
  SHORT  iStyleEntryTabOff;
  SHORT  iCharMapNameCount;         // Number of charmap entries
  SHORT  iCharMapNameOff;           // Offset to charmap's filename
  SHORT  iCharMapPtrOff;            // Offset to all charmap pointers
  SHORT  iCharMapFlag;
} FONTTABLE, FAR *QFONTTABLE;


// LOGFONTJR is the LOGFONT structure with no lfFaceName field.
// Under Windows, the first  five fields of LOGFONT are int's;
// under Windows NT and the Windows Library for Macintosh, the
// first five fields of the LOGFONT structure are LONG's.  This
// structure uses the NT and Mac format.
typedef struct
{
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
} LOGFONTJR, FAR *QLOGFONTJR;

typedef struct
  {
  BYTE red;
  BYTE green;
  BYTE blue;
  } RGBS, FAR *QRGBS;


#ifdef MOS
// We need converters from 16bit logfont to 32bit.
#define QvCopyLogfontFromLogfontjr( lf, lfjr) \
  ( (lf)->lfHeight = (int)(lfjr)->lfHeight, \
    (lf)->lfWidth = (int)(lfjr)->lfWidth, \
    (lf)->lfEscapement = (int)(lfjr)->lfEscapement, \
    (lf)->lfOrientation = (int)(lfjr)->lfOrientation, \
    (lf)->lfWeight = (int)(lfjr)->lfWeight, \
    *((DWORD*)&((lf)->lfItalic)) = *((DWORD*)&((lfjr)->lfItalic)), \
    *((DWORD*)&((lf)->lfOutPrecision)) = *((DWORD*)&((lfjr)->lfOutPrecision)) \
  )     
#define QvCopyLogfontjrFromLogfont( lfjr, lf) \
  ( (lfjr)->lfHeight = (short)(lf)->lfHeight, \
    (lfjr)->lfWidth = (short)(lf)->lfWidth, \
    (lfjr)->lfEscapement = (short)(lf)->lfEscapement, \
    (lfjr)->lfOrientation = (short)(lf)->lfOrientation, \
    (lfjr)->lfWeight = (short)(lf)->lfWeight, \
    *((DWORD*)&((lfjr)->lfItalic)) = *((DWORD*)&((lf)->lfItalic)), \
    *((DWORD*)&((lfjr)->lfOutPrecision)) = *((DWORD*)&((lf)->lfOutPrecision)) \
  )     

#endif // MOS

// When you change this structure, you MUST make a corresponding change
// to cfDefault in the file, OUTTEXT.C, in the compiler sources. Make sure
// that LOGFONTJR is 4-byte alignment for MIPS
typedef struct
{
  WORD wIdFntName;       // Font name id
  SHORT  iExpansion;     // positive for expansion; negative for compression
  SHORT  idStyleInternal;
  COLORREF clrFore;
  COLORREF clrBack;
  LOGFONTJR lf;
  BYTE bFlags;
  char bSubSuper;               // positive for superscript; negative for subscript
} CF, FAR *QCF, FAR *LPCF;

// Bit flags for the CF bFlags field.
#define fHIDDEN        0x0001
#define fHOTSPOT       0x0002
#define fSMALLCAPS     0x0004
#define fNOUNDERLINE   0x0008  // Used by char styles to remove underlining
#define fDOTUNDERLINE  0x0010
#define fWORDUNDERLINE 0x0020
#define fDBLUNDERLINE  0x0040
#define fOUTLINE	   0x0080


#define STYLESIZE      64

typedef struct                     // Style Sheet Entry
  {
  SHORT  idStyleInternal;          // ID for this style sheet
  SHORT  idStyleBasedOnInternal;        // ID for style sheet this one is based on
  CF   cf;                         // character format for this style sheet
  BYTE bFlags;                     // TRUE if additive style; else FALSE
  BYTE bUnusedPad;
  char lfFaceName[LF_FACESIZE+1];  // Font face name for this style
  char szStyleName[STYLESIZE+1];   // Name for this style sheet
} STE, NEAR *PSTE, FAR *LPSTE;

// Bit flags for the STE bFlags field.
#define fADDITIVE 0x0001

// Critical structure that gets messed up in /Zp8
#pragma pack()

/*****************************************************************************
*                Defines for Backwards Compatibility                         *
*****************************************************************************/

#define OLD_LF_FACESIZE 20
// #define OLD_FONTTABLE_SIZE (sizeof(FONTTABLE) - (sizeof(SHORT) * 2))


/*****************************************************************************
*                               Prototypes                                   *
*****************************************************************************/

BOOL FAR PASCAL fCreateFntCache(QDE);
VOID FAR PASCAL DestroyFntCache(QDE);
VOID FAR PASCAL ClearFntCache(QDE);
BOOL FAR PASCAL fSetFont(QDE, SHORT);
BOOL FAR PASCAL GetCFFromHandle (QDE, int, QCF, QCH);
VOID FAR PASCAL FontTableInfoFree (HANDLE);


#ifdef __cplusplus
}
#endif

#endif	// __FONT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\dynarray.h ===
/*************************************************************************
*                                                                        *
*  DYNARRAY.C                                                            *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1994-1995                         *
*  All Rights reserved.                                                  *
*                                                                        *
* This library implements a robust dynamic array scheme. It replaces the *
* old DRG structure and should probably also replace the MR.			 *
* The total size of the array is NOT limited to 64K since it uses        *
* Binh's threaded block memory manager to add new elements. Therefore it *
* should work correctly on both 16- and 32-bit platforms for any number  *
* of elements.                                                           *
*																		 *
* Items in the array are assumed to be of a fixed size, which is defined *
* when the array is first initialized.  To speed up the common operation *
* of forward enumeration, the next element function/macro is provided.	 *
*																		 *
* There are two types of lists possible:  normal, and single-block  	 *
* Use single-block for better space and possible more efficient time     *
* usage when you know that your entire array will fit within a block.    *
* Allocations beyond the one block limit will return NULL.               *
*																	     *
* The first member of any element in the array MUST be an LPVOID.        *																     *
* UNIMPLEMENTED: Insert into, delete									 *
**************************************************************************
*                                                                        *
**************************************************************************
*                                                                        *
*  Written By   : KevynCT                                                *
*  Current Owner: KevynCT                                                *
*                                                                        *
**************************************************************************/
#ifndef __DYNARRAY_H__
#define __DYNARRAY_H__

#if defined( __cplusplus )
extern "C" {
#endif

#define CALC_BLOCK_SIZE(x, y) (sizeof(x) * (y))
#define DEFAULT_BLOCK_MAX	((WORD)0xFFFF)

#define DynArrayValid(lpdl)	((lpdl)->lpBlockHead)
#define DynArrayGetNumElts(lpdl)	((lpdl)->cFoo)
#define DynArrayEmpty(lpdl) ((lpdl)->cFoo == 0)
#define DynArraySingleBlockGetNumElts(lpdl)	((lpdl)->cFoo)

#define DynArrayGetFirstElt(lpdl)	((lpdl)->lpFooCache = (lpdl)->lpFooHead)
#define DynArraySingleBlockGetFirstElt(lpdl)	((lpdl)->lpFooHead)

#define DynArrayGetCurElt(lpdl)	((lpdl)->lpFooCache)
#define DynArraySingleBlockGetCurElt(lpdl)	((lpdl)->lpFooCache)

#define DynArraySetCurElt(lpdl, lpv)	((lpdl)->lpFooCache = (lpv))
#define DynArraySingleBlockSetCurElt(lpdl, lpv)	((lpdl)->lpFooCache = (lpv))

#define DynArrayNextElt(lpdl) ((lpdl)->lpFooCache = *(LPVOID FAR *)((lpdl)->lpFooCache))
#define DYN_ARRAY_SINGLEBLOCK	0x00000001

#define DynArrayEltCopy(lpdest, lpsrc, size)  MEMCPY(((LPBYTE)(lpdest)) + sizeof(LPVOID), \
													  ((LPBYTE)(lpsrc)) + sizeof(LPVOID), size - sizeof(LPVOID))
// init using some default settings
#define DynArrayInitDef(lpdl, s, wAvg) \
		DynArrayInit(lpdl, CALC_BLOCK_SIZE(s, wAvg), DEFAULT_BLOCK_MAX, sizeof(s), 0)
// DFL elements:
typedef struct tagDL
{
	LPBLK	lpBlockHead;	// the linked list of blocks for this list
	WORD	cbFoo;			// the (fixed) size of the list elements
	WORD	cFooPerBlock;
	DWORD	cFoo;	
	DWORD	dwFlags;
	LPVOID	lpFooHead;		// the first element of the linked list
	LPVOID	lpFooFree;		// the next free element of the linked list
	LPVOID	lpFooCache;		// the last element accessed by an element method.
} DL, FAR *LPDL;


///// ordinary (multi-block) arrays
BOOL PASCAL FAR		DynArrayInit(LPDL lpdl, DWORD BlockSize, WORD cMaxBlock, WORD wElemSize, DWORD dwFlags);
LPVOID PASCAL FAR 	DynArrayAppendElt(LPDL lpdl);
LPVOID PASCAL FAR 	DynArrayGetOrdinalElt(LPDL lpdl, DWORD dwEltIndex);
//_inline LPVOID PASCAL FAR DynArrayNextElt(LPDL lpdl);
LPVOID PASCAL FAR	DynArrayClearElt(LPDL lpdl);
VOID PASCAL FAR 	DynArrayFree(LPDL lpdl);
VOID PASCAL FAR  	DynArrayReset(LPDL lpdl);

///// single-block arrays
#ifdef SINGLE_BLOCK
BOOL PASCAL FAR DynArraySingleBlockInit(LPDL lpdl, DWORD BlockSize, WORD wElemSize, DWORD dwFlags);
LPVOID PASCAL FAR DynArraySingleBlockAppendElt(LPDL lpdl);
LPVOID PASCAL FAR DynArraySingleBlockGetOrdinalElt(LPDL lpdl, DWORD dwEltIndex);
_inline LPVOID PASCAL FAR DynArraySingleBlockNextElt(LPDL lpdl);
#define DynArraySingleBlockClearElt(lpdl) DynArrayClearElt(lpdl)
#define DynArraySingleBlockFree(lpdl) DynArrayFree(lpdl)
#define DynArraySingleBlockReset(lpdl) DynArrayReset(lpdl)
#endif

#if defined( __cplusplus )
}
#endif

#endif	// __DYNARRAY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\itdb.h ===
// ITDB.H:	ITDatabase interface declaration

#ifndef __ITDB_H__
#define __ITDB_H__

// {8fa0d5a2-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITDatabase, 
0x8fa0d5a2, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#ifdef ITPROXY

// {66673452-8C23-11d0-A84E-00AA006C7D01}
DEFINE_GUID(CLSID_IITDatabase, 
0x66673452, 0x8c23, 0x11d0, 0xa8, 0x4e, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daa9-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITDatabaseLocal, 
0x4662daa9, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY


// Guaranteed to be an invalid value for dwObjInstance params in IITDatabase
// methods.
#define	IITDB_OBJINST_NULL	((DWORD) 0xFFFFFFFF)


DECLARE_INTERFACE_(IITDatabase, IUnknown)
{
	STDMETHOD(Open)(LPCWSTR lpszHost, LPCWSTR lpszMoniker, DWORD dwFlags) PURE;
	STDMETHOD(Close)(void) PURE;

	// Creates an unnamed object that can be referenced in the future
	// by *pdwObjInstance.  Note that the value in *pdwObjInstance will be
	// persisted by the database when it is asked to save via
	// IPersistStorage::Save.
	STDMETHOD(CreateObject)(REFCLSID rclsid, DWORD *pdwObjInstance) PURE;

	// Retrieves a specified IUnknown-based interface on the object identified
	// by dwObjInstance.
	STDMETHOD(GetObject)(DWORD dwObjInstance, REFIID riid, LPVOID *ppvObj) PURE;

	// To obtain a pointer to a named object's persistence the object's full
	// name (including any object-specific type prefix) should be passed in
	// lpswszObject.  If *lpwszObject is NULL, then the database's own storage
	// will be returned.  If lpwszObject is NULL, then dwObjInstance will be
	// used to identify the object and locate its persistence.  On exit,
	// *ppvPersistence will be either an IStorage* or an IStream*, depending
	// on what the caller specified with the fStream param.  The caller should
	// assume that only read operations can be performed on *ppvPersistence.
	// If the specified object's persistence doesn't exist, or if it exists
	// but is of the wrong type, then STG_E_FILENOTFOUND will be returned. 
	STDMETHOD(GetObjectPersistence)(LPCWSTR lpwszObject, DWORD dwObjInstance,
									LPVOID *ppvPersistence, BOOL fStream) PURE;
};

typedef IITDatabase* LPITDB;

#endif		// __ITDB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\itgroup.h ===
// ITGROUP.H:  IITGroup interface declaration

#ifndef __ITGROUP_H__
#define __ITGROUP_H__

//#include <comdef.h>

// {B1A6CA91-A479-11d0-9741-00AA006117EB}
DEFINE_GUID(IID_IITGroup, 
0xb1a6ca91, 0xa479, 0x11d0, 0x97, 0x41, 0x0, 0xaa, 0x0, 0x61, 0x17, 0xeb);

// {98258914-B6AB-11d0-9D92-00A0C90F55A5}
DEFINE_GUID(IID_IITGroupArray, 
0x98258914, 0xb6ab, 0x11d0, 0x9d, 0x92, 0x0, 0xa0, 0xc9, 0xf, 0x55, 0xa5);

#ifdef ITPROXY

// {B1A6CA92-A479-11d0-9741-00AA006117EB}
DEFINE_GUID(CLSID_IITGroup, 
0xb1a6ca92, 0xa479, 0x11d0, 0x97, 0x41, 0x0, 0xaa, 0x0, 0x61, 0x17, 0xeb);

// {98258915-B6AB-11d0-9D92-00A0C90F55A5}
DEFINE_GUID(CLSID_IITGroupArray, 
0x98258915, 0xb6ab, 0x11d0, 0x9d, 0x92, 0x0, 0xa0, 0xc9, 0xf, 0x55, 0xa5);

#else

// {4662daab-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITGroupLocal, 
0x4662daab, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daac-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITGroupArrayLocal, 
0x4662daac, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY

// Forward declarations
interface IITDatabase;

DECLARE_INTERFACE_(IITGroup, IUnknown)
{

	STDMETHOD(Initiate)(DWORD lcGrpItem) PURE;
	STDMETHOD(CreateFromBitVector)(LPBYTE lpBits, DWORD dwSize, DWORD dwItems) PURE;
	STDMETHOD(CreateFromBuffer)(HANDLE h) PURE;
    STDMETHOD(Open)(IITDatabase* lpITDB, LPCWSTR lpszMoniker) PURE;
    STDMETHOD(Free)(void) PURE;
	STDMETHOD(CopyOutBitVector)(IITGroup* pIITGroup) PURE;
    STDMETHOD(AddItem)(DWORD dwGrpItem) PURE;
    STDMETHOD(RemoveItem)(DWORD dwGrpItem) PURE;
	STDMETHOD(FindTopicNum)(DWORD dwCount, LPDWORD lpdwOutputTopicNum) PURE;
	STDMETHOD(FindOffset)(DWORD dwTopicNum, LPDWORD lpdwOutputOffset) PURE;
    STDMETHOD(GetSize)(LPDWORD dwGrpSize) PURE;
	STDMETHOD(Trim)(void) PURE;
	STDMETHOD(And)(IITGroup* pIITGroup) PURE;
	STDMETHOD(And)(IITGroup* pIITGroupIn, IITGroup* pIITGroupOut) PURE;
	STDMETHOD(Or)(IITGroup* pIITGroup) PURE;
	STDMETHOD(Or)(IITGroup* pIITGroupIn, IITGroup* pIITGroupOut) PURE;
	STDMETHOD(Not)(void) PURE;
	STDMETHOD(Not)(IITGroup* pIITGroupOut) PURE;
	STDMETHOD(IsBitSet)(DWORD dwTopicNum) PURE;
	STDMETHOD(CountBitsOn)(LPDWORD lpdwTotalNumBitsOn) PURE;
	STDMETHOD(Clear)(void) PURE;
    STDMETHOD_(LPVOID, GetLocalImageOfGroup)(void) PURE;
    STDMETHOD(PutRemoteImageOfGroup)(LPVOID lpGroupIn) PURE;

};

typedef IITGroup* LPITGROUP;

#define ITGP_MAX_GROUPARRAY_ENTRIES 32   // maximum number of groups allowed in a collection
#define ITGP_ALL_ENTRIES (-1L)
#define ITGP_OPERATOR_OR   0
#define ITGP_OPERATOR_AND  1

DECLARE_INTERFACE_(IITGroupArray, IITGroup)
{
	// composite group interface
	STDMETHOD(InitEntry)(IITDatabase *piitDB, LPCWSTR lpwszName, LONG& lEntryNum) PURE;
	STDMETHOD(InitEntry)(IITGroup *piitGroup, LONG& lEntryNum) PURE;
	STDMETHOD(SetEntry)(LONG lEntryNum) PURE;
	STDMETHOD(ClearEntry)(LONG lEntryNum) PURE;
	STDMETHOD(SetDefaultOp)(LONG cDefaultOp) PURE;
	STDMETHOD(ToString)(LPWSTR *ppwBuffer) PURE;
};

typedef IITGroupArray* LPIITGroupArray;
#endif // __ITGROUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\fileoff.h ===
/*****************************************************************************
 *                                                                            *
 *  FILEOFF.H                                                                 *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1995.                          *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  File Offset data type to replace using LONG for file offsets to handle    *
 *	files larger than 4 gigs in size.    									  *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  davej                                                     *
 *****************************************************************************/

/*****************************************************************************
 *
 *  Created 07/28/95 - davej
 *
 *****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __FILEOFF_H__
#define __FILEOFF_H__

#pragma pack(1)

typedef struct _fileoffset_t
{
	DWORD dwOffset;
	DWORD dwHigh;
} FILEOFFSET;

#pragma pack()

#endif	// __FILEOFF_H__

// Advance byte pointer past address (pointer must be at start of address)
#define ADVANCE_FO(sz) {while ((*(sz))&0x80) (sz)++; (sz)++;}

extern FILEOFFSET foNil;
extern FILEOFFSET foMax;
extern FILEOFFSET foMin;
extern FILEOFFSET foInvalid;

FILEOFFSET	PASCAL FAR EXPORT_API MakeFo(DWORD, DWORD);
FILEOFFSET	PASCAL FAR EXPORT_API FoFromSz(LPBYTE);
WORD 		PASCAL FAR EXPORT_API FoToSz(FILEOFFSET, LPBYTE);
WORD 		PASCAL FAR EXPORT_API LenSzFo(LPBYTE);
FILEOFFSET 	FAR EXPORT_API FoAddFo(FILEOFFSET, FILEOFFSET);
FILEOFFSET 	FAR EXPORT_API FoSubFo(FILEOFFSET, FILEOFFSET);
FILEOFFSET 	FAR EXPORT_API FoAddDw(FILEOFFSET, DWORD);
DWORD 		FAR EXPORT_API DwSubFo(FILEOFFSET, FILEOFFSET);
BOOL		PASCAL FAR EXPORT_API FoIsNil(FILEOFFSET);
BOOL		PASCAL FAR EXPORT_API FoEquals(FILEOFFSET, FILEOFFSET);
FILEOFFSET 	FAR EXPORT_API FoMultFo(FILEOFFSET fo1, FILEOFFSET fo2);
FILEOFFSET 	PASCAL FAR EXPORT_API FoMultDw(DWORD dw1, DWORD dw2);
short int 	PASCAL FAR EXPORT_API FoCompare(FILEOFFSET, FILEOFFSET);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\hash.h ===
#ifndef __HASH_H__
#define __HASH_H__

#ifdef __cplusplus
extern "C" {
#endif

/*****************************************************************************
*                                                                            *
*  HASH.H                                                                    *
*                                                                            *
*  Copyright (C) Microsoft Corporation 1990.                                 *
*  All Rights reserved.                                                      *
*                                                                            *
******************************************************************************
*                                                                            *
*  Module Intent                                                             *
*     This header contains typedefs and prototypes to compute hash values.   *
*                                                                            *
******************************************************************************
*                                                                            *
*  Testing Notes                                                             *
*                                                                            *
******************************************************************************
*                                                                            *
*  Current Owner:                                                            *
*                                                                            *
******************************************************************************
*                                                                            *
*  Released by Development:     (date)                                       *
*                                                                            *
*****************************************************************************/
/*****************************************************************************
*
*  Revision History:
*
*  07/22/90  RobertBu  I #ifdefed the type passed to these functions, so that
*            they would be FAR under WIN and PM.  REVIEW:  This should
*            be cleaned up!
*
*****************************************************************************/


/*****************************************************************************
*                                                                            *
*                               Definitions                                  *
*                                                                            *
*****************************************************************************/

/* This is the reserved invalid hash value.
*/
#define hashNil ((HASH)0)

/*****************************************************************************
*                                                                            *
*                               Typedefs                                     *
*                                                                            *
*****************************************************************************/

/* This number represents the hash of a context string.
 */
typedef ULONG HASH;
typedef HASH FAR *LPHASH;

/*****************************************************************************
*                                                                            *
*                               Prototypes                                   *
*                                                                            *
*****************************************************************************/
BOOL FAR PASCAL FValidContextSz(LPCSTR);
HASH FAR PASCAL HashFromSz(LPCSTR);
DWORD FAR PASCAL DwordFromSz(LPCSTR);
int FAR PASCAL StripSpaces(LPSTR szName);

#ifdef __cplusplus
}
#endif

#endif // ! HASH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\groups.h ===
/*************************************************************************
*                                                                        *
*  GROUP.H								                                 *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1995			             *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   All typedefs and defines needed for group				             *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: GarrG							                         *
*                                                                        *
**************************************************************************
*                                                                        *
*  Released by Development:     (date)                                   *
*                                                                        *
**************************************************************************
* Requires:
*	mverror.h
*/
#include <_mvutil.h>

// Critical structures that gets messed up in /Zp8
#pragma pack(1)

#define	FILE_HDR_SIZE		40

/*************************************************************************
 *                          Basic defines.
 *************************************************************************/

#if defined( __cplusplus )
extern "C" {
#endif

/*
 *	Various files stamps.
 *	This is to distinguish one file's type from another
 */
#define		GROUP_STAMP			0x3333

#define	GROUPVER	((WORD)20)

#define VALIDATE_GROUP(lpGroup) {\
	if (lpGroup == NULL || (lpGroup->version < 7 || lpGroup->version > GROUPVER) ||	lpGroup->FileStamp != GROUP_STAMP)\
		return E_FAIL;\
	return S_OK;\
    }

#define GROUPISBITSET(lpGroup, dwBit) \
    (lpGroup->lpbGrpBitVect[((dwBit) / 8)] & (1 << ((dwBit) % 8)))

/*************************************************************************
 *
 *                   Group Structure & Global Functions
 *
 *************************************************************************/

#define		GROUP_HDR_SIZE	FILE_HDR_SIZE
typedef	DWORD	LIBITGROUP;

/* Information that goes into the group file */

#define	GROUP_HEADER	\
	unsigned short FileStamp;       /* Group stamp */ \
    WORD    version;                /* Version number */ \
    DWORD   dwSize;                 /* Group size in bytes */ \
    DWORD   maxItem;                /* Largest item in group */ \
    DWORD   minItem;                /* Smallest item in group */ \
    DWORD   lcItem;                 /* Item's count */ \
    DWORD   maxItemAllGroup;        /* Maximum item of all groups */ \
	WORD  fFlag

typedef struct GROUP_HDR {
	GROUP_HEADER;
} GROUP_HDR;

#define	BITVECT_GROUP		0	// Normal bit vector group 
#define	HILO_GROUP			1	// HiLo group : no associated bit vector, only hi
								// &lo values 

#define	TRIMMED_GROUP		2	// Trimmed group : bit vector only contains bytes
								// between lo & hi

#define DISKCOMP_GROUP		3	// Disk Compression used
									// Must be expanded upon readin, becomes BITVECT_GROUP
#define DISKCOMP_TRIMMED_GROUP	4	// Disk Compression used 
									// Must be expanded upon readin, becomes TRIMMED_GROUP

/* Group structure */

/* Regular bit vector group */

typedef	struct	tagGroup {
    GROUP_HEADER;
    LPERRB  lperr;                  // Pointer to error buffer
    LPBYTE	lpbGrpBitVect;          // Pointer to group bit vector
    HANDLE	hGrpBitVect;            // Handle to "lpbGrpBitVect".
    HANDLE  hGroup;                 // Handle to this structure.
    LPSTR   lszGroupName;           // Group name
    DWORD   dwIndex;                // Group index
    struct  tagGroup FAR * lpGrpNext;  // Next group in the linked list
    DWORD   dwCount;                // for faster GroupFind
	UINT    nCache;					// for faster GroupFind = # of bytes for dwCount
    WORD    wFlag;
}   _GROUP,                         // winsock2.h defines GROUP
	FAR *_LPGROUP;

#define	GROUP_EXPAND				1
#define	GROUP_BLOCK_SIZE			256
#define LCBITGROUPMAX    ((DWORD)0x10000000)    // This is the number of bits
												//  that can fit into 32 Meg

// all of the functions provided by the Group.lib
// in groupcom.c
ERR FAR PASCAL GroupAddItem(LPVOID, DWORD);
_LPGROUP FAR PASCAL GroupInitiate(DWORD, LPERRB);
DWORD FAR PASCAL LrgbBitCount(LPBYTE, DWORD);
PUBLIC DWORD FAR PASCAL LrgbBitFind(LPBYTE, DWORD, BYTE FAR *);
_LPGROUP FAR PASCAL GroupCreate (DWORD, DWORD, LPERRB);
VOID FAR PASCAL GroupFree(_LPGROUP lpGroup);
PUBLIC int PASCAL FAR GroupFileBuild
    (HFPB hfpbSysFile, LPSTR lszGrpFilename, _LPGROUP lpGroup);
ERR FAR PASCAL GroupRemoveItem(_LPGROUP lpGroup,	DWORD dwGrpItem);
int PASCAL FAR GroupTrimmed (_LPGROUP lpGroup);
PUBLIC	_LPGROUP FAR PASCAL GroupOr(_LPGROUP lpGroup1,_LPGROUP lpGroup2, LPERRB lperr);
PUBLIC	_LPGROUP FAR PASCAL GroupNot(_LPGROUP lpGroup,LPERRB lperr);
PUBLIC	_LPGROUP FAR PASCAL GroupAnd(_LPGROUP lpGroup1,_LPGROUP lpGroup2, LPERRB lperr);
PUBLIC  DWORD FAR PASCAL GroupFind(_LPGROUP lpGroup, DWORD dwCount, LPERRB lperrb);
PUBLIC  DWORD FAR PASCAL GroupFindOffset(_LPGROUP lpGroup, DWORD dwCount, LPERRB lperrb);
PUBLIC _LPGROUP PASCAL FAR GroupDuplicate (_LPGROUP lpGroup,LPERRB lperr);
PUBLIC ERR PASCAL FAR GroupCopy (_LPGROUP lpGroupDst, _LPGROUP lpGroupSrc);
PUBLIC BOOL FAR PASCAL GroupIsBitSet (_LPGROUP lpGroup, DWORD dwTopicNum);
_LPGROUP PASCAL FAR GroupMake (LPBYTE lpBits, DWORD dwSize, DWORD dwItems);
_LPGROUP PASCAL FAR GroupBufferCreate (HANDLE h, LPERRB lperrb);

#if defined( __cplusplus )
}
#endif


// Critical structures that gets messed up in /Zp8
#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\itsort.h ===
// ITSORT.H:	IITSortKey, IITSortKeyConfig, and related definitions.

#ifndef __ITSORT_H__
#define __ITSORT_H__

#include <comdef.h>


// Some standard definitions for sort key types.  In general, key types (and
// their #defines) are specific to a particular implementation of a sort object.
// However, in the interest of making it easier to call a variety of sort object
// implementations, we define some standard key type definitions that can be
// used across different implementations.
// New sort objects should feel free to add arbitrary key formats, which could
// include a variety of custom binary formats tailored to specific applications
// (e.g. a binary key that provides indirection to a dictionary of strings).
// Note that the format of the key type must always allow its length to be
// determined without any other data than the key itself, as follows:
//		1) length is constant for the key type (e.g. DWORD is always 4 bytes)
//		2) key includes length information (e.g. a WORD prefix indicating
//			how many memory units (bytes, words, etc.) the key contains
//		3) key must contain an explicit terminator (e.g. null terminated strings).
#define IITSK_KEYTYPE_WORD			((DWORD) 18)	// Binary word
#define IITSK_KEYTYPE_DWORD			((DWORD) 19)	// Binary dword
#define IITSK_KEYTYPE_ANSI_SZ		((DWORD) 30)	// NULL-term. MBCS string
#define IITSK_KEYTYPE_UNICODE_SZ	((DWORD) 31)	// NULL-term. Unicode string


// Valid parameters that can be returned by IITSortKey::Compare in *pgrfReason.
#define IITSK_COMPREASON_UNKNOWN		((DWORD) 0x80000000)

// Valid parameters that can be passed to IITSortKey::IsRelated.
#define IITSK_KEYRELATION_PREFIX		((DWORD) 0)
#define IITSK_KEYRELATION_INFIX			((DWORD) 1)
#define IITSK_KEYRELATION_SUFFIX		((DWORD) 2)


DECLARE_INTERFACE_(IITSortKey, IUnknown)
{
	// Returns in *pcbSize the size of the key in bytes (including any
	// length information).
	STDMETHOD(GetSize)(LPCVOID lpcvKey, DWORD *pcbSize) PURE;

	// On exit, *plResult is set according to strcmp conventions:
	//	< 0, = 0, > 0, depending on whether lpcvKey1 is less than, equal to, or
	// greater than lpcvKey2.  If pgrfReason is not NULL, *pgrfReason may be
	// filled in on exit with one or more bit flags giving more information about
	// the result of the comparison if the result was affected by something other
	// than raw lexical comparison (e.g. special character mappings).  If
	// *pgrfReason contains 0 on exit, that means the comparison result
	// was purely lexical; if *pgrfReason contains IITSK_COMPREASON_UNKNOWN,
	// then the sort object implementation wasn't able to provide additional
	// information about the comparison result.
	STDMETHOD(Compare)(LPCVOID lpcvKey1, LPCVOID lpcvKey2,
						LONG *plResult, DWORD *pgrfReason) PURE;

	// Returns S_OK if lpcvKey1 is related to lpcvKey2 according to
	// dwKeyRelation; else S_FALSE.  If the value specified for dwKeyRelation
	// is not supported, E_INVALIDARG will be returned.  If pgrfReason is not
	// NULL, *pgrfReason will be filled in just as it would be by
	// IITSortKey::Compare.
	STDMETHOD(IsRelated)(LPCVOID lpcvKey1, LPCVOID lpcvKey2,
						 DWORD dwKeyRelation, DWORD *pgrfReason) PURE;

	// Converts a key of one type into a key of another type.  This is intended
	// mainly for converting an uncompressed key into a compressed key,
	// but a sort object is free to provide whatever conversion combinations
	// it wants to.  *pcbSizeOut should contain the size of the buffer pointed
	// to by lpvKeyOut.  The caller can obtain a guaranteed adequate buffer size
	// through *pcbSizeOut by passing 0 on entry.
	//
	// The following errors are returned:
	//		E_INVALIDARG:	the specified conversion is not supported, i.e.
	//						one or both of the REFGUID params is invalid.
	//		E_FAIL:			the buffer pointed to by lpvKeyOut was too small
	//						to hold the converted key.
	STDMETHOD(Convert)(DWORD dwKeyTypeIn, LPCVOID lpcvKeyIn,
						DWORD dwKeyTypeOut, LPVOID lpvKeyOut,
						DWORD *pcbSizeOut) PURE;

	STDMETHOD(ResolveDuplicates)(LPCVOID lpcvKey1, LPCVOID lpcvKey2,
						LPCVOID lpvKeyOut, DWORD *pcbSizeOut) PURE;
};

typedef IITSortKey *PIITSKY;

// Sort flags that can be passed to IITSortKeyConfig::SetControlInfo.
#define IITSKC_SORT_STRINGSORT           0x00001000  /* use string sort method */
#define IITSKC_NORM_IGNORECASE           0x00000001  /* ignore case */
#define IITSKC_NORM_IGNORENONSPACE       0x00000002  /* ignore nonspacing chars */
#define IITSKC_NORM_IGNORESYMBOLS        0x00000004  /* ignore symbols */
#define IITSKC_NORM_IGNOREKANATYPE       0x00010000  /* ignore kanatype */
#define IITSKC_NORM_IGNOREWIDTH          0x00020000  /* ignore width */


// External data types that can be passed to
// IITSortKeyConfig::LoadExternalSortData.
#define IITWBC_EXTDATA_SORTTABLE	((DWORD) 2)		


DECLARE_INTERFACE_(IITSortKeyConfig, IUnknown)
{
	// Sets/gets locale info that will affect the comparison results
	// returned from all subsequent calls to IITSortKey::Compare.
	// Returns S_OK if locale described by params is supported
	// by the sort object; E_INVALIDARG otherwise.
	STDMETHOD(SetLocaleInfo)(DWORD dwCodePageID, LCID lcid) PURE;
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;

	// Sets/gets the sort key type that the sort object will expect
	// to see in the following method calls that take keys as params:
	//		IITSortKey::GetSize, Compare, IsRelated
	// Returns S_OK if the sort key type is understood by the
	// sort object; E_INVALIDARG otherwise.
	STDMETHOD(SetKeyType)(DWORD dwKeyType) PURE;
	STDMETHOD(GetKeyType)(DWORD *pdwKeyType) PURE;

	// Sets/gets data that controls how sort key comparisons are made.
	// This method currently accepts only the following set of flags
	// in grfSortFlags:
	//
	// In the future, additional information may be passed in through
	// dwReserved.
	STDMETHOD(SetControlInfo)(DWORD grfSortFlags, DWORD dwReserved) PURE;
	STDMETHOD(GetControlInfo)(DWORD *pgrfSortFlags, DWORD *pdwReserved) PURE;

	// Will load external sort data, such as tables containing the relative
	// sort order of specific characters for a textual key type, from the
	// specified stream.  The format of the data is entirely implementation
	// specific, with the value passed in dwExtDataType providing a hint.
	STDMETHOD(LoadExternalSortData)(IStream *pStream, DWORD dwExtDataType) PURE;
};

typedef IITSortKeyConfig *PIITSKYC;


#endif		// __ITSORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\itsortid.h ===
// ITSORTID.H:	IIDs and other GUIDs related to sorting.

#ifndef __ITSORTID_H__
#define __ITSORTID_H__

#include <comdef.h>

#if 0
// {8fa0d5a0-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IITSortKey, 
0x8fa0d5a0, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);
#else
// {3FD68660-36CA-11d1-B767-00A0C913F764} // New to support ResolveDuplicates
DEFINE_GUID(IID_IITSortKey, 
0x3fd68660, 0x36ca, 0x11d1, 0xb7, 0x67, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x64);
#endif

// {8fa0d5a1-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IITSortKeyConfig, 
0x8fa0d5a1, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662dab0-d393-11d0-9a56-00c04fb68bf7}
DEFINE_GUID(CLSID_ITSysSort, 
0x4662dab0, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);


#endif // __ITSORTID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\itcc.h ===
/************************************************************************
 *
 * ITCC.H
 *
 * Copyright (c) Microsoft Corporation 1993 - 1997
 * All rights reserved.
 *
 *************************************************************************
 *
 * Module intent:
 *
 * This module contains the API (Application Programming Interface)
 * for creating and updating ITIR objects and storages
 *
 *************************************************************************
 *
 * Current owner: JohnRush
 *
 ************************************************************************/

#ifndef _ITCC_H // {
#define _ITCC_H

#include "itpropl.h"
#include "itdb.h"

// Document property macros
#define STDPROP_UID         1
#define STDPROP_TITLE       2
#define STDPROP_USERDATA    3
#define STDPROP_KEY         4

#define STDPROP_SORTKEY		100
#define STDPROP_DISPLAYKEY	101
#define STDPROP_SORTORDINAL 102

#define STDPROP_INDEX_TEXT    200
#define STDPROP_INDEX_VFLD    201
#define STDPROP_INDEX_DTYPE   202
#define STDPROP_INDEX_LENGTH  203
#define STDPROP_INDEX_BREAK   204

#define STDPROP_INDEX_TERM              210
#define STDPROP_INDEX_TERM_RAW_LENGTH   211

#define STDPROP_USERPROP_BASE   0x00010000
#define STDPROP_USERPROP_MAX    0x7FFFFFFF

// Property destinations for word wheels
#define SZ_WWDEST_GLOBAL    L"GLOBAL"
#define SZ_WWDEST_KEY       L"KEY"
#define SZ_WWDEST_OCC       L"OCC"


// {4662daa2-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITCmdInt,
0x4662daa2, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daa3-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITSvMgr,
0x4662daa3, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4CF34C30-9BF9-11d0-8764-00A0C913F764}
DEFINE_GUID(IID_IITCmdInt,
0x4cf34c30, 0x9bf9, 0x11d0, 0x87, 0x64, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x64);

// {4E7DA031-9C11-11d0-8764-00A0C913F764}
DEFINE_GUID(IID_IITSvMgr,
0x4e7da031, 0x9c11, 0x11d0, 0x87, 0x64, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x64);

// {4662daa5-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITWordWheelUpdate,
0x4662daa5, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);
    
// {8fa0d5a5-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITBuildCollect,
0x8fa0d5a5, 0xdedf, 0x11d0, 0x9a, 0x61, 0x0, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daa4-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITGroupUpdate,
0x4662daa4, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {8fa0d5aa-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(CLSID_IITIndexBuild,
0x8fa0d5aa, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {8fa0d5ab-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(CLSID_IITWWFilterBuild,
0x8fa0d5ab, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#pragma pack( push, SPECIAL_VARARG_1 )
#pragma pack(4)
struct VARARG
{
    DWORD dwArgc;
    void *Argv[20];
};
#pragma pack( pop, SPECIAL_VARARG_1 )

// Document class
class CSvDoc
{
public:
    virtual HRESULT WINAPI ResetDocTemplate (void) PURE;

    virtual HRESULT WINAPI AddObjectEntry(LPCWSTR lpObjName, IITPropList *pPL) PURE;
    virtual HRESULT WINAPI AddObjectEntry
        (LPCWSTR lpObjName, LPCWSTR szPropDest, IITPropList *pPL) PURE;
};

// Service manager class
DECLARE_INTERFACE_(IITSvMgr, IUnknown)
{
    STDMETHOD(Initiate)(IStorage *pistgStorage, IStream *piistmLog) PURE;
	STDMETHOD(Dispose)(void) PURE;
	STDMETHOD(Build)(void) PURE;
	STDMETHOD(SetPropDest)
        (LPCWSTR szObjectName, LPCWSTR szDestination, IITPropList *pPL) PURE;
	STDMETHOD(CreateBuildObject)(LPCWSTR pwstrObjectName, REFCLSID refclsid) PURE;
    STDMETHOD(GetBuildObject)
        (LPCWSTR pwstrObjectName, REFIID refiid, void **pInterface) PURE;

	STDMETHOD(CreateDocTemplate)(CSvDoc **ppDoc) PURE;
	STDMETHOD(FreeDocTemplate)(CSvDoc *pDoc) PURE;
	STDMETHOD(AddDocument)(CSvDoc *pDoc) PURE;

	STDMETHOD(HashString)(IN LPCWSTR lpwstr, OUT DWORD *pdwHash) PURE;
};

// Command Interpreter Interface
DECLARE_INTERFACE_(IITCmdInt, IUnknown)
{
	STDMETHOD(Initiate)(IITSvMgr *piitsv) PURE;
	STDMETHOD(Dispose)(void) PURE;
	STDMETHOD(LoadFromStream)(IStream *pMVPStream, IStream *pLogStream) PURE;
};

typedef struct tagHelperInfo
{
    UINT    CodePage;
    LCID    lcid;
    DWORD   argc1;
    DWORD   *argv1;
    DWORD   argc2;
    LPWSTR  *argv2;
} HelperInfo, *PHelperInfo;

// This structure is sent to IITBuildCollect::SetBuildStats
typedef struct tagIITBOCI
{
    DWORD dwSize;   // Must be set to size of this structure
    DWORD dwMaxUID; // The highest uid authored for this title
} ITBuildObjectControlInfo;

DECLARE_INTERFACE_(IITBuildCollect, IUnknown)
{
    STDMETHOD(SetConfigInfo)(IITDatabase *piitdb, VARARG vaParams) PURE;
	STDMETHOD(InitHelperInstance)(DWORD dwHelperObjInstance,
        IITDatabase *pITDatabase, DWORD dwCodePage,
        LCID lcid, VARARG vaDword, VARARG vaString) PURE;
	STDMETHOD(SetEntry)(LPCWSTR szDest, IITPropList *pPropList) PURE;
	STDMETHOD(Close)(void) PURE;
    STDMETHOD(GetTypeString)(LPWSTR wstrType, DWORD *pLength) PURE;
    STDMETHOD(SetBuildStats)(ITBuildObjectControlInfo &itboci) PURE;
};


#endif // _ITCC_H }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\itstem.h ===
// ITSTEM.H:	(from Tripoli) IStemmer, IStemSink
//				(from InfoTech) IStemmerConfig
//				(from Tripoli and InfoTech) Supporting definitions.

#ifndef __ITSTEM_H__
#define __ITSTEM_H__

#include <comdef.h>


#ifndef __IStemSink_FWD_DEFINED__
#define __IStemSink_FWD_DEFINED__
typedef interface IStemSink IStemSink;
#endif 	/* __IStemSink_FWD_DEFINED__ */


#ifndef __IStemmer_FWD_DEFINED__
#define __IStemmer_FWD_DEFINED__
typedef interface IStemmer IStemmer;
#endif 	/* __IStemmer_FWD_DEFINED__ */


#ifndef __IStemmerConfig_FWD_DEFINED__
#define __IStemmerConfig_FWD_DEFINED__
typedef interface IStemmerConfig IStemmerConfig;
#endif 	/* __IStemmerConfig_FWD_DEFINED__ */


DECLARE_INTERFACE_(IStemmer, IUnknown)
{
    STDMETHOD(Init)(ULONG ulMaxTokenSize, BOOL *pfLicense) PURE;
    STDMETHOD(GetLicenseToUse)(WCHAR const **ppwcsLicense) PURE;
    STDMETHOD(StemWord)(WCHAR const *pwcInBuf, ULONG cwc,
									IStemSink *pStemSink) PURE;   
};

typedef IStemmer *PISTEM;


DECLARE_INTERFACE_(IStemSink, IUnknown)
{
    STDMETHOD(PutAltWord)(WCHAR const *pwcInBuf, ULONG cwc) PURE;
    STDMETHOD(PutWord)(WCHAR const *pwcInBuf, ULONG cwc) PURE;
};

typedef IStemSink *PISTEMSNK;


DECLARE_INTERFACE_(IStemmerConfig, IUnknown)
{
	// Sets/gets locale info that will affect the stemming
	// behavior of IStemmer::StemWord.
	// Returns S_OK if locale described by params is supported
	// by the breaker object; E_INVALIDARG otherwise.
	STDMETHOD(SetLocaleInfo)(DWORD dwCodePageID, LCID lcid) PURE;
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;

	// Sets/gets info that controls certain aspects of stemming.
	// This method currently accepts only the following set of flags
	// in grfStemFlags:
	// In the future, additional information may be passed in through
	// dwReserved.
	STDMETHOD(SetControlInfo)(DWORD grfStemFlags, DWORD dwReserved) PURE;
	STDMETHOD(GetControlInfo)(DWORD *pgrfStemFlags, DWORD *pdwReserved) PURE;

	// Will load external stemmer data, such as word part lists, etc.
	// The format of the data in the stream is entirely
	// implementation-specific.
	STDMETHOD(LoadExternalStemmerData)(IStream *pStream,
										DWORD dwExtDataType) PURE;
};

typedef IStemmerConfig *PISTEMC;



#endif	// __ITSTEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\itwbrk.h ===
// ITWBRK.H:	(from Tripoli) IWordBreaker, IWordSink, IPhraseSink, IStem
//				(from InfoTech) IWordBreakerConfig
//				(from Tripoli and InfoTech) Supporting definitions.

#ifndef __ITWBRK_H__
#define __ITWBRK_H__

#include <comdef.h>
#include <itstem.h>


#ifndef __IPhraseSink_FWD_DEFINED__
#define __IPhraseSink_FWD_DEFINED__
typedef interface IPhraseSink IPhraseSink;
#endif 	/* __IPhraseSink_FWD_DEFINED__ */


#ifndef __IWordSink_FWD_DEFINED__
#define __IWordSink_FWD_DEFINED__
typedef interface IWordSink IWordSink;
#endif 	/* __IWordSink_FWD_DEFINED__ */


#ifndef __IWordBreaker_FWD_DEFINED__
#define __IWordBreaker_FWD_DEFINED__
typedef interface IWordBreaker IWordBreaker;
#endif 	/* __IWordBreaker_FWD_DEFINED__ */


#ifndef __IWordBreakerConfig_FWD_DEFINED__
#define __IWordBreakerConfig_FWD_DEFINED__
typedef interface IWordBreakerConfig IWordBreakerConfig;
#endif 	/* __IWordBreakerConfig_FWD_DEFINED__ */


#ifndef __IITStopWordList_FWD_DEFINED__
#define __IITStopWordList_FWD_DEFINED__
typedef interface IITStopWordList IITStopWordList;
#endif 	/* __IITStopWordList_FWD_DEFINED__ */


// Supporting definitions for IWordBreaker.
typedef struct tagTEXT_SOURCE TEXT_SOURCE;
typedef SCODE (__stdcall *PFNFILLTEXTBUFFER)(TEXT_SOURCE *pTextSource);

typedef struct tagTEXT_SOURCE
{
    PFNFILLTEXTBUFFER pfnFillTextBuffer;
    WCHAR *awcBuffer;
    ULONG iEnd;
    ULONG iCur;
} TEXT_SOURCE;


DECLARE_INTERFACE_(IWordBreaker, IUnknown)
{
	STDMETHOD(Init)(BOOL fQuery, ULONG ulMaxTokenSize, BOOL *pfLicense) PURE;
	STDMETHOD(BreakText)(TEXT_SOURCE *pTextSource, IWordSink *pWordSink,
											IPhraseSink *pPhraseSink) PURE;
	STDMETHOD(ComposePhrase)(WCHAR const *pwcNoun, ULONG cwcNoun,
						WCHAR const *pwcModifier, ULONG cwcModifier,
						ULONG ulAttachmentType, WCHAR *pwcPhrase,
												ULONG *pcwcPhrase) PURE;
    STDMETHOD(GetLicenseToUse)(WCHAR const **ppwcsLicense) PURE;
};

typedef IWordBreaker *PIWBRK;


// Break word types that can be passed to
// IWordBreakerConfig::SetBreakWordType.
#define IITWBC_BREAKTYPE_TEXT		((DWORD) 0)
#define IITWBC_BREAKTYPE_NUMBER		((DWORD) 1)
#define IITWBC_BREAKTYPE_DATE		((DWORD) 2)
#define IITWBC_BREAKTYPE_TIME		((DWORD) 3)
#define IITWBC_BREAKTYPE_EPOCH		((DWORD) 4)


// Breaker control flags that can be passed to
// IWordBreakerConfig::SetControlInfo.
#define IITWBC_BREAK_ACCEPT_WILDCARDS	0x00000001  // Interpret wildcard chars
													// as such.
#define IITWBC_BREAK_AND_STEM           0x00000002  // Stem words after breaking
													// them.

// External data types that can be passed to
// IWordBreakerConfig::LoadExternalBreakerData.
#define IITWBC_EXTDATA_CHARTABLE		((DWORD) 0)		
#define IITWBC_EXTDATA_STOPWORDLIST		((DWORD) 1)


DECLARE_INTERFACE_(IWordBreakerConfig, IUnknown)
{
	// Sets/gets locale info that will affect the word breaking
	// behavior of IWordBreaker::BreakText.
	// Returns S_OK if locale described by params is supported
	// by the breaker object; E_INVALIDARG otherwise.
	STDMETHOD(SetLocaleInfo)(DWORD dwCodePageID, LCID lcid) PURE;
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;

	// Sets/gets the type of words the breaker should expect
	// to see in all subsequent calls to IWordBreaker::BreakText.
	// Returns S_OK if the type is understood by the breaker
	//  object; E_INVALIDARG otherwise.
	STDMETHOD(SetBreakWordType)(DWORD dwBreakWordType) PURE;
	STDMETHOD(GetBreakWordType)(DWORD *pdwBreakWordType) PURE;

	// Sets/gets info that controls certain aspects of word breaking.
	// This method currently accepts only the following set of flags
	// in grfBreakFlags:
	//		IITWBC_BREAK_ACCEPT_WILDCARDS
	//		IITWBC_BREAK_AND_STEM
	// In the future, additional information may be passed in through
	// dwReserved.
	STDMETHOD(SetControlInfo)(DWORD grfBreakFlags, DWORD dwReserved) PURE;
	STDMETHOD(GetControlInfo)(DWORD *pgrfBreakFlags, DWORD *pdwReserved) PURE;

	// Will load external breaker data, such as a table containing
	// char-by-char break information or a list of stop words.
	// Although the format of the data in the stream is entirely
	// implementation-specific, this interface does define a couple
	// of general types for that data which can be passed in
	// dwStreamDataType:
	//		IITWBC_EXTDATA_CHARTABLE
	//		IITWBC_EXTDATA_STOPWORDLIST
	STDMETHOD(LoadExternalBreakerData)(IStream *pStream,
										DWORD dwExtDataType) PURE;

	// These methods allow a stemmer to be associated with the breaker.  The
	// breaker will take responsibility for calling
	// IPersistStreamInit::Load/Save when it is loaded/saved if the stemmer
	// supports that interface.
	STDMETHOD(SetWordStemmer)(REFCLSID rclsid, IStemmer *pStemmer) PURE;
	STDMETHOD(GetWordStemmer)(IStemmer **ppStemmer) PURE;
};

typedef IWordBreakerConfig *PIWBRKC;


// Supporting definitions for IWordSink.
typedef enum tagWORDREP_BREAK_TYPE
{
    WORDREP_BREAK_EOW = 0,
    WORDREP_BREAK_EOS = 1,
    WORDREP_BREAK_EOP = 2,
    WORDREP_BREAK_EOC = 3
} WORDREP_BREAK_TYPE;


DECLARE_INTERFACE_(IWordSink, IUnknown)
{
	STDMETHOD(PutWord)(WCHAR const *pwcInBuf, ULONG cwc,
						ULONG cwcSrcLen, ULONG cwcSrcPos) PURE;
	STDMETHOD(PutAltWord)(WCHAR const *pwcInBuf, ULONG cwc, 
						ULONG cwcSrcLen, ULONG cwcSrcPos) PURE;
	STDMETHOD(StartAltPhrase)(void) PURE;
	STDMETHOD(EndAltPhrase)(void) PURE;
	STDMETHOD(PutBreak)(WORDREP_BREAK_TYPE breakType) PURE;
};

typedef IWordSink *PIWRDSNK;


DECLARE_INTERFACE_(IPhraseSink, IUnknown)
{
	STDMETHOD(PutSmallPhrase)(WCHAR const *pwcNoun, ULONG cwcNoun,
								WCHAR const *pwcModifier, 
								ULONG cwcModifier,
								ULONG ulAttachmentType) PURE;
	STDMETHOD(PutPhrase)(WCHAR const *pwcPhrase, ULONG cwcPhrase) PURE;
};

typedef IPhraseSink *PIPHRSNK;


// Function or macro that can be used by a breaker implementation
// to pull characters from the caller's text source.
#ifdef __cplusplus

inline WCHAR WBreakGetWChar(TEXT_SOURCE *pTextSource )
{
    if ( pTextSource->iCur == pTextSource->iEnd )
    {
        if ( FAILED(pTextSource->pfnFillTextBuffer( pTextSource ) ) )
            return 0xFFFF;  // UniCode EOF
    }

    return pTextSource->awcBuffer[pTextSource->iCur++];
};

#else

#define WBreakGetWChar( pTextSource )\
    (pTextSource->iCur==pTextSource->iEnd)\
    ? (FAILED(pTextSource->pfnFillTextBuffer( pTextSource )) \
       ? 0xFFFF\
       : pTextSource->awcBuffer[pTextSource->iCur++])\
    : pTextSource->awcBuffer[pTextSource->iCur++]

#endif


DECLARE_INTERFACE_(IITStopWordList, IUnknown)
{
	STDMETHOD(AddWord)(WCHAR const *pwcInBuf, ULONG cwc) PURE;
	STDMETHOD(LookupWord)(WCHAR const *pwcInBuf, ULONG cwc) PURE;
};

typedef	IITStopWordList	*PIITSTWDL;


#endif		// __ITWBRK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\itwbrkid.h ===
// ITWBRKID.H:	IIDs and other GUIDs related to word breaking and stemming.

#ifndef __ITWBRKID_H__
#define __ITWBRKID_H__

#include <comdef.h>

//----------------------------------------------------------------------
//------			Word Breaking Definitions				------------
//----------------------------------------------------------------------

// {D53552C8-77E3-101A-B552-08002B33B0E6}
DEFINE_GUID(IID_IWordBreaker, 
0xD53552C8, 0x77E3, 0x101A, 0xB5, 0x52, 0x08, 0x00, 0x2B, 0x33, 0xB0, 0xE6);

// {CC907054-C058-101A-B554-08002B33B0E6}
DEFINE_GUID(IID_IWordSink, 
0xCC907054, 0xC058, 0x101A, 0xB5, 0x54, 0x08, 0x00, 0x2B, 0x33, 0xB0, 0xE6);

// {CC906FF0-C058-101A-B554-08002B33B0E6}
DEFINE_GUID(IID_IPhraseSink, 
0xCC906FF0, 0xC058, 0x101A, 0xB5, 0x54, 0x08, 0x00, 0x2B, 0x33, 0xB0, 0xE6);

// {8fa0d5a6-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IWordBreakerConfig, 
0x8fa0d5a6, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daaf-d393-11d0-9a56-00c04fb68bf7}
DEFINE_GUID(CLSID_ITStdBreaker, 
0x4662daaf, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);


//----------------------------------------------------------------------
//------			Stop Word List Definitions				------------
//----------------------------------------------------------------------

// {8fa0d5ad-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IITStopWordList, 
0x8fa0d5ad, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);


//----------------------------------------------------------------------
//------				Stemming Definitions				------------
//----------------------------------------------------------------------

// {efbaf140-7f42-11ce-be57-00aa0051fe20}
DEFINE_GUID(IID_IStemmer, 
0xefbaf140, 0x7f42, 0x11ce, 0xbe, 0x57, 0x00, 0xaa, 0x00, 0x51, 0xfe, 0x20);

// {fe77c330-7f42-11ce-be57-00aa0051fe20}
DEFINE_GUID(IID_IStemSink, 
0xfe77c330, 0x7f42, 0x11ce, 0xbe, 0x57, 0x00, 0xaa, 0x00, 0x51, 0xfe, 0x20);

// {8fa0d5a7-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IStemmerConfig, 
0x8fa0d5a7, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {8fa0d5a8-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(CLSID_ITEngStemmer, 
0x8fa0d5a8, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);


#endif // __ITWBRKID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\itquery.h ===
// ITQUERY.H:	IITIndex and IITQuery interface declarations

#ifndef __ITQUERY_H__
#define __ITQUERY_H__

#include <iterror.h>

// {8fa0d5a3-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITIndex, 
0x8fa0d5a3, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#ifdef ITPROXY

// {A38D3483-8C49-11d0-A84E-00AA006C7D01}
DEFINE_GUID(CLSID_IITIndex, 
0xa38d3483, 0x8c49, 0x11d0, 0xa8, 0x4e, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daad-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITIndexLocal, 
0x4662daad, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY

// {8fa0d5ac-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITQuery, 
0x8fa0d5ac, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daa6-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITQuery, 
0x4662daa6, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// Defines
#define IMPLICIT_AND            0x0000
#define IMPLICIT_OR             0x0001
#define COMPOUNDWORD_PHRASE     0x0010 // use PHRASE opr for compound words
#define QUERYRESULT_RANK        0x0100 // Ranked the result. If not highest hit 1st (topics in UID order)
#define QUERYRESULT_UIDSORT     0x0200 // Result topics are 1st in 1st out
#define QUERYRESULT_SKIPOCCINFO 0x8000 // Topic list only, no occurrence info

#define STEMMED_SEARCH	        0x00010000
#define RESULTSET_ASYNC			0x00020000
#define QUERY_GETTERMS			0x00080000	// Return with each set of occurrence
											// data a pointer to the term string
											// that the data is associated with.

// Standard properties
#define STDPROP_SEARCHBASE  500
#define STDPROP_FIELD			STDPROP_SEARCHBASE
#define STDPROP_LENGTH			(STDPROP_SEARCHBASE + 1)
#define STDPROP_COUNT			(STDPROP_SEARCHBASE + 2)
#define STDPROP_OFFSET			(STDPROP_SEARCHBASE + 3)
#define STDPROP_TERM_UNICODE_ST	(STDPROP_SEARCHBASE + 4)

// Don't know signature of callbacks yet
typedef void (*LPFNCBBREAK)(void);    
typedef void (*LPFNRESULTCB)(void);


// Forward declarations
interface IITResultSet;
interface IITQuery;
interface IITDatabase;
interface IITGroup;

DECLARE_INTERFACE_(IITIndex, IUnknown)
{

	STDMETHOD(Open)(IITDatabase* pITDB, LPCWSTR lpszIndexMoniker, BOOL fInsideDB) PURE;
	STDMETHOD(Close)(void) PURE;

	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;
	STDMETHOD(GetWordBreakerInstance)(DWORD *pdwObjInstance) PURE;

	STDMETHOD(CreateQueryInstance)(IITQuery** ppITQuery) PURE;
	STDMETHOD(Search)(IITQuery* pITQuery, IITResultSet* pITResult) PURE;
	STDMETHOD(Search)(IITQuery* pITQuery, IITGroup* pITGroup) PURE;
};

typedef IITIndex* PITINDEX;


DECLARE_INTERFACE_(IITQuery, IUnknown)
{
	STDMETHOD(SetResultCallback)(FCALLBACK_MSG *pfcbkmsg) PURE;
	STDMETHOD(SetCommand)(LPCWSTR lpszCommand) PURE;
	STDMETHOD(SetOptions)(DWORD dwFlags) PURE;
	STDMETHOD(SetProximity)(WORD wNear) PURE;
	STDMETHOD(SetGroup)(IITGroup* pITGroup) PURE;
	STDMETHOD(SetResultCount)(LONG cRows) PURE;

	STDMETHOD(GetResultCallback)(FCALLBACK_MSG *pfcbkmsg) PURE;
	STDMETHOD(GetCommand)(LPCWSTR& lpszCommand) PURE;
	STDMETHOD(GetOptions)(DWORD& dwFlags) PURE;
	STDMETHOD(GetProximity)(WORD& wNear) PURE;
	STDMETHOD(GetGroup)(IITGroup** ppiitGroup) PURE;
	STDMETHOD(GetResultCount)(LONG& cRows) PURE;

	STDMETHOD(ReInit)() PURE;

};

typedef IITQuery* PITQUERY;


#endif		// __ITQUERY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\itww.h ===
// ITWW.H:	IITWordWheel interface declaration

#ifndef __ITWW_H__
#define __ITWW_H__

// {8fa0d5a4-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITWordWheel, 
0x8fa0d5a4, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#ifdef ITPROXY

// {D73725C2-8C12-11d0-A84E-00AA006C7D01}
DEFINE_GUID(CLSID_IITWordWheel, 
0xd73725c2, 0x8c12, 0x11d0, 0xa8, 0x4e, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daa8-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITWordWheelLocal, 
0x4662daa8, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY

// Word-wheel open flags
#define ITWW_OPEN_CONNECT	0x00000000    // connect to server on open (the default)
#define ITWW_OPEN_NOCONNECT	0x00000001    // don't connect to server on open

// Constants for IITWordWheel::Lookup.
#define ITWW_CBKEY_MAX		1024		// Max size of keys allowed in Word Wheels.

// Forward declarations
interface IITDatabase;
interface IITResultSet;
interface IITGroup;
interface IITPropList;
interface IITQuery;

DECLARE_INTERFACE_(IITWordWheel, IUnknown)
{

	STDMETHOD(Open)(IITDatabase* lpITDB, LPCWSTR lpszMoniker, DWORD dwFlags=0) PURE;
	STDMETHOD(Close)(void) PURE;

	// Returns the code page ID and locale ID that the word wheel was built and
	// sorted with.
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;

	// Returns in *pdwObjInstance the ID of the external sort instance being used by
	// this word wheel.  The instance ID can be passed to IITDatabase::GetObject to
	// to obtain an interface pointer on the instantiated instance.  If the word
	// wheel doesn't use external sorting, then IITDB_OBJINST_NULL.
	STDMETHOD(GetSorterInstance)(DWORD *pdwObjInstance) PURE;

	STDMETHOD(Count)(LONG *pcEntries) PURE;

	// To be safe, the length of lpvKeyBuf should always be at least ITWW_CBKEY_MAX. 
	STDMETHOD(Lookup)(LONG lEntry, LPVOID lpvKeyBuf, DWORD cbKeyBuf) PURE;
	STDMETHOD(Lookup)(LONG lEntry, IITResultSet* lpITResult, LONG cEntries) PURE;
	STDMETHOD(Lookup)(LPCVOID lpcvPrefix, BOOL fExactMatch, LONG *plEntry) PURE;

	STDMETHOD(SetGroup)(IITGroup* piitGroup) PURE;
	STDMETHOD(GetGroup)(IITGroup** ppiitGroup) PURE;

	STDMETHOD(GetDataCount)(LONG lEntry, DWORD *pdwCount) PURE;
	STDMETHOD(GetData)(LONG lEntry, IITResultSet* lpITResult) PURE;
	STDMETHOD(GetDataColumns)(IITResultSet* pRS) PURE;
};

typedef IITWordWheel* LPITWORDWHEEL;

#endif		// __ITWW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\imvfs.h ===
/*****************************************************************************
*                                                                            *
*  IMVFS.H                                                                   *
*  														 *
*                                                                            *
*  Copyright (C) Microsoft Corporation 1990 - 1994.                          *
*  All Rights reserved.                                                      *
*                                                                            *
******************************************************************************
*                                                                            *
*  Module intent                                                             *
*                                                                            *
*  Declares all privately available MVFS.DLL routines                        *
*                                                                            *
******************************************************************************
*                                                                            *
*  Current Owner:  BINHN                                                     *
*                                                                            *
*****************************************************************************/

#ifndef __IMVFS_H__
#define __IMVFS_H__

#ifdef __cplusplus
extern "C" {
#endif

#pragma pack(1)		// avoid problems when Zp!=1

// requires windows.h, mvopsys.h, misc.h, orkin.h
#include <fileoff.h>

typedef USHORT RC;        // for those not coming via HELP.H

/*****************************************************************************
*
*       File Moniker
*
*****************************************************************************/

#define fmNil ((FM)0)
#define qafmNil ((QAFM)0)

/*
    When creating an FM (in other WORDs, specifying the location of a new
    or extant file), the caller must specify the directory in which that file
    is located.  There are a finite number of directories available to Help.
    These are:
*/

#define dirNil      0x0000  // No directory specified
#define dirCurrent  0x0001  // Whatever the OS thinks the current dir. is
#define dirTemp     0x0002  // The directory temporary files are created in
#define dirHelp     0x0004  // Wherever the Help Application lives
#define dirSystem   0x0008  // The Windows and Windows System directories
#define dirPath     0x0010  // Searches the $PATH
			    // (includes Current dir and System dirs)
#define dirAll      0xFFFF  // Search all directories, in the above order
#define dirFirst    dirCurrent  // The lowest bit that can be set
#define dirLast     dirPath  // The highest bit that can be set

/*
    To specify which parts of a full filename you want to extract, add
    (logical or) the following part codes:
*/

#define partNone    0x0000  // return nothing
#define partDrive   0x0001  // D:        Vol
#define partDir     0x0002  //   dir\dir\    :dir:dir:
#define partBase    0x0004  //        basename    filename
#define partExt     0x0008  //                 ext      <usu. nothing>
#define partAll     0xFFFF

// Get from stdlib.h
#if !defined(_M_MPPC) && !defined(_M_M68K)
#define _MAX_PATH   260 /* max. length of full pathname */
#else   /* ndef defined(_M_M68K) || defined(_M_MPPC) */
#define _MAX_PATH   256 /* max. length of full pathname */
#endif  /* defined(_M_M68K) || defined(_M_MPPC) */

/*
   max. string lengths of file names
*/
#define cchMaxPath      _MAX_PATH // = _MAX_PATH in <stdlib.h>

typedef HANDLE HFS;
typedef short HF;


/*
    An FM is a magic cookie which refers to some structure describing the
    location of a file, including the volume/drive, path, and filename.
*/

typedef struct {
  char rgch[cchMaxPath];  // Fully canonicalized pathname
} AFM;                          // RAllocation of FMS
typedef AFM FAR *QAFM;

typedef LPSTR FM;         // An FM is now just a string, allocated through
						  // the NewMemory()/DisposeMemory() API
typedef USHORT DIR;       // Help directory flag


#define FValidFm(fm)    ((fm)!=fmNil)

/*** MATTSMI 2/5/92 -- ADDED FROM DOS VERSION OF THIS HEADER TO SUPPORT WMVC ***/

#define VerifyFm(fm) 	// assert(fm == fmNil || FCheckGh((HANDLE) fm))
						// VerifyFm(fm) not needed for FM being LPSTR

FM      EXPORT_API FAR PASCAL    FmNewSzDir (LPSTR, DIR, LPVOID);
FM      EXPORT_API PASCAL FAR    FmNew(LPSTR, LPVOID);
FM      EXPORT_API FAR PASCAL    FmNewExistSzDir (LPSTR, DIR, LPVOID);
FM      EXPORT_API FAR PASCAL    FmNewExistSzIni (LPSTR, LPSTR, LPSTR, LPVOID);
FM      EXPORT_API FAR PASCAL    FmNewTemp (LPSTR, LPVOID);
FM      EXPORT_API FAR PASCAL    FmNewSameDirFmSz (FM, LPSTR, LPVOID);
VOID    EXPORT_API FAR PASCAL    DisposeFm (FM);
FM      EXPORT_API FAR PASCAL    FmCopyFm(FM, LPVOID);
BOOL    EXPORT_API FAR PASCAL    FExistFm(FM);
int     EXPORT_API FAR PASCAL    CbPartsFm(FM, int);
LPSTR   EXPORT_API FAR PASCAL    SzPartsFm(FM, LPSTR, int, int);
BOOL    EXPORT_API FAR PASCAL    FSameFmFm (FM, FM);



/*****************************************************************************
*
*       FIDs - file access (fid.c)
*
*****************************************************************************/

#define wRead       0x0001
#define wWrite      0x0002
#define wReadOnly   wRead
#define wReadWrite  (wRead | wWrite)
#define wRWMask     (wRead | wWrite)

#define wShareRead  0x0004
#define wShareWrite 0x0008
#define wShareAll   (wShareRead | wShareWrite)
#define wShareNone  0x000
#define wShareMask  (wShareRead | wShareWrite)
#define wShareShift 2

#define wSeekSet  0   /* SEEK_SET from stdio.h */
#define wSeekCur  1   /* SEEK_CUR from stdio.h */
#define wSeekEnd  2   /* SEEK_END from stdio.h */

#ifdef _WIN32
typedef HANDLE	FID;
#define fidNil  INVALID_HANDLE_VALUE
#else
typedef HFILE   FID;
#define fidNil  HFILE_ERROR
#endif


FID  EXPORT_API FAR PASCAL FidCreateFm(FM fm, WORD wOpenMode, WORD wPerm,
    LPVOID);
FID  EXPORT_API FAR PASCAL FidOpenFm(FM fm, WORD wOpenMode,
    LPVOID);
BOOL EXPORT_API FAR PASCAL FidFlush(FID fid);

#define FUnlinkFm(fm)   ((BOOL)(RcUnlinkFm(fm)==ERR_SUCCESS))
RC   EXPORT_API FAR PASCAL RcUnlinkFm(FM);

LONG EXPORT_API FAR PASCAL LcbReadFid(FID, LPVOID, LONG, LPVOID);

#define FCloseFid(fid)    ((BOOL)(RcCloseFid((int)fid) == ERR_SUCCESS))
RC   EXPORT_API FAR PASCAL RcCloseFid(FID);

LONG EXPORT_API FAR PASCAL LcbWriteFid(FID, LPVOID, LONG, LPVOID);
LONG EXPORT_API FAR PASCAL LTellFid(FID, LPVOID);
LONG EXPORT_API FAR PASCAL LSeekFid(FID, LONG, WORD, LPVOID);
FILEOFFSET EXPORT_API FAR PASCAL FoSeekFid(FID, FILEOFFSET, WORD, LPERRB);
int EXPORT_API PASCAL FAR FEofFid(FID);

#define FChSizeFid(fid, lcb)  (RcChSizeFid ((fid), (lcb)) == 0)
RC EXPORT_API PASCAL FAR RcChSizeFid(FID, LONG);
BOOL EXPORT_API PASCAL FAR  FDriveOk(LPSTR);

/*****************************************************************************
*
*       BTREE api
*
*****************************************************************************/

#define bBtreeVersionBonehead 0     /* fixed size key, array */


#define wBtreeMagic         0x293B  /* magic number for btrees; a winky: ;) */

#define bBtreeVersion       2       /* back to strcmp for 'z' keys */


#define bkNil               ((BK)-1)/* nil value for BK */


#define wMaxFormat          15      /* length of format string */


#define cbBtreeBlockDefault 8192    /* default btree block size */

#define fFSDirty          (BYTE)0x08  // file (FS) is dirty and needs writing



/* key types */


#define KT_SZI          'i'
#define KT_SZDELMIN     'k' /* not supported */
#define KT_SZMIN        'm' /* not supported */
#define KT_SZDEL        'r' /* not supported */
#define KT_ST           't' /* not supported */
#define KT_SZ           'z'

#define KT_VSTI			'V' // variable-byte prefixed Pascal string
#define KT_STI          'I'
#define KT_STDELMIN     'K' /* not supported */
#define KT_LONG         'L'
#define KT_STMIN        'M' /* not supported */
#define KT_STDEL        'R' /* not supported */
#define KT_SZISCAND     'S'
#define KT_SZMAP        'P'

#define FBtreeKeyTypeIsSz(c)  ((c) == KT_SZ || (c) == KT_SZMAP || (c) == KT_SZI || \
			    (c) == KT_SZISCAND)

/*
  Btree record formats

  In addition to these #defines, '1'..'9', 'a'..'f' for fixed length
  keys & records of 1..15 bytes are accepted.
*/

#define FMT_VNUM_FO 'O'			// Variable byte offset or length
#define FMT_BYTE_PREFIX 't'
#define FMT_WORD_PREFIX 'T'
#define FMT_SZ          'z'
			

#define FBtreeRecordTypeIsSz(c)     ((c) == FMT_SZ)

/* elevator constants */


#define btelevMax ((BT_ELEV)32767)
#define btelevNil ((BT_ELEV)-1)

typedef LONG      KEY;        /* btree key */
typedef BYTE      KT;         /* key type */


typedef HANDLE        HBT;        /* handle to a btree */
typedef HANDLE        HMAPBT;     /* handle to a btree map */


// @DOC INTERNAL
// @struct BTREE_PARAMS | Btree parameters passed in for creation
typedef struct _btree_params
  {
  HFS   hfs;          		// @field File system that btree lives in
  int   cbBlock;      		// @field Number of bytes in a btree block.  
  							// Key or Data cannot exceed 1/2 this amount.
  VOID FAR * qCharMapTable;	// @field Character map table.
  BYTE bFlags;       		// @field HFOPEN_ flags (same as used in opening an hFile).
  char rgchFormat[wMaxFormat+1]; // @field Key and record format string.
  } BTREE_PARAMS;


typedef DWORD    BK;   // btree block index   - extended to DWORD, davej 12/95

// @DOC INTERNAL
// @struct BTPOS | Btree position structure.
typedef struct
  {
  BK  bk;     // @field Block number.
  int cKey;   // @field Which key in block (0 means first).
  int iKey;   // @field Key's index db.rgbBlock (in bytes).
  } BTPOS, FAR *QBTPOS;


typedef int BTELEV, FAR *QBTELEV; /* elevator location: 0 .. 32767 legal */

HBT     EXPORT_API FAR PASCAL  HbtCreateBtreeSz(LPSTR, BTREE_PARAMS FAR *,
    LPVOID);
RC      EXPORT_API FAR PASCAL  RcDestroyBtreeSz(LPSTR, HFS);

HBT     EXPORT_API FAR PASCAL  HbtOpenBtreeSz  (LPSTR, HFS, BYTE,
    VOID FAR*, LPVOID);
RC      EXPORT_API FAR PASCAL  RcCloseBtreeHbt (HBT);
RC      EXPORT_API FAR PASCAL  RcAbandonHbt    (HBT);
LPVOID  EXPORT_API PASCAL FAR  BtreeGetCMap (HANDLE);
#if defined(_DEBUG)
VOID    EXPORT_API FAR PASCAL VerifyHbt       (HBT);
#else
#define VerifyHbt(hbt)
#endif //!def _DEBUG


RC      EXPORT_API FAR PASCAL  RcLookupByPos   (HBT, QBTPOS, KEY, int, LPVOID);
RC      EXPORT_API FAR PASCAL  RcLookupByKeyAux(HBT, KEY, QBTPOS, LPVOID, BOOL);

WORD    EXPORT_API FAR PASCAL  wGetNextNEntries(HBT, WORD wFlags, WORD wEntries, QBTPOS, LPVOID, LONG, LPERRB);
// Flags for wGetNextNEntries
#define GETNEXT_KEYS	1
#define GETNEXT_RECS	2
#define GETNEXT_RESET	4

#define     RcLookupByKey(   hbt, key, qbtpos, qv) \
  RcLookupByKeyAux((hbt), (key), (qbtpos), (qv), FALSE)

RC      EXPORT_API FAR PASCAL  RcFirstHbt      (HBT, KEY, LPVOID, QBTPOS);
RC      EXPORT_API FAR PASCAL  RcLastHbt       (HBT, KEY, LPVOID, QBTPOS);
RC      EXPORT_API FAR PASCAL  RcNextPos       (HBT, QBTPOS, QBTPOS);
RC      EXPORT_API FAR PASCAL  RcOffsetPos     (HBT, QBTPOS, LONG, LPLONG, QBTPOS);

#if defined(__DEBUG)
#define     FValidPos(qbtpos) \
  ((qbtpos) == NULL ? FALSE : (qbtpos)->bk != bkNil)
#else /* !_DEBUG */

#define     FValidPos(qbtpos) ((qbtpos)->bk != bkNil)
#endif /* !_DEBUG */

// Callback passed to RcTraverseHbt
typedef DWORD (FAR PASCAL *TRAVERSE_FUNC) (KEY key, BYTE FAR *rec, DWORD dwUser);
#define TRAVERSE_DONE 		0
#define TRAVERSE_DELETE 	1
#define TRAVERSE_INTERRUPT	2

RC      EXPORT_API FAR PASCAL  RcInsertHbt     (HBT, KEY, LPVOID);
RC 		EXPORT_API FAR PASCAL  RcInsertMacBrsHbt(HBT, KEY, QV);
RC      EXPORT_API FAR PASCAL  RcDeleteHbt     (HBT, KEY);
RC      EXPORT_API FAR PASCAL  RcUpdateHbt     (HBT, KEY, LPVOID);
RC 		EXPORT_API FAR PASCAL  RcTraverseHbt   (HBT, TRAVERSE_FUNC, DWORD);

RC      EXPORT_API FAR PASCAL  RcPackHbt       (HBT);            /* >>>> unimplemented */
RC      EXPORT_API FAR PASCAL  RcCheckHbt      (HBT);            /* >>>> unimplemented */
RC      EXPORT_API FAR PASCAL  RcLeafBlockHbt  (HBT, KEY, LPVOID);   /* >>>> unimplemented */

HBT     EXPORT_API FAR PASCAL  HbtInitFill     (LPSTR, BTREE_PARAMS FAR *,
    LPVOID);
RC      EXPORT_API FAR PASCAL  RcFillHbt       (HBT, KEY, LPVOID);
RC      EXPORT_API FAR PASCAL  RcFiniFillHbt   (HBT);

RC      EXPORT_API FAR PASCAL   RcFreeCacheHbt  (HBT);
RC      EXPORT_API FAR PASCAL   RcFlushHbt      (HBT);
RC      EXPORT_API FAR PASCAL   RcCloseOrFlushHbt(HBT, BOOL);

RC      EXPORT_API FAR PASCAL   RcPos2Elev(HBT, QBTPOS, QBTELEV); /* >>>> unimplemented */
RC      FAR PASCAL   RcElev2Pos(HBT, QBTELEV, QBTPOS); /* >>>> unimplemented */

RC    EXPORT_API FAR PASCAL RcGetBtreeInfo(HBT, LPBYTE, LPLONG, LPWORD);
HF    EXPORT_API PASCAL FAR HfOpenDiskBt(HFS, HBT, LPSTR, BYTE, LPVOID);

/*  Map utility functions  */

RC      EXPORT_API FAR PASCAL RcCreateBTMapHfs(HFS, HBT, LPSTR);
HMAPBT  EXPORT_API FAR PASCAL HmapbtOpenHfs(HFS, LPSTR, LPVOID);
RC      EXPORT_API FAR PASCAL RcCloseHmapbt(HMAPBT);
RC      EXPORT_API FAR PASCAL RcIndexFromKeyHbt(HBT, HMAPBT, LPLONG, KEY);
RC      EXPORT_API FAR PASCAL RcKeyFromIndexHbt(HBT, HMAPBT, KEY, int, LONG);
BOOL    EXPORT_API FAR PASCAL FIsPrefix(HBT, KEY, KEY);
VOID    EXPORT_API FAR PASCAL BtreeSetCMap (HBT, LPVOID);
VOID    EXPORT_API FAR PASCAL BtreeSetLanguageFlag(HBT, int);
VOID    EXPORT_API FAR PASCAL BtreeSetSortFlag(HBT, int);



/*****************************************************************************
*
*       FS - file system (subfile.c, filesys.c)
*
*****************************************************************************/

/* FS magic number */
#define wFileSysMagic   0x5F3F        // ?_ - the help icon (with shadow)

//#define bFileSysVersion 2           // sorted free list
/* Current FS version */
#define bFileSysVersionOld (BYTE)3       // different sorting functions
#define bFileSysVersion    (BYTE)0x04	 // M20 format quite different from M14

/* flags for FlushHfs */
#define fFSCloseFile      (BYTE)0x01  // close fid associated with the FS
#define fFSFreeBtreeCache (BYTE)0x02  // free the btree's cache

/* seek origins */

#define wFSSeekSet        0           // seek relative to start of file
#define wFSSeekCur        1           // seek relative to current position
#define wFSSeekEnd        2           // seek relative to end of file

#define FSH_READWRITE		(BYTE)0x01
#define FSH_READONLY		(BYTE)0x02
#define FSH_CREATE			(BYTE)0x04
#define FSH_M14				(BYTE)0x08	// Not used really, since we return
										// an error if reading M14 to force
										// caller to use M14 APIs instead (we
										// could make this transparent to 
										// user?)
#define FSH_FASTUPDATE		(BYTE)0x10	// System Btree is not copied to temp file
										// unless absolutely necessary
#define FSH_DISKBTREE		(BYTE)0x20	// System Btree is always copied to disk if
										// possible for speed.  Btree may be very very
										// large, and this is NOT recommended for on-line	

#define HFOPEN_READWRITE		(BYTE)0x01
#define HFOPEN_READ				(BYTE)0x02
#define HFOPEN_CREATE			(BYTE)0x04
#define HFOPEN_SYSTEM			(BYTE)0x08
#define HFOPEN_NOTEMP			(BYTE)0x10	// No temp file in r/w mode
#define HFOPEN_FORCETEMP		(BYTE)0x20  // Temp file created in r mode
#define HFOPEN_ENABLELOGGING	(BYTE)0x40	

#define FACCESS_READWRITE	(BYTE)0x01
#define FACCESS_READ		(BYTE)0x02
#define FACCESS_EXISTS		(BYTE)0x04
#define FACCESS_LIVESINFS	(BYTE)0x08
#define FACCESS_LIVESINTEMP (BYTE)0x10

#define SFH_LOCKED			(BYTE)0x01	// File may not be written to or deleted
#define SFH_EXTRABYTES		(BYTE)0x02	// (not used yet) Should use if extra bytes appear in header of file
										// file header should contain the number of header bytes as the first byte.
#define SFH_COMPRESSED		(BYTE)0x04	// (not used yet).  Perhaps use to indicate an overall file compression
#define SFH_LOGGING			(BYTE)0x08
#define SFH_INVALID			(BYTE)0x80  // This is the value if file does not
										// really exist in fs  yet.
// These are the flags that users can manipulate
#define SFH_FILEFLAGS (SFH_LOGGING|SFH_LOCKED)

// Compatibility
//#define fFSReadOnly       (BYTE)0x01  // file (FS) is readonly
//#define fFSOpenReadOnly   (BYTE)0x02  // file (FS) is opened in readonly mode
//#define fFSReadWrite      (BYTE)0x00  // file (FS) is readwrite
//#define fFSOpenReadWrite  (BYTE)0x00  // file (FS) is opened in read/write mode
//#define fFSOptCdRom       (BYTE)0x20  // align file optimally for CDROM
//#define fFSNoFlushDir     (BYTE)0x40  // don't flush directory when closing 
#define fFSReadOnly       HFOPEN_READ  // file (FS) is readonly
#define fFSOpenReadOnly   HFOPEN_READ  // file (FS) is opened in readonly mode
#define fFSReadWrite      HFOPEN_READWRITE  // file (FS) is readwrite
#define fFSOpenReadWrite  HFOPEN_READWRITE  // file (FS) is opened in read/write mode
#define fFSOptCdRom       0x00  // align file optimally for CDROM
#define fFSNoFlushDir     0x00  // don't flush directory when closing 

typedef HANDLE HSFB;		// Handle to a SFB
typedef BOOL (FAR PASCAL * PROGFUNC)(WORD);

#define hfNil (short)0

// @DOC INTERNAL API
// @struct FS_PARAMS | File system parameters to be passed in to 
//	<f HfsCreateFileSysFm>.  Only the <p cbBlock> parameter is used right now.
typedef struct _fs_params
  {
  USHORT  wFreeListSize;  // @field Free List Entries (0=default, else max entries in free list)
  USHORT  cbBlock;  // @field Size of directory btree block.  Usually 1024 to 8192.
} FS_PARAMS;

typedef struct fsfilefind_tag
{
 	FILEOFFSET foSize;
	FILEOFFSET foStart;
	BYTE bFlags;
	char szFilename[256];
	int magic;
 	BTPOS btpos;
	HFS hfs;
} FSFILEFIND, FAR * LPFSFILEFIND;


VOID    EXPORT_API FAR PASCAL      CleanErrorList   (BOOL);
VOID 	EXPORT_API FAR PASCAL	   MVFSShutDown     (void);

/* File System Operations */

HFS		PASCAL FAR EXPORT_API HfsCreateFileSysFm( FM, FS_PARAMS FAR *, LPERRB );
RC		PASCAL FAR EXPORT_API RcDestroyFileSysFm( FM );
HFS		PASCAL FAR EXPORT_API HfsOpenFm( FM, BYTE, LPERRB );
RC		PASCAL FAR EXPORT_API RcCloseHfs( HFS );
RC		PASCAL FAR EXPORT_API RcFlushHfs( HFS );
BOOL 	PASCAL FAR EXPORT_API FHfsAccess(HFS hfs, BYTE bFlags);
RC 		PASCAL FAR EXPORT_API RcFindFirstFile(HFS hfs, LPCSTR szFilename, FSFILEFIND * pfind);
RC 		PASCAL FAR EXPORT_API RcFindNextFile(FSFILEFIND * pfind);

#define VerifyHfs(hfs)


/* File Operations */

HF		PASCAL FAR EXPORT_API HfCreateFileHfs( HFS, LPCSTR, BYTE, LPERRB );
RC		PASCAL FAR EXPORT_API RcUnlinkFileHfs( HFS, LPCSTR );
HF		PASCAL FAR EXPORT_API HfOpenHfs( HFS, LPCSTR, BYTE, LPERRB );
HF		PASCAL FAR EXPORT_API HfOpenHfsReserve( HFS, LPCSTR, BYTE, FILEOFFSET, LPERRB );
RC		PASCAL FAR EXPORT_API RcFlushHf( HF );
RC		PASCAL FAR EXPORT_API RcCloseHf( HF );
LONG	PASCAL FAR EXPORT_API LcbReadHf( HF, LPVOID, LONG, LPERRB );
LONG	PASCAL FAR EXPORT_API LcbWriteHf( HF, LPVOID, LONG, LPERRB );
BOOL	PASCAL FAR EXPORT_API FEofHf( HF, LPERRB );
BOOL	PASCAL FAR EXPORT_API FChSizeHf( HF, FILEOFFSET, LPERRB );
BOOL	PASCAL FAR EXPORT_API FAccessHfs( HFS, LPCSTR, BYTE, LPERRB );
RC		PASCAL FAR EXPORT_API RcAbandonHf( HF );
RC		PASCAL FAR EXPORT_API RcRenameFileHfs( HFS, LPCSTR, LPCSTR );
BYTE 	PASCAL FAR EXPORT_API GetFileFlags(HFS, LPCSTR, LPERRB );
RC 		PASCAL FAR EXPORT_API SetFileFlags(HFS, LPCSTR, BYTE );
BOOL	PASCAL FAR EXPORT_API FHfValid( HF );
HFS		PASCAL FAR EXPORT_API HfsGetFromHf( HF );
RC 		PASCAL FAR EXPORT_API RcCopyDosFileHfs(HFS, LPCSTR, LPCSTR, BYTE, PROGFUNC );
FILEOFFSET PASCAL FAR EXPORT_API FoTellHf( HF, LPERRB );
FILEOFFSET PASCAL FAR EXPORT_API FoSeekHf(HF, FILEOFFSET, WORD, LPERRB);
FILEOFFSET PASCAL FAR EXPORT_API FoSizeHf( HF, LPERRB );
FILEOFFSET PASCAL FAR EXPORT_API FoOffsetHf(HF hf, LPERRB lperrb);


#define VerifyHf(hf)

// These functions require the FID type.  They only make sense
// if the caller already needs H_LLFILE.
//#ifdef H_LLFILE
//RC      EXPORT_API FAR PASCAL  RcLLInfoFromHf     (HF, WORD, FID FAR *, LPLONG, LPLONG);
//RC      EXPORT_API FAR PASCAL  RcLLInfoFromHfsSz  (HFS, LPSTR, WORD, FID FAR *, LPLONG, LPLONG);
//#endif // H_LLFILE

/*****************************************************************************
*
*       MediaView File Handling
*
*****************************************************************************/
BOOL EXPORT_API FAR PASCAL LooseFileCompare(LPSTR, LPSTR);
FM EXPORT_API FAR PASCAL LocateFile(LPSTR, LPVOID);
HANDLE EXPORT_API FAR PASCAL LocateDLL(LPSTR, LPVOID);

RC EXPORT_API FAR PASCAL CopyOrReplaceFileToSubfile(HFS, LPSTR, LPSTR, LONG, BYTE, PROGFUNC, BOOL);

#pragma pack()		// avoid problems when Zp!=1

#ifdef __cplusplus
}
#endif

#endif // __IMVFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\itpropl.h ===
// ITPROPL.H:	ITPropertyList interface declaration

#ifndef __ITPROPL_H__
#define __ITPROPL_H__

#include <ocidl.h>

// {1F403BB1-9997-11d0-A850-00AA006C7D01}
DEFINE_GUID(IID_IITPropList, 
0x1f403bb1, 0x9997, 0x11d0, 0xa8, 0x50, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

// {4662daae-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITPropList, 
0x4662daae, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

typedef DWORD PROPID;

// Operations you can do on a property
#define PROP_ADD    0x00000000
#define PROP_DELETE 0x00000001
#define PROP_UPDATE 0x00000002

// Type of data
#define TYPE_VALUE   0x00000000
#define TYPE_POINTER 0x00000001
#define TYPE_STRING  0x00000002

// Class definition of CProperty
class CProperty
{
public:
    PROPID dwPropID;        // property ID
    DWORD cbData;           // Amount of data
    DWORD dwType;           // What type this is
    union
    {
        LPWSTR		lpszwData;  // String
        LPVOID		lpvData;     // Any kind of data
        DWORD       dwValue;     // Numerical data
    };
	BOOL fPersist;          // TRUE to persist this property

};

typedef CProperty* LPPROP;


// Interface def. for IITPropList
DECLARE_INTERFACE_(IITPropList, IPersistStreamInit)
{

    // dwOperation = operation (add, delete, update, etc.) to perform on property list
	STDMETHOD(Set)(PROPID PropID, DWORD dwData, DWORD dwOperation) PURE;
	STDMETHOD(Set)(PROPID PropID, LPVOID lpvData, DWORD cbData, DWORD dwOperation) PURE;
    STDMETHOD(Set)(PROPID PropID, LPCWSTR lpszwString, DWORD dwOperation) PURE;
    STDMETHOD(Add)(CProperty& Prop) PURE;

    STDMETHOD(Get)(PROPID PropID, CProperty& Property) PURE;
    STDMETHOD(Clear)() PURE;

    // set persistence state on property
    STDMETHOD(SetPersist)(PROPID PropID, BOOL fPersist) PURE;   // single property
    STDMETHOD(SetPersist)(BOOL fPersist) PURE;          // all properties in list

    // for enumerating properties
    STDMETHOD(GetFirst)(CProperty& Property) PURE;
    STDMETHOD(GetNext)(CProperty& Property) PURE;
    STDMETHOD(GetPropCount)(LONG &cProp) PURE;

	// persist header and data separately
	STDMETHOD(SaveHeader)(LPVOID lpvData, DWORD dwHdrSize) PURE;
	STDMETHOD(SaveData)(LPVOID lpvHeader, DWORD dwHdrSize, LPVOID lpvData, DWORD dwBufSize) PURE;
	STDMETHOD(GetHeaderSize)(DWORD& dwHdrSize) PURE;
	STDMETHOD(GetDataSize)(LPVOID lpvHeader, DWORD dwHdrSize, DWORD& dwDataSize) PURE;
	STDMETHOD(SaveDataToStream)(LPVOID lpvHeader, DWORD dwHdrSize, IStream* pStream) PURE;

    // persist to a memory buffer
    STDMETHOD(LoadFromMem)(LPVOID lpvData, DWORD dwBufSize) PURE;
    STDMETHOD(SaveToMem)(LPVOID lpvData, DWORD dwBufSize) PURE;

};

typedef IITPropList* LPITPROPLIST;

#endif		// __ITPROPL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\itrs.h ===
// ITRS.H:	ITResultSet interface declaration

#ifndef __ITRS_H__
#define __ITRS_H__


// {3BB91D41-998B-11d0-A850-00AA006C7D01}
DEFINE_GUID(IID_IITResultSet, 
0x3bb91d41, 0x998b, 0x11d0, 0xa8, 0x50, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

// {4662daa7-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITResultSet, 
0x4662daa7, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// maximum number of columns in a row set
#define MAX_COLUMNS  256

// Column priorities
typedef enum
{
    PRIORITY_LOW = 0,
    PRIORITY_NORMAL = 1,
    PRIORITY_HIGH = 2,

} PRIORITY;


// Forward declarations
class CProperty;

typedef struct tagROWSTATUS
{
    LONG lRowFirst;
    LONG cRows;
    LONG cProperties;
    LONG cRowsTotal;

} ROWSTATUS, *LPROWSTATUS;


typedef struct tagCOLUMNSTATUS
{
    LONG cPropCount;
    LONG cPropsLoaded;

} COLUMNSTATUS, *LPCOLUMNSTATUS;


// Used by IITResultSet::SetColumnHeap.
typedef SCODE (__stdcall *PFNCOLHEAPFREE)(LPVOID);


DECLARE_INTERFACE_(IITResultSet, IUnknown)
{
    // Initialization
    STDMETHOD(SetColumnPriority)(LONG lColumnIndex, PRIORITY ColumnPriority) PURE;
	STDMETHOD(SetColumnHeap)(LONG lColumnIndex, LPVOID lpvHeap,
										PFNCOLHEAPFREE pfnColHeapFree) PURE;
    STDMETHOD(SetKeyProp)(PROPID PropID) PURE;
    STDMETHOD(Add)(LPVOID lpvHdr) PURE;
    STDMETHOD(Add)(PROPID PropID, LPVOID lpvDefaultData, DWORD cbData, PRIORITY Priority) PURE;
    STDMETHOD(Add)(PROPID PropID, LPCWSTR lpszwDefault, PRIORITY Priority) PURE;
    STDMETHOD(Add)(PROPID PropID, DWORD dwDefaultData, PRIORITY Priority) PURE;

    // Build result set
	STDMETHOD(Append)(LPVOID lpvHdr, LPVOID lpvData) PURE;
	STDMETHOD(Set)(LONG lRowIndex, LPVOID lpvHdr, LPVOID lpvData) PURE;
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, DWORD_PTR dwData) PURE;
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, LPCWSTR lpwStr) PURE;
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, LPVOID lpvData, DWORD cbData) PURE;
	STDMETHOD(Copy)(IITResultSet* pRSCopy) PURE;
	STDMETHOD(AppendRows)(IITResultSet* pResSrc, LONG lRowSrcFirst, LONG cSrcRows, 
									LONG& lRowFirstDest) PURE;


    // Obtain info about result set
    STDMETHOD(Get)(LONG lRowIndex, LONG lColumnIndex, CProperty& Prop) PURE;
    STDMETHOD(GetKeyProp)(PROPID& KeyPropID) PURE;
    STDMETHOD(GetColumnPriority)(LONG lColumnIndex, PRIORITY& ColumnPriority) PURE;
    STDMETHOD(GetRowCount)(LONG& lNumberOfRows) PURE;
	STDMETHOD(GetColumnCount)(LONG& lNumberOfColumns) PURE;
	STDMETHOD(GetColumn)(LONG lColumnIndex, PROPID& PropID) PURE;
    STDMETHOD(GetColumn)(LONG lColumnIndex, PROPID& PropID, DWORD& dwType, LPVOID& lpvDefaultValue,
		                 DWORD& cbSize, PRIORITY& ColumnPriority) PURE;

	STDMETHOD(GetColumnFromPropID)(PROPID PropID, LONG& lColumnIndex) PURE;

    // Clear result set
    STDMETHOD(Clear)() PURE;
    STDMETHOD(ClearRows)() PURE;
    STDMETHOD(Free)() PURE;

    // Asynchronous support
    STDMETHOD(IsCompleted)() PURE;      // returns S_OK or S_FALSE
    STDMETHOD(Cancel)() PURE;
    STDMETHOD(Pause)(BOOL fPause) PURE;

    STDMETHOD(GetRowStatus)(LONG lRowFirst, LONG cRows, LPROWSTATUS lpRowStatus) PURE;
    STDMETHOD(GetColumnStatus)(LPCOLUMNSTATUS lpColStatus) PURE;
};

typedef IITResultSet* LPITRS;


#endif		// __ITRS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\iterror.h ===
#ifndef __ITERROR_H__
#define __ITERROR_H__


#ifdef __cplusplus
extern "C" {
#endif


// define the old error types in terms of HRESULTs
typedef HRESULT* PHRESULT;

#define ERR     HRESULT
#define ERRB    HRESULT
#define LPERRB  HRESULT*
#define RC      HRESULT


#define	SetErrCode(a,b)	SetErr(a, b)
#define	SetErrReturn(a)	SetErr(0, a)


HRESULT PASCAL SetErr (HRESULT* phr, HRESULT ErrCode);


/*************************************************************************
 *
 *                  CALLBACK FUNCTIONS PROTOTYPES
 *
 * User callback functions are needed in case:
 *  - The application needs to support interrupt
 *  - The application needs to display error messages its way
 *  - The application needs to know the status of the process
 *************************************************************************/
typedef ERR (FAR PASCAL *ERR_FUNC) (DWORD dwFlag, LPVOID pUserData, LPVOID pMessage);

/*************************************************************************
 * Call back structure
 *  Contains information about all callback functions
 *************************************************************************/ 

#define ERRFLAG_INTERRUPT      0x01 // The processes should be cancelled
#define ERRFLAG_STATUS         0x02 // High-level status messages
#define ERRFLAG_STATUS_VERBOSE 0x04 // Low-level status messages
#define ERRFLAG_ERROR          0x08 // Warning & Error messages
#define ERRFLAG_STRING         0x10 // Debug string messages

typedef struct fCallBack_msg
{
    ERR_FUNC MessageFunc;
    LPVOID pUserData;
    DWORD  dwFlags;
} FCALLBACK_MSG, FAR * PFCALLBACK_MSG;


// ***********************************************************************
// This structure should be filled out and passed back in the case of
// an error.
// ***********************************************************************
typedef WORD HCE;   // User errors
typedef WORD EP;    // Error Phase
typedef struct
{
    LPCSTR  pchFile;
    LONG    iLine;
    DWORD   iTopic;
    DWORD   fCustom; // If true then var1 is LPCSTR to custom error message
    DWORD   var1, var2, var3;   // Error parameters

    EP      ep;                 // Error Phase
    HCE     errCode;
} ERRC, FAR *PERRC;

#define CALLBACKKEY 0x524A4A44

typedef struct
{
    DWORD_PTR dwReserved;
    DWORD dwKey;
    FCALLBACK_MSG Callback;
} CUSTOMSTRUCT, FAR *PCUSTOMSTRUCT;

// Error Phase values
#define epNoFile       0
#define epLine         1
#define epTopic        2
#define epOffset       3
#define epMVBtopic	   4
#define epAliasLine	   5
#define epByteOffset   6


//
// The InfoTech error codes
//
#define E_NOTEXIST          _HRESULT_TYPEDEF_(0x80001000L)
#define E_DUPLICATE         _HRESULT_TYPEDEF_(0x80001001L)
#define E_BADVERSION        _HRESULT_TYPEDEF_(0x80001002L)
#define E_BADFILE           _HRESULT_TYPEDEF_(0x80001003L)
#define E_BADFORMAT         _HRESULT_TYPEDEF_(0x80001004L)
#define E_NOPERMISSION      _HRESULT_TYPEDEF_(0x80001005L)
#define E_ASSERT            _HRESULT_TYPEDEF_(0x80001006L)
#define E_INTERRUPT         _HRESULT_TYPEDEF_(0x80001007L)
#define E_NOTSUPPORTED      _HRESULT_TYPEDEF_(0x80001008L)
#define E_OUTOFRANGE        _HRESULT_TYPEDEF_(0x80001009L)                  
#define E_GROUPIDTOOBIG     _HRESULT_TYPEDEF_(0x8000100AL)
#define E_TOOMANYTITLES     _HRESULT_TYPEDEF_(0x8000100BL)
#define E_NOMERGEDDATA      _HRESULT_TYPEDEF_(0x8000100CL)
#define E_NOTFOUND          _HRESULT_TYPEDEF_(0x8000100DL)
#define E_CANTFINDDLL       _HRESULT_TYPEDEF_(0x8000100EL)
#define E_NOHANDLE          _HRESULT_TYPEDEF_(0x8000100FL) 
#define E_GETLASTERROR      _HRESULT_TYPEDEF_(0x80001010L)
#define E_BADPARAM			_HRESULT_TYPEDEF_(0x80001011L)
#define E_INVALIDSTATE		_HRESULT_TYPEDEF_(0x80001012L)
#define E_NOTOPEN           _HRESULT_TYPEDEF_(0x80001013L)
#define E_ALREADYOPEN       _HRESULT_TYPEDEF_(0x80001013L)
#define E_UNKNOWN_TRANSPORT _HRESULT_TYPEDEF_(0x80001016L)
#define E_UNSUPPORTED_TRANSPORT _HRESULT_TYPEDEF_(0x80001017L)
#define E_BADFILTERSIZE     _HRESULT_TYPEDEF_(0x80001018L)
#define E_TOOMANYOBJECTS    _HRESULT_TYPEDEF_(0x80001019L)
#define E_NAMETOOLONG       _HRESULT_TYPEDEF_(0x80001020L)

#define E_FILECREATE        _HRESULT_TYPEDEF_(0x80001030L) 
#define E_FILECLOSE         _HRESULT_TYPEDEF_(0x80001031L)
#define E_FILEREAD          _HRESULT_TYPEDEF_(0x80001032L)
#define E_FILESEEK          _HRESULT_TYPEDEF_(0x80001033L)
#define E_FILEWRITE         _HRESULT_TYPEDEF_(0x80001034L)
#define E_FILEDELETE        _HRESULT_TYPEDEF_(0x80001035L)
#define E_FILEINVALID       _HRESULT_TYPEDEF_(0x80001036L)
#define E_FILENOTFOUND      _HRESULT_TYPEDEF_(0x80001037L)
#define E_DISKFULL          _HRESULT_TYPEDEF_(0x80001038L)

#define E_TOOMANYTOPICS     _HRESULT_TYPEDEF_(0x80001050L)
#define E_TOOMANYDUPS       _HRESULT_TYPEDEF_(0x80001051L)
#define E_TREETOOBIG        _HRESULT_TYPEDEF_(0x80001052L)
#define E_BADBREAKER        _HRESULT_TYPEDEF_(0x80001053L)
#define E_BADVALUE          _HRESULT_TYPEDEF_(0x80001054L)
#define E_ALL_WILD          _HRESULT_TYPEDEF_(0x80001055L)
#define E_TOODEEP           _HRESULT_TYPEDEF_(0x80001056L)
#define E_EXPECTEDTERM      _HRESULT_TYPEDEF_(0x80001057L)
#define E_MISSLPAREN        _HRESULT_TYPEDEF_(0x80001058L)
#define E_MISSRPAREN        _HRESULT_TYPEDEF_(0x80001059L)
#define E_MISSQUOTE         _HRESULT_TYPEDEF_(0x8000105AL)
#define E_NULLQUERY         _HRESULT_TYPEDEF_(0x8000105BL)
#define E_STOPWORD          _HRESULT_TYPEDEF_(0x8000105CL)
#define E_BADRANGEOP        _HRESULT_TYPEDEF_(0x8000105DL)
#define E_UNMATCHEDTYPE     _HRESULT_TYPEDEF_(0x8000105EL)
#define E_WORDTOOLONG       _HRESULT_TYPEDEF_(0x8000105FL)
#define E_BADINDEXFLAGS     _HRESULT_TYPEDEF_(0x80001060L)
#define E_WILD_IN_DTYPE		_HRESULT_TYPEDEF_(0x80001061L)   
#define E_NOSTEMMER			_HRESULT_TYPEDEF_(0x80001062L)

// Property list and result set errors
#define E_MISSINGPROP		_HRESULT_TYPEDEF_(0x80001080L)
#define E_PROPLISTNOTEMPTY  _HRESULT_TYPEDEF_(0x80001081L)
#define E_PROPLISTEMPTY     _HRESULT_TYPEDEF_(0x80001082L)
#define E_ALREADYINIT       _HRESULT_TYPEDEF_(0x80001083L)
#define E_NOTINIT           _HRESULT_TYPEDEF_(0x80001084L)
#define E_RESULTSETEMPTY	_HRESULT_TYPEDEF_(0x80001085L)
#define E_TOOMANYCOLUMNS	_HRESULT_TYPEDEF_(0x80001086L)
#define E_NOKEYPROP			_HRESULT_TYPEDEF_(0x80001087L)

#ifdef __cplusplus
}
#endif

#endif  // __ITERROR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\maps.h ===
/*************************************************************************
This file contains the character tables used by the sorters throughout the
compiler and runtime to ensure support for international characters in the
ASCII set and consistency between the runtime and compiler. -- MATTSMI
**************************************************************************/

/* note: this scheme does not handle ligatures properly
   e.g. 'ae' is treated as if it were just an 'a'. */

unsigned char mpchordNorm[] =
  {
  0x00, /* 0x00 */
  0x01, /* 0x01 */
  0x02, /* 0x02 */
  0x03, /* 0x03 */
  0x04, /* 0x04 */
  0x05, /* 0x05 */
  0x06, /* 0x06 */
  0x07, /* 0x07 */
  0x08, /* 0x08 */
  0x09, /* 0x09 */
  0x0A, /* 0x0A */
  0x0B, /* 0x0B */
  0x0C, /* 0x0C */
  0x0D, /* 0x0D */
  0x0E, /* 0x0E */
  0x0F, /* 0x0F */
  0x10, /* 0x10 */
  0x11, /* 0x11 */
  0x12, /* 0x12 */
  0x13, /* 0x13 */
  0x14, /* 0x14 */
  0x15, /* 0x15 */
  0x16, /* 0x16 */
  0x17, /* 0x17 */
  0x18, /* 0x18 */
  0x19, /* 0x19 */
  0x1A, /* 0x1A */
  0x1B, /* 0x1B */
  0x1C, /* 0x1C */
  0x1D, /* 0x1D */
  0x1E, /* 0x1E */
  0x1F, /* 0x1F */
  0x20, /* ' ' */
  0x21, /* '!' */
  0x22, /* '"' */
  0x23, /* '#' */
  0x24, /* '$' */
  0x25, /* '%' */
  0x26, /* '&' */
  0x27, /* ''' */
  0x28, /* '(' */
  0x29, /* ')' */
  0x2A, /* '*' */
  0x2B, /* '+' */
  0x2C, /* ',' */
  0x2D, /* '-' */
  0x2E, /* '.' */
  0x2F, /* '/' */
  0x82, /* '0' */
  0x83, /* '1' */
  0x84, /* '2' */
  0x85, /* '3' */
  0x86, /* '4' */
  0x87, /* '5' */
  0x88, /* '6' */
  0x89, /* '7' */
  0x8A, /* '8' */
  0x8B, /* '9' */
  0x30, /* ':' */
  0x31, /* ';' */
  0x32, /* '<' */
  0x33, /* '=' */
  0x34, /* '>' */
  0x35, /* '?' */
  0x36, /* '@' */
  0x8D, /* 'A' */
  0x8F, /* 'B' */
  0x91, /* 'C' */
  0x93, /* 'D' */
  0x95, /* 'E' */
  0x97, /* 'F' */
  0x99, /* 'G' */
  0x9B, /* 'H' */
  0x9D, /* 'I' */
  0x9F, /* 'J' */
  0xA1, /* 'K' */
  0xA3, /* 'L' */
  0xA5, /* 'M' */
  0xA7, /* 'N' */
  0xAB, /* 'O' */
  0xAD, /* 'P' */
  0xAF, /* 'Q' */
  0xB1, /* 'R' */
  0xB3, /* 'S' */
  0xB6, /* 'T' */
  0xB8, /* 'U' */
  0xBA, /* 'V' */
  0xBC, /* 'W' */
  0xBE, /* 'X' */
  0xC1, /* 'Y' */
  0xC5, /* 'Z' */
  0x37, /* '[' */
  0x38, /* '\' */
  0x39, /* ']' */
  0x3A, /* '^' */
  0x3B, /* '_' */
  0x3C, /* '`' */
  0x8D, /* 'a' */
  0x8F, /* 'b' */
  0x91, /* 'c' */
  0x93, /* 'd' */
  0x95, /* 'e' */
  0x97, /* 'f' */
  0x99, /* 'g' */
  0x9B, /* 'h' */
  0x9D, /* 'i' */
  0x9F, /* 'j' */
  0xA1, /* 'k' */
  0xA3, /* 'l' */
  0xA5, /* 'm' */
  0xA7, /* 'n' */
  0xAB, /* 'o' */
  0xAD, /* 'p' */
  0xAF, /* 'q' */
  0xB1, /* 'r' */
  0xB3, /* 's' */
  0xB6, /* 't' */
  0xB8, /* 'u' */
  0xBA, /* 'v' */
  0xBC, /* 'w' */
  0xBE, /* 'x' */
  0xC1, /* 'y' */
  0xC5, /* 'z' */
  0x3D, /* '{' */
  0x3E, /* '|' */
  0x3F, /* '}' */
  0x40, /* '~' */
  0x41, /* 0x7F */
  0x42, /* 0x80 */
  0x43, /* 0x81 */
  0x44, /* 0x82 */
  0x45, /* 0x83 */
  0x46, /* 0x84 */
  0x47, /* 0x85 */
  0x48, /* 0x86 */
  0x49, /* 0x87 */
  0x4A, /* 0x88 */
  0x4B, /* 0x89 */
  0xB3, /* 0x8A */
  0x4D, /* 0x8B */
  0xAB, /* 0x8C */
  0x4F, /* 0x8D */
  0x50, /* 0x8E */
  0x51, /* 0x8F */
  0x52, /* 0x90 */
  0x53, /* 0x91 */
  0x54, /* 0x92 */
  0x55, /* 0x93 */
  0x56, /* 0x94 */
  0x57, /* 0x95 */
  0x58, /* 0x96 */
  0x59, /* 0x97 */
  0x5A, /* 0x98 */
  0x5B, /* 0x99 */
  0xB3, /* 0x9A */
  0x5D, /* 0x9B */
  0xAB, /* 0x9C */
  0x5F, /* 0x9D */
  0x60, /* 0x9E */
  0xC1, /* 0x9F */
  0x62, /* 0xA0 */
  0x63, /* 0xA1 */
  0x64, /* 0xA2 */
  0x65, /* 0xA3 */
  0x66, /* 0xA4 */
  0x67, /* 0xA5 */
  0x68, /* 0xA6 */
  0x69, /* 0xA7 */
  0x6A, /* 0xA8 */
  0x6B, /* 0xA9 */
  0x6C, /* 0xAA */
  0x6D, /* 0xAB */
  0x6E, /* 0xAC */
  0x6F, /* 0xAD */
  0x70, /* 0xAE */
  0x71, /* 0xAF */
  0x72, /* 0xB0 */
  0x73, /* 0xB1 */
  0x74, /* 0xB2 */
  0x75, /* 0xB3 */
  0x76, /* 0xB4 */
  0x77, /* 0xB5 */
  0x78, /* 0xB6 */
  0x79, /* 0xB7 */
  0x7A, /* 0xB8 */
  0x7B, /* 0xB9 */
  0x7C, /* 0xBA */
  0x7D, /* 0xBB */
  0x7E, /* 0xBC */
  0x7F, /* 0xBD */
  0x80, /* 0xBE */
  0x81, /* 0xBF */
  0x8D, /* 0xC0 */
  0x8D, /* 0xC1 */
  0x8D, /* 0xC2 */
  0x8D, /* 0xC3 */
  0x8D, /* 0xC4 */
  0x8D, /* 0xC5 */
  0x8D, /* 0xC6 */
  0x91, /* 0xC7 */
  0x95, /* 0xC8 */
  0x95, /* 0xC9 */
  0x95, /* 0xCA */
  0x95, /* 0xCB */
  0x9D, /* 0xCC */
  0x9D, /* 0xCD */
  0x9D, /* 0xCE */
  0x9D, /* 0xCF */
  0x93, /* 0xD0 */
  0xA7, /* 0xD1 */
  0xAB, /* 0xD2 */
  0xAB, /* 0xD3 */
  0xAB, /* 0xD4 */
  0xAB, /* 0xD5 */
  0xAB, /* 0xD6 */
  0xAA, /* 0xD7 */
  0xAB, /* 0xD8 */
  0xB8, /* 0xD9 */
  0xB8, /* 0xDA */
  0xB8, /* 0xDB */
  0xB8, /* 0xDC */
  0xC1, /* 0xDD */
  0xC6, /* 0xDE */
  0xB4, /* 0xDF */
  0x8D, /* 0xE0 */
  0x8D, /* 0xE1 */
  0x8D, /* 0xE2 */
  0x8D, /* 0xE3 */
  0x8D, /* 0xE4 */
  0x8D, /* 0xE5 */
  0x8D, /* 0xE6 */
  0x91, /* 0xE7 */
  0x95, /* 0xE8 */
  0x95, /* 0xE9 */
  0x95, /* 0xEA */
  0x95, /* 0xEB */
  0x9D, /* 0xEC */
  0x9D, /* 0xED */
  0x9D, /* 0xEE */
  0x9D, /* 0xEF */
  0x93, /* 0xF0 */
  0xA7, /* 0xF1 */
  0xAB, /* 0xF2 */
  0xAB, /* 0xF3 */
  0xAB, /* 0xF4 */
  0xAB, /* 0xF5 */
  0xAB, /* 0xF6 */
  0xAB, /* 0xF7 */
  0xAB, /* 0xF8 */
  0xB8, /* 0xF9 */
  0xB8, /* 0xFA */
  0xB8, /* 0xFB */
  0xB8, /* 0xFC */
  0xC1, /* 0xFD */
  0xC6, /* 0xFE */
  0xC1, /* 0xFF */
  };


unsigned char mpchordScan[] =
  {
  0x00, /* 0x00 */
  0x01, /* 0x01 */
  0x02, /* 0x02 */
  0x03, /* 0x03 */
  0x04, /* 0x04 */
  0x05, /* 0x05 */
  0x06, /* 0x06 */
  0x07, /* 0x07 */
  0x08, /* 0x08 */
  0x09, /* 0x09 */
  0x0A, /* 0x0A */
  0x0B, /* 0x0B */
  0x0C, /* 0x0C */
  0x0D, /* 0x0D */
  0x0E, /* 0x0E */
  0x0F, /* 0x0F */
  0x10, /* 0x10 */
  0x11, /* 0x11 */
  0x12, /* 0x12 */
  0x13, /* 0x13 */
  0x14, /* 0x14 */
  0x15, /* 0x15 */
  0x16, /* 0x16 */
  0x17, /* 0x17 */
  0x18, /* 0x18 */
  0x19, /* 0x19 */
  0x1A, /* 0x1A */
  0x1B, /* 0x1B */
  0x1C, /* 0x1C */
  0x1D, /* 0x1D */
  0x1E, /* 0x1E */
  0x1F, /* 0x1F */
  0x20, /* ' ' */
  0x21, /* '!' */
  0x22, /* '"' */
  0x23, /* '#' */
  0x24, /* '$' */
  0x25, /* '%' */
  0x26, /* '&' */
  0x27, /* ''' */
  0x28, /* '(' */
  0x29, /* ')' */
  0x2A, /* '*' */
  0x2B, /* '+' */
  0x2C, /* ',' */
  0x2D, /* '-' */
  0x2E, /* '.' */
  0x2F, /* '/' */
  0x82, /* '0' */
  0x83, /* '1' */
  0x84, /* '2' */
  0x85, /* '3' */
  0x86, /* '4' */
  0x87, /* '5' */
  0x88, /* '6' */
  0x89, /* '7' */
  0x8A, /* '8' */
  0x8B, /* '9' */
  0x30, /* ':' */
  0x31, /* ';' */
  0x32, /* '<' */
  0x33, /* '=' */
  0x34, /* '>' */
  0x35, /* '?' */
  0x36, /* '@' */
  0x8D, /* 'A' */
  0x8F, /* 'B' */
  0x91, /* 'C' */
  0x93, /* 'D' */
  0x95, /* 'E' */
  0x97, /* 'F' */
  0x99, /* 'G' */
  0x9B, /* 'H' */
  0x9D, /* 'I' */
  0x9F, /* 'J' */
  0xA1, /* 'K' */
  0xA3, /* 'L' */
  0xA5, /* 'M' */
  0xA7, /* 'N' */
  0xAB, /* 'O' */
  0xAD, /* 'P' */
  0xAF, /* 'Q' */
  0xB1, /* 'R' */
  0xB3, /* 'S' */
  0xB6, /* 'T' */
  0xB8, /* 'U' */
  0xBA, /* 'V' */
  0xBC, /* 'W' */
  0xBE, /* 'X' */
  0xC1, /* 'Y' */
  0xC5, /* 'Z' */
  0x37, /* '[' */
  0x38, /* '\' */
  0x39, /* ']' */
  0x3A, /* '^' */
  0x3B, /* '_' */
  0x3C, /* '`' */
  0x8D, /* 'a' */
  0x8F, /* 'b' */
  0x91, /* 'c' */
  0x93, /* 'd' */
  0x95, /* 'e' */
  0x97, /* 'f' */
  0x99, /* 'g' */
  0x9B, /* 'h' */
  0x9D, /* 'i' */
  0x9F, /* 'j' */
  0xA1, /* 'k' */
  0xA3, /* 'l' */
  0xA5, /* 'm' */
  0xA7, /* 'n' */
  0xAB, /* 'o' */
  0xAD, /* 'p' */
  0xAF, /* 'q' */
  0xB1, /* 'r' */
  0xB3, /* 's' */
  0xB6, /* 't' */
  0xB8, /* 'u' */
  0xBA, /* 'v' */
  0xBC, /* 'w' */
  0xBE, /* 'x' */
  0xC1, /* 'y' */
  0xC5, /* 'z' */
  0x3D, /* '{' */
  0x3E, /* '|' */
  0x3F, /* '}' */
  0x40, /* '~' */
  0x41, /* 0x7F */
  0x42, /* 0x80 */
  0x43, /* 0x81 */
  0x44, /* 0x82 */
  0x45, /* 0x83 */
  0x46, /* 0x84 */
  0x47, /* 0x85 */
  0x48, /* 0x86 */
  0x49, /* 0x87 */
  0x4A, /* 0x88 */
  0x4B, /* 0x89 */
  0x4B, /* 0x8A */
  0x4D, /* 0x8B */
  0x4E, /* 0x8C */
  0x4F, /* 0x8D */
  0x50, /* 0x8E */
  0x51, /* 0x8F */
  0x52, /* 0x90 */
  0x53, /* 0x91 */
  0x54, /* 0x92 */
  0x55, /* 0x93 */
  0x56, /* 0x94 */
  0x57, /* 0x95 */
  0x58, /* 0x96 */
  0x59, /* 0x97 */
  0x5A, /* 0x98 */
  0x5B, /* 0x99 */
  0x5C, /* 0x9A */
  0x5D, /* 0x9B */
  0x5E, /* 0x9C */
  0x5F, /* 0x9D */
  0x60, /* 0x9E */
  0x61, /* 0x9F */
  0x62, /* 0xA0 */
  0x63, /* 0xA1 */
  0x64, /* 0xA2 */
  0x65, /* 0xA3 */
  0x66, /* 0xA4 */
  0x67, /* 0xA5 */
  0x68, /* 0xA6 */
  0x69, /* 0xA7 */
  0x6A, /* 0xA8 */
  0x6B, /* 0xA9 */
  0x6C, /* 0xAA */
  0x6D, /* 0xAB */
  0x6E, /* 0xAC */
  0x6F, /* 0xAD */
  0x70, /* 0xAE */
  0x71, /* 0xAF */
  0x72, /* 0xB0 */
  0x73, /* 0xB1 */
  0x74, /* 0xB2 */
  0x75, /* 0xB3 */
  0x76, /* 0xB4 */
  0x77, /* 0xB5 */
  0x78, /* 0xB6 */
  0x79, /* 0xB7 */
  0x7A, /* 0xB8 */
  0x7B, /* 0xB9 */
  0x7C, /* 0xBA */
  0x7D, /* 0xBB */
  0x7E, /* 0xBC */
  0x7F, /* 0xBD */
  0x80, /* 0xBE */
  0x81, /* 0xBF */
  0x8D, /* 0xC0 */
  0x8D, /* 0xC1 */
  0x8D, /* 0xC2 */
  0x8D, /* 0xC3 */
  0xCF, /* 0xC4 */
  0xCD, /* 0xC5 */
  0xC9, /* 0xC6 */
  0x91, /* 0xC7 */
  0x95, /* 0xC8 */
  0x95, /* 0xC9 */
  0x95, /* 0xCA */
  0x95, /* 0xCB */
  0x9D, /* 0xCC */
  0x9D, /* 0xCD */
  0x9D, /* 0xCE */
  0x9D, /* 0xCF */
  0x93, /* 0xD0 */
  0xA9, /* 0xD1 */
  0xAB, /* 0xD2 */
  0xAB, /* 0xD3 */
  0xAB, /* 0xD4 */
  0xAB, /* 0xD5 */
  0xD1, /* 0xD6 */
  0xAA, /* 0xD7 */
  0xCB, /* 0xD8 */
  0xB8, /* 0xD9 */
  0xB8, /* 0xDA */
  0xB8, /* 0xDB */
  0xB8, /* 0xDC */
  0xC2, /* 0xDD */
  0xC7, /* 0xDE */
  0xB4, /* 0xDF */
  0x8D, /* 0xE0 */
  0x8D, /* 0xE1 */
  0x8D, /* 0xE2 */
  0x8D, /* 0xE3 */
  0xCF, /* 0xE4 */
  0xCD, /* 0xE5 */
  0xC9, /* 0xE6 */
  0x91, /* 0xE7 */
  0x95, /* 0xE8 */
  0x95, /* 0xE9 */
  0x95, /* 0xEA */
  0x95, /* 0xEB */
  0x9D, /* 0xEC */
  0x9D, /* 0xED */
  0x9D, /* 0xEE */
  0x9D, /* 0xEF */
  0x93, /* 0xF0 */
  0xA9, /* 0xF1 */
  0xAB, /* 0xF2 */
  0xAB, /* 0xF3 */
  0xAB, /* 0xF4 */
  0xAB, /* 0xF5 */
  0xD1, /* 0xF6 */
  0xAB, /* 0xF7 */
  0xCB, /* 0xF8 */
  0xB8, /* 0xF9 */
  0xB8, /* 0xFA */
  0xB8, /* 0xFB */
  0xB8, /* 0xFC */
  0xC2, /* 0xFD */
  0xC7, /* 0xFE */
  0xC3, /* 0xFF */
  };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\itverinfo.h ===
/*****************************************************************************
*
*  VERINFO.H
*
*  Copyright (C) Microsoft Corporation 1996-1997
*  All Rights reserved.
*
******************************************************************************
*
*  Module Intent: Version specific constant definitions
* 
*****************************************************************************/

// Names of DLLs.  Used by the VERSIONNAME entry in the RC file of each DLL.
#define DLLFILE_ITCC     "ITCC.DLL\0"
#define DLLFILE_ITSS     "ITSS.DLL\0"
#define DLLFILE_ITIRCL   "ITIRCL.DLL\0"

// InfoTech version number:  major, minor, update, application.
#define rmj             4
#define rmm             72
#define rup             7276
#define rap             0

#define szVerName       ""
#define szVerUser       ""

// InfoTech *file* version number: major, minor, application.  These
// may not get updated as often as their executable counterparts above.
// This version number is used to stamp some areas of ITIRCL's persistent
// storage.
#define rmjFile             4
#define rmmFile             0
#define rapFile             0

// NT build environment defines DBG instead of _DEBUG
#if defined(DBG) && !defined(_DEBUG)
#define _DEBUG
#endif

#ifdef _DEBUG
#define VERSIONSTR		"Debug Version 4.72\0"
#define VERSIONFLAGS            VS_FF_DEBUG
#else
#define VERSIONSTR		"4.72\0"
#define VERSIONFLAGS            0
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\misc.h ===
/***************************************************************************\*
*
*  MISC.H
*
*  Copyright (C) Microsoft Corporation 1988 - 1994.
*  All Rights reserved.
*
*****************************************************************************
*
*  Module Description:  Include file defining basic types and constants.
*                       Windows/PM version.
*
*****************************************************************************
*
*  Known Bugs:
*
****************************************************************************/

#ifndef __MISC_H__
#define __MISC_H__

#ifdef __cplusplus
extern "C" {
#endif

#define NOCOMM
	
/* extended keywords */

#ifndef PRIVATE
#ifdef _DEBUG
#define PRIVATE 
#else
#define PRIVATE static
#endif
#endif

#ifdef PUBLIC
#undef PUBLIC
#endif
#define PUBLIC

#ifdef  _32BIT
#define HUGE
#else
#define HUGE    huge
#endif

#ifndef CDECL
#define CDECL   cdecl
#endif

#define pNil	(0)
#define qNil	(0)
#define hNil	(0)
#define lhNil	(0)


#define dwNil	(0xFFFFFFFF)

// basic types
#ifndef VOID
#define VOID void
typedef long LONG;
#endif

/* Huge pointer stuff */
typedef VOID HUGE * RV;
typedef BYTE HUGE * RB;
typedef LONG HUGE * RL;

#define rNil    ((RV) 0L)

#ifndef SHORT
typedef short SHORT;
typedef char CHAR;
#endif

#ifndef BASETYPES
#define BASETYPES
typedef unsigned long ULONG;
typedef ULONG *PULONG;
typedef unsigned short USHORT;
typedef USHORT *PUSHORT;
typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef char *PSZ;
#endif  /* !BASETYPES */

typedef unsigned short WORD;
typedef unsigned short UWORD;

// pointer types

typedef char FAR *    QCH;   // Guaranteed far pointer - not an SZ, ST or LPSTR
typedef char FAR *    LPCHAR;
typedef BYTE FAR *    QB;
typedef BYTE FAR * 	  LPB;
typedef VOID FAR *    QV;
typedef SHORT  FAR *  QI;
typedef WORD FAR *    QW;
typedef LONG FAR *    QL;
typedef WORD FAR *    QUI;
typedef ULONG FAR *   QUL;
typedef DWORD FAR *   QDW;


typedef char *        PCH;   // "Native" pointer - not SZ, ST or NPSTR
typedef VOID *        PV;
typedef SHORT  *      PI;
typedef WORD *        PW;
typedef LONG *        PL;



// string types:
typedef unsigned char FAR * SZ; // 0-terminated string
typedef unsigned char FAR * ST; // byte count prefixed string

// other types
//#ifndef ITWRAP
//typedef HANDLE  HFS;              /* Handle to a file system */
//#endif

typedef DWORD   HASH;             /* Hash value */

typedef void (CALLBACK* MVCBPROC)();

/* points and rectangles */

typedef POINT         PT;
typedef POINT FAR *   QPT;
typedef POINT *       PPT;
typedef POINT NEAR *  NPPT;

typedef RECT          RCT;
typedef RECT FAR *    QRCT;
typedef RECT *        PRCT;
typedef RECT NEAR *   NPRCT;

// This from de.h -- the QDE struct ptr type is passed around alot,
// so it is "opaquely" defined here so the type is always available.

typedef struct de_tag FAR *QDE;

#define Unreferenced( var )   (var)     /* Get rid of compiler warnings */
#define LSizeOf( t )	         (LONG)sizeof( t )

/* MAC support function's prototype */

WORD  PASCAL FAR GetMacWord (BYTE FAR *);
VOID  PASCAL FAR SetMacWord (BYTE FAR *, WORD);
DWORD PASCAL FAR GetMacLong (BYTE FAR *);
VOID  PASCAL FAR SetMacLong (BYTE FAR *, DWORD);
WORD  PASCAL FAR SwapWord (WORD);
DWORD PASCAL FAR SwapLong (DWORD);

#if  defined( _32BIT )

#ifndef _MAC
// SMALL_RECT is not defined for _MAC
/*
 *   Win32 uses 32 bit coordinates in RECT structures.  The disk files
 *  use the Win 16 version,   which has 16 bit coordinates.  The NT version
 *  maps these when reading in,  and the following macros do the conversion.
 */

typedef SMALL_RECT SRCT, FAR *QSRCT, *PSRCT, NEAR *NPSRCT ;

#define COPY_SRCT_TO_RCT(a,b) { (b).left = (INT)(a).left; \
                                (b).top = (INT)(a).top; \
                                (b).right = (INT)(a).right; \
                                (b).bottom = (INT)(a).bottom); \
                              }

#define COPY_RCT_TO_SRCT(a,b) { (b).left = (short)(a).left; \
                                (b).top = (short)(a).top; \
                                (b).right = (short)(a).right; \
                                (b).bottom = (short)(a).bottom; \
                              }
#endif

#ifndef DEFINED_SHORT_RECT
typedef struct _SHORT_RECT { /* srct */
    short left;
    short top;
    short right;
    short bottom;
} SHORT_RECT, HUGE *  HUSHORT_RECT;
// for win32
#define DEFINED_SHORT_RECT
#endif

// changed LPRECT for huge support
typedef RECT HUGE *  HURECT;

#ifndef DEFINED_WMF_HEADER
// standard metafile header (page maker?)
typedef struct
{
  DWORD   key;
  WORD    hmf;
  SHORT_RECT    bbox;
  WORD    inch;
  DWORD   Unused1;
  WORD    CheckSum;
} WMF_HEADER;
#define DEFINED_WMF_HEADER
#endif

#ifndef DEFINED_MFH16
// standard metafile header (page maker?)
typedef struct
{
  DWORD   dwKey;
  WORD    hMF;
  SHORT_RECT    rcBound;
  WORD    wUnitsPerInch;
  DWORD   dwReserved;
  WORD    wChecksum;
} MFH16, FAR *LPMFH16;
#define DEFINED_MFH16
#endif

#endif	// defined( _32BIT )

#ifdef __cplusplus
}
#endif

#endif //__MISC_H__

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\mvdbcs.h ===
#ifdef __cplusplus
extern "C" {
#endif

/************************************************************************
*
* MVDBCS.H
*
* Copyright (c) Microsoft Corporation 1994
* All rights reserved.
*
*************************************************************************
*
* Module intent: Header file for the DBCS support.
*
*************************************************************************
*
* Current owner: DougO
*
************************************************************************/

#define LANGUAGE_ENGLISH        0x00
#define LANGUAGE_JAPANESE       0x01
#define LANGUAGE_TRAD_CHINESE   0x02 // Mapped to old LANGUAGE_CHINESE
#define LANGUAGE_KOREAN         0x03
#define LANGUAGE_ANSI           0x04
#define LANGUAGE_SIMP_CHINESE   0x05

#define SZ_LANGUAGE_ENGLISH         L"English"
#define SZ_LANGUAGE_JAPANESE        L"Japanese"
#define SZ_LANGUAGE_TRAD_CHINESE    L"TradChinese"
#define SZ_LANGUAGE_KOREAN          L"Korean"
#define SZ_LANGUAGE_ANSI            L"ANSI"
#define SZ_LANGUAGE_SIMP_CHINESE    L"SimpChinese"

#define CSZ_LANGUAGE_ENGLISH        7   // strlen (SZ_LANGUAGE_ENGLISH)
#define CSZ_LANGUAGE_JAPANESE       8   // strlen (SZ_LANGUAGE_JAPANESE)
#define CSZ_LANGUAGE_TRAD_CHINESE   11  // strlen (SZ_LANGUAGE_TRAD_CHINESE)
#define CSZ_LANGUAGE_KOREAN         6   // strlen (SZ_LANGUAGE_KOREAN)
#define CSZ_LANGUAGE_ANSI           4   // strlen (SZ_LANGUAGE_ANSI)
#define CSZ_LANGUAGE_SIMP_CHINESE   11  // strlen (SZ_LANGUAGE_SIMP_CHINESE)

#define IS_DBCS(qde) ((qde)->bCurLanguage != LANGUAGE_ANSI)

// for speed, the layout engine sometimes bypasses these macros by having
// two separate routines: DBCS and non-DBCS
#define PREVINDEX(qde, a,b) (IS_DBCS(qde) ? PchPrevDbcsIndex(qde, a,b) : (b) - 1)
#define NEXTINDEX(qde, a,b) (IS_DBCS(qde) ? PchNextDbcsIndex(qde, a,b) : (b) + 1)
#define FLINEBREAK(qde,qlin, a,b,c) (IS_DBCS(qde) ? FLineBreak(qde, (qlin)->kl.qbCommand, a,b,c) : 0)
#define CHARNEXT(qde, ch) (IS_DBCS(qde) ? ch=PchNextDbcs(qde, ch) : ch++)

//#ifdef _DBCS
#ifdef _32BIT
#include <winnls.h>
#else
#include <olenls.h>
#endif

BOOL FIsDbcsLeadByte(QDE, char);
BOOL FIsDbcsLeadByte2(QDE, char *, char *);
BOOL FLineBreak(QDE, LPBYTE lpbCom, char *psz, char *pch, BOOL);
char * PchPrevDbcs(QDE, char *, char *);
char * PchPrevDbcs2(QDE, char *, char *);
long PchPrevDbcsIndex(QDE, char *, long);
long PchNextDbcsIndex(QDE, char *, long);
char * PchNextDbcs(QDE, char *);
ERR InitDBCS(QDE qde, HANDLE hTitle);
void FreeDBCS(QDE qde);

extern BOOL bUseDBCBoundary;

//#define CHARNEXT(a) a=PchNextDbcs(a)
//#define ISDBCSLEADBYTE(a) FIsDbcsLeadByte(a)

//#define CHARPREV2(a,b) b=PchPrevDbcs2(a,b)
//#define NEXTCHAR(a) PchNextDbcs(a)
//#define PREVINDEX(a,b) PchPrevDbcsIndex(a,b)
//#define NEXTINDEX(a,b) PchNextDbcsIndex(a,b)

#define	chKataMin	        0xa1
#define	chKataMac	        0xe0
#define	wchSpace	        0x8140
#define	lchSpace        	0x4081
#define	wchPlus		        0x7b81
#define	wchMinus	        0x7c81
#define	wchNum0		        0x4f82
#define	wchNum9		        0x5882
#define	wchUppA		        0x6082
#define	wchUppZ		        0x7982
#define	wchLowA		        0x8182
#define	wchLowZ		        0x9a82
#define	wchKanaMin	        0x9f82
#define	wchKanaMac	        0x9783
#define	wchKataMin	        0x4083
#define	wchHiraMin	        0x9f82
#define	wchHaveKDakuMin	    0x4a83		/* Katakana */
#define	wchHaveHDakuMin	    0xa982		/* Hiragana */
#define	wchHaveHDakuMac	    0xdc82		/* Hiragana */
#define	wchHaveDakuMac	    0x7c83

#define wchHiraganaFirst	0x9f82
#define wchHiraganaLast		0xf182
#define wchKatakanaFirst	0x4083
#define wchKatakanaLast		0x9683
#define wchKanjiFirst		0x9f88

// list of leading punctuations: don't break line after these

#define	chLeft0		0xa2
#define	wchLeft0	0x6581
#define	wchLeft1	0x6781
#define	wchLeft2	0x6981
#define	wchLeft3	0x6b81
#define	wchLeft4	0x6d81
#define	wchLeft5	0x6f81
#define	wchLeft6	0x7181
#define	wchLeft7	0x7381
#define	wchLeft8	0x7581
#define	wchLeft9	0x7781
#define	wchLeftA	0x7981

// list of following punctuations: don't break line before these

#define	chKuten		0xa1
#define	chRight0	0xa3
#define	chTouten	0xa4
#define	chMidDot	0xa5
// small kata are also forbidden followers..0xa7 thru 0xaf
#define	chChohon	0xb0
#define	chDakuten	0xde
#define	chHandaku	0xdf
#define	wchTouten	0x4181
#define	wchKuten	0x4281
#define	wchComma	0x4381
#define	wchPeriod	0x4481
#define	wchMidDot	0x4581
#define	wchColon	0x4681
#define	wchSemiCol	0x4781
#define	wchQuestion	0x4881	
#define	wchExclam	0x4981
#define	wchDakuten	0x4a81
#define	wchHandaku	0x4b81
#define	wchChohon	0x5b81
#define	wchRight0	0x6681
#define	wchRight1	0x6881
#define	wchRight2	0x6a81
#define	wchRight3	0x6c81
#define	wchRight4	0x6e81
#define	wchRight5	0x7081
#define	wchRight6	0x7281
#define	wchRight7	0x7481
#define	wchRight8	0x7681
#define	wchRight9	0x7881
#define	wchRightA	0x7a81

// other defines

#define chShade		    0x7f
#define	wchEqual	    0x8181	/* '=' of DBC */
#define	wchQuote	    0x6881	/* '"' of DBC */
#define	wchAt		    0x9781	/* '@' of DBC */
#define	wchLessThan	    0x8381	/* '<' of DBC */
#define	wchGrtThan	    0x8481	/* '>' of DBC */
#define	wchLParen	    0x6981	/* '(' of DBC */
#define	wchRParen	    0x6a81	/* ')' of DBC */
#define	wchAsterisk	    0x9681	/* '*' of DBC */
#define	wchSlash	    0x5e81	/* '/' of DBC */
#define	wchCircumflex	0x4f81	/* '^' of DBC */
#define	wchAnd		    0x9581	/* '&' of DBC */
#define	wchOr		    0x6281	/* '|' of DBC */
#define	wchPercent	    0x9381	/* '%' of DBC */
#define	wchTilde	    0x6081	/* '~' of DBC */
#define	wchName		    0x6681	/* pc's chName */
#define	wchNameAlt	    0x6881	/* pc's chNameAlt */
#define	wchRow		    0x7182	/* pc's chRow */
#define	wchCol		    0x6282	/* pc's chCol */

#define	cwchLedPunct	15
#define	cwchFlwPunct	39

// double width character end mark

#define wchDwidthMark	0x814e

//#else not DBCS
//
//#define CHARNEXT(a) (a++)
//#define NEXTCHAR(a) ((a)+1)
//#define CHARPREV2(a,b) (b--)

//#define PREVINDEX(a,b) (b-1)
//#define NEXTINDEX(a,b) (b+1)

//#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\mverror.h ===
#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************\
*                                                                            *
*  MVERROR.H                                                                 *
*                                                                            *
*  Copyright (C) Microsoft Corporation 1993 - 1994.                          *
*  All Rights reserved.                                                      *
*                                                                            *
******************************************************************************
*                                                                            *
*  Module Intent:                                                            *
*   Defines constants used as error codes.                                   *
*                                                                            *
\****************************************************************************/

#ifndef ERRB_DEFINED
#define ERRB_DEFINED

/*************************************************************************
 *                       Error management.
 *************************************************************************/
typedef WORD ERR;   // Use this for internal & external errors
typedef ERR RC;     // This should be phased out
typedef WORD HCE;   // User errors
typedef WORD EP;    // Error Phase

/*************************************************************************
 *
 *                  CALLBACK FUNCTIONS PROTOTYPES
 *
 * User callback functions are needed in case:
 *  - The application needs to support interrupt
 *  - The application needs to display error messages its way
 *  - The application needs to know the status of the process
 *************************************************************************/
typedef ERR (FAR PASCAL *ERR_FUNC) (DWORD dwFlag, LPVOID pUserData, LPVOID pMessage);

/*************************************************************************
 * Call back structure
 *  Contains information about all callback functions
 *************************************************************************/ 

#define ERRFLAG_INTERRUPT      0x01 // The processes should be cancelled
#define ERRFLAG_STATUS         0x02 // High-level status messages
#define ERRFLAG_STATUS_VERBOSE 0x04 // Low-level status messages
#define ERRFLAG_ERROR          0x08 // Warning & Error messages
#define ERRFLAG_STRING         0x10 // Debug string messages

typedef struct fCallBack_msg
{
    ERR_FUNC MessageFunc;
    LPVOID pUserData;
    DWORD  dwFlags;
} FCALLBACK_MSG, FAR * PFCALLBACK_MSG;

// Error Phase values
#define epNoFile       0
#define epLine         1
#define epTopic        2
#define epOffset       3
#define epMVBtopic	   4
#define epAliasLine	   5
#define epByteOffset   6

// ***********************************************************************
// This structure should be filled out and passed back in the case of
// an error.
// ***********************************************************************
typedef struct
{
    LPCSTR  pchFile;
    LONG    iLine;
    DWORD   iTopic;
    DWORD   fCustom; // If true then var1 is LPCSTR to custom error message
    DWORD   var1, var2, var3;   // Error parameters

    EP      ep;                 // Error Phase
    HCE     errCode;
} ERRC, FAR *PERRC;

#define CALLBACKKEY 0x524A4A44

typedef struct
{
    DWORD_PTR dwReserved;
    DWORD dwKey;
    FCALLBACK_MSG Callback;
} CUSTOMSTRUCT, FAR *PCUSTOMSTRUCT;

/*************************************************************************
 *                       Error management.
 *************************************************************************/

/******************************************
 * Error structure. For internal use only
 ******************************************/

typedef struct
{
	ERR     err;        // Error code.
	LONG    iUser;      // Whatever you want.
	BYTE    *aszFile;   // Source file that caught an error.
	DWORD   cLine;      // Source line at which the failure took place.
} ERRB, FAR *LPERRB;

#define GetErrCode(lperrb)  ((lperrb)->err)

ERR EXPORT_API PASCAL FAR SetErr (LPERRB lperrb, ERR ErrCode, WORD iUserCode);

ERR EXPORT_API CDECL MVSetUserCallback (LPVOID pStruct, PFCALLBACK_MSG pCallback);

ERR EXPORT_API PASCAL FAR DebugSetErr (LPERRB lperrb, ERR ErrCode,
	DWORD Line, char FAR *module, WORD iUserCode);

HCE EXPORT_API FAR IssueMessage
    (DWORD dwFlag, PFCALLBACK_MSG pCallbackInfo, PERRC perr, HCE hce, ...);

void EXPORT_API FAR IssueString
    (PFCALLBACK_MSG pCallback, LPVOID pMessage);

#if defined(_DEBUG)
#define	SetErrCode(a,b)	DebugSetErr(a, b, __LINE__, (char FAR *)s_aszModule, 0)
#else
#define	SetErrCode(a,b)	SetErr(a, b, 0)
#endif

#endif // ERRB_DEFINED

/* End of internal usage */

// MAX size of an error string in the resource file.
#define MAX_ERROR_MSG 256

/************************************
*  Error Constants
*************************************/

/* General errors */
#ifndef SUCCEED	// already defined in sqlfront.h, used by mos
#define SUCCEED                     0
#endif

#ifndef FAIL
#define FAIL	1
#endif

#define ERR_NONE                 0
#define ERR_SUCCESS				 0

#define ERR_OODC               1002   // Out of Display Contexts
#define ERR_NOTITLE            1003
#define ERR_INVALID            1004   // Invalid file
#define ERR_NOTOPIC            1005
#define ERR_BADPRINT           1006
#define ERR_BADFILE            1007
#define ERR_OLDFILE            1008
#define ERR_BUFOVERFLOW        1009
#define ERR_FSREADWRITE        1010
#define ERR_FCENDOFTOPIC       1011
#define ERR_BADPARAM           1012
#define ERR_NOFONTCHANGE       1013
#define ERR_NOMOREHOTSPOTS     1014
#define ERR_BADEWWINCLASS      1015
#define ERR_PARTIAL            1016
#define ERR_NOADDRESS          1017
#define ERR_NORECTANGLE        1018
#define ERR_NOVSCROLL          1019   // No Vertical Scrollbar
#define ERR_NOHSCROLL          1020   // No Horizontal Scrollbar
#define ERR_CANTFINDDLL        1021
#define ERR_CANTUSEDLL         1022
#define ERR_EWOOM              1023   // Embedded Window Out Of Memory
#define ERR_DEBUGMISMATCH      1024
#define ERR_BADPOLYGON         1025   // less than 3 pts or none passed
#define ERR_BADEWCALLBACK      1026
#define ERR_OLDFONTTABLE       1027
#define ERR_NOSUCHSTYLE        1028
#define ERR_GROUPIDTOOBIG      1029
#define ERR_NOMOREHIGHLIGHTS   1030
#define ERR_NOSELECTION        1031
#define ERR_KEYSELECTFAILED    1032   // may need to scroll MV to work.
#define ERR_NOTSCROLLED		   1033
#define ERR_NOINDEXLOADED	   1034   // search index not loaded
#define ERR_EWCREATEFAILED     1035   // CreateWindow failed.
#define ERR_NOWINDOW	       1036   // Window not set in LPMV
#define ERR_OUTOFRANGE         1037
#define ERR_NOTHINGTOCOPY      1038
#define ERR_NOTFOUND           1039
#define ERR_NOTSUPPORTED       1040
#define ERR_RECURSION	       1041   // function is currently executing.
#define ERR_XAPARATOOBIG       1042
#define ERR_DUPTITLE           1043  // Duplicate handle in an update list (titleas.c)

#define ERR_INTERNAL_BASE      2000
#define ERR_GRAMMAR_BASE       3000

#define ERR_FAILED                      (ERR_INTERNAL_BASE + 1)
#define ERR_INTERRUPT                   (ERR_INTERNAL_BASE + 2)
#define ERR_NEARMEMORY                  (ERR_INTERNAL_BASE + 3)
#define ERR_MEMORY                      (ERR_INTERNAL_BASE + 4)
#define ERR_DISKFULL                    (ERR_INTERNAL_BASE + 5)
#define ERR_WORDTOOLONG                 (ERR_INTERNAL_BASE + 6)
#define ERR_BADVERSION                  (ERR_INTERNAL_BASE + 7)
#define ERR_TOOMANYTOPICS               (ERR_INTERNAL_BASE + 8)
#define ERR_TOOMANYSTOPS                (ERR_INTERNAL_BASE + 9)
#define ERR_TOOLONGSTOPS                (ERR_INTERNAL_BASE + 10)
#define ERR_STEMTOOLONG                 (ERR_INTERNAL_BASE + 11)
#define ERR_TREETOOBIG                  (ERR_INTERNAL_BASE + 12)
#define ERR_CANTREAD                    (ERR_INTERNAL_BASE + 13)
#define ERR_IDXSEGOVERFLOW              (ERR_INTERNAL_BASE + 14)
#define ERR_BADARG                      (ERR_INTERNAL_BASE + 15)
#define ERR_VOCABTOOLARGE               (ERR_INTERNAL_BASE + 16)
#define ERR_NOTEXIST                    (ERR_INTERNAL_BASE + 17)
#define ERR_BADOPERATOR                 (ERR_INTERNAL_BASE + 18)
#define ERR_TERMTOOCOMPLEX              (ERR_INTERNAL_BASE + 19)
#define ERR_SEARCHTOOCOMPLEX            (ERR_INTERNAL_BASE + 20)
#define ERR_BADSYSCONFIG                (ERR_INTERNAL_BASE + 21)
#define ERR_ASSERT                      (ERR_INTERNAL_BASE + 22)
#define ERR_TOOMANYDUPS                 (ERR_INTERNAL_BASE + 23)
#define ERR_INVALID_FS_FILE             (ERR_INTERNAL_BASE + 24)
#define ERR_OUT_OF_RANGE                (ERR_INTERNAL_BASE + 25)
#define ERR_SEEK_FAILED                 (ERR_INTERNAL_BASE + 26)
#define ERR_FILECREAT_FAILED            (ERR_INTERNAL_BASE + 27)
#define ERR_CANTWRITE                   (ERR_INTERNAL_BASE + 28)
#define ERR_NOHANDLE                    (ERR_INTERNAL_BASE + 29)
#define ERR_EXIST                       (ERR_INTERNAL_BASE + 30)
#define ERR_INVALID_HANDLE              (ERR_INTERNAL_BASE + 31)
#define ERR_BADFILEFORMAT               (ERR_INTERNAL_BASE + 32)
#define ERR_CANTDELETE                  (ERR_INTERNAL_BASE + 33)
#define ERR_NOPERMISSION                (ERR_INTERNAL_BASE + 34)
#define ERR_CLOSEFAILED                 (ERR_INTERNAL_BASE + 35)
#define ERR_DUPLICATE					(ERR_INTERNAL_BASE + 36)

#define ERR_NOMERGEDATA					(ERR_INTERNAL_BASE + 37)
#define ERR_TOOMANYTITLES				(ERR_INTERNAL_BASE + 38)
#define ERR_BADINDEXFLAGS				(ERR_INTERNAL_BASE + 39)

#define ERR_NULLQUERY                   (ERR_GRAMMAR_BASE + 0)
#define ERR_EXPECTEDTERM                (ERR_GRAMMAR_BASE + 1)
#define ERR_EXTRACHARS                  (ERR_GRAMMAR_BASE + 2)
#define ERR_MISSQUOTE                   (ERR_GRAMMAR_BASE + 3)
#define ERR_MISSLPAREN                  (ERR_GRAMMAR_BASE + 4)
#define ERR_MISSRPAREN                  (ERR_GRAMMAR_BASE + 5)
#define ERR_TOODEEP                     (ERR_GRAMMAR_BASE + 6)
#define ERR_TOOMANYTOKENS               (ERR_GRAMMAR_BASE + 7)
#define ERR_BADFORMAT                   (ERR_GRAMMAR_BASE + 8)
#define ERR_BADVALUE                    (ERR_GRAMMAR_BASE + 9)
#define ERR_UNMATCHEDTYPE               (ERR_GRAMMAR_BASE + 10)
#define ERR_BADBREAKER                  (ERR_GRAMMAR_BASE + 11)
#define ERR_BADRANGEOP                  (ERR_GRAMMAR_BASE + 12)
#define ERR_ALL_WILD                    (ERR_GRAMMAR_BASE + 13)
#define ERR_NON_LAST_WILD               (ERR_GRAMMAR_BASE + 14)
#define ERR_WILD_IN_DTYPE               (ERR_GRAMMAR_BASE + 15)
#define ERR_STOPWORD			(ERR_GRAMMAR_BASE + 16)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\verinfo.h ===
/*****************************************************************************
*
*  VERINFO.H
*
*  Copyright (C) Microsoft Corporation 1996-1997
*  All Rights reserved.
*
******************************************************************************
*
*  Module Intent: Version specific constant definitions
* 
*****************************************************************************/

// Names of DLLs.  Used by the VERSIONNAME entry in the RC file of each DLL.
#define DLLFILE_ITCC     "ITCC.DLL\0"
#define DLLFILE_ITSS     "ITSS.DLL\0"
#define DLLFILE_ITIRCL   "ITIRCL.DLL\0"

// InfoTech version number:  major, minor, update, application.
#define rmj             4
#define rmm             72
#define rup             7276
#define rap             0

#define szVerName       ""
#define szVerUser       ""

// InfoTech *file* version number: major, minor, application.  These
// may not get updated as often as their executable counterparts above.
// This version number is used to stamp some areas of ITIRCL's persistent
// storage.
#define rmjFile             4
#define rmmFile             0
#define rapFile             0

// NT build environment defines DBG instead of _DEBUG
#if defined(DBG) && !defined(_DEBUG)
#define _DEBUG
#endif

#ifdef _DEBUG
#define VERSIONSTR		"Debug Version 4.72\0"
#define VERSIONFLAGS            VS_FF_DEBUG
#else
#define VERSIONSTR		"4.72\0"
#define VERSIONFLAGS            0
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\mem.h ===
/*****************************************************************************
*                                                                            *
*  MEM.H                                                                     *
*                                                                            *
*  Copyright (C) Microsoft Corporation 1990.                                 *
*  All Rights reserved.                                                      *
*                                                                            *
******************************************************************************
*                                                                            *
*  Module Intent:  Exports memory management functionality.
*                  Most functions map directly to Window's                   *
*                  memory manager calls.                                     *
******************************************************************************
*                                                                            *
*  Current Owner: RHobbs                                                     *
*                                                                            *
*****************************************************************************/

#if defined( __cplusplus )
extern "C" {
#endif

/*****************************************************************************
*                                                                            *
*                               Prototypes                                   *
*                                                                            *
*****************************************************************************/

HANDLE PASCAL FAR GhDupGh(HANDLE);
HANDLE PASCAL FAR GhDupSz(LPSTR);
VOID FAR PASCAL MakeGlobalPool (void);
VOID FAR PASCAL FreeGlobalPool (void);
HANDLE FAR PASCAL _VirtualAlloc(LPVOID, DWORD, DWORD, DWORD, LPSTR, UINT);
LPVOID FAR PASCAL _VirtualLock(LPVOID, DWORD, LPSTR, UINT);
BOOL   FAR PASCAL _VirtualUnlock(LPVOID, DWORD, LPSTR, UINT);
int    FAR PASCAL _VirtualFree(LPVOID, DWORD, DWORD, LPSTR, UINT);

/*****************************************************************************
*                                                                            *
*                               Defines                                      *
*                                                                            *
*****************************************************************************/

#if defined(MOSMAP) && !defined(NOMOSMEM)
// Mos server can't be limited in the number of handles. However, sometimes 
// debug layer is needed to track memory leaks. Simply comment out next line
// or compile with NOMOSMEM
#define MOSMEM
#endif

#ifndef _MAC
#define	DLLGMEM_ZEROINIT		(GMEM_MOVEABLE | GMEM_ZEROINIT)
#else
#define	DLLGMEM_ZEROINIT		(GMEM_MOVEABLE | GMEM_SHARE | GMEM_ZEROINIT | GMEM_PMODELOCKSTRATEGY)
#endif

#define	_LOCALALLOC		LocalAlloc
#define	_LOCALLOCK		LocalLock
#define	_LOCALUNLOCK	LocalUnlock
#define	_LOCALFREE		LocalFree

#if defined(_DEBUG) && !defined(_MSDN) && !defined(MOSMEM)
#include <windowsx.h>

HANDLE FAR PASCAL _GlobalAlloc(UINT, DWORD, LPSTR, UINT);
LPVOID FAR PASCAL _GlobalLock(HANDLE, LPSTR, UINT);
BOOL   FAR PASCAL _GlobalUnlock(HANDLE, LPSTR, UINT);
HANDLE FAR PASCAL _GlobalFree(HANDLE, LPSTR, UINT);
HANDLE FAR PASCAL _GlobalReAlloc(HANDLE, DWORD, UINT, LPSTR, UINT);
HANDLE FAR PASCAL _GlobalRelease(HANDLE, LPSTR, UINT);
HANDLE FAR PASCAL _GlobalAdd(HANDLE, LPSTR, UINT);
DWORD  FAR PASCAL _GlobalSize(HANDLE, LPSTR, UINT);

#define	_GLOBALALLOC(a,b)       _GlobalAlloc(a,b,s_aszModule,__LINE__)
#define	_GLOBALLOCK(a)          _GlobalLock(a,s_aszModule, __LINE__)
#define	_GLOBALSIZE(a)          _GlobalSize(a,s_aszModule, __LINE__)
#define	_GLOBALUNLOCK(a)        _GlobalUnlock(a,s_aszModule, __LINE__)
#define	_GLOBALFREE(a)          _GlobalFree(a,s_aszModule, __LINE__)
#define	_GLOBALREALLOC(a,b,c)	_GlobalReAlloc(a,b,c,s_aszModule, __LINE__)
#define _GLOBALRELEASE(a)       _GlobalRelease(a, s_aszModule, __LINE__)
#define _GLOBALADD(a)           _GlobalAdd(a, s_aszModule, __LINE__)
#define _GLOBALALLOCPTR(a,b)	(_GLOBALLOCK(_GLOBALALLOC(a,b)))
#define _GLOBALFREEPTR(a)		(_GLOBALUNLOCK(GlobalPtrHandle((LPVOID)a)), \
								 _GLOBALFREE(GlobalPtrHandle((LPVOID)a)))

#define	_VIRTUALALLOC(a,b,c,d)  _VirtualAlloc(a,b,c,d,s_aszModule,__LINE__)
#define	_VIRTUALLOCK(a,b)       _VirtualLock(a,b,s_aszModule, __LINE__)
#define	_VIRTUALUNLOCK(a,b)     _VirtualUnlock(a,b,s_aszModule, __LINE__)
#define	_VIRTUALFREE(a,b,c)     _VirtualFree(a,b,c,s_aszModule, __LINE__)

DWORD PASCAL FAR CheckMem(VOID);
DWORD PASCAL FAR GetMemUsed(VOID);

#else

#if defined( MOSMEM )	// {
// We can't afford to have memory overhead on the server.... => no debug, no moveable
#define	_GLOBALALLOC(a,b)	GlobalAlloc((a)&~GMEM_MOVEABLE,b)
#define	_GLOBALREALLOC(a,b,c)	GlobalReAlloc(a,b,((c)&~GMEM_MODIFY)|GMEM_MOVEABLE)
#define _GLOBALALLOCPTR(a,b) (_GLOBALALLOC(a,b))
#else // }{
#define	_GLOBALALLOC	GlobalAlloc
#define	_GLOBALREALLOC	GlobalReAlloc
#define _GLOBALALLOCPTR GlobalAllocPtr
#endif	// }
#define	_GLOBALLOCK		(VOID FAR *)GlobalLock
#define	_GLOBALUNLOCK	GlobalUnlock
#define	_GLOBALFREE		GlobalFree
#define	_GLOBALSIZE		GlobalSize
#define _GLOBALRELEASE(a) (a)
#define _GLOBALADD(a)	 (a)
#define _GLOBALFREEPTR	GlobalFreePtr
#define	_VIRTUALALLOC(a,b,c,d)       VirtualAlloc(a,b,c,d)
#define	_VIRTUALLOCK(a,b)          VirtualLock(a,b)
#define	_VIRTUALUNLOCK(a,b)        VirtualUnlock(a,b)
#define	_VIRTUALFREE(a,b,c)          VirtualFree(a,b,c)

#endif	// _DEBUG

#define FCheckGh( gh ) TRUE
#define LhFromP(pv) LocalHandle( (WORD)(pv) )

// Flags to be use to control block manager allocation

#define	THREADED_ELEMENT	1
#ifdef _MAC
#define	USE_VIRTUAL_MEMORY	0
#else
#define	USE_VIRTUAL_MEMORY	0
#endif

#if defined( __cplusplus )
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\mvopsys.h ===
/*************************************************************************
*                                                                        *
*  MVOPSYS.H                                                             *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   Include platform dependent include files                             *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
*************************************************************************/

#ifndef __MVOPSYS_H_
#define __MVOPSYS_H_

/*   There is C and C++ code, use these defines for interfaces between the 2 */
#if defined( __cplusplus ) // {
#define EXTC extern "C"
#define EXTCSTART EXTC {
#define EXTCEND }
#else // } {
#define	EXTC
#define EXTCSTART
#define EXTCEND
#endif // }


#include <windows.h>
#include <windowsx.h>
#include <string.h>

#if defined(DBG) && !defined(_DEBUG)
#define _DEBUG
#endif

#if defined(_WIN32) && !defined(_32BIT)
#define _32BIT
#endif

#ifdef _32BIT // {
#include <wincon.h>

/*****************************************************
 *            32-BIT SPECIFIC DEFINITIONS
 *
 *   All 32-bit platforms related definitions should be
 *   placed here, eg. _MAC, _NT, etc
 *****************************************************/

/*  Some _32BIT specific bits & pieces */

#define _loadds
#define __loadds
#define far
#define _far
#define huge
#define _huge
#define _export
#define __export
#define EXPORT_API
#define PRIVATE

// These old macros are still used in some places.
#define WRITE OF_WRITE
#define READ OF_READ

// Define PAGE_SIZE (this is processor dependent)
#if defined(ALPHA) || defined(IA64)
#define PAGE_SIZE 8192
#else
#define PAGE_SIZE 4096
#endif

/**************************************************
 *    FUNCTIONS SPECIFIC TO 32-BIT ONLY
 **************************************************/

#ifdef _MAC
#define LOCKSEMAPHORE(pl)  ((*(pl)==0) ? (*(pl)=1,0) : 1)
#define UNLOCKSEMAPHORE(pl) (*(pl)=0)
#else
#define LOCKSEMAPHORE(pl)   InterlockedExchange((pl),1)
#define UNLOCKSEMAPHORE(pl)   InterlockedExchange((pl),0)
#endif
 
/* GetProfileString */
#define GETPROFILESTRING(a,b,c,d,e)

/* MakeProcInstance is not needed for Win32 */

#define MAKEPROCINSTANCE(a,b) a
#define FREEPROCINSTANCE(a)

/* DLL currently not supported */

#define FREELIBRARY(a)

/* Function calls changes between 16 and 32 bit */

#define SETVIEWPORTORG(a,b,c) SetViewportOrgEx(a,b,c,NULL)
#define SETVIEWPORTEXT(a,b,c) SetViewportExtEx(a,b,c,NULL)
#define SETWINDOWEXT(a,b,c) SetWindowExtEx(a,b,c,NULL)
#define SETWINDOWORG(a,b,c) SetWindowOrgEx(a,b,c,NULL)
#define MOVETO(a,b,c) MoveToEx(a,b,c,NULL)
#define SETBRUSHORG(a,b,c) SetBrushOrgEx(a,b,c,NULL)
#define ENUMFONTFAMILIES(a,b,c,d)     EnumFontFamilies(a,b,c,(LPARAM)d)
#define GETCWD( addr, len )     (GetCurrentDirectory( len, addr ) ? addr : NULL)
#define MAKEPOINT(l) { (LONG)(WORD)(l) , (LONG)(WORD)(l >> 16)}

// Can't have NULL as path... must be a string
#define GETTEMPFILENAME GetTempFileNameEx

WORD EXPORT_API PASCAL FAR GetTempFileNameEx(
	LPCSTR lpszPath,        /* address of name of dir. where temp. file is created  */
	LPCSTR lpszPrefix,      /* address of prefix of temp. filename  */
	WORD uUnique,   /* number used to create temp. filename */
	LPSTR lpszTempFile) ;	/* address buffer that will receive temp. filename	*/

#define MEMCPY    memmove
#define MEMSET    memset
#define MEMCMP	  memcmp
#define FREE      free
#define MALLOC    malloc
#define REALLOC   realloc
#define MEMMOVE   memmove
#define QVCOPY    memmove
#define	VSNPRINTF	_vsnprintf
#define SPRINTF	  wsprintf
#define ITOA	  _itoa
#define ATOI	  atoi
#define ATOL	  atol
#define ISDIGIT	  isdigit
#define ISXDIGIT  isxdigit
#define QvCopy	  memmove
#define STRLEN    strlen
#define STRCPY    lstrcpy
#define STRDUP    _strdup
#define STRCHR    strchr
#define STRCAT    lstrcat
#define STRTOK    strtok
#define STRUPR    _strupr
#define STRCMP    lstrcmp
#define STRICMP   lstrcmpi
#define STRNICMP  _strnicmp 
#define STRNCPY   lstrcpyn
#define STRNCAT	  strncat

// Define some new macros
// I'm afraid of just defining the ones
// above to the appropriate UNICODE versions
// since the B-tree code (for example) is not
// yet UNICODE
 
#define WSTRLEN    wcslen
#define WSTRCPY    wcscpy
#define WSTRDUP    _wcsdup
#define WSTRCHR    wcschr
#define WSTRCAT    wcscat
#define WSTRTOK    wcstok
#define WSTRUPR    _wcsupr
#define WSTRCMP    wcscmp
#define WSTRICMP   _it_wcsicmp
#define WSTRNICMP  _wcsnicmp
#define WSTRNCPY   wcsncpy
#define WSTRNCAT   wcsncat
#define WTOI		_wtoi
#define WTOL		_wtol


#define GETINSTANCE(h)  ((HINSTANCE)GetWindowLong(h,GWL_HINSTANCE))
/***********************************************
 *    MAC SPECIFIC DEFINITIONS & DECLARATIONS
 ***********************************************/
    
#ifdef _MAC // {

/* Currently, Pascal convention is inefficient on the MAC, becuase:
 *   - Returned value are passed back on the stack instead of using register
 *   - For earlier CPU (<68910), the return code is less efficient
 *         movel	(a7)+, a0
 *         adda.w #cbParams, a7
 *         jmp    (a0)
 */
//#undef	PASCAL
//#define	PASCAL
#endif // }

#ifdef _BIG_E // BigEndian {

/* The below defines are needed to handle difference in architectures between
 * Motorola's 68K and Intel's x86 memory mappings
 */
 
#ifdef __cplusplus
extern "C"
{
	WORD  PASCAL FAR SwapWord (WORD);
	DWORD PASCAL FAR SwapLong (DWORD);
	WORD  PASCAL FAR GetMacWord (BYTE FAR *);
	VOID  PASCAL FAR SetMacWord (BYTE FAR *, WORD);
	DWORD PASCAL FAR GetMacLong (BYTE FAR *);
	VOID  PASCAL FAR SetMacLong (BYTE FAR *, DWORD);
};
#endif


#define GETWORD(p)    GetMacWord((BYTE FAR *)(p))
#define SETWORD(p,w)  SetMacWord((BYTE FAR *)(p),(w))
#define SWAPWORD(p)   SwapWord((p))
#define GETLONG(p)    GetMacLong((BYTE FAR *)(p))
#define SETLONG(p,l)  SetMacLong((BYTE FAR *)(p),(l))
#define SWAPLONG(p)   SwapLong((p))
#define GETVA(p)      GetMacVA((p))
#define SWAPVA(p)     GetMacVA((p))
#define GETMBHD(p,q)  GetMacMBHD((p),(q))
#define GETMFCP(p,q)  GetMacMFCP((p),(q))
#define HI_BYTE 1
#define LO_BYTE 0

#else	 // regular 32 bit }{
#define	GETWORD(p)	(*((USHORT UNALIGNED FAR *)(p)))
#define SETWORD(a, b)   (*((USHORT UNALIGNED FAR *)(a))=(b))
#define GETLONG(p)	(*((DWORD UNALIGNED FAR *)(p)))
#define SETLONG(p,l) ((*((DWORD UNALIGNED FAR *)(p))) = (l))


#define SWAPWORD(p)	((p))
#define SWAPLONG(p)	((p))
#define GETVA(p)     ((p))
#define SWAPVA(p)    ((p))
#define GETMBHD(p,q) QvCopy((p),(q), sizeof(MBHD))
#define GETMFCP(p,q) QvCopy((p),(q), sizeof(MFCP))
#define HI_BYTE 0
#define LO_BYTE 1

#endif   // _BIG_E}


/*********************************************************************
 *    Typecast to get rid of the unalignment problems on the RISC
 *********************************************************************/
typedef USHORT UNALIGNED FAR * LPUW;
typedef DWORD  UNALIGNED FAR * LPUL;

#else

/***************************************************
 *    16-BITS DEFINITIONS & DECLARATIONS
 ***************************************************/
 
#define EXPORT_API _export
#define UNALIGNED

#define GETWORD(p)   (*((USHORT FAR UNALIGNED *)(p)))
#define SWAPWORD(p)  (p)
#define GETLONG(p)   (*((DWORD FAR UNALIGNED *)(p)))
#define SETLONG(p,l) ((*((DWORD FAR UNALIGNED *)(p))) = l)
#define SWAPLONG(p)  (p)
#define GETVA(p)     (p)
#define SWAPVA(p)    (p)
#define GETMBHD(p,q) QvCopy((p),(q), sizeof(MBHD))
#define GETMFCP(p,q) QvCopy((p),(q), sizeof(MFCP))
#define HI_BYTE 0
#define LO_BYTE 1

#define LOCKSEMAPHORE(pl)  ((*(pl)==0) ? (*(pl)=1,0) : 1)
#define UNLOCKSEMAPHORE(pl) (*(pl)=0)

/* GetProfileString */
#define GETPROFILESTRING(a,b,c,d,e) GetProfileString(a,b,c,d,e)

/* DLL currently not supported */

#define FREELIBRARY(a) FreeLibrary(a)

/* Viewport calls */

#define SETVIEWPORTORG(a,b,c) SetViewportOrg(a,b,c)
#define SETVIEWPORTEXT(a,b,c) SetViewportExt(a,b,c)
#define SETWINDOWEXT(a,b,c) SetWindowExt(a,b,c)
#define SETWINDOWORG(a,b,c) SetWindowOrg(a,b,c)
#define MOVETO(a,b,c) MoveTo(a,b,c)
#define SETBRUSHORG(a,b,c) SetBrushOrg(a,b,c)
#define ENUMFONTFAMILIES(a,b,c,d)     EnumFontFamilies(a,b,c,(LPSTR)d)
#define GETCWD( addr, len )     getcwd( addr, len )

#define MEMCPY    _fmemmove
#define MEMSET    _fmemset
#define MEMCMP	  _fmemcmp
#define STRLEN    _fstrlen
#define STRCPY    _fstrcpy
#define STRDUP    _fstrdup
#define STRCHR    _fstrchr
#define STRCAT    _fstrcat
#define STRTOK    _fstrtok
#define STRUPR    _fstrupr
#define STRCMP    _fstrcmp
#define STRICMP   _fstricmp
#define STRNICMP  _fstrnicmp 
#define FREE      _ffree
#define MALLOC    _fmalloc
#define REALLOC   _frealloc
#define STRNCPY   _fstrncpy
#define MEMMOVE   _fmemmove
#define QVCOPY    _fmemmove
#define	VSNPRINTF	_vsnprintf
#define STRNCAT	  _fstrncat
#define SPRINTF	  wsprintf
#define ITOA	  itoa

#define MAKEPROCINSTANCE(a,b) MakeProcInstance(a,b)
#define FREEPROCINSTANCE(a) FreeProcInstance(a)
#define GETTEMPFILENAME GetTempFileName

#define GETINSTANCE(h)  ((HINSTANCE)GetWindowWord(h,GWW_HINSTANCE))
#endif  // } _32BIT
#endif // __MVOPSYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\msitstg.h ===
// MSITStg.h -- Interface declaration for IMSITStorage

#ifndef __MSITSTG_H__

#define __MSITSTG_H__

// Class ID for the ITSS File System:

DEFINE_GUID(CLSID_ITStorage, 
0x5d02926a, 0x212e, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Inteface ID for the IITStorage interface:

DEFINE_GUID(IID_ITStorage, 
0x88cc31de, 0x27ab, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Class ID for the FSStorage wrapper for the Win32 file system:

// {D54EEE56-AAAB-11d0-9E1D-00A0C922E6EC}
DEFINE_GUID(CLSID_IFSStorage, 
0xd54eee56, 0xaaab, 0x11d0, 0x9e, 0x1d, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IFSStorage interface:

// {8BB2438A-A70C-11d0-9E1C-00A0C922E6EC}
DEFINE_GUID(IID_IFSStorage, 
0x8bb2438a, 0xa70c, 0x11d0, 0x9e, 0x1c, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStream interface

DEFINE_GUID(IID_IStreamITEx, 
0xeb19b681, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStorage interface

DEFINE_GUID(IID_IStorageITEx, 
0xeb19b680, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the Data Space Manager used within an ITStorage object:

DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the plug-in data transforms:

DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

/*

The IITStorage interface parallels the API's defined for creating and
opening Docfiles. So if you have code that currently uses Docfiles for 
your storage mechanism, you can easily convert over to using ITS files 
instead. 

ITS files use a different on-disk structure to optimize them for very 
fast stream access and very low overhead. ITS files can manage thousands 
or millions of streams with very good access performance and very small 
directory space requirements. This makes ITS files ideal for CD-Roms and
for data collections that you'll download across the Internet. 

To make the conversion to ITS files you'll need to call CoCreateInstance 
with the class-id CLSID_ITStorage and the interface-id IID_ITStorage. You'll 
get back an interface pointer, say pItStg. Then you'll need to adjust the
places where your code creates or opens Docfiles. Instead of StgCreateDocfile
you'll call pItStg->StgCreateDocfile, and instead of StgOpenStorage, you'll
call pItStg->StgOpenStorage. In both cases you'll get back an IStorage 
interface pointer, say pIStg, which you can use just as you did before.

That's it. In general the rest of your code shouldn't have to change. There 
are some functional difference between ITS files and Docfiles -- ITS files
don't support STGM_TRANSACTED, for example. So if you have to have transacted 
file operations, you can't use ITS files -- at least for now. However in
almost all other respects ITS files interfaces can directly replace Docfile
interfaces.

Converting your data is also easy. Just open one of  your Docfiles using
StgOpenStorage, create a new ITS file via pItStg->StgCreateDocfile, and then
use the CopyTo interface to copy your data objects and their storage heirarchy
over to the ITS file:
    
    pStgDocfile->CopyTo(0, NULL, NULL, pStgITS);

In some cases you may want to exercise some control over the internal parameters
kept in an ITS file. You do this by calling SetControlData to give the IITStorage
interface a block of ITS control data. Then each subsequent call to StgCreateDocfile
will use that control data. The ITS control data determines, among other things,
the tradeoff between efficient random access to the stream data and minimizing the
size of an ITS file.  

The actual structure and interpretation of ITS control data is documented below.
(See the ITSFS_Control_Data data type). You can get default control data via the
DefaultControlData fuction. Note that DefaultControlData allocates the control
structure using IMalloc::Alloc as provided by CoGetMalloc and expects that your code will
deallocate the structure using the IMalloc::Free.

 */

// IID_IStreamITEx interface declaration:

DECLARE_INTERFACE_(IStreamITEx, IStream)
{
    // IStreamITEx methods
    
    STDMETHOD(SetDataSpaceName)(const WCHAR   * pwcsDataSpaceName) PURE;
    STDMETHOD(GetDataSpaceName)(       WCHAR **ppwcsDataSpaceName) PURE;

    STDMETHOD(Flush)() = 0;
};

// IID_IStorageITEx interface declaration:

DECLARE_INTERFACE_(IStorageITEx, IStorage)
{
    // IStorageITEx methods:

    STDMETHOD(GetCheckSum)(ULARGE_INTEGER *puli) PURE;
    STDMETHOD(CreateStreamITEx)(const WCHAR * pwcsName, const WCHAR *pwcsDataSpaceName, 
                            DWORD grfMode, DWORD reserved1, DWORD reserved2, 
                            IStreamITEx ** ppstm
                           ) PURE;
    STDMETHOD(OpenStreamITEx)(const WCHAR * pwcsName, void * reserved1, DWORD grfMode, 
                          DWORD reserved2, IStreamITEx ** ppstm) PURE;
};

#pragma warning( disable : 4200)

// ITS_Control_Data is the generic structure of control data passed to the 
// IITStorage::SetControlData method or returned by the IITStorage::DefaultControlData
// method.

typedef struct _ITS_Control_Data
{
    UINT cdwControlData;     // Number of DWords to follow.
    UINT adwControlData[0];  // Actually this will be adwControlData[cdwControlData]

} ITS_Control_Data, *PITS_Control_Data;  


// ITSFS_Control_Data is the actual prefix structure of control data for IITStorage. 

typedef struct _ITSFS_Control_Data
{
    UINT cdwFollowing;     // Must be 6 or 13

    DWORD cdwITFS_Control; // Must be 5
    DWORD dwMagic;         // Must be MAGIC_ITSFS_CONTROL (see below)
    DWORD dwVersion;       // Must be 1
    DWORD cbDirectoryBlock;// Size in bytes of directory blocks (Default is 8192)
    DWORD cMinCacheEntries;// Least upper bound on the number of directory blocks
	                       // which we'll cache in memory. (Default is 20)
    DWORD fFlags;          // Control bit flags (see below). 
	                       // Default value is fDefaultIsCompression.

} ITSFS_Control_Data, *PITSFS_Control_Data;

// Signature value for ITSFS_Control_Data

const DWORD MAGIC_ITSFS_CONTROL    = 'I' | ('T' << 8) | ('S' << 16) | ('C' << 24);

// Bit flag definitions for ITSFS_Control_Data::fFlags

const DWORD fDefaultIsCompression  = 0x00000001;
const DWORD fDefaultIsUncompressed = 0x00000000;

// Note all other fFlags bits positions are reserved for future releases and should be 
// set to zero.

// When ITSFS_Control_Data::cdwFollowing is > 6, we assume that LZX_Control_Data follows
// immediately after. (See the XformControlData type below) LZX_Control_Data defines
// parameters which control the default compressed data space. 
//
// If ITSFS_Control_Data::cdwFollowing is 6, we use default values for the LZX
// control data.

typedef struct _LZX_Control_Data
{
    UINT  cdwControlData; // Must be 6

    DWORD dwLZXMagic;     // Must be LZX_MAGIC (see below)
    DWORD dwVersion;      // Must be 2
    DWORD dwMulResetBlock;// Number of blocks between compression resets.  (Default: 4)
    DWORD dwMulWindowSize;// Maximum number of blocks kept in data history (Default: 4)
    DWORD dwMulSecondPartition; // Granularity in blocks of sliding history(Default: 2)
    DWORD dwOptions;  // Option flags (Default: fOptimizeCodeStreams)

} LZX_Control_Data, *PLZX_Control_Data;

// Note: The block size for LZX compression is 32768 bytes.

const DWORD LZX_MAGIC           = 'L' | ('Z' << 8 ) | ('X' << 16) | ('C' << 24);

// Values for LZX_Control_Data::dwOptions

const DWORD fOptimizeCodeStreams = 0x00000001;

// Note that all other flag bit positions are reserved for future releases and should be
// set to zero.


// The second parameter for the IITStorage::Compact method below is an enueration
// which defines the level of compaction to do.

typedef enum ECompactionLev {COMPACT_DATA=0, COMPACT_DATA_AND_PATH} ;

DECLARE_INTERFACE_(IITStorage, IUnknown)
{
    // IITStorage methods

    STDMETHOD(StgCreateDocfile)(const WCHAR * pwcsName, DWORD grfMode, 
                                DWORD reserved, IStorage ** ppstgOpen
                               ) PURE;

    STDMETHOD(StgCreateDocfileOnILockBytes)(ILockBytes * plkbyt, DWORD grfMode,
                                            DWORD reserved, IStorage ** ppstgOpen
                                           ) PURE;

    STDMETHOD(StgIsStorageFile)(const WCHAR * pwcsName) PURE;

    STDMETHOD(StgIsStorageILockBytes)(ILockBytes * plkbyt) PURE;

    STDMETHOD(StgOpenStorage)(const WCHAR * pwcsName, IStorage * pstgPriority, 
                              DWORD grfMode, SNB snbExclude, DWORD reserved, 
                              IStorage ** ppstgOpen
                             ) PURE;

    STDMETHOD(StgOpenStorageOnILockBytes)
                  (ILockBytes * plkbyt, IStorage * pStgPriority, DWORD grfMode, 
                   SNB snbExclude, DWORD reserved, IStorage ** ppstgOpen
                  ) PURE;

    STDMETHOD(StgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                           FILETIME const * patime, FILETIME const * pmtime
                          ) PURE;

    STDMETHOD(SetControlData)(PITS_Control_Data pControlData) PURE;

    STDMETHOD(DefaultControlData)(PITS_Control_Data *ppControlData) PURE;
		
    STDMETHOD(Compact)(const WCHAR * pwcsName, ECompactionLev iLev) PURE;
};

typedef IITStorage *PIITStorage;

DECLARE_INTERFACE_(IFSStorage, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)  (THIS_ REFIID, VOID **) PURE;
    STDMETHOD_(ULONG, AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IFSStorage methods

    STDMETHOD(FSCreateStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSOpenStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSCreateStream)(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateTemporaryStream)(IStream **ppStrm) PURE;
    STDMETHOD(FSOpenStream  )(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateLockBytes)(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;
    STDMETHOD(FSCreateTemporaryLockBytes)(ILockBytes **ppLkb) PURE;
    STDMETHOD(FSOpenLockBytes  )(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;

    STDMETHOD(FSStgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                             FILETIME const * patime, FILETIME const * pmtime
                            ) PURE;
};

typedef IFSStorage *PIFSStorage;

/*
**   Data Spaces -- What they are.

Within an ITS file we store information in one or more data spaces. A data space
is a container which holds the bits which represent a collection of streams. Each
data space has a name and an associated collection of transforms.

Those transforms take the raw data which you write to an ITS stream and map it into
a representation stream. When you read from an ITS stream they do the reverse mapping
to reconstruct your original data from the representation. 

When you first create an ITS file, it contains one data space named "Default_Space"
which applies the LZX data compression transform. By default all of the streams you
create will have their data representations stored in the default data space.

If LZX compression meets your needs, and you're not concerned about data enciphering,
you can skip over the following discussion. If, on the other hand, you want to 
create additional data spaces or transforms, read on.

To create a data space, you must first get a pointer to the IDataSpaceManager interface.
Just do a QueryInterface for IID_DataSpaceManager from any storage created by the 
IITStorage interface. Then you can call the CreateDataSpace function to define a new
data space. 

When you're defining a collection of data spaces, be sure that their names are distinct.
Defining two data spaces with the same name is an error. Data space names follow the
rules for stream names. That is, they must be less than 260 characters long, and may
not contain the characters '/'. '\', '|', ':', or any character less than 0x0020.

Data spaces are kept in a separate name space. So you don't have to worry about
colliding with a stream name or a storage name. As noted above, we have defined one
special data space ("Default_Space") where all data resides if you take no action.

You can redefine that default space simply by creating a new data space with the
name "Default_Space". This is the one case where a name collision is allowed. If 
you do redefine the default data space, any data in the old space will automatically
be transformed appropriately and moved into the new default data space.  

**   Importing Items

If you have defined additional data spaces, the next step is to define which streams
and storages you want to move into the new data spaces. You do that by means of the 
IDataSpace::Import function. For example suppose you've defined the dataspace 
*pMyDataSpace and you want to import the stream "Alpha" contained in the storage 
*pThatStorage:

    pMyDataSpace->Import(pThatStorage, "Alpha");

Similarly if you want to import the storage "HTML_Pages" from pThisStorage:

    pMyDataSpace->Import(pThisStorage, "HTML_Pages");

That will recursively import the "HTML_Pages" storage and all of the streams and 
storages contained within it. It also conditions those storages so that anything
you create within them will be automatically imported into pMyDataSpace. Note that
subsequent Import operations may alter that conditioning.

If you later decide that you want to move "Alpha" back into the default data
space:

    hr = pDataSpaceManager->OpenDataSpace(L"Default_Space", &pDefaultDataSpace);

    pDefaultDataSpace->Import(pThatStorage, "Alpha");

**  Data Space Transform Sets 

When you define a data space, you must specify a set of transforms to apply to 
the items you import into the space. A transform is an interface that converts
data to some other representation. For example the LZX transform converts your 
imported data into a more compact, compressed representation. Other transforms
might implement word or phrase based dictionary compression, or they might encipher 
your data, or they might just convert from one data format to another. You could, 
for example, construct a transform to store HTML data as a Rich Text stream.

When you define a data space with more than one transform, they are applied in 
order. For example let's suppose that your transform set consists of these three:

  1. A Dictionary compression transform

  2. The LXZ transform

  3. An data encryption transform

Whenever you write data into this space, it will first be compressed using the
dictionary compression methods, then LZX compression will be applied, and finally
your information will be encrypted. When you read data the process is reversed so
that the encryption transform supplies data to the LZX transform which in turn 
provides data for the dictionary compression transform.

You define the transform set via a vector of class ids (paclsidXform). Each class id
defines a location where an implementation of IID_Transform can be found. In addition
you'll supply corresponding control data for each transform (papxfcd). The number of 
transforms is defined by the cXforms parameter.

Note that it is legal to define a space with zero transforms. This is useful when
you've got items which are already compressed and which won't benefit from an
additional layer of compression overhead.

The control data for a transform defines how it will operate in a particular
data space. For example the control data for the LZX transform defines how
aggressively it will pursue compression, and it controls the tradeoff between
random access performance and the level of compression.

The actual structure and content of the control data is documented above.
(See the LZX_Control_Data data type.)

**  Transform Factories -- How they are organized; What they do

Transforms have two functional capabilities. They can return default
control data (DefaultControlData), and they can create
transform instances (CreateTransformInstance). When the ITSS code calls your 
CreateTransformInstance function, it will supply a storage medium (pXFSpan_Base)
where transformed data is to be stored along with the control data for the
instance and several other useful pieces of information. 

The CreateTransformInstance function has several parameters that you can use 
when you need to access global and/or instance data streams. They also support
the construction of encryption transforms. You can ignore those parameters if your
transform doesn't do encryption, uses only a single pass over the data, and doesn't
rely on any data beyond the data in the stream being transformed.

  -- The rclsidXForm and pwszDataSpace parameters, respectively, tell you the Class ID
  by which your code was located, and the name of the data space in which your instance
  will be working. These values are used with the ITransformServices interface.

  -- The pXformServices parameter points to an instance of the ITranformServices interface. 
  That interface gives you access to a couple of storages where you can keep global and
  instance data for your transform. It also gives you a way to contruct a temporary
  stream that is automatically deleted when you release it. That's very handy when 
  you get a seek operation into the middle of the transformed data followed by a write 
  operation.

  If you're implementing a multipass strategy, you can get access to those storages
  from code outside the transform by doing a QueryInterface from any ITS storage for 
  the interface IID_ITransformServices. You identify the storage in question by the
  transform's class id and possibly the name of the data space instance. 

  The per-transform-instance storage is also a convenient place to put the navigation
  data necessary to support fast seek operations.

  -- The pKeyManager parameter is an interface pointer used with encryption transforms.
  It supplies the read and write keys to use with your encryption transform. Those keys
  are set by the SetKeys interface of the ITransformServices interface. This allows you
  to separate your user interface code where people will enter passwords from the 
  transform implementations. This can be useful when you want the same keys to be used 
  for several different data spaces.  

**  Transform Instances -- How they are organized; What they do

A Transform Instance is an object which simulates a data medium which can be 
suballocated. Suballocated items are managed as data spans (ITransformedSpan).
You must supply a function to create a data span (CreateTransformedSpan), and
a function to open a data span (OpenTransformedSpan). Both of those functions 
return an ITransformedSpan interface when they succeed. In addition you must
supply the function SpaceSize to return the size of the entire untransformed
data image. That is, SpaceSize returns the highest limit offset (offset + size)
of any data span created within the instance. 

A span is identified by an ImageSpan structure which defines an offset and a size 
for the span. Both values are defined in untransformed space. For the Create function
this is an output parameter, while it is an input parameter for the Open function.
Note the interaction between the ImageSpan and the WriteAt member function of the
ITransformedSpan interface.

**  Transformed Data Spans -- How they are organized; What they do

A transformed Data Span (ITransformedSpan) has two member functions -- ReadAt and 
WriteAt. Those functions are very similar to the ReadAt and WriteAt functions of
the ILockBytes interface. The difference is that WriteAt includes an extra output
parameter (pImageSpan) for recording the current span parameters. The ReadAt function
doesn't include that parameter because read operations can never change the span's
size or move it to a different offset.

**  Implementation Strategies

This section describes a few scenarios that you may encounter as you construct a 
transform along with strategies for those situations. This is an open ended list 
which will expand as we gain more experience with transforms.

Many compression and encryption transforms are designed around sequential I/O. That is,
they expect to get the raw data from a sequence of write opeations with no intervening
seek operations. In many cases such transforms also write out the transformed data to 
the base stream in ascending order. Similarly they expect read requests to come to them
with no intervening seek operations. 

The key issue for those transforms is how do you implement random access and interleaved
read, write, and seek operations. 

Leaving aside write operations for the moment, let's consider a random sequence of reads
interleaved with seek operations. One solution might be to construct a table to map from
raw data offsets to transformed data offsets. You can store such a table in the instance
storage for the current data space. 

One complication is that many compression transforms use the raw data as a dictionary. 
That is, you can only start reading from the beginning of the transformed data. You can
deal with those transforms telling them to reset themselves periodically. That gives
you a collection of starting points spread fairly evenly throught the transformed 
data. When you do this you'll need to supply a control data parameter to control the
frequency of those reset points so that your clients can make an appropriate tradeoff
between compression efficiency and random access performance.

Now what about adding random write operations to the mix? The short answer here is that
you can't do this in the middle of transformed data. One strategy would be to reconstruct
the entire raw data into a temporary stream and do all your I/O to that stream until
release time. Then at release time you can transform the revised data sequentially.

A variation on that strategy is to keep track of which reset spans are modified and 
write the modified versions of those transformed spans to the end of the base stream.
This leaves a certain amount of dead space in your transformed data, but it allows
you to defer the sequential reconstruction work to a more convenient time. The down 
side  is that it requires you to manage yet more navigation data in the instance 
storage for the data space.

 */

interface IDataSpaceManager;
interface IDataSpace;
interface ITransformServices;
interface IKeyInstance;
interface ITransformFactory;
interface ITransformInstance;

typedef struct _XformControlData
{
    UINT  cdwControlData;    // Size of this structure in DWords
    UINT  adwControlData[0]; // Actually this will be UINT adwData[cdwData];

} XformControlData, *PXformControlData;

/*
// {7C01FD0F-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpaceManager : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE CreateDataSpace
        (const WCHAR *pwszDataSpace, UINT cXforms,
         const CLSID *paclsidXform, PXformControlData paxfcd,
         IDataSpace *pITDataSpace
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE OpenDataSpace
        (const WCHAR *pwszDataSpace, 
         IDataSpace *pITDataSpace
        ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE DiscardDataSpace
        (const WCHAR *pwszDataSpace) = 0;

    virtual HRESULT STDMETHODCALLTYPE EnumDataSpaces
        (IEnumSTATSTG ** ppenum) = 0;
};


/*
// {7C01FD0E-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpace : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetTransformInfo
        (PUINT pcXforms, PUINT pcdwXformControlData, 
         CLSID *paclsid, PXformControlData pxfcd
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Import
        (IStorage *pStg, const WCHAR * pwszElementName) = 0;

    virtual HRESULT STDMETHODCALLTYPE ImportSpace(IStorage **ppStg) = 0;
};

/*
// {7C01FD0C-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformFactory : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE DefaultControlData
        (XformControlData **ppXFCD) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTransformInstance
        (ITransformInstance *pXFormMedium,        // Container data span for transformed data
		 ULARGE_INTEGER      cbUntransformedSize, // Untransformed size of data
         PXformControlData   pXFCD,               // Control data for this instance
         const CLSID        *rclsidXForm,         // Transform Class ID
         const WCHAR        *pwszDataSpaceName,   // Data space name for this instance
         ITransformServices *pXformServices,      // Utility routines
         IKeyInstance       *pKeyManager,         // Interface to get enciphering keys
         ITransformInstance **ppTransformInstance // Out: Instance transform interface
        ) = 0;
};

typedef struct _ImageSpan
{
	ULARGE_INTEGER	uliHandle;
	ULARGE_INTEGER  uliSize;

} ImageSpan;

/*
// {EB19B67E-9360-11d0-9E16-00A0C922E6EC}
DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformInstance : public IUnknown
{
public:

	virtual HRESULT STDMETHODCALLTYPE ReadAt 
	                    (ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead,
						 ImageSpan *pSpan
                        ) = 0;

	virtual HRESULT STDMETHODCALLTYPE WriteAt
	                    (ULARGE_INTEGER ulOffset, const void *pv, ULONG cb, ULONG *pcbWritten, 
						 ImageSpan *pSpan
                        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Flush() = 0;

	virtual HRESULT STDMETHODCALLTYPE SpaceSize(ULARGE_INTEGER *puliSize) = 0;

	// Note: SpaceSize returns the high water mark for the space. That is, the largest
	//       limit value (uliOffset + uliSize) for any transformed lockbytes created within
	//       the base (*pXLKB).
};

/*
// {A55895FC-89E1-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformServices : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE PerTransformStorage
        (REFCLSID rclsidXForm, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE PerTransformInstanceStorage
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetKeys
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, 
         PBYTE pbReadKey,  UINT cbReadKey, 
         PBYTE pbWriteKey, UINT cbWriteKey
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTemporaryStream(IStream **ppStrm) = 0;
};

/*
// {96AF35CE-88EC-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IKeyInstance : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetKeys
        (PBYTE *pbReadKey,  PUINT pcbReadKey,
         PBYTE *pbWriteKey, PUINT pcbWriteKey
        ) = 0;
};

#endif // __MSITSTG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\verstamp.h ===
#ifndef __VERSTAMP_H__
#define __VERSTAMP_H__

#include <verinfo.h>

// Version stamp macros: stamp has format __VERSION_#### = "VVVVVVVVV"
// where #### is the four letter lib ID and VVVVVVVV is the version string
	
#define GLUESTRING(type, id, lib) type ## id ## lib

#if defined(_SLIB)
#define SETVERSIONSTAMP(x) GLUESTRING(extern char const *, __VERSION_, x) = VERSIONSTR;
#else
#define SETVERSIONSTAMP(x)
#endif


#endif // !__VERSTAMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\wrapstor.h ===
/*****************************************************************************
*                                                                            *
*  WRAPSTOR.H                                                                *
*                                                                            *
*  Copyright (C) Microsoft Corporation 1990 - 1994.                          *
*  All Rights reserved.                                                      *
*                                                                            *
******************************************************************************
*                                                                            *
*  Module intent                                                             *
*                                                                            *
*                                                                            *
*                                                                            *
******************************************************************************
*                                                                            *
*  Current Owner:  BINHN                                                     *
*                                                                            *
*****************************************************************************/

#ifndef __WRAPSTOR_H__
#define __WRAPSTOR_H__

#ifdef __cplusplus
#include <itsort.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

#pragma pack(1)		// avoid problems when Zp!=1

// requires windows.h, mvopsys.h, misc.h, orkin.h
#include <fileoff.h>

//typedef USHORT RC;        // for those not coming via HELP.H

typedef VOID FAR *    QV;    // this is also in misc.h


// Lone function from iofts.c that wasn't prototyped anywhere
LPCSTR NEAR PASCAL GetSubFilename(LPCSTR lszFilename, BYTE* lszTemp);
							 

/*****************************************************************************
*
*       File Moniker
*
*****************************************************************************/

#define fmNil ((FM)0)
#define qafmNil ((QAFM)0)

/*
    When creating an FM (in other WORDs, specifying the location of a new
    or extant file), the caller must specify the directory in which that file
    is located.  There are a finite number of directories available to Help.
    These are:
*/

#define dirNil      0x0000  // No directory specified
#define dirCurrent  0x0001  // Whatever the OS thinks the current dir. is
#define dirTemp     0x0002  // The directory temporary files are created in
#define dirHelp     0x0004  // Wherever the Help Application lives
#define dirSystem   0x0008  // The Windows and Windows System directories
#define dirPath     0x0010  // Searches the $PATH
			    // (includes Current dir and System dirs)
#define dirAll      0xFFFF  // Search all directories, in the above order
#define dirFirst    dirCurrent  // The lowest bit that can be set
#define dirLast     dirPath  // The highest bit that can be set

/*
    To specify which parts of a full filename you want to extract, add
    (logical or) the following part codes:
*/

#define partNone    0x0000  // return nothing
#define partDrive   0x0001  // D:        Vol
#define partDir     0x0002  //   dir\dir\    :dir:dir:
#define partBase    0x0004  //        basename    filename
#define partExt     0x0008  //                 ext      <usu. nothing>
#define partAll     0xFFFF

// Get from stdlib.h
#if !defined(_M_MPPC) && !defined(_M_M68K)
#define _MAX_PATH   260 /* max. length of full pathname */
#else   /* ndef defined(_M_M68K) || defined(_M_MPPC) */
#define _MAX_PATH   256 /* max. length of full pathname */
#endif  /* defined(_M_M68K) || defined(_M_MPPC) */

/*
   max. string lengths of file names
*/
#define cchMaxPath      _MAX_PATH // = _MAX_PATH in <stdlib.h>

#ifdef __cplusplus
typedef IStorage*  HFS;
typedef IStream*   HF;
#else // __cplusplus
typedef PVOID  HFS;
typedef PVOID   HF;
#endif // __cplusplus

/*
    An FM is a magic cookie which refers to some structure describing the
    location of a file, including the volume/drive, path, and filename.
*/

typedef struct {
  char rgch[cchMaxPath];  // Fully canonicalized pathname
} AFM;                          // RAllocation of FMS
typedef AFM FAR *QAFM;

typedef LPSTR FM;         // An FM is now just a string, allocated through
						  // the NewMemory()/DisposeMemory() API
typedef USHORT DIR;       // Help directory flag


#define FValidFm(fm)    ((fm)!=fmNil)

/*** MATTSMI 2/5/92 -- ADDED FROM DOS VERSION OF THIS HEADER TO SUPPORT WMVC ***/

#define VerifyFm(fm) 	// assert(fm == fmNil || FCheckGh((HANDLE) fm))
						// VerifyFm(fm) not needed for FM being LPSTR

FM      EXPORT_API FAR PASCAL    FmNewSzDir (LPSTR, DIR, LPVOID);
FM      EXPORT_API PASCAL FAR    FmNew(LPSTR, LPVOID);
FM      EXPORT_API FAR PASCAL    FmNewExistSzDir (LPSTR, DIR, LPVOID);
FM      EXPORT_API FAR PASCAL    FmNewExistSzIni (LPSTR, LPSTR, LPSTR, LPVOID);
FM      EXPORT_API FAR PASCAL    FmNewTemp (LPSTR, LPVOID);
FM      EXPORT_API FAR PASCAL    FmNewSameDirFmSz (FM, LPSTR, LPVOID);
VOID    EXPORT_API FAR PASCAL    DisposeFm (FM);
FM      EXPORT_API FAR PASCAL    FmCopyFm(FM, LPVOID);
BOOL    EXPORT_API FAR PASCAL    FExistFm(FM);
int     EXPORT_API FAR PASCAL    CbPartsFm(FM, int);
LPSTR   EXPORT_API FAR PASCAL    SzPartsFm(FM, LPSTR, int, int);
BOOL    EXPORT_API FAR PASCAL    FSameFmFm (FM, FM);



/*****************************************************************************
*
*       FIDs - file access (fid.c)
*
*****************************************************************************/

#define wRead       0x0001
#define wWrite      0x0002
#define wReadOnly   wRead
#define wReadWrite  (wRead | wWrite)
#define wRWMask     (wRead | wWrite)

#define wShareRead  0x0004
#define wShareWrite 0x0008
#define wShareAll   (wShareRead | wShareWrite)
#define wShareNone  0x000
#define wShareMask  (wShareRead | wShareWrite)
#define wShareShift 2

#define wSeekSet  0   /* SEEK_SET from stdio.h */
#define wSeekCur  1   /* SEEK_CUR from stdio.h */
#define wSeekEnd  2   /* SEEK_END from stdio.h */

#ifdef _WIN32
typedef HANDLE	FID;
#define fidNil  INVALID_HANDLE_VALUE
#else
typedef HFILE   FID;
#define fidNil  HFILE_ERROR
#endif


FID  EXPORT_API FAR PASCAL FidCreateFm(FM fm, WORD wOpenMode, WORD wPerm,
    LPVOID);
FID  EXPORT_API FAR PASCAL FidOpenFm(FM fm, WORD wOpenMode,
    LPVOID);
BOOL EXPORT_API FAR PASCAL FidFlush(FID fid);

#define FUnlinkFm(fm)   ((BOOL)(RcUnlinkFm(fm)==ERR_SUCCESS))
RC   EXPORT_API FAR PASCAL RcUnlinkFm(FM);

LONG EXPORT_API FAR PASCAL LcbReadFid(FID, LPVOID, LONG, LPVOID);

#define FCloseFid(fid)    ((BOOL)(RcCloseFid((int)fid) == ERR_SUCCESS))
RC   EXPORT_API FAR PASCAL RcCloseFid(FID);

LONG EXPORT_API FAR PASCAL LcbWriteFid(FID, LPVOID, LONG, LPVOID);
LONG EXPORT_API FAR PASCAL LTellFid(FID, LPVOID);
LONG EXPORT_API FAR PASCAL LSeekFid(FID, LONG, WORD, LPVOID);
FILEOFFSET EXPORT_API FAR PASCAL FoSeekFid(FID, FILEOFFSET, WORD, LPERRB);
int EXPORT_API PASCAL FAR FEofFid(FID);

#define FChSizeFid(fid, lcb)  (RcChSizeFid ((fid), (lcb)) == 0)
RC EXPORT_API PASCAL FAR RcChSizeFid(FID, LONG);
BOOL EXPORT_API PASCAL FAR  FDriveOk(LPSTR);

/*****************************************************************************
*
*       BTREE api
*
*****************************************************************************/

#define bBtreeVersionBonehead 0     /* fixed size key, array */


#define wBtreeMagic         0x293B  /* magic number for btrees; a winky: ;) */

#define bBtreeVersion       4       /* ver 2: back to strcmp for 'z' keys */
									/* ver 3: skipped
									/* ver 4: BTHESI header info, KT_EXTSORT */


#define bkNil               ((BK)-1)/* nil value for BK */


#define wMaxFormat          15      /* length of format string */


#define cbBtreeBlockDefault 8192    /* default btree block size */

#define fFSDirty          (BYTE)0x08  // file (FS) is dirty and needs writing



/* key types */


#define KT_SZI          'i'
#define KT_SZDELMIN     'k' /* not supported */
#define KT_SZMIN        'm' /* not supported */
#define KT_SZDEL        'r' /* not supported */
#define KT_ST           't' /* not supported */
#define KT_SZ           'z'

#define KT_VSTI			'V' // variable-byte prefixed Pascal string
#define KT_STI          'I'
#define KT_STDELMIN     'K' /* not supported */
#define KT_LONG         'L'
#define KT_STMIN        'M' /* not supported */
#define KT_STDEL        'R' /* not supported */
#define KT_SZISCAND     'S'
#define KT_SZMAP        'P'
#define KT_EXTSORT		'X' // keys are understood by an external sort object

#define FBtreeKeyTypeIsSz(c)  ((c) == KT_SZ || (c) == KT_SZMAP || (c) == KT_SZI || \
			    (c) == KT_SZISCAND)

/*
  Btree record formats

  In addition to these #defines, '1'..'9', 'a'..'f' for fixed length
  keys & records of 1..15 bytes are accepted.
*/

#define FMT_VNUM_FO 'O'			// Variable byte offset or length
#define FMT_BYTE_PREFIX 't'
#define FMT_WORD_PREFIX 'T'
#define FMT_SZ          'z'
			

#define FBtreeRecordTypeIsSz(c)     ((c) == FMT_SZ)

/* elevator constants */


#define btelevMax ((BT_ELEV)32767)
#define btelevNil ((BT_ELEV)-1)

typedef LONG_PTR  KEY;        /* btree key */
typedef BYTE      KT;         /* key type */


typedef HANDLE        HBT;        /* handle to a btree */
typedef HANDLE        HMAPBT;     /* handle to a btree map */

// @DOC INTERNAL
// @struct BTREE_PARAMS | Btree parameters passed in for creation
typedef struct _btree_params
  {
  HFS   hfs;          		// @field File system that btree lives in
  int   cbBlock;      		// @field Number of bytes in a btree block.  
  							// Key or Data cannot exceed 1/2 this amount.

	// Members used in conjunction with KT_EXTSORT - btree file version 4.0.
  DWORD	dwCodePageID;		// @field ANSI code page no.
  LCID	lcid;				// @field WIN32 locale ID.
  DWORD	dwExtSortInstID;	// @field External sort instance ID
  DWORD	dwExtSortKeyType;	// @field External sort key type

  BYTE bFlags;       		// @field HFOPEN_ flags (same as used in opening an hFile).
  char rgchFormat[wMaxFormat+1]; // @field Key and record format string.
  } BTREE_PARAMS;


typedef DWORD    BK;   // btree block index   - extended to DWORD, davej 12/95

// @DOC INTERNAL
// @struct BTPOS | Btree position structure.
typedef struct
  {
  BK  bk;     // @field Block number.
  int cKey;   // @field Which key in block (0 means first).
  int iKey;   // @field Key's index db.rgbBlock (in bytes).
  } BTPOS, FAR *QBTPOS;


typedef int BTELEV, FAR *QBTELEV; /* elevator location: 0 .. 32767 legal */

HBT     EXPORT_API FAR PASCAL  HbtCreateBtreeSz(LPSTR, BTREE_PARAMS FAR *,
												PHRESULT);
RC      EXPORT_API FAR PASCAL  RcDestroyBtreeSz(LPSTR, HFS);

HBT     EXPORT_API FAR PASCAL  HbtOpenBtreeSz  (LPWSTR, HFS, BYTE, PHRESULT);
VOID	EXPORT_API FAR PASCAL  GetBtreeParams(HBT, BTREE_PARAMS FAR *);
RC      EXPORT_API FAR PASCAL  RcCloseBtreeHbt (HBT);
RC      EXPORT_API FAR PASCAL  RcAbandonHbt    (HBT);
#if defined(_DEBUG)
VOID    EXPORT_API FAR PASCAL VerifyHbt       (HBT);
#else
#define VerifyHbt(hbt)
#endif //!def _DEBUG


RC      EXPORT_API FAR PASCAL  RcLookupByPos   (HBT, QBTPOS, KEY, int, LPVOID);
RC      EXPORT_API FAR PASCAL  RcLookupByKeyAux(HBT, KEY, QBTPOS, LPVOID, BOOL);

WORD    EXPORT_API FAR PASCAL  wGetNextNEntries(HBT, WORD wFlags, WORD wEntries, QBTPOS, LPVOID, LONG, LPERRB);
// Flags for wGetNextNEntries
#define GETNEXT_KEYS	1
#define GETNEXT_RECS	2
#define GETNEXT_RESET	4

#define     RcLookupByKey(   hbt, key, qbtpos, qv) \
  RcLookupByKeyAux((hbt), (key), (qbtpos), (qv), FALSE)

RC      EXPORT_API FAR PASCAL  RcFirstHbt      (HBT, KEY, LPVOID, QBTPOS);
RC      EXPORT_API FAR PASCAL  RcLastHbt       (HBT, KEY, LPVOID, QBTPOS);
RC      EXPORT_API FAR PASCAL  RcNextPos       (HBT, QBTPOS, QBTPOS);
RC      EXPORT_API FAR PASCAL  RcOffsetPos     (HBT, QBTPOS, LONG, LPLONG, QBTPOS);

#if defined(__DEBUG)
#define     FValidPos(qbtpos) \
  ((qbtpos) == NULL ? FALSE : (qbtpos)->bk != bkNil)
#else /* !_DEBUG */

#define     FValidPos(qbtpos) ((qbtpos)->bk != bkNil)
#endif /* !_DEBUG */

// Callback passed to RcTraverseHbt
typedef DWORD (FAR PASCAL *TRAVERSE_FUNC) (KEY key, BYTE FAR *rec, DWORD dwUser);
#define TRAVERSE_DONE 		0
#define TRAVERSE_DELETE 	1
#define TRAVERSE_INTERRUPT	2

RC      EXPORT_API FAR PASCAL  RcInsertHbt     (HBT, KEY, LPVOID);
RC 		EXPORT_API FAR PASCAL  RcInsertMacBrsHbt(HBT, KEY, QV);
RC      EXPORT_API FAR PASCAL  RcDeleteHbt     (HBT, KEY);
RC      EXPORT_API FAR PASCAL  RcUpdateHbt     (HBT, KEY, LPVOID);
RC 		EXPORT_API FAR PASCAL  RcTraverseHbt   (HBT, TRAVERSE_FUNC, DWORD);

RC      EXPORT_API FAR PASCAL  RcPackHbt       (HBT);            /* >>>> unimplemented */
RC      EXPORT_API FAR PASCAL  RcCheckHbt      (HBT);            /* >>>> unimplemented */
RC      EXPORT_API FAR PASCAL  RcLeafBlockHbt  (HBT, KEY, LPVOID);   /* >>>> unimplemented */

HBT     EXPORT_API FAR PASCAL  HbtInitFill     (LPSTR, BTREE_PARAMS FAR *,
    LPVOID);
RC      EXPORT_API FAR PASCAL  RcFillHbt       (HBT, KEY, LPVOID);
RC      EXPORT_API FAR PASCAL  RcFiniFillHbt   (HBT);

RC      EXPORT_API FAR PASCAL   RcFreeCacheHbt  (HBT);
RC      EXPORT_API FAR PASCAL   RcFlushHbt      (HBT);
RC      EXPORT_API FAR PASCAL   RcCloseOrFlushHbt(HBT, BOOL);

RC      EXPORT_API FAR PASCAL   RcPos2Elev(HBT, QBTPOS, QBTELEV); /* >>>> unimplemented */
RC      FAR PASCAL   RcElev2Pos(HBT, QBTELEV, QBTPOS); /* >>>> unimplemented */

RC    EXPORT_API FAR PASCAL RcGetBtreeInfo(HBT, LPBYTE, LPLONG, LPWORD);
HF    EXPORT_API PASCAL FAR HfOpenDiskBt(HFS, HBT, LPSTR, BYTE, LPVOID);

/*  Map utility functions  */

RC      EXPORT_API FAR PASCAL RcCreateBTMapHfs(HFS, HBT, LPSTR);
HMAPBT  EXPORT_API FAR PASCAL HmapbtOpenHfs(HFS, LPWSTR, LPVOID);
RC      EXPORT_API FAR PASCAL RcCloseHmapbt(HMAPBT);
RC      EXPORT_API FAR PASCAL RcIndexFromKeyHbt(HBT, HMAPBT, LPLONG, KEY);
RC      EXPORT_API FAR PASCAL RcKeyFromIndexHbt(HBT, HMAPBT, KEY, int, LONG);
BOOL    EXPORT_API FAR PASCAL FIsPrefix(HBT, KEY, KEY);
VOID    EXPORT_API FAR PASCAL BtreeSetCMap(HBT, LPVOID);
LPVOID  EXPORT_API PASCAL FAR BtreeGetCMap(HANDLE);

#ifdef __cplusplus
VOID    EXPORT_API FAR PASCAL BtreeSetExtSort(HBT, IITSortKey*);
VOID	EXPORT_API PASCAL FAR BtreeGetExtSort(HBT, IITSortKey**);
#else
// Hack to get .c files to compile.
VOID    EXPORT_API FAR PASCAL BtreeSetExtSort(HBT, LPVOID);
VOID	EXPORT_API PASCAL FAR BtreeGetExtSort(HBT, LPVOID*);
#endif



/*****************************************************************************
*
*       FS - file system (subfile.c, filesys.c)
*
*****************************************************************************/

/* FS magic number */
#define wFileSysMagic   0x5F3F        // ?_ - the help icon (with shadow)

//#define bFileSysVersion 2           // sorted free list
/* Current FS version */
#define bFileSysVersionOld (BYTE)3       // different sorting functions
#define bFileSysVersion    (BYTE)0x04	 // M20 format quite different from M14

/* flags for FlushHfs */
#define fFSCloseFile      (BYTE)0x01  // close fid associated with the FS
#define fFSFreeBtreeCache (BYTE)0x02  // free the btree's cache

/* seek origins */

#define wFSSeekSet        0           // seek relative to start of file
#define wFSSeekCur        1           // seek relative to current position
#define wFSSeekEnd        2           // seek relative to end of file

#define FSH_READWRITE		(BYTE)0x01
#define FSH_READONLY		(BYTE)0x02
#define FSH_CREATE			(BYTE)0x04
#define FSH_M14				(BYTE)0x08	// Not used really, since we return
										// an error if reading M14 to force
										// caller to use M14 APIs instead (we
										// could make this transparent to 
										// user?)
#define FSH_FASTUPDATE		(BYTE)0x10	// System Btree is not copied to temp file
										// unless absolutely necessary
#define FSH_DISKBTREE		(BYTE)0x20	// System Btree is always copied to disk if
										// possible for speed.  Btree may be very very
										// large, and this is NOT recommended for on-line	

#define HFOPEN_READWRITE		(BYTE)0x01
#define HFOPEN_READ				(BYTE)0x02
#define HFOPEN_CREATE			(BYTE)0x04
#define HFOPEN_SYSTEM			(BYTE)0x08
#define HFOPEN_NOTEMP			(BYTE)0x10	// No temp file in r/w mode
#define HFOPEN_FORCETEMP		(BYTE)0x20  // Temp file created in r mode
#define HFOPEN_ENABLELOGGING	(BYTE)0x40	

#define FACCESS_READWRITE	(BYTE)0x01
#define FACCESS_READ		(BYTE)0x02
#define FACCESS_EXISTS		(BYTE)0x04
#define FACCESS_LIVESINFS	(BYTE)0x08
#define FACCESS_LIVESINTEMP (BYTE)0x10

#define SFH_LOCKED			(BYTE)0x01	// File may not be written to or deleted
#define SFH_EXTRABYTES		(BYTE)0x02	// (not used yet) Should use if extra bytes appear in header of file
										// file header should contain the number of header bytes as the first byte.
#define SFH_COMPRESSED		(BYTE)0x04	// (not used yet).  Perhaps use to indicate an overall file compression
#define SFH_LOGGING			(BYTE)0x08
#define SFH_INVALID			(BYTE)0x80  // This is the value if file does not
										// really exist in fs  yet.
// These are the flags that users can manipulate
#define SFH_FILEFLAGS (SFH_LOGGING|SFH_LOCKED)

// Compatibility
//#define fFSReadOnly       (BYTE)0x01  // file (FS) is readonly
//#define fFSOpenReadOnly   (BYTE)0x02  // file (FS) is opened in readonly mode
//#define fFSReadWrite      (BYTE)0x00  // file (FS) is readwrite
//#define fFSOpenReadWrite  (BYTE)0x00  // file (FS) is opened in read/write mode
//#define fFSOptCdRom       (BYTE)0x20  // align file optimally for CDROM
//#define fFSNoFlushDir     (BYTE)0x40  // don't flush directory when closing 
#define fFSReadOnly       HFOPEN_READ  // file (FS) is readonly
#define fFSOpenReadOnly   HFOPEN_READ  // file (FS) is opened in readonly mode
#define fFSReadWrite      HFOPEN_READWRITE  // file (FS) is readwrite
#define fFSOpenReadWrite  HFOPEN_READWRITE  // file (FS) is opened in read/write mode
#define fFSOptCdRom       0x00  // align file optimally for CDROM
#define fFSNoFlushDir     0x00  // don't flush directory when closing 

typedef HANDLE HSFB;		// Handle to a SFB
typedef BOOL (FAR PASCAL * PROGFUNC)(WORD);

#define hfNil NULL

// @DOC INTERNAL API
// @struct FS_PARAMS | File system parameters to be passed in to 
//	<f HfsCreateFileSysFm>.  Only the <p cbBlock> parameter is used right now.
typedef struct _fs_params
  {
  USHORT  wFreeListSize;  // @field Free List Entries (0=default, else max entries in free list)
  USHORT  cbBlock;  // @field Size of directory btree block.  Usually 1024 to 8192.
} FS_PARAMS;

typedef struct fsfilefind_tag
{
 	FILEOFFSET foSize;
	FILEOFFSET foStart;
	BYTE bFlags;
	char szFilename[256];
	int magic;
 	BTPOS btpos;
	HFS hfs;
} FSFILEFIND, FAR * LPFSFILEFIND;


VOID    EXPORT_API FAR PASCAL      CleanErrorList   (BOOL);
VOID 	EXPORT_API FAR PASCAL	   MVFSShutDown     (void);

/* File System Operations */

HFS		PASCAL FAR EXPORT_API HfsCreateFileSysFm( FM, FS_PARAMS FAR *, LPERRB );
RC		PASCAL FAR EXPORT_API RcDestroyFileSysFm( FM );
HFS		PASCAL FAR EXPORT_API HfsOpenFm( FM, BYTE, LPERRB );
RC		PASCAL FAR EXPORT_API RcCloseHfs( HFS );
RC		PASCAL FAR EXPORT_API RcFlushHfs( HFS );
BOOL 	PASCAL FAR EXPORT_API FHfsAccess(HFS hfs, BYTE bFlags);
RC 		PASCAL FAR EXPORT_API RcFindFirstFile(HFS hfs, LPCSTR szFilename, FSFILEFIND * pfind);
RC 		PASCAL FAR EXPORT_API RcFindNextFile(FSFILEFIND * pfind);

#define VerifyHfs(hfs)


/* File Operations */

HF		PASCAL FAR EXPORT_API HfCreateFileHfs( HFS, LPCSTR, BYTE, LPERRB );
RC		PASCAL FAR EXPORT_API RcUnlinkFileHfs( HFS, LPCSTR );
HF		PASCAL FAR EXPORT_API HfOpenHfs( HFS, LPCWSTR, BYTE, LPERRB );
HF		PASCAL FAR EXPORT_API HfOpenHfsReserve( HFS, LPCSTR, BYTE, FILEOFFSET, LPERRB );
RC		PASCAL FAR EXPORT_API RcFlushHf( HF );
RC		PASCAL FAR EXPORT_API RcCloseHf( HF );
LONG	PASCAL FAR EXPORT_API LcbReadHf( HF, LPVOID, LONG, LPERRB );
LONG	PASCAL FAR EXPORT_API LcbWriteHf( HF, LPVOID, LONG, LPERRB );
BOOL	PASCAL FAR EXPORT_API FEofHf( HF, LPERRB );
BOOL	PASCAL FAR EXPORT_API FChSizeHf( HF, FILEOFFSET, LPERRB );
BOOL	PASCAL FAR EXPORT_API FAccessHfs( HFS, LPCSTR, BYTE, LPERRB );
RC		PASCAL FAR EXPORT_API RcAbandonHf( HF );
RC		PASCAL FAR EXPORT_API RcRenameFileHfs( HFS, LPCSTR, LPCSTR );
BYTE 	PASCAL FAR EXPORT_API GetFileFlags(HFS, LPCSTR, LPERRB );
RC 		PASCAL FAR EXPORT_API SetFileFlags(HFS, LPCSTR, BYTE );
//BOOL	PASCAL FAR EXPORT_API FHfValid( HF );

HFS		PASCAL FAR EXPORT_API HfsGetFromHf( HF );
RC 		PASCAL FAR EXPORT_API RcCopyDosFileHfs(HFS, LPCSTR, LPCSTR, BYTE, PROGFUNC );
FILEOFFSET PASCAL FAR EXPORT_API FoTellHf( HF, LPERRB );
FILEOFFSET PASCAL FAR EXPORT_API FoSeekHf(HF, FILEOFFSET, WORD, LPERRB);
FILEOFFSET PASCAL FAR EXPORT_API FoSizeHf( HF, LPERRB );
FILEOFFSET PASCAL FAR EXPORT_API FoOffsetHf(HF hf, LPERRB lperrb);

#define FHfValid(hf)  ((hf) != NULL)
#define VerifyHf(hf)

// These functions require the FID type.  They only make sense
// if the caller already needs H_LLFILE.
//#ifdef H_LLFILE
//RC      EXPORT_API FAR PASCAL  RcLLInfoFromHf     (HF, WORD, FID FAR *, LPLONG, LPLONG);
//RC      EXPORT_API FAR PASCAL  RcLLInfoFromHfsSz  (HFS, LPSTR, WORD, FID FAR *, LPLONG, LPLONG);
//#endif // H_LLFILE

/*****************************************************************************
*
*       MediaView File Handling
*
*****************************************************************************/
BOOL EXPORT_API FAR PASCAL LooseFileCompare(LPSTR, LPSTR);
FM EXPORT_API FAR PASCAL LocateFile(LPSTR, LPVOID);
HANDLE EXPORT_API FAR PASCAL LocateDLL(LPSTR, LPVOID);

RC EXPORT_API FAR PASCAL CopyOrReplaceFileToSubfile(HFS, LPSTR, LPSTR, LONG, BYTE, PROGFUNC, BOOL);

// New functionality
FM EXPORT_API FAR PASCAL FmFromHfs(HFS hfs);
							 

#pragma pack()		// avoid problems when Zp!=1

#ifdef __cplusplus
}
#endif

#endif // __WRAPSTOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\wwheel.h ===
/************************************************************************
*
* WWHEEL.H
*
* Copyright (c) Microsoft Corporation 1993
* All rights reserved.
*
*************************************************************************
*
*   The WordWheel API
*
*
************************************************************************/

#ifndef __WWHEEL_H_
#define __WWHEEL_H_

#include <mvopsys.h>
//#include <itww.h>
#include <itgroup.h>
#include "common.h"
#include <wrapstor.h>
#include <orkin.h>

#ifdef __cplusplus
extern "C" {
#endif


/*****************************************************************************
*
*       error handling defines
*
*       many routines are structured to have a single exit point labelled
*       "cleanup".  The following defines are a procedure-level "break"
*       that force execution to drop down to cleanup.
*
*****************************************************************************/
#ifdef _DEBUG
#define warning_abort   { DPF("\nwarning, %s, line %u\n", \
						  (LPSTR)s_aszModule, __LINE__); goto cleanup; }
#else
#define warning_abort   { goto cleanup; }
#endif
#define assert_abort    { assert(FALSE); goto cleanup; }




// Typedefs
//

typedef HANDLE HWHEEL;

// Critical structures that gets messed up in /Zp8
#pragma pack(1)

typedef struct tagWHEELINFO
{
	DWORD       magic;          // magic value for verification
	HBT         hbt;            // handle to btree subfile
	HMAPBT      hmapbt;         // handle to map subfile
	long        lNumKws;        // number of keywords in the word wheel.
	LPIDX       lpIndex;        // index for searching.
	HF          hf;             // handle to keyword index subfile
	LPBYTE      pOccHdr;        // Header for occurrence properties
	LPBYTE      pKeyHdr;        // Header for key properties
} WHEELINFO, FAR * PWHEELINFO;

typedef struct 
{
    DWORD        magic;           // magic value for verification
    HANDLE       hMergeData;      // Handle to merge data info if using multiple titles
    DWORD        dwMergeLength;   // Length in bytes of merge data for this wheel combo
    LONG         lNumEntries;     // Total number of 'virtual' (could be filtered) entries (same as lNumKws if one title)
    LPSTR        lpszCacheData;   // Key for cached data following
    HANDLE       hCacheData;      // Results of last KeyIndexGet call
    DWORD        dwCacheNumItems; // Cached number of items from last KeyIndexGet call
    DWORD        wNumWheels;      // Number of titles for merging   
    WHEELINFO    pInfo[1];        // Info for each particular title
    IITGroup*    pIITGroup;         // Group for filtering
    LONG         lNumRealEntries;  // Real number of entries (without filtering).
    LPSIPB       lpsipb;          // Stop word structure for full-text search
} WHEEL, FAR *PWHEEL;

typedef struct
{
	WORD        nTopics;
	DWORD       dwOffset;
} QREC;

// Critical structures that gets messed up in /Zp8
#pragma pack()


// Defines
//
// This must be at least as big as CBMAX_WWTITLE defined in ciextern.h
#define MAXWHEELNAME 80

// magic is "WW!\0"
#define WHEEL_MAGIC 0x00215757
#define WHEEL_INFO_MAGIC 0x00215758
#define PWHEEL_OK(p)    ((p)!=NULL&&(p)->magic==WHEEL_MAGIC)


#define MERGEFILE_HEADERSIZE    1024 
#define MERGEFILE_HEADERALIGN   32
#define MERGEFILE_FILEALIGN     8
#define MERGEFILE_ENTRYSIZE     32

typedef struct mergefile_tag
{   
	HFPB hfpb;
	WORD wNumRecords;
	LONG lctFile;
	LONG lHeaderBlockStart;
	char szHeader[MERGEFILE_HEADERSIZE];    
} MERGEFILE, FAR * LPMERGEFILE;

#if 0

#define MERGEFILE_WW_TRE_EXT ".WWT"
#define MERGEFILE_WW_DAT_EXT ".WWD"
#define MERGEFILE_WW_IDX_EXT ".WWI"
#define MERGEFILE_WW_MAP_EXT ".WWM"
#define MERGEFILE_WW_STP_EXT ".WWS"

#define MERGEFILE_KW_TRE_EXT ".KWT"
#define MERGEFILE_KW_DAT_EXT ".KWD"
#define MERGEFILE_KW_IDX_EXT ".KWI"
#define MERGEFILE_KW_MAP_EXT ".KWM"
#define MERGEFILE_KW_STP_EXT ".STP"

#define WW_BTREE_FILENAME    L"BTREE.WW3"
#define WW_DATA_FILENAME     L"DATA.WW3"
#define WW_MAP_FILENAME      L"MAP.WW3"
#define WW_PROP_FILENAME     L"PROPERTY.WW3"
#define WW_INDEX_FILENAME    L"FTI.WW3"
#define WW_STOP_FILENAME     L"FTISTOP.WW3"

#endif

//  Prototypes 

//ERR FAR PASCAL EXPORT_API WordWheelQuery(HANDLE hWheel, DWORD dwFlags,LPCSTR lpstrQuery,LPVOID lpGroupLimit,LPVOID lpGroupHits);
HWHEEL FAR PASCAL EXPORT_API WordWheelOpen(IITDatabase* lpITDB,
											IStorage* pWWStorage, HRESULT* phr);

void    FAR PASCAL EXPORT_API WordWheelClose(HWHEEL hWheel);
long    FAR PASCAL EXPORT_API WordWheelLength(HWHEEL hWheel, HRESULT* phr);
long    FAR PASCAL EXPORT_API WordWheelPrefix(HWHEEL hWheel,LPCVOID lpcvPrefix, BOOL fExactMatch, HRESULT* phr);
HRESULT  FAR PASCAL EXPORT_API WordWheelLookup(HWHEEL hWheel, long lIndex, LPVOID lpvKeyBuf, DWORD cbKeyBuf);
//ERR     FAR PASCAL EXPORT_API KeyIndexGetAddrs (HWHEEL hWheel, LPBYTE lpKey, int nStart, int nCount, LPBYTE lpAddrs);
//DWORD   FAR PASCAL EXPORT_API KeyIndexGetData (HWHEEL hWheel, LPBYTE lpKey, int nWhich, LPBYTE lpMem, DWORD dwMaxLen, LPERRB lperrb);
//WORD    FAR PASCAL EXPORT_API KeyIndexGetCount (HWHEEL,LPBYTE, LPERRB);
//ERR    FAR PASCAL EXPORT_API WordWheelSetKeyFilter(HWHEEL, LPVOID);
//LPVOID FAR PASCAL EXPORT_API WordWheelGetKeyFilter(HWHEEL, LPERRB);
//ERR FAR PASCAL EXPORT_API WordWheelGetInfo (HWHEEL, PWWINFO);

HRESULT FAR PASCAL CheckWordWheelKeyType(HBT hbt, IITSortKey **ppITSortKey);
DWORD FAR PASCAL CbKeyWordWheel(LPVOID lpvKey, IITSortKey *pITSortKey);


#ifdef __cplusplus
}
#endif

#endif  // __WWHEEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\warning.h ===
// This file is bogus for the Razzle env.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\mvsearch.h ===
/*************************************************************************
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   All typedefs and defines needed for user's retrieval                 *
*                                                                        *
*************************************************************************/

#ifndef __MVSEARCH_H_
#define __MVSEARCH_H_
#ifdef __cplusplus
extern "C" {
#endif

#pragma pack(1) // Guard against Zp problems.

#include <iterror.h>
/*************************************************************************
 *                          Basic defines.
 *************************************************************************/

#ifdef _32BIT
#define EXPORT_API
#define HUGE 

#else
#define EXPORT_API      _export
#define HUGE huge
#endif

#ifdef PRIVATE
#undef PRIVATE
#endif

#define PRIVATE static

#ifdef PUBLIC
#undef PUBLIC
#endif

#define PUBLIC 

#define cbMAX_PATH              (CB)256  // Maximum pathname length.

/* Maximum year's value that can be passed to MediaView's FBreakEpoch() */

#define MAX_YEAR        ((unsigned long)0xFFFFFFFF / 366)

/* Maximum word length that is accepted by MediaView's breaker. */
#define CB_MAX_WORD_LEN ((CB)1000)       // Longest legal word.


/*************************************************************************
 *                          Typedef
 *************************************************************************/

#ifndef LPB
typedef BYTE FAR * LPB;
#endif

typedef WORD    IB;                     // Index into an array of bytes.
#ifdef _32BIT
typedef DWORD    CB;                     // Count of bytes.
#else
typedef WORD    CB;                     // Count of bytes.
#endif
typedef DWORD   LCB;                    // Count of bytes.
typedef WORD    CBIT;                   // Count of bits.
typedef WORD FAR * LPW;                 // pointer to word  

typedef BYTE    FAR *LSZ;               // 0-terminated string far pointer
typedef BYTE    FAR *LST;               // Pascal style string far pointer
typedef void    FAR *LPV;               // Far void pointer
typedef DWORD   LFO;                    // 32-bit file offset.
typedef DWORD   LCF;                    // 32-bit file count bytes
typedef void    NEAR *NPV;              // Void near pointers.

typedef NPV     NPIBI;                  // Near
typedef WORD    IDXF;
typedef LPV     LPIBI;                  // Far
typedef LPV     LPSIPB;                 // Stop information parameter block.

typedef LPV     LPCAT;                  // Pointer to catalog
typedef LPV     LPGROUP;                // pointer to a group.
typedef LPV     LPIDX;                  // Pointer index block.
typedef LPV     LPQT;                   // Pointer to Query tree.
typedef LPV     LPIPB;                  // Pointer to Index parameter block.
typedef LPV     LPWHEEL;                // Pointer to wheel parameter block.
typedef LPV     LPHL;                   // Pointer to hitlist block.
typedef LPV     LPCTAB;                 // Pointer to chartab
typedef LPV     LPOPTAB;                // Pointer to operator table
typedef LPV     LPBRKI;                 // Pointer to breaker info
typedef WORD    OCCF;

typedef HANDLE  GHANDLE;
typedef HANDLE  HGPOUP;                 // Handle to Group list
typedef DWORD   IDGROUP;                // Group's ID

typedef GHANDLE HIDX;
typedef GHANDLE HFPB;

/*************************************************************************
 *             Word-breaker API and associated defines.
 *************************************************************************/

typedef HANDLE  HIBI;           // "Internal break info".  The individual
                                //  word breakers allocate this
/*
 *  FWORDCB
 *  Call back function needed for MediaView breaker. All the LST strings
 *  are special 2-byte length preceded strings.
 *
 *  LST lstRawWord:
 *      Words as they appear originally. MediaView only uses the length that
 *      is need for highlighting
 *
 *  LST lstNormWord:
 *      Normalized word, which will be indexed. Normalized are words that
 *      are modified (such as stemmed, changed to lower case, etc)
 *
 *  DWORD dwOffset:
 *      Offset in the topic (or from the beginning of the buffer passed to
 *      MediaView breakers) where the word occurs
 *
 *  LPV lpUser:
 *      User's data, propageted down to the user's call back function
 */
typedef ERR     (FAR PASCAL * FWORDCB)(LST lstRawWord, LST lstNormWord,
    DWORD dwOffset, LPV lpUser);
    
/*  BREAKER_INIT
 *      This is the breaker's initialization routine. This routine will
 *      be called only by MediaView's Title Builder before any calls to
 *      the breaker is made
 */
typedef LPIBI   (FAR PASCAL * BREAKER_INIT)(VOID);

/*  BREAKER_FREE
 *      Termination routine for the breaker. This will allow the breaker
 *      to free any internal buffer used by it
 */
typedef void    (FAR PASCAL * BREAKER_FREE)(LPIBI);

/*
 *  Breaker function's parameter structure:
 *
 *  BRK_PARMS structure 
 *      LPIBI   lpInternalBreakInfo:
 *          This points to internal information associated with a breaker
 *          (such as memory buffer, flags, etc). It is solely used by
 *          that breaker
 *
 *      BYTE FAR * lpbBuf;
 *          Buffer containing the strings to be broken into invidual words
 *          This buffer is allocated by the application
 *
 *      DWORD   cbBufCount;
 *          The size of the buffer
 *
 *      DWORD   lcbBufOffset;
 *          The offset of the strings from the topic. This is needed if
 *          OCCF_OFFSET is used, since the MV breaker will return offsets
 *          of the words based on this offset
 *
 *      LPV lpvUser
 *          Anything that the application's callback function needs. The way
 *          the breaker works is that:
 *          - The application calls the breaker with some buffers to be broken
 *          into words
 *          - For each word the breaker will call the app's callback function
 *          to return the word and its associated information (length, offset)
 *
 *      FWORDCB lpfnOutWord;
 *          Pointer to application callback function
 *
 *      LPSIPB  lpStopInfoBlock;
 *          Stop word information. This contains a list of words that the
 *          application wants the breaker to ignore. This pertains to
 *          MediaView's breaker only
 *
 *      LPVOID  lpCharTab;
 *          Character table information. This pertains to MediaView's breaker
 *          only
 *
 *      WORD    fFlags;
 *          Internal flags set and used by MediaView's breaker only
 *
 *  } BRK_PARMS, FAR *LPBRK_PARMS;
 */

typedef struct BRK_PARMS
{
    LPIBI   lpInternalBreakInfo;
    BYTE FAR * lpbBuf;
    DWORD   cbBufCount;
    DWORD   lcbBufOffset;
    LPV     lpvUser;
    FWORDCB lpfnOutWord;
    LPSIPB  lpStopInfoBlock;
    LPVOID  lpCharTab;
    WORD    fFlags;
    WORD    Pad;                   // Padding to make DWORD align
} BRK_PARMS, FAR *LPBRK_PARMS;

/*  BREAKER_FUNC
 *      Breaker's function prototype for various MediaView's breaker functions
 *      such as FBreakWords()
 */
typedef ERR     (FAR PASCAL * BREAKER_FUNC) (LPBRK_PARMS);

/*
 * BRKLIST structure
 *      For internal use only
 */
typedef struct BreakList
{
    HANDLE  hnd;        // handle to this structure
    HANDLE  hLib;
    BREAKER_FUNC lpfnBreakFunc;
    LPSIPB      lpStopListInfo;
    LPVOID  lpCharTab;
} BRKLIST, FAR *LPBRKLIST;


/*************************************************************************
 *
 *  The following breakers functions are internal functions
 *  They can be served as a template prototypes for user's functions
 *************************************************************************/
PUBLIC  LPIBI EXPORT_API FAR PASCAL BreakerInitiate(void);
PUBLIC  void EXPORT_API FAR PASCAL BreakerFree(LPIBI);
PUBLIC  ERR EXPORT_API FAR PASCAL FBreakWords(LPBRK_PARMS);
PUBLIC  ERR EXPORT_API FAR PASCAL FBreakNumber(LPBRK_PARMS);
PUBLIC  ERR EXPORT_API FAR PASCAL FBreakDate(LPBRK_PARMS);
PUBLIC  ERR EXPORT_API FAR PASCAL FBreakTime(LPBRK_PARMS);
PUBLIC  ERR EXPORT_API FAR PASCAL FBreakEpoch(LPBRK_PARMS);
// This exists only to enable MVJK to link statically.
// We must have the same function names for the static build.
PUBLIC ERR FAR PASCAL FBreakStems(LPBRK_PARMS lpBrkParms);


// (EX)ternal (BR)ea(K)er (P)ara(M)eter structure that old .c search code
// can pass to ExtBreakText() in order to configure and call the
// new COM breakers.  The breaker control params have been purposely defined
// to mimic those in BRK_PARAMS as much as possible.  Note that the ones
// missing are now internal to the COM breaker implementation.
typedef struct _exbrkpm
{
	// This section to be specified by .c caller of breaker.
	DWORD	dwBreakWordType;		// Reg. text, number, date, etc.
	LPBYTE	lpbBuf;					// Text buffer;
	DWORD	cbBufCount;				// No. of chars in buffer.
	LPVOID	lpvUser;				// Caller data that gets passed through
									// to *lpfnOutWord.
	FWORDCB	lpfnOutWord;			// Pointer to word callback function.
	WORD	fFlags;					// Breaker flags.
	
	// This section is owned by the index COM object and should not be
	// modified by the .c caller.
	LPVOID	lpvIndexObjBridge;
} EXBRKPM, *PEXBRKPM;

PUBLIC HRESULT EXPORT_API FAR PASCAL ExtBreakText(PEXBRKPM pexbrkpm);
PUBLIC HRESULT EXPORT_API FAR PASCAL ExtStemWord(LPVOID lpvIndexObjBridge,
									LPBYTE lpbStemWord, LPBYTE lpbRawWord);
PUBLIC HRESULT EXPORT_API FAR PASCAL ExtLookupStopWord(
							LPVOID lpvIndexObjBridge, LPBYTE lpbStopWord);
PUBLIC HRESULT EXPORT_API FAR PASCAL ExtAddQueryResultTerm(
			LPVOID lpvIndexObjBridge, LPBYTE lpbTermHit, LPVOID *ppvTermHit);


/*************************************************************************
 *  @doc    API EXTERNAL 
 *  @func   ERR FAR PASCAL | fInterrupt |
 *      Function to support interrupt (cancel) feature.
 *  @parm   LPVOID | lpV |
 *      Parameter used by the callback interrupt function
 *  @rdesc  ERR_SUCCESS if there is no interrupt, else ERR_INTERRUPT
 *************************************************************************/ 
typedef ERR    (FAR PASCAL *INTERRUPT_FUNC)(LPVOID);

/*************************************************************************
 *  @doc    API EXTERNAL 
 *  @func   int FAR PASCAL | fStatus |
 *      Function to support status messaging feature.
 *  @parm   LPSTR | lpStr |
 *      Message to be displayed
 *  @rdesc  Different status codes
 *************************************************************************/ 
typedef VOID (FAR PASCAL *STATUS_FUNC)(LPSTR);


#define BREAKERBUFFERSIZE       1024    // Size of breaker's state info struct

/*
 *       Breaker Table Constants
 */
#define MAXNUMBRKRS     16     // maximum number of breakers.
#define MAXBRKRLEN      1024   // maximum size of breaker line in |SYSTEM.

#ifndef ISBU_IR_CONSTS
#define ISBU_IR_CONSTS

#define cHundredMillion ((float) 100000000.0)
#define cVerySmallWt ((float) 0.02)
#define cNintyFiveMillion 95000000
#define cTFThreshold 4096

#endif // ISBU_IR_CONSTS

/*************************************************************************
 *                     Stop list retrieval API.
 *************************************************************************/


typedef ERR (FAR PASCAL * STOPLKUP)(LPSIPB, LST);

PUBLIC  LPSIPB EXPORT_API FAR PASCAL MVStopListInitiate (WORD wTabSize,
    LPERRB lperrb);
PUBLIC  ERR EXPORT_API FAR PASCAL MVStopListIndexLoad(HFPB hSysFile,
    LPSIPB lpsipb, LSZ szStopFilename);
PUBLIC  ERR EXPORT_API FAR PASCAL MVStopListLookup(LPSIPB lpsipb,
    LST sPascalString);
PUBLIC  void EXPORT_API FAR PASCAL MVStopListDispose(LPSIPB lpsipb);
PUBLIC  ERR EXPORT_API FAR PASCAL MVStopListAddWord(LPSIPB lpsipb,
    LST sPascalString);
PUBLIC  ERR EXPORT_API FAR PASCAL MVStopListLoad(HFPB hfpbIn, LPSIPB lpsipb,
    LSZ szFilename, BREAKER_FUNC lpfnBreakerFunc,
    LPV lpCharTab);
PUBLIC  ERR EXPORT_API PASCAL FAR MVStopFileBuild (HFPB hSysFile,
    LPSIPB lpsipb, LSZ szStopfilename);
PUBLIC	ERR EXPORT_API FAR PASCAL MVStopListEnumWords(LPSIPB lpsipb,
						LST *plstWord, LONG *plWordInfo, LPVOID *ppvWordInfo);
PUBLIC	ERR EXPORT_API FAR PASCAL MVStopListFindWordPtr(LPSIPB lpsipb,
											LST lstWord, LST *plstWordInList);

/*************************************************************************
 *                      Query's defines and API
 *************************************************************************/

/* User's operators for retrieval */

#define AND_OP      0
#define OR_OP       1
#define NOT_OP      2
#define PHRASE_OP   3
#define NEAR_OP     4

#define DEF_PROX_DIST   8               // Default prox distance

// In strings with embedded font tag, this number denotes that the next byte
// is an index into a charmap table

#define EMBEDFONT_BYTE_TAG              3
#define TL_QKEY 0x8000    // Use with cDefOp to treat operators as words

/*
 *  Parser function's parameter structure:
 *
 *  PARSE_PARMS structure
 *  This structure contains all the informations necessary for
 *  parsing a line. 
 *
 *  LPB lpbQuery:
 *		Pointer to buffer containing the query to be parsed
 *
 *  LPBRKLIST lpfnTable:
 *      Array of breaker functions (FBreakWords, etc) indexed by their dtype
 *
 *  DWORD cbQuery:
 *      Query's buffer length
 */

typedef struct PARSE_PARMS
{
    LPCSTR lpbQuery;        /* Pointer to query buffer */
    EXBRKPM *pexbrkpm; 		/* External breaker param structure */
    DWORD cbQuery;       /* Query buffer's length */

    /* Note: all the following fields may be gone in the future if
     * we provide new operator to support them 
     */

    LPGROUP lpGroup;    /* Group */
    LPVOID  lpOpTab;    /* Operator table */
    WORD wCompoundWord;
    WORD cProxDist;     /* Proximity distance */
    WORD cDefOp;        /* Default operator */
    char padding[2];
} PARSE_PARMS, FAR *LPPARSE_PARMS;

PUBLIC LPQT EXPORT_API FAR PASCAL MVQueryParse(LPPARSE_PARMS, LPERRB);

PUBLIC  void EXPORT_API FAR PASCAL MVQueryFree(LPQT);


/*************************************************************************
 *               Index & Hitlist Retrieval API
 *************************************************************************/


/*
 *      This is an information buffer structure that you pass to "HitListGetTopic"
 *      which fills in its fields.  You can look at the fields not marked as
 *      "internal", and also pass it to other API functions.
 */

typedef struct  TopicInfo
{
    DWORD   dwTopicId;         // Topic-ID associated with this hit.
    DWORD   lcHits;            // Number of hits in this document.
    union
    {
        DWORD   liFirstHit;    // Index in the ROCC file of the first
                               //  hit in this document (internal).
        LPV     lpTopicList;   // Pointer to TopicList (internal)
    };
    WORD    wWeight;           // Document-weight.
    WORD    Pad;
}   TOPICINFO,
    FAR *PTOPICINFO;

/*
 *      This is an information buffer structure that you pass to "HitListGetHit"
 *      which fills in its fields.
 */

typedef struct  HitInfo
{
    DWORD   dwOffset;               // Byte-offset ".
    DWORD   dwFieldId;              // Field-ID associated with this hit.
    DWORD   dwCount;
    DWORD   dwLength;               // Word-length ".
	LPVOID	lpvTerm;				// Pointer to a term in WORD-prefix length
									//	Unicode format, i.e. a "wide ST".
}   HIT,
    FAR *LPHIT;


//  SLOP is extra bytes to handle diacritic. Each byte represents an
//  occurence of one diacritic. 5 of them should be more than enough to
//  handle all diacritics in a word. This set up will allow us to
//  simplify the checking by just doing it for RawWord only

#define SLOP    5

/* FBreakWord states */

#define SCAN_WHITE_STATE    0
#define SCAN_WORD_STATE     1
#define SCAN_NUM_STATE      2
#define SCAN_SEP_STATE      3
#define SCAN_LEADBYTE_STATE 4
#define SCAN_SBKANA_STATE   5

/* Other breaker functions' states */

#define INITIAL_STATE       0
#define COLLECTING_STATE    1

//  The following defines have an impact on the speed of the breaker.
//  The character class that appears the most should have the lowest
//  value (eg. 1), since the compiler will generate DEC AX, JE Lab
//  We want that class to be executed first. Since most documents have
//  more lower case (normalized) characters, CLASS_NORM should be 1

#define NO_CLASS        0
#define CLASS_NORM      0x01       // The char is already normalized
#define CLASS_CHAR      0x02       // The char needs to be normalized
#define CLASS_DIGIT     0x03       // The char is a digit
#define CLASS_NSTRIP    0x04       // Strip from number (like comma)
#define CLASS_NKEEP     0x05       // Keep with number (eg. decimal point)
#define CLASS_STRIP     0x06       // Strip from the word (eg. apostrophe)
#define CLASS_TYPE      0x07       // Reserved
#define CLASS_CONTEXTNSTRIP 0x08   // Stripped or not depending on context
#define CLASS_WILDCARD  0x09       // This is a wildcard char
#define CLASS_LEADBYTE  0x0A       // This is a DBCS lead-byte
#define CLASS_SBKANA    0x0B       // This is a single Kana byte
#define CLASS_LIGATURE  0x0C       // This is a ligature char


/* Map to extract the class for special characters */
#define  SPECIAL_CHAR_MAP 0xFF00

#define CLASS_BULLET    0x0100
#define CLASS_ENDASH    0x0200
#define CLASS_EMDASH    0x0300
#define CLASS_LQUOTE    0x0400
#define CLASS_RQUOTE    0x0500
#define CLASS_LDBLQUOTE 0x0600
#define CLASS_RDBLQUOTE 0x0700
#define CLASS_TERMINATOR 0x0800     // Ignore whatever from this char on
                                    // for word wheel sorting

/* Special reserved wildcard character */
#define WILDCARD_STAR   '*'
#define WILDCARD_CHAR   '?'

/*
    Those fields will be imbedded in the beginning of the date, time, etc.
    string. This insures that only same types are compared together
    correctly
 */

/* All special data types will have that byte at the beginning */
#define SPECIAL_TYPE    0x1

#ifdef TEST
#define DATE_FORMAT     0x3131
#define EPOCH_FORMAT    0x3231
#define TIME_FORMAT     0x3331
#define NUMBER_FORMAT   0x3431
#else
#define DATE_FORMAT     0x01
#define EPOCH_FORMAT    0x02
#define TIME_FORMAT     0x03
#define NUMBER_FORMAT   0x04
#endif

/* Sign byte of number */
#define NEGATIVE    '1'
#define POSITIVE    '2'

//  -   -   -   -   -   -   -   -   -
typedef struct  InternalBreakInfo
{
    HANDLE  hibi;       // Handle to this structure
    LCB lcb;    // Byte offset of the start of the word that's
        //  being constructed.  This is equal to the
        //  user-specified offset of the start of the
        //  block being processed plus the offset into
        //  the block at which the word starts.  More
        //  simply, this is the "byte offset" field of
        //  the occurence element.
    CB  cbNormPunctLen; // When processing something that I'm calling
        //  a "number", I have to deal with characters
        //  such as ".", which I have to strip if
        //  they're at the end of the word, but have
        //  to keep if they're in the middle.  This
        //  keeps track of the number of characters
        //  that I have to remove if the word ends.
        //  For instance, for the word "162..", this
        //  value will be 2 at the time the word ends,
        //  which would tell me to remove the last two
        //  characters (the "..").
    CB  cbRawPunctLen;  // This works like "cbNormPunctLen", with a
        //  small difference.  This field handles
        //  characters that are stripped, but which
        //  affect the "length" of the "number" being
        //  processed. An example case is the ","
        //  character.  For instance, "12,345" is 6
        //  characters long, even though the "," gets
        //  stripped, but "12345," is five characters
        //  long, because the trailing comma doesn't
        //  affect the length.
    BYTE    state;
    BYTE    fGotType;   // Flag to denote we have got the 1st byte
        // of a 2-byte special type
    BYTE    astNormWord[CB_MAX_WORD_LEN + 1 + SLOP];
    BYTE    astRawWord[CB_MAX_WORD_LEN + 1];
}   IBI,
    FAR *_LPIBI;


PUBLIC  LPIDX EXPORT_API FAR PASCAL MVIndexOpen(HANDLE, LSZ, LPERRB);
PUBLIC  ERR  EXPORT_API FAR PASCAL MVSearchSetCallback (LPQT, LPVOID);
PUBLIC  void EXPORT_API FAR PASCAL MVIndexClose(LPIDX);

typedef struct SearchInfo
{
    DWORD  dwMemAllowed;    // Maximum memory allowed
    DWORD  dwTopicCount;    // Maximum topics that the user wants to return
    DWORD  Flag;            // Search flags
	DWORD  dwValue;			// Internal use (should be set to 0)
	DWORD  dwTopicFullCalc;		// Maximum topics of dwTopicCount which are guaranteed
								// to have fully calculated top N similarity scores.
	LPVOID lpvIndexObjBridge;	// Allows internal .c query code to indirectly call
								// pluggable COM stemmers.
} SRCHINFO, FAR *PSRCHINFO;

// Parameter passed to indexSearch. This should match with medv.h

#define QUERYRESULT_RANK        0x0100 // Ranked the result. If not highest hit 1st
//#define QUERYRESULT_UNSORTED    0x0200 // Result topics are 1st in 1st out (in UID order)
#define QUERYRESULT_UIDSORT     0x0200 // Topics are returned in UID order
#define QUERYRESULT_IN_MEM      0x0400 // Result should be kept in mem
#define QUERYRESULT_GROUPCREATE 0x0800 // Create a group from the hitlist
#define QUERYRESULT_NORMALIZE   0x1000 // Normalize result. Short topic 1st
#define QUERYRESULT_LONGFIRST   0x2000 // Long topic 1st (not supported yet)
#define QUERYRESULT_ALPHASORT   0x4000 // Alphabetical sort (not supported yet)
#define QUERYRESULT_SKIPOCCINFO 0x8000 // Topic list only, no occurrence info

#define STEMMED_SEARCH      0x00010000 // Perform runtime stemming (English only)
#define LARGEQUERY_SEARCH	0x00020000 // Perform large query search
#define SIMILAR_SEARCH		0x00040000 // Perform "find similar" search:
									   // currently memory-optimized ranked boolean OR
#define QUERY_GETTERMS		0x00080000	// Return with each set of occurrence
										// data a pointer to the term string
										// that the data is associated with.

PUBLIC  LPHL EXPORT_API FAR PASCAL MVIndexSearch(LPIDX, LPQT, PSRCHINFO,
    LPGROUP, LPERRB);

#ifndef SIMILARITY
PUBLIC LPHL EXPORT_API FAR PASCAL MVIndexFindSimilar (LPIDX lpidx,
  LPPARSE_PARMS lpParms, PSRCHINFO pSrchInfo, LPGROUP lpResGroup, LPVOID pCallback,
  LPERRB lperrb);
#endif // SIMILARITY

PUBLIC ERR EXPORT_API PASCAL FAR MVHitListFlush (LPHL, DWORD);
PUBLIC ERR EXPORT_API FAR PASCAL MVHitListGetTopic(LPHL, DWORD, PTOPICINFO);
PUBLIC ERR EXPORT_API FAR PASCAL MVHitListGetHit(LPHL, PTOPICINFO, DWORD, LPHIT);
PUBLIC void EXPORT_API FAR PASCAL MVHitListDispose(LPHL);
PUBLIC DWORD EXPORT_API PASCAL FAR MVHitListEntries (LPHL);
PUBLIC LONG EXPORT_API PASCAL FAR MVHitListMax (LPHL);
PUBLIC ERR EXPORT_API PASCAL FAR MVHitListGroup (LPVOID, LPHL);

PUBLIC void EXPORT_API PASCAL FAR MVGetIndexInfoLpidx(LPIDX, struct IndexInfo *);

/*************************************************************************
 *                     Character Table Retrieval API
 *************************************************************************/
PUBLIC VOID EXPORT_API FAR PASCAL MVCharTableDispose (LPCTAB);
PUBLIC LPCTAB EXPORT_API FAR PASCAL MVCharTableIndexLoad(HFPB, LSZ, LPERRB);
PUBLIC LPCTAB EXPORT_API FAR PASCAL MVCharTableLoad (HFPB, LPB, LPERRB);
PUBLIC LPCTAB EXPORT_API FAR PASCAL MVCharTableGetDefault (LPERRB);
PUBLIC VOID EXPORT_API FAR PASCAL MVCharTableDispose (LPCTAB);
PUBLIC ERR EXPORT_API PASCAL FAR MVCharTableFileBuild (HFPB, LPCTAB, LSZ);
PUBLIC VOID EXPORT_API FAR PASCAL MVCharTableSetWildcards (LPCTAB);



/*************************************************************************
 *                 Operator Table Index & Retrieval API
 *************************************************************************/
PUBLIC LPOPTAB EXPORT_API PASCAL FAR MVOpTableLoad (LSZ, LPERRB);
PUBLIC VOID EXPORT_API PASCAL FAR MVOpTableDispose (LPOPTAB);
PUBLIC LPOPTAB EXPORT_API FAR PASCAL MVOpTableIndexLoad(HANDLE, LSZ, LPERRB);
PUBLIC LPOPTAB EXPORT_API FAR PASCAL MVOpTableGetDefault(LPERRB);
PUBLIC ERR EXPORT_API PASCAL FAR MVOpTableFileBuild(HFPB, LPOPTAB, LSZ);



/*************************************************************************
 *                          Index API
 *************************************************************************/

/*************************************************************************
    INDEXINFO structure
    This structure is used to give the indexer information on how the
    the index should be built given a certain amount of resource
    
    DWORD   dwMemSize :
        Specify approximately how much memory the indexer is allowed to use.
        The rule of thumb is that if more memory is allowed indexing speed
        will be increased, if this much memory is given to the indexer by the
        operating system. The catch is that the operating system can not
        allocate such amount of memory for the indexer, so when some allowed
        limit is reached, the O/S will start swapping to disk (using Virtual
        Memory). This will slow down the indexer signicantly. It is best to
        try to do some trial/error testing to see how much memory will give
        an optmal indexing speed.
        If dwMemSize = 0, a minimum 4M is used
        
   DWORD   dwBlockSize:
        Desired block size used by the index. The minimum size if 4096. By
        varying the block size, the user can make the overall size of the index
        smaller or larger, the retrieval speed slower or faster. Again, there
        is no strict rule. A large block will cause slowness in comparison,
        while a small block will cause extra seeks to be perfromed
        
   DWORD   Occf:
        Occurrence field flags. Those describe what data are to be included
        in the index. The currently supported flags are:
            OCCF_FIELDID
            OCCF_TOPICID
            OCCF_COUNT
            OCCF_OFFSET
            OCCF_LENGTH
        Those flags can be OR'ed together
        
   DWORD   Idxf
        Flags to denote how the index is built in term of ranking. The only
        supported flag is
            IDXF_NORMALIZE
        which tell the indexer to do normalized ranking. This causes the
        indexer to generate a huge table proportional with the maximum
        topic id to be reside in memory at index time, and saved with the
        index. This flag may cause the index's size to increase significantly,
        especially when the topic ids are non-sequential (ie. random). Using
        this flag with non-sequential topic ids may cause the indexer to
        fail because lack of memory. Normalized searches will have a tendercy
        to return short topics first
        
    LCID   lcid
        This is used mostly for runtime stemming. Currently, runtime
        stemming is supported for English only. Any other language doesn't
        support runtime stemming yet
 *************************************************************************/
typedef struct IndexInfo
{
    DWORD   dwMemSize;      // Memory allocated for indexing to use
    DWORD   dwBlockSize;    // Unit block size of the index
    DWORD   Occf;           // Occurrenc field flags
    DWORD   Idxf;           // Various index flag

	//--------------- New Members for File Version 4.0 ----------------
	DWORD	dwCodePageID;		// ANSI code page no. specified at build time
	LCID	lcid;				// WIN32 locale ID specified at build time;
	DWORD	dwBreakerInstID;	// breaker instance that was used to parse
								// terms for the index at build time.  
} INDEXINFO, FAR *PINDEXINFO;

// Various idxf flags. They can be OR'ed together

#define     IDXF_NONE       ((IDXF)0x0000)   // Nothing, just do straight boolean.
#define     IDXF_NORMALIZE  ((IDXF)0x0001)   // Index is normalized
#define     IDXF_NOSLACK    ((IDXF)0x0002)   // Not supported yet
#define     KEEP_TEMP_FILE  ((IDXF)0x0100)   // Keep flag

#ifdef OLD_LANG_INFO
// Various language flags

#define LANGUAGE_ENGLISH        0x00
#define LANGUAGE_JAPANESE       0x01
#define LANGUAGE_TRAD_CHINESE   0x02 // Mapped to old LANGUAGE_CHINESE
#define LANGUAGE_KOREAN         0x03
#define LANGUAGE_ANSI           0x04
#define LANGUAGE_SIMP_CHINESE   0x05

#define SZ_LANGUAGE_ENGLISH         L"English"
#define SZ_LANGUAGE_JAPANESE        L"Japanese"
#define SZ_LANGUAGE_TRAD_CHINESE    L"TradChinese"
#define SZ_LANGUAGE_KOREAN          L"Korean"
#define SZ_LANGUAGE_ANSI            L"ANSI"
#define SZ_LANGUAGE_SIMP_CHINESE    L"SimpChinese"

#define CSZ_LANGUAGE_ENGLISH        7   // strlen (SZ_LANGUAGE_ENGLISH)
#define CSZ_LANGUAGE_JAPANESE       8   // strlen (SZ_LANGUAGE_JAPANESE)
#define CSZ_LANGUAGE_TRAD_CHINESE   11  // strlen (SZ_LANGUAGE_TRAD_CHINESE)
#define CSZ_LANGUAGE_KOREAN         6   // strlen (SZ_LANGUAGE_KOREAN)
#define CSZ_LANGUAGE_ANSI           4   // strlen (SZ_LANGUAGE_ANSI)
#define CSZ_LANGUAGE_SIMP_CHINESE   11  // strlen (SZ_LANGUAGE_SIMP_CHINESE)

#endif	// OLD_LANG_INFO - obsoleted by IT 4.0's use of locale ids.


/*
 *  Occurence field flags.  These are initially used to indicate which
 *  occurence fields are to be indexed.  Once an index is created, the
 *  flags used to create an index are stored in it.  During retrieval
 *  these flags are examined in order to determine how to decode the
 *  index format.  Any combination of these fields is legal
 *  OCCF_TOPICID field must be always present.
 *
 *  OCCF_NONE
 *      Basically, this is equivalent to OCCF_TOPICID, since the indexer
 *      always turn OCCF_TOPICID on
 *
 *  OCCF_FIELDID
 *      Save information about the field that the word belongs to. This must
 *      be set if the application is using VFLD
 *
 *  OCCF_TOPICID
 *      Topic ID is to be saved. Basically, a topic id is just a number
 *      associated with the topic to uniquely identify it. This flag is always
 *      set by the indexer
 *
 *  OCCF_COUNT
 *      Save information about the positions of the words relative to the
 *      first word in a topic. This flag must be set if the application wants
 *      to use NEAR or phrase operator in the search
 *
 *  OCCF_OFFSET
 *      Save the information about the offset of the word in the topic. This
 *      is mostly used if the application wants to do search result highlighting
 *
 *  OCCF_LENGTH
 *      Save the information about the length of the word in the topic. This
 *      is mostly used if the application wants to do search result highlighting
 *      The length of a word can be different from the real length if stemming
 *      or aliasing is used
 *
 *  OCCF_LANGUAGE
 *      Currently ignored. This is for future multi-lingual topics support
 */

#define OCCF_NONE       ((OCCF)0x0000)    // Blank.
#define OCCF_FIELDID    ((OCCF)0x0001)    // Field-ID is present.
#define OCCF_TOPICID    ((OCCF)0x0002)    // Topic ID is present.  This should
                                          //  always be set.
#define OCCF_COUNT      ((OCCF)0x0004)    // Word-count is present.
#define OCCF_OFFSET     ((OCCF)0x0008)    // Byte-offset is present.
#define OCCF_LENGTH     ((OCCF)0x0010)    // Word-length is present.
#define OCCF_LANGUAGE   ((OCCF)0x0020)    // Language (not supported yet)

#define OCCF_HAVE_OCCURRENCE (OCCF_OFFSET | OCCF_COUNT)

/*
    OCC structure
    This structure contains all the information related to a word to be
    added to the index
    
    DWORD   dwFieldId:
        Field Id value associated with the word. This field is added to
        the index if OCCF_FIELDID flag is set
        
    DWORD   dwTopicID:
        Id of the topic that the word belongs to. Used if OCCF_TOPICID is set
        
    DWORD   dwCount:
        Starting at 0, this is the position of the word compared to the first
        word in the topic (eg.the 11th word in the topic). Used if OCCF_COUNT
        is set
        
    DWORD   dwOffset:
        Starting at 0, this is the offset of the word compared to the first
        byte in the topic. Used if OCCF_OFFSET is set
        
    WORD    wWordLen:
        Real length of the word (unstemmed or alias). Used if OCCF_LENGTH is
        set
        
    WORD    wLanguage:
        Currently ignored
 
    This structure is passed to MVIndexAddWord
 */
typedef struct  Occurence
{
    DWORD   dwFieldId;              // Field-ID.
    DWORD   dwTopicID;              // TopicID.
    DWORD   dwCount;                // Word-count.
    DWORD   dwOffset;               // Byte-offset.
    WORD    wWordLen;               // Word-length.
    WORD    wLanguage;              // Language (not supported yet)
} OCC, FAR *LPOCC;

PUBLIC  LPIPB EXPORT_API FAR PASCAL MVIndexInitiate(PINDEXINFO, LPERRB);
PUBLIC  ERR EXPORT_API FAR PASCAL MVIndexAddWord(LPIPB, LST, LPOCC);
PUBLIC  ERR EXPORT_API FAR PASCAL MVIndexBuild(HFPB, LPIPB, HFPB, LPSTR);
PUBLIC  ERR EXPORT_API FAR PASCAL MVIndexTopicDelete(HFPB, LPIPB, LSZ,
    DWORD FAR [], DWORD);

PUBLIC  ERR EXPORT_API FAR PASCAL MVIndexUpdate(HFPB, LPIPB, LSZ);
PUBLIC  ERR EXPORT_API FAR PASCAL MVIndexUpdateEx(HFPB, LPIPB, LSZ, DWORD FAR [], DWORD);
PUBLIC  void EXPORT_API FAR PASCAL MVIndexDispose(LPIPB);

/*************************************************************************
 *              Structures for internal uses only
 *************************************************************************/


/*****************************************************************************
*
*       MatchCache Structure
*
*   The layout engine expects the matches to be in sorted order and 
*   non-overlapping.  Neither assumption is maintained by the search 
*   engine.  So, when the layout asks for matches for a particular
*   topic, they are sorted and combined and stored in a match cache.
*
*****************************************************************************/

typedef struct _MATCHCACHE
{
    long    lTopic;         // the topic number
    long    lItem;          // the item in the topic list
    long    lMatches;       // the number of matches
    HIT     match[1];       // array of match information
} MATCHCACHE, NEAR *PMATCHCACHE, FAR *LPMATCHCACHE;

#pragma pack()  // Guard against Zp problems.

#ifdef __cplusplus
}
#endif

#endif //__MVSEARCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\objects.h ===
/*-------------------------------------------------------------------------
| Objects.h                                                               |
| Copyright (C) 1989 Microsoft Corporation                                |
|                                                                         |
| mattb 4/19/89                                                           |
|-------------------------------------------------------------------------|
| This file contains definitions associated with the layout objects used  |
| in help.                                                                |
-------------------------------------------------------------------------*/

#ifndef __OBJECTS_H__
#define __OBJECTS_H__

#include <address.h>   // for VA
#include <hash.h>  // for HASH

/*-------------------------------------------------------------------------
| Objects fall in two ranges:  Uncounted objects and counted objects.     |
| For uncounted objects, the count of object regions is contained in a    |
| fixed array, or calculated on the fly.  (see datapres.c)                |
-------------------------------------------------------------------------*/
#define bTypeParaGroup  1     /* Object type indicating paragraph group */
#define bTypeTopic      2     /* Object type indicating topic break */
#define bTypeBitmap     3     /* Bitmap */
#define bTypeSbys       4     /* Side-by-side paragraphs */
#define bTypeWindow     5     /* Windows */
#define bTypeMarker     6     /* Generic inter-layout marker */
#define MAX_UNCOUNTED_OBJ_TYPE 16   /* Unused numbers are reserved for future
                                       use.  While uncounted objects can
                                       actually go up to 31, going past 15 will
                                       break the file format.                 */

#define bTypeParaGroupCounted  32   /* Object type indicating paragraph group */
#define bTypeTopicCounted      33   /* Object type indicating topic break */
#define bTypeBitmapCounted     34   /* Bitmap */
#define bTypeSbysCounted       35   /* Side-by-side paragraphs */
#define bTypeWindowCounted     36   /* Windows */
#define bTypeMultiParaGroup	   37   /* Array of paragraph groups */
#define MAX_OBJ_TYPE           37


#define bMagicMBHD  0x11
#define bMagicMFCP  0x22
#define bMagicMOBJ  0x33
#define bMagicMTOP  0x44
#define bMagicMOPG  0x55
#define bMagicMBMR  0x66
#define bMagicMBHS  0x77
#define bMagicMSBS  0x88
#define bMagicMCOL  0x99

#define cxTabsMax       32        /* Maximum number of tabs in MOPG */

#define cbBLOCK_SIZE 4096         /* Size of blocks in the topic.  */

#define cbMAX_BLOCK_SIZE (1<<14)  // max size of 2k block after decompress
#define shrFclToBlknum   11       // offset to blknum transform, used in hc

#define bHotspotInvisible   0
#define bHotspotVisible     1




/* Paragraph justification properties */
#define wJustifyMost    2
#define wJustifyLeft    0
#define wJustifyRight   1
#define wJustifyCenter  2

/* Paragraph box line types */
#define wBoxLineMost    5
#define wBoxLineNormal  0
#define wBoxLineThick   1
#define wBoxLineDouble  2
#define wBoxLineShadow  3
#define wBoxLineDotted  4
#define wBoxLineDash	5

/* Border line orientations */
/* The order must match order in MBOX */
#define wBoxBorderNone	  ((WORD)(-1))
#define wBoxBorderFull    0
#define wBoxBorderTop	  0
#define wBoxBorderLeft	  1
#define wBoxBorderBottom  2
#define wBoxBorderRight	  3

#define wBoxPatternNone		0
#define wBoxPatternDkHoriz	1
#define wBoxPatternDkVert	2
#define wBoxPatternDkFdiag	3
#define wBoxPatternDkBdiag	4
#define wBoxPatternDkCross	5
#define wBoxPatternDkDcross	6
#define wBoxPatternHoriz	7
#define wBoxPatternVert		8
#define wBoxPatternFdiag	9
#define wBoxPatternBdiag	10
#define wBoxPatternCross	11
#define wBoxPatternDcross	12


/* Tab types */
#define wTabTypeMost    3
#define wTabTypeLeft    0
#define wTabTypeRight   1
#define wTabTypeCenter  2
#define wTabTypeDecimal 3

/* Used for various things */
#define ldibNil         ((LONG)-1)	// Protect comparisons in WIN32

/* End of a side by side paragraph list */
#define cColumnMax      32
#define iColumnNil      ((WORD)-1)	// (WORD) fixes 32bit BUG !! ARGHH!




// Critical structures that gets messed up in /Zp8
#pragma pack(1)


/* MBHD- Memory resident block header structure */
typedef struct mbhd
  {
  VA vaFCPPrev;
  VA  vaFCPNext;
  VA  vaFCPTopic;
  } MBHD, FAR *QMBHD;


/* MFCP- Memory resident FCP header structure */
typedef struct mfcp
  {
  long lcbSizeCompressed;   /* Size of whole FC when compressed */
  long lcbSizeText;         /* Size of uncompressed text (not FC) */
  VA vaPrevFc;              /* File address to previous FC */
  VA vaNextFc;              /* File address to next FC */
  ULONG ichText;            /* Memory image offset to text */
  } MFCP, FAR *QMFCP;


/* MOBJ- Memory resident generic object header */
typedef struct mobj
  {
  BYTE bType;
  LONG lcbSize;
  WORD wObjInfo;
  } MOBJ, FAR *QMOBJ, FAR *LPMOBJ;


/*** Group macro structures start ***/

/* MTOP contains an offset into the Group subfile.
 * This offset serves as a group identifier and also
 * indicates where the group macro strings are in the
 * file.
 */

#define NULLGROUP (0L)		   // NULL group number for MTOP
#define NOGROUPEXIT ((ULONG)(-1))  // No group exit macros
#define GRPFILENAME "|GMACROS"	   // Group macros subfile

/*** Structure for group file entry (when not NULLGROUP)
 *
 * cbGrpMac - byte count of macro data including header
 * cbToExit - byte count to exit macros (including header)
 *	      NOGROUPEXIT indicates none
 *
 *
 *  This structure is followed by SZ for entry macros and then
 *  an SZ for exit macros if they exist.
 *
 *  cbGrpMac == sizeof(GMH) means no macros
 *  cbToExit == sizeof(GMH) means no entry macros
 *  cbToExit == NOGROUPEXIT means no exit macros
 *
 * MTOP contains an offset into GRPFILENAME and a count of bytes
 * for the size of the macro data.  Having the size in MTOP allows
 * quicker retreival.  A size == sizeof(GMH) means the group
 * has no macros.
 *
 * This technique for determining where the group entry and exit
 * macros start is awkward, but there wasn't time to have the
 * compiler use a more flexible approach.  Note that there
 * is no way to add new fields to the end of the group data.
 *
 ***/
typedef struct gmh_tag {
    ULONG   cbGrpMac;		// cb group data
    ULONG   cbToExit;		// cb to exit macros or NOGROUPEXIT
} GMH;

typedef GMH FAR *QGMH;

/*** Group macro structures end ***/

#if 1
/* MTOP- Memory resident topic object structure */
  typedef struct mtopent
    {
    ADDR addrPrev;                    /* Physical address                 */
    ADDR addrNext;                    /* Physical address                 */

    LONG lTopicNo;

    VA  vaNSR;          // non scrollable region, if any, vaNil if none.
    VA  vaSR;           // scrollable region, if any, vaNil if none.
    VA  vaNextSeqTopic; // next sequential topic, for scrollbar calc.
                        // For Help 3.0 files this will not be correct in
                        // the case that there is padding between the MTOP
                        // and the end of a block.

    ULONG ulGrpNum;	// Group number
    ULONG ulGrpFileOff; // Offset into group file for macros
    ULONG cbGrpMacro;	// Size of group macros

    } MTOP, FAR *QMTOP;

#endif

// The new mv2.0 FC header
typedef struct tagFC {
   DWORD	  dwFcIndex;
   DWORD	  lichCumulativeText;   // total of all previous lichText  TO DO: REMOVE THIS EVENTUALLY
   MVADDR	  mva;
   WORD		  wUserFlags;  // kevynct added
   WORD		  iSubtopic;   
   LPCSTR	  lpszSubtopicUnique;
   LPCSTR	  lpszSubtopicTitle;
   DWORD      lcbSize;		// sizeof data + text
   DWORD	  lichText;		// offset to text   
   DWORD	  lcbText;  	// sizeof text
   LPBYTE	  lpbData;		// start of the whoel thing
   DWORD	  dwReserved1;	// Don't touch! 
   DWORD	  dwReserved2;	// Don't touch! 
} FC, FAR *LPFC;

// The new mv2.0 topic header
#pragma warning(disable : 4200)  // for zero-sized array
typedef struct tagTOPIC {
	HANDLE	hTopic;
	VOID FAR * lpvMemory; 			// Using block mgr for strings/FC data
	DWORD	dwReserved;
	DWORD	dwReserved2;
	DWORD	dwUser;				// Anything you want!
	DWORD	dwUserRef;				// Anything you want!
	DWORD	dwAllocatedSize;
	DWORD   dwBrowseDefault;  // zero if none
	HASH	uhUnique;
	WORD 	wSubtopicCount;
	LPCSTR 	lpszTitle;
	LPCSTR 	lpszUserData;
	DWORD 	dwFcCount;
	FC		fc[0];	
} TOPIC, FAR *LPTOPIC;

#pragma warning(default : 4200)


/* MPFG- Disk resident paragraph flag information */
// kevynct: slightly modified to support paragraph styles
typedef struct mpfg
  {
  // (kevynct) I have unionized the MPFG as it should have been in the first place.
  // but this will break the file format, so I'm ifdefing for now.
  // the difference is that in the old format, there was a separate SHORT for a style number
  // and another SHORT for the flags.  if MV20_STYLEONLY is defined, these structures will be
  // merged and an fStyle added to the flags for the case where both a para style and para attributes
  // are specified.
#ifdef MV20_STYLEONLY
  union {
#endif //MV20_STYLEONLY
	  struct {
	  unsigned short fStyleOnly:1;	// if set, mopg consists of a style number only and no more flags...
	  unsigned short wStyle:15;		// in the past, this was never set, and for rgf never will be
	  } st;
	  struct {
#ifdef MV20_STYLEONLY  
		unsigned short fStyleOnly:1;  
#endif //MV20_STYLEONLY
	    unsigned short fMoreFlags:1;
	    unsigned short fSpaceOver:1;
	    unsigned short fSpaceUnder:1;
	    unsigned short fLineSpacing:1;
	    unsigned short fLeftIndent:1;
	    unsigned short fRightIndent:1;
	    unsigned short fFirstIndent:1;
	    unsigned short fTabSpacing:1;
	    unsigned short fBoxed:1;
	    unsigned short fTabs:1;
	    unsigned short wJustify:2;
	    unsigned short fSingleLine:1;
#ifdef MV20_STYLEONLY  
		unsigned short fStyle:1;
	    unsigned short wUnused:1;
#else
		unsigned short wUnused:2;		
#endif //MV20_STYLEONLY
	 } rgf;
#ifdef MV20_STYLEONLY  
  }
#endif //MV20_STYLEONLY
} MPFG, FAR *QMPFG, FAR *LPMPFG;

typedef struct tagMBRD
{	
  unsigned short wLineType;
  unsigned short wWidth; // in twips.
  unsigned short wDistance; // distance from text, in twips
  unsigned long  dwColor; // COLORREF    
} MBRD, FAR *LPMBRD;

#define IS_VISIBLE_MBOX(x) ((x).fBorderAtAll || (x).fHasShading || (x).fHasPattern)
/* MBOX- Memory/disk resident paragraph frame record */
typedef struct mbox
  {
  // these initial flags describe the lines that are present in the box.
  // MBOX structures occur in the same order as the flags if they are present
  union {
	  unsigned short wFlags;
	  struct {
		  unsigned short fBorderAtAll:1;
		  unsigned short fFullBox:1;  // if true, there is only one MBRD which is used for all lines
		  unsigned short fTopLine:1;  // else these four bits describe the MBRDs present
		  unsigned short fLeftLine:1;
		  unsigned short fBottomLine:1;
		  unsigned short fRightLine:1;
		  unsigned short fHasShading:1;  // true if percent shading is used
		  unsigned short fHasPattern:1;  // true if pattern is used. mutex with shading if set 		  
		  unsigned short bUnused:8;
	  };
  };
  union {
  	  unsigned short  wPercentShading; // percent shading value.
	  unsigned short  wBoxPattern;
  };
  unsigned long  dwClrPatFore;      // line color for bkground patter.
  unsigned long  dwClrPatBack;      // background color for bkground patter.	
  MBRD rgmbrd[4]; // up to four different lines can be part of a box
  } MBOX, FAR *QMBOX, FAR *LPMBOX;


/* TAB: Tab data structure */
typedef struct tab
  {
  SHORT x;
  SHORT wType;
  } TAB, FAR *QTAB;

#define wParaStyleNil	((SHORT) 0x7FFF)
#define wParaStyleDefault	((SHORT) 0)

/* MOPG- Memory resident paragraph group object structure */
typedef struct mopg
  {
  long libText;
  SHORT wStyle;  // kevynct:  the (optional) paragraph style to apply
  SHORT iFnt;
  SHORT fMoreFlags;
  SHORT fBoxed;
  SHORT wJustify;
  SHORT fSingleLine;
  SHORT wUnused;
  long lMoreFlags;
  SHORT ySpaceOver;
  SHORT ySpaceUnder;
  SHORT yLineSpacing;
  SHORT xLeftIndent;
  SHORT xRightIndent;
  SHORT xFirstIndent;
  SHORT xTabSpacing;
  MBOX mbox;
  SHORT cTabs;
  TAB rgtab[cxTabsMax];
  } MOPG, FAR *QMOPG, FAR *LPMOPG;

// Values that can be used in the lMoreFlags field.
#define PF_SIZESINTWIPS 0x00000001

/* MBMR- Memory/disk resident bitmap record (layout component) */
typedef struct mbmr
  {
  BYTE bVersion;
  SHORT dxSize;
  SHORT dySize;
  SHORT wColor;
  SHORT cHotspots;
  LONG lcbData;
  } MBMR, FAR *QMBMR;


/* MBHS- Memory / disk resident bitmap hotspot record */
typedef struct mbhs
  {
  BYTE bType;
  BYTE bAttributes;
  BYTE bFutureRegionType;
  SHORT xPos;
  SHORT yPos;
  SHORT dxSize;
  SHORT dySize;
  long lBinding;
  } MBHS, FAR *QMBHS;


/* MSBS- Memory/disk resident side by side paragraph group object structure */
typedef struct msbs
  {
  BYTE bcCol;
  BYTE bFlags;
  // new members go here
  SHORT dxRowIndent;
  SHORT dxRowWidth; // used for relative spacing: stores total width of table, zero otherwise
  SHORT dyRowHeight; // height of the table row in twips: zero if "automatic", < 0 if "absolute", > 0 if "at least"  
  } MSBS, FAR *QMSBS, FAR *LPMSBS;

// Values for use with the bFlags field of the MSBS structure.
#define MSBS_ABSOLUTE      0x0001  // Must be 1 to correspond to old version
#define MSBS_SIZESINTWIPS  0x0002

/* MCOL- Memory/disk resident column structure */
typedef struct mcol
{
	unsigned short xWidthColumn;   // cell width
	unsigned short xWidthSpace;    // space between cells
	// new members for mv2.0
	MBOX mbox;   // the cell's border formatting
} MCOL, FAR *QMCOL, FAR *LPMCOL;

/* MWIN- Memory/disk resident embedded window object structure */
typedef struct mwin
  {
  WORD  wStyle;
  SHORT  dx;
  SHORT  dy;
  char szData[1];
  } MWIN, FAR *QMWIN;

// Critical structure that gets messed up in /Zp8
#pragma pack()

//wjc Size of command and data for searcher commands (see below)
#define cbSearchFieldCommand  5
#define cbDTypeCommand        3
#define cbAliasCommand        7

#define chCommand       0x00  /* Indicates a parallel command in text */

// The following definitions describe the commands used in the layout command table.
//
// (kevynct)  The following three commands were added during Viewer and are never used
// at run-time.  They really shouldn't have been put in here.
// (kevynct) Removed for mv2.0, but not removed from cmd table space.  sigh.

#define bSearchFieldCommand   0x20 /* Followed by 4 byte ident */
#define bDTypeCommand	0x21 /* Followed by 2 byte unsigned */
#define bAliasCommand   0x22 /* Followed by 6 bytes  (alias idx & highlight length) */

#define IsFormatCommand(b) ((b) >= bSmallFormat0 && (b) <= bWordFormat)
																										 
// Format change commands: the order of these should not be changed
#define GetSmallFormat(b) ((b) & 0x0f)
#define IsSmallFormat(b) ((b) & 0x0f) == bSmallFormat0)
#define IsMediumFormat(b) ((b) == bByteFormat)

#define bSmallFormat0	0x60  // Format change: 0  (least-sig nibble must be zero)
#define bSmallFormat1	0x61  // Format change: 1
#define bSmallFormat2	0x62  // Format change: 2
#define bSmallFormat3	0x63  // Format change: 3
#define bSmallFormat4	0x64  // Format change: 4
#define bSmallFormat5	0x65  // Format change: 5
#define bSmallFormat6	0x66  // Format change: 6
#define bSmallFormat7	0x67  // Format change: 7
#define bSmallFormat8	0x68  // Format change: 8
#define bSmallFormat9	0x69  // Format change: 9
#define bSmallFormat10 	0x6a  // Format change: 10
#define bSmallFormat11	0x6b  // Format change: 11
#define bSmallFormat12	0x6c  // Format change: 12
#define bSmallFormat13	0x6d  // Format change: 13
#define bSmallFormat14	0x6e  // Format change: 14
#define bSmallFormat15	0x6f  // Format change: 15
#define bByteFormat		0x70  // Format change: (one-byte arg) 16-255. Must follow bSmallFormat15

// New commands are allowed in this space
#define bWordFormat     0x80  /* Format change, two byte arg (0-32767) */
#define bNewLine        0x81  /* Newline */
#define bNewPara        0x82  /* New paragraph */
#define bTab            0x83  /* Left-aligned tab */
#define bBlankLine      0x85  /* Followed by 16 bit skip count */
#define bInlineObject   0x86  /* Followed by inline layout object */
#define bWrapObjLeft    0x87  /* Left- aligned wrapping object */
#define bWrapObjRight   0x88  /* Right-aligned wrapping object */

#define bEndHotspot     0x89  /* End of a hotspot */
#define bColdspot       0x8A  /* Coldspot for searchable bitmaps */
#define bNoBreakSpace	0x8B  /* a non-breaking space */
#define bOptionalHyphen	0x8C  /* a potentially existing hypen */
#define bBeginFold  	0x8D  // start of collapsable region
#define bEndFold		0x8E  // end of collapsable region

/*
 Coldspot Commands

 A "coldspot" is understood by the runtime but not added
 to the hotspot list, since it is not a hotspot.  This is used
 to create searchable regions in metafiles and bitmaps.  Coldspots are
 always invisible, and currently not inserted into the command table.
*/

/*
  Hotspot Commands

  Hotspot commands have first nibble of E or C.

  E - normal hotspot
  C - macro

  Bits in the second nibble have the following meaning:

      (set)     (clear)
  8 - long      short
  4 - invisible visible
  2 - ITO       HASH
  1 - jump      popup

  Long hotspots are followed by a word count prefixed block of binding
  data.  The count does not include the command byte or the count word.

  Short hotspots are followed by four bytes of binding data.

  ** Note that some of the combinations of bits are meaningless.
*/

#define fHSMask           0xD0
#define fHS               0xC0
#define fHSNorm           0x20
#define fHSLong           0x08
#define fHSInv            0x04
#define fHSHash           0x02
#define fHSJump           0x01

#define FHotspot(          b ) (((b) &  fHSMask         ) ==  fHS         )
#define FNormalHotspot(    b ) (((b) & (fHSMask|fHSNorm)) == (fHS|fHSNorm))
#define FLongHotspot(      b ) (((b) & (fHSMask|fHSLong)) == (fHS|fHSLong))
#define FInvisibleHotspot( b ) (((b) & (fHSMask|fHSInv )) == (fHS|fHSInv ))
#define FHashHotspot(      b ) (((b) & (fHSMask|fHSNorm|fHSHash)) == (fHS|fHSNorm|fHSHash))
#define FJumpHotspot(      b ) (((b) & (fHSMask|fHSNorm|fHSJump)) == (fHS|fHSNorm|fHSJump))

#define FMacroHotspot(     b ) (((b) & (fHSMask|fHSNorm)) == fHS)
#define FShortHotspot(     b ) (((b) & (fHSMask|fHSLong)) == fHS)
#define FVisibleHotspot(   b ) (((b) & (fHSMask|fHSInv )) == fHS)
#define FItoHotspot(       b ) (((b) & (fHSMask|fHSNorm|fHSHash)) == (fHS|fHSNorm))
#define FPopupHotspot(     b ) (((b) & (fHSMask|fHSNorm|fHSJump)) == (fHS|fHSNorm))

#define bLongMacro        (fHS        |fHSLong                       )
//
//
//
#define bLongMacroInv     (fHS        |fHSLong|fHSInv                )
//
//
//
#define bShortUidPopup     (fHS|fHSNorm                               )
#define bShortUidJump      (fHS|fHSNorm                       |fHSJump)
#define bShortHashPopup    (fHS|fHSNorm               |fHSHash        )
#define bShortHashJump     (fHS|fHSNorm               |fHSHash|fHSJump)
//                         (fHS|fHSNorm        |fHSInv                )
//                         (fHS|fHSNorm        |fHSInv        |fHSJump)
#define bShortInvHashJump  (fHS|fHSNorm        |fHSInv|fHSHash|fHSJump)
#define bShortInvHashPopup (fHS|fHSNorm        |fHSInv|fHSHash        )
//                         (fHS|fHSNorm|fHSLong                       )
//                         (fHS|fHSNorm|fHSLong               |fHSJump)
#define bLongHashPopup     (fHS|fHSNorm|fHSLong       |fHSHash        )
#define bLongHashJump      (fHS|fHSNorm|fHSLong       |fHSHash|fHSJump)
//                         (fHS|fHSNorm|fHSLong|fHSInv                )
//                         (fHS|fHSNorm|fHSLong|fHSInv        |fHSJump)
#define bLongInvHashPopup  (fHS|fHSNorm|fHSLong|fHSInv|fHSHash        )
#define bLongInvHashJump   (fHS|fHSNorm|fHSLong|fHSInv|fHSHash|fHSJump)

#define bEnd            0xFF  /* End of text */

// Upon encountering an embedded window with a class name of
// EW_CALLBACK_CLASS, a special EW will be created and the data for
// the embedded window will be saved.  Upon an attempt to render this
// embedded window, instead of actually creating a window, MediaView
// will execute the qde->lpfnHotspotCallback() routine with a hotspot
// of type HOTSPOT_EWSHOWN and with a pointer to the saved string
// containing the data for the embedded window.

#define EW_CALLBACK_CLASS "MVEWCallBack"

#ifndef CONTENTTYPE_DEFINED
#define CONTENTTYPE_DEFINED
enum CONTENTTYPE
{
  CONTENT_TEXT,
  CONTENT_BITMAP,
  CONTENT_WINDOW,
  CONTENT_UNKNOWN
};
#endif // CONTENTTYPE_DEFINED

// These first four hotspot types are public.
// They MUST correspond to those in MEDV14.H
#define HOTSPOT_STRING           0
#define HOTSPOT_HASH             1
#define HOTSPOT_POPUPHASH        2
#define HOTSPOT_UNKNOWN          3

// These next six are not public.
#define HOTSPOT_TOPICUID		 4
#define HOTSPOT_POPUPTOPICUID	 5
#define HOTSPOT_JI               6
#define HOTSPOT_POPUPJI          7
#define HOTSPOT_EWSHOWN          8 // Occurs when an embedded window with
                                   // the classname EW_CALLBACK_CLASS is shown.
#define HOTSPOT_EWHIDDEN         9 // Occurs when an embedded window with the
                                   // classname EW_CALLBACK_CLASS is hidden.

/* Function prototypes */

VOID PASCAL FAR GetMacMFCP (QMFCP qmfcp, unsigned char far * qb);
VOID PASCAL FAR GetMacMBHD (QMBHD qmbhd, unsigned char far * qb);

#endif // !OBJECTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\orkin.h ===
#ifdef MOS
#include <_DEBUG.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef ORKIN
#define ORKIN

/*****************************************************************************
*                                                                            *
*  ORKIN.H                                                                   *
*                                                                            *
*  Copyright (C) Microsoft Corporation 1991.                                 *
*  All Rights reserved.                                                      *
*                                                                            *
******************************************************************************
*                                                                            *
*  Module Description: DEBUGGING LIBRARY                                     *
*                                                                            *
******************************************************************************
*                                                                            *
*  Current Owner: DAVIDJES                                                   *
*                                                                            *
******************************************************************************
*                                                                            *
*  Revision History:                                                         *
*     -- Dec 1991 Created                                                    *
*     -- Mar 1992 Waynej Added assert description string                     *
*                                                                            *
*                                                                            *
******************************************************************************
*                                                                            *
*  Known Bugs: NONE                                                          *
*                                                                            *
******************************************************************************
*                                                                            *
*  How it could be improved:                                                 *
*                                                                            *
*****************************************************************************/
//
//      This only assumes you have included <windows.h> before <orkin>
//
#if defined(_DEBUG)

#if defined(_WIN32) || defined(_MAC)
#ifndef _loadds
#define _loadds
#endif
#endif

#ifndef EXPORT_API
#define EXPORT_API
#endif

//******************
//
//  ASSERT
//
//       usage:  assert(c) where the condition c is any expression of type BOOL
//  
//  notes:      An assertion is a logical proposition about the state space of
//  the program at a particular point in program execution.  Evaluation of
//  the condition MUST NOT have side effects!  (Otherwise your _DEBUG and
//  nondebug programs have different semantics).  Do not expect any value 
//  back from the assert.  For example, don't do "if (assert(f)) foo()"
//
//       A false condition implies an inconsistent or invalid program state.
//  If this occurs the assertion routine will display a message box giving
//  the file and line number of the failed assert.  The message box will
//  include options to ignore and continue or break into the debugger.
//  
//       When you break in the debugger you will be at an INT 3 instruction.
//       Increment the IP register to step over the INT 3 then step out of the
//       assertion routine.  You will return to the statement immediately following
//       the failed assert.  All symbolic information should be available.
//
//  Use asserts liberally!  The time they take to insert will be saved
//  tenfold over the time that would otherwise be required later to
//  track down pesky bugs.
//
//  The assertion routine is defined in ASSERT.C
//
//*******************

#ifdef MOS
// Reroute to stuff in _DEBUG.h
#define assert(x) Assert((int)(x))
#else
extern void far pascal _assertion(WORD wLine, LPSTR lpstrFile);

#define assert(f) ((f)?(void)0:_assertion(__LINE__,s_aszModule))
#define Assert(f) assert(f)
#define ITASSERT(f) assert(f)
#endif

//*******************
//
//  DEBUGGING OUTPUT
//
//      the following was ripped off from the \\looney\brothers skelapp2 project:
//
// InitializeDebugOutput(szAppName):
//
//      Read _DEBUG level for this application (named <szAppName>) from
//      win.ini's [_DEBUG] section, which should look like this:
//
//         [_DEBUG]
//         location=aux                 ; use OutputDebugString() to output
//         foobar=2                     ; this app has _DEBUG level 2
//         blorg=0                      ; this app has _DEBUG output disabled
//
//      If you want _DEBUG output to go to a file instead of to the AUX
//      device (or the debugger), use "location=>filename".  To append to
//      the file instead of rewriting the file, use "location=>>filename".
//
//      If _DEBUG is not #define'd, then the call to InitializeDebugOutput()
//      generates no code,
//
// TerminateDebugOutput():
//
//      End _DEBUG output for this application.  If _DEBUG is not #define'd,
//      then the call to InitializeDebugOutput() generates no code,
//
// DPF(szFormat, args...)
// CPF
//
//      If debugging output for this applicaton is enabled (see
//      InitializeDebugOutput()), print _DEBUG output specified by format
//      string <szFormat>, which may contain wsprintf()-style formatting
//      codes corresponding to arguments <args>.  Example:
//
//              DPF("in WriteFile(): szFile='%s', dwFlags=0x%08lx\n",
//              CPF     (LSPTR) szFile, dwFlags);
//
//      If the DPF statement occupies more than one line, then all
//      lines following the first line should have CPF before any text.
//      Reason: if _DEBUG is #define'd, DPF is #define'd to call _DPFx()
//      and CPF is #define'd to nothing, but if _DEBUG is not #define'd then
//      DPF and CPF are both #define'd to be // (comment to end of line).
//
// DPF2(szFormat, args...)
// DPF3(szFormat, args...)
// DPF4(szFormat, args...)
//
//      Like DPF, but only output the _DEBUG string if the _DEBUG level for
//      this application is at least 2, 3, or 4, respectively.
//
//  These output routines are defined in BUGOUT.C
//  
//*******************

/* _DEBUG printf macros */
#define	DPF		_DPF1
#define DPF1             _DPF1
#define DPF1             _DPF1
#define DPF2    _DPF2
#define DPF3    _DPF3
#define DPF4    _DPF4
#define CPF

/* prototypes */
#define InitializeDebugOutput _InitializeDebugOutput
#define TerminateDebugOutput _TerminateDebugOutput

void FAR PASCAL EXPORT_API _InitializeDebugOutput(LPSTR szAppName);
void FAR PASCAL EXPORT_API _TerminateDebugOutput(void);

void FAR EXPORT_API __cdecl _DPF1(LPSTR szFormat, ...);
void FAR EXPORT_API __cdecl _DPF2(LPSTR szFormat, ...);
void FAR EXPORT_API __cdecl _DPF3(LPSTR szFormat, ...);
void FAR EXPORT_API __cdecl _DPF4(LPSTR szFormat, ...);


#else
//******************
//
//  If debugging is not turned on we will define all debugging calls
//  into nothingness...
//
//******************

#define assert(f)
#define Assert(f)
#define ITASSERT(f)

/* _DEBUG printf macros */
#define DPF     0; / ## /
#define DPF1	0;
#define DPF2    0; / ## /
#define DPF3    0; / ## /
#define DPF4    0; / ## /
#define CPF     / ## /

/* stubs for debugging function prototypes */
#define InitializeDebugOutput(szAppName)        0
#define TerminateDebugOutput()                  0

#endif // _DEBUG

#endif // orkin

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\zeck.h ===
/*****************************************************************************
*                                                                            *
*  ZECK.H                                                                    *
*                                                                            *
*  Copyright (C) Microsoft Corporation 1990.                                 *
*  All Rights reserved.                                                      *
*                                                                            *
******************************************************************************
*                                                                            *
*  Module Intent                                                             *
*                                                                            *
*   Zeck compression routines for bitmaps & topic 2K blocks.
*                                                                            *
*****************************************************************************/

// This structure is passed to the compression routine to specify ranges
// in which to suppress compression:

#ifndef __ZECK_H__
#define __ZECK_H__

#ifdef __cplusplus
extern "C" {
#endif


#include "misc.h"
typedef struct struct_suppresszeck SUPPRESSZECK, FAR *QSUPPRESSZECK;

struct struct_suppresszeck {
  RB      rbSuppress; // beginning of range for suppression.
  WORD    cbSuppress; // number of bytes to suppress compression.
  RB      rbNewpos;   // pointer into dest buffer where suppressed range
                      // ended up after compression (an OUT param value).
  WORD    iBitdex;    // offset from rbNewpos of zeck code bits, used when
                      // back patching.
  QSUPPRESSZECK next; // next suppression range in this list.
};

#define BITDEX_NONE   ((WORD)-1)  // indicates no compression took place, and
                                  // backpatch should not adjust for the
                                  // code bits.

/* LcbCompressZeck -
 *
 *  This is the only entry point into zeck compression.  Compresses 'cbSrc'
 * bytes at 'rbSrc' into the buffer at 'rbDest', suppressing compression
 * for bytes specified by the qSuppress linked list.
 *
 * rbSrc - IN  far pointer to source buffer.
 * rbDest- IN  far pointer to dest buffer.
 * cbSrc - IN  count of bytes to be compressed.
 * cbDest- IN  limit count of bytes to put in rbDest - used to create
 *              the 2K topic blocks.
 * qulSrcUsed- OUT    count of src bytes compressed into rbDest (needed when
 *                     a cbDest limit is used).
 * qSuppress IN OUT   linked list of compression suppression specifiers,
 *                    the out value is where the suppression ranges ended
 *                    up in the rbDest buffer.
 *
 * RETURNS: length of compressed data put in rbDest, 0 for error.
 */
#define COMPRESS_CBNONE   0   // passed as cbDest when no limit is to apply.
#define COMPRESS_SUPPRESSNIL  NULL  // passed as qSuppress when no
                                     // suppression is desired

ULONG FAR PASCAL LcbCompressZeck( QB rbSrc, QB rbDest, ULONG cbSrc,
             ULONG cbDest, QUL qulSrcUsed, QSUPPRESSZECK qSuppress, LPVOID
			 lperrb);

BOOL FAR PASCAL FAllocateZeckGlobals( void );
void FAR PASCAL FreeZeckGlobals( void );

ULONG PASCAL FAR LcbSimpleCompressZeck(RB rbSrc, RB rbDest,
	ULONG cbSrc, LPVOID lperrb);

VOID FAR PASCAL VMemBackpatchZeck( QSUPPRESSZECK qsuppresszeck,
                                           ULONG ulOffset, ULONG ulValue );

// erinfox: comment out so we don't need def. for HF
//BOOL FAR PASCAL FDiskBackpatchZeck( HF hf, ULONG fcl, ULONG ulOffset,
//      WORD iBitdex, ULONG ulValue, BOOL fSaveLoc, LPVOID lperrb );

ULONG FAR PASCAL LcbUncompressZeck( RB rbSrc, RB rbDest, ULONG cbSrc,
	ULONG cbDest);





/***********************************************************************
MATTSMI 4/17/92 -- CALLBACK DEFNS PUT HERE SO THAT THE WMVC COMPILER CAN
GET STATUS INFORMATION DURING COMPRESSION
************************************************************************/
typedef BOOL (FAR PASCAL * lpfnPumpMessageQueue)(VOID);
typedef VOID (FAR PASCAL * lpfnPrintStatusMessage)(LPSTR);
typedef VOID (FAR PASCAL * lpfnMessageGetPutFunc)(VOID);

#ifdef __cplusplus
}
#endif


#endif // __ZECK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\orkin\critsec.h ===
#ifndef __CRITSEC_H__
#define __CRITSEC_H__


//
//  CRITSEC.H:   Wrapper class for critical sections
//
//
class CCriticalSection
{
public:
    // Constructor/Destructor
    CCriticalSection() { InitializeCriticalSection(&m_CriticalSection); }
    ~CCriticalSection() { DeleteCriticalSection(&m_CriticalSection); }

protected:
    CRITICAL_SECTION    m_CriticalSection;

public:
    inline operator CRITICAL_SECTION*() { return &m_CriticalSection; }

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\inc\_mvutil.h ===
/*****************************************************************************
*                                                                            *
*  _MVUTIL.H                                                                   *
*                                                                            *
*  Copyright (C) Microsoft Corporation 1992.                                 *
*  All Rights reserved.                                                      *
*                                                                            *
******************************************************************************
*                                                                            *
*  Module Intent                                                             *
*                                                                            *
*  Interfile declarations that are internal to MVUT                          *
*                                                                            *
******************************************************************************
*                                                                            *
*  Current Owner:  davej                                                     *
*                                                                            *
******************************************************************************
*
*  Revision History:
*
*       -- Mar 92       Created DAVIDJES
*		-- Aug 95		Merged file system, btree, etc into utilities
*
*****************************************************************************/

// requires mvopsys.h
// requires orkin.h
// requires misc.h

#ifndef __MVUTIL_H__
#define __MVUTIL_H__

#include <mem.h>
#include <objects.h>   // for object types and defines
#include <misc.h>
#include <mvsearch.h>	// for LFO type
#include <iterror.h>
#include <freelist.h>
#include <fileoff.h>
#include <wrapstor.h>
#include <font.h>

#ifdef __cplusplus
#include <itsort.h>
#endif


#ifdef __cplusplus
extern "C" {
#endif

#pragma pack(1)

/***************************************************************************\
*
*                                General Defines
*
****************************************************************************/

// These macros are temporary and will be removed when we typedef
// all our ints where they are supposed to be 16 bits - maha
	
#ifdef _32BIT

#if defined( _NT )
extern RC	RcFromLoadLibErr[];
#endif

#else
typedef HANDLE        HINSTANCE;
extern RC	RcFromLoadLibErr[HINSTANCE_ERROR];
#endif

/* pointer types */

typedef char FAR *    QCH;      // Guaranteed far pointer - not an SZ, an ST, or an LPSTR
typedef BYTE FAR *    QB;
typedef VOID FAR *    QV;
typedef SHORT  FAR *  QI;
typedef WORD FAR *    QW;
typedef LONG FAR *    QL;
typedef WORD FAR *    QUI;
typedef ULONG FAR *   QUL;
typedef DWORD FAR *   QDW;


typedef char *        PCH;      // "Native" pointer (depends on the model) - not an SZ, an ST, or an NPSTR
typedef VOID *        PV;
typedef SHORT  *      PI;
typedef WORD *        PW;
typedef LONG *        PL;

/* string types */

// These are the two main string types:
typedef unsigned char FAR * SZ; // 0-terminated string
typedef unsigned char FAR * ST; // byte count prefixed string

// Hey, perhaps others want this stuff below?
#ifdef _WIN32
	#define _INITIALIZECRITICALSECTION(lpcs)	InitializeCriticalSection(lpcs)
	#define _ENTERCRITICALSECTION(lpcs) 		EnterCriticalSection(lpcs)
	#define _LEAVECRITICALSECTION(lpcs) 		LeaveCriticalSection(lpcs)
	#define _DELETECRITICALSECTION(lpcs) 		DeleteCriticalSection(lpcs)
	#define _INTERLOCKEDINCREMENT(lplong)		InterlockedIncrement(lplong)
	#define _INTERLOCKEDDECREMENT(lplong)		InterlockedDecrement(lplong)
#else
	#define _INITIALIZECRITICALSECTION(lpcs) 	(*(lpcs)=-1L)
	#define _ENTERCRITICALSECTION(lpcs)		 	verify((++(*(lpcs)))==0L)
	#define _LEAVECRITICALSECTION(lpcs)		 	(*(lpcs)--)
	#define _DELETECRITICALSECTION(lpcs)		(*(lpcs)=0L)
	#define _INTERLOCKEDINCREMENT(lplong)		(++(*(lplong)))
	#define _INTERLOCKEDDECREMENT(lplong)		(--(*(lplong)))
	typedef LONG CRITICAL_SECTION;
#endif	

/* other types */

/***************************************************************************\
*
*                                    Misc
*
\***************************************************************************/

/*****************************************************************************
*                                                                            *
*                               Defines                                      *
*                                                                            *
*****************************************************************************/

// Defines for use in compressing topics and decompressing them
#define MAXTEXTBLOCK 	32768L				// Maximum amount of data in uncompressed block
#define TOPICFILENAME 	">%08lX"		// we want these to appear before the system files
#define SUBTOPICSFILENAME "#SUBTOPICS"	// Subtopics string list filename

#define MAXGROUPID		7000000			// Let's limit groups to 7,000,000 items
/*****************************************************************************
*                                                                            *
*                               Prototypes                                   *
*                                                                            *
*****************************************************************************/

#ifdef MOSMAP // {
// Multithreaded error support
EXTC RC	MosSetViewerError(RC rc, LPSTR sz, int l) ;
EXTC RC MosGetViewerError(VOID) ;
#endif // MOSMAP }

/*******************************************************************
 *                                                                 *
 *                          STR.C                                  *
 *                                                                 *
 *******************************************************************/

SZ    FAR PASCAL  SzNzCat( SZ, SZ, WORD);
SHORT   FAR PASCAL  WCmpiScandSz( SZ, SZ );
SHORT   FAR PASCAL  WCmpiSz( SZ, SZ, BYTE far * );
SHORT 	FAR PASCAL 	WCmpiSnn(SZ, SZ, BYTE far *, SHORT, SHORT);
SHORT   FAR PASCAL  WCmpSt( ST, ST );


/*******************************************************************
 *                                                                 *
 *                          BTREE.C                                *
 *                                                                 *
 *******************************************************************/

PUBLIC int PASCAL FAR StrFntMappedLigatureComp(SZ, SZ, LPVOID);

/*******************************************************************
 *                                                                 *
 *                          FID.C                                  *
 *                                                                 *
 *******************************************************************/

extern WORD _rgwOpenMode[4];
extern WORD _rgwPerm[4] ;
extern WORD _rgwShare[4];

RC     FAR PASCAL  RcGetDOSError(void);


/*******************************************************************
 *                                                                 *
 *                          VFILE.C                                *
 *                                                                 *
 *******************************************************************/

#define VFF_TEMP 		1
#define VFF_FID  		2
#define VFF_READ 		4
#define VFF_READWRITE           8
#define VFF_DIRTY		16

#define VFOPEN_ASTEMP 		1
#define VFOPEN_ASFID  		2
#define VFOPEN_READ	        4
#define VFOPEN_READWRITE 	8

typedef HANDLE HVF;

// @DOC PRIVATE
// @struct SHAREDBUFFER | Memory buffer that can be shared by many
//		users.  When user is completely finished with memory block,
//		the next person waiting for it will be granted permission
//		to start using it in a multi-threaded environment.
typedef struct _sharedbuffer_t
{
 	HANDLE hBuffer;
 	LPVOID lpvBuffer;	// @field Actual buffer memory
	LONG lcbBuffer;		// @field Size of buffer
	LONG lCursor;
	CRITICAL_SECTION cs;// @field Critical section for monitoring shared use
} SHAREDBUFFER, FAR * LPSHAREDBUFFER;


// @DOC PRIVATE
// @struct VFILE | Virtual file structure.  Files can exist in a temp file
//		or inside a parent (M20) file.  Information about the file is kept here.
//		[P] is important if file is in Parent, [T] for Temporary.
typedef struct _vfile_hr
{	
	DWORD dwFlags;			// @field Any of the VFF_ flags   		[P, T]
	FILEOFFSET foEof;		// @field Size of file (loc'n of EOF) 	[P, T]
	FILEOFFSET foCurrent;	// @field Current temp file pointer		[   T]
	FILEOFFSET foBase;  	// @field Base offset into parent file 	[P   ]
	FILEOFFSET foBlock;		// Maximum file size in parent  		[P   ]
	FM fmTemp;				// @field Moniker of temp file			[   T]
	FID fidParent;			// @field Parent File 					[P   ]
	FID fidTemp;			// @field Temp File						[   T]
	CRITICAL_SECTION cs;  	// @field An unused LONG if not in _WIN32	
	LPSHAREDBUFFER lpsb; 	// @field Memory to use in tempfile xfers
} VFILE, FAR * QVFILE;

HVF		FAR EXPORT_API VFileOpen( FID, FILEOFFSET, FILEOFFSET, FILEOFFSET, 
			DWORD, LPSHAREDBUFFER, LPERRB );
RC 		PASCAL FAR EXPORT_API VFileSetTemp( HVF );
RC 		PASCAL FAR EXPORT_API VFileSetBase( HVF, FID, FILEOFFSET, FILEOFFSET );
RC 		PASCAL FAR EXPORT_API VFileSetEOF( HVF, FILEOFFSET );
FILEOFFSET PASCAL FAR EXPORT_API VFileGetSize( HVF, LPERRB );
DWORD 	PASCAL FAR EXPORT_API VFileGetFlags( HVF, LPERRB );
LONG 	PASCAL FAR EXPORT_API VFileSeekRead( HVF, FILEOFFSET, LPVOID, DWORD, LPERRB );
LONG 	PASCAL FAR EXPORT_API VFileSeekWrite( HVF, FILEOFFSET, LPVOID, DWORD, LPERRB );
RC 		PASCAL FAR EXPORT_API VFileClose( HVF );
RC 		PASCAL FAR EXPORT_API VFileAbandon( HVF );
RC 		PASCAL FAR EXPORT_API VFileSetBuffer( LPVOID lpvBuffer, LONG lcbBuffer );

/*******************************************************************
 *                                                                 *
 *                          FILESYS.C                  			   *
 *                                                                 *
 *******************************************************************/

#define wDefaultFreeListSize 510	// 510 entries in free list structure
#define MAXSUBFILES 128				// Start with no more than 128 subfiles opened (can grow)
#define SCRATCHBUFSIZE 60000L		// Mainly used for temporary file copying

// @DOC PRIVATE
// @struct SF | Subfile element.  An array of these is created by the file system.
//		Since the same file can be opened multiple times, each instance needs to
//		know where it's own current file pointer is.  An HF is simply an index
//		into the file system's array of these SF structures.
typedef struct _subfile_t
{
 	FILEOFFSET foCurrent;	// @field Current file pointer.
	HSFB hsfb;				// @field The actual subfile block for the file in question.
} SF, FAR * QSF;

// GLOBALS
extern SF FAR * mv_gsfa;			// Subfile headers (better/faster than globalalloc'ing them)
extern LONG mv_gsfa_count;			// User count, equals number of MV titles opened
extern CRITICAL_SECTION mv_gsfa_cs; // Ensure accessing the array is OK in multi-threaded environment

// @DOC PRIVATE
// @struct SFH | System subfile header (only one system file per M20 file, and it's the directory
//		btree.
typedef struct _sfh_t
{
	FILEOFFSET foBlockSize;		// @field Size of file on disk, includes header
	BYTE bFlags;				// @field SFH_ flags.  Depending on flags, more data may follow
	BYTE Pad1;
	BYTE Pad2;
	BYTE Pad3;
} SFH, FAR * QSFH;

// @DOC PRIVATE
// @struct FSH | File System Header.  This header is the first item in an M20 file.
typedef struct _fsh_t
{
 	USHORT wMagic;			// @field The magic number for a file system
	BYTE bVersion;			// @field Version number for this file type.
	BYTE bFlags;			// @field Any _FSH flags	
	FILEOFFSET foDirectory;	// @field Offset to system btree
	FILEOFFSET foFreeList;	// @field Offset to free list
	FILEOFFSET foEof;		// @field Next free spot in M20 file for new info
	SFH sfhSystem;			// @field System btree file header (for size of sys btree)
} FSH, FAR * QFSH;

// @DOC PRIVATE
// @struct FSHR | File system RAM header.  All info important to an opened file system.
typedef struct _fshr_t
{
	HBT hbt;				// @field File system btree
	FID fid;				// @field File ID of M20 file
	FM fm;					// @field Name of M20 file
	HFREELIST hfl;			// @field Free list
	HSFB hsfbFirst;			// @field First opened subfile in linked list
	HSFB hsfbSystem;		// @field System (btree dir)
	CRITICAL_SECTION cs;	// @field When doing subfile seek/read combos, ensure OK
	FSH fsh;				// @field File system disk header
	SF FAR * sfa;			// @field Subfile headers array
	SHAREDBUFFER sb;		// @field Buffer, used anywhere we need scratch memory	
} FSHR, FAR * QFSHR;


// These should be moved to freelist.c once FID's are common in mvutils
HFREELIST	PASCAL FAR FreeListInitFromFid	( FID, LPERRB );
LONG		PASCAL FAR FreeListWriteToFid	( HFREELIST, FID, LPERRB );
 
/*******************************************************************
 *                                                                 *
 *                          SUBFILE.C                  			   *
 *                                                                 *
 *******************************************************************/

// @DOC PRIVATE
// @struct FILE_REC | Mirrors information saved as the data portion in the file 
//		directory system btree for any particular entry.  If any more info is
//		added to a directory entry, it should be added here.
typedef struct _file_rec_t
{
	char szData[14];    // @field Actual data stored in btree.  Max size for variable width offset + length + byte (6 + 6 + 1).
	FILEOFFSET foStart;	// @field Copy of file offset
	FILEOFFSET foSize;	// @field Copy of file size
	BYTE bFlags;		// @field Copy of flags
} FILE_REC;

// @DOC PRIVATE
// @struct SFB | Subfile block RAM header.  One per opened subfile.
typedef struct _sfb_t
{	
	HVF hvf;				// @field Virtual file handle - actual data may be in fs or temp
	FILEOFFSET foHeader;	// @field Points to disk header in fs
	HFS hfs;				// @field File system this lives in
	HSFB hsfbNext;			// @field Next subfile (linked list of opened files)
	WORD wLockCount;		// @field Number of HF's using file
	SFH sfh;				// @field Copy of disk file header (not extra data)
	BYTE bOpenFlags;		// @field SFO_ flags
	CHAR rgchKey[1];		// @field File key name
} SFB, FAR * QSFB;

RC 		PASCAL FAR EXPORT_API RcCloseEveryHf(HFS hfs);
RC 		PASCAL FAR EXPORT_API RcFlushEveryHf(HFS hfs);

/*******************************************************************
 *                                                                 *
 *                          BTREE STUFF                  		   *
 *                                                                 *
 *******************************************************************/

/***************************************************************************\
*
*                               BTREE Defines
*
\***************************************************************************/

/* default btree record format */
#define rgchBtreeFormatDefault  "z4"

/* cache flags */
#define fCacheDirty   0x01
#define fCacheValid   0x04
#define fBTCompressed 0x08
#define fBTinRam      0x10


/***************************************************************************\
*
*                               BTREE Macros
*
\***************************************************************************/

/* Get the real size of a cache block */
#define CbCacheBlock( qbthr ) \
      ( sizeof( CACHE_BLOCK ) - sizeof( DISK_BLOCK ) + (qbthr)->bth.cbBlock )

/* convert a BK into a file offset */
// We now should only use FoFromBk!!!
//#define LifFromBk( bk, qbthr ) ( (LONG)(bk) * (LONG)(qbthr)->bth.cbBlock + (LONG)sizeof( BTH ) )

/* Btrees are limited to 268 megs for block sizes of 4096... no need for this below
   for now, but keep it for the future... */
#define FoFromBk( bk, qbthr) \
		(FoAddDw(FoMultDw((DWORD)(bk),(DWORD)(qbthr)->bth.cbBlock),(DWORD)sizeof(BTH)) )

/* get a pointer to the cache block cached for the given level */
#define QCacheBlock( qbthr, wLevel ) \
        ((QCB)( (qbthr)->qCache + (wLevel) * CbCacheBlock( qbthr ) ))


/* get and set prev and next BK (defined for leaf blocks only) */

#define BkPrev( qcb )         *(LPUL)((qcb)->db.rgbBlock)
#define BkNext( qcb )         *(((LPUL)((qcb)->db.rgbBlock)) + 1 )
#define SetBkPrev( qcb, bk )  BkPrev( qcb ) = bk
#define SetBkNext( qcb, bk )  BkNext( qcb ) = bk

// For btree map functions: returns byte number of x-th btree map record //
#define LcbFromBk(x) ((LONG)sizeof( short ) + x * sizeof( MAPREC ))

/***************************************************************************\
*
*                               BTREE Types
*
\***************************************************************************/

// Critical structures that gets messed up in /Zp8
#pragma pack(1)

/* This leading byte to signal the following font number */
#define EMBEDFONT_BYTE_TAG				3


/*
  Header of a btree file.
*/
typedef struct _btree_header
  {
  USHORT  wMagic;
  BYTE  bVersion;
  BYTE  bFlags;                       // r/o, open r/o, dirty, isdir
  SHORT cbBlock;                      // # bytes in a disk block
  CHAR  rgchFormat[ wMaxFormat + 1 ]; // key and record format string
  BK    bkFirst;                      // first leaf block in tree
  BK    bkLast;                       // last leaf block in tree
  BK    bkRoot;                       // root block
  BK    bkFree;                       // head of free block list
  BK    bkEOF;                        // next bk to use if free list empty
  SHORT cLevels;                      // # levels currently in tree
  LONG  lcEntries;                    // # keys in btree

  //---- New Header Entries For Btree file version 4.0 -----
  DWORD	dwCodePageID;				// ANSI code page no.
  LCID	lcid;						// WIN32 locale ID (used for sorting).

	// If rgchFormat[0] != KT_EXTSORT, then the values for the following
	// two members are invalid.
  DWORD	dwExtSortInstID;			// External sort object specified by
									//	btree caller for all key comparisons
									//	during btree creation and search.
  DWORD	dwExtSortKeyType;			// Identifies the key datatype that the
									//	sort object understands.
  DWORD	dwUnused1;
  DWORD	dwUnused2;
  DWORD	dwUnused3;
  } BTH;
  
/*
  In-memory struct referring to a btree.
*/
typedef struct _bthr
  {
  BTH    bth;                          // copy of header from disk
  HF     hf;                           // file handle of open btree file
  SHORT  cbRecordSize;                 // 0 means variable size record
  HANDLE ghCache;                      // handle to cache array
  QB     qCache;                       // pointer to locked cache
  LPVOID FAR *lrglpCharTab;            // Pointer to array of LPCHARTAB
									   //	(used by KT_SZMAP).

#ifdef __cplusplus
  IITSortKey	*pITSortKey;		   // Pointer to external sort instance
									   //	object (used by KT_EXTSORT).
#else
  LPVOID		pITSortKey;			   // Hack to make .c files compile.
#endif

  // KT specific routines
  BK    (FAR PASCAL *BkScanInternal)( BK, KEY, SHORT, struct _bthr FAR *, QW, LPVOID);
  RC    (FAR PASCAL *RcScanLeaf)( BK, KEY, SHORT, struct _bthr FAR *, QV, QBTPOS );
  } BTH_RAM, FAR *QBTHR;

/*
  Btree leaf or internal node.  Keys and records live in rgbBlock[].
  See btree.doc for details.
*/
typedef struct _disk_btree_block
  {
  short  cbSlack;                      // unused bytes in block
  short  cKeys;                        // count of keys in block
  BYTE  rgbBlock[1];                  // the block (real size cbBlock - 4)
  } DISK_BLOCK;

/*
  Btree node as it exists in the in-memory cache.
*/
typedef struct _cache_btree_block
  {
  BK          bk;                     // IDs which block is cached
  BYTE        bFlags;                 // dirty, cache valid 
  BYTE        bCompressed;            // Is the B-tree compressed?
  DISK_BLOCK  db;
  } CACHE_BLOCK, FAR *QCB;

/*
  One record of a btree map.
*/
typedef struct _btree_map_record      // One record of a btree map
  {
  LONG         cPreviousKeys;         // total # of keys in previous blocks
  BK           bk;                    // The block number
  } MAPREC, FAR *QMAPREC;

/*
  Auxiliary index of btree leaves.
  Used for indexing a given % of the way into a btree.
*/
typedef struct _btree_map
  {
  short    cTotalBk;
  MAPREC table[1];                    // sorted by MAPREC's cPreviousKeys field
  } MAPBT, FAR *QMAPBT;               // and is in-order list of leaf nodes

// Critical structures that gets messed up in /Zp8
#pragma pack()


/***************************************************************************\
*
*                      BTREE Function Prototypes
*
\***************************************************************************/

SHORT         PASCAL FAR CbSizeRec     ( QV, QBTHR );
QCB           PASCAL FAR QFromBk       ( BK, SHORT, QBTHR, LPVOID );

RC            PASCAL FAR RcGetKey      ( QV, KEY, KEY *, KT );
SHORT         PASCAL FAR WCmpKey       ( KEY, KEY, QBTHR );
SHORT         PASCAL FAR CbSizeKey     ( KEY, QBTHR, BOOL );

RC            PASCAL FAR FReadBlock    ( QCB, QBTHR );
RC            PASCAL FAR RcWriteBlock  ( QCB, QBTHR );

BK            PASCAL FAR BkAlloc       ( QBTHR, LPVOID);
void          PASCAL FAR FreeBk        ( QBTHR, BK );

RC            PASCAL FAR RcSplitLeaf   ( QCB, QCB, QBTHR );
void          PASCAL FAR SplitInternal ( QCB, QCB, QBTHR, QW );

RC            PASCAL FAR RcInsertInternal( BK, KEY, SHORT, QBTHR );

RC PASCAL FAR RcFlushCache    ( QBTHR );
RC FAR PASCAL RcMakeCache     ( QBTHR );

// overkill - function to verify integrity of cache
BOOL FAR PASCAL IsCacheValid(QBTHR qbthr, QFSHR qfshr);



// KT specific routines

BK FAR PASCAL BkScanSzInternal( BK, KEY, SHORT, QBTHR, QW , LPVOID);
RC FAR PASCAL RcScanSzLeaf    ( BK, KEY, SHORT, QBTHR, QV, QBTPOS );

BK FAR PASCAL BkScanLInternal ( BK, KEY, SHORT, QBTHR, QW , LPVOID);
RC FAR PASCAL RcScanLLeaf     ( BK, KEY, SHORT, QBTHR, QV, QBTPOS );

BK FAR PASCAL BkScanSziInternal ( BK, KEY, SHORT, QBTHR, QW, LPVOID );
RC FAR PASCAL RcScanSziLeaf     ( BK, KEY, SHORT, QBTHR, QV, QBTPOS );

BK FAR PASCAL BkScanVstiInternal ( BK, KEY, SHORT, QBTHR, QW, LPVOID );
RC FAR PASCAL RcScanVstiLeaf     ( BK, KEY, SHORT, QBTHR, QV, QBTPOS );

BK FAR PASCAL BkScanSziScandInternal( BK, KEY, SHORT, QBTHR, QW, LPVOID );
RC FAR PASCAL RcScanSziScandLeaf    ( BK, KEY, SHORT, QBTHR, QV, QBTPOS );

RC FAR PASCAL RcScanCMapLeaf(BK, KEY, SHORT, QBTHR, QV, QBTPOS);
BK FAR PASCAL BkScanCMapInternal(BK, KEY, SHORT, QBTHR, QW, LPVOID);
int PASCAL FAR StringJCompare(DWORD, LPBYTE, int, LPBYTE, int);

RC FAR PASCAL RcScanExtSortLeaf(BK, KEY, SHORT, QBTHR, QV, QBTPOS);
BK FAR PASCAL BkScanExtSortInternal(BK, KEY, SHORT, QBTHR, QW, LPVOID);


/***************************************************************************\
*
*                      IOFTS.C
*
\***************************************************************************/

#ifndef READ
#define	READ	0		// File opened for read-only
#endif

#ifdef _32BIT
#define READ_WRITE 2
#endif

typedef	HANDLE            	GHANDLE;
typedef GHANDLE				HFPB;
typedef	BYTE	FAR *       LRGB;

/* Compound file system related macros and typedef */

#define	FS_SYSTEMFILE		1
#define	FS_SUBFILE			2
#define	REGULAR_FILE		3
#define	cbIO_ERROR	((WORD)-1)	// Low-level I/O error return.
#define	cbMAX_IO_SIZE	((WORD)32767)	// Largest physical I/O I can do.

/*
#ifdef DLL	// {
#define LPF_HFCREATEFILEHFS		HfCreateFileHfs
#define LPF_RCCLOSEHFS    		RcCloseHfs
#define LPF_HFOPENHFS     		HfOpenHfs
#define LPF_RCCLOSEHF     		RcCloseHf
#define LPF_LCBREADHF     		LcbReadHf
#define LPF_LCBWRITEHF    		LcbWriteHf
#define LPF_LSEEKHF       		DwSeekHf
#define LPF_RCFLUSHHF			RcFlushHf
#define LPF_LCBSIZEHF     		LcbSizeHf
#define	LPF_GETFSERR			RcGetFSError
#define	LPF_HFSOPENSZ     		HfsOpenSz

#else

#define	LPF_HFSCREATEFILESYS 	VfsCreate
#define LPF_RCCLOSEHFS    		RcCloseHfs
#define LPF_HFCREATEFILEHFS 	HfCreateFileHfs
#define LPF_HFSOPENSZ     		HfsOpenSz
#define LPF_HFOPENHFS     		HfOpenHfs
#define LPF_RCCLOSEHF     		RcCloseHf
#define LPF_LCBREADHF     		LcbReadHf
#define LPF_LCBWRITEHF    		LcbWriteHf
#define LPF_LSEEKHF       		DwSeekHf
#define LPF_RCFLUSHHF       	RcFlushHf
#define LPF_LCBSIZEHF     		LcbSizeHf
#define	LPF_GETFSERR			RcGetFSError
#endif	//  } LOMEM
*/

/* The file I/O buffer structure. This is to minimize I/O time
 * The allocated buffer should be right after the structure
 * ie. the memory allocation call should be:
 *     alloc (BufSize + sizeof(FBI)
 * or everything will fail
 */

#ifdef _WIN32
#define HFILE_GENERIC	HANDLE
#define HFILE_GENERIC_ERROR	((HANDLE)-1)
#else 
#define HFILE_GENERIC	HFILE
#define HFILE_GENERIC_ERROR	HFILE_ERROR
#endif


typedef	struct	FileBufInfo {
	GHANDLE	hStruct;	/* Structure's handle. MUST BE 1ST FIELD */
	DWORD lcByteWritten; /* How many bytes are written using this buffer */
	WORD  cbBufSize;	/* Size of the buffer */
	HFILE_GENERIC hFile;		/* DOS file handle */
	FILEOFFSET fo;
	FILEOFFSET foExtent;
	LRGB lrgbBuf;

	/* TO BE DELETED */
	HFPB hfpb;
	WORD	ibBuf;		
	WORD	cbBuf;
}	FBI,
	FAR *LPFBI;


/* File related functions */

PUBLIC RC FAR PASCAL FileExist (HFPB, LPCSTR, int);
PUBLIC HFPB FAR PASCAL FileCreate (HFPB, LPCSTR, int, LPERRB);
PUBLIC HFPB FAR PASCAL FileOpen (HFPB, LPCSTR, int, int, LPERRB);
PUBLIC FILEOFFSET FAR PASCAL FileSeek(HFPB, FILEOFFSET, WORD, LPERRB);
PUBLIC LONG FAR PASCAL FileRead(HFPB, LPV, LONG, LPERRB);
PUBLIC LONG FAR PASCAL FileWrite (HFPB, LPV, LONG, LPERRB);
PUBLIC LONG FAR PASCAL FileSeekRead(HFPB, LPV, FILEOFFSET, LONG, LPERRB);
PUBLIC LONG FAR PASCAL FileSeekWrite (HFPB, LPV, FILEOFFSET, LONG, LPERRB);
PUBLIC FILEOFFSET FAR PASCAL FileSize(HFPB hfpb, LPERRB lperrb);
PUBLIC FILEOFFSET FAR PASCAL FileOffset(HFPB hfpb, LPERRB lperrb);
PUBLIC int FAR PASCAL FileFlush(HFPB);
PUBLIC RC FAR PASCAL FileClose(HFPB);
PUBLIC RC FAR PASCAL FileUnlink (HFPB, LPCSTR, int);
PUBLIC VOID SetFCallBack (HFPB, INTERRUPT_FUNC, LPV);
PUBLIC VOID PASCAL FAR GetFSName(LSZ, LSZ, LSZ FAR *, LSZ);
PUBLIC HFS FAR PASCAL GetHfs(HFPB, LPCSTR, BOOL, LPERRB);
PUBLIC int PASCAL FAR IsFsName (LSZ);
PUBLIC LPSTR FAR PASCAL CreateDefaultFilename(LPCSTR, LPCSTR, LPSTR);
PUBLIC HFS FAR PASCAL HfsFromHfpb(HFPB hfpb);

KEY PASCAL FAR EXPORT_API NewKeyFromSz(LPCSTR sz);
void PASCAL FAR EXPORT_API GetFrData(FILE_REC FAR *pfr);




/* File buffer related functions */
PUBLIC LPFBI PASCAL FAR EXPORT_API FileBufAlloc (HFPB, WORD);
PUBLIC int PASCAL FAR FileBufFlush (LPFBI);
PUBLIC VOID PASCAL FAR FileBufFree (LPFBI);
PUBLIC	BOOL FAR PASCAL FileBufFill (LPFBI, LPERRB);
PUBLIC	BOOL FAR PASCAL FileBufBackPatch(LPFBI, LPV, FILEOFFSET, WORD);
PUBLIC	BOOL FAR PASCAL FileBufRewind(LPFBI);

// Be sure to call FreeHfpb when done with an HFPB that was created
// via one of the FbpFromXXXX calls.
PUBLIC HSFB PASCAL FAR FpbFromHfs(HFS hfsHandle, LPERRB lperrb);
PUBLIC HSFB PASCAL FAR FpbFromHf(HF hfHandle, PHRESULT phr);
PUBLIC DWORD PASCAL FAR FsTypeFromHfpb(HFPB hfpb);
PUBLIC VOID PASCAL FAR FreeHfpb(HFPB hfpb);


/*************************************************************************
 *
 *	Block Memory Management Functions Prototype
 *
 *************************************************************************/

typedef struct BLOCK {
    HANDLE hStruct;             /* Handle to this structure */
    struct BLOCK FAR *lpNext;   /* Pointer to next block */
    int wStamp;
} BLOCK, FAR *LPBLOCK;

typedef struct {
    HANDLE hStruct;             /* Handle to this structure */
    int  wStamp;                /* For block consistency checking */
    struct BLOCK FAR *lpHead;   /* Head of block list */
    struct BLOCK FAR *lpCur;    /* Current block */
    LPB lpbCurLoc;              /* Pointer to current data location */
    DWORD cBytePerBlock;        /* Number of bytes per block */
    DWORD cByteLeft;            /* How many bytes left */
    DWORD lTotalSize;
    WORD wElemSize;             /* Element size */
    WORD cMaxBlock;             /* Maximum number of blocks */
    WORD cCurBlockCnt;          /* Current number of blocks */
    WORD fFlag;                 /* Various block flags */
} BLOCK_MGR,
  FAR *LPBLK;

#define BLOCKMGR_ELEMSIZE(lpblk)    ((lpblk)->wElemSize)
#define BLOCKMGR_BLOCKSIZE(lpblk)	((lpblk)->cBytePerBlock)
#define BlockRequest(lpblk, cb, cbExtra)	BlockCopy(lpblk, NULL, cb, cbExtra)


LPB PASCAL FAR BlockGetOrdinalBlock (LPVOID lpBlockHead, WORD iBlock);
PUBLIC LPB PASCAL FAR BlockReset (LPV);
PUBLIC VOID PASCAL FAR BlockFree (LPV);
PUBLIC LPV PASCAL FAR BlockInitiate (DWORD, WORD, WORD, int);
PUBLIC LPV PASCAL FAR BlockCopy (LPV, LPB, DWORD, WORD);
PUBLIC LPV PASCAL FAR BlockGetElement(LPV);
PUBLIC int PASCAL FAR BlockGrowth (LPV);
PUBLIC LPB PASCAL FAR BlockGetLinkedList(LPV);
PUBLIC LPVOID PASCAL FAR BlockGetBlock (LPV, DWORD);
PUBLIC VOID PASCAL FAR SetBlockCount (LPV lpBlock, WORD count);

// hashing-related functions
PUBLIC DWORD FAR PASCAL DwordFromSz(LPCSTR szKey);
PUBLIC HASH FAR PASCAL HashFromSz(LPCSTR szKey);

// miscellaneous
PUBLIC int FAR PASCAL StripSpaces(LPSTR szName);

// Byte Packing
int PASCAL FAR EXPORT_API PackBytes (LPB lpbOut, DWORD dwIn);
int PASCAL FAR EXPORT_API UnpackBytes (LPDWORD lpdwOut, LPB lpbIn);


/*******************************************************************
 *                                                                 *
 *                          FCPARSE.C                              *
 *                                                                 *
 *******************************************************************/
// generic FC parsing routine: one command at a time

// arbitrary upper limit on total number of leaf nodes in object tree.  Only if heavy use
// is made of tables within tables, will it be possible to reach this limit.
#define cChildLeafMax (cColumnMax * 8)
typedef struct tagFCPARSE
{
	LPBYTE  lpbNextCmd;    
	LPCHAR  lpchNext;

	SHORT	iChild;
	SHORT	iChildMax;  // (child and column mean same thing)

	LPBYTE  rglpbCmd[cChildLeafMax];    // offset into command table (for child objects)
	LPCHAR  rglpchText[cChildLeafMax];    // offset into command table (for child objects)
} FCPARSE, FAR *LPFCPARSE;


/*************************************************************************
 *  @doc    INTERNAL COMMON
 *
 *  @func   BOOL FAR PASCAL | FcParseInit |
 *		Prepare to parse a MediaView FC
 *
 *  @parm   LPBYTE | qbObj |
 *      Pointer to memory buffer holding MV FC to be parsed
 *
 *  @parm   DWORD | dwObj |
 *      Total buffer's size
 *
 *  @parm   LPFCPARSE | lpfcp |
 *      Pointer to FCPARSE structure to hold parse state
 *************************************************************************/
BOOL FAR PASCAL FcParseInit(LPBYTE qbObj, DWORD dwObj, LPFCPARSE lpfcp);

/*************************************************************************
 *  @doc    INTERNAL COMMON
 *
 *  @func   LPCHAR FAR PASCAL | FcParseNextCmd |
 *		Get the next command or text string in the object.  The return
 *  pointer always points to a CHAR in the text section of an Fc.  If this
 *  character is zero, this indicates a command, and the lpbCom param will 
 *  have been filled with a pointer to the corresponding command data, else it
 *  is NULL.
 *  It is up to the app to process the command arguments after this function
 *  returns.
 *
 *  @parm   LPFCPARSE | lpfcp |
 *      Pointer to FCPARSE structure holding current parse state
 *
 *  @parm   LPBYTE FAR * | lpbCom |
 *      NULL if pointing to text, else points to command data
 *************************************************************************/
LPCHAR FAR PASCAL FcParseNextCmd(LPFCPARSE lpfcp, LPBYTE FAR *lpbCom);


////////// FONT TABLE AND CHAR TAB STUFF ///////////////////

HANDLE FAR PASCAL hReadFontTable (HANDLE, VOID FAR *);
PUBLIC VOID PASCAL FAR CharMapOffsetToPointer (QFONTTABLE qFontTable);
PUBLIC VOID PASCAL FAR CharMapPointerToOffset (QFONTTABLE qFontTable);
PUBLIC LPCTAB EXPORT_API FAR PASCAL MVCharTableLoad (HFPB, LSZ, LPERRB);
PUBLIC LPCTAB EXPORT_API FAR PASCAL MVCharTableGetDefault (LPERRB);
PUBLIC VOID EXPORT_API FAR PASCAL MVCharTableDispose (LPCTAB);
PUBLIC ERR EXPORT_API PASCAL FAR MVCharTableFileBuild (HFPB, LPCTAB, LSZ);
PUBLIC  LPCTAB EXPORT_API FAR PASCAL MVCharTableIndexLoad(HANDLE, LSZ, LPERRB);


////////// FILESORT STUFF ///////////////////

typedef HRESULT (PASCAL FAR * FNSCAN)(LPFBI, LPB, LPV);
typedef int (PASCAL FAR * FNSORT)(LPSTR, LPSTR, LPV);

HRESULT PASCAL FileSort (HFPB hfpb, LPB Filename, 
    STATUS_FUNC PrintStatusFunc, INTERRUPT_FUNC lpfnInterrupt,
    LPV lpInterruptParm, FNSORT fnSort, LPVOID lpSortParm,
    FNSCAN fnScan, LPVOID lpScanParam);


//-------------------------------------------------------------
//------			 COMMON\ITUTILS.CPP STUFF			-------
//-------------------------------------------------------------

HRESULT FAR PASCAL ReallocBufferHmem(HGLOBAL *phmemBuf, DWORD *pcbBufCur,
															DWORD cbBufNew);
void FAR PASCAL SetGrfFlag(DWORD *pgrf, DWORD fGrfFlag, BOOL fSet);
LPSTR MapSequentialReadFile(LPCSTR szFilename, LPDWORD pdwFileSize);

// We use our own simplified version so that the linker doesn't pull in
// CRT startup code from LIBCMT.LIB.
int __cdecl _it_wcsicmp(const wchar_t *dst, const wchar_t *src);


#pragma pack()

#ifdef __cplusplus
}
#endif

#endif //__MVUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\orkin\assert.c ===
/*****************************************************************************
*                                                                            *
*  ASSERT.C                                                                  *
*                                                                            *
*  Copyright (C) Microsoft Corporation 1991 - 1994.                          *
*  All Rights reserved.                                                      *
*                                                                            *
******************************************************************************
*                                                                            *
*  Module Description: ASSERTION ROUTINES FOR ORKIN DEBUGGING LIBRARY        *
*                                                                            *
******************************************************************************
*                                                                            *
*  Previous Owner: DavidJes                                                  *
*  Current  Owner: RHobbs                                                    *
*                                                                            *
*****************************************************************************/


#include <mvopsys.h>
#include <orkin.h>

// The following is missing the second "void" in windows.h which
// results in a "No Prototype" warning by the compiler

#ifndef _32BIT
void    FAR PASCAL DebugBreak(void);
#endif


#ifdef _DEBUG

void EXPORT_API far pascal _assertion(WORD wLine, LPSTR lpstrFile)
{
   static char szExitMsg[180];

   LPSTR lpstrExitMsg = &szExitMsg[0];

   wsprintf(lpstrExitMsg, "Assertion Failed: File %s, Line %u.\r\n",
						  lpstrFile, wLine);
   OutputDebugString(lpstrExitMsg);
   DebugBreak();

   return;
}

#else

// This is here so _assertion can be placed in the .DEF file for WMVC.
void EXPORT_API far pascal _assertion(WORD wLine, LPSTR lpstrFile)
{}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\property\plist.h ===
// PLISTIMP.H:  Definition of CITPropList

#ifndef __PLISTIMP_H__
#define __PLISTIMP_H__

#include "verinfo.h"

#define TABLE_SIZE 17


// Linked list of properties
class CPropList
{
public:
    CIntProperty Prop;
    CPropList* pNext;
};


// Implemenation of IITPropList
class CITPropList : 
	public IITPropList,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CITPropList, &CLSID_IITPropList>

{

BEGIN_COM_MAP(CITPropList)
	COM_INTERFACE_ENTRY(IITPropList)
    COM_INTERFACE_ENTRY(IPersistStreamInit)

END_COM_MAP()

DECLARE_REGISTRY(CLSID_IITPropList, "ITIR.PropertyList.4", "ITIR.PropertyList", 0, THREADFLAGS_BOTH )

public:
    CITPropList();
    ~CITPropList();

    // ITPropertyList methods
	STDMETHOD(Set)(DWORD dwPropID, DWORD dwData, DWORD dwOperation);
	STDMETHOD(Set)(DWORD dwPropID, LPVOID lpvData, DWORD cbData, DWORD dwOperation);
    STDMETHOD(Set)(DWORD dwPropID, LPCWSTR lpszwString, DWORD dwOperation);
    STDMETHOD(Add)(CProperty& Property);

    STDMETHOD(Get)(DWORD dwPropID, CProperty& Property);

    STDMETHOD(Clear)();

    // set persistence state
    STDMETHOD(SetPersist)(DWORD dwPropID, BOOL fPersist);
    STDMETHOD(SetPersist)(BOOL fPersist);    

      // for enumerating properties
    STDMETHOD(GetFirst)(CProperty& Property);
    STDMETHOD(GetNext)(CProperty& Property); 
    STDMETHOD(GetPropCount)(LONG& cProp);

    // Persist to memory
    STDMETHOD(SaveToMem)(LPVOID lpvData, DWORD dwBufSize);
    STDMETHOD(LoadFromMem)(LPVOID lpvData, DWORD dwBufSize);
    
	// persist header and data separately
	STDMETHOD(SaveHeader)(LPVOID lpvData, DWORD dwHdrSize);
	STDMETHOD(SaveData)(LPVOID lpvHeader, DWORD dwHdrSize, LPVOID lpvData, DWORD dwBufSize);
	STDMETHOD(GetHeaderSize)(DWORD& dwHdrSize);
	STDMETHOD(GetDataSize)(LPVOID lpvHeader, DWORD dwHdrSize, DWORD& dwDataSize);
	STDMETHOD(SaveDataToStream)(LPVOID lpvHeader, DWORD dwHdrSize, IStream* pStream);

    // IPersistStreamInit methods
    STDMETHOD(GetClassID)(CLSID* pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(LPSTREAM pStream);
    STDMETHOD(Save)(LPSTREAM pStream, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pcbsize);
    STDMETHOD(InitNew)();


    // Private methods and data
private:
    // Methods
    BOOL FindEntry(DWORD dwPropID, int& nHashIndex, CPropList** pList, CPropList** pPrev);
    
    // Data
    LONG  m_cProps;
    CPropList* PropTable[TABLE_SIZE];
    BOOL m_fIsDirty;

	int m_nCurrentIndex;   // Used in GetNext
	CPropList* m_pNext;    // Used in GetNext

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\orkin\memallo.cpp ===
/*************************************************************************
*                                                                        *
*  MEMALLO.C                                                             *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1992                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   Debugging memory management module. The purpose of this module is    *
*   to ensure that memories are allocated, locked, unlocked and freed    *
*   properly. The following examples show some common mistakes, which    *
*   may cause havoc, and are hard to find:                               *
*      - Use LocalFree() instead GlobalFree() for a global memory, and   *
*      vice versa. This bug will cause subtle error and possible system  *
*      crashes                                                           *
*      - Lock or free garbage handle: will cause random system crashes   *
*      - Check for unfreed memory                                        *
*                                                                        *
*   Note: All the local memory management scheme have been removed       *
*      - Since it will not work for DLL (using DS of the DLL instead     *
*        of the app                                                      *
*      - There is plan to not to use local memory (to avoid 64K limit)   *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
*************************************************************************/

#include <mvopsys.h>

#ifdef _DEBUG // {

#include <misc.h>
#include <mem.h>
#include <iterror.h>
#include "critsec.h"

#if !defined( MOSMEM )  // {

typedef struct tagMEMPOOL 
{
    HANDLE  hnd;
    DWORD   size;
    char    FAR *lszFileName;
    UINT    line;
} MEMPOOL;

// Under multitasking  Win32, protect debug functions by critical section
// We only protect simultaneous ALLOC & FREE. Lock and Unlock are not
// protected against each other because these cases are not supposed to happen
static CCriticalSection gcsMemory;

#define ENTER_CRITICAL_SECTION  EnterCriticalSection(gcsMemory)
#define LEAVE_CRITICAL_SECTION  LeaveCriticalSection(gcsMemory)

// make sure it is near to allow multiple instances
// for static case
static MEMPOOL FAR *GlobalPool=NULL;
static UINT GlobalPoolIndex = 0;
static UINT GlobalPoolSize=0;
static DWORD GlobalMemUsed = 0;


/*************************************************************************
 *
 * 	                  GLOBAL FUNCTIONS
 *************************************************************************/

PUBLIC HANDLE EXPORT_API PASCAL FAR _GlobalAlloc(UINT, DWORD, LPSTR, UINT);
PUBLIC HANDLE EXPORT_API PASCAL FAR _GlobalReAlloc(HANDLE, DWORD,
    UINT, LPSTR, UINT);
PUBLIC LPVOID EXPORT_API PASCAL FAR _GlobalLock(HANDLE, LPSTR, UINT);
PUBLIC int EXPORT_API PASCAL FAR _GlobalUnlock(HANDLE, LPSTR, UINT);
PUBLIC HANDLE EXPORT_API PASCAL  FAR _GlobalFree(HANDLE, LPSTR, UINT);


/*************************************************************************
 *	@doc	INTERNAL DEBUG
 *
 *	@func	VOID NEAR PASCAL | MakeGlobalPool |
 *		Just break inside CodeView
 *************************************************************************/
PUBLIC VOID EXPORT_API PASCAL FAR MakeGlobalPool (void)
{
	GlobalPool = (MEMPOOL FAR *)GlobalAllocPtr(DLLGMEM_ZEROINIT,
		sizeof(MEMPOOL)*2000);
	GlobalPoolSize = 2000;
	GlobalMemUsed = 0;
	GlobalPoolIndex = 0;
}


PUBLIC VOID EXPORT_API PASCAL FAR FreeGlobalPool (void)
{
	if (GlobalPool)
		GlobalFreePtr (GlobalPool);
	GlobalPool = NULL;
	GlobalPoolSize = 0;
}


/*************************************************************************
 *	@doc	INTERNAL DEBUG
 *
 *	@func	int NEAR PASCAL | MemErr |
 *      Output the error
 *
 *  @parm   int | err |
 *      Error code
 *
 *	@parm	LPSTR | lszFilename |
 *		Module where the function is invoked
 *
 *	@parm	UINT | line |
 *		Line where the function is invoked
 *
 *  @rdesc  Corresponding error
 *************************************************************************/
int NEAR PASCAL MemErr(int err, LPSTR lszFilename, UINT line)
{
	char Buffer[510];
    
    switch (err)
    {
        case E_NOHANDLE:
            wsprintf (Buffer, "No memory handle left. File: %s, line:%d\n", 
            		lszFilename, line);
            break;
        case E_OUTOFMEMORY:
            wsprintf (Buffer, "Out of memory. File: %s, line:%d\n",
                lszFilename, line);
            break;
        case E_HANDLE:
            wsprintf (Buffer, "Invalid handle. File: %s, line:%d\n",
                lszFilename, line);
            break;
        case E_INVALIDARG:
            wsprintf (Buffer, "Free locked handle. File: %s, line:%d\n",
                lszFilename, line);
            break;
        case E_ASSERT:
            wsprintf (Buffer, "Releasing invalid handle. File: %s, line:%d\n",
                lszFilename, line);
            break;
		case E_FAIL:
            wsprintf (Buffer, "Buffer overwritten. File: %s, line:%d\n",
                lszFilename, line);
			break;
		case S_OK:
            // wsprintf (Buffer, "Buffer > 64K. File: %s, line:%d\n",
            //  lszFilename, line);
			return err;
			break;
    }
    OutputDebugString (Buffer);
    return(err);
    
}

void DumpMemory (void)
{
    register UINT i;
    char szTemp[1024];

    ENTER_CRITICAL_SECTION;

	/* Check in global memory pool */
	for (i = 0; i <= GlobalPoolIndex; i++) 
	{
        wsprintf(szTemp, "%u\t\t%s\t%u\n",
            GlobalPool[i].size,
            GlobalPool[i].lszFileName,
            GlobalPool[i].line);
        OutputDebugString(szTemp);
       
	}

    LEAVE_CRITICAL_SECTION;
}

/*************************************************************************
 *	@doc	INTERNAL DEBUG
 *
 *	@func	UINT NEAR PASCAL | CheckMemValidity |
 *		Make sure that we really did allocate the specified handle
 *
 *	@parm	HANDLE | hnd |
 *		Handle to be checked
 *
 *	@parm	LPSTR | lszFilename |
 *		Module where the function is invoked
 *
 *	@parm	UINT | line |
 *		Line where the function is invoked
 *
 *	@rdesc	GlobalPoolSize + 1 if invalid handle, else the
 *		index of the pool location
 *************************************************************************/
PRIVATE UINT NEAR PASCAL CheckMemValidity (HANDLE hnd, LPSTR lszFilename,
    UINT line)
{
	register UINT i;

    // erinfox: critical section around this function because _GlobalLock
    // and _GlobalUnlock use it
    ENTER_CRITICAL_SECTION;
	/* Check in global memory pool */
	for (i = 0; i <= GlobalPoolIndex; i++) 
	{
		if (GlobalPool[i].hnd == hnd)
        {
            LEAVE_CRITICAL_SECTION;
			return i;
        }
	}

    // if i is GlobalPoolSize, handle isn't truly "invalid" - it's
    // just not part of the pool (because we've filled the pool)
    if (i < GlobalPoolSize)
    MemErr (E_HANDLE, lszFilename, line);
    LEAVE_CRITICAL_SECTION;

	return i;
}


/*************************************************************************
 *	@doc	INTERNAL DEBUG
 *
 *	@func	HANDLE PASCAL | _GlobalAlloc |
 *		Allocate a near block of memory via GlobalAlloc. The number of
 *		handles is actually limited by GlobalPoolSize
 *
 *	@parm	UINT | flag |
 *		Various windows memory flags (such as GMEM_ZEROINIT)
 *
 *	@parm	DWORD | size |
 *		Size of the block
 *
 *	@parm	LPSTR | lpszFile |
 *		Module where the function is invoked
 *
 *	@parm	UINT | line |
 *		Line where the function is invoked
 *
 *	@rdesc	Handle to the block of memory if succeded, 0 otherwise
 *************************************************************************/
PUBLIC HANDLE EXPORT_API PASCAL FAR _GlobalAlloc(UINT flag, DWORD size,
    LPSTR lszFilename, UINT line)
{
	register UINT i, j;
	MEMPOOL FAR *pMem = NULL;
#if 0
	BYTE HUGE *lpb;
#endif
    HANDLE   hnd;

	ENTER_CRITICAL_SECTION;
    
	if (GlobalPool==NULL)
    	MakeGlobalPool();

	/* Find an available handle */
	for (i = 0; i < GlobalPoolSize; i++) 
	{
		if (GlobalPool[i].hnd == 0) 
		{
			pMem = &GlobalPool[i];
			break;
		}
	}

	if (pMem == NULL)
	{
	    LEAVE_CRITICAL_SECTION;
        
        MemErr (E_NOHANDLE, lszFilename, line);
		return GlobalAlloc(flag, size);
	}

	/* Update index */
	if (GlobalPoolIndex < i)
		GlobalPoolIndex = i;

	if ((hnd = GlobalAlloc(flag, size + 1)) == NULL)
	{
		LEAVE_CRITICAL_SECTION;
		
		MemErr(E_OUTOFMEMORY, lszFilename, line);
        return(NULL);
	}
        
#if 0
    /* Add buffer overflow checking */
	if (lpb = GlobalLock (hnd))
	{
		*(lpb + size) = 'x';
		GlobalUnlock (hnd);
	}
#endif

    /* Check to see if any other location has the same handle
     * If happens since we may return a handle back to the user,
     * who will eventually free it without our knowledge
     */
    for (j = 0; j <= GlobalPoolIndex; j++)
    {
        if (j == i)
            continue;
        if (GlobalPool[j].hnd == hnd) 
        {
            if (GlobalPool[j].size == (DWORD)-1) 
                break;    // Reuse that "released" block
            else
        	    MemErr (E_ASSERT, lszFilename, line);
            pMem = &GlobalPool[j];
        }
    }
    
	pMem->hnd = hnd;
	pMem->size = size;
	pMem->lszFileName = lszFilename;
	pMem->line = line;
	GlobalMemUsed += size;

	LEAVE_CRITICAL_SECTION;
	return (pMem->hnd);
}

/*************************************************************************
 *	@doc	INTERNAL DEBUG
 *
 *	@func	HANDLE PASCAL | _GlobalReAlloc |
 *		Allocate a near block of memory via GlobalReAlloc. The function
 *		makes sure that we did allocate the memory block
 *
 *	@parm	HANDLE | handle |
 *		Handle to memory block
 *
 *	@parm	DWORD | size |
 *		Size of the block
 *
 *	@parm	WORD | flag |
 *		Various windows memory flags (such as GMEM_ZEROINIT)
 *
 *	@parm	LPSTR | lszFilename |
 *		Module where the function is invoked
 *
 *	@parm	UINT | line |
 *		Line where the function is invoked
 *
 *	@rdesc	Return the new handle, or 0 if failed
 *************************************************************************/
PUBLIC HANDLE EXPORT_API PASCAL FAR _GlobalReAlloc(HANDLE handle,
    DWORD size, UINT flag, LPSTR lszFilename, UINT line)
{
	register UINT i;
	MEMPOOL FAR *pMem = NULL;

	ENTER_CRITICAL_SECTION;

	for (i = 0; i <= GlobalPoolIndex; i++) 
	{
		if (GlobalPool[i].hnd == handle) 
		{
			pMem = &GlobalPool[i];
			break;
		}
	}
	if (pMem == NULL) 
	{
		LEAVE_CRITICAL_SECTION;
		
		MemErr(E_HANDLE, lszFilename, line);
		return GlobalReAlloc(handle, size, flag);
	}
    
	if (size) {
#if 0
		BYTE HUGE *lpb;
        if (pMem->size < size)
        {
            /* We have to remove the last 'x' that we put in */
    		lpb = GlobalLock (pMem->hnd);
    		lpb [pMem->size] = 0;
    		GlobalUnlock (pMem->hnd);
        }
#endif
        
		GlobalMemUsed += size - pMem->size;
		pMem->size = size;
		if ((pMem->hnd = GlobalReAlloc(handle, size + 1, flag)) == NULL)
			MemErr(E_OUTOFMEMORY, lszFilename, line);
#if 0
		if (lpb = GlobalLock (pMem->hnd))
		{
			*(lpb + size) = 'x';
			GlobalUnlock (pMem->hnd);
		}
#endif
	}
	else
	{
		if ((pMem->hnd = GlobalReAlloc(handle, size, flag)) == NULL)
			MemErr(E_OUTOFMEMORY, lszFilename, line);
	}
	pMem->lszFileName = lszFilename;
	pMem->line = line;
		
    LEAVE_CRITICAL_SECTION;
	return (pMem->hnd);
}

/*************************************************************************
 *	@doc	INTERNAL DEBUG
 *
 *	@func	LPVOID PASCAL FAR | _GlobalLock |
 *		Lock a piece of far memory via GlobalLock
 *
 *	@parm	HANDLE | hnd |
 *		Memory handle to be locked
 *
 *	@parm	LPSTR | lszFilename |
 *		Module where the function is invoked
 *
 *	@parm	UINT | line |
 *		Line where the function is invoked
 *
 *	@rdesc	Pointer to the block of memory if succeeded, else NULL
 *************************************************************************/
PUBLIC LPVOID EXPORT_API PASCAL FAR _GlobalLock(HANDLE hnd,
	LPSTR lszFilename, UINT line)
{
	if (hnd == 0) 
	{
		// GarrG - removed call to MemErr. Locking a NULL handle
		// is a valid thing to try, since it eliminates the necessity
		// of checking for NULL twice (on the handle AND on the
		// result of GlobalLock).
		return NULL;
	}
	
	/* Check for data integrity */
	CheckMemValidity(hnd, lszFilename, line);
        
	return (LPVOID)GlobalLock(hnd);
}

/*************************************************************************
 *	@doc	INTERNAL DEBUG
 *
 *	@func	DWORD PASCAL FAR | _GlobalSize |
 *		Return the size of a block of memory
 *
 *	@parm	HANDLE | hnd |
 *		Handle to memory block
 *
 *	@parm	LPSTR | lszFilename |
 *		Module where the function is invoked
 *
 *	@parm	UINT | line |
 *		Line where the function is invoked
 *
 *	@rdesc	Size of the block of memory
 *************************************************************************/
PUBLIC DWORD EXPORT_API PASCAL FAR _GlobalSize(HANDLE hnd,
	LPSTR lszFilename, UINT line)
{
    UINT i;
    
	if (hnd == 0) 
	{
		MemErr(E_HANDLE, lszFilename, line);
		return 0;
	}
	
	/* Check for data integrity */
	if ((i = CheckMemValidity(hnd, lszFilename, line)) >= GlobalPoolSize)
	{
		MemErr(E_HANDLE, lszFilename, line);
		return (DWORD) GlobalSize(hnd);
	}
	return  (GlobalPool[i].size);
}    
 
/*************************************************************************
 *	@doc	INTERNAL DEBUG
 *
 *	@func	int PASCAL | _GlobalUnlock |
 *		Unlock a handle. Memory validity is checked for invalid handle
 *
 *	@parm	HANDLE | hnd |
 *		Handle to be unlocked
 *
 *	@parm	LPSTR | lszFilename |
 *		Module where the function is invoked
 *
 *	@parm	UINT | line |
 *		Line where the function is invoked
 *
 *	@rdesc	If the handle is valid, return GlobalUnlock(), else -1.
 *		In case of failure the returned value has not much validity
 *************************************************************************/
PUBLIC int EXPORT_API PASCAL FAR _GlobalUnlock(HANDLE hnd,
	LPSTR lszFilename, UINT line)
{
#if 0
	BYTE HUGE *lpb;
#endif
	register UINT i;
	MEMPOOL FAR *pMem;

	if (hnd == 0) 
	{
		MemErr(E_HANDLE, lszFilename, line);
		return -1;
	}

	/* Check for data integrity */
	if ((i = CheckMemValidity(hnd, lszFilename, line)) >= GlobalPoolSize) 
	{
	    return(GlobalUnlock(hnd));
	}

	pMem = &GlobalPool[i];
	
    /* Now check for buffer overflow. This only works for memory allocated
     * by us, ie. not through _GlobalAdd(), which in this case, has the
     * size = -1
     */
#if 0
	if (pMem->size != (DWORD)-1) 
	{
    	if (lpb = GlobalLock (hnd))
			{
	    	if (*(lpb + pMem->size) != 'x')
	    		MemErr(E_FAIL, lszFilename, line);
	    	GlobalUnlock(hnd);
			}
	}
#endif
    return GlobalUnlock(hnd);
}

/*************************************************************************
 *	@doc	INTERNAL DEBUG
 *
 *	@func	HANDLE PASCAL | _GlobalFree |
 *		Free the global memory. Memory validity is checked to ensure that
 *		we don't free an invalid handle
 *
 *	@parm	HANDLE | hnd |
 *		Handle to the global memory to be freed
 *
 *	@parm	LPSTR | lszFilename |
 *		Module where the function is invoked
 *
 *	@parm	UINT | line |
 *		Line where the function is invoked
 *
 *	@rdesc	Return NULL if failed, else the handle
 *************************************************************************/
PUBLIC HANDLE EXPORT_API PASCAL FAR _GlobalFree(HANDLE hnd,
	LPSTR lszFilename, UINT line)
{
	register UINT i;
	HANDLE h;
    int    count;

	if (hnd == 0) 
	{
		MemErr(E_HANDLE, lszFilename, line);
		return 0;
	}

    if (hnd == (HANDLE)-1)
        DumpMemory();

	ENTER_CRITICAL_SECTION;

	/* Check for data integrity */
	if ((i = (CheckMemValidity(hnd, lszFilename, line))) >= GlobalPoolSize) 
	{
	    MemErr (E_ASSERT, lszFilename, line);
		return (GlobalFree(hnd));
	}

	if (GlobalPool[i].size == (DWORD)-1) 
	{
	    /* We are freeing a pointer passed to us from the user, who has
         * the responsibility to free it. This may be a bug.
         */
	    // MemErr (E_ASSERT, lszFilename, line);
        GlobalPool[i].size = 0;
	}


	if ((count = (GlobalFlags(hnd) & GMEM_LOCKCOUNT)) > 0)
	{
		/* Freeing locked handle */
		MemErr(E_INVALIDARG, lszFilename, line);
		
        while	(count > 0) 
        {
            GlobalUnlock (hnd);
            count--;
        }
	}
    
	h = GlobalFree(hnd);
	GlobalMemUsed -= GlobalPool[i].size;
	GlobalPool[i].size = 0;
	GlobalPool[i].lszFileName = NULL;
	GlobalPool[i].hnd = 0;
	GlobalPool[i].line = 0;

	LEAVE_CRITICAL_SECTION ;

	return h ;
}

/*************************************************************************
 *	@doc	INTERNAL DEBUG
 *
 *	@func	HANDLE PASCAL | _GlobalRelease |
 *      There are case when we allocated memory blocks in MV and return
 *      them to the user. It is the user's responsibility to free this
 *      block.In this case, all the memory allocations scheme can't apply.
 *      In the meantime, we still want to keep track of all memory
 *      allocation. So this routine will remove the handle from the
 *      memory pool without really releasing it. It just stops tracking
 *      that piece of memory
 *
 *  @parm   HANDLE | hnd |
 *      Handle to be released from the memory pool
 *
 *	@parm	LPSTR | lszFilename |
 *		Module where the function is invoked
 *
 *	@parm	UINT | line |
 *		Line where the function is invoked
 *************************************************************************/
HANDLE EXPORT_API PASCAL FAR _GlobalRelease (HANDLE hnd, LPSTR lszFilename,
    UINT line)
{
    
	register UINT i;
	MEMPOOL FAR *pMem;

	ENTER_CRITICAL_SECTION;
	if (hnd == 0) 
	{
		LEAVE_CRITICAL_SECTION;
		
		MemErr(E_HANDLE, lszFilename, line);
		return (hnd);
	}

	/* Check for data integrity */
	if ((i = CheckMemValidity(hnd, lszFilename, line)) >= GlobalPoolSize) 
	{
        LEAVE_CRITICAL_SECTION;
        
        MemErr(E_HANDLE, lszFilename, line);
        return (hnd);
	}

	pMem = &GlobalPool[i];
#if 0
	if (pMem->size != (DWORD)-1) 
	{
        BYTE HUGE *lpb;
        
	    if (lpb = (LPSTR)GlobalLock (hnd)) 
	    {
	        if (lpb[pMem->size] == 'x')
    	        lpb[pMem->size] = 0;
        GlobalUnlock(hnd);
	    }
    	GlobalMemUsed -= pMem->size;
	}
#endif
	pMem->size = 0;
	pMem->lszFileName = NULL;
	pMem->hnd = 0;
	pMem->line = 0;
    LEAVE_CRITICAL_SECTION;
	return(hnd);
	
} 

/*************************************************************************
 *	@doc	INTERNAL DEBUG
 *
 *	@func	EXPORT_API FAR PASCAL | _GlobalAdd |
 *      There are case when we receive a handle from the user to be
 *      manipulated (lock, unlock) etc. To make it works with our
 *      memory scheme, we need to put this into the memory table to be
 *      able to track it.
 *
 *  @parm   HANDLE | hnd |
 *      Handle to be added to the memory pool
 *
 *	@parm	LPSTR | lszFilename |
 *		Module where the function is invoked
 *
 *	@parm	UINT | line |
 *		Line where the function is invoked
 *************************************************************************/
HANDLE EXPORT_API PASCAL FAR _GlobalAdd (HANDLE hnd, LPSTR lszFilename,
    UINT line)
{
	register UINT i;
    UINT j = (UINT)-1;
	MEMPOOL FAR *pMem = NULL;
	
	ENTER_CRITICAL_SECTION;
    
	if (GlobalPool==NULL)
    	MakeGlobalPool();

	/* Find an available handle */
	for (i = 0; i < GlobalPoolSize; i++) 
	{
		if (GlobalPool[i].hnd == 0) 
		{
            if (j == (UINT)-1)
                j = i;
		}
		else if (GlobalPool[i].hnd == hnd) 
		{
    	    LEAVE_CRITICAL_SECTION;
            return hnd; // Already in the pool
		}
	}

	if (j == (UINT)-1)
	{
    	LEAVE_CRITICAL_SECTION;
        MemErr (E_NOHANDLE, lszFilename, line);
		return NULL;
	}

    if (GlobalPoolIndex < j)
        GlobalPoolIndex = j;
    pMem = &GlobalPool[j];    
	pMem->size = (DWORD)-1; // Mark that the buffer came from outside
	pMem->lszFileName = lszFilename;
	pMem->line = line;
	pMem->hnd = hnd;

	LEAVE_CRITICAL_SECTION;
	return hnd;
} 


PUBLIC DWORD EXPORT_API PASCAL FAR GetMemUsed()
{
	return GlobalMemUsed;
}

/*************************************************************************
 *	@doc	INTERNAL DEBUG
 *
 *	@func	DWORD PASCAL | CheckMem |
 *		Make sure that all memory blocks are freed properly
 *
 *	@rdesc	Number of unfreed bytes
 *************************************************************************/
PUBLIC DWORD EXPORT_API PASCAL FAR CheckMem()
{
	register UINT i;
	DWORD dwUnreleasedMem = 0;
	HANDLE hnd;
    char  Buffer[500];	// 100 is not safe when filenames are real long.
	LPSTR szFile ;

	if ((GlobalMemUsed) == 0) {
		FreeGlobalPool();
		return 0;
	}

	if (GlobalPool)	// When called several times, protect against null ptr
	{
		for (i = 0; i <= GlobalPoolIndex; i++) 
		{
			if ((hnd = GlobalPool[i].hnd) && GlobalPool[i].size != (DWORD)-1) 
			{ // This pool is not released
				dwUnreleasedMem += GlobalPool[i].size;
#ifdef WIN32
		// When the DLL containing the string has been unloaded, we run into big troubles -> check
		if (GlobalPool[i].lszFileName && !IsBadStringPtr(GlobalPool[i].lszFileName, sizeof(Buffer)/2))
			szFile = GlobalPool[i].lszFileName ;
		else
			szFile = "File Unavailable" ;
#else	// dunno if this would work on other platforms...
		szFile = GlobalPool[i].lszFileName ;
#endif
				wsprintf (Buffer,
					"Unreleased GM at: %d, Size: %ld, Alloc at: %s, Line: %d\r\n",
					i, GlobalPool[i].size, szFile,
					GlobalPool[i].line);
				OutputDebugString (Buffer);

				/* Release the pool */
				GlobalPool[i].hnd = 0;
				GlobalUnlock(hnd);
				GlobalFree(hnd);
			}
		}
	}
	else
		dwUnreleasedMem = GlobalMemUsed ;

	GlobalPoolIndex = 0;
	FreeGlobalPool();
	return dwUnreleasedMem;
}

#ifndef _MAC // {
/*************************************************************************
 *	@doc	INTERNAL DEBUG
 *
 *	@func	HANDLE PASCAL | _VirtualAlloc |
 *		Allocate a block of memory via VirtualAlloc. The number of
 *		handles is actually limited by GlobalPoolSize
 *
 *	@parm	LPVOID | lpAddr |
 *		Address of region to be allocated
 *
 *	@parm	DWORD | size |
 *		Size of the block
 *
 *	@parm	DWORD | flag |
 *		Type of allocation
 *
 *	@parm	DWORD | fProtect |
 *		Type of access protection
 *
 *	@parm	LPSTR | lpszFile |
 *		Module where the function is invoked
 *
 *	@parm	UINT | line |
 *		Line where the function is invoked
 *
 *	@rdesc	Handle to the block of memory if succeded, 0 otherwise
 *************************************************************************/
PUBLIC HANDLE EXPORT_API PASCAL FAR _VirtualAlloc(LPVOID lpAddr, DWORD size,
    DWORD flag, DWORD fProtect, LPSTR lszFilename, UINT line)
{
	register UINT i, j;
	MEMPOOL FAR *pMem = NULL;
#if 0
	BYTE HUGE *lpb;
#endif
    HANDLE   hnd;

	ENTER_CRITICAL_SECTION;
    
	if (GlobalPool==NULL)
    	MakeGlobalPool();

	/* Find an available handle */
	for (i = 0; i < GlobalPoolSize; i++) 
	{
		if (GlobalPool[i].hnd == 0) 
		{
			pMem = &GlobalPool[i];
			break;
		}
	}

	if (pMem == NULL)
	{
	    LEAVE_CRITICAL_SECTION;
        
        MemErr (E_NOHANDLE, lszFilename, line);
		return (HANDLE)VirtualAlloc(NULL, size, flag, fProtect);
	}

	/* Update index */
	if (GlobalPoolIndex < i)
		GlobalPoolIndex = i;

	if ((hnd = (HANDLE)VirtualAlloc(NULL, size,
		flag, fProtect)) == NULL)
	{
		MemErr(E_OUTOFMEMORY, lszFilename, line);
        return(NULL);
	}
        
    /* Check to see if any other location has the same handle
     * If happens since we may return a handle back to the user,
     * who will eventually free it without our knowledge
     */
    for (j = 0; j <= GlobalPoolIndex; j++)
    {
        if (j == i)
            continue;
        if (GlobalPool[j].hnd == hnd) 
        {
            if (GlobalPool[j].size == (DWORD)-1) 
                break;    // Reuse that "released" block
            else
        	    MemErr (E_ASSERT, lszFilename, line);
            pMem = &GlobalPool[j];
        }
    }
    
	pMem->hnd = hnd;
	pMem->size = size;
	pMem->lszFileName = lszFilename;
	pMem->line = line;
	GlobalMemUsed += size;

	LEAVE_CRITICAL_SECTION;
	return (pMem->hnd);
}

/*************************************************************************
 *	@doc	INTERNAL DEBUG
 *
 *	@func	LPVOID PASCAL FAR | __VirtualLock |
 *		Lock a piece of far memory via VirtualLock
 *
 *	@parm	HANDLE | hnd |
 *		Memory handle to be locked
 *
 *  @parm   DWORD | size |
 *      Size of memory to be locked
 *
 *	@parm	LPSTR | lszFilename |
 *		Module where the function is invoked
 *
 *	@parm	UINT | line |
 *		Line where the function is invoked
 *
 *	@rdesc	Pointer to the block of memory if succeeded, else NULL
 *************************************************************************/
PUBLIC LPVOID EXPORT_API PASCAL FAR _VirtualLock(HANDLE hnd, DWORD size,
	LPSTR lszFilename, UINT line)
{
	if (hnd == 0) 
	{
		// GarrG - removed call to MemErr. Locking a NULL handle
		// is a valid thing to try, since it eliminates the necessity
		// of checking for NULL twice (on the handle AND on the
		// result of VirtualLock).
		return NULL;
	}
	
	/* Check for data integrity */
	CheckMemValidity(hnd, lszFilename, line);
        
	return (LPVOID)(VirtualLock(hnd, size) ? &hnd : NULL);
}

 
/*************************************************************************
 *	@doc	INTERNAL DEBUG
 *
 *	@func	int PASCAL | _VirtualUnlock |
 *		Unlock a handle. Memory validity is checked for invalid handle
 *
 *	@parm	HANDLE | hnd |
 *		Handle to be unlocked
 *
 *	@parm	LPSTR | lszFilename |
 *		Module where the function is invoked
 *
 *	@parm	UINT | line |
 *		Line where the function is invoked
 *
 *	@rdesc	If the handle is valid, return VirtualUnlock(), else -1.
 *		In case of failure the returned value has not much validity
 *************************************************************************/
PUBLIC int EXPORT_API PASCAL FAR _VirtualUnlock(HANDLE hnd,
	DWORD size, LPSTR lszFilename, UINT line)
{
#if 0
	BYTE HUGE *lpb;
#endif
	register UINT i;
	MEMPOOL FAR *pMem;

	if (hnd == 0) 
	{
		MemErr(E_HANDLE, lszFilename, line);
		return -1;
	}

	/* Check for data integrity */
	if ((i = CheckMemValidity(hnd, lszFilename, line)) >= GlobalPoolSize) 
	{
	    return(GlobalUnlock(hnd));
	}

	pMem = &GlobalPool[i];
	
    /* Now check for buffer overflow. This only works for memory allocated
     * by us, ie. not through _GlobalAdd(), which in this case, has the
     * size = -1
     */
#if 0
	if (pMem->size != (DWORD)-1) 
	{
    	if (lpb = GlobalLock (hnd))
			{
	    	if (*(lpb + pMem->size) != 'x')
	    		MemErr(E_FAIL, lszFilename, line);
	    	GlobalUnlock(hnd);
			}
	}
#endif
    return VirtualUnlock(hnd, size);
}


/*************************************************************************
 *	@doc	INTERNAL DEBUG
 *
 *	@func	int PASCAL | _VirtualFree |
 *		Free the global memory. Memory validity is checked to ensure that
 *		we don't free an invalid handle
 *
 *	@parm	HANDLE | hnd |
 *		Handle to the global memory to be freed
 *
 *	@parm	LPSTR | lszFilename |
 *		Module where the function is invoked
 *
 *	@parm	UINT | line |
 *		Line where the function is invoked
 *
 *	@rdesc	Return NULL if failed, else the handle
 *************************************************************************/
PUBLIC int EXPORT_API PASCAL FAR _VirtualFree(HANDLE hnd, DWORD size,
	DWORD flag, LPSTR lszFilename, UINT line)
{
	register UINT i;
	int    h;

	if (hnd == 0) 
	{
		MemErr(E_HANDLE, lszFilename, line);
		return 0;
	}

	/* Check for data integrity */
	if ((i = (CheckMemValidity(hnd, lszFilename, line))) >= GlobalPoolSize) 
	{
	    MemErr (E_ASSERT, lszFilename, line);
		return (VirtualFree(hnd, 0L, (MEM_DECOMMIT | MEM_RELEASE)));
	}


	ENTER_CRITICAL_SECTION;

    
	h = VirtualFree(hnd, 0L, MEM_DECOMMIT | MEM_RELEASE);
	GlobalMemUsed -= GlobalPool[i].size;
	GlobalPool[i].size = 0;
	GlobalPool[i].lszFileName = NULL;
	GlobalPool[i].hnd = 0;
	GlobalPool[i].line = 0;

	LEAVE_CRITICAL_SECTION ;

	return h ;
}
#endif  // } _MAC

#else // }{

/****************************************************
 *
 *    STUBS FOR NON-DEBUG VERSION TO SATISFY MVFS.DEF
 *
 ****************************************************/

PUBLIC HANDLE PASCAL FAR _GlobalAlloc(UINT flag, DWORD size,
    LPSTR lszFile, UINT line)
{
	return GlobalAlloc(flag, size);
}

PUBLIC HANDLE PASCAL FAR _GlobalReAlloc(HANDLE handle,
    DWORD size, UINT flag, LPSTR lszFile, UINT line)
{
	return GlobalReAlloc(handle, size, flag);
}


PUBLIC LPVOID PASCAL FAR _GlobalLock(HANDLE hnd, LPSTR lszFile, UINT line)
{
	return (LPVOID)GlobalLock(hnd);
}

PUBLIC int PASCAL FAR _GlobalUnlock(HANDLE hnd, LPSTR lszFile, UINT line)
{
	return GlobalUnlock(hnd);
}

PUBLIC HANDLE PASCAL FAR _GlobalFree(HANDLE hnd, LPSTR lszFile, UINT line)
{
	return GlobalFree(hnd);
}

PUBLIC DWORD PASCAL FAR _GlobalSize(HANDLE hnd, LPSTR lszFile, UINT line)
{
	return GlobalSize(hnd);
}

PUBLIC int PASCAL FAR _GlobalAdd (HANDLE hnd, LPSTR lszFilename,
    UINT line)
{
    return(S_OK);
}
    
PUBLIC HANDLE PASCAL FAR _GlobalRelease (HANDLE hnd, LPSTR pszFilename,
    UINT line)
{
    return(hnd);
}

DWORD PASCAL EXPORT_API FAR GetMemUsed()
{
	return 0;
}

DWORD PASCAL EXPORT_API FAR CheckMem()
{
	return 0;
}

#ifndef _MAC // {_MAC
PUBLIC HANDLE EXPORT_API PASCAL FAR _VirtualAlloc(LPVOID lpv,
	DWORD size, DWORD flag, DWORD fProtect, LPSTR lszFilename, UINT line)
{
	return (HANDLE)VirtualAlloc(lpv, size, flag, fProtect);
}

PUBLIC LPVOID EXPORT_API PASCAL FAR _VirtualLock(HANDLE hnd, DWORD size,
	LPSTR lszFilename, UINT line)
{
	return (LPVOID)VirtualLock(hnd, size);
}

PUBLIC int EXPORT_API PASCAL FAR _VirtualUnlock(HANDLE hnd,
	DWORD size, LPSTR lszFilename, UINT line)
{
	return (int)VirtualUnlock(hnd, size);
}

PUBLIC int EXPORT_API PASCAL FAR _VirtualFree(HANDLE hnd, DWORD size,
	DWORD flag, LPSTR lszFilename, UINT line)
{
		return (VirtualFree(hnd, 0L, (MEM_DECOMMIT | MEM_RELEASE)));
}
#endif // }_MAC
#endif // }

#endif // } _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\property\plist.cpp ===
/*************************************************************************
*  @doc SHROOM EXTERNAL API                                              *
*																		 *
*  PLIST.CPP                                                             *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1997                              *
*  All Rights reserved.                                                  *
*                                                                        *
*  This file contains the implementation of the property list, which     *
*  is a collection of properties (CProperty objects)                     *
*  												                         *
*																	     *
**************************************************************************
*                                                                        *
*  Written By   : Erin Foxford                                           *
*  Current Owner: erinfox                                                *
*                                                                        *
**************************************************************************/

// This implementation uses a hash table of properties
//

#include <atlinc.h>      // Includes for ATL

#include <itpropl.h>
#include <iterror.h>

#include "prop.h"
#include "plist.h"

// InfoTech includes
#include <mvopsys.h>
#include <_mvutil.h>


CITPropList::CITPropList() : m_cProps(0), m_fIsDirty(FALSE), 
                             m_pNext(NULL), m_nCurrentIndex(0)
{
    MEMSET(PropTable, NULL, sizeof(PropTable));
}

CITPropList::~CITPropList()
{
    Clear();
}


///////////////////////////// IITPropList methods //////////////////////////////////


/********************************************************************
 * @method    STDMETHODIMP | IITPropList | Clear |
 *      Clears memory associated with a property list and reinitializes
 *      the list.
 *
 * @rvalue S_OK | The property list was cleared.
 * 
 * @comm This method can be called to clear a property list without
 * requiring the list to be destroyed before being used again.    
 ********************************************************************/
STDMETHODIMP CITPropList::Clear()
{
    for (int iHashIndex = 0; iHashIndex < TABLE_SIZE; iHashIndex++)
    {
        CPropList* pNext;
        CPropList* pList = PropTable[iHashIndex];

		// traverse linked-list
        while (pList)
        {
            pNext = pList->pNext;
            delete pList;
            pList = pNext;
        }
		PropTable[iHashIndex] = NULL;
    }

    m_cProps = 0;
    m_pNext = NULL;
	m_nCurrentIndex = 0;
    m_fIsDirty = FALSE;


    return S_OK;

}


/********************************************************************
 * @method    STDMETHODIMP | IITPropList | Set|
 *      Sets a property to a given value or deletes a property from the list.      
 *
 * @parm DWORD | dwPropID | ID of property you want to set
 *
 * @parm DWORD | dwData | Value of property
 *
 * @parm DWORD | dwOperation | The operation you want to perform. Can be any of the following
 * flags:
 *
 * @flag PROP_ADD | Add property to list
 * @flag PROP_DELETE | Remove property from list
 * @flag PROP_UPDATE | Update property in list
 * 
 * @rvalue S_OK | The property list was successfully set
 * @rvalue E_DUPLICATE | The property already exists in the list (applies to adding)
 * @rvalue E_OUTOFMEMORY | Memory could not be allocated when adding a property
 * @rvalue E_NOTEXIST | The property does not exist (applies to deleting and updating)
 * @rvalue E_NOTIMPL | The specified operation is not available
 *
 * @comm  This method is used to set properties with numerical values.  
 ********************************************************************/
STDMETHODIMP CITPropList::Set(DWORD dwPropID, DWORD dwData, DWORD dwOperation)
{
    CPropList* pList;
    CPropList* pPrev;   // used in delete
	int nHashIndex;
	BOOL IsEntry = FindEntry(dwPropID, nHashIndex, &pList, &pPrev);

    switch (dwOperation)
    {
    case PROP_ADD:
        if (IsEntry)
            return E_DUPLICATE;

		if (NULL == pList)
		{
			// Hash table entry was empty, so we add it there
			pList = new CPropList;
			if (NULL == pList)
				return E_OUTOFMEMORY;

			PropTable[nHashIndex] = pList;
		}
		else
		{
			// Hash table entry wasn't empty; we got passed
			// back pointer to previous node, so we allocate a new link
			CPropList* pNew = new CPropList;
			if (NULL == pList)
				return E_OUTOFMEMORY;
			pList->pNext = pNew;
			pList = pNew;
		}
		pList->pNext = NULL;   // always make sure end of list is NULL

        // set data
        pList->Prop.SetPropID(dwPropID);
        pList->Prop.SetProp(dwData);
        pList->Prop.SetPersistState(TRUE);         // Persist on by default

        m_cProps++;
        m_fIsDirty = TRUE;

        break;

    case PROP_DELETE:
        if (IsEntry)
        {
            // Entry is first in linked list (or only entry)
            if (pList == PropTable[nHashIndex])
            {
                PropTable[nHashIndex] = pList->pNext;
                delete pList;
            }
            else
            {
                // Entry is inside linked list
                pPrev->pNext = pList->pNext;
                delete pList;
            }
        }
        else
            return E_NOTEXIST;

        m_cProps--;

        break;

    case PROP_UPDATE:
        // replace data value
        if (IsEntry)
        {
            pList->Prop.SetProp(dwData);
            m_fIsDirty = TRUE;

        }
        else
            return E_NOTEXIST;

        break;

    default:
        return E_NOTIMPL;

    }

    return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITPropList | Set|
 *      Sets a property to a given value or deletes a property from the list.      
 *
 * @parm DWORD | dwPropID | ID of the property to set
 *
 * @parm LPVOID | lpvData | Pointer to the buffer containing data
 *
 * @parm DWORD | cbData | Length of the buffer
 *
 * @parm DWORD | dwOperation | The operation you want to perform. Can be any of the following
 * flags:
 *
 * @flag PROP_ADD | Add property to list
 * @flag PROP_DELETE | Remove property from list
 * @flag PROP_UPDATE | Update property in list
 * 
 * @rvalue S_OK | The property list was successfully set
 * @rvalue E_DUPLICATE | The property already exists in the list (applies to adding)
 * @rvalue E_OUTOFMEMORY | Memory could not be allocated when adding a property
 * @rvalue E_NOTEXIST | The property does not exist (applies to deleting and updating)
 * @rvalue E_NOTIMPL | The specified operation is not available
 * 
 * @comm  
 ********************************************************************/
STDMETHODIMP CITPropList::Set(DWORD dwPropID, LPVOID lpvData, DWORD cbData, DWORD dwOperation)
{
    CPropList* pList;
    CPropList* pPrev;
	int nHashIndex;
	BOOL IsEntry = FindEntry(dwPropID, nHashIndex, &pList, &pPrev);
    switch (dwOperation)
    {
    case PROP_ADD:
        if (IsEntry)
            return E_DUPLICATE;

		if (NULL == pList)
		{
			// Hash table entry was empty, so we add it there
			pList = new CPropList;
			if (NULL == pList)
				return E_OUTOFMEMORY;

			PropTable[nHashIndex] = pList;
		}
		else
		{
			// Hash table entry wasn't empty; we got passed
			// back pointer to previous node, so we allocate a new link
			CPropList* pNew = new CPropList;
			if (NULL == pList)
				return E_OUTOFMEMORY;
			pList->pNext = pNew;
			pList = pNew;
		}
		pList->pNext = NULL;   // always make sure end of list is NULL

        // set data
        pList->Prop.SetPropID(dwPropID);
        pList->Prop.SetProp(lpvData, cbData);
        pList->Prop.SetPersistState(TRUE);         // Persist on by default

        m_fIsDirty = TRUE;

        m_cProps++;

        break;

    case PROP_DELETE:
        if (IsEntry)
        {
            // Entry is first in linked list (or only entry)
            if (pList == PropTable[nHashIndex])
            {
                PropTable[nHashIndex] = pList->pNext;
                delete pList;
            }
            else
            {
                // Entry is inside linked list
                pPrev->pNext = pList->pNext;
                delete pList;
            }
        }
        else
            return E_NOTEXIST;

        m_cProps--;

        break;

    case PROP_UPDATE:
        if (IsEntry)
        {
            pList->Prop.SetProp(lpvData, cbData);
            m_fIsDirty = TRUE;
        }
        else
            return E_NOTEXIST;

        break;

    default:
        return E_NOTIMPL;

    }

    return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITPropList | Set |
 *      Sets a property to a given value or deletes a property from the list.      
 *
 * @parm DWORD | dwPropID | ID of the property to set
 *
 * @parm LPCWSTR | lpszwString | Pointer to a Unicode string
 *
 * @parm DWORD | dwOperation | The operation you want to perform. Can be any of the following
 * flags:
 *
 * @flag PROP_ADD | Add property to list
 * @flag PROP_DELETE | Remove property from list
 * @flag PROP_UPDATE | Update property in list
 * 
 * @rvalue S_OK | The property list was successfully set
 * @rvalue E_DUPLICATE | The property already exists in the list (applies to adding)
 * @rvalue E_OUTOFMEMORY | Memory could not be allocated when adding a property
 * @rvalue E_NOTEXIST | The property does not exist (applies to deleting and updating)
 * @rvalue E_NOTIMPL | The specified operation is not available
 * 
 * @comm  
 ********************************************************************/

STDMETHODIMP CITPropList::Set(DWORD dwPropID, LPCWSTR lpszwString, DWORD dwOperation)
{
    CPropList* pList;
    CPropList* pPrev;    // used in delete
	int nHashIndex;
	BOOL IsEntry = FindEntry(dwPropID, nHashIndex, &pList, &pPrev);

    switch (dwOperation)
    {
	case(PROP_ADD):
        if (IsEntry)
            return E_DUPLICATE;

		if (NULL == pList)
		{
			// Hash table entry was empty, so we add it there
			pList = new CPropList;
			if (NULL == pList)
				return E_OUTOFMEMORY;

			PropTable[nHashIndex] = pList;
		}
		else
		{
			// Hash table entry wasn't empty; we got passed
			// back pointer to previous node, so we allocate a new link
			CPropList* pNew = new CPropList;
			if (NULL == pList)
				return E_OUTOFMEMORY;
			pList->pNext = pNew;
			pList = pNew;
		}
		pList->pNext = NULL;   // always make sure end of list is NULL

        // set data
        pList->Prop.SetPropID(dwPropID);
        pList->Prop.SetProp(lpszwString);
        pList->Prop.SetPersistState(TRUE);         // Persist on by default

        m_fIsDirty = TRUE;

        m_cProps++;

        break;

    case PROP_DELETE:
        if (IsEntry)
        {
            // Entry is first in linked list (or only entry)
            if (pList == PropTable[nHashIndex])
            {
                PropTable[nHashIndex] = pList->pNext;
                delete pList;
            }
            else
            {
                // Entry is inside linked list
                pPrev->pNext = pList->pNext;
                delete pList;
            }
        }
        else
            return E_NOTEXIST;

        m_cProps--;

        break;

    case PROP_UPDATE:
        // replace data - probably should delete old memory first
        if (IsEntry)
        {
            pList->Prop.SetProp(lpszwString);
            m_fIsDirty = TRUE;

        }
        else
            return E_NOTEXIST;

        break;


    default:
        return E_NOTIMPL;

    }

    return S_OK;

}

/********************************************************************
 * @method    STDMETHODIMP | IITPropList | Add |
 *      Adds a property to the property list.    
 *
 * @parm CProperty | Prop | Property object 
 *
 * @rvalue S_OK | The property list was successfully set
 * @rvalue E_DUPLICATE | The property already exists in the list 
 * @rvalue E_OUTOFMEMORY | Memory could not be allocated when adding a property
 * 
 * @comm  
 ********************************************************************/

STDMETHODIMP CITPropList::Add(CProperty& Prop)
{
    CPropList* pList;
    CPropList* pPrev;    // used in delete
	int nHashIndex;

	BOOL IsEntry = FindEntry(Prop.dwPropID, nHashIndex, &pList, &pPrev);

    if (IsEntry)
        return E_DUPLICATE;

	if (NULL == pList)
	{
		// Hash table entry was empty, so we add it there
		pList = new CPropList;
		if (NULL == pList)
			return E_OUTOFMEMORY;

		PropTable[nHashIndex] = pList;
	}
	else
	{
		// Hash table entry wasn't empty; we got passed
		// back pointer to previous node, so we allocate a new link
		CPropList* pNew = new CPropList;
		if (NULL == pList)
			return E_OUTOFMEMORY;
		pList->pNext = pNew;
		pList = pNew;
	}
	pList->pNext = NULL;   // always make sure end of list is NULL

    // set data
    pList->Prop.SetPropID(Prop.dwPropID);
    if (TYPE_VALUE == Prop.dwType)
        pList->Prop.SetProp(Prop.dwValue);
    else
        pList->Prop.SetProp(Prop.lpvData, Prop.cbData);

    pList->Prop.SetPersistState(Prop.fPersist);         

    m_fIsDirty = TRUE;

    m_cProps++;


    return S_OK;
}

// Search hash table and return pointer to list
// This function is private
BOOL CITPropList::FindEntry(DWORD dwPropID, int& nHashIndex, CPropList** pList,
                            CPropList** pPrev)
{
    nHashIndex = dwPropID % TABLE_SIZE;

    // hash entry not there
    if (NULL == (*pList = PropTable[nHashIndex]))
	{
		return FALSE;
	}

	// otherwise search the linked list
    do       
    {   
        if (dwPropID == (*pList)->Prop.GetPropID() )
			return TRUE;

		*pPrev = *pList;
        *pList = (*pList)->pNext;

    } while (*pList);

	*pList = *pPrev;

    return FALSE;
}


/********************************************************************
 * @method    STDMETHODIMP | IITPropList | Get|
 *      Returns the property object associated with the given property ID.       
 *
 * @parm DWORD | dwPropID | ID of the property object you want to get
 *
 * @parm CProperty& | Property | The property object returned
 *
 * @rvalue S_OK | The property was successfully returned
 * @rvalue E_NOTEXIST | The requested property does not exist 
 *
 * @comm  
 ********************************************************************/
STDMETHODIMP CITPropList::Get(DWORD dwPropID, CProperty& Property)
{
    HRESULT hr = S_OK;
	CPropList* pList;
    CPropList* pDummy;
	int nHashIndex;

	BOOL IsEntry = FindEntry(dwPropID, nHashIndex, &pList, &pDummy);
	if (IsEntry)
	{
		// fill in "public" property structure using values in our
		// internal class
		Property.dwPropID = dwPropID;
        Property.dwType = pList->Prop.GetType();
        Property.cbData = pList->Prop.GetSize();
		Property.fPersist = pList->Prop.GetPersistState();

		if (Property.dwType == TYPE_VALUE)
			pList->Prop.GetProp(Property.dwValue);
		else if (Property.dwType == TYPE_POINTER)
			pList->Prop.GetProp(Property.lpvData);
		else if (Property.dwType == TYPE_STRING)
			pList->Prop.GetProp(Property.lpszwData);

	}
	else
		hr = E_NOTEXIST;

	return hr;
}

/********************************************************************
 * @method    STDMETHODIMP | IITPropList | GetFirst|
 *      Returns the first property object in the property list    
 *
 * @parm CProperty& | FirstProp | The property object returned
 *
 * @rvalue S_OK | The property was successfully returned
 * @rvalue E_NOTEXIST | The requested property does not exist  
 *
 * @xref <om.GetNext>
 * @comm  
 ********************************************************************/
STDMETHODIMP CITPropList::GetFirst(CProperty& FirstProp)
{
	HRESULT hr = E_NOTEXIST;
	CPropList* pList;

	// search hash table and break on first non-NULL entry
	for (int iHashIndex = 0; iHashIndex < TABLE_SIZE; iHashIndex++)
	{
		if ( NULL != (pList = PropTable[iHashIndex]) )
		{
			hr = S_OK;
			m_nCurrentIndex = iHashIndex;
			m_pNext = pList->pNext;

			// fill in "public" property structure using values in our
			// internal class
			FirstProp.dwPropID = pList->Prop.GetPropID();
            FirstProp.dwType = pList->Prop.GetType();
            FirstProp.cbData = pList->Prop.GetSize();
			FirstProp.fPersist = pList->Prop.GetPersistState();

			if (FirstProp.dwType == TYPE_VALUE)
				pList->Prop.GetProp(FirstProp.dwValue);
			else if (FirstProp.dwType == TYPE_POINTER)
				pList->Prop.GetProp(FirstProp.lpvData);
			else if (FirstProp.dwType == TYPE_STRING)
				pList->Prop.GetProp(FirstProp.lpszwData);

            break;
        }
	}
	
    
	return hr;
}

/********************************************************************
 * @method    STDMETHODIMP | IITPropList | GetNext|
 *      Returns the next property object in the property list. Use this
 *      function with the GetFirst method to enumerate the
 *      properties in the list.
 *
 * @parm CProperty& | NextProp | Reference to property object to return
 *
 * @rvalue S_OK | The property was successfully returned
 * @rvalue E_NOTEXIST | The requested property does not exist. This error is
 * returned when the end of the list is reached.
 *
 * @xref <om.GetFirst>
 *
 * @comm Call the GetFirst method before calling this function. 
 ********************************************************************/
// Calling this method multiple times results in traversing the property list.
STDMETHODIMP CITPropList::GetNext(CProperty& NextProp)
{
	CPropList* pList = m_pNext;

	if (NULL == pList)
	{
		// search rest of hash table and break on first non-NULL entry
		for (int iHashIndex = m_nCurrentIndex+1; iHashIndex < TABLE_SIZE; iHashIndex++)
		{
			if ( NULL != (pList = PropTable[iHashIndex]) )
			{
				m_nCurrentIndex = iHashIndex;
				m_pNext = pList->pNext;
				goto FoundEntry;    // break out of for-loop
			}
		}

		// if we got here, we exhausted hash table w/out finding anything else
		return E_NOTEXIST;
	}

FoundEntry:
	m_pNext = pList->pNext;

	// fill in "public" property structure using values in our
	// internal class
	NextProp.dwPropID = pList->Prop.GetPropID();
    NextProp.dwType = pList->Prop.GetType();
    NextProp.cbData = pList->Prop.GetSize();
	NextProp.fPersist = pList->Prop.GetPersistState();

	if (NextProp.dwType == TYPE_VALUE)
		pList->Prop.GetProp(NextProp.dwValue);
	else if (NextProp.dwType == TYPE_POINTER)
		pList->Prop.GetProp(NextProp.lpvData);
	else if (NextProp.dwType == TYPE_STRING)
		pList->Prop.GetProp(NextProp.lpszwData);

    return S_OK;
}

/********************************************************************
 * @method    STDMETHODIMP | IITPropList | GetPropCount |
 *      Returns the number of properties in the list.
 *
 * @parm LONG& | cProp | Number of properties in the list
 *
 * @rvalue S_OK | The count was successfully returned
 *
 * @comm 
 ********************************************************************/
// Number of properties in list
inline STDMETHODIMP CITPropList::GetPropCount(LONG &cProp)
{
    cProp = m_cProps;
    return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITPropList | SetPersist |
 *      Sets the persistence state on or off for a given property. If
 *      the state is on, this property can be persisted by calling the SaveToMem
 *      or Save methods.
 *
 * @parm DWORD | dwPropID | ID of the property to set
 * @parm BOOL | fPersist | Persistence state. If TRUE, the persistence state is on;
 * if FALSE, the state is off.
 *
 * @rvalue S_OK | The state was successfully set
 * @rvalue E_NOTEXIST | The requested property does not exist
 *
 * @xref <om.SaveToMem>
 * @xref <om.Save>
 *
 * @comm By default, properties are created with a persistence state of TRUE.
 ********************************************************************/

STDMETHODIMP CITPropList::SetPersist(DWORD dwPropID, BOOL fPersist)
{	
	CPropList* pList;
    CPropList* pDummy;
	int nHashEntry;
    BOOL IsEntry = FindEntry(dwPropID, nHashEntry, &pList, &pDummy);
    if (IsEntry)
    {
        pList->Prop.SetPersistState(fPersist);
        m_fIsDirty = TRUE;
    }
    else
        return E_NOTEXIST;

    return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITPropList | SetPersist |
 *      Sets the persistence state on or off all properties. If
 *      the state is on, all properties can be persisted by calling SaveToMem
 *      or Save.
 *
 * @parm BOOL | fPersist | Persistence state. If TRUE, persistence state is on;
 * if FALSE, the state is off.
 *
 * @rvalue S_OK | The state was successfully set
 *
 * @xref <om.SaveToMem>
 * @xref <om.Save>
 *
 * @comm By default, properties are created with a persistence state of TRUE
 ********************************************************************/
STDMETHODIMP CITPropList::SetPersist(BOOL fPersist)
{
	for (int iHashIndex = 0; iHashIndex < TABLE_SIZE; iHashIndex++)
	{
        CPropList* pList = PropTable[iHashIndex];
        while (pList)
        {
			pList->Prop.SetPersistState(fPersist);
            pList = pList->pNext;
        }
	}

    m_fIsDirty = TRUE;
    return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITPropList | SaveToMem |
 *      Saves the property list to a buffer. Only properties
 *      marked with a persistence state of TRUE are saved.
 *
 * @parm LPVOID | lpvData | Pointer to the buffer you want to fill
 *
 * @parm DWORD | dwBufSize | Size of the buffer
 *
 * @rvalue S_OK | The property list was successfully saved
 *
 * @xref <om.GetSizeMax>
 *
 * @comm The caller is responsible for passing a buffer large enough to
 * hold the property list. The necessary size can be obtained by calling
 * the GetSizeMax method. There is no check against buffer size.
 * @devnote To be implemented: Check to make sure the buffer
 * size is large enough and return an error if it isn't.
 ********************************************************************/
STDMETHODIMP CITPropList::SaveToMem(LPVOID lpvBuffer, DWORD dwBufSize)
{
    // TODO: Make checks against buffer size to ensure that we don't write over
    // the end
    MEMSET(lpvBuffer, 0, dwBufSize);

    // should we return an error if pList is NULL ?
    LPBYTE pCur = (LPBYTE) lpvBuffer;
    HRESULT hr = S_OK;  
	DWORD cbSize;
	DWORD dwPropID;
    DWORD dwType;
	DWORD dwValue;
	LPVOID lpvData;

    for (int iHashIndex = 0; iHashIndex < TABLE_SIZE; iHashIndex++)
    {
		// Walk hash table (and linked lists, if any)
        CPropList* pList = PropTable[iHashIndex];
        while (pList)
        {
			if (pList->Prop.GetPersistState())
			{
				// write out property ID
				dwPropID = pList->Prop.GetPropID();
				MEMCPY(pCur, &dwPropID, sizeof(DWORD));
				pCur += sizeof(DWORD);

				// write out type
				dwType = pList->Prop.GetType();
				MEMCPY(pCur, &dwType, sizeof(DWORD)); 
				pCur += sizeof(DWORD);

				// write out property value
				if (TYPE_VALUE == pList->Prop.GetType())
				{
					// it's a value
					pList->Prop.GetProp(dwValue);
					MEMCPY(pCur, &dwValue,  sizeof(DWORD));
					pCur += sizeof(DWORD);
				}
				else 
				{
					// it's a pointer
                    // get size first
                    cbSize = pList->Prop.GetSize();
                    MEMCPY(pCur, &cbSize, sizeof(DWORD));
                    pCur += sizeof(DWORD);

					pList->Prop.GetProp(lpvData);
					MEMCPY(pCur, lpvData, cbSize);
					pCur += cbSize;
				}

			}

            pList = pList->pNext;
        }
    }
	
    m_fIsDirty = FALSE;
	
	return hr;

}


/********************************************************************
 * @method    STDMETHODIMP | IITPropList | LoadFromMem |
 *     Initializes the property list from the buffer where it was previously
 * saved.
 *
 * @parm LPVOID | lpvData | Pointer to the buffer from which the property list
 * should be loaded.
 *
 * @parm DWORD | dwBufSize | Buffer size
 *
 * @rvalue S_OK | The property list was successfully loaded
 * @rvalue E_FAIL | The buffer does not contain all the necessary data
 * @rvalue E_PROPLISTNOTEMPTY | The property list is not empty. The caller
 * must clear the property list before calling LoadFromMem.
 * @rvalue E_OUTOFMEMORY | Memory could not be allocated when creating property list.
 *
 * @comm In the current implementation the property list does not own the data. 
 * Therefore, the caller must not free the buffer before freeing the property list.
 ********************************************************************/
STDMETHODIMP CITPropList::LoadFromMem(LPVOID lpvData, DWORD dwBufSize)
{
    HRESULT hr = S_OK;
    DWORD dwPropID;
    DWORD cbSize;
    DWORD dwValue;
    DWORD dwType;
    LPVOID lpvPropData;

    LPBYTE pCur = (LPBYTE) lpvData;

    BOOL fMore = TRUE;

    // What happens if we already have a property list?
    // For now, return an error and force user to clear it
    if (0 != m_cProps)
        return E_PROPLISTNOTEMPTY;

    // Build a property list from the given stream
    do
    {
        // Read property ID
        MEMCPY(&dwPropID, pCur, sizeof(DWORD));
        pCur += sizeof(DWORD);
        // we're done if this is true
        if ( (DWORD)(pCur - (LPBYTE)lpvData) >= dwBufSize) 
            return E_FAIL;       // should never happen here

        // Read type
        MEMCPY(&dwType, pCur, sizeof(DWORD));
        pCur += sizeof(DWORD);
        // we're done if this is true
        if ( (DWORD)(pCur - (LPBYTE)lpvData) >= dwBufSize) 
            return E_FAIL;      // should never happen here

        // Read property
        if (TYPE_VALUE == dwType)
        {
			// It's a value
            MEMCPY(&dwValue, pCur, sizeof(DWORD));
            pCur += sizeof(DWORD);
            // we're done if this is true
            if ( (DWORD)(pCur - (LPBYTE)lpvData) >= dwBufSize) 
                fMore = FALSE;

			// Set
			Set(dwPropID, dwValue, PROP_ADD);
        }
        else
        {
            // read size first
            MEMCPY(&cbSize, pCur, sizeof(DWORD));
            pCur += sizeof(DWORD);
            // we're done if this is true
            if ( (DWORD)(pCur - (LPBYTE)lpvData) >= dwBufSize) 
                return E_FAIL;      // should never happen here

            lpvPropData = pCur;
            pCur += cbSize;
            // we're done if this is true
            if ( (DWORD)(pCur - (LPBYTE)lpvData) >= dwBufSize) 
                fMore = FALSE;

			// Set
            if(TYPE_STRING == dwType)
                Set(dwPropID, (LPWSTR) lpvPropData, PROP_ADD);
            else
                Set(dwPropID, lpvPropData, cbSize, PROP_ADD);

        }

    } while (fMore);


    return S_OK;
}

/********************************************************************
 * @method    STDMETHODIMP | IITPropList | GetHeaderSize |
 *      Number of bytes needed to save the header
 *
 * @parm DWORD& | dwHdrSize | Size in bytes
 *
 * @rvalue S_OK | The size was successfully returned
 *
 ********************************************************************/
// optimization - once we find m_cProps, stop looping
STDMETHODIMP CITPropList::GetHeaderSize(DWORD& dwHdrSize)
{
	DWORD NumberOfBytes = 4;      // number of properties is a DWORD
    for (int iHashIndex = 0; iHashIndex < TABLE_SIZE; iHashIndex++)
    {
		// Walk hash table (and linked lists, if any)
        CPropList* pList = PropTable[iHashIndex];
        while (pList)
        {
			if (pList->Prop.GetPersistState())
			{
				NumberOfBytes += sizeof(DWORD) + sizeof(DWORD);  // Prop ID and type
			}

            pList = pList->pNext;
        }
    }

    if (NumberOfBytes != 4)
    	dwHdrSize = NumberOfBytes;
    else
        dwHdrSize = 0;
	return S_OK;
}

/********************************************************************
 * @method    STDMETHODIMP | IITPropList | SaveHeader |
 *      Saves the property ID and data type from the property list 
 *      to a buffer. Only properties marked with a persistence state 
 *      of TRUE are saved.
 *
 * @parm LPVOID | lpvData | Pointer to a buffer to fill
 * @parm DWORD | dwHdrSize | Size of the buffer
 *
 * @rvalue S_OK | The property list was successfully saved
 *
 * @comm The caller is responsible for passing a buffer large enough to
 * hold the header. 
 ********************************************************************/
STDMETHODIMP CITPropList::SaveHeader(LPVOID lpvData, DWORD dwHdrSize)
{
	// TODO: dwHdrSize currently only used to memset header but could be used to check
	// that buffer isn't overrun

    // should we return an error if pList is NULL ?
    LPBYTE pCur = (LPBYTE) lpvData + 4;   // save top DWORD for number of properties
    HRESULT hr = S_OK;  
	DWORD dwPropID;
    DWORD dwType;
	DWORD nNumberOfProps = 0;
	
    if (!dwHdrSize)
        return E_INVALIDARG;

	// Make sure lpvData is 0'd out
	MEMSET(lpvData, 0, dwHdrSize);

	for (int iHashIndex = 0; iHashIndex < TABLE_SIZE; iHashIndex++)
    {
		// Walk hash table (and linked lists, if any)
        CPropList* pList = PropTable[iHashIndex];
        while (pList)
        {
			if (pList->Prop.GetPersistState())
			{
				// write out property ID
				dwPropID = pList->Prop.GetPropID();
				MEMCPY(pCur, &dwPropID, sizeof(DWORD));
				pCur += sizeof(DWORD);

				// write out type
				dwType = pList->Prop.GetType();
				MEMCPY(pCur, &dwType, sizeof(DWORD)); 
				pCur += sizeof(DWORD);

				nNumberOfProps++;

			}

            pList = pList->pNext;
        }
    }
	
	// write in number of properties
	MEMCPY(lpvData, &nNumberOfProps, sizeof(DWORD));

	return hr;
}


/********************************************************************
 * @method    STDMETHODIMP | IITPropList | GetDataSize |
 *      Returns the number of bytes needed to save the header
 *
 * @parm LPVOID | lpvHeader | Pointer to a buffer containing the header
 * @parm DWORD | dwHdrSize | Size of the header buffer
 * @parm DWORD& | dwDataSize | Size in bytes
 *
 * @rvalue S_OK | The size was successfully returned
 *
 ********************************************************************/
STDMETHODIMP CITPropList::GetDataSize(LPVOID lpvHeader, DWORD dwHdrSize, DWORD& dwDataSize)
{
	BOOL IsEntry;
	DWORD dwPropID;
	DWORD dwProps;
	HRESULT hr = S_OK;
	LPBYTE pCur = (LPBYTE) lpvHeader;
	DWORD NumberOfBytes = 0;

	CPropList* pList = NULL;
	CPropList* pPrev;     // Not needed, but FindEntry takes it
	int nHashIndex;         // Ditto

	// Number of properties in header
	MEMCPY(&dwProps, pCur, sizeof(DWORD));
	pCur += sizeof(DWORD);

	for (DWORD iProp = 0; iProp < dwProps; iProp++)
	{
		// Read property ID and skip type
		MEMCPY(&dwPropID, pCur, sizeof(DWORD));
		pCur += 2*sizeof(DWORD);

		IsEntry = FindEntry(dwPropID, nHashIndex, &pList, &pPrev);
		if (IsEntry)
		{
			// write out property value
			if (TYPE_VALUE == pList->Prop.GetType())
			{
				NumberOfBytes += sizeof(DWORD);
			}
			else 
			{
				NumberOfBytes += sizeof(DWORD) + pList->Prop.GetSize();
			}

		}
		
	} 

    if (!NumberOfBytes)
        hr = S_FALSE;
	
    NumberOfBytes += (dwProps/8 + 1);
    dwDataSize = NumberOfBytes;
	return hr;
}


/********************************************************************
 * @method    STDMETHODIMP | IITPropList | SaveData |
 *      Saves the data size and data from the property list 
 *      to a buffer. 
 *
 * @parm LPVOID | lpHeader | Pointer to a buffer containing the header
 * @parm DWORD | dwHdrSize | Size of the buffer containing header
 *
 * @parm LPVOID | lpvData | Pointer to a buffer to fill
 * @parm DWORD | dwBufSize | Size of the buffer to fill
 *
 * @rvalue S_OK | The property list was successfully saved
 *
 * @comm The caller is responsible for passing a buffer large enough to
 * hold the property list. 
 ********************************************************************/
STDMETHODIMP CITPropList::SaveData(LPVOID lpvHeader, DWORD dwHdrSize, LPVOID lpvData, DWORD dwBufSize)
{
	// TODO: dwBufSize currently only used to memset buffer, but could be used to check
	// that buffer isn't overrun
    
	HRESULT hr = S_OK;

	DWORD dwPropID;
	DWORD dwValue;
	DWORD cbSize;
	DWORD dwProps;
	LPBYTE pCurData = (LPBYTE) lpvData;
	LPBYTE pBitField = (LPBYTE) lpvData;
	LPBYTE pCurHdr = (LPBYTE) lpvHeader;

	CPropList* pList;
	CPropList* pPrev;   // not needed, but FindEntry takes it
	int nHashIndex;     // ditto
	BOOL IsEntry;

	// Make sure lpvData is 0'd out
	MEMSET(lpvData, 0, dwBufSize);

	// Number of properties in header
	MEMCPY(&dwProps, pCurHdr, sizeof(DWORD));
	pCurHdr += sizeof(DWORD);

	// shift pCurData up to leave room for the property bit field
	pCurData += (dwProps/8 + 1);

	for (DWORD iProp = 0; iProp < dwProps; iProp++)
	{
		// Read property ID
		MEMCPY(&dwPropID, pCurHdr, sizeof(DWORD));
		pCurHdr += 2*sizeof(DWORD);

		IsEntry = FindEntry(dwPropID, nHashIndex, &pList, &pPrev);
		if (IsEntry)
		{
			// Set bit on - bytes are numbered starting with 0, at the left
			// Bits in the byte are filled left to right
			// which byte? and which bit?
			BYTE WhichBit = 0x80 >> (iProp % 8);
			pBitField[iProp/8] |= WhichBit;

			// write out property value
			if (TYPE_VALUE == pList->Prop.GetType())
			{
				// it's a value
				pList->Prop.GetProp(dwValue);
				MEMCPY(pCurData, &dwValue,  sizeof(DWORD));
				pCurData += sizeof(DWORD);
			}
			else 
			{
				// it's a pointer
				// get size first
				cbSize = pList->Prop.GetSize();
				MEMCPY(pCurData, &cbSize, sizeof(DWORD));
				pCurData += sizeof(DWORD);

				pList->Prop.GetProp(lpvData);
				MEMCPY(pCurData, lpvData, cbSize);
				pCurData += cbSize;
			}

		}
		
	} 
  

	return hr;

}

/********************************************************************
 * @method    STDMETHODIMP | IITPropList | SaveDataToStream |
 *      Saves the data size and data from the property list 
 *      to a stream 
 *
 * @parm LPVOID | lpHeader | Pointer to a buffer containing the header
 * @parm DWORD | dwHdrSize | Size of the buffer containing the header
 *
 * @parm IStream* | pStream | Pointer to a stream to fill
 *
 * @rvalue E_OUTOFMEMORY | Memory allocation failed
 * @rvalue STG_E_* | Any of the IStorage/IStream messages that could occur during writing
 * @rvalue S_OK | The property list was successfully saved
 *
 * @comm The caller is responsible for passing a buffer large enough to
 * hold the property list. 
 ********************************************************************/
STDMETHODIMP CITPropList::SaveDataToStream(LPVOID lpvHeader, DWORD dwHdrSize, IStream* pStream)
{
	DWORD dwDataSize;
	GetDataSize(lpvHeader, dwHdrSize, dwDataSize);

	LPBYTE pDataBuffer;
	if (NULL == (pDataBuffer = new BYTE[dwDataSize]))
		return E_OUTOFMEMORY;

	SaveData(lpvHeader, dwHdrSize, pDataBuffer, dwDataSize);
	
	ULONG ulWritten;
	HRESULT hr = pStream->Write(pDataBuffer, dwDataSize, &ulWritten);

	delete pDataBuffer;

	return hr;

}



///////////////////////////// IPersistStreamInit methods //////////////////////////////////

/********************************************************************
 * @method    STDMETHODIMP | IITPropList | GetClassID |
 *     Retrieves the class identifier (CLSID) for the property list object
 *
 * @parm CLSID* | pClassID | Pointer to a CLSID structure.
 *
 * @rvalue S_OK | The CLSID was successfully returned
 *
 * @comm
 ********************************************************************/
STDMETHODIMP CITPropList::GetClassID(CLSID* pClassID)
{
    *pClassID = CLSID_IITPropList;
    return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITPropList | IsDirty |
 *      Indicates whether or not the property list has changed since
 * it was lasted saved.      
 *
 * @rvalue S_OK | The property list has changed
 * @rvalue S_FALSE | The property list has not changed
 *
 * @comm
 ********************************************************************/
STDMETHODIMP CITPropList::IsDirty()
{
    return m_fIsDirty ? S_OK : S_FALSE;
}


/********************************************************************
 * @method    STDMETHODIMP | IITPropList | Load |
 *     Initializes the property list from the stream where it was previously
 * saved.
 *
 * @parm LPSTREAM | pStream | Pointer to the stream from which the property list
 * should be loaded.
 *
 * @rvalue S_OK | The property list was successfully loaded
 *
 * @rvalue E_PROPLISTNOTEMPTY | The property list is not empty. The caller
 * must clear the property list before calling Load.
 * @rvalue E_OUTOFMEMORY | Memory could not be allocated when creating property list.
 *
 * @comm
 ********************************************************************/
STDMETHODIMP CITPropList::Load(LPSTREAM pStream)
{
    HRESULT hr = S_OK;
    ULONG ulRead;
    DWORD dwPropID;
    DWORD cbSize;
    DWORD dwData;
    DWORD dwType;

    LPVOID pString;
	LPVOID pBuffer;

    // What happens if we already have a property list?
    // For now, return an error and force user to clear it
    if (0 != m_cProps)
        return E_PROPLISTNOTEMPTY;

    // We have to allocate a block of memory for the strings
    if (NULL == (pString = BlockInitiate((DWORD)65500, 0, 0, 0)) )
        return E_OUTOFMEMORY;

    // Build a property list from the given stream
    for (;;)
    {
        // Read property ID
        hr = pStream->Read(&dwPropID, sizeof(DWORD), &ulRead);
        if (hr != S_OK || ulRead == 0)            // note hr can be S_FALSE if nothing more to read
            break;

        // Read type
        hr = pStream->Read(&dwType, sizeof(DWORD), &ulRead);
        if (hr != S_OK || ulRead == 0)            // note hr can be S_FALSE if nothing more to read
            break;

        // Read property
        if (TYPE_VALUE == dwType)
        {
			// it's a value
            hr = pStream->Read(&dwData, sizeof(DWORD), &ulRead);
			Set(dwPropID, dwData, PROP_ADD);
        }
        else
        {
			// it's a pointer

            // read size first
            hr = pStream->Read(&cbSize, sizeof(DWORD), &ulRead);
            if (hr != S_OK || ulRead == 0)            // note hr can be S_FALSE if nothing more to read
                break;

            // allocate memory
			BlockReset(pString);
            if (NULL == (pBuffer = BlockCopy(pString, NULL, cbSize, 0)))
			{
				BlockFree(pString);
                return E_OUTOFMEMORY;
			}

            hr = pStream->Read(pBuffer, cbSize, &ulRead);
            if (TYPE_STRING == dwType)
                Set(dwPropID, (LPWSTR) pBuffer, PROP_ADD);
            else
                Set(dwPropID, pBuffer, cbSize, PROP_ADD);
        }

        if (hr != S_OK || ulRead == 0)            // note hr can be S_FALSE if nothing more to read
            break;
    }

    // it's false because we finished reading
    if (hr == S_FALSE)
        hr = NOERROR;

	
	BlockFree(pString);

    return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITPropList | Save |
 *     Saves a property list to the specified stream. Only properties
 *     marked with a persistence state of TRUE are saved.
 *
 * @parm LPSTREAM | pStream | Pointer to the stream where the property list
 * is to be saved.
 *
 * @parm BOOL | fClearDirty | Indicates whether to clear the dirty flag after the save is complete. 
 * If TRUE, the flag should be cleared. If FALSE, the flag should be left unchanged. 
 *
 * @rvalue S_OK | The property list was successfully saved
 * @rvalue STG_E_* | Any of the IStorage errors that could occur during writing
 *
 * @comm
 ********************************************************************/
STDMETHODIMP CITPropList::Save(LPSTREAM pStream, BOOL fClearDirty)
{
    // should we return an error if pList is NULL ?
    HRESULT hr = S_OK;   
    ULONG ulWritten;

	DWORD dwPropID;
	DWORD cbSize;
	DWORD dwValue;
    DWORD dwType;
	LPVOID lpvData;

    for (int iHashIndex = 0; iHashIndex < TABLE_SIZE; iHashIndex++)
    {
		// Walk hash table (and linked lists, if any)
        CPropList* pList = PropTable[iHashIndex];
        while (pList)
        {
			if (pList->Prop.GetPersistState())
			{
				// write out property ID
				dwPropID = pList->Prop.GetPropID();
				hr = pStream->Write(&dwPropID, sizeof(DWORD), &ulWritten);
				if (FAILED(hr))
					return hr;

                // write out property type 
                dwType = pList->Prop.GetType();
			    hr = pStream->Write(&dwType, sizeof(DWORD), &ulWritten);
                if (FAILED(hr))
                    return hr;


				// write out property value
				if (TYPE_VALUE == dwType)
				{
					// it's a value
					pList->Prop.GetProp(dwValue);
					hr = pStream->Write(&dwValue, sizeof(DWORD), &ulWritten);
				}
				else
				{
				    // write out size first
				    cbSize = pList->Prop.GetSize();
				    hr = pStream->Write(&cbSize, sizeof(DWORD), &ulWritten);
				    if (FAILED(hr))
					    return hr;

					pList->Prop.GetProp(lpvData);
					hr = pStream->Write(lpvData, cbSize, &ulWritten);
				}

				if (FAILED(hr))
					return hr;
  
			}

            pList = pList->pNext;
        }
    }
	
	
    if (fClearDirty)
        m_fIsDirty = FALSE;
  
		
	return hr;
    
}


/********************************************************************
 * @method    STDMETHODIMP | IITPropList | GetSizeMax |
 *    Returns the size in bytes of the stream or buffer needed to write
 * the property list.   
 *
 * @parm ULARGE_INTEGER* | pcbsize | Points to a 64-bit unsigned integer
 * value indicating the size in bytes needed to save property list.
 *
 * @rvalue S_OK | The size was successfully returned
 *
 * @comm
 ********************************************************************/
STDMETHODIMP CITPropList::GetSizeMax(ULARGE_INTEGER* pcbsize)
{
    DWORDLONG NumberOfBytes = 0;

    for (int iHashIndex = 0; iHashIndex < TABLE_SIZE; iHashIndex++)
    {
		// Walk hash table (and linked lists, if any)
        CPropList* pList = PropTable[iHashIndex];
        while (pList)
        {
			if (pList->Prop.GetPersistState())
			{
				NumberOfBytes += sizeof(DWORD) + sizeof(DWORD);  // Prop ID and type
				if (TYPE_VALUE == pList->Prop.GetType() )
				{
					NumberOfBytes += sizeof(DWORD);      // DWORD value
				}
				else
				{
                    // Size of buffer
					NumberOfBytes += sizeof(DWORD) + pList->Prop.GetSize();          
				}
			}

            pList = pList->pNext;
        }
    }


    pcbsize->QuadPart = NumberOfBytes;

    return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITPropList | InitNew |
 *    Part of IPersistStreamInit interface.   
 *
 * @rvalue E_NOTIMPL | This method is currently not implemented
 *
 ********************************************************************/
STDMETHODIMP CITPropList::InitNew()
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\orkin\bugout.c ===
/*****************************************************************************
*                                                                            *
*  BUGOUT.C                                                                  *
*                                                                            *
*  Copyright (C) Microsoft Corporation 1991 - 1994.                          *
*  All Rights reserved.                                                      *
*                                                                            *
******************************************************************************
*                                                                            *
*  Module Description: DEBUGGING OUPUT ROUTINES FOR ORKIN DEBUGGING LIBRARY  *
*                                                                            *
******************************************************************************
*                                                                            *
*  Previous Owner: DavidJes                                                  *
*  Current  Owner: RHobbs                                                    *
*                                                                            *
*****************************************************************************/


static char * s_aszModule = __FILE__;   /* For error report */

#include <mvopsys.h>
#include <orkin.h>
#include <stdarg.h>

//
//   the following was ripped off from the \\looney\brothers skelapp2 project:
//

#define SEEK_SET    0    // seek relative to start of file
#define SEEK_CUR    1    // seek relative to current position
#define SEEK_END    2    // seek relative to end of file

/* globals */
int       giDebugLevel = 0;   // current debug level (0 = disabled)
int       gfhDebugFile = -1;  // file handle for debug output (or -1)


#ifdef _DEBUG

/* InitializeDebugOutput(szAppName)
 *
 * Read the current debug level of this application (named <szAppName>)
 * from the [debug] section of win.ini, as well as the current location
 * for debug output.
 */
void FAR PASCAL EXPORT_API InitializeDebugOutput(LPSTR szAppName)
{
#ifndef _MAC
     char      achLocation[300]; // debug output location

     /* debugging is disabled by default (and if an error occurs below) */
     giDebugLevel = 0;
     gfhDebugFile = -1;

     /* get the debug output location */
     if ( (GetProfileString("debug", szAppName, "", achLocation,
                          sizeof(achLocation)) == sizeof(achLocation)) ||
          (achLocation[0] == 0) )
          return;

     if (achLocation[0] == '>')
     {
          /* <achLocation> is the name of a file to overwrite (if
           * a single '>' is given) or append to (if '>>' is given)
           */
          if (achLocation[1] == '>')
               gfhDebugFile = _lopen(achLocation + 2, OF_WRITE);
          else
               gfhDebugFile = _lcreat(achLocation + 1, 0);

          if (gfhDebugFile < 0)
               return;

          if (achLocation[1] == '>')
               _llseek(gfhDebugFile, 0, SEEK_END);
     }
     else
     if (lstrcmpi(achLocation, "aux") != 0)
     {
          /* use OutputDebugString() for debug output */
     }
     else
     {
          /* invalid "location=" -- keep debugging disabled */
          return;
     }

     /* get the debug level */
     giDebugLevel = GetProfileInt("debug", szAppName, 0);
#endif
}


/* TerminateDebugOutput()
 *
 * Terminate debug output for this application.
 */
void FAR PASCAL EXPORT_API TerminateDebugOutput(void)
{
     if (gfhDebugFile >= 0)
          _lclose(gfhDebugFile);
     gfhDebugFile = -1;
     giDebugLevel = 0;
}

/* _DebugPrintf(iDebugLevel, szFormat, szArg1)
 *
 * If the application's debug level is at or above <iDebugLevel>,
 * then output debug string <szFormat> with formatting codes
 * replaced with arguments in the argument list pointed to by <szArg1>.
 */
void FAR PASCAL EXPORT_API _DebugPrintf(int iDebugLevel, LPSTR szFormat, LPSTR szArg1)
{
     static char    ach[300]; // debug output (avoid stack overflow)
     int       cch;      // length of debug output string
     NPSTR          pchSrc, pchDst;
	 char *achT = ach;

     if (giDebugLevel != 0 && giDebugLevel < iDebugLevel)
          return;

	 achT += wsprintf(achT, "%ld:", GetTickCount());
     wvsprintf(achT, szFormat, *((va_list *)szArg1));

     /* expand the newlines into carrige-return-line-feed pairs;
      * first, figure out how long the new (expanded) string will be
      */
     for (pchSrc = pchDst = ach; *pchSrc != 0; pchSrc++, pchDst++)
          if (*pchSrc == '\n')
               pchDst++;

     /* is <ach> large enough? */
     cch = (int)((INT_PTR)pchDst - (INT_PTR)ach); /*** MATTSMI 2/7/92 - cast so that large model version works ***/
     assert(cch < sizeof(ach));
     *pchDst-- = 0;

     /* working backwards, expand \n's to \r\n's */
     while (pchSrc-- > ach)
          if ((*pchDst-- = *pchSrc) == '\n')
               *pchDst-- = '\r';

     /* output the debug string */
     if (gfhDebugFile > 0)
          _lwrite(gfhDebugFile, ach, cch);
#ifndef CHICAGO	// Debug messages mess-up the com ports under chicago!
     else
          OutputDebugString(ach);
#endif
}


/* _DPF1()
 *
 * Helper function called by DPF() macro.
 */
void FAR EXPORT_API _cdecl _DPF1(LPSTR szFormat, // debug output format string
	...)         // placeholder for first argument
{
  va_list valist;

  va_start( valist, szFormat );
    _DebugPrintf(1, szFormat, (LPSTR) &valist);
  va_end( valist );
}


/* _DPF2()
 *
 * Helper function called by DPF2() macro.
 */
void FAR EXPORT_API _cdecl _DPF2(LPSTR szFormat, // debug output format string
	...)         // placeholder for first argument
{
  va_list valist;

  va_start( valist, szFormat );
    _DebugPrintf(2, szFormat, (LPSTR) &valist);
  va_end( valist );
}


/* _DPF3()
 *
 * Helper function called by DPF3() macro.
 */
void FAR EXPORT_API _cdecl _DPF3(szFormat, ...)
LPSTR          szFormat; // debug output format string
{
  va_list valist;

  va_start( valist, szFormat );
    _DebugPrintf(3, szFormat, (LPSTR) &valist);
  va_end( valist );
}


/* _DPF4()
 *
 * Helper function called by DPF4() macro.
 */
void FAR EXPORT_API _cdecl _DPF4(szFormat, ...)
LPSTR          szFormat; // debug output format string
{
  va_list valist;

  va_start( valist, szFormat );
    _DebugPrintf(4, szFormat, (LPSTR) &valist);
  va_end( valist );
}



#else // DEBUG

// stubs for non-debug
void FAR PASCAL EXPORT_API _InitializeDebugOutput(LPSTR szAppName)
{
}


void FAR PASCAL EXPORT_API _TerminateDebugOutput(void)
{
}


void FAR EXPORT_API _cdecl _DPF1(LPSTR szFormat, // debug output format string
	int iArg1, ...)         // placeholder for first argument
{
}


void FAR EXPORT_API _cdecl _DPF2(LPSTR szFormat, // debug output format string
	int iArg1, ...)         // placeholder for first argument
{
}


void FAR EXPORT_API _cdecl _DPF3(szFormat, iArg1, ...)
LPSTR          szFormat; // debug output format string
int       iArg1;         // placeholder for first argument
{
}

void FAR EXPORT_API _cdecl _DPF4(szFormat, iArg1, ...)
LPSTR          szFormat; // debug output format string
int       iArg1;         // placeholder for first argument
{
}



#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\property\prop.cpp ===
#include <atlinc.h>

// just need this one for TYPE_ defines
#include <itpropl.h>

#include "prop.h"

#include <mvopsys.h>
#include <_mvutil.h>


// Inititialization of static members
int CIntProperty::m_cRefCount = 0;
LPVOID CIntProperty::m_pMemPool = NULL;


CIntProperty::CIntProperty()
{
    // ref count is 0 so allocate pool
    if (0 == m_cRefCount)
    {
        m_pMemPool = BlockInitiate((DWORD)65500, 0, 0, 0);
    }

    m_cRefCount++;
}


CIntProperty::~CIntProperty()
{
    m_cRefCount--;

    // ref count has gone to 0, so deallocate pool
    if (0 == m_cRefCount)
    {
        BlockFree(m_pMemPool);
        m_pMemPool = NULL;
    }
}


STDMETHODIMP CIntProperty::SetProp(LPCWSTR lpszwString)
{
    // remember a Unicode char is 2 bytes... We may not really need to
    // store this info.
    m_dwType = TYPE_STRING;

	if (lpszwString)
	{
		m_cbSize = (DWORD) (WSTRLEN(lpszwString) + 1) * sizeof(WCHAR);

		// copy data into pool
		if (NULL == (m_lpszwString = (LPWSTR) BlockCopy(m_pMemPool, (LPBYTE) lpszwString, m_cbSize, 0) ))
			return E_OUTOFMEMORY;
	}
	else
	{
		m_lpszwString = NULL;
		m_cbSize = 0;

	}


    return S_OK;

}


STDMETHODIMP CIntProperty::SetProp(LPVOID lpvData, DWORD cbBufSize)
{
    m_cbSize = cbBufSize;
    m_dwType = TYPE_POINTER;

    // copy data into pool
    if (NULL == (m_lpvData = BlockCopy(m_pMemPool, (LPBYTE)lpvData, m_cbSize, 0) ))
        return E_OUTOFMEMORY;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\property\prop.h ===
// PROP.H : The internal property class

#ifndef __PROP_H__
#define __PROP_H__

class CIntProperty
{
public:
    CIntProperty();
    ~CIntProperty();

    // Access functions
    STDMETHODIMP SetProp(DWORD dwData) { 
                                        m_dwData = dwData;
                                        m_cbSize = sizeof(DWORD);
                                        m_dwType = TYPE_VALUE;
                                        return S_OK; }

    STDMETHODIMP SetProp(LPCWSTR lpszwString);
    STDMETHODIMP SetProp(LPVOID lpvData, DWORD cbBufSize);


    STDMETHODIMP SetPropID(DWORD dwID) { m_dwPropID = dwID;
                                         return S_OK; }
    STDMETHODIMP SetPersistState(BOOL fPersist) { m_fPersist = fPersist; 
                                                 return S_OK; }

    STDMETHODIMP SetType(DWORD dwType) { m_dwType = dwType; 
                                         return S_OK; }

    DWORD GetPropID() { return m_dwPropID; }
	DWORD GetSize() { return m_cbSize; }    
    DWORD GetType() { return m_dwType; }
	STDMETHODIMP GetProp(DWORD& dwData) { dwData = m_dwData;
                                          return S_OK; }
    STDMETHODIMP GetProp(LPWSTR& lpszwString) { lpszwString = m_lpszwString;
											  return S_OK; }
    STDMETHODIMP GetProp(LPVOID& lpvData) { lpvData = m_lpvData;
								           return S_OK; }
    BOOL GetPersistState() { return m_fPersist; }

private:
    DWORD m_dwPropID;
    DWORD m_cbSize;      
    DWORD m_dwType;
    union
    {
        DWORD     m_dwData;
        LPVOID    m_lpvData;
        LPWSTR    m_lpszwString;
    };
    BOOL m_fPersist;

    static int m_cRefCount;
    static LPVOID m_pMemPool;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\property\rsimp.cpp ===
/*************************************************************************
*  @doc SHROOM EXTERNAL API                                              *
*																		 *
*  RSIMP.CPP                                                             *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1997                              *
*  All Rights reserved.                                                  *
*                                                                        *
*  This file contains the implementation of the result set object        *
*  												                         *
*																	     *
**************************************************************************
*                                                                        *
*  Written By   : Erin Foxford                                           *
*  Current Owner: erinfox                                                *
*                                                                        *
**************************************************************************/

#include <mvopsys.h>

#ifdef _DEBUG
static char s_aszModule[] = __FILE__;   /* For error report */
#endif

#include <_mvutil.h>

#include <atlinc.h>       // Includes for ATL
#include <itpropl.h>
#include <itrs.h>
#include <orkin.h>
 
#include "rsimp.h"
#include "prop.h"
#include "plist.h"

#define THEORETICAL_MAX_PROP    30  // This would be a lot of properties - Assert only

const unsigned int CHUNK_SIZE =  512;                // How many "chunks" of rows that can be allocated
const unsigned int ROW_CHUNK = 1024;                 // Number of rows allocated per chunk
const unsigned int ROW_CHUNK_LESS1 = ROW_CHUNK - 1;  // Number of rows minus 1

//                                    optimization for  Real % ROW_CHUNK
#define RealToLogical(Real, Logical) (Logical = Real & ROW_CHUNK_LESS1)

static unsigned int g_iAlloc = 0;
static unsigned int g_iFreed = 0;

CITResultSet::CITResultSet() :  m_PageMap(NULL), m_hResultSet(NULL), 
                                m_AppendRow(0), m_cProp(0), m_NumberOfPages(0),
                                m_fInit(FALSE), m_RowsReserved(0), m_Chunk(-1)  
{
    // Allocate memory for data pool - if allocation fails,
    // how do we notify user?
    m_pMemPool = BlockInitiate((DWORD)16384, 0, 0, 0);
    ITASSERT (NULL != m_pMemPool);

	// Allocate an array of DWORD pointers. These pointers will point to the virtual memory
	// space of the result set
	m_hResultSet = _GLOBALALLOC(GMEM_MOVEABLE | GMEM_ZEROINIT, CHUNK_SIZE*sizeof(DWORD*));
    ITASSERT (NULL != m_hResultSet);
	if (m_hResultSet)
		m_ResultSet = (DWORD_PTR**)_GLOBALLOCK(m_hResultSet);

	// The number of chunks allocated in one shot
	m_NumChunks = CHUNK_SIZE;
}


CITResultSet::~CITResultSet()
{
	// Free up virtual memory
    Clear();

    // Free memory pool
    if (m_pMemPool)
	{
        BlockFree(m_pMemPool);
		m_pMemPool = NULL;
	}

	// Free result set array
	if (m_hResultSet)
	{
		_GLOBALUNLOCK(m_hResultSet);
		_GLOBALFREE(m_hResultSet);
		m_hResultSet = NULL;
	}

}



// We wrap VirtualAlloc(.... MEM_RESERVE) so in the future we can
// make this nothing on the Mac
//
// NOTE: Uses #define PAGE_SIZE, which is defined in mvopsys.h. 
// Currently it's 8k for Alpha, 4k for everything else
//

HRESULT WINAPI CITResultSet::Reserve()
{
#ifdef _DEBUG
	SYSTEM_INFO si;
	GetSystemInfo(&si);
	ITASSERT(PAGE_SIZE == si.dwPageSize);
#endif

	m_Chunk++;

	// we have to realloc...
	if (m_Chunk == m_NumChunks)
	{
        // We're allocating a BUNCH of memory here.  If we hit this code often, we need
        // to redesign our allocation scheme.
        ITASSERT(0);

		_GLOBALUNLOCK(m_hResultSet);
		m_NumChunks += CHUNK_SIZE;
		m_hResultSet = _GLOBALREALLOC(m_hResultSet, m_NumChunks*sizeof(DWORD*), GMEM_MOVEABLE | GMEM_ZEROINIT);
		if (m_hResultSet)
		{
			m_ResultSet = (DWORD_PTR**) _GLOBALLOCK(m_hResultSet);
		}
		else
			return SetErrReturn(E_OUTOFMEMORY);
	}
	

    // Calculate some info we'll need later on
	if (!m_fInit)
	{

		// how many rows fit into a page of memory?
		m_RowsPerPage = PAGE_SIZE/(m_cProp* sizeof(DWORD *));

		// the number of pages in a chunk of rows
		m_NumberOfPages = (m_cProp * ROW_CHUNK * sizeof(DWORD *))/PAGE_SIZE + 1;

		// allocation size in bytes. 
		m_BytesReserved = m_NumberOfPages*PAGE_SIZE;

		if (NULL == (m_PageMap = new BOOL[m_NumberOfPages]))
			return SetErrReturn(E_OUTOFMEMORY);

		m_fInit = TRUE;
	}

    // set page map to 0 - this keeps track of which pages are allocated
    MEMSET(m_PageMap, 0, m_NumberOfPages*sizeof(BOOL));
   
    // reserve memory for an entire chunk - this call shouldn't happen very frequently.
    if (NULL == (m_ResultSet[m_Chunk] = (DWORD_PTR *) VirtualAlloc(NULL, m_BytesReserved, 
                                         MEM_RESERVE, PAGE_READWRITE)))
    {
#ifdef _DEBUG
        int Error = GetLastError( );
        DPF1("CITResultSet::Reserve: MEM_RESERVE faild: %u", Error);
#endif // _DEBUG
        return SetErrReturn(E_OUTOFMEMORY);
    }

#ifdef _DEBUG
	MEMORY_BASIC_INFORMATION MemInfo; 
	VirtualQuery(m_ResultSet[m_Chunk], &MemInfo, sizeof(MEMORY_BASIC_INFORMATION));
#endif // _DEBUG

	m_RowsReserved += ROW_CHUNK;
    
	return S_OK;
}



// Wrapper for VirtualAlloc(... MEM_COMMIT...)
// One possible optimization: replace w/ SEH instead
// of maintaining a page map
HRESULT WINAPI CITResultSet::Commit(LONG RowNum)
{
	LONG LogicalRowNum;
	LONG PageNum;

	RealToLogical(RowNum, LogicalRowNum);
    PageNum = LogicalRowNum/m_RowsPerPage;

    // Only allocate if page hasn't been committed before
	// Note that allocated memory gets zero'd
    if (FALSE == m_PageMap[PageNum])
    {
        // this will allocate a full page
        if (NULL == VirtualAlloc(&m_ResultSet[m_Chunk][ROW_CHUNK * PageNum], PAGE_SIZE,
                                 MEM_COMMIT, PAGE_READWRITE) )
        {
            // TODO: map relevant Win32 error to HRESULT... for now I'm assuming
            // we ran out of memory
#ifdef _DEBUG
            int Error = GetLastError( );
            DPF1("CITResultSet::Reserve: MEM_COMMIT faild: %u", Error);
#endif // _DEBUG
            return SetErrReturn(E_OUTOFMEMORY);
        }
g_iAlloc++;
        m_PageMap[PageNum] = TRUE;
    }


    return S_OK;  
}


/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | Add |
 *     Adds columns to result set, given a header containing pairs
 * of property ID followed by property type
 *
 * @parm LPVOID | lpvHdr | Buffer containing property ID/property pairs
 *      
 * @rvalue S_OK | The columns were successfully added
 * 
 * @xcomm
 *      The format of lpvHdr is identical to the output format of
 *      PorpertyList::SaveHeader.  If PL:SaveHeader changes we
 *      may need to modify this code to maintain compatability.
 *
 ********************************************************************/
STDMETHODIMP CITResultSet::Add(LPVOID lpvHdr)
{
	LPBYTE pCurHdr = (LPBYTE) lpvHdr;
	DWORD dwPropID;
	DWORD dwType;
	DWORD dwProps;
	DWORD dwMax;
	DWORD iProp;   // loop index

	m_cs.Lock();

	// Number of properties in header
	MEMCPY(&dwProps, pCurHdr, sizeof(DWORD));
	pCurHdr += sizeof(DWORD);

	dwMax = m_cProp + dwProps;

	if (dwMax >= MAX_COLUMNS)
	{
		m_cs.Unlock();
		return (SetErrReturn(E_TOOMANYCOLUMNS));
	}

	// For each property in header, create a column
	for (iProp = m_cProp; iProp < dwMax; iProp++)
	{
		// clear header
		MEMSET(&m_Header[iProp], NULL, sizeof(CHeader));

		MEMCPY(&dwPropID, pCurHdr, sizeof(DWORD));
		pCurHdr += sizeof(DWORD);
		MEMCPY(&dwType, pCurHdr, sizeof(DWORD));
		pCurHdr += sizeof(DWORD);

		m_Header[iProp].dwPropID = dwPropID;
		m_Header[iProp].lpvData = NULL;
		m_Header[iProp].dwType = dwType;
		m_Header[iProp].Priority = PRIORITY_NORMAL;   // default priority

	} // end for over properties in header

	m_cProp += dwProps;

	m_cs.Unlock();

	return S_OK;
}



/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | Add |
 *     Adds a column to the result set
 *
 * @parm PROPID | PropID | Property ID associated with column
 * @parm DWORD | dwDefautData | Default data value
 * @parm PRIORITY | Priority | Download priority of column (PRIORITY_LOW, PRIORITY_NORMAL, 
 * or PRIORITY_HIGH)
 *    
 * @rvalue E_OUTOFMEMORY | Memory allocation failed
 * @rvalue S_OK | The column was successfully added
 * 
 * @comm This method is used to add a column for numerical properties.
 ********************************************************************/
STDMETHODIMP CITResultSet::Add(PROPID PropID, DWORD dwDefaultData, PRIORITY Priority)
{
	if (m_cProp >= MAX_COLUMNS)
		return (SetErrReturn(E_TOOMANYCOLUMNS));

    m_cs.Lock();

	// clear header
	MEMSET(&m_Header[m_cProp], NULL, sizeof(CHeader));

    // copy data
    m_Header[m_cProp].dwPropID = PropID;
    m_Header[m_cProp].dwValue = dwDefaultData;
    m_Header[m_cProp].dwType = TYPE_VALUE;
    m_Header[m_cProp].Priority = Priority;   // default priority

    m_cProp++;

    // Wow! This is a lot of properties!
    ITASSERT (m_cProp < THEORETICAL_MAX_PROP);

    m_cs.Unlock();

    return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | Add |
 *     Adds a column to the result set
 *
 * @parm PROPID | PropID | Property ID associated with column
 * @parm LPCWSTR | lpDefaultData | Default value of string
 * @parm PRIORITY | Priority | Download priority of column (PRIORITY_LOW, PRIORITY_NORMAL, 
 * or PRIORITY_HIGH)
 *    
 * @rvalue E_OUTOFMEMORY | Memory allocation failed
 * @rvalue S_OK | The column was successfully added
 * 
 * @comm This method is used to add a column for string properties.
 ********************************************************************/
STDMETHODIMP CITResultSet::Add(PROPID PropID, LPCWSTR lpszwDefault, PRIORITY Priority)
{
	if (m_cProp >= MAX_COLUMNS)
		return (SetErrReturn(E_TOOMANYCOLUMNS));

    m_cs.Lock();

	// clear header
	MEMSET(&m_Header[m_cProp], NULL, sizeof(CHeader));

    // copy data
	if (lpszwDefault)
	{
		LPBYTE pBuffer;
		DWORD cbData = (DWORD)(WSTRLEN(lpszwDefault) + 1) * sizeof(WCHAR);
		if (NULL == (pBuffer = (LPBYTE) BlockCopy(m_pMemPool, NULL, cbData + 4, 0)))
		{
			m_cs.Unlock();
			return SetErrReturn(E_OUTOFMEMORY);
		}

		MEMCPY(pBuffer + sizeof (DWORD), lpszwDefault, cbData);
		*(LPDWORD)pBuffer = cbData;

		m_Header[m_cProp].lpvData = pBuffer;
	}
	else
		m_Header[m_cProp].lpvData = NULL;

    m_Header[m_cProp].dwPropID = PropID;
    m_Header[m_cProp].dwType = TYPE_STRING;
    m_Header[m_cProp].Priority = Priority;   // default priority

    m_cProp++;
    // Wow! This is a lot of properties!
    ITASSERT (m_cProp < THEORETICAL_MAX_PROP);

    m_cs.Unlock();

    return S_OK;
}



/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | Add |
 *     Adds a column to the result set
 *
 * @parm PROPID | PropID | Property ID associated with column
 * @parm LPVOID | lpvDefaultData | Buffer containing default value of data
 * @parm DWORD | cbData | Size of buffer
 * @parm PRIORITY | Priority | Download priority of column (PRIORITY_LOW, PRIORITY_NORMAL, 
 * or PRIORITY_HIGH)
 *    
 * @rvalue E_OUTOFMEMORY | Memory allocation failed
 * @rvalue S_OK | The column was successfully added
 * 
 * @comm This method is used to add a column for pointer properties.
 ********************************************************************/
STDMETHODIMP CITResultSet::Add(PROPID PropID, LPVOID lpvDefaultData, DWORD cbData, PRIORITY Priority)
{
	if (m_cProp >= MAX_COLUMNS)
		return (SetErrReturn(E_TOOMANYCOLUMNS));

    m_cs.Lock();

	// clear header
	MEMSET(&m_Header[m_cProp], NULL, sizeof(CHeader));

    // copy data
	if (lpvDefaultData)
	{
		LPBYTE pBuffer;
		if (NULL == (pBuffer = (LPBYTE) BlockCopy(m_pMemPool, NULL, cbData + 4, 0)))
		{
			m_cs.Unlock();
			return SetErrReturn(E_OUTOFMEMORY);
		}

		MEMCPY(pBuffer + 4, lpvDefaultData, cbData);
		*(LPDWORD)pBuffer = cbData;

		m_Header[m_cProp].lpvData = pBuffer;

	}
	else
		m_Header[m_cProp].lpvData = NULL;

    m_Header[m_cProp].dwPropID = PropID;
    m_Header[m_cProp].dwType = TYPE_POINTER;
    m_Header[m_cProp].Priority = Priority;   // default priority

    m_cProp++;
    // Wow! This is a lot of properties!
    ITASSERT (m_cProp < THEORETICAL_MAX_PROP);

    m_cs.Unlock();

    return S_OK;
}

/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | SetColumnPriority |
 *     Sets the download priority for the given column in the result set
 *
 * @parm LONG | lColumnIndex | Index of column to set
 * @parm PRIORITY | Priority | Priority, which can be one of the following:
 *
 * @flag PRIORITY_LOW | Low priority
 * @flag PRIORITY_NORMAL | Normal priority
 * @flag PRIORITY_HIGH | High priority
 *    
 * @rvalue E_NOTEXIST | Column does not exist
 * @rvalue S_OK | The priority was successfully set
 ********************************************************************/
STDMETHODIMP CITResultSet::SetColumnPriority(LONG lColumnIndex, PRIORITY ColumnPriority)
{
	if (lColumnIndex >= m_cProp || lColumnIndex < 0)
		return SetErrReturn(E_NOTEXIST);

    m_cs.Lock();

	m_Header[lColumnIndex].Priority = ColumnPriority;

    m_cs.Unlock();
    
    return S_OK;
}

/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | SetColumnHeap |
 *     Sets the heap which DWORD values in this column point into.
 *
 * @parm LONG | lColumnIndex | Index of column to set
 * @parm LPVOID | lpvHeap | Pointer to the heap.
 * @parm PFNCOLHEAPFREE | pfnColHeapFree |
 *		Pointer to a function which can be called to free the heap
 *		when the result set is cleared or freed.
 *
 *    
 * @rvalue E_NOTEXIST | Column does not exist
 * @rvalue S_OK | The heap was successfully set
 ********************************************************************/
STDMETHODIMP CITResultSet::SetColumnHeap(LONG lColumnIndex, LPVOID lpvHeap,
												PFNCOLHEAPFREE pfnColHeapFree)
{
	HRESULT	hr = S_OK;

	if (lColumnIndex < 0)
		return SetErrReturn(E_INVALIDARG);

    m_cs.Lock();

	if (lColumnIndex >= m_cProp)
		hr = E_NOTEXIST;
	else
		if (m_Header[lColumnIndex].lpvHeap != NULL)
			hr = E_ALREADYINIT;

	if (SUCCEEDED(hr))
	{
		m_Header[lColumnIndex].lpvHeap = lpvHeap;
		m_Header[lColumnIndex].pfnHeapFree = pfnColHeapFree;
	}

    m_cs.Unlock();
    
    return (hr);
}

/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | GetColumnPriority |
 *     Gets the download priority for the given column in the result set
 *
 * @parm LONG | lColumnIndex | Index of column to get
 * @parm PRIORITY& | Priority | Priority, which can be one of the following:
 *
 * @flag PRIORITY_LOW | Low priority
 * @flag PRIORITY_NORMAL | Normal priority
 * @flag PRIORITY_HIGH | High priority
 *    
 * @rvalue E_NOTEXIST | Column does not exist
 * @rvalue S_OK | The priority was successfully retrieved
 ********************************************************************/
STDMETHODIMP CITResultSet::GetColumnPriority(LONG lColumnIndex, PRIORITY& ColumnPriority)
{
	if (lColumnIndex >= m_cProp || lColumnIndex < 0)
		return SetErrReturn(E_NOTEXIST);

	ColumnPriority = m_Header[lColumnIndex].Priority;    
    return S_OK;
}

/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | SetKeyProp |
 *     Sets the property to be used as the key.
 *
 * @parm PROPID | KeyPropID | Property ID
 *
 * @rvalue S_OK | The key property was successfully set
 * 
 ********************************************************************/
inline STDMETHODIMP CITResultSet::SetKeyProp(PROPID KeyPropID)
{
	m_cs.Lock();

    m_dwKeyProp = KeyPropID;

	m_cs.Unlock();
    return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | GetKeyProp |
 *     Retrieves the property used as the key
 *
 * @parm PROPID | KeyPropID | Property ID
 *
 * @rvalue S_OK | The key property was successfully retrieved
 * 
 ********************************************************************/
inline STDMETHODIMP CITResultSet::GetKeyProp(PROPID& KeyPropID)
{
    KeyPropID = m_dwKeyProp;
    return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | Append |
 *     Given header (prop ID and type) and data, this function forms a
 *     row and appends it to the current result set
 *
 * @parm LPVOID | lpvHdr | Pointer to buffer containing header
 * @parm LPVOID | lpvData | Pointer to buffer containing data
 *
 * @rvalue E_INVALIDARG | Exceeded maximum number of rows
 * @rvalue E_OUTOFMEMORY | Memory allocation failed
 * @rvalue S_FALSE | No columns were found to set, but no failure occurred
 * @rvalue S_OK | The row was successfully filled in
 * 
 * @xcomm
 *      The format of lpvHdr is identical to the output format of
 *      PorpertyList::SaveData.  If PL:Savedata changes we may
 *      need to modify this code to maintain compatability.
 *
 ********************************************************************/
STDMETHODIMP CITResultSet::Append(LPVOID lpvHdr, LPVOID lpvData)
{
	return Set(m_AppendRow, lpvHdr, lpvData);
}


/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | Set |
 *     Given header (prop ID and type) and data, this function puts
 * the information into the specified row in the result set
 *
 * @parm LONG | lRowIndex | Index of row in result set
 * @parm LPVOID | lpvHdr | Pointer to buffer containing header
 * @parm LPVOID | lpvData | Pointer to buffer containing data
 *
 * @rvalue E_INVALIDARG | Exceeded maximum number of rows
 * @rvalue E_OUTOFMEMORY | Memory allocation failed
 * @rvalue S_FALSE | No columns were found to set, but no failure occurred
 * @rvalue S_OK | The row was successfully filled in
 *
 * @xcomm
 *      The format of lpvHdr is identical to the output format of
 *      PorpertyList::SaveData.  If PL:Savedata changes we may
 *      need to modify this code to maintain compatability.
 *
 ********************************************************************/
STDMETHODIMP CITResultSet::Set(LONG lRowIndex, LPVOID lpvHdr, LPVOID lpvData)
{

	LPBYTE pCurHdr = (LPBYTE) lpvHdr;
	LPBYTE pCurData = (LPBYTE) lpvData;
	LPBYTE pBitField = (LPBYTE) lpvData;
	DWORD dwProps;
	DWORD dwPropID;
	DWORD dwType;
    LPBYTE pBuffer;
	DWORD cbSize;
	LONG lColumn;
	HRESULT hr = S_FALSE;

	m_cs.Lock();

	// Reserve memory if necessary
	if (lRowIndex >= m_RowsReserved)
	{
		if ( FAILED(Reserve()) )
		{
			m_cs.Unlock();
			return SetErrReturn(E_OUTOFMEMORY);
		}
	}

    // Commit memory
    if ( FAILED(Commit(lRowIndex)) )
    {
        m_cs.Unlock();
        return SetErrReturn(E_OUTOFMEMORY);
    }

	LONG LogicalRow;
	RealToLogical(lRowIndex, LogicalRow);
	LONG nRow = LogicalRow * m_cProp;
	LONG nChunk = lRowIndex/ROW_CHUNK;
	
	// Number of properties in header
	MEMCPY(&dwProps, pCurHdr, sizeof(DWORD));
	pCurHdr += sizeof(DWORD);

	// Shift pCurData up to leave room for the property bit field
	pCurData += (dwProps/8 + 1);

	// For each property in header, look for matching result set column
	for (DWORD iProp = 0; iProp < dwProps; iProp++)
	{
		MEMCPY(&dwPropID, pCurHdr, sizeof(DWORD));
		pCurHdr += sizeof(DWORD);
		MEMCPY(&dwType, pCurHdr, sizeof(DWORD));
		pCurHdr += sizeof(DWORD);

		// UNDONE: Figure out an optimization. If columns match up w/ header,
		// then by the time we get to the end of the header, we'll have to loop
		// over ALL the columns just to find which the column that matches the 
		// property ID. The problem is, it's not guaranteed that the columns
		// match up exactly; the user could set them in any order.

		// Is there data for this property?
		BYTE WhichBit = (0x80 >> (iProp % 8));
		int BitSet = pBitField[iProp/8] & WhichBit;

		HRESULT hrFound = GetColumnFromPropID(dwPropID, lColumn);
		if (SUCCEEDED(hrFound))
			hr = S_OK;            // found at least one column

		if (BitSet)
		{
			if (TYPE_VALUE == dwType)
			{
				// copy data value
				if (SUCCEEDED(hrFound))
					m_ResultSet[nChunk][nRow + lColumn] = *(LPDWORD) pCurData;

				// if user didn't specify column, we still need to skip the data for
				// this property
				pCurData += sizeof(DWORD);

			}
			else
			{
				// get size
				MEMCPY(&cbSize, pCurData, sizeof(DWORD));
				pCurData += sizeof(DWORD);

				if (SUCCEEDED(hrFound))
				{
					if (NULL == (pBuffer = (LPBYTE) BlockCopy(m_pMemPool, NULL, cbSize + 4, 0)))
					{
						m_cs.Unlock();
						return SetErrReturn(E_OUTOFMEMORY);
					}

					// append size to data
					MEMCPY(pBuffer + 4, pCurData, cbSize);
					*(LPDWORD)pBuffer = cbSize;
					m_ResultSet[nChunk][nRow + lColumn] = (DWORD_PTR) pBuffer; 
				}

				pCurData += cbSize;
			}

		}
		else
		{
			// No, so use default
			if (SUCCEEDED(hrFound))
				m_ResultSet[nChunk][nRow + lColumn] = (DWORD_PTR) m_Header[lColumn].lpvData;
		}


	} // end for over properties in header


    // Always maintain one past the last row as the append row
	// unless we didn't put anything in the result set
    if ( (lRowIndex >= m_AppendRow) && (S_OK == hr))
        m_AppendRow = lRowIndex + 1;


	m_cs.Unlock();

	return hr;
}





/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | Set |
 *    Sets the property in the specified row to the property value.
 *
 * @parm LONG | lRowIndex | Row in which property belongs
 * @parm LONG | lColumnIndex | Column in which property belongs
 * @parm DWORD | dwData | Data to set
 *
 * @rvalue E_INVALIDARG | Exceed maximum row count
 * @rvalue E_NOTEXIST | Column does not exist
 * @rvalue E_OUTOFMEMORY | Memory allocation failed
 * @rvalue S_OK | The row was successfully set
 ********************************************************************/
STDMETHODIMP CITResultSet::Set(LONG lRowIndex, LONG lColumnIndex, DWORD dwData)
{
	if (lColumnIndex >= m_cProp || lColumnIndex < 0)
		return SetErrReturn(E_NOTEXIST);

    m_cs.Lock();

	// Reserve memory if necessary
	if (lRowIndex >= m_RowsReserved)
	{
		if ( FAILED(Reserve()) )
		{
			m_cs.Unlock();
			return SetErrReturn(E_OUTOFMEMORY);
		}
	}
  
        
    // Commit memory
    if ( FAILED(Commit(lRowIndex)) )
    {
        m_cs.Unlock();
        return SetErrReturn(E_OUTOFMEMORY);
    }

	LONG LogicalRow;
	RealToLogical(lRowIndex, LogicalRow);
	LONG nRow = LogicalRow * m_cProp;
	LONG nChunk = lRowIndex/ROW_CHUNK;

    m_ResultSet[nChunk][nRow + lColumnIndex] = dwData;

    // always maintain one past the last row as the append row
    if (lRowIndex >= m_AppendRow)
        m_AppendRow = lRowIndex + 1;

    m_cs.Unlock();

    return S_OK;
}

/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | Set |
 *    Sets the property in the specified row to the property value.
 *
 * @parm LONG | lRowIndex | Row in which property belongs
 * @parm LONG | lColumnIndex | Column in which property belongs
 * @parm DWORD | dwData | Data to set
 *
 * @rvalue E_INVALIDARG | Exceed maximum row count
 * @rvalue E_NOTEXIST | Column does not exist
 * @rvalue E_OUTOFMEMORY | Memory allocation failed
 * @rvalue S_OK | The row was successfully set
 ********************************************************************/
STDMETHODIMP CITResultSet::Set(LONG lRowIndex, LONG lColumnIndex, DWORD_PTR dwData)
{
	if (lColumnIndex >= m_cProp || lColumnIndex < 0)
		return SetErrReturn(E_NOTEXIST);

    m_cs.Lock();

	// Reserve memory if necessary
	if (lRowIndex >= m_RowsReserved)
	{
		if ( FAILED(Reserve()) )
		{
			m_cs.Unlock();
			return SetErrReturn(E_OUTOFMEMORY);
		}
	}
  
        
    // Commit memory
    if ( FAILED(Commit(lRowIndex)) )
    {
        m_cs.Unlock();
        return SetErrReturn(E_OUTOFMEMORY);
    }

	LONG LogicalRow;
	RealToLogical(lRowIndex, LogicalRow);
	LONG nRow = LogicalRow * m_cProp;
	LONG nChunk = lRowIndex/ROW_CHUNK;

    m_ResultSet[nChunk][nRow + lColumnIndex] = dwData;

    // always maintain one past the last row as the append row
    if (lRowIndex >= m_AppendRow)
        m_AppendRow = lRowIndex + 1;

    m_cs.Unlock();

    return S_OK;
}

/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | Set |
 *    Sets the property in the specified row to the property value.
 *
 * @parm LONG | lRowIndex | Row in which property belongs
 * @parm LPCWSTR | lpszString | Data to set
 *
 * @rvalue E_INVALIDARG | Exceed maximum row count
 * @rvalue E_NOTEXIST | Column does not exist
 * @rvalue E_OUTOFMEMORY | Memory allocation failed
 * @rvalue S_OK | The row was successfully set
 ********************************************************************/
STDMETHODIMP CITResultSet::Set(LONG lRowIndex, LONG lColumnIndex, LPCWSTR lpszString)
{

	if (lColumnIndex >= m_cProp || lColumnIndex < 0)
		return SetErrReturn(E_NOTEXIST);

    m_cs.Lock();

	// Reserve memory if necessary
	if (lRowIndex >= m_RowsReserved)
	{
		if ( FAILED(Reserve()) )
		{
			m_cs.Unlock();
			return SetErrReturn(E_OUTOFMEMORY);
		}
	}
  
        
    // Commit memory
    if ( FAILED(Commit(lRowIndex)) )
    {
        m_cs.Unlock();
        return SetErrReturn(E_OUTOFMEMORY);
    }

	LONG LogicalRow;
	RealToLogical(lRowIndex, LogicalRow);
	LONG nRow = LogicalRow * m_cProp;
	LONG nChunk = lRowIndex/ROW_CHUNK;

	
	DWORD cbData = 0;
	if (lpszString)
		cbData = (DWORD) (2*(WSTRLEN(lpszString) + 1));
	
	LPBYTE pBuffer = (LPBYTE) BlockCopy(m_pMemPool, NULL, cbData + sizeof (DWORD), 0);
	if (NULL == pBuffer)
	{
		m_cs.Unlock();
		return SetErrReturn(E_OUTOFMEMORY);
	}
	MEMCPY(pBuffer + 4, lpszString, cbData);
	*(LPDWORD)pBuffer =  cbData;
	m_ResultSet[nChunk][nRow + lColumnIndex] = (DWORD_PTR) pBuffer; 

    // always maintain one past the last row as the append row
    if (lRowIndex >= m_AppendRow)
        m_AppendRow = lRowIndex + 1;
    
	m_cs.Unlock();

    return S_OK;
}

/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | Set |
 *    Sets the property in the specified row to the property value.
 *
 * @parm LONG | lRowIndex | Row in which property belongs
 * @parm DWORD | dwData | Data to set
 *
 * @rvalue E_INVALIDARG | Exceed maximum row count
 * @rvalue E_NOTEXIST | Column does not exist
 * @rvalue E_OUTOFMEMORY | Memory allocation failed
 * @rvalue S_OK | The row was successfully set
 ********************************************************************/
STDMETHODIMP CITResultSet::Set(LONG lRowIndex, LONG lColumnIndex, LPVOID lpvData, DWORD cbData)
{

	if (lColumnIndex >= m_cProp || lColumnIndex < 0)
		return SetErrReturn(E_NOTEXIST);

    m_cs.Lock();

	// Reserve memory if necessary
	if (lRowIndex >= m_RowsReserved)
	{
		if ( FAILED(Reserve()) )
		{
			m_cs.Unlock();
			return SetErrReturn(E_OUTOFMEMORY);
		}
	}
  
        
    // Commit memory
    if ( FAILED(Commit(lRowIndex)) )
    {
        m_cs.Unlock();
        return SetErrReturn(E_OUTOFMEMORY);
    }
	
	LONG LogicalRow;
	RealToLogical(lRowIndex, LogicalRow);
	LONG nRow = LogicalRow * m_cProp;
	LONG nChunk = lRowIndex/ROW_CHUNK;

	LPBYTE pBuffer = (LPBYTE) BlockCopy(m_pMemPool, NULL, cbData + sizeof (DWORD), 0);
	if (NULL == pBuffer)
	{
		m_cs.Unlock();
		return SetErrReturn(E_OUTOFMEMORY);
	}
	*(LPDWORD)pBuffer = cbData;
	MEMCPY(pBuffer + sizeof (DWORD), lpvData, cbData);
	m_ResultSet[nChunk][nRow + lColumnIndex] = (DWORD_PTR) pBuffer; 

    // always maintain one past the last row as the append row
    if (lRowIndex >= m_AppendRow)
        m_AppendRow = lRowIndex + 1;

    m_cs.Unlock();

    return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | Get |
 *    Gets the property in the specified row and column and fills the given 
 * property object.
 *
 * @parm LONG | lRowIndex | Row in which property belongs
 * @parm LONG | lColumnIndex | Column in which property belongs
 * @parm CProperty& | Prop | Property object to fill
 *
 * @rvalue E_NOTEXIST | The row or column does not exist in the row set
 * @rvalue S_OK | The row was successfully retrieved
 *
 ********************************************************************/
STDMETHODIMP CITResultSet::Get(LONG lRowIndex, LONG lColumnIndex, CProperty& Prop)
{
	
    if (lRowIndex >= m_AppendRow || lColumnIndex >= m_cProp)
        return SetErrReturn(E_NOTEXIST);

	LONG LogicalRow;
	RealToLogical(lRowIndex, LogicalRow);
	LONG nRow = LogicalRow * m_cProp;
	LONG nChunk = lRowIndex/ROW_CHUNK;

	Prop.dwPropID = m_Header[lColumnIndex].dwPropID;
    if (TYPE_VALUE == (Prop.dwType = m_Header[lColumnIndex].dwType))
    {
		// For data types, we have no way of knowing how to return
		// the default, so we just return 0 if this cell was never filled in
        Prop.lpvData = (LPVOID) m_ResultSet[nChunk][nRow+lColumnIndex]; 
        Prop.dwValue = (DWORD) m_ResultSet[nChunk][nRow+lColumnIndex];
        Prop.cbData = sizeof(DWORD);
    }
    else
    {
        LPBYTE pBuffer = (LPBYTE) m_ResultSet[nChunk][nRow+lColumnIndex]; 

		if (pBuffer)
		{
			Prop.cbData = *(LPDWORD)pBuffer;
			Prop.lpvData = pBuffer + sizeof (DWORD);
		}
		else
		{
			// there's nothing there, so return default
			if (m_Header[lColumnIndex].lpvData)
			{
				Prop.cbData = *(LPDWORD) m_Header[lColumnIndex].lpvData;
				Prop.lpvData = (LPDWORD)(m_Header[lColumnIndex].lpvData) + 1;
			}
			else
			{
				// default was specified as NULL, so we make sure we
				// return that
				Prop.cbData = 0;
				Prop.lpvData = NULL;
			}
		}
    }
 
    return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | GetColumnCount |
 *    Gets number of columns in result set
 *
 * @parm LONG& | lNumberOfColumns | Number of columns
 *
 * @rvalue S_OK | The number of columns was successfully retrieved
 *
 ********************************************************************/
inline STDMETHODIMP CITResultSet::GetColumnCount(LONG& lNumberOfColumns)
{
    lNumberOfColumns = m_cProp;
    return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | GetRowCount |
 *    Gets number of rows in result set
 *
 * @parm LONG& | lNumberOfRows | Number of rows
 *
 * @rvalue S_OK | The number of rows was successfully retrieved
 *
 ********************************************************************/
inline STDMETHODIMP CITResultSet::GetRowCount(LONG& lNumberOfRows)
{
	lNumberOfRows = m_AppendRow;
	return S_OK;
}



/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | GetColumn|
 *    Gets property ID and default value associated with a column. 
 *
 * @parm LONG | lColumnIndex | Column number 
 * @parm PROPID | PropID | Property ID
 * @parm DWORD | dwType | Property Type (TYPE_VALUE, TYPE_POINTER, TYPE_STRING)
 * @parm LPVOID& | lpvDefaultValue | Default value
 * @parm DWORD& | cbSize |Length of data (in bytes)
 * @parm PRIORITY& | Priority | Column priority
 *
 * @rvalue E_NOTEXIST | Column does not exist
 * @rvalue S_OK | The column was successfully retrieved
 *
 ********************************************************************/
STDMETHODIMP CITResultSet::GetColumn(LONG lColumnIndex, PROPID& PropID, DWORD& dwType, LPVOID& lpvDefaultValue, 
									 DWORD& cbSize, PRIORITY& Priority)
{
    // check against invalid lColumnIndex
    if (lColumnIndex >= m_cProp || lColumnIndex < 0)
        return SetErrReturn(E_NOTEXIST);

	PropID = m_Header[lColumnIndex].dwPropID;
	dwType = m_Header[lColumnIndex].dwType;

	// it could be NULL
	if (m_Header[lColumnIndex].lpvData)
	{
		lpvDefaultValue = (LPBYTE) m_Header[lColumnIndex].lpvData + sizeof (DWORD);
		if (TYPE_VALUE == dwType)
			cbSize = sizeof(DWORD);
		else
			cbSize = *((LPDWORD)m_Header[lColumnIndex].lpvData);
	}
	else
	{
		lpvDefaultValue = NULL;
		cbSize = 0;
	}

	Priority = m_Header[lColumnIndex].Priority;

    return S_OK;
}

/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | GetColumn|
 *    Gets property ID for a given column index.
 *
 * @parm LONG | lColumnIndex | Column number 
 * @parm PROPID | PropID | Property ID
 *
 * @rvalue E_NOTEXIST | Column does not exist
 * @rvalue S_OK | The column was successfully retrieved
 *
 ********************************************************************/
STDMETHODIMP CITResultSet::GetColumn(LONG lColumnIndex, PROPID& PropID)
{
    // check against invalid lColumnIndex
    if (lColumnIndex >= m_cProp || lColumnIndex < 0)
        return SetErrReturn(E_NOTEXIST);

	PropID = m_Header[lColumnIndex].dwPropID;

    return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | GetColumnFromPropID |
 *      Gets column index for which a property ID is associated
 *
 * @parm PROPID | PropID | Property ID
 * @parm LONG& | lColumnIndex | Column index
 *
 * @rvalue E_NOTEXIST | The column does not exist
 * @rvalue S_OK | The column index was successfully returned
 *
 ********************************************************************/
STDMETHODIMP CITResultSet::GetColumnFromPropID(PROPID PropID, LONG& lColumnIndex)
{
    // Loop over all columns, looking for match
    for (LONG iIndex = 0; iIndex < m_cProp; iIndex++)
    {
        if (PropID == m_Header[iIndex].dwPropID)
        {
            // Found it
			lColumnIndex = iIndex;
            return S_OK;
        }
    }

	return SetErrReturn(E_NOTEXIST);
}


/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | AppendRows|
 *    Appends rows from the given source resultset
 *
 * @parm IITResultSet* | pResSrc | Source resultset
 * @parm LONG | lRowSrcFirst | Source row number to start the copy
 * @parm LONG | cSrcRows | Number of rows to append
 * @parm LONG& | lRowFirstDest | First destination row number appended
 *
 * @rvalue E_OUTOFMEMORY | Not enough memory to append to the destination
 * @rvalue S_OK | All rows were successfully appended
 *
 ********************************************************************/
// UNDONE: this is terribly inefficient.  We need to fix resultsets so that rows can
// be copied more easily
STDMETHODIMP CITResultSet::AppendRows(IITResultSet* pResSrc, LONG lRowSrcFirst, LONG cSrcRows, 
									LONG& lRowDestFirst)
{
	LONG lColumn;
	HRESULT hr = E_NOTEXIST;
	PROPID PropID;
	LONG lDestColumn;
	CProperty Prop;
	
	lRowDestFirst = m_AppendRow;

	m_cs.Lock();

	pResSrc->GetColumnCount(lColumn);

	// Loop over columns in source result set
	for (LONG iProp = 0; iProp < lColumn; iProp++)
	{
		// get column in dest result set
		pResSrc->GetColumn(iProp, PropID);
		if (FAILED(GetColumnFromPropID(PropID, lDestColumn)))
			continue;

		hr = S_OK;    // there's at least one matching column
		// Loop over rows in input result set
    	LONG iRow;   // loop index
		switch( m_Header[lDestColumn].dwType )
		{
			case TYPE_VALUE:
				for (iRow = 0; iRow < cSrcRows; iRow++)
				{
					pResSrc->Get(lRowSrcFirst + iRow, iProp, Prop);
					Set(lRowDestFirst + iRow, lDestColumn, Prop.dwValue);
				}
				break;
			case TYPE_STRING:
				for (iRow = 0; iRow < cSrcRows; iRow++)
				{
					pResSrc->Get(lRowSrcFirst + iRow, iProp, Prop);
					Set(lRowDestFirst + iRow, lDestColumn, Prop.lpszwData);
				}
				break;
			case TYPE_POINTER:
				for (iRow = 0; iRow < cSrcRows; iRow++)
				{
					pResSrc->Get(lRowSrcFirst + iRow, iProp, Prop);
					Set(lRowDestFirst + iRow, lDestColumn, Prop.lpvData, Prop.cbData);
				}
				break;
		}
	}

	m_cs.Unlock();

	return hr;
}


/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | Copy |
 *		Copies the rows associated with the columns set in the 
 * given result set. This method can be used to take a larger result
 * set and reduce it   Passing an empty resultset will cause all columns
 * and rows to be added and copied from the source resultset. 
 *
 * @parm IITResultSet* | pRSCopy | Result set object containing copied
 * rows.
 *
 * @rvalue E_NOTEXIST | No columns match the input result set
 *
 * @rvalue S_OK | The rows were successfully copied.
 *
 ********************************************************************/
STDMETHODIMP CITResultSet::Copy(IITResultSet* pRSCopy)
{
	LONG lColumn;
	HRESULT hr;

	pRSCopy->GetColumnCount(lColumn);
	if (0L == lColumn)
	{
		LONG cCols;
		LONG iCol;
		// add all columns from the source to the dest
		GetColumnCount(cCols);
		for (iCol = 0; iCol < cCols; iCol++)
		{
			PROPID pid;
			DWORD dwType;
			LPVOID lpv;
			DWORD cbSize;
			PRIORITY pri;

			// UNDONE: get rid of this dwType stuff
			// UNDONE: simpler place to put column info (i.e. struct/class)
			GetColumn(iCol, pid, dwType, lpv, cbSize, pri);

			if (dwType == TYPE_VALUE)
			{
				if (FAILED(hr = pRSCopy->Add(pid, (DWORD)0, PRIORITY_NORMAL)))
					return hr;
			}
			else
			{
				if (FAILED(hr= pRSCopy->Add(pid, (LPWSTR)0, PRIORITY_NORMAL)))
					return hr;
			}
		}
		lColumn = cCols;
	}

	PROPID PropID;
	LONG lInputColumn;
	CProperty Prop;

	m_cs.Lock();
    hr = E_NOTEXIST;

	// Loop over columns in output result set
	for (LONG iProp  = 0; iProp < lColumn; iProp++)
	{
		// get column in input result set
		pRSCopy->GetColumn(iProp, PropID);  
		if (FAILED(GetColumnFromPropID(PropID, lInputColumn)))
			continue;

		hr = S_OK;    // there's at least one matching column
		// Loop over rows in input result set
    	LONG iRow;   // loop index
		switch( m_Header[lInputColumn].dwType )
		{
			case TYPE_VALUE:
				for (iRow = 0; iRow < m_AppendRow; iRow++)
				{
					Get(iRow, lInputColumn, Prop);
					pRSCopy->Set(iRow, iProp, Prop.dwValue);
				}
				break;
			case TYPE_STRING:
				for (iRow = 0; iRow < m_AppendRow; iRow++)
				{
					Get(iRow, lInputColumn, Prop);
					pRSCopy->Set(iRow, iProp, Prop.lpszwData);
				}
				break;
			case TYPE_POINTER:
				for (iRow = 0; iRow < m_AppendRow; iRow++)
				{
					Get(iRow, lInputColumn, Prop);
					pRSCopy->Set(iRow, iProp, Prop.lpvData, Prop.cbData);
				}
				break;
		}
	}

	m_cs.Unlock();

	return hr;
}

/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | Clear |
 *      Frees all memory associated with a result set
 *
 * @rvalue S_OK | The result set was successfully cleared
 *
 * @comm This method can be called to clear a result set without
 * requiring the set to be destroyed before being used again.    
 ********************************************************************/
STDMETHODIMP CITResultSet::Clear()
{
	LONG	iProp;

	m_cs.Lock();

	// Free any column heaps which may have been set.
	for (iProp = 0; iProp < m_cProp; iProp++)
	{
		LPVOID	lpvHeap;
		PFNCOLHEAPFREE pfnHeapFree;

		if ((lpvHeap = m_Header[iProp].lpvHeap) != NULL &&
			(pfnHeapFree = m_Header[iProp].pfnHeapFree) != NULL)
		{
			(*pfnHeapFree)(lpvHeap);
		}
	}

	ClearRows();
	m_cProp = 0;

	m_cs.Unlock();

    return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITResultSet | ClearRows |
 *      Frees all memory associated with a result set, without 
 *   resetting column information
 *
 * @rvalue S_OK | The result set was successfully cleared
 *
 * @comm This method can be called to clear a result set without
 * requiring the set to be destroyed before being used again.    
 ********************************************************************/
STDMETHODIMP CITResultSet::ClearRows()
{
	m_cs.Lock();

	// Free page map
	if (m_PageMap)
	{
		delete m_PageMap;
		m_PageMap = NULL;
	}

    // Decommit and release virtual memory
    FreeMem();

	// Reset memory pool
	if (m_pMemPool)
		BlockReset(m_pMemPool);

    // Reset member data
	m_NumberOfPages = 0;
    m_fInit = FALSE;
    m_RowsReserved = 0;                              
    m_AppendRow = 0;
	m_Chunk = -1;

	m_cs.Unlock();

    return S_OK;
}


// Wrapper for VirtualFree(MEM_DECOMMIT) and VirtualFree(MEM_RELEASE)
HRESULT WINAPI CITResultSet::FreeMem()
{
    BOOL fRet;
	int iLoop;

    // Decommit result set - remember that it's an array of chunks (of rows)
	// so we have to loop over all the chunks
	// erinfox: bug fix, iLoop <= m_Chunk because m_Chunk is numbered from 0!
	for (iLoop = 0; iLoop <= m_Chunk; iLoop++)
    {
g_iFreed++;
		fRet = VirtualFree(m_ResultSet[iLoop], m_BytesReserved, MEM_DECOMMIT);
        ITASSERT(TRUE == fRet);
    }

    // Then release it
	for (iLoop = 0; iLoop <= m_Chunk; iLoop++)
    {
		fRet = VirtualFree(m_ResultSet[iLoop], 0, MEM_RELEASE);
        ITASSERT(TRUE == fRet);
    }


	return S_OK;
}


STDMETHODIMP CITResultSet::Free()
{
    return E_NOTIMPL;
}

//////////////////////// Asynchronous //////////////////////////////////////


STDMETHODIMP CITResultSet::IsCompleted()
{
    return E_NOTIMPL;
}


STDMETHODIMP CITResultSet::Cancel()
{
    return E_NOTIMPL;
}


STDMETHODIMP CITResultSet::Pause(BOOL fPause)
{
    return E_NOTIMPL;
}


STDMETHODIMP CITResultSet::GetRowStatus(LONG lRowFirst, LONG cRows, LPROWSTATUS lpRowStatus)
{
    return E_NOTIMPL;
}


STDMETHODIMP CITResultSet::GetColumnStatus(LPCOLUMNSTATUS lpColStatus)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\query\idxobr.h ===
// IDXOBR.H:  Definition of CITIndexObjBridge

#ifndef __IDXOBR_H__
#define __IDXOBR_H__

#include "verinfo.h"
#include <itwbrk.h>
#include <itstem.h>

// REVIEW (billa): EXBRKPM needs to get moved to mvsearch.h, where PARSE_PARMS
// is defined.  A pointer to this structure will replace the lpfnTable member
// of PARSE_PARMS.

class CITIndexObjBridge : 
	public IWordSink,
	public IStemSink
{
public:
	CITIndexObjBridge();
	virtual ~CITIndexObjBridge();

	// IUnknown methods
	STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj);
	STDMETHOD_(ULONG, AddRef)(void);
	STDMETHOD_(ULONG, Release)(void);

	// IWordSink methods
	STDMETHOD(PutWord)(WCHAR const *pwcInBuf, ULONG cwc,
							ULONG cwcSrcLen, ULONG cwcSrcPos);
	STDMETHOD(PutAltWord)(WCHAR const *pwcInBuf, ULONG cwc,
							ULONG cwcSrcLen, ULONG cwcSrcPos);
	STDMETHOD(StartAltPhrase)(void);
	STDMETHOD(EndAltPhrase)(void);
	STDMETHOD(PutBreak)(WORDREP_BREAK_TYPE breakType);
	
	// IStemSink methods
	STDMETHOD(PutWord)(WCHAR const *pwcInBuf, ULONG cwc);
	STDMETHOD(PutAltWord)(WCHAR const *pwcInBuf, ULONG cwc);
	
	// Public methods not derived from IUnknown.
	STDMETHOD(SetWordBreaker)(PIWBRK piwbrk);
	STDMETHOD(BreakText)(PEXBRKPM pexbrkpm);
	STDMETHOD(LookupStopWord)(LPBYTE lpbStopWord);
	STDMETHOD(StemWord)(LPBYTE lpbStemWord, LPBYTE lpbRawWord);
	STDMETHOD(AddQueryResultTerm)(LPBYTE lpbTermHit, LPVOID *ppvTermHit);
	STDMETHOD(AdjustQueryResultTerms)(void);
		
private:
    // Private methods 
	HRESULT	ReallocBuffer(HGLOBAL *phmemBuf, DWORD *cbBufCur, DWORD cbBufNew);

	// Private Data members
	ULONG	m_cRef;
	PIWBRK	m_piwbrk;				// pointer to IWordBreaker
	PIWBRKC m_piwbrkc;				// pointer to IWordBreakerConfig
	PISTEM	m_pistem;				// pointer to IStemmer
	PIITSTWDL	m_piitstwdl;		// pointer to IITStopWordList
	DWORD	m_dwCodePageID;			// from breaker to do AToW/WToA
	PEXBRKPM	m_pexbrkpm;			// Params for BreakText call in progress.
	BOOL	m_fNormWord;
	HGLOBAL	m_hmemSrc;
	HGLOBAL	m_hmemDestNorm;
	HGLOBAL	m_hmemDestRaw;
	DWORD	m_cbBufSrcCur;
	DWORD	m_cbBufDestNormCur;
	DWORD	m_cbBufDestRawCur;
	LPSIPB	m_lpsipbTermHit;
};


// Initial size of Ansi<->Unicode string conversion buffers.
#define	cbConvBufInit	256

#define IDXOBR_TERMHASH_SIZE	1013	// Large prime number good for supporting
										// thousands of term hit words.


#endif	// __IDXOBR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\query\idxobr.cpp ===
/*************************************************************************
*  @doc SHROOM INTERNAL API                                              *
*																		 *
*  IDXOBR.CPP                                                            *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1997                              *
*  All Rights reserved.                                                  *
*                                                                        *
*  This file contains the implementation of CITIndexObjBridge,           *
*  which is a class used by CITIndexLocal to allow the old .c			 *
*  search internals to call the new COM-based breaker and stemmer		 *
*  objects.
*  												                         *
*																	     *
**************************************************************************
*                                                                        *
*  Written By   : Bill Aloof                                             *
*  Current Owner: billa                                                  *
*                                                                        *
**************************************************************************/
#include <mvopsys.h>

#ifdef _DEBUG
static char s_aszModule[] = __FILE__;   /* For error report */
#endif


#include <atlinc.h>

// MediaView (InfoTech) includes
#include <orkin.h>
#include <groups.h>

#include <itquery.h>
#include <itcat.h>
#include <itwbrk.h>
#include <itwbrkid.h>
#include "indeximp.h"
#include "queryimp.h"
#include "mvsearch.h"
#include "idxobr.h"
#include "common.h"


//---------------------------------------------------------------------------
//						Constructor and Destructor
//---------------------------------------------------------------------------


CITIndexObjBridge::CITIndexObjBridge()
{
	m_cRef = 0;
	m_piwbrk = NULL;
	m_piwbrkc = NULL;
	m_pistem = NULL;
	m_piitstwdl = NULL;
	m_pexbrkpm = NULL;
	m_fNormWord = FALSE;
	m_dwCodePageID = 0;
	m_hmemSrc = m_hmemDestNorm = m_hmemDestRaw = NULL;
	m_cbBufSrcCur = m_cbBufDestNormCur = m_cbBufDestRawCur = 0;
	m_lpsipbTermHit = NULL;
}

CITIndexObjBridge::~CITIndexObjBridge()
{
	if (m_cRef > 0)
	{
		ITASSERT(FALSE);
	}
	
	if (m_hmemSrc != NULL)
	{
		_GLOBALFREE(m_hmemSrc);
		m_hmemSrc = NULL;
		m_cbBufSrcCur = 0;
	}

	if (m_hmemDestNorm != NULL)
	{
		_GLOBALFREE(m_hmemDestNorm);
		m_hmemDestNorm = NULL;
		m_cbBufDestNormCur = 0;
	}
	
	if (m_hmemDestRaw != NULL)
	{
		_GLOBALFREE(m_hmemDestRaw);
		m_hmemDestRaw = NULL;
		m_cbBufDestRawCur = 0;
	}
	
	if (m_piwbrk != NULL)
	{
		m_piwbrk->Release();
		m_piwbrk = NULL;
	}
	
	if (m_piwbrkc != NULL)
	{
		m_piwbrkc->Release();
		m_piwbrkc = NULL;
	}
	
	if (m_pistem != NULL)
	{
		m_pistem->Release();
		m_pistem = NULL;
	}
	
	if (m_piitstwdl != NULL)
	{
		m_piitstwdl->Release();
		m_piitstwdl = NULL;
	}

	MVStopListDispose(m_lpsipbTermHit);
}


//---------------------------------------------------------------------------
//						IUnknown Method Implementations
//---------------------------------------------------------------------------

// NOTE: This implementation of IUnknown assumes that this object is used
//	only in a local context, meaning that no piece of code will hold onto
//	an IUnknown pointer obtained via QueryInterface beyond the scope that
//	an instance of this object was created in.  For example, this object
//	will very likely be created/destroyed in the same method.  That's why
//	there's no controlling IUnknown for us to forward AddRef's and Release's
//	to.  It is also the reason that IUnknown::Release doesn't call the
//	class's destructor when the ref count goes to 0. 

STDMETHODIMP
CITIndexObjBridge::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
	HRESULT	hr = S_OK;
	void	*pvObj = NULL;
	
	if (ppvObj == NULL)
		return (SetErrReturn(E_POINTER));
		
	if (riid == IID_IWordSink)
		pvObj = (void *)((PIWRDSNK) this);
	else if (riid == IID_IStemSink)
		pvObj = (void *)((PISTEMSNK) this);
	else if (riid == IID_IUnknown)
		pvObj = (void *)((IUnknown *) ((PIWRDSNK) this));
		
	if (pvObj != NULL)
		*ppvObj = pvObj;
	else
		hr = E_NOINTERFACE;
		
	return (hr);
}


STDMETHODIMP_(ULONG)
CITIndexObjBridge::AddRef(void)
{
	return (++m_cRef);
}


STDMETHODIMP_(ULONG)
CITIndexObjBridge::Release(void)
{
	if (m_cRef > 0)
		--m_cRef;
	else
	{
		ITASSERT(FALSE);
	}
	
	return (m_cRef);
}


//---------------------------------------------------------------------------
//						IWordSink Method Implementations
//---------------------------------------------------------------------------


/*****************************************************************
 * @method STDMETHODIMP | IWordSink | PutWord |
 * This method notifies IWordSink of a new word. 
 *
 * @parm WCHAR const | *pwcInBuf | Pointer to the word to add.
 * @parm ULONG |cwc | Count of characters in the word.
 * @parm ULONG |cwcSrcLen | count of characters in pTextSource buffer 
 * (see <om IWordBreaker.BreakText>) that corresponds to the output word
 * @parm ULONG |cwcSrcPos | the position of the word in pTextSource 
 *  buffer that corresponds to the output word
 * 
 * @rvalue S_OK | The operation completed successfully. 
 * @rvalue E_POINTER | Input buffer is NULL. 
 *
 * @comm The values of <p cwcSrcLen> and <p cwcSrcPos> are used by the 
 * ISearch interface, which given a query and a text source, will highlight 
 * all hits within the text source that match the query. The location 
 * of the text to be highlighted is computed from <p cwcSrcLen> and 
 * <p cwcSrcPos>. Since <p pwcInfbuf> is constant and should not be 
 * modified by PutWord, it can point directly into <p pTextSource>.  
 * Values of cwc larger than the ulMaxTokenSize specified in 
 * <om IWordBreaker.Init> will result in LANGUAGE_S_LARGE_WORD.
 * @comm Text sent to PutWord should match the source text as closely 
 * as possible, including capitalization and accents. 
 *
 * @comm You need to call this method for every word retrieved from 
 * <p pTextSource> except those for which the <om .PutAltWord> call 
 * has been made.  The word sink automatically adds an end of word break 
 * (EOW) after this token.
 *
 ****************************************************************/

STDMETHODIMP
CITIndexObjBridge::PutWord(WCHAR const *pwcInBuf, ULONG cwc,
							ULONG cwcSrcLen, ULONG cwcSrcPos)
{
	HRESULT hr;
	DWORD	cbAnsi;
	
	if (pwcInBuf == NULL)
		return (E_POINTER);
 
 	cbAnsi = (sizeof(WCHAR) * cwc) + sizeof(WORD);
 	
	if (SUCCEEDED(hr =
			ReallocBuffer(&m_hmemDestRaw, &m_cbBufDestRawCur, cbAnsi)))
	{
		char	*lpchBufRaw;
		
		lpchBufRaw = (char *) _GLOBALLOCK(m_hmemDestRaw);

		if ((*((WORD *)lpchBufRaw) = (WORD)
				WideCharToMultiByte(m_dwCodePageID, NULL, pwcInBuf, cwc,
						lpchBufRaw + sizeof(WORD), cbAnsi - sizeof(WORD),
														NULL, NULL)) > 0)
		{
			char	*lpchBufNorm;
			
			lpchBufNorm = (char *) _GLOBALLOCK(m_hmemDestNorm);

			if (!m_fNormWord)
				MEMCPY(lpchBufNorm, lpchBufRaw,
						*((WORD *)lpchBufRaw) + sizeof(WORD));

			ITASSERT(m_pexbrkpm != NULL); 						
			if (m_pexbrkpm->lpfnOutWord != NULL)
			{
				DWORD	ibAnsiOffset;
				WCHAR	*lpwchSrc;
				
				lpwchSrc = (WCHAR *) _GLOBALLOCK(m_hmemSrc);
				
				// Compute the ANSI offset of the beginning of the raw word.
				// The ANSI buffer we pass won't get written to - we just
				// pass a pointer just in case the routine requires a non-NULL
				// for that param (documentation doesn't say).
				ibAnsiOffset = WideCharToMultiByte(m_dwCodePageID, NULL,
													lpwchSrc, cwcSrcPos,
													lpchBufRaw, 0, NULL, NULL);
				
				// Call the supplied word callback function.	
				hr = m_pexbrkpm->lpfnOutWord((LPBYTE)lpchBufRaw,
											 (LPBYTE)lpchBufNorm,
										ibAnsiOffset, m_pexbrkpm->lpvUser);
										
				_GLOBALUNLOCK(m_hmemSrc);
			}

			_GLOBALUNLOCK(m_hmemDestNorm);
		}
		else
			hr = E_UNEXPECTED;
			
		_GLOBALUNLOCK(m_hmemDestRaw);
	}
	
	return (hr);
}

/****************************************************************
 * @method STDMETHODIMP | IWordSink | PutAltWord |
 * Allows the word breaker to put more than one word in the same place.  
 * @parm WCHAR const | *pwcInBuf | Pointer to the word to add.
 * @parm ULONG |cwc | Count of characters in the word.
 * @parm ULONG |cwcSrcLen | count of characters in pTextSource buffer 
 * (see <om IWordBreaker.BreakText>) that corresponds to the output word.
 * @parm ULONG |cwcSrcPos | the position of the word in pTextSource 
 *  buffer that corresponds to the output word
 * 
 * @rvalue S_OK | The operation completed successfully. 
 * @rvalue E_POINTER | Input buffer is NULL. 
 *
 * @comm
 * When you need to add more than one word in the same place, use 
 * PutAltWord for all alternative words except the last one.  Use 
 * PutWord for the final alternative, indicating movement to the next position. 
 * @ex The phrase "Where is Kyle's document" would be stored as: | 
* pWSink->PutWord( L"Where", 5, 5, 0 );
* pWSink->PutWord( L"is", 2, 2, 6 );
* pWSink->PutAltWord( L"Kyle", 4, 6, 9 );
* pWSink->PutWord( L"Kyle's", 6, 6, 9 );
* pWSink->PutWord( L"document", 8, 8, 16 );
 *
 * 
 ***************************************************************/
STDMETHODIMP
CITIndexObjBridge::PutAltWord(WCHAR const *pwcInBuf, ULONG cwc,
								ULONG cwcSrcLen, ULONG cwcSrcPos)
{
	HRESULT hr;
	DWORD	cbAnsi;
	
	if (pwcInBuf == NULL)
		return (E_POINTER);
 
 	cbAnsi = (sizeof(WCHAR) * cwc) + sizeof(WORD);
 	
	if (SUCCEEDED(hr =
			ReallocBuffer(&m_hmemDestNorm, &m_cbBufDestNormCur, cbAnsi)))
	{
		char	*lpchBuf;
		
		lpchBuf = (char *) _GLOBALLOCK(m_hmemDestNorm);

		if ((*((WORD *)lpchBuf) = (WORD) 
				WideCharToMultiByte(m_dwCodePageID, NULL, pwcInBuf, cwc,
						lpchBuf + sizeof(WORD), cbAnsi - sizeof(WORD),
														NULL, NULL)) > 0)
		{
			m_fNormWord = TRUE;
		}
		else
			hr = E_UNEXPECTED;
			
		_GLOBALUNLOCK(m_hmemDestNorm);
	}
	
	return (hr);
}


/****************************************************************
 * @method STDMETHODIMP | IWordSink | StartAltPhrase |
 * This method is not implemented. 
 ***************************************************************/
STDMETHODIMP
CITIndexObjBridge::StartAltPhrase(void)
{
	return (E_NOTIMPL);
}


/****************************************************************
 * @method STDMETHODIMP | IWordSink | EndAltPhrase|
 * This method is not implemented. 
 ***************************************************************/
STDMETHODIMP
CITIndexObjBridge::EndAltPhrase(void)
{
	return (E_NOTIMPL);
}


/****************************************************************
 * @method STDMETHODIMP | IWordSink | PutBreak |
 * This method is not implemented. 
 *
 * @parm WORDREP_BREAK_TYPE | breakType | Specifies break type
 *
 * 
 ***************************************************************/
STDMETHODIMP
CITIndexObjBridge::PutBreak(WORDREP_BREAK_TYPE breakType)
{
	return (E_NOTIMPL);
}


//---------------------------------------------------------------------------
//						IStemSink Method Implementations
//---------------------------------------------------------------------------


/****************************************************************
 * @method STDMETHODIMP | IStemSink | PutWord |
 * Notifies IStemSink of a word that is similar to the input word 
 * of <om IStemmer.StemWord> method.  
 *
 * @parm WCHAR const | *pwcInBuf | Pointer to the word
 * @parm ULONG | cwc | Number of characters in the word
 * 
 * @rvalue E_POINTER | The input buffer is NULL. 
 * 
 ***************************************************************/
STDMETHODIMP
CITIndexObjBridge::PutWord(WCHAR const *pwcInBuf, ULONG cwc)
{
	HRESULT hr;
	DWORD	cbAnsi;
	
	if (pwcInBuf == NULL)
		return (E_POINTER);
 
 	cbAnsi = (sizeof(WCHAR) * cwc) + sizeof(WORD);
 	
	if (SUCCEEDED(hr =
			ReallocBuffer(&m_hmemDestNorm, &m_cbBufDestNormCur, cbAnsi)))
	{
		char	*lpchBuf;
		
		lpchBuf = (char *) _GLOBALLOCK(m_hmemDestNorm);

		if ((*((WORD *)lpchBuf) = (WORD)
				WideCharToMultiByte(m_dwCodePageID, NULL, pwcInBuf, cwc,
						lpchBuf + sizeof(WORD), cbAnsi - sizeof(WORD),
														NULL, NULL)) == 0)
			hr = E_UNEXPECTED;
			
		_GLOBALUNLOCK(m_hmemDestNorm);
	}
	
	return (hr);
}


/****************************************************************
 * @method STDMETHODIMP | IStemSink | PutAltWord |
 * Notifies IStemSink of a word that is similar to the input word 
 * of <om IStemmer.StemWord> method.  
 * @parm WCHAR const | *pwcInBuf | Pointer to the word
 * @parm ULONG | cwc | Number of characters in the word
 * 
 * @rvalue S_OK | This method always returns success. 
 * 
 * @comm
 * InfoTech Search only supports getting back one stemmed version 
 * of the raw word. Any others are ignored. 
 * @xref <om .PutWord>
 ***************************************************************/
STDMETHODIMP
CITIndexObjBridge::PutAltWord(WCHAR const *pwcInBuf, ULONG cwc)
{
	// We only support getting back one stemmed version of the raw word,
	// so we ignore all the others.
	return (S_OK);
}


//---------------------------------------------------------------------------
//						Other Public Method Implementations
//---------------------------------------------------------------------------


// By the time this method is called, we assume the breaker has been fully
// initialized via IWordBreakerConfig (if present) and via IWordBreaker::Init.
STDMETHODIMP
CITIndexObjBridge::SetWordBreaker(PIWBRK piwbrk)
{
	LCID lcid;
	
	if (piwbrk == NULL)
		return (SetErrReturn(E_POINTER));

	if (m_piwbrk != NULL)
		return (SetErrReturn(E_ALREADYINIT));

	// Pick up IWordBreakerConfig if its there, otherwise we'll go without it.
	// Do the same for IStemmer if we got IWordBreakerConfig.
	if (SUCCEEDED(piwbrk->QueryInterface(IID_IWordBreakerConfig,
											(LPVOID *) &m_piwbrkc)))
		m_piwbrkc->GetWordStemmer(&m_pistem);
		
	// Pick up IITStopWordList if its there, otherwise we'll go without it.
	piwbrk->QueryInterface(IID_IITStopWordList, (LPVOID *) &m_piitstwdl);

	if (m_piwbrkc == NULL ||
		FAILED(m_piwbrkc->GetLocaleInfo(&m_dwCodePageID, &lcid)))
		m_dwCodePageID = GetACP();
			
	(m_piwbrk = piwbrk)->AddRef();
	
	return (S_OK);
}


// NOTE: If CITIndexObjBridge::BreakText was going to provide more than
//	one buffer's worth of text to the COM breaker, then the very first members of
//	CITIndexObjBridge would be made to match those of TEXT_SOURCE so that
//	FillTextSource callback could call back into us (by casting the TEXT_SOURCE
//	param passed to it).  Otherwise, we would have no way of providing
//	object-oriented breaking - we would have to resort to using globals.

SCODE __stdcall FillTextSource(TEXT_SOURCE *pTextSource)
{
	// We always return failure to signify no more text.
	return E_FAIL;
}


STDMETHODIMP
CITIndexObjBridge::BreakText(PEXBRKPM pexbrkpm)
{
	HRESULT	hr = S_OK;
	
	if (m_piwbrk == NULL)
		return (E_UNEXPECTED);
		
	if (pexbrkpm == NULL)
		return (SetErrReturn(E_POINTER));
		
	if (pexbrkpm->lpbBuf == NULL)
		return (SetErrReturn(E_INVALIDARG));

	// Configure word breaker if we got IWordBreakerConfig; otherwise,
	// check values in *pexbrkpm to see if they are compatible with defaults.		
	if (m_piwbrkc != NULL)
	{
		DWORD	grfBreakFlags;
		
		if (SUCCEEDED(hr =
				m_piwbrkc->SetBreakWordType(pexbrkpm->dwBreakWordType)) &&
			SUCCEEDED(hr =
				m_piwbrkc->GetControlInfo(&grfBreakFlags, NULL)))
			{
				SetGrfFlag(&grfBreakFlags, IITWBC_BREAK_ACCEPT_WILDCARDS,
									(pexbrkpm->fFlags & ACCEPT_WILDCARD));
				hr = m_piwbrkc->SetControlInfo(grfBreakFlags, NULL);
			}
	}
	else
	{
		if (pexbrkpm->dwBreakWordType != IITWBC_BREAKTYPE_TEXT)
			hr = E_NOTSUPPORTED;
	}
	
	if (SUCCEEDED(hr))
	{
		DWORD	cwch;
		
		m_fNormWord = FALSE;
		m_pexbrkpm = pexbrkpm;
		cwch = pexbrkpm->cbBufCount;

		if (SUCCEEDED(hr = ReallocBuffer(&m_hmemSrc, &m_cbBufSrcCur,
												sizeof(WCHAR) * cwch)))
		{
			WCHAR	*lpwchBuf;
	
			lpwchBuf = (WCHAR *) _GLOBALLOCK(m_hmemSrc);
	
			// Convert the text source buffer to Unicode.
			if ((cwch = MultiByteToWideChar(m_dwCodePageID, NULL, 
							(LPCSTR) pexbrkpm->lpbBuf, pexbrkpm->cbBufCount,
														lpwchBuf, cwch)) > 0)
			{
				TEXT_SOURCE	txtsrc;
				
				txtsrc.pfnFillTextBuffer = FillTextSource;
				txtsrc.awcBuffer = lpwchBuf;
				txtsrc.iCur = 0;
				txtsrc.iEnd = cwch;
				
				// Send the Unicode text buffer to the breaker.
				hr = m_piwbrk->BreakText(&txtsrc, (PIWRDSNK) this, NULL);
			}
			else
				hr = E_UNEXPECTED;
	
			_GLOBALUNLOCK(m_hmemSrc);
		}

		m_pexbrkpm = NULL;
	}
	
	return (hr);
}


// The stop word is in WORD length prefix format.
STDMETHODIMP
CITIndexObjBridge::LookupStopWord(LPBYTE lpbStopWord)
{
	HRESULT hr;
	DWORD	cwch;
	DWORD	cbAnsi;
	
	if (lpbStopWord == NULL)
		return (SetErrReturn(E_POINTER));
		
	if (m_piitstwdl == NULL)
		return (SetErrReturn(E_NOTIMPL));
		
	cwch = cbAnsi = (DWORD)(*((WORD *)lpbStopWord));
	if (SUCCEEDED(hr = ReallocBuffer(&m_hmemSrc, &m_cbBufSrcCur,
											sizeof(WCHAR) * cwch)))
	{
		WCHAR	*lpwchBuf;
	
		lpwchBuf = (WCHAR *) _GLOBALLOCK(m_hmemSrc);
	
		// Convert the stop word to Unicode.
		if ((cwch = MultiByteToWideChar(m_dwCodePageID, NULL, 
							(LPCSTR)lpbStopWord + sizeof(WORD), cbAnsi,
													lpwchBuf, cwch)) > 0)
		{
			// Lookup the stop word.
			hr = m_piitstwdl->LookupWord(lpwchBuf, cwch);
		}
		else
			hr = E_UNEXPECTED;
	
		_GLOBALUNLOCK(m_hmemSrc);
	}
	
	return (hr);
}


// Stem the raw word and return result in lpbStemWord.
// Both word buffers are in WORD length prefix format.
STDMETHODIMP
CITIndexObjBridge::StemWord(LPBYTE lpbStemWord, LPBYTE lpbRawWord)
{
	HRESULT hr;
	DWORD	cwch;
	DWORD	cbAnsi;
	
	if (lpbStemWord == NULL || lpbRawWord == NULL)
		return (SetErrReturn(E_POINTER));
		
	if (m_pistem == NULL)
		return (SetErrReturn(E_NOSTEMMER));

	cwch = cbAnsi = (DWORD)(*((WORD *)lpbRawWord));
	if (SUCCEEDED(hr = ReallocBuffer(&m_hmemSrc, &m_cbBufSrcCur,
											sizeof(WCHAR) * cwch)))
	{
		WCHAR	*lpwchBuf;
	
		lpwchBuf = (WCHAR *) _GLOBALLOCK(m_hmemSrc);
	
		// Convert the word to be stemmed to Unicode.
		if ((cwch = MultiByteToWideChar(m_dwCodePageID, NULL, 
							(LPCSTR)lpbRawWord + sizeof(WORD), cbAnsi,
													lpwchBuf, cwch)) > 0)
		{
			// Stem the raw word.
			if (SUCCEEDED(hr =
					m_pistem->StemWord(lpwchBuf, cwch, (PISTEMSNK) this)))
			{
				char	*lpchStemBuf;
				WORD	cbStemWord;
		
				lpchStemBuf = (char *) _GLOBALLOCK(m_hmemDestNorm);
				
				// Copy stem word from the normalized word destination buffer
				// (where our implementation of IStemSink::PutWord put it) to
				// lpbStemWord as long as it is not longer than the raw word.
				if ((cbStemWord = *((WORD *)lpchStemBuf)) <= cbAnsi)
					MEMCPY(lpbStemWord, lpchStemBuf, cbStemWord + sizeof(WORD));
				else
					hr = E_WORDTOOLONG;
				
				_GLOBALUNLOCK(m_hmemDestNorm);
			}
		}
		else
			hr = E_UNEXPECTED;
	
		_GLOBALUNLOCK(m_hmemSrc);
	}
	
	return (hr);
}


// On entry, lpbTermHit is a WORD-prefixed MBCS string.
// On exit, *ppvTermHit is a WORD-prefixed Unicode string.
STDMETHODIMP
CITIndexObjBridge::AddQueryResultTerm(LPBYTE lpbTermHit, LPVOID *ppvTermHit)
{
	DWORD	cwch;
	DWORD	cbAnsi;
	HRESULT hr = S_OK;

	if (lpbTermHit == NULL || ppvTermHit == NULL)
		return (SetErrReturn(E_POINTER));
		
	if (m_dwCodePageID == 0)
		return (SetErrReturn(E_NOTINIT));

	cwch = cbAnsi = (DWORD)(*((WORD *)lpbTermHit));

	// When allocating the buffer, add 1 char to leave room for the
	// Unicode string's WORD prefix.
	if ((m_lpsipbTermHit != NULL ||
		 (m_lpsipbTermHit = MVStopListInitiate(IDXOBR_TERMHASH_SIZE,
														&hr)) != NULL) &&
		SUCCEEDED(hr = ReallocBuffer(&m_hmemSrc, &m_cbBufSrcCur,
											sizeof(WCHAR) * (cwch + 1))))
	{
		WCHAR	*lpwchBuf;
	
		lpwchBuf = (WCHAR *) _GLOBALLOCK(m_hmemSrc);
	
		// Convert lpbTermHit to Unicode before searching or storing it;
		// leave space in the Unicode buffer for the WORD length prefix.
		if ((cwch = MultiByteToWideChar(m_dwCodePageID, NULL, 
							(LPCSTR)lpbTermHit + sizeof(WORD), cbAnsi,
												lpwchBuf + 1, cwch)) > 0)
		{
			// Store the Unicode string length, but restate it in bytes
			// since the stopword list lookup code assumes MBCS.
			*lpwchBuf = (WORD)cwch * sizeof(WCHAR);

			// Add the word to the list and then get a pointer to it.
			if (SUCCEEDED(hr = MVStopListAddWord(m_lpsipbTermHit,
														(LPBYTE) lpwchBuf)))
			{
				hr = MVStopListFindWordPtr(m_lpsipbTermHit,
											(LST)lpwchBuf, (LST *)ppvTermHit);
			}
		}
		else
			hr = E_UNEXPECTED;
	
		_GLOBALUNLOCK(m_hmemSrc);
	}

	return (hr);
}


// This method should only be called after a query term hit list has been
// completely built.  It will iterate over all the terms and reduce the
// length prefixes from byte-based to WCHAR-based - i.e. the lengths
// ill be divided by two.  Once this method has been called, it will
// no longer be possible to search for terms in the term list.
// We do this so that the direct pointer refs to terms that end up in the
// query result list point to correct WCHAR-based length prefixes.
STDMETHODIMP
CITIndexObjBridge::AdjustQueryResultTerms(void)
{
	if (m_lpsipbTermHit != NULL)
	{
		LST		lstWord;
		LONG	lWordInfo = -1L;
		LPVOID	pvWordInfo = NULL;

		while (SUCCEEDED(MVStopListEnumWords(m_lpsipbTermHit, &lstWord,
												&lWordInfo, &pvWordInfo)))
		{
			ITASSERT(*((WORD *)lstWord) % sizeof(WCHAR) == 0);
			*((WORD *)lstWord) /= sizeof(WCHAR);
		}
	}

	return (S_OK);
}


//---------------------------------------------------------------------------
//						Private Method Implementations
//---------------------------------------------------------------------------

HRESULT
CITIndexObjBridge::ReallocBuffer(HGLOBAL *phmemBuf, DWORD *pcbBufCur,
														DWORD cbBufNew)
{
	return (ReallocBufferHmem(phmemBuf, pcbBufCur,
								max(cbBufNew, cbConvBufInit)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\query\indeximp.h ===
// INDEXIMP.H:  Definition of CITIndexLocal

#ifndef __INDEXIMP_H__
#define __INDEXIMP_H__

#include "verinfo.h"
#include "idxobr.h"

// Implemenation of IITIndex
class CITIndexLocal: 
	public IITIndex,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CITIndexLocal, &CLSID_IITIndexLocal>

{
public:
	CITIndexLocal() : m_idx(NULL), m_fSkipOcc(FALSE), m_pCatalog(NULL),
						m_piwbrk(NULL) {;}
	virtual ~CITIndexLocal() { if (m_idx) Close(); }

BEGIN_COM_MAP(CITIndexLocal)
	COM_INTERFACE_ENTRY(IITIndex)
END_COM_MAP()

DECLARE_REGISTRY(CLSID_IITIndexLocal, "ITIR.IndexSearch.4", "ITIR.IndexSearch", 0, THREADFLAGS_BOTH)

	// IITIndex methods
public:
	STDMETHOD(Open)(IITDatabase* pITDB, LPCWSTR lpszIndexMoniker, BOOL fInsideDB);
	STDMETHOD(CreateQueryInstance)(IITQuery** ppITQuery);
	STDMETHOD(Search)(IITQuery* pITQuery, IITResultSet* pITResult);
	STDMETHOD(Search)(IITQuery* pITQuery, IITGroup* pITGroup);
	STDMETHOD(Close)(void);
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid);
	STDMETHOD(GetWordBreakerInstance)(DWORD *pdwObjInstance);

    // Private methods 
private:
	STDMETHOD(HitListToResultSet)(LPHL pHitList, IITResultSet* pITResult,
												CITIndexObjBridge *pidxobr);
	STDMETHOD(QueryParse)(IITQuery* pITQuery, LPQT* pQueryTree,
									CITIndexObjBridge *pidxobr);

	// Data members
private:
	LPIDX m_idx;
	BOOL m_fSkipOcc;
	IITCatalog* m_pCatalog;
	PIWBRK m_piwbrk;							// pointer to IWordBreakerConfig
    _ThreadModel::AutoCriticalSection m_cs;      // Critical section obj.
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\property\rsimp.h ===
// RSIMP.H:  Definition of CITResultSet

#ifndef __RSIMP_H__
#define __RSIMP_H__

#include "verinfo.h"

class CHeader
{
public:
    PROPID dwPropID;
    DWORD dwType;
    union
    {
        LPVOID lpvData;
        DWORD dwValue; 
    };

    PRIORITY Priority;
	LPVOID	lpvHeap;
	PFNCOLHEAPFREE	pfnHeapFree;
};

// Implemenation of IITResultSet
class CITResultSet: 
	public IITResultSet,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CITResultSet, &CLSID_IITResultSet>

{

BEGIN_COM_MAP(CITResultSet)
	COM_INTERFACE_ENTRY(IITResultSet)
END_COM_MAP()

DECLARE_REGISTRY(CLSID_IITResultSet, "ITIR.ResultSet.4", 
                 "ITIR.ResultSet", 0, THREADFLAGS_BOTH)

public:
    CITResultSet();
    ~CITResultSet();

public:
    // Initialization
    STDMETHOD(SetColumnPriority)(LONG lColumnIndex, PRIORITY ColumnPriority);
	STDMETHOD(SetColumnHeap)(LONG lColumnIndex, LPVOID lpvHeap,
										PFNCOLHEAPFREE pfnColHeapFree);
    inline STDMETHOD(SetKeyProp)(PROPID KeyPropID);
	STDMETHOD(Add)(LPVOID lpvHdr);
    STDMETHOD(Add)(PROPID PropID, LPVOID lpvDefaultData, DWORD cbData, PRIORITY Priority);
    STDMETHOD(Add)(PROPID PropID, LPCWSTR lpszwDefault, PRIORITY Priority);
    STDMETHOD(Add)(PROPID PropID, DWORD dwDefaultData, PRIORITY Priority);

    // Build result set
	STDMETHOD(Append)(LPVOID lpvHdr, LPVOID lpvData);
	STDMETHOD(Set)(LONG lRowIndex, LPVOID lpvHdr, LPVOID lpvData);
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, DWORD   dwData);
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, LPCWSTR lpwStr);
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, LPVOID lpvData, DWORD cbData);
	STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, DWORD_PTR dwData);

	STDMETHOD(Copy)(IITResultSet* pRSCopy);

	STDMETHOD(AppendRows)(IITResultSet* pResSrc, LONG lRowSrcFirst, LONG cSrcRows, 
									LONG& lRowFirstDest);

    // Obtain info about result set
    STDMETHOD(Get)(LONG lRowIndex, LONG lColumnIndex, CProperty& Prop);
    inline STDMETHOD(GetKeyProp)(DWORD& KeyPropID);
    STDMETHOD(GetColumnPriority)(LONG lColumnIndex, PRIORITY& ColumnPriority);
    inline STDMETHOD(GetColumnCount)(LONG& lNumberOfColumns);
	inline STDMETHOD(GetRowCount)(LONG& lNumberOfRows);
	STDMETHOD(GetColumn)(LONG lColumnIndex, PROPID& PropID);

    STDMETHOD(GetColumn)(LONG lColumnIndex, PROPID& PropID, DWORD& dwType, LPVOID& lpvDefaultValue,
		                 DWORD& cbSize, PRIORITY& ColumnPriority);

	STDMETHOD(GetColumnFromPropID)(PROPID PropID, LONG& lColumnIndex);

    // Clear result set
    STDMETHOD(Clear)();
    STDMETHOD(ClearRows)();

    STDMETHOD(Free)();

    // Asynchronous support
    STDMETHOD(IsCompleted)();      // returns S_OK or S_FALSE
    STDMETHOD(Cancel)();
    STDMETHOD(Pause)(BOOL fPause);

    STDMETHOD(GetRowStatus)(LONG lRowFirst, LONG cRows, LPROWSTATUS lpRowStatus);
    STDMETHOD(GetColumnStatus)(LPCOLUMNSTATUS lpColStatus);

    // STDMETHOD(Merge)();

    // Private methods and data
private:
    // Methods for memory management
    HRESULT WINAPI Reserve();
    HRESULT WINAPI Commit(LONG RowNum);
    HRESULT WINAPI FreeMem();

    // Data
    LONG m_cProp;       // Number of properties (column count)
    DWORD m_dwKeyProp;  // Key property

    CHeader m_Header[MAX_COLUMNS];   // Result set header
	HANDLE m_hResultSet;             // Handle to result set
    DWORD_PTR** m_ResultSet;             // Result set data - an array of pointers to chunks
	                                 // of rows 
	LONG m_Chunk;                    // Keeps track of which chunk we need to access
	LONG m_NumChunks;                // Number of chunks accessible via m_ResultSet

    LONG m_AppendRow;     // Next row for appending

    // data to keep calculations to a minimum
	BOOL m_fInit;         // Have we calculated numbers and allocated page map yet?
	LONG m_BytesReserved;  // Number of bytes reserved at a time
    LONG m_RowsPerPage;   // Number of rows in a page of memory
	LONG m_NumberOfPages;  // Number of pages in a result set chunk
    BOOL* m_PageMap;      // Keeps track of which pages have been allocated (per chunk)
	LONG m_RowsReserved;  // Total number of rows that have been reserved

    _ThreadModel::AutoCriticalSection m_cs;      // Critical section obj.

    LPVOID m_pMemPool;   // Memory pool for data
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\query\indeximp.cpp ===
/*************************************************************************
*  @doc SHROOM EXTERNAL API                                              *
*																		 *
*  INDEXIMP.CPP                                                          *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1997                              *
*  All Rights reserved.                                                  *
*                                                                        *
*  This file contains the implementation of the index object             *
*  												                         *
*																	     *
**************************************************************************
*                                                                        *
*  Written By   : Erin Foxford                                           *
*  Current Owner: erinfox                                                *
*                                                                        *
**************************************************************************/
#include <mvopsys.h>

#ifdef _DEBUG
static char s_aszModule[] = __FILE__;   /* For error report */
#endif


#include <atlinc.h>

// MediaView (InfoTech) includes
#include <groups.h>
#include <wwheel.h>

#include <itquery.h>
#include <itcat.h>
#include <itwbrk.h>
#include <ccfiles.h>
#include <itwbrkid.h>
#include "indeximp.h"
#include "queryimp.h"
#include "mvsearch.h"

#include <ITDB.h>
#include <itcc.h>   // for STDPROP_UID def.
#include <itrs.h>   // for IITResultSet def.
#include <itgroup.h>

#define QUERYRESULT_GROUPCREATE		0x0800


//----------------------------------------------------------------------
// REVIEW (billa): Need to add critical section locking to all methods
// that reference member variables.
//----------------------------------------------------------------------


/********************************************************************
 * @method    STDMETHODIMP | IITIndex | Open |
 *     Opens a full-text index, which can reside in the database's
 * storage or as a Win32 file.
 *
 * @parm IITDatabase* | pITDB | Pointer to database associated with 
 * full-text index
 * @parm LPCWSTR | lpszIndexMoniker | Name of full-text index to open.
 * If index resides outside database (as a file), this should include 
 * the full path to the index.
 * @parm BOOL | fInside | If TRUE, index resides inside of database; 
 * otherwise, index resides outside of database.
 *
 * @rvalue S_OK | The index was successfully opened 
 ********************************************************************/
STDMETHODIMP CITIndexLocal::Open(IITDatabase* pITDB, LPCWSTR lpszIndexMoniker,
								 BOOL fInside)
{
	HFPB hfpb = NULL;
	HRESULT hr;
	INDEXINFO indexinfo;
	char szFileName[_MAX_PATH + 1] = SZ_FI_STREAM_A;

	if (m_idx)
		return (SetErrReturn(E_ALREADYINIT));

	// We have to have a database for charmap (and stoplist and
	// operator table eventually)
    if (NULL == pITDB || NULL == lpszIndexMoniker)
        return (SetErrReturn(E_INVALIDARG));

	m_cs.Lock();
	
	// if index is inside storage, need to get hfpb
	if (fInside)
	{
		WCHAR	rgwch[1];
		IStorage *pStorageDBRoot = NULL;

		// Get root storage from database.
		rgwch[0] = (WCHAR) NULL;
		if (FAILED(hr = pITDB->GetObjectPersistence(rgwch, IITDB_OBJINST_NULL,
										(LPVOID *)&pStorageDBRoot, FALSE)) ||
			(hfpb = (HFPB)FpbFromHfs(pStorageDBRoot, &hr)) == NULL)
		{
			if (pStorageDBRoot != NULL)
				pStorageDBRoot->Release();
				
			m_cs.Unlock();
			return (hr);
		}
	}

	// TODO: make MVIndexOpen take Unicode file name. This might take a little
	// work because it depends on FileOpen, which has a call to one of the Fm 
	// functions...
    DWORD dwSize = (DWORD) STRLEN(szFileName);
	WideCharToMultiByte(CP_ACP, 0, lpszIndexMoniker, -1,
        szFileName + dwSize, _MAX_PATH + 1 - dwSize, NULL, NULL);

	if (NULL == (m_idx = MVIndexOpen(hfpb, (LSZ) szFileName, &hr)))
		goto cleanup;

	MVGetIndexInfoLpidx(m_idx, &indexinfo);
	if (SUCCEEDED(hr = pITDB->GetObject(indexinfo.dwBreakerInstID,
							IID_IWordBreaker, (LPVOID *) &m_piwbrk)))
	{
		BOOL	fLicense;
		
		hr = m_piwbrk->Init(TRUE, CB_MAX_WORD_LEN, &fLicense);
	}
	
	if (FAILED(hr))
		goto cleanup; 
		
	// Open catalog object - we only need one instance
	// TODO (evaluate): how bad of hit is this going to be?
	hr = CoCreateInstance(CLSID_IITCatalogLocal, NULL, CLSCTX_INPROC_SERVER, IID_IITCatalog, 
		                  (VOID **) &m_pCatalog);

	if (FAILED(hr))
		goto cleanup;

	// if it fails, there is no catalog which we can run without.
	if (FAILED(m_pCatalog->Open(pITDB)))
	{
		m_pCatalog->Release();
		m_pCatalog = NULL;
	}
	
cleanup:
	if (FAILED(hr))
		Close();

	// If we have an HFPB for the DB's root storage, we need to release the
	// storage pointer and free the HFPB.  FileClose takes care of everything.
	if (hfpb)
		FileClose(hfpb);
		
	m_cs.Unlock();
	
	return hr;
}


/********************************************************************
 * @method    STDMETHODIMP | IITIndex | CreateQueryInstance |
 *     Creates a query object
 *
 * @parm IITQuery** | ppITQuery | Indirect pointer to query object
 *
 * @rvalue S_OK | The query object was successfully returned   
 *
 ********************************************************************/
STDMETHODIMP CITIndexLocal::CreateQueryInstance(IITQuery** ppITQuery)
{
	// TODO: possible optimization in case where user specifies multiple
	// query objects... get class factory pointer once; then call CreateInstance
	// Free CF when all done w/ index object.

	return CoCreateInstance(CLSID_IITQuery, NULL, CLSCTX_INPROC_SERVER, IID_IITQuery, 
		                  (VOID **) ppITQuery);
}

/********************************************************************
 * @method    STDMETHODIMP | IITIndex | Search |
 *     Performs a full-text search on the open index, returning the
 * results in a result set object.
 *
 * @parm IITQuery* | pITQuery | Pointer to query object
 * @parm IITResultSet* | pITResult | Pointer to result set object 
 *  containing search results. Caller is responsible for initializing
 *  the result set with the properties to be returned. 
 *
 * @rvalue S_FALSE | The search was successful, but returned no hits.
 * @rvalue S_OK | The search was successfully performed. 
 * @rvalue E_NOTOPEN | The index object is not open.
 * @rvalue E_INVALIDARG | One or both parameters is NULL. 
 * @rvalue E_OUTOFMEMORY | There was not enough memory to perform this function. 
 * @rvalue E_NULLQUERY | The query consisted of no terms, or is all stopwords.
 * @rvalue E_STOPWORD | A stopword was one of the terms in the query.
 * @rvalue E_* | An error occurred during the search. Check iterror.h for the possible error codes.
 *
 * @comm  The caller is responsible for setting the proper options
 * through the query object before calling this function.
 ********************************************************************/
STDMETHODIMP CITIndexLocal::Search(IITQuery* pITQuery, IITResultSet* pITResult)
{
	HRESULT hr;
	CITIndexObjBridge *pidxobr = NULL;
	LPQT pQueryTree = NULL;   // Pointer to query tree
	LPHL pHitList = NULL;     // Pointer to hit list
	IITGroup* piitGroup = NULL;
	_LPGROUP lpGroup;

	if (NULL == pITQuery || NULL == pITResult)
		return (SetErrReturn(E_INVALIDARG));

	if (m_idx == NULL)
		return (SetErrReturn(E_NOTOPEN));
		
	if ((pidxobr = new CITIndexObjBridge) != NULL)
	{
		pidxobr->AddRef();
		hr = pidxobr->SetWordBreaker(m_piwbrk);
	}
	else
		hr = E_OUTOFMEMORY;

	if (SUCCEEDED(hr) &&		
		SUCCEEDED(hr = QueryParse(pITQuery, &pQueryTree, pidxobr)))
	{
		SRCHINFO SrchInfo;        // Search parameters
		SrchInfo.dwMemAllowed = 0;
		pITQuery->GetResultCount((LONG &)SrchInfo.dwTopicCount);
		pITQuery->GetOptions(SrchInfo.Flag);
		SrchInfo.dwValue = 0;
		SrchInfo.dwTopicFullCalc = 0;
		SrchInfo.lpvIndexObjBridge = (LPVOID) pidxobr;

		pITQuery->GetGroup(&piitGroup);
		if (piitGroup)
			lpGroup = (_LPGROUP)piitGroup->GetLocalImageOfGroup();
		else
			lpGroup = NULL;
	
		// Perform search
		pHitList = MVIndexSearch(m_idx, pQueryTree, &SrchInfo, lpGroup, &hr);
	
		// Massage hitlist into a result set. 
		if (pHitList)
		{
			hr = HitListToResultSet(pHitList, pITResult, pidxobr);
			MVHitListDispose(pHitList);
		}
	}

	if (pQueryTree)		
		MVQueryFree(pQueryTree);

	// We don't want to delete pidxobr if HitListToResultSet AddRef'ed it
	// so that the result set can hold onto a term string heap via pidxobr.
	if (pidxobr && pidxobr->Release() == 0)
		delete pidxobr;

	return hr;
}

/********************************************************************
 * @method    STDMETHODIMP | IITIndex | Search |
 *     Performs a full-text search on the open index, returning the
 * results in a group object.
 *
 * @parm IITQuery* | pITQuery | Pointer to query object
 * @parm IITGroup* | pITGroup | Pointer to group object. The caller
 * is responsible for initializing this object before passing it.
 *
 * @rvalue S_OK | The search was successfully performed   
 *
 * @comm  The caller is responsible for setting the proper options
 * through the query object before calling this function.
 ********************************************************************/
STDMETHODIMP CITIndexLocal::Search(IITQuery* pITQuery, IITGroup* pITGroup)
{
	HRESULT hr = S_OK;
	CITIndexObjBridge *pidxobr = NULL;
	LPQT pQueryTree = NULL;   // Pointer to query tree
	LPHL pHitList = NULL;     // Pointer to hit list
	
	if (NULL == pITQuery || NULL == pITGroup)
		return (SetErrReturn(E_INVALIDARG));

	if (m_idx == NULL)
		return (SetErrReturn(E_NOTOPEN));
		
	// TODO: MVIndexSearch would take IITGroup*, not _LPGROUP
	_LPGROUP lpGroup = (_LPGROUP) pITGroup->GetLocalImageOfGroup();
	

	if ((pidxobr = new CITIndexObjBridge) != NULL)
		hr = pidxobr->SetWordBreaker(m_piwbrk);
	else
		hr = E_OUTOFMEMORY;

	if (SUCCEEDED(hr) &&		
		SUCCEEDED(hr = QueryParse(pITQuery, &pQueryTree, pidxobr)))
	{
		SRCHINFO SrchInfo;        // Search parameters
		SrchInfo.dwMemAllowed = 0;
		pITQuery->GetResultCount((LONG &)SrchInfo.dwTopicCount);
		pITQuery->GetOptions(SrchInfo.Flag);
		SrchInfo.Flag |= QUERYRESULT_GROUPCREATE;
		SrchInfo.dwValue = 0;
		SrchInfo.dwTopicFullCalc = 0;
		SrchInfo.lpvIndexObjBridge = (LPVOID) pidxobr;
		
		// Perform search - if pHitList comes back NULL, we will return hr
		if (pHitList = MVIndexSearch(m_idx, pQueryTree, &SrchInfo, lpGroup, &hr))
			MVHitListDispose(pHitList);
		}

	if (pQueryTree)		
		MVQueryFree(pQueryTree);
		
	if (pidxobr)
		delete pidxobr;

	return hr;
}


// This is private - it encapsulates the query parsing needed
// in all searches
STDMETHODIMP CITIndexLocal::QueryParse(IITQuery* pITQuery, LPQT* pQueryTree,
												CITIndexObjBridge *pidxobr)
{
	HRESULT hr  = S_OK;
	EXBRKPM	exbrkpm;
	PARSE_PARMS ParseParm;

	ITASSERT(pITQuery != NULL && pQueryTree != NULL && pidxobr != NULL);
	
	// Fill PARSE_PARMS structure
	DWORD dwFlags;
	pITQuery->GetOptions(dwFlags);
	if (dwFlags & QUERYRESULT_SKIPOCCINFO)
		m_fSkipOcc = TRUE;

	ParseParm.cDefOp = (WORD)(dwFlags & IMPLICIT_OR);
	ParseParm.wCompoundWord = (WORD)(dwFlags & COMPOUNDWORD_PHRASE);
	pITQuery->GetProximity(ParseParm.cProxDist);

	IITGroup* ITGroup;
	pITQuery->GetGroup(&ITGroup);
	if (ITGroup)
	{
		_LPGROUP lpGroup = (_LPGROUP) ITGroup->GetLocalImageOfGroup();
		ParseParm.lpGroup = lpGroup;
	}
	else
		ParseParm.lpGroup = NULL;

	// Breaker bridge setup
	exbrkpm.lpvIndexObjBridge = (LPVOID)pidxobr;
	ParseParm.pexbrkpm = &exbrkpm; 
	
	// TODO: provide the right stuff
	ParseParm.lpOpTab = NULL;

    LPSTR lpszQuery = NULL;  // Pointer to query buffer
    DWORD cbQuery;           // Query buffer's length
	DWORD dwCodePageID;
	LCID  lcid;
	
	if (FAILED(GetLocaleInfo(&dwCodePageID, &lcid)))
	{
		ITASSERT(FALSE);
		dwCodePageID = CP_ACP;
	} 

	LPCWSTR lpszwQuery;
	pITQuery->GetCommand(lpszwQuery);
	if (NULL == lpszwQuery)
		return E_NULLQUERY;

	// Query comes in as Unicode, but the FTI still uses MBCS.
	cbQuery = WideCharToMultiByte
        (dwCodePageID, 0, lpszwQuery, -1, NULL, 0, NULL, NULL);

	if ((lpszQuery = new char[cbQuery]) != NULL)
	{
		WideCharToMultiByte(dwCodePageID, 0, lpszwQuery, -1, lpszQuery, cbQuery,
																NULL, NULL);
		ParseParm.cbQuery = cbQuery - 1;
		ParseParm.lpbQuery = (const char*) lpszQuery;
	}
	else	
		hr = E_OUTOFMEMORY;

	// Parse query
	if (SUCCEEDED(hr))
	{
		FCALLBACK_MSG fcbkmsg;
		
		*pQueryTree = MVQueryParse (&ParseParm, &hr);

		if (SUCCEEDED(hr) && SUCCEEDED(pITQuery->GetResultCallback(&fcbkmsg)))
			MVSearchSetCallback(*pQueryTree, &fcbkmsg);
	}
	
	if (lpszQuery)
		delete lpszQuery;
		
	return hr;
}

/********************************************************************
 * @method    STDMETHODIMP | IITIndex | Close |
 *     Closes the full-text index.
 *
 * @rvalue S_OK | The index was successfully closed   
 *
 ********************************************************************/
STDMETHODIMP CITIndexLocal::Close()
{
	m_cs.Lock();

	if (m_idx)
	{
		MVIndexClose(m_idx);
		m_idx = NULL;
	}

	if (m_pCatalog)
	{
		m_pCatalog->Close();
		m_pCatalog->Release();
		m_pCatalog = NULL;
	}
	
	if (m_piwbrk != NULL)
	{
		m_piwbrk->Release();
		m_piwbrk = NULL;
	}
	
	m_cs.Unlock();
	return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITIndex | GetLocaleInfo |
 *     Gets locale info that the full text index was built with.
 * @parm DWORD* | pdwCodePageID | On exit, pointer to code page ID.
 * @parm LCID* | plcid | On exit, pointer to locale ID.
 *
 * @rvalue S_OK | The locale info was successfully retrieved.   
 *
 ********************************************************************/
STDMETHODIMP CITIndexLocal::GetLocaleInfo(DWORD *pdwCodePageID, LCID *plcid)
{
	INDEXINFO	indexinfo;
	
	if (pdwCodePageID == NULL || plcid == NULL)
		return (SetErrReturn(E_POINTER));

	if (m_idx == NULL)
		return (SetErrReturn(E_NOTOPEN));
		
	MVGetIndexInfoLpidx(m_idx, &indexinfo);
	*pdwCodePageID = indexinfo.dwCodePageID;
	*plcid = indexinfo.lcid;
	
	return (S_OK);
}


/********************************************************************
 * @method    STDMETHODIMP | IITIndex | GetWordBreakerInstance |
 *     Gets the ID of the word breaker instance that the full text
 *		index was built with.
 * @parm DWORD* | pdwObjInstance | On exit, pointer to word breaker instance.
 *
 * @rvalue S_OK | The word breaker instance ID was successfully retrieved.   
 *
 ********************************************************************/
STDMETHODIMP CITIndexLocal::GetWordBreakerInstance(DWORD *pdwObjInstance)
{
	INDEXINFO	indexinfo;
	
	if (pdwObjInstance == NULL)
		return (SetErrReturn(E_POINTER));
	
	if (m_idx == NULL)
		return (SetErrReturn(E_NOTOPEN));
		
	MVGetIndexInfoLpidx(m_idx, &indexinfo);
	*pdwObjInstance = indexinfo.dwBreakerInstID;
	
	return (S_OK);
}


// Private function - passed as a parameter by
// CITIndexLocal::HitListToResultSet.
SCODE __stdcall FreeRSColumnHeap(LPVOID lpvIndexObjBridge)
{
	CITIndexObjBridge *pidxobr;
	
	if (lpvIndexObjBridge == NULL)
		return (SetErrReturn(E_POINTER));
		
	pidxobr = (CITIndexObjBridge *) lpvIndexObjBridge;
	pidxobr->Release();
	delete pidxobr;

	return (S_OK);
}


// Private function - one grand hack to provide a result set from a hit list
STDMETHODIMP CITIndexLocal::HitListToResultSet(LPHL pHitList, IITResultSet* pRS,
												CITIndexObjBridge *pidxobr)
{
	DWORD cEntry;  // Number of entries
	HIT HitInfo;
	TOPICINFO TopicInfo;
	LONG lColumnUID = -1;
	LONG lColumnOccInfo[5];
	DWORD iTopic, iHit, iColumn;   // Loop indices
	LONG lRow = 0;
	HRESULT hr;

	ITASSERT(pRS != NULL && pidxobr != NULL);

    // Number of entries in hit list - if 0, just return FALSE
    if (0 == (cEntry = MVHitListEntries(pHitList)))
		return S_FALSE;

	hr = pRS->GetColumnFromPropID(STDPROP_UID, lColumnUID);

	if (!m_fSkipOcc)
	{
		for (iColumn = 0; iColumn < 5; iColumn++)
			lColumnOccInfo[iColumn] = -1;

		pRS->GetColumnFromPropID(STDPROP_FIELD, lColumnOccInfo[0]);
		pRS->GetColumnFromPropID(STDPROP_LENGTH, lColumnOccInfo[1]);
		pRS->GetColumnFromPropID(STDPROP_COUNT, lColumnOccInfo[2]);
		pRS->GetColumnFromPropID(STDPROP_OFFSET, lColumnOccInfo[3]);
		pRS->GetColumnFromPropID(STDPROP_TERM_UNICODE_ST, lColumnOccInfo[4]);
	}

    // Loop over all the topics in the hit list
    for (iTopic = 0; iTopic < cEntry; iTopic++)
    {
		hr = MVHitListGetTopic(pHitList, iTopic, &TopicInfo);
		if (FAILED(hr))
			return hr;   // or do we continue?

		if (m_fSkipOcc)
		{
			// No occurrence info
			if (-1 != lColumnUID)
				pRS->Set(lRow, lColumnUID, TopicInfo.dwTopicId);

			lRow++;
		}
		else
		{
			// Requested occurence info, so loop
			// over all the hits in this topic
			for (iHit = 0; iHit < TopicInfo.lcHits; iHit++)
			{
				if (-1 != lColumnUID)
					pRS->Set(lRow, lColumnUID, TopicInfo.dwTopicId);
				
				hr = MVHitListGetHit(pHitList, &TopicInfo, iHit, &HitInfo);
				if (FAILED(hr))
					continue;

				if (-1 != lColumnOccInfo[0])
					pRS->Set(lRow, lColumnOccInfo[0],  HitInfo.dwFieldId);
				if (-1 != lColumnOccInfo[1])
					pRS->Set(lRow, lColumnOccInfo[1],  HitInfo.dwLength);
				if (-1 != lColumnOccInfo[2])
					pRS->Set(lRow, lColumnOccInfo[2],  HitInfo.dwCount);
				if (-1 != lColumnOccInfo[3])
					pRS->Set(lRow, lColumnOccInfo[3],  HitInfo.dwOffset);
				if (-1 != lColumnOccInfo[4])
					pRS->Set(lRow, lColumnOccInfo[4],  (DWORD_PTR) HitInfo.lpvTerm);

				lRow++;

			}  
		}

	}

	// Fill in rest of properties from catalog (like IITWordWheel::GetData)
	if (m_pCatalog)
	{
		hr = m_pCatalog->Lookup(pRS);
		if (S_FALSE == hr)
			hr = S_OK;         // don't report S_FALSE
	}

	// If the caller requested Unicode term STs, then we need to give the result
	// set the string heap and adjust the string lengths in the heap.  Otherwise,
	// we will just let the heap get freed whenever pidxobr gets deleted.
	if (-1 != lColumnOccInfo[4])
	{
		pidxobr->AdjustQueryResultTerms();
		pRS->SetColumnHeap(lColumnOccInfo[4], (LPVOID) pidxobr, FreeRSColumnHeap);

		// Tell our caller not to delete pidxobr because the result set is
		// holding onto it.
		pidxobr->AddRef();
	}

	return S_OK;
}


// Need to export these without decoration to the linker so they can be called
// from the old .c files.
extern "C" {


PUBLIC HRESULT EXPORT_API FAR PASCAL
ExtBreakText(PEXBRKPM pexbrkpm)
{
	CITIndexObjBridge *pidxobr;
	
	if (pexbrkpm == NULL || pexbrkpm->lpvIndexObjBridge == NULL)
		return (SetErrReturn(E_POINTER));
		
	pidxobr = (CITIndexObjBridge *) pexbrkpm->lpvIndexObjBridge;
	
	return (pidxobr->BreakText(pexbrkpm));
}


PUBLIC HRESULT EXPORT_API FAR PASCAL
ExtStemWord(LPVOID lpvIndexObjBridge, LPBYTE lpbStemWord, LPBYTE lpbRawWord)
{
	CITIndexObjBridge *pidxobr;
	
	if (lpvIndexObjBridge == NULL ||
		lpbStemWord == NULL || lpbRawWord == NULL)
		return (SetErrReturn(E_POINTER));
		
	pidxobr = (CITIndexObjBridge *) lpvIndexObjBridge;
	return (pidxobr->StemWord(lpbStemWord, lpbRawWord));
}


PUBLIC HRESULT EXPORT_API FAR PASCAL
ExtLookupStopWord(LPVOID lpvIndexObjBridge, LPBYTE lpbStopWord)
{
	CITIndexObjBridge *pidxobr;
	
	if (lpvIndexObjBridge == NULL || lpbStopWord == NULL)
		return (SetErrReturn(E_POINTER));
		
	pidxobr = (CITIndexObjBridge *) lpvIndexObjBridge;
	return (pidxobr->LookupStopWord(lpbStopWord));
}


PUBLIC HRESULT EXPORT_API FAR PASCAL
ExtAddQueryResultTerm(LPVOID lpvIndexObjBridge, LPBYTE lpbTermHit,
												LPVOID *ppvTermHit)
{
	CITIndexObjBridge *pidxobr;
	
	if (lpvIndexObjBridge == NULL || lpbTermHit == NULL || ppvTermHit == NULL)
		return (SetErrReturn(E_POINTER));
		
	pidxobr = (CITIndexObjBridge *) lpvIndexObjBridge;
	return (pidxobr->AddQueryResultTerm(lpbTermHit, ppvTermHit));
}


}	// End extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\itccprel.cpp ===
// PRELOCAL.CPP: Source file that includes just the standard includes


#include <atlinc.h>

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#ifdef IA64
#include <itdfguid.h> 
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\iterr.h ===
// Error messages
#define SVERROR_BASE                                20000
#define SVERR_InitNew                               SVERROR_BASE + 0
#define SVERR_CoCreateInstance                      SVERROR_BASE + 1
#define SVERR_NoUID                                 SVERROR_BASE + 2
#define SVERR_SetEntry                              SVERROR_BASE + 3
#define SVERR_DatabaseSave                          SVERROR_BASE + 4
#define SVERR_IPSTGSave                             SVERROR_BASE + 5
#define SVERR_IPSTMSave                             SVERROR_BASE + 6
#define SVERR_ClassFactory                          SVERROR_BASE + 7
#define SVERR_CreateInstance                        SVERROR_BASE + 8

// Status messages
#define SVSTATUS_BASE                               21000
#define SV_StatusMessage                            SVSTATUS_BASE + 0
#define SV_BuildComplete                            SVSTATUS_BASE + 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\itccmain.cpp ===
// CIENTRY.CPP : Implementation of DLL Exports.

#include <atlinc.h>
#include <initguid.h>

#include <itcc.h>
#include <mvopsys.h>
#include <_mvutil.h>

#include <itwbrkid.h>
#include <itsortid.h>
#include <itpropl.h>
#include <itrs.h>
#include <itdb.h>
#include <itgroup.h>

#include "svWrdSnk.h"
#include "cmdint\cmdint.h"
#include "itsvmgr.h"
#include "gpbuild\gpumain.h"
#include "gpbuild\wfumain.h"
#include "ftbuild\ftumain.h"

CComModule _Module;
HINSTANCE _hInstITCC;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_IITCmdInt, CITCmdInt)
    OBJECT_ENTRY(CLSID_IITSvMgr, CITSvMgr)
    OBJECT_ENTRY(CLSID_IITGroupUpdate, CITGroupUpdate)
    OBJECT_ENTRY(CLSID_IITIndexBuild, CITIndexBuild)
    OBJECT_ENTRY(CLSID_IITWWFilterBuild, CITWWFilterUpdate)
    OBJECT_ENTRY(CLSID_IITWordSink, CDefWordSink)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
#ifdef _DEBUG
		MakeGlobalPool();
#endif
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
		_Module.Term();
#ifdef _DEBUG
		FreeGlobalPool();
#endif
    }
    _hInstITCC = hInstance;
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

STDAPI DllRegisterServer(void)
{
	return _Module.RegisterServer(FALSE);
}

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\query\queryimp.h ===
/************************************************************************
 *  @doc   SHROOM EXTERNAL API
 *
 *	TITLE: QUERYIMP.H
 *
 *	DESCRIPTION:
 *		Definition of CITQuery
 *  Autodoc headers added by Anita Legsdin 8/6/97
 *
 *********************************************************************/
// QUERYIMP.H:  Definition of CITQuery

#ifndef __QUERYIMP_H__
#define __QUERYIMP_H__

#include "verinfo.h"


// Implemenation of IITQuery

class CITQuery: 
	public IITQuery,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CITQuery, &CLSID_IITQuery>

{

BEGIN_COM_MAP(CITQuery)
	COM_INTERFACE_ENTRY(IITQuery)
END_COM_MAP()

DECLARE_REGISTRY(CLSID_IITQuery, "ITIR.Query.4", 
                 "ITIR.Query", 0, THREADFLAGS_BOTH)

public:
    CITQuery();
    ~CITQuery();

	// IITQuery methods
public:

	STDMETHOD(SetResultCallback)(FCALLBACK_MSG *pfcbkmsg);
	STDMETHOD(SetCommand)(LPCWSTR lpszCommand);
	STDMETHOD(SetOptions)(DWORD dwFlags);
	STDMETHOD(SetProximity)(WORD wNear);
	STDMETHOD(SetGroup)(IITGroup* pITGroup);
	STDMETHOD(SetResultCount)(LONG cRows);

/*****************************************************************
 * @method STDMETHOD | IITQuery | GetResultCallback |
 * Retrieves callback structure containing ERR_FUNC MessageFunc member 
 * that is called during query processing.
 *
 * @parm FCALLBACK_MSG | *pfcbkmsg | Pointer to callback structure.
 *
 * @rvalue E_POINTER | The argument *pfcbkmsg is NULL.
 * 
 * @xref <om .SetResultCallback>
 ****************************************************************/
	STDMETHOD(GetResultCallback)(FCALLBACK_MSG *pfcbkmsg)
		{
			if (pfcbkmsg == NULL)
				return (E_POINTER);
			*pfcbkmsg = m_fcbkmsg;
			return (S_OK);
		}

/*****************************************************************
 *  @method STDMETHOD | IITQuery | GetCommand |
 * Gets full-text query used by Search method.
 *
 * @parm LPCWSTR& | lpszCommand | Full-text query command. 
 *
 * @xref <om.SetCommand>
 *
 ****************************************************************/
	STDMETHOD(GetCommand)(LPCWSTR& lpszCommand) { lpszCommand = GetCommand(); return S_OK; }

/*****************************************************************
 *  @method STDMETHOD | IITQuery | GetOptions | 
 * Gets search options. 
 *
 * @parm DWORD& | dwFlags | Search options. See <om .SetCommand> for
 * a list of values. 
 *
 * @xref <om .setoptions>
 ****************************************************************/
	STDMETHOD(GetOptions)(DWORD& dwFlags) { dwFlags = GetOptions(); return S_OK; }

/*****************************************************************
 *  @method STDMETHOD | IITQuery | GetProximity | 
 *  Gets proximity value for searching with NEAR operator.
 *
 * @parm WORD& | wNear | The number of words apart the search terms can be to be 
 * considered "near". Default value is 8. 
 *
 * @xref <om.SetProximity>
 *
 ****************************************************************/
	STDMETHOD(GetProximity)(WORD& wNear) { wNear = GetProximity(); return S_OK; }

/*****************************************************************
 *  @method STDMETHOD | IITQuery | GetGroup | 
 * Gets the group object used in filtering search results. 
 *
 * @parm IITGroup** | ppiitGroup | Pointer to group object. 
 *
 * @rvalue E_POINTER | The argument ppitGroup is NULL.
 *
 * @xref <om .SetGroup>
 *
 ****************************************************************/
	STDMETHOD(GetGroup)(IITGroup** ppiitGroup) 
		{ 
			if (NULL==ppiitGroup) 
				return (E_POINTER);
			*ppiitGroup = GetGroup(); 
			return S_OK;
		}

/*****************************************************************
 *  @method STDMETHOD | IITQuery | GetResultCount | 
 * Gets maximum number of search hits to return. 
 *
 * @parm LONG& | cRows | Maximum number of hits. 
 *
 * @rvalue E_POINTER | The argument ppitGroup is NULL.
 *
 * @xref <om .SetResultCount>
 *
 ****************************************************************/
	STDMETHOD(GetResultCount)(LONG& cRows) { cRows = GetResultCount(); return S_OK; }

	STDMETHOD(ReInit)();


	// Access functions
public:
	LPCWSTR GetCommand() { return m_lpszCommand; }
	DWORD GetOptions() { return m_dwFlags; }
	WORD GetProximity() { return m_wNear; }
	DWORD GetResultCount() { return (DWORD) m_cRows; }
	IITGroup* GetGroup() { return m_pITGroup; }

    // Private methods and data
private:
	LONG m_cRows; 
	DWORD m_dwFlags;
	LPCWSTR m_lpszCommand;
	WORD m_wNear;
	IITGroup* m_pITGroup;
	LPVOID m_pCommand;
	FCALLBACK_MSG m_fcbkmsg;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\query\queryimp.cpp ===
/*************************************************************************
*  @doc SHROOM EXTERNAL API                                              *
*																		 *
*  QUERYIMP.CPP                                                          *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1997                              *
*  All Rights reserved.                                                  *
*                                                                        *
*  This file contains the implementation of the index object             *
*  												                         *
*																	     *
**************************************************************************
*                                                                        *
*  Written By   : Erin Foxford                                           *
*  Current Owner: erinfox                                                *
*                                                                        *
**************************************************************************/
#include <atlinc.h>

// MediaView (InfoTech) includes
#include <mvopsys.h>
#include <groups.h>
#include <wwheel.h>

#include <itquery.h>
#include "queryimp.h"

CITQuery::CITQuery() : m_dwFlags(0), m_wNear(8), m_pITGroup(NULL), m_cRows(0),
				       m_lpszCommand(NULL)  
{
    m_pCommand = BlockInitiate((DWORD)65500, 0, 0, 0);
    MEMSET(&m_fcbkmsg, NULL, sizeof(FCALLBACK_MSG));
}

CITQuery::~CITQuery() 
{
	if (m_pCommand)
		BlockFree(m_pCommand);

}


/********************************************************************
 * @method    STDMETHODIMP | IITQuery | SetResultCallback |
 *     Sets callback structure containing ERR_FUNC MessageFunc member
 *		that will be called periodically during query processing.
 *
 * @parm FCALLBACK_MSG* | pfcbkmsg | Pointer to callback structure.
 * @rvalue S_OK | The structure was successfully set.
 * @rvalue E_POINTER | pfcbkmsg was NULL
 * @rvalue E_BADPARAM | MessageFunc member of *pfcbkmsg was NULL.   
 *
 ********************************************************************/
STDMETHODIMP CITQuery::SetResultCallback(FCALLBACK_MSG *pfcbkmsg)
{
	if (pfcbkmsg == NULL)
		return (E_POINTER);
		
	if (pfcbkmsg->MessageFunc == NULL)
		return (E_BADPARAM);
		
	m_fcbkmsg = *pfcbkmsg;
	return (S_OK);
}

/********************************************************************
 * @method    STDMETHODIMP | IITQuery | SetCommand |
 *     Sets full-text query to be used when Search method is called.
 *
 * @parm LPCWSTR | lpszwCommand | Command to carry out
 * @rvalue S_OK | The command was successfully set   
 *
 ********************************************************************/
STDMETHODIMP CITQuery::SetCommand(LPCWSTR lpszwCommand)
{ 
	if (NULL == lpszwCommand)
		return E_INVALIDARG;

	if (m_pCommand)
	{
		BlockReset(m_pCommand);

		int cbData = (int) (2*(WSTRLEN(lpszwCommand)+1));
		if (NULL == (m_lpszCommand = (LPCWSTR) BlockCopy(m_pCommand, NULL, cbData, 0)))
			return E_OUTOFMEMORY;

		MEMCPY((LPVOID) m_lpszCommand, lpszwCommand, cbData);
	}
	else
		return E_OUTOFMEMORY;    // something went wrong in ctor
	
	return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITQuery | SetOptions |
 *     Sets options for searching
 *
 * @parm DWORD | dwFlag | Options, can be one or more of the following:
 * 
 * @flag IMPLICIT_AND | Search terms are AND'd if no operator is specified
 * @flag IMPLICIT_OR | Search terms are OR'd if no operator is specified
 * @flag COMPOUNDWORD_PHRASE | Use PHRASE operator for compound words
 * @flag QUERYRESULT_RANK | Results are returned in ranked order
 * @flag QUERYRESULT_UIDSORT | Results are returned in UID order
 * @flag QUERYRESULT_SKIPOCCINFO | Only topic-level hit information is returned
 * @flag STEMMED_SEARCH | The search returns stemmed results
 * @flag RESULT_ASYNC | Results are returned asynchronously
 * @flag QUERY_GETTERMS | Return with each set of occurrence data a pointer to
 *							the term string that the data is associated with.
 *
 * @rvalue S_OK | The options were successfully set   
 *
 ********************************************************************/
STDMETHODIMP CITQuery::SetOptions(DWORD dwFlags)
{
	m_dwFlags = dwFlags;
	return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITQuery | SetProximity |
 *     Sets proximity value for searching with NEAR operator. 
 *
 * @parm WORD | wNear | The number of words apart the search terms can
 * be to be considered "near". Default value is 8.
 *
 * @rvalue S_OK | The proximity value was successfully set   
 *
 ********************************************************************/
STDMETHODIMP CITQuery::SetProximity(WORD wNear)
{
	m_wNear = wNear;
	return S_OK;
}

/********************************************************************
 * @method    STDMETHODIMP | IITQuery | SetGroup |
 *     Sets group object to be used in filtering search results 
 *
 * @parm IITGroup* | pITGroup | Pointer to group object
 *
 * @rvalue S_OK | The group object was successfully set   
 * @comm If the existing query group is non-null, this method will
 * call Release() for the existing group before replacing it with the
 * new group object.  The caller is responsible for calling AddRef before
 * setting the new group.
 ********************************************************************/
STDMETHODIMP CITQuery::SetGroup(IITGroup* piitGrp)
{
	if (m_pITGroup != NULL)
		m_pITGroup->Release();

	m_pITGroup = piitGrp;
	return S_OK;
}


/********************************************************************
 * @method    STDMETHODIMP | IITQuery | SetResultCount |
 *     Sets maximum number of search hits to return
 *
 * @parm LONG | cRows | Maxium number of hits
 *
 * @rvalue S_OK | The proximity value was successfully set   
 *
 ********************************************************************/
STDMETHODIMP CITQuery::SetResultCount(LONG cRows)
{
	m_cRows = cRows;
	return S_OK;
}

/********************************************************************
 * @method    STDMETHODIMP | IITQuery | ReInit |
 *     Initializes query object to its default values
 *
 * @rvalue S_OK | The query object was successfully reinitialized  
 *
 ********************************************************************/

STDMETHODIMP CITQuery::ReInit()
{
	m_dwFlags = 0;
	m_wNear = 8;
	m_cRows = 0;          // I use this as number of hits, where 0 means all
	if (m_pCommand)
		BlockReset(m_pCommand);

	SetGroup(NULL);
	m_lpszCommand = NULL;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\svdoc.h ===
// SVDOC.H

#ifndef _SVDOC_H
#define _SVDOC_H

#include <windows.h>
#include <bfnew.h>
#include <dynarray.h>
#include <itpropl.h>
#include <itcc.h>

#define MAX_OBJECT_NAME 256
#define UID_INVALID 0xFFFFFFFF

// Index command macros

#define DYN_BUFFER_INIT_SIZE	256

typedef struct indexCmdType
{
    LPVOID ReservedForDynBuffer;
    int iStart, iNext;
    DWORD dwCommand, dwArg;
} INDEXCMD, *PINDEXCMD;

class CSvDocInternal : public CSvDoc
{
public:
    CSvDocInternal (void);
    ~CSvDocInternal ();

    virtual HRESULT WINAPI ResetDocTemplate (void);

    virtual HRESULT WINAPI AddObjectEntry(LPCWSTR lpObjName, IITPropList *pPL);
    virtual HRESULT WINAPI AddObjectEntry
        (LPCWSTR lpObjName, LPCWSTR szPropDest, IITPropList *pPL);

public:
	DWORD m_dwUID;
	
	LPBF m_lpbfEntry;
	LPBF m_lpbfDoc;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\itsvmgr.h ===
#ifndef __ITSVMGR_H__
#define __ITSVMGR_H__

#include <atlinc.h>
#include <itcc.h>
#include <itww.h>
#include <itwbrk.h>
#include <verinfo.h>
#include "svdoc.h"

typedef struct
{
    LPVOID pNext;
    CLSID clsid;
    IClassFactory *pCf;
} CLSIDENTRY, *PCLSIDENTRY;

typedef struct
{
    LPVOID pNext;
    WCHAR wszObjName[80];
    IITBuildCollect *piitbc;
    IStorage *piistg;
    IStream *piistm;
    LPWSTR wszStorage;
} OBJENTRY, *POBJENTRY;

// Service manager class
class CITSvMgr : 
	public IITSvMgr,
	public CComObjectRoot,
	public CComCoClass<CITSvMgr,&CLSID_IITSvMgr>
{
public:
BEGIN_COM_MAP(CITSvMgr)
	COM_INTERFACE_ENTRY(IITSvMgr)
END_COM_MAP()

DECLARE_REGISTRY (CLSID_IITSvMgr,
    "ITIR.SvMgr.4", "ITIR.SvMgr", 0, THREADFLAGS_APARTMENT)

public:
    CITSvMgr(void);
    ~CITSvMgr(void);

    STDMETHOD(Initiate)(IStorage *pistgStorage, IStream *piistmLog);
	STDMETHOD(Dispose)(void);
	STDMETHOD(Build)(void);

	STDMETHOD(SetPropDest)
        (LPCWSTR szObjectName, LPCWSTR szDestination, IITPropList *pPL);
	STDMETHOD(CreateBuildObject)(LPCWSTR szObjectName, REFCLSID refclsid);
    STDMETHOD(GetBuildObject)
        (LPCWSTR pwstrObjectName, REFIID refiid, void **ppInterface);

	STDMETHOD(CreateDocTemplate)(CSvDoc **ppDoc);
	STDMETHOD(FreeDocTemplate)(CSvDoc *pDoc);
	STDMETHOD(AddDocument)(CSvDoc *pDoc);

	STDMETHOD(HashString)(LPCWSTR lpwstr, DWORD *pdwHash);

private:
    STDMETHOD(CatalogSetEntry)(IITPropList *pPropList, DWORD dwFlags);
    STDMETHOD(CatalogCompleteUpdate)(void);
    STDMETHOD(LogMessage)(DWORD dwResourceId, ...);

    DL m_dlCLSID;
    DL m_dlObjList;
    IITCmdInt *m_pCmdInt;
    BOOL m_fInitialized;

    IITDatabase *m_piitdb;
    IPersistStorage *m_pipstgDatabase;
    IStorage *m_piistgRoot;
    IStream *m_piistmLog;

    // Document catalog members
    HANDLE m_hCatFile;
    char m_szCatFile[_MAX_PATH + 1];
    LPBYTE m_pCatHeader;
    DWORD m_dwMaxPropSize, m_dwMaxUID;
    IITPropList *m_pPLDocunent;
}; /* CITSvMgr */

#endif // __ITSVMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\svdoc.cpp ===
/*************************************************************************
*  @doc SHROOM EXTERNAL API                                              *
*  SVDOC.C			                                                     *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1997                              *
*  All Rights reserved.                                                  *
*                                                                        *
*																	     *
*  Written By   : JohnRush		                                  		 *
*  Current Owner: JohnRush                                               *
*                                                                        *
**************************************************************************/


#ifdef _DEBUG
static char s_aszModule[] = __FILE__;   /* For error report */
#endif

#include <windows.h>
#include <mvopsys.h>
#include <_mvutil.h>
#include <assertf.h>

#include "svdoc.h"

CSvDocInternal::CSvDocInternal (void)
{
	m_lpbfEntry = NULL;
	m_lpbfDoc = NULL;
	m_dwUID = UID_INVALID;

} /* SVCreateDocTemplate */


CSvDocInternal::~CSvDocInternal ()
{
	if (m_lpbfEntry)
		DynBufferFree(m_lpbfEntry);

	if (m_lpbfDoc)
		DynBufferFree(m_lpbfDoc);

} /* SVFreeDocTemplate */

/********************************************************************
 * @method    HRESULT WINAPI | CSvDoc | ResetDocTemplate |
 * Clears the contents of the document template so that the next document's
 * properties can be added.
 *
 * @rvalue S_OK | Currently always returns this value.
 *
 * @xref <om.AddObjectEntry>
 *
 * @comm A document template object is meant to be reused for all documents
 * being added to the service manager build.
 ********************************************************************/
HRESULT WINAPI CSvDocInternal::ResetDocTemplate (void)
{
	m_dwUID = UID_INVALID;

    if (m_lpbfEntry)
        DynBufferReset (m_lpbfEntry);
    if (m_lpbfDoc)
        DynBufferReset (m_lpbfDoc);

    return S_OK;
} /* ResetDocTemplate */


/********************************************************************
 * @method    HRESULT WINAPI | CSvDoc | AddObjectEntry |
 * Sets properties of an object such as a group or word wheel. 
 *
 * @parm LPCWSTR | lpObjName | The text string identifying a group or word wheel object
 * @parm IITPropList * | pPL | The property list you want to add to the object
 *
 * @rvalue S_OK | The given properties were added to the processing queue for the given object.
 * @rvalue E_OUTOFMEMORY | Some resources needed by the service manager could not be allocated
 *
 * @xref <om IITSvMgr.AddDocument>
 *
 * @comm Once all the properties for all objects have been added, call the 
 * <p AddDocument> method to complete the processing for the current document
 ********************************************************************/

HRESULT WINAPI CSvDocInternal::AddObjectEntry
    (LPCWSTR lpObjName, IITPropList *pPL)
{
    return AddObjectEntry (lpObjName, L"", pPL);
} /* AddObjectEntry */


/********************************************************************
 * @method    HRESULT WINAPI | CSvDoc | AddObjectEntry |
 * Sets properties of an object such as a group or word wheel. 
 *
 * @parm LPCWSTR | lpObjName | The text string identifying a group or word wheel object
 * @parm LPCWSTR | szPropDest | The text string identifying the
 *  destination of this property list
 * @parm IITPropList * | pPL | The property list you want to add to the object
 *
 * @rvalue S_OK | The given properties were added to the processing queue for the given object.
 * @rvalue E_OUTOFMEMORY | Some resources needed by the service manager could not be allocated
 *
 * @xref <om IITSvMgr.AddDocument>
 *
 * @comm Once all the properties for all objects have been added, call the 
 * <p AddDocument> method to complete the processing for the current document.
 ********************************************************************/

HRESULT WINAPI CSvDocInternal::AddObjectEntry
    (LPCWSTR lpObjName, LPCWSTR szPropDest, IITPropList *pPL)
{
	CProperty prop;
	LPBF lpbf;
    ULARGE_INTEGER ulSize;

	// An empty property list is OK but useless
	if (!pPL || FAILED (pPL->GetFirst(prop)))
		return S_OK;

	// Copy the proplist to the batch execution buffer
	if (lpObjName)
	{
        LONG lcb;

		if (!m_lpbfEntry &&
			NULL == (m_lpbfEntry = DynBufferAlloc (DYN_BUFFER_INIT_SIZE)))
			return SetErrReturn(E_OUTOFMEMORY);

        // Write object name
		lcb = (LONG) (WSTRLEN(lpObjName) + 1) * sizeof(WCHAR);
		if (!DynBufferAppend(m_lpbfEntry, (LPBYTE)lpObjName, lcb))
			return SetErrReturn(E_OUTOFMEMORY);

        // Write property destination
        if(!szPropDest)
            szPropDest = L"";
		lcb = (LONG) (WSTRLEN(szPropDest) + 1) * sizeof(WCHAR);
		if (!DynBufferAppend(m_lpbfEntry, (LPBYTE)szPropDest, lcb))
			return SetErrReturn(E_OUTOFMEMORY);

		lpbf = m_lpbfEntry;
	}
	else
	{
		if (!m_lpbfDoc &&
			NULL == (m_lpbfDoc= DynBufferAlloc (DYN_BUFFER_INIT_SIZE)))
			return SetErrReturn(E_OUTOFMEMORY);

		lpbf = m_lpbfDoc;
	}

    pPL->GetSizeMax (&ulSize);
    // Write the record length
    if (!DynBufferAppend (lpbf, (LPBYTE)&ulSize.LowPart, sizeof (DWORD)))
        return SetErrReturn(E_OUTOFMEMORY);
    // Write all the tags
    if (!DynBufferEnsureAdd (lpbf, ulSize.LowPart))
        return SetErrReturn(E_OUTOFMEMORY);
    pPL->SaveToMem (DynBufferPtr (lpbf) + DynBufferLen (lpbf), ulSize.LowPart);
    DynBufferSetLength (lpbf, (DynBufferLen (lpbf) + ulSize.LowPart));
    return S_OK;
} /* AddObjectEntry */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\svutil.h ===
// SVUTIL.H

#include <_mvutil.h>

BOOL WINAPI StreamGetLine
    (IStream *pStream, LPWSTR rgch, int *cch, int iReceptacleSize);
BOOL StreamGetLineASCII
    (IStream *pStream, LPWSTR rgch, int *cch, int iReceptacleSize);
DWORD BinFromHex(LPSTR lpszHex, LPSTR lpbData, DWORD dwSize);
DWORD HexFromBin(LPSTR lpszHex, LPBYTE lpbData, DWORD dwSize);
LPSTR WINAPI StringToLong(LPCSTR lszBuf, LPDWORD lpValue);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\svwrdsnk.h ===
#ifndef __SVWRDSNK_H__
#define __SVWRDSNK_H__

#include <windows.h>
#include <atlinc.h>
#include <verinfo.h>
#include <itwbrk.h>
#include <itwbrkid.h>

// {8fa0d5a9-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(CLSID_IITWordSink,
0x8fa0d5a9, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

class CDefWordSink : 
	public IWordSink,
	public CComObjectRoot,
	public CComCoClass<CDefWordSink,&CLSID_IITWordSink>
{
public:
BEGIN_COM_MAP(CDefWordSink)
	COM_INTERFACE_ENTRY(IWordSink)
END_COM_MAP()

DECLARE_REGISTRY (CDefWordSink,
    "ITIR.SystemWordSink.4", "ITIR.SystemWordSink",
    0, THREADFLAGS_APARTMENT)

public:
//    CDefWordSink() {m_dwWordCount = 0;}

    STDMETHOD(PutWord)( WCHAR const * pwcInBuf,
                   ULONG cwc,
                   ULONG cwcSrcLen,
                   ULONG cwcSrcPos );
    STDMETHOD(PutAltWord)( WCHAR const * pwcInBuf,
                      ULONG cwc, 
                      ULONG cwcSrcLen,
                      ULONG cwcSrcPos );
    STDMETHOD(StartAltPhrase)(void);
    STDMETHOD(EndAltPhrase)(void);
    STDMETHOD(PutBreak)(WORDREP_BREAK_TYPE breakType);

    STDMETHOD(SetLocaleInfo)(DWORD dwCodePage, LCID lcid);
    STDMETHOD(SetIPB)(void *lpipb);
    STDMETHOD(SetDocID)(DWORD dwDocID);
    STDMETHOD(SetVFLD)(DWORD dwVFLD);


private:
    void *m_lpipb;
    LCID m_lcid;
    DWORD m_dwWordCount, m_dwUID, m_dwVFLD, m_dwCodePage;
}; /* CITSvMgr */

#endif // __SVWRDSNK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\svwrdsnk.cpp ===
#include <windows.h>
#include "svWrdSnk.h"

#include <mvopsys.h>
#include <common.h>

/*
    By not implementing this method we cause DBCS source lengths to be
    inaccurate.  To solve this problem we need to beffur the result of the
    PutAltWord call and actually add the term to the index once we have all
    the occurrence data.  Specifically, the byte count for cwc.
*/
STDMETHODIMP CDefWordSink::PutWord
    (WCHAR const *pwcInBuf, ULONG cwc, ULONG cwcSrcLen, ULONG cwcSrcPos)
{
    return S_OK;
} // PutWord

STDMETHODIMP CDefWordSink::PutAltWord
    (WCHAR const *pwcInBuf, ULONG cwc, ULONG cwcSrcLen, ULONG cwcSrcPos)
{
	OCC occ;
	occ.dwFieldId = m_dwVFLD;
	occ.dwTopicID = m_dwUID;
	occ.dwCount   = m_dwWordCount++;
    // This is a character count and will be wrong for DBCS languages!
	occ.wWordLen  = (WORD)cwcSrcLen;
    occ.dwOffset  = cwcSrcPos;

    char strTerm[100 + sizeof(WORD)];
    if(0 == (*(LPWORD)strTerm = (WORD) WideCharToMultiByte(m_dwCodePage, 0, pwcInBuf, cwc,
        strTerm + sizeof(WORD), 99, NULL, NULL)))
    {
        // The conversion failed! -- very bad
        return SetErrReturn(E_UNEXPECTED);
    }
    return MVIndexAddWord(m_lpipb, (LPB)strTerm, &occ);
} // PutAltWord

STDMETHODIMP CDefWordSink::StartAltPhrase(void)
{
    return S_OK;
} // StartAltPhrase

STDMETHODIMP CDefWordSink::EndAltPhrase(void)
{
    return S_OK;
} // EndAltPhrase

STDMETHODIMP CDefWordSink::PutBreak(WORDREP_BREAK_TYPE breakType)
{
    return S_OK;
} // PutBreak

STDMETHODIMP CDefWordSink::SetIPB(void *lpipb)
{
    if(NULL == (m_lpipb = lpipb))
        return E_POINTER;
    return S_OK;
} // SetIPB

STDMETHODIMP CDefWordSink::SetDocID(DWORD dwUID)
{
    if (m_dwUID != dwUID)
    {
        m_dwUID = dwUID;
        m_dwWordCount = 0;
    }
    return S_OK;
} // SetDocID

STDMETHODIMP CDefWordSink::SetVFLD(DWORD dwVFLD)
{
    m_dwVFLD = dwVFLD;
    return S_OK;
} // SetVFLD


STDMETHODIMP CDefWordSink::SetLocaleInfo(DWORD dwCodePage, LCID lcid)
{
    m_dwCodePage = dwCodePage;
    m_lcid = lcid;
    return S_OK;
} /* SetLocaleInfo */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\svmgr.cpp ===
/*************************************************************************
*  @doc SHROOM EXTERNAL API                                              *
*																		 *
*  SVMGR.C                                                               *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1995-1997                         *
*  All Rights reserved.                                                  *
*                                                                        *
*  The Service Manager is responsible for reading the object description *
*  from the command interpreter, getting object properties and data, and *
*  building the objects.												 *
*																	     *
**************************************************************************
*                                                                        *
*  Written By   : John Rush                                              *
*  Current Owner: johnrush                                               *
*                                                                        *
**************************************************************************/

#include <verstamp.h>
SETVERSIONSTAMP(MVSV);
#include <mvopsys.h>

#ifdef _DEBUG
static char s_aszModule[] = __FILE__;   /* For error report */
#endif

#include <windows.h>

#ifdef IA64 
#include <itdfguid.h> 
#endif

#include <iterror.h>
#include <orkin.h>
#include <wrapstor.h>
#include <_mvutil.h>
#include <mvsearch.h>
#include <dynarray.h>
#include <groups.h>
#include <itwbrk.h>
#include <itwbrkid.h>
#include <ccfiles.h>
#include <itdb.h>
#include <itsortid.h>
#include <itgroup.h>

#include "itsvmgr.h"
#include "svutil.h"
#include "svdoc.h"
#include "iterr.h"

extern HINSTANCE _hInstITCC;

CITSvMgr::CITSvMgr(void)
{
    m_fInitialized = FALSE;
    m_piistmLog = NULL;
}

CITSvMgr::~CITSvMgr(void)
{
    if (m_fInitialized)
        Dispose();
}

/********************************************************************
 * @method    HRESULT WINAPI | IITSvMgr | Initiate |
 *      Creates and initiates a structure containing
 *      data necessary for future service requests.
 *
 * @parm IStorage * | pStorage |
 *		Pointer to destination IStorage. In most cases, this 
 * is the ITSS IStorage file.
 *
 * @parm IStream * | piistmLog |
 *		Optional IStream to log error messages.
 *
 * @rvalue S_OK | The service manager was initialized successfully
 * @rvalue E_INVALIDARG | One of the required arguments was NULL or otherwise not valid
 * @rvalue E_OUTOFMEMORY | Some resources needed by the service manager could not be allocated
 *
 * @xref <om.LoadFromStream>
 *
 * @comm This should be the first method called for the service manager.
 ********************************************************************/
HRESULT WINAPI CITSvMgr::Initiate
    (IStorage *piistgStorage, IStream *piistmLog)
{
    HRESULT hResult = S_OK;

    if (m_fInitialized)
        return SetErrReturn(E_ALREADYINIT);

    if (NULL == piistgStorage)
        return SetErrReturn(E_INVALIDARG);

    if(m_piistmLog = piistmLog)
        m_piistmLog->AddRef();

    m_pPLDocunent = NULL;
    m_pCatHeader = NULL;
    m_dwMaxPropSize = 0;
    *m_szCatFile = '\0';
    m_piitdb = NULL;
    m_pipstgDatabase = NULL;
    m_dwMaxUID = 0;

    hResult = (m_piistgRoot = piistgStorage)->AddRef();

    if (SUCCEEDED(hResult))
    {
        ZeroMemory (&m_dlCLSID, sizeof (DL));
        ZeroMemory (&m_dlObjList, sizeof (DL));

        // Create database
        if (SUCCEEDED(hResult = CoCreateInstance(CLSID_IITDatabaseLocal, NULL,
                CLSCTX_INPROC_SERVER, IID_IITDatabase, (void **)&m_piitdb))
            &&
            SUCCEEDED(hResult = m_piitdb->QueryInterface
                (IID_IPersistStorage, (void **)&m_pipstgDatabase)))
        {
            if (FAILED(hResult = m_pipstgDatabase->InitNew(piistgStorage)))
                LogMessage(SVERR_InitNew, "IITDatabase", hResult);
        }
    }

    if (FAILED(hResult))
    {

        if (m_piistgRoot)
            m_piistgRoot->Release();
        piistgStorage->Release();
        
        if (m_piitdb)
        {
            m_piitdb->Release();
            m_piitdb = NULL;
        }
        if (m_pipstgDatabase)
        {
            m_pipstgDatabase->Release();
            m_pipstgDatabase = NULL;
        }
    } else
        m_fInitialized = TRUE;

    return (hResult);
} /* SVInitiate */

/********************************************************************
 * @method    HRESULT WINAPI | IITSvMgr | Dispose |
 *
 * Signal that all services are no longer needed, causing any resources 
 * allocated during use of the service manager to be freed.
 *
 * @rvalue S_OK | All resources freed successfully
 *
 * @xref <om.Initiate>
 *
 * @comm This should be the last method called for the service manager.
 ********************************************************************/
HRESULT WINAPI CITSvMgr::Dispose ()
{
    if (FALSE == m_fInitialized)
        return SetErrReturn(E_NOTINIT);

    if (m_pPLDocunent)
    {
        m_pPLDocunent->Release();
        m_pPLDocunent = NULL;
    }

    // Destroy catalog
    if (*m_szCatFile)
    {
        CloseHandle (m_hCatFile);
        DeleteFile (m_szCatFile);
    }

    if (m_pCatHeader)
    {
        _GLOBALFREE ((HANDLE)m_pCatHeader);
        m_pCatHeader = NULL;
        *m_szCatFile = '\0';
    }

    m_piitdb->Release();
    m_pipstgDatabase->Release();

    m_piistgRoot->Release();
    if(m_piistmLog)
        m_piistmLog->Release();

    if (DynArrayValid (&m_dlCLSID))
    {
        PCLSIDENTRY pEntry;
        for (pEntry = (PCLSIDENTRY)DynArrayGetFirstElt (&m_dlCLSID);
            pEntry; pEntry = (PCLSIDENTRY)DynArrayNextElt (&m_dlCLSID))
        {
            pEntry->pCf->Release();
        }
        DynArrayFree (&m_dlCLSID);
    }

    if (DynArrayValid (&m_dlObjList))
    {
        POBJENTRY pEntry;
        for (pEntry = (POBJENTRY)DynArrayGetFirstElt (&m_dlObjList);
            pEntry; pEntry = (POBJENTRY)DynArrayNextElt (&m_dlObjList))
        {
            if (pEntry->piitbc)
            {
                pEntry->piitbc->Release();
                pEntry->piitbc = NULL;

                if (pEntry->piistg)
                {
                    pEntry->piistg->Commit(STGC_DEFAULT);
                    pEntry->piistg->Release();
                } else if (pEntry->piistm)
                    pEntry->piistm->Release();
#ifdef _DEBUG
                pEntry->piistg = NULL;
                pEntry->piistm = NULL;
#endif
            }
            delete pEntry->wszStorage;
        }
        DynArrayFree (&m_dlObjList);
    }

    m_fInitialized = FALSE;

    return S_OK;
} /* Dispose */


/********************************************************************
 * @method    HRESULT WINAPI | IITSvMgr | AddDocument |
 * Adds the authored properties and indexable content that were added to the
 * given document template into the service manager's build process.  Once 
 * AddDocument is called, the data will included in the pending 
 * Build() operation.
 *
 * @parm CSvDoc *| pDoc | Pointer to document template containing the
 * content and properties for the current document.
 *
 * @rvalue S_OK | The properties and content were added successfully
 * @rvalue E_MISSINGPROP | The document did not have one of the mandatory properties.
 * Currently, the only required property is STDPROP_UID.
 *
 * @rvalue E_INVALIDARG | One of the required arguments was NULL or otherwise not valid
 * @rvalue E_OUTOFMEMORY | Some resources needed by the service manager could not be allocated
 *
 * @xref <om.AddObjectEntry>
 * @xref <om.Build>
 *
 * @comm
 ********************************************************************/

HRESULT WINAPI CITSvMgr::AddDocument (CSvDoc *lpDoc)
{
	WCHAR *lpch;
    HRESULT hr;
    DWORD cbData;
    CSvDocInternal *pDoc = (CSvDocInternal *)lpDoc;

    if (FALSE == m_fInitialized)
        return SetErrReturn(E_NOTINIT);

    if (NULL == pDoc)
        return SetErrReturn(E_INVALIDARG);

	// Suck in the document properties from the batch buffer
	if (!pDoc->m_lpbfDoc)
		return SetErrReturn(E_MISSINGPROP);

    // Create property list
    if (m_pPLDocunent == NULL)
    {
        hr = CoCreateInstance (CLSID_IITPropList, NULL,
            CLSCTX_INPROC_SERVER, IID_IITPropList, (LPVOID *)&m_pPLDocunent);
        if (FAILED (hr))
        {
            LogMessage(SVERR_CoCreateInstance, "IID_IITPropList", hr);
            return SetErrReturn(hr);
        }
    }
    else
        m_pPLDocunent->Clear();

    // Get the property list for the document
    cbData = *(LPDWORD)DynBufferPtr (pDoc->m_lpbfDoc);
    m_pPLDocunent->LoadFromMem (DynBufferPtr (pDoc->m_lpbfDoc) + sizeof (DWORD), cbData);

    // Get the UID for the document
    CProperty UidProp;
    if (FAILED(hr = m_pPLDocunent->Get(STDPROP_UID, UidProp))
        || TYPE_STRING == UidProp.dwType)
    {
        LogMessage(SVERR_NoUID);
        return SetErrReturn(E_MISSINGPROP);
    }
    // This could be a pointer to a UID or a DWORD UID
    if (TYPE_VALUE == UidProp.dwType)
        pDoc->m_dwUID = UidProp.dwValue;
    else if (TYPE_POINTER == UidProp.dwType)
        pDoc->m_dwUID = *((LPDWORD&)UidProp.lpvData);

    if (m_dwMaxUID < pDoc->m_dwUID)
        m_dwMaxUID = pDoc->m_dwUID;

    if (cbData)
        CatalogSetEntry (m_pPLDocunent, 0);

	// Now scan through the batch entry buffer.  For each object, farm out the
	// persisted property values to that object.
	if (!pDoc->m_lpbfEntry || !DynBufferLen (pDoc->m_lpbfEntry))
		return S_OK;

	// Ensure the buffer is terminated with zero marker
    cbData = 0;
    if (!DynBufferAppend (pDoc->m_lpbfEntry, (LPBYTE)&cbData, sizeof (DWORD)))
		return SetErrReturn(E_OUTOFMEMORY);

    // Work through all the property lists
	for (lpch = (WCHAR *) DynBufferPtr(pDoc->m_lpbfEntry); lpch;)
	{
		WCHAR szObject[MAX_OBJECT_NAME];
		WCHAR szPropDest[MAX_OBJECT_NAME];
        
        m_pPLDocunent->Clear();

		// found zero marker instead of name
		if (*(LPDWORD)lpch == 0L)
			break;

		// read the object name
		WSTRCPY(szObject, lpch);
		lpch += WSTRLEN(szObject) + 1;

		// read the property destination
		WSTRCPY(szPropDest, lpch);
		lpch += WSTRLEN(szPropDest) + 1;

        cbData = *(LPDWORD)lpch;
        ((LPBYTE&)lpch) += sizeof(DWORD);
        
        m_pPLDocunent->LoadFromMem (lpch, cbData);
        ((LPBYTE&)lpch) += cbData;

		// we now have a property list, examine the object type and pass to the
		// lower level build routines.
        POBJENTRY pEntry;
        for (pEntry = (POBJENTRY)DynArrayGetFirstElt (&m_dlObjList);
            pEntry; pEntry = (POBJENTRY)DynArrayNextElt (&m_dlObjList))
        {
            if (!WSTRICMP (szObject, pEntry->wszObjName) && pEntry->piitbc)
            {
                hr = pEntry->piitbc->SetEntry 
                    (*szPropDest ? szPropDest : NULL, m_pPLDocunent);
                if (FAILED (hr))
                {
                    LogMessage(SVERR_SetEntry, pEntry->wszObjName, hr);

                    pEntry->piitbc->Close();
                    pEntry->piitbc->Release();
                    pEntry->piitbc = NULL;

                    if (pEntry->piistg)
                        pEntry->piistg->Release();
                    else if (pEntry->piistm)
                        pEntry->piistm->Release();
#ifdef _DEBUG
                    pEntry->piistg = NULL;
                    pEntry->piistm = NULL;
#endif
                    m_piistgRoot->DestroyElement (pEntry->wszStorage);
                }
                break;
            }
        }
		// UNDONE: document catalog build (titles and other custom doc properties) 
	}
    return S_OK;
} /* AddDocument */


/********************************************************************
 * @method    HRESULT WINAPI | IITSvMgr | Build |
 * Takes the data accumulated during AddDocument calls and completes the
 * creation of the objects that were requested in the original command
 * interpreter description.
 *
 * @rvalue S_OK | All requested objects, such as wordwheels, and full-text
 * index, were built successfully and added to the output storage.
 *
 * @rvalue E_OUTOFMEMORY | Some resources needed by the service manager could not be allocated
 *
 * @xref <om.AddObjectEntry>
 * @xref <om.AddDocument>
 *
 * @comm
 ********************************************************************/
HRESULT WINAPI CITSvMgr::Build ()
{
    HRESULT hr = S_OK;
    ITBuildObjectControlInfo itboci = {sizeof (itboci), m_dwMaxUID};

    if (FALSE == m_fInitialized)
        return SetErrReturn(E_NOTINIT);

    // Handle Document Catalog
    hr = CatalogCompleteUpdate();

    // Save all breaker and sort instance data to the storage
    if (SUCCEEDED(hr))
    {
        if (FAILED(hr = m_pipstgDatabase->Save(m_piistgRoot, TRUE)))
            LogMessage(SVERR_DatabaseSave, hr);
    }

    if (SUCCEEDED(hr) && DynArrayValid (&m_dlObjList))
    {
	    // Build objects
        for (POBJENTRY pObj = (POBJENTRY)DynArrayGetFirstElt (&m_dlObjList);
            pObj; pObj = (POBJENTRY)DynArrayNextElt (&m_dlObjList))
        {
            if (NULL == pObj->piitbc)
                continue;

            hr = pObj->piitbc->SetBuildStats(itboci);
            if (FAILED(hr) && hr != E_NOTIMPL)
            {
;//                LogMessage();
                continue;
            }

            if (pObj->piistg)
            {
                // Must support IPersistStorage
                IPersistStorage *pPersistStorage;
                if (FAILED(hr = pObj->piitbc->QueryInterface
                    (IID_IPersistStorage, (void **)&pPersistStorage)))
                {
                    ITASSERT(0); // We shoulnd't ever hit this condition!
                    continue;
                }

                if(FAILED(hr = pPersistStorage->Save(pObj->piistg, TRUE)))
                    LogMessage(SVERR_IPSTGSave, pObj->wszObjName, hr);
                
                pPersistStorage->Release();

                pObj->piistg->Commit(STGC_DEFAULT);
                pObj->piistg->Release();
            }
            else if (pObj->piistm)
            {
                // Must support IPersistStream then
                IPersistStreamInit *pPersistStream;
                if (FAILED(hr = pObj->piitbc->QueryInterface
                    (IID_IPersistStreamInit, (void **)&pPersistStream)))
                {
                    ITASSERT(0); // We shoulnd't ever hit this condition!
                    continue;
                }
                if(FAILED(hr = pPersistStream->Save(pObj->piistm, TRUE)))
                    LogMessage(SVERR_IPSTMSave, pObj->wszObjName, hr);

                pPersistStream->Release();
                pObj->piistm->Release();
#ifdef _DEBUG
                pObj->piistm = NULL;
#endif
            }
            // What's the deal???  We checked for these earlier!
            else ITASSERT(0);

            if (FAILED (hr))
                m_piistgRoot->DestroyElement (pObj->wszStorage);

            pObj->piitbc->Release();
            pObj->piitbc = NULL;
        }
        hr = S_OK;  // We don't return componenet build errors
    }

    LogMessage(SV_BuildComplete);

    return hr;
} /* Build */


/********************************************************************
 * @method    HRESULT WINAPI | IITSvMgr | CreateDocTemplate |
 * Returns a popinter to a CSVDoc class which can be sent to AddDocument.
 * Pass this pointer to FreeDocTemplate when you no longer need it.
 *
 * @rvalue S_OK | The CSvDoc object was succesfully created.
 *
 * @rvalue E_OUTOFMEMORY | Some resources needed by the service manager could not be allocated
 *
 * @xref <om.AddObjectEntry>
 * @xref <om.AddDocument>
 * @xref <om.FreeDocTemplate>
 *
 * 
 ********************************************************************/
HRESULT WINAPI CITSvMgr::CreateDocTemplate (CSvDoc **pDoc)
{
    *pDoc = new CSvDocInternal;
    if (*pDoc)
        return S_OK;
    return SetErrReturn(E_OUTOFMEMORY);
} /* CreateDocTemplate */


/********************************************************************
 * @method    HRESULT WINAPI | IITSvMgr | FreeDocTemplate |
 * Frees a CSvDoc class returned from CreateDocTemplate.
 *
 * @rvalue E_INVALIDARG | Thie CSvDoc pointer is NULL.
 * @rvalue S_OK | The CSvDoc object was freed.
 *
 * @xref <om.CreateDocTemplate>
 *
 * 
 ********************************************************************/
HRESULT WINAPI CITSvMgr::FreeDocTemplate (CSvDoc *pDoc)
{
    if (NULL == pDoc)
        return SetErrReturn(E_INVALIDARG);
    delete (CSvDocInternal *)pDoc;
    return S_OK;
} /* FreeDocTemplate */


/********************************************************************
 * @method    HRESULT WINAPI | IITSvMgr | CreateBuildObject|
 * Creates a build object.
 *
 * @parm LPCWSTR | szObjectName | Name of object to create. 
 * @parm REFCLSID | clsid |Class ID of object.  
 * 
 * @rvalue S_OK | The operation completed successfully.
 * @rvalue E_INVALIDARG | The argument was not valid
 *
********************************************************************/
HRESULT WINAPI CITSvMgr::CreateBuildObject(LPCWSTR szObjectName, REFCLSID clsid)
{
    HRESULT hr;

    if (FALSE == m_fInitialized)
        return SetErrReturn(E_NOTINIT);

    if (NULL == szObjectName)
        return SetErrReturn(E_INVALIDARG);

    if (!DynArrayValid (&m_dlCLSID))
        // This allocates a dynamic array that can hold a
        // MAXIMUM of 500 unique classes
        if (FALSE == DynArrayInit (&m_dlCLSID,
            sizeof (CLSIDENTRY) * 5, 100, sizeof (CLSIDENTRY), 0))
            return SetErrReturn(E_OUTOFMEMORY);

    // Is this entry already in the list?
    PCLSIDENTRY pclsidEntry;
    IClassFactory *pCF;
    for (pclsidEntry = (PCLSIDENTRY)DynArrayGetFirstElt (&m_dlCLSID);
        pclsidEntry; pclsidEntry = (PCLSIDENTRY)DynArrayNextElt (&m_dlCLSID))
    {
        if (clsid == pclsidEntry->clsid)
        {
            pCF = pclsidEntry->pCf;
            break;
        }
    }

    // Create new class factory
    if (NULL == pclsidEntry)
    {
    	hr = CoGetClassObject(clsid, CLSCTX_INPROC_SERVER, NULL, 
                          IID_IClassFactory, (VOID **)&pCF);
        if (FAILED (hr))
        {
            LogMessage(SVERR_ClassFactory, szObjectName, hr);
            return hr;
        }

        pclsidEntry = (PCLSIDENTRY)DynArrayAppendElt (&m_dlCLSID);
        if (NULL == pclsidEntry)
            return SetErrReturn(E_OUTOFMEMORY);
        pclsidEntry->clsid = clsid;
        pclsidEntry->pCf = pCF;
    }

    // Create new class object
    IITBuildCollect *pInterface;
	if (FAILED (hr = pCF->CreateInstance 
        (NULL, IID_IITBuildCollect, (VOID **)&pInterface)))
    {
        LogMessage(SVERR_CreateInstance, szObjectName, hr);
        return hr;
    }

    // Construct Storage/Stream name
    WCHAR szStorage [CCH_MAX_OBJ_NAME + CCH_MAX_OBJ_STORAGE + 1];
    pInterface->GetTypeString(szStorage, NULL);
    WSTRCAT(szStorage, szObjectName);

    // Check for IPersistStorage support
    IStorage *pSubStorage = NULL;
    IStream *pStream = NULL;
    IPersistStorage *pPersistStorage;
    if (SUCCEEDED(hr = pInterface->QueryInterface
        (IID_IPersistStorage, (void **)&pPersistStorage)))
    {
        // Create sub-storage for object persistance
        if (FAILED (hr = m_piistgRoot->CreateStorage
            (szStorage, STGM_READWRITE, 0, 0, &pSubStorage)))
        {
            pPersistStorage->Release();
            return hr;
        } 

        hr = pPersistStorage->InitNew(pSubStorage);

        pPersistStorage->Release(); // Don't need to hold on to this
        if (FAILED(hr))
        {
            LogMessage(SVERR_CreateInstance, szObjectName, hr);

            pSubStorage->Release();
            m_piistgRoot->DestroyElement(szStorage);   
            return hr;
        }
    }
    else
    {
        IPersistStreamInit *pPersistStream;
        if (FAILED(hr = pInterface->QueryInterface
            (IID_IPersistStreamInit, (void **)&pPersistStream)))
            // No IPersistX interfaces supported!
            return hr;

        if (FAILED (hr = m_piistgRoot->CreateStream
            (szStorage, STGM_READWRITE, 0, 0, &pStream)))
        {
            pPersistStream->Release();
            return hr;
        }

        hr = pPersistStream->InitNew();
        pPersistStream->Release();
        if (FAILED(hr))
        {
            pStream->Release();
            m_piistgRoot->DestroyElement(szStorage);   
            return hr;
        }
    }

    if (!DynArrayValid (&m_dlObjList))
        // This allocates a dynamic array that can hold a
        // MAXIMUM of 1000 objects
        if (FALSE == DynArrayInit (&m_dlObjList,
            sizeof (OBJENTRY) * 20, 50, sizeof (OBJENTRY), 0))
            return SetErrReturn(E_OUTOFMEMORY);

    // Create object node
    // TODO: Check for duplicate entries!
    POBJENTRY pObj;
    pObj = (POBJENTRY)DynArrayAppendElt (&m_dlObjList);
    WSTRCPY (pObj->wszObjName, szObjectName);
    pObj->piitbc = pInterface;
    pObj->piistg = pSubStorage;
    pObj->piistm = pStream;
    pObj->wszStorage = new WCHAR [WSTRLEN(szStorage) + 1];
    WSTRCPY(pObj->wszStorage, szStorage);

    return S_OK;
} /* CreateBuildObject */


/***************************************************************
 * @method	HRESULT WINAPI | IITSvMgr | GetBuildObject |
 * Retrieves an object built with CreateBuildObject
 *
 * @parm LPCWSTR | pwstrObjectName | Name of object
 * @parm REFIID | refiid | Identifier for object
 * @parm void | **ppInterface | Indirect interface pointer
 *
 * 
 ***************************************************************/
HRESULT WINAPI CITSvMgr::GetBuildObject
        (LPCWSTR pwstrObjectName, REFIID refiid, void **ppInterface)
{
    if (NULL == pwstrObjectName || NULL == ppInterface)
        return E_INVALIDARG;

    if (!*pwstrObjectName && refiid == IID_IITDatabase)
    {   // Return the database pointer
        (*((IITDatabase **)ppInterface) = m_piitdb)->AddRef();
        return S_OK;
    }

    HRESULT hr = E_NOTEXIST;
    POBJENTRY pEntry;
    for (pEntry = (POBJENTRY)DynArrayGetFirstElt (&m_dlObjList);
        pEntry; pEntry = (POBJENTRY)DynArrayNextElt (&m_dlObjList))
    {
        if (!WSTRCMP(pEntry->wszObjName, pwstrObjectName))
        {
            hr = pEntry->piitbc->QueryInterface(refiid, ppInterface);
            break;
        }
    }

    return hr;
} /* GetBuildObjectInterface */


HRESULT WINAPI CITSvMgr::SetPropDest
    (LPCWSTR szObjectName, LPCWSTR szDestination, IITPropList *pPropList)
{
    if (FALSE == m_fInitialized)
        return SetErrReturn(E_NOTINIT);

    // Remove this once we support prop dest for arbitrary objects
    if (szObjectName != NULL)
        return SetErrReturn(E_NOTIMPL);

    // Handle catalog
    if (szObjectName == NULL)
    {
        DWORD dwSize;

        if (szDestination != NULL)
            return SetErrReturn(E_INVALIDARG);

        if (NULL != m_pCatHeader)
            return SetErrReturn(E_ALREADYINIT);

        pPropList->SetPersist(STDPROP_UID, FALSE);
        pPropList->GetHeaderSize (dwSize);
        if (!dwSize)
            // There are no document properties
            return S_OK;

        m_pCatHeader =
            (LPBYTE)_GLOBALALLOC (GMEM_FIXED, sizeof (DWORD) + dwSize);
        if (NULL == m_pCatHeader)
            return SetErrReturn(E_OUTOFMEMORY);
        *((LPDWORD&)m_pCatHeader) = dwSize;
        pPropList->SaveHeader (m_pCatHeader + sizeof (DWORD), dwSize);

        // Don't permenantly change the persist state 
        pPropList->SetPersist(STDPROP_UID, TRUE);
    }
    return S_OK;
} /* SetPropDest */


HRESULT WINAPI CITSvMgr::CatalogCompleteUpdate (void)
{
    HRESULT hr;
    DWORD dwSize, dwUID, dwOffset, dwLastUID;
    LPSTR pInput = NULL, pCur, pEnd;
	BTREE_PARAMS bp;
    HBT hbt = NULL;
    IStream *pDataStream = NULL;
    IStorage *pStorage = NULL;
    LPSTR pBin = NULL;

    if (NULL == m_pCatHeader || !*m_szCatFile)
        return S_OK;

    CloseHandle (m_hCatFile);
    m_hCatFile = NULL;

    // Create sub-storage
    if (FAILED (hr = m_piistgRoot->CreateStorage
        (SZ_CATALOG_STORAGE, STGM_READWRITE, 0, 0, &pStorage)))
    {
        SetErrCode(&hr, E_FAIL);
exit0:
        // Release everything
        if (pBin)
            delete pBin;
        if (pStorage)
            pStorage->Release();
        if (pDataStream)
            pDataStream->Release();
        if (pInput)
            UnmapViewOfFile (pInput);
        if (hbt)
            RcAbandonHbt(hbt);
        DeleteFile (m_szCatFile);
        _GLOBALFREE ((HANDLE)m_pCatHeader);
        m_pCatHeader = NULL;
        *m_szCatFile = '\0';
        return hr;
    }

    // Create Data Stream
    hr = pStorage->CreateStream
        (SZ_BTREE_DATA, STGM_WRITE, 0, 0, &pDataStream);
    if (FAILED(hr))
        goto exit0;

    if (S_OK !=(hr = FileSort
        (NULL, (LPB)m_szCatFile, NULL, NULL, 0, NULL, NULL, NULL, NULL)))
    {
        SetErrCode(&hr, E_FAIL);
        goto exit0;
    }

	bp.hfs = pStorage;
	bp.cbBlock = 2048;
	bp.bFlags = fFSReadWrite;

	bp.rgchFormat[0] = KT_LONG; // UID
	bp.rgchFormat[1] = '4'; // OFFSET
	bp.rgchFormat[2] = '\0';

    // Create BTREE
    hbt = HbtInitFill(SZ_BTREE_BTREE_A, &bp, &hr);
	if (hbt == hNil)
        goto exit0;

    pBin = new char[m_dwMaxPropSize];

    // Map the temp file to memory
    pInput = MapSequentialReadFile(m_szCatFile, &dwSize);
    if (NULL == pInput)
    {
        SetErrCode(&hr, E_FAIL);
        goto exit0;
    }
    pCur = pInput;
    pEnd = pInput + dwSize;
    dwOffset = 0;
    dwLastUID = 0xFFFFFFFF;

    while (pEnd != pCur)
    {
        char chTemp[9], *pchend;
        chTemp[8] = '\0';

        // Read in the record
        MEMCPY (chTemp, pCur, 8);
        dwUID = strtol(chTemp, &pchend, 16);
        pCur += 8;

        pCur = StringToLong (pCur, &dwSize) + 1;
        BinFromHex (pCur, pBin, dwSize);
        pCur += dwSize + 2;
        dwSize /= 2;

        if (dwUID != dwLastUID)
        {
		    if (FAILED (hr = RcFillHbt(hbt,(KEY)&dwUID,(QV)&dwOffset)))
            {
                delete pBin;
                goto exit0;
            }

            hr = pDataStream->Write (&dwSize, sizeof (DWORD), NULL);
            if (FAILED(hr))
                goto exit0;
            if (FAILED (hr = pDataStream->Write (pBin, dwSize, NULL)))
                goto exit0;
            dwLastUID = dwUID;
        }
        else
        {   // What to do with duplicates?
            // For now, we skip them
        }

        dwOffset += dwSize + sizeof (DWORD);
    }

	hr = RcFiniFillHbt(hbt);
    if (FAILED(hr))
        goto exit0;
	if (S_OK !=(hr = RcCloseBtreeHbt(hbt)))
		goto exit0;
    hbt = NULL;

    // Create and write header
    IStream *pStream;
    hr = pStorage->CreateStream (SZ_BTREE_HEADER, STGM_WRITE, 0, 0, &pStream);
    if (FAILED(hr))
        goto exit0;

    hr = pStream->Write (m_pCatHeader, sizeof (DWORD), NULL);
    if (FAILED (hr))
    {
        pStream->Release();
        goto exit0;
    }

    hr = pStream->Write (m_pCatHeader + sizeof (DWORD),
        *((LPDWORD&)m_pCatHeader), NULL);
    pStream->Release();
    if (FAILED (hr))
        goto exit0;

    hr = S_OK;
    goto exit0;
} /* CatalogCompleteUpdate */


HRESULT WINAPI CITSvMgr::CatalogSetEntry (IITPropList *pPropList, DWORD dwFlags)
{
    HRESULT hr;
    DWORD dwUID, dwTemp, dwDataSize;
    CProperty CProp;
    char szTemp[1025];

    if (FAILED(hr = pPropList->Get(STDPROP_UID, CProp)))
        return SetErrReturn(E_MISSINGPROP);

    // This could be a pointer to a UID or a DWORD UID
    if (TYPE_VALUE == CProp.dwType)
        dwUID = CProp.dwValue;
    else if (TYPE_POINTER == CProp.dwType)
        dwUID = *((LPDWORD&)CProp.lpvData);

    // Allocate memory if we need to
    if (NULL == m_pCatHeader)
    {
        pPropList->SetPersist(STDPROP_UID, FALSE);
        pPropList->GetHeaderSize (dwTemp);
        if (!dwTemp)
            // There are no document properties
            return S_OK;

        m_pCatHeader =
            (LPBYTE)_GLOBALALLOC (GMEM_FIXED, sizeof (DWORD) + dwTemp);
        if (NULL == m_pCatHeader)
            return SetErrReturn(E_OUTOFMEMORY);
        *((LPDWORD&)m_pCatHeader) = dwTemp;
        pPropList->SaveHeader (m_pCatHeader + sizeof (DWORD), dwTemp);

        // Don't permenantly change the persist state 
        pPropList->SetPersist(STDPROP_UID, TRUE);
    }

    hr = pPropList->GetDataSize (m_pCatHeader + sizeof (DWORD),
        *((LPDWORD&)m_pCatHeader), dwDataSize);
    // Returns S_FALSE if no records to write (still writes empty bit flags)
    if (S_FALSE == hr || !dwDataSize)
        return S_OK;

    if ('\0' == *m_szCatFile)
    {
        // Create the temp file
        char szTempPath[_MAX_PATH + 1];

        if (0 == GetTempPath(_MAX_PATH, szTempPath))
            return SetErrReturn(E_FILECREATE);
        if (0 == GetTempFileName(szTempPath, "CAT", 0, m_szCatFile))
            return SetErrReturn(E_FILECREATE);
        m_hCatFile = CreateFile
           (m_szCatFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,
            FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
        if (INVALID_HANDLE_VALUE == m_hCatFile)
            return SetErrReturn(E_FILECREATE);
    }

    LPBYTE pData;
    LPSTR  pHex;
    pPropList->GetDataSize (m_pCatHeader + sizeof (DWORD),
        *((LPDWORD&)m_pCatHeader), dwDataSize);
    pData = new BYTE[dwDataSize];
    pHex = new char[dwDataSize * 2];
    if (dwDataSize > m_dwMaxPropSize)
        m_dwMaxPropSize = dwDataSize;
    
    pPropList->SaveData (m_pCatHeader + sizeof (DWORD),
        *((LPDWORD&)m_pCatHeader), pData, dwDataSize);
    HexFromBin (pHex, pData, dwDataSize);

    dwDataSize *= 2;
    wsprintf (szTemp, "%08X%u:", dwUID, dwDataSize);
    WriteFile (m_hCatFile, szTemp, (DWORD) STRLEN (szTemp), &dwTemp, NULL);
    WriteFile (m_hCatFile, pHex, dwDataSize, &dwTemp, NULL);
    WriteFile (m_hCatFile, "\r\n", (DWORD) STRLEN ("\r\n"), &dwTemp, NULL);

    delete pData;
    delete pHex;

    return S_OK;
} /* CatalogSetEntry */


/*******************************************************************
 *
 * @method    HRESULT WINAPI | IITSvMgr | HashString |
 *	    Returns a hashed DWORD value for an input string.  
 *      This method is an optional advanced feature, and is
 *      not necessary to build any object. 
 *
 * @parm LPCWSTR | szKey | String to convert
 * @parm DWORD | *pdwHash | Hashed value of string
 * 
 * @rvalue S_OK | The operation completed successfully.
 *
 * @comm 
 * This method takes a string, and returns a hashed DWORD value.
 * For example, this method allows you to use hashstring values 
 * as UIDs. It provides a unique value based on a title, for example. 
 * 
 * @comm Using the hash value as a UID in groups
 * can cause inefficiencies due to memory considerations 
 * (non-sequential UIDs are more difficult to store). 
 * 
 *
 ********************************************************************/
HRESULT WINAPI CITSvMgr::HashString (LPCWSTR szKey, DWORD *pdwHash)
{
    int ich, cch;
    DWORD hash = 0L;
    const int MAX_CHARS = 43;

    *pdwHash = 0L;
    cch = (int) WSTRLEN (szKey);

    // The following is used to generate a hash value for structured
    // "ascii hex" context strings.  If a title's context strings use
    // the format "0xHHHHHHHH", where H is a valid hex digit, then
    // this algorithm replaces the standard hash algorithm.  This is so
    // title's can determined a context string from a given hash value.

    if ( szKey[0] == L'0' && szKey[1] == L'x' && (cch == 10) )
    {
        WCHAR c;

        for( ich = 0; ich < cch; ++ich )
        {
            c = szKey[ich];
            hash <<= 4;
            hash += (c & 0x10 ? c : (c + 9)) & 0x0f;
        }

        *pdwHash = hash;
        return S_OK;
    }
 
    for ( ich = 0; ich < cch; ++ich )
    {
        if ( szKey[ich] == L'!' )
            hash = (hash * MAX_CHARS) + 11;
        else if ( szKey[ich] == L'.' )
            hash = (hash * MAX_CHARS) + 12;
        else if ( szKey[ich] == L'_' )
            hash = (hash * MAX_CHARS) + 13;
        else if ( szKey[ich] == L'0' )
            hash = (hash * MAX_CHARS) + 10;
        else if ( szKey[ich] <= L'Z' )
            hash = (hash * MAX_CHARS) + ( szKey[ich] - L'0' );
        else
            hash = (hash * MAX_CHARS) + ( szKey[ich] - 'L0' - (L'a' - L'A') );
    }

    /* Since the value hashNil is reserved as a nil value, if any context
     * string actually hashes to this value, we just move it.
     */
    *pdwHash = (hash == hashNil ? hashNil + 1 : hash);
    return S_OK;
} /* CITSvMgr::HashString */


HRESULT WINAPI CITSvMgr::LogMessage(DWORD dwResourceId, ...)
{
    if (!m_fInitialized || !m_piistmLog)
        return S_FALSE;

    char rgchLocalBuf[1024];
    char rgchFormatBuf[1024];
    if (LoadString (_hInstITCC, dwResourceId, 
        rgchFormatBuf, 1024 * sizeof (char)))
    {
        va_list vl;

        va_start(vl, dwResourceId);
        int arg1 = va_arg(vl, int);
        int arg2 = va_arg(vl, int);
        int arg3 = va_arg(vl, int);
        va_end(vl);

        wsprintf (rgchLocalBuf, rgchFormatBuf, arg1, arg2, arg3);
    }
    else
        STRCPY(rgchLocalBuf, "Error string could not be loaded from resource file.");

    m_piistmLog->Write(rgchLocalBuf, (DWORD) STRLEN (rgchLocalBuf), NULL);
    m_piistmLog->Write (".\r\n", (DWORD) STRLEN (".\r\n"), NULL);

    return S_OK;
} /* LogMessage */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\svutil.cpp ===
// SVUTIL.CPP

#include <windows.h>
#include <objidl.h>
#include <mvopsys.h>

// ***************************************************************************
BOOL WINAPI StreamGetLine
    (IStream *pStream, LPWSTR lpstrDest, int *cch, int iReceptacleSize)
{
    LPWSTR pDest;
    int fRet = FALSE;
    ULONG ulRead;

    if (NULL == pStream)
        return FALSE;

    pDest = lpstrDest;

    /********************
    STRING RETRIEVAL LOOP
    *********************/
    iReceptacleSize--; // save room for 0
    for (;;iReceptacleSize--)
    {
        if (FAILED (pStream->Read (pDest, sizeof (WCHAR), &ulRead)) || !ulRead)
            break;
        if (*pDest == L'\r')
            continue;
		if (*pDest == L'\n')
        {
            fRet = TRUE;
			break;
        }
        pDest++;
    }
    *pDest++ = L'\0';
    if(cch)
        *cch = (int)(pDest - lpstrDest);
    return fRet;
}   /* StreamGetLine */


// ***************************************************************************
BOOL StreamGetLineASCII
    (IStream *pStream, LPWSTR lpstrDest, int *cch, int iReceptacleSize)
{
    LPSTR pDest;
    int fRet = FALSE;
    ULONG ulRead;
    char rgchLocal[8192]={0};

    if (NULL == pStream)
        return FALSE;

    pDest = rgchLocal;

    /********************
    STRING RETRIEVAL LOOP
    *********************/
    iReceptacleSize--; // save room for 0
    for (;;iReceptacleSize--)
    {
        if (FAILED (pStream->Read (pDest, sizeof (CHAR), &ulRead)) || !ulRead)
            break;
        if (*pDest == '\r')
            continue;
		if (*pDest == '\n')
        {
            fRet = TRUE;
			break;
        }
        pDest++;
    }
    *pDest = '\0';
    int iSize = MultiByteToWideChar (CP_ACP, 0, rgchLocal, -1, lpstrDest, 8192);

    if(cch)
        *cch = iSize;

    return fRet;
}   /* StreamGetLine */


// ***************************************************************************
DWORD BinFromHex(LPSTR lpszHex, LPSTR lpbData, DWORD dwSize)
{
    char *pchend, chBuf[3];
    LPSTR lpbStart = lpbData;

    chBuf[2] = 0;

    if (dwSize &(DWORD)0x01)
    {
        chBuf[0] = '0';
        chBuf[1] = *lpszHex++;
        *lpbData++ =(char)strtol(chBuf, &pchend, 16);
        --dwSize;
    }
    
    for (dwSize /= 2;dwSize; dwSize--)
    {
        chBuf[0] = *lpszHex++;
        chBuf[1] = *lpszHex++;

        *lpbData++ =(BYTE)strtol(chBuf, &pchend, 16);
    }

    return (DWORD)(lpbData - lpbStart);
} /* BinFromHex */


/********************************************************************
 * @method    DWORD | HexFromBin
 * Takes a pointer to binary data and writes it to a buuffer in ASCII
 * hex notation.
 *
 * @comm
 ********************************************************************/

DWORD HexFromBin(LPSTR lpszHex, LPBYTE lpbData, DWORD dwSize)
{
	LPBYTE lpb, lpbMax;
	BYTE ch;

	// for each byte, write the hex equivalent
	for (lpb = lpbData, lpbMax = lpbData + dwSize; lpb < lpbMax;lpb++)
	{
		const char hex[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
		ch = *lpb;
		*lpszHex++ = hex[ch >> 4];
		*lpszHex++ = hex[ch & 0xf];
	}
	return dwSize;
} /* Hex FromBin */


/*************************************************************************
 *  @doc    INTERNAL
 *
 *  @func   LPSTR PASCAL NEAR | StringToLong |
 *      The function reads in a string of digits and convert them into
 *      a DWORD. The function will move the input pointer correspondingly
 *
 *  @parm   LPCSTR | lszBuf |
 *      Input buffer containing the string of digit with no sign
 *
 *  @parm   LPDW  | lpValue |
 *      Pointer to a DWORD that receives the result
 *
 *  @rdesc  NULL, if there is no digit, else the new position of the input
 *      buffer pointer
 *************************************************************************/
LPSTR WINAPI StringToLong(LPCSTR lszBuf, LPDWORD lpValue)
{
    register DWORD Result;  // Returned result
    register int i;         // Scratch variable
    char fGetDigit;         // Flag to mark we do get a digit

    /* Skip all blanks, tabs */
    while (*lszBuf == ' ' || *lszBuf == '\t')
        lszBuf++;

    Result = fGetDigit = 0;

    if (*lszBuf >= '0' && *lszBuf <= '9')
    {
        fGetDigit = TRUE;

        /* The credit of this piece of code goes to Leon */
        while (i = *lszBuf - '0', i >= 0 && i <= 9)
        {
            Result = Result * 10 + i;
            lszBuf++;
        }
    }
    *lpValue = Result;
    return(fGetDigit ? (LPSTR)lszBuf : NULL);
} /* StringToLong */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\cmdint\cistream.h ===
#ifndef __CISTREAM_H_ // {
#define  __CISTREAM_H_

#include <windows.h>
#include <objbase.h>

#define MAX_MVP_LINE_BYTES  1024

class CStreamParseLine
{
public:
    CStreamParseLine (void);
    ~CStreamParseLine() {Close();}

    STDMETHOD(SetStream)(IStream *pistm);
    STDMETHOD(GetLogicalLine)(LPWSTR *ppwstrLineBuffer, int *iLineCount);
    STDMETHOD(Reset)(void);
    STDMETHOD(Close)(void);

private:
    IStream *m_pistmInput;
    WCHAR m_wstrLine[MAX_MVP_LINE_BYTES];
    BOOL m_fASCII;
    LARGE_INTEGER m_liStartOffset;
    LARGE_INTEGER m_liNull;
};

#endif //  } __CISTREAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\cmdint\cistream.cpp ===
#include <mvopsys.h>

// Global debug variable
#ifdef _DEBUG
static char s_aszModule[] = __FILE__;
#endif

#include <windows.h>
#include <iterror.h>

#include "cistream.h"
#include "orkin.h"
#include "..\svutil.h"
#include "ciutil.h"


CStreamParseLine::CStreamParseLine(void)
{
    MEMSET(&m_liNull, 0, sizeof(LARGE_INTEGER));
    m_pistmInput = NULL;
#ifdef _DEBUG
    MEMSET(m_wstrLine, 0, sizeof(m_wstrLine));
#endif
} // Constructor


STDMETHODIMP CStreamParseLine::Reset(void)
{
    return m_pistmInput->Seek(m_liStartOffset, STREAM_SEEK_SET, NULL);
} // Reset


STDMETHODIMP CStreamParseLine::SetStream(IStream *pistm)
{
    if (NULL == pistm)
        return E_POINTER;
    (m_pistmInput = pistm)->AddRef();

    // Make sure this stream is Unicode
    ULARGE_INTEGER uliStartOffset;
    pistm->Seek(m_liNull, STREAM_SEEK_CUR, &uliStartOffset);

    WORD wUnicodeWord;
    HRESULT hr;
    if (SUCCEEDED(hr = pistm->Read (&wUnicodeWord, sizeof (WORD), NULL)))
    {
        if (wUnicodeWord == 0xFEFF)
            m_fASCII = FALSE;
        else if (wUnicodeWord == 0xFFEF)
            // This requires byte swapping on INTEL
            SetErrCode(&hr, E_NOTIMPL);
        else
        {
            LARGE_INTEGER liTemp;
            liTemp.QuadPart = uliStartOffset.QuadPart;
            pistm->Seek (liTemp, STREAM_SEEK_SET, NULL);
            m_fASCII = TRUE;
        }
    }

    pistm->Seek(m_liNull, STREAM_SEEK_CUR, &uliStartOffset);
    m_liStartOffset.QuadPart = uliStartOffset.QuadPart;
    return hr;
} // SetStream


STDMETHODIMP CStreamParseLine::Close(void)
{
    if (m_pistmInput)
    {
        m_pistmInput->Release();
        m_pistmInput = NULL;
    }
    return S_OK;
} // Close


STDMETHODIMP CStreamParseLine::GetLogicalLine
    (LPWSTR *ppwstrLineBuffer, int *piLineCount)
{
    ITASSERT(ppwstrLineBuffer);

    LPWSTR pwstrCurrent;
    BOOL fGotLine, fIgnore = FALSE;
    BOOL fCommentStrippingOn = TRUE;
    BOOL fCommentedLine;
    int iQuoteNesting = 0;
    int iParenNesting = 0;
    int iLineCount = 0;

    for (;;)
    {
        iLineCount += 1;
        fCommentedLine = FALSE;
        if (m_fASCII)
            fGotLine = StreamGetLineASCII (m_pistmInput,
                m_wstrLine, NULL, MAX_MVP_LINE_BYTES * sizeof(WCHAR));
        else
            fGotLine = StreamGetLine (m_pistmInput,
                m_wstrLine, NULL, MAX_MVP_LINE_BYTES * sizeof(WCHAR));
        if (fGotLine)
        {
            StripLeadingBlanks(StripTrailingBlanks(m_wstrLine));

            if (!fIgnore)
            {
                /********************************
                SCAN THROUGH LOOKING FOR COMMENTS
                (AND NULLING THEM OUT)
                *********************************/
                pwstrCurrent = m_wstrLine;

                while (*pwstrCurrent) {                  
                    switch (*pwstrCurrent) {
                        case '(':
                            ++iParenNesting;
                            fCommentStrippingOn=FALSE;
                            ++pwstrCurrent;
                            break;

                        case ')':                         
                            if ((iParenNesting == 1) && (iQuoteNesting == 0))
                                fCommentStrippingOn=TRUE;
                            if (iParenNesting > 0)
                                --iParenNesting;                                 
                            ++pwstrCurrent;
                            break;

                        case '"':
                            if (iQuoteNesting==0)   {
                                iQuoteNesting=1;
                                fCommentStrippingOn=FALSE;
                            }
                            else
                                iQuoteNesting=0;

                            if ((iQuoteNesting==0) && (iParenNesting == 0))
                                fCommentStrippingOn=TRUE;

                            ++pwstrCurrent;
                            break;

                        case '\\':
                            if (*(pwstrCurrent+1) == ';') {
                                // slash escapes comment character!
                                *pwstrCurrent=' '; // just put a space in the buffer!
                                pwstrCurrent+=2;   // increment past ';'
                            }
                            else ++pwstrCurrent;
                            break;

                        case ';':
                            if (fCommentStrippingOn)
                            {
                                *pwstrCurrent='\0';
                                fCommentedLine = TRUE;
                            }
                            else
                                ++pwstrCurrent;
                            break;

                        default:
                            ++pwstrCurrent;
                            break;
                    }
                }
            }

            StripTrailingBlanks(m_wstrLine);
            if (*m_wstrLine)
            {
                if (!WSTRICMP (m_wstrLine, L"#IGNORE"))
                    fIgnore = TRUE;
                else if (!WSTRICMP (m_wstrLine, L"#ENDIGNORE"))
                    fIgnore = FALSE;
                else if (!fIgnore)
                {
                    *ppwstrLineBuffer = m_wstrLine;
                    if (piLineCount)
                        *piLineCount = iLineCount;
                    return (S_OK);
                }
            }
        }
        else
        {
            if (piLineCount)
                *piLineCount = iLineCount;
            return (S_FALSE);
        }
    }
} // GetLogicalLine
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\cmdint\cierror.h ===
//
// CIERROR.H
//

/*
*   xxx0, xxx5 - errors
*   xxx1, xxx6 - level 1 warnings
*   xxx2, xxx7 - level 2 warnings
*   xxx3, xxx8 - level 3 warnings
*   xxx4, xxx9, x000 - fatal errors
*/

#define CIERR_StringTruncate            1023    // Warning 3
#define CIERR_DefaultExtension          1091    // Warning 1
#define CIERR_NoPermission              1100    // Error
#define CIERR_IOFailure                 1651    // Warning 1
#define CIERR_SectionHeadMissing        2111    // Warning 1
#define CIERR_BadOptionSyntax           2131    // Warning 1
#define CIERR_MissingRHS                2151    // Warning 1
#define CIERR_SectionHeadingSyntax      2161    // Warning 1
#define CIERR_InvalidEntry              2162    // Warning 2
#define CIERR_UnknownSectionName        2191    // Warning 1
#define CIERR_SectionsOutOfOrder        2287    // Warning 2
#define CIERR_SectionDuplicated         2291    // Warning 1
#define CIERR_ChineseNotSupported       2412    // Warning 1
#define CIERR_UnknownOptionType         2511    // Warning 1
#define CIERR_OptionRedefined           2532    // Warning 2
#define CIERR_InvalidPathName           2550    // Error
#define CIERR_RootNameTooLong           2570    // Error
#define CIERR_MissingEqualInKeyword     2701    // Warning 1
#define CIERR_KeywordSyntax             2711    // Warning 1
#define CIERR_KeywordTitleSpec          2721    // Warning 1
#define CIERR_BadKeywordSpecifier       2741    // Warning 1
#define CIERR_KeywordSetTitleTooLong    2751    // Warning 1
#define CIERR_InvalidCompressOption     2832    // Warning 2
#define CIERR_TitleTooLong              2852    // Warning 2
#define CIERR_CopyrightTooLong          2932    // Warning 2
#define CIERR_BadBatchOption            2941    // Warning 1
#define CIERR_BadKeepIncOption          2951    // Warning 1
#define CIERR_BadUseMakeOption          2971    // Warning 1
#define CIERR_BadSortOption             2976    // Warning 1
#define CIERR_BadWarningLevel           2983    // Warning 3
#define CIERR_LanguageTooLong           2993    // Warning 3
#define CIERR_IgnoreFirst               5002    // Warning 2
#define CIERR_UnknownCompression        5003    // Warning 3
#define CIERR_OOMErr                    5059    // Fatal Error
#define CIERR_MissingEqualInWWheel      6211    // Warning 1
#define CIERR_BadWWheelLHS              6221    // Warning 1
#define CIERR_SubfileNameTooLong        6351    // Warning 1
#define CIERR_GarbageTrailingSubfile    6401    // Warning 1
#define CIERR_BadVFLDSpec               6411    // Warning 1
#define CIERR_StrippingSubfileExt       6421    // Warning 1
#define CIERR_BadGroupSyntax            8001    // Warning 1
#define CIERR_BadGroupRHS               8031    // Warning 1
#define CIERR_BadGroupLineSequence      8061    // Warning 1
#define CIERR_BadBreakerSzLHS           9011    // Warning 1
#define CIERR_MissingEqualInBreakerSZ   9001    // Warning 1
#define CIERR_BreakerIdxOutOfRange      9021    // Warning 1
#define CIERR_DllNameMissingBreakerSz   9031    // Warning 1
#define CIERR_OldCharTabSyntax          9032    // Warning 2
#define CIERR_BangMissingBreakerSz      9041    // Warning 1
#define CIERR_MissingRoutineName        9051    // Warning 1
#define CIERR_BadBreakerSzRHS           9061    // Warning 1
#define CIERR_NotOnOffOption            9302    // Warning 2
#define CIERR_UnknownOption             9303    // Warning 3
#define CIERR_AmbiguousWWGroup          10091   // Warning 1
#define CIERR_SectionObsolete           10101   // Warning 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\cmdint\ciutil.h ===
/*********************************************************
 TITLE: CIUTIL.H

 DATE CREATED: January 16, 1992

 DESCRIPTION:
     This is the header file associated with the utility
     library ciutil.c.  It will contain basic sorts of
     useful tool functions that may be used in lots of
     different places.

**********************************************************/


#ifndef _CIUTIL_H
#define _CIUTIL_H

/*======================================================================*/

/*******
INCLUDES
********/
#include <windows.h>
#include "cmdint.h"


LPWSTR WINAPI SkipWhitespace(LPWSTR pch);
int WINAPI ReportError (IStream *piistm, ERRC &errc);

LPWSTR WINAPI StripTrailingBlanks(LPWSTR);
VOID WINAPI StripLeadingBlanks(LPWSTR pchSource);

BOOL WINAPI IsStringOfDigits(char *szNumericString);
LONG WINAPI StrToLong (LPWSTR lszBuf);   

LPWSTR GetNextDelimiter(LPWSTR pwstrStart, WCHAR wcDelimiter);
HRESULT ParseKeyAndValue(LPVOID pBlockMgr, LPWSTR pwstrLine, KEYVAL **ppkvOut);

#endif /* _CIUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\svmgr\cmdint\cimain.cpp ===
/************************************************************************
 *  @doc   SHROOM EXTERNAL API
 *
 *	TITLE: CIMAIN.CPP
 *
 *	OWNER: johnrush (John C. Rush)
 *
 *	DATE CREATED: January 29, 1997
 *
 *	DESCRIPTION:
 *		This is the main file for the Command Interpreter.
 *
 *********************************************************************/
#include <mvopsys.h>

// Global debug variable
#ifdef _DEBUG
static char s_aszModule[] = __FILE__;
#endif

// Include Files
#include <windows.h>

#include <orkin.h>
#include <common.h>
#include <itdb.h>

#include "cmdint.h"
#include "ciutil.h"
#include "cierror.h"

CITCmdInt::~CITCmdInt ()
{
    Dispose();
}

/************************************************************************
 *  @method   HRESULT WINAPI | IITCmdInt | Initiate |
 *	Initializes the command interpreter.  Should be called before any other
 *  methods for this class.
 *
 *  @parm IITSvMgr | *piitsv | Pointer to the instance of the service manager. 
 *
 *  @rvalue E_OUTOFMEMORY | Resources for command interpreter couldn't be allocated.
 *  @rvalue S_OK | Command interpreter was successfull initialized
 *
 *  @xref <om.Dispose>
 ************************************************************************/
HRESULT WINAPI CITCmdInt::Initiate (IITSvMgr *piitsv)
{
    if (m_fInit)
        return E_ALREADYINIT;

    HRESULT hr;
    (m_piitsv = piitsv)->AddRef();
    if (SUCCEEDED(hr = piitsv->GetBuildObject 
        (L"", IID_IITDatabase, (void **)&m_piitdb))
        &&
        SUCCEEDED(hr = (NULL == (m_pBlockMgr =
            BlockInitiate ((DWORD)65500, 0, 0, 0)) ? E_OUTOFMEMORY : S_OK))
       )
    {
        MEMSET(m_wstrHelper, 0, sizeof(m_wstrHelper));
        m_dwMaxInstance = 0;
        m_fInit = TRUE;
    }
    return hr;
} /* CITCmdInt::Initiate */


/************************************************************************
 *  @method   HRESULT WINAPI | IITCmdInt | Dispose |
 *	Frees any resources allocated by the command interpreter.  Should be 
 *  the last method called.
 *
 *
 *  @rvalue S_OK | All resources were freed successfully
 *
 *  @xref <om.Initiate>
 ************************************************************************/
HRESULT WINAPI CITCmdInt::Dispose (void)
{
    if (FALSE == m_fInit)
        return E_NOTINIT;

    m_piitsv->Release();
    m_piitdb->Release();
    BlockFree(m_pBlockMgr);
    m_fInit = FALSE;
    return S_OK;
} /* CITCmdInt::Dispose */


/************************************************************************
 *  @method   HRESULT WINAPI | IITCmdInt | LoadFromStream |
 *	Loads and parses the build configuration information from the given input
 *  stream.  
 *
 *  @rvalue S_OK | The configuration stream was loaded successfully
 *  @rvalue E_OUTOFMEMORY | Not enough memory was available to parse the stream
 *  @rvalue Other | Another I/O condition prevents the processing of the stream
 *
 *  @xref <om.Initiate>
 *
 *  @comm During the parsing of the stream, various warnings may occur as a result
 *  of authoring error, and these are written to the log file.  In this case, the
 *  method still returns S_OK if none of the errors was fatal.
 ************************************************************************/
HRESULT WINAPI CITCmdInt::LoadFromStream
    (IStream *pStream,  //@parm Pointer to the input <p IStream>
	IStream *pLogStream) //@parm Pointer to the log stream <p IStream>
{
    HRESULT hr;

    if (FALSE == m_fInit)
        return E_NOTINIT;

    m_piistmLog = pLogStream;

    m_errc.iLine = 0;
    m_errc.ep = epLine;
    m_ConfigParser.SetStream(pStream);

    hr = ParseConfigStream();
    m_piistmLog = NULL;

    return hr;
} /* CITCmdInt::LoadFromStream */

HRESULT WINAPI CITCmdInt::ParseBogusSz(LPWSTR)
{
    return S_OK;
}

HRESULT WINAPI CITCmdInt::ParseIndexSz(LPWSTR wstrLine)
{
    ITASSERT(wstrLine);

    KEYVAL *pKeyValue;
    HRESULT hr = ParseKeyAndValue(m_pBlockMgr, wstrLine, &pKeyValue);
    if (FAILED(hr))
        return hr;

    // Verify the format
    if (!pKeyValue->vaValue.dwArgc)
        // TODO: Issue warning message
        return E_INVALIDARG;

    CLSID clsid;
    hr = CLSIDFromProgID((LPCWSTR)pKeyValue->vaValue.Argv[0], &clsid);
    IITBuildCollect *pInterface = NULL;

    if (SUCCEEDED(hr) && SUCCEEDED
        (hr = m_piitsv->CreateBuildObject(pKeyValue->pwstrKey, clsid)))
    {
        if(FAILED(hr = m_piitsv->GetBuildObject
            (pKeyValue->pwstrKey, IID_IITBuildCollect, (void**)&pInterface))) {
                ITASSERT(0);
            }
    }

    if(SUCCEEDED(hr))
    {
        // Skip the first 2 (required params)
        DWORD dwArgc = pKeyValue->vaValue.dwArgc;
        if((int)(dwArgc -= 2) < 0)
            dwArgc = 0;
        VARARG vaNew = {0};
        vaNew.dwArgc = dwArgc;
        LPWSTR *ppwstr = (LPWSTR *)pKeyValue->vaValue.Argv + 2;
        for(DWORD loop = 0; loop < dwArgc; ++loop, ++ppwstr)
        {
            *(vaNew.Argv + loop) = *ppwstr;
        }
        hr = pInterface->SetConfigInfo(m_piitdb, vaNew);
    }

    if(SUCCEEDED(hr) && (LPWSTR)pKeyValue->vaValue.Argv[1]
        && *(LPWSTR)pKeyValue->vaValue.Argv[1])
    {
        for(DWORD loop = 0; loop <= m_dwMaxInstance; ++loop)
        {
            if((m_wstrHelper + loop)->pwstrName &&
                !WSTRCMP ((m_wstrHelper+loop)->pwstrName,
                (LPWSTR)pKeyValue->vaValue.Argv[1]))
            {
                tagHELPERSTUFF *pInfo = (m_wstrHelper + loop);

                hr = pInterface->InitHelperInstance
                    (loop, m_piitdb, pInfo->dwCodePage, pInfo->lcid,
                    pInfo->kvDword, pInfo->kvString);
                break;
            }
        }
    }

    if(pInterface)
        pInterface->Release();
    return hr;
}


HRESULT WINAPI CITCmdInt::ParseHelperSz(LPWSTR wstrLine)
{
    int iLineCount;
    KEYVAL *pKeyValue, *pkvDword, *pkvString;
    CLSID clsid;
    DWORD dwCodePage;
    LCID lcid;

    // The +3 skips to 'HO:' prefix
    HRESULT hr = ParseKeyAndValue(m_pBlockMgr, wstrLine, &pKeyValue);
    if (FAILED(hr))
        return hr;

    if (!WSTRICMP(L"VIProgId", pKeyValue->pwstrKey))
    {
        if(pKeyValue->vaValue.dwArgc != 1)
            return SetErrReturn(E_INVALIDARG);
        hr = CLSIDFromProgID((LPCWSTR)pKeyValue->vaValue.Argv[0], &clsid);
    }
    else hr = E_FAIL;

    if (SUCCEEDED(hr))
    {
        m_ConfigParser.GetLogicalLine(&wstrLine, &iLineCount);
        m_errc.iLine += iLineCount;
        hr = ParseKeyAndValue(m_pBlockMgr, wstrLine, &pKeyValue);
        if (!WSTRICMP(L"CodePage", pKeyValue->pwstrKey))
        {
            if(pKeyValue->vaValue.dwArgc != 1)
                return E_INVALIDARG;
            dwCodePage = _wtol((LPWSTR)pKeyValue->vaValue.Argv[0]);
        }
        else hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        m_ConfigParser.GetLogicalLine(&wstrLine, &iLineCount);
        m_errc.iLine += iLineCount;
        hr = ParseKeyAndValue(m_pBlockMgr, wstrLine, &pKeyValue);
        if (!WSTRICMP(L"Locale", pKeyValue->pwstrKey))
        {
            if(pKeyValue->vaValue.dwArgc != 1)
                return E_INVALIDARG;
            lcid = _wtol((LPWSTR)pKeyValue->vaValue.Argv[0]);
        }
        else hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        m_ConfigParser.GetLogicalLine(&wstrLine, &iLineCount);
        m_errc.iLine += iLineCount;
        hr = ParseKeyAndValue(m_pBlockMgr, wstrLine, &pKeyValue);
        if (SUCCEEDED(hr) && !WSTRICMP(L"DWOR