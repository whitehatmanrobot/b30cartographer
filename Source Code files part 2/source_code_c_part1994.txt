ED( dr ) && dstrExpr.cchString != 0 )
        {
            fCheckRollback = TRUE;
        }
        dr = DRM_SUCCESS;
    }

    if( fCheckRollback )
    {
        DRM_UINT64  u64MachineDateTime;
        TOKEN       token       = {0};

        /* Get machine.datetime */
        dr = GetMachineDatetime( f_pcontextLQ->pLicEval, &u64MachineDateTime );
        if( DRM_FAILED( dr ) )
        {
            /* A failure is unexpected */
            dr = DRM_S_FALSE;
            goto ErrorExit;
        }

        /* Get secstate.OldSaveTime */
        ZEROMEM( &token, SIZEOF( token ) );
        dr = DRM_SST_GetTokenValue( f_pcontextLQ->pLicEval->pcontextSSTLicense,
                                   &g_dstrDRM_LS_OLDSAVETIME_ATTR,
                                   &token );

        if( DRM_FAILED( dr ) )
        {
            /* A failure is unexpected */
            dr = DRM_S_FALSE;
            goto ErrorExit;
        }

        if( f_pcontextLQ->pLicEval->fLicenseIsXMR && dr == DRM_S_FALSE )
        {
            /* Should always be able to get a value for XMR licenses */
            dr = DRM_S_FALSE;
            goto ErrorExit;
        }

        /*
        ** For XML licenses, though, we might not get a value
        ** So, only check the actual rollback state if we got a value
        */
        if ( dr == DRM_SUCCESS )
        {
            if( token.TokenType != TOKEN_DATETIME )
            {
                /* Should always get a datetime value */
                dr = DRM_S_FALSE;
                goto ErrorExit;
            }

            /* if ( u64MachineDateTime < token.val.u64DateTime */
            if ( DRM_UI64Les( u64MachineDateTime,
                              token.val.u64DateTime ) )
            {
                /* Rollback state - Disable license */
                dr = DRM_S_FALSE;
                goto ErrorExit;
            }
        }
    }
#endif /* DRM_SUPPORT_ANTIROLLBACK_CLOCK */

    /* First retrieve end expiry date.  */
    if( _GetSecStateAttr( f_pcontextSST, &g_dstrDRM_LS_ENDDATE_ATTR, NULL, &f_plicenseInfo->endDate ) != DRM_SUCCESS )
    {
        if( f_pcontextLQ->fCurrentLicenseIsXML )
        {
            ( void )DRM_ASD_ParseV2License( f_pdstrLicense, &g_dstrDRM_LS_ENDDATE_ATTR, NULL, &f_plicenseInfo->endDate );
        }
        else if( XMR_IS_EXPIRATION_VALID( &f_pcontextLQ->licXMR )
              && f_pcontextLQ->licXMR.containerOuter.containerGlobalPolicies.Expiration.dwEndDate != XMR_UNLIMITED )
        {
            CREATE_FILE_TIME( f_pcontextLQ->licXMR.containerOuter.containerGlobalPolicies.Expiration.dwEndDate, f_plicenseInfo->endDate );
        }
    }

    if( _IsExpired( f_pcontextLQ->pBBContext->pOEMContext, &f_plicenseInfo->endDate ) )
    {
        f_plicenseInfo->dwCategory = LIC_TYPE_IGNORE;
        goto ErrorExit;
    }

    /* Next retrieve begin expiry date.     */
    if( _GetSecStateAttr( f_pcontextSST, &g_dstrDRM_LS_BEGDATE_ATTR, NULL, &f_plicenseInfo->begDate ) != DRM_SUCCESS )
    {
        if( f_pcontextLQ->fCurrentLicenseIsXML )
        {
            ( void )DRM_ASD_ParseV2License( f_pdstrLicense, &g_dstrDRM_LS_BEGDATE_ATTR, NULL, &f_plicenseInfo->begDate );
        }
        else if( XMR_IS_EXPIRATION_VALID( &f_pcontextLQ->licXMR )
              && f_pcontextLQ->licXMR.containerOuter.containerGlobalPolicies.Expiration.dwBeginDate != 0 )
        {
            CREATE_FILE_TIME( f_pcontextLQ->licXMR.containerOuter.containerGlobalPolicies.Expiration.dwBeginDate, f_plicenseInfo->begDate );
        }
    }

    /*
    ** Next retrieve expiration after first use. For this type of license,
    ** we will not do parsing for XML. We expect the data to be in secure store.
    ** For XMR, we have to parse.
    */
    if( ( _GetSecStateAttr( f_pcontextSST,
                           &g_dstrDRM_LS_EXPIRATION_AFTER_FIRSTUSE_ATTR,
                           &f_plicenseInfo->dwHours, NULL ) == DRM_SUCCESS )
     || ( !f_pcontextLQ->fCurrentLicenseIsXML
       && XMR_IS_EXPIRATION_AFTER_FIRST_USE_VALID(&f_pcontextLQ->licXMR) ) )
    {
        DRMFILETIME ft;

        if( !f_pcontextLQ->fCurrentLicenseIsXML
          && XMR_IS_EXPIRATION_AFTER_FIRST_USE_VALID(&f_pcontextLQ->licXMR) )
        {
            f_plicenseInfo->dwHours = f_pcontextLQ->licXMR.containerOuter.containerGlobalPolicies.ExpirationAfterUse.dwValue / ( 60 * 60 );
        }
        
        /*
        ** It is expiration after first use type of license.
        ** See if FirstUseDate is available in secure store. If it is, it is activated.
        ** If it does not exist, then it is not enabled yet.
        */
        if( _GetSecStateAttr( f_pcontextSST, &g_dstrDRM_LS_FIRSTUSE_ATTR, NULL, &ft ) == DRM_SUCCESS )
        {
            DRM_UINT64 u64;

            FILETIME_TO_UI64( ft, u64 );

            /*
            ** It is enabled. Treat the license has expiring license.
            ** Compute the expiry date according to hours allowed by the license.
            */
            f_plicenseInfo->dwCategory = LIC_TYPE_EXPIRY;
            if( !f_pcontextLQ->fCurrentLicenseIsXML
              && XMR_IS_EXPIRATION_AFTER_FIRST_USE_VALID(&f_pcontextLQ->licXMR) )
            {
                /* XMR license is in seconds, use the value directly to get a more accurate date */
                u64 = DRM_UI64Add( DRM_UI64Mul( DRM_UI64( 10000000 ),
                                                DRM_UI64( f_pcontextLQ->licXMR.containerOuter.containerGlobalPolicies.ExpirationAfterUse.dwValue ) ),
                                   u64 );
            }
            else
            {
                /* XML license is in hours */
                u64 = DRM_UI64Add( DRM_UI64Mul( DRM_UI64( 10000000 ),
                                                DRM_UI64( 60 * 60 * f_plicenseInfo->dwHours ) ),
                                   u64 );
            }
            UI64_TO_FILETIME( u64, ft );

            /* Set the expiry as min of this and the any end expiry specified in license. */
            if( DRM_UTL_DateLessThan( &ft, &f_plicenseInfo->endDate ) )
            {
                f_plicenseInfo->endDate = ft;
            }
        }
#if DRM_BACKUP_RESTORE_SUPPORT
        else if( DRM_UTL_DSTRStringsEqual( f_pdstrAction, &g_dstrWMDRM_RIGHT_BACKUP ) )
        {
            /*
            ** Expires after first use just means expires for backup right
            */
            f_plicenseInfo->dwCategory = LIC_TYPE_EXPIRY;
        }
#endif
        else
        {
            /* If it is an expire after first use licenses we should just return
               now so we don't override this type with counts that aren't usable */
            f_plicenseInfo->dwCategory = LIC_TYPE_EXPIRATION_AFTER_FIRST_USE;
            goto ErrorExit;
        }
    }

    if( !f_pcontextLQ->fCurrentLicenseIsXML
       && XMR_IS_EXPIRATION_AFTER_STORE_VALID(&f_pcontextLQ->licXMR) ) 
    {
        DRMFILETIME ft;
        
        if( _GetSecStateAttr( f_pcontextSST, &g_dstrDRM_LS_FIRSTSTORE_ATTR, NULL, &ft ) == DRM_SUCCESS )
        {
            DRM_UINT64 u64;

            FILETIME_TO_UI64( ft, u64 );

            /*
            ** It is enabled. Treat the license has expiring license.
            ** Compute the expiry date according to hours allowed by the license.
            */
            f_plicenseInfo->dwCategory = LIC_TYPE_EXPIRY;
            u64 = DRM_UI64Add( DRM_UI64Mul( DRM_UI64( 10000000 ),
                                            DRM_UI64( f_pcontextLQ->licXMR.containerOuter.containerGlobalPolicies.ExpirationAfterStore.dwValue ) ),
                               u64 );
            UI64_TO_FILETIME( u64, ft );

            /* Set the expiry as min of this and the any end expiry specified in license. */
            if( DRM_UTL_DateLessThan( &ft, &f_plicenseInfo->endDate ) )
            {
                f_plicenseInfo->endDate = ft;
            }
        }
    }
    
    /*
    ** Next retrieve count. If it exists, we should treat it as counted expiry license.
    ** Remaining count is never parsed from the license.
    */
    dr = DRM_S_FALSE;

#if DRM_SUPPORT_PMLICENSE
    /* For Transfer count, the name is TransferCount. Don't use the action word supplied. */
    if( DRM_UTL_DSTRStringsEqual( f_pdstrAction, &g_dstrWMDRM_RIGHT_COPY_TO_SDMI_DEVICE     )
     || DRM_UTL_DSTRStringsEqual( f_pdstrAction, &g_dstrWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE ) )
    {
        pdstrCountString = &g_dstrDRM_LS_TRANSFERCOUNT_ATTR;
    }
    else
#endif
    if( DRM_UTL_DSTRStringsEqual( f_pdstrAction, &g_dstrWMDRM_RIGHT_COPY_TO_CD ) )
    {
        /* wmrm sdk uses BurnToCDCount for this right instead of Print.redbookCount. So special case this too.         */
        pdstrCountString = &g_dstrDRM_LS_BURNTOCDCOUNT_ATTR;
    }
    else if( DRM_UTL_DSTRStringsEqual( f_pdstrAction, &g_dstrWMDRM_RIGHT_PLAYBACK )
          || DRM_UTL_DSTRStringsEqual( f_pdstrAction, &g_dstrWMDRM_RIGHT_COLLABORATIVE_PLAY ) )
    {
        pdstrCountString = &g_dstrDRM_LS_PLAYCOUNT_ATTR;
    }
    else
    {
        if( NO_OF( rgwchCountString ) - g_dstrDRM_LS_COUNT_ATTR.cchString >= f_pdstrAction->cchString
         && NO_OF( rgwchCountString )                                      > g_dstrDRM_LS_COUNT_ATTR.cchString )
        {
            ChkDR( DRM_STR_StringCchCopyNW( rgwchCountString,                            NO_OF(rgwchCountString),                            f_pdstrAction->pwszString,          f_pdstrAction->cchString ) );
            ChkDR( DRM_STR_StringCchCopyNW( rgwchCountString + f_pdstrAction->cchString, NO_OF(rgwchCountString) - f_pdstrAction->cchString, g_dstrDRM_LS_COUNT_ATTR.pwszString, g_dstrDRM_LS_COUNT_ATTR.cchString ) );
            dstrCountString.pwszString = rgwchCountString;
            dstrCountString.cchString  = f_pdstrAction->cchString
                                       + g_dstrDRM_LS_COUNT_ATTR.cchString;
            pdstrCountString           = &dstrCountString;
        }
    }

    if( pdstrCountString != NULL )
    {
        dr = _GetSecStateAttr( f_pcontextSST, pdstrCountString, &f_plicenseInfo->dwCount, NULL);
    }

    if( dr == DRM_SUCCESS)
    {
        /* We got the count. To play safe, make sure the count is non-zero. If zero. ignore this license. */
        if( f_plicenseInfo->dwCount == 0 )
        {
            f_plicenseInfo->dwCategory = LIC_TYPE_IGNORE;
            goto ErrorExit;
        }
        else
        {
            f_plicenseInfo->dwCategory = LIC_TYPE_COUNTED_EXPIRY;
        }
    }

    if( f_plicenseInfo->dwCategory == LIC_TYPE_COUNTED_EXPIRY )
    {
        /* Retrieve the Start Count. */
#if DRM_SUPPORT_PMLICENSE
        /* For Transfer count, the name is TransferCount. Don't use the action word supplied. */
        if( DRM_UTL_DSTRStringsEqual( f_pdstrAction, &g_dstrWMDRM_RIGHT_COPY_TO_SDMI_DEVICE )
         || DRM_UTL_DSTRStringsEqual( f_pdstrAction, &g_dstrWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE ) )
        {
            pdstrCountString = &g_dstrDRM_LS_BEGINTRANSFERCOUNT_ATTR;
        }
        else
#endif
        if( DRM_UTL_DSTRStringsEqual( f_pdstrAction, &g_dstrWMDRM_RIGHT_COPY_TO_CD ) )
        {
            /* WMRM SDK uses BeginBurnToCDCount for this right instead of BeginPrint.redbookCount. So special case this too.         */
            pdstrCountString = &g_dstrDRM_LS_BEGINBURNTOCDCOUNT_ATTR;
        }
        else if( DRM_UTL_DSTRStringsEqual( f_pdstrAction, &g_dstrWMDRM_RIGHT_PLAYBACK ) )
        {
            pdstrCountString = &g_dstrDRM_LS_BEGINPLAYCOUNT_ATTR;
        }
        /* construct a "Begin" + action + "Count" string */
        else
        {
            DRM_DWORD cch = g_dstrDRM_LS_COUNT_ATTR.cchString + g_dstrDRM_LS_BEGIN_ATTR.cchString;

            ChkOverflow( cch, g_dstrDRM_LS_COUNT_ATTR.cchString );

            if( NO_OF( rgwchCountString ) - cch >= f_pdstrAction->cchString
             && NO_OF( rgwchCountString )        > cch )
            {
                /* Begin */
                ChkDR( DRM_STR_StringCchCopyNW(rgwchCountString, NO_OF(rgwchCountString), g_dstrDRM_LS_BEGIN_ATTR.pwszString, g_dstrDRM_LS_BEGIN_ATTR.cchString ) );
                cch = g_dstrDRM_LS_BEGIN_ATTR.cchString;

                /* Action */
                ChkDR( DRM_STR_StringCchCopyNW( rgwchCountString + cch, NO_OF(rgwchCountString) - cch, f_pdstrAction->pwszString, f_pdstrAction->cchString ) );
                cch += f_pdstrAction->cchString;

                /* Count */
                ChkDR( DRM_STR_StringCchCopyNW( rgwchCountString + cch, NO_OF(rgwchCountString) - cch, g_dstrDRM_LS_COUNT_ATTR.pwszString, g_dstrDRM_LS_COUNT_ATTR.cchString ) );
                dstrCountString.pwszString = rgwchCountString;
                dstrCountString.cchString  = g_dstrDRM_LS_BEGIN_ATTR.cchString + f_pdstrAction->cchString + g_dstrDRM_LS_COUNT_ATTR.cchString;
                pdstrCountString           = &dstrCountString;
            }
        }

        dr = _GetSecStateAttr( f_pcontextSST, pdstrCountString, &f_plicenseInfo->dwStartCount, NULL );

        if( dr != DRM_SUCCESS && f_pcontextLQ->fCurrentLicenseIsXML )
        {
            /*
            ** XMR license does not have start count
            */
            ChkDR( DRM_ASD_ParseV2License( f_pdstrLicense, pdstrCountString, &f_plicenseInfo->dwStartCount, NULL ));
        }
    }
    dr = DRM_SUCCESS;
ErrorExit:
    return dr;
}

static DRM_BOOL _ConvertLicenseInfoToStateData(
    IN const LicenseInfo               *f_plicenseinfo,
       OUT   DRM_LICENSE_STATE_DATA    *f_pstatedata )
{
    DRM_BOOL fUseState = TRUE;
    switch( f_plicenseinfo->dwCategory )
    {
    case LIC_TYPE_EXPIRY:
        _SetExpiryCategory( f_pstatedata,
                           &f_plicenseinfo->begDate,
                           &f_plicenseinfo->endDate );
        break;
    case LIC_TYPE_COUNTED_EXPIRY:
        _SetCountedExpiryCategory( f_pstatedata,
                                  &f_plicenseinfo->begDate,
                                  &f_plicenseinfo->endDate );

        /*
        ** We return both counts.
        ** Since the spec does not require to send start counts,
        ** set dwNumCounts to 1.
        */
        f_pstatedata->dwNumCounts = 1;
        f_pstatedata->dwCount[0]  = f_plicenseinfo->dwCount;
        f_pstatedata->dwCount[1]  = f_plicenseinfo->dwStartCount;
        break;
    case LIC_TYPE_EXPIRATION_AFTER_FIRST_USE:
        /*
        ** The license has never been used.
        ** It is still LIC_TYPE_EXPIRATION_AFTER_FIRST_USE type.
        ** If it had been used, it would have been changed to
        ** one of the other types.
        */

        /* Set the expiry values. */
        _SetExpiryCategory( f_pstatedata,
                           &f_plicenseinfo->begDate,
                           &f_plicenseinfo->endDate );

        f_pstatedata->dwCategory  = DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE;
        f_pstatedata->dwNumCounts = 1;
        f_pstatedata->dwCount[0]  = f_plicenseinfo->dwHours;
        break;
    default:
        /*
        ** Either unknown type of license or unsupported or expired.
        ** Ignore this license.
        */
        fUseState = FALSE;
        break;
    }

    if( fUseState )
    {
        if( f_plicenseinfo->fHasOPLs )
        {
            f_pstatedata->dwVague |= DRM_ASD_OPL;
        }
        if( f_plicenseinfo->fRequiresSAP )
        {
            f_pstatedata->dwVague |= DRM_ASD_SAP;
        }
        if( f_pstatedata->dwVague )
        {
            f_pstatedata->dwVague |= DRM_ASD_VAGUE;
        }
    }

    if( f_plicenseinfo->fHasMUExtensibleRestrictions )
    {
        f_pstatedata->dwVague |= DRM_ASD_MU_EXT_REST;
    }

    return fUseState;
}

static DRM_VOID _AggregateStateDataAndStateData(
    IN       DRM_VOID               *pOEMContext,
    IN OUT   DRM_LICENSE_STATE_DATA *f_pstatedata1,
    IN const DRM_LICENSE_STATE_DATA *f_pstatedata2,
    IN       DRM_BOOL                fFirstHasPriority)
{
    /* Aggregated Date variables */
    DRMFILETIME state1BegDate;
    DRMFILETIME state1EndDate;
    DRMFILETIME state2BegDate;
    DRMFILETIME state2EndDate;

    /* If we aggregate successfully, we must aggregate vague */
    DRM_DWORD dwAggregatedVague =
        f_pstatedata1->dwVague | f_pstatedata2->dwVague;

    /*
    ** This variable indicates whether we should we use
    ** f_statedata1 or f_statedata2 when we can't aggregate.
    */
    DRM_BOOL fUseFirst;

    switch( f_pstatedata1->dwCategory )
    {
    case DRM_LICENSE_STATE_NORIGHT:
    case DRM_LICENSE_STATE_UNLIM:
    case DRM_LICENSE_STATE_COUNT:
    case DRM_LICENSE_STATE_FROM:
    case DRM_LICENSE_STATE_UNTIL:
    case DRM_LICENSE_STATE_FROM_UNTIL:
    case DRM_LICENSE_STATE_COUNT_FROM:
    case DRM_LICENSE_STATE_COUNT_UNTIL:
    case DRM_LICENSE_STATE_COUNT_FROM_UNTIL:
    case DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE:
        break;
    default:
        /* Unrecognized category, just use the other one */
        fUseFirst = FALSE;
        goto CanNotAggregate;
    }

    switch( f_pstatedata2->dwCategory )
    {
    case DRM_LICENSE_STATE_NORIGHT:
    case DRM_LICENSE_STATE_UNLIM:
    case DRM_LICENSE_STATE_COUNT:
    case DRM_LICENSE_STATE_FROM:
    case DRM_LICENSE_STATE_UNTIL:
    case DRM_LICENSE_STATE_FROM_UNTIL:
    case DRM_LICENSE_STATE_COUNT_FROM:
    case DRM_LICENSE_STATE_COUNT_UNTIL:
    case DRM_LICENSE_STATE_COUNT_FROM_UNTIL:
    case DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE:
        break;
    default:
        /* Unrecognized category, just use the other one */
        fUseFirst = TRUE;
        goto CanNotAggregate;
    }

    if( f_pstatedata1->dwCategory == DRM_LICENSE_STATE_UNLIM
     || f_pstatedata2->dwCategory == DRM_LICENSE_STATE_NORIGHT )
    {
        /*
        ** It is already set to unlim or the new aggregation doesn't
        ** provide any new rights.
        ** Aggregation should not be called in this case. But, play safe.
        */
        goto ErrorExit;
    }

    if( f_pstatedata1->dwCategory == DRM_LICENSE_STATE_NORIGHT
     || f_pstatedata2->dwCategory == DRM_LICENSE_STATE_UNLIM )
    {
        /*
        ** In this case the new statedata is always better than the old.
        ** No need to aggregate - just copy.
        */
        MEMCPY( f_pstatedata1, f_pstatedata2, SIZEOF( *f_pstatedata1 ) );
        goto ErrorExit;
    }

    if( f_pstatedata1->dwCategory == DRM_LICENSE_STATE_COUNT
     || f_pstatedata2->dwCategory == DRM_LICENSE_STATE_COUNT )
    {
        if( f_pstatedata1->dwCategory == f_pstatedata2->dwCategory )
        {
            /* If both are counts, aggregate by taking the sum */
            f_pstatedata1->dwCount[0] += f_pstatedata2->dwCount[0];
            f_pstatedata1->dwCount[1] += f_pstatedata2->dwCount[1];

            /* Make sure to aggregate vague */
            goto AggregateVague;
        }
        else
        {
            /* If only one is count, can't aggregate */
            fUseFirst = fFirstHasPriority
                     || (f_pstatedata1->dwCategory == DRM_LICENSE_STATE_COUNT);
            goto CanNotAggregate;
        }
    }

    if( f_pstatedata1->dwCategory == DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE
     || f_pstatedata2->dwCategory == DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE )
    {
        if( f_pstatedata1->dwCategory == f_pstatedata2->dwCategory )
        {
            /* If both are firstuse, aggregate by taking the max */
            f_pstatedata1->dwCount[0] = max( f_pstatedata1->dwCount[0],
                                             f_pstatedata2->dwCount[1] );

            /* Make sure to aggregate vague */
            goto AggregateVague;
        }
        else
        {
            /* If only one is firstuse, can't aggregate */
            fUseFirst = fFirstHasPriority
                     || (f_pstatedata1->dwCategory == DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE);
            goto CanNotAggregate;
        }
    }

    /*
    ** At this point, all that should be left are:
    ** DRM_LICENSE_STATE_FROM
    ** DRM_LICENSE_STATE_UNTIL
    ** DRM_LICENSE_STATE_FROM_UNTIL
    ** DRM_LICENSE_STATE_COUNT_FROM
    ** DRM_LICENSE_STATE_COUNT_UNTIL
    ** DRM_LICENSE_STATE_COUNT_FROM_UNTIL
    */

    /* Read in dates from the state data. */
    _ReadDates( f_pstatedata1, &state1BegDate, &state1EndDate );
    _ReadDates( f_pstatedata2, &state2BegDate, &state2EndDate );

    if( ( f_pstatedata1->dwCategory == DRM_LICENSE_STATE_FROM
       || f_pstatedata1->dwCategory == DRM_LICENSE_STATE_UNTIL
       || f_pstatedata1->dwCategory == DRM_LICENSE_STATE_FROM_UNTIL )
     && ( f_pstatedata2->dwCategory == DRM_LICENSE_STATE_FROM
       || f_pstatedata2->dwCategory == DRM_LICENSE_STATE_UNTIL
       || f_pstatedata2->dwCategory == DRM_LICENSE_STATE_FROM_UNTIL ) )
    {
        /*
        ** We can aggregate two states that are date-ranges only.
        ** But, only if the date ranges overlap.
        */
        if( _OverlappingDates( &state1BegDate,
                               &state1EndDate,
                               &state2BegDate,
                               &state2EndDate ) )
        {
            /* Aggregate overlapping dates */
            /* Set the BegDate to the min BegDate */
            if( DRM_UTL_DateLessThan( &state2BegDate,
                                      &state1BegDate ) )
            {
                state1BegDate = state2BegDate;
            }
            /* Set the EndDate to the max EndDate */
            if( DRM_UTL_DateLessThan( &state1EndDate,
                                      &state2EndDate ) )
            {
                state1EndDate = state2EndDate;
            }
            _SetExpiryCategory( f_pstatedata1,
                               &state1BegDate,
                               &state1EndDate );

            /* Make sure to aggregate vague */
            goto AggregateVague;
        }
        /* Fall through if they don't overlap */
    }

    /*
    ** At this point, at least one state is:
    ** DRM_LICENSE_STATE_COUNT_FROM
    ** DRM_LICENSE_STATE_COUNT_UNTIL
    ** DRM_LICENSE_STATE_COUNT_FROM_UNTIL
    ** OR we have two expiry states that have non-overlapping date ranges.
    ** These can't be aggregated.
    ** So, we're going to use whichever one is currently usable.
    */
    if( ( _IsDateUsable( pOEMContext, &state1BegDate, &state1EndDate ) && _IsDateUsable( pOEMContext, &state2BegDate, &state2EndDate ) )
     || ( !_IsDateUsable( pOEMContext, &state1BegDate, &state1EndDate ) && !_IsDateUsable( pOEMContext, &state2BegDate, &state2EndDate ) ) )
    {
        /*
        ** Both or neither are usable.
        ** Just use the one that has priority or starts soonest.
        ** In case of a tie, we want to use first.
        ** So, we use !(state2<state1) which is same as (state1<=state2)
        */
        fUseFirst = fFirstHasPriority
                 || !DRM_UTL_DateLessThan( &state2BegDate, &state1BegDate );
    }
    else
    {
        /* Exactly one is usable.  Just use that one. */
        fUseFirst = _IsDateUsable( pOEMContext, &state1BegDate, &state1EndDate );
    }
    /* Either way, we couldn't actually aggregate */
    goto CanNotAggregate;

CanNotAggregate:
    if( !fUseFirst )
    {
        MEMCPY( f_pstatedata1, f_pstatedata2, SIZEOF( *f_pstatedata1 ) );
    }
    f_pstatedata1->dwVague |= DRM_ASD_VAGUE;
    goto ErrorExit;

AggregateVague:
    /* We were able to aggregate - make sure to aggregate vague as well */
    f_pstatedata1->dwVague |= dwAggregatedVague;
    goto ErrorExit;

ErrorExit:
    /* We finished aggregating as best we could */

    /* If any vague is set, make sure the base vague is set too */
    if( f_pstatedata1->dwVague )
    {
        f_pstatedata1->dwVague |= DRM_ASD_VAGUE;
    }

    return;
}

DRMINLINE static DRM_VOID _AggregateStateDataAndStateDataMultiple(
    IN       DRM_VOID               *f_pOEMContext,
    IN OUT   DRM_LICENSE_STATE_DATA *f_rgstatedata1,
    IN const DRM_LICENSE_STATE_DATA *f_rgstatedata2,
    IN       DRM_DWORD               f_cstatedata )
{
    for( ; f_cstatedata > 0; )
    {
        f_cstatedata--;
        _AggregateStateDataAndStateData( f_pOEMContext,
                                         &f_rgstatedata1[f_cstatedata],
                                         &f_rgstatedata2[f_cstatedata],
                                          TRUE );
    }

    return;
}

static DRM_VOID _AggregateStateDataAndStateDataChain(
    IN OUT   DRM_LICENSE_STATE_DATA    *f_pstatedata1,
    IN const DRM_LICENSE_STATE_DATA    *f_pstatedata2 )
{
    DRMFILETIME state1BegDate;       /* Beg Date of aggregated data in f_pstatedata-> */
    DRMFILETIME state1EndDate;       /* End Date of aggregated data in f_pstatedata-> */

    DRMFILETIME state2BegDate;       /* Beg Date of aggregated data in f_pstatedata-> */
    DRMFILETIME state2EndDate;       /* End Date of aggregated data in f_pstatedata-> */

    if( f_pstatedata1->dwCategory == DRM_LICENSE_STATE_NORIGHT )
    {
        /* Already know there are no rights.  Just return */
        return;
    }

    if( f_pstatedata1->dwCategory == DRM_LICENSE_STATE_UNLIM
     || f_pstatedata2->dwCategory == DRM_LICENSE_STATE_NORIGHT )
    {
        /* It's easy to tell that state1 has more rights than state2.  Assign
           state1 to the value of state2 and we are done. */
        MEMCPY( f_pstatedata1, f_pstatedata2, SIZEOF( *f_pstatedata2 ) );
        return;
    }

    if( f_pstatedata2->dwCategory == DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE )
    {
        if( f_pstatedata1->dwCategory != DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE )
        {
            /*
            ** There is no way to aggregate this type with other types of licenses
            ** return information on the counted licenses and set to vague
            */
            f_pstatedata1->dwVague   |= DRM_ASD_VAGUE;
        }
        else
        {
            f_pstatedata1->dwCount[0] = min( f_pstatedata1->dwCount[0],
                                             f_pstatedata2->dwCount[0] );
        }

        f_pstatedata1->dwVague |= f_pstatedata2->dwVague & DRM_ASD_OPL;
        f_pstatedata1->dwVague |= f_pstatedata2->dwVague & DRM_ASD_SAP;
        return;
    }

    /* Handle the counts first */
    if( f_pstatedata2->dwCategory == DRM_LICENSE_STATE_COUNT
     || f_pstatedata2->dwCategory == DRM_LICENSE_STATE_COUNT_FROM
     || f_pstatedata2->dwCategory == DRM_LICENSE_STATE_COUNT_UNTIL
     || f_pstatedata2->dwCategory == DRM_LICENSE_STATE_COUNT_FROM_UNTIL )
    {
        f_pstatedata1->dwNumCounts = 1;
        if( f_pstatedata1->dwCategory == DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE )
        {
            /*
            ** There is no way to aggregate this type with counted licenses
            ** return information on the counted licenses and set to vague
            */
            f_pstatedata1->dwCount[0] = f_pstatedata2->dwCount[0];
            f_pstatedata1->dwVague   |= DRM_ASD_VAGUE;
        }
        else
        {
            f_pstatedata1->dwCount[0] = min( f_pstatedata1->dwCount[0],
                                             f_pstatedata2->dwCount[0] );
        }
    }

    /* handle the dates */
    _ReadDates( f_pstatedata1, &state1BegDate, &state1EndDate );
    _ReadDates( f_pstatedata2, &state2BegDate, &state2EndDate );

    if( _OverlappingDates( &state1BegDate,
                           &state1EndDate,
                           &state2BegDate,
                           &state2EndDate ) )
    {
        /* Set the BegDate to the max BegDate */
        if( DRM_UTL_DateLessThan( &state1BegDate, &state2BegDate ) )
        {
            state1BegDate = state2BegDate;
        }
        /* Set the EndDate to the min EndDate */
        if( DRM_UTL_DateLessThan( &state2EndDate, &state1EndDate ) )
        {
            state1EndDate = state2EndDate;
        }
    }
    else
    {
        /* no overlapped date, no right */
        f_pstatedata1->dwCategory = DRM_LICENSE_STATE_NORIGHT;
        goto ErrorExit;
    }

    /* Now update the category since we have changed lots of fields */
    if( f_pstatedata1->dwNumCounts > 0 )
    {
        _SetCountedExpiryCategory( f_pstatedata1,
                                  &state1BegDate,
                                  &state1EndDate );
    }
    else
    {
        _SetExpiryCategory( f_pstatedata1,
                           &state1BegDate,
                           &state1EndDate );
    }

    f_pstatedata1->dwVague |= f_pstatedata2->dwVague & DRM_ASD_OPL;
    f_pstatedata1->dwVague |= f_pstatedata2->dwVague & DRM_ASD_SAP;

ErrorExit:
    return;
}

DRMINLINE static DRM_VOID _AggregateStateDataAndStateDataChainMultiple(
    IN OUT   DRM_LICENSE_STATE_DATA    *f_rgstatedata1,
    IN const DRM_LICENSE_STATE_DATA    *f_rgstatedata2,
    IN       DRM_DWORD                  f_cstatedata )
{
    for( ; f_cstatedata > 0; )
    {
        f_cstatedata--;
        _AggregateStateDataAndStateDataChain( &f_rgstatedata1[f_cstatedata],
                                              &f_rgstatedata2[f_cstatedata] );
        if( f_rgstatedata1[f_cstatedata].dwVague != 0 )
        {
            /* If any value in the Vague field is set always set the low bit */
            f_rgstatedata1[f_cstatedata].dwVague |= DRM_ASD_VAGUE;
        }
    }

    return;
}

static DRM_VOID _AggregateStateDataAndLicenseInfo(
    IN       DRM_VOID               *pOEMContext,
    IN OUT   DRM_LICENSE_STATE_DATA *f_pstatedata,
    IN const LicenseInfo            *f_plicenseInfo )
{
    DRM_LICENSE_STATE_DATA    nextstatedata;
    ZEROMEM( &nextstatedata, SIZEOF( DRM_LICENSE_STATE_DATA    ) );
    if( _ConvertLicenseInfoToStateData( f_plicenseInfo,
                                       &nextstatedata ) )
    {
        _AggregateStateDataAndStateData( pOEMContext,
                                         f_pstatedata,
                                        &nextstatedata,
                                         FALSE );
    }

    return;
}

static DRM_VOID _AggregateStateDataAndLicenseInfoMultiple(
    IN       DRM_VOID               *f_pOEMContext,
    IN OUT   DRM_LICENSE_STATE_DATA *f_pstatedata,
    IN const LicenseInfo            *f_plicenseInfo,
    IN       DRM_DWORD               f_cstatedata )
{
    for( ; f_cstatedata > 0; )
    {
        f_cstatedata--;
        _AggregateStateDataAndLicenseInfo( f_pOEMContext,
                                           &f_pstatedata[f_cstatedata],
                                           &f_plicenseInfo[f_cstatedata] );
    }

    return;
}

/*****************************************************************************
** Function :   _IsLicenseExpired
** Synopsis :   Check if the V2 license has expired
** Arguments :
**    f_pdstrLicense: buffer containing the license
**    f_pcontextSST:  Secure store context
** Returns :    TRUE if expired
** Notes :
** Algorithm :
*/
static DRM_BOOL _IsLicenseExpired(
    IN OUT   DRM_VIEW_RIGHTS_CONTEXT *f_pcontextLQ,
    IN       DRM_SECSTORE_CONTEXT    *f_pcontextSST )
{
    DRMFILETIME endDate = {0};

    _InitInfDate( &endDate );

    /* retrieve end expiry date.  */
    if( _GetSecStateAttr( f_pcontextSST, &g_dstrDRM_LS_ENDDATE_ATTR, NULL, &endDate ) != DRM_SUCCESS )
    {
        if( f_pcontextLQ->fCurrentLicenseIsXML )
        {
            ( void )DRM_ASD_ParseV2License( &f_pcontextLQ->pLicEval->dstrContentLicense, &g_dstrDRM_LS_ENDDATE_ATTR, NULL, &endDate );
        }
        else if( XMR_IS_EXPIRATION_VALID(&f_pcontextLQ->licXMR)
              && f_pcontextLQ->licXMR.containerOuter.containerGlobalPolicies.Expiration.dwEndDate != XMR_UNLIMITED )
        {
            CREATE_FILE_TIME( f_pcontextLQ->licXMR.containerOuter.containerGlobalPolicies.Expiration.dwEndDate, endDate );
        }
    }

    return _IsExpired(f_pcontextLQ->pBBContext->pOEMContext, &endDate);
}


/*****************************************************************************
** Function :   _QueryRightForCandoAction
** Synopsis :   try perform all action individually on this license
** Arguments :
** Returns :    DRM_SUCCESS if action is satisfied
**              DRM_S_FALSE if not
** Notes :      Available actions are: "CanCopy", "CanPlay", "CanBurn" and "CanCreateThumbnailImage".
**              f_ppdstrActionUsed still gets set if the license might have
**              allowed the action but is expired, out of counts, etc,
**              but does not get set if the license could never support it.
** Algorithm :
*/
static DRM_RESULT _QueryRightForCandoAction(
    IN const DRM_CONST_STRING        *f_dstrAction,
    IN OUT   DRM_VIEW_RIGHTS_CONTEXT *f_pcontextLQ,
    IN OUT   DRM_DST                 *f_pDatastore,
#if DRM_SUPPORT_PMLICENSE
       OUT   DRM_BOOL                *f_pfUpdateWithPMExpiry,
#endif
       OUT   DRM_CONST_STRING const **f_ppdstrActionUsed )
{
    DRM_RESULT dr             = DRM_E_FAIL;
    DRM_BOOL   fCanPerform    = FALSE;
    DRM_BOOL   fActionExisted = FALSE;
    DRM_BOOL   fKeepPrevious  = FALSE;

    ChkArg( f_pcontextLQ != NULL );

    *f_ppdstrActionUsed = NULL;

    /* CanCopy */
    if( DRM_UTL_DSTRStringsEqual( f_dstrAction, &g_dstrWMDRM_RIGHT_COPY ) )
    {
        /*  g_dstrWMDRM_RIGHT_COPY
            g_dstrWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE
            g_dstrWMDRM_RIGHT_COPY_TO_SDMI_DEVICE
        */
        dr = DRM_LEVL_PerformOperations( f_pcontextLQ->pLicEval,
                                         DRM_LICENSE_EVAL_ACTION,
                                         DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                        &g_dstrWMDRM_RIGHT_COPY,
                                        &fCanPerform,
                                        &fActionExisted,
                                         f_pDatastore,
                                         NULL,
                                         NULL );
        if( dr == DRM_SUCCESS )
        {
            *f_ppdstrActionUsed = &g_dstrWMDRM_RIGHT_COPY;
#if DRM_SUPPORT_PMLICENSE
            fKeepPrevious = TRUE;
#endif
            if( fCanPerform )
            {
                /* Success! */
                goto ErrorExit;
            }
            /* Fall through - Need to try PMLICENSE (if supported) */
        }

#if DRM_SUPPORT_PMLICENSE
        /* XMR license does not have PMLICENSE rights */
        if( f_pcontextLQ->fCurrentLicenseIsXML )
        {
            /* The Copy right isn't allowed.  Check for CreatePMLicense */
            dr = DRM_LEVL_PerformOperations( f_pcontextLQ->pLicEval,
                                             DRM_LICENSE_EVAL_ACTION,
                                             DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                            &g_dstrCreatePMLicense,
                                            &fCanPerform,
                                             NULL,
                                             f_pDatastore,
                                             NULL,
                                             NULL);

            if( dr == DRM_SUCCESS )
            {
                if( fCanPerform
                && ( _HaveRightsLong( RIGHT_COPY_TO_SDMI_DEVICE,    f_pcontextLQ->pLicEval->lPMRights )
                || _HaveRightsLong( RIGHT_COPY_TO_NONSDMI_DEVICE, f_pcontextLQ->pLicEval->lPMRights ) ) )
                {
                    *f_ppdstrActionUsed = &g_dstrWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE;
                    *f_pfUpdateWithPMExpiry = TRUE;
                    dr = DRM_SUCCESS;
                    goto ErrorExit;
                }
                else if( !fKeepPrevious )
                {
                    *f_ppdstrActionUsed = &g_dstrWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE;
                    *f_pfUpdateWithPMExpiry = TRUE;
                }
            }
        }
#endif /* DRM_SUPPORT_PMLICENSE */

        /*
        ** If we succeed for copy, we return copy as the action used
        ** unless PMLICENSE is supported, it succeeds, && can be performed.
        ** In other words, if both copy and PMLICENSE succeed
        ** but either both can be performed or neither can be performed,
        ** then we favor copy.
        ** In all other cases, we favor the one closest to success and can
        ** be performed.
        */
        dr = DRM_S_FALSE;
        goto ErrorExit;
    }

    /* CanPlay */
    if( DRM_UTL_DSTRStringsEqual( f_dstrAction, &g_dstrWMDRM_RIGHT_PLAYBACK ) )
    {
        /*  g_dstrWMDRM_RIGHT_PLAYBACK
            g_dstrWMDRM_RIGHT_COLLABORATIVE_PLAY
        */
        dr = DRM_LEVL_PerformOperations( f_pcontextLQ->pLicEval,
                                         DRM_LICENSE_EVAL_ACTION,
                                         DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                        &g_dstrWMDRM_RIGHT_PLAYBACK,
                                        &fCanPerform,
                                        &fActionExisted,
                                         f_pDatastore,
                                         NULL,
                                         NULL );
        if( dr == DRM_SUCCESS )
        {
            *f_ppdstrActionUsed = &g_dstrWMDRM_RIGHT_PLAYBACK;
            fKeepPrevious = TRUE;
            if( fCanPerform )
            {
                /* Success! */
                goto ErrorExit;
            }
            /* Fall through - Need to try COLLABORATIVE_PLAY */
        }

        dr = DRM_LEVL_PerformOperations( f_pcontextLQ->pLicEval,
                                         DRM_LICENSE_EVAL_ACTION,
                                         DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                        &g_dstrWMDRM_RIGHT_COLLABORATIVE_PLAY,
                                        &fCanPerform,
                                        &fActionExisted,
                                         f_pDatastore,
                                         NULL,
                                         NULL );
        if( dr == DRM_SUCCESS )
        {
            if( fCanPerform )
            {
                *f_ppdstrActionUsed = &g_dstrWMDRM_RIGHT_COLLABORATIVE_PLAY;
                dr = DRM_SUCCESS;
                goto ErrorExit;
            }
            else if( !fKeepPrevious )
            {
                *f_ppdstrActionUsed = &g_dstrWMDRM_RIGHT_COLLABORATIVE_PLAY;
            }
        }

        /*
        ** If we succeed for playback, we return playback as the action used
        ** unless COLLABORATIVE_PLAY succeeds && can be performed.
        ** In other words, if both playback and COLLABORATIVE_PLAY succeed
        ** but either both can be performed or neither can be performed,
        ** then we favor playback.
        ** In all other cases, we favor the one closest to success and can
        ** be performed.
        */
        dr = DRM_S_FALSE;
        goto ErrorExit;
    }

#if DRM_SUPPORT_PLAYLIST_BURN
    /* CanBurn */
    if( DRM_UTL_DSTRStringsEqual( f_dstrAction, &g_dstrWMDRM_RIGHT_PLAYLIST_BURN )
     || DRM_UTL_DSTRStringsEqual( f_dstrAction, &g_dstrWMDRM_RIGHT_COPY_TO_CD ) )
    {
        /*  g_dstrWMDRM_RIGHT_COPY_TO_CD
            g_dstrWMDRM_RIGHT_PLAYLIST_BURN
        */
        dr = DRM_LEVL_PerformOperations( f_pcontextLQ->pLicEval,
                                         DRM_LICENSE_EVAL_ACTION,
                                         DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                         f_dstrAction,
                                        &fCanPerform,
                                        &fActionExisted,
                                         f_pDatastore,
                                         NULL,
                                         NULL);
        if( dr == DRM_SUCCESS )
        {
            *f_ppdstrActionUsed = f_dstrAction;

            /* XMR licenses must have done a "fall-forward" to the "playlist burn" right */
            if( !f_pcontextLQ->fCurrentLicenseIsXML
             && DRM_UTL_DSTRStringsEqual( f_dstrAction, &g_dstrWMDRM_RIGHT_COPY_TO_CD ) )
            {
                /*
                ** Here's what's going on:
                ** DRM_LEVL_PerformOperations has logic to "fall-forward" from
                **  the "copy to cd" right to the "playlist burn" right.
                ** This will occur on all XMR licenses since "copy to cd"
                **  is not supported on them.
                ** Problem: This codepath needs to know what right was actually
                **  USED to allow the action.
                ** Otherwise, it's unable to get the counts for that action later.
                ** Hence, when we're dealing with an XMR license,
                **  we assume that "copy to cd" used the "fall-forward" logic.
                */
                *f_ppdstrActionUsed = &g_dstrWMDRM_RIGHT_PLAYLIST_BURN;
            }
            fKeepPrevious = TRUE;
            if( fCanPerform )
            {
                /* Success! */
                goto ErrorExit;
            }
            /* Fall through - Need to try COPY_TO_CD (if applicable) */
        }

        /*
        ** Ideally, we'd only fallback from PLAYLIST_BURN to COPY_TO_CD
        ** if the MaxPlaylistBurnCount for the playlist were not set.
        ** That's exactly what the playlist object does for decrypt.
        ** However, we're doing query now, and we don't HAVE a playlist.
        ** We can't get this information, but we can make a best effort.
        ** So, we always fallback from PLAYLIST_BURN to COPY_TO_CD if we
        ** didn't find the PLAYLIST_BURN right in the license.
        */
        if( !fActionExisted
         && DRM_UTL_DSTRStringsEqual( f_dstrAction, &g_dstrWMDRM_RIGHT_PLAYLIST_BURN ) )
        {
            dr = DRM_LEVL_PerformOperations( f_pcontextLQ->pLicEval,
                                             DRM_LICENSE_EVAL_ACTION,
                                             DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                            &g_dstrWMDRM_RIGHT_COPY_TO_CD,
                                            &fCanPerform,
                                            &fActionExisted,
                                             f_pDatastore,
                                             NULL,
                                             NULL);
            if( dr == DRM_SUCCESS )
            {
                if( fCanPerform )
                {
                    *f_ppdstrActionUsed = &g_dstrWMDRM_RIGHT_COPY_TO_CD;
                    dr = DRM_SUCCESS;
                    goto ErrorExit;
                }
                else if( !fKeepPrevious )
                {
                    *f_ppdstrActionUsed = &g_dstrWMDRM_RIGHT_COPY_TO_CD;
                }
            }
        }

        /*
        ** If we succeed for copy to cd, we return copy as the action used
        ** unless PLAYLIST_BURN is supported, it succeeds, && can be performed.
        ** In other words, if both copy to cd and PLAYLIST_BURN succeed
        ** but either both can be performed or neither can be performed,
        ** then we favor copy to cd.
        ** In all other cases, we favor the one closest to success and can
        ** be performed.
        */
        dr = DRM_S_FALSE;
        goto ErrorExit;
    }
#endif  /* DRM_SUPPORT_PLAYLIST_BURN */

#if DRM_SUPPORT_THUMBNAIL_RIGHT
    /* CanCreateThumbnailImage */
    if ( DRM_UTL_DSTRStringsEqual(f_dstrAction, &g_dstrWMDRM_RIGHT_CREATE_THUMBNAIL_IMAGE ) )
    {
        /*  g_dstrWMDRM_RIGHT_CREATE_THUMBNAIL_IMAGE
        */
        dr = DRM_LEVL_PerformOperations(f_pcontextLQ->pLicEval,
                                        DRM_LICENSE_EVAL_ACTION,
                                        DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                        &g_dstrWMDRM_RIGHT_CREATE_THUMBNAIL_IMAGE,
                                        &fCanPerform,
                                        &fActionExisted,
                                        f_pDatastore);
        if ( dr == DRM_SUCCESS )
        {

            //  'Create Thumbnail Image' right is an implied right which maps to Play right when using licenses.
            //  Switch the Action string if CreateThumbnailImage detected

            *f_ppdstrActionUsed = &g_dstrWMDRM_RIGHT_PLAYBACK;

            if( fCanPerform )
            {
                /* Success! */
                goto ErrorExit;
            }
        }

        dr = DRM_S_FALSE;

        goto ErrorExit;
    }
#endif

ErrorExit:
    return dr;
}


/*****************************************************************************
** Function :   _ExamineOutputLevels
** Synopsis :   Examine the output level data from DRM
** Arguments :
** Returns :    DRM_SUCCESS if output level is allowed
**              DRM_S_FALSE otherwise
** Notes :
** Algorithm :
*/
static DRM_RESULT _ExamineOutputLevels(
    IN     DRM_VIEW_RIGHTS_CONTEXT *f_pcontextLQ,
    IN     DRM_COPY_OPL            *f_pOutputLevels,
       OUT DRM_DWORD               *f_pdwResult )
{
    DRM_RESULT dr = DRM_S_FALSE;
    DRM_DWORD  i  = 0;

    ChkArg( f_pOutputLevels != NULL );

    /* examine the excluded list first */
    for ( i=0; i<f_pOutputLevels->oplIdExcludes.cIds; i++ )
    {
        if( DRMCRT_memcmp(&(f_pOutputLevels->oplIdExcludes.rgIds[i]), &f_pcontextLQ->deviceGUID, sizeof(DRM_GUID)) == 0 )
        {
            *f_pdwResult |= DRM_LICQUERY_NOT_ENABLED_COPY_OPL_EXCLUDED;
            dr = DRM_S_FALSE;
            goto ErrorExit;
        }
    }

    /* check the OPL level */
    if( f_pOutputLevels->wMinimumCopyLevel <= f_pcontextLQ->dwDeviceCopyOPL )
    {
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }

    /* examine the included list */
    for ( i=0; i<f_pOutputLevels->oplIdIncludes.cIds; i++ )
    {
        if( DRMCRT_memcmp(&(f_pOutputLevels->oplIdIncludes.rgIds[i]), &f_pcontextLQ->deviceGUID, sizeof(DRM_GUID)) == 0 )
        {
            dr = DRM_SUCCESS;
            goto ErrorExit;
        }
    }

    *f_pdwResult |= DRM_LICQUERY_NOT_ENABLED_COPY_OPL_TOO_LOW;
    dr = DRM_S_FALSE;

ErrorExit:
    return dr;
}


/*****************************************************************************
**
** Function  :   _ExamineOutputLevelsXMR
**
** Synopsis  :   Examine the output level data from DRM
**
** Arguments :  [f_pcontextLQ] : Specifies the ViewRights context
**              [f_pdwResult]  : Returns result flags
**
** Returns   :
**      DRM_SUCCESS
**          output level is allowed
**      DRM_S_FALSE
**          output level is not allowed
**      DRM_E_INVALIDARG
**          One of the parameters was NULL
**
******************************************************************************/
static DRM_RESULT _ExamineOutputLevelsXMR(
    IN     DRM_VIEW_RIGHTS_CONTEXT *f_pcontextLQ,
       OUT DRM_DWORD               *f_pdwResult )
{
    DRM_RESULT           dr          = DRM_SUCCESS;
    DRM_XMR_COPY_RIGHTS *pCopyRights = NULL;

    ChkArg( f_pcontextLQ != NULL );
    ChkArg( f_pdwResult  != NULL );

    pCopyRights = &( f_pcontextLQ->licXMR.containerOuter.containerCopyPolicies );
    f_pdwResult = 0;

    /*
    ** check the OPL level
    */
    if( XMR_IS_COPYPROTECTIONLEVEL_VALID( &f_pcontextLQ->licXMR )
     && ( DRM_DWORD )( pCopyRights->CopyProtectionLevel.wValue ) > f_pcontextLQ->dwDeviceCopyOPL )
    {
       *f_pdwResult |= DRM_LICQUERY_NOT_ENABLED_COPY_OPL_TOO_LOW;
        dr = DRM_S_FALSE;
    }

ErrorExit:
    return dr;
}


/*****************************************************************************
** Function :   _UseRightForCandoAction
** Synopsis :   Try to use the given right for action
** Arguments :
** Returns :    DRM_SUCCESS if right can be used for action
**              DRM_S_FALSE otherwise
** Notes :
** Algorithm :
*/
static DRM_RESULT _UseRightForCandoAction(
    IN OUT   DRM_VIEW_RIGHTS_CONTEXT *f_pcontextLQ,
    IN const DRM_CONST_STRING        *f_dstrAction,
    IN const DRM_CONST_STRING        *f_pdstrRightUsed,
#if DRM_SUPPORT_PMLICENSE
    IN       DRM_BOOL                 f_fUpdateWithPMExpiry,
    IN       DRMFILETIME             *f_pft,
#endif
       OUT   DRM_DWORD               *f_pdwResult )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrDummy         = EMPTY_DRM_STRING;
    DRM_BOOL         fLicReqMetering   = FALSE;
    DRM_BOOL         fLicTimeBased     = FALSE;
    DRM_DWORD        dwLicMinReqAppSec = 0;
    LicenseInfo      licInfo           = { LIC_TYPE_IGNORE, 0 };
#if DRM_SUPPORT_COPY_OPL
    DRM_CONST_STRING dstrRestriction   = EMPTY_DRM_STRING;
#endif

    /* The right is allowed. Let us now check if the license can be used on this machine. */
    if( _GetV2LicenseInfo( f_pcontextLQ,
                          &f_pcontextLQ->pLicEval->dstrContentLicense,
                          &licInfo,
                           f_pdstrRightUsed,
                           f_pcontextLQ->pbLIDSecStore) == DRM_SUCCESS )
    {
        DRM_DWORD cbSize = 0;

        if( f_pcontextLQ->fCurrentLicenseIsXML )
        {
            /* XMR license does not have SAP */
            DRM_ASD_ParseV2License( &f_pcontextLQ->pLicEval->dstrContentLicense,
                                    &g_dstrDRM_LS_SAP_ATTR,
                                    &cbSize,
                                     NULL );
            if( cbSize > 0 )
            {
                licInfo.fRequiresSAP = TRUE;
            }
        }

#if DRM_SUPPORT_PMLICENSE
        if( f_fUpdateWithPMExpiry  &&  DRM_UTL_DateLessThan( f_pft, &licInfo.endDate ) )
        {
            licInfo.endDate = *f_pft;
        }
#endif

        switch (licInfo.dwCategory)
        {
            case LIC_TYPE_EXPIRY:
                if( _IsExpired(f_pcontextLQ->pBBContext->pOEMContext, &licInfo.endDate) )     /* endDate > now ? */
                {
                    *f_pdwResult |= DRM_LICQUERY_NOT_ENABLED_EXPIRED;
                    dr = DRM_S_FALSE;
                    goto ErrorExit;
                }
                if( !_IsExpired(f_pcontextLQ->pBBContext->pOEMContext, &licInfo.begDate) )     /* now < begDate ? */
                {
                    *f_pdwResult |= DRM_LICQUERY_NOT_ENABLED_NOT_STARTED;
                    dr = DRM_S_FALSE;
                    goto ErrorExit;
                }
                break;

            case LIC_TYPE_IGNORE:
                if( _IsExpired(f_pcontextLQ->pBBContext->pOEMContext, &licInfo.endDate) )     /* endDate > now ? */
                {
                    *f_pdwResult |= DRM_LICQUERY_NOT_ENABLED_EXPIRED;
                    dr = DRM_S_FALSE;
                    goto ErrorExit;
                }
                else if( licInfo.dwCount == 0 )
                {
                    *f_pdwResult |= DRM_LICQUERY_NOT_ENABLED_EXHAUSTED;
                    dr = DRM_S_FALSE;
                    goto ErrorExit;
                }
                break;

            default:
                break;
        }
    }
    else
    {
        /* If we couldn't get the License Info, then just set NO_RIGHT */
        *f_pdwResult |= DRM_LICQUERY_NOT_ENABLED_NO_RIGHT;
        dr = DRM_S_FALSE;
        goto ErrorExit;
    }
#if DRM_SUPPORT_COPY_OPL
    /* get OPL restriction */
    if( f_pcontextLQ->fCurrentLicenseIsXML )
    {
        dr = DRM_LIC_GetEvent( &f_pcontextLQ->pLicEval->dstrContentLicense,
                               &g_dstrLicEvalOnAction,
                                f_pdstrRightUsed,
                                NULL,
                                NULL,
                                NULL,
                               &dstrRestriction );
        if( dr == DRM_SUCCESS  &&  dstrRestriction.cchString > 0 )
        {
            licInfo.fHasOPLs = TRUE;

            /* examine OPL here for CanCopy */
            if( DRM_UTL_DSTRStringsEqual( f_dstrAction, &g_dstrWMDRM_RIGHT_COPY ) )
            {
                DRM_STACK_ALLOCATOR_CONTEXT stack = {0};

                stack.pbStack  = f_pcontextLQ->copyOPL.rgbCopyOPLBuffer;
                stack.cbStack  = SIZEOF(f_pcontextLQ->copyOPL.rgbCopyOPLBuffer);

                dr = DRM_OPL_ProcessCopyOutputLevelData( &dstrRestriction,&f_pcontextLQ->copyOPL.oplCopy,&stack );
                if( dr == DRM_SUCCESS )
                {
                    dr = _ExamineOutputLevels( f_pcontextLQ, &f_pcontextLQ->copyOPL.oplCopy, f_pdwResult );
                    if( dr != DRM_SUCCESS )
                    {
                        dr = DRM_S_FALSE;
                        goto ErrorExit;
                    }
                }
            }
        }
    }
    else
    {
        if( DRM_UTL_DSTRStringsEqual( f_dstrAction, &g_dstrWMDRM_RIGHT_COPY ) )
        {
            if( XMR_IS_COPYPROTECTIONLEVEL_VALID( &f_pcontextLQ->licXMR ) )
            {
                licInfo.fHasOPLs = TRUE;
                dr = _ExamineOutputLevelsXMR( f_pcontextLQ, f_pdwResult );
                if( dr != DRM_SUCCESS )
                {
                    dr = DRM_S_FALSE;
                    goto ErrorExit;
                }
            }
        }
        else if( DRM_UTL_DSTRStringsEqual( f_dstrAction, &g_dstrWMDRM_RIGHT_PLAYBACK ) )
        {
            if( XMR_IS_OPL_VALID( &f_pcontextLQ->licXMR ) )
            {
                licInfo.fHasOPLs = TRUE;
            }
        }
    }
#endif
    dr = DRM_SUCCESS;

    fLicTimeBased = !_InfDate( &licInfo.endDate );

    if( f_pcontextLQ->fCurrentLicenseIsXML )
    {
        /*
        ** get metering info
        */
        fLicReqMetering = DRM_LIC_GetAttribute( &f_pcontextLQ->pLicEval->dstrContentLicense,
                                                 NULL,
                                                 DRM_LICENSE_ATTRIB_METERING_ID,
                                                 NULL,
                                                &dstrDummy,
                                                 0 ) == DRM_SUCCESS;

        /*
        ** get min appsec required
        */
        DRM_ASD_ParseV2License( &f_pcontextLQ->pLicEval->dstrContentLicense,
                                &g_dstrDRM_LS_APPSEC_ATTR,
                                &dwLicMinReqAppSec,
                                 NULL );

    }
    else
    {
        /*
        ** get metering info
        */
        if( XMR_IS_METERING_VALID( &f_pcontextLQ->licXMR ) )
        {
            fLicReqMetering = f_pcontextLQ->licXMR.containerOuter.containerGlobalPolicies.Metering.fValid;
        }

        /*
        ** get min appsec required
        */
        if( XMR_IS_MINIMUM_ENVIRONMENT_VALID( &f_pcontextLQ->licXMR ) )
        {
            dwLicMinReqAppSec = f_pcontextLQ->licXMR.containerOuter.containerGlobalPolicies.MinimumEnvironment.wMinimumSecurityLevel;
        }
    }

    /* CanCopy */
    if( DRM_UTL_DSTRStringsEqual( f_dstrAction, &g_dstrWMDRM_RIGHT_COPY ) )
    {
        if( DRM_UTL_DSTRStringsEqual( f_pdstrRightUsed, &g_dstrWMDRM_RIGHT_COPY ) )
        {
            if( f_pcontextLQ->fIsWMDRMPDDevice )   /* is WMDRM-PD device */
            {
                /* check appsec */
                if( f_pcontextLQ->cacheDevCert.appSec < dwLicMinReqAppSec )
                {
                    *f_pdwResult |= DRM_LICQUERY_NOT_ENABLED_APPSEC_TOO_LOW;
                    dr = DRM_S_FALSE;
                    goto ErrorExit;
                }

                /* check WMDRM-PD feature in devcert */
                if( fLicReqMetering
                 && (f_pcontextLQ->cacheDevCert.dwFeatureFlags & DRM_FEATURE_METERING) == 0 )
                {
                    *f_pdwResult |= DRM_LICQUERY_NOT_ENABLED_NO_METERING_SUPPORT;
                    dr = DRM_S_FALSE;
                    goto ErrorExit;
                }

                if( fLicTimeBased
                 && (f_pcontextLQ->cacheDevCert.dwFeatureFlags & DRM_FEATURE_SECURE_CLOCK) == 0
                 && (f_pcontextLQ->cacheDevCert.dwFeatureFlags & DRM_FEATURE_ANTI_ROLLBACK_CLOCK) == 0 )
                {
                    *f_pdwResult |= DRM_LICQUERY_NOT_ENABLED_NO_CLOCK_SUPPORT;
                    dr = DRM_S_FALSE;
                    goto ErrorExit;
                }
            }

            /* non WMDRM-PD device */
            else if( f_pcontextLQ->lDeviceAppSec < f_pcontextLQ->pLicEval->lPMAppSec )
            {
                *f_pdwResult |= DRM_LICQUERY_NOT_ENABLED_APPSEC_TOO_LOW;
                dr = DRM_S_FALSE;
                goto ErrorExit;
            }

            dr = DRM_SUCCESS;
        }
        else
        {
#if DRM_SUPPORT_PMLICENSE
            if( DRM_UTL_DSTRStringsEqual( f_pdstrRightUsed, &g_dstrWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE )
             || DRM_UTL_DSTRStringsEqual( f_pdstrRightUsed, &g_dstrWMDRM_RIGHT_COPY_TO_SDMI_DEVICE ) )
            {
                /* check environment variables */
                if( f_pcontextLQ->fIsWMDRMPDDevice )
                {
                    if( f_pcontextLQ->cacheDevCert.appSec < (DRM_DWORD)(f_pcontextLQ->pLicEval->lPMAppSec) )
                    {
                        *f_pdwResult |= DRM_LICQUERY_NOT_ENABLED_APPSEC_TOO_LOW;
                        dr = DRM_S_FALSE;
                        goto ErrorExit;
                    }
                }

                /* non-WMDRM-PD device */
                else if( f_pcontextLQ->lDeviceAppSec < f_pcontextLQ->pLicEval->lPMAppSec )
                {
                    *f_pdwResult |= DRM_LICQUERY_NOT_ENABLED_APPSEC_TOO_LOW;
                    dr = DRM_S_FALSE;
                    goto ErrorExit;
                }

                dr = DRM_SUCCESS;
                goto ErrorExit;
            }
#endif /* DRM_SUPPORT_PMLICENSE */

            dr = DRM_S_FALSE;
        }
        goto ErrorExit;
    }

    /* CanPlay */
    if( DRM_UTL_DSTRStringsEqual( f_dstrAction, &g_dstrWMDRM_RIGHT_PLAYBACK ) )
    {
        if( DRM_UTL_DSTRStringsEqual(f_pdstrRightUsed, &g_dstrWMDRM_RIGHT_PLAYBACK)
         || DRM_UTL_DSTRStringsEqual(f_pdstrRightUsed, &g_dstrWMDRM_RIGHT_COLLABORATIVE_PLAY) )
        {
            /* check environment variables */
            if( fLicReqMetering  &&  !f_pcontextLQ->fPCSupportMetering )
            {
                *f_pdwResult |= DRM_LICQUERY_NOT_ENABLED_NO_METERING_SUPPORT;
                dr = DRM_S_FALSE;
                goto ErrorExit;
            }

            dr = DRM_SUCCESS;
        }

        goto ErrorExit;
    }

#if DRM_SUPPORT_PLAYLIST_BURN
    /* CanBurn */
    if( DRM_UTL_DSTRStringsEqual( f_dstrAction, &g_dstrWMDRM_RIGHT_PLAYLIST_BURN ) )
    {
        /*  g_dstrWMDRM_RIGHT_COPY_TO_CD
            g_dstrWMDRM_RIGHT_PLAYLIST_BURN
        */
        if( DRM_UTL_DSTRStringsEqual( f_pdstrRightUsed, &g_dstrWMDRM_RIGHT_COPY_TO_CD )
         || DRM_UTL_DSTRStringsEqual( f_pdstrRightUsed, &g_dstrWMDRM_RIGHT_PLAYLIST_BURN )
          )
        {
            /* check environment variables */
            if( fLicReqMetering  &&  !f_pcontextLQ->fPCSupportMetering )
            {
                *f_pdwResult |= DRM_LICQUERY_NOT_ENABLED_NO_METERING_SUPPORT;
                dr = DRM_S_FALSE;
                goto ErrorExit;
            }

            dr = DRM_SUCCESS;
        }
    }
#endif  /* DRM_SUPPORT_PLAYLIST_BURN*/
ErrorExit:
    return dr;
}


static DRM_VOID _AddLicResultCache(
    IN OUT DRM_VIEW_RIGHTS_CONTEXT *f_pcontextLQ,
    IN     DRM_LID                 *f_pLID,
    IN     DRM_BOOL                 f_fHasParentLink,
    IN     DRM_KID                 *f_pparentKID,
    IN     DRM_DWORD               *f_rgLicResult,
    IN     DRM_DWORD                f_dwUplinkVector,
    IN     LicenseInfo             *f_rgLicInfo )
{
    DRM_DWORD iAction = DRM_MAX_RIGHTS_SUPPORTED;

    if( f_pcontextLQ->cCacheSlots == 0 )
    {
        return;
    }

    MEMCPY(&(f_pcontextLQ->rgCacheSlots[f_pcontextLQ->iCurrSlot].cachedLID), f_pLID, SIZEOF(DRM_LID));
    if( f_fHasParentLink )
    {
        MEMCPY(&(f_pcontextLQ->rgCacheSlots[f_pcontextLQ->iCurrSlot].parentKID), f_pparentKID, SIZEOF(DRM_KID));
    }
    else
    {
        MEMSET(&(f_pcontextLQ->rgCacheSlots[f_pcontextLQ->iCurrSlot].parentKID), 0, SIZEOF(DRM_KID));
    }

    f_pcontextLQ->rgCacheSlots[f_pcontextLQ->iCurrSlot].dwUplinkVector = f_dwUplinkVector;

    if (iAction > 0)
    {
        do  /* This loop iterates backwards from (DRM_MAX_RIGHTS_SUPPORTED-1) through 0. */
        {
            iAction--;

            if( f_rgLicResult != NULL )
            {
                f_pcontextLQ->rgCacheSlots[f_pcontextLQ->iCurrSlot].dwResult[iAction] = f_rgLicResult[iAction];
            }
            if( f_rgLicInfo != NULL )
            {
                f_pcontextLQ->rgCacheSlots[f_pcontextLQ->iCurrSlot].licInfo[iAction]  = f_rgLicInfo[iAction];
            }
        } while (iAction > 0);
    }

    f_pcontextLQ->iCurrSlot = (f_pcontextLQ->iCurrSlot + 1) % f_pcontextLQ->cCacheSlots;
}


static DRM_BOOL _GetLicResultCache(
    IN OUT DRM_VIEW_RIGHTS_CONTEXT *f_pcontextLQ,
    IN     DRM_LID                 *f_pLID,
       OUT DRM_BOOL                *f_pfHasParentLink,
       OUT DRM_KID                 *f_pparentKID,
       OUT DRM_DWORD               *f_rgLicResult,
       OUT DRM_DWORD               *f_pdwUplinkVector,
       OUT LicenseInfo             *f_rgLicInfo )
{
    DRM_DWORD iSlot   = 0;
    DRM_DWORD iAction = 0;
    DRM_BOOL  fResult = FALSE;

    for (iSlot=0; iSlot<f_pcontextLQ->cCacheSlots; iSlot++)
    {
        if( MEMCMP(&(f_pcontextLQ->rgCacheSlots[iSlot].cachedLID), f_pLID, SIZEOF(DRM_LID)) == 0 )
        {
            /* copy cached result */
            if( f_pdwUplinkVector != NULL )
            {
                *f_pdwUplinkVector = f_pcontextLQ->rgCacheSlots[iSlot].dwUplinkVector;
            }

            iAction = DRM_MAX_RIGHTS_SUPPORTED;
            if (iAction > 0)
            {
                do  /* This loop iterates backwards from (DRM_MAX_RIGHTS_SUPPORTED-1) through 0. */
                {
                    iAction--;
                    if( f_rgLicResult != NULL )
                    {
                        f_rgLicResult[iAction] = f_pcontextLQ->rgCacheSlots[iSlot].dwResult[iAction];
                    }
                    if( f_rgLicInfo != NULL )
                    {
                        f_rgLicInfo[iAction]   = f_pcontextLQ->rgCacheSlots[iSlot].licInfo[iAction];
                    }
                } while (iAction > 0);
            }

            /* copy cached parentKID */
            for ( iAction = 0; iAction < SIZEOF(DRM_KID); iAction++ )
            {
                if( f_pcontextLQ->rgCacheSlots[iSlot].parentKID.rgb[iAction] != 0 )
                {
                    break;
                }
            }
            if( iAction == SIZEOF(DRM_KID) )   /* the cached parentKID is NULL */
            {
                *f_pfHasParentLink = FALSE;
            }
            else
            {
                MEMCPY(f_pparentKID, &(f_pcontextLQ->rgCacheSlots[iSlot].parentKID), SIZEOF(DRM_KID));
            }

            fResult = TRUE;
            break;
        }
    }

    return fResult;
}



/*****************************************************************************
** Function :   _LoadNextLicense
** Synopsis :   Load next license to memory
** Arguments :
** Returns :    DRM_SUCCESS if next license can be loaded
**              DRM_S_FALSE otherwise
** Notes :
** Algorithm :
*/
static DRM_RESULT _LoadNextLicense(
    IN OUT DRM_VIEW_RIGHTS_CONTEXT *f_pcontextLQ,
    IN OUT DRM_DST                 *f_pDatastore,
    IN     DRM_DWORD                f_dwChainDepth,
       OUT DRM_BOOL                *f_pFromCache,
       OUT DRM_LID                 *f_pLID,
       OUT DRM_BOOL                *f_pfHasParentLink,
       OUT DRM_KID                 *f_pparentKID,
       OUT DRM_DWORD               *f_rgLicResult,
       OUT DRM_DWORD               *f_pdwUplinkVector,
       OUT LicenseInfo             *f_rgLiceInfo )
{
    DRM_RESULT dr     = DRM_SUCCESS;
    DRM_DWORD  cbSize = f_pcontextLQ->cbBuffer;
    DRM_KID    kid;
    DRM_BYTE   rgbPassword [__CB_DECL(DRM_SHA1_DIGEST_LEN)];
    DRM_CONST_STRING dstrUplinkKID = EMPTY_DRM_STRING;
    DRM_DST_SLOT_HINT slotHint = {0};

    /* get next license LID */
    ChkDR(DRM_LST_EnumNext(f_pcontextLQ->rgpLicQueryContext[f_dwChainDepth], &kid, f_pLID, &slotHint, &cbSize));

    /* try load licinfo of "f_pLID" from cache if not LEAF license */
    if( f_dwChainDepth > 0 )
    {
        if( _GetLicResultCache(f_pcontextLQ, f_pLID, f_pfHasParentLink, f_pparentKID, f_rgLicResult, f_pdwUplinkVector, f_rgLiceInfo) )
        {
            *f_pFromCache = TRUE;
            goto ErrorExit;
        }
    }

    /*
    ** Reset the stack by setting the stack top to 0, effectively clear everything on the stack.
    **
    ** Waning: Any existing data on the stack will be lost due to the reset of the stack stop.
    **         The caller should make sure that any existing data on the stack can be safely
    **         discarded.
    */
    f_pcontextLQ->stack.nStackTop = 0;
    f_pcontextLQ->pbCurrentLicenseBuff = NULL;

    ChkDR(DRM_STK_Alloc( &f_pcontextLQ->stack, cbSize, (DRM_VOID **)&f_pcontextLQ->pbCurrentLicenseBuff));


    /* load next license in memory */
    ChkDR(DRM_LST_GetLicense(f_pcontextLQ->pActiveLicStore, &kid, f_pLID, &slotHint, f_pcontextLQ->pbCurrentLicenseBuff, &cbSize));

    if( f_pcontextLQ->fCurrentLicenseIsXML )
    {
        /* setup DSTR for XML license */
        DSTR_FROM_PB(&f_pcontextLQ->pLicEval->dstrContentLicense, f_pcontextLQ->pbCurrentLicenseBuff, cbSize);
    }
    else
    {
        /*
        ** crack the XMR license
        */
        ChkDR( DRM_XMR_UnpackLicense( f_pcontextLQ->pbCurrentLicenseBuff,
                                      cbSize,
                                     &f_pcontextLQ->stack,
                                     &f_pcontextLQ->licXMR ) );
    }

    f_pcontextLQ->pLicEval->fUseCachedAttribs = FALSE;
    MEMCPY( f_pcontextLQ->pLicEval->LID.rgb, f_pLID->rgb, SIZEOF(f_pLID->rgb) );

    /* Talk to blackbox to get the secure store password for this license */

    ChkDR(DRM_SST_CreateLicenseStatePassword(f_pLID, rgbPassword, f_pcontextLQ->pBBContext));
    dr = DRM_SST_OpenKeyTokens( f_pcontextLQ->pbLIDSecStore,
                               &f_pcontextLQ->pLicEval->LID,
                                NULL,
                                rgbPassword,
                                0,
                                SECURE_STORE_LICENSE_DATA,
                                f_pDatastore );

    /* get parent uplink KID, if any */
    *f_pfHasParentLink = FALSE;
    if( f_pcontextLQ->fCurrentLicenseIsXML )
    {
        if( DRM_LIC_GetAttribute( &f_pcontextLQ->pLicEval->dstrContentLicense,
                                   NULL,
                                   DRM_LICENSE_ATTRIB_CHAINEDKID,
                                   NULL,
                                  &dstrUplinkKID,
                                   0) == DRM_SUCCESS )
        {
            *f_pfHasParentLink = TRUE;
            DRM_UTL_DecodeKID( &dstrUplinkKID, f_pparentKID );
        }
    }
    else
    {
        if( XMR_IS_UPLINK_KID_VALID( &f_pcontextLQ->licXMR ) )
        {
            *f_pfHasParentLink = TRUE;
            DRM_BYT_CopyBytes( f_pparentKID->rgb,
                               0,
                               f_pcontextLQ->licXMR.containerOuter.containerKeys.UplinkKid.pbguidUplinkKID,
                               f_pcontextLQ->licXMR.containerOuter.containerKeys.UplinkKid.iguidUplinkKID,
                               SIZEOF( f_pparentKID->rgb ) );
        }
    }

ErrorExit:
    return dr;
}


/*****************************************************************************
** Function :   _IsLicenseSelectable
** Synopsis :   Check if the license is selectable / valid
** Arguments :
** Returns :    DRM_SUCCESS if license can be selected
**              DRM_S_FALSE otherwise
** Notes :
** Algorithm :
*/
static DRM_RESULT _IsLicenseSelectable(
    IN OUT DRM_LICSTOREENUM_CONTEXT *f_pcontextLIC,
    IN OUT DRM_VIEW_RIGHTS_CONTEXT  *f_pcontextLQ,
    IN OUT DRM_DST                  *f_pDatastore,
    IN     DRM_BOOL                  f_fDeleteExpiredLicenses,
       OUT DRM_BOOL                 *f_pLicenseDeleted )
{
    DRM_RESULT dr      = DRM_SUCCESS;
    DRM_BOOL   fSelect = FALSE;

    f_pcontextLQ->pLicEval->pcontextSSTLicense      = f_pcontextLQ->pbLIDSecStore;
    f_pcontextLQ->pLicEval->pcontextSSTGlobal       = f_pcontextLQ->pbGlobalSecStore;
    f_pcontextLQ->pLicEval->fGlobalSecStoreWritable = FALSE;
    f_pcontextLQ->pLicEval->dwFlags                 = LICEVAL_VERIFY_IGNORE_VERIFICATION;
    f_pcontextLQ->pLicEval->fReserved               = 0;
    DRM_LEVL_PerformOperations( f_pcontextLQ->pLicEval,
                                DRM_LICENSE_EVAL_SELECT,
                                DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                NULL,
                               &fSelect,
                                NULL,
                                f_pDatastore,
                                NULL,
                                NULL );

    if( fSelect )
    {
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }

    /* skip this license if cannot be selected, expired, etc */
    if( f_fDeleteExpiredLicenses )
    {
        /*
        **  We need to make sure that the reason for failure is set correctly.
        **  This is a workaround to compensate for the fact that v9
        **  licenses do not set the reason correctly sometimes.
        */
        if( f_pcontextLQ->pLicEval->lReasonForFail == 0 )
        {
            /* No reason given by license. Try parsing to get the reason, if we can. */
            (void) DRM_LEVL_GetLicenseReasonForUnusable( f_pcontextLQ->pLicEval,
                                                        &f_pcontextLQ->pLicEval->lReasonForFail );
        }

        if( f_pcontextLQ->pLicEval->lReasonForFail == LR_LICENSE_EXPIRED
          || f_pcontextLQ->pLicEval->fDeleteLicense )
        {
            /* License is expired. Let's delete it. */
#if DRM_SUPPORT_DELETEDSTORE
            (void) DRM_LST_EnumDeleteAndSaveDate( f_pcontextLIC, TRUE );
#else
            (void) DRM_LST_EnumDelete( f_pcontextLIC );
#endif
            *f_pLicenseDeleted = TRUE;
            dr = DRM_S_FALSE;
            goto ErrorExit;
        }
    }

    if( f_pcontextLQ->pLicEval->lReasonForFail == LR_LICENSE_EXPIRED
     || f_pcontextLQ->pLicEval->lReasonForFail == LR_LICENSE_NOSAP
     || f_pcontextLQ->pLicEval->lReasonForFail == LR_LICENSE_NOSVP
     || f_pcontextLQ->pLicEval->lReasonForFail == LR_LICENSE_NOWDM
     || f_pcontextLQ->pLicEval->lReasonForFail == LR_LICENSE_NEED_UPGRADE_MSSAP
     || f_pcontextLQ->pLicEval->lReasonForFail == LR_LICENSE_INVALID_APPLICATION )
    {
        dr = DRM_S_FALSE;
    }

ErrorExit:
    return dr;
}


/* return FALSE if the license cannot be used */
static DRM_BOOL _EvalCurrLicforCandoActions(
    IN OUT                          DRM_VIEW_RIGHTS_CONTEXT *f_pcontextLQ,
    IN OUT                          DRM_DST                 *f_pDatastore,
    IN                              DRM_DWORD                f_cActions,
    __in_ecount(f_cActions)   const DRM_CONST_STRING        *f_rgpdstrAction[],
    IN                              DRM_BOOL                 f_fHasParentLink,
    __out_ecount(f_cActions)        DRM_DWORD                f_rgAggrResults[],
    __out_ecount(f_cActions)        DRM_DWORD                f_rgLicResult[],
       OUT                          DRM_DWORD               *f_pdwUpSearchVector )
{
          DRM_RESULT        dr                  = DRM_SUCCESS;
          DRM_BOOL          fCanDo              = FALSE;
          DRM_DWORD         iAction             = f_cActions;
    const DRM_CONST_STRING *pdstrRightUsed      = NULL;

#if DRM_SUPPORT_PMLICENSE
          DRM_BOOL          fUpdateWithPMExpiry = FALSE;
#endif

    *f_pdwUpSearchVector = 0;

    /* get right for each action */
    if (iAction > 0)
    {
        do  /* This loop iterates backwards from (f_cActions-1) through 0. */
        {
            DRM_BOOL    fNoRight  = FALSE;
#if DRM_SUPPORT_PMLICENSE
            DRMFILETIME ft;
#endif

            iAction--;

            /* this action already has right, skip to next */
            if( f_rgAggrResults[iAction] == DRM_LICQUERY_SATISFIED )
            {
                continue;
            }

            /* see if we have right for this action requested */
            dr = _QueryRightForCandoAction( f_rgpdstrAction[iAction],
                                            f_pcontextLQ,
                                            f_pDatastore,
#if DRM_SUPPORT_PMLICENSE
                                           &fUpdateWithPMExpiry,
#endif
                                           &pdstrRightUsed );
            if( DRM_FAILED( dr ) || ( pdstrRightUsed == NULL ) )
            {
                f_rgLicResult[iAction] |= DRM_LICQUERY_NOT_ENABLED_NO_RIGHT;
                continue;   /* no possible right for action, try next */
            }
            /*
            ** If _QueryRightForCandoAction returns DRM_S_FALSE and still
            ** sets pdstrRightUsed, then the license might have
            ** allowed the action but is expired, out of counts, etc.
            ** There's no way we're going to return DRM_LICQUERY_SATISFIED
            ** in this case, but we're hoping to return something more detailed
            ** than just DRM_LICQUERY_NOT_ENABLED_NO_RIGHT.
            ** So, set fNoRight to indicate that we should fall back to
            ** DRM_LICQUERY_NOT_ENABLED_NO_RIGHT even if everything else succeeds.
            */
            if( dr == DRM_S_FALSE )
            {
                fNoRight = TRUE;
            }

#if DRM_SUPPORT_PMLICENSE
            /* Check PM Expiry, if it is relevant. */
            if( fUpdateWithPMExpiry )
            {
                if( f_pcontextLQ->pLicEval->PMExpiryDate.wYear == 9999 )
                {
                    _InitInfDate( &ft );
                }
                else
                {
                    if( !Oem_Clock_SystemTimeToFileTime( &f_pcontextLQ->pLicEval->PMExpiryDate, &ft ) )
                    {
                        /* If unable to convert, just treat as expired */
                        f_rgLicResult[iAction] |= DRM_LICQUERY_NOT_ENABLED_EXPIRED;
                        continue;
                    }
                }

                if( _IsExpired( f_pcontextLQ->pBBContext->pOEMContext, &ft ) )
                {
                    f_rgLicResult[iAction] |= DRM_LICQUERY_NOT_ENABLED_EXPIRED;
                    continue;
                }
            }
#endif  /* DRM_SUPPORT_PMLICENSE */

            /*
            ** The right is or was allowed.
            ** Let us now check if the license can be used on this machine.
            */
            dr = _UseRightForCandoAction( f_pcontextLQ,
                                          f_rgpdstrAction[iAction],
                                          pdstrRightUsed,
#if DRM_SUPPORT_PMLICENSE
                                          fUpdateWithPMExpiry,
                                         &ft,
#endif
                                         &f_rgLicResult[iAction] );
            if( dr != DRM_SUCCESS)
            {
                continue;
            }

            if( fNoRight )
            {
                /*
                ** Well, _UseRightForCandoAction didn't give us better info
                ** about why we couldn't use the right, so fall back to
                ** DRM_LICQUERY_NOT_ENABLED_NO_RIGHT.
                */
                f_rgLicResult[iAction] |= DRM_LICQUERY_NOT_ENABLED_NO_RIGHT;
                continue;
            }

            /* everything is fine. Check if this is end of chain */
            f_rgLicResult[iAction] = DRM_LICQUERY_SATISFIED;
            if( f_fHasParentLink )
            {
                *f_pdwUpSearchVector |= (1 << iAction);  /* include this for uplink (parent) search */
            }

            fCanDo = TRUE;
        }while (iAction > 0);
    }
    return fCanDo;
}


/*****************************************************************************
** Function :   _QueryRightForCandoActions
** Synopsis :   Find V2/V3 license for requested actions
**              - all licenses for given KID are scanned, or
**              - when all actions are satisfied.
** Arguments :
** Returns :    DRM_SUCCESS if no error, otherwise, specific error code is returned
** Notes :
** Algorithm :
**    FindRightForActions(Env,KID,cAction,rgActions[],rgResults[],rgfInclude[],dwChainDepth)
**    {
**        DRM_BOOL _rgfInclude[];
**        For each license of KID
**        {
**            if  !( license is selectable ) || !( license is not expired ) then
**                continue;
**
**            parentKID = GetParentLink();
**            For (action i to N)
**            {
**                if( rgResults[i].Satisfied ) or ( !rgfInclude[i] ) then
**                    contimue;
**
**                RightUsed = GetRightForAction()
**                if( RightUsed == NULL ) then
**                    continue;
**
**                use_right(rgAction[i], RightUsed);
**
**                if( parentKID == NULL )
**                    rgResults[i].Satisfied = TRUE;
**                else
**                    _rgfInclude[i] = TRUE;
**            }
**
**            if(_rgfInclude[] not empty) and (parentKID != NULL) then
**            {
**                // call recursively for parent license
**                FindRightForActions(Env,parentKID,cAction,rgActions[],rgResults[],_rgfInclude[i],dwChainDepth+1);
**            }
**            if(all actions are satisfied) then
**                break;
**        }
**    }
*/
static DRM_RESULT _QueryRightForCandoActions(
    IN OUT   DRM_VIEW_RIGHTS_CONTEXT *f_pcontextLQ,
    IN OUT   DRM_DST                 *f_pDatastore,
    IN       DRM_BOOL                 f_fDeleteExpiredLicenses,
    IN       DRM_KID                 *f_pKID,
    IN       DRM_DWORD                f_dwSearchVector,
    IN       DRM_DWORD                f_dwChainDepth,
    IN       DRM_DWORD                f_cActions,
    IN const DRM_CONST_STRING        *f_rgpdstrAction[],
       OUT   DRM_BOOL                *f_pfLicFound,
       OUT   DRM_BOOL                *f_pfRecentExpired,
       OUT   DRM_DWORD                f_rgAggrResults[] )
{
    DRM_RESULT  dr                  = DRM_SUCCESS;
    DRM_DWORD   dwUpSearchVector    = 0;
    DRM_DWORD   iAction             = 0;
    DRM_BOOL    fLicenseDeleted     = FALSE;
    DRM_BOOL    fAllDone            = FALSE;
    DRM_BOOL    fHasParentLink      = FALSE;
    DRM_BOOL    fParentLinkExists   = FALSE;
    DRM_BOOL    fFromCache          = FALSE;
    DRM_BOOL    fHasRight           = FALSE;
    DRM_KID     kidParent           = {0};
    DRM_LID     lid                 = {0};
    DRM_DWORD   rgLicResult[DRM_MAX_RIGHTS_SUPPORTED];

    ChkArg( f_pfLicFound      != NULL
         && f_pfRecentExpired != NULL
         && f_cActions        <= DRM_MAX_RIGHTS_SUPPORTED
         && f_cActions         > 0);

    /* Terminating condition: check chaining depth */
    if( f_dwChainDepth >= f_pcontextLQ->dwLicChainDepth  ||  f_dwChainDepth >= DRM_MAX_LICENSE_CHAIN_DEPTH )
    {
        iAction = f_cActions;
        do   /* This loop iterates backwards from (f_cActions-1) through 0. */
        {
            iAction--;
            if( (f_dwSearchVector & (1 << iAction)) != 0 )
            {
                f_rgAggrResults[iAction] |= DRM_LICQUERY_NOT_ENABLED_CHAIN_DEPTH_TOO_HIGH;
            }
        } while (iAction > 0);
        goto ErrorExit;   /* exceeding max license chain depth, we are done */
    }

#if DRM_SUPPORT_DELETEDSTORE
    /* Check for recently expired non-leaf licenses */
    if( f_dwChainDepth > 0 )
    {
        ChkDR( _CheckRecentExpired( f_pcontextLQ->pBBContext->pOEMContext,
                                    f_pDatastore,
                                    f_pKID,
                                    f_pfRecentExpired ) );
        /*
        ** A recently expired uplink license counts as "finding" a license
        ** since we want to return "expired" but not "no uplink"
        */
        *f_pfLicFound = *f_pfLicFound || *f_pfRecentExpired;
    }
#endif

    /* init enum license for given KID */
    ChkDR(DRM_LST_InitEnum(f_pcontextLQ->pActiveLicStore, f_pKID, TRUE, f_pcontextLQ->rgpLicQueryContext[f_dwChainDepth]));
    while (!fAllDone)  /* try each license equals to KID until all done */
    {
        /* init temp result and cache LID */
        iAction = f_cActions;
        do   /* This loop iterates backwards from (f_cActions-1) through 0. */
        {
            iAction--;
            rgLicResult[iAction] = DRM_LICQUERY_NOT_ENABLED;
        } while (iAction > 0);
    	
        dr = _LoadNextLicense(f_pcontextLQ, f_pDatastore, f_dwChainDepth, &fFromCache, &lid, &fHasParentLink, &kidParent, rgLicResult, &dwUpSearchVector, NULL);
        if( dr != DRM_SUCCESS )
        {
            /* No more licenses - we're done. */
            dr = DRM_SUCCESS;
            goto ErrorExit;
        }

        /* Found a license */
        *f_pfLicFound = TRUE;

        if( !fFromCache )  /* no cached value found */
        {
            /* Is the license selectable or expired? */
            dr = _IsLicenseSelectable(f_pcontextLQ->rgpLicQueryContext[f_dwChainDepth],f_pcontextLQ,f_pDatastore,f_fDeleteExpiredLicenses,&fLicenseDeleted);
            if( dr != DRM_SUCCESS
             || fLicenseDeleted
             || _IsLicenseExpired(f_pcontextLQ, f_pcontextLQ->pbLIDSecStore) )
            {
                iAction = f_cActions;
                do   /* This loop iterates backwards from (f_cActions-1) through 0. */
                {
                    iAction--;
                    if( (f_dwSearchVector & (1 << iAction)) != 0 )
                    {
                        f_rgAggrResults[iAction] |= DRM_LICQUERY_NOT_ENABLED_EXPIRED;
                    }
                } while (iAction > 0);
                continue;
            }

            /* get right for each action from current license */
            fHasRight = _EvalCurrLicforCandoActions( f_pcontextLQ,
                                                     f_pDatastore,
                                                     f_cActions,
                                                     f_rgpdstrAction,
                                                     fHasParentLink,     /* TRUE if parent exists */
                                                     f_rgAggrResults,
                                                     rgLicResult,
                                                    &dwUpSearchVector ); /* bit vector for corresponding action to search for parent link */

            /* cache LID and parentKID */
            if( fHasRight  &&  f_dwChainDepth > 0 )
            {
                /* add rgLicResult and rgLicInfo to cache */
                _AddLicResultCache(f_pcontextLQ, &lid, fHasParentLink, &kidParent, rgLicResult, dwUpSearchVector, NULL);
            }
        }

        /* aggregate the result from license */
        iAction = f_cActions;
        do   /* This loop iterates backwards from (f_cActions-1) through 0. */
        {
            iAction--;
            if( rgLicResult[iAction] == DRM_LICQUERY_SATISFIED  )
            {
                if( !fHasParentLink                                /* fHasParentLink == FALSE if this is the end of the chain */
                 && ( (f_dwSearchVector & (1 << iAction)) != 0 ) ) /* this bit is 'ON' when the leaf has right for action */
                {
                    /* only set this to satisfied when this license is end of the chain
                       and the leaf license has the right for action */
                    f_rgAggrResults[iAction] = DRM_LICQUERY_SATISFIED;
                }
            }
            else if( f_rgAggrResults[iAction] != DRM_LICQUERY_SATISFIED )
            {
                f_rgAggrResults[iAction] |= rgLicResult[iAction];
            }
        } while (iAction > 0);

        if( !fHasRight )
        {
            continue;
        }

        if( dwUpSearchVector != 0  &&  fHasParentLink )
        {
            /* call recursively for parent link search */
            _QueryRightForCandoActions( f_pcontextLQ,
                                        f_pDatastore,
                                        FALSE,  /* do not perform delete on parent link */
                                       &kidParent,
                                        dwUpSearchVector,      /* bit vector for corresponding action to search for parent link */
                                        f_dwChainDepth+1,
                                        f_cActions,
                                        f_rgpdstrAction,
                                       &fParentLinkExists,
                                        f_pfRecentExpired,
                                        f_rgAggrResults );

            if( !fParentLinkExists )
            {
                iAction = f_cActions;
                do   /* This loop iterates backwards from (f_cActions-1) through 0. */
                {
                    iAction--;
                    if( f_rgAggrResults[iAction] != DRM_LICQUERY_SATISFIED )
                    {
                        f_rgAggrResults[iAction] |= DRM_LICQUERY_NOT_ENABLED_NO_UPLINK;
                    }
                } while (iAction > 0);
            }
        }

        dwUpSearchVector = 0;   /* reset for next round of parent search */

        /* check if we are done */
        fAllDone = TRUE;
        iAction = f_cActions;
        do   /* This loop iterates backwards from (f_cActions-1) through 0. */
        {
            iAction--;
            if( f_rgAggrResults[iAction] != DRM_LICQUERY_SATISFIED )
            {
                fAllDone = FALSE;
                break;
            }
        } while (iAction > 0);
    }

ErrorExit:
    return dr;
}



static DRM_RESULT _QueryRightForAction(
    IN const DRM_CONST_STRING        *f_dstrAction,
    IN OUT   DRM_VIEW_RIGHTS_CONTEXT *f_pcontextLQ,
    IN OUT   DRM_DST                 *f_pDatastore,
#if DRM_SUPPORT_PMLICENSE
       OUT   DRM_BOOL                *f_pfUpdateWithPMExpiry,
#endif
       OUT   DRM_CONST_STRING const **f_ppdstrActionUsed )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BOOL   fCanPerform    = FALSE;
    DRM_BOOL   fActionExisted = FALSE;

    *f_ppdstrActionUsed = f_dstrAction;

#if DRM_SUPPORT_PMLICENSE
#ifndef PDDRM_COPYOPL
#define PDDRM_COPYOPL 300
#endif /* PDDRM_COPYOPL */
    /*
    ** XMR license does not hace PMRights, but PerformOperations will
    **  "fall-forward" to the "copy" right.
    ** Only allow this "fall-forward" if OPLs are appropriate for PDRM.
    */
    if( f_pcontextLQ->fCurrentLicenseIsXML
     || !XMR_IS_COPYPROTECTIONLEVEL_VALID( f_pcontextLQ->pLicEval->plicenseXMR )
     || f_pcontextLQ->pLicEval->plicenseXMR->containerOuter.containerCopyPolicies.CopyProtectionLevel.wValue <= PDDRM_COPYOPL )
    {
        if( DRM_UTL_DSTRStringsEqual(f_dstrAction, &g_dstrWMDRM_RIGHT_COPY_TO_SDMI_DEVICE ) )
        {
            dr = DRM_LEVL_PerformOperations( f_pcontextLQ->pLicEval,
                                             DRM_LICENSE_EVAL_ACTION,
                                             DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                            &g_dstrCreatePMLicense,
                                            &fCanPerform,
                                             NULL,
                                             f_pDatastore,
                                             NULL,
                                             NULL );

            /* Check if the pmlicence data supports the required action */
            if( dr == DRM_SUCCESS
             && fCanPerform
             && _HaveRightsLong( RIGHT_COPY_TO_SDMI_DEVICE, f_pcontextLQ->pLicEval->lPMRights ) )
            {
                /* XMR licenses don't have PMExpiry */
                if( f_pcontextLQ->fCurrentLicenseIsXML )
                {
                    *f_pfUpdateWithPMExpiry = TRUE;
                }
                else
                {
                    /*
                    ** XMR licenses must have done a "fall-forward" to the "copy" right
                    ** Here's what's going on:
                    ** DRM_LEVL_PerformOperations has logic to "fall-forward" from
                    **  the "SDMI" rights to the "Copy" right.
                    ** This will occur on all XMR licenses since "SDMI" rights
                    **  are not supported on them.
                    ** Problem: This codepath needs to know what right was actually
                    **  USED to allow the action.
                    ** Otherwise, it's unable to get the counts for that action later.
                    ** Hence, when we're dealing with an XMR license,
                    **  we assume that "SDMI" rights used the "fall-forward" logic.
                    */
                    *f_ppdstrActionUsed = &g_dstrWMDRM_RIGHT_COPY;
                }
                goto ErrorExit;
            }
        }
        else if( DRM_UTL_DSTRStringsEqual( f_dstrAction, &g_dstrWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE ) )
        {
            dr = DRM_LEVL_PerformOperations( f_pcontextLQ->pLicEval,
                                             DRM_LICENSE_EVAL_ACTION,
                                             DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                            &g_dstrCreatePMLicense,
                                            &fCanPerform,
                                             NULL,
                                             f_pDatastore,
                                             NULL,
                                             NULL);

            /* Check if the pmlicence data supports the required action */
            if( dr == DRM_SUCCESS
             && fCanPerform
             && _HaveRightsLong(RIGHT_COPY_TO_NONSDMI_DEVICE, f_pcontextLQ->pLicEval->lPMRights))
            {
                /* XMR licenses don't have PMExpiry */
                if( f_pcontextLQ->fCurrentLicenseIsXML )
                {
                    *f_pfUpdateWithPMExpiry = TRUE;
                }
                else
                {
                    /*
                    ** XMR licenses must have done a "fall-forward" to the "copy" right
                    ** Here's what's going on:
                    ** DRM_LEVL_PerformOperations has logic to "fall-forward" from
                    **  the "SDMI" rights to the "Copy" right.
                    ** This will occur on all XMR licenses since "SDMI" rights
                    **  are not supported on them.
                    ** Problem: This codepath needs to know what right was actually
                    **  USED to allow the action.
                    ** Otherwise, it's unable to get the counts for that action later.
                    ** Hence, when we're dealing with an XMR license,
                    **  we assume that "SDMI" rights used the "fall-forward" logic.
                    */
                    *f_ppdstrActionUsed = &g_dstrWMDRM_RIGHT_COPY;
                }
                goto ErrorExit;
            }
        }
    }

#endif /* DRM_SUPPORT_PMLICENSE */
    dr = DRM_LEVL_PerformOperations( f_pcontextLQ->pLicEval,
                                     DRM_LICENSE_EVAL_ACTION,
                                     DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                     f_dstrAction,
                                    &fCanPerform,
                                    &fActionExisted,
                                     f_pDatastore,
                                     NULL,
                                     NULL );
    if( dr == DRM_SUCCESS && fCanPerform )
    {
        /* XMR licenses must have done a "fall-forward" to the "playlist burn" right */
#if DRM_SUPPORT_PLAYLIST_BURN
        if( !f_pcontextLQ->fCurrentLicenseIsXML
         && DRM_UTL_DSTRStringsEqual( f_dstrAction, &g_dstrWMDRM_RIGHT_COPY_TO_CD ) )
        {
            /*
            ** Here's what's going on:
            ** DRM_LEVL_PerformOperations has logic to "fall-forward" from
            **  the "copy to cd" right to the "playlist burn" right.
            ** This will occur on all XMR licenses since "copy to cd"
            **  is not supported on them.
            ** Problem: This codepath needs to know what right was actually
            **  USED to allow the action.
            ** Otherwise, it's unable to get the counts for that action later.
            ** Hence, when we're dealing with an XMR license,
            **  we assume that "copy to cd" used the "fall-forward" logic.
            */
            *f_ppdstrActionUsed = &g_dstrWMDRM_RIGHT_PLAYLIST_BURN;
        }
#endif /* DRM_SUPPORT_PLAYLIST_BURN */
        goto ErrorExit;
    }

#if DRM_SUPPORT_PMLICENSE
    if( f_pcontextLQ->fCurrentLicenseIsXML
     && DRM_UTL_DSTRStringsEqual( f_dstrAction, &g_dstrWMDRM_RIGHT_COPY ) )
    {
        /* The Copy right isn't allowed.  Check for CreatePMLicense */
        dr = DRM_LEVL_PerformOperations( f_pcontextLQ->pLicEval,
                                         DRM_LICENSE_EVAL_ACTION,
                                         DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                        &g_dstrCreatePMLicense,
                                        &fCanPerform,
                                         NULL,
                                         f_pDatastore,
                                         NULL,
                                         NULL);

        /* Check if the pmlicence data supports the required action */
        if( dr == DRM_SUCCESS
         && fCanPerform
         && ( _HaveRightsLong( RIGHT_COPY_TO_SDMI_DEVICE,    f_pcontextLQ->pLicEval->lPMRights )
           || _HaveRightsLong( RIGHT_COPY_TO_NONSDMI_DEVICE, f_pcontextLQ->pLicEval->lPMRights ) ) )
        {
            *f_ppdstrActionUsed = &g_dstrWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE;
            *f_pfUpdateWithPMExpiry = TRUE;
        }
    }
#endif /* DRM_SUPPORT_PMLICENSE */

#if DRM_SUPPORT_PLAYLIST_BURN
#if DRM_SUPPORT_PMLICENSE
    else
#endif /* DRM_SUPPORT_PMLICENSE */
    if( !fActionExisted
     && DRM_UTL_DSTRStringsEqual( f_dstrAction, &g_dstrWMDRM_RIGHT_PLAYLIST_BURN ) )
    {
        /*
        ** Ideally, we'd only fallback from PLAYLIST_BURN to COPY_TO_CD
        ** if the MaxPlaylistBurnCount for the playlist were not set.
        ** That's exactly what the playlist object does for decrypt.
        ** However, we're doing query now, and we don't HAVE a playlist.
        ** We can't get this information, but we can make a best effort.
        ** So, we always fallback from PLAYLIST_BURN to COPY_TO_CD if we
        ** didn't find the PLAYLIST_BURN right in the license.
        */
        dr = DRM_LEVL_PerformOperations( f_pcontextLQ->pLicEval,
                                         DRM_LICENSE_EVAL_ACTION,
                                         DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                        &g_dstrWMDRM_RIGHT_COPY_TO_CD,
                                        &fCanPerform,
                                         NULL,
                                         f_pDatastore,
                                         NULL,
                                         NULL);
        if( dr == DRM_SUCCESS  &&  fCanPerform )
        {
            *f_ppdstrActionUsed = &g_dstrWMDRM_RIGHT_COPY_TO_CD;
        }
    }

    /*
    ** Fallback (fall"forward"?) from COPY_TO_CD to PLAYLIST_BURN is
    ** handled by the XMR codepath in DRM_LEVL_PerformOperations.
    ** Per spec, we only want to fallback in the XMR case.
    ** So, do not fallback here.
    */
#if 0
    else if( !fActionExisted
          && DRM_UTL_DSTRStringsEqual( f_dstrAction, &g_dstrWMDRM_RIGHT_COPY_TO_CD ) )
    {
        /* Print.Redbook doesn't exist in this license.  Look for a Playlist burn right */
        dr = DRM_LEVL_PerformOperations( f_pcontextLQ->pLicEval,
                                         DRM_LICENSE_EVAL_ACTION,
                                         DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                        &g_dstrWMDRM_RIGHT_PLAYLIST_BURN,
                                        &fCanPerform,
                                         NULL,
                                         f_pDatastore );
        if( dr == DRM_SUCCESS  &&  fCanPerform )
        {
            *f_ppdstrActionUsed = &g_dstrWMDRM_RIGHT_PLAYLIST_BURN;
        }
    }
#endif /* 0 */
#endif  /* DRM_SUPPORT_PLAYLIST_BURN */

ErrorExit:

    return fCanPerform? DRM_SUCCESS : DRM_S_FALSE;
}

/* return FALSE if the license cannot be used */
static DRM_BOOL _CollectLicStateforRequestedActions(
    IN OUT   DRM_VIEW_RIGHTS_CONTEXT *f_pcontextLQ,
    IN OUT   DRM_DST                 *f_pDatastore,
    IN       DRM_DWORD                f_cActions,
    IN const DRM_CONST_STRING* const  f_rgpdstrAction[],
    IN       DRM_BOOL                 f_fHasParentLink,
       OUT   LicenseInfo              f_rgLicinfo[],
    IN       DRMPFNPOLICYCALLBACK       f_pfnPolicyCallback,
    IN const DRM_VOID                *f_pv)
{
    DRM_RESULT              dr                  = DRM_SUCCESS;
    DRM_DWORD               iAction             = f_cActions;
    DRM_BOOL                fHasRights          = FALSE;
    const DRM_CONST_STRING *pdstrRightUsed      = NULL;
    DRM_CONST_STRING        dstrRestriction     = EMPTY_DRM_STRING;
    DRM_XMR_UNKNOWN_OBJECT *pExtRestrictLoop    = NULL;
    DRM_WORD                wRightID            = XMR_OBJECT_TYPE_INVALID;
#if DRM_SUPPORT_PMLICENSE
    DRM_BOOL                fUpdateWithPMExpiry = FALSE;
#endif

    /* get right for each action */
    if (iAction > 0)
    {
        do  /* This loop iterates backwards from (f_cActions-1) through 0. */
        {
            iAction--;
            ZEROMEM( &f_rgLicinfo[iAction], SIZEOF( LicenseInfo ) );

            if( _QueryRightForAction( f_rgpdstrAction[iAction],
                                      f_pcontextLQ,
                                      f_pDatastore,
#if DRM_SUPPORT_PMLICENSE
                                     &fUpdateWithPMExpiry,
#endif
                                     &pdstrRightUsed ) != DRM_SUCCESS )
            {
                continue;   /* no right for this action, try next one */
            }

            /* The right is allowed. Let us now check if the license can be used on this machine. */
            if( _GetV2LicenseInfo( f_pcontextLQ,
                                  &f_pcontextLQ->pLicEval->dstrContentLicense,
                                  &f_rgLicinfo[iAction],
                                   pdstrRightUsed,
                                   f_pcontextLQ->pbLIDSecStore ) != DRM_SUCCESS )
            {
                continue;   /* nope! */
            }

#if DRM_SUPPORT_PMLICENSE
            /* Check PM Expiry, if it is relevant. */
            if( fUpdateWithPMExpiry )
            {
                DRMFILETIME ft;

                if( !Oem_Clock_SystemTimeToFileTime( &f_pcontextLQ->pLicEval->PMExpiryDate, &ft ) )
                {
                    /* If unable to convert, just treat as expired */
                    continue;
                }

                if( f_pcontextLQ->pLicEval->PMExpiryDate.wYear == 9999 )
                {
                    _InitInfDate( &ft );
                }

                if( _IsExpired(f_pcontextLQ->pBBContext->pOEMContext, &ft) )
                {
                    continue;
                }

                if( DRM_UTL_DateLessThan( &ft, &f_rgLicinfo[iAction].endDate ) )
                {
                    f_rgLicinfo[iAction].endDate = ft;
                }
            }
#endif /* DRM_SUPPORT_PMLICENSE */

            fHasRights = TRUE;

            if( f_pcontextLQ->fCurrentLicenseIsXML )
            {
                DRM_DWORD cbSize = 0;

                dr = DRM_LIC_GetEvent( &f_pcontextLQ->pLicEval->dstrContentLicense,
                                       &g_dstrLicEvalOnAction,
                                        pdstrRightUsed,
                                        NULL,
                                        NULL,
                                        NULL,
                                       &dstrRestriction );
                if( (dr == DRM_SUCCESS) && (dstrRestriction.cchString > 0) )
                {
                    f_rgLicinfo[iAction].fHasOPLs = TRUE;
                }

                DRM_ASD_ParseV2License( &f_pcontextLQ->pLicEval->dstrContentLicense,
                                        &g_dstrDRM_LS_SAP_ATTR,
                                        &cbSize,
                                         NULL );
                if( cbSize > 0 )
                {
                    f_rgLicinfo[iAction].fRequiresSAP = TRUE;
                }
            }
            else if( DRM_UTL_DSTRStringsEqual( f_rgpdstrAction[iAction], &g_dstrWMDRM_RIGHT_COPY )
#if DRM_SUPPORT_PMLICENSE
                  || DRM_UTL_DSTRStringsEqual( f_rgpdstrAction[iAction], &g_dstrWMDRM_RIGHT_COPY_TO_SDMI_DEVICE )
                  || DRM_UTL_DSTRStringsEqual( f_rgpdstrAction[iAction], &g_dstrWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE )
#endif
                  )
            {
                wRightID = XMR_OBJECT_TYPE_COPY_POLICY_CONTAINER;
                
                if( XMR_IS_COPYPROTECTIONLEVEL_VALID(&f_pcontextLQ->licXMR) )
                {
                    f_rgLicinfo[iAction].fHasOPLs = TRUE;
                }

                if( XMR_IS_COPY_VALID( &f_pcontextLQ->licXMR ) )
                {
                    pExtRestrictLoop = f_pcontextLQ->licXMR.containerOuter.containerCopyPolicies.pUnknownObjects;
                }
            }
            else if( DRM_UTL_DSTRStringsEqual( f_rgpdstrAction[iAction], &g_dstrWMDRM_RIGHT_PLAYBACK )
                  || DRM_UTL_DSTRStringsEqual( f_rgpdstrAction[iAction], &g_dstrWMDRM_RIGHT_COLLABORATIVE_PLAY ) )
            {
                wRightID = XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER;
                
                if( XMR_IS_OPL_VALID( &f_pcontextLQ->licXMR ) )
                {
                    f_rgLicinfo[iAction].fHasOPLs = TRUE;
                }

                if( XMR_IS_PLAY_VALID( &f_pcontextLQ->licXMR ) )
                {
                    pExtRestrictLoop = f_pcontextLQ->licXMR.containerOuter.containerPlaybackPolicies.pUnknownObjects;
                }
            }
#if DRM_SUPPORT_PLAYLIST_BURN
            else if( DRM_UTL_DSTRStringsEqual( f_rgpdstrAction[iAction], &g_dstrWMDRM_RIGHT_PLAYLIST_BURN )
                  || DRM_UTL_DSTRStringsEqual( f_rgpdstrAction[iAction], &g_dstrWMDRM_RIGHT_COPY_TO_CD ) )
            {
                wRightID = XMR_OBJECT_TYPE_ALLOW_PLAYLISTBURN_POLICY_CONTAINER;

                if( XMR_IS_PLAYLISTBURN_VALID( &f_pcontextLQ->licXMR ) )
                {
                    pExtRestrictLoop = f_pcontextLQ->licXMR.containerOuter.containerPlaylistBurnPolicies.pUnknownObjects;
                }  
            }
#endif
            else if( f_pcontextLQ->licXMR.containerOuter.containerUnknown.fValid )
            {
                DRM_LONG lExtObjType = 0;
                
                /* Check if the string they gave is a 16-bit number, if so it would be the
                ** object type of a container that may be an extensible right
                */
                if( DRM_SUCCEEDED( DRMCRT_wcsntol( f_rgpdstrAction[iAction]->pwszString, f_rgpdstrAction[iAction]->cchString, &lExtObjType )
                  && lExtObjType > 0 && lExtObjType <= MAX_UNSIGNED_TYPE( DRM_WORD ) ) )
                {
                    DRM_XMR_UNKNOWN_CONTAINER *pUnknownContainer = &f_pcontextLQ->licXMR.containerOuter.containerUnknown;
                    
                    /* Seems to be a valid object type */

                    while( pUnknownContainer != NULL
                        && pUnknownContainer->fValid )
                    {
                        if( pUnknownContainer->wType == lExtObjType )
                        {
                            /* We found a match */
                            pExtRestrictLoop = pUnknownContainer->pObject;
                            break;
                        }

                        pUnknownContainer = pUnknownContainer->pNext;
                    }
                }

                wRightID = (DRM_WORD)lExtObjType;
            }

            while( pExtRestrictLoop != NULL
                && pExtRestrictLoop->fValid )
            {
                if( ( pExtRestrictLoop->wFlags & XMR_FLAGS_ALLOW_EXTERNAL_PARSE ) != 0 )
                {
                    if( ( pExtRestrictLoop->wFlags & XMR_FLAGS_MUST_UNDERSTAND ) != 0 )
                    {
                        f_rgLicinfo[iAction].fHasMUExtensibleRestrictions = TRUE;
                    }
                    
                    if( f_pfnPolicyCallback != NULL )
                    {
                        DRM_EXTENDED_RESTRICTION_CALLBACK_STRUCT oCallback = {0};
                        
                        /*
                        ** This is likley an extensible rights container.
                        ** Need to pass it up to the app for them to parse.
                        */
                        oCallback.wRightID = wRightID;
                        oCallback.pRestriction = pExtRestrictLoop;
                        oCallback.pXMRLicense = &f_pcontextLQ->licXMR;
                        oCallback.pContextSST = f_pcontextLQ->pbLIDSecStore;

                        f_pfnPolicyCallback( &oCallback, DRM_EXTENDED_RESTRICTION_QUERY_CALLBACK, f_pv );
                    }
                }
                pExtRestrictLoop = pExtRestrictLoop->pNext;
            }
        }while (iAction > 0);
    }

    return fHasRights;
}


static DRM_BOOL _GetRootVariance(
    IN OUT DRM_VIEW_RIGHTS_CONTEXT *f_pcontextLQ,
    IN     DRM_DWORD                f_dwChainDepth,
    IN     DRM_DWORD                f_cRootVariance,
    IN     DRM_KID                 *f_pkidParent,
       OUT DRM_DWORD               *f_piCurrVariance )
{
    DRM_BOOL  fResult = FALSE;
    DRM_DWORD i = 0;

    for (i=0; i<f_cRootVariance && i<DRM_MAX_CHAIN_ROOTVARIANCE_SUPPORT; i++)
    {
        if( MEMCMP(f_pkidParent, &(f_pcontextLQ->rgStack[f_dwChainDepth].rgkidRoot[i]), SIZEOF(DRM_KID)) == 0 )
        {
            *f_piCurrVariance = i;
            fResult = TRUE;
            break;
        }
    }

    if( i < DRM_MAX_CHAIN_ROOTVARIANCE_SUPPORT )
    {
        *f_piCurrVariance = i;
        fResult = TRUE;
    }

    return fResult;
}



static DRM_RESULT _AddRootVariance(
    IN OUT DRM_VIEW_RIGHTS_CONTEXT *f_pcontextLQ,
    IN     DRM_DWORD                f_dwChainDepth,
    IN     DRM_DWORD                f_iCurrVariance,
    IN     DRM_KID                 *f_pkidParent )
{
    DRM_RESULT dr        = DRM_SUCCESS;
    DRM_DWORD  iAction   = 0;

    ChkArg(f_iCurrVariance < DRM_MAX_CHAIN_ROOTVARIANCE_SUPPORT);
    MEMMOVE(&(f_pcontextLQ->rgStack[f_dwChainDepth].rgkidRoot[f_iCurrVariance]), f_pkidParent, SIZEOF(DRM_KID));

    ZEROMEM(f_pcontextLQ->rgStack[f_dwChainDepth].rgRootState[f_iCurrVariance], SIZEOF(DRM_LICENSE_STATE_DATA   ) * DRM_MAX_RIGHTS_SUPPORTED);
    ZEROMEM(f_pcontextLQ->rgStack[f_dwChainDepth].rgLeafState[f_iCurrVariance], SIZEOF(DRM_LICENSE_STATE_DATA   ) * DRM_MAX_RIGHTS_SUPPORTED);
    for ( iAction = 0; iAction < DRM_MAX_RIGHTS_SUPPORTED; iAction++ )
    {
        f_pcontextLQ->rgStack[f_dwChainDepth].rgRootState[f_iCurrVariance][iAction].dwCategory = DRM_LICENSE_STATE_NORIGHT;
        f_pcontextLQ->rgStack[f_dwChainDepth].rgLeafState[f_iCurrVariance][iAction].dwCategory = DRM_LICENSE_STATE_NORIGHT;
    }

ErrorExit:
    return dr;
}


/*****************************************************************************
** Function :   _QueryAndAggregateLicStatesForKID
** Synopsis :   Query and aggregate license state for given KID
** Arguments :
** Returns :    DRM_SUCCESS if no error, otherwise, specific error code is returned
** Notes :      - All licenses for given KID are scanned.
**              - support up to "DRM_MAX_CHAIN_ROOTVARIANCE_SUPPORT" root KID variances
**                per leaf license of same KID.
*/
static DRM_RESULT _QueryAndAggregateLicStatesForKID(
    IN       DRM_KID                  *f_pKID,
    IN       DRM_DWORD                 f_dwAggregationType,
    IN OUT   DRM_VIEW_RIGHTS_CONTEXT  *f_pcontextLQ,
    IN OUT   DRM_DST                  *f_pDatastore,
    IN       DRM_BOOL                  f_fDeleteExpiredLicenses,
    IN       DRM_DWORD                 f_dwChainDepth,
    IN       DRM_DWORD                 f_cActions,
    IN const DRM_CONST_STRING*  const  f_rgpdstrAction[],
       OUT   DRM_LICENSE_STATE_DATA    f_rgStateData[],
     IN       DRMPFNPOLICYCALLBACK     f_pfnPolicyCallback,
    IN const DRM_VOID                 *f_pv)
{
    DRM_RESULT  dr = DRM_SUCCESS;
    DRM_DWORD   iAction          = 0;
    DRM_DWORD   cRootVariance    = 0;
    DRM_DWORD   iCurrVariance    = 0;
    DRM_BOOL    fLicenseDeleted  = FALSE;
    DRM_BOOL    fHasParentLink   = FALSE;
    DRM_BOOL    fFromCache       = FALSE;
    DRM_KID     kidParent        = {0};
    DRM_LID     lid              = {0};
    DRM_BOOL    fUnlimited       = FALSE;

    /* Terminating condition for recursive call: check chaining depth
    ** up to DRM_MAX_LICENSE_CHAIN_DEPTH depth of recursive call
    */
    if( f_dwChainDepth >= f_pcontextLQ->dwLicChainDepth  ||  f_dwChainDepth >= DRM_MAX_LICENSE_CHAIN_DEPTH )
    {
        ChkDR( DRM_E_LIC_CHAIN_TOO_DEEP );  /* exceeding max license chain depth, we are done */
    }

    /* init buffer */
    for ( iAction = 0; iAction < f_cActions; iAction++ )
    {
        f_pcontextLQ->rgStack[f_dwChainDepth].rgStatePri[iAction].dwCategory = DRM_LICENSE_STATE_NORIGHT;
        ZEROMEM(&(f_pcontextLQ->rgStack[f_dwChainDepth].rgkidRoot), SIZEOF(DRM_KID) * DRM_MAX_CHAIN_ROOTVARIANCE_SUPPORT);
    }

    /* init enum license for given KID */
    ChkDR(DRM_LST_InitEnum(f_pcontextLQ->pActiveLicStore, f_pKID, TRUE, f_pcontextLQ->rgpLicQueryContext[f_dwChainDepth]));
    while ( !fUnlimited )  /* try each license equals to KID */
    {    	
        if( _LoadNextLicense( f_pcontextLQ,
                              f_pDatastore,
                              f_dwChainDepth,
                             &fFromCache,
                             &lid,
                             &fHasParentLink,
                             &kidParent,
                              NULL,
                              NULL,
                              f_pcontextLQ->rgLicInfo ) != DRM_SUCCESS )
        {
            dr = DRM_SUCCESS;       /* no more license */
            break;
        }

        if( !fFromCache )  /* no cached value found */
        {
            if( fHasParentLink && !_GetRootVariance(f_pcontextLQ, f_dwChainDepth, cRootVariance, &kidParent, &iCurrVariance) )
            {
                continue;   /* ignore this license if root variance is full */
            }

            /* Is the license selectable or expired? */
            dr = _IsLicenseSelectable(
                    f_pcontextLQ->rgpLicQueryContext[f_dwChainDepth],
                    f_pcontextLQ,
                    f_pDatastore,
                    f_fDeleteExpiredLicenses,
                   &fLicenseDeleted );
            if( dr != DRM_SUCCESS
             || fLicenseDeleted
             || _IsLicenseExpired( f_pcontextLQ, f_pcontextLQ->pbLIDSecStore ) )
            {
                continue;   /* not selectable or expired */
            }

            /* get right for each action from current license */
            if( !_CollectLicStateforRequestedActions( f_pcontextLQ,
                                                      f_pDatastore,
                                                      f_cActions,
                                                      f_rgpdstrAction,
                                                      fHasParentLink,
                                                      f_pcontextLQ->rgLicInfo,
                                                      f_pfnPolicyCallback,
                                                      f_pv ) )
            {
                continue;   /* this license has no rights for actions */
            }

            if( f_dwChainDepth > 0  &&  iCurrVariance == cRootVariance )   /* cache LID and parentKID */
            {
                /* add rgLicResult and rgLicInfo to cache */
                _AddLicResultCache(f_pcontextLQ, &lid, fHasParentLink, &kidParent, NULL, 0, f_pcontextLQ->rgLicInfo);
            }
        }

        if( !fHasParentLink  ||  f_dwAggregationType != DRM_ASD_AGGREGATE_ROOT_LICENSES)
        {
            /* aggregate SIMPLE license */
            _AggregateStateDataAndLicenseInfoMultiple( f_pcontextLQ->pBBContext->pOEMContext,
                                                       f_rgStateData,
                                                       f_pcontextLQ->rgLicInfo,
                                                       f_cActions );

            for ( iAction = 0; iAction < f_cActions; iAction++ )
            {
                fUnlimited = TRUE;      /* Assume unlimited for now */
                if( f_rgStateData[iAction].dwCategory != DRM_LICENSE_STATE_UNLIM )
                {
                    fUnlimited = FALSE;
                    break; /* from the for loop */
                }
            }
        }
        else
        {
            if( iCurrVariance == cRootVariance )   /* this is a new root variance */
            {
                _AddRootVariance(f_pcontextLQ, f_dwChainDepth, iCurrVariance, &kidParent);
            }

            /* aggregate LEAF license */
            _AggregateStateDataAndLicenseInfoMultiple( f_pcontextLQ->pBBContext->pOEMContext,
                                                       f_pcontextLQ->rgStack[f_dwChainDepth].rgLeafState[iCurrVariance],
                                                       f_pcontextLQ->rgLicInfo,
                                                       f_cActions);

            if( iCurrVariance == cRootVariance )   /* this is a new root variance */
            {
                ++cRootVariance;

                /* call recursively for parent link search */
                _QueryAndAggregateLicStatesForKID( &kidParent,
                                                    f_dwAggregationType,
                                                    f_pcontextLQ,
                                                    f_pDatastore,
                                                    FALSE,  /* do not perform delete on parent link */
                                                    f_dwChainDepth+1,
                                                    f_cActions,
                                                    f_rgpdstrAction,
                                                    f_pcontextLQ->rgStack[f_dwChainDepth].rgRootState[iCurrVariance],
                                                    f_pfnPolicyCallback,
                                                    f_pv );
            }

            /* we cannot tell if there is any unlimited license before we aggregate root to leaf */
        }
    }

    for (iCurrVariance = 0; iCurrVariance < cRootVariance; iCurrVariance++)
    {
        /* aggregate ROOT to LEAF */
        _AggregateStateDataAndStateDataChainMultiple( f_pcontextLQ->rgStack[f_dwChainDepth].rgLeafState[iCurrVariance],
                                                      f_pcontextLQ->rgStack[f_dwChainDepth].rgRootState[iCurrVariance],
                                                      f_cActions );

        /*
        ** Aggregate LEAF to SIMPLE
        ** Simple takes precedence in case of ties, so pass simple first
        */
        _AggregateStateDataAndStateDataMultiple( f_pcontextLQ->pBBContext->pOEMContext,
                                                 f_rgStateData,
                                                 f_pcontextLQ->rgStack[f_dwChainDepth].rgLeafState[iCurrVariance],
                                                 f_cActions );
    }

    /* Handle post-aggregation functionality, if any */
#if DRM_BACKUP_RESTORE_SUPPORT
    if( !fHasParentLink )
    {
        for ( iAction = 0; iAction < f_cActions; iAction++ )
        {
            /*
            ** When a caller asks:
            ** "Can I backup this KID",
            ** they're really asking:
            ** "If I backup this KID and restore later, will my content work?"
            **
            ** If the license chain for this KID doesn't allow you
            ** to do ANYTHING with the content (copy, play, burn, etc)
            ** except (technically) backup, we'll indicate that you can't
            ** backup either (even though you technically can).
            **
            ** This is consistent with the original user's request (above)
            ** because at no point in the future after restore will this
            ** KID be usable for anything but (surprise!) backup.
            **
            ** However, if the license or license chain has indicated
            ** that the license is not valid YET (before the begin date),
            ** we should still tell the user that they can backup because
            ** it WILL become valid in the future.
            **
            ** This is consistent with the original user's request (above)
            ** because the restore can occur after the license becomes valid.
            **
            ** Therefore, ignore begin expiry (only) for backup right,
            ** but only AFTER all aggregation due to chaining.
            **
            ** If we ignore begin expiry before chaining, then we will destroy
            ** the date aggregation algorithm for the chain which determines
            ** that the chain is invalid if license date ranges don't overlap.
            */
            if( DRM_UTL_DSTRStringsEqual( f_rgpdstrAction[iAction], &g_dstrWMDRM_RIGHT_BACKUP ) )
            {
                DRMFILETIME ftNegInf;
                DRMFILETIME ftInf;
                _InitNegInfDate( &ftNegInf );
                _InitInfDate(    &ftInf );

                switch( f_rgStateData[iAction].dwCategory )
                {
                case DRM_LICENSE_STATE_FROM:
                    /* Convert FROM to UNLIMITED */
                    _SetExpiryCategory( &f_rgStateData[iAction],
                                        &ftNegInf,
                                        &ftInf );
                    break;
                case DRM_LICENSE_STATE_FROM_UNTIL:
                    /* Convert FROM_UNTIL to UNTIL */
                    _SetExpiryCategory( &f_rgStateData[iAction],
                                        &ftNegInf,
                                        &f_rgStateData[iAction].datetime[1] );
                    break;
                case DRM_LICENSE_STATE_COUNT_FROM:
                    /* Convert COUNT_FROM to COUNT */
                    _SetCountedExpiryCategory( &f_rgStateData[iAction],
                                               &ftNegInf,
                                               &ftInf );
                    break;
                case DRM_LICENSE_STATE_COUNT_FROM_UNTIL:
                    /* Convert COUNT_FROM_UNTIL to COUNT_UNTIL */
                    _SetCountedExpiryCategory( &f_rgStateData[iAction],
                                               &ftNegInf,
                                               &f_rgStateData[iAction].datetime[1] );
                    break;
                default:
                    /* do nothing */
                    break;
                }
            }
        }
    }
#endif /* DRM_BACKUP_RESTORE_SUPPORT */

ErrorExit:
    return dr;
}



/*****************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_ASD_GetLicenseAggregateData(
    IN const DRM_CONST_STRING*  const f_rgpdstrAction[], /* Array of DRM_CONST_STRING pointers */
       OUT   DRM_LICENSE_STATE_DATA   f_rgStateData[],   /* array of DRM_LICENSE_STATE_DATAs */
    IN       DRM_DWORD                f_cActionsQueried,
    IN OUT   DRM_VIEW_RIGHTS_CONTEXT *f_pcontextLQ,
    IN OUT   DRM_DST                 *f_pDatastore,
    IN       DRM_BOOL                 f_fDeleteExpiredLicenses,
    IN       DRM_DWORD                f_dwAggregationType,
    IN       DRMPFNPOLICYCALLBACK     f_pfnPolicyCallback,
    IN const DRM_VOID                *f_pv)
{
    DRM_RESULT dr      = DRM_SUCCESS;
    DRM_WORD   iAction = 0;
    DRM_DWORD  i       = 0;

    ChkArg( f_rgpdstrAction   != NULL
         && f_rgStateData     != NULL
         && f_pcontextLQ      != NULL
         && f_pDatastore      != NULL
         && f_cActionsQueried  > 0
         && f_cActionsQueried <= DRM_MAX_RIGHTS_SUPPORTED );

    for( iAction = 0; iAction < f_cActionsQueried; iAction ++ )
    {
        ChkDRMString( f_rgpdstrAction[iAction] );
    }

    ZEROMEM(f_pcontextLQ->rgLicInfo,           SIZEOF(f_pcontextLQ->rgLicInfo ) );
    ZEROMEM(f_pcontextLQ->rgStack,             SIZEOF(DRM_STATE_DATA_STACK) * DRM_MAX_LICENSE_CHAIN_DEPTH);
    ZEROMEM(f_rgStateData,                     SIZEOF(DRM_LICENSE_STATE_DATA   ) * f_cActionsQueried );

    /* initialize cache to NULL. This query will not use cache for now */
    f_pcontextLQ->iCurrSlot    = 0;
    f_pcontextLQ->cCacheSlots  = 0;
    f_pcontextLQ->rgCacheSlots = NULL;
    f_pcontextLQ->dwLicChainDepth = DRM_MAX_LICENSE_CHAIN_DEPTH;

    /* init buffer */
    for ( iAction = 0; iAction < f_cActionsQueried; iAction++ )
    {
        f_rgStateData[iAction].dwCategory = DRM_LICENSE_STATE_NORIGHT;
    }

    /* do XML license store query */
    if( f_pcontextLQ->pbLicenseStoreXML != NULL )
    {
        f_pcontextLQ->fCurrentLicenseIsXML    = TRUE;
        f_pcontextLQ->pLicEval->fLicenseIsXMR = FALSE;
        f_pcontextLQ->pActiveLicStore         = f_pcontextLQ->pbLicenseStoreXML;
        f_pcontextLQ->pLicEval->plicenseXMR   = NULL;
        f_pcontextLQ->pbCurrentLicenseBuff    = NULL;

        MEMSET(&f_pcontextLQ->stack, 0, SIZEOF(DRM_STACK_ALLOCATOR_CONTEXT));
        f_pcontextLQ->stack.cbStack = f_pcontextLQ->cbBuffer;
        f_pcontextLQ->stack.pbStack = f_pcontextLQ->pbBuffer;

        _QueryAndAggregateLicStatesForKID( &f_pcontextLQ->KID,
                                            f_dwAggregationType,
                                            f_pcontextLQ,
                                            f_pDatastore,
                                            f_fDeleteExpiredLicenses,
                                            0,
                                            f_cActionsQueried,
                                            f_rgpdstrAction,
                                            f_rgStateData,
                                            f_pfnPolicyCallback,
                                            f_pv );
    }

    if( f_pcontextLQ->pbLicenseStoreXMR != NULL )
    {
        f_pcontextLQ->fCurrentLicenseIsXML    = FALSE;
        f_pcontextLQ->pLicEval->fLicenseIsXMR = TRUE;
        f_pcontextLQ->pActiveLicStore         = f_pcontextLQ->pbLicenseStoreXMR;
        f_pcontextLQ->pLicEval->plicenseXMR   = &(f_pcontextLQ->licXMR);
        f_pcontextLQ->pbCurrentLicenseBuff    = NULL;

        MEMSET(&f_pcontextLQ->stack, 0, SIZEOF(DRM_STACK_ALLOCATOR_CONTEXT));
        f_pcontextLQ->stack.cbStack = f_pcontextLQ->cbBuffer;
        f_pcontextLQ->stack.pbStack = f_pcontextLQ->pbBuffer;

        _QueryAndAggregateLicStatesForKID( &f_pcontextLQ->KID,
                                            f_dwAggregationType,
                                            f_pcontextLQ,
                                            f_pDatastore,
                                            f_fDeleteExpiredLicenses,
                                            0,
                                            f_cActionsQueried,
                                            f_rgpdstrAction,
                                            f_rgStateData,
                                            f_pfnPolicyCallback,
                                            f_pv );
    }


    dr = DRM_SUCCESS;
ErrorExit:

    if( f_pcontextLQ != NULL )
    {
        for (i = 0; i < DRM_MAX_LICENSE_CHAIN_DEPTH; i++)
        {
            if( f_pcontextLQ->rgpLicQueryContext[i] != NULL )
            {
                ZEROMEM( f_pcontextLQ->rgpLicQueryContext[i], SIZEOF( *(f_pcontextLQ->rgpLicQueryContext[i])) );

            }
        }
    }
    return dr;
}


/*****************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_ASD_IsAllowed(
    IN const DRM_CONST_STRING        *f_pdstrAction,
    IN OUT   DRM_VIEW_RIGHTS_CONTEXT *f_pcontextLQ,
    IN OUT   DRM_DST                 *f_pDatastore )
{
    DRM_RESULT                   dr = DRM_E_LOGICERR;
    const DRM_CONST_STRING      *ppArray [1];
    DRM_LICENSE_STATE_DATA       rgStateData[1];

    ppArray [0] = f_pdstrAction;

    ChkArg( f_pcontextLQ != NULL );
    ChkDRMString( f_pdstrAction );

    ChkDR( DRM_ASD_GetLicenseAggregateData( ppArray,
                                            rgStateData,
                                            1,
                                            f_pcontextLQ,
                                            f_pDatastore,
                                            FALSE,
                                            DRM_ASD_AGGREGATE_ROOT_LICENSES,
                                            NULL,
                                            NULL ) );

    if( rgStateData[0].dwCategory != DRM_LICENSE_STATE_NORIGHT
     && rgStateData[0].dwCategory != DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE )
    {
        dr = DRM_SUCCESS;
    }
    else
    {
        dr = DRM_S_FALSE;
    }

ErrorExit:
    if( DRM_FAILED( dr ) )
    {
        dr = DRM_S_FALSE;
    }
    return dr;
}


DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_ASD_ParseV2License(
    IN const DRM_CONST_STRING *f_pdstrLicense,
    IN const DRM_CONST_STRING *f_pdstrAttrName,
       OUT   DRM_DWORD        *f_pdwValue,
       OUT   DRMFILETIME      *f_pfiletime)
{
    DRM_RESULT       dr             = DRM_SUCCESS;
    DRM_CONST_STRING dstrExpression = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrLIData     = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrValue      = EMPTY_DRM_STRING;
    TOKEN            token          = {0};

    ChkDRMString( f_pdstrLicense );
    ChkDRMString( f_pdstrAttrName );

    if( f_pfiletime != NULL
     && ( f_pdstrAttrName == &g_dstrDRM_LS_BEGDATE_ATTR
       || f_pdstrAttrName == &g_dstrDRM_LS_ENDDATE_ATTR ) )
    {
        const DRM_CONST_STRING *pdstrSubString = NULL;

        /* Retrieve the condition for the ONSELECT event. */
        ChkDR( DRM_LIC_GetEvent( f_pdstrLicense,
                                &g_dstrLicEvalOnSelect,
                                 NULL,
                                &dstrLIData,
                                &dstrExpression,
                                 NULL,
                                 NULL ) );
        dr = DRM_S_FALSE;

        if( f_pdstrAttrName == &g_dstrDRM_LS_BEGDATE_ATTR )
        {
            pdstrSubString = &g_dstrDRM_LS_MACHINE_DATETIME_GE;
        }
        else if( f_pdstrAttrName == &g_dstrDRM_LS_ENDDATE_ATTR )
        {
            pdstrSubString = &g_dstrDRM_LS_MACHINE_DATETIME_LE;
        }

        /*
        ** Search for last occurence of pwszSearch in bstrExpr. Due to disable clock & deletelicesne
        ** functionalities, it is possible that there is more than one such string. The last one
        ** is the correct one that is used for determining whether license is selectable or not.
        */
        if( DRM_UTL_DSTRSearchReverse( &dstrExpression, pdstrSubString, &dstrValue ) )
        {
            /*
            ** If the date string was found we know there are at least 21 characters,
            ** and we push past all those and look at the date immediately after,
            ** skipping whitespace
            */

            if( dstrValue.cchString > g_dstrDRM_LS_MACHINE_DATETIME_GE.cchString
             && 1                   < g_dstrDRM_LS_MACHINE_DATETIME_GE.cchString ) /* There must be at least a '#' character */
            {
                /* Advance to the # */
                dstrValue.pwszString += g_dstrDRM_LS_MACHINE_DATETIME_GE.cchString - 1;
                dstrValue.cchString  -= g_dstrDRM_LS_MACHINE_DATETIME_GE.cchString - 1;

                while( dstrValue.cchString > 0
                    && DRMCRT_iswspace( *(dstrValue.pwszString) ) )
                {
                    dstrValue.pwszString++;
                    dstrValue.cchString--;
                }

                if( DRM_SUCCEEDED( ExtractDateToken( &dstrValue, &token ) ) )
                {
                    UI64_TO_FILETIME( token.val.u64DateTime, *f_pfiletime );
                    dr = DRM_SUCCESS;
                }
            }
        }
    }
    else if( f_pdwValue      !=  NULL
          && f_pdstrAttrName == &g_dstrDRM_LS_APPSEC_ATTR )
    {
        /*
        ** Need to get min app sec needed by the license.
        ** Retrieve the condition for the ONSELECT event.
        */

        ChkDR( DRM_LIC_GetEvent( f_pdstrLicense,
                                &g_dstrLicEvalOnSelect,
                                 NULL,
                                &dstrLIData,
                                &dstrExpression,
                                 NULL,
                                 NULL ) );
        dr = DRM_S_FALSE;

        if( DRM_UTL_DSTRSearchReverse( &dstrExpression, &g_dstrDRM_LS_APP_MINSECLEVEL_GE, &dstrValue ) )
        {
            /*
            ** If the date string was found we know there are at least 21 characters,
            ** and we push past all those and look at the date immediately after,
            ** skipping whitespace
            */

            if( dstrValue.cchString > g_dstrDRM_LS_APP_MINSECLEVEL_GE.cchString )
            {
                /* Advance past the string */
                dstrValue.pwszString += g_dstrDRM_LS_APP_MINSECLEVEL_GE.cchString;
                dstrValue.cchString  -= g_dstrDRM_LS_APP_MINSECLEVEL_GE.cchString;

                while( dstrValue.cchString > 0
                    && DRMCRT_iswspace( *(dstrValue.pwszString) ) )
                {
                    dstrValue.pwszString++;
                    dstrValue.cchString--;
                }

                if( DRM_SUCCEEDED( ExtractLongToken( &dstrValue, &token ) ) )
                {
                    *f_pdwValue = token.val.lValue;
                    dr          = DRM_SUCCESS;
                }
            }
        }
    }
    else if( f_pdwValue      !=  NULL
          && f_pdstrAttrName == &g_dstrDRM_LS_SAP_ATTR )
    {
        /*
        ** Need to get min app sec needed by the license.
        ** Retrieve the condition for the ONSELECT event.
        */
        *f_pdwValue = 0;
        ChkDR( DRM_LIC_GetEvent( f_pdstrLicense,
                                &g_dstrLicEvalOnSelect,
                                 NULL,
                                &dstrLIData,
                                &dstrExpression,
                                 NULL,
                                 NULL ) );
        dr = DRM_S_FALSE;

        if( DRM_UTL_DSTRSearch( &dstrExpression, &g_dstrDRMK_PREFIX, &dstrValue ) )
        {
            /*
            ** If drmk was found in the onselect statement then we know SAP
            ** is requiered
            */
            *f_pdwValue = 1;
        }
    }
    else if( f_pdwValue != NULL
          && DRM_UTL_DSTRSearch( f_pdstrAttrName, &g_dstrDRM_LS_BEGIN_ATTR, &dstrValue )
          && DRM_UTL_DSTRSearch( f_pdstrAttrName, &g_dstrDRM_LS_COUNT_ATTR, &dstrValue ) )
    {
        /* We will look for this in ONSTORE action part. */
        ChkDR( DRM_LIC_GetEvent( f_pdstrLicense,
                                &g_dstrLicEvalOnStore,
                                 NULL,
                                &dstrLIData,
                                 NULL,
                                &dstrExpression,
                                 NULL ) );

        dr = DRM_S_FALSE;

        if( DRM_UTL_DSTRSearch( &dstrExpression, f_pdstrAttrName, &dstrValue ) )
        {
            DRM_CONST_STRING dstr = EMPTY_DRM_STRING;

            if( DRM_UTL_DSTRSearch( &dstrValue, &g_dstrEqual, &dstr) )
            {
                /* Move past the "=" */
                dstr.pwszString += 1;
                dstr.cchString  -= 1;

                while( dstrValue.cchString > 0
                    && DRMCRT_iswspace( *(dstrValue.pwszString) ) )
                {
                    dstrValue.pwszString++;
                    dstrValue.cchString--;
                }

                ChkDR( ExtractLongToken( &dstr, &token ) );
                *f_pdwValue = token.val.lValue;
            }
        }
    }
    else
    {
        ChkDR( DRM_E_INVALIDARG );
    }

ErrorExit:
    if( DRM_FAILED( dr ) )
    {
        dr = DRM_S_FALSE;
    }
    return dr;
}


/******************************************************************************
** Function :   DRM_ASD_InitQuery
** Synopsis :   Init context for query rights.
** Arguments :  f_pdstrDevCert - optional, can be NULL
**              f_dwTargetOPL  - target device Output Level
**              f_pcontextLQ - output query context
** Returns :
** Notes :
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_ASD_InitCanDoQuery(
    IN       DRM_CRYPTO_CONTEXT       *f_pDrmCrypto,
    IN       DRM_LICSTORE_CONTEXT     *f_pbLicenseStoreXML,
    IN       DRM_LICSTORE_CONTEXT     *f_pbLicenseStoreXMR,     /* optional for now */
    IN       DRM_LICSTOREENUM_CONTEXT *f_rgpLicQueryContext[DRM_MAX_LICENSE_CHAIN_DEPTH],
    IN       DRM_LICEVAL_CONTEXT      *f_pLicEval,
    IN       DRM_BYTE                 *f_pbBuffer,
    IN       DRM_DWORD                 f_cbBuffer,
    IN       DRM_LONG                  f_lDeviceAppSec,
    IN       DRM_BOOL                  f_fDeviceHasSerialNum,
    IN       DRM_DWORD                 f_dwDeviceCopyOPL,
    IN const DRM_GUID                 *f_pDeviceGUID,
    IN const DRM_CONST_STRING         *f_pdstrDevCert,
    IN       DRM_DWORD                 f_cCacheSlots,     /* must be >= 1 */
    IN       DRM_CANDO_QUERY_CACHE    *f_rgCacheSlots,
       OUT   DRM_VIEW_RIGHTS_CONTEXT  *f_pcontextLQ )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  i  = 0;

    ChkArg(f_pDrmCrypto         != NULL
        && f_pbLicenseStoreXML  != NULL
        && f_rgpLicQueryContext != NULL
        && f_pLicEval           != NULL
        && f_pbBuffer           != NULL
        && f_pDeviceGUID        != NULL
        && f_pcontextLQ         != NULL
        && f_cCacheSlots        >= 1
        && f_rgCacheSlots       != NULL
        && f_pLicEval->pcontextSSTGlobal  != NULL
        && f_pLicEval->pcontextSSTLicense != NULL);

    MEMSET(f_pcontextLQ, 0, SIZEOF(DRM_VIEW_RIGHTS_CONTEXT));

    f_pcontextLQ->pbGlobalSecStore  = f_pLicEval->pcontextSSTGlobal;
    f_pcontextLQ->pbLIDSecStore     = f_pLicEval->pcontextSSTLicense;
    f_pcontextLQ->pbLicenseStoreXML = f_pbLicenseStoreXML;
    f_pcontextLQ->pbLicenseStoreXMR = f_pbLicenseStoreXMR;
    f_pcontextLQ->pLicEval          = f_pLicEval;
    f_pcontextLQ->pbBuffer          = f_pbBuffer;
    f_pcontextLQ->cbBuffer          = f_cbBuffer;

    for (i=0; i<DRM_MAX_LICENSE_CHAIN_DEPTH; i++)
    {
        ChkArg(f_rgpLicQueryContext[i] != NULL);
        f_pcontextLQ->rgpLicQueryContext[i] = f_rgpLicQueryContext[i];
    }

    /* parse the given device cert if not NULL */
    if( f_pdstrDevCert != NULL )
    {
        DRM_CONST_STRING dstrValue = EMPTY_DRM_STRING;

        ChkDRMString(f_pdstrDevCert);
        ChkDR(DRM_DCP_VerifyDeviceCert(f_pdstrDevCert, DRM_DCP_VERIFY_ENTIRE_DEVCERT, f_pDrmCrypto));
        ChkDR(DRM_DCP_LoadPropertiesCache(f_pdstrDevCert, &f_pcontextLQ->cacheDevCert, f_pDrmCrypto));

        /* get max chain depth */
        if( DRM_DCP_GetAttribute(f_pdstrDevCert, DRM_DEVCERT_MAXCHAINDEPTH, NULL, &dstrValue) == DRM_SUCCESS )
        {
            DRMCRT_wcsntol( dstrValue.pwszString, dstrValue.cchString, (DRM_LONG*)&f_pcontextLQ->dwLicChainDepth);
        }
    }
    else
    {
        f_pcontextLQ->dwLicChainDepth = DRM_MAX_LICENSE_CHAIN_DEPTH;
    }

    f_pcontextLQ->fIsWMDRMPDDevice    = (f_pdstrDevCert != NULL);
    f_pcontextLQ->lDeviceAppSec       = f_lDeviceAppSec;
    f_pcontextLQ->dwDeviceCopyOPL     = f_dwDeviceCopyOPL;
    f_pcontextLQ->deviceGUID          = *f_pDeviceGUID;
    f_pcontextLQ->fDeviceHasSerialNum = f_fDeviceHasSerialNum;

    /* initialize cache */
    f_pcontextLQ->iCurrSlot = 0;
    f_pcontextLQ->cCacheSlots = f_cCacheSlots;
    f_pcontextLQ->rgCacheSlots = f_rgCacheSlots;
    for( i=0; i<f_cCacheSlots; i++ )
    {
        MEMSET( &f_rgCacheSlots[i], 0, SIZEOF(DRM_CANDO_QUERY_CACHE) );
    }

ErrorExit:
    return dr;
}


/******************************************************************************
**
** Function :   DRM_ASD_CandoQuery
**
** Synopsis :   Query rights for given actions
**
** Arguments :  pcontextHDS - HDS context
**              pNamespace  - Namespace identifier to be opened/created
**              eOpenMode   - eDRM_DST_CREATE_NEW / eDRM_DST_OPEN_EXISTING
**              wMaxNumChildren - Number of children if a new namespace is to
**                                be created
**              pcontextNS  - Namespace context
**
** Returns :    DRM_E_DSTNAMESPACENOTFOUND - if namespace is not found and
**                  request is only to open existing existing namespace
**
** Notes :
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_ASD_CandoQuery(
    IN       DRM_KID                 *f_pKID,               /* kid to query */
    IN       DRM_DWORD                f_cActionsQueried,    /* # of actions to query */
    IN const DRM_CONST_STRING        *f_rgpdstrAction[],    /* Array of DRM_CONST_STRING pointers */
    IN OUT   DRM_VIEW_RIGHTS_CONTEXT *f_pcontextLQ,
    IN OUT   DRM_DST                 *f_pDatastore,
    IN       DRM_BOOL                 f_fDeleteExpiredLicenses,
       OUT   DRM_DWORD                f_rgResults[] )       /* query result */
{
    DRM_RESULT dr      = DRM_SUCCESS;
    DRM_WORD   iAction = 0;
    DRM_BOOL   fLicFound = FALSE;
    DRM_BOOL   fRecentExpired = FALSE;

    /* check arguments */
    ChkArg( f_pKID                      != NULL
         && f_pcontextLQ                != NULL
         && f_pcontextLQ->pBBContext    != NULL
         && f_rgpdstrAction             != NULL
         && f_pcontextLQ                != NULL
         && f_pDatastore                != NULL
         && f_rgpdstrAction             != NULL
         && f_rgResults                 != NULL
         && f_cActionsQueried            > 0
         && f_cActionsQueried           <= DRM_MAX_RIGHTS_SUPPORTED );
    for( iAction = 0; iAction           < f_cActionsQueried; iAction ++ )
    {
        ChkDRMString( f_rgpdstrAction[iAction] );
        f_rgResults[iAction] = DRM_LICQUERY_NOT_ENABLED;    /* initialize result */
    }

    /* initialize cache */
    f_pcontextLQ->iCurrSlot = 0;
    for (iAction=0; iAction<f_pcontextLQ->cCacheSlots; iAction++)
    {
        MEMSET(&(f_pcontextLQ->rgCacheSlots[iAction]), 0, SIZEOF(DRM_CANDO_QUERY_CACHE));
    }

    /* do XML license store query */
    if( f_pcontextLQ->pbLicenseStoreXML != NULL )
    {
        f_pcontextLQ->fCurrentLicenseIsXML      = TRUE;
        f_pcontextLQ->pActiveLicStore           = f_pcontextLQ->pbLicenseStoreXML;
        f_pcontextLQ->pLicEval->plicenseXMR     = NULL;
        f_pcontextLQ->pbCurrentLicenseBuff      = NULL;
        f_pcontextLQ->pLicEval->fLicenseIsXMR   = FALSE;
        f_pcontextLQ->pLicEval->fIsReadOnlyMode = TRUE;

        MEMSET(&f_pcontextLQ->stack, 0, SIZEOF(DRM_STACK_ALLOCATOR_CONTEXT));
        f_pcontextLQ->stack.cbStack = f_pcontextLQ->cbBuffer;
        f_pcontextLQ->stack.pbStack = f_pcontextLQ->pbBuffer;

        ChkDR( _QueryRightForCandoActions( f_pcontextLQ,
                                           f_pDatastore,
                                           f_fDeleteExpiredLicenses,
                                           f_pKID,
                                           0xFFFFFFFF,  /* initial vector: include all actions */
                                           0,           /* start from LEAF */
                                           f_cActionsQueried,
                                           f_rgpdstrAction,
                                          &fLicFound,
                                          &fRecentExpired,
                                           f_rgResults ) );
        for ( iAction = 0; iAction < f_cActionsQueried; iAction ++ )
        {
            if( f_rgResults[iAction] == DRM_LICQUERY_SATISFIED )
            {
                f_rgResults[iAction] = 0;
            }
        }
    }

    /* do XMR license store query */
    if( f_pcontextLQ->pbLicenseStoreXMR != NULL )
    {
        f_pcontextLQ->fCurrentLicenseIsXML = FALSE;
        f_pcontextLQ->pActiveLicStore = f_pcontextLQ->pbLicenseStoreXMR;
        f_pcontextLQ->pLicEval->plicenseXMR = &(f_pcontextLQ->licXMR);
        f_pcontextLQ->pLicEval->fLicenseIsXMR = TRUE;
        f_pcontextLQ->pbCurrentLicenseBuff = NULL;

        MEMSET(&f_pcontextLQ->stack, 0, SIZEOF(DRM_STACK_ALLOCATOR_CONTEXT));
        f_pcontextLQ->stack.cbStack = f_pcontextLQ->cbBuffer;
        f_pcontextLQ->stack.pbStack = f_pcontextLQ->pbBuffer;

        ChkDR( _QueryRightForCandoActions( f_pcontextLQ,
                                           f_pDatastore,
                                           f_fDeleteExpiredLicenses,
                                           f_pKID,
                                           0xFFFFFFFF,  /* initial vector: include all actions */
                                           0,           /* start from LEAF */
                                           f_cActionsQueried,
                                           f_rgpdstrAction,
                                          &fLicFound,
                                          &fRecentExpired,
                                           f_rgResults ) );
        for ( iAction = 0; iAction < f_cActionsQueried; iAction ++ )
        {
            if( f_rgResults[iAction] == DRM_LICQUERY_SATISFIED )
            {
                f_rgResults[iAction] = 0;
            }
        }
    }

#if DRM_SUPPORT_DELETEDSTORE
    /* Check for recently expired leaf licenses */
    ChkDR( _CheckRecentExpired( f_pcontextLQ->pBBContext->pOEMContext,
                                f_pDatastore,
                                f_pKID,
                               &fRecentExpired ) );
#endif

    /*
    ** A recently expired leaf license counts as "finding" a license
    ** since we want to return "expired" and not "no license"
    */
    fLicFound = fLicFound || fRecentExpired;

    for( iAction = 0; iAction < f_cActionsQueried; iAction ++ )
    {
        /*
        ** fLicFound represents whether a license for the KID queried
        ** was found (in any store).  If not, then we return "no license".
        */
        if( !fLicFound )
        {
            f_rgResults[iAction] =
                DRM_LICQUERY_NOT_ENABLED |
                DRM_LICQUERY_NOT_ENABLED_NO_LICENSE;
        }
        /*
        ** If we found a recent expired license AND we didn't
        ** find a license that allows the action, then add the expired flag.
        */
        else if( fRecentExpired && f_rgResults[iAction] != 0 )
        {
            f_rgResults[iAction] |= DRM_LICQUERY_NOT_ENABLED_EXPIRED;
        }
        /*
        ** If we get to this point with no reason set,
        ** then set the generic reason.
        */
        else if( f_rgResults[iAction] == DRM_LICQUERY_NOT_ENABLED )
        {
            f_rgResults[iAction] |= DRM_LICQUERY_NOT_ENABLED_NO_RIGHT;
        }
    }

    dr = DRM_SUCCESS;
ErrorExit:
    if( f_pcontextLQ != NULL )
    {
        for( iAction=0; iAction<DRM_MAX_LICENSE_CHAIN_DEPTH; iAction++ )
        {
            if( f_pcontextLQ->rgpLicQueryContext[iAction] != NULL )
            {
                ZEROMEM( f_pcontextLQ->rgpLicQueryContext[iAction], SIZEOF( *(f_pcontextLQ->rgpLicQueryContext[iAction]) ) );
            }
        }
    }
    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmxmlbuildera.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmcrt.h>
#include <drmutilities.h>
#include <drmxmlbuildera.h>

#if DRM_SUPPORT_WMDRMNET
#include <drmrsacommon.h>
#include <drmrsa.h>
#endif /* DRM_SUPPORT_WMDRMNET */

#include <drmaes.h>

ENTER_PK_NAMESPACE_CODE;

#define CB_XML_BUFFER_MINIMUM_A  100

const DRM_EXPORT_VAR DRM_DWORD g_cbXMLBuilderMinimumA = SIZEOF ( _XMBContextA ) +
                                         __CB_DECL( CB_XML_BUFFER_MINIMUM_A ) +
                                         SIZEOF (DRM_CHAR);

/******************************************************************************
**
** Function:   _PushDWORD
** 
** Synopsis:   Push a DWORD value onto the stack.
** 
** Arguments:
**
** [f_poXMBContextA]        -- Pointer to an initialized _XMBContextA.
** [f_dwValue]              -- DWORD value to be pushed to the stack.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _PushDWORD(
    __inout _XMBContextA *f_poXMBContextA,
    __in    DRM_DWORD     f_dwValue )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD iPos = 0;

    ChkArg( f_poXMBContextA != NULL &&
            f_poXMBContextA->fInited );
            
    ChkBOOL( f_poXMBContextA->ichNextOpenNode >= SIZEOF( DRM_DWORD ),
             DRM_E_BUFFERTOOSMALL );

    iPos = f_poXMBContextA->ichNextOpenNode;
    
    DRM_BYT_CopyBytes( f_poXMBContextA->rgchXML, iPos, &f_dwValue, 0, SIZEOF( DRM_DWORD ) );

    f_poXMBContextA->ichNextOpenNode -= SIZEOF( DRM_DWORD );

ErrorExit:
    
    return dr;
}

/******************************************************************************
**
** Function:   _PopDWORD
** 
** Synopsis:   Pop a DWORD value from the stack.
** 
** Arguments:
**
** [f_poXMBContextA]        -- Pointer to an initialized _XMBContextA.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
******************************************************************************/
static DRM_RESULT _PopDWORD(
    __inout _XMBContextA *f_poXMBContextA )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_poXMBContextA != NULL &&
            f_poXMBContextA->fInited );

    f_poXMBContextA->ichNextOpenNode += SIZEOF( DRM_DWORD );

ErrorExit:
    
    return dr;
}

/******************************************************************************
**
** Function:   _GetTopDWORD
** 
** Synopsis:   Get a DWORD value currently at the top of the stack.
** 
** Arguments:
**
** [f_poXMBContextA]        -- Pointer to an initialized _XMBContextA.
** [f_pdwValue]             -- Pointer to a DWORD variable to receive the top
**                             DWORD value on the stack.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid or
**                          the stack is empty.
**
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _GetTopDWORD(
    __in  _XMBContextA *f_poXMBContextA,
    __out DRM_DWORD    *f_pdwValue )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD iPos = 0;
    
    ChkArg( f_poXMBContextA != NULL &&
            f_poXMBContextA->fInited );
            
    ChkArg( f_pdwValue != NULL );

    iPos = f_poXMBContextA->ichNextOpenNode + SIZEOF( DRM_DWORD );

    ChkArg( iPos >= SIZEOF( DRM_DWORD ) );

    DRM_BYT_CopyBytes( f_pdwValue,
                       0,
                       f_poXMBContextA->rgchXML,
                       iPos,
                       SIZEOF( DRM_DWORD ) );
                       
ErrorExit:
    
    return dr;
}

/******************************************************************************
**
** Function:   _AllTrim2
** 
** Synopsis:   Trim all leading and trailing blanks of a DRM_CHAR string.
** 
** Arguments:
**
** [f_pszBase]              -- Pointer to a DRM_CHAR string to be trimmed.
** [f_pdasstr]              -- Pointer to a DRM_SUBSTRING that receives the
**                             portion of a DRM_CHAR string that has been trimmed
**                             (with no leading and trailing blanks).
**
** Returns:                 DRM_TRUE if resulting string length > 0. Otherwise
**                          DRM_FALSE will be returned.
**
******************************************************************************/
static DRM_NO_INLINE DRM_BOOL _AllTrim2(
    __in_ecount(f_pdasstr->m_cch) const DRM_CHAR      *f_pszBase,
    __inout                             DRM_SUBSTRING *f_pdasstr )
{
    DRM_BOOL fResult = FALSE;

    if ( f_pszBase == NULL ||
         f_pdasstr == NULL ||
         f_pdasstr->m_cch == 0 )
    {
        goto ErrorExit;
    }

    /* Trim the leading blanks. */
    while ( GET_CHAR( f_pszBase, f_pdasstr->m_ich ) == ' ' &&
            ( f_pdasstr->m_cch > 0 ) )
    {
        f_pdasstr->m_ich++;
        f_pdasstr->m_cch--;
    }

    /* Trim the trailing blanks. */
    while ( f_pdasstr->m_cch > 0 &&
            GET_CHAR( f_pszBase, 
                      f_pdasstr->m_ich + f_pdasstr->m_cch - 1 ) == ' ' )
    {
        f_pdasstr->m_cch--;
    }

    fResult = f_pdasstr->m_cch > 0;

ErrorExit:
    
    return fResult;
}

/******************************************************************************
**
** Function:   _CreateContextA
** 
** Synopsis:   Function that creates and initializes a XML builder context
**             on a passed in buffer.
** 
** Arguments:
**
** [f_pbXMBContextA]        -- Pointer to a buffer on which a XML builder context
**                             will be built.
** [f_cbXMBContextA]        -- Size (number of bytes) of a buffer on which a
**                             _XMBContextA structure will be built.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the size of buffer is not big
**                          enough.
**
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _CreateContextA(
    __inout_bcount(f_cbXMBContextA) DRM_BYTE *f_pbXMBContextA,
    __in                            DRM_DWORD f_cbXMBContextA )
{
    DRM_RESULT dr = DRM_SUCCESS;
    _XMBContextA *poXMBContextA = NULL;

    ChkArg( f_pbXMBContextA != NULL &&
            f_cbXMBContextA > 0 );
 
    if ( f_cbXMBContextA < g_cbXMLBuilderMinimumA )
    {
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    ZEROMEM( f_pbXMBContextA, f_cbXMBContextA );
    
    poXMBContextA = ( _XMBContextA * )f_pbXMBContextA;
    
    poXMBContextA->cbContext = f_cbXMBContextA;
    
    poXMBContextA->cchBuffer = ( ( f_cbXMBContextA - SIZEOF( _XMBContextA ) ) );
    
    poXMBContextA->ichNextString  = 0;
    
    /* Next position to be used on stack */
    poXMBContextA->ichNextOpenNode = poXMBContextA->cchBuffer - SIZEOF( DRM_DWORD );
    
    poXMBContextA->fInited = TRUE;

    poXMBContextA->cbMaxStackUsed = 0;
    
ErrorExit:
    
    return dr;
}

/******************************************************************************
**
** Function:   _OpenNodeA
** 
** Synopsis:   Function that creates a new node in the XML builder context.
** 
** Arguments:
**
** [f_poXMBContextA]        -- Pointer to an initialized XML builder context.
** [f_pdastrNodeName]       -- Pointer to a DRM_ANSI_CONST_STRING that contains the
**                             name of the node to be created.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the size of buffer in the XML
**                          builder context is not big enough to accomodate the new
**                          node.
**
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _OpenNodeA(
    __inout       _XMBContextA          *f_poXMBContextA,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrNodeName )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD ichNode = 0;
    DRM_SUBSTRING dasstrTrimmed = EMPTY_DRM_SUBSTRING;
    DRM_DWORD cchRequired = 0;

    ChkArg( f_poXMBContextA != NULL &&
            f_poXMBContextA->fInited );
    
    ChkDRMANSIString( f_pdastrNodeName );
    
    dasstrTrimmed.m_ich = 0;
    dasstrTrimmed.m_cch = f_pdastrNodeName->cchString;
        
    ChkArg( _AllTrim2( f_pdastrNodeName->pszString, &dasstrTrimmed ) );

    /* Calculate the size of the tag (length of the tag name plus two chars for '<>'). */ 
    cchRequired = f_poXMBContextA->ichNextString + dasstrTrimmed.m_cch + 2;

    ChkFAIL( cchRequired > f_poXMBContextA->ichNextString );
    ChkFAIL( cchRequired > dasstrTrimmed.m_cch );

    if ( cchRequired < f_poXMBContextA->ichNextString )
    {
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    ChkFAIL( ( cchRequired + SIZEOF( DRM_DWORD ) ) > cchRequired );

    cchRequired += SIZEOF( DRM_DWORD );

    if ( cchRequired >= f_poXMBContextA->ichNextOpenNode )
    {
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    /* Output "<tag>" to the output buffer. */
    PUT_CHAR( f_poXMBContextA->rgchXML,
              f_poXMBContextA->ichNextString,
              '<' );
        
    f_poXMBContextA->ichNextString++;
    
    ichNode = f_poXMBContextA->ichNextString;

    DRM_BYT_CopyBytes( f_poXMBContextA->rgchXML,
                       f_poXMBContextA->ichNextString,
                       f_pdastrNodeName->pszString,
                       dasstrTrimmed.m_ich,
                       dasstrTrimmed.m_cch );

    f_poXMBContextA->ichNextString += dasstrTrimmed.m_cch;

    PUT_CHAR( f_poXMBContextA->rgchXML, 
              f_poXMBContextA->ichNextString, 
              '>' );

    f_poXMBContextA->ichNextString++;
        
    /* Push the position of the new node onto the stack. */
    ChkDR( _PushDWORD( f_poXMBContextA, ichNode ) );
    
ErrorExit:
    
    return dr;
}

/******************************************************************************
**
** Function:   _CloseCurrNodeA
** 
** Synopsis:   Function that closes the current node in the XML builder context.
** 
** Arguments:
**
** [f_poXMBContextA]        -- Pointer to an initialized XML builder context.
** [f_fOkayToCloseRoot]     -- Flag indicating whether the root node should be closed.
** [f_pdasstrXML]           -- Pointer to a DRM_SUBSTRING to receive the XML fragment
**                             of the node to be closed (including tags).
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_NOMORE if there is no node to be closed.
**                          DRM_E_NOXMLCLOSETAG if the current node is not
**                          followed by a '>'.
**                          DRM_E_BUFFERTOOSMALL if the size of buffer in the XML
**                          builder context is not big enough to accomodate the data
**                          to be added.
**
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _CloseCurrNodeA(
    __inout   _XMBContextA  *f_poXMBContextA,
    __in      DRM_BOOL       f_fOkayToCloseRoot,
    __out_opt DRM_SUBSTRING *f_pdasstrXML )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cch = 0;
    DRM_DWORD ichNode = 0;
    DRM_DWORD cchMinStack = 0;

    ChkArg( f_poXMBContextA != NULL &&
            f_poXMBContextA->fInited );
            
    /*
    ** Make sure the stack is not empty. Stack is count by DRM_DWORD.
    ** to close a node, there must be at least one DRM_DWORD on the stack.
    ** if f_fOkayToCloseRoot is FALSE, there must be at least two DRM_DWORDs
    ** on the stack.
    */
    if ( f_fOkayToCloseRoot )
    {
        /* Should have the at least a Root node on the stack. */
        cchMinStack = SIZEOF( DRM_DWORD );
    }
    else
    {
        /* Should have at least a Root node plus the last open node on the stack. */
        cchMinStack = 2 * SIZEOF( DRM_DWORD );
    }

    if ( f_poXMBContextA->ichNextOpenNode + cchMinStack  < f_poXMBContextA->ichNextOpenNode ||
         f_poXMBContextA->ichNextOpenNode + cchMinStack >= f_poXMBContextA->cchBuffer )
    {
        /* Stack is empty. */
        ChkDR( DRM_E_NOMORE );
    }

    /* Retrieve the length of name of the current node on top of the stack. */
    ChkDR( _GetTopDWORD( f_poXMBContextA, &ichNode ) );

    if ( f_pdasstrXML != NULL )
    {
        /* Save the starting position of the current node. */
        f_pdasstrXML->m_ich = ichNode - 1;
    }

    /*
    ** Calculate the length of the name of the current node.
    ** If a space (<Tag Attr-"...">) or '>' (<Tag>) is found, all characters
    ** in front of it and after the '<' character (pointed by ichNode) are part
    ** of the name.
    */
    while ( ichNode + cch < f_poXMBContextA->cchBuffer &&
            ( GET_CHAR( f_poXMBContextA->rgchXML, ichNode + cch ) != '>'  && 
              GET_CHAR( f_poXMBContextA->rgchXML, ichNode + cch ) != ' ' ) )
    {
        cch++;
    }

    /* Check whether the '>' or the ' ' character is found. */
    if ( ichNode + cch >= f_poXMBContextA->cchBuffer ||
         ( GET_CHAR( f_poXMBContextA->rgchXML, ichNode + cch ) != '>'  && 
          GET_CHAR( f_poXMBContextA->rgchXML, ichNode + cch ) != ' ' ) )
    {
        ChkDR( DRM_E_NOXMLCLOSETAG );
    }

    /* The constant 3 means the additional three characters for a close tag: </>. */
    if ( f_poXMBContextA->ichNextString + cch < f_poXMBContextA->ichNextString ||
         f_poXMBContextA->ichNextString + cch + 3 < f_poXMBContextA->ichNextString ||
         f_poXMBContextA->ichNextString + cch + 3 >= f_poXMBContextA->ichNextOpenNode )
    {
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    /* Output </tag> to the output buffer. */
    DRM_BYT_CopyBytes( f_poXMBContextA->rgchXML,
                       f_poXMBContextA->ichNextString,
                       g_dastrOpenEndTag.pszString,
                       0,
                       g_dastrOpenEndTag.cchString );
        
    f_poXMBContextA->ichNextString += g_dastrOpenEndTag.cchString;

    DRM_BYT_CopyBytes( f_poXMBContextA->rgchXML,
                       f_poXMBContextA->ichNextString,
                       f_poXMBContextA->rgchXML,
                       ichNode, 
                       cch );
        
    f_poXMBContextA->ichNextString += cch;

    PUT_CHAR( f_poXMBContextA->rgchXML, 
              f_poXMBContextA->ichNextString, 
              '>' );

    f_poXMBContextA->ichNextString++;

    /* Pop the current node from the stack. */
    _PopDWORD( f_poXMBContextA );

    if (f_pdasstrXML != NULL)
    {
        /* Save the length of the node that has just been closed. */
        f_pdasstrXML->m_cch = f_poXMBContextA->ichNextString - ichNode + 1;
    }

ErrorExit:
    
    return dr;
}


/*
** calcuate the current node size
*/
static DRM_RESULT DRM_CALL _CalcNodeSizeA(
    __in  _XMBContextA  *f_pbContextXMLA,
    __out DRM_DWORD     *f_pcchContent,  /* ch count of node content */
    __out DRM_DWORD     *f_pcchTagName)  /* ch count of node tag */
{
    DRM_RESULT   dr      = DRM_SUCCESS;
    _XMBContextA *pcontextXMLA = (_XMBContextA *) f_pbContextXMLA;
    DRM_DWORD    cch     = 0;
    DRM_DWORD    ichNode = 0;

    ChkArg(f_pbContextXMLA != NULL
         && f_pcchContent  != NULL
         && f_pcchTagName  != NULL
         && pcontextXMLA->fInited);

    /* parse length of node name */
    
    ChkDR( _GetTopDWORD( pcontextXMLA, &ichNode ) );
        
    while (GET_CHAR(pcontextXMLA->rgchXML, ichNode + cch) != ' '
        && GET_CHAR(pcontextXMLA->rgchXML, ichNode + cch) != '>')
    {
        cch++;
    }

    *f_pcchTagName = cch;

    /* parse first position of node content */
    while (GET_CHAR(pcontextXMLA->rgchXML, ichNode + cch) != '>')
    {
        cch++;
    }

    *f_pcchContent = pcontextXMLA->ichNextString - ichNode - cch - 1;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function:   DRM_XMB_CreateDocumentA
** 
** Synopsis:   API that creates and initializes a XML builder context on a passed
**             in buffer. It also opens the root node of the whole XML document
**             to be created.
** 
** Arguments:
**
** [f_cbXMBContextA]        -- Size (number of bytes) of a passed in buffer
**                             on which a XML builder context will be built.
** [f_pbXMBContextA]        -- Pointer to buffer on which a XML builder context
**                             will be created.
** [f_pdastrRootNode]       -- Pointer to a DRM_ANSI_CONST_STRING that contains the
**                             name of the root node of the XML document to be
**                             created.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMB_CreateDocumentA(
    __in                      const DRM_DWORD              f_cbXMBContextA,
    __inout_bcount(f_cbXMBContextA) DRM_BYTE              *f_pbXMBContextA,
    __in                      const DRM_ANSI_CONST_STRING *f_pdastrRootNode )
{
    DRM_RESULT dr = DRM_SUCCESS;
    _XMBContextA *poXMBContextA = ( _XMBContextA * )f_pbXMBContextA;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_CreateDocumentA );

    ChkArg( f_pbXMBContextA != NULL &&
            f_cbXMBContextA != 0 );

    /* Make sure the passed in buffer is aligned properly. */
    DRMASSERT( ( ( ( DRM_DWORD_PTR )f_pbXMBContextA) % SIZEOF( DRM_DWORD ) ) == 0 );

    ChkDRMANSIString( f_pdastrRootNode );
    ChkBOOL( f_cbXMBContextA >= SIZEOF( _XMBContextA ), DRM_E_BUFFERTOOSMALL);

    /* Create the XML builder context. */
    ChkDR( _CreateContextA( f_pbXMBContextA, f_cbXMBContextA ) );

    /* Open the root node. */
    ChkDR( _OpenNodeA( poXMBContextA, f_pdastrRootNode ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/******************************************************************************
**
** Function:   DRM_XMB_CloseDocumentA
** 
** Synopsis:   API that closes a XML document being created and returns the
**             complete XML string that has been built.
** 
** Arguments:
**
** [f_poXMBContextA]        -- Pointer to an initialized XML builder context.
** [f_pdasstrXML]           -- Pointer to a DRM_SUBSTRING to receive the complete
**                             XML string that has been built.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMB_CloseDocumentA(
    __inout _XMBContextA  *f_poXMBContextA,
    __out   DRM_SUBSTRING *f_pdasstrXML )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_CloseDocumentA );

    ChkArg( f_poXMBContextA != NULL &&
            f_poXMBContextA->fInited );
            
    ChkArg( f_pdasstrXML != NULL );
    
    for ( ; ; )
    {
        /* Closes all nodes on the stack. */
        dr = _CloseCurrNodeA( f_poXMBContextA, TRUE, NULL );
        
        if ( dr == DRM_E_NOMORE )
        {
            dr = DRM_SUCCESS;
            
            break;
        }
        else
        {
            ChkDR( dr );
        }
    }

    f_pdasstrXML->m_ich = 0;
    f_pdasstrXML->m_cch = f_poXMBContextA->ichNextString;

    /* Invalidate the XML builder context. */
    f_poXMBContextA->fInited = FALSE;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;    
    return dr;
}

/******************************************************************************
**
** Function:   DRM_XMB_OpenNodeA
** 
** Synopsis:   API that creates a new node in the XML builder context.
** 
** Arguments:
**
** [f_poXMBContextA]        -- Pointer to an initialized XML builder context.
** [f_pdastrNodeName]       -- Pointer to a DRM_ANSI_CONST_STRING that contains the
**                             name of the node to be created.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMB_OpenNodeA(
    __inout       _XMBContextA          *f_poXMBContextA,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrNodeName )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_OpenNodeA );

    ChkArg( f_poXMBContextA != NULL &&
            f_poXMBContextA->fInited );
            
    ChkDRMANSIString( f_pdastrNodeName );

    ChkDR( _OpenNodeA( f_poXMBContextA, f_pdastrNodeName ) );

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;    
    return dr;
}

/******************************************************************************
**
** Function:   DRM_XMB_CloseCurrNodeA
** 
** Synopsis:   API that closes the current node in the XML builder context.
** 
** Arguments:
**
** [f_poXMBContextA]        -- Pointer to an initialized XML builder context.
** [f_pdasstrXML]           -- Pointer to a DRM_SUBSTRING to receive the XML fragment
**                             of the node to be closed (including tags).
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMB_CloseCurrNodeA(
    __inout   _XMBContextA  *f_pbXMBContextA,
    __out_opt DRM_SUBSTRING *f_pdasstrXML )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_CloseCurrNodeA );
    
    ChkArg( f_pbXMBContextA != NULL );
    
    ChkDR( _CloseCurrNodeA( f_pbXMBContextA, FALSE, f_pdasstrXML ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;    
    return dr;
}

DRM_RESULT DRM_CALL DRM_XMB_AESEncryptAndCloseCurrNodeA(
    __inout _XMBContextA  *f_pbContextXMLA,
    __in    DRM_AES_KEY   *f_pkeyAES,
    __in    DRM_DWORD      f_dwNonce,
    __out   DRM_SUBSTRING *f_pdasstrXMLFragment)
{
    DRM_RESULT    dr = DRM_SUCCESS;
    _XMBContextA *pcontextXMLA = (_XMBContextA *) f_pbContextXMLA;
    DRM_DWORD     cchContent   = 0;
    DRM_DWORD     cchEncoded   = 0;
    DRM_DWORD     cchTagName   = 0;
    DRM_DWORD     ichStart     = 0;
    DRM_BYTE     *pbContent    = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_AESEncryptAndCloseCurrNodeA );
        
    ChkArg(f_pbContextXMLA != NULL
        && f_pkeyAES      != NULL 
        && pcontextXMLA->fInited);

    /*
    ** 1. check available buffer size: 
    **    req size = (blob_size) / 3 * 4)
    ** 2. call AES code to encrypt the blob in place
    ** 3. call Base64Encode the encrypted data
    ** 4. close the node 
    */

    /* check available space */

    ChkDR(_CalcNodeSizeA(f_pbContextXMLA, &cchContent, &cchTagName));

    /* cache the starting index */

    ichStart  = pcontextXMLA->ichNextString - cchContent;


    cchEncoded = CCH_BASE64_EQUIV(cchContent);

    if (pcontextXMLA->ichNextString - cchContent  > pcontextXMLA->ichNextString 
    ||  pcontextXMLA->ichNextString - cchContent >= pcontextXMLA->cchBuffer)
    {
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }

    pbContent = (DRM_BYTE*)pcontextXMLA->rgchXML + ichStart;
    /* encrypt the content */

    if (cchContent > 0)
    {
        DRM_AES_COUNTER_MODE_CONTEXT ctx = { 0 };
        ctx.qwInitializationVector = DRM_UI64(f_dwNonce);
        ctx.qwBlockOffset = DRM_UI64(0);
        ctx.bByteOffset = 0;


        ChkDR(DRM_Aes_CtrProcessData(f_pkeyAES, pbContent, cchContent, &ctx));
        /* base64 encode the encrypted blob */
        
        ChkDR(DRM_B64_EncodeA(pbContent, 
                              cchContent,
                   (DRM_CHAR*)pbContent, 
                             &cchEncoded, 
                              0));
    }
      
    /* update ichNextString with the difference between raw and B64-encoded data sizes */
    
    pcontextXMLA->ichNextString = pcontextXMLA->ichNextString - cchContent + cchEncoded;

    /* now close the node */
    ChkDR(_CloseCurrNodeA(f_pbContextXMLA, FALSE, f_pdasstrXMLFragment));

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;    
    return dr;
}

#if DRM_SUPPORT_WMDRMNET

DRM_RESULT DRM_CALL DRM_XMB_RSASignAndCloseCurrNodeA(
    __inout         _XMBContextA        *f_pbContextXMLA,
    __in      const DRM_RSA_PRIVATE_KEY *f_pprivkeyRSA,
    __in            DRM_BOOL             f_fIncludeTag,
    __out           DRM_DWORD           *f_pcbSignature,
    __out_bcount    (*f_pcbSignature)  DRM_BYTE *f_pbSignature,    
    __out_ecount_opt(*f_pcchSignature) DRM_CHAR *f_pszSignature, 
    __inout         DRM_DWORD           *f_pcchSignature,
    __out_opt       DRM_SUBSTRING       *f_pdasstrXMLFragment,
    __in            DRM_CRYPTO_CONTEXT  *f_pCryptCtx)
{
    DRM_RESULT    dr = DRM_SUCCESS;
    _XMBContextA *pcontextXMLA   = (_XMBContextA *) f_pbContextXMLA;
    DRM_DWORD     cchContent     = 0;
    DRM_DWORD     cchTagName     = 0;
    DRM_SUBSTRING dasstrFragment = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_RSASignAndCloseCurrNodeA );

    ChkArg(f_pbContextXMLA    != NULL
       &&  f_pprivkeyRSA      != NULL
       &&  f_pcbSignature     != NULL
       &&  f_pbSignature      != NULL 
       &&  pcontextXMLA->fInited);
    
    ChkDR(_CalcNodeSizeA(f_pbContextXMLA, &cchContent, &cchTagName));

    if (! f_fIncludeTag)
    {
        DRM_SUBSTRING dasstr = EMPTY_DRM_SUBSTRING;
    
        dasstr.m_ich = pcontextXMLA->ichNextString - cchContent;
        dasstr.m_cch = cchContent;


        /* sign the content */
        ChkDR(DRM_RSA_PssSign(f_pprivkeyRSA,
                              cchContent,
                 (DRM_BYTE *) pcontextXMLA->rgchXML,
                              pcontextXMLA->ichNextString - cchContent,
                              f_pcbSignature,
                              f_pbSignature,
                              f_pCryptCtx));
    }
    
    /* close the node */
    ChkDR(_CloseCurrNodeA(f_pbContextXMLA, FALSE, &dasstrFragment));

    if (f_fIncludeTag)
    {
        /* sign the content */
        ChkDR(DRM_RSA_PssSign(f_pprivkeyRSA,
                              dasstrFragment.m_cch,
                 (DRM_BYTE *) pcontextXMLA->rgchXML,
                              dasstrFragment.m_ich,
                              f_pcbSignature,
                              f_pbSignature,
                              f_pCryptCtx));

    }

    /* Base64 encode the signature */
    if (f_pszSignature != NULL)
    {
        ChkDR(DRM_B64_EncodeA( f_pbSignature, 
                              *f_pcbSignature, 
                               f_pszSignature, 
                               f_pcchSignature, 
                               0));
    }
    
    if (f_pdasstrXMLFragment != NULL)
    {
        *f_pdasstrXMLFragment = dasstrFragment;
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;    
    return dr;
}

#endif /* DRM_SUPPORT_WMDRMNET */

DRM_RESULT DRM_CALL DRM_XMB_HashAndCloseCurrNodeA(
    __inout   _XMBContextA      *f_pbContextXMLA,
    __in      DRM_SHA1_CONTEXT  *f_pcontextSHA,
    __in      DRM_BOOL           f_fIncludeTag,
    __out_bcount(DRM_SHA1_DIGEST_LEN) DRM_BYTE f_rgbSHA [__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    __out_ecount(CCH_BASE64_EQUIV_SAL( DRM_SHA1_DIGEST_LEN )) DRM_CHAR f_rgchSHA[__CB_DECL(DRM_SHA1_B64ENC_DIGEST_LEN)], 
    __out_opt DRM_SUBSTRING     *f_pdasstrXMLFragment)
{
    DRM_RESULT    dr = DRM_SUCCESS;
    _XMBContextA *pcontextXMLA   = (_XMBContextA *) f_pbContextXMLA;
    DRM_SUBSTRING dasstrFragment = { 0 };
    DRM_DWORD     cchContent = 0;
    DRM_DWORD     cchTagName = 0;
    DRM_DWORD     cchSHA     = 0;
    DRM_BYTE     *pbContent  = 0;
    DRM_DWORD     ichStart   = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_HashAndCloseCurrNodeA );

    ChkArg(f_pbContextXMLA != NULL
         && f_pcontextSHA  != NULL
         && f_rgbSHA       != NULL
         && pcontextXMLA->fInited);
    
    ChkDR(_CalcNodeSizeA(f_pbContextXMLA, &cchContent, &cchTagName));

    ichStart  = pcontextXMLA->ichNextString - cchContent;

    pbContent = (DRM_BYTE*)pcontextXMLA->rgchXML + ichStart;

    DRM_SHA1_Init(f_pcontextSHA);

    if (! f_fIncludeTag)
    {
        /* sign the content */

        DRM_SHA1_Update(pbContent, cchContent, f_pcontextSHA);
    }

    /* close the node */
    ChkDR(_CloseCurrNodeA(f_pbContextXMLA, FALSE, &dasstrFragment));

    if (f_fIncludeTag)
    {
        pbContent = (DRM_BYTE*)pcontextXMLA->rgchXML + dasstrFragment.m_ich;

        /* sign the content */
        DRM_SHA1_Update(pbContent, dasstrFragment.m_cch, f_pcontextSHA);
    }
    DRM_SHA1_Finalize(f_pcontextSHA, f_rgbSHA);

    /* Base64 encode the signature */
    
    if (f_rgchSHA != NULL)
    {
        cchSHA = DRM_SHA1_B64ENC_DIGEST_LEN;

        ChkDR(DRM_B64_EncodeA(f_rgbSHA, 
                              DRM_SHA1_DIGEST_LEN, 
                              f_rgchSHA, 
                             &cchSHA, 
                              0));
    }

    if (f_pdasstrXMLFragment != NULL)
    {
        *f_pdasstrXMLFragment = dasstrFragment;
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;    
    return dr;
}

#if DRM_SUPPORT_WMDRMNET

DRM_RESULT DRM_CALL DRM_XMB_HashAndRSASignAndCloseCurrNodeA(
    __inout         _XMBContextA           *f_pbContextXMLA,
    __in            DRM_SHA1_CONTEXT       *f_pcontextSHA,
    __in      const DRM_RSA_PRIVATE_KEY    *f_pprivkeyRSA,
    __in            DRM_BOOL                f_fIncludeTag,
    __out_bcount(DRM_SHA1_DIGEST_LEN) DRM_BYTE f_rgbSHA  [__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    __out_ecount(CCH_BASE64_EQUIV_SAL( DRM_SHA1_DIGEST_LEN )) DRM_CHAR f_rgchSHA [__CB_DECL(DRM_SHA1_B64ENC_DIGEST_LEN)],
    __out           DRM_DWORD              *f_pcbSignature,
    __out_bcount(*f_pcbSignature) DRM_BYTE *f_pbSignature,
    __out           DRM_DWORD              *f_pcchSignature,
    __out_ecount(CCH_BASE64_EQUIV_SAL(DRM_RSA_CB_PRIME_MAX)) DRM_CHAR f_rgchSignature [__CB_DECL(CCH_BASE64_EQUIV(DRM_RSA_CB_PRIME_MAX))],
    __out_opt       DRM_SUBSTRING          *f_pdasstrXMLFragment,
    __in            DRM_CRYPTO_CONTEXT     *f_pCryptCtx)
{
    DRM_RESULT    dr = DRM_SUCCESS;
    _XMBContextA *pcontextXMLA   = (_XMBContextA *) f_pbContextXMLA;
    DRM_SUBSTRING dasstrFragment = { 0 };
    DRM_DWORD     cchContent     = 0;
    DRM_DWORD     cchTagName     = 0;
    DRM_BYTE     *pbContent      = 0;
    DRM_DWORD     ichStart       = 0;
    DRM_DWORD     cchSignature   = 0;
    DRM_DWORD     cchSHA         = 0;
    DRM_RSA_SUPPORTED_KEY_LENGTHS eKeyLength = eDRM_RSA_UNKNOWN;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_HashAndRSASignAndCloseCurrNodeA );

    ChkArg(f_pbContextXMLA  != NULL
         && f_pcontextSHA   != NULL
         && f_pprivkeyRSA   != NULL
         && f_rgbSHA        != NULL
         && f_pcbSignature  != NULL
         && f_pbSignature   != NULL
         && f_pcchSignature != NULL
         && pcontextXMLA->fInited);

    ChkDR( OEM_RSA_GetPrivateKeyLength( f_pprivkeyRSA, &eKeyLength ) );
    
    ChkDR(_CalcNodeSizeA(f_pbContextXMLA, &cchContent, &cchTagName));

    ichStart  = pcontextXMLA->ichNextString - cchContent;

    pbContent = (DRM_BYTE*)pcontextXMLA->rgchXML + ichStart;

    DRM_SHA1_Init(f_pcontextSHA);

    if (! f_fIncludeTag)
    {
        DRM_SUBSTRING dasstr = EMPTY_DRM_SUBSTRING;
    
        /* create the SHA digest over the content */

        DRM_SHA1_Update(pbContent, cchContent, f_pcontextSHA);

        /* RSA Sign the content */

        dasstr.m_ich = 0;
        dasstr.m_cch = cchContent;
        cchSignature = CCH_BASE64_EQUIV( DRM_RSA_CB_PRIME_MAX );

        /* sign the content */
        ChkDR( DRM_RSA_PssSign( f_pprivkeyRSA,
                                cchContent,
                                pbContent,
                                0,
                                f_pcbSignature,
                                f_pbSignature,
                                f_pCryptCtx ) );

        ChkDR( DRM_B64_EncodeA(  f_pbSignature, 
                                *f_pcbSignature, 
                                 f_rgchSignature, 
                                &cchSignature, 
                                 0 ) );
        *f_pcchSignature = cchSignature;

    }
   
    /* close the node */
    ChkDR(_CloseCurrNodeA(f_pbContextXMLA, FALSE, &dasstrFragment));

    if (f_fIncludeTag)
    {
        DRM_SUBSTRING dasstr = EMPTY_DRM_SUBSTRING;
    
        pbContent = (DRM_BYTE*)pcontextXMLA->rgchXML + dasstrFragment.m_ich;

        /* create the SHA hash */

        DRM_SHA1_Update  (pbContent, 
                          dasstrFragment.m_cch, 
                          f_pcontextSHA);

        DRM_SHA1_Finalize(f_pcontextSHA, 
                          f_rgbSHA);
    
        /* Base64 encode the digest */

        if (f_rgchSHA != NULL)
        {
            cchSHA = DRM_SHA1_B64ENC_DIGEST_LEN;

            ChkDR(DRM_B64_EncodeA(f_rgbSHA, 
                                  DRM_SHA1_DIGEST_LEN, 
                                  f_rgchSHA, 
                                 &cchSHA, 
                                  0));
        }

        /* RSA Sign the content */

        dasstr.m_ich = 0;
        dasstr.m_cch = dasstrFragment.m_cch;
        cchSignature = CCH_BASE64_EQUIV( DRM_RSA_CB_PRIME_MAX );

        /* sign the content */
        ChkDR( DRM_RSA_PssSign(  f_pprivkeyRSA,
                                 dasstrFragment.m_cch,
                                 pbContent,
                                 0,
                                 f_pcbSignature,
                                 f_pbSignature,
                                 f_pCryptCtx ) );

        ChkDR( DRM_B64_EncodeA(  f_pbSignature, 
                                *f_pcbSignature, 
                                 f_rgchSignature, 
                                &cchSignature, 
                                 0 ) );
        *f_pcchSignature = cchSignature;

    }

    if (f_pdasstrXMLFragment != NULL)
    {
        *f_pdasstrXMLFragment = dasstrFragment;
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;    
    return dr;
}

#endif /* DRM_SUPPORT_WMDRMNET */

/******************************************************************************
**
** Function:   DRM_XMB_AddAttributeA
** 
** Synopsis:   API that adds an atribute pair to the current node in the XML
**             builder context.
** 
** Arguments:
**
** [f_poXMBContextA]        -- Pointer to an initialized XML builder context.
** [f_pdastrAttrName]       -- Pointer to a DRM_ANSI_CONST_STRING that contains
**                             the name of the attribute to be added.
** [f_pdastrAttrValue]      -- Pointer to a DRM_ANSI_CONST_STRING that contains
**                             the value of the attribute to be added.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_NOMORE if there is no node opened.
**                          DRM_E_NOXMLCLOSETAG if the current node is not
**                          followed by a '>'.
**                          DRM_E_BUFFERTOOSMALL if the size of buffer in the XML
**                          builder context is not big enough to accomodate the data
**                          to be added.
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMB_AddAttributeA(
    __inout       _XMBContextA          *f_poXMBContextA,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrAttrName,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrAttrValue )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchRequired = 0;    
    DRM_SUBSTRING dasstrNameTrimmed = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrValueTrimmed = EMPTY_DRM_SUBSTRING;
    DRM_DWORD ichInsert = 0;
    DRM_DWORD ichDest = 0;
    DRM_DWORD ichSource = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_AddAttributeA );

    ChkArg( f_poXMBContextA != NULL &&
            f_poXMBContextA->fInited );
         
    ChkDRMANSIString( f_pdastrAttrName );
    ChkDRMANSIString( f_pdastrAttrValue );

    if ( f_poXMBContextA->ichNextOpenNode + 1 >= f_poXMBContextA->cchBuffer )
    {
        /* Stack is empty. */
        ChkDR(DRM_E_NOMORE);
    }

    dasstrNameTrimmed.m_ich = 0;
    dasstrValueTrimmed.m_ich = 0;
    dasstrNameTrimmed.m_cch = f_pdastrAttrName->cchString;
    dasstrValueTrimmed.m_cch = f_pdastrAttrValue->cchString;
 
    _AllTrim2( f_pdastrAttrName->pszString, &dasstrNameTrimmed );
  
    /* Make sure the attribute name is not blank. */
    if ( dasstrNameTrimmed.m_cch == 0 )
    {
        ChkDR( DRM_E_INVALIDARG );
    }    

    /* Blank attrib value is allowed. */
    _AllTrim2( f_pdastrAttrValue->pszString, &dasstrValueTrimmed );

    /* Calculate the buffer size needed to insert the ' attr="value"'. 4 = space + equal sign + "". */
    cchRequired = dasstrNameTrimmed.m_cch +
                  dasstrValueTrimmed.m_cch +
                  4;

    /* Check whether there is enough space. */
    if ( f_poXMBContextA->ichNextString + cchRequired  < f_poXMBContextA->ichNextString ||
         f_poXMBContextA->ichNextString + cchRequired >= f_poXMBContextA->ichNextOpenNode )
    {
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }

    /* Retrieve the length of name of the current node from the top of the stack. */
    ChkDR( _GetTopDWORD( f_poXMBContextA, &ichInsert ) );

    /* Search for the position of the '>' character. */
    while ( ichInsert < f_poXMBContextA->cchBuffer &&
            GET_CHAR( f_poXMBContextA->rgchXML, ichInsert ) != '>' )
    {
        ichInsert++;
    }

    /* Check whether the '>' character is found. */
    if ( ichInsert >= f_poXMBContextA->cchBuffer ||
         GET_CHAR( f_poXMBContextA->rgchXML, ichInsert ) != '>' )
    {
        ChkDR( DRM_E_NOXMLCLOSETAG );
    }

    /*
    ** Now, rgchXML[ichInsert] contains the '>' char, output attr=value there.
    ** First, shift everything, if any, from '>' to allow space for the output.
    */
    ichDest = ichInsert + cchRequired;
    ichSource = ichInsert;

    if ( ichInsert + cchRequired  < ichInsert ||
         ichInsert + cchRequired >= f_poXMBContextA->cchBuffer )
    {
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    DRM_BYT_MoveBytes( f_poXMBContextA->rgchXML,
                       ichDest,
                       f_poXMBContextA->rgchXML,
                       ichSource,
                       f_poXMBContextA->ichNextString - ichInsert );

    /* Output the attribute name. */
    PUT_CHAR( f_poXMBContextA->rgchXML, ichInsert++, ' ' );

    DRM_BYT_CopyBytes( f_poXMBContextA->rgchXML, 
                       ichInsert, 
                       f_pdastrAttrName->pszString, 
                       dasstrNameTrimmed.m_ich, 
                       dasstrNameTrimmed.m_cch );

    ichInsert += dasstrNameTrimmed.m_cch;

    /* Output =". */
    PUT_CHAR( f_poXMBContextA->rgchXML, ichInsert++, '=' );
    PUT_CHAR( f_poXMBContextA->rgchXML, ichInsert++, '\"' );

    /* Output the attribute value. */
    DRM_BYT_CopyBytes( f_poXMBContextA->rgchXML, 
                       ichInsert, 
                       f_pdastrAttrValue->pszString, 
                       dasstrValueTrimmed.m_ich, 
                       dasstrValueTrimmed.m_cch );

    ichInsert += dasstrValueTrimmed.m_cch;
        
    /* Output " */
    PUT_CHAR( f_poXMBContextA->rgchXML, ichInsert++, '\"' );

    /* Update the output buffer pointer. */
    f_poXMBContextA->ichNextString += cchRequired;

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/******************************************************************************
**
** Function:   DRM_XMB_AddDataA
** 
** Synopsis:   API that adds a string data to the current node in the XML
**             builder context.
** 
** Arguments:
**
** [f_poXMBContextA]        -- Pointer to an initialized XML builder context.
** [f_pdastrData]           -- Pointer to a DRM_ANSI_CONST_STRING that contains
**                             the data to be added.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_NOMORE if there is no node opened.
**                          DRM_E_NOXMLCLOSETAG if the current node is not
**                          followed by a '>'.
**                          DRM_E_BUFFERTOOSMALL if the size of buffer in the XML
**                          builder context is not big enough to accomodate the data
**                          to be added.
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMB_AddDataA(
    __inout       _XMBContextA          *f_poXMBContextA,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrData )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD i = 0;
    DRM_SUBSTRING dasstrDataTrimmed = EMPTY_DRM_SUBSTRING;
    DRM_DWORD ichInsert = 0;
    DRM_DWORD ichDest = 0;
    DRM_DWORD ichSource = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_AddDataA );

    ChkArg( f_poXMBContextA != NULL &&
            f_poXMBContextA->fInited );

    ChkDRMANSIString( f_pdastrData );

    if ( f_poXMBContextA->ichNextOpenNode + 1 >= f_poXMBContextA->cchBuffer )
    {
        /* Stack is empty. */
        ChkDR( DRM_E_NOMORE );
    }

    dasstrDataTrimmed.m_ich = 0;
    dasstrDataTrimmed.m_cch = f_pdastrData->cchString;

    if ( !_AllTrim2( f_pdastrData->pszString, &dasstrDataTrimmed ) )
    {
        /* If the data being added is a blank string, nothing needs to be done. */
        goto ErrorExit;
    }
    
    /* Check whether there is enough space. */
    if ( ( f_poXMBContextA->ichNextString + dasstrDataTrimmed.m_cch ) < f_poXMBContextA->ichNextString ||
         ( f_poXMBContextA->ichNextString + dasstrDataTrimmed.m_cch ) >= f_poXMBContextA->ichNextOpenNode )
    {
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    /* Retrieve the length of name of the current node on top of the stack. */
    ChkDR( _GetTopDWORD( f_poXMBContextA, &ichInsert ) );

    /* Search for the position of the '>' character. */
    while ( ichInsert < f_poXMBContextA->cchBuffer &&
            GET_CHAR( f_poXMBContextA->rgchXML, ichInsert ) != '>' )
    {
        ichInsert++;
    }

    /* Check whether the '>' character is found. */
    if ( ichInsert >= f_poXMBContextA->cchBuffer ||
         GET_CHAR( f_poXMBContextA->rgchXML, ichInsert ) != '>' )
    {
        ChkDR( DRM_E_NOXMLCLOSETAG );
    }

    /*
    ** At this point, rgchXML[ichInsert] contains a '>' char, output data after it.
    ** first, shift all the existing output, if any, after '>' to allow space for the
    ** output.
    */
    ichInsert++;

    ichDest = f_poXMBContextA->ichNextString + dasstrDataTrimmed.m_cch - 1;
    ichSource = f_poXMBContextA->ichNextString - 1;
        
    for ( i = 0; i < ( f_poXMBContextA->ichNextString - ichInsert ); i++ )
    {
        PUT_CHAR( f_poXMBContextA->rgchXML,
                  ichDest--,
                  GET_CHAR( f_poXMBContextA->rgchXML, ichSource-- ) );
    }

    /* Make sure there is enough space left. */
    ChkBOOL( ( f_poXMBContextA->cchBuffer - ichInsert) > dasstrDataTrimmed.m_cch, DRM_E_BUFFERTOOSMALL );
  
    /* Output the data. */
    DRM_BYT_CopyBytes( f_poXMBContextA->rgchXML,
                       ichInsert,
                       f_pdastrData->pszString,
                       dasstrDataTrimmed.m_ich,
                       dasstrDataTrimmed.m_cch);

    /* Update the output buffer pointer. */
    f_poXMBContextA->ichNextString += dasstrDataTrimmed.m_cch;

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/******************************************************************************
**
** Function:   DRM_XMB_WriteTagA
** 
** Synopsis:   API that creates a new node that has optional data and attribute
**             pair in the XML builder context. The node is left open or closed
**             depending on an input enumeration value.
** 
** Arguments:
**
** [f_poXMBContextA]        -- Pointer to an initialized XML builder context.
** [f_pdastrTag]            -- Pointer to a DRM_ANSI_CONST_STRING that contains
**                             the name of the node to be added.
** [f_pdastrData]           -- Pointer to a DRM_ANSI_CONST_STRING that contains
**                             the data (optional) of the node to be added.
** [f_pdastrAttrName]       -- Pointer to a DRM_ANSI_CONST_STRING that contains
**                             the attribute name (optional) of the node to be added.
** [f_pdastrAttrValue]      -- Pointer to a DRM_ANSI_CONST_STRING that contains
**                             the attribute value (optional) of the node to be added.
** [f_wtt]                  -- Enumeration value indicating whether the node will
**                             remain open or closed after this API call.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMB_WriteTagA(
    __inout        _XMBContextA          *f_poXMBContextA,
    __in     const DRM_ANSI_CONST_STRING *f_pdastrTag,
    __in_opt const DRM_ANSI_CONST_STRING *f_pdastrData,
    __in_opt const DRM_ANSI_CONST_STRING *f_pdastrAttrName,
    __in_opt const DRM_ANSI_CONST_STRING *f_pdastrAttrValue,
    __in     enum  WriteTagType           f_wtt )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_WriteTagA );

    ChkArg( f_poXMBContextA != NULL &&
            f_poXMBContextA->fInited );
            
    ChkDRMANSIString( f_pdastrTag );
             
    ChkArg( ( f_pdastrAttrName == NULL && f_pdastrAttrValue == NULL) ||
            ( f_pdastrAttrName != NULL && f_pdastrAttrValue != NULL ) );
         
    /* Create the node. */
    ChkDR( DRM_XMB_OpenNodeA( f_poXMBContextA, f_pdastrTag ) );

    /* Add optional attribute pair. */
    if ( f_pdastrAttrName != NULL && f_pdastrAttrValue != NULL )
    {
        ChkDR( DRM_XMB_AddAttributeA( f_poXMBContextA, f_pdastrAttrName, f_pdastrAttrValue ) );
    }

    /* Add optional data. */
    if ( f_pdastrData != NULL )
    {
        ChkDR( DRM_XMB_AddDataA( f_poXMBContextA, f_pdastrData ) );
    }
    
    if ( f_wtt == wttClosed )
    {    
        ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMBContextA, NULL ) );
    }

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/******************************************************************************
**
** Function:   DRM_XMB_GetXMLBaseA
** 
** Synopsis:   API that retrieves the base pointer to an internal buffer of
**             the XML builder context.
** 
** Arguments:
**
** [f_poXMBContextA]        -- Pointer to an initialized XML builder context.
** [f_ppchBase]             -- Pointer to pointer to an internal buffer of the
**                             XML builder context.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMB_GetXMLBaseA(
    __inout _XMBContextA *f_poXMBContextA,
    __out   DRM_CHAR    **f_ppchBase )
{
    DRM_RESULT dr = DRM_SUCCESS;
    
    ChkArg( f_poXMBContextA != NULL &&
            f_ppchBase != NULL );
    
    *f_ppchBase = f_poXMBContextA->rgchXML;

ErrorExit:
    
    return dr;
}

/******************************************************************************
** Function:   DRM_XMB_AddCDataA
** 
** Synopsis:   API that adds a string data as a CDATA node to the current node
**             in the XML builder context.
** 
** Arguments:
**
** [f_poXMBContextA]        -- Pointer to an initialized XML builder context.
** [f_pdastrCData]          -- Pointer to a DRM_ANSI_CONST_STRING that contains
**                             the data to be added as a CDATA node.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_NOMORE if there is no node opened.
**                          DRM_E_NOXMLCLOSETAG if the current node is not
**                          followed by a '>'.
**                          DRM_E_BUFFERTOOSMALL if the size of buffer in the XML
**                          builder context is not big enough to accomodate the data
**                          to be added.
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XMB_AddCDataA(
    __inout       _XMBContextA          *f_poXMBContextA,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrCData )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD i = 0;
    DRM_SUBSTRING dasstrDataTrimmed = EMPTY_DRM_SUBSTRING;
    DRM_DWORD ichInsert = 0;
    DRM_DWORD cchReqSize = 0;
    DRM_DWORD ichDest = 0;
    DRM_DWORD ichSource = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_AddCDataA );
        
    ChkArg( f_poXMBContextA != NULL &&
            f_poXMBContextA->fInited );
            
    ChkDRMANSIString( f_pdastrCData );
    
    if ( f_poXMBContextA->ichNextOpenNode + 1 >= f_poXMBContextA->cchBuffer )
    {
        /* Stack is empty. */
        ChkDR( DRM_E_NOMORE );
    }
    
    dasstrDataTrimmed.m_ich = 0;
    dasstrDataTrimmed.m_cch = f_pdastrCData->cchString;

    /* Trim leading and trialing blanks, but blank CDATA value is allowed */
    if ( !_AllTrim2( f_pdastrCData->pszString, &dasstrDataTrimmed ) )
    {
        /* If the data being added is a blank string, nothing needs to be done. */
        goto ErrorExit;
    }

    /* Calculate the buffer size needed to insert <!<CDATA[xxx]]>. */
    cchReqSize = dasstrDataTrimmed.m_cch; 

    ChkOverflow( cchReqSize + g_dastrOpenCDATATag.cchString, cchReqSize );
    cchReqSize += g_dastrOpenCDATATag.cchString; 
    
    ChkOverflow( cchReqSize + g_dastrCloseCDATATag.cchString , cchReqSize );
    cchReqSize += g_dastrCloseCDATATag.cchString; 

    if ( ( f_poXMBContextA->ichNextString + cchReqSize ) < f_poXMBContextA->ichNextString ||
         ( f_poXMBContextA->ichNextString + cchReqSize ) >= f_poXMBContextA->ichNextOpenNode )
    {
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }
    
    /* Retrieve the length of name of the current node on top of the stack. */
    ChkDR( _GetTopDWORD( f_poXMBContextA, &ichInsert ));
        
    /* Search for the position of the '>' character. */
    while ( ichInsert < f_poXMBContextA->cchBuffer &&
            GET_CHAR( f_poXMBContextA->rgchXML, ichInsert ) != '>' )
    {
        ichInsert++;
    }    
        
    /* Check whether the '>' character is found. */
    if ( ichInsert >= f_poXMBContextA->cchBuffer ||
         GET_CHAR( f_poXMBContextA->rgchXML, ichInsert ) != '>' )
    {
        ChkDR( DRM_E_NOXMLCLOSETAG );
    }

    /*
    ** At this point, rgchXML[ichInsert] contains a '>' char, output data after it.
    ** first, shift all the existing output, if any, after '>' to allow space for the
    ** output.
    */
    ichInsert++;
    
    ichDest = f_poXMBContextA->ichNextString + cchReqSize - 1;
    ichSource = f_poXMBContextA->ichNextString - 1;
           
    for ( i = 0; i < ( f_poXMBContextA->ichNextString - ichInsert ); i++ )
    {
        PUT_CHAR( f_poXMBContextA->rgchXML,
                  ichDest--,
                  GET_CHAR( f_poXMBContextA->rgchXML, ichSource-- ) );
    }

    /* Make sure there is enough space left. */
    ChkBOOL( ( f_poXMBContextA->cchBuffer - ichInsert) > cchReqSize, DRM_E_BUFFERTOOSMALL );
    
    /* Output the CDATA node. */
    DRM_BYT_CopyBytes( f_poXMBContextA->rgchXML,
                       ichInsert,
                       g_dastrOpenCDATATag.pszString,
                       0,
                       g_dastrOpenCDATATag.cchString );

    ichInsert += g_dastrOpenCDATATag.cchString;

    DRM_BYT_CopyBytes( f_poXMBContextA->rgchXML,
                       ichInsert,
                       f_pdastrCData->pszString,
                       dasstrDataTrimmed.m_ich,
                       dasstrDataTrimmed.m_cch );

    ichInsert += dasstrDataTrimmed.m_cch;
                       
    DRM_BYT_CopyBytes( f_poXMBContextA->rgchXML,
                       ichInsert,
                       g_dastrCloseCDATATag.pszString,
                       0,
                       g_dastrCloseCDATATag.cchString );
                       
     /* Update the output buffer pointer. */
    f_poXMBContextA->ichNextString += cchReqSize;

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/******************************************************************************
**
** Function:   DRM_XMB_WriteTagA
** 
** Synopsis:   API that creates a new node that has optional CDATA node data and
**             attribute pair in the XML builder context. The node is left open
**             or closed depending on an input enumeration value.
** 
** Arguments:
**
** [f_poXMBContextA]        -- Pointer to an initialized XML builder context.
** [f_pdastrTag]            -- Pointer to a DRM_ANSI_CONST_STRING that contains
**                             the name of the node to be added.
** [f_pdastrData]           -- Pointer to a DRM_ANSI_CONST_STRING that contains
**                             the data (optional) that is to be put into the CDATA
**                             node within the node to be added.
** [f_pdastrAttrName]       -- Pointer to a DRM_ANSI_CONST_STRING that contains
**                             the attribute name (optional) of the node to be added.
** [f_pdastrAttrValue]      -- Pointer to a DRM_ANSI_CONST_STRING that contains
**                             the attribute value (optional) of the node to be added.
** [f_wtt]                  -- Enumeration value indicating whether the node will
**                             remain open or closed after this API call.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XMB_WriteCDATATagA(
    __inout       _XMBContextA *f_poXMBContextA,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrTag,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrCData,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrAttrName,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrAttrValue,
    __in    enum  WriteTagType f_wtt )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_WriteCDATATagA );

    ChkArg( f_poXMBContextA != NULL &&
            f_poXMBContextA->fInited );
            
    ChkDRMANSIString( f_pdastrTag );

    ChkArg( ( f_pdastrAttrName == NULL && f_pdastrAttrValue == NULL) ||
            ( f_pdastrAttrName != NULL && f_pdastrAttrValue != NULL ) );

    /* Create the node. */
    ChkDR( DRM_XMB_OpenNodeA( f_poXMBContextA, f_pdastrTag ) );

    /* Add optional attribute pair. */
    if ( f_pdastrAttrName != NULL && f_pdastrAttrValue != NULL )
    {
        ChkDR( DRM_XMB_AddAttributeA( f_poXMBContextA, f_pdastrAttrName, f_pdastrAttrValue ) );
    }

    /* Add optional CDATA. */
    if ( f_pdastrCData != NULL )
    {
        ChkDR( DRM_XMB_AddCDataA( f_poXMBContextA, f_pdastrCData ) );
    }
    
    if ( f_wtt == wttClosed )
    {    
        ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMBContextA, NULL ) );
    }

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/******************************************************************************
**
** Function:   DRM_XMB_ReserveSpaceA
** 
** Synopsis:   API that reserve a specific number of characters in the XML builder
**             context.
** 
** Arguments:
**
** [f_poXMBContextA]        -- Pointer to an initialized XML builder context.
** [f_cchAlignment]         -- An integer that defines the alignment of the start
**                             address of the buffer space reserved. For example,
**                             if the start address should be aligned to DWORD,
**                             f_cchAlignment should be SIZEOF(DRM_DWORD).
** [f_cchData]              -- Number of characters to reserve in the XML builder
**                             context.
** [f_pdasstrData]          -- Pointer to a sub string that receives the portion of
**                             the internal XML builder context buffer that has been
**                             reserved.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the size of buffer in the XML
**                          builder context is not big enough to accomodate the data
**                          to be added.
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMB_ReserveSpaceA(
    __inout       _XMBContextA  *f_poXMBContextA,
    __in          DRM_DWORD      f_cchAlignment,
    __in    const DRM_DWORD      f_cchData,
    __out         DRM_SUBSTRING *f_pdasstrData )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD ichStart = 0, cchShift = 0, ich = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_ReserveSpaceA );

    ChkArg( f_poXMBContextA != NULL &&
            f_poXMBContextA->fInited );
            
    ChkArg( f_cchAlignment != 0 );
    ChkArg( f_cchData > 0 );
    ChkArg( f_pdasstrData != NULL );

    /* Check whether there is enough space. */
    if ( ( f_poXMBContextA->ichNextString + f_cchData ) < f_poXMBContextA->ichNextString ||
         ( f_poXMBContextA->ichNextString + f_cchData ) >= f_poXMBContextA->ichNextOpenNode )
    {
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    ichStart = f_poXMBContextA->ichNextString;

    if ( ichStart % f_cchAlignment != 0)
    {
        cchShift = f_cchAlignment - ( ichStart % f_cchAlignment );

        /* Fill the 'hole' with spaces. */
        for ( ich = 0; ich < cchShift; ich++ )
        {
            PUT_CHAR( f_poXMBContextA->rgchXML,
                      ichStart + ich,
                      ' ' );
        }

        f_poXMBContextA->ichNextString += cchShift;
    }

    f_pdasstrData->m_ich = f_poXMBContextA->ichNextString;
    f_pdasstrData->m_cch = f_cchData;

    /* Update the output buffer pointer. */
    f_poXMBContextA->ichNextString += f_cchData;

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/******************************************************************************
**
** Function:   DRM_XMB_ShiftDataFromCurrentPositionA
** 
** Synopsis:   API that shift a specific number of characters from the current
**             buffer position in the XML builderto a buffer position of a
**             higer address.
** 
** Arguments:
**
** [f_poXMBContextA]        -- Pointer to an initialized XML builder context.
** [f_cchShift]             -- Amount (number of characters) of the shift from
**                             the current bufer position in the XML builder
**                             context.
** [f_cchData]              -- Number of characters to shift from the current
**                             buffer position in the XML builder context.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the size of buffer in the XML
**                          builder context is not big enough to satisfy the
**                          operation.
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMB_ShiftDataFromCurrentPositionA(
    __inout       _XMBContextA *f_poXMBContextA,
    __in    const DRM_DWORD     f_cchShift,
    __in    const DRM_DWORD     f_cchData )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD ichTarget = 0, ich = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_ShiftDataFromCurrentPositionA );

    ChkArg( f_poXMBContextA != NULL &&
            f_poXMBContextA->fInited );

    ChkArg( f_cchData > 0 );

    /* Check whether there is enough space. */
    if ( ( f_poXMBContextA->ichNextString + f_cchShift + f_cchData ) < f_poXMBContextA->ichNextString ||
         ( f_poXMBContextA->ichNextString + f_cchShift + f_cchData ) >= f_poXMBContextA->ichNextOpenNode )
    {
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    ichTarget = f_poXMBContextA->ichNextString + f_cchShift;

    DRM_BYT_MoveBytes( f_poXMBContextA->rgchXML,
                       ichTarget,
                       f_poXMBContextA->rgchXML,
                       f_poXMBContextA->ichNextString,
                       f_cchData );

    /* Fill the 'hole' with spaces. */
    for ( ich = 0; ich < f_cchShift; ich++ )
    {
        PUT_CHAR( f_poXMBContextA->rgchXML,
                  f_poXMBContextA->ichNextString + ich,
                  ' ' );
    }

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/******************************************************************************
**
** Function:   DRM_XMB_ShiftCurrentPointerA
** 
** Synopsis:   API that shift the current buffer pointer in the XML builder
**             context to a position of a higer address.
** 
** Arguments:
**
** [f_poXMBContextA]        -- Pointer to an initialized XML builder context.
** [f_cchShift]             -- Amount (number of characters) of the shift from
**                             the current position in the XML builder context.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the size of buffer in the XML
**                          builder context is not big enough to satisfy the
**                          operation.
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMB_ShiftCurrentPointerA(
    __inout       _XMBContextA *f_poXMBContextA,
    __in    const DRM_DWORD     f_cchShift )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_ShiftCurrentPointerA );

    ChkArg( f_poXMBContextA != NULL &&
            f_poXMBContextA->fInited );

    /* Check whether there is enough space. */
    if ( ( f_poXMBContextA->ichNextString + f_cchShift ) < f_poXMBContextA->ichNextString ||
         ( f_poXMBContextA->ichNextString + f_cchShift ) >= f_poXMBContextA->ichNextOpenNode )
    {
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    f_poXMBContextA->ichNextString += f_cchShift;

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/******************************************************************************
**
** Function:   DRM_XMB_GetCurrentBufferPointerA
** 
** Synopsis:   API that returns the current aligned buffer pointer in the XML
**             builder context.
** 
** Arguments:
**
** [f_poXMBContextA]        -- Pointer to an initialized XML builder context.
** [f_fAligned]             -- Flag indicating whether the returned buffer pointer
**                             should be aligned.
** [f_ppchBufferPointer]    -- Pointer to a variable to receive the current
**                             aligned buffer pointer in the XML builder context.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMB_GetCurrentBufferPointerA(
    __inout _XMBContextA *f_poXMBContextA,
    __in    DRM_BOOL      f_fAligned,
    __out DRM_CHAR      **f_ppchBufferPointer )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchExtra = 0;
    DRM_DWORD ich = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_GetCurrentBufferPointerA );

    ChkArg( f_poXMBContextA != NULL &&
            f_poXMBContextA->fInited );
    ChkArg( f_ppchBufferPointer != NULL );

    if ( f_fAligned )
    {
        cchExtra = f_poXMBContextA->ichNextString % SIZEOF( DRM_WORD );

        if ( cchExtra != 0 )
        {
            cchExtra = SIZEOF( DRM_WORD ) - cchExtra;

            /* Fill the 'hole' with spaces. */
            for ( ich = 0; ich < cchExtra; ich++ )
            {
                PUT_CHAR( f_poXMBContextA->rgchXML,
                          f_poXMBContextA->ichNextString + ich,
                          ' ' );
            }

            f_poXMBContextA->ichNextString += cchExtra;
        }
    }
 
    *f_ppchBufferPointer = f_poXMBContextA->rgchXML +
                           __CB_DECL( f_poXMBContextA->ichNextString );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/**********************************************************************
** Function:    DRM_XMB_AppendNodeA
** Synopsis:    Appends a caller provided node nested from current opened node
** Arguments:   [pXmlContextA]    -- UTF-8 XML context
**              [pdastrXmlString] -- pointer to UTF-8 string to add
** Returns:     DRM_SUCCESS on success
** Notes:       The caller is responsible for the validity of the appending node
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XMB_AppendNodeA(
    __inout       _XMBContextA          *f_poXMBContextA,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrXmlString )
{
    DRM_RESULT    dr        = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_AppendNodeA );

    ChkArg( f_poXMBContextA != NULL )
    ChkArg( f_poXMBContextA->fInited );
    ChkDRMANSIString( f_pdastrXmlString );

    if ( f_poXMBContextA->ichNextString + f_pdastrXmlString->cchString < f_poXMBContextA->ichNextString
      || f_poXMBContextA->ichNextString + f_pdastrXmlString->cchString >= f_poXMBContextA->ichNextOpenNode)
    {
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }
    
    ChkOverflow( f_poXMBContextA->cchBuffer, f_poXMBContextA->cchBuffer - f_poXMBContextA->ichNextString );

    ChkDR( DRM_STR_StringCchCopyNA( &f_poXMBContextA->rgchXML [f_poXMBContextA->ichNextString], 
                                    f_poXMBContextA->cchBuffer - f_poXMBContextA->ichNextString,
                                    f_pdastrXmlString->pszString, 
                                    f_pdastrXmlString->cchString ) );
    
    f_poXMBContextA->ichNextString += f_pdastrXmlString->cchString;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmxmlbuilder.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmbase64.h>
#include <drmcrt.h>
#include <drmutilities.h>
#include <drmcipher.h>
#include <drmxmlbuilder.h>

ENTER_PK_NAMESPACE_CODE;

#define CB_XML_BUFFER_MINIMUM  100
#define CWCH_DWORD_STACK       (SIZEOF(DRM_DWORD)/SIZEOF(DRM_WCHAR))
#define CCH_SIMULATION_MININUM (2*CWCH_DWORD_STACK)

/******************************************************************************
** Function:   _GetPushedDWORD
** 
** Synopsis:   pop a DWORD value from the end of the stack 
** 
** Arguments:  f_pcontextXML - the XML context in use; must be inited
**             f_iOffset     - an offset from the current stack position
**             f_pdwValue    - pointer to variable to hold the retrieved value
******************************************************************************/
static DRM_RESULT _GetPushedDWORD( __in  _XMBContext *f_pcontextXML,
                                   __in  DRM_DWORD    f_iOffset,
                                   __out DRM_DWORD   *f_pdwValue)
{
    DRM_RESULT dr = DRM_SUCCESS;
    
    ChkArg(f_pcontextXML != NULL
        && f_pdwValue    != NULL);

    ChkArg((f_pcontextXML->wNextOpenNodePos + f_iOffset) >= CWCH_DWORD_STACK);

    *f_pdwValue  =  (DRM_DWORD)  (f_pcontextXML->XmlString [f_pcontextXML->wNextOpenNodePos + f_iOffset + 1]);
    *f_pdwValue += ((DRM_DWORD) ((f_pcontextXML->XmlString [f_pcontextXML->wNextOpenNodePos + f_iOffset])) << 16);

ErrorExit:
    return dr;
}

/*
** Close the current opened node
*/
static DRM_RESULT DRM_CALL _CloseCurrNode(
    __inout   _XMBContext *pXmlContext,
    __in      DRM_BOOL     fOkayToCloseRoot,
    __out_opt DRM_STRING  *pdstrXMLString)   /* optional parameter */
{
    DRM_RESULT   dr          = DRM_SUCCESS;
    DRM_DWORD    wLen        = 0;
    DRM_DWORD    wNodePos    = 0;
    DRM_DWORD    cwchMinStack = 0;

    ChkArg(pXmlContext->fInited);

    /*
    ** make sure the stack is not empty. Stack is count by CWCH_DWORD_STACK. 
    ** to close a node, we must have at least ONE CWCH_DWORD_STACK on stack.
    ** if fOkayToCloseRoot is FALSE, we must have at least two CWCH_DWORD_STACK
    ** on stack.
    */
    cwchMinStack = 2 * CWCH_DWORD_STACK;  /* do not pop off the root node */
    if (fOkayToCloseRoot)
    {
        cwchMinStack = CWCH_DWORD_STACK;  /* root node */
    }

    if ( (pXmlContext->wNextOpenNodePos + cwchMinStack) >= pXmlContext->wBuffSize )    /* do not pop off the root node !*/
    {
        dr = DRM_E_NOMORE;    /* stack is empty */
        goto ErrorExit;
    }

    if ( !pXmlContext->fIsSimMode )
    {
        /* parse length of node name */

        ChkDR(_GetPushedDWORD(pXmlContext, CWCH_DWORD_STACK, &wNodePos));

        if ( pdstrXMLString != NULL )
        {
            pdstrXMLString->pwszString = &(pXmlContext->XmlString[wNodePos - 1]);    
        }

        while (pXmlContext->XmlString [wNodePos + wLen] != g_wchSpace 
            && pXmlContext->XmlString [wNodePos + wLen] != g_wchGreaterThan )
        {
            wLen++;
        }
        
        if ( pXmlContext->wNextStringPos + wLen      < pXmlContext->wNextStringPos
          || pXmlContext->wNextStringPos + wLen + 3  < pXmlContext->wNextStringPos
          || pXmlContext->wNextStringPos + wLen + 3 >= pXmlContext->wNextOpenNodePos )
        {
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }

        /* print </tag> to the XML string*/
        ChkDR( DRM_STR_StringCchCopyNW(&pXmlContext->XmlString[pXmlContext->wNextStringPos], 
                                   pXmlContext->wBuffSize - pXmlContext->wNextStringPos, 
                                   g_dstrOpenEndTag.pwszString, 
                                   g_dstrOpenEndTag.cchString) );
        pXmlContext->wNextStringPos += 2;
        
        ChkDR( DRM_STR_StringCchCopyNW(&pXmlContext->XmlString[pXmlContext->wNextStringPos], 
                                   pXmlContext->wBuffSize - pXmlContext->wNextStringPos, 
                                  &pXmlContext->XmlString[wNodePos], 
                                   wLen) );
        pXmlContext->wNextStringPos += wLen;
        
        ChkDR( DRM_STR_StringCchCopyNW(&pXmlContext->XmlString[pXmlContext->wNextStringPos], 
                                   pXmlContext->wBuffSize - pXmlContext->wNextStringPos, 
                                   g_dstrCloseTag.pwszString, 
                                   g_dstrCloseTag.cchString) );
        pXmlContext->wNextStringPos += 1;

        /* pop the node position from end of XML string */
        pXmlContext->wNextOpenNodePos += CWCH_DWORD_STACK;
    }
    else
    {
        DRM_DWORD cchPop = 0;
        
        ChkDR(_GetPushedDWORD(pXmlContext, CWCH_DWORD_STACK, &cchPop));
        ChkDR(_GetPushedDWORD(pXmlContext, 2 * CWCH_DWORD_STACK, &wNodePos));
                              
        /* calculate length of the close tag now 3 = "</>" */
        
        pXmlContext->wNextStringPos += cchPop + 3;

        /* pop the node position and tag name size from end of XML string */

        pXmlContext->wNextOpenNodePos += 2 * CWCH_DWORD_STACK;
    }

    if ( pdstrXMLString != NULL )
    {
        pdstrXMLString->cchString = pXmlContext->wNextStringPos - wNodePos + 1;
    }

ErrorExit:
    return dr;
}

/*
** calcuate the current node size
*/
static DRM_RESULT DRM_CALL _CalcNodeSize(
    __in  _XMBContext *pbXmlContext,
    __out DRM_DWORD   *pcchContent,  /* ch count of node content */
    __out DRM_DWORD   *pcchTagName)  /* ch count of node tag */
{
    DRM_RESULT   dr       = DRM_SUCCESS;
    DRM_DWORD    wLen     = 0;
    DRM_DWORD    wNodePos = 0;

    ChkArg( pbXmlContext != NULL
         && pcchContent  != NULL
         && pcchTagName  != NULL
         && pbXmlContext->fInited );

    if ( pbXmlContext->fIsSimMode )
    {
        _GetPushedDWORD(pbXmlContext, CWCH_DWORD_STACK,  pcchTagName);
        _GetPushedDWORD(pbXmlContext, 2 * CWCH_DWORD_STACK, &wNodePos);
        
        /* this is not accurate in case the open node has attributes */
        *pcchContent = pbXmlContext->wNextStringPos - wNodePos - *pcchTagName - 1;
    }
    else
    {
        /* parse length of node name */
        
        _GetPushedDWORD(pbXmlContext, CWCH_DWORD_STACK, &wNodePos);
        
        while (pbXmlContext->XmlString [wNodePos + wLen] != g_wchSpace 
            && pbXmlContext->XmlString [wNodePos + wLen] != g_wchGreaterThan )
        {
            wLen++;
        }
        *pcchTagName = wLen;

        /* parse first position of node content */
        while (pbXmlContext->XmlString[wNodePos + wLen] != g_wchGreaterThan )
        {
            wLen++;
        }
        *pcchContent = pbXmlContext->wNextStringPos - wNodePos - wLen - 1;
    }
    
ErrorExit:
    return dr;
}

DRM_API DRM_RESULT DRM_CALL DRM_XMB_EncryptAndCloseCurrNode(
    __inout         _XMBContext        *pXmlContext,
    __in            DRM_CRYPTO_CONTEXT *pCryptoContext,    /* Pointer to DRM_CRYPTO_CONTEXT */
    __in_opt        DRM_VOID           *pOEMContext,
    __in      const PUBKEY             *pPubkey,           /* pub key to use for encrypt */
    __out_opt       DRM_STRING         *pdstrXMLFragment)  /* optional: XML fragment of the current node, optional. */
{
    DRM_RESULT   dr = DRM_SUCCESS;
    DRM_DWORD    cchContent = 0;
    DRM_DWORD    cbCryptSize= 0;
    DRM_DWORD    cchEncoded = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_EncryptAndCloseCurrNode );

    ChkArg( pXmlContext   != NULL
         && pCryptoContext != NULL
         && pPubkey        != NULL
         && pXmlContext->fInited );
    

    /*
    ** 1. check available buffer size: 
    **    req size = SIZEOF(WCHAR) * ((blob_size + DRM_ECC160_CIPHERTEXT_LEN + 2) / 3 * 4)
    ** 2. call EncryptLarge to encrypt the blob in place
    ** 3. call Base64Encode the encrypted data
    ** 4. close the node 
    */

    /* check available space */
    {
        DRM_DWORD cchTagName=0;

        ChkDR(_CalcNodeSize(pXmlContext, &cchContent, &cchTagName));

        /* req size for encryption */    
        cbCryptSize = cchContent * SIZEOF(DRM_WCHAR) + DRM_ECC160_CIPHERTEXT_LEN;
        
        /* req size for base64 encode after encryption */
        cchEncoded = CCH_BASE64_EQUIV( cbCryptSize );
        
        if ( !pXmlContext->fIsSimMode )
        {
            if( pXmlContext->wNextStringPos - cchContent  > pXmlContext->wNextStringPos 
             || pXmlContext->wNextStringPos - cchContent >= pXmlContext->wBuffSize )
            {
                ChkDR(DRM_E_BUFFERTOOSMALL);
            }
        }
    }

    if ( !pXmlContext->fIsSimMode )
    {
        /* encrypt the content */
        ChkDR(DRM_PK_EncryptLarge(pOEMContext,
                                  pPubkey, 
                     (DRM_BYTE*)(&pXmlContext->XmlString[pXmlContext->wNextStringPos-cchContent]),
                                  cchContent * SIZEOF(DRM_WCHAR), 
                     (DRM_BYTE*)(&pXmlContext->XmlString[pXmlContext->wNextStringPos-cchContent]), /* encrypt in place */
                                  DRMCIPHERKEYLEN_RC4,
                                  pCryptoContext));
        
        /* base64 encode the crypted blob */
        ChkDR(DRM_B64_EncodeW( (DRM_BYTE*)(&pXmlContext->XmlString[pXmlContext->wNextStringPos-cchContent]), 
                                            cbCryptSize,
                                           &pXmlContext->XmlString[pXmlContext->wNextStringPos-cchContent],  /* encode in place */
                                           &cchEncoded, 
                                            0));
    }
    
    /* update wNextStringPos */
    pXmlContext->wNextStringPos = pXmlContext->wNextStringPos - cchContent + cchEncoded;

    /* now close the node */
    ChkDR(_CloseCurrNode(pXmlContext, FALSE, pdstrXMLFragment));

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


DRM_API DRM_RESULT DRM_CALL DRM_XMB_SignAndCloseCurrNode(
    __inout                                       _XMBContext        *pbXmlContext,
    __in                                          DRM_CRYPTO_CONTEXT *pCryptoContext,  /* Pointer to DRM_CRYPTO_CONTEXT */
    __in    const                                 PRIVKEY            *pPrivkey,        /* pub key to use for encrypt */
    __in                                          DRM_BOOL            fIncludeTag,
    __out_bcount_opt(DRM_ECC160_SIGNATURE_LEN)    DRM_BYTE            rgbSign   [__CB_DECL(DRM_ECC160_SIGNATURE_LEN)], /* cannot be both NULL */
    __out_ecount_opt(DRM_ECC160_SIGNATURE_B64LEN) DRM_WCHAR           wszB64Sign[DRM_ECC160_SIGNATURE_B64LEN], /* cannot be both NULL */
    __out_opt                                     DRM_STRING         *pdstrXMLFragment)  /* optional: XML fragment of the current node, optional. */
{
    DRM_RESULT   dr = DRM_SUCCESS;
    DRM_DWORD    cchContent=0;
    DRM_DWORD    cchTagName=0;
    DRM_STRING   dstrXMLFragment = EMPTY_DRM_STRING;
    DRM_BYTE     _rgbSign[__CB_DECL(DRM_ECC160_SIGNATURE_LEN)]={0};
    DRM_BYTE    *prgbSign = _rgbSign;
    DRM_DWORD    cbSignature = DRM_ECC160_SIGNATURE_LEN;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_SignAndCloseCurrNode );

    ChkArg( pbXmlContext   != NULL
         && pCryptoContext != NULL
         && pPrivkey       != NULL
         && ( rgbSign      != NULL 
           || wszB64Sign   != NULL ) 
         && pbXmlContext->fInited   );
    
    ChkDR(_CalcNodeSize(pbXmlContext, &cchContent, &cchTagName));

    if ( rgbSign != NULL )
    {
        prgbSign = rgbSign;
    }

    if ( !pbXmlContext->fIsSimMode )
    {
        if ( !fIncludeTag )
        {
            /* sign the content */
            ChkDR(DRM_PK_Sign(pCryptoContext->rgbCryptoContext, 
                              eDRM_ECC_P160,
                              DRM_ECC160_PRIVATE_KEY_LEN,
                              ( const DRM_BYTE * )pPrivkey,
                              cchContent * SIZEOF(DRM_WCHAR),
                              (DRM_BYTE*)(&pbXmlContext->XmlString[pbXmlContext->wNextStringPos-cchContent]),
                              &cbSignature,
                              prgbSign));                                                             
        }
    }
    
    /* close the node */
    ChkDR(_CloseCurrNode(pbXmlContext, FALSE, &dstrXMLFragment));

    if ( !pbXmlContext->fIsSimMode )
    {
        if ( fIncludeTag )
        {
            /* sign the content */
            ChkDR(DRM_PK_Sign(pCryptoContext->rgbCryptoContext, 
                              eDRM_ECC_P160,
                              DRM_ECC160_PRIVATE_KEY_LEN,
                              ( const DRM_BYTE * )pPrivkey,
                              CB_DSTR( &dstrXMLFragment ),
                              PB_DSTR( &dstrXMLFragment ),
                              &cbSignature,
                              prgbSign));                             
        }

        /* Base64 encode the signature */
        if ( wszB64Sign )
        {
            DRM_DWORD cchEncoded=DRM_ECC160_SIGNATURE_B64LEN;
            
            ChkDR(DRM_B64_EncodeW( prgbSign, 
                                   cbSignature, 
                                   (DRM_WCHAR *)wszB64Sign, 
                                   &cchEncoded, 
                                   0));
        }
    }
    
    if ( pdstrXMLFragment )
    {
        *pdstrXMLFragment = dstrXMLFragment;
    }

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


DRM_API DRM_RESULT DRM_CALL DRM_XMB_KeyedHashAndCloseCurrNode(
    __inout                                      _XMBContext        *pbXmlContext,
    __in                                         DRM_HMAC_CONTEXT   *pHmacContext,     /* HMAC context */
    __in_bcount(cbHashkey) const                 DRM_BYTE           *pbHashkey,        /* Hash key for HMAC */
    __in                                         DRM_DWORD           cbHashkey,        /* byte count of HMAC */
    __in                                         DRM_BOOL            fIncludeTag,
    __out_bcount_opt(DRM_SHA1_DIGEST_LEN)        DRM_BYTE            rgbSign   [__CB_DECL(DRM_SHA1_DIGEST_LEN)],       /* cannot be both NULL */
    __out_ecount_opt(SHA_B64ENC_DIGEST_LEN_CALC) DRM_WCHAR           wszB64Sign[DRM_SHA1_B64ENC_DIGEST_LEN], /* cannot be both NULL */
    __out_opt                                    DRM_STRING         *pdstrXMLFragment)  /* optional: XML fragment of the current node, optional. */
{
    DRM_RESULT   dr = DRM_SUCCESS;
    DRM_DWORD    cchContent = 0;
    DRM_DWORD    cchTagName = 0;
    DRM_STRING   dstrXMLFragment = EMPTY_DRM_STRING;
    DRM_BYTE     _rgbSign [__CB_DECL(DRM_SHA1_DIGEST_LEN)];
    DRM_BYTE    *prgbSign = _rgbSign;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_KeyedHashAndCloseCurrNode );

    DRMCASSERT( SHA_B64ENC_DIGEST_LEN_CALC == DRM_SHA1_B64ENC_DIGEST_LEN );

    ChkArg( pbXmlContext != NULL
         && pHmacContext != NULL
         && pbHashkey    != NULL
         && cbHashkey    != 0
         && ( rgbSign    != NULL
           || wszB64Sign != NULL )
         && pbXmlContext->fInited );
    
    ChkDR(_CalcNodeSize(pbXmlContext, &cchContent, &cchTagName));

    if ( rgbSign )
    {
        prgbSign = rgbSign;
    }


    if ( !pbXmlContext->fIsSimMode )
    {
        ChkDR(DRM_HMAC_Init(pHmacContext,eDRM_SHA_1,pbHashkey,cbHashkey));
        if ( !fIncludeTag )
        {
            /* sign the content */
            ChkDR(DRM_HMAC_Update( pHmacContext,
                      (DRM_BYTE*)(&pbXmlContext->XmlString[pbXmlContext->wNextStringPos - cchContent]),
                                   cchContent * SIZEOF(DRM_WCHAR)));
        }
    }
    
    /* close the node */
    ChkDR(_CloseCurrNode(pbXmlContext, FALSE, &dstrXMLFragment));

    if ( !pbXmlContext->fIsSimMode )
    {
        if ( fIncludeTag )
        {
            /* sign the content */
            ChkDR(DRM_HMAC_Update(pHmacContext, PB_DSTR(&dstrXMLFragment), CB_DSTR(&dstrXMLFragment)));
        }
        ChkDR(DRM_HMAC_Finalize(pHmacContext,prgbSign,DRM_SHA1_DIGEST_LEN));
    
        /* Base64 encode the signature */
        if ( wszB64Sign )
        {
            DRM_DWORD cchEncoded=DRM_SHA1_B64ENC_DIGEST_LEN;
            
            ChkDR(DRM_B64_EncodeW(prgbSign, 
                                  DRM_SHA1_DIGEST_LEN, 
                     (DRM_WCHAR *)wszB64Sign, 
                                 &cchEncoded, 
                                  0));
        }
    }

    if ( pdstrXMLFragment )
    {
        *pdstrXMLFragment = dstrXMLFragment;
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmxmlparser.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmxmlparser.h>
#include <drmcrt.h>
#include <drmbase64.h>
#include <drmutilities.h>
#include <drmcipher.h>
#include <drmhmac.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

/*********************************************************************
** Function  : _TranslateXMLError
**
** Synopsis  : Converts XML parsing errors into more meaningful ones.
** 
** Arguments  
** [f_drXML] : Input DRM_RESULT code
**
** Returns   : DRM_RESULT
**             output error code
*********************************************************************/
DRMFORCEINLINE DRM_RESULT _TranslateXMLError(
    IN DRM_RESULT f_drXML )
{
    DRM_RESULT dr = f_drXML;

    switch (dr)
    {
    case DRM_E_NOXMLOPENTAG:
        dr = DRM_E_XMLNOTFOUND;
        break;

    default:
        dr = f_drXML;
        break;
    }

    return dr;
}


DRM_API DRM_RESULT DRM_CALL DRM_XML_GetAndDecryptNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,           /* nth occurence of the node in the xml stirng, start from 0 */
    IN  DRM_CRYPTO_CONTEXT     *f_pcontextCRYP,    /* Pointer to DRM_CRYPTO_CONTEXT */
    IN  PRIVKEY                *f_pprivkey,          /* priv key to use for decrypt */
    OUT DRM_CONST_STRING       *f_pdstrNode,      /* either of these 2 parameter can be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrNodeData)  /* data enclosed by the immediate <tag>...</tag> in the given XML string */
{
    return DRM_XML_GetAndDecryptSubNode(f_pdstrXML,
                                        f_pdstrTag,
                                        f_pdstrAttrName,
                                        f_pdstrAttrValue,
                                        f_iNode,
                                        f_pcontextCRYP,
                                        f_pprivkey,
                                        f_pdstrNode,
                                        f_pdstrNodeData,
                                        0);
}


/*
** extract license node from given XML string matching <tag AttrName="Value"> ... </tag>
*/
DRM_API DRM_RESULT DRM_CALL DRM_XML_GetAndDecryptSubNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,        /* nth occurence of the node in the xml stirng, start from 0 */
    IN  DRM_CRYPTO_CONTEXT     *f_pcontextCRYP, /* Pointer to DRM_CRYPTO_CONTEXT */
    IN  PRIVKEY                *f_pprivkey,     /* priv key to use for decrypt */
    OUT DRM_CONST_STRING       *f_pdstrNode,    /* these two parameters can either be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrNodeData,
    IN  DRM_DWORD               f_iLayer)       /* outermost layer is 0 */
{
    DRM_CONST_STRING dstrXMLNode     = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrXMLNodeData = EMPTY_DRM_STRING;
    DRM_RESULT       dr          = DRM_SUCCESS;
    DRM_DWORD        cbDecoded     = 0;
    DRM_DWORD        i           = 0;
    DRM_WCHAR       *_pwszString = NULL;

    ChkArg(f_pcontextCRYP  != NULL
        && f_pprivkey      != NULL);
         
    ChkArg(f_pdstrNode     != NULL 
        || f_pdstrNodeData != NULL);

    /* get the node first */

    ChkDR(DRM_XML_GetSubNode(f_pdstrXML, 
                             f_pdstrTag, 
                             f_pdstrAttrName, 
                             f_pdstrAttrValue, 
                             f_iNode, 
                            &dstrXMLNode,
                            &dstrXMLNodeData, 
                             f_iLayer));

    /* base64 decode in-place */

    ChkDR(DRM_B64_DecodeW(&dstrXMLNodeData, &cbDecoded, NULL, DRM_BASE64_DECODE_IN_PLACE));

    /* decrypt the node data in-place */
                                
    ChkDR (DRM_PK_DecryptLarge (f_pprivkey, 
                                PB_DSTR(&dstrXMLNodeData),
                                cbDecoded,
                                PB_DSTR(&dstrXMLNodeData),
                                f_pcontextCRYP));

    /* fill the "empty space" with blanks */
    cbDecoded = (cbDecoded - DRM_ECC160_CIPHERTEXT_LEN) / SIZEOF(DRM_WCHAR);

    _pwszString = (DRM_WCHAR*)(dstrXMLNodeData.pwszString);
    for (i = 0; i < (dstrXMLNodeData.cchString - cbDecoded); i++)
    {
        _pwszString [cbDecoded+i] = g_wchSpace;
    }

    dstrXMLNodeData.cchString = cbDecoded;

    /* prepare for return value */
    if (f_pdstrNode != NULL)
    {
        ASSIGN_DRM_STRING(*f_pdstrNode, dstrXMLNode);
    }

    if (f_pdstrNodeData != NULL)
    {
        ASSIGN_DRM_STRING(*f_pdstrNodeData, dstrXMLNodeData);
    }
    
ErrorExit:

    return _TranslateXMLError(dr);
}

DRM_API DRM_RESULT DRM_CALL DRM_XML_GetAndVerifyKeyedHashNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,              /* nth occurence of the node in the xml stirng, start from 0 */
    IN  DRM_HMAC_CONTEXT       *f_pcontextHMAC,
    IN  DRM_BYTE               *f_pbKeyHash,          /* Hash key for HMAC */
    IN  DRM_DWORD               f_cbKeyHash,          /* byte count of HMAC */
    IN  DRM_BOOL                f_fIncludeTag,
    IN  DRM_CONST_STRING       *f_pdstrB64Signature,
    OUT DRM_CONST_STRING       *f_pdstrNode,       /* either of these 2 parameter can be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrNodeData)   /* data enclosed by the immediate <tag>...</tag> in the given XML string */
{
    return DRM_XML_GetAndVerifyKeyedHashSubNode(f_pdstrXML,
                                                f_pdstrTag,
                                                f_pdstrAttrName,
                                                f_pdstrAttrValue,
                                                f_iNode,
                                                f_pcontextHMAC,
                                                f_pbKeyHash,
                                                f_cbKeyHash,
                                                f_fIncludeTag,
                                                f_pdstrB64Signature,
                                                f_pdstrNode,
                                                f_pdstrNodeData,
                                                0);
}

DRM_API DRM_RESULT DRM_CALL DRM_XML_GetAndVerifyKeyedHashSubNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,          /* nth occurence of the node in the xml stirng, start from 0 */
    IN  DRM_HMAC_CONTEXT       *f_pcontextHMAC,     /* HMAC context */
    IN  DRM_BYTE               *f_pbKeyHash,        /* Hash key for HMAC */
    IN  DRM_DWORD               f_cbKeyHash,        /* byte count of HMAC */
    IN  DRM_BOOL                f_fIncludeTag,
    IN  DRM_CONST_STRING       *f_pdstrB64Signature,
    OUT DRM_CONST_STRING       *f_pdstrNode,     /* either of these 2 parameter can be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrNodeData, /* data enclosed by the immediate <tag>...</tag> in the given XML string */
    IN  DRM_DWORD               f_iLayer)      /* outermost layer is 0 */
{
    DRM_RESULT       dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrXMLNode;
    DRM_CONST_STRING dstrXMLNodeData;
    DRM_DWORD        cbDecoded = DRM_SHA1_DIGEST_LEN;
    DRM_BYTE         rgbSign   [__CB_DECL(DRM_SHA1_DIGEST_LEN)];
    DRM_BYTE         rgbVerify [__CB_DECL(DRM_SHA1_DIGEST_LEN)];
    
    ChkArg(f_pcontextHMAC      != NULL
        && f_pbKeyHash         != NULL
        && f_cbKeyHash         != NULL
        && f_pdstrB64Signature != NULL);

    ChkArg(f_pdstrNode     != NULL 
        || f_pdstrNodeData != NULL);
        
    ChkArg(f_pdstrB64Signature->cchString == DRM_SHA1_B64ENC_DIGEST_LEN);

    /* get the node first */
    ChkDR(DRM_XML_GetSubNode(f_pdstrXML,
                             f_pdstrTag,
                             f_pdstrAttrName,
                             f_pdstrAttrValue,
                             f_iNode,
                            &dstrXMLNode,
                            &dstrXMLNodeData, 
                             f_iLayer));

    /* base64 decode the signature */
    ChkDR(DRM_B64_DecodeW(f_pdstrB64Signature, &cbDecoded, rgbSign, 0));

    ChkDR(DRM_HMAC_Init(f_pcontextHMAC, eDRM_SHA_1, f_pbKeyHash, f_cbKeyHash));

    if (f_fIncludeTag)
    {
        ChkDR(DRM_HMAC_Update(f_pcontextHMAC, 
                              PB_DSTR (&dstrXMLNode), 
                              CB_DSTR (&dstrXMLNode)));
    }
    else
    {
        ChkDR(DRM_HMAC_Update(f_pcontextHMAC,
                              PB_DSTR (&dstrXMLNodeData), 
                              CB_DSTR (&dstrXMLNodeData)));
    }

    ChkDR(DRM_HMAC_Finalize(f_pcontextHMAC, rgbVerify, DRM_SHA1_DIGEST_LEN));

    if (MEMCMP(rgbVerify, rgbSign, DRM_SHA1_DIGEST_LEN) != 0)
    {
        ChkDR(DRM_E_HASHMISMATCH);
    }

    /* prepare for return value */
    if (f_pdstrNode != NULL)
    {
        ASSIGN_DRM_STRING(*f_pdstrNode, dstrXMLNode);
    }

    if (f_pdstrNodeData != NULL)
    {
        ASSIGN_DRM_STRING(*f_pdstrNodeData, dstrXMLNodeData);
    }

ErrorExit:

    return _TranslateXMLError(dr);
}

/*
** extract license node from given XML string matching <tag AttrName="Value"> ... </tag>
*/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XML_GetAndVerifyNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,           /* nth occurence of the node in the xml stirng, start from 0 */
    IN  DRM_CRYPTO_CONTEXT     *f_pcontextCRYP,    /* Pointer to DRM_CRYPTO_CONTEXT */
    IN  const PUBKEY           *f_ppubkey,           /* pub key to use for verify */
    IN  DRM_BOOL                f_fIncludeTag,
    IN  DRM_CONST_STRING       *f_pdstrB64Signature,
    OUT DRM_CONST_STRING       *f_pdstrNode,      /* either of these 2 parameter can be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrNodeData)  /* data enclosed by the immediate <tag>...</tag> in the given XML string */
{
    return DRM_XML_GetAndVerifySubNode(f_pdstrXML,
                                       f_pdstrTag,
                                       f_pdstrAttrName,
                                       f_pdstrAttrValue,
                                       f_iNode,
                                       f_pcontextCRYP,
                                       f_ppubkey,
                                       f_fIncludeTag,
                                       f_pdstrB64Signature,
                                       f_pdstrNode,
                                       f_pdstrNodeData,
                                       0);
}

/*
** extract license node from given XML string matching <tag AttrName="Value"> ... </tag>
*/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XML_GetAndVerifySubNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,          /* nth occurence of the node in the xml stirng, start from 0 */
    IN  DRM_CRYPTO_CONTEXT     *f_pcontextCRYP,   /* Pointer to DRM_CRYPTO_CONTEXT */
    IN  const PUBKEY           *f_ppubkey,          /* pub key to use for verify */
    IN  DRM_BOOL                f_fIncludeTag,
    IN  DRM_CONST_STRING       *f_pdstrB64Signature,
    OUT DRM_CONST_STRING       *f_pdstrNode,     /* these two parameters can either be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrNodeData,
    IN  DRM_DWORD               f_iLayer)      /* outermost layer is 0 */
{
    DRM_RESULT       dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrXMLNode;
    DRM_CONST_STRING dstrXMLNodeData;
    DRM_DWORD        cbDecoded = DRM_ECC160_SIGNATURE_LEN;
    DRM_BYTE         rgbSign [__CB_DECL(DRM_ECC160_SIGNATURE_LEN)] = { 0 };
    
    ChkArg(f_pcontextCRYP      != NULL
        && f_ppubkey           != NULL
        && f_pdstrB64Signature != NULL);
        
    ChkArg(f_pdstrNode    != NULL 
       || f_pdstrNodeData != NULL);
        
    ChkArg(f_pdstrB64Signature->cchString == DRM_ECC160_SIGNATURE_B64LEN);

    /* get the node first */
    ChkDR(DRM_XML_GetSubNode(f_pdstrXML, 
                             f_pdstrTag, 
                             f_pdstrAttrName, 
                             f_pdstrAttrValue, 
                             f_iNode,
                            &dstrXMLNode,
                            &dstrXMLNodeData, 
                             f_iLayer));

    /* base64 decode the signature */
    ChkDR(DRM_B64_DecodeW(f_pdstrB64Signature, &cbDecoded, rgbSign, 0));

    /* verify the node with the signature */
    if (f_fIncludeTag)
    {   
        ChkDR( DRM_PK_Verify( f_pcontextCRYP->rgbCryptoContext, 
                              eDRM_ECC_P160,
                              DRM_ECC160_PUBLIC_KEY_LEN,
                              ( const DRM_BYTE * )f_ppubkey, 
                              CB_DSTR( &dstrXMLNode ),
                              PB_DSTR( &dstrXMLNode ), 
                              DRM_ECC160_SIGNATURE_LEN,
                              rgbSign ) );
    }
    else
    {    
        ChkDR( DRM_PK_Verify( f_pcontextCRYP->rgbCryptoContext, 
                              eDRM_ECC_P160,
                              DRM_ECC160_PUBLIC_KEY_LEN,
                              ( const DRM_BYTE * )f_ppubkey, 
                              CB_DSTR( &dstrXMLNodeData ),
                              PB_DSTR( &dstrXMLNodeData ), 
                              DRM_ECC160_SIGNATURE_LEN, 
                              rgbSign ) );
    }

    /* prepare for return value */
    if (f_pdstrNode != NULL)
    {
        ASSIGN_DRM_STRING(*f_pdstrNode, dstrXMLNode);
    }
    if (f_pdstrNodeData != NULL)
    {
        ASSIGN_DRM_STRING(*f_pdstrNodeData, dstrXMLNodeData);
    }

ErrorExit:

    return _TranslateXMLError(dr);
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmxmlbuilderlite.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmbase64.h>
#include <drmcrt.h>
#include <drmutilities.h>
#include <drmcipher.h>
#include <drmxmlbuilder.h>

ENTER_PK_NAMESPACE_CODE;

#define CB_XML_BUFFER_MINIMUM  100
#define CWCH_DWORD_STACK       (SIZEOF(DRM_DWORD)/SIZEOF(DRM_WCHAR))
#define CCH_SIMULATION_MININUM (2*CWCH_DWORD_STACK)

/*
***********************************************************************
** types used within this file
***********************************************************************
*/

const DRM_DWORD g_cbXMLBuilderMinimum = SIZEOF (_XMBContext) 
                                      + __CB_DECL(CB_XML_BUFFER_MINIMUM)
                                      + SIZEOF (DRM_WCHAR);

/***************************************************************************** */

/******************************************************************************
** Function:   _PushDWORD
** 
** Synopsis:   push a DWORD value on the end of the stack and decrement it 
** 
** Arguments:  f_pcontextXML - the XML context in use; must be inited
**             f_dwValue     - the value to push  
******************************************************************************/
static DRM_RESULT _PushDWORD( __inout _XMBContext *f_pcontextXML,
                              __in    DRM_DWORD    f_dwValue)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  iPos = 0;

    ChkArg (f_pcontextXML != NULL);
    ChkBOOL(f_pcontextXML->wNextOpenNodePos >= CWCH_DWORD_STACK, DRM_E_BUFFERTOOSMALL);

    iPos = f_pcontextXML->wNextOpenNodePos;
    f_pcontextXML->XmlString [iPos+1] = (DRM_WCHAR) (f_dwValue  & 0x0000FFFF);
    f_pcontextXML->XmlString [iPos]   = (DRM_WCHAR) (f_dwValue >> 16);
    f_pcontextXML->wNextOpenNodePos  -= CWCH_DWORD_STACK;

ErrorExit:
    return dr;
}

/******************************************************************************
** Function:   _GetPushedDWORD
** 
** Synopsis:   pop a DWORD value from the end of the stack 
** 
** Arguments:  f_pcontextXML - the XML context in use; must be inited
**             f_iOffset     - an offset from the current stack position
**             f_pdwValue    - pointer to variable to hold the retrieved value
******************************************************************************/
static DRM_RESULT _GetPushedDWORD( __in  _XMBContext *f_pcontextXML,
                                   __in  DRM_DWORD    f_iOffset,
                                   __out DRM_DWORD   *f_pdwValue)
{
    DRM_RESULT dr = DRM_SUCCESS;
    
    ChkArg(f_pcontextXML != NULL
        && f_pdwValue    != NULL);

    ChkArg((f_pcontextXML->wNextOpenNodePos + f_iOffset) >= CWCH_DWORD_STACK);

    *f_pdwValue  =  (DRM_DWORD)  (f_pcontextXML->XmlString [f_pcontextXML->wNextOpenNodePos + f_iOffset + 1]);
    *f_pdwValue += ((DRM_DWORD) ((f_pcontextXML->XmlString [f_pcontextXML->wNextOpenNodePos + f_iOffset])) << 16);

ErrorExit:
    return dr;
}

/*
** Trim all leading and trailing blanks in given string 
** return TRUE if resulting string length > 0
*/
static DRM_BOOL _AllTrim2(
    __in const DRM_CONST_STRING *pdstrString,
    __out      DRM_CONST_STRING *pdstrTrimedString)
{
    DRM_BOOL fResult = FALSE;

    if ( pdstrString             == NULL
      || pdstrTrimedString       == NULL
      || pdstrString->pwszString == NULL 
      || pdstrString->cchString  == 0 )
    {
        goto ErrorExit;
    }

    *pdstrTrimedString = *pdstrString;

    /* trim leading blanks */
    while ( pdstrTrimedString->pwszString[0] == g_wchSpace  && pdstrTrimedString->cchString>0 )
    {
        ++pdstrTrimedString->pwszString;
        --pdstrTrimedString->cchString;
    }

    /* trim trailing blanks */
    while ( pdstrTrimedString->cchString>0
        && pdstrTrimedString->pwszString[pdstrTrimedString->cchString-1] == g_wchSpace )
    {
        --pdstrTrimedString->cchString;
    }

    fResult = pdstrTrimedString->cchString > 0;

ErrorExit:
    return fResult;
}

/*
** Create context for the builder
*/
static DRM_RESULT _CreateContext(
    __in     DRM_DWORD    cbXmlContext,
    __inout _XMBContext *pbXmlContext,
    __in     DRM_BOOL     fIsSimMode)
{
    DRM_RESULT   dr = DRM_SUCCESS;

    if (cbXmlContext < g_cbXMLBuilderMinimum)
    {
        ChkDR (DRM_E_BUFFERTOOSMALL);
    }

    ZEROMEM(pbXmlContext, cbXmlContext);
    pbXmlContext->wSize            = cbXmlContext;
    pbXmlContext->wBuffSize        = ((cbXmlContext - SIZEOF(_XMBContext)) / SIZEOF(DRM_WCHAR));
    pbXmlContext->wNextStringPos   = 0;
    pbXmlContext->wNextOpenNodePos = pbXmlContext->wBuffSize - CWCH_DWORD_STACK; /* next position to be used on stack */
    pbXmlContext->fInited          = TRUE;
    pbXmlContext->fIsSimMode       = fIsSimMode;
    pbXmlContext->wMaxStackUsed    = 0;
    
ErrorExit:
    return dr;
}

/**********************************************************************
**
** Function: _SaveContextState
**
** Synopsis: Saves context state to allow rollback of failed operation
**              
** Arguments:   IN    pbXmlContext      - pointer to _XMBContext which state should be saved
**              INOUT pbXmlContextState - pointer to _XMBContext where state will be saved    
**
** Returns:     DRM_SUCCESS on success. 
**      
**********************************************************************/
static DRM_RESULT _SaveContextState(
    __in    _XMBContext *pbXmlContext,
    __inout _XMBContext *pbXmlContextState
)
{
    DRM_RESULT   dr = DRM_SUCCESS;

    ChkArg( pbXmlContext != NULL );
    ChkArg( pbXmlContextState != NULL );

    if ( pbXmlContext->fInited )
    {
        pbXmlContextState->wMaxStackUsed    = pbXmlContext->wMaxStackUsed;
        pbXmlContextState->wSize            = pbXmlContext->wSize;
        pbXmlContextState->wNextStringPos   = pbXmlContext->wNextStringPos;
        pbXmlContextState->wNextOpenNodePos = pbXmlContext->wNextOpenNodePos;
    }
        
ErrorExit:
    return dr;
}

/**********************************************************************
**
** Function: _RestoreContextState
**
** Synopsis: Restores context state from saved context
**              
** Arguments:   INOUT pbXmlContext      - pointer to _XMBContext which state should be restored
**              IN    pbXmlContextState - pointer to _XMBContext from where state will be restored
**
** Returns:     DRM_SUCCESS on success. 
**      
**********************************************************************/

static DRM_RESULT _RestoreContextState(
    __inout _XMBContext *pbXmlContext,
    __in    _XMBContext *pbXmlContextState
)
{
    DRM_RESULT   dr = DRM_SUCCESS;

    ChkArg( pbXmlContext != NULL );
    ChkArg( pbXmlContextState != NULL );

    if ( pbXmlContext->fInited )
    {
        pbXmlContext->wMaxStackUsed    = pbXmlContextState->wMaxStackUsed;
        pbXmlContext->wSize            = pbXmlContextState->wSize;
        pbXmlContext->wNextStringPos   = pbXmlContextState->wNextStringPos;
        pbXmlContext->wNextOpenNodePos = pbXmlContextState->wNextOpenNodePos;
    }
        
ErrorExit:
    return dr;
}

/*
** Open a new node nested from current opened node
*/
static DRM_RESULT _OpenNode(
    __inout       _XMBContext      *pContext,
    __in    const DRM_CONST_STRING *pdstrNodeName )
{
    DRM_RESULT       dr           = DRM_SUCCESS;
    DRM_DWORD        wNodePos     = 0;
    DRM_CONST_STRING dstrNodeName = EMPTY_DRM_STRING;
    
    ChkArg(_AllTrim2(pdstrNodeName, &dstrNodeName));

    if ( pContext->fIsSimMode )
    {
        /* fake mode pushes 2 DWORDs, one for node position, one for tag name size */
        
        if (pContext->wNextOpenNodePos < CCH_SIMULATION_MININUM)
        {
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }
        wNodePos = pContext->wNextStringPos + 1;
        
        /* calculate length of the open tag now  2 = "<>" */
        
        pContext->wNextStringPos += dstrNodeName.cchString + 2;

        /* push the node position to end of XML string */
        
        ChkDR(_PushDWORD(pContext, wNodePos));

        /* push the tag name length to end of XML string */

        ChkDR(_PushDWORD(pContext, dstrNodeName.cchString));

        /* keep track of max stack used */
        {

            DRM_DWORD wCurrStack = (pContext->wBuffSize - 1 - pContext->wNextOpenNodePos) / 2;

            if ( pContext->wMaxStackUsed < wCurrStack )
            {
                pContext->wMaxStackUsed = wCurrStack;
            }
        }
        
    }
    else
    {
        if ( pContext->wNextStringPos + dstrNodeName.cchString                     < pContext->wNextStringPos
          || pContext->wNextStringPos + dstrNodeName.cchString + CWCH_DWORD_STACK  < pContext->wNextStringPos
          || pContext->wNextStringPos + dstrNodeName.cchString + CWCH_DWORD_STACK >= pContext->wNextOpenNodePos )
        {
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }

        /* print "<tag>" to the XML string*/
        ChkOverflow(pContext->wBuffSize, pContext->wBuffSize - pContext->wNextStringPos);
        ChkDR( DRM_STR_StringCchCopyNW(&pContext->XmlString[pContext->wNextStringPos],
                                   pContext->wBuffSize - pContext->wNextStringPos, 
                                   g_dstrOpenTag.pwszString, 
                                   g_dstrOpenTag.cchString) );
        pContext->wNextStringPos += 1;
        wNodePos = pContext->wNextStringPos;

        ChkDR( DRM_STR_StringCchCopyNW(&pContext->XmlString[pContext->wNextStringPos], 
                                   pContext->wBuffSize - pContext->wNextStringPos, 
                                   dstrNodeName.pwszString, 
                                   dstrNodeName.cchString) );
        pContext->wNextStringPos += dstrNodeName.cchString;

        ChkDR( DRM_STR_StringCchCopyNW(&pContext->XmlString[pContext->wNextStringPos], 
                                   pContext->wBuffSize - pContext->wNextStringPos, 
                                   g_dstrCloseTag.pwszString, 
                                   g_dstrCloseTag.cchString) );
        pContext->wNextStringPos += 1;
        
        /* push the node position to end of XML string */

        ChkDR(_PushDWORD(pContext, wNodePos));
    }
    
ErrorExit:
    return dr;
}


/*
** Close the current opened node
*/
static DRM_RESULT DRM_CALL _CloseCurrNode(
    __inout   _XMBContext *pXmlContext,
    __in      DRM_BOOL     fOkayToCloseRoot,
    __out_opt DRM_STRING  *pdstrXMLString)   /* optional parameter */
{
    DRM_RESULT   dr          = DRM_SUCCESS;
    DRM_DWORD    wLen        = 0;
    DRM_DWORD    wNodePos    = 0;
    DRM_DWORD    cwchMinStack = 0;

    ChkArg(pXmlContext->fInited);

    /*
    ** make sure the stack is not empty. Stack is count by CWCH_DWORD_STACK. 
    ** to close a node, we must have at least ONE CWCH_DWORD_STACK on stack.
    ** if fOkayToCloseRoot is FALSE, we must have at least two CWCH_DWORD_STACK
    ** on stack.
    */
    cwchMinStack = 2 * CWCH_DWORD_STACK;  /* do not pop off the root node */
    if (fOkayToCloseRoot)
    {
        cwchMinStack = CWCH_DWORD_STACK;  /* root node */
    }

    if ( (pXmlContext->wNextOpenNodePos + cwchMinStack) >= pXmlContext->wBuffSize )    /* do not pop off the root node !*/
    {
        dr = DRM_E_NOMORE;    /* stack is empty */
        goto ErrorExit;
    }

    if ( !pXmlContext->fIsSimMode )
    {
        /* parse length of node name */

        ChkDR(_GetPushedDWORD(pXmlContext, CWCH_DWORD_STACK, &wNodePos));

        if ( pdstrXMLString != NULL )
        {
            pdstrXMLString->pwszString = &(pXmlContext->XmlString[wNodePos - 1]);    
        }

        while (pXmlContext->XmlString [wNodePos + wLen] != g_wchSpace 
            && pXmlContext->XmlString [wNodePos + wLen] != g_wchGreaterThan )
        {
            wLen++;
        }
        
        if ( pXmlContext->wNextStringPos + wLen      < pXmlContext->wNextStringPos
          || pXmlContext->wNextStringPos + wLen + 3  < pXmlContext->wNextStringPos
          || pXmlContext->wNextStringPos + wLen + 3 >= pXmlContext->wNextOpenNodePos )
        {
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }

        /* print </tag> to the XML string*/
        ChkDR( DRM_STR_StringCchCopyNW(&pXmlContext->XmlString[pXmlContext->wNextStringPos], 
                                   pXmlContext->wBuffSize - pXmlContext->wNextStringPos, 
                                   g_dstrOpenEndTag.pwszString, 
                                   g_dstrOpenEndTag.cchString) );
        pXmlContext->wNextStringPos += 2;
        
        ChkDR( DRM_STR_StringCchCopyNW(&pXmlContext->XmlString[pXmlContext->wNextStringPos], 
                                   pXmlContext->wBuffSize - pXmlContext->wNextStringPos, 
                                  &pXmlContext->XmlString[wNodePos], 
                                   wLen) );
        pXmlContext->wNextStringPos += wLen;
        
        ChkDR( DRM_STR_StringCchCopyNW(&pXmlContext->XmlString[pXmlContext->wNextStringPos], 
                                   pXmlContext->wBuffSize - pXmlContext->wNextStringPos, 
                                   g_dstrCloseTag.pwszString, 
                                   g_dstrCloseTag.cchString) );
        pXmlContext->wNextStringPos += 1;

        /* pop the node position from end of XML string */
        pXmlContext->wNextOpenNodePos += CWCH_DWORD_STACK;
    }
    else
    {
        DRM_DWORD cchPop = 0;
        
        ChkDR(_GetPushedDWORD(pXmlContext, CWCH_DWORD_STACK, &cchPop));
        ChkDR(_GetPushedDWORD(pXmlContext, 2 * CWCH_DWORD_STACK, &wNodePos));
                              
        /* calculate length of the close tag now 3 = "</>" */
        
        pXmlContext->wNextStringPos += cchPop + 3;

        /* pop the node position and tag name size from end of XML string */

        pXmlContext->wNextOpenNodePos += 2 * CWCH_DWORD_STACK;
    }

    if ( pdstrXMLString != NULL )
    {
        pdstrXMLString->cchString = pXmlContext->wNextStringPos - wNodePos + 1;
    }

ErrorExit:
    return dr;
}


/*
** calcuate the current node size
*/
static DRM_RESULT DRM_CALL _CalcNodeSize(
    __in  _XMBContext *pbXmlContext,
    __out DRM_DWORD   *pcchContent,  /* ch count of node content */
    __out DRM_DWORD   *pcchTagName)  /* ch count of node tag */
{
    DRM_RESULT   dr       = DRM_SUCCESS;
    DRM_DWORD    wLen     = 0;
    DRM_DWORD    wNodePos = 0;

    ChkArg( pbXmlContext != NULL
         && pcchContent  != NULL
         && pcchTagName  != NULL
         && pbXmlContext->fInited );

    if ( pbXmlContext->fIsSimMode )
    {
        _GetPushedDWORD(pbXmlContext, CWCH_DWORD_STACK,  pcchTagName);
        _GetPushedDWORD(pbXmlContext, 2 * CWCH_DWORD_STACK, &wNodePos);
        
        /* this is not accurate in case the open node has attributes */
        *pcchContent = pbXmlContext->wNextStringPos - wNodePos - *pcchTagName - 1;
    }
    else
    {
        /* parse length of node name */
        
        _GetPushedDWORD(pbXmlContext, CWCH_DWORD_STACK, &wNodePos);
        
        while (pbXmlContext->XmlString [wNodePos + wLen] != g_wchSpace 
            && pbXmlContext->XmlString [wNodePos + wLen] != g_wchGreaterThan )
        {
            wLen++;
        }
        *pcchTagName = wLen;

        /* parse first position of node content */
        while (pbXmlContext->XmlString[wNodePos + wLen] != g_wchGreaterThan )
        {
            wLen++;
        }
        *pcchContent = pbXmlContext->wNextStringPos - wNodePos - wLen - 1;
    }
    
ErrorExit:
    return dr;
}


DRM_API DRM_RESULT DRM_CALL DRM_XMB_SimulateCreateDocument(
    __in    const DRM_DWORD         cbXmlContext,
    __inout       _XMBContext      *pbXmlContext,
    __in    const DRM_CONST_STRING *pdstrRootNodeName)
{
    DRM_RESULT dr = DRM_SUCCESS;

    /* create the context */
    ChkArg(pbXmlContext != NULL
        && cbXmlContext != 0    );

    ChkDRMString(pdstrRootNodeName);

    ChkDR(_CreateContext(cbXmlContext, pbXmlContext, TRUE));

    /* open the root node */
    ChkDR( _OpenNode(pbXmlContext, pdstrRootNodeName) );

ErrorExit:
    return dr;
}


DRM_API DRM_RESULT DRM_CALL DRM_XMB_CreateDocument(
    __in    const DRM_DWORD         cbXmlContext,
    __inout       _XMBContext      *pbXmlContext,
    __in    const DRM_CONST_STRING *pdstrRootNodeName)
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_CreateDocument );
    /* create the context */
    ChkArg(pbXmlContext != NULL
        && cbXmlContext != 0    );

    ChkArg((((DRM_DWORD_PTR) pbXmlContext) % sizeof (DRM_DWORD)) == 0);

    ChkDRMString(pdstrRootNodeName);

    ChkDR(_CreateContext(cbXmlContext, pbXmlContext, FALSE));

    /* open the root node */
    ChkDR( _OpenNode(pbXmlContext, pdstrRootNodeName) );

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

DRM_API DRM_RESULT DRM_CALL DRM_XMB_ReallocDocument(
    __in          _XMBContext *pbOldXmlContext,
    __in    const DRM_DWORD    cbNewXmlContext,
    __inout       _XMBContext *pbNewXmlContext )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_ReallocDocument );

    ChkArg( pbOldXmlContext != NULL
         && cbNewXmlContext != 0
         && pbNewXmlContext != NULL 
         && pbOldXmlContext->fInited );

    if ( cbNewXmlContext <= pbOldXmlContext->wSize )
    {
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }

    /* create new context using new buffer */
    if ( pbOldXmlContext != pbNewXmlContext )
    {
        ChkDR(_CreateContext(cbNewXmlContext, pbNewXmlContext, pbOldXmlContext->fIsSimMode));

        /* copy XML String to new context */
        MEMCPY(pbNewXmlContext->XmlString, pbOldXmlContext->XmlString, pbOldXmlContext->wNextStringPos * SIZEOF(DRM_WCHAR));
        pbNewXmlContext->wNextStringPos = pbOldXmlContext->wNextStringPos;

        /* copy node positions info to new context */
        pbNewXmlContext->wNextOpenNodePos = pbNewXmlContext->wBuffSize 
                                          - pbOldXmlContext->wBuffSize 
                                          + pbOldXmlContext->wNextOpenNodePos;

        MEMMOVE(&pbNewXmlContext->XmlString[pbNewXmlContext->wNextOpenNodePos],
                &pbOldXmlContext->XmlString[pbOldXmlContext->wNextOpenNodePos],
                (pbOldXmlContext->wBuffSize - pbOldXmlContext->wNextOpenNodePos) * SIZEOF(DRM_WCHAR));
        
        /* invalidate the old context */
        pbOldXmlContext->fInited = FALSE;
    }

    // the new buffer is the same as the old buffer except bigger.
    else
    {
        DRM_DWORD dwOldSize = pbOldXmlContext->wBuffSize;
        DRM_DWORD dwOldNextOpenNodePos = pbOldXmlContext->wNextOpenNodePos;
            
        pbNewXmlContext->wSize     = cbNewXmlContext;
        pbNewXmlContext->wBuffSize = ((cbNewXmlContext - SIZEOF(_XMBContext)) / SIZEOF(DRM_WCHAR));

        /* copy node positions info to new context */
        pbNewXmlContext->wNextOpenNodePos = pbNewXmlContext->wBuffSize - dwOldSize + dwOldNextOpenNodePos;

        MEMMOVE(&pbNewXmlContext->XmlString[pbNewXmlContext->wNextOpenNodePos],
                &pbOldXmlContext->XmlString[dwOldNextOpenNodePos],
                (dwOldSize - dwOldNextOpenNodePos) * SIZEOF(DRM_WCHAR));
    }
ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}
 

DRM_API DRM_RESULT DRM_CALL DRM_XMB_CloseDocument(
    __inout _XMBContext *pbXmlContext,
    __out   DRM_STRING  *pdstrXML)
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_CloseDocument );

    ChkArg( pbXmlContext != NULL 
         && pdstrXML     != NULL
         && pbXmlContext->fInited );
    
    while (TRUE)
    {
        dr = _CloseCurrNode(pbXmlContext, TRUE, NULL);
        if ( dr == DRM_E_NOMORE )
        {
            dr = DRM_SUCCESS;
            break;
        }
        else
        {
            ChkDR(dr);
        }
    }

    if ( pbXmlContext->fIsSimMode )
    {
        DRM_DWORD cbOverhead = DRM_XMB_OVERHEAD;

        pdstrXML->pwszString = NULL;
        pdstrXML->cchString  = pbXmlContext->wNextStringPos;

        /* add extra room for simulate mode so that the call can allow enough 
        ** buffer size for creating this document */
        if ( cbOverhead < (pbXmlContext->wMaxStackUsed * SIZEOF(DRM_WCHAR) + SIZEOF(_XMBContext)) )
        {
            cbOverhead = pbXmlContext->wMaxStackUsed * SIZEOF(DRM_WCHAR) + SIZEOF(_XMBContext);
        }
        pdstrXML->cchString += (cbOverhead + 1) / SIZEOF(DRM_WCHAR);
    }
    else
    {
        pdstrXML->pwszString = pbXmlContext->XmlString;
        pdstrXML->cchString  = pbXmlContext->wNextStringPos;
    }
        

    /* invalidate the context */
    pbXmlContext->fInited = FALSE;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


DRM_API DRM_RESULT DRM_CALL DRM_XMB_OpenNode(
    __inout       _XMBContext      *pbXmlContext,
    __in    const DRM_CONST_STRING *pdstrNodeName)
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_OpenNode );

    ChkArg( pbXmlContext != NULL
         && pbXmlContext->fInited    ); 
    ChkDRMString(pdstrNodeName);

    /* open the root node */
    ChkDR( _OpenNode(pbXmlContext, pdstrNodeName) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


DRM_API DRM_RESULT DRM_CALL DRM_XMB_CloseCurrNode(
    __inout   _XMBContext *pbXmlContext,
    __out_opt DRM_STRING  *pdstrXMLFragment)
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_CloseCurrNode );

    ChkArg( pbXmlContext != NULL );
    ChkDR(_CloseCurrNode(pbXmlContext, FALSE, pdstrXMLFragment));

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


DRM_API DRM_RESULT DRM_CALL DRM_XMB_SaveState(
    __inout _XMBContext *pbXmlContext,
    __out   XMBState    *pState)
{
    DRM_RESULT   dr = DRM_SUCCESS;

    ChkArg( pbXmlContext != NULL  &&  pState != NULL );

    pState->cwchMaxStackUsed    = pbXmlContext->wMaxStackUsed;
    pState->iwchNextOpenNodePos = pbXmlContext->wNextOpenNodePos;
    pState->iwchNextStringPos   = pbXmlContext->wNextStringPos;

ErrorExit:

    return dr;
}


DRM_API DRM_RESULT DRM_CALL DRM_XMB_RestoreState(
    __inout   _XMBContext *pbXmlContext,
    __in       XMBState    *pState)
{
    DRM_RESULT   dr = DRM_SUCCESS;

    ChkArg( pbXmlContext != NULL  &&  pState != NULL );

    pbXmlContext->wMaxStackUsed    = pState->cwchMaxStackUsed;
    pbXmlContext->wNextOpenNodePos = pState->iwchNextOpenNodePos;
    pbXmlContext->wNextStringPos   = pState->iwchNextStringPos;

ErrorExit:

    return dr;
}

DRM_API DRM_RESULT DRM_CALL DRM_XMB_GetCurrNodeName(
    __in  _XMBContext *pbXmlContext,
    __out DRM_STRING  *pdstrNodeName)
{
    DRM_RESULT   dr       = DRM_SUCCESS;
    DRM_DWORD    wLen     = 0;
    DRM_DWORD    wNodePos = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_GetCurrNodeName );

    ChkArg( pbXmlContext  != NULL
         && pdstrNodeName != NULL
         && pbXmlContext->fInited);
         
    if ( pbXmlContext->fIsSimMode )
    {
        ChkDR(DRM_E_LOGICERR);  /* this function does not support fake mode */
    }

    /* parse length of node name */

    ChkDR(_GetPushedDWORD(pbXmlContext, CWCH_DWORD_STACK, &wNodePos));
    
    while (pbXmlContext->XmlString [wNodePos + wLen] != g_wchSpace 
        && pbXmlContext->XmlString [wNodePos + wLen] != g_wchGreaterThan)
    {
        wLen++;
    }

    pdstrNodeName->pwszString = &pbXmlContext->XmlString[wNodePos];
    pdstrNodeName->cchString  = wLen;

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



DRM_API DRM_RESULT DRM_CALL DRM_XMB_GetContextSize(
    __in  _XMBContext *pbXmlContext,
    __out DRM_DWORD   *pcbXmlContext)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( pbXmlContext  != NULL
         && pcbXmlContext != NULL 
         && pbXmlContext->fInited );
   
    *pcbXmlContext = pbXmlContext->wSize;

ErrorExit:
    return dr;
}


DRM_API DRM_RESULT DRM_CALL DRM_XMB_AddAttribute(
    __inout       _XMBContext      *pXmlContext,
    __in    const DRM_CONST_STRING *pdstrAttrName,
    __in    const DRM_CONST_STRING *pdstrAttrValue )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD    wReqSize = 0;
    DRM_DWORD    wOffset  = 0;
    DRM_DWORD    wDst     = 0;
    DRM_DWORD    wSrc     = 0;
    DRM_DWORD    i        = 0;
    DRM_CONST_STRING dstrAttrName  = EMPTY_DRM_STRING,
                     dstrAttrValue = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_AddAttribute );

    ChkArg( pXmlContext != NULL
         && pXmlContext->fInited);
         
    ChkDRMString(pdstrAttrName);
    ChkDRMString(pdstrAttrValue);

    if ( (pXmlContext->wNextOpenNodePos + ( pXmlContext->fIsSimMode? 2 : 1 )) == pXmlContext->wBuffSize )
    {
        ChkDR(DRM_E_NOMORE);    /* stack is empty */
    }

    /* make sure it's not blank */
    ChkArg(_AllTrim2(pdstrAttrName, &dstrAttrName));

    /* trim leading and trialing blanks, but blank attrib value is allowed */
    _AllTrim2(pdstrAttrValue, &dstrAttrValue);

    /* calculate the buffer size needed to insert the ' attr="value"' 4 = space + equal sign + "" */
    wReqSize = dstrAttrName.cchString;

    ChkOverflow( wReqSize + dstrAttrValue.cchString , wReqSize );
    wReqSize += dstrAttrValue.cchString;

    ChkOverflow( wReqSize + g_dstrEqualQuote.cchString , wReqSize );
    wReqSize += g_dstrEqualQuote.cchString;

    ChkOverflow( wReqSize + g_dstrSpace.cchString , wReqSize );
    wReqSize += g_dstrSpace.cchString;

    ChkOverflow( wReqSize + g_dstrQuote.cchString , wReqSize );
    wReqSize += g_dstrQuote.cchString;

    if ( !pXmlContext->fIsSimMode )
    {
        if ( (pXmlContext->wNextStringPos + wReqSize)  < pXmlContext->wNextStringPos
          || (pXmlContext->wNextStringPos + wReqSize) >= pXmlContext->wNextOpenNodePos )
        {
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }

        /* at this point, we've got the required buffer length,
        ** now parse for '>' start from the current node name */
        ChkDR(_GetPushedDWORD(pXmlContext, CWCH_DWORD_STACK, &wOffset));
        
        while ( wOffset < pXmlContext->wBuffSize
           &&   pXmlContext->XmlString[wOffset] != g_wchGreaterThan )
        {
            wOffset++;
        }

        if ( wOffset >= pXmlContext->wBuffSize
        ||   pXmlContext->XmlString[wOffset] != g_wchGreaterThan )
        {
            ChkDR(DRM_E_NOXMLCLOSETAG);
        }

        /* now, XmlString[wOffset] contains the '>' char, insert attr=value in there
        ** first, move everything, if any, from '>' to give space for the insertion 
        */
        wDst = pXmlContext->wNextStringPos+wReqSize-1;
        wSrc = pXmlContext->wNextStringPos-1;
        for (i=0; i<(pXmlContext->wNextStringPos - wOffset); i++)
        {
            pXmlContext->XmlString[wDst--] = pXmlContext->XmlString[wSrc--];
        }

        if( wOffset + wReqSize  < wOffset
         || wOffset + wReqSize >= pXmlContext->wBuffSize )
        {
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }

        /* now, insert it in there */
        ChkOverflow( pXmlContext->wBuffSize , pXmlContext->wBuffSize - wOffset );
        ChkDR( DRM_STR_StringCchCopyNW( &pXmlContext->XmlString[wOffset], 
                                    pXmlContext->wBuffSize - wOffset, 
                                    g_dstrSpace.pwszString, 
                                    g_dstrSpace.cchString ) );
        wOffset += g_dstrSpace.cchString;
        
        ChkOverflow( pXmlContext->wBuffSize , pXmlContext->wBuffSize - wOffset );
        ChkDR( DRM_STR_StringCchCopyNW( &pXmlContext->XmlString[wOffset], 
                                    pXmlContext->wBuffSize - wOffset,
                                    dstrAttrName.pwszString, 
                                    dstrAttrName.cchString) );
        wOffset += dstrAttrName.cchString;
        
        ChkOverflow( pXmlContext->wBuffSize , pXmlContext->wBuffSize - wOffset );
        ChkDR( DRM_STR_StringCchCopyNW( &pXmlContext->XmlString[wOffset], 
                                    pXmlContext->wBuffSize - wOffset,
                                    g_dstrEqualQuote.pwszString, 
                                    g_dstrEqualQuote.cchString ) );
        wOffset += g_dstrEqualQuote.cchString;
        
        ChkOverflow( pXmlContext->wBuffSize , pXmlContext->wBuffSize - wOffset );
        ChkDR( DRM_STR_StringCchCopyNW( &pXmlContext->XmlString[wOffset], 
                                    pXmlContext->wBuffSize - wOffset,
                                    dstrAttrValue.pwszString, 
                                    dstrAttrValue.cchString) );
        wOffset += dstrAttrValue.cchString;
        
        ChkOverflow( pXmlContext->wBuffSize , pXmlContext->wBuffSize - wOffset );
        ChkDR( DRM_STR_StringCchCopyNW( &pXmlContext->XmlString[wOffset], 
                                    pXmlContext->wBuffSize - wOffset,
                                    g_dstrQuote.pwszString, 
                                    g_dstrQuote.cchString) );
        wOffset += g_dstrQuote.cchString;
        pXmlContext->XmlString[wOffset] = g_wchGreaterThan;
        
    }

    /* update next XML string position */
    pXmlContext->wNextStringPos += wReqSize;

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

DRM_API DRM_RESULT DRM_CALL DRM_XMB_AddData(
    __inout       _XMBContext      *pXmlContext,
    __in    const DRM_CONST_STRING *pdstrData )
{
    DRM_RESULT       dr       = DRM_SUCCESS;
    DRM_DWORD        wOffset  = 0;
    DRM_DWORD        wDst     = 0;
    DRM_DWORD        wSrc     = 0;
    DRM_DWORD        i        = 0;
    DRM_CONST_STRING dstrData = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_AddData );

    ChkArg( pXmlContext != NULL
         && pXmlContext->fInited    );
    ChkDRMString(pdstrData);

    if ( (pXmlContext->wNextOpenNodePos + ( pXmlContext->fIsSimMode? 2 : 1 )) == pXmlContext->wBuffSize )
    {
        ChkDR(DRM_E_NOMORE);    /* stack is empty */
    }

    if ( !_AllTrim2(pdstrData, &dstrData) )     /* a blank string found */
    {
        goto ErrorExit;
    }

    if ( !pXmlContext->fIsSimMode )
    {
        /* check if we have enough space */
        if ( (pXmlContext->wNextStringPos + dstrData.cchString)  < pXmlContext->wNextStringPos
          || (pXmlContext->wNextStringPos + dstrData.cchString) >= pXmlContext->wNextOpenNodePos)
        {
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }

        /* at this point, we've got the required buffer length,
        ** now parse for '>' start from the current node name */
        
        ChkDR(_GetPushedDWORD(pXmlContext, CWCH_DWORD_STACK, &wOffset));

        while ( wOffset < pXmlContext->wBuffSize
           &&   pXmlContext->XmlString[wOffset] != g_wchGreaterThan )
        {
            wOffset++;
        }

        if ( wOffset >= pXmlContext->wBuffSize
        ||   pXmlContext->XmlString[wOffset] != g_wchGreaterThan )
        {
            ChkDR(DRM_E_NOXMLCLOSETAG);
        }

        /* now, XmlString[wOffset] contains the '>' char, insert data after it.
        ** first, move everything, if any, after '>' to give space for the insertion 
        */
        wOffset += 1;

        wDst = pXmlContext->wNextStringPos + dstrData.cchString - 1;
        wSrc = pXmlContext->wNextStringPos-1;

        for (i=0; i<(pXmlContext->wNextStringPos - wOffset); i++)
        {
            pXmlContext->XmlString[wDst--] = pXmlContext->XmlString[wSrc--];
        }

        /* now, insert it in there */
        ChkDR( DRM_STR_StringCchCopyNW(&pXmlContext->XmlString[wOffset], 
                                   pXmlContext->wBuffSize - wOffset, 
                                   dstrData.pwszString, 
                                   dstrData.cchString) );
        wOffset += dstrData.cchString;
        pXmlContext->XmlString[wOffset] = g_wchLessThan;
        
    }

    /* update next XML string position */
    pXmlContext->wNextStringPos += dstrData.cchString;

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/******************************************************************************
**
** Function:   DRM_XMB_ReserveSpace
** 
** Synopsis:   API that reserves a specific number of characters in the XML builder
**             context.
** 
** Arguments:
**
** [f_poXMBContext]         -- Pointer to an initialized XML builder context.
** [f_cchData]              -- Number of wide characters to reserve in the XML builder
**                             context.
** [f_ppwchData]            -- Pointer to pointer that receives the address of
**                             the internal XML builder context buffer that has been
**                             reserved.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_BUFFERTOOSMALL if the size of buffer in the XML
**                          builder context is not big enough to accomodate the data
**                          to be added.
**
** Note:                    The purpose of this API is to reserve a buffer of specific
**                          size in the XML builder context first and then fill the
**                          buffer in other functions (such as file read). Without this
**                          API, other functions have to store the data to be added to the
**                          XML builder context in a temporary buffer, and then call
**                          DRM_XMB_AddData() to add the data to the XML builder context.
**                          If the data to be added has a large size, the memory usage will
**                          be doubled compared with using this API. 
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XMB_ReserveSpace(
    __inout                 _XMBContext *f_poXMBContext,
    __in                    DRM_DWORD    f_cchData,
    __out_ecount(f_cchData) DRM_WCHAR  **f_ppwchData )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_ReserveSpace );

    ChkArg( f_poXMBContext != NULL &&
            f_poXMBContext->fInited );

    ChkArg( f_cchData > 0 );

    ChkArg( f_ppwchData != NULL );

    if ( !f_poXMBContext->fIsSimMode )
    {
        /* Check whether there is enough space. */
        if ( ( f_poXMBContext->wNextStringPos + f_cchData ) < f_poXMBContext->wNextStringPos ||
             ( f_poXMBContext->wNextStringPos + f_cchData ) >= f_poXMBContext->wNextOpenNodePos )
        {
            ChkDR( DRM_E_BUFFERTOOSMALL );
        }

        *f_ppwchData = &f_poXMBContext->XmlString[ f_poXMBContext->wNextStringPos ];
    }

    /* Update the output buffer pointer. */
    f_poXMBContext->wNextStringPos += f_cchData;

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

DRM_API DRM_RESULT DRM_CALL DRM_XMB_AddCData(
    __inout       _XMBContext      *pXmlContext,
    __in    const DRM_CONST_STRING *pdstrCData )
{
    DRM_RESULT       dr        = DRM_SUCCESS;
    DRM_DWORD        wReqSize  = 0;
    DRM_DWORD        wOffset   = 0;
    DRM_DWORD        wDst      = 0;
    DRM_DWORD        wSrc      = 0;
    DRM_DWORD        i         = 0;
    DRM_CONST_STRING dstrCData = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_AddCData );

    ChkArg( pXmlContext != NULL
         && pXmlContext->fInited    );
    ChkDRMString(pdstrCData);

    if ( (pXmlContext->wNextOpenNodePos + ( pXmlContext->fIsSimMode? 2 : 1 )) < pXmlContext->wNextOpenNodePos
       || (pXmlContext->wNextOpenNodePos + ( pXmlContext->fIsSimMode? 2 : 1 )) >= pXmlContext->wBuffSize )
    {
        ChkDR(DRM_E_NOMORE);    /* stack is empty */
    }

    /* trim leading and trialing blanks, but blank CDATA value is allowed */
    _AllTrim2(pdstrCData, &dstrCData);

    /* calculate the buffer size needed to insert <!<CDATA[xxx]]> */
    wReqSize = dstrCData.cchString; 

    ChkOverflow( wReqSize + g_dstrOpenCDATATag.cchString , wReqSize );
    wReqSize += g_dstrOpenCDATATag.cchString; 
    
    ChkOverflow( wReqSize + g_dstrCloseCDATATag.cchString , wReqSize );
    wReqSize += g_dstrCloseCDATATag.cchString; 

    if ( !pXmlContext->fIsSimMode )
    {
        if ( pXmlContext->wNextStringPos + wReqSize  < pXmlContext->wNextStringPos
         ||  pXmlContext->wNextStringPos + wReqSize >= pXmlContext->wNextOpenNodePos
         ||  pXmlContext->wNextStringPos + wReqSize >= pXmlContext->wBuffSize )
        {
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }

        /* at this point, we've got the required buffer length,
        ** now parse for '>' start from the current node name */
        ChkDR(_GetPushedDWORD(pXmlContext, CWCH_DWORD_STACK, &wOffset));
        
        while ( wOffset < pXmlContext->wBuffSize
           &&   pXmlContext->XmlString[wOffset] != g_wchGreaterThan )
        {
            wOffset++;
        }

        if ( wOffset >= pXmlContext->wBuffSize
        ||   pXmlContext->XmlString[wOffset] != g_wchGreaterThan )
        {
            ChkDR(DRM_E_NOXMLCLOSETAG);
        }

        /* now, XmlString[wOffset] contains the '>' char, insert CDATA after it
        ** first, move everything, if any, after '>' to give space for the insertion 
        */
        wOffset += 1;
        wDst = pXmlContext->wNextStringPos+wReqSize-1;
        wSrc = pXmlContext->wNextStringPos-1;
        
        for (i = 0; i < (pXmlContext->wNextStringPos - wOffset); i++)
        {
            pXmlContext->XmlString[wDst--] = pXmlContext->XmlString[wSrc--];
        }

        /* now, insert it in there */
        ChkDR( DRM_STR_StringCchCopyNW(&pXmlContext->XmlString[wOffset],
                                   pXmlContext->wBuffSize - wOffset, 
                                   g_dstrOpenCDATATag.pwszString, 
                                   g_dstrOpenCDATATag.cchString) );
        wOffset += g_dstrOpenCDATATag.cchString;
        
        ChkDR( DRM_STR_StringCchCopyNW(&pXmlContext->XmlString[wOffset], 
                                   pXmlContext->wBuffSize - wOffset, 
                                   dstrCData.pwszString, 
                                   dstrCData.cchString) );
        wOffset += dstrCData.cchString;
        
        ChkDR( DRM_STR_StringCchCopyNW(&pXmlContext->XmlString[wOffset], 
                                   pXmlContext->wBuffSize - wOffset, 
                                   g_dstrCloseCDATATag.pwszString, 
                                   g_dstrCloseCDATATag.cchString) );

    }

    /* update next XML string position */
    pXmlContext->wNextStringPos += wReqSize;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



DRM_API DRM_RESULT DRM_CALL DRM_XMB_AppendNode(
    __inout       _XMBContext      *pXmlContext,
    __in    const DRM_CONST_STRING *pdstrXmlString)
{
    DRM_RESULT       dr       = DRM_SUCCESS;
    DRM_CONST_STRING dstrNode = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_AppendNode );

    ChkArg( pXmlContext != NULL
         && pXmlContext->fInited    );
    ChkDRMString( pdstrXmlString );

    /* open the root node */
    ChkArg(_AllTrim2(pdstrXmlString, &dstrNode));

    if (! pXmlContext->fIsSimMode)
    {
        if ( pXmlContext->wNextStringPos + dstrNode.cchString  < pXmlContext->wNextStringPos
          || pXmlContext->wNextStringPos + dstrNode.cchString >= pXmlContext->wNextOpenNodePos)
        {
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }
        
        ChkOverflow( pXmlContext->wBuffSize, pXmlContext->wBuffSize - pXmlContext->wNextStringPos );

        ChkDR( DRM_STR_StringCchCopyNW(&pXmlContext->XmlString [pXmlContext->wNextStringPos], 
                                   pXmlContext->wBuffSize - pXmlContext->wNextStringPos,
                                   dstrNode.pwszString, 
                                   dstrNode.cchString) );
    }
    
    pXmlContext->wNextStringPos += dstrNode.cchString;

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}


DRM_API DRM_NO_INLINE DRM_DWORD DRM_CALL DRM_XMB_RequiredCharsForTag (
    __in const DRM_DWORD cchTag,
    __in const DRM_DWORD cchData,
    __in const DRM_DWORD cchAttrLabel,
    __in const DRM_DWORD cchAttrText)
{
    DRM_DWORD  cch = 0;

    cch = (cchTag * 2) +  5; /* <TAG></TAG> */
    
    cch += cchData;

    if (cchAttrLabel != 0)
    {
        cch += cchAttrLabel + 4;  /* two quotes, space and equal sign */
        cch += cchAttrText;
    }

    return cch;
}


DRM_API DRM_NO_INLINE DRM_DWORD DRM_CALL DRM_XMB_RequiredCharsForTagNoClose (
    __in const DRM_DWORD cchTag,
    __in const DRM_DWORD cchData,
    __in const DRM_DWORD cchAttrLabel,
    __in const DRM_DWORD cchAttrText)
{
    DRM_DWORD  cch = 0;

    cch = cchTag +  2; /* <TAG> */
    
    cch += cchData;

    if (cchAttrLabel != 0)
    {
        cch += cchAttrLabel + 4;  /* two quotes, space and equal sign */
        cch += cchAttrText;
    }

    return cch;
}


DRM_API DRM_NO_INLINE DRM_DWORD DRM_CALL DRM_XMB_RequiredCharsForAttribute (
    __in const DRM_DWORD cchAttrLabel,
    __in const DRM_DWORD cchAttrText)
{
    DRM_DWORD  cch = 0;

    if (cchAttrLabel != 0)
    {
        cch += cchAttrLabel + 4;  /* two quotes, space and equal sign */
        cch += cchAttrText;
    }

    return cch;
}


/**********************************************************************
**
** Function: DRM_XMB_WriteTag
**
** Synopsis: Adds XML node, it's value and attribute to XML context
**              
** Arguments:   INOUT pbDataOut      - pointer to XML context
**              IN    pdstrTag       - pointer to node name
**              IN    pdstrData      - pointer to node value
**              IN    pdstrAttrLabel - pointer to node name
**              IN    pdstrAttrText  - pointer to node value
**              IN    wtt            - value from WriteTagType enum 
**                                     which specifies if tag should be closed
**
** Returns:     DRM_SUCCESS on success. 
**      
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XMB_WriteTag (
    __inout        _XMBContext      *pbDataOut,
    __in     const DRM_CONST_STRING *pdstrTag,
    __in_opt const DRM_CONST_STRING *pdstrData,
    __in_opt const DRM_CONST_STRING *pdstrAttrLabel,
    __in_opt const DRM_CONST_STRING *pdstrAttrText,
    __in     enum  WriteTagType      wtt)
{
    DRM_RESULT  dr               = DRM_SUCCESS;
    _XMBContext oXMLContextSaved = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_WriteTag );

    ChkArg(pbDataOut != NULL
        && pdstrTag  != NULL);

    /* Save state of context to rollback if buffer overflows */
    ChkDR( _SaveContextState( pbDataOut, &oXMLContextSaved ) );

    ChkDR (DRM_XMB_OpenNode (pbDataOut, pdstrTag));

    if (pdstrAttrLabel != NULL
    &&  pdstrAttrText  != NULL)
    {
        ChkDR (DRM_XMB_AddAttribute (pbDataOut, pdstrAttrLabel, pdstrAttrText));
    }

    if (pdstrData != NULL)
    {
        ChkDR (DRM_XMB_AddData (pbDataOut, pdstrData));
    }
    
    if (wtt == wttClosed)
    {    
        ChkDR (DRM_XMB_CloseCurrNode (pbDataOut,  NULL));
    }

ErrorExit:    
    /* Restore state of context if buffer is not enough */
    if ( dr == DRM_E_BUFFERTOOSMALL )
    {
        _RestoreContextState( pbDataOut, &oXMLContextSaved );
    }

    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
} /* DRM_XMB_WriteTag */

/**********************************************************************
**
** Function: DRM_XMB_WriteCDATATag
**
** Synopsis: Adds CData XML node, it's value and attribute to XML context
**              
** Arguments:   INOUT pbDataOut      - pointer to XML context
**              IN    pdstrTag       - pointer to node name
**              IN    pdstrCDATA     - pointer to node value
**              IN    pdstrAttrLabel - pointer to node name
**              IN    pdstrAttrText  - pointer to node value
**              IN    wtt            - value from WriteTagType enum 
**                                     which specifies if tag should be closed
**
** Returns:     DRM_SUCCESS on success. 
**      
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XMB_WriteCDATATag (
    __inout        _XMBContext      *pbDataOut,
    __in     const DRM_CONST_STRING *pdstrTag,
    __in_opt const DRM_CONST_STRING *pdstrCDATA,
    __in_opt const DRM_CONST_STRING *pdstrAttrLabel,
    __in_opt const DRM_CONST_STRING *pdstrAttrText,
    __in     enum  WriteTagType      wtt)
{
    DRM_RESULT  dr               = DRM_SUCCESS;
    _XMBContext oXMLContextSaved = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_WriteCDATATag );

    ChkArg (pbDataOut  != NULL
        &&  pdstrTag   != NULL);

    /* Save state of context to rollback if buffer overflows */
    ChkDR( _SaveContextState( pbDataOut, &oXMLContextSaved ) );

    ChkDR (DRM_XMB_OpenNode (pbDataOut, pdstrTag));

    if (pdstrAttrLabel != NULL
    &&  pdstrAttrText  != NULL)
    {
        ChkDR (DRM_XMB_AddAttribute (pbDataOut, pdstrAttrLabel, pdstrAttrText));
    }

    if (pdstrCDATA != NULL)
    {
        ChkDR (DRM_XMB_AddCData (pbDataOut, pdstrCDATA));
    }
    
    if (wtt == wttClosed)
    {    
        ChkDR (DRM_XMB_CloseCurrNode (pbDataOut,  NULL));
    }

ErrorExit:    

    /* Restore state of context if buffer is not enough */
    if ( dr == DRM_E_BUFFERTOOSMALL )
    {
        _RestoreContextState( pbDataOut, &oXMLContextSaved );
    }
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
} /* DRM_XMB_WriteCDATATag */

DRM_API DRM_RESULT DRM_CALL DRM_XMB_RemainingBuffer(
    __in  _XMBContext *f_pbXMB,
    __out DRM_DWORD   *f_pcbRemaining)
{
    DRM_RESULT   dr       = DRM_SUCCESS;
    
    ChkArg(f_pbXMB        != NULL
        && f_pcbRemaining != NULL);
    
    ChkBOOL((f_pbXMB->wNextStringPos + CWCH_DWORD_STACK) < f_pbXMB->wNextOpenNodePos, DRM_E_BUFFERTOOSMALL);
    
    *f_pcbRemaining = (f_pbXMB->wNextOpenNodePos - (f_pbXMB->wNextStringPos + CWCH_DWORD_STACK));

ErrorExit:
    return dr;
}

/**********************************************************************
**
** Function: DRM_XMB_AddXMLNode
**
** Synopsis: Adds XML node and it's value to XML context
**              
** Arguments:   INOUT pbXmlContext - pointer to XML context
**              IN    dstrName     - pointer to node name
**              IN    dstrName     - pointer to node value
**
** Returns:     DRM_SUCCESS on success. 
**      
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XMB_AddXMLNode (  
    __inout       _XMBContext      *pbXMLContext, 
    __in    const DRM_CONST_STRING *dstrName, 
    __in    const DRM_CONST_STRING *dstrValue 
)
{   DRM_RESULT  dr               = DRM_SUCCESS;
    _XMBContext oXMLContextSaved = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLBUILDER, PERF_FUNC_DRM_XMB_AddXMLNode );

    ChkArg( pbXMLContext != NULL && dstrName != NULL && dstrValue != NULL );

    /* Save state of context to rollback if buffer overflows */
    ChkDR( _SaveContextState( pbXMLContext, &oXMLContextSaved ) );
    
    /* Opens node, add data, closes node */
    ChkDR( DRM_XMB_OpenNode( pbXMLContext,  dstrName   ) );

    /* adds data */
    ChkDR( DRM_XMB_AppendNode( pbXMLContext, dstrValue ) );

    /*closes node */
    ChkDR( DRM_XMB_CloseCurrNode( pbXMLContext, NULL   ) );

ErrorExit:

    /* Restore state of context if buffer is not enough */
    if ( dr == DRM_E_BUFFERTOOSMALL )
    {
        _RestoreContextState( pbXMLContext, &oXMLContextSaved );
    }
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmxmlparserlite.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmxmlparser.h>
#include <drmcrt.h>
#include <drmbase64.h>
#include <drmutilities.h>
#include <drmcipher.h>
#include <drmhmac.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

/*
***********************************************************************
** types used within this file
***********************************************************************
*/

typedef enum {
    eTagNone = 0,
    eOpenTag = 1,     /* <tag ...> */
    eCloseTag,      /* </tag> */
    eEmptyTag,      /* <tag ... /> */
    eCDataSection,  /* <![CDATA[...]]> */
}  _ETAGTYPE;

typedef enum {
    eInvalidData   = 0, 
    eOpaqueData    = 1, /* treat the data as binary blob - allow any symbol in it */
    eTrimSpaces    = 2, /* trim leading and trailing spaces: old code behavior for attr values */
    eStandardValue = 3, /* follow the standards: trim spaces, don't allow special symbols like '<'. Not supported yet. */
}   _EDATATYPE;

typedef struct _tag_XMLTAG 
{
    _ETAGTYPE       m_eTagType;
    DRM_SUBSTRING   m_dasstrTag;
    DRM_SUBSTRING   m_dasstrAttrName;
    DRM_SUBSTRING   m_dasstrAttrValue;
    DRM_SUBSTRING   m_dasstrCData;
    DRM_DWORD       m_ichTagBegin; /* index of '<' */
    DRM_DWORD       m_ichTagEnd;   /* index of '>' */
}  _XMLTAGA;

typedef struct _tag_XMLTAGW
{
    _ETAGTYPE        m_eTagType;         /* Tag type */            
    const DRM_WCHAR *m_pwszBase;         /* XML data string with this tag */
    DRM_SUBSTRING    m_dasstrTag;        /* XML tag name */
    DRM_SUBSTRING    m_dasstrAttrName;   /* Name of one of XML attributes that XML tag has, can be NULL */
    DRM_SUBSTRING    m_dasstrAttrValue;  /* Value of XML attibute m_dasstrAttrName, or NULL */
    DRM_SUBSTRING    m_dasstrCData;      /* string data in a tag <![CDATA[data]]> */
    DRM_DWORD        m_ichTagBegin;      /* Index of '<' */
    DRM_DWORD        m_ichTagEnd;        /* index of '>' */
}  _XMLTAGW;

#define SCAN_FOR(condition)  \
{                            \
    while (ichCurr != ichEnd \
       && !(condition))      \
    {                        \
        ichCurr++;           \
    }                        \
    if (ichCurr >= ichEnd)   \
    {                        \
        break;               \
    }                        \
}

#define SCAN_WHILE(condition) \
{                             \
    while(ichCurr != ichEnd   \
       && (condition))        \
    {                         \
        if (++ichCurr >= ichEnd) \
        {                        \
            break;               \
        }                        \
    }                        \
}

#define NEXT_CHAR            \
{                            \
    if (++ichCurr >= ichEnd) \
    {                        \
        break;               \
    }                        \
}    

#define SKIP_SPACEW           \
{                             \
    while (ichCurr < ichEnd   \
       &&  _IsSpaceW(pwszBase[ichCurr]))\
    {                         \
        ichCurr++;            \
    }                         \
    if (ichCurr >= ichEnd)    \
    {                         \
        break;                \
    }                         \
}

#define SKIP_SPACEA           \
{                             \
    while (ichCurr < ichEnd   \
       &&  _IsSpaceA(GET_CHAR(f_pszBase,ichCurr)))\
    {                         \
        ichCurr++;            \
    }                         \
    if (ichCurr >= ichEnd)    \
    {                         \
        break;                \
    }                         \
}

/*
***********************************************************************
** static functions
***********************************************************************
*/

#define _IsAlphaNumW(f_wch) (DRMCRT_iswalpha(f_wch) || DRMCRT_iswdigit(f_wch))

#define _IsAlphaNumA(f_ch) ( (f_ch >= '0' && f_ch <= '9')        \
                          || (f_ch >= 'a' && f_ch <= 'z')        \
                          || (f_ch >= 'A' && f_ch <= 'Z'))

#define _IsSymbolW(f_wch) ( _IsAlphaNumW(f_wch)                  \
                         || f_wch == g_wchUnderscore             \
                         || f_wch == g_wchColon                  \
                         || f_wch == g_wchMinus                  \
                         || f_wch == g_wchPeriod )

#define _IsSymbolA(f_ch) ( _IsAlphaNumA(f_ch)                    \
                        || f_ch == '_'                           \
                        || f_ch == ':'                           \
                        || f_ch == '-'                           \
                        || f_ch == '.' )

#define _IsFirstNameSymbolW(f_wch) ( _IsAlphaNumW(f_wch)         \
                         || f_wch == g_wchUnderscore             \
                         || f_wch == g_wchColon )                 


#define _IsFirstNameSymbolA(f_ch) ( _IsAlphaNumA(f_ch)           \
                        || f_ch == '_'                           \
                        || f_ch == ':' )                          


#define _IsSpaceW(f_wch) ( f_wch > 0           && ( NATIVE_WCHAR(f_wch) < NATIVE_WCHAR (g_wchExclamationMark) ) )
#define _IsSpaceA(f_ch)  ( f_ch > 0            && f_ch < '!' )
#define _IsQuoteW(f_wch) ( f_wch == g_wchQuote || f_wch == g_wchSingleQuote )
#define _IsQuoteA(f_ch)  ( f_ch == '\''        || f_ch == '\"' )



/*********************************************************************
** Function  : _TranslateXMLError
**
** Synopsis  : Converts XML parsing errors into more meaningful ones.
** 
** Arguments  
** [f_drXML] : Input DRM_RESULT code
**
** Returns   : DRM_RESULT
**             output error code
*********************************************************************/
DRMFORCEINLINE DRM_RESULT _TranslateXMLError(
    IN DRM_RESULT f_drXML )
{
    DRM_RESULT dr = f_drXML;

    switch (dr)
    {
    case DRM_E_NOXMLOPENTAG:
        dr = DRM_E_XMLNOTFOUND;
        break;

    default:
        dr = f_drXML;
        break;
    }

    return dr;
}


/*********************************************************************
** Function  : _AllTrimW
**
** Synopsis  : Trim all leading and trailing blanks in given string.
** 
** Arguments :   
** [f_pdstr] : string to be trimmed
**
** Returns   : DRM_BOOL   
**             TRUE if resulting string length > 0
*********************************************************************/
static DRM_NO_INLINE DRM_BOOL _AllTrimW(
    IN OUT DRM_CONST_STRING *f_pdstr )
{
    DRM_BOOL fOK = FALSE;
    
    if ( f_pdstr == NULL )
    {
        goto ErrorExit;
    }
    
    /*
    ** trim space in node data, if any
    */
    while ( f_pdstr->cchString > 0
        && _IsSpaceW( f_pdstr->pwszString [0] ) )
    {
        f_pdstr->pwszString++;
        f_pdstr->cchString--;
    }

    while ( f_pdstr->cchString > 0
        && _IsSpaceW( f_pdstr->pwszString [f_pdstr->cchString - 1] ) )
    {
        f_pdstr->cchString--;
    }

    fOK = ( f_pdstr->cchString > 0 );

ErrorExit:
    return fOK;
}


/*********************************************************************
** Function  : _AllTrimA
**
** Synopsis  : Trim all leading and trailing blanks in given string.
** 
** Arguments  
** [f_pszBase]  : base string
** [f_pdasstr]  : pointer to substring we trim
**
** Returns   : DRM_BOOL   
**             TRUE if resulting string length > 0
*********************************************************************/
static DRM_NO_INLINE DRM_BOOL _AllTrimA(
    IN     const DRM_CHAR *f_pszBase,
    IN OUT DRM_SUBSTRING  *f_pdasstr )
{
    DRM_BOOL fOK = FALSE;

    if ( f_pszBase == NULL
        || f_pdasstr == NULL )
    {
        goto ErrorExit;
    }
    
    /* 
    ** trim space in node data, if any 
    */
    while (  f_pdasstr->m_cch > 0
        && _IsSpaceA( GET_CHAR( f_pszBase, f_pdasstr->m_ich ) ) )
    {
        f_pdasstr->m_ich++;
        f_pdasstr->m_cch--;
    }

    while ( f_pdasstr->m_cch > 0 
       &&  _IsSpaceA( GET_CHAR( f_pszBase, ( f_pdasstr->m_ich + f_pdasstr->m_cch - 1 ) ) ) )
    {
        f_pdasstr->m_cch--;
    }

    fOK = ( f_pdasstr->m_cch > 0 );

ErrorExit:
    return fOK;
}


/************************************************************************************
** Function  :    _GetNextAttributeW
**
** Synopsis  :  Function looks for 'attribute="value"' construction in the data string.
**              It increases the pointer to a current position in a string if succeeds.
**
** Arguments :   
** [f_pdstrXML]         : points somewhere inside XML tag, either after a tag name,
**                        or between attributes, or before the closing bracket:
**                        <name # attr1='val1'# attr2='val2' # attrN='valN'# />,
**                        and there may be no attributes in a tag at all.
**                      
** [f_pichCurr]         : Place in XML string to begin parsing from. Returns
**                        position next after parsed attribute-value construction.
**                        If parsing failed it does not change value so that a caller
**                        may try different parser.
**
** [f_eDataType]        : Tells if we follow XML standard requirements 
**                        when parsing attribute value.
**
** [f_pdastrAttrName]   : Attribute name, may be NULL.
**
** [f_pdastrAttrValue]  : Attribute value, may be NULL.
**
** Returns   : DRM_BOOL. False if there is no attribute/value pair found.
**
** Note: If XML tag is well-formed but does not have attributes at all 
**       or there are no attributes between current position and closing bracket 
**       then the function also returns false.
************************************************************************************/
static DRM_NO_INLINE DRM_BOOL _GetNextAttributeW(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const _EDATATYPE       f_eDataType,
    IN OUT    DRM_DWORD        *f_pichCurr,
    OUT       DRM_SUBSTRING    *f_pdastrAttrName,
    OUT       DRM_SUBSTRING    *f_pdastrAttrValue )
{
    const DRM_WCHAR *pwszBase    = f_pdstrXML->pwszString;
    DRM_DWORD        ichEnd      = f_pdstrXML->cchString;
    DRM_DWORD        ichCurr     = *f_pichCurr;
    DRM_DWORD        dwPos       = 0;
    DRM_SUBSTRING    dastrName   = {0};
    DRM_SUBSTRING    dastrValue  = {0};
    DRM_BOOL         fParsedOkay = FALSE;
    DRM_WCHAR        wchQuote    = ONE_WCHAR( '\0', '\0' );
        
    while ( TRUE ) /* loop is needed for SKIP...() and NEXT macros */
    {
        SKIP_SPACEW;

        /*
        ** Check for attribute name, stop parsing if failed
        */
        if ( !_IsSymbolW( pwszBase [ichCurr] ) )
        {
            goto ErrorExit;
        }
        
        /*
        ** Found attribute name
        */
        dastrName.m_ich = ichCurr;
        
        /* 
        ** Scan for a terminator. 
        */
        SCAN_WHILE(_IsSymbolW(pwszBase [ichCurr]));    
        
        dastrName.m_cch = ichCurr - dastrName.m_ich;

        SKIP_SPACEW;
        
        /* 
        ** Check for '=' and skip it
        */
        if ( pwszBase [ichCurr] != g_wchEqual ) 
        {
            goto ErrorExit;
        }
        NEXT_CHAR;

        SKIP_SPACEW;

        /* 
        ** Check for quotes around attribute value: "value" or 'value'.
        ** Remember which type of quote is used, and skip it.
        */
        if ( !_IsQuoteW( pwszBase [ichCurr] ) )     
        {
            goto ErrorExit;
        }
        wchQuote = pwszBase [ichCurr];
        NEXT_CHAR;
        
        /* 
        ** Found attribute value
        */
        dastrValue.m_ich = ichCurr;

        /* 
        ** Scan for the terminating quote.
        */
        SCAN_FOR( pwszBase [ichCurr] == wchQuote );
        
        dastrValue.m_cch = ichCurr - dastrValue.m_ich;

        NEXT_CHAR;

        if (  f_eDataType == eTrimSpaces 
           || f_eDataType == eStandardValue )
        {
            while ( dastrValue.m_cch > 0 
                &&  _IsSpaceW( pwszBase [dastrValue.m_ich
                                       + dastrValue.m_cch
                                       - 1] ) )
            {
               dastrValue.m_cch--;
            }
            
            if ( f_eDataType == eStandardValue )
            {
                /*
                ** In addition to trimming spaces
                ** verify that value has only symbol characters,
                ** and the first letter if either alphanum, '_' or ':'
                */
                if ( !_IsFirstNameSymbolW( pwszBase[dastrValue.m_ich] ) )
                {
                    goto ErrorExit;                   
                }
                for ( dwPos = dastrValue.m_ich + 1; dwPos < dastrValue.m_cch; dwPos++ )
                {
                    if ( !_IsSymbolW( pwszBase[dwPos] ) )
                    {
                        goto ErrorExit;                   
                    }
                }
            }
        }

        /* 
        ** Parsed the attribute successfully
        */
        *f_pichCurr = ichCurr;
        fParsedOkay = TRUE;
        
        break;        
    }

ErrorExit:
    /*
    ** save attribute and value string if caller wants
    */
    if( f_pdastrAttrName != NULL )
    {
        f_pdastrAttrName->m_cch = dastrName.m_cch;
        f_pdastrAttrName->m_ich  = dastrName.m_ich;
    }
    if( f_pdastrAttrValue != NULL )
    {
        f_pdastrAttrValue->m_cch = dastrValue.m_cch;
        f_pdastrAttrValue->m_ich  = dastrValue.m_ich;
    }

    return fParsedOkay;
}


/************************************************************************************
** Function  :    _GetNextAttributeA
**
** Synopsis  :  Function looks for 'attribute="value"' construction in the data string.
**              It increases the pointer to a current position in a string if succeeds.
**
** Arguments :   
** [f_pszBase]          : base string with XML data
**
** [f_pdasstrXML]       : points somewhere inside XML tag, either after a tag name,
**                        or between attributes, or before the closing bracket:
**                        <name # attr1='val1'# attr2='val2' # attrN='valN'# />,
**                        and there may be no attributes in a tag at all.
**                      
** [f_eDataType]        : Tells if we follow XML standard requirements 
**                        when parsing attribute value.
**
** [f_pichCurr]         : Place in XML string to begin parsing from. Returns
**                        position next after parsed attribute-value construction.
**                        If parsing failed it does not change value so that a caller
**                        may try different parser.
**
** [f_pdasstrAttrName]  : attribute name, may be NULL.
**
** [f_pdasstrAttrValue] : attribute value, may be NULL.
**
** Returns   : DRM_BOOL. False if there is no attribute/value pair found.
**
** Note: If XML tag is well-formed but does not have attributes at all 
**       or there are no attributes between current position and closing bracket 
**       then the function also returns false.
************************************************************************************/
static DRM_NO_INLINE DRM_BOOL _GetNextAttributeA(
    IN const DRM_CHAR          *f_pszBase,
    IN const DRM_SUBSTRING     *f_pdasstrXML, 
    IN  const _EDATATYPE       f_eDataType,
    IN OUT    DRM_DWORD        *f_pichCurr,
    OUT       DRM_SUBSTRING    *f_pdasstrAttrName,
    OUT       DRM_SUBSTRING    *f_pdasstrAttrValue )
{
    DRM_DWORD        ichEnd      = f_pdasstrXML->m_ich 
                                 + f_pdasstrXML->m_cch;
    DRM_DWORD        ichCurr     = *f_pichCurr;
    DRM_DWORD        dwPos       = 0;
    DRM_SUBSTRING    dastrName   = {0};
    DRM_SUBSTRING    dastrValue  = {0};
    DRM_BOOL         fParsedOkay = FALSE;
    DRM_CHAR         chQuote     = '\0';
        
    while ( TRUE ) /* loop is needed for SCAN, SKIP and NEXT macros */
    {
        SKIP_SPACEA;

        /*
        ** Check for attribute name, stop parsing if failed
        */
        if ( !_IsSymbolA( GET_CHAR( f_pszBase, ichCurr ) ) )
        {
            goto ErrorExit;
        }
        
        /*
        ** Found attribute name
        */
        dastrName.m_ich = ichCurr;
        
        /* 
        ** Scan for a terminator. 
        */
        SCAN_WHILE( _IsSymbolA( GET_CHAR( f_pszBase, ichCurr ) ) );    
        
        dastrName.m_cch = ichCurr - dastrName.m_ich;

        SKIP_SPACEA;
        
        /* 
        ** Check for '=' and skip it
        */
        if ( GET_CHAR( f_pszBase, ichCurr ) != '=' )
        {
            goto ErrorExit;
        }
        NEXT_CHAR;

        SKIP_SPACEA;

        /* 
        ** Check for quotes around attribute value: "value" or 'value'.
        ** Remember which type of quote is used, and skip it.
        */
        if ( !_IsQuoteA( GET_CHAR( f_pszBase, ichCurr ) ) )     
        {
            goto ErrorExit;
        }
        chQuote = GET_CHAR( f_pszBase, ichCurr );
        NEXT_CHAR;
        
        /* 
        ** Found attribute value
        */
        dastrValue.m_ich = ichCurr;

        /* 
        ** Scan for the terminating quote.
        */
        SCAN_FOR( GET_CHAR( f_pszBase, ichCurr ) == chQuote );
        
        dastrValue.m_cch = ichCurr - dastrValue.m_ich;

        NEXT_CHAR;

        if ( f_eDataType == eTrimSpaces || f_eDataType == eStandardValue )
        {
            while ( dastrValue.m_cch > 0 
                &&  _IsSpaceA( GET_CHAR( f_pszBase, 
                                       dastrValue.m_ich + dastrValue.m_cch - 1 ) ) )
            {
               dastrValue.m_cch--;
            }
            if ( f_eDataType == eStandardValue )
            {
                /*
                ** In addition to trimming spaces
                ** verify that value has only symbol characters,
                ** and the first letter if either alphanum, '_' or ':'
                */
                if ( !_IsFirstNameSymbolA( GET_CHAR( f_pszBase, dastrValue.m_ich ) ) )
                {
                    goto ErrorExit;                   
                }
                for ( dwPos = dastrValue.m_ich + 1; dwPos < dastrValue.m_cch; dwPos++ )
                {
                    if ( !_IsSymbolA( GET_CHAR( f_pszBase, dwPos ) ) )
                    {
                        goto ErrorExit;                   
                    }
                }
            }
        }

        /* 
        ** Parsed the attribute successfully
        */
        *f_pichCurr = ichCurr;
        fParsedOkay = TRUE;
        
        break;        
    }

ErrorExit:
    /*
    ** save attribute and value string if caller wants
    */
    if( f_pdasstrAttrName != NULL )
    {
        f_pdasstrAttrName->m_cch = dastrName.m_cch;
        f_pdasstrAttrName->m_ich  = dastrName.m_ich;
    }
    if( f_pdasstrAttrValue != NULL )
    {
        f_pdasstrAttrValue->m_cch = dastrValue.m_cch;
        f_pdasstrAttrValue->m_ich  = dastrValue.m_ich;
    }

    return fParsedOkay;
}


/**********************************************************************************************
** Function  : _ScanTagW
**
** Synopsis  : Finds the first well-formed XML tag of the type that we support;
**             for example, comments tag will be ignored.
** 
** Arguments :   
**    [f_pdstrXML]     : XML data string where we look for XML tag
**    [f_pichCurr]     : pointer to start position in XML data string, may be modified
**    [f_ptagParsed]   : output XML tag
**
** Returns   : DRM_BOOL : True if found one of the following:
**                      1. CDATA tag: <![CDATA[xxxx]]>
**                      2. Close tag: </tagName>
**                      3. Open tag:  <tagName attrib="value">
**                      4. Empty tag:  <tagName attrib="value" />
**
** Notes     :  1. f_pichCurr will be changed only if function succeeded - it will point 
**              to the next character after end of parsed tag.
**              2. f_ptagParsed may contain invalid data if function failed.
**              
**********************************************************************************************/
static DRM_NO_INLINE DRM_BOOL _ScanTagW(
    IN const DRM_CONST_STRING *f_pdstrXML, 
    IN OUT   DRM_DWORD        *f_pichCurr, 
       OUT   _XMLTAGW         *f_ptagParsed )
{
    const DRM_WCHAR *pwszBase    =  f_pdstrXML->pwszString;
    DRM_DWORD        ichCurr     = *f_pichCurr;
    DRM_DWORD        ichEnd      =  f_pdstrXML->cchString;
    DRM_BOOL         fParsedOkay =  FALSE;
    DRM_DWORD        ichOpenTag  =  0;        /* position of '<' */

    
#if DBG
    ZEROMEM(f_ptagParsed, SIZEOF(_XMLTAGW));  /* init return value */
#endif

    f_ptagParsed->m_pwszBase = pwszBase;    
    f_ptagParsed->m_eTagType = eTagNone;
    
    while ( ichCurr < ichEnd )
    {
        /* 
        ** Look for '<'
        */
        SCAN_FOR( pwszBase [ichCurr] == g_wchLessThan );

        ichOpenTag = ichCurr;

        NEXT_CHAR;
        
        /* 
        ** ------------------------------------------------------------------ 
        ** '</...'
        ** parse the close tag
        ** ------------------------------------------------------------------ 
        */
        if ( pwszBase [ichCurr] == g_wchForwardSlash )
        {
            NEXT_CHAR;

            if ( _IsSymbolW( pwszBase [ichCurr] ) )
            {
                f_ptagParsed->m_eTagType = eCloseTag;

                goto PARSE_TAG;
            }            
            /*
            ** Bad tag: look for '>' to end it, ignore the tag and continue.
            */
            SCAN_FOR( pwszBase [ichCurr] == g_wchGreaterThan );

            NEXT_CHAR;
            continue;
        }

        /* 
        ** ------------------------------------------------------------------ 
        ** '<?...'
        ** parse the Process Instruction: not supported, ignore and continue
        ** ------------------------------------------------------------------ 
        */
        else if ( pwszBase [ichCurr] == g_wchQuestionMark )
        {
            NEXT_CHAR;

            SCAN_FOR(pwszBase [ichCurr] == g_wchGreaterThan);

            NEXT_CHAR;
            continue;
        }

        /* 
        ** ------------------------------------------------------------------ 
        ** '<!...'
        ** parse the Special tag, read CDATA tag, ignore others and continue
        ** ------------------------------------------------------------------ 
        */
        else if ( pwszBase [ichCurr] == g_wchExclamationMark )
        {
            NEXT_CHAR;

            if ( pwszBase [ichCurr] == g_wchMinus )     
            {
                /*
                ** '<!-...'
                ** Comment tag, look for terminating '-->', ignore and continue.
                */
                SCAN_FOR( ichCurr < ichEnd - 2
                    && pwszBase [ichCurr]     == g_wchMinus
                    && pwszBase [ichCurr + 1] == g_wchMinus
                    && pwszBase [ichCurr + 2] == g_wchGreaterThan );
                
                ichCurr+= 2; /* set ichCurr to '>' in '--> */

                NEXT_CHAR;
                continue; 
            }
            
            /* 
            ** '<![...'
            ** Could be CDATA section, otherwise it's a bad tag
            */            
            else if ( pwszBase [ichCurr] == g_wchLeftBracket )
            {
                NEXT_CHAR;
                /* 
                ** Check if this is CDATA section: '<![CDATA[...'
                */
                if ( ( ichCurr + g_dstrTagCDATAOpenBracket.cchString ) >= ichEnd  
                    || ( DRMCRT_wcsncmp( (DRM_WCHAR *) ( pwszBase + ichCurr ), 
                                 g_dstrTagCDATAOpenBracket.pwszString, 
                                 g_dstrTagCDATAOpenBracket.cchString) != 0 ) )
                {   
                    /* 
                    ** not CDATA section, look for '>' to end it, ignore the tag and continue.
                    */
                    SCAN_FOR( pwszBase [ichCurr] == g_wchGreaterThan );

                    NEXT_CHAR;
                    continue;
                }
                else
                {
                    /* 
                    ** CDATA section found, parse it right here.
                    ** The tag's name is always "CDATA".
                    */
                    f_ptagParsed->m_dasstrTag.m_ich = ichCurr;
                    f_ptagParsed->m_dasstrTag.m_cch = g_dstrTagCDATA.cchString;

                    /*
                    ** Skip "CDATA["
                    */
                    ichCurr += g_dstrTagCDATAOpenBracket.cchString;
                    
                    f_ptagParsed->m_dasstrCData.m_ich = ichCurr;
                    f_ptagParsed->m_dasstrCData.m_cch = 0;
                    
                    /*
                    ** Scan for terminating ']]>' 
                    */                    
                    SCAN_FOR( ichCurr + 2 < ichEnd
                        && pwszBase [ichCurr]     == g_wchRightBracket
                        && pwszBase [ichCurr + 1] == g_wchRightBracket
                        && pwszBase [ichCurr + 2] == g_wchGreaterThan );

                    /*
                    ** CDATA tag parsed successfully, 
                    ** save data and exit the main while loop
                    */
                    f_ptagParsed->m_dasstrCData.m_cch = ichCurr
                                                        - f_ptagParsed->m_dasstrCData.m_ich;

                    f_ptagParsed->m_eTagType    = eCDataSection;
                    f_ptagParsed->m_ichTagBegin = ichOpenTag;
                    f_ptagParsed->m_ichTagEnd   = ichCurr;

                    fParsedOkay = TRUE;
                    break;
                }
            }           
            /* 
            ** inline DTD tag which is not '<!...' and not '<!-...' and not '<![...'
            ** ignore and continue
            */
            else if ( _IsSymbolW( pwszBase [ichCurr] ) )
            {
                NEXT_CHAR;

                SCAN_FOR( pwszBase [ichCurr] == g_wchGreaterThan );
                
                NEXT_CHAR;
                continue;
            }
        }
        /* 
        ** ------------------------------------------------------------------ 
        ** '<#...'
        ** Open tag, parse it.
        ** ------------------------------------------------------------------ 
        */
        else if ( _IsFirstNameSymbolW( pwszBase [ichCurr] ) ) /* first symbol cannot be '.' or '-' */
        {
PARSE_TAG:   
            /* 
            ** Scan for tag name.
            */
            f_ptagParsed->m_dasstrTag.m_ich = ichCurr;

            SCAN_WHILE(_IsSymbolW(pwszBase [ichCurr]));

            f_ptagParsed->m_dasstrTag.m_cch = ichCurr - f_ptagParsed->m_dasstrTag.m_ich;

            /* 
            ** We've got the tag name.
            ** Skip whitespaces and parse attr name.
            */
            SKIP_SPACEW;

            if( _GetNextAttributeW( f_pdstrXML, 
                                    eTrimSpaces,
                                    &ichCurr,
                                    &f_ptagParsed->m_dasstrAttrName,
                                    &f_ptagParsed->m_dasstrAttrValue ) )
            {
                /*
                ** Error: there can be no attributes in </tagname> nodes
                */
                if ( f_ptagParsed->m_eTagType == eCloseTag )
                {
                    break;
                }
                
                /* 
                ** We have the first attribute value, skip the rest.
                */
                while( _GetNextAttributeW( f_pdstrXML, 
                                           eOpaqueData,
                                           &ichCurr,
                                           NULL,
                                           NULL ) )
                {
                }
            }
            
            /*
            ** Find the end of tag.
            */
            SCAN_FOR( pwszBase [ichCurr] == g_wchGreaterThan );   

            if ( f_ptagParsed->m_eTagType != eCloseTag )
            {
                if ( pwszBase [ichCurr - 1] == g_wchForwardSlash )
                {
                    f_ptagParsed->m_eTagType = eEmptyTag;
                }
                else
                {
                    f_ptagParsed->m_eTagType = eOpenTag;  
                }
            }

            f_ptagParsed->m_ichTagBegin = ichOpenTag;
            f_ptagParsed->m_ichTagEnd   = ichCurr;

            fParsedOkay = TRUE;
            
            NEXT_CHAR;
            break;  /* that's it, we parsed a tag */
        }
    }

    if ( fParsedOkay )
    {
        *f_pichCurr = ichCurr;
    }

    return fParsedOkay;
}


/**********************************************************************************************
** Function  : _ScanTagA
**
** Synopsis  : Finds the first well-formed XML tag of the type that we support;
**             for example, comments tag will be ignored.
** 
** Arguments :   
**    [f_pszBase]        : base string
**    [f_pdasstrXML]     : pointer to XML data string where we look for XML tag
**    [f_pichCurr]       : pointer to start position in XML data string, may be modified
**    [f_ptagParsed]     : output XML tag
**
** Returns   : DRM_BOOL : True if found one of the following:
**                      1. CDATA tag: <![CDATA[xxxx]]>
**                      2. Close tag: </tagName>
**                      3. Open tag:  <tagName attrib="value">
**                      4. Empty tag:  <tagName attrib="value" />
**
** Notes     :  1. f_pichCurr will be changed only if function succeeded - it will point 
**              to the next character after end of parsed tag.
**              2. f_ptagParsed may contain invalid data if function failed.
**              
**********************************************************************************************/
static DRM_NO_INLINE DRM_BOOL _ScanTagA(
    IN const DRM_CHAR      *f_pszBase,
    IN const DRM_SUBSTRING *f_pdasstrXML, 
    IN OUT   DRM_DWORD     *f_pichCurr, 
       OUT   _XMLTAGA      *f_ptagParsed )
{
    DRM_DWORD ichEnd      = f_pdasstrXML->m_ich + f_pdasstrXML->m_cch;                            
    DRM_DWORD ichCurr     = *f_pichCurr;
    DRM_BOOL  fParsedOkay = FALSE;
    DRM_DWORD ichOpenTag  = 0;

#if DBG
    ZEROMEM(f_ptagParsed, SIZEOF(_XMLTAGA));    /* init return value */
#endif

    f_ptagParsed->m_eTagType = eTagNone;
    
    while ( ichCurr < ichEnd )
    {
        /* 
        ** Look for '<'
        */
        SCAN_FOR( GET_CHAR( f_pszBase, ichCurr ) == '<' );

        ichOpenTag = ichCurr;

        NEXT_CHAR;

        /* 
        ** ------------------------------------------------------------------ 
        ** '</...'
        ** parse the close tag
        ** ------------------------------------------------------------------ 
        */
        if ( GET_CHAR( f_pszBase, ichCurr ) == '/' )
        {
            NEXT_CHAR;
            
            if ( _IsSymbolA( GET_CHAR( f_pszBase, ichCurr ) ) )
            {
                f_ptagParsed->m_eTagType = eCloseTag;
                goto PARSE_TAG;
            }
            /*
            ** Bad tag: look for '>' to end it, ignore the tag and continue.
            */
            SCAN_FOR( GET_CHAR( f_pszBase, ichCurr ) == '>' );            

            NEXT_CHAR;
            continue;
        }
        /* 
        ** ------------------------------------------------------------------ 
        ** '<?...'
        ** parse the Process Instruction: not supported, ignore and continue
        ** ------------------------------------------------------------------ 
        */
        else if ( GET_CHAR( f_pszBase, ichCurr ) == '?' )
        {
            NEXT_CHAR;

            SCAN_FOR( GET_CHAR( f_pszBase, ichCurr ) == '>' );

            NEXT_CHAR;
            continue;
        }

        /* 
        ** ------------------------------------------------------------------ 
        ** '<!...'
        ** parse the Special tag, read CDATA tag, ignore others and continue
        ** ------------------------------------------------------------------ 
        */
        else if ( GET_CHAR( f_pszBase, ichCurr ) == '!' )
        {
            NEXT_CHAR;

            if ( GET_CHAR( f_pszBase, ichCurr ) == '-' )
            {
                /*
                ** '<!-...'
                ** Comment tag, look for terminating '-->', ignore and continue.
                */
                SCAN_FOR( ichCurr < ichEnd - 2
                        && GET_CHAR( f_pszBase, ichCurr )     == '-'
                        && GET_CHAR( f_pszBase, ichCurr + 1 ) == '-'
                        && GET_CHAR( f_pszBase, ichCurr + 2 ) == '>' );

                ichCurr += 2; /* set ichCurr to '>' in '--> */

                NEXT_CHAR;
                continue;
            }
            /* 
            ** '<![...'
            ** Could be CDATA section, otherwise it's a bad tag
            */            
            else if ( GET_CHAR( f_pszBase, ichCurr ) == '[' )    
            {
                NEXT_CHAR;
                /* 
                ** Check if this is CDATA section: '<![CDATA[...'
                */
                if ( ichCurr + g_dastrTagCDATAOpenBracket.cchString >= ichEnd  
                    || DRM_BYT_CompareBytes( f_pszBase, 
                                             ichCurr, 
                                             g_dastrTagCDATAOpenBracket.pszString, 
                                             0, 
                                             g_dastrTagCDATAOpenBracket.cchString ) != 0 )
                {   
                    /* 
                    ** not CDATA section, scan for terminating '>' and ignore this tag
                    */
                    SCAN_FOR( GET_CHAR( f_pszBase, ichCurr ) == '>' );            

                    NEXT_CHAR;
                    continue;
                }
                else
                {
                    /* 
                    ** CDATA section found, parse it right here.
                    ** The tag's name is always "CDATA".
                    */
                    f_ptagParsed->m_dasstrTag.m_ich = ichCurr;
                    f_ptagParsed->m_dasstrTag.m_cch = g_dastrTagCDATA.cchString;

                    /*
                    ** Skip "CDATA["
                    */
                    ichCurr += g_dastrTagCDATAOpenBracket.cchString;
                    
                    f_ptagParsed->m_dasstrCData.m_ich = ichCurr;
                    f_ptagParsed->m_dasstrCData.m_cch = 0;

                    /*
                    ** Scan for terminating ']]>' 
                    */                    
                    SCAN_FOR( ichCurr < ichEnd - 2
                        && GET_CHAR( f_pszBase, ichCurr )     == ']'
                        && GET_CHAR( f_pszBase, ichCurr + 1 ) == ']'
                        && GET_CHAR( f_pszBase, ichCurr + 2 ) == '>' );

                    f_ptagParsed->m_dasstrCData.m_cch = ichCurr 
                                                        - f_ptagParsed->m_dasstrCData.m_ich;
                    /*
                    ** CDATA tag parsed successfully, 
                    ** save data and exit the main while loop
                    */
                    f_ptagParsed->m_eTagType    = eCDataSection;
                    f_ptagParsed->m_ichTagBegin = ichOpenTag;
                    
                    f_ptagParsed->m_ichTagEnd = ichCurr;
                    fParsedOkay               = TRUE;
                    break;
                }
            }
            /* 
            ** inline DTD tag which is not '<!...' and not '<!-...' and not '<![...'
            ** ignore and continue
            */
            else if ( _IsSymbolA( GET_CHAR( f_pszBase, ichCurr ) ) )
            {
                NEXT_CHAR;
                SCAN_FOR(GET_CHAR(f_pszBase, ichCurr) == '>');
                NEXT_CHAR;
                continue;
            }
        }
        /* 
        ** ------------------------------------------------------------------ 
        ** '<#...'
        ** Open tag, parse it.
        ** ------------------------------------------------------------------ 
        */
        else if ( _IsFirstNameSymbolA( GET_CHAR( f_pszBase, ichCurr ) ) ) /* first symbol cannot be '.' or '-' */
        {
PARSE_TAG:   
            /* 
            ** Scan for tag name. 
            */
            f_ptagParsed->m_dasstrTag.m_ich = ichCurr;
            
            SCAN_WHILE( _IsSymbolA( GET_CHAR( f_pszBase, ichCurr ) ) );

            f_ptagParsed->m_dasstrTag.m_cch = ichCurr - f_ptagParsed->m_dasstrTag.m_ich;

            /* 
            ** We've got the tag name.
            ** Skip whitespaces and parse attr name.
            */
            SKIP_SPACEA;
            
            if( _GetNextAttributeA( f_pszBase,
                                    f_pdasstrXML, 
                                    eTrimSpaces,
                                    &ichCurr,
                                    &f_ptagParsed->m_dasstrAttrName,
                                    &f_ptagParsed->m_dasstrAttrValue ) )
            {
                /*
                ** Error: there can be no attributes in </tagname> nodes
                */
                if ( f_ptagParsed->m_eTagType == eCloseTag )
                {
                    break;
                }

                /* 
                ** We have the first attribute value, skip the rest.
                */
                while( _GetNextAttributeA( f_pszBase,
                                           f_pdasstrXML, 
                                           eOpaqueData,
                                           &ichCurr,
                                           NULL,
                                           NULL ) )
                {
                }
            }
            /*
            ** Find the end of tag.
            */
            SCAN_FOR( GET_CHAR( f_pszBase, ichCurr ) == '>' );   

            if ( f_ptagParsed->m_eTagType != eCloseTag )
            {
                if ( GET_CHAR( f_pszBase, ichCurr - 1 ) == '/' )
                {
                    f_ptagParsed->m_eTagType = eEmptyTag;
                }
                else
                {
                    f_ptagParsed->m_eTagType = eOpenTag;  
                }
            }

            f_ptagParsed->m_ichTagBegin = ichOpenTag;
            f_ptagParsed->m_ichTagEnd   = ichCurr;

            fParsedOkay = TRUE;
            
            NEXT_CHAR;
            break;  /* that's it, we parsed a tag */
        }
    }

    if (fParsedOkay)
    {
        *f_pichCurr = ichCurr;
    }

    return fParsedOkay;
}


/**********************************************************************
** Function  :    _ScanNodeForAttributeW
**
** Synopsis  :  Function looks for an attribute's value in the first XML tag
**              it finds in the string.
**
** Arguments   
** [f_pdstrNode]       : points to a node whose attributes are scanned,
**                       should look like 
**                       <name attr1="val1" attr1="val2" ... attrN="valN">
** [f_pdstrAttr]       : attribute name to retrieve, assume it is never NULL
** [f_ptagParsed]      : XML tag found
**
** Returns   : DRM_BOOL
************************************************************************/
static DRM_NO_INLINE DRM_BOOL _ScanNodeForAttributeW(
    IN const DRM_CONST_STRING *f_pdstrNode,
    IN const DRM_CONST_STRING *f_pdstrAttr,
    OUT      _XMLTAGW         *f_ptagParsed )
{
    const DRM_WCHAR *pwszBase    = f_pdstrNode->pwszString;
    DRM_DWORD        ichEnd      = f_pdstrNode->cchString;
    DRM_DWORD        ichCurr     = 0;
    DRM_BOOL         fParsedOkay = FALSE;
    DRM_CONST_STRING dstrAttr    = EMPTY_DRM_STRING;

#if DBG   
    ZEROMEM( f_ptagParsed, SIZEOF( _XMLTAGW ) );  /* init return value */
#endif

    while ( TRUE ) 
    {
        SCAN_FOR( pwszBase [ichCurr] == g_wchLessThan );   /* Find the next '<' */

        if ( pwszBase [ichCurr] != g_wchLessThan )
        {
            goto ErrorExit;   /* cannot find  '<' */
        }
        
        NEXT_CHAR;

        /* 
        ** Parse the contents of a tag
        */
        if ( !_IsFirstNameSymbolW( pwszBase [ichCurr] ) )  /* '<#...' */
        {
            goto ErrorExit;  /* cannot find an element tag */
        }
        
        /*
        ** Scan for tag name.
        */
        f_ptagParsed->m_dasstrTag.m_ich = ichCurr;
        
        /*
        ** Scan for a terminator. 
        */        
        SCAN_WHILE( _IsSymbolW( pwszBase [ichCurr] ) );    
        
        f_ptagParsed->m_dasstrTag.m_cch = ichCurr - f_ptagParsed->m_dasstrTag.m_ich;

        /*
        ** At this point, we've got the tag name
        */

        SKIP_SPACEW;   /* skip any whitespace and parse attributes */
        
        if ( _IsSymbolW( pwszBase [ichCurr] ) )  /* <... #... */
        {
PARSE_ATTR:
            if( _GetNextAttributeW( f_pdstrNode, 
                                    eTrimSpaces,
                                    &ichCurr,
                                    &f_ptagParsed->m_dasstrAttrName,
                                    &f_ptagParsed->m_dasstrAttrValue ) )
            {
                dstrAttr.pwszString = pwszBase + f_ptagParsed->m_dasstrAttrName.m_ich;
                dstrAttr.cchString  =            f_ptagParsed->m_dasstrAttrName.m_cch;

                if ( DRM_UTL_DSTRStringsEqual( &dstrAttr, f_pdstrAttr ) )
                {
                    /* 
                    ** Scan till there is no more attributes 
                    */
                    while( _GetNextAttributeW( f_pdstrNode, 
                                               eOpaqueData,
                                               &ichCurr,
                                               NULL,
                                               NULL ) )
                    {
                    }

                    /* 
                    ** Now scan for '>' to make sure this is a legal tag 
                    */                
                    SCAN_FOR( pwszBase [ichCurr] == g_wchGreaterThan );

                    fParsedOkay = TRUE;

                    f_ptagParsed->m_ichTagBegin = 0;
                    f_ptagParsed->m_ichTagEnd   = 0;
                    DRMASSERT( ichCurr > 1 );
                    if ( pwszBase [ichCurr - 1] == g_wchForwardSlash )
                    {
                        f_ptagParsed->m_eTagType = eEmptyTag;
                    }
                    else
                    {
                        f_ptagParsed->m_eTagType = eOpenTag;  
                    }
                    goto ErrorExit;        /* we found it */
                }
                else
                {
                    SKIP_SPACEW;   /* skip any whitespace */

                    if ( _IsAlphaNumW( pwszBase [ichCurr] ) )
                    {
                        /*
                        * Parse another attribute
                        */
                        goto PARSE_ATTR;
                    }
                }
            }
        }    
        break;
    }

ErrorExit:
    return fParsedOkay;
}


/**********************************************************************
** Function  :    _ScanNodeForAttributeA
**
** Synopsis  :  Function looks for an attribute's value in the first XML tag
**              it finds in the string.
**
** Arguments    
** [f_pszBase]        : data string
** [f_pdstrNode]      : substring with a node whose attributes are scanned,
**                      should look like 
**                      <name attr1="val1" attr1="val2" ... attrN="valN">
** [f_pdastrAttrName] : attribute name to retrieve, assume it is never NULL
** [f_ptagParsed]     : XML tag found
**
** Returns   : DRM_RESULT
************************************************************************/
static DRM_NO_INLINE DRM_BOOL _ScanNodeForAttributeA(
    IN const DRM_CHAR              *f_pszBase,
    IN const DRM_SUBSTRING         *f_pdasstrNode,
    IN const DRM_ANSI_CONST_STRING *f_pdastrAttrName,
    OUT      _XMLTAGA              *f_ptagParsed )
{
    DRM_DWORD ichEnd      = f_pdasstrNode->m_ich 
                          + f_pdasstrNode->m_cch;
    DRM_DWORD ichCurr     = f_pdasstrNode->m_ich;
    DRM_BOOL  fParsedOkay = FALSE;

#if DBG    
    ZEROMEM( f_ptagParsed, SIZEOF( _XMLTAGA ) ); /* init return value */
#endif
    
    while ( TRUE )
    {
        SCAN_FOR( GET_CHAR( f_pszBase, ichCurr ) == '<' ); /* Find the next '<' */

        if ( GET_CHAR( f_pszBase, ichCurr ) != '<' )
        {
            goto ErrorExit;   /* cannot find  '<' */
        }
        
        NEXT_CHAR;

        /* 
        ** Parse the contents of a tag
        */
        if ( !_IsFirstNameSymbolA( GET_CHAR( f_pszBase, ichCurr ) ) )  /* '<#...' */
        {
            goto ErrorExit;  /* cannot find an element tag */
        }
        
        /* 
        ** Scan for tag name. 
        */
        f_ptagParsed->m_dasstrTag.m_ich = ichCurr;
        
        /* 
        ** Scan for a terminator. 
        */        
        SCAN_WHILE( _IsSymbolA( GET_CHAR( f_pszBase, ichCurr ) ) );    
        
        f_ptagParsed->m_dasstrTag.m_cch = ichCurr - f_ptagParsed->m_dasstrTag.m_ich;

        /* 
        ** At this point, we've got the tag name 
        */
        SKIP_SPACEA;   /* skip any whitespace and parse attr name. */
        
        if ( _IsSymbolA( GET_CHAR( f_pszBase, ichCurr ) ) )  /* <... #... */
        {
PARSE_ATTR:
            if( _GetNextAttributeA( f_pszBase,
                                    f_pdasstrNode,
                                    eTrimSpaces,
                                    &ichCurr,
                                    &f_ptagParsed->m_dasstrAttrName,
                                    &f_ptagParsed->m_dasstrAttrValue ) )
            {

                /* check if this is the attr we want */
                if ( DRM_UTL_DASSTRStringsEqual( f_pszBase, 
                                                 &f_ptagParsed->m_dasstrAttrName, 
                                                 f_pdastrAttrName ) )
                {
                    /* 
                    ** Scan till there is no more attributes 
                    */
                    while( _GetNextAttributeA( f_pszBase,
                                               f_pdasstrNode,
                                               eOpaqueData,
                                               &ichCurr,
                                               NULL,
                                               NULL ) )
                    {}

                    /* 
                    ** Scan for '>' to make sure this is a legal tag 
                    */                    
                    SCAN_FOR( GET_CHAR( f_pszBase, ichCurr ) == '>' );   

                    fParsedOkay = TRUE;

                    f_ptagParsed->m_ichTagBegin = 0;
                    f_ptagParsed->m_ichTagEnd   = 0;
                    DRMASSERT( ichCurr > 1 );
                    if ( GET_CHAR( f_pszBase, ichCurr - 1 ) == '/' )
                    {
                        f_ptagParsed->m_eTagType = eEmptyTag;
                    }
                    else
                    {
                        f_ptagParsed->m_eTagType = eOpenTag;  
                    }
                    
                    goto ErrorExit;        /* we found it */
                }
                else
                {
                    SKIP_SPACEA;   /* skip any whitespace and parse attr value. */

                    if ( _IsAlphaNumA( GET_CHAR( f_pszBase, ichCurr ) ) )
                    {
                        goto PARSE_ATTR;    /* keep going */
                    }
                }
            }
        }
        
        break;
    }

ErrorExit:
    return fParsedOkay;
}



/******************************************************************************************************************
** Function  :    _CheckTagW
**
** Synopsis  :    Checks if some XML tag matches tagname, attribute and value parameters.
**                If f_pdstrTag is NULL or empty then try to match only by attribute and value.
**                If f_pdstrTag string is present then match by tag name
**                and by attribute and value only if attribute is not empty.
**                If all three string parameters are NULL then the function returns tag's type.
**                If the tag name is NULL and tag type is eCloseTag then the function returns eCloseTag type.
**
** Arguments :   
**     [f_ptagParsed]     : some XML tag
**     [f_pdstrTag]       : pointer to XML tag name, may be NULL
**     [f_pdstrAttrName]  : pointer to XML tag's attribute name, may be NULL
**     [f_pdstrAttrValue] : pointer to XML tag's attribute value, may be NULL
**
** Returns   : _ETAGTYPE     : if there is no match - eTagNone, otherwise f_ptagParsed type
******************************************************************************************************************/
static DRM_NO_INLINE _ETAGTYPE _CheckTagW(
    IN       _XMLTAGW         *f_ptagParsed, 
    IN const DRM_CONST_STRING *f_pdstrTag,
    IN const DRM_CONST_STRING *f_pdstrAttrName,
    IN const DRM_CONST_STRING *f_pdstrAttrValue ) 
{
    const DRM_WCHAR *pwszBase       = NULL; /* XML data string */
    DRM_BOOL   fWork                = FALSE;
    _ETAGTYPE  eStatus              = eTagNone;
    DRM_CONST_STRING dstrParsed     = EMPTY_DRM_STRING;   /* temporary storage of parsed tag's data */

    if ( f_ptagParsed == NULL )
    {
        return eTagNone;
    }

    pwszBase = f_ptagParsed->m_pwszBase;    
    dstrParsed.cchString  = f_ptagParsed->m_dasstrTag.m_cch;
    dstrParsed.pwszString = pwszBase + f_ptagParsed->m_dasstrTag.m_ich;
    
    /*
    ** If tag name is empty or if it matches name of a parsed tag
    ** we will need to compare attribute and value.
    ** Otherwise tag names don't match, and check failed.
    */
    fWork = ( f_pdstrTag == NULL
           || f_pdstrTag->cchString  == 0
           || f_pdstrTag->pwszString == NULL );
         
    fWork = fWork || DRM_UTL_DSTRStringsEqual( f_pdstrTag, &dstrParsed );

    if ( fWork )
    {
        if ( f_ptagParsed->m_eTagType == eCloseTag )
        {
            eStatus = eCloseTag; /* don't compare attribute and value for closing tags like </tagname> */
        }
        else if ( f_pdstrAttrName  == NULL 
               || f_pdstrAttrName->pwszString == NULL
               || f_pdstrAttrName->cchString == 0 )
        {
            eStatus = f_ptagParsed->m_eTagType; /* empty attribute name is ignored */
        }
        else
        {
            /* 
            ** check the attribute and its value, return eTagNone if value is not provided or does not match 
            */
            dstrParsed.cchString  = f_ptagParsed->m_dasstrAttrName.m_cch;
            dstrParsed.pwszString = pwszBase + f_ptagParsed->m_dasstrAttrName.m_ich;

            if ( DRM_UTL_DSTRStringsEqual( &dstrParsed, f_pdstrAttrName ) )
            {
                
                dstrParsed.cchString  = f_ptagParsed->m_dasstrAttrValue.m_cch;
                dstrParsed.pwszString = pwszBase + f_ptagParsed->m_dasstrAttrValue.m_ich;

                if ( f_pdstrAttrValue != NULL 
                    && DRM_UTL_DSTRStringsEqual( &dstrParsed, f_pdstrAttrValue ) )
                {
                    eStatus = f_ptagParsed->m_eTagType;
                }
            }
        }
    }
    
    return eStatus;
}


static DRM_NO_INLINE _ETAGTYPE _CheckTagA(
    IN const DRM_CHAR              *f_pszBase,
    IN       _XMLTAGA              *f_ptagParsed, 
    IN const DRM_CHAR              *f_pszBaseTag,
    IN const DRM_SUBSTRING         *f_pdasstrTag,
    IN const DRM_ANSI_CONST_STRING *f_pdastrAttrName,
    IN const DRM_ANSI_CONST_STRING *f_pdasstrAttrValue )
{
    DRM_BOOL  fWork    = FALSE;
    _ETAGTYPE eStatus  = eTagNone;
    
    fWork = f_pdasstrTag->m_cch == 0 
         || f_pszBaseTag        == NULL;
         
    fWork = (fWork 
          || DRM_UTL_DASSSTRStringsEqual(f_pszBase, 
                                        &f_ptagParsed->m_dasstrTag, 
                                         f_pszBaseTag,
                                         f_pdasstrTag));

    if (fWork)
    {
        if (f_ptagParsed->m_eTagType == eCloseTag)
        {
            eStatus = eCloseTag;
        }

        /* attribute is ignored */
        else if (f_pdastrAttrName            == NULL 
             ||  f_pdastrAttrName->cchString == 0)
        {
            eStatus = f_ptagParsed->m_eTagType;
        }

        /* check the attribute and its value */
        
        else if (DRM_UTL_DASSTRStringsEqual(f_pszBase, &f_ptagParsed->m_dasstrAttrName,   f_pdastrAttrName)
              && DRM_UTL_DASSTRStringsEqual(f_pszBase, &f_ptagParsed->m_dasstrAttrValue,  f_pdasstrAttrValue))
        {
                eStatus = f_ptagParsed->m_eTagType;
        }
    }
    
    return eStatus;
}

/**********************************************************************************************************
** Function  :    _GetXMLSubNodeW
**
** Synopsis  :    Scans XML string and looks for XML node under XML tag with given name and attribute data.
**                Caller can specify how many XML hierarchy layers to skip.
**
** Arguments :   
**    [f_pdstrXML]         : pointer into XML string data, not necessarily the beginning
**    [f_pdstrTag]         : pointer to XML tag name
**    [f_pdstrAttrName]    : pointer to XML tag's attribute name, may be NULL
**    [f_pdstrAttrValue]   : pointer to XML tag's attribute value, may be NULL
**    [f_iNode]            : look for f_iNode-th occurence of XML tag in f_pdstrXML
                             on the same hierarchy level; 0 means the first occurence.
**    [f_pdstrNodeOut]     : pointer to XML node under found XML tag,
**                           either f_pdstrNodeOut or f_pdstrNodeDataOut can be NULL but not both
**    [f_pdstrNodeDataOut] : pointer to XML node's data under found XML tag
**                           either f_pdstrNodeOut or f_pdstrNodeDataOut can be NULL but not both
**    [f_cLayersToSkip]    : number of XML hierarchy levels to skip down before beginning to match XML tags
**
**   Returns               : DRM_RESULT
**
**********************************************************************************************************/
static DRM_NO_INLINE DRM_RESULT _GetXMLSubNodeW(
    IN const DRM_CONST_STRING *f_pdstrXML,
    IN const DRM_CONST_STRING *f_pdstrTag,
    IN const DRM_CONST_STRING *f_pdstrAttrName,
    IN const DRM_CONST_STRING *f_pdstrAttrValue,
    IN const DRM_DWORD         f_iNode,
    OUT      DRM_CONST_STRING *f_pdstrNodeOut,
    OUT      DRM_CONST_STRING *f_pdstrNodeDataOut,
    IN const DRM_DWORD         f_cLayersToSkip )
{
    DRM_RESULT dr               = DRM_E_NOXMLOPENTAG;
    DRM_DWORD  cNodes           = 0;
    DRM_DWORD  ichCurr          = 0;
    DRM_DWORD  cTagsUnmatched   = 0;   /* counts the balance of opening and closing tags,
                                          use this counter to skip XML hierarchy levels */                                        
    DRM_DWORD  cTagsMatched     = 0;   /* balance of tags that passed _CheckTagW() */
    DRM_DWORD  ichNodeBegin     = 0;
    DRM_DWORD  ichNodeEnd       = 0;
    DRM_DWORD  ichDataBegin     = 0;
    DRM_DWORD  ichDataEnd       = 0;
    _ETAGTYPE  eStatus          = eTagNone;
    _XMLTAGW   xmltagW          = { eTagNone, 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLPARSER, PERF_FUNC__GetXMLSubNodeW );
    DRM_PROFILING_DETAIL_LEVEL(6);

    ChkDRMString( f_pdstrXML );
    ChkDRMString( f_pdstrTag );
    
    ChkArg( f_pdstrNodeOut    != NULL
        || f_pdstrNodeDataOut != NULL );

    while ( TRUE )
    {
        /*
        ** scan for tag at currIndex 
        */
        if ( !_ScanTagW( f_pdstrXML, &ichCurr, &xmltagW ) )
        {
            if ( cTagsMatched == 0 )
            {
                ChkDR( DRM_E_NOXMLOPENTAG );
            }
            else
            {
                ChkDR( DRM_E_NOXMLCLOSETAG );
            }
        }

        /*
        ** skip XML hierarchy levels
        */
        if ( cTagsUnmatched != f_cLayersToSkip )
        {
            if ( xmltagW.m_eTagType == eOpenTag )
            {
                cTagsUnmatched++;
            }
            else if ( xmltagW.m_eTagType == eCloseTag )
            {
                if ( cTagsUnmatched > 0 )
                {
                    cTagsUnmatched--;
                }
                else
                {
                    ChkDR( DRM_E_NOXMLOPENTAG );
                }
            }
            continue;
        }

        /* 
        ** check if we have a match to the node tag
        */
        eStatus = _CheckTagW( &xmltagW, 
                               f_pdstrTag, 
                               f_pdstrAttrName, 
                               f_pdstrAttrValue );

        switch ( eStatus )
        {
        case eOpenTag:     /* open tag found */
            /* 
            ** this is the first matched open tag found.
            ** if cTagsMatched > 0 it means the matched opend tag is nested.
            */
            if ( cTagsMatched == 0 ) 
            {
                ichNodeBegin = xmltagW.m_ichTagBegin;
                ichDataBegin = xmltagW.m_ichTagEnd + 1;                               
            }
            cTagsMatched++;
            break;

        case eCloseTag:    /* close tag found */
            /*
            ** we get </tag> before we get <tag>
            */
            if ( cTagsMatched == 0 )
            {
                ChkDR( DRM_E_NOXMLOPENTAG );
            }
            cTagsMatched--;
            
            if ( cTagsMatched == 0 )  /* make sure it is not nested */
            {
                /*
                ** we've got the matching <tag> and </tag>, 
                ** exit the loop if this is the node we want
                */
                if ( cNodes == f_iNode )
                {
                    ichNodeEnd = xmltagW.m_ichTagEnd;
                    ichDataEnd = xmltagW.m_ichTagBegin - 1;
                    goto PREPARENODE;
                }
                ichNodeBegin = 0;
                ichDataBegin = 0;
                cNodes++;
            }
            break;

        case eEmptyTag:
            if ( cTagsMatched == 0 )
            {
                /* 
                ** we've got the matching <tag/>, 
                ** exit the loop if this is the node we want
                */
                if ( cNodes == f_iNode )
                {
                    ichNodeBegin = xmltagW.m_ichTagBegin;
                    ichNodeEnd   = xmltagW.m_ichTagEnd;
                    ichDataBegin = 0;
                    ichDataEnd   = 0;
                    goto PREPARENODE;
                }
                ichNodeBegin = 0;
                cNodes++;
            }
            break;

        default:   /* eTagNone or eCDataSection */
            if ( xmltagW.m_eTagType == eOpenTag )
            {
                cTagsUnmatched++;
            }
            else if ( xmltagW.m_eTagType == eCloseTag )
            {
                if ( cTagsUnmatched > f_cLayersToSkip )
                {
                    --cTagsUnmatched;
                }
                else
                {
                    /* 
                    ** end of 'f_cLayersToSkip' layers exits, the target tag is not found 
                    */
                    ChkDR( DRM_E_NOXMLOPENTAG );   
                }
            }
            break;
        }
    }

PREPARENODE:
    /* 
    ** prepare f_pdstrNodeOut & f_pdstrNodeDataOut 
    */
    if ( f_pdstrNodeOut != NULL )
    {
        f_pdstrNodeOut->pwszString = f_pdstrXML->pwszString + ichNodeBegin;
        f_pdstrNodeOut->cchString  = (DRM_DWORD) ( ichNodeEnd - ichNodeBegin + 1 );
    }

    if ( f_pdstrNodeDataOut != NULL )
    {
        if ( eStatus == eEmptyTag )
        {
            f_pdstrNodeDataOut->pwszString = NULL;
            f_pdstrNodeDataOut->cchString  = 0;
        }
        else
        {
            f_pdstrNodeDataOut->pwszString = f_pdstrXML->pwszString + ichDataBegin;
            f_pdstrNodeDataOut->cchString = (DRM_DWORD) ( ichDataEnd - ichDataBegin + 1 );

            /* 
            ** trim space in node data, if any 
            */
            _AllTrimW( f_pdstrNodeDataOut );
        }
    }
    dr = DRM_SUCCESS;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;
    
    return dr;
}


static DRM_NO_INLINE DRM_RESULT _GetXMLSubNodeA(
    IN  const DRM_CHAR              *f_pszXMLBase,
    IN  const DRM_SUBSTRING         *f_pdasstrXML,
    IN  const DRM_CHAR              *f_pszTagBase,
    IN  const DRM_SUBSTRING         *f_pdasstrTag,
    IN  const DRM_ANSI_CONST_STRING *f_pdastrAttrName,
    IN  const DRM_ANSI_CONST_STRING *f_pdasstrAttrValue,
    IN  const DRM_DWORD             f_iNode,
    OUT DRM_SUBSTRING               *f_pdasstrNode,     /* these two parameters can either be NULL but not both */
    OUT DRM_SUBSTRING               *f_pdasstrNodeData,
    IN  const DRM_DWORD             f_iLayer,
    IN  DRM_BOOL                    f_fSkipValidation )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD     cTagsMatched   = 0;
    DRM_DWORD     cNodes         = 0;
    DRM_DWORD     cTagsUnmatched = 0;   /* increment until we find the matching tag */
    DRM_DWORD     ichNodeBegin   = 0; 
    DRM_DWORD     ichDataBegin   = 0; 
    DRM_DWORD     ichNodeEnd     = 0; 
    DRM_DWORD     ichDataEnd     = 0; 
    DRM_DWORD     ichCurr        = f_pdasstrXML->m_ich;
    _ETAGTYPE     eStatus        = eTagNone;
    _XMLTAGA      xmltag         = { eTagNone, 0 };    

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMXMLPARSER, PERF_FUNC_DRM_XML_GetSubNodeA);
    DRM_PROFILING_DETAIL_LEVEL(6);

    ChkArg( f_pszXMLBase != NULL );
    ChkArg( f_pszTagBase != NULL );
    ChkArg(f_pdasstrXML != NULL );
    ChkArg( f_pdasstrTag != NULL);
    ChkArg(f_pdasstrNode != NULL || f_pdasstrNodeData != NULL);

    while (TRUE)
    {
        /* scan for tag at currIndex */
        if (! _ScanTagA(f_pszXMLBase, f_pdasstrXML, &ichCurr, &xmltag))
        {
            if (cTagsMatched == 0)
            {
                ChkDR(DRM_E_NOXMLOPENTAG);
            }
            else
            {
                ChkDR(DRM_E_NOXMLCLOSETAG);
            }
        }

        /* check if we have a match to the node tag */
        if (cTagsUnmatched != f_iLayer)
        {
            if (xmltag.m_eTagType == eOpenTag)
            {
                cTagsUnmatched++;
            }
            else if (xmltag.m_eTagType == eCloseTag)
            {
                if (cTagsUnmatched > 0)
                {
                    cTagsUnmatched--;
                }
                else
                {
                    ChkDR(DRM_E_NOXMLOPENTAG);
                }
            }
            continue;
        }

        eStatus = _CheckTagA(f_pszXMLBase,
                             &xmltag, 
                             f_pszTagBase, 
                             f_pdasstrTag,
                             f_pdastrAttrName, 
                             f_pdasstrAttrValue);
        switch (eStatus)
        {
        case eOpenTag:     /* open tag found */
            /* this is the first matched open tag found. if cTagsMatched>0, it
            ** means the matched opend tag is nested.
            */
            if (cTagsMatched == 0) 
            {
                ichNodeBegin = xmltag.m_ichTagBegin;
                ichDataBegin = xmltag.m_ichTagEnd + 1;
                if ( f_fSkipValidation 
                    && ( cNodes == f_iNode ) )
                {
                    ichNodeEnd = f_pdasstrXML->m_ich + f_pdasstrXML->m_cch - 1;
                    ichDataEnd = f_pdasstrXML->m_ich + f_pdasstrXML->m_cch - 1;
                    goto PREPARENODE;
                }                
            }
            cTagsMatched++;
            break;

        case eCloseTag:    /* close tag found */
            if (cTagsMatched == 0)
            {
                /* we get </tag> before we get <tag> */
                ChkDR(DRM_E_NOXMLOPENTAG);
            }
            
            cTagsMatched--;
            
            if (cTagsMatched == 0)  /* make sure it is not nested */
            {
                /* we've got the matching <tag> and </tag>, 
                ** exit the loop if this is the node we want
                */
                if (cNodes == f_iNode)
                {
                    ichNodeEnd = xmltag.m_ichTagEnd;
                    ichDataEnd = xmltag.m_ichTagBegin - 1;
                    goto PREPARENODE;
                }
                ichNodeBegin = 0;
                ichDataBegin = 0;
                cNodes++;
            }
            break;

        case eEmptyTag:
            if (cTagsMatched == 0)
            {
                /* we've got the matching <tag/>, 
                ** exit the loop if this is the node we want
                */
                if (cNodes == f_iNode)
                {
                    ichNodeBegin = xmltag.m_ichTagBegin;
                    ichNodeEnd   = xmltag.m_ichTagEnd;
                    ichDataBegin = 0;
                    ichDataEnd   = 0;
                    goto PREPARENODE;
                }
                ichNodeBegin = 0;
                cNodes++;
            }
            break;

        default:
            if (xmltag.m_eTagType == eOpenTag)
            {
                cTagsUnmatched++;
            }
            else if (xmltag.m_eTagType == eCloseTag)
            {
                if (cTagsUnmatched > f_iLayer)
                {
                    cTagsUnmatched--;
                }
                else
                {
                    /* end of 'f_cLayers' layers exits, the target tag is not found */
                    ChkDR(DRM_E_NOXMLOPENTAG);   
                }
            }
            break;
        }
    }

PREPARENODE:
    /* prepare f_pdstrNode & f_pdstrNodeData */
    if (f_pdasstrNode != NULL)
    {
        f_pdasstrNode->m_ich = ichNodeBegin;
        f_pdasstrNode->m_cch = (ichNodeEnd - ichNodeBegin + 1);
    }

    if (f_pdasstrNodeData != NULL)
    {
        if (eStatus == eEmptyTag)
        {
            f_pdasstrNodeData->m_cch = 0;
            f_pdasstrNodeData->m_ich = 0;
        }
        else
        {
            f_pdasstrNodeData->m_ich = ichDataBegin;
            f_pdasstrNodeData->m_cch = (ichDataEnd - ichDataBegin + 1);

            _AllTrimA(f_pszXMLBase, f_pdasstrNodeData);
        }
    }
    dr = DRM_SUCCESS;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return _TranslateXMLError(dr);
}


/*********************************************************************
** Function  : _GetXMLNodeCDataA
**
** Synopsis  : returns data from CDATA node,
**             may return zero-length substring
** 
** Arguments :   
**    [f_pszXMLBase]   : string with XML data
**    [f_pdasstrXML]   : points to XML node with CDATA, 
**                       cannot be NULL, nor point to zero-length substring
**    [f_pdasstrCData] : returned CDATA string, must not be NULL 
**
** Returns   : DRM_RESULT
**
** Notes     : The function allows one opening tag before CDATA tag.
**             If it finds two opening tags or tag of other types 
**             it returns error.
*********************************************************************/
static DRM_NO_INLINE DRM_RESULT _GetXMLNodeCDataA(
    IN  const DRM_CHAR      *f_pszXMLBase,
    IN  const DRM_SUBSTRING *f_pdasstrXML,
    OUT       DRM_SUBSTRING *f_pdasstrCData
    )
{
    DRM_RESULT dr            = DRM_E_NOXMLCDATA;
    DRM_BOOL   fOpenTagFound = FALSE;
    DRM_DWORD  ichCurr       = 0;
    _XMLTAGA   xmltagA       = { eTagNone, 0 };

    ChkArg( f_pszXMLBase != NULL );
    ChkArg( f_pdasstrXML != NULL );
    ChkArg( f_pdasstrXML->m_cch > 0 );
    ChkArg( f_pdasstrCData != NULL );
    
    ichCurr = f_pdasstrXML->m_ich;

    while ( TRUE )
    {
        /*
        ** scan for tag at currIndex
        */
        if ( !_ScanTagA( f_pszXMLBase, f_pdasstrXML, &ichCurr, &xmltagA ) )
        {
            if ( !fOpenTagFound )
            {
                ChkDR( DRM_E_NOXMLOPENTAG );      /* open tag not found yet */
            }
            else
            {
                ChkDR( DRM_E_NOXMLCDATA );        /* could not find CDATA */
            }
        }

        switch ( xmltagA.m_eTagType )
        {
            case eTagNone:
            case eCloseTag:
            case eEmptyTag:
                ChkDR( DRM_E_NOXMLCDATA );    /* could not find CDATA */

            case eOpenTag:
                if ( fOpenTagFound )
                {
                    ChkDR( DRM_E_INVALIDXMLTAG ); /* an open tag found already */
                }

                fOpenTagFound = TRUE;
                break;

            case eCDataSection:
                if ( !fOpenTagFound )
                {
                    ChkDR( DRM_E_NOXMLOPENTAG ); /* an open tag not found yet */
                }

                f_pdasstrCData->m_cch  = xmltagA.m_dasstrCData.m_cch;
                f_pdasstrCData->m_ich  = xmltagA.m_dasstrCData.m_ich;
                
                dr = ( _AllTrimA( f_pszXMLBase, f_pdasstrCData ) 
                      ? DRM_SUCCESS
                      : DRM_E_NOXMLCDATA );

                goto ErrorExit;
        }
    }

ErrorExit:
    return dr;
}


/*********************************************************************
** Function  : _GetXMLNodeCDataW
**
** Synopsis  : .
** 
** 
** Arguments :   
**    [f_pdstrNode]     :   pointer to XML data string with CDATA node.
**                          must be not NULL, and string should be not empty.
**    [f_pdstrCData]    :   returned CDATA string, must not be NULL.
**
** Returns   : DRM_RESULT
**
** Notes     : The function allows one opening tag before CDATA tag.
**             If it finds two opening tags or tag of other types 
**             it returns error.
*********************************************************************/
static DRM_NO_INLINE DRM_RESULT _GetXMLNodeCDataW(
    IN const DRM_CONST_STRING *f_pdstrNode,
    OUT      DRM_CONST_STRING *f_pdstrCData
    )
{
    DRM_RESULT dr            = DRM_E_NOXMLCDATA;
    DRM_BOOL   fOpenTagFound = FALSE;
    DRM_DWORD  ichCurr       = 0;
    _XMLTAGW   xmltagW       = { eTagNone, 0 };

    ChkDRMString( f_pdstrNode );
    
    ChkArg( f_pdstrCData != NULL );
    
    while ( TRUE )
    {
        /*
        ** scan for tag at currIndex
        */
        if ( !_ScanTagW( f_pdstrNode, &ichCurr, &xmltagW ) )
        {
            if ( !fOpenTagFound )
            {
                ChkDR( DRM_E_NOXMLOPENTAG );      /* open tag not found yet */
            }
            else
            {
                ChkDR( DRM_E_NOXMLCDATA );        /* could not find CDATA */
            }
        }

        switch ( xmltagW.m_eTagType )
        {
            case eTagNone:
            case eCloseTag:
            case eEmptyTag:
                ChkDR( DRM_E_NOXMLCDATA );    /* could not find CDATA */

            case eOpenTag:
                if ( fOpenTagFound )
                {
                    ChkDR( DRM_E_INVALIDXMLTAG ); /* an open tag found already */
                }

                fOpenTagFound = TRUE;
                break;

            case eCDataSection:
                if ( !fOpenTagFound )
                {
                    ChkDR( DRM_E_NOXMLOPENTAG ); /* an open tag not found yet */
                }

                f_pdstrCData->cchString  = xmltagW.m_dasstrCData.m_cch;
                f_pdstrCData->pwszString = f_pdstrNode->pwszString + xmltagW.m_dasstrCData.m_ich;
                
                dr = ( _AllTrimW( f_pdstrCData ) 
                      ? DRM_SUCCESS
                      : DRM_E_NOXMLCDATA );

                goto ErrorExit;
        }
    }

ErrorExit:
    return dr;
}


/**************************************************************************************************
** Function  :    _EnumXMLSubNodeW
**
** Synopsis  :    In the given XML string retrieves the next node either with a specified tag name
**                (if f_pdstrTag is not empty) or with just any node.
**
**                Function can be used by XML nodes enumerator.
**                Caller can specify how many XML hierarchy layers to skip.
**
** Arguments :   
**    [f_pdstrXML]          : pointer to XML string data
**                            can point to some place in the middle of XML data
**    [f_pdstrTag]          : pointer to XML tag name, cannot be NULL, may be empty string.
**    [f_pdstrNode]         : pointer to XML node under found XML tag,
**                            either f_pdstrNodeOut or f_pdstrNodeDataOut can be NULL but not both
**    [f_pdstrNodeData]     : pointer to XML node's data under found XML tag
**    [f_pdstr1stAttrName]  : pointer to XML tag's attribute name, may be NULL
**    [f_pdstr1stAttrValue] : pointer to XML tag's attribute value, may be NULL
**    [f_pfIsLeaf]          : will be set to TRUE of the returned node is a leaf node
**    [f_cLayers]           : number of XML hierarchy levels to skip down
**
** Returns   : DRM_RESULT
****************************************************************************************************/
static DRM_RESULT _EnumXMLSubNodeW(
    IN const DRM_CONST_STRING *f_pdstrXML,
    IN       DRM_CONST_STRING *f_pdstrTag,
    OUT      DRM_CONST_STRING *f_pdstrNode,
    OUT      DRM_CONST_STRING *f_pdstrNodeData,
    OUT      DRM_CONST_STRING *f_pdstr1stAttrName, 
    OUT      DRM_CONST_STRING *f_pdstr1stAttrValue, 
    OUT      DRM_BOOL         *f_pfIsLeaf,
    IN const DRM_DWORD         f_cLayers )
{
    DRM_RESULT       dr               = DRM_E_NOXMLOPENTAG;
    DRM_DWORD        cTagsMatched     = 0; 
    DRM_DWORD        ichNodeBegin     = 0, 
                     ichDataBegin     = 0, 
                     ichNodeEnd       = 0, 
                     ichDataEnd       = 0, 
                     ichCurr          = 0;
    DRM_DWORD        cTagsUnmatched   = 0;        /* increment until we find the matching tag */
    _ETAGTYPE        eStatus          = eTagNone;
    _XMLTAGW         xmltag           = { eTagNone, 0 };   
    DRM_CONST_STRING dstr1stAttrName  = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstr1stAttrValue = EMPTY_DRM_STRING;

    ChkDRMString( f_pdstrXML );
    ChkArg( f_pdstrTag != NULL );    
    ChkArg( f_pfIsLeaf     != NULL );
    ChkArg( f_pdstrNode    != NULL
        || f_pdstrNodeData != NULL );

    *f_pfIsLeaf = TRUE;
    
    xmltag.m_pwszBase = f_pdstrXML->pwszString;
    
    while ( TRUE )
    {
        /*
        ** scan for tag at currIndex
        */
        if ( !_ScanTagW( f_pdstrXML, &ichCurr, &xmltag ) )
        {
            if ( cTagsMatched == 0 )
            {
                ChkDR( DRM_E_NOXMLOPENTAG );
            }
            else
            {
                ChkDR( DRM_E_NOXMLCLOSETAG );
            }
        }

        /*
        ** skip XML hierarchy levels
        */
        if ( cTagsUnmatched != f_cLayers )
        {
            if ( xmltag.m_eTagType == eOpenTag )
            {
                cTagsUnmatched++;
            }
            else if ( xmltag.m_eTagType == eCloseTag )
            {
                if ( cTagsUnmatched>0 )
                {
                    cTagsUnmatched--;
                }
                else
                {
                    ChkDR( DRM_E_NOXMLOPENTAG );
                }
            }
            continue;
        }

        /* 
        ** grab the tag: 
        ** if f_pdstrTag is empty string then just return a tag's type,
        ** else only grab the tag with a name that matches f_pdstrTag 
        */
        eStatus = _CheckTagW( &xmltag, 
                              f_pdstrTag, 
                              NULL, 
                              NULL );

        switch ( eStatus )
        {
            case eOpenTag:
                /* 
                ** this is the first matched open tag found. if cTagsMatched>0, it
                ** means the matched opend tag is nested.
                */
                if ( cTagsMatched == 0 ) 
                {
                    ichNodeBegin = xmltag.m_ichTagBegin;
                    ichDataBegin = xmltag.m_ichTagEnd + 1;

                    /* 
                    ** assign the tag name so that we know what to look for closing tag
                    */
                    f_pdstrTag->cchString  = xmltag.m_dasstrTag.m_cch;
                    f_pdstrTag->pwszString = f_pdstrXML->pwszString + xmltag.m_dasstrTag.m_ich;

                    /*
                    ** save the attr name/value 
                    */
                    dstr1stAttrName.cchString  = xmltag.m_dasstrAttrName.m_cch;
                    dstr1stAttrName.pwszString = f_pdstrXML->pwszString + xmltag.m_dasstrAttrName.m_ich;
                    dstr1stAttrValue.cchString  = xmltag.m_dasstrAttrValue.m_cch;
                    dstr1stAttrValue.pwszString = f_pdstrXML->pwszString + xmltag.m_dasstrAttrValue.m_ich;
                }
                else if ( *f_pfIsLeaf )
                {
                    *f_pfIsLeaf = FALSE;
                }
                cTagsMatched++;
                break;
                
            case eCloseTag:
                if (cTagsMatched == 0) /* we get </tag> before we get <tag> */
                {                    
                    ChkDR(DRM_E_NOXMLOPENTAG);
                }
                cTagsMatched--;
                
                if ( cTagsMatched == 0 )  /* make sure it is not nested */
                {
                    /* 
                    ** we've got the matching <tag> and </tag>, 
                    ** exit the loop if this is the node we want
                    */
                    ichNodeEnd = xmltag.m_ichTagEnd;
                    ichDataEnd = xmltag.m_ichTagBegin - 1;
                    goto PREPARENODE;
                }
                break;

            case eEmptyTag:
                if ( cTagsMatched == 0 )
                {
                    /* 
                    ** we've got the matching <tag/>, 
                    ** exit the loop, this is the node we want
                    */
                    ichNodeBegin = xmltag.m_ichTagBegin;
                    ichDataBegin = 0;
                    ichNodeEnd   = xmltag.m_ichTagEnd;
                    ichDataEnd   = 0;

                    /* 
                    ** assign the tag name so that we know what to look for closing tag
                    */
                    f_pdstrTag->cchString  = xmltag.m_dasstrTag.m_cch;
                    f_pdstrTag->pwszString = f_pdstrXML->pwszString + xmltag.m_dasstrTag.m_ich;
                    goto PREPARENODE;
                }
                break;
                
            default: /* eStatus is eTagNone or eCDataSection */
                if ( xmltag.m_eTagType == eOpenTag )
                {
                    cTagsUnmatched++;
                    *f_pfIsLeaf = FALSE;
                }
                else if ( xmltag.m_eTagType == eCloseTag )
                {
                    if ( cTagsUnmatched > f_cLayers )
                    {
                        cTagsUnmatched--;
                    }
                    else
                    {
                        /* 
                        ** end of 'f_cLayers' layers exits, the target tag is not found
                        */
                        ChkDR( DRM_E_NOXMLOPENTAG );   
                    }
                }
                break;
        }
    }

PREPARENODE:
    /* 
    ** prepare f_pdstrNode & f_pdstrNodeData
    */
    if ( f_pdstrNode != NULL )
    {
        f_pdstrNode->pwszString = f_pdstrXML->pwszString  + ichNodeBegin;
        f_pdstrNode->cchString  = (DRM_DWORD) (ichNodeEnd - ichNodeBegin + 1);
    }

    if (f_pdstrNodeData != NULL)
    {
        if (eStatus == eEmptyTag)
        {
            f_pdstrNodeData->pwszString = NULL;
            f_pdstrNodeData->cchString  = 0;
        }
        else
        {
            f_pdstrNodeData->pwszString = f_pdstrXML->pwszString  + ichDataBegin;
            f_pdstrNodeData->cchString  = (DRM_DWORD) (ichDataEnd - ichDataBegin + 1);

            if (! _AllTrimW(f_pdstrNodeData))
            {
                f_pdstrNodeData->pwszString = NULL;
            }
        }
    }

    if (f_pdstr1stAttrName != NULL)
    {
        *f_pdstr1stAttrName = dstr1stAttrName;
    }

    if (f_pdstr1stAttrValue != NULL)
    {
        *f_pdstr1stAttrValue = dstr1stAttrValue;
    }
    
    dr = DRM_SUCCESS;

ErrorExit:

    return dr;
}

/*
***********************************************************************
** API methods
***********************************************************************
*/

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XML_GetNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,            /* nth occurence of the node in the xml stirng, start from 0 */
    OUT DRM_CONST_STRING       *f_pdstrNode,       /* either of these 2 parameter can be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrNodeData)   /* data enclosed by the immediate <tag>...</tag> in the given XML string */
{
    return DRM_XML_GetSubNode(f_pdstrXML,
                              f_pdstrTag,
                              f_pdstrAttrName,
                              f_pdstrAttrValue,
                              f_iNode,
                              f_pdstrNode,
                              f_pdstrNodeData,
                              0);    
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XML_GetNodeA(
    __in_ecount( f_pdasstrXML->m_ich + f_pdasstrXML->m_cch ) const DRM_CHAR *f_pszBase,
    IN  const DRM_SUBSTRING         *f_pdasstrXML,
    IN  const DRM_ANSI_CONST_STRING *f_pdastrTag,
    IN  const DRM_ANSI_CONST_STRING *f_pdastrAttrName,
    IN  const DRM_ANSI_CONST_STRING *f_pdasstrAttrValue,
    IN  const DRM_DWORD              f_iNode,              /* nth occurence of the node in the xml stirng, start from 0 */
    OUT DRM_SUBSTRING               *f_pdasstrXmlNode,     /* either of these 2 parameter can be NULL but not both */
    OUT DRM_SUBSTRING               *f_pdasstrXmlNodeData) /* data enclosed by the immediate <tag>...</tag> in the given XML string */
{
    return DRM_XML_GetSubNodeA(f_pszBase,
                               f_pdasstrXML,
                               f_pdastrTag,
                               f_pdastrAttrName,
                               f_pdasstrAttrValue,
                               f_iNode,
                               f_pdasstrXmlNode, 
                               f_pdasstrXmlNodeData,
                               0);
}
    
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XML_GetSubNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,          /* nth occurence of the node in the xml stirng, start from 0 */
    OUT DRM_CONST_STRING       *f_pdstrNode,     /* these two parameters can either be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrNodeData,
    IN  DRM_DWORD               f_iLayer)      /* outermost layer is 0 */
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDRMString( f_pdstrXML );
    ChkDRMString( f_pdstrTag );
        
    ChkArg( f_pdstrNode     != NULL 
         || f_pdstrNodeData != NULL );

    ChkDR(_GetXMLSubNodeW(f_pdstrXML, 
                          f_pdstrTag, 
                          f_pdstrAttrName, 
                          f_pdstrAttrValue, 
                          f_iNode,
                          f_pdstrNode, 
                          f_pdstrNodeData, 
                          f_iLayer));

ErrorExit:

    return _TranslateXMLError(dr);
}



DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XML_GetSubNodeA(
    __in_ecount( f_pdasstrXML->m_ich + f_pdasstrXML->m_cch ) const DRM_CHAR *f_pszBase,
    IN  const DRM_SUBSTRING         *f_pdasstrXML,
    IN  const DRM_ANSI_CONST_STRING *f_pdastrTag,
    IN  const DRM_ANSI_CONST_STRING *f_pdastrAttrName,
    IN  const DRM_ANSI_CONST_STRING *f_pdasstrAttrValue,
    IN  const DRM_DWORD              f_iNode,           /* nth occurence of the node in the xml stirng, start from 0 */
    OUT DRM_SUBSTRING               *f_pdasstrNode,     /* these two parameters can either be NULL but not both */
    OUT DRM_SUBSTRING               *f_pdasstrNodeData,
    IN  DRM_DWORD                    f_iLayer )       /* outermost layer is 0 */
{
    DRM_RESULT    dr        = DRM_SUCCESS;
    DRM_SUBSTRING dasstrTag = EMPTY_DRM_SUBSTRING;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_DRMXMLPARSER, PERF_FUNC_DRM_XML_GetSubNodeA);

    ChkArg( f_pszBase != NULL );
    ChkArg( f_pdasstrXML != NULL );
    ChkDRMANSIString( f_pdastrTag );
    ChkArg( f_pdasstrNode != NULL || f_pdasstrNodeData != NULL );

    dasstrTag.m_cch = f_pdastrTag->cchString;

    ChkDR( _GetXMLSubNodeA( f_pszBase,
                            f_pdasstrXML,
                            f_pdastrTag->pszString,
                            &dasstrTag,
                            f_pdastrAttrName,
                            f_pdasstrAttrValue,
                            f_iNode,
                            f_pdasstrNode,     /* these two parameters can either be NULL but not both */
                            f_pdasstrNodeData,
                            f_iLayer,
                            FALSE ) );

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
} /* DRM_XML_GetSubNodeA */


/**********************************************************************
** Function  :    DRM_XML_GetNodeAttribute
**
** Synopsis  :    
**                
**
**
** Arguments :   
**    [f_pdstrNode]       : the topmost node in this XML string will be worked on
**    [f_pdstrAttrName]   : attribute name to retrieve
**    [f_pdstrAttrValue]  : returned attrValue
**
** Returns   : DRM_RESULT
************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XML_GetNodeAttribute(
    IN const DRM_CONST_STRING *f_pdstrNode,    
    IN const DRM_CONST_STRING *f_pdstrAttrName,
    OUT      DRM_CONST_STRING *f_pdstrAttrValue )
{
    DRM_RESULT dr     = DRM_E_INVALIDXMLTAG;
    _XMLTAGW   xmltag = { eTagNone, 0 };
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLPARSER, PERF_FUNC_DRM_XML_GetNodeAttribute );

    ChkDRMString( f_pdstrNode );
    ChkDRMString( f_pdstrAttrName );
    ChkArg( f_pdstrAttrValue != NULL );

    if ( _ScanNodeForAttributeW( f_pdstrNode, f_pdstrAttrName, &xmltag ) )
    {
        f_pdstrAttrValue->pwszString = f_pdstrNode->pwszString + xmltag.m_dasstrAttrValue.m_ich;
        f_pdstrAttrValue->cchString  = xmltag.m_dasstrAttrValue.m_cch;

        dr = DRM_SUCCESS;
    }
    else
    {
        goto ErrorExit;
    }
    
ErrorExit:    
    DRM_PROFILING_LEAVE_SCOPE;    

    return _TranslateXMLError( dr );
}


/**********************************************************************
** Function:    DRM_XML_GetNodeAttributeA
** Synopsis:    
** Arguments:   [pdwStamp] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XML_GetNodeAttributeA(
    __in_ecount( f_pdasstrNode->m_ich + f_pdasstrNode->m_cch ) const DRM_CHAR *f_pszBase,
    IN const DRM_SUBSTRING         *f_pdasstrNode,
    IN const DRM_ANSI_CONST_STRING *f_pdastrAttrName,  /* attrName to retrieve */
       OUT   DRM_SUBSTRING         *f_pdasstrAttrValue) /* returned attrValue */
{
    DRM_RESULT dr = DRM_E_INVALIDXMLTAG;
    _XMLTAGA   xmltag = { eTagNone, 0 };

    ChkArg(f_pszBase          != NULL);
    ChkArg(f_pdasstrAttrValue != NULL);

    ChkArg(f_pdasstrNode       != NULL
        && f_pdasstrNode->m_cch > 0);
        
    ChkArg(f_pdastrAttrName            != NULL
        && f_pdastrAttrName->pszString != NULL
        && f_pdastrAttrName->cchString  > 0);
        
    if (_ScanNodeForAttributeA(f_pszBase, f_pdasstrNode, f_pdastrAttrName, &xmltag))
    {
        f_pdasstrAttrValue->m_cch = xmltag.m_dasstrAttrValue.m_cch;
        f_pdasstrAttrValue->m_ich = xmltag.m_dasstrAttrValue.m_ich;

        dr = DRM_SUCCESS;
    }
    
ErrorExit:

    return _TranslateXMLError(dr);
}


/**********************************************************************
** Function:    DRM_XML_GetNodeCDataA
**
** Synopsis:    API for retrieving CDATA data from XML tag.
**
** Arguments:
**    [f_pszXMLBase]   : string with XML data
**    [f_pdasstrXML]   : points to XML node with CDATA, 
**                       cannot be NULL, nor point to zero-length substring
**    [f_pdasstrCData] : returned CDATA string, must not be NULL. 
**
** Returns             : DRM_RESULT
**
***********************************************************************
*/
DRM_API DRM_RESULT DRM_CALL DRM_XML_GetNodeCDataA(
    __in_ecount( f_pdasstrXML->m_ich + f_pdasstrXML->m_cch ) const DRM_CHAR *f_pszXMLBase,
    IN  const DRM_SUBSTRING *f_pdasstrXML,
    OUT       DRM_SUBSTRING *f_pdasstrCData )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pszXMLBase != NULL );
    ChkArg( f_pdasstrXML != NULL );
    ChkArg( f_pdasstrXML->m_cch > 0 );
    ChkArg( f_pdasstrCData != NULL );

    ChkDR( _GetXMLNodeCDataA( f_pszXMLBase, 
                              f_pdasstrXML, 
                              f_pdasstrCData ) );

ErrorExit:
    return _TranslateXMLError( dr );
}


/**********************************************************************
** Function:    DRM_XML_GetNodeCData
** Synopsis:    
** Arguments:   [f_pdstrNode] -- 
**              [f_pdstrCData] --
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XML_GetNodeCData(
    IN const DRM_CONST_STRING *f_pdstrNode,
    OUT      DRM_CONST_STRING *f_pdstrCData )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDRMString( f_pdstrNode );
    ChkArg( f_pdstrCData != NULL );

    ChkDR( _GetXMLNodeCDataW( f_pdstrNode, f_pdstrCData ) );

ErrorExit:

    return _TranslateXMLError( dr );
}




/*******************************************************************************************
** Function  :    DRM_XML_GetSubNodeByPath
**
** Synopsis  :    Retrieves a node in XML string
**                given a "path" to a node down the XML hierarchy levels 
**                that is the node's name with its parents' names.
**                Path looks like "node1/node2/.../nodeN", 
**                and character separator can be any DRM_WCHAR
**
** Arguments :   
**   [f_pdstrXML]         : XML string data
**   [f_pdstrXMLNode]     : Path to a node with its parents' names
**   [f_pdstrAttrName]    : Attribute name of the last XML node in the path, may be NULL
**   [f_pdstrAttrValue]   : Attribute value of the last XML node in the path, may be NULL
**   [f_pdstrXMLNodeOut]  : Output XML node, may be NULL
**   [f_pdstrXMLDataOut]  : Output XML node's data under found XML tag, may be NULL
**   [f_chSeparator]      : Character that separates nodes' names in the path
**
** Returns   : DRM_RESULT
*******************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XML_GetSubNodeByPath(
    IN const DRM_CONST_STRING *f_pdstrXML, 
    IN const DRM_CONST_STRING *f_pdstrXMLNode, 
    IN const DRM_CONST_STRING *f_pdstrAttrName, 
    IN const DRM_CONST_STRING *f_pdstrAttrValue,
    OUT      DRM_CONST_STRING *f_pdstrXMLNodeOut, 
    OUT      DRM_CONST_STRING *f_pdstrXMLDataOut,
    IN       DRM_WCHAR        f_chSeparator )
{
    DRM_RESULT       dr           = DRM_E_LOGICERR;
    const DRM_WCHAR* pch          = NULL;
    DRM_DWORD        cch          = 0;
    DRM_CONST_STRING dstrXml      = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrNode     = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrNodeName = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_DRMXMLPARSER, PERF_FUNC_DRM_XML_GetSubNodeByPath );

    ChkDRMString( f_pdstrXML );
    ChkDRMString( f_pdstrXMLNode );

    ASSIGN_DRM_STRING( dstrXml, *f_pdstrXML );
    while( cch < f_pdstrXMLNode->cchString )
    {
        /*
        ** Find separator
        */
        pch = f_pdstrXMLNode->pwszString + cch;
        while( f_pdstrXMLNode->pwszString [cch] != f_chSeparator 
            &&  cch  < f_pdstrXMLNode->cchString )
        {
            cch++;
        }

        dstrNodeName.pwszString = pch;
        dstrNodeName.cchString  = cch - ( (DRM_DWORD)( pch - f_pdstrXMLNode->pwszString ) );

        if ( *( f_pdstrXMLNode->pwszString + cch ) != f_chSeparator )
        {   
            /* 
            ** We are on the last segment.
            */
            if ( DRM_UTL_DSTRStringsEqual( &g_dstrTagCDATA, &dstrNodeName ) )
            {   
                /* 
                ** Requesting the CDATA section.  Ask for that. 
                */
                ChkDR( DRM_XML_GetNodeCData( &dstrXml, f_pdstrXMLDataOut ) );
            }
            else
            {   
                /* 
                ** Just get the node and use the attributes parameters
                */
                ChkDR( DRM_XML_GetSubNode( &dstrXml, 
                                           &dstrNodeName, 
                                           f_pdstrAttrName, 
                                           f_pdstrAttrValue, 
                                           0, 
                                           &dstrNode, 
                                           f_pdstrXMLDataOut, 
                                           1 ) );
            }
        }
        else
        {   
            ChkDR( DRM_XML_GetSubNode( &dstrXml, 
                                       &dstrNodeName, 
                                       NULL, 
                                       NULL, 
                                       0, 
                                       &dstrNode, 
                                       f_pdstrXMLDataOut, 
                                       1 ) );
        }

        ASSIGN_DRM_STRING( dstrXml, dstrNode );
        cch++;    
    }
    if ( f_pdstrXMLNodeOut != NULL )
    {
        ASSIGN_DRM_STRING( *f_pdstrXMLNodeOut, dstrXml );
    }

ErrorExit:
    DRMASSERT( dr != DRM_E_LOGICERR );

    DRM_PROFILING_LEAVE_SCOPE;

    return _TranslateXMLError( dr );
}


/***********************************************************************************************************************
** Function  :    DRM_XML_GetSubNodeByPathA
**
** Synopsis  :    Function retrieves a node in XML string given a "path inside XML tree" 
**                from the current position to the node, 
**                that is the node's name with its parent nodes' names
**                starting from the node's name which is a child to the current one.
**                Path string looks like: "node1/node2/node3/node4".
**
** Arguments :   
**    [f_pdstrXML]         : XML string data
**    [f_pdstrXMLNode]     : Path to a node with its parents' names
**    [f_pdstrAttrName]    : Attribute name of the last XML node in the path, may be NULL
**    [f_pdstrAttrValue]   : Attribute value of the last XML node in the path, may be NULL.
**                           These two arguments are needed if on the same level
**                           there are a few nodes with the same name.
**    [f_pdstrXMLNodeOut]  : Pointer to output XML node string, may be NULL.
**    [f_pdstrXMLDataOut]  : Pointer to output XML node's data, may be NULL.
**    [chSeparator]        : Character that separates nodes' names in the path string.
**
** Returns   : DRM_RESULT
***********************************************************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XML_GetSubNodeByPathA(
    __in_ecount( f_pdasstrXML->m_ich + f_pdasstrXML->m_cch ) const DRM_CHAR *f_pszBase,
    IN const DRM_SUBSTRING         *f_pdasstrXML,
    IN const DRM_ANSI_CONST_STRING *f_pdastrNodePath,
    IN const DRM_ANSI_CONST_STRING *f_pdastrAttrName,
    IN const DRM_ANSI_CONST_STRING *f_pdastrAttrValue,
    OUT      DRM_SUBSTRING         *f_pdasstrXMLNodeOut,
    OUT      DRM_SUBSTRING         *f_pdasstrXMLDataOut,
    IN       DRM_CHAR              chSeparator )
{
    DRM_RESULT    dr                 = DRM_E_LOGICERR;
    DRM_DWORD     ichCurrNodeBegin   = 0;                 /* start of current node name */
    DRM_DWORD     ichCurr            = 0;
    DRM_SUBSTRING dasstrCurrNodeName = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrXml          = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrNode         = EMPTY_DRM_SUBSTRING;

    ChkArg( f_pszBase != NULL );
    ChkArg( f_pdasstrXML != NULL );
    ChkArg( f_pdasstrXML->m_cch > 0 );
    ChkDRMANSIString( f_pdastrNodePath );

    dasstrXml.m_ich = f_pdasstrXML->m_ich;
    dasstrXml.m_cch = f_pdasstrXML->m_cch;
    
    while( ichCurr < f_pdastrNodePath->cchString )
    {
        /*
        ** Find separator or the end of path string
        */
        while( GET_CHAR( f_pdastrNodePath->pszString, ichCurr ) != chSeparator
            &&  ichCurr < f_pdastrNodePath->cchString )        
        {
            ichCurr++;
        }
        dasstrCurrNodeName.m_ich = ichCurrNodeBegin;
        dasstrCurrNodeName.m_cch = ichCurr - ichCurrNodeBegin;

        if ( ichCurr >= f_pdastrNodePath->cchString  )
        {   
            /* 
            ** Did not find more separators, we are on the last segment.
            */
            if ( DRM_UTL_DASSTRStringsEqual( f_pdastrNodePath->pszString, 
                                             &dasstrCurrNodeName, 
                                             &g_dastrTagCDATA ) )
            {   
                /* 
                ** Requesting the CDATA section. Ask for that.
                */
                ChkDR( _GetXMLNodeCDataA( f_pszBase,
                                          &dasstrXml, 
                                          f_pdasstrXMLDataOut ) );
            }
            else
            {   
                /* 
                ** Just get the node and use the attributes parameters
                */
                ChkDR( _GetXMLSubNodeA( f_pszBase,
                                        &dasstrXml,
                                        f_pdastrNodePath->pszString,
                                        &dasstrCurrNodeName,
                                        f_pdastrAttrName, 
                                        f_pdastrAttrValue, 
                                        0, 
                                        &dasstrNode, 
                                        f_pdasstrXMLDataOut, 
                                        1,
                                        FALSE ) );
            }
        }
        else
        {   
#if DBG
                ChkDR( _GetXMLSubNodeA( f_pszBase,
                                        &dasstrXml,
                                        f_pdastrNodePath->pszString,
                                        &dasstrCurrNodeName,
                                        NULL, 
                                        NULL, 
                                        0, 
                                        &dasstrNode, 
                                        f_pdasstrXMLDataOut, 
                                        1,
                                        FALSE ) );
#else
            /*
            **  Use optimized version - no need to check end tag,
            **  just set to the end of the whole XML data string.
            */
                ChkDR( _GetXMLSubNodeA( f_pszBase,
                                        &dasstrXml,
                                        f_pdastrNodePath->pszString,
                                        &dasstrCurrNodeName,
                                        NULL, 
                                        NULL, 
                                        0, 
                                        &dasstrNode, 
                                        f_pdasstrXMLDataOut, 
                                        1,
                                        TRUE ) );
#endif            
        }

        /*
        ** down the next level in XML data string
        */
        dasstrXml.m_ich = dasstrNode.m_ich;
        dasstrXml.m_cch = dasstrNode.m_cch;

        /*
        ** look for the next node name in a node path string
        */
        ichCurrNodeBegin = dasstrCurrNodeName.m_ich + dasstrCurrNodeName.m_cch + 1;
        ichCurr = ichCurrNodeBegin;
    }
    if( f_pdasstrXMLNodeOut != NULL )
    {
        f_pdasstrXMLNodeOut->m_ich = dasstrXml.m_ich;
        f_pdasstrXMLNodeOut->m_cch = dasstrXml.m_cch;
    }

ErrorExit:
    DRMASSERT( dr != DRM_E_LOGICERR );

    return _TranslateXMLError( dr );
}


/***********************************************************************************************
**
** Function:    DRM_XML_EnumNextNode
** Synopsis:    Enumerate the next node from the given xml string,
**              optionally with a specified tag name.
**
** Arguments :   
**    [f_pdstrXML]          : pointer to XML data string.
**    [f_pdstrTag]          : pointer to XML tag name, cannot be NULL, may be empty string.
**    [f_pdstrNode]         : pointer to XML node under found XML tag,
**                            either f_pdstrNodeOut or f_pdstrNodeDataOut 
**                            can be NULL but not both.
**    [f_pdstrNodeData]     : pointer to XML node's data under found XML tag
**                            that is text between <tag>...</tag>
**    [f_pdstr1stAttrName]  : pointer to XML tag's attribute name, may be NULL
**    [f_pdstr1stAttrValue] : pointer to XML tag's attribute value, may be NULL
**    [f_pfIsLeaf]          : will be set to TRUE of the returned node is a leaf node
**
**  Returns:     DRM_RESULT
**
***********************************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XML_EnumNextNode(
    IN const DRM_CONST_STRING *f_pdstrXML,
       IN    DRM_CONST_STRING *f_pdstrTag,
       OUT   DRM_CONST_STRING *f_pdstrNode,
       OUT   DRM_CONST_STRING *f_pdstrNodeData,
       OUT   DRM_CONST_STRING *f_pdstr1stAttrName,
       OUT   DRM_CONST_STRING *f_pdstr1stAttrValue,
       OUT   DRM_BOOL         *f_pfIsLeaf )
{
    return DRM_XML_EnumNextSubNode(
                f_pdstrXML,
                f_pdstrTag,
                f_pdstrNode,
                f_pdstrNodeData,
                f_pdstr1stAttrName,
                f_pdstr1stAttrValue,
                f_pfIsLeaf,
                0);    
}


/***********************************************************************************************
** Function:    DRM_XML_EnumNextSubNode
** Synopsis:    Enumerate the next subnode from the given xml string,
**              optionaly, from nth layer, and with a specified tag name 
**
** Arguments :   
**    [f_pdstrXML]          : pointer to XML data string
**    [f_pdstrTag]          : pointer to XML tag name, cannot be NULL, may be empty string.
**    [f_pdstrNode]         : pointer to XML node under found XML tag,
**                            either f_pdstrNodeOut or f_pdstrNodeDataOut 
**                            can be NULL but not both.
**    [f_pdstrNodeData]     : pointer to XML node's data under found XML tag
**    [f_pdstr1stAttrName]  : pointer to XML tag's attribute name, may be NULL
**    [f_pdstr1stAttrValue] : pointer to XML tag's attribute value, may be NULL
**    [f_pfIsLeaf]          : will be set to TRUE of the returned node is a leaf node
**    [f_nAtNthLayer]       : number of XML hierarchy levels to skip down,
**                            outermost layer is 0
**
**  Returns:     DRM_RESULT
***********************************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XML_EnumNextSubNode(
    IN const DRM_CONST_STRING *f_pdstrXML,
       IN    DRM_CONST_STRING *f_pdstrTag,
       OUT   DRM_CONST_STRING *f_pdstrNode,
       OUT   DRM_CONST_STRING *f_pdstrNodeData,
       OUT   DRM_CONST_STRING *f_pdstr1stAttrName,
       OUT   DRM_CONST_STRING *f_pdstr1stAttrValue,
       OUT   DRM_BOOL         *f_pfIsLeaf,
    IN       DRM_DWORD        f_nAtNthLayer )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDRMString( f_pdstrXML );
    ChkArg( f_pdstrTag != NULL );
        
    ChkArg( f_pdstrNode != NULL 
        || f_pdstrNodeData != NULL );

    ChkDR( _EnumXMLSubNodeW( f_pdstrXML, 
                             f_pdstrTag, 
                             f_pdstrNode, 
                             f_pdstrNodeData, 
                             f_pdstr1stAttrName,
                             f_pdstr1stAttrValue,
                             f_pfIsLeaf, 
                             f_nAtNthLayer ) );

ErrorExit:
    return _TranslateXMLError(dr);
}


/* Ensure that the XML is valid */
DRM_API DRM_BOOL DRM_CALL DRM_XML_Validate( IN const DRM_CONST_STRING *f_pdstrXML )
{
    DRM_RESULT       dr      = DRM_SUCCESS;
    DRM_DWORD        ich     = 0;
    _XMLTAGW         xmltag  = { eTagNone, 0 };
    DRM_CONST_STRING dstrTag = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrNode= EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrData= EMPTY_DRM_STRING;

    /* Note that all error codes are meaningless in the end.  Only a 
       true of false is returned */
    DRMASSERT( f_pdstrXML             != NULL 
            && f_pdstrXML->pwszString != NULL
            && f_pdstrXML->cchString   > 0 );
    
    ChkDRMString( f_pdstrXML );

    /* ScanTag will skip all the xml preamble stuff and give me the
       first real XML tag */
    if( !_ScanTagW( f_pdstrXML, &ich, &xmltag )
     ||  xmltag.m_eTagType != eOpenTag )
    {
        ChkDR( DRM_E_INVALIDXMLTAG );
    }

    /* The first tag has been found. */
    dstrTag.cchString  = xmltag.m_dasstrTag.m_cch;
    dstrTag.pwszString = xmltag.m_pwszBase 
                       + xmltag.m_dasstrTag.m_ich;

    /* Now do an XML GetNode to parse to the end of 
       this tag and ensure it's valid. */
    
    ChkDR( _GetXMLSubNodeW( f_pdstrXML,
                           &dstrTag,
                            NULL,
                            NULL,
                            0,
                           &dstrNode,
                           &dstrData,
                            0 ) );

ErrorExit:
    return DRM_SUCCEEDED( dr );
}

/**********************************************************************
** Function:    DRM_XML_EnumNextNode
** Synopsis:    Enumerate the next node from the given xml string
** Arguments:   [f_pdstrXML] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XML_EnumNextNodeA(
    __in_ecount( f_pdasstrXML->m_ich + f_pdasstrXML->m_cch ) const DRM_CHAR *f_pszBase,
    IN const DRM_SUBSTRING    *f_pdasstrXML,
    IN const DRM_DWORD         f_iNode,
       OUT   DRM_SUBSTRING    *f_pdasstrTag,
       OUT   DRM_SUBSTRING    *f_pdasstrNode,         /* either of these 2 parameter can be NULL but not both */
       OUT   DRM_SUBSTRING    *f_pdasstrNodeData,     /* data enclosed by the immediate <tag>...</tag> in the given XML string */
       OUT   DRM_SUBSTRING    *f_pdasstr1stAttrName,  /* optional */
       OUT   DRM_SUBSTRING    *f_pdasstr1stAttrValue)            /* set to TRUE of the returned node is a leaf node */
{
    DRM_RESULT    dr = DRM_E_NOXMLOPENTAG;
    DRM_DWORD     cRecursionDepth= 0;
    DRM_DWORD     cTagsMatched   = 0; 
    DRM_DWORD     ichNodeBegin   = 0; 
    DRM_DWORD     ichDataBegin   = 0; 
    DRM_DWORD     ichNodeEnd     = 0; 
    DRM_DWORD     ichDataEnd     = 0; 
    DRM_DWORD     iNode          = 0;
    DRM_DWORD     ichCurr        = f_pdasstrXML->m_ich;
    _XMLTAGA      xmltag         = { eTagNone, 0 };    
    DRM_SUBSTRING dasstr1stAttrName  = { 0 };
    DRM_SUBSTRING dasstr1stAttrValue = { 0 };

    ChkArg(f_pszBase    != NULL
        && f_pdasstrXML != NULL
        && f_pdasstrTag != NULL);
        
    ChkArg(f_pdasstrNode     != NULL 
        || f_pdasstrNodeData != NULL);

    for( ; ; )
    {
        /* scan for tag at currIndex */
        if (! _ScanTagA(f_pszBase, f_pdasstrXML, &ichCurr, &xmltag))
        {
            if (cTagsMatched == 0)
            {
                ChkDR(DRM_E_NOXMLOPENTAG);
            }
            else
            {
                ChkDR(DRM_E_NOXMLCLOSETAG);
            }
        }

        switch (xmltag.m_eTagType)
        {
            case eOpenTag:
                if (cRecursionDepth == 0
                &&  ++iNode         == (f_iNode + 1)) 
                {
                    ichNodeBegin = xmltag.m_ichTagBegin;
                    ichDataBegin = xmltag.m_ichTagEnd + 1;

                    /* assign the tag name so that we know what to look for closing tag */

                    f_pdasstrTag->m_cch = xmltag.m_dasstrTag.m_cch;
                    f_pdasstrTag->m_ich = xmltag.m_dasstrTag.m_ich;

                    /* save the attr name/value */
                    dasstr1stAttrName.m_cch  = xmltag.m_dasstrAttrName.m_cch;
                    dasstr1stAttrName.m_ich  = xmltag.m_dasstrAttrName.m_ich;
                    dasstr1stAttrValue.m_cch = xmltag.m_dasstrAttrValue.m_cch;
                    dasstr1stAttrValue.m_ich = xmltag.m_dasstrAttrValue.m_ich;
                }
                else
                {
                    cRecursionDepth++;
                }
                cTagsMatched++;
                break;
                
            case eCloseTag:    /* close tag found */
                if (cTagsMatched == 0)
                {
                    /* we get </tag> before we get <tag> */
                    ChkDR(DRM_E_NOXMLOPENTAG);
                }

                cTagsMatched--;

                if (cTagsMatched    == 0
                &&  cRecursionDepth == 0)
                {
                    /* we've got the matching <tag> and </tag>, 
                    ** exit the loop if this is the node we want
                    */
                    ichNodeEnd   = xmltag.m_ichTagEnd;
                    ichDataEnd   = xmltag.m_ichTagBegin - 1;
                    goto PREPARENODE;
                }
                else
                {
                    cRecursionDepth--;
                }
                break;

            default:
                break;
        }
    }

PREPARENODE:
    /* prepare f_pdasstrNode & f_pdasstrNodeData */
    if (f_pdasstrNode != NULL)
    {
        f_pdasstrNode->m_ich = ichNodeBegin;
        f_pdasstrNode->m_cch = (DRM_DWORD) (ichNodeEnd - ichNodeBegin + 1);
    }

    if (f_pdasstrNodeData != NULL)
    {
        if (xmltag.m_eTagType == eEmptyTag)
        {
            f_pdasstrNodeData->m_ich = 0;
            f_pdasstrNodeData->m_cch = 0;
        }
        else
        {
            f_pdasstrNodeData->m_ich = ichDataBegin;
            f_pdasstrNodeData->m_cch = (DRM_DWORD) (ichDataEnd - ichDataBegin + 1);

            if (! _AllTrimA(f_pszBase, f_pdasstrNodeData))
            {
                f_pdasstrNodeData->m_cch = 0;
            }
        }
    }

    if (f_pdasstr1stAttrName != NULL)
    {
        *f_pdasstr1stAttrName = dasstr1stAttrName;
    }

    if (f_pdasstr1stAttrValue != NULL)
    {
        *f_pdasstr1stAttrValue = dasstr1stAttrValue;
    }
    
    dr = DRM_SUCCESS;

ErrorExit:

    return _TranslateXMLError(dr);
} /* DRM_XML_EnumNextNode */

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XML_CountMatchingNodesA(
    __in_ecount( f_pdasstrXML->m_ich + f_pdasstrXML->m_cch ) const DRM_CHAR *f_pszBase,
    IN const DRM_SUBSTRING         *f_pdasstrXML,
    IN const DRM_ANSI_CONST_STRING *f_pdastrTag,          /* optional */
    IN       DRM_ANSI_CONST_STRING *f_pdastr1stAttrName,  /* optional */
    IN       DRM_ANSI_CONST_STRING *f_pdastr1stAttrValue, /* optional */
       OUT   DRM_DWORD             *f_cMatchingNodes)
{
    DRM_RESULT    dr    = DRM_SUCCESS;
    DRM_DWORD     iNode = 0;
    DRM_SUBSTRING dasstrTag          = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrDummy        = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstr1stAttrLabel = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstr1stAttrValue = EMPTY_DRM_SUBSTRING;

    ChkArg(f_pszBase        != NULL
        && f_pdasstrXML     != NULL
        && f_cMatchingNodes != NULL);

    *f_cMatchingNodes = 0;

    for( ; ; )
    {
        dr = DRM_XML_EnumNextNodeA(f_pszBase,
                                   f_pdasstrXML,
                                   iNode++,
                                  &dasstrTag,
                                  &dasstrDummy,
                                   NULL,
                                  &dasstr1stAttrLabel,
                                  &dasstr1stAttrValue);

        if (dr == DRM_E_XMLNOTFOUND)                                                   
        {
            dr = DRM_SUCCESS;
            break;
        }
        else
        {
            ChkDR(dr);
            
            if ((f_pdastrTag          == NULL || DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrTag,          f_pdastrTag))
            &&  (f_pdastr1stAttrName  == NULL || DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstr1stAttrLabel, f_pdastr1stAttrName))
            &&  (f_pdastr1stAttrValue == NULL || DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstr1stAttrValue, f_pdastr1stAttrValue)))
            {
                (*f_cMatchingNodes)++;
            }              
        }
    }
    
ErrorExit:

    return dr;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmxmlsig.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmtypes.h>
#include <drmutilities.h>
#include <drmxmlparser.h>
#include <drmcrt.h>
#include <drmeccp256.h>
#include <drmaescommon.h>
#include <drmxmlsigconstants.h>
#include <drmxmlsig.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

/*********************************************************************
**
** Function: _CalcSHA256Hash
**
** Synopsis: Function that generates a SHA-256 hash of the passed in data.
**
** Arguments:
**
** [f_pdastrData]           -- Pointer to a DRM ANSI string for which a
**                             SHA-256 hash is generated.
** [f_rgbHash]              -- Pointer to a buffer that receives a generated
**                             SHA-256 hash.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _CalcSHA256Hash(
    __in                                const DRM_ANSI_CONST_STRING *f_pdastrData,
    __out_bcount(SHA256_DIGEST_SIZE_IN_BYTES) DRM_BYTE               f_rgbHash[ __CB_DECL( SHA256_DIGEST_SIZE_IN_BYTES ) ] )
{
    DRM_RESULT  dr = DRM_SUCCESS;
    DRM_SHA_CONTEXT oSHAContext = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_XMLSIG, PERF_FUNC__CalcSHA256Hash );

    ChkDRMANSIString( f_pdastrData );
    ChkArg( f_rgbHash != NULL );

    /* Generate a SHA-1 hash of the passed in data. */
    ChkDR( DRM_SHA_Init( &oSHAContext, eDRM_SHA_256 ) );

    ChkDR( DRM_SHA_Update( PB_DASTR( f_pdastrData ),
                           CB_DASTR( f_pdastrData ),
                           &oSHAContext ) );

    ChkDR( DRM_SHA_Finalize( &oSHAContext,
                             SHA256_DIGEST_SIZE_IN_BYTES,
                             f_rgbHash ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _VerifySHA256Hash
**
** Synopsis: Function that verifies a SHA-256 hash of the passed in
**           data.
**
** Arguments:
**
** [f_pszBase]              -- base string, all substrings
**                             are operating on it.
** [f_pdasstrData]          -- Pointer to substring with data against
**                             which a SHA-256 hash is verified.
** [f_rgbHash]              -- Pointer to a buffer that contains a SHA-256
**                             hash to be verified.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _VerifySHA256Hash(
    __in_ecount(f_pdasstrData->m_ich+f_pdasstrData->m_cch)
                                             const DRM_CHAR      *f_pszBase,
    __in                                     const DRM_SUBSTRING *f_pdasstrData,
    __in_bcount(SHA256_DIGEST_SIZE_IN_BYTES) const DRM_BYTE       f_rgbHash[ __CB_DECL( SHA256_DIGEST_SIZE_IN_BYTES ) ] )
{
    DRM_RESULT  dr = DRM_SUCCESS;
    DRM_SHA_CONTEXT oSHAContext = { 0 };
    DRM_BYTE rgbCalculatedHash[ __CB_DECL( SHA256_DIGEST_SIZE_IN_BYTES ) ] = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_XMLSIG, PERF_FUNC__VerifySHA256Hash );

    ChkArg( f_pszBase != NULL );
    ChkArg( f_pdasstrData != NULL );
    ChkArg( f_pdasstrData->m_cch > 0 );
    ChkArg( f_rgbHash != NULL );

    ChkDR( DRM_SHA_Init( &oSHAContext, eDRM_SHA_256 ) );

    ChkDR( DRM_SHA_Update( ( DRM_BYTE * )( f_pszBase + __CB_DECL( f_pdasstrData->m_ich ) ),
                           f_pdasstrData->m_cch,
                           &oSHAContext ) );

    ChkDR( DRM_SHA_Finalize( &oSHAContext,
                             SHA256_DIGEST_SIZE_IN_BYTES,
                             rgbCalculatedHash ) );

    if ( MEMCMP( rgbCalculatedHash, f_rgbHash, SHA256_DIGEST_SIZE_IN_BYTES ) != 0 )
    {
        ChkDR( DRM_E_XMLSIG_SHA_VERIFY_FAILURE );
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _GetCipherDataNodeCharCount
**
** Synopsis: Function that calculates the number of characters
**           in a <CipherData> XML node.
**
** Arguments:
** [f_cbData]               -- Number of bytes of data to be
**                             ciphered.
**
** Returns:                 A long integer value that is number of
**                          characters in a <CipherData> XML segment.
**
** Note:                    We allow cipher data of a zero length.
**
**********************************************************************/
static DRM_NO_INLINE DRM_DWORD DRM_CALL _GetCipherDataNodeCharCount(
    __in const DRM_DWORD f_cbData )
{
    DRM_DWORD cchSize = 0;

    /* <CipherData> */
    cchSize += DRM_XMB_RequiredCharsForTagA( g_dastrSigCipherDataTag.cchString,
                                             0,
                                             0,
                                             0 );

    /* <CipherValue> */
    cchSize += DRM_XMB_RequiredCharsForTagA( g_dastrSigCipherValueTag.cchString,
                                             0,
                                             0,
                                             0 );

    cchSize += CCH_BASE64_EQUIV( f_cbData );

    return cchSize;
}

/*********************************************************************
**
** Function: _BuildCipherDataNode
**
** Synopsis: Function that constructs a cipher data XML
**           segment of the passed in data.
**
**           The cipher data XML segment should have a root node
**           <CipherData>, and should have one subnode <CipherVaue>
**           under it. The <Cipher Value> node contains the passed in
**           data.
**
** Arguments:
**
** [f_poXMLContextA]        -- Pointer to a XML builder context, ANSI version.
** [f_pbData]               -- Pointer to data to be put in the
**                             <CipherValue> node. If this data is encrypted
**                             encryption should already be applied.
**                             If f_pbData is NULL, the function assumes
**                             the data to be B64 encoded is already
**                             stored at the right place in the buffer of the
**                             XML builder context.
** [f_cbData]               -- Size of the data to be B64 encoded.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _BuildCipherDataNode(
    __inout _XMBContextA                     *f_poXMLContextA,
    __in_bcount_opt(f_cbData) const DRM_BYTE *f_pbData,
    __in                      const DRM_DWORD f_cbData )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE *pbData = NULL;
    DRM_BYTE *pbDataIn = NULL;
    DRM_BYTE *pbDataOut = NULL;
    DRM_DWORD cchData = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_XMLSIG, PERF_FUNC__BuildCipherDataNode );

    ChkArg( f_poXMLContextA != NULL );
    ChkArg( f_cbData > 0 );

    /*
    ** Add and open <CipherData> node.
    **
    ** Output:
    ** <CipherData>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigCipherDataTag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

    /*
    ** Add and open <CipherValue> node.
    **
    ** Output:
    ** <CipherData>
    **      <CipherValue>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigCipherValueTag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

    {
        ChkDR( DRM_XMB_GetCurrentBufferPointerA( f_poXMLContextA,
                                                 FALSE,
                                                 ( DRM_CHAR ** )&pbData ) );

        DRMASSERT( pbData != NULL );

        if ( f_pbData == NULL )
        {
            /* B64 encoding in place. */
            pbDataIn = pbData;
            pbDataOut = pbData;
        }
        else
        {
            pbDataIn = (DRM_BYTE*) f_pbData;
            pbDataOut = pbData;
        }

        cchData = CCH_BASE64_EQUIV( f_cbData );

        ChkDR( DRM_B64_EncodeA( pbDataIn,
                                f_cbData,
                                ( DRM_CHAR * )pbDataOut,
                                &cchData,
                                0 ) );

        ChkDR( DRM_XMB_ShiftCurrentPointerA( f_poXMLContextA, cchData ) );
    }

    /*
    ** Close <CipherValue> node.
    **
    ** Output:
    ** <CipherData>
    **      <CipherValue>
    **      ...
    **      </CipherValue>
    ** </CipherData>
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContextA, NULL ) );

    /*
    ** Close <CipherData> node.
    **
    ** Output:
    ** <CipherData>
    ** ...
    ** </CipherData>
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContextA, NULL ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _ExtractCipherData
**
** Synopsis: Function that extracts a cipher data buffer contained in
**           a XML segment and applies B64 decoder.
**           This function does not decrypt cipher data.
**           The XML segment should be in the form of
**           <...>/<CipherData>/<CipherValue>, and the name of the root
**           node can be any string.
**
** Arguments:
**
** [f_pszBase]              -- base XML data string for f_pdasstrXML
**                             and other substrings.
** [f_pdasstrXML]           -- Pointer to a substring that contains a
**                             XML segment whose root node contains a
**                             <CipherData> subnode.
** [f_ppbCipherData]        -- Pointer to a pointer to a buffer that
**                             receives the B64 decoded cipher data
**                             contained in the XML segment.
** [f_pcbCipherData]        -- Pointer to a variable to receive the size
**                             (number of bytes) of the B64 decoded cipher
**                             data contained in the XML segment.
** [f_pdasstrCipherData]    -- Pointer to a variable to receive the a
**                             substring that cover the encoded cipher data.
**                             It is the caller's responsiblity to cover
**                             the the substring with space (' ') to
**                             ensure the whole XML string is still valid
**                             for future parsing.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT DRM_CALL _ExtractCipherData(
    __inout_ecount(f_pdasstrXML->m_ich+f_pdasstrXML->m_cch)
                    DRM_CHAR      *f_pszBase,
    __in      const DRM_SUBSTRING *f_pdasstrXML,
    __deref_out_bcount( *f_pcbCipherData )
                    DRM_BYTE     **f_ppbCipherData,
    __out           DRM_DWORD     *f_pcbCipherData,
    __out_opt       DRM_SUBSTRING *f_pdasstrCipherData )
{
    DRM_RESULT    dr               = DRM_SUCCESS;
    DRM_SUBSTRING dasstrCipherData = EMPTY_DRM_SUBSTRING;
    DRM_DWORD     cchExtra         = 0;
    DRM_BYTE     *pbCipherData     = NULL;
    DRM_DWORD     cbCipherData     = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_XMLSIG, PERF_FUNC__ExtractCipherData );

    ChkArg( f_pszBase != NULL );
    ChkArg( f_pdasstrXML != NULL );
    ChkArg( f_pdasstrXML->m_cch > 0 );
    ChkArg( f_ppbCipherData != NULL );
    ChkArg( f_pcbCipherData != NULL );

    /*
    ** Extract <CipherValue> node from the passed in root node.
    ** It contains the cipher data string.
    */
    ChkDR( DRM_XML_GetSubNodeByPathA( f_pszBase,
                                      f_pdasstrXML,
                                      &g_dastrSigCipherValuePath,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &dasstrCipherData,
                                      g_chForwardSlash ) );

    if ( f_pdasstrCipherData != NULL )
    {
        *f_pdasstrCipherData = dasstrCipherData;
    }

    cbCipherData = dasstrCipherData.m_cch;

    if ( cbCipherData > 0 )
    {
        ChkDR( DRM_B64_DecodeA( f_pszBase,
                                &dasstrCipherData,
                                &cbCipherData,
                                NULL,
                                DRM_BASE64_DECODE_IN_PLACE ) );

        /* Make sure that size of decoded buffer is in proper range and satisfy OACR */
        ChkBOOL( dasstrCipherData.m_ich + cbCipherData <= f_pdasstrXML->m_ich + f_pdasstrXML->m_cch, DRM_E_BUFFER_BOUNDS_EXCEEDED );

        if ( dasstrCipherData.m_ich % SIZEOF( DRM_DWORD ) != 0 )
        {
            /* If the encoded string is not beginning at an aligned address,
            ** shift it to make aligned.
            */
            cchExtra = SIZEOF( DRM_DWORD ) - ( dasstrCipherData.m_ich % SIZEOF( DRM_DWORD ) );

            /* *f_ppbCipherData will point to an aligned address. */
            pbCipherData = ( DRM_BYTE * )f_pszBase + __CB_DECL( dasstrCipherData.m_ich + cchExtra );

            /* validation of buffer size */
            ChkBOOL( f_pdasstrXML->m_ich+f_pdasstrXML->m_cch >= __CB_DECL( dasstrCipherData.m_ich + cchExtra ) + cbCipherData,
                     DRM_E_BUFFERTOOSMALL );
            DRM_BYT_MoveBytes( pbCipherData,
                               0,
                               ( DRM_BYTE * )f_pszBase,
                               dasstrCipherData.m_ich,
                               cbCipherData );
        }
        else
        {
            /* The encoded string is beginning at an aligned address. */
            pbCipherData = ( DRM_BYTE * )f_pszBase + __CB_DECL( dasstrCipherData.m_ich );
        }
    }
    else
    {
        /* If <CipherValue> does not have any content, something is wrong. */
        ChkDR( DRM_E_XMLSIG_FORMAT );
    }

    *f_ppbCipherData = pbCipherData;
    *f_pcbCipherData = cbCipherData;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/************************************************************************************
**
** Function: _GetSignedInfoNodeCharCount
**
** Synopsis: Function that calculates the number of characters in a <SignedInfo>
**           XML segment.
**
** Arguments:               N/A
**
** Returns:                 A long integer value that is number of characters in
**                          a <SignedInfo> XML segment.
**
************************************************************************************/
static DRM_NO_INLINE DRM_DWORD _GetSignedInfoNodeCharCount( DRM_VOID )
{
    DRM_DWORD cchSize = 0;

    /* <SignedInfo> */
    cchSize = DRM_XMB_RequiredCharsForTagA( g_dastrSigSignedInfoTag.cchString,
                                            0,
                                            g_dastrSigSignedInfoAttribName.cchString,
                                            g_dastrSigSignedInfoAttribValue.cchString );

    /* <CanonicalizationMethod> */
    cchSize += DRM_XMB_RequiredCharsForTagA( g_dastrSigCanonicalizationMethodTag.cchString,
                                             0,
                                             g_dastrSigCanonicalizationMethodAttribName.cchString,
                                             g_dastrSigCanonicalizationMethodAttribValue.cchString );

    /* <SignatureMethod> */
    cchSize += DRM_XMB_RequiredCharsForTagA( g_dastrSigSignatureMethodTag.cchString,
                                             0,
                                             g_dastrSigSignatureMethodAttribName.cchString,
                                             g_dastrSigSignatureMethodAttribValue.cchString );

    /* <Reference> */
    cchSize += DRM_XMB_RequiredCharsForTagA( g_dastrSigReferenceTag.cchString,
                                             0,
                                             g_dastrSigReferenceAttribName.cchString,
                                             g_dastrSigReferenceAttribValue.cchString );

    /* <DigestMethod> */
    cchSize += DRM_XMB_RequiredCharsForTagA( g_dastrSigDigestMethodTag.cchString,
                                             0,
                                             g_dastrSigDigestMethodAttribName.cchString,
                                             g_dastrSigDigestMethodAttribValue.cchString );

    /* Add the B64-ed size of SHA-256 hash. */
    cchSize += CCH_BASE64_EQUIV( SHA256_DIGEST_SIZE_IN_BYTES );

    /* <DigestValue> */
    cchSize += DRM_XMB_RequiredCharsForTagA( g_dastrSigDigestValueTag.cchString,
                                             0,
                                             g_dastrSigDigestMethodAttribName.cchString,
                                             g_dastrSigDigestMethodAttribValue.cchString );

    return cchSize;
}

/*********************************************************************
**
** Function: _BuildSignedInfoNode
**
** Synopsis: Function that constructs <SignedInfo> node.
**           This information will be used to calculate a signature value.
**
** Arguments:
**
** [f_poXMLContextA]        -- Pointer to a XML builder context, ANSI version.
** [f_poBBXContext]         -- Pointer to a DRM_BB_CONTEXT context.
** [f_pdastrData]           -- Pointer to a ANSI string with data
**                             to calculate SHA-256 digest.
** [f_dasstrSignedInfo]     -- Pointer to a substring with <SignedInfo> tag
**                             which is used in signature value calculation.
**                             Substring operates on XMLBuilder's buffer
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
*********************************************************************/
static DRM_NO_INLINE DRM_RESULT _BuildSignedInfoNode(
    __inout       _XMBContextA          *f_poXMLContextA,
    __in    const DRM_BB_CONTEXT        *f_poBBXContext,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrData,
    __out         DRM_SUBSTRING         *f_dasstrSignedInfo )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE rgbHash[ __CB_DECL( SHA256_DIGEST_SIZE_IN_BYTES ) ] = { 0 };
    DRM_CHAR rgchScratch[ CCH_BASE64_EQUIV( SHA256_DIGEST_SIZE_IN_BYTES ) ] = { 0 };
    DRM_DWORD cchScratch = 0;
    DRM_ANSI_STRING dastrScratch = {0};

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_XMLSIG, PERF_FUNC__BuildSignedInfoNode );

    ChkArg( f_poXMLContextA != NULL );
    ChkArg( f_poBBXContext != NULL );
    ChkDRMANSIString( f_pdastrData );

    ChkDR( _CalcSHA256Hash( f_pdastrData, rgbHash ) );

    DRMCASSERT( SIZEOF( rgchScratch ) >=
                CCH_BASE64_EQUIV( SHA256_DIGEST_SIZE_IN_BYTES ) * SIZEOF ( DRM_CHAR ) );

    /*
    ** Add and open <SignedInfo> node.
    **
    ** Output:
    **      <SignedInfo>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigSignedInfoTag,
                              NULL,
                              &g_dastrSigSignedInfoAttribName,
                              &g_dastrSigSignedInfoAttribValue,
                              wttOpen ) );

    /*
    ** Add and close <CanonicalizationMethod> node.
    **
    ** Output:
    **      <SignedInfo>
    **          <CanonicalizationMethod></CanonicalizationMethod>
    **
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigCanonicalizationMethodTag,
                              NULL,
                              &g_dastrSigCanonicalizationMethodAttribName,
                              &g_dastrSigCanonicalizationMethodAttribValue,
                              wttOpen ) );
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContextA, NULL ) );

    /*
    ** Add and close <SignatureMethod> node.
    **
    ** Output:
    **      <SignedInfo>
    **      ...
    **          <SignatureMethod></SignatureMethod>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigSignatureMethodTag,
                              NULL,
                              &g_dastrSigSignatureMethodAttribName,
                              &g_dastrSigSignatureMethodAttribValue,
                              wttOpen ) );

    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContextA, NULL ) );

    /*
    ** Add and open <Reference> node.
    **
    ** Output:
    **      <SignedInfo>
    **      ...
    **          <Reference URI="#SignedData">
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigReferenceTag,
                              NULL,
                              &g_dastrSigReferenceAttribName,
                              &g_dastrSigReferenceAttribValue,
                              wttOpen ) );

    /*
    ** Add and close <DigestMethod> node.
    **
    ** Output:
    **      <SignedInfo>
    **      ...
    **          <Reference>
    **              <DigestMethod>...</DigestMethod>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigDigestMethodTag,
                              NULL,
                              &g_dastrSigDigestMethodAttribName,
                              &g_dastrSigDigestMethodAttribValue,
                              wttOpen ) );

    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContextA, NULL ) );

    /*
    ** Add and open <DigestValue> node.
    **
    ** Output:
    **      <SignedInfo>
    **      ...
    **          <Reference>
    **          ...
    **              <DigestValue>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigDigestValueTag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

    cchScratch = CCH_BASE64_EQUIV( SHA256_DIGEST_SIZE_IN_BYTES );

    ChkDR( DRM_B64_EncodeA( rgbHash,
                            SHA256_DIGEST_SIZE_IN_BYTES,
                            rgchScratch,
                            &cchScratch,
                            0 ) );

    dastrScratch.pszString = rgchScratch;
    dastrScratch.cchString = cchScratch;

    ChkDR( DRM_XMB_AddDataA( f_poXMLContextA,
                            ( DRM_ANSI_CONST_STRING* )&dastrScratch ) );

    /*
    ** Close <DigestValue> node.
    **
    ** Output:
    **      <SignedInfo>
    **      ...
    **          <Reference>
    ***             ...
    **              <DigestValue></DigestValue>
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContextA, NULL ) );

    /*
    ** Close <Reference> node.
    **
    ** Output:
    **      <SignedInfo>
    **          ...
    **          <Reference>
    **          ...
    **          </Reference>
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContextA, NULL ) );

    /*
    ** Close <SignedInfo> node.
    **
    ** Output:
    **      <SignedInfo>
    **      ...
    **      </SignedInfo>
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContextA, f_dasstrSignedInfo ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/************************************************************************************
**
** Function: _GetSignatureValueNodeCharCount
**
** Synopsis: Function that calculates the number of characters in a <SignatureValue>
**           XML segment.
**
** Arguments:               N/A
**
** Returns:                 A long integer value that is number of characters in
**                          a <SignatureValue> XML segment.
**
** Note:                    Assumes that ECC-256 key is used to sign data.
**
************************************************************************************/
static DRM_DWORD _GetSignatureValueNodeCharCount( DRM_VOID )
{
    DRM_DWORD cchSize = 0;

    /* <SignatureValue> */
    cchSize = DRM_XMB_RequiredCharsForTagA( g_dastrSigSignatureValueTag.cchString,
                                            0,
                                            0,
                                            0 );

    /* Add the B64-ed size of ECC-256 signature. */
    cchSize += CCH_BASE64_EQUIV( ECDSA_P256_SIGNATURE_SIZE_IN_BYTES );

    return cchSize;
}

/*********************************************************************
**
** Function: _BuildSignatureValueNode
**
** Synopsis: Function that constructs <SignatureValue> node
**
** Arguments:
**
** [f_poXMLContextA]        -- Pointer to ANSI XML builder context.
** [f_poBBXContext]         -- Pointer to a DRM_BB_CONTEXT context.
** [f_dastrSignedInfo]      -- Pointer to ANSI string with data being signed.
** [f_poECC256PubKey]       -- Pointer to an ECC-256 public key that is used
**                             to receive the extracted ECC-256 public key.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
** Note:                    ECC-256 key is always in explicit format.
**
*********************************************************************/
static DRM_NO_INLINE DRM_RESULT _BuildSignatureValueNode(
    __inout       _XMBContextA          *f_poXMLContextA,
    __inout       DRM_BB_CONTEXT        *f_poBBXContext,
    __in    const DRM_ANSI_CONST_STRING *f_dastrSignedInfo,
    __out         PUBKEY_P256           *f_poECC256PubKey )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE rgbECC256Signature[ __CB_DECL( ECDSA_P256_SIGNATURE_SIZE_IN_BYTES ) ] = { 0 };
    /*
    ** The size of the scratch buffer is the B64-ed size of an ECC-256 signature.
    ** Since the scratch buffer is also used to process ECC-256 public key,
    ** it assumes the size of an ECC-256 signature is enough to accomodate the
    ** size of all other types of data being processed.
    */
    DRM_CHAR rgchScratch[ CCH_BASE64_EQUIV( ECDSA_P256_SIGNATURE_SIZE_IN_BYTES ) ];
    DRM_DWORD cchScratch = 0;
    DRM_ANSI_STRING dastrScratch = {0};

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_XMLSIG, PERF_FUNC__BuildSignatureValueNode );

    /*
    ** Enforce the assumtpion rule on the size of the scratch buffer.
    */
    DRMCASSERT( SIZEOF( rgchScratch ) >=
                CCH_BASE64_EQUIV( SIZEOF( PUBKEY_P256 ) ) * SIZEOF( DRM_CHAR ) );

    ChkArg( f_poXMLContextA != NULL );
    ChkArg( f_poBBXContext != NULL );
    ChkArg( f_poECC256PubKey != NULL );
    ChkDRMANSIString( f_dastrSignedInfo );

    /*
    ** Point the scratch string to the scratch buffer.
    ** Although the size of the scratch string can change, its starting location is
    ** always the same.
    */
    dastrScratch.pszString = rgchScratch;

    ChkDR( DRM_BBX_ECC256_Sign( f_poBBXContext,
                                PB_DASTR(f_dastrSignedInfo),
                                CB_DASTR(f_dastrSignedInfo),
                                f_poECC256PubKey,
                                rgbECC256Signature ) );

    /* Add and open <SignatureValue> node.
    /*
    ** Output:
    ** <Signature ... >
    ** ...
    **  <SignatureValue>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigSignatureValueTag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

    cchScratch = CCH_BASE64_EQUIV( ECDSA_P256_SIGNATURE_SIZE_IN_BYTES );

    ChkDR( DRM_B64_EncodeA( rgbECC256Signature,
                            ECDSA_P256_SIGNATURE_SIZE_IN_BYTES,
                            rgchScratch,
                            &cchScratch,
                            0 ) );

    dastrScratch.cchString = cchScratch;

    ChkDR( DRM_XMB_AddDataA( f_poXMLContextA,
                            ( DRM_ANSI_CONST_STRING* )&dastrScratch ) );

    /* Close <SignatureValue> node. */
    /*
    ** Output:
    ** <Signature ... >
    ** ...
    **      <SignatureValue>...</SignatureValue>
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContextA, NULL ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _GetPublicKeyInfoNodeWithNameCharCount
**
** Synopsis: Function that calculates the number of characters in a
**           <KeyInfo> tag for pre-shared ECC-256 public key: e.g.
**           <KeyInfo><KeyName>WMRMServer</KeyName></KeyInfo>
**
** Arguments:
**
** [f_pdastrID]             -- Pointer to a DRM ANSI String that specifies the
**                             ID of a pre-shared ECC-256 public key.
**
** Returns:                 A long integer value that is number of characters
**                          in <KeyInfo> XML segment.
**
**********************************************************************/
static DRM_NO_INLINE DRM_DWORD _GetPublicKeyInfoNodeWithNameCharCount(
    __in const DRM_ANSI_CONST_STRING *f_pdastrID )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchSize = 0;

    ChkDRMANSIString( f_pdastrID );

    /* <KeyInfo> */
    cchSize += DRM_XMB_RequiredCharsForTagA( g_dastrSigKeyInfoTag.cchString,
                                             0,
                                             g_dastrSigKeyInfoAttribName.cchString,
                                             g_dastrSigKeyInfoAttribValue.cchString );

    cchSize += DRM_XMB_RequiredCharsForTagA( g_dastrSigKeyNameTag.cchString,
                                             f_pdastrID->cchString,
                                             0,
                                             0 );

ErrorExit:

    return cchSize;
}

/*********************************************************************
**
** Function: _BuildPublicNameKeyInfoNodeWithName
**
** Synopsis: Function that constructs KeyInfo for ECC-256 public key
**           which is built into PK code: e.g.
**           <KeyInfo><KeyName>WMRMServer</KeyName></KeyInfo>
**
** Arguments:
**
** [f_poXMLContextA]         -- Pointer to ANSI XML builder context.
** [f_pdastrID]              -- Pointer to a DRM ANSI string that specifies the
**                              ID of a pre-shared ECC-256 public key.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _BuildPublicKeyInfoNodeWithName(
    __inout       _XMBContextA          *f_poXMLContextA,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrID )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_XMLSIG, PERF_FUNC__BuildPublicKeyInfoNodeWithName );

    ChkArg( f_poXMLContextA != NULL );

    /*
    ** KeyName is always "WMRMServer" or "Metering" or "Client".
    */
    if ( !DRM_UTL_DASTRStringsEqual( f_pdastrID, &g_dastrSigKeyInfoKeyName1 ) &&
         !DRM_UTL_DASTRStringsEqual( f_pdastrID, &g_dastrSigKeyInfoKeyName2 ) &&
         !DRM_UTL_DASTRStringsEqual( f_pdastrID, &g_dastrSigKeyInfoKeyName3 ) )
    {
        ChkDR( DRM_E_XMLSIG_PUBLIC_KEY_ID );
    }

    /*
    ** Add <KeyInfo> node.
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigKeyInfoTag,
                              NULL,
                              &g_dastrSigKeyInfoAttribName,
                              &g_dastrSigKeyInfoAttribValue,
                              wttOpen ) );
    /*
    ** Add <KeyName> node.
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigKeyNameTag,
                              f_pdastrID,
                              NULL,
                              NULL,
                              wttOpen ) );

    /* Close <KeyName> */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContextA, NULL ) );

    /* Close <KeyInfo> */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContextA, NULL ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _ExtractXMLPublicKeyByName
**
** Synopsis: Function that extracts a ECC-256 public key from a XML segment.
**           The XML segment should be in the form of
**           <KeyInfo><KeyName>name</KeyName></KeyInfo>.
**           The name of the root node can be any string.
**
** Arguments:
**
** [f_pszBase]              -- base XML data string, all substrings
**                             are operating on it.
** [f_pdasstrXML]           -- Pointer to a substring that contains a
**                             XML segment whose root node contains a
**                             <KeyInfo> subnode where an ECC-256 public key
**                             is stored.
** [f_pdastrID]             -- Pointer to ANSI string that specifies the
**                             ID of a pre-shared ECC-256 public key.
** [f_poECC256PubKey]       -- Pointer to an ECC-256 public key structure that
**                             will receive the extracted ECC-256 public key.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_XMLSIG_PUBLIC_KEY_ID if the passed
**                          in ID is unknown.
**
** Note: "KeyByName" functions take key name as parameter so that
**       in future we could support more pre-shared key names,
**       but right now there is only "WMRMServer".
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _ExtractPublicKeyByName(
    __in_ecount(f_pdasstrXML->m_ich+f_pdasstrXML->m_cch) const DRM_CHAR              *f_pszBase,
    __in                                                 const DRM_SUBSTRING         *f_pdasstrXML,
    __in                                                 const DRM_ANSI_CONST_STRING *f_pdastrID,
    __out                                                      PUBKEY_P256           *f_poECC256PubKey )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_SUBSTRING dasstrKeyNameValue = EMPTY_DRM_SUBSTRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_XMLSIG, PERF_FUNC__ExtractPublicKeyByName );

    ChkArg( f_pszBase != NULL );
    ChkArg( f_pdasstrXML != NULL );
    ChkArg( f_pdasstrXML->m_cch > 0 );
    ChkDRMANSIString( f_pdastrID );
    ChkArg( f_poECC256PubKey != NULL );

    /*
    ** pre-shared ECC-256 public key is always "WMRMServer" or "Client".
    */
    if ( !DRM_UTL_DASTRStringsEqual( f_pdastrID, &g_dastrSigKeyInfoKeyName1 ) &&
         !DRM_UTL_DASTRStringsEqual( f_pdastrID, &g_dastrSigKeyInfoKeyName2 ))
    {
        ChkDR( DRM_E_XMLSIG_PUBLIC_KEY_ID );
    }

    /*
    ** Extract <KeyName> and read the name of the key
    */
    ChkDR( DRM_XML_GetSubNodeByPathA( f_pszBase,
                                      f_pdasstrXML,
                                      &g_dastrSigKeyNameTag,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &dasstrKeyNameValue,
                                      g_chForwardSlash ) );

    /*
    ** Verify the key name and return it.
    */
    if ( DRM_UTL_DASSTRStringsEqual( f_pszBase, &dasstrKeyNameValue, f_pdastrID ) )
    {
        if ( DRM_UTL_DASTRStringsEqual( f_pdastrID, &g_dastrSigKeyInfoKeyName1 ) )
        {
            MEMCPY( ( DRM_BYTE * )f_poECC256PubKey,
                    ( DRM_BYTE * )&g_oWMRMECC256PubKey,
                    SIZEOF( PUBKEY_P256 ) );
        }
        else
        {
            /* If the key name is "Client", set the returned public key to be all 0. */
            ZEROMEM( ( DRM_BYTE * )f_poECC256PubKey, SIZEOF( PUBKEY_P256 ) );
        }
    }
    else
    {
        ChkDR( DRM_E_XMLSIG_PUBLIC_KEY_ID );
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _GetECC256PublicKeyInfoNodeCharCount
**
** Synopsis: Function that calculates the number of characters in
**           a <KeyInfo> XML segment with ECC256 key in the following format:
**              <KeyInfo>
**                  <KeyValue>
**                      <ECCKeyValue>
**                          <PublicKey>
**                              ...
**                          </PublicKey>
**                      </ECCKeyValue>
**                  </KeyValue>
**              </KeyInfo>
**
** Arguments:               N/A
**
** Returns:                 A long integer value that is number of characters
**                          in the <KeyInfo> XML segment.
**
**********************************************************************/
static DRM_NO_INLINE DRM_DWORD _GetECC256PublicKeyInfoNodeCharCount( DRM_VOID )
{
    DRM_DWORD cchSize = 0;

    /* <KeyInfo> */
    cchSize += DRM_XMB_RequiredCharsForTagA( g_dastrSigKeyInfoTag.cchString,
                                             0,
                                             g_dastrSigKeyInfoAttribName.cchString,
                                             g_dastrSigKeyInfoAttribValue.cchString );

    /* <KeyValue> */
    cchSize += DRM_XMB_RequiredCharsForTagA( g_dastrSigKeyValueTag.cchString,
                                             0,
                                             0,
                                             0 );

    /* <ECCKeyValue> */
    cchSize += DRM_XMB_RequiredCharsForTagA( g_dastrSigECCKeyValueTag.cchString,
                                             0,
                                             0,
                                             0 );

    /* <PublicKey> */
    cchSize += DRM_XMB_RequiredCharsForTagA( g_dastrSigPublicKeyTag.cchString,
                                             0,
                                             0,
                                             0 );

    /* Add the B64-ed size of public key. */
    cchSize += CCH_BASE64_EQUIV( SIZEOF( PUBKEY_P256) );

    return cchSize;
}

/*********************************************************************
**
** Function: _BuildECC256PublicKeyInfoNode
**
** Synopsis: Function that constructs a public key XML segment
**           for ECC-256 public key.
**
**           The public key XML segment should have a root node
**           <KeyInfo>, then <KeyValue> node under it.
**           Under <KeyValue> there is a <ECCKeyValue><PublicKey>
**           node that contains the B64 encoded ECC-256 public key.
**
** Arguments:
**
** [f_poXMLContextA]        -- Pointer to ANSI XML builder context.
** [f_poECC256PubKey]       -- Pointer to a PUBKEY_P256 structure that
**                             is going to be encoded in the generated
**                             XML segment.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _BuildECC256PublicKeyInfoNode(
    __inout       _XMBContextA *f_poXMLContextA,
    __in    const PUBKEY_P256  *f_poECC256PubKey )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CHAR rgchScratch[ CCH_BASE64_EQUIV( SIZEOF( PUBKEY_P256 ) ) ];
    DRM_DWORD cchScratch = 0;
    DRM_ANSI_STRING dastrScratch = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_XMLSIG, PERF_FUNC__BuildECC256PublicKeyInfoNode );

    ChkArg( f_poXMLContextA != NULL );
    ChkArg( f_poECC256PubKey != NULL );

    dastrScratch.pszString = rgchScratch;

    /*
    ** Add and open <KeyInfo> node.
    **
    ** Output:
    ** <KeyInfo>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigKeyInfoTag,
                              NULL,
                              &g_dastrSigKeyInfoAttribName,
                              &g_dastrSigKeyInfoAttribValue,
                              wttOpen ) );

    /*
    ** Add and open <KeyValue> node.
    **
    ** Output:
    ** <KeyInfo>
    **      <KeyValue>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigKeyValueTag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

    /*
    ** Add and open <ECCKeyValue> node.
    **
    ** Output:
    ** <KeyInfo>
    **      <KeyValue>
    **          <ECCKeyValue>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigECCKeyValueTag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

    /*
    ** Add and open <PublicKey> node.
    **
    ** Output:
    ** <KeyInfo>
    **      <KeyValue>
    **          <ECCKeyValue>
    **              <PublicKey>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigPublicKeyTag,
                              NULL,
                              NULL,
                              NULL,
                              wttOpen ) );

    cchScratch = CCH_BASE64_EQUIV( SIZEOF( PUBKEY_P256 ) );

    ChkDR( DRM_B64_EncodeA( ( DRM_BYTE * )f_poECC256PubKey->m_rgbPubkey,
                            SIZEOF( PUBKEY_P256 ),
                            rgchScratch,
                            &cchScratch,
                            0 ) );

    DRMASSERT( cchScratch == CCH_BASE64_EQUIV( SIZEOF( PUBKEY_P256 ) ) );

    dastrScratch.cchString = cchScratch;

    ChkDR( DRM_XMB_AddDataA( f_poXMLContextA,
                            ( DRM_ANSI_CONST_STRING* )&dastrScratch ) );

    /*
    ** Close <PublicKey> node.
    **
    ** Output:
    ** <KeyInfo>
    **      <KeyValue>
    **          <ECCKeyValue>
    **              <PublicKey>
    **              ...
    **              </PublicKey>
    **          </ECCKeyValue>
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContextA, NULL ) );

    /*
    ** Close <ECCKeyValue> node.
    **
    ** Output:
    ** <KeyInfo>
    **      <KeyValue>
    **          <ECCKeyValue>
    **          ...
    **          </ECCKeyValue>
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContextA, NULL ) );

    /*
    ** Close <KeyValue> node.
    **
    ** Output:
    ** <KeyInfo>
    **      <KeyValue>
    **      ...
    **      </KeyValue>
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContextA, NULL ) );

    /*
    ** Close <KeyInfo> node.
    **
    ** Output:
    ** <KeyInfo>
    ** ...
    ** </KeyInfo>
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContextA, NULL ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _ExtractECC256PublicKey
**
** Synopsis: Function that extracts an ECC-256 public key from a XML segment.
**           The XML segment should be in the form of
**           <KeyInfo>/<KeyValue>/<ECCKeyValue>/<PublicKey>.
**           Under the <KeyInfo>/<KeyValue>/<ECCKeyValue>/<PublicKey> node,
**           there is a B64 encoded ECC-256 public key.
**
** Arguments:
**
** [f_pszBase]              -- base XML data string, all substrings
**                             are operating on it.
** [f_pdasstrXML]           -- Pointer to a substring that contains a
**                             XML segment whose root node contains a
**                             <KeyInfo> subnode where an ECC-256 public
**                             key is stored.
** [f_poECC256PubKey]       -- Pointer to an ECC-256 public key that is used
**                             to receive the extracted ECC-256 public key.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_XMLNOTFOUND if XML tags are not found
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _ExtractECC256PublicKey(
    __in_ecount(f_pdasstrXML->m_ich+f_pdasstrXML->m_cch) const DRM_CHAR      *f_pszBase,
    __in                                                 const DRM_SUBSTRING *f_pdasstrXML,
    __out                                                      PUBKEY_P256   *f_poECC256PubKey )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_SUBSTRING dasstrPublicKey  = EMPTY_DRM_SUBSTRING;
    DRM_DWORD cbSize = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_XMLSIG, PERF_FUNC__ExtractECC256PublicKey );

    ChkArg( f_pszBase != NULL );
    ChkArg( f_pdasstrXML != NULL );
    ChkArg( f_pdasstrXML->m_cch > 0 );
    ChkArg( f_poECC256PubKey != NULL );

    /*
    ** Extract the public key from the passed in root node.
    */
    if ( DRM_FAILED( DRM_XML_GetSubNodeByPathA( f_pszBase,
                                                f_pdasstrXML,
                                                &g_dastrSigPublicKeyPath,
                                                NULL,
                                                NULL,
                                                NULL,
                                                &dasstrPublicKey,
                                                g_chForwardSlash ) ) )
    {
        ChkDR( DRM_E_XMLNOTFOUND );
    }

    cbSize = SIZEOF( PUBKEY_P256 );

    ChkDR( DRM_B64_DecodeA( f_pszBase,
                            &dasstrPublicKey,
                            &cbSize,
                            f_poECC256PubKey->m_rgbPubkey,
                            0 ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: _GetEncryptedDataNodePrefixCharCount
**
** Synopsis: Function that calculates the prefix portion of the
**           <EncryptedData> node. The prefix portion includes
**           all characters immediately before the actual data to be
**           B64 encoded.
**
** Arguments:
** [f_poXMLKey]             -- Pointer to a DRM_XML_KEY that contains a
**                             information of how to build a <KeyInfo>
**                             XML segment.
** [f_pcchSize]             -- Pointer to a variable to receive the
**                             calculated character count.
**
** Returns:
**                          DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
static DRM_NO_INLINE DRM_RESULT _GetEncryptedDataNodePrefixCharCount(
    __in  const DRM_XML_KEY *f_poXMLKey,
    __out       DRM_DWORD   *f_pcchSize )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchSize = 0;

    ChkArg( f_poXMLKey != NULL );
    ChkArg( f_poXMLKey->m_eKeyInfoType == DRM_XML_KEYINFO_ENCRYPTED );
    ChkArg( f_pcchSize != NULL );

    /* <EncryptedData Type="..."> */
    cchSize += DRM_XMB_RequiredCharsForTagNoCloseA( g_dastrSigEncryptedDataTag.cchString,
                                                    0,
                                                    g_dastrSigEncryptedDataAttrib1Name.cchString,
                                                    g_dastrSigEncryptedDataAttrib1Value.cchString );

    cchSize += DRM_XMB_RequiredCharsForAttributeA( g_dastrSigEncryptedDataAttrib2Name.cchString,
                                                   g_dastrSigEncryptedDataAttrib2Value.cchString );

    /* <EncryptionMethod Algorithm="../xmlenc#aes128cbc"> */
    cchSize += DRM_XMB_RequiredCharsForTagA( g_dastrSigEncryptionMethodTag.cchString,
                                             0,
                                             g_dastrSigEncryptionMethodAttrib1Name.cchString,
                                             g_dastrSigEncryptionMethodAttrib1Value.cchString );

    /* <KeyInfo> */
    ChkDR( DRM_XMLSIG_GetEncryptedKeyInfoNodeCharCount( f_poXMLKey, f_pcchSize ) );

    /* <CipherData> */
    cchSize += DRM_XMB_RequiredCharsForTagNoCloseA( g_dastrSigCipherDataTag.cchString,
                                                    0,
                                                    0,
                                                    0 );

    /* <CipherValue> */
    cchSize += DRM_XMB_RequiredCharsForTagNoCloseA( g_dastrSigCipherValueTag.cchString,
                                                    0,
                                                    0,
                                                    0 );

    *f_pcchSize += cchSize;

ErrorExit:

    return dr;
}

/*********************************************************************
**
** Function: DRM_XMLSIG_GetSimpleECC256KeyInfoNodeCharCount
**
** Synopsis: Function that calculates the number of characters in a <KeyInfo>
**           XML segment. Size depends on wether we write a pre-shared ECC-256
**           key pair name or a full ECC-256 public key.
**
** Arguments:
** [f_eECC256KeyFormat]     -- ECC-256 key format
** [f_pcchSize]             -- Pointer to a variable to be incremented
**                             by a result of calculations, cannot be NULL,
**                             and a variable should be initialized.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_GetSimpleECC256KeyInfoNodeCharCount(
    __in    const DRM_XML_ECC256_KEY_FORMAT f_eECC256KeyFormat,
    __out         DRM_DWORD                *f_pcchSize )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchSize = 0;

    ChkArg( f_pcchSize != NULL );
    ChkArg( f_eECC256KeyFormat == DRM_XML_ECC256_SERVER_PUBLIC_KEY_ID ||
            f_eECC256KeyFormat == DRM_XML_ECC256_CLIENT_PUBLIC_KEY_ID ||
            f_eECC256KeyFormat == DRM_XML_ECC256_METERING_PUBLIC_KEY_ID ||
            f_eECC256KeyFormat == DRM_XML_ECC256_PUBLIC_KEY_DATA );

    if ( f_eECC256KeyFormat == DRM_XML_ECC256_SERVER_PUBLIC_KEY_ID )
    {
        cchSize = _GetPublicKeyInfoNodeWithNameCharCount(
            ( DRM_ANSI_CONST_STRING * )&g_dastrSigKeyInfoKeyName1
            );
    }
    else if ( f_eECC256KeyFormat == DRM_XML_ECC256_CLIENT_PUBLIC_KEY_ID )
    {
        cchSize = _GetPublicKeyInfoNodeWithNameCharCount(
            ( DRM_ANSI_CONST_STRING * )&g_dastrSigKeyInfoKeyName2
            );
    }
    else if ( f_eECC256KeyFormat == DRM_XML_ECC256_METERING_PUBLIC_KEY_ID )
    {
        cchSize = _GetPublicKeyInfoNodeWithNameCharCount(
            ( DRM_ANSI_CONST_STRING * )&g_dastrSigKeyInfoKeyName3
            );
    }
    else if ( f_eECC256KeyFormat == DRM_XML_ECC256_PUBLIC_KEY_DATA )
    {
        cchSize = _GetECC256PublicKeyInfoNodeCharCount();
    }
    else
    {
        ChkDR( DRM_E_XMLSIG_INVALID_KEY_FORMAT );
    }

ErrorExit:

    *f_pcchSize += cchSize;

    return dr;
}

/*********************************************************************
**
** Function: DRM_XMLSIG_BuildSimpleECC256KeyInfoNode
**
** Synopsis: Function that constructs KeyInfo XML node for a given
**           ECC-256 public key. It supports two formats:
**           either there is <KeyValue> node with a full ECC-256 public
**           key or a reference to a pre-shared ECC-256 public key.
**
** Arguments:
**
** [f_poXMLContextA]        -- Pointer to ANSI XML builder context.
** [f_poECC256PubKey]       -- Pointer to a PUBKEY_P256 structure that
**                             is going to be encoded in the generated
**                             XML segment.
** [f_eECC256KeyFormat]     -- ECC-256 key info format.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
** Note:  If key format is DRM_XML_ECC256_PUBLIC_KEY_ID then the value of
**        ECC0256 public key does not matter, but we still check it for NULL.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMLSIG_BuildSimpleECC256KeyInfoNode(
    __inout       _XMBContextA             *f_poXMLContextA,
    __in    const PUBKEY_P256              *f_poECC256PubKey,
    __in    const DRM_XML_ECC256_KEY_FORMAT f_eECC256KeyFormat )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_poXMLContextA != NULL );
    ChkArg( f_poECC256PubKey != NULL );
    ChkArg( f_eECC256KeyFormat != DRM_XML_ECC256_INVALID_KEY );

    if ( f_eECC256KeyFormat == DRM_XML_ECC256_SERVER_PUBLIC_KEY_ID )
    {
        ChkDR( _BuildPublicKeyInfoNodeWithName( f_poXMLContextA,
                    ( DRM_ANSI_CONST_STRING * )&g_dastrSigKeyInfoKeyName1 ) );
    }
    else if ( f_eECC256KeyFormat == DRM_XML_ECC256_CLIENT_PUBLIC_KEY_ID )
    {
        ChkDR( _BuildPublicKeyInfoNodeWithName( f_poXMLContextA,
                    ( DRM_ANSI_CONST_STRING * )&g_dastrSigKeyInfoKeyName2 ) );
    }
    else if ( f_eECC256KeyFormat == DRM_XML_ECC256_METERING_PUBLIC_KEY_ID )
    {
        ChkDR( _BuildPublicKeyInfoNodeWithName( f_poXMLContextA,
                    ( DRM_ANSI_CONST_STRING * )&g_dastrSigKeyInfoKeyName3 ) );
    }
    else if ( f_eECC256KeyFormat == DRM_XML_ECC256_PUBLIC_KEY_DATA )
    {
        ChkDR( _BuildECC256PublicKeyInfoNode( f_poXMLContextA,
                                              f_poECC256PubKey) );
    }
    else
    {
        ChkDR( DRM_E_XMLSIG_INVALID_KEY_FORMAT );
    }

ErrorExit:

    return dr;
}

/*********************************************************************
**
** Function: DRM_XMLSIG_ExtractSimpleECC256Key
**
** Synopsis: Function that extracts an ECC-256 public key from a XML
**           segment that it is correctly-formed <KeyInfo>. The XML
**           segment may contain ECC-256 key name or ECC-256 key
**           parameters.
**           Function does not know the exact format of <KeyInfo>
**           and attempts to find ECC-256 key parameters first,
**           then if failed looks for a pre-shared ECC-256 key name.
**
** Arguments:
**
** [f_pszBase]              -- base XML data string for f_pdasstrXML.
** [f_pdasstrXML]           -- Pointer to a substring that contains a
**                             XML segment whose root node contains a
**                             <KeyInfo> subnode where an ECC-256 public
**                             key is stored.
** [f_poECC256PubKey]       -- Pointer to an ECC-256 public key that is
**                             used to receive the extracted ECC-256
**                             public key.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMLSIG_ExtractSimpleECC256Key(
    __in_ecount( f_pdasstrXML->m_ich + f_pdasstrXML->m_cch ) const DRM_CHAR      *f_pszBase,
    __in                                                     const DRM_SUBSTRING *f_pdasstrXML,
    __out                                                          PUBKEY_P256   *f_poECC256PubKey )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pszBase != NULL );
    ChkArg( f_pdasstrXML != NULL );
    ChkArg( f_pdasstrXML->m_cch > 0 );
    ChkArg( f_poECC256PubKey != NULL );

    dr = _ExtractECC256PublicKey( f_pszBase,
                                  f_pdasstrXML,
                                  f_poECC256PubKey );
    /*
    ** XML error means that the key may be stored in a different format.
    */
    if ( dr == DRM_E_XMLNOTFOUND )
    {
        dr = DRM_SUCCESS;

        /*
        ** Extract a pre-shared ECC-256 public key.
        */
        if ( DRM_FAILED( _ExtractPublicKeyByName( f_pszBase,
                                                  f_pdasstrXML,
                                                  ( DRM_ANSI_CONST_STRING * ) &g_dastrSigKeyInfoKeyName1,
                                                  f_poECC256PubKey ) ) )
        {
            ChkDR( _ExtractPublicKeyByName( f_pszBase,
                                            f_pdasstrXML,
                                            ( DRM_ANSI_CONST_STRING * ) &g_dastrSigKeyInfoKeyName2,
                                            f_poECC256PubKey ) );
        }
    }

ErrorExit:

    return dr;
}

/*********************************************************************
**
** Function: DRM_XMLSIG_GetEncryptedKeyInfoNodeCharCount
**
** Synopsis: Function that calculates the number of characters in <KeyInfo>
**           XML segment that contains AES key encrypted with ECC-256 key.
**
** Arguments:
** [f_poXMLKey]             -- Pointer to a DRM_XML_KEY that contains
**                             information of a key to be put in the
**                             <KeyInfo> XML segment.
** [f_pcchSize]             -- Pointer to a variable to be incremented
**                             by a result of calculations, cannot be NULL,
**                             and a variable should be initialized.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
** Note:    Keys values inside DRM_XML_KEY are not needed for calculations.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMLSIG_GetEncryptedKeyInfoNodeCharCount(
    __in    const DRM_XML_KEY *f_poXMLKey,
    __inout       DRM_DWORD   *f_pcchSize )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchSize = 0;

    ChkArg( f_poXMLKey != NULL );
    ChkArg( f_poXMLKey->m_eKeyInfoType == DRM_XML_KEYINFO_ENCRYPTED );
    ChkArg( f_poXMLKey->m_eKeyFormat == DRM_XML_ECC256_SERVER_PUBLIC_KEY_ID ||
            f_poXMLKey->m_eKeyFormat == DRM_XML_ECC256_CLIENT_PUBLIC_KEY_ID ||
            f_poXMLKey->m_eKeyFormat == DRM_XML_ECC256_METERING_PUBLIC_KEY_ID ||
            f_poXMLKey->m_eKeyFormat == DRM_XML_ECC256_PUBLIC_KEY_DATA );
    ChkArg( f_pcchSize != NULL );

    /* <KeyInfo> */
    cchSize += DRM_XMB_RequiredCharsForTagA( g_dastrSigKeyInfoTag.cchString,
                                             0,
                                             g_dastrSigKeyInfoAttribName.cchString,
                                             g_dastrSigKeyInfoAttribValue.cchString );

    /* <EncryptedKey> */
    cchSize += DRM_XMB_RequiredCharsForTagA( g_dastrSigEncryptedKeyTag.cchString,
                                             0,
                                             g_dastrSigEncryptedKeyAttribName.cchString,
                                             g_dastrSigEncryptedKeyAttribValue.cchString );

    /* <EncryptionMethod Algorithm="..."> */
    cchSize += DRM_XMB_RequiredCharsForTagA( g_dastrSigEncryptionMethodTag.cchString,
                                             0,
                                             g_dastrSigEncryptionMethodAttrib2Name.cchString,
                                             g_dastrSigEncryptionMethodAttrib2Value.cchString );

    ChkDR( DRM_XMLSIG_GetSimpleECC256KeyInfoNodeCharCount( f_poXMLKey->m_eKeyFormat, f_pcchSize ) );

    cchSize += _GetCipherDataNodeCharCount( SIZEOF( _AES_KEY ) );

ErrorExit:

    *f_pcchSize += cchSize;

    return dr;
}

/*********************************************************************************
** Function: DRM_XMLSIG_BuildEncryptedKeyInfoNode
**
** Synopsis: Function constructs a complex <KeyInfo> XML node
**           that contains an AES key encrypted with ECC-256 algorithm
**           together with ECC-256 public key used to encrypt it:
**
**           <KeyInfo xmlns="...">
**               <EncryptedKey>
**                   <EncryptionMethod Algorithm="rsa"/>
**                   <KeyInfo>
**                      (ECC-256 KeyInfo)
**                   </KeyInfo>
**                   <CipherData>
**                       (cypher data: encrypted AES key)
**                   </CipherData>
**               </EncryptedKey>
**           </KeyInfo>
**
** Arguments:
**
** [f_poXMLContextA]        -- Pointer to ANSI XML builder context.
** [f_poXMLKey]             -- Pointer to a DRM_XML_KEY that contains
**                             information of a key to be put in the
**                             <KeyInfo> XML segment.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
** Note: DRM_XML_KEY structure should already contain encrypted AES key data
** because this API will not encrypt the AES key itself.
**
*********************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMLSIG_BuildEncryptedKeyInfoNode(
    __inout       _XMBContextA *f_poXMLContextA,
    __in    const DRM_XML_KEY  *f_poXMLKey )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_XMLSIG, PERF_FUNC_DRM_XMLSIG_BuildEncryptedKeyInfoNode );

    ChkArg( f_poXMLContextA != NULL );
    ChkArg( f_poXMLKey != NULL );
    ChkArg( f_poXMLKey->m_eKeyInfoType == DRM_XML_KEYINFO_ENCRYPTED );
    ChkArg( f_poXMLKey->m_eKeyFormat == DRM_XML_ECC256_SERVER_PUBLIC_KEY_ID ||
            f_poXMLKey->m_eKeyFormat == DRM_XML_ECC256_METERING_PUBLIC_KEY_ID ||
            f_poXMLKey->m_eKeyFormat == DRM_XML_ECC256_PUBLIC_KEY_DATA );

    /*
    ** Add and open <KeyInfo> node.
    **
    ** Output:
    ** <KeyInfo>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigKeyInfoTag,
                              NULL,
                              &g_dastrSigKeyInfoAttribName,
                              &g_dastrSigKeyInfoAttribValue,
                              wttOpen ) );

    /*
    ** Add and open <EncryptedKey> node.
    **
    ** Output:
    ** <KeyInfo ... >
    **      <EncryptedKey>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigEncryptedKeyTag,
                              NULL,
                              &g_dastrSigEncryptedKeyAttribName,
                              &g_dastrSigEncryptedKeyAttribValue,
                              wttOpen ) );

    /*
    ** Add and close <EncryptionMethod> node.
    **
    ** Output:
    ** <KeyInfo ... >
    **      <EncryptedKey ... >
    **          <EncryptionMethod/>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigEncryptionMethodTag,
                              NULL,
                              &g_dastrSigEncryptionMethodAttrib2Name,
                              &g_dastrSigEncryptionMethodAttrib2Value,
                              wttClosed ) );

    /*
    ** Build <KeyInfo> node.
    **
    ** Output:
    ** <KeyInfo ... >
    ** ...
    **      <EncryptedKey ... >
    **      ...
    **          <KeyInfo>...</KeyInfo>
    */
    ChkDR( DRM_XMLSIG_BuildSimpleECC256KeyInfoNode( f_poXMLContextA,
                                                    &f_poXMLKey->m_oECC256PubKey,
                                                    f_poXMLKey->m_eKeyFormat ) );

    /*
    ** Build <CipherData> node.
    **
    ** Output:
    ** <KeyInfo ... >
    ** ...
    **      <EncryptedKey ... >
    **      ...
    **          <CypherData>...</CipherData>
    */
    ChkDR( _BuildCipherDataNode( f_poXMLContextA,
                                 f_poXMLKey->m_oAESKey.m_rgbCipherAESKey,
                                 SIZEOF( _AES_KEY  ) ) );

    /*
    ** Close <EncryptedKey> node.
    **
    ** Output:
    ** <KeyInfo ...>
    ** ...
    **      <EncryptedKey>
    **      ...
    **      </EncryptedKey>
    ** </KeyInfo>
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContextA, NULL ) );

    /*
    ** Close <KeyInfo> node.
    **
    ** Output:
    ** <KeyInfo ...>
    ** ...
    ** </KeyInfo>
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContextA, NULL ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: DRM_XMLSIG_ExtractEncryptedKey
**
** Synopsis: Function that extracts and decrypts an AES key contained
**           in a XML segment.
**           The XML segment should have a root node named <EncryptedKey>.
**           Under it there are three subnodes:
**           1. <EncryptionMethod> that contains the method used to do
**              the encryption.
**           2. <KeyInfo> that contains an ECC-256 public key used to
**              encrypt the AES key. Its matching ECC-256 private key
**              should be used to decrypt the AES key.
**           3. <CipherData> that contains the encrypted AES key.
**
** Arguments:
**
** [f_poBBXContext]         -- Pointer to a DRM_BB_CONTEXT context.
** [f_pszBase]              -- base XML data string, all substrings
**                             are operating on it.
** [f_pdasstrXML]           -- Pointer to a substring that contains a
**                             XML segment whose root node contains a
**                             <CipherData> subnode.
** [f_ppbKey]               -- Pointer to a pointer to a buffer that
**                             receives the encrypted AES key contained
**                             in the XML segment.
** [f_pcbKey]               -- Pointer to a variable to receive the size
**                             (number of bytes) of the decrypted AES key.
** [f_pdasstrKey]           -- Pointer to a variable to receive the a
**                             substring that cover the encoded key.
**                             It is the caller's responsiblity to cover
**                             the the substring with space (' ') to
**                             ensure the whole XML string is still valid
**                             for future parsing.
** [f_poECC256PubKey]       -- PubKey used to encrypt the AES session key
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMLSIG_ExtractEncryptedKey(
    __in                                                  const DRM_BB_CONTEXT *f_poBBXContext,
    __inout_ecount(f_pdasstrXML->m_ich+f_pdasstrXML->m_cch)     DRM_CHAR       *f_pszBase,
    __inout                                                     DRM_SUBSTRING  *f_pdasstrXML,
    __deref_out_bcount( *f_pcbKey )                             DRM_BYTE      **f_ppbKey,
    __out                                                       DRM_DWORD      *f_pcbKey,
    __out                                                       DRM_SUBSTRING  *f_pdasstrKey,
    __out                                                       PUBKEY_P256    *f_poECC256PubKey )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_SUBSTRING dasstrKeyInfo  = EMPTY_DRM_SUBSTRING;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_XMLSIG, PERF_FUNC_DRM_XMLSIG_ExtractEncryptedKey );

    ChkArg( f_poBBXContext != NULL );
    ChkArg( f_pszBase != NULL );
    ChkArg( f_pdasstrXML != NULL );
    ChkArg( f_pdasstrXML->m_cch > 0 );
    ChkArg( f_ppbKey != NULL );
    ChkArg( f_pcbKey != NULL );
    ChkArg( f_pdasstrKey != NULL );
    ChkArg( f_poECC256PubKey  != NULL );

    *f_ppbKey = NULL;
    *f_pcbKey = 0;

    /*
    ** Extract <KeyInfo> node from <EncryptedKey> node.
    */
    ChkDR( DRM_XML_GetSubNodeByPathA( f_pszBase,
                                      f_pdasstrXML,
                                      &g_dastrSigKeyInfoPath,
                                      NULL,
                                      NULL,
                                      &dasstrKeyInfo,
                                      NULL,
                                      g_chForwardSlash ) );

    /*
    ** Extract ECC-256 public key from <KeyInfo> node.
    */
    ChkDR( DRM_XMLSIG_ExtractSimpleECC256Key( f_pszBase,
                                              &dasstrKeyInfo,
                                              f_poECC256PubKey ) );

    /*
    ** Extract the the encrypted AES key from the <CipherValue> node.
    */
    ChkDR( _ExtractCipherData( f_pszBase,
                               f_pdasstrXML,
                               f_ppbKey,
                               f_pcbKey,
                               f_pdasstrKey ) );


ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/************************************************************************************
**
** Function: DRM_XMLSIG_GetSignatureNodeCharCount
**
** Synopsis: Function that calculates the number of characters in <Signature>
**           XML segment.
**
** Arguments:
**
** [f_pcchSize]             -- Pointer to a variable to be incremented
**                             by a result of calculations, cannot be NULL,
**                             and a variable should be initialized.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
** Note:                    Supports only DRM_XML_ECC256_PUBLIC_KEY_DATA format.
**
************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMLSIG_GetSignatureNodeCharCount(
    __inout DRM_DWORD *f_pcchSize )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchSize = 0;

    ChkArg( f_pcchSize != NULL );

    /* <Signature xmlns="..."> */
    cchSize += DRM_XMB_RequiredCharsForTagA( g_dastrSigRootTag.cchString,
                                             0,
                                             g_dastrSigRootAttribName.cchString,
                                             g_dastrSigRootAttribValue.cchString );

    /* Add the size of a SignedInfo XML segment. */
    cchSize += _GetSignedInfoNodeCharCount();

    /* size of a SignatureValue XML segment. */
    cchSize += _GetSignatureValueNodeCharCount();

    /* size of a public key XML segment. */
    cchSize += _GetECC256PublicKeyInfoNodeCharCount();

ErrorExit:

    *f_pcchSize += cchSize;

    return dr;
}

/*********************************************************************
**
** Function: DRM_XMLSIG_BuildSignatureNode
**
** Synopsis: Function that constructs a signature XML segment of the
**           passed in data.
**
**           The signature XML segment should have a root node
**           <Signature>, and should have three subnodes under it:
**           <SignedInfo> that contains a SHA-256 hash of the passed in
**           data, <SignatureValue> that contains an ECC-256 signature
**           over the whole <SignedInfo> node, and <KeyInfo> that contains
**           a public key to verify the ECC-256 signature. Each subnode
**           has its own XML structure.
**
** Arguments:
**
** [f_poXMLContextA]        -- Pointer to ANSI XML builder context.
** [f_poBBXContext]         -- Pointer to a DRM_BB_CONTEXT context.
** [f_pszBase]              -- base XML data string for f_pdasstrData
**                             and other substrings.
** [f_pdasstrData]          -- Pointer to a non-empty substring
**                             for which the hash contained
**                             in the signature XML segment is calculated.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
** Note:        Works only with DRM_XML_ECC256_PUBLIC_KEY_DATA format.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMLSIG_BuildSignatureNode(
    __inout       _XMBContextA   *f_poXMLContextA,
    __inout       DRM_BB_CONTEXT *f_poBBXContext,
    __in_ecount( f_pdasstrData->m_ich + f_pdasstrData->m_cch )
            const DRM_CHAR       *f_pszBase,
    __in    const DRM_SUBSTRING  *f_pdasstrData )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_SUBSTRING dasstrSignedInfo = EMPTY_DRM_SUBSTRING;
    DRM_ANSI_CONST_STRING dastrSignedInfo = EMPTY_DRM_STRING;
    DRM_ANSI_CONST_STRING dastrData = EMPTY_DRM_STRING;
    PUBKEY_P256 oECC256PubKey = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_XMLSIG, PERF_FUNC_DRM_XMLSIG_BuildSignatureNode );

    ChkArg( f_poXMLContextA != NULL );
    ChkArg( f_poBBXContext != NULL );
    ChkArg( f_pszBase != NULL );
    ChkArg( f_pdasstrData != NULL );
    ChkArg( f_pdasstrData->m_cch > 0 );

    /*
    ** Add and open <Signature> node.
    **
    ** Output:
    ** <Signature ... >
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigRootTag,
                              NULL,
                              &g_dastrSigRootAttribName,
                              &g_dastrSigRootAttribValue,
                              wttOpen ) );

    /*
    ** Write <SignedInfo>...</SignedInfo>
    */
    dastrData.pszString = f_pszBase + __CB_DECL( f_pdasstrData->m_ich );
    dastrData.cchString = f_pdasstrData->m_cch;

    ChkDR( _BuildSignedInfoNode( f_poXMLContextA,
                                 f_poBBXContext,
                                 &dastrData,
                                 &dasstrSignedInfo ) );

    /*
    ** Write <SignatureValue>...</SignatureValue>
    */
    dastrSignedInfo.pszString = f_poXMLContextA->rgchXML + dasstrSignedInfo.m_ich;
    dastrSignedInfo.cchString = dasstrSignedInfo.m_cch;

    ChkDR( _BuildSignatureValueNode( f_poXMLContextA,
                                     f_poBBXContext,
                                     &dastrSignedInfo,
                                     &oECC256PubKey ) );

    /*
    ** Build <KeyInfo> node.
    **
    ** Output:
    ** <Signature ... >
    ** ...
    **      <KeyInfo>
    **      ...
    **      </KeyInfo>
    */
    ChkDR( _BuildECC256PublicKeyInfoNode( f_poXMLContextA,
                                          &oECC256PubKey ) );

    /*
    ** Close <Signature> node.
    **
    ** Output:
    ** <Signature ... >
    ** ...
    ** </Signature>
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContextA, NULL ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: DRM_XMLSIG_VerifySignature
**
** Synopsis: Function that verifies the integrity of the data. First an
**           ECC-256 signature is calculated for the whole <SignedInfo>
**           node and is compared against an ECC-256 signature contained
**           in the <SignatureValue> node. If it is OK, a SHA-256 hash
**           contained in the <DigestValue> node is retrieved and is
**           compared against the calculated SHA-256 hash of the passed
**           in data for integrity verification.
**
** Arguments:
**
** [f_pszDataBase]           -- Base string for f_pdasstrData
** [f_pdasstrData]           -- Pointer to a substring that whose signature
**                              is going to be verified against a
**                              signature contained in the signature XML
**                              segment.
** [f_pszSignatureBase]      -- base string for f_pdasstrSignature
**
** [f_pdasstrSignature]      -- Pointer to a substring that contains the
**                              signature XML segment in the form of
**                              <Signature>...</Signature>.
** [f_poECC256PubKey]        -- Pointer to ECC256 public key thay used if <KeyInfo> public key not found
** [f_pBBXContext]           -- Pointer to Black Box Context. CryptoContext member is used for temporary data in crypto code.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**                          DRM_E_XMLSIG_SHA_HASH_SIZE if the size of hash is
**                          unexpected.
**                          DRM_E_XMLSIG_ECDSA_SIGNATURE_SIZE if the size of
**                          ECDSA signature is unexpected.
**                          DRM_E_XMLSIG_SHA_VERIFY_FAILURE if the SHA-256
**                          hash verfication failed.
**                          DRM_E_XMLSIG_ECDSA_VERIFY_FAILURE of ECDSA
**                          signature verification failed.
**                          DRM_E_XMLNOTFOUND if expected node cannot be found.
**
** Note: If <KeyInfo> node cannot be found, assume caller wants to use WMRM
**       server public key.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMLSIG_VerifySignature(
    __in_ecount(f_pdasstrData->m_ich+f_pdasstrData->m_cch)           const DRM_CHAR       *f_pszDataBase,
    __in                                                             const DRM_SUBSTRING  *f_pdasstrData,
    __in_ecount(f_pdasstrSignature->m_ich+f_pdasstrSignature->m_cch) const DRM_CHAR       *f_pszSignatureBase,
    __in                                                             const DRM_SUBSTRING  *f_pdasstrSignature,
    __in                                                             const PUBKEY_P256    *f_poECC256PubKey,
    __inout                                                                DRM_BB_CONTEXT *f_pBBXContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_SUBSTRING dasstrSignedInfo = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrKeyInfo = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrHashValue = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrSignatureValue = EMPTY_DRM_SUBSTRING;
    DRM_DWORD cbSize = 0;
    DRM_BYTE rgbHash[ __CB_DECL( SHA256_DIGEST_SIZE_IN_BYTES ) ] = { 0 };
    DRM_BYTE rgbECC256Signature[ __CB_DECL( ECDSA_P256_SIGNATURE_SIZE_IN_BYTES ) ] = { 0 };
    PUBKEY_P256 oECC256PubKey = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_XMLSIG, PERF_FUNC_DRM_XMLSIG_VerifySignature );

    ChkArg( f_pszDataBase != NULL );
    ChkArg( f_pdasstrData != NULL );
    ChkArg( f_pdasstrData->m_cch > 0 );
    ChkArg( f_pszSignatureBase != NULL );
    ChkArg( f_pdasstrSignature != NULL );
    ChkArg( f_pdasstrSignature->m_cch > 0 );
    ChkArg( f_poECC256PubKey != NULL );
    ChkArg( f_pBBXContext != NULL );

    /*
    ** Extract <SignedInfo> node from <Signature> node.
    ** The integrity of the node will be verified using an ECC-256
    ** signature as illustrated below.
    */
    ChkDR( DRM_XML_GetSubNodeByPathA( f_pszSignatureBase,
                                      f_pdasstrSignature,
                                      &g_dastrSigSignedInfoPath,
                                      NULL,
                                      NULL,
                                      &dasstrSignedInfo,
                                      NULL,
                                      g_chForwardSlash ) );

    ChkBOOL( dasstrSignedInfo.m_ich + dasstrSignedInfo.m_cch <=
             f_pdasstrSignature->m_ich + f_pdasstrSignature->m_cch,
             DRM_E_XMLSIG_ECDSA_VERIFY_FAILURE );

    /*
    ** Extract <DigestValue> node from <SignInfo>/<Reference> node.
    ** It contains a SHA-256 hash of the passed in data.
    */
    ChkDR( DRM_XML_GetSubNodeByPathA( f_pszSignatureBase,
                                      f_pdasstrSignature,
                                      &g_dastrSigHashPath,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &dasstrHashValue,
                                      g_chForwardSlash ) );

    cbSize = SHA256_DIGEST_SIZE_IN_BYTES;

    ChkDR( DRM_B64_DecodeA( f_pszSignatureBase,
                            &dasstrHashValue,
                            &cbSize,
                            rgbHash,
                            0 ) );

    ChkBOOL( cbSize == SHA256_DIGEST_SIZE_IN_BYTES, DRM_E_XMLSIG_SHA_HASH_SIZE );

    /*
    ** Extract a public key from the <KeyInfo> node. The public key
    ** is used to verify the ECC-256 signature of the <SignedInfo> node.
    */
    dr = DRM_XML_GetSubNodeByPathA( f_pszSignatureBase,
                                    f_pdasstrSignature,
                                    &g_dastrSigKeyInfoPath,
                                    NULL,
                                    NULL,
                                    &dasstrKeyInfo,
                                    NULL,
                                    g_chForwardSlash );

    if ( DRM_FAILED( dr ) )
    {
        /*
        ** If <KeyInfo> node cannot be found, assume caller wants to use supplied public key.
        */
        MEMCPY( &oECC256PubKey, f_poECC256PubKey, SIZEOF( PUBKEY_P256 ) );
    }
    else
    {
        ChkDR( DRM_XMLSIG_ExtractSimpleECC256Key( f_pszSignatureBase,
                                                  &dasstrKeyInfo,
                                                  &oECC256PubKey ) );
    }

    /*
    ** Extract <SignatureValue> node from <Signature> node.
    ** It contains an ECC-256 signature of the <SignInfo> node.
    */
    ChkDR( DRM_XML_GetSubNodeByPathA( f_pszSignatureBase,
                                      f_pdasstrSignature,
                                      &g_dastrSigSignatureValuePath,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &dasstrSignatureValue,
                                      g_chForwardSlash ) );

    cbSize = ECDSA_P256_SIGNATURE_SIZE_IN_BYTES;

    ChkDR( DRM_B64_DecodeA( f_pszSignatureBase,
                            &dasstrSignatureValue,
                            &cbSize,
                            rgbECC256Signature,
                            0 ) );

    ChkBOOL( cbSize == ECDSA_P256_SIGNATURE_SIZE_IN_BYTES,
             DRM_E_XMLSIG_ECDSA_SIGNATURE_SIZE );

    /* Verify the ECC-256 signature of the <SignedInfo> node. */
    if ( DRM_FAILED( DRM_ECDSA_Verify_P256( ( DRM_BYTE * )( f_pszSignatureBase + __CB_DECL( dasstrSignedInfo.m_ich ) ),
                                  dasstrSignedInfo.m_cch,
                                  &oECC256PubKey,
                                  (SIGNATURE_P256*)&rgbECC256Signature,
                                  (struct bigctx_t *)&f_pBBXContext->CryptoContext.rgbCryptoContext ) ) )
    {
        ChkDR( DRM_E_XMLSIG_ECDSA_VERIFY_FAILURE );
    }

    /*
    ** If the integrity of <SignedInfo> is OK, verify the SHA-256 hash of the
    ** passed in data against the SHA-1 hash stored in <DigestValue> node.
    */
    ChkDR( _VerifySHA256Hash( f_pszDataBase,
                              f_pdasstrData,
                              rgbHash ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: DRM_XMLSIG_GetXMLEncryptedDataNodeCharCount
**
** Synopsis: Function that calculates the number of characters in
**           <EncryptedData> XML segment.
**
** Arguments:
** [f_poXMLKey]             -- Pointer to a DRM_XML_KEY that contains a key
**                             used to encrypt the data.
** [f_cbData]               -- Size (number of bytes) of data to be encrypted.
**
** [f_pcchSize]             -- Pointer to a variable to receive the result
**                             of calculations, cannot be NULL.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
** Note:    The function does not encrypt anything during calculations.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMLSIG_GetEncryptedDataNodeCharCount(
    __in  const DRM_XML_KEY *f_poXMLKey,
    __in  const DRM_DWORD    f_cbData,
    __out       DRM_DWORD   *f_pcchSize )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchSize = 0;

    ChkArg( f_poXMLKey != NULL );
    ChkArg( f_poXMLKey->m_eKeyInfoType == DRM_XML_KEYINFO_ENCRYPTED );
    ChkArg( f_pcchSize != NULL );

    *f_pcchSize = 0;

    /* <EncryptedData Type="..."> */
    cchSize += DRM_XMB_RequiredCharsForTagA( g_dastrSigEncryptedDataTag.cchString,
                                             0,
                                             g_dastrSigEncryptedDataAttrib1Name.cchString,
                                             g_dastrSigEncryptedDataAttrib1Value.cchString );

    cchSize += DRM_XMB_RequiredCharsForTagA( 0,
                                             0,
                                             g_dastrSigEncryptedDataAttrib2Name.cchString,
                                             g_dastrSigEncryptedDataAttrib2Value.cchString );

    /* <EncryptionMethod Algorithm="../xmlenc#aes128cbc"> */
    cchSize += DRM_XMB_RequiredCharsForTagA( g_dastrSigEncryptionMethodTag.cchString,
                                             0,
                                             g_dastrSigEncryptionMethodAttrib1Name.cchString,
                                             g_dastrSigEncryptionMethodAttrib1Value.cchString );

    /* <KeyInfo> */
    ChkDR( DRM_XMLSIG_GetEncryptedKeyInfoNodeCharCount( f_poXMLKey, f_pcchSize ) );

    /* <CipherData> */
    cchSize += _GetCipherDataNodeCharCount( f_cbData );

    *f_pcchSize += cchSize;

ErrorExit:

    return dr;
}

/*********************************************************************
**
** Function: DRM_XMLSIG_BuildEncryptedDataNode
**
** Synopsis: Function that constructs an encrypted data XML segment of
**           the passed in key information and data.
**
**           The cipher data XML segment should have a root node
**           <EncryptedData>, and should have three subnodes under it:
**           <EncryptionMethod> contains the method used to encrypt the
**           data. <KeyInfo> contains information of how to find a way
**           to decrypt the data. <CipherData> contains the encrypted
**           data.
**
** Arguments:
**
** [f_poXMLContextA]        -- Pointer to ANSI XML builder context.
** [f_poXMLKey]             -- Pointer to a DRM_XML_KEY that contains a
**                             information of how to build a <KeyInfo>
**                             XML segment.
** [f_cbData]               -- Size (number of bytes) of data to be put
**                             into the <CipherValue> node. The data should
**                             have already been stored at the position
**                             pointed by the current buffer pointer in the
**                             XML builder context, and the data should have
**                             already been encrypted.
** [f_pdasstrEncryptedData] -- Pointer to a DRM substring to receive the result
**                             of the whole <EncryptedData> XML segment.
**                             The substring operates on XML builder's buffer.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMLSIG_BuildEncryptedDataNode(
    __inout       _XMBContextA  *f_poXMLContextA,
    __in    const DRM_XML_KEY   *f_poXMLKey,
    __in    const DRM_DWORD      f_cbData,
    __out         DRM_SUBSTRING *f_pdasstrEncryptedData )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cchShift = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_XMLSIG, PERF_FUNC_DRM_XMLSIG_BuildEncryptedDataNode );

    ChkArg( f_poXMLContextA != NULL );
    ChkArg( f_poXMLKey != NULL );
    ChkArg( f_poXMLKey->m_eKeyInfoType == DRM_XML_KEYINFO_ENCRYPTED );
    /* Encrypt either using a preshared server key or a full ECC-256 public key. */
    ChkArg( f_poXMLKey->m_eKeyFormat == DRM_XML_ECC256_SERVER_PUBLIC_KEY_ID ||
            f_poXMLKey->m_eKeyFormat == DRM_XML_ECC256_METERING_PUBLIC_KEY_ID ||
            f_poXMLKey->m_eKeyFormat == DRM_XML_ECC256_PUBLIC_KEY_DATA );
    ChkArg( f_cbData > 0 );

    ChkDR( _GetEncryptedDataNodePrefixCharCount( f_poXMLKey, &cchShift ) );

    ChkDR( DRM_XMB_ShiftDataFromCurrentPositionA( f_poXMLContextA,
                                                  cchShift,
                                                  f_cbData ) );

    /*
    ** Add and open <EncryptedData> node.
    **
    ** Output:
    ** <EncryptedData ... >
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigEncryptedDataTag,
                              NULL,
                              &g_dastrSigEncryptedDataAttrib1Name,
                              &g_dastrSigEncryptedDataAttrib1Value,
                              wttOpen ) );

    ChkDR( DRM_XMB_AddAttributeA( f_poXMLContextA,
                                  &g_dastrSigEncryptedDataAttrib2Name,
                                  &g_dastrSigEncryptedDataAttrib2Value ) );

    /*
    ** Add and close <EncryptionMethod> node.
    **
    ** Output:
    ** <EncryptedData>
    **      <EncryptionMethod/>
    */
    ChkDR( DRM_XMB_WriteTagA( f_poXMLContextA,
                              &g_dastrSigEncryptionMethodTag,
                              NULL,
                              &g_dastrSigEncryptionMethodAttrib1Name,
                              &g_dastrSigEncryptionMethodAttrib1Value,
                              wttClosed ) );

    /*
    ** Build <KeyInfo> node.
    **
    ** Output:
    ** <EncryptedData>
    ** ...
    **      <KeyInfo ... >
    **      ...
    **      </KeyInfo>
    */
    ChkDR( DRM_XMLSIG_BuildEncryptedKeyInfoNode( f_poXMLContextA, f_poXMLKey ) );

    /*
    ** Build <CipherData> node.
    **
    ** Output:
    ** <EncryptedDataData>
    ** ...
    **      <CipherData>...</CipherData>
    */
    ChkDR( _BuildCipherDataNode( f_poXMLContextA, NULL, f_cbData ) );

    /*
    ** Close <EncryptedData> node.
    **
    ** Output:
    ** <EncryptedData>
    ** ...
    ** </EncryptedData>
    */
    ChkDR( DRM_XMB_CloseCurrNodeA( f_poXMLContextA, f_pdasstrEncryptedData ) );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/*********************************************************************
**
** Function: DRM_XMLSIG_ExtractEncryptedData
**
** Synopsis: Function that extracts and decrypts a data buffer contained
**           in a XML segment.
**           The XML segment should have a root node named <EncryptedData>
**           and should have three subnodes under it. They are:
**           1. <EncryptionMethod> that contains the method used to do
**              the encryption.
**           2. <KeyInfo> that contains an AES key used to encrypt the
**              data.
**           3. <CipherData> that contains the encrypted data.
**
** Arguments:
**
** [f_poBBXContext]         -- Pointer to a DRM_BB_CONTEXT context.
** [f_pszBase]              -- base XML data string, all substrings
**                             are operating on it.
** [f_pdasstrXML]           -- Pointer to a substring that contains a
**                             XML segment of the whole <EncryptedData>.
** [f_ppbData]              -- Pointer to a buffer pointer to receive the
**                             address of the decrypted data contained in
**                             the XML segment.
** [f_pcbData]              -- Pointer to a variable to receive the
**                             size (number of bytes) of the decrypted
**                             data.
**
** Returns:                 DRM_SUCCESS on success.
**                          DRM_E_INVALIDARG if the arguments are invalid.
**
** Note:
**                          When the function completes, the original input
**                          XML string will contain decrypted data that may
**                          cause the original XML string to be a malformed
**                          XML string. It is the caller's responsibility to
**                          repair the original XML string if it is going to
**                          be used for other XML parsings.
**
**********************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMLSIG_ExtractEncryptedData(
    __inout                                DRM_BB_CONTEXT *f_poBBXContext,
    __inout_ecount( f_pdasstrXML->m_ich + f_pdasstrXML->m_cch )
                                           DRM_CHAR       *f_pszBase,
    __in                             const DRM_SUBSTRING  *f_pdasstrXML,
    __deref_out_bcount( *f_pcbData )       DRM_BYTE      **f_ppbData,
    __out                                  DRM_DWORD      *f_pcbData )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_SUBSTRING dasstrEncryptedKey = EMPTY_DRM_SUBSTRING;
    DRM_BYTE *pbKey = NULL;
    DRM_DWORD cbKey = 0;
    DRM_BYTE *pbCipherData = NULL;
    DRM_DWORD cbCipherData = 0;
    DRM_SUBSTRING dasstrKey = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrCipherData = EMPTY_DRM_SUBSTRING;
    PUBKEY_P256 oECC256PubKey = { 0 };
    DRM_BYTE rgbKey[__CB_DECL(ECC_P256_CIPHERTEXT_SIZE_IN_BYTES)] = { 0 };

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_XMLSIG, PERF_FUNC_DRM_XMLSIG_ExtractEncryptedData );

    ChkArg( f_poBBXContext != NULL );
    ChkArg( f_pszBase != NULL );
    ChkArg( f_pdasstrXML != NULL );
    ChkArg( f_pdasstrXML->m_cch > 0 );
    ChkArg( f_ppbData != NULL );
    ChkArg( f_pcbData != NULL );

    /*
    ** Extract <EncryptedKey> node from <EncryptedData> node.
    */
    ChkDR( DRM_XML_GetSubNodeByPathA( f_pszBase,
                                      f_pdasstrXML,
                                      &g_dastrSigEncryptedKeyPath,
                                      NULL,
                                      NULL,
                                      &dasstrEncryptedKey,
                                      NULL,
                                      g_chForwardSlash ) );

    ChkBOOL( dasstrEncryptedKey.m_ich + dasstrEncryptedKey.m_cch <=
             f_pdasstrXML->m_ich + f_pdasstrXML->m_cch,
             DRM_E_XMLSIG_FORMAT );

    /* Extract AES key from <EncryptedKey> node. */
    ChkDR( DRM_XMLSIG_ExtractEncryptedKey( f_poBBXContext,
                                           f_pszBase,
                                           &dasstrEncryptedKey,
                                           &pbKey,
                                           &cbKey,
                                           &dasstrKey,
                                           &oECC256PubKey ) );

    ChkBOOL( dasstrKey.m_ich + dasstrKey.m_cch <=
             f_pdasstrXML->m_ich + f_pdasstrXML->m_cch,
             DRM_E_XMLSIG_FORMAT );

    ChkBOOL( cbKey == ECC_P256_CIPHERTEXT_SIZE_IN_BYTES, DRM_E_XMLSIG_FORMAT );
    MEMCPY( rgbKey, pbKey, ECC_P256_CIPHERTEXT_SIZE_IN_BYTES );

    /*
    ** Set all bytes of the decoded string to ' ' to prevent future parsing
    ** error of the current XML string.
    */
    DRM_BYT_SetBytes( ( DRM_BYTE * )f_pszBase,
                      dasstrKey.m_ich,
                      dasstrKey.m_cch,
                      ' ' );


    /* Extract the data to be AES decrypted. */
    ChkDR( _ExtractCipherData( f_pszBase,
                               f_pdasstrXML,
                               &pbCipherData,
                               &cbCipherData,
                               &dasstrCipherData ) );

    ChkBOOL( cbCipherData >= DRM_AES_KEYSIZE_128, DRM_E_XMLSIG_FORMAT );

    /* Discount the size of the first DRM_AES_KEYSIZE_128 bytes of IV. */
    cbCipherData -= DRM_AES_KEYSIZE_128;

    ChkDR( DRM_BBX_ECC256_AESCBC_Decrypt(
        f_poBBXContext,
        rgbKey,
        cbKey,
        &oECC256PubKey,
        pbCipherData,
        pbCipherData + __CB_DECL(DRM_AES_KEYSIZE_128),
        cbCipherData
        ) );

    /* Set the input buffer pointer to the beginning address of the decrypted data. */
    *f_ppbData = pbCipherData + __CB_DECL(DRM_AES_KEYSIZE_128);

    /* Store the size of the decrypted data. */
    *f_pcbData = cbCipherData;

ErrorExit:
    OEM_SECURE_ZERO_MEMORY( rgbKey, SIZEOF(__CB_DECL(rgbKey)) );


    /*
    ** Set all bytes of the decoded string to ' ' to prevent future parsing
    ** error of the current XML string.
    */
    if( dasstrKey.m_ich != 0
    &&( dasstrKey.m_ich + dasstrKey.m_cch <= f_pdasstrXML->m_ich + f_pdasstrXML->m_cch ) )
    {
        DRM_BYT_SetBytes( ( DRM_BYTE * )f_pszBase,
                          dasstrKey.m_ich,
                          dasstrKey.m_cch,
                          ' ' );
    }
    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmxmlsigconstants.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmtypes.h>
#include <drmxmlsigconstants.h>

ENTER_PK_NAMESPACE_CODE;

/* A well known WMRM ECC-256 public key */
const PUBKEY_P256 g_oWMRMECC256PubKey = 
{
    TWO_BYTES( 0XC8, 0XB6 ), TWO_BYTES( 0XAF, 0X16 ), TWO_BYTES( 0XEE, 0X94 ), TWO_BYTES( 0X1A, 0XAD ),
    TWO_BYTES( 0XAA, 0X53 ), TWO_BYTES( 0X89, 0XB4 ), TWO_BYTES( 0XAF, 0X2C ), TWO_BYTES( 0X10, 0XE3 ),
    TWO_BYTES( 0X56, 0XBE ), TWO_BYTES( 0X42, 0XAF ), TWO_BYTES( 0X17, 0X5E ), TWO_BYTES( 0XF3, 0XFA ),
    TWO_BYTES( 0XCE, 0X93 ), TWO_BYTES( 0X25, 0X4E ), TWO_BYTES( 0X7B, 0X0B ), TWO_BYTES( 0X3D, 0X9B ),
    TWO_BYTES( 0X98, 0X2B ), TWO_BYTES( 0X27, 0XB5 ), TWO_BYTES( 0XCB, 0X23 ), TWO_BYTES( 0X41, 0X32 ),
    TWO_BYTES( 0X6E, 0X56 ), TWO_BYTES( 0XAA, 0X85 ), TWO_BYTES( 0X7D, 0XBF ), TWO_BYTES( 0XD5, 0XC6 ),
    TWO_BYTES( 0X34, 0XCE ), TWO_BYTES( 0X2C, 0XF9 ), TWO_BYTES( 0XEA, 0X74 ), TWO_BYTES( 0XFC, 0XA8 ),
    TWO_BYTES( 0XF2, 0XAF ), TWO_BYTES( 0X59, 0X57 ), TWO_BYTES( 0XEF, 0XEE ), TWO_BYTES( 0XA5, 0X62 )
};

/*
** -------------------------------------------------------------
** XML strings used in the construction of signature XML segment
** -------------------------------------------------------------
*/
/* "Signature" */
const DRM_CHAR g_rgchSigRootTag [] =
{
    TWO_BYTES( 'S', 'i' ), TWO_BYTES( 'g', 'n' ), TWO_BYTES( 'a', 't' ), TWO_BYTES( 'u', 'r' ), 
    TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigRootTag = { g_rgchSigRootTag, 9 };


/* "SignedInfo" */
const DRM_CHAR g_rgchSigSignedInfoTag [] =
{
    TWO_BYTES( 'S', 'i' ), TWO_BYTES( 'g', 'n' ), TWO_BYTES( 'e', 'd' ), TWO_BYTES( 'I', 'n' ), 
    TWO_BYTES( 'f', 'o' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigSignedInfoTag = { g_rgchSigSignedInfoTag, 10 };


/* "CanonicalizationMethod" */
const DRM_CHAR g_rgchSigCanonicalizationMethodTag [] =
{
    TWO_BYTES( 'C', 'a' ), TWO_BYTES( 'n', 'o' ), TWO_BYTES( 'n', 'i' ), TWO_BYTES( 'c', 'a' ), 
    TWO_BYTES( 'l', 'i' ), TWO_BYTES( 'z', 'a' ), TWO_BYTES( 't', 'i' ), TWO_BYTES( 'o', 'n' ), 
    TWO_BYTES( 'M', 'e' ), TWO_BYTES( 't', 'h' ), TWO_BYTES( 'o', 'd' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigCanonicalizationMethodTag = { g_rgchSigCanonicalizationMethodTag, 22 };


/* "SignatureMethod" */
const DRM_CHAR g_rgchSigSignatureMethodTag [] =
{
    TWO_BYTES( 'S', 'i' ), TWO_BYTES( 'g', 'n' ), TWO_BYTES( 'a', 't' ), TWO_BYTES( 'u', 'r' ), 
    TWO_BYTES( 'e', 'M' ), TWO_BYTES( 'e', 't' ), TWO_BYTES( 'h', 'o' ), TWO_BYTES( 'd', '\0' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigSignatureMethodTag = { g_rgchSigSignatureMethodTag, 15 };


/* "Reference" */
const DRM_CHAR g_rgchSigReferenceTag [] =
{
    TWO_BYTES( 'R', 'e' ), TWO_BYTES( 'f', 'e' ), TWO_BYTES( 'r', 'e' ), TWO_BYTES( 'n', 'c' ), 
    TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigReferenceTag = { g_rgchSigReferenceTag, 9 };


/* "DigestMethod" */
const DRM_CHAR g_rgchSigDigestMethodTag [] =
{
    TWO_BYTES( 'D', 'i' ), TWO_BYTES( 'g', 'e' ), TWO_BYTES( 's', 't' ), TWO_BYTES( 'M', 'e' ), 
    TWO_BYTES( 't', 'h' ), TWO_BYTES( 'o', 'd' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigDigestMethodTag = { g_rgchSigDigestMethodTag, 12 };


/* "DigestValue" */
const DRM_CHAR g_rgchSigDigestValueTag [] =
{
    TWO_BYTES( 'D', 'i' ), TWO_BYTES( 'g', 'e' ), TWO_BYTES( 's', 't' ), TWO_BYTES( 'V', 'a' ), 
    TWO_BYTES( 'l', 'u' ), TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigDigestValueTag = { g_rgchSigDigestValueTag, 11 };


/* "SignatureValue" */
const DRM_CHAR g_rgchSigSignatureValueTag [] =
{
    TWO_BYTES( 'S', 'i' ), TWO_BYTES( 'g', 'n' ), TWO_BYTES( 'a', 't' ), TWO_BYTES( 'u', 'r' ), 
    TWO_BYTES( 'e', 'V' ), TWO_BYTES( 'a', 'l' ), TWO_BYTES( 'u', 'e' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigSignatureValueTag = { g_rgchSigSignatureValueTag, 14 };


/* "KeyInfo" */
const DRM_CHAR g_rgchSigKeyInfoTag [] =
{
    TWO_BYTES( 'K', 'e' ), TWO_BYTES( 'y', 'I' ), TWO_BYTES( 'n', 'f' ), TWO_BYTES( 'o', '\0' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigKeyInfoTag = { g_rgchSigKeyInfoTag, 7 };


/* "KeyValue" */
const DRM_CHAR g_rgchSigKeyValueTag [] =
{
    TWO_BYTES( 'K', 'e' ), TWO_BYTES( 'y', 'V' ), TWO_BYTES( 'a', 'l' ), TWO_BYTES( 'u', 'e' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigKeyValueTag = { g_rgchSigKeyValueTag, 8 };


/* "ECCKeyValue" */
const DRM_CHAR g_rgchSigECCKeyValueTag [] =
{
    TWO_BYTES( 'E', 'C' ), TWO_BYTES( 'C', 'K' ), TWO_BYTES( 'e', 'y' ), TWO_BYTES( 'V', 'a' ), 
    TWO_BYTES( 'l', 'u' ), TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigECCKeyValueTag = { g_rgchSigECCKeyValueTag, 11 };


/* "PublicKey" */
const DRM_CHAR g_rgchSigPublicKeyTag [] =
{
    TWO_BYTES( 'P', 'u' ), TWO_BYTES( 'b', 'l' ), TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'K', 'e' ), 
    TWO_BYTES( 'y', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigPublicKeyTag = { g_rgchSigPublicKeyTag, 9 };



/* "xmlns" */
const DRM_CHAR g_rgchSigRootAttribName [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigRootAttribName = { g_rgchSigRootAttribName, 5 };

/* "http://www.w3.org/2000/09/xmldsig#" */
const DRM_CHAR g_rgchSigRootAttribValue [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 'w' ), 
    TWO_BYTES( 'w', 'w' ), TWO_BYTES( '.', 'w' ), TWO_BYTES( '3', '.' ), TWO_BYTES( 'o', 'r' ), 
    TWO_BYTES( 'g', '/' ), TWO_BYTES( '2', '0' ), TWO_BYTES( '0', '0' ), TWO_BYTES( '/', '0' ), 
    TWO_BYTES( '9', '/' ), TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'd' ), TWO_BYTES( 's', 'i' ), 
    TWO_BYTES( 'g', '#' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigRootAttribValue = { g_rgchSigRootAttribValue, 34 };


/* "xmlns" */
const DRM_CHAR g_rgchSigSignedInfoAttribName [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigSignedInfoAttribName = { g_rgchSigSignedInfoAttribName, 5 };

/* "xmlns:m" */
const DRM_CHAR  g_rgchRSAPrefixMSLP                [] = 
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', ':' ), TWO_BYTES( 'm', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING  g_dastrRSAPrefixMSLP = { g_rgchRSAPrefixMSLP, 7 };

/* "http://www.w3.org/2000/09/xmldsig#" */
const DRM_CHAR g_rgchSigSignedInfoAttribValue [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 'w' ), 
    TWO_BYTES( 'w', 'w' ), TWO_BYTES( '.', 'w' ), TWO_BYTES( '3', '.' ), TWO_BYTES( 'o', 'r' ), 
    TWO_BYTES( 'g', '/' ), TWO_BYTES( '2', '0' ), TWO_BYTES( '0', '0' ), TWO_BYTES( '/', '0' ), 
    TWO_BYTES( '9', '/' ), TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'd' ), TWO_BYTES( 's', 'i' ), 
    TWO_BYTES( 'g', '#' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigSignedInfoAttribValue = { g_rgchSigSignedInfoAttribValue, 34 };


/* "Algorithm" */
const DRM_CHAR g_rgchSigCanonicalizationMethodAttribName [] =
{
    TWO_BYTES( 'A', 'l' ), TWO_BYTES( 'g', 'o' ), TWO_BYTES( 'r', 'i' ), TWO_BYTES( 't', 'h' ), 
    TWO_BYTES( 'm', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigCanonicalizationMethodAttribName = { g_rgchSigCanonicalizationMethodAttribName, 9 };

/* "http://www.w3.org/TR/2001/REC-xml-c14n-20010315" */
const DRM_CHAR g_rgchSigCanonicalizationMethodAttribValue [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 'w' ), 
    TWO_BYTES( 'w', 'w' ), TWO_BYTES( '.', 'w' ), TWO_BYTES( '3', '.' ), TWO_BYTES( 'o', 'r' ), 
    TWO_BYTES( 'g', '/' ), TWO_BYTES( 'T', 'R' ), TWO_BYTES( '/', '2' ), TWO_BYTES( '0', '0' ), 
    TWO_BYTES( '1', '/' ), TWO_BYTES( 'R', 'E' ), TWO_BYTES( 'C', '-' ), TWO_BYTES( 'x', 'm' ), 
    TWO_BYTES( 'l', '-' ), TWO_BYTES( 'c', '1' ), TWO_BYTES( '4', 'n' ), TWO_BYTES( '-', '2' ), 
    TWO_BYTES( '0', '0' ), TWO_BYTES( '1', '0' ), TWO_BYTES( '3', '1' ), TWO_BYTES( '5', '\0' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigCanonicalizationMethodAttribValue = { g_rgchSigCanonicalizationMethodAttribValue, 47 };


/* "Algorithm" */
const DRM_CHAR g_rgchSigSignatureMethodAttribName [] =
{
    TWO_BYTES( 'A', 'l' ), TWO_BYTES( 'g', 'o' ), TWO_BYTES( 'r', 'i' ), TWO_BYTES( 't', 'h' ), 
    TWO_BYTES( 'm', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigSignatureMethodAttribName = { g_rgchSigSignatureMethodAttribName, 9 };

/* "http://schemas.microsoft.com/DRM/2007/03/protocols#ecdsa-sha256" */
const DRM_CHAR g_rgchSigSignatureMethodAttribValue [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 's' ), 
    TWO_BYTES( 'c', 'h' ), TWO_BYTES( 'e', 'm' ), TWO_BYTES( 'a', 's' ), TWO_BYTES( '.', 'm' ), 
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 's', 'o' ), TWO_BYTES( 'f', 't' ), 
    TWO_BYTES( '.', 'c' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( '/', 'D' ), TWO_BYTES( 'R', 'M' ), 
    TWO_BYTES( '/', '2' ), TWO_BYTES( '0', '0' ), TWO_BYTES( '7', '/' ), TWO_BYTES( '0', '3' ), 
    TWO_BYTES( '/', 'p' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 't', 'o' ), TWO_BYTES( 'c', 'o' ), 
    TWO_BYTES( 'l', 's' ), TWO_BYTES( '#', 'e' ), TWO_BYTES( 'c', 'd' ), TWO_BYTES( 's', 'a' ), 
    TWO_BYTES( '-', 's' ), TWO_BYTES( 'h', 'a' ), TWO_BYTES( '2', '5' ), TWO_BYTES( '6', '\0' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigSignatureMethodAttribValue = { g_rgchSigSignatureMethodAttribValue, 63 };


/* "Algorithm" */
const DRM_CHAR g_rgchSigDigestMethodAttribName [] =
{
    TWO_BYTES( 'A', 'l' ), TWO_BYTES( 'g', 'o' ), TWO_BYTES( 'r', 'i' ), TWO_BYTES( 't', 'h' ), 
    TWO_BYTES( 'm', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigDigestMethodAttribName = { g_rgchSigDigestMethodAttribName, 9 };

/* "http://schemas.microsoft.com/DRM/2007/03/protocols#sha256" */
const DRM_CHAR g_rgchSigDigestMethodAttribValue [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 's' ), 
    TWO_BYTES( 'c', 'h' ), TWO_BYTES( 'e', 'm' ), TWO_BYTES( 'a', 's' ), TWO_BYTES( '.', 'm' ), 
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 's', 'o' ), TWO_BYTES( 'f', 't' ), 
    TWO_BYTES( '.', 'c' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( '/', 'D' ), TWO_BYTES( 'R', 'M' ), 
    TWO_BYTES( '/', '2' ), TWO_BYTES( '0', '0' ), TWO_BYTES( '7', '/' ), TWO_BYTES( '0', '3' ), 
    TWO_BYTES( '/', 'p' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 't', 'o' ), TWO_BYTES( 'c', 'o' ), 
    TWO_BYTES( 'l', 's' ), TWO_BYTES( '#', 's' ), TWO_BYTES( 'h', 'a' ), TWO_BYTES( '2', '5' ), 
    TWO_BYTES( '6', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigDigestMethodAttribValue = { g_rgchSigDigestMethodAttribValue, 57 };


/* "xmlns" */
const DRM_CHAR g_rgchSigKeyInfoAttribName [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigKeyInfoAttribName = { g_rgchSigKeyInfoAttribName, 5 };

/* "http://www.w3.org/2000/09/xmldsig#" */
const DRM_CHAR g_rgchSigKeyInfoAttribValue [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 'w' ), 
    TWO_BYTES( 'w', 'w' ), TWO_BYTES( '.', 'w' ), TWO_BYTES( '3', '.' ), TWO_BYTES( 'o', 'r' ), 
    TWO_BYTES( 'g', '/' ), TWO_BYTES( '2', '0' ), TWO_BYTES( '0', '0' ), TWO_BYTES( '/', '0' ), 
    TWO_BYTES( '9', '/' ), TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'd' ), TWO_BYTES( 's', 'i' ), 
    TWO_BYTES( 'g', '#' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigKeyInfoAttribValue = { g_rgchSigKeyInfoAttribValue, 34 };




/*
** ------------------------------------------------------------------
** XML strings used in the construction of XML encrypted data segment
** ------------------------------------------------------------------
*/
/* "EncryptedData" */
const DRM_CHAR g_rgchSigEncryptedDataTag [] =
{
    TWO_BYTES( 'E', 'n' ), TWO_BYTES( 'c', 'r' ), TWO_BYTES( 'y', 'p' ), TWO_BYTES( 't', 'e' ), 
    TWO_BYTES( 'd', 'D' ), TWO_BYTES( 'a', 't' ), TWO_BYTES( 'a', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigEncryptedDataTag = { g_rgchSigEncryptedDataTag, 13 };


/* "EncryptionMethod" */
const DRM_CHAR g_rgchSigEncryptionMethodTag [] =
{
    TWO_BYTES( 'E', 'n' ), TWO_BYTES( 'c', 'r' ), TWO_BYTES( 'y', 'p' ), TWO_BYTES( 't', 'i' ), 
    TWO_BYTES( 'o', 'n' ), TWO_BYTES( 'M', 'e' ), TWO_BYTES( 't', 'h' ), TWO_BYTES( 'o', 'd' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigEncryptionMethodTag = { g_rgchSigEncryptionMethodTag, 16 };


/* "EncryptedKey" */
const DRM_CHAR g_rgchSigEncryptedKeyTag [] =
{
    TWO_BYTES( 'E', 'n' ), TWO_BYTES( 'c', 'r' ), TWO_BYTES( 'y', 'p' ), TWO_BYTES( 't', 'e' ), 
    TWO_BYTES( 'd', 'K' ), TWO_BYTES( 'e', 'y' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigEncryptedKeyTag = { g_rgchSigEncryptedKeyTag, 12 };


/* "CipherData" */
const DRM_CHAR g_rgchSigCipherDataTag [] =
{
    TWO_BYTES( 'C', 'i' ), TWO_BYTES( 'p', 'h' ), TWO_BYTES( 'e', 'r' ), TWO_BYTES( 'D', 'a' ), 
    TWO_BYTES( 't', 'a' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigCipherDataTag = { g_rgchSigCipherDataTag, 10 };


/* "CipherValue" */
const DRM_CHAR g_rgchSigCipherValueTag [] =
{
    TWO_BYTES( 'C', 'i' ), TWO_BYTES( 'p', 'h' ), TWO_BYTES( 'e', 'r' ), TWO_BYTES( 'V', 'a' ), 
    TWO_BYTES( 'l', 'u' ), TWO_BYTES( 'e', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigCipherValueTag = { g_rgchSigCipherValueTag, 11 };



/* "xmlns" */
const DRM_CHAR g_rgchSigEncryptedDataAttrib1Name [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigEncryptedDataAttrib1Name = { g_rgchSigEncryptedDataAttrib1Name, 5 };

/* "http://www.w3.org/2001/04/xmlenc#" */
const DRM_CHAR g_rgchSigEncryptedDataAttrib1Value [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 'w' ), 
    TWO_BYTES( 'w', 'w' ), TWO_BYTES( '.', 'w' ), TWO_BYTES( '3', '.' ), TWO_BYTES( 'o', 'r' ), 
    TWO_BYTES( 'g', '/' ), TWO_BYTES( '2', '0' ), TWO_BYTES( '0', '1' ), TWO_BYTES( '/', '0' ), 
    TWO_BYTES( '4', '/' ), TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'e' ), TWO_BYTES( 'n', 'c' ), 
    TWO_BYTES( '#', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigEncryptedDataAttrib1Value = { g_rgchSigEncryptedDataAttrib1Value, 33 };


/* "Type" */
const DRM_CHAR g_rgchSigEncryptedDataAttrib2Name [] =
{
    TWO_BYTES( 'T', 'y' ), TWO_BYTES( 'p', 'e' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigEncryptedDataAttrib2Name = { g_rgchSigEncryptedDataAttrib2Name, 4 };

/* "http://www.w3.org/2001/04/xmlenc#Element" */
const DRM_CHAR g_rgchSigEncryptedDataAttrib2Value [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 'w' ), 
    TWO_BYTES( 'w', 'w' ), TWO_BYTES( '.', 'w' ), TWO_BYTES( '3', '.' ), TWO_BYTES( 'o', 'r' ), 
    TWO_BYTES( 'g', '/' ), TWO_BYTES( '2', '0' ), TWO_BYTES( '0', '1' ), TWO_BYTES( '/', '0' ), 
    TWO_BYTES( '4', '/' ), TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'e' ), TWO_BYTES( 'n', 'c' ), 
    TWO_BYTES( '#', 'E' ), TWO_BYTES( 'l', 'e' ), TWO_BYTES( 'm', 'e' ), TWO_BYTES( 'n', 't' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigEncryptedDataAttrib2Value = { g_rgchSigEncryptedDataAttrib2Value, 40 };


/* "Algorithm" */
const DRM_CHAR g_rgchSigEncryptionMethodAttrib1Name [] =
{
    TWO_BYTES( 'A', 'l' ), TWO_BYTES( 'g', 'o' ), TWO_BYTES( 'r', 'i' ), TWO_BYTES( 't', 'h' ), 
    TWO_BYTES( 'm', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigEncryptionMethodAttrib1Name = { g_rgchSigEncryptionMethodAttrib1Name, 9 };

/* "http://www.w3.org/2001/04/xmlenc#aes128-cbc" */
const DRM_CHAR g_rgchSigEncryptionMethodAttrib1Value [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 'w' ), 
    TWO_BYTES( 'w', 'w' ), TWO_BYTES( '.', 'w' ), TWO_BYTES( '3', '.' ), TWO_BYTES( 'o', 'r' ), 
    TWO_BYTES( 'g', '/' ), TWO_BYTES( '2', '0' ), TWO_BYTES( '0', '1' ), TWO_BYTES( '/', '0' ), 
    TWO_BYTES( '4', '/' ), TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'e' ), TWO_BYTES( 'n', 'c' ), 
    TWO_BYTES( '#', 'a' ), TWO_BYTES( 'e', 's' ), TWO_BYTES( '1', '2' ), TWO_BYTES( '8', '-' ), 
    TWO_BYTES( 'c', 'b' ), TWO_BYTES( 'c', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigEncryptionMethodAttrib1Value = { g_rgchSigEncryptionMethodAttrib1Value, 43 };


/* "Algorithm" */
const DRM_CHAR g_rgchSigEncryptionMethodAttrib2Name [] =
{
    TWO_BYTES( 'A', 'l' ), TWO_BYTES( 'g', 'o' ), TWO_BYTES( 'r', 'i' ), TWO_BYTES( 't', 'h' ), 
    TWO_BYTES( 'm', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigEncryptionMethodAttrib2Name = { g_rgchSigEncryptionMethodAttrib2Name, 9 };

/* "http://schemas.microsoft.com/DRM/2007/03/protocols#ecc256" */
const DRM_CHAR g_rgchSigEncryptionMethodAttrib2Value [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 's' ), 
    TWO_BYTES( 'c', 'h' ), TWO_BYTES( 'e', 'm' ), TWO_BYTES( 'a', 's' ), TWO_BYTES( '.', 'm' ), 
    TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 's', 'o' ), TWO_BYTES( 'f', 't' ), 
    TWO_BYTES( '.', 'c' ), TWO_BYTES( 'o', 'm' ), TWO_BYTES( '/', 'D' ), TWO_BYTES( 'R', 'M' ), 
    TWO_BYTES( '/', '2' ), TWO_BYTES( '0', '0' ), TWO_BYTES( '7', '/' ), TWO_BYTES( '0', '3' ), 
    TWO_BYTES( '/', 'p' ), TWO_BYTES( 'r', 'o' ), TWO_BYTES( 't', 'o' ), TWO_BYTES( 'c', 'o' ), 
    TWO_BYTES( 'l', 's' ), TWO_BYTES( '#', 'e' ), TWO_BYTES( 'c', 'c' ), TWO_BYTES( '2', '5' ), 
    TWO_BYTES( '6', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigEncryptionMethodAttrib2Value = { g_rgchSigEncryptionMethodAttrib2Value, 57 };


/* "xmlns" */
const DRM_CHAR g_rgchSigKeyInfoAttrib1Name [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigKeyInfoAttrib1Name = { g_rgchSigKeyInfoAttrib1Name, 5 };

/* "http://www.w3.org/2000/09/xmldsig#" */
const DRM_CHAR g_rgchSigKeyInfoAttrib1Value [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 'w' ), 
    TWO_BYTES( 'w', 'w' ), TWO_BYTES( '.', 'w' ), TWO_BYTES( '3', '.' ), TWO_BYTES( 'o', 'r' ), 
    TWO_BYTES( 'g', '/' ), TWO_BYTES( '2', '0' ), TWO_BYTES( '0', '0' ), TWO_BYTES( '/', '0' ), 
    TWO_BYTES( '9', '/' ), TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'd' ), TWO_BYTES( 's', 'i' ), 
    TWO_BYTES( 'g', '#' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigKeyInfoAttrib1Value = { g_rgchSigKeyInfoAttrib1Value, 34 };


/* "KeyName" */
const DRM_CHAR g_rgchSigKeyNameTag [] =
{
    TWO_BYTES( 'K', 'e' ), TWO_BYTES( 'y', 'N' ), TWO_BYTES( 'a', 'm' ), TWO_BYTES( 'e', '\0' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigKeyNameTag = { g_rgchSigKeyNameTag, 7 };


/* "WMRMServer" */
const DRM_CHAR g_rgchSigKeyInfoKeyName1 [] =
{
    TWO_BYTES( 'W', 'M' ), TWO_BYTES( 'R', 'M' ), TWO_BYTES( 'S', 'e' ), TWO_BYTES( 'r', 'v' ), 
    TWO_BYTES( 'e', 'r' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigKeyInfoKeyName1 = { g_rgchSigKeyInfoKeyName1, 10 };

/* "Client" */
const DRM_CHAR g_rgchSigKeyInfoKeyName2 [] =
{
    TWO_BYTES( 'C', 'l' ), TWO_BYTES( 'i', 'e' ), TWO_BYTES( 'n', 't' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigKeyInfoKeyName2 = { g_rgchSigKeyInfoKeyName2, 6 };

/* "Metering" */
const DRM_CHAR g_rgchSigKeyInfoKeyName3 [] =
{
    TWO_BYTES( 'M', 'e' ), TWO_BYTES( 't', 'e' ), TWO_BYTES( 'r', 'i' ), TWO_BYTES( 'n', 'g' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigKeyInfoKeyName3 = { g_rgchSigKeyInfoKeyName3, 8 };

/* "KeyInfo/KeyName" */
const DRM_CHAR g_rgchKeyInfoKeyNamePath [] =
{
    TWO_BYTES( 'K', 'e' ), TWO_BYTES( 'y', 'I' ), TWO_BYTES( 'n', 'f' ), TWO_BYTES( 'o', '/' ), 
    TWO_BYTES( 'K', 'e' ), TWO_BYTES( 'y', 'N' ), TWO_BYTES( 'a', 'm' ), TWO_BYTES( 'e', '\0' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrKeyInfoKeyNamePath = { g_rgchKeyInfoKeyNamePath, 15 };


/* "URI" */
const DRM_CHAR g_rgchSigReferenceAttribName [] =
{
    TWO_BYTES( 'U', 'R' ), TWO_BYTES( 'I', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigReferenceAttribName = { g_rgchSigReferenceAttribName, 3 };

/* "#SignedData" */
const DRM_CHAR g_rgchSigReferenceAttribValue [] =
{
    TWO_BYTES( '#', 'S' ), TWO_BYTES( 'i', 'g' ), TWO_BYTES( 'n', 'e' ), TWO_BYTES( 'd', 'D' ), 
    TWO_BYTES( 'a', 't' ), TWO_BYTES( 'a', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigReferenceAttribValue = { g_rgchSigReferenceAttribValue, 11 };


/* "xmlns" */
const DRM_CHAR g_rgchSigEncryptedKeyAttribName [] =
{
    TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'n' ), TWO_BYTES( 's', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigEncryptedKeyAttribName = { g_rgchSigEncryptedKeyAttribName, 5 };

/* "http://www.w3.org/2001/04/xmlenc#" */
const DRM_CHAR g_rgchSigEncryptedKeyAttribValue [] =
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 'w' ), 
    TWO_BYTES( 'w', 'w' ), TWO_BYTES( '.', 'w' ), TWO_BYTES( '3', '.' ), TWO_BYTES( 'o', 'r' ), 
    TWO_BYTES( 'g', '/' ), TWO_BYTES( '2', '0' ), TWO_BYTES( '0', '1' ), TWO_BYTES( '/', '0' ), 
    TWO_BYTES( '4', '/' ), TWO_BYTES( 'x', 'm' ), TWO_BYTES( 'l', 'e' ), TWO_BYTES( 'n', 'c' ), 
    TWO_BYTES( '#', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigEncryptedKeyAttribValue = { g_rgchSigEncryptedKeyAttribValue, 33 };




/*
** --------------------------------------------------------
** XML strings used in the parsing of signature XML segment
** --------------------------------------------------------
*/
/* "SignedInfo" */
const DRM_CHAR g_rgchSigSignedInfoPath [] =
{
    TWO_BYTES( 'S', 'i' ), TWO_BYTES( 'g', 'n' ), TWO_BYTES( 'e', 'd' ), TWO_BYTES( 'I', 'n' ), 
    TWO_BYTES( 'f', 'o' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigSignedInfoPath = { g_rgchSigSignedInfoPath, 10 };


/* "SignatureValue" */
const DRM_CHAR g_rgchSigSignatureValuePath [] =
{
    TWO_BYTES( 'S', 'i' ), TWO_BYTES( 'g', 'n' ), TWO_BYTES( 'a', 't' ), TWO_BYTES( 'u', 'r' ), 
    TWO_BYTES( 'e', 'V' ), TWO_BYTES( 'a', 'l' ), TWO_BYTES( 'u', 'e' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigSignatureValuePath = { g_rgchSigSignatureValuePath, 14 };


/* "SignedInfo/Reference/DigestValue" */
const DRM_CHAR g_rgchSigHashPath [] =
{
    TWO_BYTES( 'S', 'i' ), TWO_BYTES( 'g', 'n' ), TWO_BYTES( 'e', 'd' ), TWO_BYTES( 'I', 'n' ), 
    TWO_BYTES( 'f', 'o' ), TWO_BYTES( '/', 'R' ), TWO_BYTES( 'e', 'f' ), TWO_BYTES( 'e', 'r' ), 
    TWO_BYTES( 'e', 'n' ), TWO_BYTES( 'c', 'e' ), TWO_BYTES( '/', 'D' ), TWO_BYTES( 'i', 'g' ), 
    TWO_BYTES( 'e', 's' ), TWO_BYTES( 't', 'V' ), TWO_BYTES( 'a', 'l' ), TWO_BYTES( 'u', 'e' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigHashPath = { g_rgchSigHashPath, 32 };


/* "KeyValue/ECCKeyValue/PublicKey" */
const DRM_CHAR g_rgchSigPublicKeyPath [] =
{
    TWO_BYTES( 'K', 'e' ), TWO_BYTES( 'y', 'V' ), TWO_BYTES( 'a', 'l' ), TWO_BYTES( 'u', 'e' ), 
    TWO_BYTES( '/', 'E' ), TWO_BYTES( 'C', 'C' ), TWO_BYTES( 'K', 'e' ), TWO_BYTES( 'y', 'V' ), 
    TWO_BYTES( 'a', 'l' ), TWO_BYTES( 'u', 'e' ), TWO_BYTES( '/', 'P' ), TWO_BYTES( 'u', 'b' ), 
    TWO_BYTES( 'l', 'i' ), TWO_BYTES( 'c', 'K' ), TWO_BYTES( 'e', 'y' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigPublicKeyPath = { g_rgchSigPublicKeyPath, 30 };



/*
** -------------------------------------------------------------
** XML strings used in the parsing of XML encrypted data segment
** -------------------------------------------------------------
*/
/* "KeyInfo" */
const DRM_CHAR g_rgchSigKeyInfoPath [] =
{
    TWO_BYTES( 'K', 'e' ), TWO_BYTES( 'y', 'I' ), TWO_BYTES( 'n', 'f' ), TWO_BYTES( 'o', '\0' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigKeyInfoPath = { g_rgchSigKeyInfoPath, 7 };


/* "KeyInfo/EncryptedKey" */
const DRM_CHAR g_rgchSigEncryptedKeyPath [] =
{
    TWO_BYTES( 'K', 'e' ), TWO_BYTES( 'y', 'I' ), TWO_BYTES( 'n', 'f' ), TWO_BYTES( 'o', '/' ), 
    TWO_BYTES( 'E', 'n' ), TWO_BYTES( 'c', 'r' ), TWO_BYTES( 'y', 'p' ), TWO_BYTES( 't', 'e' ), 
    TWO_BYTES( 'd', 'K' ), TWO_BYTES( 'e', 'y' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigEncryptedKeyPath = { g_rgchSigEncryptedKeyPath, 20 };


/* "CipherData/CipherValue" */
const DRM_CHAR g_rgchSigCipherValuePath [] =
{
    TWO_BYTES( 'C', 'i' ), TWO_BYTES( 'p', 'h' ), TWO_BYTES( 'e', 'r' ), TWO_BYTES( 'D', 'a' ), 
    TWO_BYTES( 't', 'a' ), TWO_BYTES( '/', 'C' ), TWO_BYTES( 'i', 'p' ), TWO_BYTES( 'h', 'e' ), 
    TWO_BYTES( 'r', 'V' ), TWO_BYTES( 'a', 'l' ), TWO_BYTES( 'u', 'e' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING g_dastrSigCipherValuePath = { g_rgchSigCipherValuePath, 22 };

/* "http://www.microsoft.com/DRM/2004/11/mslp" */
const DRM_CHAR  g_rgchRSAURIMSLP [] = 
{
    TWO_BYTES( 'h', 't' ), TWO_BYTES( 't', 'p' ), TWO_BYTES( ':', '/' ), TWO_BYTES( '/', 'w' ), 
    TWO_BYTES( 'w', 'w' ), TWO_BYTES( '.', 'm' ), TWO_BYTES( 'i', 'c' ), TWO_BYTES( 'r', 'o' ), 
    TWO_BYTES( 's', 'o' ), TWO_BYTES( 'f', 't' ), TWO_BYTES( '.', 'c' ), TWO_BYTES( 'o', 'm' ), 
    TWO_BYTES( '/', 'D' ), TWO_BYTES( 'R', 'M' ), TWO_BYTES( '/', '2' ), TWO_BYTES( '0', '0' ), 
    TWO_BYTES( '4', '/' ), TWO_BYTES( '1', '1' ), TWO_BYTES( '/', 'm' ), TWO_BYTES( 's', 'l' ), 
    TWO_BYTES( 'p', '\0' ), TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING  g_dastrRSAURIMSLP = { g_rgchRSAURIMSLP, 41 };

/* "KeyPair" */
const DRM_CHAR  g_rgchTagRSAKeyPair [] = 
{
    TWO_BYTES( 'K', 'e' ), TWO_BYTES( 'y', 'P' ), TWO_BYTES( 'a', 'i' ), TWO_BYTES( 'r', '\0' ), 
    TWO_BYTES( '\0', '\0' )
};
const DRM_ANSI_CONST_STRING  g_dastrTagRSAKeyPair = { g_rgchTagRSAKeyPair, 7 } ;

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmxmr.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcontextsizes.h>
#include <drmxmr.h>

ENTER_PK_NAMESPACE_CODE;

const DRM_EXPORT_VAR XMR_COMMON_INTERNAL_DEFINES g_xmrCommonDefines[XMR_OBJECT_TYPE_MAXIMUM_DEFINED+1] =
{
    { FALSE, XMR_OBJECT_TYPE_INVALID,                                             XMR_FLAGS_NONE                                                                   },    /* XMR_OBJECT_TYPE_INVALID */
    { TRUE,  XMR_OBJECT_TYPE_INVALID,                                             XMR_FLAGS_MUST_UNDERSTAND | XMR_FLAGS_CONTAINER                                  },    /* XMR_OBJECT_TYPE_OUTER_CONTAINER */
    { TRUE,  XMR_OBJECT_TYPE_OUTER_CONTAINER,                                     XMR_FLAGS_MUST_UNDERSTAND | XMR_FLAGS_CONTAINER                                  },    /* XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER */
    { FALSE, XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER,                             XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_MINIMUM_ENVIRONMENT_OBJECT */
    { TRUE,  XMR_OBJECT_TYPE_OUTER_CONTAINER,                                     XMR_FLAGS_CONTAINER                                                              },    /* XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER */
    { FALSE, XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER,                           XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_OUTPUT_PROTECTION_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_KEY_MATERIAL_CONTAINER,                              XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_UPLINK_KID_OBJECT */
    { TRUE,  XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER,                           XMR_FLAGS_MUST_UNDERSTAND | XMR_FLAGS_CONTAINER                                  },    /* XMR_OBJECT_TYPE_EXPLICIT_ANALOG_VIDEO_OUTPUT_PROTECTION_CONTAINER */
    { FALSE, XMR_OBJECT_TYPE_EXPLICIT_ANALOG_VIDEO_OUTPUT_PROTECTION_CONTAINER,   XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_ANALOG_VIDEO_OUTPUT_CONFIGURATION_OBJECT */
    { TRUE,  XMR_OBJECT_TYPE_OUTER_CONTAINER,                                     XMR_FLAGS_MUST_UNDERSTAND | XMR_FLAGS_CONTAINER                                  },    /* XMR_OBJECT_TYPE_KEY_MATERIAL_CONTAINER */
    { FALSE, XMR_OBJECT_TYPE_KEY_MATERIAL_CONTAINER,                              XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_CONTENT_KEY_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_OUTER_CONTAINER,                                     XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_SIGNATURE_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER,                             XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_SERIAL_NUMBER_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER,                             XMR_FLAGS_NONE                                                                   },    /* XMR_OBJECT_TYPE_SETTINGS_OBJECT */
    { TRUE,  XMR_OBJECT_TYPE_OUTER_CONTAINER,                                     XMR_FLAGS_CONTAINER                                                              },    /* XMR_OBJECT_TYPE_COPY_POLICY_CONTAINER */
    { TRUE,  XMR_OBJECT_TYPE_OUTER_CONTAINER,                                     XMR_FLAGS_CONTAINER                                                              },    /* XMR_OBJECT_TYPE_ALLOW_PLAYLISTBURN_POLICY_CONTAINER */
    { FALSE, XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER,                             XMR_FLAGS_NONE                                                                   },    /* XMR_OBJECT_TYPE_INCLUSION_LIST_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER,                             XMR_FLAGS_NONE                                                                   },    /* XMR_OBJECT_TYPE_PRIORITY_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER,                             XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_EXPIRATION_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER,                             XMR_FLAGS_NONE                                                                   },    /* XMR_OBJECT_TYPE_ISSUEDATE_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER,                             XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTUSE_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER,                             XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTSTORE_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER,                             XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_METERING_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER,                           XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_PLAYCOUNT_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_INVALID,                                             XMR_FLAGS_NONE                                                                   },    /* Deprecated: XMR_OBJECT_TYPE_PLAYBACK_EXCLUSION_LIST_OBJECT (Shipped in Emerald Beta 1)*/
    { FALSE, XMR_OBJECT_TYPE_INVALID,                                             XMR_FLAGS_NONE                                                                   },    /* Deprecated: XMR_OBJECT_TYPE_PLAYBACK_INCLUSION_LIST_OBJECT (Shipped in Emerald Beta 1)*/
    { FALSE, XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER,                             XMR_FLAGS_NONE                                                                   },    /* XMR_OBJECT_TYPE_GRACE_PERIOD_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_COPY_POLICY_CONTAINER,                               XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_COPYCOUNT_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_COPY_POLICY_CONTAINER,                               XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_COPY_PROTECTION_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_INVALID,                                             XMR_FLAGS_NONE                                                                   },    /* Deprecated: XMR_OBJECT_TYPE_COPY_EXCLUSION_LIST_OBJECT (Shipped in Emerald Beta 1)*/
    { FALSE, XMR_OBJECT_TYPE_INVALID,                                             XMR_FLAGS_NONE                                                                   },    /* Deprecated: XMR_OBJECT_TYPE_COPY_INCLUSION_LIST_OBJECT (Shipped in Emerald Beta 1)*/
    { FALSE, XMR_OBJECT_TYPE_ALLOW_PLAYLISTBURN_POLICY_CONTAINER,                 XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_PLAYLISTBURN_COUNT_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER,                             XMR_FLAGS_NONE                                                                   },    /* XMR_OBJECT_TYPE_REVOCATION_INFORMATION_VERSION_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_KEY_MATERIAL_CONTAINER,                              XMR_FLAGS_NONE                                                                   },    /* XMR_OBJECT_TYPE_RSA_DEVICE_KEY_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER,                             XMR_FLAGS_NONE                                                                   },    /* XMR_OBJECT_TYPE_SOURCEID_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_INVALID,                                             XMR_FLAGS_NONE                                                                   },    /* Deprecated: XMR_OBJECT_TYPE_EXPLICIT_UNCOMPRESSED_DIGITAL_AUDIO_OUTPUT_PROTECTION_CONTAINER (Shipped in Emerald Beta 1)*/
    { FALSE, XMR_OBJECT_TYPE_INVALID,                                             XMR_FLAGS_NONE                                                                   },    /* Deprecated: XMR_OBJECT_TYPE_UNCOMPRESSED_DIGITAL_AUDIO_OUTPUT_CONFIGURATION_OBJECT (Shipped in Emerald Beta 1)*/
    { TRUE,  XMR_OBJECT_TYPE_OUTER_CONTAINER,                                     XMR_FLAGS_CONTAINER                                                              },    /* XMR_OBJECT_TYPE_REVOCATION_CONTAINER */
    { FALSE, XMR_OBJECT_TYPE_REVOCATION_CONTAINER,                                XMR_FLAGS_NONE                                                                   },    /* XMR_OBJECT_TYPE_RSA_LICENSE_GRANTER_KEY_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_REVOCATION_CONTAINER,                                XMR_FLAGS_NONE                                                                   },    /* XMR_OBJECT_TYPE_USERID_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER,                             XMR_FLAGS_NONE                                                                   },    /* XMR_OBJECT_TYPE_RESTRICTED_SOURCEID_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER ,                            XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_DOMAIN_ID_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_KEY_MATERIAL_CONTAINER,                              XMR_FLAGS_NONE                                                                   },    /* XMR_OBJECT_TYPE_ECC_DEVICE_KEY_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_OUTER_CONTAINER,                                     XMR_FLAGS_NONE                                                                   },    /* XMR_OBJECT_TYPE_GENERATION_NUMBER_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER,                             XMR_FLAGS_NONE                                                                   },    /* XMR_OBJECT_TYPE_POLICY_METADATA_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_KEY_MATERIAL_CONTAINER,                              XMR_FLAGS_NONE                                                                   },    /* XMR_OBJECT_TYPE_OPTIMIZED_CONTENT_KEY_OBJECT */
    { TRUE,  XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER,                           XMR_FLAGS_MUST_UNDERSTAND | XMR_FLAGS_CONTAINER                                  },    /* XMR_OBJECT_TYPE_EXPLICIT_DIGITAL_AUDIO_OUTPUT_PROTECTION_CONTAINER */
    { TRUE,  XMR_OBJECT_TYPE_OUTER_CONTAINER,                                     XMR_FLAGS_CONTAINER | XMR_FLAGS_ALLOW_EXTERNAL_PARSE                             },    /* XMR_OBJECT_TYPE_RINGTONE_POLICY_CONTAINER */
    { FALSE, XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER,                             XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTPLAY_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_EXPLICIT_DIGITAL_AUDIO_OUTPUT_PROTECTION_CONTAINER,  XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_DIGITAL_AUDIO_OUTPUT_CONFIGURATION_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER,                             XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_REVOCATION_INFORMATION_VERSION_2_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER,                             XMR_FLAGS_NONE                                                                   },    /* XMR_OBJECT_TYPE_EMBEDDING_BEHAVIOR_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER,                             XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_SECURITY_LEVEL */
    { TRUE,  XMR_OBJECT_TYPE_OUTER_CONTAINER,                                     XMR_FLAGS_CONTAINER                                                              },    /* XMR_OBJECT_TYPE_COPY_TO_PC_CONTAINER */
    { TRUE,  XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER,                           XMR_FLAGS_CONTAINER                                                              },    /* XMR_OBJECT_TYPE_PLAY_ENABLER_CONTAINER */
    { FALSE, XMR_OBJECT_TYPE_COPY_POLICY_2_CONTAINER,                             XMR_FLAGS_NONE                                                                   },    /* XMR_OBJECT_TYPE_MOVE_ENABLER_OBJECT */
    { TRUE,  XMR_OBJECT_TYPE_COPY_POLICY_2_CONTAINER,                             XMR_FLAGS_CONTAINER                                                              },    /* XMR_OBJECT_TYPE_COPY_ENABLER_CONTAINER */
    { FALSE, XMR_OBJECT_TYPE_PLAY_ENABLER_CONTAINER,                              XMR_FLAGS_NONE                                                                   },    /* XMR_OBJECT_TYPE_PLAY_ENABLER_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_COPY_ENABLER_CONTAINER,                              XMR_FLAGS_NONE                                                                   },    /* XMR_OBJECT_TYPE_COPY_ENABLER_OBJECT */
    { FALSE, XMR_OBJECT_TYPE_KEY_MATERIAL_CONTAINER,                              XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_UPLINK_KID_2_OBJECT */
    { TRUE,  XMR_OBJECT_TYPE_OUTER_CONTAINER,                                     XMR_FLAGS_CONTAINER                                                              },    /* XMR_OBJECT_TYPE_COPY_POLICY_2_CONTAINER */
    { FALSE, XMR_OBJECT_TYPE_COPY_POLICY_2_CONTAINER,                             XMR_FLAGS_MUST_UNDERSTAND                                                        },    /* XMR_OBJECT_TYPE_COPYCOUNT_2_OBJECT */

    /*  NOTE:  When adding new objects or containers to XMR that have the Must Understand flag set, you have to review
               whether that object is required to be understood by WMDRM-ND.  If it is required to be
               understood by WMDRM-ND, then it can be a backward compatability issue and you need to address it.
               If it is not required to be understood by WMDRM-ND, then you need to filter it appropriately in the PC codebase. */
};

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmxmrbuilder.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcontextsizes.h>
#include <byteorder.h>
#include <drmxmr.h>
#include <drmxmrbuilder.h>

ENTER_PK_NAMESPACE_CODE;

const DRM_EXPORT_VAR XMR_BUILDER_INTERNAL_DEFINES g_xmrBuilderDefines[XMR_OBJECT_TYPE_MAXIMUM_DEFINED+1] =
{
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Invalid,            DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  0,                                                     },    /* XMR_OBJECT_TYPE_INVALID */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Container,          DRM_XMR_ParseStructure_OuterContainer,                                  FALSE,    FALSE, SIZEOF( DRM_XMR_OUTER_CONTAINER ),                     },    /* XMR_OBJECT_TYPE_OUTER_CONTAINER */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Container,          DRM_XMR_ParseStructure_GlobalContainer,                                 FALSE,    FALSE, SIZEOF( DRM_XMR_GLOBAL_REQUIREMENTS ),                 },    /* XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER */
    { DRM_XMR_SetDefaults_MinimumEnvironment,        DRM_XMR_Serialize_MinimumEnvironment, DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_MINIMUM_ENVIRONMENT ),                 },    /* XMR_OBJECT_TYPE_MINIMUM_ENVIRONMENT_OBJECT */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Container,          DRM_XMR_ParseStructure_PlaybackContainer,                               FALSE,    TRUE,  SIZEOF( DRM_XMR_PLAYBACK_RIGHTS ),                     },    /* XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER */
    { DRM_XMR_SetDefaults_OPLs,                      DRM_XMR_Serialize_OPLs,               DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_MINIMUM_OUTPUT_PROTECTION_LEVELS ),    },    /* XMR_OBJECT_TYPE_OUTPUT_PROTECTION_OBJECT */
    { DRM_XMR_SetDefaults_UplinkKID,                 DRM_XMR_Serialize_UplinkKID,          DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_UPLINK_KID ),                          },    /* XMR_OBJECT_TYPE_UPLINK_KID_OBJECT */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Container,          DRM_XMR_ParseStructure_ExplicitAnalogVideoOutputProtectionContainer,    FALSE,    TRUE,  SIZEOF( DRM_XMR_EXPLICIT_ANALOG_VIDEO_PROTECTION ),    },    /* XMR_OBJECT_TYPE_EXPLICIT_ANALOG_VIDEO_OUTPUT_PROTECTION_CONTAINER */
    { DRM_XMR_SetDefaults_VideoOutputConfig,         DRM_XMR_Serialize_VideoOutputConfig,  DRM_XMR_ParseStructure_Invalid,                                         TRUE,     TRUE,  SIZEOF( DRM_XMR_VIDEO_OUTPUT_CONFIGURATION ),          },    /* XMR_OBJECT_TYPE_ANALOG_VIDEO_OUTPUT_CONFIGURATION_OBJECT */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Container,          DRM_XMR_ParseStructure_KeyMaterialContainer,                            FALSE,    FALSE, SIZEOF( DRM_XMR_KEY_MATERIAL ),                        },    /* XMR_OBJECT_TYPE_KEY_MATERIAL_CONTAINER */
    { DRM_XMR_SetDefaults_ContentKey,                DRM_XMR_Serialize_ContentKey,         DRM_XMR_ParseStructure_Invalid,                                         FALSE,    FALSE, SIZEOF( DRM_XMR_CONTENT_KEY ),                         },    /* XMR_OBJECT_TYPE_CONTENT_KEY_OBJECT */
    { DRM_XMR_SetDefaults_Invalid,                   DRM_XMR_Serialize_Invalid,            DRM_XMR_ParseStructure_Invalid,                                         FALSE,    FALSE, SIZEOF( DRM_XMR_SIGNATURE ),                           },    /* XMR_OBJECT_TYPE_SIGNATURE_OBJECT */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_BYTEARRAY,          DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_SERIAL_NUMBER ),                       },    /* XMR_OBJECT_TYPE_SERIAL_NUMBER_OBJECT */
    { DRM_XMR_SetDefaults_Rights,                    DRM_XMR_Serialize_WORD,               DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_RIGHTS ),                              },    /* XMR_OBJECT_TYPE_SETTINGS_OBJECT */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Container,          DRM_XMR_ParseStructure_CopyContainer,                                   FALSE,    TRUE,  SIZEOF( DRM_XMR_COPY_RIGHTS ),                         },    /* XMR_OBJECT_TYPE_COPY_POLICY_CONTAINER */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Container,          DRM_XMR_ParseStructure_PlaylistBurnContainer,                           FALSE,    TRUE,  SIZEOF( DRM_XMR_PLAYLIST_BURN_RIGHTS ),                },    /* XMR_OBJECT_TYPE_ALLOW_PLAYLISTBURN_POLICY_CONTAINER */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_GUIDLIST,           DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_INCLUSION_LIST ),                      },    /* XMR_OBJECT_TYPE_INCLUSION_LIST_OBJECT */
    { DRM_XMR_SetDefaults_Priority,                  DRM_XMR_Serialize_DWORD,              DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_PRIORITY ),                            },    /* XMR_OBJECT_TYPE_PRIORITY_OBJECT */
    { DRM_XMR_SetDefaults_Expiration,                DRM_XMR_Serialize_Expiration,         DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_EXPIRATION ),                          },    /* XMR_OBJECT_TYPE_EXPIRATION_OBJECT */
    { DRM_XMR_SetDefaults_Issuedate,                 DRM_XMR_Serialize_DWORD,              DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_ISSUEDATE ),                           },    /* XMR_OBJECT_TYPE_ISSUEDATE_OBJECT */
    { DRM_XMR_SetDefaults_ExpirationAfterFirstUse,   DRM_XMR_Serialize_DWORD_Versioned,    DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_EXPIRATION_AFTER_FIRSTUSE ),           },    /* XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTUSE_OBJECT */
    { DRM_XMR_SetDefaults_ExpirationAfterFirstStore, DRM_XMR_Serialize_DWORD,              DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_EXPIRATION_AFTER_FIRSTSTORE ),         },    /* XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTSTORE_OBJECT */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_GUID,               DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_METERING ),                            },    /* XMR_OBJECT_TYPE_METERING_OBJECT */
    { DRM_XMR_SetDefaults_Playcount,                 DRM_XMR_Serialize_DWORD,              DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_PLAYCOUNT ),                           },    /* XMR_OBJECT_TYPE_PLAYCOUNT_OBJECT */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Invalid,            DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  0,                                                     },    /* Deprecated: XMR_OBJECT_TYPE_PLAYBACK_EXCLUSION_LIST_OBJECT ( Shipped in Emerald Beta 1 )*/
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Invalid,            DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  0,                                                     },    /* Deprecated: XMR_OBJECT_TYPE_PLAYBACK_INCLUSION_LIST_OBJECT ( Shipped in Emerald Beta 1 )*/
    { DRM_XMR_SetDefaults_GracePeriod,               DRM_XMR_Serialize_DWORD,              DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_GRACE_PERIOD ),                        },    /* XMR_OBJECT_TYPE_GRACE_PERIOD_OBJECT */
    { DRM_XMR_SetDefaults_CopyCount,                 DRM_XMR_Serialize_DWORD_Versioned,    DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_COPY_COUNT ),                          },    /* XMR_OBJECT_TYPE_COPYCOUNT_OBJECT */
    { DRM_XMR_SetDefaults_CopyProtectionLevel,       DRM_XMR_Serialize_WORD,               DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_COPY_PROTECTION_LEVEL ),               },    /* XMR_OBJECT_TYPE_COPY_PROTECTION_OBJECT */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Invalid,            DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  0,                                                     },    /* Deprecated: XMR_OBJECT_TYPE_COPY_EXCLUSION_LIST_OBJECT ( Shipped in Emerald Beta 1 )*/
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Invalid,            DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  0,                                                     },    /* Deprecated: XMR_OBJECT_TYPE_COPY_INCLUSION_LIST_OBJECT ( Shipped in Emerald Beta 1 )*/
    { DRM_XMR_SetDefaults_PlaylistBurnRights,        DRM_XMR_Serialize_PlaylistBurnRights, DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_PLAYLIST_BURN_RESTRICTIONS ),          },    /* XMR_OBJECT_TYPE_PLAYLISTBURN_COUNT_OBJECT */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_DWORD_Versioned,    DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_REVOCATION_INFORMATION_VERSION ),      },    /* XMR_OBJECT_TYPE_REVOCATION_INFORMATION_VERSION_OBJECT */
    { DRM_XMR_SetDefaults_RsaPubkey,                 DRM_XMR_Serialize_RsaPubkey,          DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_DEVICE_KEY ),                          },    /* XMR_OBJECT_TYPE_RSA_DEVICE_KEY_OBJECT */
    { DRM_XMR_SetDefaults_SourceID,                  DRM_XMR_Serialize_DWORD,              DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_SOURCEID ),                            },    /* XMR_OBJECT_TYPE_SOURCEID_OBJECT */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Invalid,            DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  0,                                                     },    /* Deprecated: XMR_OBJECT_TYPE_EXPLICIT_UNCOMPRESSED_DIGITAL_AUDIO_OUTPUT_PROTECTION_CONTAINER ( Shipped in Emerald Beta 1 )*/
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Invalid,            DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  0,                                                     },    /* Deprecated: XMR_OBJECT_TYPE_UNCOMPRESSED_DIGITAL_AUDIO_OUTPUT_CONFIGURATION_OBJECT ( Shipped in Emerald Beta 1 )*/
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Container,          DRM_XMR_ParseStructure_RevocationContainer,                             FALSE,    TRUE,  SIZEOF( DRM_XMR_REVOCATION ),                          },    /* XMR_OBJECT_TYPE_REVOCATION_CONTAINER */
    { DRM_XMR_SetDefaults_RsaPubkey,                 DRM_XMR_Serialize_RsaPubkey,          DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_RSA_LICENSE_GRANTER_KEY ),             },    /* XMR_OBJECT_TYPE_RSA_LICENSE_GRANTER_KEY_OBJECT */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_UserID,             DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_USERID ),                              },    /* XMR_OBJECT_TYPE_USERID_OBJECT */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Empty,              DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_RESTRICTED_SOURCEID ),                 },    /* XMR_OBJECT_TYPE_RESTRICTED_SOURCEID_OBJECT */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_DomainID,           DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_DOMAIN_ID ),                           },    /* XMR_OBJECT_TYPE_DOMAIN_ID_OBJECT */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_EccDevicekey,       DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_ECC_DEVICE_KEY ),                      },    /* XMR_OBJECT_TYPE_ECC_DEVICE_KEY_OBJECT */
    { DRM_XMR_SetDefaults_GenerationNumber,          DRM_XMR_Serialize_GenerationNumber,   DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_GENERATION_NUMBER ),                   },    /* XMR_OBJECT_TYPE_GENERATION_NUMBER_OBJECT */
    { DRM_XMR_SetDefaults_PolicyMetadata,            DRM_XMR_Serialize_PolicyMetadata,     DRM_XMR_ParseStructure_PolicyMetadata,                                  TRUE,     TRUE,  SIZEOF( DRM_XMR_POLICY_METADATA ),                     },    /* XMR_OBJECT_TYPE_POLICY_METADATA_OBJECT */
    { DRM_XMR_SetDefaults_OptimizedContentKey,       DRM_XMR_Serialize_OptimizedContentKey,DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_OPTIMIZED_CONTENT_KEY ),               },    /* XMR_OBJECT_TYPE_OPTIMIZED_CONTENT_KEY_OBJECT */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Container,          DRM_XMR_ParseStructure_ExplicitDigitalAudioOutputProtectionContainer,   FALSE,    TRUE,  SIZEOF( DRM_XMR_EXPLICIT_DIGITAL_AUDIO_PROTECTION ),   },    /* XMR_OBJECT_TYPE_EXPLICIT_DIGITAL_AUDIO_OUTPUT_PROTECTION_CONTAINER */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Container,          DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_UNKNOWN_CONTAINER ),                   },    /* XMR_OBJECT_TYPE_RINGTONE_POLICY_CONTAINER */
    { DRM_XMR_SetDefaults_ExpirationAfterFirstUse,   DRM_XMR_Serialize_DWORD_Versioned,    DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_EXPIRATION_AFTER_FIRSTUSE ),           },    /* XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTPLAY_OBJECT */
    { DRM_XMR_SetDefaults_AudioOutputConfig,         DRM_XMR_Serialize_AudioOutputConfig,  DRM_XMR_ParseStructure_Invalid,                                         TRUE,     TRUE,  SIZEOF( DRM_XMR_AUDIO_OUTPUT_CONFIGURATION ),          },    /* XMR_OBJECT_TYPE_DIGITAL_AUDIO_OUTPUT_CONFIGURATION_OBJECT */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_DWORD_Versioned,    DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_REVOCATION_INFORMATION_VERSION ),      },    /* XMR_OBJECT_TYPE_REVOCATION_INFORMATION_VERSION_2_OBJECT */
    { DRM_XMR_SetDefaults_EmbeddingBehavior,         DRM_XMR_Serialize_WORD,               DRM_XMR_ParseStructure_Invalid,                                         FALSE,    FALSE, SIZEOF( DRM_XMR_EMBEDDING_BEHAVIOR ),                  },    /* XMR_OBJECT_TYPE_EMBEDDING_BEHAVIOR_OBJECT */
    { DRM_XMR_SetDefaults_MinimumEnvironment,        DRM_XMR_Serialize_SecurityObject,     DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_MINIMUM_ENVIRONMENT ),                 },    /* XMR_OBJECT_TYPE_SECURITY_LEVEL */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Container,          DRM_XMR_ParseStructure_CopyToPCContainer,                               FALSE,    TRUE,  SIZEOF( DRM_XMR_COPY_TO_PC ),                          },    /* XMR_OBJECT_TYPE_COPY_TO_PC_CONTAINER */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Container,          DRM_XMR_ParseStructure_Invalid,                                         TRUE,     TRUE,  SIZEOF( DRM_XMR_UNKNOWN_CONTAINER ),                   },    /* XMR_OBJECT_TYPE_PLAY_ENABLER_CONTAINER */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_DWORD,              DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_MOVE_ENABLER ),                        },    /* XMR_OBJECT_TYPE_MOVE_ENABLER_OBJECT */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Container,          DRM_XMR_ParseStructure_Invalid,                                         TRUE,     TRUE,  SIZEOF( DRM_XMR_UNKNOWN_CONTAINER ),                   },    /* XMR_OBJECT_COPY_ENABLER_CONTAINER */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_UnknownObject,      DRM_XMR_ParseStructure_Invalid,                                         TRUE,     TRUE,  SIZEOF( DRM_XMR_UNKNOWN_OBJECT),                       },    /* XMR_OBJECT_TYPE_PLAY_ENABLER_OBJECT */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_UnknownObject,      DRM_XMR_ParseStructure_Invalid,                                         TRUE,     TRUE,  SIZEOF( DRM_XMR_UNKNOWN_OBJECT),                       },    /* XMR_OBJECT_TYPE_COPY_ENABLER_OBJECT */
    { DRM_XMR_SetDefaults_UplinkKID,                 DRM_XMR_Serialize_UplinkKID2,         DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_UPLINK_KID ),                          },    /* XMR_OBJECT_TYPE_UPLINK_KID_2_OBJECT */
    { DRM_XMR_SetDefaults_NoOP,                      DRM_XMR_Serialize_Container,          DRM_XMR_ParseStructure_CopyContainer,                                   FALSE,    TRUE,  SIZEOF( DRM_XMR_COPY_RIGHTS ),                         },    /* XMR_OBJECT_TYPE_COPY_POLICY_2_CONTAINER */
    { DRM_XMR_SetDefaults_CopyCount,                 DRM_XMR_Serialize_DWORD_Versioned,    DRM_XMR_ParseStructure_Invalid,                                         FALSE,    TRUE,  SIZEOF( DRM_XMR_COPY_COUNT ),                          },    /* XMR_OBJECT_TYPE_COPYCOUNT_2_OBJECT */
};

/******************************************************************************
**
** Function :   DRM_XMR_CreateExtensibleRestriction
**
** Synopsis :   Returns an XMR object for extensible Restriction
**
** Arguments :  f_pcontextBuilder - builder context
**              f_wType            - object type
**              f_wFlags           - XMR Flags
**              f_pbPolicy         - Policy Data
**              f_wPolicyLen       - Policy data length
**              f_dwSecureDataSize - Size of the data, which may or may not be same as f_dwStateLen
**              f_bStateType       - State data type
**              f_pvState          - State data
**              f_dwStateLen       - State data length
**              f_ppbRestriction   - XMR Restriction returned from the function
**              f_cbRestriction    - Length of above XMR Restriction
**
******************************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_XMR_CreateExtensibleRestriction(
    __in_ecount( 1 )  const                   DRM_XMR_BUILDER_CONTEXT *f_pcontextBuilder,
    __in_bcount( f_wPolicyLen )               DRM_BYTE                *f_pbPolicy,
    __in                                      DRM_WORD                 f_wPolicyLen,
    __in                                      DRM_DWORD                f_dwSecureDataSize,
    __in                                      DRM_BYTE                 f_bStateType,
    __in_bcount( f_dwStateLen )               void                    *f_pvState,
    __in                                      DRM_WORD                 f_dwStateLen,
    __deref_inout_bcount( *f_cbRestriction )  DRM_BYTE               **f_ppbRestriction,
    __inout_ecount( 1 )                       DRM_DWORD               *f_cbRestriction )
{
    DRM_RESULT                  dr               = DRM_SUCCESS;
    DRM_DWORD                   dwObjectSize     = 0;
    DRM_BYTE                   *pbXMRObject      = NULL;
    DRM_DWORD                   dwXMRObjectIndex = 0;

    DRM_XMR_BUILDER_CONTEXT_INTERNAL    *pcontextBuilder = (DRM_XMR_BUILDER_CONTEXT_INTERNAL*) f_pcontextBuilder;

    ChkArg( f_pcontextBuilder  != NULL );
    ChkArg( f_ppbRestriction != NULL );
    ChkArg( f_cbRestriction != NULL );

    dwObjectSize = sizeof(DRM_WORD) +  /* Size of Policy data length field */
                   f_wPolicyLen;

    if( f_dwSecureDataSize > 0 )
    {
        dwObjectSize += sizeof(DRM_BYTE) +  /* Size of State data type field */
                        sizeof(DRM_WORD);   /* Size of State data length field */
    }

    if( f_pvState != NULL )
    {
        dwObjectSize += f_dwStateLen;
    }

    ChkDR( DRM_STK_Alloc( &pcontextBuilder->contextStack,
                          dwObjectSize,
                          (DRM_VOID **)&pbXMRObject ) );

    WORD_TO_NETWORKBYTES( pbXMRObject, dwXMRObjectIndex, f_wPolicyLen );
    dwXMRObjectIndex += SIZEOF( DRM_WORD );

    DRM_BYT_CopyBytes( pbXMRObject,
                       dwXMRObjectIndex,
                       f_pbPolicy,
                       0,
                       f_wPolicyLen );

    dwXMRObjectIndex += f_wPolicyLen;

    if( f_dwSecureDataSize > 0 )
    {
        DRM_BYT_CopyBytes( pbXMRObject,
                           dwXMRObjectIndex,
                           &f_bStateType,
                           0,
                           sizeof(DRM_BYTE) );
        dwXMRObjectIndex += sizeof(DRM_BYTE);

        //
        // Xbox LIVE specific: disabling conversion warning (C4242) after review.
        //
        #pragma warning( disable:4242 )
        WORD_TO_NETWORKBYTES( pbXMRObject, dwXMRObjectIndex, f_dwSecureDataSize );
        #pragma warning( default:4242 )
        //
        // End Xbox LIVE specific
        //

        dwXMRObjectIndex += sizeof(DRM_WORD);
    }

    if( f_pvState != NULL )
    {
        switch( f_bStateType )
        {
        case XMR_EXTENSIBLE_RESTRICTON_STATE_COUNT:
            DWORD_TO_NETWORKBYTES( pbXMRObject, dwXMRObjectIndex, *((DRM_DWORD *)f_pvState) );
            dwXMRObjectIndex += SIZEOF( DRM_DWORD );
            break;
        case XMR_EXTENSIBLE_RESTRICTON_STATE_DATE:
            QWORD_TO_NETWORKBYTES( pbXMRObject, dwXMRObjectIndex, *((DRM_UINT64 *)f_pvState) );
            dwXMRObjectIndex += SIZEOF( DRM_UINT64 );
            break;
        case XMR_EXTENSIBLE_RESTRICTON_STATE_BYTEARRAY:
            DRM_BYT_CopyBytes( pbXMRObject,
                               dwXMRObjectIndex,
                               (DRM_BYTE*)f_pvState,
                               0,
                               f_dwStateLen);
            dwXMRObjectIndex += sizeof(DRM_BYTE);
            break;
        }
        ChkDR( dr );
    }
    *f_ppbRestriction = pbXMRObject;
    *f_cbRestriction = dwObjectSize;

ErrorExit:
    return dr;
}

static DRM_NO_INLINE DRM_BOOL DRM_XMR_IsNativeObject( __in DRM_WORD f_wType )
{
    /* Note: Internal function - No need to check input */

    if( f_wType <= XMR_OBJECT_TYPE_MAXIMUM_DEFINED )
    {
        /*
        ** Note: Values in XMR_OBJECT_TYPE which are greater than XMR_OBJECT_TYPE_MAXIMUM_DEFINED
        **  should still be included in this list.  That way, when XMR_OBJECT_TYPE_MAXIMUM_DEFINED
        **  is increased in a future release (as more native types get introduced), existing
        **  non-native types will already be handled properly by this function.
        */
        if( ! ( ( g_xmrCommonDefines[f_wType].wFlags & XMR_FLAGS_ALLOW_EXTERNAL_PARSE )
                || f_wType == XMR_OBJECT_TYPE_PLAY_ENABLER_CONTAINER
                || f_wType == XMR_OBJECT_TYPE_COPY_ENABLER_CONTAINER
                || f_wType == XMR_OBJECT_TYPE_PLAY_ENABLER_OBJECT
                || f_wType == XMR_OBJECT_TYPE_COPY_ENABLER_OBJECT
                || f_wType == XMR_OBJECT_TYPE_RINGTONE_ENABLER_OBJECT
                || f_wType == XMR_OBJECT_TYPE_EXECUTE_POLICY_CONTAINER ) )
        {
            return TRUE;
        }
    }

    return FALSE;
}

DRM_BOOL DRM_NO_INLINE DRM_XMR_IsDuplicateAllowed(
    __in_ecount( 1 ) const DRM_XMR_BUILDER_LISTNODE *f_plistnode )
{
    /* Note: Internal function - No need to check input */
    DRM_BOOL fRetVal = FALSE;
    if( DRM_XMR_IsNativeObject( f_plistnode->Node.wType ) )
    {
        fRetVal =  g_xmrBuilderDefines[f_plistnode->Node.wType].fDuplicateAllowed;
    }
    else
    {
        DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE *pUnkNode = ( DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE * )f_plistnode;
        fRetVal = pUnkNode->fDuplicateAllowed;
    }

    return fRetVal;
}

/******************************************************************************
**
** Function :   DRM_XMR_GetParent
**
** Synopsis :   Returns the parent object type for a given node.
**
** Arguments :  plistnode - Node for which parent needs to be found
**
******************************************************************************/

DRM_WORD DRM_XMR_GetParent( __in_ecount( 1 ) const DRM_XMR_BUILDER_LISTNODE *f_plistnode )
{
    /* Note: Internal function - No need to check input */
    DRM_WORD wRetVal = XMR_OBJECT_TYPE_INVALID;
    if( DRM_XMR_IsNativeObject( f_plistnode->Node.wType ) )
    {
        wRetVal = g_xmrCommonDefines[f_plistnode->Node.wType].wParent;
    }
    else
    {
        DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE *pUnkNode = ( DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE * )f_plistnode;
        wRetVal = pUnkNode->wParent;
    }

    return wRetVal;
}

/******************************************************************************
**
** Function :   _DRM_XMR_GetBuilderNode
**
** Synopsis :   Returns the builder node for a given XMR object type.
**              Returns null if object is not found
**
** Arguments :  f_pcontextBuilder - builder context
**              f_wType     - object type
**
******************************************************************************/

DRM_NO_INLINE DRM_XMR_BUILDER_NODE* _DRM_XMR_GetBuilderNode(
    __in_ecount( 1 ) const DRM_XMR_BUILDER_CONTEXT_INTERNAL *f_pcontextBuilder,
    __in                   DRM_WORD                          f_wType )
{
    /* Note: Internal function - No need to check input */
    DRM_XMR_BUILDER_NODE  *pNode    = NULL;

    if( DRM_XMR_IsNativeObject( f_wType ) )
    {
        DRMASSERT( f_wType <= XMR_OBJECT_TYPE_MAXIMUM_DEFINED );    /* Ensure we don't buffer overrun rgpObjectNodes array */
        pNode = f_pcontextBuilder->rgpObjectNodes[f_wType];
    }
    else
    {
        DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE *pUnkList = f_pcontextBuilder->pUnknownObjects;
        while( pUnkList != NULL )
        {
            if( pUnkList->listNode.Node.wType == f_wType )
            {
                pNode = &( pUnkList->listNode.Node );
                break;
            }
            pUnkList = pUnkList->pNext;

        }
    }
    return pNode;
}

/******************************************************************************
**
** Function :   DRM_XMR_GetObjectLength
**
** Synopsis :   Estimates the length of an object. For a container, it only
**              returns the length of the base object
**
** Arguments :
**              [f_wType]    : Object type
**              [f_pvObject] : Actual object passed as void (optional)
**
** Returns:
**              Returns the length of the object
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_DWORD DRM_CALL DRM_XMR_GetObjectLength(
    __in             DRM_WORD    f_wType,
    __in_opt const   DRM_VOID   *f_pvObject )
{
    DRM_DWORD cbLength = XMR_BASE_OBJECT_LENGTH;

    switch( f_wType )
    {
    case XMR_OBJECT_TYPE_SETTINGS_OBJECT:
    case XMR_OBJECT_TYPE_COPY_PROTECTION_OBJECT:
    case XMR_OBJECT_TYPE_EMBEDDING_BEHAVIOR_OBJECT:
        cbLength += SIZEOF( DRM_WORD );
        break;
    case XMR_OBJECT_TYPE_PRIORITY_OBJECT:
    case XMR_OBJECT_TYPE_ISSUEDATE_OBJECT:
    case XMR_OBJECT_TYPE_GRACE_PERIOD_OBJECT:
    case XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTUSE_OBJECT:
    case XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTPLAY_OBJECT:
    case XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTSTORE_OBJECT:
    case XMR_OBJECT_TYPE_PLAYCOUNT_OBJECT:
    case XMR_OBJECT_TYPE_COPYCOUNT_OBJECT:
    case XMR_OBJECT_TYPE_COPYCOUNT_2_OBJECT:
    case XMR_OBJECT_TYPE_SOURCEID_OBJECT:
    case XMR_OBJECT_TYPE_REVOCATION_INFORMATION_VERSION_OBJECT:
    case XMR_OBJECT_TYPE_REVOCATION_INFORMATION_VERSION_2_OBJECT:
    case XMR_OBJECT_TYPE_GENERATION_NUMBER_OBJECT:
    case XMR_OBJECT_TYPE_MOVE_ENABLER_OBJECT:
        cbLength += SIZEOF( DRM_DWORD );
        break;
    case XMR_OBJECT_TYPE_EXPIRATION_OBJECT:
    case XMR_OBJECT_TYPE_PLAYLISTBURN_COUNT_OBJECT:
        cbLength += SIZEOF( DRM_DWORD ) * 2;
        break;
    case XMR_OBJECT_TYPE_MINIMUM_ENVIRONMENT_OBJECT:
        cbLength += SIZEOF( DRM_WORD ) + SIZEOF( DRM_DWORD ) * 2;
        break;
    case XMR_OBJECT_TYPE_OUTPUT_PROTECTION_OBJECT:
        cbLength += SIZEOF( DRM_WORD ) * 5;
        break;
    case XMR_OBJECT_TYPE_METERING_OBJECT:
        cbLength += SIZEOF( DRM_GUID );
        break;
    case XMR_OBJECT_TYPE_DOMAIN_ID_OBJECT:
        cbLength += SIZEOF( DRM_DWORD ) * 5;
        break;
    case XMR_OBJECT_TYPE_ANALOG_VIDEO_OUTPUT_CONFIGURATION_OBJECT:
        cbLength += SIZEOF( DRM_GUID );
        cbLength += ( ( DRM_XMR_VIDEO_OUTPUT_CONFIGURATION * )f_pvObject )->cbConfigData;
        break;
    case XMR_OBJECT_TYPE_DIGITAL_AUDIO_OUTPUT_CONFIGURATION_OBJECT:
        cbLength += SIZEOF( DRM_GUID );
        cbLength += ( ( DRM_XMR_AUDIO_OUTPUT_CONFIGURATION * )f_pvObject )->cbConfigData;
        break;
    case XMR_OBJECT_TYPE_CONTENT_KEY_OBJECT:
        cbLength += SIZEOF( DRM_GUID ) + SIZEOF( DRM_WORD ) * 3;
        cbLength += ( ( DRM_XMR_CONTENT_KEY * )f_pvObject )->cbEncryptedKey;
        break;
    case XMR_OBJECT_TYPE_OPTIMIZED_CONTENT_KEY_OBJECT:
        cbLength += SIZEOF( DRM_WORD ) * 2;
        cbLength += ( ( DRM_XMR_OPTIMIZED_CONTENT_KEY * )f_pvObject )->cbEncryptedKey;
        break;
    case XMR_OBJECT_TYPE_SERIAL_NUMBER_OBJECT:
        cbLength += ( ( DRM_XMR_BYTEARRAY * )f_pvObject )->cbData;
        break;
    case XMR_OBJECT_TYPE_INCLUSION_LIST_OBJECT:
        cbLength += SIZEOF( DRM_DWORD );
        cbLength += ( ( DRM_XMR_INCLUSION_LIST * )f_pvObject )->cGUIDs * SIZEOF( DRM_GUID );
        break;
    case XMR_OBJECT_TYPE_RSA_DEVICE_KEY_OBJECT:
    case XMR_OBJECT_TYPE_RSA_LICENSE_GRANTER_KEY_OBJECT:
        cbLength += SIZEOF( DRM_DWORD ) + SIZEOF( DRM_WORD );
        cbLength += ( ( DRM_XMR_RSA_PUBKEY * )f_pvObject )->cbModulus;
        break;
    case XMR_OBJECT_TYPE_UPLINK_KID_OBJECT:
        cbLength += SIZEOF( DRM_GUID );
        cbLength += SIZEOF( DRM_WORD );
        cbLength += ( ( DRM_XMR_UPLINK_KID * )f_pvObject )->cbChainedCheckSum;
        break;
    case XMR_OBJECT_TYPE_UPLINK_KID_2_OBJECT:
        cbLength += SIZEOF( DRM_GUID );
        cbLength += ( 2 * SIZEOF( DRM_WORD ) );
        cbLength += ( ( DRM_XMR_UPLINK_KID * )f_pvObject )->cbChainedCheckSum;
        break;
    case XMR_OBJECT_TYPE_USERID_OBJECT:
        cbLength += ( ( DRM_XMR_USERID * )f_pvObject )->cbUserID;
        break;
    case XMR_OBJECT_TYPE_SIGNATURE_OBJECT:
        /*
        ** Estimate using the largest supported size
        ** SHA256 is larger than OMAC1
        */
        cbLength += XMR_SHA256_HMAC_SIGNATURE_LENGTH + SIZEOF(DRM_WORD) * 2;
        break;
    case XMR_OBJECT_TYPE_ECC_DEVICE_KEY_OBJECT:
        cbLength += 2 * SIZEOF( DRM_WORD );
        cbLength += ( ( DRM_XMR_ECC_DEVICE_KEY * )f_pvObject )->cbKeyData;
        break;
    case XMR_OBJECT_TYPE_POLICY_METADATA_OBJECT:
        cbLength += SIZEOF( DRM_GUID );
        cbLength += ( ( DRM_XMR_POLICY_METADATA_OBJECT * )f_pvObject )->cbPolicyData;
        break;
    case XMR_OBJECT_TYPE_SECURITY_LEVEL:
        cbLength += SIZEOF( DRM_WORD );
        break;
    case XMR_OBJECT_TYPE_RESTRICTED_SOURCEID_OBJECT:
        break;
    case XMR_OBJECT_TYPE_PLAY_ENABLER_OBJECT:
        cbLength += SIZEOF( DRM_GUID );
        break;
    case XMR_OBJECT_TYPE_COPY_ENABLER_OBJECT:
        cbLength += SIZEOF( DRM_GUID );
        break;
    default:
        break;
    }

    return cbLength;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_NoOP
**
** Synopsis :   Return DRM_SUCCESS with no operation
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_NoOP(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    return DRM_SUCCESS;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_Invalid
**
** Synopsis :   Return DRM_E_INVALIDARG with no operation
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_E_INVALIDARG
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_Invalid(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    return DRM_E_INVALIDARG;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_MinimumEnvironment
**
** Synopsis :   Set defaults for a minimum environment object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_MinimumEnvironment(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT                   dr  = DRM_SUCCESS;
    DRM_XMR_MINIMUM_ENVIRONMENT *pMinimumEnvrionment =
                                    ( DRM_XMR_MINIMUM_ENVIRONMENT * )f_pvObject;

    ChkArg( f_pvObject != NULL );

    pMinimumEnvrionment->wMinimumSecurityLevel                = DRM_DEFAULT_MINIMUM_SECURITY_LEVEL;
    pMinimumEnvrionment->dwMinimumAppRevocationListVersion    = 0;
    pMinimumEnvrionment->dwMinimumDeviceRevocationListVersion = 0;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_Expiration
**
** Synopsis :   Set defaults for an expiration object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_Expiration(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT          dr  = DRM_SUCCESS;
    DRM_XMR_EXPIRATION *pExpiration = ( DRM_XMR_EXPIRATION * )f_pvObject;

    ChkArg( f_pvObject != NULL );

    pExpiration->dwBeginDate = 0;
    pExpiration->dwEndDate   = XMR_UNLIMITED;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_OPLs
**
** Synopsis :   Set defaults for an OPL object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_OPLs(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT dr  = DRM_SUCCESS;
    DRM_XMR_MINIMUM_OUTPUT_PROTECTION_LEVELS *pOPLs =
            ( DRM_XMR_MINIMUM_OUTPUT_PROTECTION_LEVELS * )f_pvObject;

    ChkArg( f_pvObject != NULL );

    pOPLs->wAnalogVideo              = DRM_DEFAULT_MINIMUM_SECURITY_LEVEL;
    pOPLs->wCompressedDigitalAudio   = DRM_DEFAULT_MINIMUM_SECURITY_LEVEL;
    pOPLs->wCompressedDigitalVideo   = DRM_DEFAULT_MINIMUM_SECURITY_LEVEL;
    pOPLs->wUncompressedDigitalAudio = DRM_DEFAULT_MINIMUM_SECURITY_LEVEL;
    pOPLs->wUncompressedDigitalVideo = DRM_DEFAULT_MINIMUM_SECURITY_LEVEL;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_VideoOutputConfig
**
** Synopsis :   Set defaults for a video output configuration object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_VideoOutputConfig(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT  dr = DRM_SUCCESS;
    DRM_XMR_VIDEO_OUTPUT_CONFIGURATION *pVideoOutputConfig =
            ( DRM_XMR_VIDEO_OUTPUT_CONFIGURATION * )f_pvObject;

    ChkArg( f_pvObject != NULL );

    pVideoOutputConfig->cbConfigData       = 0;
    pVideoOutputConfig->pbConfigDataBuffer = NULL;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_AudioOutputConfig
**
** Synopsis :   Set defaults for a audio output configuration object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_AudioOutputConfig(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT  dr = DRM_SUCCESS;
    DRM_XMR_AUDIO_OUTPUT_CONFIGURATION *pAudioOutputConfig =
            ( DRM_XMR_AUDIO_OUTPUT_CONFIGURATION * )f_pvObject;

    ChkArg( f_pvObject != NULL );

    pAudioOutputConfig->cbConfigData       = 0;
    pAudioOutputConfig->pbConfigDataBuffer = NULL;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_PolicyMetadata
**
** Synopsis :   Set defaults for the Policy Metadata
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_PolicyMetadata(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT  dr = DRM_SUCCESS;
    DRM_XMR_POLICY_METADATA *pPolicyMetadata =
            ( DRM_XMR_POLICY_METADATA * )f_pvObject;

    ChkArg( f_pvObject != NULL );

    pPolicyMetadata->cPolicyMetadataObjects     = 0;
    pPolicyMetadata->plistPolicyMetadataObjects = NULL;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_PlaylistBurnRights
**
** Synopsis :   Set defaults for a playlist burn rights object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_PlaylistBurnRights(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_XMR_PLAYLIST_BURN_RESTRICTIONS *pPlaylistBurnRights =
            ( DRM_XMR_PLAYLIST_BURN_RESTRICTIONS * )f_pvObject;

    ChkArg( f_pvObject != NULL );

    pPlaylistBurnRights->dwMaxPlaylistBurnCount   = XMR_UNLIMITED;
    pPlaylistBurnRights->dwPlaylistBurnTrackCount = XMR_UNLIMITED;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_ContentKey
**
** Synopsis :   Set defaults for a content key object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_ContentKey(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT           dr          = DRM_SUCCESS;
    DRM_XMR_CONTENT_KEY *pContentKey = ( DRM_XMR_CONTENT_KEY * )f_pvObject;

    ChkArg( f_pvObject != NULL );

    pContentKey->cbEncryptedKey           = 0;
    pContentKey->pbEncryptedKeyBuffer     = NULL;
    pContentKey->wKeyEncryptionCipherType = XMR_ASYMMETRIC_ENCRYPTION_TYPE_RSA_1024;
    pContentKey->wSymmetricCipherType     = XMR_SYMMETRIC_ENCRYPTION_TYPE_AES_128_CTR;

ErrorExit:
    return dr;
}


/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_OptimizedContentKey
**
** Synopsis :   Set defaults for an optimized content key object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_OptimizedContentKey(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT                     dr          = DRM_SUCCESS;
    DRM_XMR_OPTIMIZED_CONTENT_KEY *pContentKey = ( DRM_XMR_OPTIMIZED_CONTENT_KEY * )f_pvObject;

    ChkArg( f_pvObject != NULL );

    pContentKey->cbEncryptedKey           = 0;
    pContentKey->pbEncryptedKeyBuffer     = NULL;
    pContentKey->iEncryptedKey            = 0;
    pContentKey->wKeyEncryptionCipherType = XMR_SYMMETRIC_KEY_ENCRYPTION_TYPE_INVALID;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_RsaPubkey
**
** Synopsis :   Set defaults for an RSA public key object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_RsaPubkey(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT          dr         = DRM_SUCCESS;
    DRM_XMR_RSA_PUBKEY *pRsaPubkey = ( DRM_XMR_RSA_PUBKEY * )f_pvObject;

    ChkArg( f_pvObject != NULL );

    pRsaPubkey->cbModulus       = 0;
    pRsaPubkey->pbModulusBuffer = NULL;
    pRsaPubkey->dwExponent      = 0;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_UplinkKID
**
** Synopsis :   Set defaults for an uplink KID object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_UplinkKID(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT          dr         = DRM_SUCCESS;
    DRM_XMR_UPLINK_KID *pUplinkKID = ( DRM_XMR_UPLINK_KID * )f_pvObject;

    ChkArg( f_pvObject != NULL );

    pUplinkKID->cbChainedCheckSum       = 0;
    pUplinkKID->iChainedCheckSum        = 0;
    pUplinkKID->pbChainedCheckSumBuffer = NULL;
    pUplinkKID->iguidUplinkKID          = 0;
    pUplinkKID->pbguidUplinkKID         = NULL;
    pUplinkKID->wChecksumType           = XMR_UPLINK_CHECKSUM_TYPE_AESOMAC1;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_CopyProtectionLevel
**
** Synopsis :   Set defaults for a copy protection level object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_CopyProtectionLevel(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pvObject != NULL );

    ( ( DRM_XMR_COPY_PROTECTION_LEVEL * )f_pvObject )->wValue = DRM_DEFAULT_MINIMUM_SECURITY_LEVEL;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_CopyCount
**
** Synopsis :   Set defaults for a copy count object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_CopyCount(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pvObject != NULL );

    ( ( DRM_XMR_COPY_COUNT * )f_pvObject )->dwValue = XMR_UNLIMITED;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_Playcount
**
** Synopsis :   Set defaults for a play count object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_Playcount(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pvObject != NULL );

    ( ( DRM_XMR_PLAYCOUNT * )f_pvObject )->dwValue = XMR_UNLIMITED;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_ExpirationAfterFirstStore
**
** Synopsis :   Set defaults for an expiration after first store object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_ExpirationAfterFirstStore(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pvObject != NULL );

    ( ( DRM_XMR_EXPIRATION_AFTER_FIRSTSTORE * )f_pvObject )->dwValue = 0;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_ExpirationAfterFirstUse
**
** Synopsis :   Set defaults for an expiration after first use object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_ExpirationAfterFirstUse(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pvObject != NULL );

    ( ( DRM_XMR_EXPIRATION_AFTER_FIRSTUSE * )f_pvObject )->dwValue = 0;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_Issuedate
**
** Synopsis :   Set defaults for an issue date object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_Issuedate(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pvObject != NULL );

    ( ( DRM_XMR_ISSUEDATE * )f_pvObject )->dwValue = 0;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_GracePeriod
**
** Synopsis :   Set defaults for a grace perios object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_GracePeriod(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pvObject != NULL );

    ( ( DRM_XMR_GRACE_PERIOD * )f_pvObject )->dwValue = 0;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_Priority
**
** Synopsis :   Set defaults for a priority object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_Priority(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pvObject != NULL );

    ( ( DRM_XMR_PRIORITY * )f_pvObject )->dwValue = 0;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_SourceID
**
** Synopsis :   Set defaults for a source id object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_SourceID(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pvObject != NULL );

    ( ( DRM_XMR_SOURCEID * )f_pvObject )->dwValue = XMR_SOURCEID_NONE;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_Rights
**
** Synopsis :   Set defaults for a rights object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_Rights(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pvObject != NULL );

    ( ( DRM_XMR_RIGHTS * )f_pvObject )->wValue = 0;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_GenerationNumber
**
** Synopsis :   Set defaults for the generation number objects
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrdefs.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_GenerationNumber(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pvObject != NULL );

    ( ( DRM_XMR_GENERATION_NUMBER * )f_pvObject )->dwValue = 1;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_SetDefaults_EmbeddingBehavior
**
** Synopsis :   Set defaults for an embedding behavior object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pvObject was NULL
**
** Notes:
**      Prototyped in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_EmbeddingBehavior(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject )
    {
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pvObject != NULL );

    ( ( DRM_XMR_EMBEDDING_BEHAVIOR * )f_pvObject )->wValue = XMR_EMBEDDING_BEHAVIOR_INVALID;

ErrorExit:
    return dr;
}



static DRM_NO_INLINE DRM_VOID _DRM_XMR_Serialize_UnknownBaseObject(
    __in                                                   DRM_WORD    f_wType,
    __in                                                   DRM_WORD    f_wFlags,
    __in                                                   DRM_DWORD   f_dwLength,
    __inout_bcount( XMR_BASE_OBJECT_LENGTH + *f_piBuffer ) DRM_BYTE   *f_pbBuffer,
    __inout_ecount( 1 )                                    DRM_DWORD  *f_piBuffer )
{
    DRM_DWORD dwIndex = *f_piBuffer;
    WORD_TO_NETWORKBYTES( f_pbBuffer, dwIndex, f_wFlags );
    dwIndex += SIZEOF( DRM_WORD );
    WORD_TO_NETWORKBYTES( f_pbBuffer, dwIndex, f_wType );
    dwIndex += SIZEOF( DRM_WORD );
    DWORD_TO_NETWORKBYTES( f_pbBuffer, dwIndex, f_dwLength );
    dwIndex += SIZEOF( DRM_DWORD );
    *f_piBuffer = dwIndex;
}

DRM_API DRM_VOID DRM_CALL DRM_XMR_Serialize_BaseObject(
    __in                                                   DRM_WORD    f_wType,
    __in                                                   DRM_DWORD   f_dwLength,
    __inout_bcount( XMR_BASE_OBJECT_LENGTH + *f_piBuffer ) DRM_BYTE   *f_pbBuffer,
    __inout_ecount( 1 )                                    DRM_DWORD  *f_piBuffer )
{
    DRMASSERT( f_wType <= XMR_OBJECT_TYPE_MAXIMUM_DEFINED );
    if ( f_wType <= XMR_OBJECT_TYPE_MAXIMUM_DEFINED )
    {
        _DRM_XMR_Serialize_UnknownBaseObject( f_wType,
                                              g_xmrCommonDefines[f_wType].wFlags,
                                              f_dwLength,
                                              f_pbBuffer,
                                              f_piBuffer );
    }
}


/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_Invalid(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    return DRM_E_INVALIDARG;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_Container(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT                 dr          = DRM_SUCCESS;
    DRM_XMR_BUILDER_LISTNODE  *pnodeChild  = ( DRM_XMR_BUILDER_LISTNODE * )f_pvObject;
    DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE* pUnkNodeChild = NULL;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );

    /* Serialize all the child nodes */
    while ( pnodeChild != NULL )
    {
        if( DRM_XMR_IsNativeObject( pnodeChild->Node.wType ) )
        {
             ChkBOOL( f_cbBuffer >= *f_piBuffer + XMR_BASE_OBJECT_LENGTH,
                      DRM_E_BUFFERTOOSMALL );

            DRM_XMR_Serialize_BaseObject( pnodeChild->Node.wType,
                                          pnodeChild->Node.cbLength,
                                          f_pbBuffer,
                                          f_piBuffer );

            if ( pnodeChild->Node.pvObject != NULL )
            {
                /* Call Serialize only if this container has any children */
                ChkDR( g_xmrBuilderDefines[pnodeChild->Node.wType].fnSerialize( pnodeChild->Node.pvObject,
                                                                                f_pbBuffer,
                                                                                f_cbBuffer,
                                                                                f_piBuffer ) );
            }
        }
        else
        {
            ChkBOOL( f_cbBuffer >= *f_piBuffer + pnodeChild->Node.cbLength,
                     DRM_E_BUFFERTOOSMALL );


            pUnkNodeChild = (DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE *)pnodeChild;

            /* Now serialize XMR object into the buffer */
            _DRM_XMR_Serialize_UnknownBaseObject( pnodeChild->Node.wType,
                                                  pUnkNodeChild->wFlags,
                                                  pnodeChild->Node.cbLength,
                                                  f_pbBuffer,
                                                  f_piBuffer );

            if( pUnkNodeChild->wFlags & XMR_FLAGS_CONTAINER )
            {
                /* Call Serialize only if this container has any children */
                if ( pnodeChild->Node.pvObject != NULL )
                {
                    ChkDR( DRM_XMR_Serialize_Container( pnodeChild->Node.pvObject,
                                                        f_pbBuffer,
                                                        f_cbBuffer,
                                                        f_piBuffer ) );
                }
            }
            else
            {
                ChkDR( DRM_XMR_Serialize_UnknownObject( pnodeChild,
                                                        f_pbBuffer,
                                                        f_cbBuffer,
                                                        f_piBuffer ) );
            }
        }
        pnodeChild = pnodeChild->pNext;
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_Empty(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    return DRM_SUCCESS;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_WORD(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT    dr     = DRM_SUCCESS;
    DRM_XMR_WORD *pword  = ( DRM_XMR_WORD * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );

    ChkBOOL( f_cbBuffer >= *f_piBuffer + SIZEOF( DRM_WORD ),
             DRM_E_BUFFERTOOSMALL );

    WORD_TO_NETWORKBYTES( f_pbBuffer, *f_piBuffer, pword->wValue );
    *f_piBuffer += SIZEOF( DRM_WORD );

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_DWORD(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT       dr     = DRM_SUCCESS;
    DRM_XMR_DWORD    *pdword  = ( DRM_XMR_DWORD * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );

    ChkBOOL( f_cbBuffer >= *f_piBuffer + SIZEOF( DRM_DWORD ),
             DRM_E_BUFFERTOOSMALL );

    DWORD_TO_NETWORKBYTES( f_pbBuffer, *f_piBuffer, pdword->dwValue );
    *f_piBuffer += SIZEOF( DRM_DWORD );

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_DWORD_Versioned(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT       dr     = DRM_SUCCESS;
    DRM_XMR_DWORD_VERSIONED    *pdword  = ( DRM_XMR_DWORD_VERSIONED * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );

    ChkBOOL( f_cbBuffer >= *f_piBuffer + SIZEOF( DRM_DWORD ),
             DRM_E_BUFFERTOOSMALL );

    DWORD_TO_NETWORKBYTES( f_pbBuffer, *f_piBuffer, pdword->dwValue );
    *f_piBuffer += SIZEOF( DRM_DWORD );

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_GUID(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT       dr    = DRM_SUCCESS;
    DRM_XMR_GUID    *pguid = ( DRM_XMR_GUID * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );
    ChkArg( pguid->pguidBuffer != NULL );

    ChkBOOL( f_cbBuffer >= *f_piBuffer + SIZEOF( DRM_GUID ),
             DRM_E_BUFFERTOOSMALL );

    DRM_BYT_CopyBytes( f_pbBuffer,
                       *f_piBuffer,
                       pguid->pguidBuffer,
                       pguid->iGuid,
                       SIZEOF( DRM_GUID ) );
    *f_piBuffer += SIZEOF( DRM_GUID );

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_GUIDLIST(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT           dr        = DRM_SUCCESS;
    DRM_DWORD            iBuffer   = 0;
    DRM_DWORD            iGuids    = 0;
    DRM_XMR_GUIDLIST    *pguidlist = ( DRM_XMR_GUIDLIST * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );
    ChkArg( pguidlist->pguidBuffer != NULL );

    iBuffer = *f_piBuffer;

    ChkBOOL( f_cbBuffer >= iBuffer + SIZEOF( DRM_DWORD ) + SIZEOF( DRM_GUID ) * pguidlist->cGUIDs,
             DRM_E_BUFFERTOOSMALL );

    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, pguidlist->cGUIDs );
    iBuffer += SIZEOF( DRM_DWORD );

    for ( iGuids = 0; iGuids < pguidlist->cGUIDs; iGuids++ )
    {
        DRM_BYT_CopyBytes( f_pbBuffer,
                           iBuffer,
                           pguidlist->pguidBuffer,
                           pguidlist->iGuids + iGuids*SIZEOF( DRM_GUID ),
                           SIZEOF( DRM_GUID ) );
        iBuffer += SIZEOF( DRM_GUID );
    }
    *f_piBuffer = iBuffer;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_BYTEARRAY(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT           dr  = DRM_SUCCESS;
    DRM_XMR_BYTEARRAY   *pbytearray = ( DRM_XMR_BYTEARRAY * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );
    ChkArg( pbytearray->cbData == 0 || pbytearray->pbDataBuffer != NULL );

    ChkBOOL( f_cbBuffer >= *f_piBuffer + pbytearray->cbData,
             DRM_E_BUFFERTOOSMALL );

    DRM_BYT_CopyBytes( f_pbBuffer,
                       *f_piBuffer,
                       pbytearray->pbDataBuffer,
                       pbytearray->iData,
                       pbytearray->cbData );
    *f_piBuffer += pbytearray->cbData;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_MinimumEnvironment(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT                   dr                  = DRM_SUCCESS;
    DRM_DWORD                    iBuffer             = 0;
    DRM_XMR_MINIMUM_ENVIRONMENT *pMinimumEnvrionment =
                                    ( DRM_XMR_MINIMUM_ENVIRONMENT * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );

    iBuffer = *f_piBuffer;

    ChkBOOL( f_cbBuffer >= iBuffer + 5 * SIZEOF( DRM_WORD ),
             DRM_E_BUFFERTOOSMALL );

    WORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, pMinimumEnvrionment->wMinimumSecurityLevel );
    iBuffer += SIZEOF( DRM_WORD );

    DWORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pMinimumEnvrionment->dwMinimumAppRevocationListVersion );
    iBuffer += SIZEOF( DRM_DWORD );

    DWORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pMinimumEnvrionment->dwMinimumDeviceRevocationListVersion );
    iBuffer += SIZEOF( DRM_DWORD );

    *f_piBuffer = iBuffer;

ErrorExit:
    return dr;
}


DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_SecurityObject(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT                   dr                  = DRM_SUCCESS;
    DRM_DWORD                    iBuffer             = 0;
    DRM_XMR_MINIMUM_ENVIRONMENT *pMinimumEnvrionment =
                                    ( DRM_XMR_MINIMUM_ENVIRONMENT * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );

    ChkBOOL( pMinimumEnvrionment->dwMinimumAppRevocationListVersion == 0, DRM_E_INVALIDLICENSE );
    ChkBOOL( pMinimumEnvrionment->dwMinimumDeviceRevocationListVersion == 0, DRM_E_INVALIDLICENSE );

    iBuffer = *f_piBuffer;

    ChkBOOL( f_cbBuffer >= iBuffer + SIZEOF( DRM_WORD ),
             DRM_E_BUFFERTOOSMALL );

    WORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, pMinimumEnvrionment->wMinimumSecurityLevel );
    iBuffer += SIZEOF( DRM_WORD );

    *f_piBuffer = iBuffer;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_Expiration(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT                  dr          = DRM_SUCCESS;
    DRM_DWORD                   iBuffer     = 0;
    DRM_XMR_EXPIRATION         *pExpiration = ( DRM_XMR_EXPIRATION * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );

    iBuffer = *f_piBuffer;

    ChkBOOL( f_cbBuffer >= iBuffer + 2 * SIZEOF( DRM_DWORD ),
             DRM_E_BUFFERTOOSMALL );

    DWORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pExpiration->dwBeginDate );
    iBuffer += SIZEOF( DRM_DWORD );

    DWORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pExpiration->dwEndDate );
    iBuffer += SIZEOF( DRM_DWORD );

    *f_piBuffer = iBuffer;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_OPLs(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT  dr      = DRM_SUCCESS;
    DRM_DWORD   iBuffer = 0;
    DRM_XMR_MINIMUM_OUTPUT_PROTECTION_LEVELS         *pOPLs =
                        ( DRM_XMR_MINIMUM_OUTPUT_PROTECTION_LEVELS * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );

    iBuffer = *f_piBuffer;

    ChkBOOL( f_cbBuffer >= iBuffer + 5 * SIZEOF( DRM_WORD ),
             DRM_E_BUFFERTOOSMALL );

    WORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pOPLs->wCompressedDigitalVideo );
    iBuffer += SIZEOF( DRM_WORD );

    WORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pOPLs->wUncompressedDigitalVideo );
    iBuffer += SIZEOF( DRM_WORD );

    WORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pOPLs->wAnalogVideo );
    iBuffer += SIZEOF( DRM_WORD );

    WORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pOPLs->wCompressedDigitalAudio );
    iBuffer += SIZEOF( DRM_WORD );

    WORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pOPLs->wUncompressedDigitalAudio );
    iBuffer += SIZEOF( DRM_WORD );

    *f_piBuffer = iBuffer;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_VideoOutputConfig(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT  dr      = DRM_SUCCESS;
    DRM_DWORD   iBuffer = 0;
    DRM_XMR_VIDEO_OUTPUT_CONFIGURATION *pVideoOutputConfig =
                        ( DRM_XMR_VIDEO_OUTPUT_CONFIGURATION * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );
    ChkArg( pVideoOutputConfig->pguidBuffer != NULL );
    ChkArg( pVideoOutputConfig->cbConfigData == 0 || pVideoOutputConfig->pbConfigDataBuffer != NULL );

    iBuffer = *f_piBuffer;

    ChkBOOL( f_cbBuffer >= iBuffer + SIZEOF( DRM_GUID ) + pVideoOutputConfig->cbConfigData,
             DRM_E_BUFFERTOOSMALL );

    DRM_BYT_CopyBytes( f_pbBuffer,
                       iBuffer,
                       pVideoOutputConfig->pguidBuffer,
                       pVideoOutputConfig->iGuid,
                       SIZEOF( DRM_GUID ) );
    iBuffer += SIZEOF( DRM_GUID );

    DRM_BYT_CopyBytes( f_pbBuffer,
                       iBuffer,
                       pVideoOutputConfig->pbConfigDataBuffer,
                       pVideoOutputConfig->iConfigData,
                       pVideoOutputConfig->cbConfigData );
    iBuffer += pVideoOutputConfig->cbConfigData;

    *f_piBuffer = iBuffer;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_AudioOutputConfig(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT  dr      = DRM_SUCCESS;
    DRM_DWORD   iBuffer = 0;
    DRM_XMR_AUDIO_OUTPUT_CONFIGURATION *pAudioOutputConfig =
                        ( DRM_XMR_AUDIO_OUTPUT_CONFIGURATION * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );
    ChkArg( pAudioOutputConfig->pguidBuffer != NULL );
    ChkArg( pAudioOutputConfig->cbConfigData == 0 || pAudioOutputConfig->pbConfigDataBuffer != NULL );

    iBuffer = *f_piBuffer;

    ChkBOOL( f_cbBuffer >= iBuffer + SIZEOF( DRM_GUID ) + pAudioOutputConfig->cbConfigData,
             DRM_E_BUFFERTOOSMALL );

    DRM_BYT_CopyBytes( f_pbBuffer,
                       iBuffer,
                       pAudioOutputConfig->pguidBuffer,
                       pAudioOutputConfig->iGuid,
                       SIZEOF( DRM_GUID ) );
    iBuffer += SIZEOF( DRM_GUID );

    DRM_BYT_CopyBytes( f_pbBuffer,
                       iBuffer,
                       pAudioOutputConfig->pbConfigDataBuffer,
                       pAudioOutputConfig->iConfigData,
                       pAudioOutputConfig->cbConfigData );
    iBuffer += pAudioOutputConfig->cbConfigData;

    *f_piBuffer = iBuffer;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_PolicyMetadata(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT  dr      = DRM_SUCCESS;
    DRM_DWORD   iBuffer = 0;
    DRM_XMR_POLICY_METADATA_OBJECT *pPolicyMetadata =
                        ( DRM_XMR_POLICY_METADATA_OBJECT * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );
    ChkArg( pPolicyMetadata->pMetadataTypeGuidBuffer != NULL );
    ChkArg( pPolicyMetadata->cbPolicyData == 0 || pPolicyMetadata->pbPolicyDataBuffer != NULL );

    iBuffer = *f_piBuffer;

    ChkBOOL( f_cbBuffer >= iBuffer + SIZEOF( DRM_GUID ) + pPolicyMetadata->cbPolicyData,
             DRM_E_BUFFERTOOSMALL );

    DRM_BYT_CopyBytes( f_pbBuffer,
                       iBuffer,
                       pPolicyMetadata->pMetadataTypeGuidBuffer,
                       pPolicyMetadata->iMetadataTypeGuid,
                       SIZEOF( DRM_GUID ) );
    iBuffer += SIZEOF( DRM_GUID );

    DRM_BYT_CopyBytes( f_pbBuffer,
                       iBuffer,
                       pPolicyMetadata->pbPolicyDataBuffer,
                       pPolicyMetadata->iPolicyData,
                       pPolicyMetadata->cbPolicyData );
    iBuffer += pPolicyMetadata->cbPolicyData;

    *f_piBuffer = iBuffer;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_PlaylistBurnRights(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT                  dr      = DRM_SUCCESS;
    DRM_DWORD                   iBuffer = 0;
    DRM_XMR_PLAYLIST_BURN_RESTRICTIONS  *pPlaylistBurnRights =
                            ( DRM_XMR_PLAYLIST_BURN_RESTRICTIONS * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );

    iBuffer = *f_piBuffer;

    ChkBOOL( f_cbBuffer >= iBuffer + 2 * SIZEOF( DRM_DWORD ),
             DRM_E_BUFFERTOOSMALL );

    DWORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pPlaylistBurnRights->dwMaxPlaylistBurnCount );
    iBuffer += SIZEOF( DRM_DWORD );

    DWORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pPlaylistBurnRights->dwPlaylistBurnTrackCount );
    iBuffer += SIZEOF( DRM_DWORD );

    *f_piBuffer = iBuffer;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_UserID(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT  dr      = DRM_SUCCESS;
    DRM_DWORD   iBuffer = 0;
    DRM_XMR_USERID *pUserID =
                        ( DRM_XMR_USERID * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );
    ChkArg( pUserID->cbUserID == 0 || pUserID->pbUserID != NULL );

    iBuffer = *f_piBuffer;

    ChkBOOL( f_cbBuffer >= iBuffer + pUserID->cbUserID,
             DRM_E_BUFFERTOOSMALL );

    DRM_BYT_CopyBytes( f_pbBuffer,
                       iBuffer,
                       pUserID->pbUserID,
                       pUserID->iUserID,
                       pUserID->cbUserID );
    iBuffer += pUserID->cbUserID;

    *f_piBuffer = iBuffer;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_ContentKey(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT           dr             = DRM_SUCCESS;
    DRM_DWORD            iBuffer        = 0;
    DRM_XMR_CONTENT_KEY *pContentKey    = ( DRM_XMR_CONTENT_KEY * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );
    ChkArg( pContentKey->pbguidKeyID != NULL );
    ChkArg( pContentKey->cbEncryptedKey == 0 || pContentKey->pbEncryptedKeyBuffer != NULL );

    iBuffer = *f_piBuffer;

    ChkBOOL( f_cbBuffer >= iBuffer + SIZEOF( DRM_GUID ) + 3 * SIZEOF( DRM_WORD ) + pContentKey->cbEncryptedKey,
             DRM_E_BUFFERTOOSMALL );

    DRM_BYT_CopyBytes( f_pbBuffer,
                       iBuffer,
                       pContentKey->pbguidKeyID,
                       pContentKey->iguidKeyID,
                       SIZEOF( DRM_GUID ) );
    iBuffer += SIZEOF( DRM_GUID );

    WORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pContentKey->wSymmetricCipherType );
    iBuffer += SIZEOF( DRM_WORD );

    WORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pContentKey->wKeyEncryptionCipherType );
    iBuffer += SIZEOF( DRM_WORD );

    WORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pContentKey->cbEncryptedKey );
    iBuffer += SIZEOF( DRM_WORD );

    DRM_BYT_CopyBytes( f_pbBuffer,
                       iBuffer,
                       pContentKey->pbEncryptedKeyBuffer,
                       pContentKey->iEncryptedKey,
                       pContentKey->cbEncryptedKey );
    iBuffer += pContentKey->cbEncryptedKey;

    *f_piBuffer = iBuffer;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_RsaPubkey(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT           dr         = DRM_SUCCESS;
    DRM_DWORD            iBuffer    = 0;
    DRM_XMR_RSA_PUBKEY  *pRsaPubkey = ( DRM_XMR_RSA_PUBKEY * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );
    ChkArg( pRsaPubkey->cbModulus == 0 || pRsaPubkey->pbModulusBuffer != NULL );

    iBuffer = *f_piBuffer;

    ChkBOOL( f_cbBuffer >= iBuffer + 3 * SIZEOF( DRM_WORD ) + pRsaPubkey->cbModulus,
             DRM_E_BUFFERTOOSMALL );

    DWORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pRsaPubkey->dwExponent );
    iBuffer += SIZEOF( DRM_DWORD );

    WORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pRsaPubkey->cbModulus );
    iBuffer += SIZEOF( DRM_WORD );

    DRM_BYT_CopyBytes( f_pbBuffer,
                       iBuffer,
                       pRsaPubkey->pbModulusBuffer,
                       pRsaPubkey->iModulus,
                       pRsaPubkey->cbModulus );
    iBuffer += pRsaPubkey->cbModulus;

    *f_piBuffer = iBuffer;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_DomainID(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT            dr         = DRM_SUCCESS;
    DRM_DWORD             iBuffer    = 0;
    DRM_XMR_DOMAIN_ID    *pdomainID  = ( DRM_XMR_DOMAIN_ID * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );
    ChkArg( pdomainID->pbAccountID != NULL );

    iBuffer = *f_piBuffer;

    ChkBOOL( f_cbBuffer >= iBuffer + SIZEOF( DRM_GUID ) + SIZEOF( DRM_DWORD ),
             DRM_E_BUFFERTOOSMALL );

    DRM_BYT_CopyBytes( f_pbBuffer,
        iBuffer,
        pdomainID->pbAccountID,
        pdomainID->ibAccountID,
        SIZEOF( DRM_GUID ) );
    iBuffer += SIZEOF( DRM_GUID );

    DWORD_TO_NETWORKBYTES( f_pbBuffer, iBuffer, pdomainID->dwRevision );
    iBuffer += SIZEOF( DRM_DWORD );

    *f_piBuffer = iBuffer;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_EccDevicekey(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT              dr      = DRM_SUCCESS;
    DRM_DWORD               iBuffer = 0;
    DRM_XMR_ECC_DEVICE_KEY *pEccPubkey    = ( DRM_XMR_ECC_DEVICE_KEY * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );
    ChkArg( 0 == pEccPubkey->cbKeyData || NULL != pEccPubkey->pbKeyData );

    iBuffer = *f_piBuffer;

    ChkBOOL( f_cbBuffer >= iBuffer + 2 * SIZEOF( DRM_WORD ) + pEccPubkey->cbKeyData,
             DRM_E_BUFFERTOOSMALL );

    WORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pEccPubkey->wEccCurveType );
    iBuffer += SIZEOF( DRM_WORD );

    WORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pEccPubkey->cbKeyData );
    iBuffer += SIZEOF( DRM_WORD );

    DRM_BYT_CopyBytes( f_pbBuffer,
        iBuffer,
        pEccPubkey->pbKeyData,
        pEccPubkey->iKeyData,
        pEccPubkey->cbKeyData );
    iBuffer += pEccPubkey->cbKeyData;

    *f_piBuffer = iBuffer;

ErrorExit:
    return dr;
}


/******************************************************************************
** Function :   DRM_XMR_Serialize_GenerationNumber
**
** Synopsis :   Serializes unknown object
**
** Arguments :
**      [f_pvObject] : Actual object returned as void
**      [f_pbBuffer] : Object Buffer
**      [f_piBuffer] : Index marking beginning of object in the buffer
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**
** Notes :  Prototyped in drmxmrdefs.h
******************************************************************************/

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_GenerationNumber(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT                  dr         = DRM_SUCCESS;
    DRM_DWORD                   iBuffer    = 0;
    DRM_XMR_GENERATION_NUMBER  *pGenerationNumber    = ( DRM_XMR_GENERATION_NUMBER * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );

    iBuffer = *f_piBuffer;

    ChkBOOL( f_cbBuffer >= iBuffer + SIZEOF( DRM_DWORD ),
             DRM_E_BUFFERTOOSMALL );

    DWORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pGenerationNumber->dwValue );
    iBuffer += SIZEOF( DRM_DWORD );

    *f_piBuffer = iBuffer;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Serialize_UnknownObject
**
** Synopsis :   Serializes unknown object
**
** Arguments :
**      [f_pvObject] : Actual object returned as void
**      [f_cbObject] : Size of serialized object
**      [f_pbBuffer] : Object Buffer
**      [f_piBuffer] : Index marking beginning of object in the buffer
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          A parsing error occurred
**
** Notes :  Prototyped in drmxmrbuilder.h
******************************************************************************/

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_UnknownObject(
    __in_ecount( 1 )  const                    DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer )               DRM_BYTE    *f_pbBuffer,
    __in                                       DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )                        DRM_DWORD   *f_piBuffer )
{

    DRM_RESULT            dr              = DRM_SUCCESS;
    DRM_BYTE             *pbObject        = NULL;
    DRM_DWORD             iBuffer         = 0;
    DRM_XMR_BUILDER_NODE* pChildNode      = NULL;
    DRM_DWORD             dwBufferToCopy  = 0;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );

    iBuffer = *f_piBuffer;

    pChildNode= (DRM_XMR_BUILDER_NODE *)f_pvObject;

    if( pChildNode->cbLength < XMR_BASE_OBJECT_LENGTH )
    {
        ChkDR(DRM_E_FAIL);
    }

    dwBufferToCopy = pChildNode->cbLength - XMR_BASE_OBJECT_LENGTH;

    ChkBOOL( (f_cbBuffer >= iBuffer + dwBufferToCopy ),
             DRM_E_BUFFERTOOSMALL );

    pbObject = ( DRM_BYTE * )pChildNode->pvObject;

    DRM_BYT_CopyBytes( f_pbBuffer,
                       *f_piBuffer,
                       pbObject,
                       0,
                       dwBufferToCopy);

    *f_piBuffer += dwBufferToCopy;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_UplinkKID(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT           dr         = DRM_SUCCESS;
    DRM_DWORD            iBuffer    = 0;
    DRM_XMR_UPLINK_KID  *pUplinkKID = ( DRM_XMR_UPLINK_KID * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );
    ChkArg( pUplinkKID->cbChainedCheckSum == 0 || pUplinkKID->pbChainedCheckSumBuffer != NULL );
    ChkArg( pUplinkKID->pbguidUplinkKID != NULL );

    iBuffer = *f_piBuffer;

    ChkBOOL( f_cbBuffer >= iBuffer + SIZEOF( DRM_WORD ) + SIZEOF( DRM_GUID ) + pUplinkKID->cbChainedCheckSum,
             DRM_E_BUFFERTOOSMALL );

    DRM_BYT_CopyBytes( f_pbBuffer,
                       iBuffer,
                       pUplinkKID->pbguidUplinkKID,
                       pUplinkKID->iguidUplinkKID,
                       SIZEOF( DRM_GUID ) );
    iBuffer += SIZEOF( DRM_GUID );

    WORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pUplinkKID->cbChainedCheckSum );
    iBuffer += SIZEOF( DRM_WORD );

    DRM_BYT_CopyBytes( f_pbBuffer,
                       iBuffer,
                       pUplinkKID->pbChainedCheckSumBuffer,
                       pUplinkKID->iChainedCheckSum,
                       pUplinkKID->cbChainedCheckSum );
    iBuffer += pUplinkKID->cbChainedCheckSum;

    *f_piBuffer = iBuffer;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_UplinkKID2(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT           dr         = DRM_SUCCESS;
    DRM_DWORD            iBuffer    = 0;
    DRM_XMR_UPLINK_KID  *pUplinkKID = ( DRM_XMR_UPLINK_KID * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );
    ChkArg( pUplinkKID->cbChainedCheckSum == 0 || pUplinkKID->pbChainedCheckSumBuffer != NULL );
    ChkArg( pUplinkKID->pbguidUplinkKID != NULL );

    iBuffer = *f_piBuffer;

    ChkBOOL( f_cbBuffer >= iBuffer + ( 2 * SIZEOF( DRM_WORD ) ) + SIZEOF( DRM_GUID ) + pUplinkKID->cbChainedCheckSum,
             DRM_E_BUFFERTOOSMALL );

    DRM_BYT_CopyBytes( f_pbBuffer,
                       iBuffer,
                       pUplinkKID->pbguidUplinkKID,
                       pUplinkKID->iguidUplinkKID,
                       SIZEOF( DRM_GUID ) );
    iBuffer += SIZEOF( DRM_GUID );

    WORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pUplinkKID->wChecksumType );
    iBuffer += SIZEOF( DRM_WORD );

    WORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pUplinkKID->cbChainedCheckSum );
    iBuffer += SIZEOF( DRM_WORD );

    DRM_BYT_CopyBytes( f_pbBuffer,
                       iBuffer,
                       pUplinkKID->pbChainedCheckSumBuffer,
                       pUplinkKID->iChainedCheckSum,
                       pUplinkKID->cbChainedCheckSum );
    iBuffer += pUplinkKID->cbChainedCheckSum;

    *f_piBuffer = iBuffer;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Serialize_OptimizedContentKey(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer )
{
    DRM_RESULT                     dr             = DRM_SUCCESS;
    DRM_DWORD                      iBuffer        = 0;
    DRM_XMR_OPTIMIZED_CONTENT_KEY *pContentKey    = ( DRM_XMR_OPTIMIZED_CONTENT_KEY * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkArg( f_piBuffer != NULL );
    ChkArg( pContentKey->cbEncryptedKey == 0 || pContentKey->pbEncryptedKeyBuffer != NULL );

    iBuffer = *f_piBuffer;

    ChkBOOL( f_cbBuffer >= iBuffer + 2 * SIZEOF( DRM_WORD ) + pContentKey->cbEncryptedKey,
             DRM_E_BUFFERTOOSMALL );

    WORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pContentKey->wKeyEncryptionCipherType );
    iBuffer += SIZEOF( DRM_WORD );

    WORD_TO_NETWORKBYTES ( f_pbBuffer, iBuffer, pContentKey->cbEncryptedKey );
    iBuffer += SIZEOF( DRM_WORD );

    DRM_BYT_CopyBytes( f_pbBuffer,
                       iBuffer,
                       pContentKey->pbEncryptedKeyBuffer,
                       pContentKey->iEncryptedKey,
                       pContentKey->cbEncryptedKey );
    iBuffer += pContentKey->cbEncryptedKey;

    *f_piBuffer = iBuffer;

ErrorExit:
    return dr;
}


#define INSERT_OBJECT_IF_VALID( type, object, parenttype )  \
if ( object.fValid )\
{\
    ChkDR( DRM_STK_Alloc( &f_pcontextBuilder->contextStack,\
                          SIZEOF( DRM_XMR_BUILDER_LISTNODE ),\
                          ( DRM_VOID ** )&plistnode ) );\
    plistnode->Node.cbLength = DRM_XMR_GetObjectLength( type, ( DRM_VOID * )&object );\
    plistnode->Node.pvObject = ( DRM_VOID * )&object;\
    plistnode->Node.wType    = type;\
    DRMASSERT( type <= XMR_OBJECT_TYPE_MAXIMUM_DEFINED );    /* Ensure we don't buffer overrun rgpObjectNodes array */\
    f_pcontextBuilder->rgpObjectNodes[type] = &plistnode->Node;\
    if ( g_xmrCommonDefines[type].fIsContainer )\
    {\
        plistnode->Node.pvObject = NULL;\
        ChkDR( g_xmrBuilderDefines[type].fnParseStructure( f_pcontextBuilder, &object ) );\
    }\
    DRMASSERT( parenttype <= XMR_OBJECT_TYPE_MAXIMUM_DEFINED );    /* Ensure we don't buffer overrun rgpObjectNodes array */\
    plistnode->pNext = ( DRM_XMR_BUILDER_LISTNODE * )f_pcontextBuilder->rgpObjectNodes[parenttype]->pvObject;\
    f_pcontextBuilder->rgpObjectNodes[parenttype]->pvObject = ( DRM_VOID * )plistnode;\
    f_pcontextBuilder->rgpObjectNodes[parenttype]->cbLength += plistnode->Node.cbLength;\
}


DRM_NO_INLINE DRM_RESULT _DRM_XMR_InsertUnknownObject(
    IN  OUT DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    IN      DRM_XMR_UNKNOWN_OBJECT              *f_pUnkobject,
    IN      DRM_WORD                             f_wparenttype )

{
    DRM_RESULT                                     dr             = DRM_SUCCESS;
    DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE        *pUnklistnode   = NULL;
    DRM_BYTE                                      *pbUnkXMRObject = NULL;
    DRM_DWORD                                      cbUnkXMRObject = 0;
    ChkArg( f_pcontextBuilder != NULL );
    ChkArg( f_pUnkobject != NULL );

    if ( f_pUnkobject->fValid )
    {
        /* V1 XMR doesn't support unknown objects */
        ChkArg( f_pcontextBuilder->dwVersion >= XMR_VERSION_2 );

        ChkDR( DRM_STK_Alloc( &f_pcontextBuilder->contextStack,
                  SIZEOF( DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE ),
                  ( DRM_VOID ** )&pUnklistnode ) );

        cbUnkXMRObject = f_pUnkobject->cbData;

        ChkDR( DRM_STK_Alloc( &f_pcontextBuilder->contextStack,
                  cbUnkXMRObject,
                  ( DRM_VOID ** )&pbUnkXMRObject ) );

        DRM_BYT_CopyBytes( pbUnkXMRObject,
                           0,
                           f_pUnkobject->pbBuffer,
                           f_pUnkobject->ibData,
                           f_pUnkobject->cbData );

        ZEROMEM( pUnklistnode, SIZEOF( DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE ) );
        pUnklistnode->listNode.Node.wType      = f_pUnkobject->wType;
        pUnklistnode->listNode.Node.cbLength   = cbUnkXMRObject + XMR_BASE_OBJECT_LENGTH;
        pUnklistnode->listNode.Node.pvObject   = pbUnkXMRObject;
        pUnklistnode->wParent                  = f_wparenttype;
        pUnklistnode->pNext                    = NULL;
        pUnklistnode->fDuplicateAllowed        = TRUE;
        pUnklistnode->wFlags                   = f_pUnkobject->wFlags;

        pUnklistnode->pNext    = f_pcontextBuilder->pUnknownObjects;
        f_pcontextBuilder->pUnknownObjects = pUnklistnode;

        if ( DRM_XMR_IsNativeObject( f_wparenttype ) )
        {
            DRMASSERT( f_wparenttype <= XMR_OBJECT_TYPE_MAXIMUM_DEFINED );    /* Ensure we don't buffer overrun rgpObjectNodes array */
            pUnklistnode->listNode.pNext = ( DRM_XMR_BUILDER_LISTNODE * )f_pcontextBuilder->rgpObjectNodes[f_wparenttype]->pvObject;
            f_pcontextBuilder->rgpObjectNodes[f_wparenttype]->pvObject = ( DRM_VOID * )&( pUnklistnode->listNode );
            f_pcontextBuilder->rgpObjectNodes[f_wparenttype]->cbLength += pUnklistnode->listNode.Node.cbLength;
            ChkOverflow( f_pcontextBuilder->rgpObjectNodes[f_wparenttype]->cbLength, pUnklistnode->listNode.Node.cbLength );
        }
        else
        {
            DRM_XMR_BUILDER_NODE* pnodeParent = _DRM_XMR_GetBuilderNode( f_pcontextBuilder, f_wparenttype );

            if( pnodeParent == NULL )
            {
                ChkDR( DRM_E_XMR_OBJECT_NOTFOUND );
            }

            /*
            **  Insert this node into parent's child list
            */

            pUnklistnode->listNode.pNext = ( DRM_XMR_BUILDER_LISTNODE * )pnodeParent->pvObject;
            pnodeParent->pvObject = ( DRM_VOID * )&( pUnklistnode->listNode );
            pnodeParent->cbLength += pUnklistnode->listNode.Node.cbLength;
            ChkOverflow( pnodeParent->cbLength, pUnklistnode->listNode.Node.cbLength );
        }
    }

ErrorExit:
    return dr;
}

DRM_NO_INLINE DRM_RESULT _DRM_XMR_InsertUnknownContainer(
    IN  OUT DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    IN      DRM_XMR_UNKNOWN_CONTAINER           *f_pUnkContainer,
    IN      DRM_WORD                             f_wparenttype )
{
    DRM_RESULT                                     dr                   = DRM_SUCCESS;
    DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE        *pUnklistnode         = NULL;
    DRM_XMR_UNKNOWN_OBJECT                        *pUnkObject           = NULL;
    DRM_XMR_UNKNOWN_CONTAINER                     *pUnkChildContainer   = NULL;

    ChkArg( f_pcontextBuilder != NULL );
    ChkArg( f_pUnkContainer != NULL );

    if ( f_pUnkContainer->fValid )
    {
        /* V1 XMR doesn't support unknown objects */
        ChkArg( f_pcontextBuilder->dwVersion >= XMR_VERSION_2 );

        ChkDR( DRM_STK_Alloc( &f_pcontextBuilder->contextStack,
                  SIZEOF( DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE ),
                  ( DRM_VOID ** )&pUnklistnode ) );

        /* Add the node in the XMR data structure */
        ZEROMEM( pUnklistnode, SIZEOF( DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE ) );
        pUnklistnode->listNode.Node.wType      = f_pUnkContainer->wType;
        pUnklistnode->listNode.Node.cbLength   = XMR_BASE_OBJECT_LENGTH;
        pUnklistnode->listNode.Node.pvObject   = NULL;
        pUnklistnode->wParent                  = f_wparenttype;
        pUnklistnode->pNext                    = NULL;
        pUnklistnode->fDuplicateAllowed        = TRUE;
        pUnklistnode->wFlags                   = f_pUnkContainer->wFlags;

        pUnklistnode->pNext    = f_pcontextBuilder->pUnknownObjects;
        f_pcontextBuilder->pUnknownObjects = pUnklistnode;

        /* Update the size of all the children before updating the size of the parent */
        pUnkObject = f_pUnkContainer->pObject;
        while( pUnkObject != NULL )
        {
            ChkDR( _DRM_XMR_InsertUnknownObject( f_pcontextBuilder,
                                                 pUnkObject,
                                                 pUnklistnode->listNode.Node.wType ) );

            pUnkObject = pUnkObject->pNext;
        }

        pUnkChildContainer = f_pUnkContainer->pUnkChildcontainer;
        while( pUnkChildContainer != NULL )
        {
            if( pUnkChildContainer->fValid )
            {
                ChkDR( _DRM_XMR_InsertUnknownContainer( f_pcontextBuilder,
                                                        pUnkChildContainer,
                                                        pUnkChildContainer->wType) );
            }
            pUnkChildContainer = pUnkChildContainer->pNext;
        }

        /* Update the size of the parent node */
        if ( DRM_XMR_IsNativeObject( f_wparenttype ) )
        {
            DRMASSERT( f_wparenttype <= XMR_OBJECT_TYPE_MAXIMUM_DEFINED );    /* Ensure we don't buffer overrun rgpObjectNodes array */
            pUnklistnode->listNode.pNext = ( DRM_XMR_BUILDER_LISTNODE * )f_pcontextBuilder->rgpObjectNodes[f_wparenttype]->pvObject;
            f_pcontextBuilder->rgpObjectNodes[f_wparenttype]->pvObject = ( DRM_VOID * )&( pUnklistnode->listNode );
            f_pcontextBuilder->rgpObjectNodes[f_wparenttype]->cbLength += pUnklistnode->listNode.Node.cbLength;
        }
        else
        {
            DRM_XMR_BUILDER_NODE* pnodeParent = _DRM_XMR_GetBuilderNode( f_pcontextBuilder, f_wparenttype );

            if( pnodeParent == NULL )
            {
                ChkDR( DRM_E_XMR_OBJECT_NOTFOUND );
            }
            /*
            **  Insert this node into parent's child list
            */
            pUnklistnode->listNode.pNext = ( DRM_XMR_BUILDER_LISTNODE * )pnodeParent->pvObject;
            pnodeParent->pvObject = ( DRM_VOID * )&( pUnklistnode->listNode );
            pnodeParent->cbLength += pUnklistnode->listNode.Node.cbLength;
        }
    }

ErrorExit:
    return dr;
}


/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_Invalid(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject )
{
    return DRM_E_INVALIDARG;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_GlobalContainer(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject )
{
    DRM_RESULT                   dr         = DRM_SUCCESS;
    DRM_XMR_BUILDER_LISTNODE    *plistnode  = NULL;
    DRM_XMR_UNKNOWN_OBJECT      *pUnkObject    = NULL;
    DRM_XMR_GLOBAL_REQUIREMENTS *pglobalContainer =
                        ( DRM_XMR_GLOBAL_REQUIREMENTS * )f_pvObject;
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_EXPIRATION_OBJECT,
                            pglobalContainer->Expiration,
                            XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_INCLUSION_LIST_OBJECT,
                            pglobalContainer->InclusionList,
                            XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTSTORE_OBJECT,
                            pglobalContainer->ExpirationAfterStore,
                            XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_ISSUEDATE_OBJECT,
                            pglobalContainer->IssueDate,
                            XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_GRACE_PERIOD_OBJECT,
                            pglobalContainer->GracePeriod,
                            XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_METERING_OBJECT,
                            pglobalContainer->Metering,
                            XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_PRIORITY_OBJECT,
                            pglobalContainer->Priority,
                            XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_SETTINGS_OBJECT,
                            pglobalContainer->Rights,
                            XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_SERIAL_NUMBER_OBJECT,
                            pglobalContainer->SerialNumber,
                            XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_SOURCEID_OBJECT,
                            pglobalContainer->SourceID,
                            XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_RESTRICTED_SOURCEID_OBJECT,
                            pglobalContainer->RestrictedSourceID,
                            XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER );

    if( f_pcontextBuilder->dwVersion == XMR_VERSION_1 )
    {
        INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_REVOCATION_INFORMATION_VERSION_OBJECT,
                                pglobalContainer->RevocationInformationVersion,
                                XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER );
        INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTUSE_OBJECT,
                                pglobalContainer->ExpirationAfterUse,
                                XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER );
    }
    else
    {
        INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_REVOCATION_INFORMATION_VERSION_2_OBJECT,
                                pglobalContainer->RevocationInformationVersion,
                                XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER );
        INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTPLAY_OBJECT,
                                pglobalContainer->ExpirationAfterUse,
                                XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER );
    }
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_DOMAIN_ID_OBJECT,
                            pglobalContainer->DomainID,
                            XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_EMBEDDING_BEHAVIOR_OBJECT,
                            pglobalContainer->EmbeddingBehavior,
                            XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER );

    /* Minimum Environment Object is not valid in V3+, Security Level Object is used instead */
    if( f_pcontextBuilder->dwVersion < XMR_VERSION_3 )
    {
        INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_MINIMUM_ENVIRONMENT_OBJECT,
                                pglobalContainer->MinimumEnvironment,
                                XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER );
    }
    else
    {
        INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_SECURITY_LEVEL,
                                pglobalContainer->MinimumEnvironment,
                                XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER );
    }

    /*
    ** for Policy Metadata, we don't add object using INSERT_OBJECT_IF_VALID as
    ** we can have multiple Metadata objects without a container of their own
    */
    if( pglobalContainer->PolicyMetadata.fValid )
    {
        ChkDR( DRM_XMR_ParseStructure_PolicyMetadata(  f_pcontextBuilder,
                                                      &pglobalContainer->PolicyMetadata ) );
    }

    if (   !pglobalContainer->SourceID.fValid
        && pglobalContainer->RestrictedSourceID.fValid )
    {
        ChkDR( DRM_E_INVALIDLICENSE );
    }

    pUnkObject = pglobalContainer->pUnknownObjects;
    while( pUnkObject != NULL )
    {
        if( pUnkObject->fValid )
        {
            ChkDR( _DRM_XMR_InsertUnknownObject( f_pcontextBuilder,
                                                 pUnkObject,
                                                 XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER ) );
        }
        pUnkObject = pUnkObject->pNext;
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_OuterContainer(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject )
{
    DRM_RESULT                   dr         = DRM_SUCCESS;
    DRM_XMR_BUILDER_LISTNODE    *plistnode  = NULL;
    DRM_XMR_UNKNOWN_CONTAINER    *pUnkContainer = NULL;

    DRM_XMR_OUTER_CONTAINER     *pouterContainer =
                            ( DRM_XMR_OUTER_CONTAINER * )f_pvObject;
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_GENERATION_NUMBER_OBJECT,
                            pouterContainer->generationNumber,
                            XMR_OBJECT_TYPE_OUTER_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_KEY_MATERIAL_CONTAINER,
                            pouterContainer->containerKeys,
                            XMR_OBJECT_TYPE_OUTER_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_REVOCATION_CONTAINER,
                            pouterContainer->containerRevocation,
                            XMR_OBJECT_TYPE_OUTER_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_ALLOW_PLAYLISTBURN_POLICY_CONTAINER,
                            pouterContainer->containerPlaylistBurnPolicies,
                            XMR_OBJECT_TYPE_OUTER_CONTAINER );
    if( pouterContainer->containerCopyPolicies.fValid )
    {
        if( pouterContainer->containerCopyPolicies.dwVersion == 1 )
        {
            ChkBOOL( f_pcontextBuilder->dwVersion == XMR_VERSION_1, DRM_E_INVALIDLICENSE );
            INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_COPY_POLICY_CONTAINER,
                                    pouterContainer->containerCopyPolicies,
                                    XMR_OBJECT_TYPE_OUTER_CONTAINER );
        }
        else
        {
            INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_COPY_POLICY_2_CONTAINER,
                                    pouterContainer->containerCopyPolicies,
                                    XMR_OBJECT_TYPE_OUTER_CONTAINER );
        }
    }
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER,
                            pouterContainer->containerPlaybackPolicies,
                            XMR_OBJECT_TYPE_OUTER_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_COPY_TO_PC_CONTAINER,
                            pouterContainer->containerCopyToPCPolicies,
                            XMR_OBJECT_TYPE_OUTER_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER,
                            pouterContainer->containerGlobalPolicies,
                            XMR_OBJECT_TYPE_OUTER_CONTAINER );

    pUnkContainer = &( pouterContainer->containerUnknown );
    while( pUnkContainer != NULL )
    {
        if( pUnkContainer->fValid )
        {
            ChkDR( _DRM_XMR_InsertUnknownContainer( f_pcontextBuilder,
                                                    pUnkContainer,
                                                    XMR_OBJECT_TYPE_OUTER_CONTAINER ) );
        }
        pUnkContainer = pUnkContainer->pNext;
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_CopyToPCContainer(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject )
{
    /* This container has no children */
    return DRM_SUCCESS;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_PlaybackContainer(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject )
{
    DRM_RESULT                   dr             = DRM_SUCCESS;
    DRM_XMR_BUILDER_LISTNODE    *plistnode      = NULL;
    DRM_XMR_UNKNOWN_OBJECT      *pUnkObject     = NULL;
    DRM_XMR_PLAYBACK_RIGHTS     *pPlayback      =
                            ( DRM_XMR_PLAYBACK_RIGHTS * )f_pvObject;
    DRM_XMR_UNKNOWN_CONTAINER   *pUnkContainer  = NULL;
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_EXPLICIT_ANALOG_VIDEO_OUTPUT_PROTECTION_CONTAINER,
                            pPlayback->containerExplicitAnalogVideoProtection,
                            XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_EXPLICIT_DIGITAL_AUDIO_OUTPUT_PROTECTION_CONTAINER,
                            pPlayback->containerExplicitDigitalAudioProtection,
                            XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_OUTPUT_PROTECTION_OBJECT,
                            pPlayback->opl,
                            XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_PLAYCOUNT_OBJECT,
                            pPlayback->PlayCount,
                            XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER );

    pUnkObject = pPlayback->pUnknownObjects;
    while( pUnkObject != NULL )
    {
        if( pUnkObject->fValid )
        {
            ChkDR( _DRM_XMR_InsertUnknownObject( f_pcontextBuilder,
                                                 pUnkObject,
                                                 XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER ) );
        }
        pUnkObject = pUnkObject->pNext;
    }
    pUnkContainer = &(pPlayback->UnknownContainer);
    while( pUnkContainer != NULL )
    {
        if( pUnkContainer->fValid )
        {
            ChkDR( _DRM_XMR_InsertUnknownContainer( f_pcontextBuilder,
                                                    pUnkContainer,
                                                    XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER) );
        }
        pUnkContainer = pUnkContainer->pNext;
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_CopyContainer(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject )
{
    DRM_RESULT                   dr             = DRM_SUCCESS;
    DRM_XMR_BUILDER_LISTNODE    *plistnode      = NULL;
    DRM_XMR_UNKNOWN_OBJECT      *pUnkObject     = NULL;
    DRM_XMR_COPY_RIGHTS         *pCopyrights    = ( DRM_XMR_COPY_RIGHTS * )f_pvObject;
    DRM_XMR_UNKNOWN_CONTAINER   *pUnkContainer  = NULL;

    if( pCopyrights->fValid )
    {
        if( pCopyrights->dwVersion == 1 )
        {
            ChkBOOL( f_pcontextBuilder->dwVersion == XMR_VERSION_1, DRM_E_INVALIDLICENSE );
            INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_COPYCOUNT_OBJECT,
                                    pCopyrights->CopyCount,
                                    XMR_OBJECT_TYPE_COPY_POLICY_CONTAINER );
            INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_COPY_PROTECTION_OBJECT,
                                    pCopyrights->CopyProtectionLevel,
                                    XMR_OBJECT_TYPE_COPY_POLICY_CONTAINER );
        }
        else
        {
            INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_COPYCOUNT_2_OBJECT,
                                    pCopyrights->CopyCount,
                                    XMR_OBJECT_TYPE_COPY_POLICY_2_CONTAINER );
            INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_MOVE_ENABLER_OBJECT,
                                    pCopyrights->MoveEnabler,
                                    XMR_OBJECT_TYPE_COPY_POLICY_2_CONTAINER );

            pUnkObject = pCopyrights->pUnknownObjects;
            while( pUnkObject != NULL )
            {
                if( pUnkObject->fValid )
                {
                    ChkDR( _DRM_XMR_InsertUnknownObject( f_pcontextBuilder,
                                                         pUnkObject,
                                                         XMR_OBJECT_TYPE_COPY_POLICY_2_CONTAINER ) );
                }
                pUnkObject = pUnkObject->pNext;
            }

            pUnkContainer = &(pCopyrights->UnknownContainer);
            while( pUnkContainer != NULL )
            {
                if( pUnkContainer->fValid )
                {
                    ChkDR( _DRM_XMR_InsertUnknownContainer( f_pcontextBuilder,
                                                            pUnkContainer,
                                                            XMR_OBJECT_TYPE_COPY_POLICY_2_CONTAINER ) );
                }
                pUnkContainer = pUnkContainer->pNext;
            }
        }
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL
DRM_XMR_ParseStructure_ExplicitAnalogVideoOutputProtectionContainer(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject )
{
    DRM_RESULT                   dr         = DRM_SUCCESS;
    DRM_XMR_BUILDER_LISTNODE    *plistnode  = NULL;
    DRM_XMR_EXPLICIT_ANALOG_VIDEO_PROTECTION    *pcontainerExplicitAnalogVideoProtection =
                        ( DRM_XMR_EXPLICIT_ANALOG_VIDEO_PROTECTION * )f_pvObject;
    DRM_XMR_VIDEO_OUTPUT_CONFIGURATION_LIST     *pConfigList =
                    pcontainerExplicitAnalogVideoProtection->plistOutputConfiguration;

    while( pConfigList != NULL && f_pcontextBuilder->rgpObjectNodes != NULL )
    {
        INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_ANALOG_VIDEO_OUTPUT_CONFIGURATION_OBJECT,
                                pConfigList->Config,
                                XMR_OBJECT_TYPE_EXPLICIT_ANALOG_VIDEO_OUTPUT_PROTECTION_CONTAINER );

        pConfigList = pConfigList->pNext;
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL
DRM_XMR_ParseStructure_ExplicitDigitalAudioOutputProtectionContainer(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject )
{
    DRM_RESULT                   dr         = DRM_SUCCESS;
    DRM_XMR_BUILDER_LISTNODE    *plistnode  = NULL;
    DRM_XMR_EXPLICIT_DIGITAL_AUDIO_PROTECTION    *pcontainerExplicitDigitalAudioProtection =
                        ( DRM_XMR_EXPLICIT_DIGITAL_AUDIO_PROTECTION * )f_pvObject;
    DRM_XMR_AUDIO_OUTPUT_CONFIGURATION_LIST     *pConfigList =
                    pcontainerExplicitDigitalAudioProtection->plistOutputConfiguration;

    while( pConfigList != NULL && f_pcontextBuilder->rgpObjectNodes != NULL )
    {
        INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_DIGITAL_AUDIO_OUTPUT_CONFIGURATION_OBJECT,
                                pConfigList->Config,
                                XMR_OBJECT_TYPE_EXPLICIT_DIGITAL_AUDIO_OUTPUT_PROTECTION_CONTAINER );

        pConfigList = pConfigList->pNext;
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_PolicyMetadata(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject )
{
    DRM_RESULT                        dr = DRM_SUCCESS;
    DRM_XMR_BUILDER_LISTNODE         *plistnode  = NULL;
    DRM_XMR_POLICY_METADATA          *pPolicyMetadataObjects = ( DRM_XMR_POLICY_METADATA * )f_pvObject;
    DRM_XMR_POLICY_METADATA_LIST     *pPolicyMetadataList =  pPolicyMetadataObjects->plistPolicyMetadataObjects;

    while( pPolicyMetadataList != NULL && f_pcontextBuilder->rgpObjectNodes != NULL )
    {
        INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_POLICY_METADATA_OBJECT,
                                pPolicyMetadataList->MetadataObject,
                                XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER );

        pPolicyMetadataList = pPolicyMetadataList->pNext;
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_RevocationContainer(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject )
{
    DRM_RESULT                   dr             = DRM_SUCCESS;
    DRM_XMR_BUILDER_LISTNODE    *plistnode      = NULL;
    DRM_XMR_REVOCATION          *pKeyMaterial   = ( DRM_XMR_REVOCATION * )f_pvObject;

    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_RSA_LICENSE_GRANTER_KEY_OBJECT,
                            pKeyMaterial->RsaLicenseGranterKey,
                            XMR_OBJECT_TYPE_REVOCATION_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_USERID_OBJECT,
                            pKeyMaterial->UserID,
                            XMR_OBJECT_TYPE_REVOCATION_CONTAINER );

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_KeyMaterialContainer(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject )
{
    DRM_RESULT                   dr             = DRM_SUCCESS;
    DRM_XMR_BUILDER_LISTNODE    *plistnode      = NULL;
    DRM_XMR_KEY_MATERIAL        *pKeyMaterial   = ( DRM_XMR_KEY_MATERIAL * )f_pvObject;

    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_CONTENT_KEY_OBJECT,
                            pKeyMaterial->ContentKey,
                            XMR_OBJECT_TYPE_KEY_MATERIAL_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_RSA_DEVICE_KEY_OBJECT,
                            pKeyMaterial->DeviceKey,
                            XMR_OBJECT_TYPE_KEY_MATERIAL_CONTAINER );
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_ECC_DEVICE_KEY_OBJECT,
                            pKeyMaterial->ECCKey,
                            XMR_OBJECT_TYPE_KEY_MATERIAL_CONTAINER );
    if( f_pcontextBuilder->dwVersion == XMR_VERSION_1 )
    {
        INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_UPLINK_KID_OBJECT,
                                pKeyMaterial->UplinkKid,
                                XMR_OBJECT_TYPE_KEY_MATERIAL_CONTAINER );
    }
    else
    {
        INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_UPLINK_KID_2_OBJECT,
                                pKeyMaterial->UplinkKid,
                                XMR_OBJECT_TYPE_KEY_MATERIAL_CONTAINER );
    }
    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_OPTIMIZED_CONTENT_KEY_OBJECT,
                            pKeyMaterial->OptimizedContentKey,
                            XMR_OBJECT_TYPE_KEY_MATERIAL_CONTAINER );

ErrorExit:
    return dr;
}

/******************************************************************************
**
** For summary, see prototype definition in drmxmrbuilder.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_PlaylistBurnContainer(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject )
{
    DRM_RESULT                    dr            = DRM_SUCCESS;
    DRM_XMR_BUILDER_LISTNODE     *plistnode     = NULL;
    DRM_XMR_UNKNOWN_OBJECT      *pUnkObject    = NULL;

    DRM_XMR_PLAYLIST_BURN_RIGHTS *pPlaylistBurn =
                                    ( DRM_XMR_PLAYLIST_BURN_RIGHTS * )f_pvObject;

    INSERT_OBJECT_IF_VALID( XMR_OBJECT_TYPE_PLAYLISTBURN_COUNT_OBJECT,
                            pPlaylistBurn->Restrictions,
                            XMR_OBJECT_TYPE_ALLOW_PLAYLISTBURN_POLICY_CONTAINER );

    pUnkObject = pPlaylistBurn->pUnknownObjects;
    while( pUnkObject != NULL )
    {
        if( pUnkObject->fValid )
        {
            ChkDR( _DRM_XMR_InsertUnknownObject( f_pcontextBuilder,
                                                 pUnkObject,
                                                 XMR_OBJECT_TYPE_ALLOW_PLAYLISTBURN_POLICY_CONTAINER ) );
        }
        pUnkObject = pUnkObject->pNext;
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   _XMR_AddHierarchy
**
** Synopsis :   Adds all the ancestors of a node, and builds the correct
**              hierarchy
**
** Arguments :  f_pcontextBuilder -
**              f_plistnode       - Linked list node containing the node whose
**                      ancestors are to be added to the builder tree
**
** Returns :    DRM_E_XMR_OBJECT_ALREADY_EXISTS if the node already exists, or one
**
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT _XMR_AddHierarchy(
    __inout_ecount( 1 ) DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __inout_ecount( 1 ) DRM_XMR_BUILDER_LISTNODE            *f_plistnode )
{
    /* Note: Internal function - No need to check input */
    DRM_RESULT                  dr              = DRM_SUCCESS;
    DRM_WORD                    wParent         = 0;
    DRM_XMR_BUILDER_LISTNODE   *plistnodeChild  = f_plistnode;

    wParent = DRM_XMR_GetParent( f_plistnode );
    ChkArg( wParent <= XMR_OBJECT_TYPE_MAXIMUM_DEFINED );

    /* This loop adds any ancestors not already included */
    while ( wParent != XMR_OBJECT_TYPE_INVALID )
    {
        ChkArg( wParent <= XMR_OBJECT_TYPE_MAXIMUM_DEFINED );   /* Ensure we don't buffer overrun rgpObjectNodes array */
        if ( f_pcontextBuilder->rgpObjectNodes[wParent] == NULL )
        {
            DRM_XMR_BUILDER_LISTNODE    *plistnode = NULL;

            /*
            **  Add object for this parent
            */
            ChkDR( DRM_STK_Alloc( &f_pcontextBuilder->contextStack,
                                  SIZEOF( DRM_XMR_BUILDER_LISTNODE ),
                                  ( DRM_VOID * * ) &plistnode ) );
            plistnode->Node.wType     = wParent;
            plistnode->Node.cbLength  = XMR_BASE_OBJECT_LENGTH
                                      + plistnodeChild->Node.cbLength;
            plistnode->Node.pvObject  = ( DRM_VOID * )plistnodeChild;
            plistnode->pNext          = NULL;
            f_pcontextBuilder->rgpObjectNodes[wParent] = &plistnode->Node;
            plistnodeChild = plistnode;
            wParent = g_xmrCommonDefines[wParent].wParent;

        }
        else
        {
            DRM_XMR_BUILDER_NODE    *pnodeParent =
                                f_pcontextBuilder->rgpObjectNodes[wParent];
            if ( !DRM_XMR_IsDuplicateAllowed( plistnodeChild ) )
            {
                DRM_XMR_BUILDER_LISTNODE    *plistnode =
                            ( DRM_XMR_BUILDER_LISTNODE * )pnodeParent->pvObject;
                /*
                **  Check whether a duplicate exists
                */
                while( plistnode != NULL )
                {
                    if ( plistnode->Node.wType == plistnodeChild->Node.wType )
                    {
                        ChkDR( DRM_E_XMR_OBJECT_ALREADY_EXISTS );
                    }
                    plistnode = plistnode->pNext;
                }
            }

            /*
            **  Insert this node into parent's child list
            */
            plistnodeChild->pNext = ( DRM_XMR_BUILDER_LISTNODE * )pnodeParent->pvObject;
            pnodeParent->pvObject = ( DRM_VOID * )plistnodeChild;
            pnodeParent->cbLength += plistnodeChild->Node.cbLength;
            break;
        }
    }

    /*
    **  Now update length of all ancestors of the current wParent
    */
    while ( wParent != XMR_OBJECT_TYPE_OUTER_CONTAINER )
    {
        DRMASSERT( g_xmrCommonDefines[wParent].wParent <= XMR_OBJECT_TYPE_MAXIMUM_DEFINED );    /* Ensure we don't buffer overrun rgpObjectNodes array */
        f_pcontextBuilder->rgpObjectNodes[g_xmrCommonDefines[wParent].wParent]->cbLength +=
                                                plistnodeChild->Node.cbLength;
        wParent = g_xmrCommonDefines[wParent].wParent;
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   XMR_AddUnknownHierarchy
**
** Synopsis :   Adds all the ancestors of a node, and builds the correct
**              hierarchy
**
** Arguments :  f_pcontextBuilder -
**              f_plistnode       - Linked list node containing the node whose
**                      ancestors are to be added to the builder tree
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the parameters is invalid
**      DRM_E_XMR_OBJECT_ALREADY_EXISTS
**          Node already exists
**      DRM_E_XMR_OBJECT_NOTFOUND
**          Failed to find the parent node
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL  DRM_XMR_AddUnknownHierarchy (
    __inout_ecount( 1 )  DRM_XMR_BUILDER_CONTEXT_INTERNAL        *f_pcontextBuilder,
    __inout_ecount( 1 )  DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE  *f_plistnode )

{
    /* Note: Internal function - No need to check input */
    DRM_RESULT             dr          = DRM_SUCCESS;
    DRM_WORD               wParent     = 0;
    DRM_XMR_BUILDER_NODE  *pnodeParent = NULL;
    DRM_XMR_BUILDER_NODE  *pnode       = NULL;

    DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE   *plistnodeChild  = f_plistnode;

    ChkArg( f_plistnode->listNode.Node.wType > XMR_OBJECT_TYPE_INVALID );

    wParent =  f_plistnode->wParent;
    pnode   = &( f_plistnode->listNode.Node );

    pnodeParent = _DRM_XMR_GetBuilderNode( f_pcontextBuilder, wParent );
    if( pnodeParent != NULL && ( pnode->wType == pnodeParent->wType ) )
    {
        ChkDR(DRM_E_FAIL);
    }

    if ( DRM_XMR_IsNativeObject( wParent ) )
    {
        /*
        ** All known objects are deferred to _XMR_AddHierarchy
        */
        ChkDR( _XMR_AddHierarchy( f_pcontextBuilder, &( plistnodeChild->listNode ) ) );
    }
    else
    {
        /*
        ** We require that if the parent of the object is not a well known
        ** XMR object, parent should be added before adding the node itself.
        ** Therefore, the builder node for the parent should be non-null
        */

        if( pnodeParent == NULL )
        {
            ChkDR( DRM_E_XMR_OBJECT_NOTFOUND );
        }

        /*
        **  Insert this node into parent's child list
        */

        f_plistnode->listNode.pNext = ( DRM_XMR_BUILDER_LISTNODE * )pnodeParent->pvObject;
        pnodeParent->pvObject = ( DRM_VOID * )&( f_plistnode->listNode );
        pnodeParent->cbLength += f_plistnode->listNode.Node.cbLength;

        /*
        **  Now update length of all ancestors of the current wParent
        */

        while ( wParent != XMR_OBJECT_TYPE_OUTER_CONTAINER )
        {
            if ( DRM_XMR_IsNativeObject( wParent ) )
            {
                DRMASSERT( g_xmrCommonDefines[wParent].wParent <= XMR_OBJECT_TYPE_MAXIMUM_DEFINED );    /* Ensure we don't buffer overrun rgpObjectNodes array */
                f_pcontextBuilder->rgpObjectNodes[g_xmrCommonDefines[wParent].wParent]->cbLength +=
                                                        plistnodeChild->listNode.Node.cbLength;
                wParent = g_xmrCommonDefines[wParent].wParent;
            }
            else
            {
                wParent = DRM_XMR_GetParent((DRM_XMR_BUILDER_LISTNODE *)pnodeParent);
                pnodeParent = _DRM_XMR_GetBuilderNode( f_pcontextBuilder, wParent );
                pnodeParent->cbLength += plistnodeChild->listNode.Node.cbLength;
            }
        }
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_StartLicense
**
** Synopsis :   Builder API used to initiate a builder context
**
** Arguments :  f_pbStack, f_cbStack - Stack used to allocate internal structures
**              f_pidRights - Rights ID ( same as LID in Crescent )
**              f_pcontextBuilder
**
** Notes    :   Memory will not be freed from this stack. The caller should just
**              throw away this stack buffer after the license has been built.
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_StartLicense(
    __inout_bcount( f_cbStack ) DRM_BYTE                *f_pbStack,
    __in                        DRM_DWORD                f_cbStack,
    __in_ecount( 1 )      const DRM_ID                  *f_pidRights,
    __in                        DRM_DWORD                f_dwVersion,
    __inout_ecount( 1 )         DRM_XMR_BUILDER_CONTEXT *f_pcontextBuilder )
{
    DRM_RESULT                           dr  = DRM_SUCCESS;
    DRM_XMR_BUILDER_NODE                *pnodeOuterContainer  = NULL;
    DRM_XMR_BUILDER_CONTEXT_INTERNAL    *pcontextBuilder =
                            ( DRM_XMR_BUILDER_CONTEXT_INTERNAL * )f_pcontextBuilder;

    ChkArg( pcontextBuilder != NULL );
    ChkArg( f_pidRights     != NULL );
    ChkArg( f_dwVersion     == XMR_VERSION_1
         || f_dwVersion     == XMR_VERSION_3 );  /* XMR_VERSION_2 is not supported */

    pcontextBuilder->pidRights              = f_pidRights;
    pcontextBuilder->dwVersion              = f_dwVersion;
    pcontextBuilder->contextStack.cbStack   = f_cbStack;
    pcontextBuilder->contextStack.pbStack   = f_pbStack;
    pcontextBuilder->contextStack.nStackTop = 0;
    pcontextBuilder->pUnknownObjects        = NULL;

    /*
    **  Add a table for list of containers
    */
    ChkDR( DRM_STK_Alloc( &pcontextBuilder->contextStack,
                          SIZEOF( DRM_XMR_BUILDER_NODE * ) * ( XMR_OBJECT_TYPE_MAXIMUM_DEFINED + 1 ),
                          ( DRM_VOID * * )&pcontextBuilder->rgpObjectNodes ) );
    ZEROMEM( pcontextBuilder->rgpObjectNodes,
             SIZEOF( DRM_XMR_BUILDER_NODE * ) * ( XMR_OBJECT_TYPE_MAXIMUM_DEFINED + 1 ) );

    /*
    **  Add the outer container object
    */
    ChkDR( DRM_STK_Alloc( &pcontextBuilder->contextStack,
                          SIZEOF( DRM_XMR_BUILDER_NODE ),
                          ( DRM_VOID * * )&pnodeOuterContainer ) );
    pnodeOuterContainer->wType     = XMR_OBJECT_TYPE_OUTER_CONTAINER;
    pnodeOuterContainer->cbLength  = XMR_BASE_OBJECT_LENGTH;

    /*
    **  Add length of signature object to outer container. Signature object will
    **  not be added explicitly by the caller
    **  The length of the signature object is determined by the license version
    */
    pnodeOuterContainer->cbLength += XMR_BASE_OBJECT_LENGTH + SIZEOF( DRM_WORD ) * 2;

    /* XMR_VERSION_2 is not supported */
    switch( f_dwVersion )
    {
    case XMR_VERSION_1: /* Fall through */
    case XMR_VERSION_3:
        pnodeOuterContainer->cbLength += XMR_AES_OMAC_SIGNATURE_LENGTH;
        break;
    default:
        AssertChkArg( FALSE );
        break;
    }

    pnodeOuterContainer->pvObject  = NULL;
    pcontextBuilder->rgpObjectNodes[XMR_OBJECT_TYPE_OUTER_CONTAINER] = pnodeOuterContainer;

ErrorExit:
    return dr;
}


/******************************************************************************
**
** Function :   DRM_XMR_InitializeObject
**
** Synopsis :   Sets the defaults for a particular object. Caller can then set
**              the required values it knows about
**
** Arguments :  f_wObjectType   - type
**              f_pvObject      - Object passed as a void
**
** Note      :  This method memsets the entire structure of the objects to 0. It
**              then sets the fValid flag on.
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XMR_InitializeObject(
    __in                DRM_WORD    f_wObjectType,
    __inout_ecount( 1 ) DRM_VOID   *f_pvObject )
{
    DRM_RESULT      dr      = DRM_SUCCESS;
    /*  First field of each structure must be the fValid flag */
    DRM_BOOL       *pfValid = ( DRM_BOOL * )f_pvObject;

    ChkArg( f_wObjectType > XMR_OBJECT_TYPE_INVALID );
    ChkArg( f_wObjectType <= XMR_OBJECT_TYPE_MAXIMUM_DEFINED );
    ChkArg( f_pvObject != NULL || g_xmrCommonDefines[f_wObjectType].fIsContainer );

    /*
    **  Set the defaults
    */
    if ( f_pvObject != NULL )
    {
        MEMSET( ( DRM_BYTE * )f_pvObject, 0, g_xmrBuilderDefines[f_wObjectType].cbStructureSize );
        ( *pfValid ) = TRUE;
        ChkDR( g_xmrBuilderDefines[f_wObjectType].fnSetDefaults( f_pvObject ) );
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_AddObject
**
** Synopsis :   Adds any object to the builder tree. This API can be used to add
**              either a leaf object, or a container structure
**
** Arguments :  f_pcontextBuilder   -
**              f_wObjectType   - type
**              f_pvObject      - Object passed as a void. This can be NULL, if
**                  the object is a container.
** Returns :    Unless a duplicate is permissible for this type, adding a
**              duplicate object will cause an error. If a container has been
**              explicitly added and then one of it's child nodes is added
**              separately, it is treated as a duplicate as well
**
** Notes :      The caller can add an empty container to a license.
**              The caller MUST make sure that no part of the object is freed,
**              or goes out of scope before the license is built. This is
**              because the internal builder context refers to the original
**              object ( instead of making a copy for efficiency reasons )
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_AddObject(
    __inout_ecount( 1 )    DRM_XMR_BUILDER_CONTEXT *f_pcontextBuilder,
    __in                   DRM_WORD                 f_wObjectType,
    __in_ecount( 1 ) const DRM_VOID                *f_pvObject )
{
    DRM_RESULT                  dr  = DRM_SUCCESS;
    DRM_XMR_BUILDER_LISTNODE   *plistnode  = NULL;
    DRM_XMR_BUILDER_CONTEXT_INTERNAL *pcontextBuilder =
                        ( DRM_XMR_BUILDER_CONTEXT_INTERNAL * ) f_pcontextBuilder;

    ChkArg( pcontextBuilder != NULL );
    ChkArg( f_wObjectType >  XMR_OBJECT_TYPE_INVALID );
    ChkArg( f_wObjectType <= XMR_OBJECT_TYPE_MAXIMUM_DEFINED );
    ChkArg( f_pvObject != NULL || g_xmrCommonDefines[f_wObjectType].fIsContainer );
    ChkArg( pcontextBuilder->rgpObjectNodes != NULL );

    if ( f_wObjectType != XMR_OBJECT_TYPE_OUTER_CONTAINER )
    {
        ChkDR( DRM_STK_Alloc( &pcontextBuilder->contextStack,
                              SIZEOF( DRM_XMR_BUILDER_LISTNODE ),
                              ( DRM_VOID ** )&plistnode ) );
        plistnode->Node.cbLength = DRM_XMR_GetObjectLength( f_wObjectType, f_pvObject );
        plistnode->Node.pvObject = f_pvObject;
        plistnode->Node.wType    = f_wObjectType;
        plistnode->pNext         = NULL;
        DRMASSERT( f_wObjectType <= XMR_OBJECT_TYPE_MAXIMUM_DEFINED );    /* Ensure we don't buffer overrun rgpObjectNodes array */
        pcontextBuilder->rgpObjectNodes[f_wObjectType] = &plistnode->Node;
        if ( g_xmrCommonDefines[f_wObjectType].fIsContainer && ( f_pvObject != NULL ) )
        {
            /*
            **  This will add all the children of this container and also update
            **  the length of f_pvObject
            */
            plistnode->Node.pvObject = NULL;
            ChkDR( g_xmrBuilderDefines[f_wObjectType].fnParseStructure( pcontextBuilder, f_pvObject ) );
        }
        ChkDR( _XMR_AddHierarchy( pcontextBuilder, plistnode ) );
    }
    else
    {
        ChkDR( g_xmrBuilderDefines[XMR_OBJECT_TYPE_OUTER_CONTAINER].fnParseStructure( pcontextBuilder, f_pvObject ) );
    }

ErrorExit:
    if ( DRM_FAILED( dr ) && ( plistnode != NULL ) )
    {
        ( void ) DRM_STK_Free( &pcontextBuilder->contextStack,
                             ( DRM_VOID ** )&plistnode );
    }
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_AddUnknownObject
**
** Synopsis :   Adds unknown object to the builder tree. This API can be used to add
**              either a leaf object, or a container structure
**
** Arguments :  f_pcontextBuilder   -
**              f_wObjectType   - type
**              f_pvObject      - Object passed as a void. This can be NULL, if
**                  the object is a container.
** Returns :    Unless a duplicate is permissible for this type, adding a
**              duplicate object will cause an error. If a container has been
**              explicitly added and then one of it's child nodes is added
**              separately, it is treated as a duplicate as well
**
** Notes :      The caller can add an empty container to a license.
**              The caller MUST make sure that no part of the object is freed,
**              or goes out of scope before the license is built. This is
**              because the internal builder context refers to the original
**              object ( instead of making a copy for efficiency reasons )
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XMR_AddUnknownObject(
    __inout_ecount( 1 )                 DRM_XMR_BUILDER_CONTEXT *f_pcontextBuilder,
    __in                                DRM_WORD                 f_wObjectType,
    __in                                DRM_BOOL                 f_fDuplicateAllowed,
    __in                                DRM_WORD                 f_wParent,
    __in                                DRM_WORD                 f_wFlags,
    __in_bcount_opt( f_cbObject ) const DRM_BYTE                *f_pbObject,
    __in                                DRM_DWORD                f_cbObject )
{
    DRM_RESULT dr  = DRM_SUCCESS;
    DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE *plistnode  = NULL;
    DRM_XMR_BUILDER_CONTEXT_INTERNAL       *pcontextBuilder =
            ( DRM_XMR_BUILDER_CONTEXT_INTERNAL * ) f_pcontextBuilder;

    ChkArg( pcontextBuilder != NULL );

    ChkArg( f_wObjectType > XMR_OBJECT_TYPE_INVALID );

    ChkArg( f_pbObject != NULL || f_wFlags & XMR_FLAGS_CONTAINER );


    if( !( ( f_wFlags & XMR_FLAGS_ALLOW_EXTERNAL_PARSE )
        || f_wObjectType == XMR_OBJECT_TYPE_PLAY_ENABLER_CONTAINER
        || f_wObjectType == XMR_OBJECT_TYPE_COPY_ENABLER_CONTAINER
        || f_wObjectType == XMR_OBJECT_TYPE_PLAY_ENABLER_OBJECT
        || f_wObjectType == XMR_OBJECT_TYPE_COPY_ENABLER_OBJECT ) )
    {
        ChkDR( DRM_E_XMR_INVALID_UNKNOWN_OBJECT );
    }

    ChkDR( DRM_STK_Alloc( &pcontextBuilder->contextStack,
        SIZEOF( DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE ),
        ( DRM_VOID ** )&plistnode ) );

    ZEROMEM( plistnode, SIZEOF( DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE ) );

    plistnode->listNode.Node.wType      = f_wObjectType;
    plistnode->listNode.Node.cbLength   = XMR_BASE_OBJECT_LENGTH + f_cbObject;
    plistnode->listNode.Node.pvObject   = f_pbObject;
    plistnode->wParent                  = f_wParent;
    plistnode->pNext                    = NULL;
    plistnode->fDuplicateAllowed        = f_fDuplicateAllowed;
    plistnode->wFlags                   = f_wFlags;

    /*
    ** Add it to linked list
    */
    plistnode->pNext    = pcontextBuilder->pUnknownObjects;
    pcontextBuilder->pUnknownObjects = plistnode;

    ChkDR( DRM_XMR_AddUnknownHierarchy ( pcontextBuilder, plistnode ) );

ErrorExit:
    if ( DRM_FAILED( dr ) && ( plistnode != NULL ) )
    {
        ( void ) DRM_STK_Free( &pcontextBuilder->contextStack,
            ( DRM_VOID ** )&plistnode );
    }
    return dr;
}

static DRM_VOID DRM_CALL _XMR_FilterNotMustUnderstandUnknownObjects(
    DRM_XMR_UNKNOWN_OBJECT      *f_pUnkObject )
{
    while( f_pUnkObject != NULL )
    {
        if( ( f_pUnkObject->wFlags & XMR_FLAGS_MUST_UNDERSTAND ) == 0 )
        {
            f_pUnkObject->fValid = FALSE;
        }
        f_pUnkObject = f_pUnkObject->pNext;
    }
}

static DRM_VOID DRM_CALL _XMR_FilterNotMustUnderstandUnknownContainers(
    DRM_XMR_UNKNOWN_CONTAINER      *f_pUnkContainer )
{
    while( f_pUnkContainer != NULL )
    {
        /* Only filter unknown containers that are NOT must understand */
        if( ( f_pUnkContainer->wFlags & XMR_FLAGS_MUST_UNDERSTAND ) == 0 )
        {
            f_pUnkContainer->fValid = FALSE;
        }
        if( f_pUnkContainer->fValid )
        {
            _XMR_FilterNotMustUnderstandUnknownObjects( f_pUnkContainer->pObject );
        }

        f_pUnkContainer = f_pUnkContainer->pNext;
    }
}

DRM_API DRM_RESULT DRM_CALL DRM_XMR_FilterNonMustUnderstandObjectsByVersion(
    __in_ecount( 1 )       DRM_XMR_LICENSE  *f_pXmrLicense,
    __in                   DRM_DWORD         f_dwVersion )
{
    DRM_RESULT                   dr                 = DRM_SUCCESS;
    ChkArg( f_pXmrLicense != NULL );
    ChkArg( f_dwVersion   == XMR_VERSION_1
         || f_dwVersion   == XMR_VERSION_3 ); /* XMR_VERSION_2 is not supported */

    if( f_dwVersion == XMR_VERSION_3 )
    {
        /* Nothing to filter for version 3 */
        goto ErrorExit;
    }

    f_pXmrLicense->containerOuter.generationNumber.fValid = FALSE;
    f_pXmrLicense->containerOuter.containerGlobalPolicies.PolicyMetadata.fValid = FALSE;
    f_pXmrLicense->containerOuter.containerGlobalPolicies.EmbeddingBehavior.fValid = FALSE;
    f_pXmrLicense->containerOuter.containerCopyToPCPolicies.fValid = FALSE;

    _XMR_FilterNotMustUnderstandUnknownContainers(
             &f_pXmrLicense->containerOuter.containerUnknown);

    if( f_pXmrLicense->containerOuter.containerGlobalPolicies.fValid )
    {
        _XMR_FilterNotMustUnderstandUnknownObjects(
            f_pXmrLicense->containerOuter.containerGlobalPolicies.pUnknownObjects );
    }
    if( f_pXmrLicense->containerOuter.containerCopyPolicies.fValid )
    {
        _XMR_FilterNotMustUnderstandUnknownObjects(
            f_pXmrLicense->containerOuter.containerCopyPolicies.pUnknownObjects );
    }
    if( f_pXmrLicense->containerOuter.containerPlaybackPolicies.fValid )
    {
        _XMR_FilterNotMustUnderstandUnknownObjects(
            f_pXmrLicense->containerOuter.containerPlaybackPolicies.pUnknownObjects );
    }
    if( f_pXmrLicense->containerOuter.containerPlaylistBurnPolicies.fValid )
    {
        _XMR_FilterNotMustUnderstandUnknownObjects(
            f_pXmrLicense->containerOuter.containerPlaylistBurnPolicies.pUnknownObjects );
    }

    f_pXmrLicense->containerOuter.containerKeys.ECCKey.fValid = FALSE;
    f_pXmrLicense->containerOuter.containerKeys.OptimizedContentKey.fValid = FALSE;

    /*
    ** The following V2 objects are must understand and are therefore NOT filtered by this function.
    **
    ** f_pXmrLicense->containerOuter.containerGlobalPolicies.DomainID.fValid = FALSE;
    ** f_pXmrLicense->containerOuter.containerPlaybackPolicies.containerExplicitDigitalAudioProtection.fValid = FALSE;
    */

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_FinishLicense
**
** Synopsis :   This method takes all the information in the builder context,
**              figures out the appropriate objects and containers to be added
**              to the license, and builds the appropriate license. This method
**              will also verify that all the mandatory objects have been added
**              to the license, before this method is called.
**
** Arguments :  f_pcontextBuilder -
**              f_pvSignatureContext  - Context needed by caller to retrieve
**                                    appropriate integrity key
**              f_eSignature      - Signature type that the callback function will perform
**              f_pfnSignature    - Callback function to create signature using
**                                  Integrity key. Integrity key is not passed to
**                                  this function for security reasons.
**              f_pbLicense       - Buffer for license
**              f_pcbLicense      - Size of license buffer. If not sufficient,
**                  the method returns an error and sets this to the required
**                  length
**
** Returns :    DRM_E_BUFFERTOOSMALL, DRM_E_XMR_REQUIRED_OBJECT_MISSING
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_FinishLicense (
    __in_ecount( 1 ) const              DRM_XMR_BUILDER_CONTEXT *f_pcontextBuilder,
    __in_ecount( 1 ) const              DRM_VOID                *f_pvSignatureContext,
    __in                                DRM_XMR_CB_SIGNATURE     f_pfnSignature,
    __inout_bcount_opt( *f_pcbLicense ) DRM_BYTE                *f_pbLicense,
    __inout_ecount( 1 )                 DRM_DWORD               *f_pcbLicense )
{
    DRM_BYTE    *pbBuffer          = f_pbLicense;
    DRM_DWORD    cbLicense         = 0;
    DRM_WORD     cbSignature       = XMR_AES_OMAC_SIGNATURE_LENGTH;
    DRM_DWORD    cbSignatureObject = 0;
    DRM_DWORD    iLicense          = 0;
    DRM_RESULT   dr                = DRM_SUCCESS;
    DRM_WORD     wObjectType       = XMR_OBJECT_TYPE_INVALID;
    DRM_DWORD    eSignature        = XMR_SIGNATURE_TYPE_AES_128_OMAC;

    DRM_XMR_BUILDER_CONTEXT_INTERNAL    *pcontextBuilder =
                            ( DRM_XMR_BUILDER_CONTEXT_INTERNAL * ) f_pcontextBuilder;

    ChkArg( pcontextBuilder  != NULL );
    ChkArg( f_pfnSignature   != NULL );
    ChkArg( f_pcbLicense     != NULL );
    ChkArg( pcontextBuilder->rgpObjectNodes != NULL );
    AssertChkArg(
        ( pcontextBuilder->dwVersion == XMR_VERSION_1 )
     || ( pcontextBuilder->dwVersion == XMR_VERSION_3 ) );

    /*
    **  Ensure that required objects were added
    */
    for ( wObjectType =  XMR_OBJECT_TYPE_INVALID;
          wObjectType <= XMR_OBJECT_TYPE_MAXIMUM_DEFINED;
          wObjectType++ )
    {
        /*
        **  The logic here makes exception for XMR_OBJECT_TYPE_EMBEDDING_BEHAVIOR_OBJECT
        **  because Silverlight licenses don't require this object.
        */
        if (   pcontextBuilder->rgpObjectNodes[wObjectType] == NULL
            && !g_xmrBuilderDefines[wObjectType].fIsOptional
            && wObjectType != XMR_OBJECT_TYPE_SIGNATURE_OBJECT
            && wObjectType != XMR_OBJECT_TYPE_EMBEDDING_BEHAVIOR_OBJECT )
        {
            ChkDR( DRM_E_XMR_REQUIRED_OBJECT_MISSING );
        }
    }

    /* Special case Minimum Environment / Security Level: At least one must be specified but not both */
    if( ( pcontextBuilder->rgpObjectNodes[XMR_OBJECT_TYPE_MINIMUM_ENVIRONMENT_OBJECT] == NULL )
     == ( pcontextBuilder->rgpObjectNodes[XMR_OBJECT_TYPE_SECURITY_LEVEL]             == NULL ) )
    {
        ChkDR( DRM_E_XMR_REQUIRED_OBJECT_MISSING );
    }

    cbLicense = XMR_HEADER_LENGTH
              + pcontextBuilder->rgpObjectNodes[XMR_OBJECT_TYPE_OUTER_CONTAINER]->cbLength;

    if ( *f_pcbLicense < cbLicense || f_pbLicense == NULL )
    {
        *f_pcbLicense = cbLicense;
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    /* Serialize the Header */
    DWORD_TO_NETWORKBYTES( pbBuffer, iLicense, XMR_MAGIC_CONSTANT );
    iLicense += sizeof( DRM_DWORD );

    DWORD_TO_NETWORKBYTES( pbBuffer, iLicense, pcontextBuilder->dwVersion );
    iLicense += sizeof( DRM_DWORD );

    ChkBOOL( iLicense + SIZEOF( DRM_ID ) <= cbLicense, DRM_E_INVALIDARG );

    DRM_BYT_CopyBytes( pbBuffer,
                       iLicense,
                       pcontextBuilder->pidRights->rgb,
                       0,
                       SIZEOF( DRM_ID ) );
    iLicense += SIZEOF( DRM_ID );

    cbSignatureObject = cbSignature + XMR_BASE_OBJECT_LENGTH + 2 * SIZEOF( DRM_WORD );

    /* Serialize the Outer Container */
    ChkBOOL( XMR_BASE_OBJECT_LENGTH + iLicense <= cbLicense, DRM_E_BUFFERTOOSMALL );

    DRM_XMR_Serialize_BaseObject( XMR_OBJECT_TYPE_OUTER_CONTAINER,
                                  pcontextBuilder->rgpObjectNodes[XMR_OBJECT_TYPE_OUTER_CONTAINER]->cbLength,
                                  pbBuffer,
                                  &iLicense );
    ChkDR( DRM_XMR_Serialize_Container( pcontextBuilder->rgpObjectNodes[XMR_OBJECT_TYPE_OUTER_CONTAINER]->pvObject,
                                        pbBuffer,
                                        cbLicense,
                                        &iLicense ) );

    ChkBOOL( iLicense + 6 * SIZEOF( DRM_WORD ) <= cbLicense, DRM_E_BUFFERTOOSMALL );

    /* Serialize the signature object */
    WORD_TO_NETWORKBYTES( pbBuffer, iLicense, XMR_FLAGS_MUST_UNDERSTAND );
    iLicense += SIZEOF( DRM_WORD );

    WORD_TO_NETWORKBYTES( pbBuffer, iLicense, XMR_OBJECT_TYPE_SIGNATURE_OBJECT );
    iLicense += SIZEOF( DRM_WORD );

    DWORD_TO_NETWORKBYTES( pbBuffer, iLicense, cbSignatureObject );
    iLicense += SIZEOF( DRM_DWORD );

    //
    // Xbox LIVE specific: disabling conversion warning (C4242) after review.
    //
    #pragma warning( disable:4242 )
    WORD_TO_NETWORKBYTES( pbBuffer, iLicense, eSignature );
    #pragma warning( default:4242 )
    //
    // End Xbox LIVE specific
    //

    iLicense += SIZEOF( DRM_WORD );

    WORD_TO_NETWORKBYTES( pbBuffer, iLicense, cbSignature );
    iLicense += SIZEOF( DRM_WORD );

    /* Create signature */
    ChkDR( f_pfnSignature( f_pvSignatureContext,
                           f_pbLicense,
                           cbLicense - cbSignatureObject,
                           pbBuffer,
                           *f_pcbLicense,
                           iLicense ) );

    *f_pcbLicense = cbLicense;

ErrorExit:

    return dr;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\ecex2001.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bignum.h"
#include "ecurve.h"

ENTER_PK_NAMESPACE_CODE;


/*
    File ecex2001.c.    Version 01 October 2001

        Let E be an elliptic curve (over GF(2^m) or GF(p), where p is prime).
        The costs of some group operations (using affine coordinates) are
        (I = inversion, S = squaring, M = multiplication)

     Operation           GF(2^m)        GF(p)
        2P              I +  S + 2M    I + 2S + 2M
       P+Q              I +  S + 2M    I +  S + 2M
     2P+Q = P+(P+Q)    2I + 2S + 3M   2I + 2S + 3M  (ecaffine_PPQ)
      Both P +- Q       I + 2S + 4M    I + 2S + 4M
                                                (ecaffine_addition_subtraction)

 3P+Q = (2P) + (P+Q)   2I + 3S + 9M   2I + 4S + 9M  (after replacing I by 3M)
 3P+Q = P+(P+(P+Q))    3I + 3S + 4M   3I + 2S + 4M  (using same idea as in 2P+Q)
 3P+Q = 2(P+Q) + (P-Q) 3I + 4S + 7M   3I + 4S + 7M


    These costs appply to the generic case, where no input is a
    point at infinity and where we encounter no divisions by zero.

        We are given a point P0 on E and a nonnegative exponent expon.
    Select a width w (2 <= w <= WMAX),
    dependent upon the number of bits in our exponent.
    Set oddmax = 2^(w-1) - 1.  The plan is tabulate j*P0 for all odd j,
    1 <= j <= oddmax, as well as j = 3*2^(w - 3) when w > 2.
    The table is constructed as follows (when w <= 6):

                 if (w >= 3) then
                     Use 2P + Q code to form 2*P0 + P0 = 3*P0.
                 end if
                 if (w >= 4) then
                     Use doubling code to form 6*P0.
                     Use (both P +- Q) code to form 5*P0 and 7*P0    (6 +- 1)
                 end if
                 if (w >= 5) then
                     Use doubling code to form 12*P0
                     Use (both P +- Q) code to form 9*P0, 11*P0, 13*P0, 15*P0
                                                     (12 +- 1, 12 +- 3)
                 end if
                 if (w >= 6) then
                     Use doubling code to form 24*P0
                     Use (both P +- Q) code to form 17*P0, 19*P0, ..., 31*P0
                                         (24 +- 1, 24 +- 3, 24 +- 5, 24 +- 7)
                end if

    This strategy can be improved slightly by (for example)
    computing 6*P0 + 6*P0, and 6*P0 +- P0 together, replacing one of the
    inversions by three multiplications.
    This strategy would do  2^(w-3) - 2 such replacements when w >= 4.
    Assuming such is later implemented, this initialization would use

         1           invocation  of 2*P + Q code
         2^(w-3) - 1 invocations of (both P +- Q) code
         w - 3       invocations of doubling code
         2^(w-3) - 2 replacements of an inversion by 3 multiplications

        After this table is built, the idea is to use windows of width w,
    with odd signed digits from -oddmax to +oddmax.
    A simplified, recursive, description is

              Function multiply_by(e)    // Return e*P0, assuming e > 0
                  if (e is small) then
                      use a table entry, or a sum of a few table entries
                  else if e is even then
                      return 2*multiply_by(e/2)
                  else
                      choose j == e (mod 2^w), -oddmax <= j <= oddmax
                      return 2*multiply_by((e-j)/2) + j*P0
                  end if
              end function multiply_by

    We estimate this cost as log2(e) doublings and log2(e)/(w + 1) additions.
    That is log2(e)*w/(w + 1) invocations of the doubling code and
    log2(e)/(w + 1) invocations of the 2*P + Q code

        Suppose w = 6, so that oddmax = 31 and doublings3pwr = 24.
     Here is how we aim to compute expleft*P0 for various small expleft:

No operation

       0                                       0
       table                                   odd 1 to 31
                                               24

One group operation
       P+Q or 2P                               even 2 to 62 (except 24)
                                               odd 33 to 55

Two group operations
       2P + Q or 3P                            odd 57 to 93
                                               2 mod 4, 66 to 86
                                               72
       2(P + Q)                                2 mod 4, 90 to 110
                                               0 mod 4, 64 to 124 (except 72)

Three group operations
       2(P + Q) + R                            odd 95 to 155
       3(P + Q)                                0 mod 6, 96 to 186
                                                   (except 96, 108, 120)
                                               3 mod 6, 99 to 165

     w             = {2, 3, 4,  5,  6}
     doublings3pwr = (1, 3, 6, 12, 24)
     oddmax =        (1, 3, 7, 15, 31)

     if (expleft is high or more bits left) {
         delay
     else if (expleft == 0) then
         identity
     else if (expleftodd && expleft <= oddmax) then
         Copy from table
     else if (expleft == doublings3pwr) then
         Copy from table
     else if (even(expleft) && expleft <= 2*oddmax) then
         Use MIN(expleft - 1, oddmax) and another odd value
     else if (    odd(expleft + doublings3pwr)
              and expleft <= doublings3pwr + oddmax) then
         Use doublings3pwr   and odd value
     else if (expleftodd && expleft <= 3*oddmax) then
         odd1 =  2*((expleft - oddmax + 2)/4) - 1
         Use 2*odd1 + odd
     else if (expleft - doublings3pwr == 2 mod 4, at most 2*oddmax) then
         Use 2*odd + doublings3pwr
     else if (expleft is even, at most 2*(oddmax + doublings3pwr)) then
         delay
     else if (expleft = 0 mod 4, at most 4*oddmax) then
         delay
     else if (expleft == 0 mod 6, at most 6*oddmax) then
         Use 3 *(odd + odd)
     else if (odd (expleft + doublings3pwr) and
              expleft divisible by 3,
              at most 3*(doublings3pwr + oddmax) then
         Use 3*(doublings3pwr + odd)
     else if (expleftodd, at most 5*oddmax) then
         even1 = 2*((expleft - oddmax + 2)/4)
         Use 2*(oddmax + (even1 - oddmax)) + (oddmax or oddmax - 2)
     else
         delay
     end if
*/


DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL ecaffine_exponentiation
             (const digit_t    *P0,
              const digit_t        exponent[],
              const DRM_DWORD       lng_exponent,
              digit_t     *Presult,        // OUT
              const ecurve_t      *E,
              struct bigctx_t *f_pBigCtx)

// Compute Pesult = exponent*P0 in the elliptic curve group.
// Unlike ecaffine_exponentiation1998, this code allows
// P0 and Pesult to overlap.
{
    const field_desc_t *fdesc = E->fdesc;
    const DRM_DWORD elng = fdesc->elng;
    const DRM_DWORD expbits = mp_significant_bit_count(exponent, lng_exponent);

    DRM_BOOL OK = TRUE;
    DRM_BOOL delay;
    digit_t *dtemps = NULL;
    digit_t *etemps = NULL;              // Length E->ndigtemps;
    digit_t *adjustment_locs = NULL;     // Length lng_exponent
    digit_t *Presult1998 = NULL;         // Length 2*elng
    digit_t *p0muls = NULL;              // length 2*elng ((oddmax + 1)/2)
    digit_t doublings3pwr, expon_partial, oddmax;
    sdigit_t expon_excess;
    DRM_DWORD iexpbit, numdoubling, w;

    static const DRM_DWORD wcutoffs[] = {22, 50, 110, 256, 600};
    #define WMAX ((DRM_DWORD)(2 + SIZEOF(wcutoffs)/SIZEOF(wcutoffs[0])))

/*
    Use       w = 2 (digits  -1 to  1) if expbits <= 22,
    otherwise w = 3 (digits  -3 to  3) if expbits <= 50,
    otherwise w = 4 (digits  -7 to  7) if expbits <= 110,
    otherwise w = 5 (digits -15 to 15) if expbits <= 256,
    otherwise w = 6 (digits -31 to 31) if expbits <= 600,
    otherwise w = 7 (digits -63 to 63).

    wcutoffs has approximations to the cutoffs suggested by the
    Maple program at the end of this file.
    [Actual cutoffs are about 20% lower for GF(2^n) than
    for GF(p) -- this table has compromise values.]
 */
    w = 2;
    while (w < WMAX && expbits > wcutoffs[w-2]) w++;

         // Check for Koblitz curves (ec_Koblitz2_exponentiation).
         // The Koblitz code allows overlapping arguments.

    if (E->fexpon != NULL) {
        return (*E->fexpon)(P0, exponent, lng_exponent,
                            Presult, E, f_pBigCtx);
    }

    oddmax = ((digit_t)1 << (w-1)) - 1;          // 1, 3, 7, 15, 31, or 63
/*
         Decide how many temporaries we need.  Allocate them.
*/
    if (OK) {
        const DRM_DWORD ndigtemp = E->ndigtemps + ((DRM_DWORD)oddmax + 3)*elng
                                          + lng_exponent;
        if ( ndigtemp < E->ndigtemps
          || ndigtemp < lng_exponent 
          || ((DRM_DWORD)oddmax + 3)*elng < elng
          || ndigtemp < ((DRM_DWORD)oddmax + 3)*elng ) 
        {
            OK = FALSE;
        }
        else
        {
            dtemps = digit_allocate(ndigtemp,
                                    "ecaffine_exponentiation", f_pBigCtx);
            if (dtemps == NULL) {
                OK = FALSE;
            } else {
                ZEROMEM(dtemps,( ndigtemp)*SIZEOF( digit_t ));

                adjustment_locs = dtemps;
                p0muls = adjustment_locs + lng_exponent;
                Presult1998 = p0muls + (oddmax + 1)*elng;
                etemps = Presult1998 + 2*elng;
                DRMASSERT(etemps + E->ndigtemps == dtemps + ndigtemp);
            }
        }
    }

#define p0location(iodd) (DRMASSERT((iodd) & 1), \
                          DRMASSERT((digit_t)(iodd) <= oddmax), \
                           &p0muls[elng*(iodd) - elng])
               // Return address in p0muls array, after validating
               // subscript in debug mode.

    doublings3pwr = 1;
    if (OK) {
        DRM_DWORD iw;
        digit_t j;
/*
             Initialize table of multiples of P0.

             Presult = doublings3pwr * P0
             p0muls = (1, 3, 5, 7, ..., oddmax) * P0
*/
        MEMCPY( p0location(1),P0,( 2*  E->fdesc->elng)*SIZEOF( digit_t ));
        if (w == 2) {
            MEMCPY( Presult,P0,( 2*  E->fdesc->elng)*SIZEOF( digit_t ));
                                                      // Only P0 stored in table
        } else {
            doublings3pwr = 3;
            OK = OK && ecaffine_PPQ(P0, P0, p0location(3), +1,
                                    E, etemps, f_pBigCtx);
                                                           // 3*P0

            if (w == 3) {
                MEMCPY( Presult,p0location(3),( 2*  E->fdesc->elng)*SIZEOF( digit_t ));
                                                           // P0 and 3*P0 saved
            } else {
                OK = OK && ecaffine_addition(p0location(3), p0location(3),
                                             Presult, +1, E,
                                             etemps, f_pBigCtx);
                                   // Presult = 6*P0

                for (iw = 4; iw <= w; iw++) {
                    doublings3pwr *= 2;
                    DRMASSERT(doublings3pwr == (digit_t)3 << (iw - 3));

                          // At this point Presult = doublings3pwr * P0
                          // p0muls has been initialized p0location(2^(w-1) - 1)

// TBD -- Future inplementation should do all group operations below at once,
// combining the inversions
                    for (j = 1; j >> (iw-3) == 0; j += 2) {
                        OK = OK && ecaffine_addition_subtraction(Presult,
                                        p0location(j),
                                        p0location(doublings3pwr + j),
                                        p0location(doublings3pwr - j),
                                        E, etemps, f_pBigCtx);
                    } // for j
                    if (iw != w) {
                        OK = OK && ecaffine_addition(Presult, Presult,
                                                     Presult, +1, E,
                                                     etemps, f_pBigCtx);
                    }
                }  // for iw
            } // if w > 3
        } // if w > 2
        if ( !OK ) {
            TRACE( ( "ecaffine_exponentiation -- OK = FALSE initializing multiples of P0\n" ) );
        } 
    } // if OK

    numdoubling = 0;
    expon_partial = 0;

    for (iexpbit = 0; iexpbit != expbits; iexpbit++) {
        expon_partial += mp_getbit(exponent, iexpbit)
                                << (iexpbit - numdoubling);
        if (iexpbit < numdoubling + w + 1) {
            /* delay */
        } else {
            if (IS_ODD(expon_partial)) {
                const sdigit_t sindex =   ((expon_partial + oddmax) & (2*oddmax))
                                   - oddmax;
                expon_partial -= (digit_t)sindex;
                DRMASSERT((expon_partial & (2*oddmax + 1)) == 0);
                mp_setbit(adjustment_locs, numdoubling, 1);
            }
            expon_partial >>= 1;
            numdoubling++;
        }
    } // for iexpbit

    delay = TRUE;
    while (OK && delay) {
        const DRM_BOOL expon_partial_odd = IS_ODD(expon_partial);
        const digit_t expon_partial3 = expon_partial - doublings3pwr;
                                         /* May be negative */
        const DRM_BOOL expon_partial3_odd = IS_ODD(expon_partial3);
        const digit_t expon_partial_div3 = expon_partial/3;
        const digit_t expon_partial_mod3 = expon_partial - 3*expon_partial_div3;

        delay = FALSE;
        if (expon_partial == 0) {
            OK = OK && ecaffine_set_infinite(Presult, E, f_pBigCtx);
        } else if (expon_partial_odd && expon_partial <= oddmax) {
            MEMCPY( Presult,p0location(expon_partial),( 2*  E->fdesc->elng)*SIZEOF( digit_t ));
        } else if (expon_partial == doublings3pwr) {
            /* Presult already has doublings3pwr * P0 */
        } else if (!expon_partial_odd && expon_partial <= 2*oddmax) {
            const digit_t odd1 = MIN(expon_partial - 1, oddmax);
            const digit_t odd2 = expon_partial - odd1;

            OK = OK && ecaffine_addition(p0location(odd1),
                                         p0location(odd2),
                                         Presult, +1, E,
                                         etemps, f_pBigCtx);
        } else if (   expon_partial3_odd
                   && expon_partial <= doublings3pwr + oddmax) {
            OK = OK && ecaffine_addition(Presult,
                                         p0location(expon_partial3),
                                         Presult, +1, E,
                                         etemps, f_pBigCtx);
        } else if (expon_partial_odd && expon_partial <= 3*oddmax) {
            const digit_t odd1 = ((expon_partial - oddmax)/2) | 1;
            const digit_t odd2 = expon_partial - 2*odd1;
            OK = OK && ecaffine_PPQ(p0location(odd1),
                                    p0location(odd2),
                                    Presult, +1, E,
                                    etemps, f_pBigCtx);
        } else if (    (expon_partial3 & 3) == 2
                    && expon_partial3 <= 2*oddmax) {
            OK = OK && ecaffine_PPQ(p0location(expon_partial3 >> 1),
                                    Presult, Presult, +1, E,
                                    etemps, f_pBigCtx);
        } else if (   !expon_partial_odd
                   && expon_partial <= 2*(oddmax + doublings3pwr)) {
            delay = TRUE;
        } else if ( (expon_partial & 3) == 0 && expon_partial <= 4*oddmax) {
            delay = TRUE;
        } else if (    !expon_partial_odd
                    && expon_partial_mod3 == 0
                    && expon_partial_div3 <= 2*oddmax) {
            const digit_t odd1 = MIN(expon_partial_div3 - 1, oddmax);
            const digit_t odd2 = expon_partial_div3 - odd1;
                            // expon_partial = 3*(odd1 + odd2)

            OK = OK && ecaffine_addition(p0location(odd1), p0location(odd2),
                                         Presult, +1, E,
                                         etemps, f_pBigCtx);
            OK = OK && ecaffine_PPQ(Presult, Presult, Presult, +1, E,
                                         etemps, f_pBigCtx);
        } else if (   expon_partial_mod3 == 0
                   && expon_partial3_odd
                   && expon_partial_div3 - doublings3pwr <= oddmax) {
            DRMASSERT (  expon_partial == 3*(doublings3pwr
                    + (expon_partial_div3 - doublings3pwr)));

            OK = OK && ecaffine_addition(
                           p0location(expon_partial_div3 - doublings3pwr),
                           Presult, Presult, +1, E,
                           etemps, f_pBigCtx);
            OK = OK && ecaffine_PPQ(Presult, Presult, Presult, +1, E,
                           etemps, f_pBigCtx);
        } else if (expon_partial_odd && expon_partial <= 5*oddmax) {
                     // Use 2*(oddmax + odd) + odd
            const digit_t even1 = 2*((expon_partial - oddmax + 2)/4);
            DRMASSERT(expon_partial >= 3*oddmax + 2);

            OK = OK && ecaffine_addition(p0location(oddmax),
                                         p0location(even1 - oddmax),
                                         Presult, +1, E,
                                         etemps, f_pBigCtx);
            OK = OK && ecaffine_PPQ(Presult,
                                    p0location(expon_partial - 2*even1),
                                    Presult, +1, E,
                                    etemps, f_pBigCtx);
        } else {
            delay = TRUE;
        }
        if (!OK) {
            TRACE( ( "ecaffine_exponentiation -- OK = FALSE" ) );
            TRACE( ( "multiplying by expon_partial = %ld\n", ( DRM_LONG )expon_partial ) );            
        } else if (delay) {
            if (expon_partial_odd) {
                const sdigit_t sindex =    ((expon_partial + oddmax) & (2*oddmax))
                                    - oddmax;
                expon_partial -= (digit_t)sindex;
                DRMASSERT((expon_partial & (2*oddmax + 1)) == 0);
                mp_setbit( adjustment_locs, numdoubling, 1 );
            }
            numdoubling++;
            expon_partial >>= 1;
        } // if
    } // while

/*
        At this point, Presult = expon_partial * P0.

        We intend to double Presult numdoubling times,
        occasionally adding or subtracting
        (odd value in [1, oddmax] * P0).
*/

    expon_excess = (sdigit_t)expon_partial;
    for (iexpbit = expbits; iexpbit-- && OK; ) {
        const digit_t adjustment_bit = mp_getbit(adjustment_locs, iexpbit);
        const digit_t exponent_bit = mp_getbit(exponent, iexpbit);

/*
           The final result is

              (Presult - expon_excess*P0) * 2^numdoubling
              + (bits 0 to iexpbit-1 of exponent)*P0
*/
        while (OK && numdoubling > iexpbit + adjustment_bit) {
            OK = OK && ecaffine_addition(Presult, Presult,
                                         Presult, +1, E,
                                         etemps, f_pBigCtx);
            numdoubling--;
            expon_excess *= 2;
        }

        if (!OK) {
        } else if (adjustment_bit == 0) {
            DRMASSERT(iexpbit >= numdoubling);
            expon_excess -= exponent_bit << (iexpbit - numdoubling);
        } else {
            DRM_INT pm1;
            digit_t index;
            sdigit_t sindex;
            const DRM_DWORD pre_doublings = numdoubling - iexpbit;

            expon_excess = (expon_excess << pre_doublings) - exponent_bit;
            pm1 = (expon_excess > 0 ? -1 : +1);

            sindex = 1 | (-expon_excess);
            index = (digit_t)(pm1*sindex);
            expon_excess += sindex;

            if (pre_doublings > 1) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                "ecaffine_exponentiation pre_doublings");
                TRACE( ( "ecaffine_exponentiation -- pre_doublings = %ld out of range\n",
                       ( DRM_LONG )pre_doublings ) );
            } else if (index > oddmax) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                "ecaffine_exponentiation index > oddmax");
                TRACE( ( "ecaffine_exponentiation -- index = %ld exceeds oddmax = %ld\n",
                       ( DRM_LONG )index, ( DRM_LONG )oddmax ) );
            } else {
                numdoubling = iexpbit;
                DRMASSERT(expon_excess == 0 || expon_excess == 1);
            }

            if (!OK) {
            } else if (pre_doublings == 0) {
                OK = OK && ecaffine_addition(Presult,
                               p0location(index), Presult, pm1, E,
                               etemps, f_pBigCtx);
            } else if (pre_doublings == 1) {
                OK = OK && ecaffine_PPQ(Presult, p0location(index),
                                        Presult, pm1, E,
                                        etemps, f_pBigCtx);
            } else {
                DRMASSERT(FALSE);
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                "ecaffine_exponentiation - 3");
            }
        } // if (OK && adjustment_bit)
    } // for iexpbit

    if (OK) {
        DRMASSERT(numdoubling == 0);
        DRMASSERT(expon_excess == 0);
    }
    if (dtemps != NULL) {
        Free_Temporaries(dtemps, f_pBigCtx);
    }
    if (!OK) {
        TRACE( ( "ecaffine_exponentiation exiting unsuccessfully\n" ) );
    }
    return OK;
#undef p0location
#undef WMAX

/*

#      Maple code for estimating change-overs.
#      Paste this code into a maple input buffer.


# I = inversion, S = squaring, M = multiplication

for char2 in [false, true] do

    if (char2) then     # Relative operation costs over GF(2^m)
                        # with polynomial basis.   October, 2001.
        cS := cM/3;
        cI := 6*cM;
        cost2P := costPQ;
    else                # Relative operation costs over GF(p)
        cS := 9*cM/10;
        cI := 11*cM/2;
        cost2P := costPQ + cS;
    fi;
    costPQ := cI + cS + 2*cM;


    costPPQ := 2*costPQ - cM;
    costPpmQ := 2*costPQ - cI;

# Next approximation assumes w >= 2.

    costtot := costPPQ + (2^(w-3) - 1)*costPpmQ
           + (w - 3)*cost2P
           + (2^(w-3) - 2) * (3*cM - cI)
           + (costPPQ + w*cost2P)*log2e/(w + 1);

    for ww from 3 to 8 do
        savings := subs(w = ww, costtot) - subs(w = ww-1, costtot);
        print(char2, ww, evalf(solve(savings = 0, log2e)));
    od:
od;  # char2

# End of maple code

*/
} // ecaffine_exponentiation

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmxmrparser.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcontextsizes.h>
#include <byteorder.h>
#include <drmxmrparser.h>

ENTER_PK_NAMESPACE_CODE;

const XMR_PARSER_INTERNAL_DEFINES g_xmrParserDefines[XMR_OBJECT_TYPE_MAXIMUM_DEFINED+1] =
{
                                                                   /*  V1     V2     V3 */
    { DRM_XMR_Parse_Invalid,                                       { FALSE, FALSE, FALSE } },   /* XMR_OBJECT_TYPE_INVALID */
    { DRM_XMR_Parse_OuterContainer,                                {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_OUTER_CONTAINER */
    { DRM_XMR_Parse_GlobalContainer,                               {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER */
    { DRM_XMR_Parse_MinimumEnvironment,                            {  TRUE, FALSE, FALSE } },   /* XMR_OBJECT_TYPE_MINIMUM_ENVIRONMENT_OBJECT */
    { DRM_XMR_Parse_PlaybackContainer,                             {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER */
    { DRM_XMR_Parse_OPLs,                                          {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_OUTPUT_PROTECTION_OBJECT */
    { DRM_XMR_Parse_UplinkKID,                                     {  TRUE, FALSE, FALSE } },   /* XMR_OBJECT_TYPE_UPLINK_KID_OBJECT    */
    { DRM_XMR_Parse_ExplicitAnalogVideoOutputProtectionContainer,  {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_EXPLICIT_ANALOG_VIDEO_OUTPUT_PROTECTION_CONTAINER */
    { DRM_XMR_Parse_VideoOutputConfig,                             {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_ANALOG_VIDEO_OUTPUT_CONFIGURATION_OBJECT */
    { DRM_XMR_Parse_KeyMaterialContainer,                          {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_KEY_MATERIAL_CONTAINER */
    { DRM_XMR_Parse_ContentKey,                                    {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_CONTENT_KEY_OBJECT */
    { DRM_XMR_Parse_Signature,                                     {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_SIGNATURE_OBJECT */
    { DRM_XMR_Parse_BYTEARRAY,                                     {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_SERIAL_NUMBER_OBJECT */
    { DRM_XMR_Parse_WORD,                                          {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_SETTINGS_OBJECT */
    { DRM_XMR_Parse_CopyContainer,                                 {  TRUE, FALSE, FALSE } },   /* XMR_OBJECT_TYPE_COPY_POLICY_CONTAINER */
    { DRM_XMR_Parse_PlaylistBurnContainer,                         {  TRUE, FALSE, FALSE } },   /* XMR_OBJECT_TYPE_ALLOW_PLAYLISTBURN_POLICY_CONTAINER */
    { DRM_XMR_Parse_GUIDLIST,                                      {  TRUE, FALSE, FALSE } },   /* XMR_OBJECT_TYPE_INCLUSION_LIST_OBJECT   */
    { DRM_XMR_Parse_DWORD,                                         {  TRUE, FALSE, FALSE } },   /* XMR_OBJECT_TYPE_PRIORITY_OBJECT  */
    { DRM_XMR_Parse_Expiration,                                    {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_EXPIRATION_OBJECT    */
    { DRM_XMR_Parse_DWORD,                                         {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_ISSUEDATE_OBJECT */
    { DRM_XMR_Parse_DWORD_Versioned,                               {  TRUE, FALSE, FALSE } },   /* XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTUSE_OBJECT */
    { DRM_XMR_Parse_DWORD,                                         {  TRUE, FALSE, FALSE } },   /* XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTSTORE_OBJECT   */
    { DRM_XMR_Parse_GUID,                                          {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_METERING_OBJECT  */
    { DRM_XMR_Parse_DWORD,                                         {  TRUE, FALSE, FALSE } },   /* XMR_OBJECT_TYPE_PLAYCOUNT_OBJECT */
    { DRM_XMR_Parse_Invalid,                                       { FALSE, FALSE, FALSE } },   /* Deprecated: XMR_OBJECT_TYPE_PLAYBACK_EXCLUSION_LIST_OBJECT (Shipped in Emerald Beta 1)*/
    { DRM_XMR_Parse_Invalid,                                       { FALSE, FALSE, FALSE } },   /* Deprecated: XMR_OBJECT_TYPE_PLAYBACK_INCLUSION_LIST_OBJECT (Shipped in Emerald Beta 1)*/
    { DRM_XMR_Parse_DWORD,                                         {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_GRACE_PERIOD_OBJECT */
    { DRM_XMR_Parse_DWORD_Versioned,                               {  TRUE, FALSE, FALSE } },   /* XMR_OBJECT_TYPE_COPYCOUNT_OBJECT */
    { DRM_XMR_Parse_WORD,                                          {  TRUE, FALSE, FALSE } },   /* XMR_OBJECT_TYPE_COPY_PROTECTION_OBJECT   */
    { DRM_XMR_Parse_Invalid,                                       { FALSE, FALSE, FALSE } },   /* Deprecated: XMR_OBJECT_TYPE_COPY_EXCLUSION_LIST_OBJECT (Shipped in Emerald Beta 1)*/
    { DRM_XMR_Parse_Invalid,                                       { FALSE, FALSE, FALSE } },   /* Deprecated: XMR_OBJECT_TYPE_COPY_INCLUSION_LIST_OBJECT (Shipped in Emerald Beta 1)*/
    { DRM_XMR_Parse_PlaylistBurnRights,                            {  TRUE, FALSE, FALSE } },   /* XMR_OBJECT_TYPE_PLAYLISTBURN_COUNT_OBJECT    */
    { DRM_XMR_Parse_DWORD_Versioned,                               {  TRUE, FALSE, FALSE } },   /* XMR_OBJECT_TYPE_REVOCATION_INFORMATION_VERSION_OBJECT */
    { DRM_XMR_Parse_RsaPubkey,                                     {  TRUE, FALSE, FALSE } },   /* XMR_OBJECT_TYPE_RSA_DEVICE_KEY_OBJECT */
    { DRM_XMR_Parse_DWORD,                                         {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_SOURCEID_OBJECT  */
    { DRM_XMR_Parse_Invalid,                                       { FALSE, FALSE, FALSE } },   /* Deprecated: XMR_OBJECT_TYPE_EXPLICIT_UNCOMPRESSED_DIGITAL_AUDIO_OUTPUT_PROTECTION_CONTAINER (Shipped in Emerald Beta 1)*/
    { DRM_XMR_Parse_Invalid,                                       { FALSE, FALSE, FALSE } },   /* Deprecated: XMR_OBJECT_TYPE_UNCOMPRESSED_DIGITAL_AUDIO_OUTPUT_CONFIGURATION_OBJECT (Shipped in Emerald Beta 1)*/
    { DRM_XMR_Parse_RevocationContainer,                           {  TRUE, FALSE, FALSE } },   /* XMR_OBJECT_TYPE_REVOCATION_CONTAINER */
    { DRM_XMR_Parse_RsaPubkey,                                     {  TRUE, FALSE, FALSE } },   /* XMR_OBJECT_TYPE_RSA_LICENSE_GRANTER_KEY_OBJECT */
    { DRM_XMR_Parse_UserID,                                        {  TRUE, FALSE, FALSE } },   /* XMR_OBJECT_TYPE_USERID_OBJECT */
    { DRM_XMR_Parse_Empty,                                         {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_RESTRICTED_SOURCEID_OBJECT  */
    { DRM_XMR_Parse_DomainID,                                      { FALSE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_DOMAIN_ID_OBJECT  */
    { DRM_XMR_Parse_EccDevicekey,                                  { FALSE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_ECC_DEVICE_KEY_OBJECT */
    { DRM_XMR_Parse_DWORD,                                         { FALSE, FALSE, FALSE } },   /* XMR_OBJECT_TYPE_GENERATION_NUMBER_OBJECT */
    { DRM_XMR_Parse_PolicyMetadata,                                {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_POLICY_METADATA_OBJECT */
    { DRM_XMR_Parse_OptimizedContentKey,                           { FALSE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_OPTIMIZED_CONTENT_KEY_OBJECT */
    { DRM_XMR_Parse_ExplicitDigitalAudioOutputProtectionContainer, {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_EXPLICIT_DIGITAL_AUDIO_OUTPUT_PROTECTION_CONTAINER */
    { DRM_XMR_Parse_UnknownContainer,                              { FALSE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_RINGTONE_POLICY_CONTAINER */
    { DRM_XMR_Parse_DWORD_Versioned,                               { FALSE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTPLAY_OBJECT */
    { DRM_XMR_Parse_AudioOutputConfig,                             {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_DIGITAL_AUDIO_OUTPUT_CONFIGURATION_OBJECT */
    { DRM_XMR_Parse_DWORD_Versioned,                               { FALSE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_REVOCATION_INFORMATION_VERSION_2_OBJECT */
    { DRM_XMR_Parse_WORD,                                          { FALSE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_EMBEDDING_BEHAVIOR_OBJECT */
    { DRM_XMR_Parse_SecurityLevel,                                 { FALSE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_SECURITY_LEVEL */
    { DRM_XMR_Parse_CopyToPCContainer,                             {  TRUE, FALSE, FALSE } },   /* XMR_OBJECT_TYPE_COPY_TO_PC_CONTAINER */
    { DRM_XMR_Parse_UnknownContainer,                              { FALSE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_PLAY_ENABLER_CONTAINER */
    { DRM_XMR_Parse_DWORD,                                         {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_MOVE_ENABLER_OBJECT */
    { DRM_XMR_Parse_UnknownContainer,                              {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_COPY_ENABLER_CONTAINER */
    { DRM_XMR_Parse_UnknownObject,                                 { FALSE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_PLAY_ENABLER_OBJECT */
    { DRM_XMR_Parse_UnknownObject,                                 {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_COPY_ENABLER_OBJECT */
    { DRM_XMR_Parse_UplinkKID2,                                    { FALSE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_UPLINK_KID_2_OBJECT */
    { DRM_XMR_Parse_CopyContainer,                                 {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_COPY_POLICY_2_CONTAINER */
    { DRM_XMR_Parse_DWORD_Versioned,                               {  TRUE, FALSE,  TRUE } },   /* XMR_OBJECT_TYPE_COPYCOUNT_2_OBJECT */
};

/******************************************************************************
**
** Function :   DRM_XMR_Parse_Invalid
**
** Synopsis :   Returns DRM_E_INVALIDARG
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_E_INVALIDARG
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_Invalid(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *pbBuffer,
    IN          DRM_DWORD    iObject,
    IN          DRM_DWORD    cbObject,
    IN  OUT     DRM_VOID    *pvObject )
{
    return DRM_E_INVALIDARG;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_OuterContainer
**
** Synopsis :   Parse an outer container object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          A parsing error occurred
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_OuterContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbLicense,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT               dr = DRM_SUCCESS;
    DRM_DWORD                iCurrent = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_WORD                 wFlags = 0;
    DRM_WORD                 wType = 0;
    DRM_DWORD                cbChild    = 0;
    DRM_XMR_OUTER_CONTAINER *pContainer = ( DRM_XMR_OUTER_CONTAINER * )f_pvObject;

    ChkArg( f_pbLicense != NULL );
    ChkArg( f_pvObject  != NULL );
    ChkOverflow( iCurrent, f_iObject );
    ChkOverflow( f_iObject + f_cbObject, f_iObject );
    
    pContainer->fValid                                  = TRUE;
    pContainer->containerGlobalPolicies.fValid          = FALSE;
    pContainer->containerPlaybackPolicies.fValid        = FALSE;
    pContainer->containerCopyPolicies.fValid            = FALSE;
    pContainer->containerCopyToPCPolicies.fValid        = FALSE;
    pContainer->containerPlaylistBurnPolicies.fValid    = FALSE;
    pContainer->generationNumber.fValid                 = FALSE;
    pContainer->containerUnknown.fValid                 = FALSE;
    pContainer->containerRevocation.fValid              = FALSE;
    pContainer->containerKeys.fValid                    = FALSE;
    pContainer->signature.fValid                        = FALSE;

    while ( iCurrent < f_iObject + f_cbObject )
    {
        NETWORKBYTES_TO_WORD( wFlags,  f_pbLicense, iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ), iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ) * 2, iCurrent );
        NETWORKBYTES_TO_WORD( wType,   f_pbLicense, iCurrent + SIZEOF( DRM_WORD ) );
        NETWORKBYTES_TO_DWORD( cbChild, f_pbLicense, iCurrent + SIZEOF( DRM_WORD ) * 2 );
        ChkBOOL( cbChild <= ( f_iObject + f_cbObject - iCurrent ), DRM_E_INVALIDLICENSE );

        switch ( wType )
        {
            case XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER:
                ChkBOOL( !pContainer->containerGlobalPolicies.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pContainer->containerGlobalPolicies ) );
                break;

            case XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER:
                ChkBOOL( !pContainer->containerPlaybackPolicies.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pContainer->containerPlaybackPolicies ) );
                break;

            case XMR_OBJECT_TYPE_COPY_POLICY_CONTAINER:
            case XMR_OBJECT_TYPE_COPY_POLICY_2_CONTAINER:
                ChkBOOL( !pContainer->containerCopyPolicies.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pContainer->containerCopyPolicies ) );
                pContainer->containerCopyPolicies.dwVersion =
                    ( wType == XMR_OBJECT_TYPE_COPY_POLICY_CONTAINER ) ? 1 : 2;

                /* Make sure that the Copy Count, if present, is the same version as the container */
                ChkBOOL(
                    !pContainer->containerCopyPolicies.CopyCount.fValid
                 || pContainer->containerCopyPolicies.dwVersion == pContainer->containerCopyPolicies.CopyCount.dwVersion, DRM_E_INVALIDLICENSE );

                break;

            case XMR_OBJECT_TYPE_COPY_TO_PC_CONTAINER:
                ChkBOOL( !pContainer->containerCopyToPCPolicies.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pContainer->containerCopyToPCPolicies ) );
                break;

            case XMR_OBJECT_TYPE_ALLOW_PLAYLISTBURN_POLICY_CONTAINER:
                ChkBOOL( !pContainer->containerPlaylistBurnPolicies.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pContainer->containerPlaylistBurnPolicies ) );
                break;

            case XMR_OBJECT_TYPE_REVOCATION_CONTAINER:
                ChkBOOL( !pContainer->containerRevocation.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pContainer->containerRevocation ) );
                break;

            case XMR_OBJECT_TYPE_KEY_MATERIAL_CONTAINER:
                ChkBOOL( !pContainer->containerKeys.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pContainer->containerKeys ) );
                break;

            case XMR_OBJECT_TYPE_SIGNATURE_OBJECT:
                ChkBOOL( !pContainer->signature.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pContainer->signature ) );
                break;

            case XMR_OBJECT_TYPE_GENERATION_NUMBER_OBJECT:
                ChkBOOL( !pContainer->generationNumber.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pContainer->generationNumber ) );
                break;

            default:
                ChkBOOL( ( wFlags & XMR_FLAGS_MUST_UNDERSTAND ) == 0, DRM_E_INVALIDLICENSE );

                /*
                ** Only keep external-parse containers.
                ** We can't act on any other objects and shouldn't
                ** waste time/effort trying to parse them.
                */
                if( ( ( wFlags & XMR_FLAGS_CONTAINER ) != 0 )
                 && ( ( wFlags & XMR_FLAGS_ALLOW_EXTERNAL_PARSE ) != 0 ) )
                {
                    if( !pContainer->containerUnknown.fValid )
                    {
                        ZEROMEM( &pContainer->containerUnknown, SIZEOF( DRM_XMR_UNKNOWN_CONTAINER ) );

                        /* It's the first container, no need to allocate */
                        ChkDR( DRM_XMR_Parse_UnknownContainer( f_pStack,
                                f_pbLicense,
                                iCurrent,
                                cbChild,
                               &pContainer->containerUnknown ) );
                    }
                    else
                    {
                        /* It's another container, need to allocated another entry in the linked list */
                        DRM_XMR_UNKNOWN_CONTAINER *pUnknownContainer = NULL;

                        ChkDR( DRM_STK_Alloc_Aligned( f_pStack,
                                                      SIZEOF( DRM_XMR_UNKNOWN_CONTAINER ),
                                                      SIZEOF( DRM_DWORD ),
                                                      NULL,
                                                      ( DRM_VOID ** ) &pUnknownContainer ) );

                        ZEROMEM( pUnknownContainer, SIZEOF( DRM_XMR_UNKNOWN_CONTAINER ) );

                        ChkDR( DRM_XMR_Parse_UnknownContainer( f_pStack,
                                    f_pbLicense,
                                    iCurrent,
                                    cbChild,
                                    pUnknownContainer ) );

                        pUnknownContainer->pNext = pContainer->containerUnknown.pNext;
                        pContainer->containerUnknown.pNext = pUnknownContainer;
                    }
                }
                break;
        };
        ChkOverflow( iCurrent + cbChild, iCurrent );
        iCurrent += cbChild;
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_GlobalContainer
**
** Synopsis :   Parse a global container object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          A parsing error occurred
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_GlobalContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbLicense,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT  dr       = DRM_SUCCESS;
    DRM_DWORD   iCurrent = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_WORD    wFlags   = 0;
    DRM_WORD    wType    = 0;
    DRM_DWORD   cbChild  = 0;
    DRM_XMR_UNKNOWN_OBJECT *pUnknownObject = NULL;
    DRM_XMR_GLOBAL_REQUIREMENTS *pcontainerGlobal =
            ( DRM_XMR_GLOBAL_REQUIREMENTS * )f_pvObject;

    ChkArg( f_pbLicense != NULL );
    ChkArg( f_pvObject  != NULL );
    ChkOverflow( iCurrent, f_iObject );
    ChkOverflow( f_iObject + f_cbObject, f_iObject );
    
    pcontainerGlobal->fValid                                = TRUE;
    pcontainerGlobal->MinimumEnvironment.fValid             = FALSE;
    pcontainerGlobal->SerialNumber.fValid                   = FALSE;
    pcontainerGlobal->Rights.fValid                         = FALSE;
    pcontainerGlobal->Priority.fValid                       = FALSE;
    pcontainerGlobal->SourceID.fValid                       = FALSE;
    pcontainerGlobal->RestrictedSourceID.fValid             = FALSE;
    pcontainerGlobal->Expiration.fValid                     = FALSE;
    pcontainerGlobal->IssueDate.fValid                      = FALSE;
    pcontainerGlobal->GracePeriod.fValid                    = FALSE;
    pcontainerGlobal->Metering.fValid                       = FALSE;
    pcontainerGlobal->ExpirationAfterUse.fValid             = FALSE;
    pcontainerGlobal->ExpirationAfterStore.fValid           = FALSE;
    pcontainerGlobal->InclusionList.fValid                  = FALSE;
    pcontainerGlobal->RevocationInformationVersion.fValid   = FALSE;
    pcontainerGlobal->DomainID.fValid                       = FALSE;
    pcontainerGlobal->EmbeddingBehavior.fValid              = FALSE;
    pcontainerGlobal->pUnknownObjects                       = NULL;
    pcontainerGlobal->PolicyMetadata.fValid                 = FALSE;

    while ( iCurrent < f_iObject + f_cbObject )
    {
        NETWORKBYTES_TO_WORD( wFlags, f_pbLicense, iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ), iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ) * 2, iCurrent );
        NETWORKBYTES_TO_WORD( wType, f_pbLicense, iCurrent + SIZEOF( DRM_WORD ) );
        NETWORKBYTES_TO_DWORD( cbChild, f_pbLicense, iCurrent + SIZEOF( DRM_WORD ) * 2 );
        ChkBOOL( cbChild <= ( f_iObject + ( f_cbObject - iCurrent ) ), DRM_E_INVALIDLICENSE );

        switch ( wType )
        {
            case XMR_OBJECT_TYPE_MINIMUM_ENVIRONMENT_OBJECT:
            case XMR_OBJECT_TYPE_SECURITY_LEVEL:
                ChkBOOL( !pcontainerGlobal->MinimumEnvironment.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainerGlobal->MinimumEnvironment ) );
                pcontainerGlobal->MinimumEnvironment.dwVersion =
                    ( wType == XMR_OBJECT_TYPE_MINIMUM_ENVIRONMENT_OBJECT ) ? 1 : 2;
                break;
            case XMR_OBJECT_TYPE_SERIAL_NUMBER_OBJECT:
                ChkBOOL( !pcontainerGlobal->SerialNumber.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainerGlobal->SerialNumber ) );
                break;
            case XMR_OBJECT_TYPE_SETTINGS_OBJECT:
                ChkBOOL( !pcontainerGlobal->Rights.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainerGlobal->Rights ) );
                break;
            case XMR_OBJECT_TYPE_PRIORITY_OBJECT:
                ChkBOOL( !pcontainerGlobal->Priority.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainerGlobal->Priority ) );
                break;

            case XMR_OBJECT_TYPE_EXPIRATION_OBJECT:
                ChkBOOL( !pcontainerGlobal->Expiration.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainerGlobal->Expiration ) );
                break;
            case XMR_OBJECT_TYPE_ISSUEDATE_OBJECT:
                ChkBOOL( !pcontainerGlobal->IssueDate.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainerGlobal->IssueDate ) );
                break;
            case XMR_OBJECT_TYPE_GRACE_PERIOD_OBJECT:
                ChkBOOL( !pcontainerGlobal->GracePeriod.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainerGlobal->GracePeriod ) );
                break;
            case XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTUSE_OBJECT:
            case XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTPLAY_OBJECT:
                ChkBOOL( !pcontainerGlobal->ExpirationAfterUse.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainerGlobal->ExpirationAfterUse ) );
                pcontainerGlobal->ExpirationAfterUse.dwVersion =
                    ( wType == XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTUSE_OBJECT ) ? 1 : 2;
                break;
            case XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTSTORE_OBJECT:
                ChkBOOL( !pcontainerGlobal->ExpirationAfterStore.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainerGlobal->ExpirationAfterStore ) );
                break;
            case XMR_OBJECT_TYPE_METERING_OBJECT:
                ChkBOOL( !pcontainerGlobal->Metering.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainerGlobal->Metering ) );
                break;
            case XMR_OBJECT_TYPE_SOURCEID_OBJECT:
                ChkBOOL( !pcontainerGlobal->SourceID.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainerGlobal->SourceID ) );
                break;
            case XMR_OBJECT_TYPE_RESTRICTED_SOURCEID_OBJECT:
                ChkBOOL( !pcontainerGlobal->RestrictedSourceID.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainerGlobal->RestrictedSourceID ) );
                break;
            case XMR_OBJECT_TYPE_REVOCATION_INFORMATION_VERSION_OBJECT:
            case XMR_OBJECT_TYPE_REVOCATION_INFORMATION_VERSION_2_OBJECT:
                ChkBOOL( !pcontainerGlobal->RevocationInformationVersion.fValid, DRM_E_INVALIDLICENSE);
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainerGlobal->RevocationInformationVersion ) );
                pcontainerGlobal->RevocationInformationVersion.dwVersion =
                    ( wType == XMR_OBJECT_TYPE_REVOCATION_INFORMATION_VERSION_OBJECT ) ? 1 : 2;
                break;
            case XMR_OBJECT_TYPE_INCLUSION_LIST_OBJECT:
                ChkBOOL( !pcontainerGlobal->InclusionList.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainerGlobal->InclusionList ) );
                break;

            case XMR_OBJECT_TYPE_DOMAIN_ID_OBJECT:
                ChkBOOL( !pcontainerGlobal->DomainID.fValid, DRM_E_INVALIDLICENSE);
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainerGlobal->DomainID ) );
                break;
            case XMR_OBJECT_TYPE_EMBEDDING_BEHAVIOR_OBJECT:
                ChkBOOL( !pcontainerGlobal->EmbeddingBehavior.fValid, DRM_E_INVALIDLICENSE);
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainerGlobal->EmbeddingBehavior ) );
                break;
            case XMR_OBJECT_TYPE_POLICY_METADATA_OBJECT:
                /* dont' check for  !pcontainerGlobal->PolicyMetadata.fValid as it may
                   have been set to true for a previous Policy Metadata object */
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainerGlobal->PolicyMetadata ) );
                break;
            default:
                /*
                ** We don't understand it, but if it allows us to try to externally
                ** parse the object then we may be able to continue
                */
                ChkBOOL( ( wFlags & XMR_FLAGS_MUST_UNDERSTAND ) == 0
                       || ( ( wFlags & XMR_FLAGS_ALLOW_EXTERNAL_PARSE ) != 0 && ( wFlags & XMR_FLAGS_CONTAINER ) == 0 ), DRM_E_INVALIDLICENSE );

                /* Only bother keeping it if it's allowed to be parsed externally, otherwise
                ** we may as well ignore it since we can't do anything else with it */
                if( ( wFlags & XMR_FLAGS_CONTAINER ) == 0
                 && ( wFlags & XMR_FLAGS_ALLOW_EXTERNAL_PARSE ) != 0 )
                {
                    /* Alloc space and add to linked list */
                    ChkDR( DRM_STK_Alloc_Aligned( f_pStack,
                                                  SIZEOF( DRM_XMR_UNKNOWN_OBJECT ),
                                                  SIZEOF( DRM_DWORD ),
                                                  NULL,
                                                  ( DRM_VOID ** ) &pUnknownObject ) );

                    ZEROMEM( pUnknownObject, SIZEOF( DRM_XMR_UNKNOWN_OBJECT ) );

                    ChkDR( DRM_XMR_Parse_UnknownObject( f_pStack,
                                                        f_pbLicense,
                                                        iCurrent,
                                                        cbChild,
                                                        pUnknownObject ) );

                    pUnknownObject->pNext = pcontainerGlobal->pUnknownObjects;
                    pcontainerGlobal->pUnknownObjects = pUnknownObject;
                }
                break;
        };
        ChkOverflow( iCurrent + cbChild, iCurrent );
        iCurrent += cbChild;
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_PlaybackContainer
**
** Synopsis :   Parse a playback container object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          A parsing error occurred
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_PlaybackContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbLicense,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT dr       = DRM_SUCCESS;
    DRM_DWORD  iCurrent = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_WORD   wFlags   = 0;
    DRM_WORD   wType    = 0;
    DRM_DWORD  cbChild  = 0;
    DRM_XMR_UNKNOWN_OBJECT *pUnknownObject = NULL;

    DRM_XMR_PLAYBACK_RIGHTS *pcontainer =
            ( DRM_XMR_PLAYBACK_RIGHTS * )f_pvObject;

    ChkArg( f_pbLicense != NULL );
    ChkArg( f_pvObject  != NULL );
    ChkOverflow( iCurrent, f_iObject );
    ChkOverflow( f_iObject + f_cbObject, f_iObject );

    pcontainer->fValid                                          = TRUE;
    pcontainer->PlayCount.fValid                                = FALSE;
    pcontainer->opl.fValid                                      = FALSE;
    pcontainer->containerExplicitAnalogVideoProtection.fValid   = FALSE;
    pcontainer->containerExplicitDigitalAudioProtection.fValid  = FALSE;
    pcontainer->pUnknownObjects                                 = NULL;
    ZEROMEM( &pcontainer->UnknownContainer, SIZEOF( DRM_XMR_UNKNOWN_CONTAINER ) );

    while ( iCurrent < f_iObject + f_cbObject )
    {
        NETWORKBYTES_TO_WORD( wFlags, f_pbLicense, iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ), iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ) * 2, iCurrent );
        NETWORKBYTES_TO_WORD( wType, f_pbLicense, iCurrent + SIZEOF( DRM_WORD ) );
        NETWORKBYTES_TO_DWORD( cbChild, f_pbLicense, iCurrent + SIZEOF( DRM_WORD ) * 2 );
        ChkBOOL( cbChild <= ( f_iObject + ( f_cbObject - iCurrent ) ), DRM_E_INVALIDLICENSE );

        switch ( wType )
        {
            case XMR_OBJECT_TYPE_PLAYCOUNT_OBJECT:
                ChkBOOL( !pcontainer->PlayCount.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainer->PlayCount ) );
                break;
            case XMR_OBJECT_TYPE_OUTPUT_PROTECTION_OBJECT:
                ChkBOOL( !pcontainer->opl.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainer->opl ) );
                break;
            case XMR_OBJECT_TYPE_EXPLICIT_ANALOG_VIDEO_OUTPUT_PROTECTION_CONTAINER:
                ChkBOOL( !pcontainer->containerExplicitAnalogVideoProtection.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainer->containerExplicitAnalogVideoProtection ) );
                break;
            case XMR_OBJECT_TYPE_EXPLICIT_DIGITAL_AUDIO_OUTPUT_PROTECTION_CONTAINER:
                ChkBOOL( !pcontainer->containerExplicitDigitalAudioProtection.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainer->containerExplicitDigitalAudioProtection ) );
                break;

            case XMR_OBJECT_TYPE_PLAY_ENABLER_CONTAINER:
                ChkBOOL( ( wFlags & XMR_FLAGS_MUST_UNDERSTAND ) == 0, DRM_E_INVALIDLICENSE );
                ChkBOOL( ( wFlags & XMR_FLAGS_CONTAINER ) != 0, DRM_E_INVALIDLICENSE );

                if( !pcontainer->UnknownContainer.fValid )
                {
                    ZEROMEM( &pcontainer->UnknownContainer, SIZEOF( DRM_XMR_UNKNOWN_CONTAINER ) );

                    ChkDR( DRM_XMR_Parse_UnknownContainer( f_pStack,
                            f_pbLicense,
                            iCurrent,
                            cbChild,
                           &pcontainer->UnknownContainer ) );
                }
                else
                {
                    DRM_XMR_UNKNOWN_CONTAINER *pUnkContainer = NULL;

                    ChkDR( DRM_STK_Alloc_Aligned( f_pStack,
                                                  SIZEOF( DRM_XMR_UNKNOWN_CONTAINER ),
                                                  SIZEOF( DRM_DWORD ),
                                                  NULL,
                                                  ( DRM_VOID ** ) &pUnkContainer ) );

                    ZEROMEM( pUnkContainer, SIZEOF( DRM_XMR_UNKNOWN_CONTAINER ) );

                    ChkDR( DRM_XMR_Parse_UnknownContainer( f_pStack,
                                f_pbLicense,
                                iCurrent,
                                cbChild,
                                pUnkContainer ) );
                    pUnkContainer->pNext = pcontainer->UnknownContainer.pNext;
                    pcontainer->UnknownContainer.pNext = pUnkContainer;
                }
                break;

            default:
                /*
                ** We don't understand it, but if it allows us to try to externally
                ** parse the object then we may be able to continue
                */
                ChkBOOL( ( wFlags & XMR_FLAGS_MUST_UNDERSTAND ) == 0
                       || ( ( wFlags & XMR_FLAGS_ALLOW_EXTERNAL_PARSE ) != 0 && ( wFlags & XMR_FLAGS_CONTAINER ) == 0 ), DRM_E_INVALIDLICENSE );

                /* Only bother keeping it if it's allowed to be parsed externally, otherwise
                ** we may as well ignore it since we can't do anything else with it */
                if( ( wFlags & XMR_FLAGS_CONTAINER ) == 0
                 && ( wFlags & XMR_FLAGS_ALLOW_EXTERNAL_PARSE ) != 0 )
                {
                    /* Alloc space and add to linked list */
                    ChkDR( DRM_STK_Alloc_Aligned( f_pStack,
                                                  SIZEOF( DRM_XMR_UNKNOWN_OBJECT ),
                                                  SIZEOF( DRM_DWORD ),
                                                  NULL,
                                                  ( DRM_VOID ** ) &pUnknownObject ) );

                    ZEROMEM( pUnknownObject, SIZEOF( DRM_XMR_UNKNOWN_OBJECT ) );

                    ChkDR( DRM_XMR_Parse_UnknownObject( f_pStack,
                                                        f_pbLicense,
                                                        iCurrent,
                                                        cbChild,
                                                        pUnknownObject ) );

                    pUnknownObject->pNext = pcontainer->pUnknownObjects;
                    pcontainer->pUnknownObjects = pUnknownObject;
                }

                break;
        }
        ChkOverflow( iCurrent + cbChild, iCurrent );
        iCurrent += cbChild;
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_ExplicitAnalogVideoOutputProtectionContainer
**
** Synopsis :   Parse an analog video output protection container object
**
** Arguments :
**      [f_pStack]    : Stack for intermediate usage
**      [f_pbLicense] : Base address in license
**      [f_iObject]   : Index marking beginning of object in the buffer
**      [f_cbObject]  : Size of serialized object
**      [f_pvObject]  : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          A parsing error occurred
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL 
DRM_XMR_Parse_ExplicitAnalogVideoOutputProtectionContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbLicense,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT dr       = DRM_SUCCESS;
    DRM_DWORD  iCurrent = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_WORD   wFlags   = 0;
    DRM_WORD   wType    = 0;
    DRM_DWORD  cbChild  = 0;
    DRM_XMR_EXPLICIT_ANALOG_VIDEO_PROTECTION *pcontainer =
            ( DRM_XMR_EXPLICIT_ANALOG_VIDEO_PROTECTION * )f_pvObject;
    DRM_XMR_VIDEO_OUTPUT_CONFIGURATION_LIST  *pListNode  = NULL;

    ChkArg( f_pbLicense != NULL );
    ChkArg( f_pvObject  != NULL );
    ChkOverflow( iCurrent, f_iObject );
    ChkOverflow( f_iObject + f_cbObject, f_iObject );
    
    pcontainer->fValid = TRUE;
    pcontainer->cOutputProtectionIDs        = 0;

    while ( iCurrent < f_iObject + f_cbObject )
    {
        NETWORKBYTES_TO_WORD( wFlags, f_pbLicense, iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ), iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ) * 2, iCurrent );
        NETWORKBYTES_TO_WORD( wType, f_pbLicense, iCurrent + SIZEOF( DRM_WORD ) );
        NETWORKBYTES_TO_DWORD( cbChild, f_pbLicense, iCurrent + SIZEOF( DRM_WORD ) * 2 );
        ChkBOOL( cbChild <= ( f_iObject + ( f_cbObject - iCurrent ) ), DRM_E_INVALIDLICENSE );

        switch ( wType )
        {
            case XMR_OBJECT_TYPE_ANALOG_VIDEO_OUTPUT_CONFIGURATION_OBJECT:
                ChkDR( DRM_STK_Alloc_Aligned( f_pStack,
                                              SIZEOF( DRM_XMR_VIDEO_OUTPUT_CONFIGURATION_LIST ),
                                              SIZEOF( DRM_DWORD ),
                                              NULL,
                                              ( DRM_VOID ** )&pListNode ) );

                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pListNode->Config ) );
                pListNode->pNext = pcontainer->plistOutputConfiguration;
                pcontainer->plistOutputConfiguration = pListNode;
                pcontainer->cOutputProtectionIDs++;
                break;

            default:
                ChkBOOL( ( wFlags & XMR_FLAGS_MUST_UNDERSTAND ) == 0, DRM_E_INVALIDLICENSE );
        };
        ChkOverflow( iCurrent + cbChild, iCurrent );
        iCurrent += cbChild;
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_ExplicitDigitalAudioOutputProtectionContainer
**
** Synopsis :   Parse a digital audio output protection container object
**
** Arguments :
**      [f_pStack]    : Stack for intermediate usage
**      [f_pbLicense] : Base address in license
**      [f_iObject]   : Index marking beginning of object in the buffer
**      [f_cbObject]  : Size of serialized object
**      [f_pvObject]  : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          A parsing error occurred
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL 
DRM_XMR_Parse_ExplicitDigitalAudioOutputProtectionContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbLicense,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT dr       = DRM_SUCCESS;
    DRM_DWORD  iCurrent = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_WORD   wFlags   = 0;
    DRM_WORD   wType    = 0;
    DRM_DWORD  cbChild  = 0;
    DRM_XMR_EXPLICIT_DIGITAL_AUDIO_PROTECTION *pcontainer =
            ( DRM_XMR_EXPLICIT_DIGITAL_AUDIO_PROTECTION * )f_pvObject;
    DRM_XMR_AUDIO_OUTPUT_CONFIGURATION_LIST  *pListNode  = NULL;

    ChkArg( f_pbLicense != NULL );
    ChkArg( f_pvObject  != NULL );
    ChkOverflow( iCurrent, f_iObject );
    ChkOverflow( f_iObject + f_cbObject, f_iObject );

    pcontainer->fValid = TRUE;
    pcontainer->cOutputProtectionIDs        = 0;

    while ( iCurrent < f_iObject + f_cbObject )
    {
        NETWORKBYTES_TO_WORD( wFlags, f_pbLicense, iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ), iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ) * 2, iCurrent );
        NETWORKBYTES_TO_WORD( wType, f_pbLicense, iCurrent + SIZEOF( DRM_WORD ) );
        NETWORKBYTES_TO_DWORD( cbChild, f_pbLicense, iCurrent + SIZEOF( DRM_WORD ) * 2 );
        ChkBOOL( cbChild <= ( f_iObject + ( f_cbObject - iCurrent ) ), DRM_E_INVALIDLICENSE );

        switch ( wType )
        {
            case XMR_OBJECT_TYPE_DIGITAL_AUDIO_OUTPUT_CONFIGURATION_OBJECT:
                ChkDR( DRM_STK_Alloc_Aligned( f_pStack,
                                              SIZEOF( DRM_XMR_AUDIO_OUTPUT_CONFIGURATION_LIST ),
                                              SIZEOF( DRM_DWORD ),
                                              NULL,
                                              ( DRM_VOID ** ) &pListNode ) );

                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pListNode->Config ) );
                pListNode->pNext = pcontainer->plistOutputConfiguration;
                pcontainer->plistOutputConfiguration = pListNode;
                pcontainer->cOutputProtectionIDs++;
                break;

            default:
                ChkBOOL( ( wFlags & XMR_FLAGS_MUST_UNDERSTAND ) == 0, DRM_E_INVALIDLICENSE );
        };
        ChkOverflow( iCurrent + cbChild, iCurrent );
        iCurrent += cbChild;
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_PolicyMetadata
**
** Synopsis :   Parse the policy metadata object
**
** Arguments :
**      [f_pStack]    : Stack for intermediate usage
**      [f_pbLicense] : Base address in license
**      [f_iObject]   : Index marking beginning of object in the buffer
**      [f_cbObject]  : Size of serialized object
**      [f_pvObject]  : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          A parsing error occurred
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_PolicyMetadata(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbLicense,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT dr       = DRM_SUCCESS;
    DRM_XMR_POLICY_METADATA *pMetaData =
            ( DRM_XMR_POLICY_METADATA * )f_pvObject;
    DRM_XMR_POLICY_METADATA_LIST  *pListNode  = NULL;

    ChkArg(  f_pbLicense != NULL );
    ChkArg(  f_pvObject  != NULL );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH + SIZEOF( DRM_GUID ),
             DRM_E_INVALIDLICENSE );
    
    /* Since there can be multiple Policy Metadata objects, this function can get called multiple times
        ** Initialize the member variables only on the first call */
    if( pMetaData->fValid == FALSE )
    {
        pMetaData->fValid = TRUE;
        pMetaData->cPolicyMetadataObjects = 0;
        pMetaData->plistPolicyMetadataObjects = NULL;
    }

    ChkDR( DRM_STK_Alloc_Aligned( f_pStack,
                                  SIZEOF( DRM_XMR_POLICY_METADATA_LIST ),
                                  SIZEOF( DRM_DWORD ),
                                  NULL,
                                  ( DRM_VOID ** ) &pListNode ) );

    pListNode->MetadataObject.pMetadataTypeGuidBuffer = ( DRM_BYTE * )f_pbLicense;
    ChkOverflow( f_iObject + XMR_BASE_OBJECT_LENGTH, f_iObject );
    pListNode->MetadataObject.iMetadataTypeGuid       = f_iObject + XMR_BASE_OBJECT_LENGTH;
    pListNode->MetadataObject.pbPolicyDataBuffer      = ( DRM_BYTE * )f_pbLicense;
    ChkOverflow( pListNode->MetadataObject.iMetadataTypeGuid + SIZEOF( DRM_GUID ),pListNode->MetadataObject.iMetadataTypeGuid );
    pListNode->MetadataObject.iPolicyData             = pListNode->MetadataObject.iMetadataTypeGuid + SIZEOF( DRM_GUID );
    pListNode->MetadataObject.cbPolicyData            = ( f_cbObject - XMR_BASE_OBJECT_LENGTH ) - SIZEOF( DRM_GUID );
    pListNode->MetadataObject.fValid                  = TRUE;

    pListNode->pNext                                  = pMetaData->plistPolicyMetadataObjects;

    pMetaData->plistPolicyMetadataObjects             = pListNode;
    ChkOverflow( pMetaData->cPolicyMetadataObjects + 1, pMetaData->cPolicyMetadataObjects );
    pMetaData->cPolicyMetadataObjects++;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_RevocationContainer
**
** Synopsis :   Parse a revocation container object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          A parsing error occurred
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_RevocationContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbLicense,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT          dr         = DRM_SUCCESS;
    DRM_DWORD           iCurrent   = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_WORD            wFlags     = 0;
    DRM_WORD            wType      = 0;
    DRM_DWORD           cbChild    = 0;
    DRM_XMR_REVOCATION *pcontainer = ( DRM_XMR_REVOCATION * )f_pvObject;

    ChkArg( f_pbLicense != NULL );
    ChkArg( f_pvObject  != NULL );
    ChkOverflow( iCurrent, f_iObject );
    ChkOverflow( f_iObject + f_cbObject, f_iObject );

    pcontainer->fValid                       = TRUE;
    pcontainer->RsaLicenseGranterKey.fValid  = FALSE;
    pcontainer->UserID.fValid                = FALSE;

    while ( iCurrent < f_iObject + f_cbObject )
    {
        NETWORKBYTES_TO_WORD( wFlags, f_pbLicense, iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ), iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ) * 2, iCurrent );
        NETWORKBYTES_TO_WORD( wType, f_pbLicense, iCurrent + SIZEOF( DRM_WORD ) );
        NETWORKBYTES_TO_DWORD( cbChild, f_pbLicense, iCurrent + ( SIZEOF( DRM_WORD ) * 2 ) );
        ChkBOOL( cbChild <= ( f_iObject + ( f_cbObject - iCurrent ) ), DRM_E_INVALIDLICENSE );

        switch ( wType )
        {

            case XMR_OBJECT_TYPE_RSA_LICENSE_GRANTER_KEY_OBJECT:
                ChkBOOL( !pcontainer->RsaLicenseGranterKey.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainer->RsaLicenseGranterKey ) );
                break;
            case XMR_OBJECT_TYPE_USERID_OBJECT:
                ChkBOOL( !pcontainer->UserID.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainer->UserID ) );
                break;
            default:
                ChkBOOL( ( wFlags & XMR_FLAGS_MUST_UNDERSTAND ) == 0, DRM_E_INVALIDLICENSE );
        };
        ChkOverflow( iCurrent + cbChild, iCurrent );
        iCurrent += cbChild;
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_KeyMaterialContainer
**
** Synopsis :   Parse a key material container object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          A parsing error occurred
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_KeyMaterialContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbLicense,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT            dr         = DRM_SUCCESS;
    DRM_DWORD             iCurrent   = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_WORD              wFlags     = 0;
    DRM_WORD              wType      = 0;
    DRM_DWORD             cbChild    = 0;
    DRM_XMR_KEY_MATERIAL *pcontainer = ( DRM_XMR_KEY_MATERIAL * )f_pvObject;

    ChkArg( f_pbLicense != NULL );
    ChkArg( f_pvObject  != NULL );
    ChkOverflow( iCurrent, f_iObject );
    ChkOverflow( f_iObject + f_cbObject, f_iObject );

    pcontainer->fValid                     = TRUE;
    pcontainer->ContentKey.fValid          = FALSE;
    pcontainer->OptimizedContentKey.fValid = FALSE;
    pcontainer->DeviceKey.fValid           = FALSE;
    pcontainer->ECCKey.fValid              = FALSE;
    pcontainer->UplinkKid.fValid           = FALSE;

    while ( iCurrent < f_iObject + f_cbObject )
    {
        NETWORKBYTES_TO_WORD( wFlags, f_pbLicense, iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ), iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ) * 2, iCurrent );
        NETWORKBYTES_TO_WORD( wType, f_pbLicense, iCurrent + SIZEOF( DRM_WORD ) );
        NETWORKBYTES_TO_DWORD( cbChild, f_pbLicense, iCurrent + ( SIZEOF( DRM_WORD ) * 2 ) );
        ChkBOOL( cbChild <= ( f_iObject + ( f_cbObject - iCurrent ) ), DRM_E_INVALIDLICENSE );

        switch ( wType )
        {
            case XMR_OBJECT_TYPE_CONTENT_KEY_OBJECT:
                ChkBOOL( !pcontainer->ContentKey.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainer->ContentKey ) );
                break;
            case XMR_OBJECT_TYPE_OPTIMIZED_CONTENT_KEY_OBJECT:
                ChkBOOL( !pcontainer->OptimizedContentKey.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainer->OptimizedContentKey ) );
                break;
            case XMR_OBJECT_TYPE_RSA_DEVICE_KEY_OBJECT:
                ChkBOOL( !pcontainer->DeviceKey.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainer->DeviceKey ) );
                break;
            case XMR_OBJECT_TYPE_UPLINK_KID_OBJECT:
            case XMR_OBJECT_TYPE_UPLINK_KID_2_OBJECT:
                ChkBOOL( !pcontainer->UplinkKid.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainer->UplinkKid ) );
                pcontainer->UplinkKid.dwVersion =
                    ( wType == XMR_OBJECT_TYPE_UPLINK_KID_OBJECT ) ? 1 : 2;
                break;
            case XMR_OBJECT_TYPE_ECC_DEVICE_KEY_OBJECT:
                ChkBOOL( !pcontainer->ECCKey.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainer->ECCKey ) );
                break;
            default:
                ChkBOOL( ( wFlags & XMR_FLAGS_MUST_UNDERSTAND ) == 0, DRM_E_INVALIDLICENSE );
        };
        ChkOverflow( iCurrent + cbChild, iCurrent );
        iCurrent += cbChild;
    }

ErrorExit:
    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_CopyToPCContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE                    *f_pbLicense,
    IN          DRM_DWORD                    f_iObject,
    IN          DRM_DWORD                    f_cbObject,
    IN  OUT     DRM_VOID                    *f_pvObject )
{
    DRM_RESULT           dr         = DRM_SUCCESS;
    DRM_DWORD            iCurrent   = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_WORD             wFlags     = 0;
    DRM_WORD             wType      = 0;
    DRM_DWORD            cbChild    = 0;
    DRM_XMR_COPY_TO_PC  *pcontainer = ( DRM_XMR_COPY_TO_PC * )f_pvObject;

    ChkArg( f_pbLicense != NULL );
    ChkArg( f_pvObject  != NULL );
    ChkOverflow( iCurrent, f_iObject );
    ChkOverflow( f_iObject + f_cbObject, f_iObject );
    
    pcontainer->fValid  = TRUE;

    while ( iCurrent < f_iObject + f_cbObject )
    {
        NETWORKBYTES_TO_WORD( wFlags, f_pbLicense, iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ), iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ) * 2, iCurrent );
        NETWORKBYTES_TO_WORD( wType, f_pbLicense, iCurrent + SIZEOF( DRM_WORD ) );
        NETWORKBYTES_TO_DWORD( cbChild, f_pbLicense, iCurrent + SIZEOF( DRM_WORD ) * 2 );
        ChkBOOL( cbChild <= ( f_iObject + ( f_cbObject - iCurrent ) ), DRM_E_INVALIDLICENSE );

        /* We don't understand any children for this object */
        ChkBOOL( ( wFlags & XMR_FLAGS_MUST_UNDERSTAND ) == 0, DRM_E_INVALIDLICENSE );

        ChkOverflow( iCurrent + cbChild, iCurrent );
        iCurrent += cbChild;
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_CopyContainer
**
** Synopsis :   Parse a copy container object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          A parsing error occurred
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_CopyContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE                    *f_pbLicense,
    IN          DRM_DWORD                    f_iObject,
    IN          DRM_DWORD                    f_cbObject,
    IN  OUT     DRM_VOID                    *f_pvObject )
{
    DRM_RESULT           dr         = DRM_SUCCESS;
    DRM_DWORD            iCurrent   = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_WORD             wFlags     = 0;
    DRM_WORD             wType      = 0;
    DRM_DWORD            cbChild    = 0;
    DRM_XMR_UNKNOWN_OBJECT *pUnknownObject = NULL;
    DRM_XMR_COPY_RIGHTS *pcontainer = ( DRM_XMR_COPY_RIGHTS * )f_pvObject;

    ChkArg( f_pbLicense != NULL );
    ChkArg( f_pvObject  != NULL );
    ChkOverflow( iCurrent, f_iObject );
    ChkOverflow( f_iObject + f_cbObject, f_iObject );

    pcontainer->fValid                      = TRUE;
    pcontainer->CopyCount.fValid            = FALSE;
    pcontainer->CopyProtectionLevel.fValid  = FALSE;
    pcontainer->MoveEnabler.fValid          = FALSE;
    pcontainer->pUnknownObjects             = NULL;
    ZEROMEM( &pcontainer->UnknownContainer, SIZEOF( DRM_XMR_UNKNOWN_CONTAINER ) );

    while ( iCurrent < f_iObject + f_cbObject )
    {
        NETWORKBYTES_TO_WORD( wFlags,  f_pbLicense, iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ), iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ) * 2, iCurrent );
        NETWORKBYTES_TO_WORD( wType,   f_pbLicense, iCurrent + SIZEOF( DRM_WORD ) );
        NETWORKBYTES_TO_DWORD( cbChild, f_pbLicense, iCurrent + SIZEOF( DRM_WORD ) * 2 );
        ChkBOOL( cbChild <= ( f_iObject + ( f_cbObject - iCurrent ) ), DRM_E_INVALIDLICENSE );

        switch ( wType )
        {
            case XMR_OBJECT_TYPE_COPYCOUNT_OBJECT:
            case XMR_OBJECT_TYPE_COPYCOUNT_2_OBJECT:
                ChkBOOL( !pcontainer->CopyCount.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainer->CopyCount ) );
                pcontainer->CopyCount.dwVersion =
                    ( wType == XMR_OBJECT_TYPE_COPYCOUNT_OBJECT ) ? 1 : 2;
                break;

            case XMR_OBJECT_TYPE_COPY_PROTECTION_OBJECT:
                ChkBOOL( !pcontainer->CopyProtectionLevel.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainer->CopyProtectionLevel ) );
                break;

            case XMR_OBJECT_TYPE_MOVE_ENABLER_OBJECT:
                ChkBOOL( !pcontainer->MoveEnabler.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainer->MoveEnabler ) );
                break;

            case XMR_OBJECT_TYPE_COPY_ENABLER_CONTAINER:
                ChkBOOL( ( wFlags & XMR_FLAGS_MUST_UNDERSTAND ) == 0, DRM_E_INVALIDLICENSE );
                ChkBOOL( ( wFlags & XMR_FLAGS_CONTAINER ) != 0, DRM_E_INVALIDLICENSE );

                if( !pcontainer->UnknownContainer.fValid )
                {
                    ZEROMEM( &pcontainer->UnknownContainer , SIZEOF( DRM_XMR_UNKNOWN_CONTAINER ) );

                    ChkDR( DRM_XMR_Parse_UnknownContainer( f_pStack,
                            f_pbLicense,
                            iCurrent,
                            cbChild,
                            &pcontainer->UnknownContainer ) );
                }
                else
                {
                    DRM_XMR_UNKNOWN_CONTAINER *pUnkContainer = NULL;

                    ChkDR( DRM_STK_Alloc_Aligned( f_pStack,
                                                  SIZEOF( DRM_XMR_UNKNOWN_CONTAINER ),
                                                  SIZEOF( DRM_DWORD ),
                                                  NULL,
                                                  ( DRM_VOID ** ) &pUnkContainer ) );

                    ZEROMEM( pUnkContainer, SIZEOF( DRM_XMR_UNKNOWN_CONTAINER ) );

                    ChkDR( DRM_XMR_Parse_UnknownContainer( f_pStack,
                                f_pbLicense,
                                iCurrent,
                                cbChild,
                                pUnkContainer ) );
                    pUnkContainer->pNext = pcontainer->UnknownContainer.pNext;
                    pcontainer->UnknownContainer.pNext = pUnkContainer;
                }
                break;

            default:
                /*
                ** We don't understand it, but if it allows us to try to externally
                ** parse the object then we may be able to continue
                */
                ChkBOOL( ( wFlags & XMR_FLAGS_MUST_UNDERSTAND ) == 0
                       || ( ( wFlags & XMR_FLAGS_ALLOW_EXTERNAL_PARSE ) != 0 && ( wFlags & XMR_FLAGS_CONTAINER ) == 0 ), DRM_E_INVALIDLICENSE );

                /* Only bother keeping it if it's allowed to be parsed externally, otherwise
                ** we may as well ignore it since we can't do anything else with it */
                if( ( wFlags & XMR_FLAGS_CONTAINER ) == 0
                 && ( wFlags & XMR_FLAGS_ALLOW_EXTERNAL_PARSE ) != 0 )
                {
                    /* Alloc space and add to linked list */
                    ChkDR( DRM_STK_Alloc_Aligned( f_pStack,
                                                  SIZEOF( DRM_XMR_UNKNOWN_OBJECT ),
                                                  SIZEOF( DRM_DWORD ),
                                                  NULL,
                                                  ( DRM_VOID ** ) &pUnknownObject ) );

                    ZEROMEM( pUnknownObject, SIZEOF( DRM_XMR_UNKNOWN_OBJECT ) );

                    ChkDR( DRM_XMR_Parse_UnknownObject( f_pStack,
                                                        f_pbLicense,
                                                        iCurrent,
                                                        cbChild,
                                                        pUnknownObject ) );

                    pUnknownObject->pNext = pcontainer->pUnknownObjects;
                    pcontainer->pUnknownObjects = pUnknownObject;
                }
                break;
        };
        ChkOverflow( iCurrent + cbChild, iCurrent );
        iCurrent += cbChild;
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_CopyContainer
**
** Synopsis :   Parse a playlist burn container object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          A parsing error occurred
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_PlaylistBurnContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbLicense,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT                    dr         = DRM_SUCCESS;
    DRM_DWORD                     iCurrent   = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_WORD                      wFlags     = 0;
    DRM_WORD                      wType      = 0;
    DRM_DWORD                     cbChild    = 0;
    DRM_XMR_UNKNOWN_OBJECT *pUnknownObject   = NULL;
    DRM_XMR_PLAYLIST_BURN_RIGHTS *pcontainer = ( DRM_XMR_PLAYLIST_BURN_RIGHTS * )f_pvObject;

    ChkArg( f_pbLicense != NULL );
    ChkArg( f_pvObject  != NULL );
    ChkOverflow( iCurrent, f_iObject );
    ChkOverflow( f_iObject + f_cbObject, f_iObject );
    
    pcontainer->fValid = TRUE;
    pcontainer->Restrictions.fValid = FALSE;
    pcontainer->pUnknownObjects     = NULL;

    while ( iCurrent < f_iObject + f_cbObject )
    {
        NETWORKBYTES_TO_WORD( wFlags,  f_pbLicense, iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ), iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ) * 2, iCurrent );
        NETWORKBYTES_TO_WORD( wType,   f_pbLicense, iCurrent + SIZEOF( DRM_WORD ) );
        NETWORKBYTES_TO_DWORD( cbChild, f_pbLicense, iCurrent + SIZEOF( DRM_WORD ) * 2 );
        ChkBOOL( cbChild <= ( f_iObject + ( f_cbObject - iCurrent ) ), DRM_E_INVALIDLICENSE );

        switch ( wType )
        {
            case XMR_OBJECT_TYPE_PLAYLISTBURN_COUNT_OBJECT:
                ChkBOOL( !pcontainer->Restrictions.fValid, DRM_E_INVALIDLICENSE );
                ChkDR( g_xmrParserDefines[wType].fnParse( f_pStack,
                                                    f_pbLicense,
                                                    iCurrent,
                                                    cbChild,
                                                   &pcontainer->Restrictions ) );
                break;

            default:
                /*
                ** We don't understand it, but if it allows us to try to externally
                ** parse the object then we may be able to continue
                */
                ChkBOOL( ( wFlags & XMR_FLAGS_MUST_UNDERSTAND ) == 0
                       || ( ( wFlags & XMR_FLAGS_ALLOW_EXTERNAL_PARSE ) != 0 && ( wFlags & XMR_FLAGS_CONTAINER ) == 0 ), DRM_E_INVALIDLICENSE );

                /* Only bother keeping it if it's allowed to be parsed externally, otherwise
                ** we may as well ignore it since we can't do anything else with it */
                if( ( wFlags & XMR_FLAGS_CONTAINER ) == 0
                 && ( wFlags & XMR_FLAGS_ALLOW_EXTERNAL_PARSE ) != 0 )
                {
                    /* Alloc space and add to linked list */
                    ChkDR( DRM_STK_Alloc_Aligned( f_pStack,
                                                  SIZEOF( DRM_XMR_UNKNOWN_OBJECT ),
                                                  SIZEOF( DRM_DWORD ),
                                                  NULL,
                                                  ( DRM_VOID ** ) &pUnknownObject ) );

                    ZEROMEM( pUnknownObject, SIZEOF( DRM_XMR_UNKNOWN_OBJECT ) );

                    ChkDR( DRM_XMR_Parse_UnknownObject( f_pStack,
                                                        f_pbLicense,
                                                        iCurrent,
                                                        cbChild,
                                                        pUnknownObject ) );

                    pUnknownObject->pNext = pcontainer->pUnknownObjects;
                    pcontainer->pUnknownObjects = pUnknownObject;
                }
                break;
        };
        ChkOverflow( iCurrent + cbChild, iCurrent );
        iCurrent += cbChild;
    }

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_Empty
**
** Synopsis :   Parse an empty object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_Empty(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH, DRM_E_INVALIDLICENSE );

    ( ( DRM_XMR_EMPTY * )f_pvObject )->fValid = TRUE;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_WORD
**
** Synopsis :   Parse a word object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_WORD(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT    dr    = DRM_SUCCESS;
    DRM_XMR_WORD *pword = ( DRM_XMR_WORD * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH + SIZEOF( DRM_WORD ), DRM_E_INVALIDLICENSE );
    ChkOverflow( f_iObject + XMR_BASE_OBJECT_LENGTH, f_iObject );
    
    pword->fValid = TRUE;
    NETWORKBYTES_TO_WORD( pword->wValue,
                          f_pbBuffer,
                          f_iObject + XMR_BASE_OBJECT_LENGTH );

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_DWORD
**
** Synopsis :   Parse a dword object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_DWORD(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT     dr     = DRM_SUCCESS;
    DRM_XMR_DWORD *pdword = ( DRM_XMR_DWORD * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH + SIZEOF( DRM_DWORD ), DRM_E_INVALIDLICENSE );
    ChkOverflow( f_iObject + XMR_BASE_OBJECT_LENGTH, f_iObject );
    
    pdword->fValid = TRUE;
    NETWORKBYTES_TO_DWORD( pdword->dwValue,
                           f_pbBuffer,
                           f_iObject + XMR_BASE_OBJECT_LENGTH );

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_DWORD_Versioned
**
** Synopsis :   Parse a dword object with version
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_DWORD_Versioned(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT     dr     = DRM_SUCCESS;
    DRM_XMR_DWORD_VERSIONED *pdword = ( DRM_XMR_DWORD_VERSIONED * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH + SIZEOF( DRM_DWORD ), DRM_E_INVALIDLICENSE );
    ChkOverflow( f_iObject + XMR_BASE_OBJECT_LENGTH, f_iObject );
    
    pdword->fValid = TRUE;
    NETWORKBYTES_TO_DWORD( pdword->dwValue,
                           f_pbBuffer,
                           f_iObject + XMR_BASE_OBJECT_LENGTH );

ErrorExit:
    return dr;
}


/******************************************************************************
**
** Function :   DRM_XMR_Parse_GUID
**
** Synopsis :   Parse a GUID object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_GUID(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT    dr    = DRM_SUCCESS;
    DRM_XMR_GUID *pguid = ( DRM_XMR_GUID * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH + SIZEOF( DRM_GUID ), DRM_E_INVALIDLICENSE );
    ChkOverflow( f_iObject + XMR_BASE_OBJECT_LENGTH, f_iObject );
    
    pguid->pguidBuffer = ( DRM_BYTE * )f_pbBuffer;
    pguid->iGuid       = f_iObject + XMR_BASE_OBJECT_LENGTH;
    pguid->fValid      = TRUE;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_GUIDLIST
**
** Synopsis :   Parse a GUID list object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_GUIDLIST(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT        dr        = DRM_SUCCESS;
    DRM_DWORD         iObject   = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_XMR_GUIDLIST *pguidlist = ( DRM_XMR_GUIDLIST * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH + SIZEOF( DRM_DWORD ), DRM_E_INVALIDLICENSE );
    ChkOverflow( iObject, f_iObject );
    
    NETWORKBYTES_TO_DWORD( pguidlist->cGUIDs, f_pbBuffer, iObject );

    ChkOverflow( iObject + SIZEOF( DRM_DWORD ), iObject);
    iObject += SIZEOF( DRM_DWORD );

    ChkOverflow( f_iObject + f_cbObject, f_iObject );
    ChkOverflow( DRM_UINT_MAX, ( (DRM_LONG) pguidlist->cGUIDs ) * ( (DRM_LONG) SIZEOF( DRM_GUID ) ) );
    ChkOverflow( iObject + pguidlist->cGUIDs * SIZEOF( DRM_GUID ), iObject );
    ChkBOOL( f_iObject + f_cbObject == iObject + pguidlist->cGUIDs * SIZEOF( DRM_GUID ),
             DRM_E_INVALIDLICENSE );

    pguidlist->pguidBuffer = ( DRM_BYTE * )f_pbBuffer;
    pguidlist->iGuids      = iObject;
    pguidlist->fValid      = TRUE;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_BYTEARRAY
**
** Synopsis :   Parse a byte array object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_BYTEARRAY(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT         dr          = DRM_SUCCESS;
    DRM_XMR_BYTEARRAY *pbytearray  = ( DRM_XMR_BYTEARRAY * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH, DRM_E_INVALIDLICENSE );
    ChkOverflow( f_iObject + XMR_BASE_OBJECT_LENGTH, f_iObject );
    
    pbytearray->cbData        = f_cbObject - XMR_BASE_OBJECT_LENGTH;
    pbytearray->pbDataBuffer  = ( DRM_BYTE * )f_pbBuffer;
    pbytearray->iData         = f_iObject + XMR_BASE_OBJECT_LENGTH;
    pbytearray->fValid        = TRUE;

ErrorExit:
    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_SecurityLevel(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT                   dr                  = DRM_SUCCESS;
    DRM_DWORD                    iObject             = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_XMR_MINIMUM_ENVIRONMENT *pMinimumEnvironment =
                                    ( DRM_XMR_MINIMUM_ENVIRONMENT * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject == XMR_BASE_OBJECT_LENGTH + SIZEOF( DRM_WORD ),
             DRM_E_INVALIDLICENSE );
    ChkOverflow( iObject, f_iObject );
    
    NETWORKBYTES_TO_WORD( pMinimumEnvironment->wMinimumSecurityLevel,
                          f_pbBuffer,
                          iObject );
    ChkOverflow( iObject + SIZEOF( DRM_WORD ), iObject );
    iObject += SIZEOF( DRM_WORD );

    pMinimumEnvironment->dwMinimumAppRevocationListVersion = 0;
    pMinimumEnvironment->dwMinimumDeviceRevocationListVersion = 0;
    pMinimumEnvironment->fValid = TRUE;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_MinimumEnvironment
**
** Synopsis :   Parse a minimum environment object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_MinimumEnvironment(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT                   dr                  = DRM_SUCCESS;
    DRM_DWORD                    iObject             = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_XMR_MINIMUM_ENVIRONMENT *pMinimumEnvironment =
                                    ( DRM_XMR_MINIMUM_ENVIRONMENT * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject == XMR_BASE_OBJECT_LENGTH + SIZEOF( DRM_WORD ) + SIZEOF( DRM_DWORD ) * 2,
             DRM_E_INVALIDLICENSE );
    ChkOverflow( iObject, f_iObject );

    NETWORKBYTES_TO_WORD( pMinimumEnvironment->wMinimumSecurityLevel,
                          f_pbBuffer,
                          iObject );
    ChkOverflow( iObject + SIZEOF( DRM_WORD ), iObject );
    iObject += SIZEOF( DRM_WORD );

    NETWORKBYTES_TO_DWORD( pMinimumEnvironment->dwMinimumAppRevocationListVersion,
                           f_pbBuffer,
                           iObject );
    ChkOverflow( iObject + SIZEOF( DRM_DWORD ), iObject );
    iObject += SIZEOF( DRM_DWORD );

    NETWORKBYTES_TO_DWORD( pMinimumEnvironment->dwMinimumDeviceRevocationListVersion,
                          f_pbBuffer,
                          iObject );
    pMinimumEnvironment->fValid = TRUE;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_Expiration
**
** Synopsis :   Parse an expiration object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_Expiration(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT          dr          = DRM_SUCCESS;
    DRM_DWORD           iObject     = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_XMR_EXPIRATION *pExpiration = ( DRM_XMR_EXPIRATION * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject == XMR_BASE_OBJECT_LENGTH + SIZEOF( DRM_DWORD ) * 2,
             DRM_E_INVALIDLICENSE );
    ChkOverflow( iObject, f_iObject );

    NETWORKBYTES_TO_DWORD( pExpiration->dwBeginDate,
                           f_pbBuffer,
                           iObject );
    ChkOverflow( iObject + SIZEOF( DRM_DWORD ), iObject );
    iObject += SIZEOF( DRM_DWORD );

    NETWORKBYTES_TO_DWORD( pExpiration->dwEndDate,
                          f_pbBuffer,
                          iObject );
    pExpiration->fValid = TRUE;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_OPLs
**
** Synopsis :   Parse an OPL object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_OPLs(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT dr      = DRM_SUCCESS;
    DRM_DWORD  iObject = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_XMR_MINIMUM_OUTPUT_PROTECTION_LEVELS *pOPLs =
            ( DRM_XMR_MINIMUM_OUTPUT_PROTECTION_LEVELS * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject == XMR_BASE_OBJECT_LENGTH + ( SIZEOF( DRM_WORD ) * 5 ),
             DRM_E_INVALIDLICENSE );
    ChkOverflow( iObject, f_iObject );

    NETWORKBYTES_TO_WORD( pOPLs->wCompressedDigitalVideo, f_pbBuffer, iObject );
    ChkOverflow( iObject + SIZEOF( DRM_WORD ), iObject );
    iObject += SIZEOF( DRM_WORD );

    NETWORKBYTES_TO_WORD( pOPLs->wUncompressedDigitalVideo, f_pbBuffer, iObject );
    ChkOverflow( iObject + SIZEOF( DRM_WORD ), iObject );
    iObject += SIZEOF( DRM_WORD );

    NETWORKBYTES_TO_WORD( pOPLs->wAnalogVideo, f_pbBuffer, iObject );
    ChkOverflow( iObject + SIZEOF( DRM_WORD ), iObject );
    iObject += SIZEOF( DRM_WORD );

    NETWORKBYTES_TO_WORD( pOPLs->wCompressedDigitalAudio, f_pbBuffer, iObject );
    ChkOverflow( iObject + SIZEOF( DRM_WORD ), iObject );
    iObject += SIZEOF( DRM_WORD );

    NETWORKBYTES_TO_WORD( pOPLs->wUncompressedDigitalAudio, f_pbBuffer, iObject );
    ChkOverflow( iObject + SIZEOF( DRM_WORD ), iObject );
    iObject += SIZEOF( DRM_WORD );
    pOPLs->fValid = TRUE;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_VideoOutputConfig
**
** Synopsis :   Parse a video output configuration object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_VideoOutputConfig(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT  dr      = DRM_SUCCESS;
    DRM_XMR_VIDEO_OUTPUT_CONFIGURATION  *pVideoConfig =
            ( DRM_XMR_VIDEO_OUTPUT_CONFIGURATION * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH + SIZEOF( DRM_GUID ),
             DRM_E_INVALIDLICENSE );
    ChkOverflow( f_iObject + XMR_BASE_OBJECT_LENGTH, f_iObject);

    pVideoConfig->pguidBuffer         = ( DRM_BYTE * )f_pbBuffer;
    pVideoConfig->iGuid               = f_iObject + XMR_BASE_OBJECT_LENGTH;
    pVideoConfig->cbConfigData        = ( f_cbObject - XMR_BASE_OBJECT_LENGTH ) - SIZEOF( DRM_GUID );
    pVideoConfig->iConfigData         = 0;

    if ( pVideoConfig->cbConfigData > 0 )
    {
        ChkDR( DRM_STK_Alloc_Aligned( f_pStack,
                                      pVideoConfig->cbConfigData,
                                      SIZEOF( DRM_DWORD ),
                                      NULL,
                                      ( DRM_VOID ** ) &pVideoConfig->pbConfigDataBuffer ) );

        ChkOverflow( pVideoConfig->iGuid + SIZEOF( DRM_GUID ), pVideoConfig->iGuid );
        DRM_BYT_CopyBytes( pVideoConfig->pbConfigDataBuffer,
                           pVideoConfig->iConfigData,
                           f_pbBuffer,
                           pVideoConfig->iGuid + SIZEOF( DRM_GUID ),
                           pVideoConfig->cbConfigData );

    }
    else
    {
        pVideoConfig->pbConfigDataBuffer = NULL;
    }
    
    pVideoConfig->fValid = TRUE;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_AudioOutputConfig
**
** Synopsis :   Parse a audio output configuration object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_AudioOutputConfig(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT  dr      = DRM_SUCCESS;
    DRM_XMR_AUDIO_OUTPUT_CONFIGURATION  *pAudioConfig =
            ( DRM_XMR_AUDIO_OUTPUT_CONFIGURATION * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH + SIZEOF( DRM_GUID ),
             DRM_E_INVALIDLICENSE );
    ChkOverflow( f_iObject + XMR_BASE_OBJECT_LENGTH, f_iObject );

    pAudioConfig->pguidBuffer         = ( DRM_BYTE * )f_pbBuffer;
    pAudioConfig->iGuid               = f_iObject + XMR_BASE_OBJECT_LENGTH;
    pAudioConfig->cbConfigData        = ( f_cbObject - XMR_BASE_OBJECT_LENGTH ) - SIZEOF( DRM_GUID );
    pAudioConfig->iConfigData         = 0;

    if ( pAudioConfig->cbConfigData > 0 )
    {
        ChkDR( DRM_STK_Alloc_Aligned( f_pStack,
                                      pAudioConfig->cbConfigData,
                                      SIZEOF( DRM_DWORD ),
                                      NULL,
                                      ( DRM_VOID ** ) &pAudioConfig->pbConfigDataBuffer ) );

        ChkOverflow( pAudioConfig->iGuid + SIZEOF( DRM_GUID ), pAudioConfig->iGuid );
        DRM_BYT_CopyBytes( pAudioConfig->pbConfigDataBuffer,
                           pAudioConfig->iConfigData,
                           f_pbBuffer,
                           pAudioConfig->iGuid + SIZEOF( DRM_GUID ),
                           pAudioConfig->cbConfigData );

    }
    else
    {
        pAudioConfig->pbConfigDataBuffer = NULL;
    }
    pAudioConfig->fValid = TRUE;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_PlaylistBurnRights
**
** Synopsis :   Parse a playlist burn rights object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_PlaylistBurnRights(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT dr      = DRM_SUCCESS;
    DRM_DWORD  iObject = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_XMR_PLAYLIST_BURN_RESTRICTIONS *pPlaylistBurnRestrictions =
                            ( DRM_XMR_PLAYLIST_BURN_RESTRICTIONS * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject == XMR_BASE_OBJECT_LENGTH + SIZEOF( DRM_DWORD ) * 2,
             DRM_E_INVALIDLICENSE );
    ChkOverflow( iObject, f_iObject );

    NETWORKBYTES_TO_DWORD( pPlaylistBurnRestrictions->dwMaxPlaylistBurnCount,
                           f_pbBuffer,
                           iObject );
    ChkOverflow( iObject + SIZEOF( DRM_DWORD ), iObject );
    iObject += SIZEOF( DRM_DWORD );

    NETWORKBYTES_TO_DWORD( pPlaylistBurnRestrictions->dwPlaylistBurnTrackCount,
                           f_pbBuffer,
                           iObject );
    pPlaylistBurnRestrictions->fValid = TRUE;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_UserID
**
** Synopsis :   Parse a user ID object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_UserID(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT      dr      = DRM_SUCCESS;
    DRM_XMR_USERID *pUserID = ( DRM_XMR_USERID * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH, DRM_E_INVALIDLICENSE );
    ChkOverflow( f_iObject + XMR_BASE_OBJECT_LENGTH, f_iObject );
    
    pUserID->pbUserID = ( DRM_BYTE * )f_pbBuffer;
    pUserID->iUserID  = f_iObject + XMR_BASE_OBJECT_LENGTH;
    pUserID->cbUserID = f_cbObject - XMR_BASE_OBJECT_LENGTH;
    pUserID->fValid   = TRUE;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_ContentKey
**
** Synopsis :   Parse a content key object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_ContentKey(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT           dr          = DRM_SUCCESS;
    DRM_DWORD            iObject     = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_XMR_CONTENT_KEY *pContentKey = ( DRM_XMR_CONTENT_KEY * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH
                         + ( SIZEOF( DRM_WORD ) * 3 )
                         + SIZEOF( DRM_GUID ), DRM_E_INVALIDLICENSE );
    ChkOverflow( iObject, f_iObject );

    pContentKey->pbguidKeyID = ( DRM_BYTE * )f_pbBuffer;
    pContentKey->iguidKeyID  = iObject;
    ChkOverflow( iObject + SIZEOF( DRM_GUID ), iObject );
    iObject += SIZEOF( DRM_GUID );

    NETWORKBYTES_TO_WORD( pContentKey->wSymmetricCipherType, f_pbBuffer, iObject );
    ChkOverflow( iObject + SIZEOF( DRM_WORD ), iObject );
    iObject += SIZEOF( DRM_WORD );

    NETWORKBYTES_TO_WORD( pContentKey->wKeyEncryptionCipherType, f_pbBuffer, iObject );
    ChkOverflow( iObject + SIZEOF( DRM_WORD ), iObject );
    iObject += SIZEOF( DRM_WORD );

    NETWORKBYTES_TO_WORD( pContentKey->cbEncryptedKey, f_pbBuffer, iObject );
    ChkOverflow( iObject + SIZEOF( DRM_WORD ), iObject );
    iObject += SIZEOF( DRM_WORD );

    ChkOverflow( f_iObject + f_cbObject, f_iObject );
    ChkOverflow( iObject + pContentKey->cbEncryptedKey, iObject );
    ChkBOOL( f_iObject + f_cbObject == iObject + pContentKey->cbEncryptedKey,
            DRM_E_INVALIDLICENSE );
    pContentKey->pbEncryptedKeyBuffer = ( DRM_BYTE * )f_pbBuffer;
    pContentKey->iEncryptedKey        = iObject;
    pContentKey->fValid               = TRUE;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_RsaPubkey
**
** Synopsis :   Parse an RSA public key object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_RsaPubkey(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT          dr         = DRM_SUCCESS;
    DRM_DWORD           iObject    = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_XMR_RSA_PUBKEY *pRsaPubkey = ( DRM_XMR_RSA_PUBKEY * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH + SIZEOF( DRM_WORD ) + SIZEOF( DRM_DWORD ),
             DRM_E_INVALIDLICENSE );
    ChkOverflow( iObject, f_iObject );

    NETWORKBYTES_TO_DWORD( pRsaPubkey->dwExponent, f_pbBuffer, iObject );
    ChkOverflow( iObject + SIZEOF( DRM_DWORD ), iObject );
    iObject += SIZEOF( DRM_DWORD );

    NETWORKBYTES_TO_WORD( pRsaPubkey->cbModulus, f_pbBuffer, iObject );
    ChkOverflow( iObject + SIZEOF( DRM_WORD ), iObject );
    iObject += SIZEOF( DRM_WORD );

    ChkOverflow( f_iObject + f_cbObject, f_iObject );
    ChkOverflow( iObject + pRsaPubkey->cbModulus, iObject );
    ChkBOOL( f_iObject + f_cbObject == iObject + pRsaPubkey->cbModulus, DRM_E_INVALIDLICENSE );
    pRsaPubkey->pbModulusBuffer = ( DRM_BYTE * )f_pbBuffer;
    pRsaPubkey->iModulus        = iObject;
    pRsaPubkey->fValid          = TRUE;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_UplinkKID
**
** Synopsis :   Parse an uplink KID object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_UplinkKID(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT          dr         = DRM_SUCCESS;
    DRM_DWORD           iObject    = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_XMR_UPLINK_KID *pUplinkKID = ( DRM_XMR_UPLINK_KID * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH + SIZEOF( DRM_WORD ) + SIZEOF( DRM_GUID ),
             DRM_E_INVALIDLICENSE );
    ChkOverflow( iObject, f_iObject );

    pUplinkKID->pbguidUplinkKID = ( DRM_BYTE * )f_pbBuffer;
    pUplinkKID->iguidUplinkKID  = iObject;
    ChkOverflow( iObject + SIZEOF( DRM_GUID ), iObject );
    iObject += SIZEOF( DRM_GUID );

    NETWORKBYTES_TO_WORD( pUplinkKID->cbChainedCheckSum, f_pbBuffer,  iObject );
    ChkOverflow( iObject + SIZEOF( DRM_WORD ), iObject );
    iObject += SIZEOF( DRM_WORD );

    /* If we got this far, then (iObject-f_iObject) is always >0, thus no possibility of underflow.
    */
    ChkOverflow( iObject - f_iObject + pUplinkKID->cbChainedCheckSum, iObject - f_iObject );
    ChkBOOL( f_cbObject >= iObject - f_iObject + pUplinkKID->cbChainedCheckSum, DRM_E_INVALIDLICENSE );

    pUplinkKID->pbChainedCheckSumBuffer = ( DRM_BYTE * ) f_pbBuffer;
    pUplinkKID->iChainedCheckSum        = iObject;

    pUplinkKID->wChecksumType = XMR_UPLINK_CHECKSUM_TYPE_XMRV1;

    pUplinkKID->fValid = TRUE;

ErrorExit:
    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_UplinkKID2(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT          dr         = DRM_SUCCESS;
    DRM_DWORD           iObject    = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_XMR_UPLINK_KID *pUplinkKID = ( DRM_XMR_UPLINK_KID * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH + ( 2 * SIZEOF( DRM_WORD ) ) + SIZEOF( DRM_GUID ),
             DRM_E_INVALIDLICENSE );
    ChkOverflow( iObject, f_iObject );

    pUplinkKID->pbguidUplinkKID = ( DRM_BYTE * )f_pbBuffer;
    pUplinkKID->iguidUplinkKID  = iObject;
    ChkOverflow( iObject + SIZEOF( DRM_GUID ), iObject );
    iObject += SIZEOF( DRM_GUID );

    NETWORKBYTES_TO_WORD( pUplinkKID->wChecksumType, f_pbBuffer,  iObject );
    ChkOverflow( iObject + SIZEOF( DRM_WORD ), iObject );
    iObject += SIZEOF( DRM_WORD );

    NETWORKBYTES_TO_WORD( pUplinkKID->cbChainedCheckSum, f_pbBuffer,  iObject );
    ChkOverflow( iObject + SIZEOF( DRM_WORD ), iObject );
    iObject += SIZEOF( DRM_WORD );

    /* If we got this far, then (iObject-f_iObject) is always >0, thus no possibility of underflow.
    */
    ChkOverflow( iObject - f_iObject + pUplinkKID->cbChainedCheckSum, iObject - f_iObject);
    ChkBOOL( f_cbObject >= iObject - f_iObject + pUplinkKID->cbChainedCheckSum, DRM_E_INVALIDLICENSE );

    pUplinkKID->pbChainedCheckSumBuffer = ( DRM_BYTE * ) f_pbBuffer;
    pUplinkKID->iChainedCheckSum        = iObject;

    pUplinkKID->fValid = TRUE;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_Signature
**
** Synopsis :   Parse a signature object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_Signature(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT         dr         = DRM_SUCCESS;
    DRM_DWORD          iObject    = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_XMR_SIGNATURE *pSignature = ( DRM_XMR_SIGNATURE * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH + ( SIZEOF( DRM_WORD ) * 2 ),
             DRM_E_INVALIDLICENSE );
    ChkOverflow( iObject, f_iObject );

    pSignature->fValid = TRUE;
    NETWORKBYTES_TO_WORD( pSignature->wType, f_pbBuffer,  iObject );
    ChkOverflow( iObject + SIZEOF( DRM_WORD ), iObject );
    iObject += SIZEOF( DRM_WORD );

    NETWORKBYTES_TO_WORD( pSignature->cbSignature, f_pbBuffer, iObject );
    ChkOverflow( iObject + SIZEOF( DRM_WORD ), iObject );
    iObject += SIZEOF( DRM_WORD );

    ChkOverflow( XMR_BASE_OBJECT_LENGTH + ( SIZEOF( DRM_WORD ) * 2 ) + pSignature->cbSignature, pSignature->cbSignature );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH + ( SIZEOF( DRM_WORD ) * 2 ) + pSignature->cbSignature,
             DRM_E_INVALIDLICENSE );

    pSignature->pbSignatureBuffer = ( DRM_BYTE * )f_pbBuffer;
    pSignature->iSignature        = iObject;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_UnknownContainer
**
** Synopsis :   Parses any unknown container objects
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          A parsing error occurred
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_UnknownContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbLicense,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT            dr         = DRM_SUCCESS;
    DRM_DWORD             iCurrent   = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_WORD              wFlags     = 0;
    DRM_WORD              wType      = 0;
    DRM_DWORD             cbChild    = 0;
    DRM_XMR_UNKNOWN_OBJECT          *pUnknownObject         = NULL;
    DRM_XMR_UNKNOWN_CONTAINER       *pUnknownChildContainer = NULL;
    DRM_XMR_UNKNOWN_CONTAINER       *pcontainer             = ( DRM_XMR_UNKNOWN_CONTAINER * )f_pvObject;

    ChkArg( f_pbLicense != NULL );
    ChkArg( f_pvObject  != NULL );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH,
             DRM_E_INVALIDLICENSE );
    ChkOverflow( iCurrent, f_iObject );
    ChkOverflow( f_iObject + f_cbObject, f_iObject );
    ChkOverflow( f_iObject + SIZEOF( DRM_WORD ), f_iObject );

    pcontainer->fValid            = TRUE;
    NETWORKBYTES_TO_WORD( pcontainer->wFlags, f_pbLicense, f_iObject );
    NETWORKBYTES_TO_WORD( pcontainer->wType, f_pbLicense, f_iObject + SIZEOF( DRM_WORD ) );

    while ( iCurrent < f_iObject + f_cbObject )
    {
        NETWORKBYTES_TO_WORD( wFlags, f_pbLicense, iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ), iCurrent );
        ChkOverflow( iCurrent + SIZEOF( DRM_WORD ) * 2, iCurrent );
        NETWORKBYTES_TO_WORD( wType, f_pbLicense, iCurrent + SIZEOF( DRM_WORD ) );
        NETWORKBYTES_TO_DWORD( cbChild, f_pbLicense, iCurrent + ( SIZEOF( DRM_WORD ) * 2 ) );

        ChkBOOL( cbChild <= ( f_iObject + ( f_cbObject - iCurrent ) ), DRM_E_INVALIDLICENSE );

        /*
        ** We don't understand it, but if it allows us to try to externally
        ** parse the object then we may be able to continue
        */
        ChkBOOL( ( wFlags & XMR_FLAGS_MUST_UNDERSTAND ) == 0
               || ( ( wFlags & XMR_FLAGS_ALLOW_EXTERNAL_PARSE ) != 0 ), DRM_E_INVALIDLICENSE );

        /* Parse the object if any */
        if( ( wFlags & XMR_FLAGS_CONTAINER ) == 0 )
        {
            /*
            ** Only bother keeping it if it's allowed to be parsed externally, otherwise
            ** we may as well ignore it since we can't do anything else with it
            */
            if( ( wFlags & XMR_FLAGS_ALLOW_EXTERNAL_PARSE ) != 0
                || wType == XMR_OBJECT_TYPE_PLAY_ENABLER_OBJECT
                || wType == XMR_OBJECT_TYPE_COPY_ENABLER_OBJECT )
            {
                /* Alloc space and add to linked list */
                ChkDR( DRM_STK_Alloc_Aligned( f_pStack,
                                              SIZEOF( DRM_XMR_UNKNOWN_OBJECT ),
                                              SIZEOF( DRM_DWORD ),
                                              NULL,
                                              ( DRM_VOID ** ) &pUnknownObject ) );

                ZEROMEM( pUnknownObject, SIZEOF( DRM_XMR_UNKNOWN_OBJECT ) );

                ChkDR( DRM_XMR_Parse_UnknownObject( f_pStack,
                    f_pbLicense,
                    iCurrent,
                    cbChild,
                    pUnknownObject ) );

                pUnknownObject->pNext = pcontainer->pObject;
                pcontainer->pObject = pUnknownObject;
            }
        } /* Object parsing */
        else /* if( ( wFlags & XMR_FLAGS_CONTAINER ) != 0 ) */
        {
            /*
            ** Only bother keeping it if it's allowed to be parsed externally, otherwise
            ** we may as well ignore it since we can't do anything else with it
            */
            if( ( wFlags & XMR_FLAGS_ALLOW_EXTERNAL_PARSE ) != 0 )
            {
                /* Alloc space and add to linked list */
                ChkDR( DRM_STK_Alloc_Aligned( f_pStack,
                                              SIZEOF( DRM_XMR_UNKNOWN_CONTAINER ),
                                              SIZEOF( DRM_DWORD ),
                                              NULL,
                                              ( DRM_VOID ** ) &pUnknownChildContainer ) );

                ZEROMEM( pUnknownChildContainer, SIZEOF( DRM_XMR_UNKNOWN_CONTAINER ) );

                ChkDR( DRM_XMR_Parse_UnknownContainer( f_pStack,
                    f_pbLicense,
                    iCurrent,
                    cbChild,
                    pUnknownChildContainer ) );

                pUnknownChildContainer->pNext = pcontainer->pUnkChildcontainer;
                pcontainer->pUnkChildcontainer = pUnknownChildContainer;
            }
        }
        ChkOverflow( iCurrent + cbChild, iCurrent );
        iCurrent += cbChild;
    }

ErrorExit:
    return dr;
}


/******************************************************************************
**
** Function :   DRM_XMR_Parse_UnknownObject
**
** Synopsis :   Parses any unknown objects
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_UnknownObject(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT              dr         = DRM_SUCCESS;
    DRM_XMR_UNKNOWN_OBJECT *pObject    = ( DRM_XMR_UNKNOWN_OBJECT * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH + SIZEOF( DRM_WORD ),
             DRM_E_INVALIDLICENSE );
    ChkOverflow( f_iObject + XMR_BASE_OBJECT_LENGTH, f_iObject );
    ChkOverflow( f_iObject + SIZEOF( DRM_WORD ), f_iObject );

    pObject->fValid = TRUE;
    NETWORKBYTES_TO_WORD( pObject->wFlags, f_pbBuffer, f_iObject );
    NETWORKBYTES_TO_WORD( pObject->wType, f_pbBuffer, f_iObject + SIZEOF( DRM_WORD ) );

    pObject->pbBuffer = ( DRM_BYTE * )f_pbBuffer;
    pObject->ibData = f_iObject + XMR_BASE_OBJECT_LENGTH;
    pObject->cbData = f_cbObject - XMR_BASE_OBJECT_LENGTH;

ErrorExit:
    return dr;
}


/******************************************************************************
**
** Function :   DRM_XMR_Parse_EccDevicekey
**
** Synopsis :   Parse an ECC device key object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_EccDevicekey(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT              dr      = DRM_SUCCESS;
    DRM_DWORD               iObject = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_XMR_ECC_DEVICE_KEY *pKey    = ( DRM_XMR_ECC_DEVICE_KEY * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH + SIZEOF( DRM_DWORD ), DRM_E_INVALIDLICENSE );
    ChkOverflow( iObject, f_iObject );

    pKey->fValid      = TRUE;

    NETWORKBYTES_TO_WORD( pKey->wEccCurveType, f_pbBuffer,  iObject );
    ChkOverflow( iObject + SIZEOF( DRM_WORD ), iObject );
    iObject += SIZEOF( DRM_WORD );

    NETWORKBYTES_TO_WORD( pKey->cbKeyData, f_pbBuffer, iObject );
    ChkOverflow( iObject + SIZEOF( DRM_WORD ), iObject );
    iObject += SIZEOF( DRM_WORD );

    pKey->pbKeyData = ( DRM_BYTE * )f_pbBuffer;
    pKey->iKeyData = iObject;

ErrorExit:
    return dr;
}


/******************************************************************************
**
** Function :   DRM_XMR_Parse_DomainID
**
** Synopsis :   Parse a Domain ID object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_DomainID(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT         dr        = DRM_SUCCESS;
    DRM_DWORD          iObject   = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_XMR_DOMAIN_ID *pDomainID = ( DRM_XMR_DOMAIN_ID * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject == XMR_BASE_OBJECT_LENGTH + SIZEOF( DRM_DWORD ) * 5, DRM_E_INVALIDLICENSE );
    ChkOverflow( iObject, f_iObject );

    pDomainID->fValid      = TRUE;
    pDomainID->pbAccountID = ( DRM_BYTE * )f_pbBuffer;
    pDomainID->ibAccountID = iObject;
    pDomainID->cbAccountID = SIZEOF( DRM_DWORD ) * 4;
    iObject += pDomainID->cbAccountID;

    NETWORKBYTES_TO_DWORD( pDomainID->dwRevision, f_pbBuffer, iObject );

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_Parse_OptimizedContentKey
**
** Synopsis :   Parse a symmetrically optimized content key object
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL
**      DRM_E_INVALIDLICENSE
**          f_cbObject is outside the expected range for the object type
**
** Notes :  Prototyped in drmxmrparser.h
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_Parse_OptimizedContentKey(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject )
{
    DRM_RESULT                     dr          = DRM_SUCCESS;
    DRM_DWORD                      iObject     = f_iObject + XMR_BASE_OBJECT_LENGTH;
    DRM_XMR_OPTIMIZED_CONTENT_KEY *pContentKey = ( DRM_XMR_OPTIMIZED_CONTENT_KEY * )f_pvObject;

    ChkArg( f_pvObject != NULL );
    ChkArg( f_pbBuffer != NULL );
    ChkBOOL( f_cbObject >= XMR_BASE_OBJECT_LENGTH
                         + ( SIZEOF( DRM_WORD ) * 2 ) , DRM_E_INVALIDLICENSE );
    ChkOverflow( iObject, f_iObject );

    NETWORKBYTES_TO_WORD( pContentKey->wKeyEncryptionCipherType, f_pbBuffer, iObject );
    ChkOverflow( iObject + SIZEOF( DRM_WORD ), iObject );
    iObject += SIZEOF( DRM_WORD );

    NETWORKBYTES_TO_WORD( pContentKey->cbEncryptedKey, f_pbBuffer, iObject );
    ChkOverflow( iObject + SIZEOF( DRM_WORD ), iObject );
    iObject += SIZEOF( DRM_WORD );

    ChkOverflow( f_iObject + f_cbObject, f_iObject );
    ChkOverflow( iObject + pContentKey->cbEncryptedKey, iObject );
    ChkBOOL( f_iObject + f_cbObject == iObject + pContentKey->cbEncryptedKey,
            DRM_E_INVALIDLICENSE );
    pContentKey->pbEncryptedKeyBuffer = ( DRM_BYTE * )f_pbBuffer;
    pContentKey->iEncryptedKey        = iObject;
    pContentKey->fValid               = TRUE;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   _XMR_FindChild
**
** Synopsis :   Used by Parser to find a child in a node buffer
**
** Arguments :
**      [f_wObjectType]   : Object type to find
**      [f_pbBuffer]      : Buffer
**      [f_iCurrentNode]  : Buffer index marking start of parent node
**      [f_cbCurrentNode] : Size in bytes of parent node
**      [f_piObject]      : Buffer index marking start of required child
**      [f_pcbObject]     : Size in bytes of required child
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the parameters is NULL
**      DRM_E_ARITHMETICOVERFLOW
**          An arithmetic overflow occurred during processing
**      DRM_E_XMR_OBJECT_NOTFOUND
**          Failed to find the child node
**      DRM_E_INVALIDLICENSE
**          A child node was found that was too large for the current container
**
******************************************************************************/
static DRM_NO_INLINE DRM_RESULT DRM_CALL _XMR_FindChild(
    IN        DRM_WORD         f_wType,
    IN  const DRM_BYTE        *f_pbBuffer,
    IN        DRM_DWORD        f_iCurrentNode,
    IN        DRM_DWORD        f_cbCurrentNode,
    OUT       DRM_DWORD       *f_piChild,
    OUT       DRM_DWORD       *f_pcbChild )
{
    DRM_RESULT  dr        = DRM_SUCCESS;
    DRM_DWORD   iNext     = f_iCurrentNode + XMR_BASE_OBJECT_LENGTH;
    DRM_DWORD   cbNext    = 0;
    DRM_WORD    wNextType = 0;

    ChkArg( f_pbBuffer  != NULL );
    ChkArg( f_piChild   != NULL );
    ChkArg( f_pcbChild  != NULL );

    ChkOverflow( iNext, f_iCurrentNode );
    ChkOverflow( f_iCurrentNode + f_cbCurrentNode, f_iCurrentNode );
    ChkOverflow( f_iCurrentNode + f_cbCurrentNode,
                 f_iCurrentNode + f_cbCurrentNode - XMR_BASE_OBJECT_LENGTH );   /* Underflow check */

    while ( wNextType != f_wType
          && iNext < ( f_iCurrentNode + f_cbCurrentNode - XMR_BASE_OBJECT_LENGTH ) )
    {
        ChkOverflow( iNext + SIZEOF( DRM_WORD ), iNext );
        NETWORKBYTES_TO_WORD( wNextType,
                              f_pbBuffer,
                              iNext + SIZEOF( DRM_WORD ) );
        ChkOverflow( iNext + SIZEOF( DRM_WORD ), iNext );
        NETWORKBYTES_TO_DWORD( cbNext,
                               f_pbBuffer,
                               iNext + SIZEOF( DRM_WORD )*2 );
        ChkOverflow( iNext + cbNext, iNext );
        iNext += cbNext;
    }
    iNext -= cbNext;
    ChkBOOL( wNextType == f_wType, DRM_E_XMR_OBJECT_NOTFOUND );
    ChkBOOL( cbNext <= ( f_iCurrentNode + f_cbCurrentNode - iNext ), DRM_E_INVALIDLICENSE );

    *f_piChild = iNext;
    *f_pcbChild = cbNext;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_FindObject
**
** Synopsis :   Used by Parser to find some object in a license buffer
**
** Arguments :
**      [f_wObjectType] : Object type to find
**      [f_pbBuffer]    : License buffer
**      [f_cbBuffer]    : License buffer size
**      [f_piObject]    : Buffer index marking start of required object
**      [f_pcbObject]   : Size in bytes of required object
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the parameters is NULL
**      DRM_E_INVALIDLICENSE
**          The license buffer is an unexpected length
**      DRM_E_ARITHMETICOVERFLOW
**          An arithmetic overflow occurred during processing
**      DRM_E_XMR_OBJECT_NOTFOUND
**          Failed to find the object
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_FindObject(
    IN        DRM_WORD         f_wObjectType,
    IN  const DRM_BYTE        *f_pbLicense,
    IN        DRM_DWORD        f_cbLicense,
    OUT       DRM_DWORD       *f_piObject,
    OUT       DRM_DWORD       *f_pcbObject )
{
    DRM_RESULT  dr          = DRM_SUCCESS;
    DRM_WORD    wParent     = f_wObjectType;
    DRM_WORD    wLevel      = 1;
    DRM_DWORD   iCurrent    = XMR_HEADER_LENGTH;
    DRM_DWORD   iNext       = XMR_HEADER_LENGTH;
    DRM_DWORD   cbCurrent   = 0;
    DRM_DWORD   cbNext      = 0;
    DRM_WORD    wHierarchy[XMR_MAXIMUM_OBJECT_DEPTH] = { 0 };

    ChkArg( f_pbLicense != NULL );
    ChkArg( f_piObject  != NULL );
    ChkArg( f_pcbObject != NULL );

    NETWORKBYTES_TO_DWORD( cbCurrent,
                           f_pbLicense,
                           iCurrent + SIZEOF( DRM_WORD ) * 2 );

    ChkOverflow( cbCurrent + XMR_HEADER_LENGTH, cbCurrent );

    ChkBOOL( f_cbLicense >= (cbCurrent + XMR_HEADER_LENGTH), DRM_E_INVALIDLICENSE );

    for ( ; ( wParent != XMR_OBJECT_TYPE_OUTER_CONTAINER
         && wLevel   < XMR_MAXIMUM_OBJECT_DEPTH
         && wParent <= XMR_OBJECT_TYPE_MAXIMUM_DEFINED ); wLevel++ )
    {
        wHierarchy[wLevel] = wParent;
        wParent = g_xmrCommonDefines[wParent].wParent;
    }
    wLevel--;

    /*
    **  First find node wHierarchy[wLevel], followed by wHierarchy[wLevel-1],
    **  etc till wHierarchy[1]
    */
    while ( wLevel > 0 && wLevel < XMR_MAXIMUM_OBJECT_DEPTH )
    {
        ChkDR( _XMR_FindChild( wHierarchy[wLevel],
                               f_pbLicense,
                               iCurrent,
                               cbCurrent,
                               &iNext,
                               &cbNext ) );
        iCurrent = iNext;
        cbCurrent = cbNext;
        wLevel--;
    }
    *f_piObject  = iCurrent;
    *f_pcbObject = cbCurrent;

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_UnpackLicense
**
** Synopsis :   Parse the license
**
** Arguments :
**      [f_pbLicense]   : License buffer
**      [f_cbLicense]   : License buffer size
**      [f_pStack]      : Stack pointer
**      [f_pXmrLicense] : Returns the parsed license
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the parameters is NULL or invalid
**      DRM_E_INVALIDLICENSE
**          The license buffer does not specify a valid license
**
** Notes     :  Callers must keep the stack around as long as they use the
**              contents of the structure returned. The structure might have
**              some intermediate nodes allocated out of this stack
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_UnpackLicense(
    IN  const   DRM_BYTE                    *f_pbLicense,
    IN          DRM_DWORD                    f_cbLicense,
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    OUT         DRM_XMR_LICENSE             *f_pXmrLicense )
{
    DRM_RESULT dr               = DRM_SUCCESS;
    DRM_DWORD  dwMagicConstant  = 0;
    DRM_DWORD  cbOuterContainer = 0;

    DRMCASSERT( DRM_XMR_MAX_UNPACK_ALLOC_FACTOR >= DRM_XMR_COMPUTED_MAX_UNPACK_ALLOC_FACTOR );

    ChkArg( f_pbLicense     != NULL );
    ChkArg( f_cbLicense     != 0 );
    ChkArg( f_pXmrLicense   != NULL );

    ChkBOOL( f_cbLicense > XMR_HEADER_LENGTH, DRM_E_INVALIDLICENSE );

    NETWORKBYTES_TO_DWORD( dwMagicConstant, f_pbLicense, 0 );

    ChkBOOL( dwMagicConstant == XMR_MAGIC_CONSTANT, DRM_E_INVALIDLICENSE );

    NETWORKBYTES_TO_DWORD( f_pXmrLicense->dwVersion, f_pbLicense, SIZEOF( DRM_DWORD ) );
    f_pXmrLicense->pbRightsIdBuffer = ( DRM_BYTE * ) f_pbLicense;
    f_pXmrLicense->iRightsId        = SIZEOF( DRM_DWORD ) * 2;
    ChkDR( DRM_XMR_GetContainer( f_pbLicense,
                                 f_cbLicense,
                                 XMR_OBJECT_TYPE_OUTER_CONTAINER,
                                 f_pStack,
                 ( DRM_VOID * ) &f_pXmrLicense->containerOuter ) );

    /*
    ** Verify that the length of the license buffer is consistent with the outer container size
    */
    NETWORKBYTES_TO_DWORD( cbOuterContainer, f_pbLicense, XMR_HEADER_LENGTH + 2 * SIZEOF( DRM_WORD ) );
    ChkBOOL( cbOuterContainer + XMR_HEADER_LENGTH == f_cbLicense, DRM_E_INVALIDLICENSE );

    f_pXmrLicense->pbSignedDataBuffer = ( DRM_BYTE * )f_pbLicense;
    f_pXmrLicense->iSignedData        = 0;
    f_pXmrLicense->cbSignedData       = f_cbLicense
                                      - XMR_BASE_OBJECT_LENGTH
                                      - SIZEOF( DRM_WORD ) * 2
                                      - f_pXmrLicense->containerOuter.signature.cbSignature;

    ChkDR( DRM_XMR_ValidateLicenseObjects( f_pXmrLicense ) );

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_GetContainer
**
** Synopsis :   Parse the license to obtain a particular container
**
** Arguments :
**      [f_pbLicense]      : License buffer
**      [f_cbLicense]      : License buffer size
**      [f_wContainerType] : Container type
**      [f_pStack]         : Stack pointer
**      [f_pvContainer]    : Container object passed as void
**
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the parameters is NULL or invalid
**      DRM_E_INVALIDLICENSE
**          The license buffer does not specify a valid license
**      DRM_E_ARITHMETICOVERFLOW
**          An arithmetic overflow occurred during processing
**      DRM_E_XMR_OBJECT_NOTFOUND
**          Failed to find the container object
**
******************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_GetContainer(
    IN  const   DRM_BYTE                     *f_pbLicense,
    IN          DRM_DWORD                     f_cbLicense,
    IN          DRM_WORD                      f_wContainerType,
    IN          DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack,
    IN  OUT     DRM_VOID                     *f_pvContainer )
{
    DRM_RESULT dr              = DRM_SUCCESS;
    DRM_DWORD  iContainer      = 0;
    DRM_DWORD  cbContainer     = 0;
    DRM_DWORD  dwMagicConstant = 0;

    ChkArg( f_pbLicense   != NULL );
    ChkArg( f_cbLicense   != 0 );
    ChkArg( f_pvContainer != NULL );
    ChkArg( f_wContainerType <= XMR_OBJECT_TYPE_MAXIMUM_DEFINED );
    ChkArg( g_xmrCommonDefines[f_wContainerType].fIsContainer );

    ChkBOOL( f_cbLicense > XMR_HEADER_LENGTH, DRM_E_INVALIDLICENSE );

    NETWORKBYTES_TO_DWORD( dwMagicConstant, f_pbLicense, 0 );
    ChkBOOL( dwMagicConstant == XMR_MAGIC_CONSTANT, DRM_E_INVALIDLICENSE );

    ChkDR( DRM_XMR_FindObject( f_wContainerType,
                               f_pbLicense,
                               f_cbLicense,
                               &iContainer,
                               &cbContainer ) );
    ChkDR( g_xmrParserDefines[f_wContainerType].fnParse( f_pstack,
                                                   f_pbLicense,
                                                   iContainer,
                                                   cbContainer,
                                                   f_pvContainer ) );

ErrorExit:
    return dr;
}

/******************************************************************************
**
** Function :   DRM_XMR_PopulateInclusionList
**
** Synopsis :   Populate an XMR inclusion list
**
** Arguments :
**      [f_pInclusionList]  : Specifies the inclusion list to copy from
**      [f_rgInclusionList] : Specifies the set of GUIDs to populate
**      [f_rgfGuidValid]    : Specifies the validity flags to populate
**      [f_dwChainDepth]    : Specifies the chain depth
**
** Returns :
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the parameters is NULL or invalid
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XMR_PopulateInclusionList(
    IN       DRM_XMR_INCLUSION_LIST *f_pInclusionList,
    IN OUT   DRM_GUID                f_rgInclusionList[DRM_MAX_INCLUSION_GUIDS],
    IN OUT   DRM_BOOL                f_rgfGuidValid[DRM_MAX_INCLUSION_GUIDS][DRM_MAX_LICENSE_CHAIN_DEPTH],
    IN       DRM_DWORD               f_dwChainDepth )
{
    DRM_RESULT dr    = DRM_SUCCESS;
    DRM_DWORD  iGuid = 0;
    DRM_DWORD  i     = 0;

    ChkArg( f_pInclusionList != NULL );
    ChkArg( f_pInclusionList->fValid );

    /*
    ** Set all the valid flags at this chain depth to FALSE for all GUIDs
    */
    for ( ; iGuid < DRM_MAX_INCLUSION_GUIDS; iGuid++ )
    {
        f_rgfGuidValid[iGuid][f_dwChainDepth] = FALSE;
    }

    for ( iGuid = 0; iGuid < f_pInclusionList->cGUIDs; iGuid++ )
    {
        if( f_dwChainDepth == 0 )
        {
            if( iGuid >= DRM_MAX_INCLUSION_GUIDS )
            {
                /*
                **  If this is a leaf license we have to stop at the Maximum number of guids
                */
                break;
            }

            /*
            **  For the leaf license we need to populate the output array of GUIDs
            **  and valid list as appropriate
            */
            ChkOverflow( f_pInclusionList->iGuids + ( SIZEOF( DRM_GUID ) * iGuid ), f_pInclusionList->iGuids );
            DRM_BYT_CopyBytes( &f_rgInclusionList[iGuid],
                                0,
                                f_pInclusionList->pguidBuffer,
                                f_pInclusionList->iGuids + ( SIZEOF( DRM_GUID ) * iGuid ),
                                SIZEOF( DRM_GUID ) );
            f_rgfGuidValid[iGuid][0] = TRUE;
        }
        else
        {
            /*
            **  For non-leaf licenses we should check to see if this guid is in the list,
            **  and if so is it valid at the previous chain level.
            **  If it is then it is still valid at the current level.
            */
            for( i = 0; i < DRM_MAX_INCLUSION_GUIDS; i++ )
            {
                ChkOverflow( f_pInclusionList->iGuids + ( SIZEOF( DRM_GUID ) * iGuid ), f_pInclusionList->iGuids );
                if( DRM_BYT_CompareBytes( &f_rgInclusionList[i],
                                           0,
                                           f_pInclusionList->pguidBuffer,
                                           f_pInclusionList->iGuids + ( SIZEOF( DRM_GUID ) * iGuid ),
                                           SIZEOF( DRM_GUID ) ) == 0
                 && f_rgfGuidValid[i][f_dwChainDepth - 1] )
                {
                    f_rgfGuidValid[i][f_dwChainDepth] = TRUE;
                }
            }
        }
    }

ErrorExit:
    return dr;
}

/*
** Some objects are simply required.
** For V1 XMR, certain licenses from legacy tuners are incomplete,
** so we skip this validation for V1 XMR.
*/
#define VALIDATE_REQUIRED_OBJECT( pXmrLicense, IS_VALID_MACRO )             \
    ChkBOOL( ( f_pXmrLicense->dwVersion == XMR_VERSION_1 ) || IS_VALID_MACRO( pXmrLicense ), DRM_E_INVALIDLICENSE )

/* Use the look-up table to see if the object is supported for the given version */
#define VALIDATE_OPTIONAL_OBJECT( pXmrLicense, IS_VALID_MACRO, ObjType )                                            \
    ChkBOOL(                                                                                                        \
        !IS_VALID_MACRO( pXmrLicense )                                                                              \
     || g_xmrParserDefines[ObjType].rgfIsVersionSupported[(pXmrLicense)->dwVersion - 1], DRM_E_INVALIDLICENSE )

/* All Unknown Objects under the specified path must be V2 and up */
#define VALIDATE_UNKNOWN_OBJECTS_ARE_V2( pXmrLicense, IS_VALID_MACRO, ObjPath )     \
    ChkBOOL(                                                                        \
        !IS_VALID_MACRO( pXmrLicense )                                              \
     || ( (pXmrLicense)->containerOuter.ObjPath.pUnknownObjects == NULL )           \
     || ( (pXmrLicense)->dwVersion >= XMR_VERSION_2 ), DRM_E_INVALIDLICENSE )

/* All enabler containers must include one child which is the enabler type object, but no more than one of that type */
#define VALIDATE_ENABLERS( pXmrLicense, IS_VALID_MACRO, ObjPath, ContainerType, ObjectType, fAllowEnablers )                \
    do {                                                                                                                    \
        if( IS_VALID_MACRO( pXmrLicense ) )                                                                                 \
        {                                                                                                                   \
            DRM_XMR_UNKNOWN_CONTAINER *pUnkContainer =                                                                      \
                &pXmrLicense->containerOuter.ObjPath.UnknownContainer;                                                    \
            while( pUnkContainer != NULL )                                                                                  \
            {                                                                                                               \
                if( pUnkContainer->fValid )                                                                                 \
                {                                                                                                           \
                    ChkBOOL( fAllowEnablers, DRM_E_INVALIDLICENSE );                                                        \
                    if( pUnkContainer->wType == (ContainerType) )                                                           \
                    {                                                                                                       \
                        DRM_BOOL fHasEnabler = FALSE;                                                                       \
                        DRM_XMR_UNKNOWN_OBJECT *pUnkObject  = pUnkContainer->pObject;                                       \
                        while( pUnkObject != NULL )                                                                         \
                        {                                                                                                   \
                            if( pUnkObject->fValid && ( pUnkObject->wType == (ObjectType) ) )                               \
                            {                                                                                               \
                                ChkBOOL( !fHasEnabler, DRM_E_INVALIDLICENSE );                                              \
                                fHasEnabler = TRUE;                                                                         \
                            }                                                                                               \
                            pUnkObject = pUnkObject->pNext;                                                                 \
                        }                                                                                                   \
                        ChkBOOL( fHasEnabler, DRM_E_INVALIDLICENSE );                                                       \
                    }                                                                                                       \
                    else                                                                                                    \
                    {                                                                                                       \
                        ChkBOOL( pXmrLicense->dwVersion >= XMR_VERSION_2, DRM_E_INVALIDLICENSE );                           \
                    }                                                                                                       \
                }                                                                                                           \
                pUnkContainer = pUnkContainer->pNext;                                                                       \
            }                                                                                                               \
        }                                                                                                                   \
    } while( FALSE )


#define VALIDATE_RIGHTS_MASK( pXmrLicense, wValidMask )                                                                             \
    ChkBOOL(                                                                                                                        \
        ( (pXmrLicense)->containerOuter.containerGlobalPolicies.Rights.wValue == 0 )                                                \
     || ( (pXmrLicense)->containerOuter.containerGlobalPolicies.Rights.wValue                                                       \
     == ( (pXmrLicense)->containerOuter.containerGlobalPolicies.Rights.wValue & (DRM_WORD)(wValidMask) ) ), DRM_E_INVALIDLICENSE )

static DRM_NO_INLINE DRM_RESULT DRM_CALL _XMR_ValidateLicenseObjectsVersioned(
    IN          DRM_XMR_LICENSE             *f_pXmrLicense )
{
    DRM_RESULT  dr  = DRM_SUCCESS;

    if( XMR_IS_MINIMUM_ENVIRONMENT_VALID( f_pXmrLicense ) )
    {
        switch( f_pXmrLicense->dwVersion )
        {
        case XMR_VERSION_1:
            ChkBOOL( f_pXmrLicense->containerOuter.containerGlobalPolicies.MinimumEnvironment.dwVersion == 1, DRM_E_INVALIDLICENSE );
            break;
        case XMR_VERSION_3:
            ChkBOOL( f_pXmrLicense->containerOuter.containerGlobalPolicies.MinimumEnvironment.dwVersion == 2, DRM_E_INVALIDLICENSE );
            break;
        default:
            AssertChkArg( FALSE ); /* Should never be reached - checked previously */
            break;
        }
    }

    if( XMR_IS_EXPIRATION_AFTER_FIRST_USE_VALID( f_pXmrLicense ) )
    {
        switch( f_pXmrLicense->dwVersion )
        {
        case XMR_VERSION_1:
            ChkBOOL( f_pXmrLicense->containerOuter.containerGlobalPolicies.ExpirationAfterUse.dwVersion == 1, DRM_E_INVALIDLICENSE );
            break;
        case XMR_VERSION_3:
            ChkBOOL( f_pXmrLicense->containerOuter.containerGlobalPolicies.ExpirationAfterUse.dwVersion == 2, DRM_E_INVALIDLICENSE );
            break;
        default:
            AssertChkArg( FALSE ); /* Should never be reached - checked previously */
            break;
        }
    }

    if( XMR_IS_REVOCATION_INFORMATION_VERSION_VALID( f_pXmrLicense ) )
    {
        switch( f_pXmrLicense->dwVersion )
        {
        case XMR_VERSION_1:
            ChkBOOL( f_pXmrLicense->containerOuter.containerGlobalPolicies.RevocationInformationVersion.dwVersion == 1, DRM_E_INVALIDLICENSE );
            break;
        case XMR_VERSION_3:
            ChkBOOL( f_pXmrLicense->containerOuter.containerGlobalPolicies.RevocationInformationVersion.dwVersion == 2, DRM_E_INVALIDLICENSE );
            break;
        default:
            AssertChkArg( FALSE ); /* Should never be reached - checked previously */
            break;
        }
    }

    if( XMR_IS_UPLINK_KID_VALID( f_pXmrLicense ) )
    {
        switch( f_pXmrLicense->dwVersion )
        {
        case XMR_VERSION_1:
            ChkBOOL( f_pXmrLicense->containerOuter.containerKeys.UplinkKid.dwVersion == 1, DRM_E_INVALIDLICENSE );
            ChkBOOL( f_pXmrLicense->containerOuter.containerKeys.UplinkKid.wChecksumType == XMR_UPLINK_CHECKSUM_TYPE_XMRV1, DRM_E_INVALIDLICENSE );
            break;
        case XMR_VERSION_3:
            ChkBOOL( f_pXmrLicense->containerOuter.containerKeys.UplinkKid.dwVersion == 2, DRM_E_INVALIDLICENSE );
            ChkBOOL( f_pXmrLicense->containerOuter.containerKeys.UplinkKid.wChecksumType == XMR_UPLINK_CHECKSUM_TYPE_AESOMAC1, DRM_E_INVALIDLICENSE );
            break;
        default:
            AssertChkArg( FALSE ); /* Should never be reached - checked previously */
            break;
        }
    }

    if( XMR_IS_COPY_VALID( f_pXmrLicense ) )
    {
        switch( f_pXmrLicense->dwVersion )
        {
        case XMR_VERSION_1:
            /* V1 XMR supports both old and new Copy Policy Container Objects */
            ChkBOOL( f_pXmrLicense->containerOuter.containerCopyPolicies.dwVersion == 1
                  || f_pXmrLicense->containerOuter.containerCopyPolicies.dwVersion == 2, DRM_E_INVALIDLICENSE );
            break;
        case XMR_VERSION_3:
            ChkBOOL( f_pXmrLicense->containerOuter.containerCopyPolicies.dwVersion == 2, DRM_E_INVALIDLICENSE );
            break;
        default:
            AssertChkArg( FALSE ); /* Should never be reached - checked previously */
            break;
        }
    }

    if( XMR_IS_COPYCOUNT_VALID( f_pXmrLicense ) )
    {
        switch( f_pXmrLicense->dwVersion )
        {
        case XMR_VERSION_1:
            /* V1 XMR supports both old and new Copy Count Restriction Objects */
            ChkBOOL( f_pXmrLicense->containerOuter.containerCopyPolicies.CopyCount.dwVersion == 1
                  || f_pXmrLicense->containerOuter.containerCopyPolicies.CopyCount.dwVersion == 2, DRM_E_INVALIDLICENSE );
            break;
        case XMR_VERSION_3:
            ChkBOOL( f_pXmrLicense->containerOuter.containerCopyPolicies.CopyCount.dwVersion == 2, DRM_E_INVALIDLICENSE );
            break;
        default:
            AssertChkArg( FALSE ); /* Should never be reached - checked previously */
            break;
        }
    }

ErrorExit:
    return dr;
}

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_XMR_ValidateLicenseObjects(
    IN          DRM_XMR_LICENSE             *f_pXmrLicense )
{
    DRM_RESULT                   dr                             = DRM_SUCCESS;
    DRM_XMR_UNKNOWN_CONTAINER   *pUnknownContainer              = NULL;
    DRM_XMR_UNKNOWN_OBJECT      *pUnknownObject                 = NULL;
    DRM_GUID                     dguidFromObject                = EMPTY_DRM_GUID;
    DRM_BOOL                     fHasCopyEnabler                = FALSE;
    DRM_BOOL                     fHasDomainInvalidCopyEnabler   = FALSE;

    ChkArg( f_pXmrLicense != NULL );

    /* XMR_VERSION_2 is not supported */
    ChkBOOL(
        ( f_pXmrLicense->dwVersion == XMR_VERSION_1 )
     || ( f_pXmrLicense->dwVersion == XMR_VERSION_3 ), DRM_E_INVALIDLICENSE );

    /* RID (LID) is required - this also validates that the outer container is valid */
    VALIDATE_REQUIRED_OBJECT( f_pXmrLicense, XMR_IS_RID_VALID );

    /*
    ** Validate "versioned" objects - objects that use the same structure
    ** but have different semantics based on the XMR version
    */
    ChkDR( _XMR_ValidateLicenseObjectsVersioned( f_pXmrLicense ) );

    /* Validate the Global Policy Container Object */
    VALIDATE_REQUIRED_OBJECT( f_pXmrLicense, XMR_IS_GLOBAL_POLICIES_VALID );
    VALIDATE_REQUIRED_OBJECT( f_pXmrLicense, XMR_IS_MINIMUM_ENVIRONMENT_VALID );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_SERIAL_NUMBER_RESTRICTION_VALID,        XMR_OBJECT_TYPE_SERIAL_NUMBER_OBJECT );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_RIGHTS_VALID,                           XMR_OBJECT_TYPE_SETTINGS_OBJECT );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_PRIORITY_VALID,                         XMR_OBJECT_TYPE_PRIORITY_OBJECT );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_SOURCEID_VALID,                         XMR_OBJECT_TYPE_SOURCEID_OBJECT );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_RESTRICTED_SOURCEID_VALID,              XMR_OBJECT_TYPE_RESTRICTED_SOURCEID_OBJECT );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_EXPIRATION_VALID,                       XMR_OBJECT_TYPE_EXPIRATION_OBJECT );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_ISSUEDATE_VALID,                        XMR_OBJECT_TYPE_ISSUEDATE_OBJECT );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_GRACE_PERIOD_VALID,                     XMR_OBJECT_TYPE_GRACE_PERIOD_OBJECT );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_METERING_VALID,                         XMR_OBJECT_TYPE_METERING_OBJECT );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_EXPIRATION_VALID,                       XMR_OBJECT_TYPE_EXPIRATION_OBJECT );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_EXPIRATION_AFTER_STORE_VALID,           XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTSTORE_OBJECT );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_INCLUSIONLIST_VALID,                    XMR_OBJECT_TYPE_INCLUSION_LIST_OBJECT );
    VALIDATE_REQUIRED_OBJECT( f_pXmrLicense, XMR_IS_REVOCATION_INFORMATION_VERSION_VALID );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_DOMAIN_ID_VALID,                        XMR_OBJECT_TYPE_DOMAIN_ID_OBJECT );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_EMBEDDING_BEHAVIOR_VALID,               XMR_OBJECT_TYPE_EMBEDDING_BEHAVIOR_OBJECT );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_POLICYMETADATA_VALID,                   XMR_OBJECT_TYPE_POLICY_METADATA_OBJECT );
    VALIDATE_UNKNOWN_OBJECTS_ARE_V2( f_pXmrLicense, XMR_IS_GLOBAL_POLICIES_VALID, containerGlobalPolicies );

    /* This object is versioned and must be validated by _XMR_ValidateLicenseObjectsVersioned */
    /* VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_EXPIRATION_AFTER_FIRST_USE_VALID,       XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTUSE_OBJECT ); */

    /* Validate the Play Policy Container Object */
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_PLAY_VALID,                             XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_PLAYCOUNT_VALID,                        XMR_OBJECT_TYPE_PLAYCOUNT_OBJECT );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_OPL_VALID,                              XMR_OBJECT_TYPE_OUTPUT_PROTECTION_OBJECT );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_EXPLICITANALOGVIDEOPROTECTION_VALID,    XMR_OBJECT_TYPE_EXPLICIT_ANALOG_VIDEO_OUTPUT_PROTECTION_CONTAINER );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_EXPLICITDIGITALAUDIOPROTECTION_VALID,   XMR_OBJECT_TYPE_EXPLICIT_DIGITAL_AUDIO_OUTPUT_PROTECTION_CONTAINER );
    VALIDATE_UNKNOWN_OBJECTS_ARE_V2( f_pXmrLicense, XMR_IS_PLAY_VALID, containerPlaybackPolicies );
    VALIDATE_ENABLERS( f_pXmrLicense, XMR_IS_PLAY_VALID, containerPlaybackPolicies, XMR_OBJECT_TYPE_PLAY_ENABLER_CONTAINER, XMR_OBJECT_TYPE_PLAY_ENABLER_OBJECT, f_pXmrLicense->dwVersion >= XMR_VERSION_2 );

    /* Validate the Copy Policy Container Object */
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_COPYPROTECTIONLEVEL_VALID,              XMR_OBJECT_TYPE_COPY_PROTECTION_OBJECT );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_MOVEENABLER_VALID,                      XMR_OBJECT_TYPE_MOVE_ENABLER_OBJECT );
    VALIDATE_UNKNOWN_OBJECTS_ARE_V2( f_pXmrLicense, XMR_IS_COPY_VALID, containerCopyPolicies );
    VALIDATE_ENABLERS( f_pXmrLicense, XMR_IS_COPY_VALID, containerCopyPolicies, XMR_OBJECT_TYPE_COPY_ENABLER_CONTAINER, XMR_OBJECT_TYPE_COPY_ENABLER_OBJECT, TRUE );

    /* This object is versioned and must be validated by _XMR_ValidateLicenseObjectsVersioned */
    /* VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_COPY_VALID,                             XMR_OBJECT_TYPE_COPY_POLICY_CONTAINER ); */

    /* This object is versioned and must be validated by _XMR_ValidateLicenseObjectsVersioned */
    /* VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_COPYCOUNT_VALID,                        XMR_OBJECT_TYPE_COPYCOUNT_OBJECT ); */

    /* Validate the PlaylistBurn Policy Container Object */
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_PLAYLISTBURN_VALID,                     XMR_OBJECT_TYPE_ALLOW_PLAYLISTBURN_POLICY_CONTAINER );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_PLAYLISTBURN_RESTRICTIONS_VALID,        XMR_OBJECT_TYPE_PLAYLISTBURN_COUNT_OBJECT );
    VALIDATE_UNKNOWN_OBJECTS_ARE_V2( f_pXmrLicense, XMR_IS_PLAYLISTBURN_VALID, containerPlaylistBurnPolicies );

    /* Validate the Generation Number Object */
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_GENERATION_NUMBER_VALID,                XMR_OBJECT_TYPE_GENERATION_NUMBER_OBJECT );

    /* Validate the Copy To PC Container Object */
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_COPY_TO_PC_VALID,                       XMR_OBJECT_TYPE_COPY_TO_PC_CONTAINER );

    /* Validate the outermost Unknown Container Object */
    ChkBOOL(
        !XMR_IS_UNKNOWN_CONTAINER_VALID(                f_pXmrLicense )
     || ( f_pXmrLicense->dwVersion >= XMR_VERSION_2 ), DRM_E_INVALIDLICENSE ); /* Unknown objects are V2 and up */

    /* Validate the Revocation Container Object */
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_REVOCATION_VALID,                       XMR_OBJECT_TYPE_REVOCATION_CONTAINER );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_RSA_LICENSE_GRANTER_KEY_VALID,          XMR_OBJECT_TYPE_RSA_LICENSE_GRANTER_KEY_OBJECT );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_USERID_VALID,                           XMR_OBJECT_TYPE_USERID_OBJECT );

    /* Validate the Key Container Object */
    VALIDATE_REQUIRED_OBJECT( f_pXmrLicense, XMR_IS_KEY_MATERIAL_VALID ); /* All licenses require key material */
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_CONTENT_KEY_VALID,                      XMR_OBJECT_TYPE_CONTENT_KEY_OBJECT  ); /* Almost all licenses require a content key. License that are used during regeneration do not need a content key */
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_OPTIMIZED_CONTENT_KEY_VALID,            XMR_OBJECT_TYPE_OPTIMIZED_CONTENT_KEY_OBJECT );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_DEVICE_KEY_VALID,                       XMR_OBJECT_TYPE_RSA_DEVICE_KEY_OBJECT );
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_ECC_DEVICE_KEY_VALID,                   XMR_OBJECT_TYPE_ECC_DEVICE_KEY_OBJECT );

    /* This object is versioned and must be validated by _XMR_ValidateLicenseObjectsVersioned */
    /* VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_UPLINK_KID_VALID,                       XMR_OBJECT_TYPE_UPLINK_KID_OBJECT ); */

    /* Validate the Signature Object */
    VALIDATE_OPTIONAL_OBJECT( f_pXmrLicense, XMR_IS_SIGNATURE_VALID,                        XMR_OBJECT_TYPE_SIGNATURE_OBJECT );

    if( XMR_IS_CONTENT_KEY_VALID( f_pXmrLicense ) )
    {
        /* Validate that the license has a valid encryption type */
        switch( f_pXmrLicense->dwVersion )
        {
        case XMR_VERSION_1:
            ChkBOOL(
                ( f_pXmrLicense->containerOuter.containerKeys.ContentKey.wSymmetricCipherType == XMR_SYMMETRIC_ENCRYPTION_TYPE_AES_128_CTR )
             || ( f_pXmrLicense->containerOuter.containerKeys.ContentKey.wSymmetricCipherType == XMR_SYMMETRIC_ENCRYPTION_TYPE_RC4_CIPHER  )
             || ( f_pXmrLicense->containerOuter.containerKeys.ContentKey.wSymmetricCipherType == XMR_SYMMETRIC_ENCRYPTION_TYPE_AES_128_ECB ), DRM_E_INVALIDLICENSE );
            break;
        case XMR_VERSION_3:
            ChkBOOL(
                ( f_pXmrLicense->containerOuter.containerKeys.ContentKey.wSymmetricCipherType == XMR_SYMMETRIC_ENCRYPTION_TYPE_AES_128_CTR )
             || ( f_pXmrLicense->containerOuter.containerKeys.ContentKey.wSymmetricCipherType == XMR_SYMMETRIC_ENCRYPTION_TYPE_AES_128_ECB )
             || ( f_pXmrLicense->containerOuter.containerKeys.ContentKey.wSymmetricCipherType == XMR_SYMMETRIC_ENCRYPTION_TYPE_COCKTAIL    ), DRM_E_INVALIDLICENSE );
            break;
        default:
            AssertChkArg( FALSE ); /* Should never be reached - checked previously */
            break;
        }
    }

    if( XMR_IS_COPY_VALID( f_pXmrLicense )
     && ( ( f_pXmrLicense->dwVersion >= XMR_VERSION_3 )
       || ( f_pXmrLicense->containerOuter.containerCopyPolicies.dwVersion == 2 ) ) )
    {
        /*
        ** If we have a copy container 2 object,
        ** we MUST have at least one copy enabler under it.
        ** This block verifies that fact.
        */
        pUnknownContainer = &f_pXmrLicense->containerOuter.containerCopyPolicies.UnknownContainer;
        while( ( pUnknownContainer != NULL ) && pUnknownContainer->fValid )
        {
            if( pUnknownContainer->wType == XMR_OBJECT_TYPE_COPY_ENABLER_CONTAINER )
            {
                pUnknownObject = pUnknownContainer->pObject;
                while( ( pUnknownObject != NULL ) && pUnknownObject->fValid )
                {
                    if( pUnknownObject->wType == XMR_OBJECT_TYPE_COPY_ENABLER_OBJECT )
                    {
                        /* 
                        ** Check that the object contains a GUID 
                        */
                        ChkBOOL( SIZEOF(DRM_GUID) == (pUnknownObject->cbData), DRM_E_INVALIDLICENSE );

                        fHasCopyEnabler = TRUE;

                        DRM_BYT_CopyBytes(
                            &dguidFromObject,
                            0,
                            pUnknownObject->pbBuffer,
                            pUnknownObject->ibData,
                            SIZEOF(DRM_GUID) );
                        if( IDENTICAL_GUIDS( &dguidFromObject, &DRM_ACTION_COPY_TO_PC )
                         || IDENTICAL_GUIDS( &dguidFromObject, &DRM_ACTION_COPY_TO_DEVICE ) )
                        {
                            /*
                            ** Domain licenses can only have a copy container
                            ** if the only copy enabler(s) present are NEITHER
                            ** Copy To PC nor Copy To Device
                            */
                            fHasDomainInvalidCopyEnabler = TRUE;
                        }
                    }
                    pUnknownObject = pUnknownObject->pNext;
                }
            }
            pUnknownContainer = pUnknownContainer->pNext;
        }

        ChkBOOL( fHasCopyEnabler, DRM_E_INVALIDLICENSE );
    }

    if( XMR_IS_DOMAIN_ID_VALID( f_pXmrLicense ) )
    {
        /* Domain ID must be 16 bytes */
        ChkBOOL(
            f_pXmrLicense->containerOuter.containerGlobalPolicies.DomainID.cbAccountID == SIZEOF( DRM_GUID ),
            DRM_E_INVALIDLICENSE );

        /*
        ** Make sure the license doesn't have one of the copy
        ** enablers which is invalid for domain-bound licenses
        */
        ChkBOOL( !fHasDomainInvalidCopyEnabler, DRM_E_INVALIDLICENSE );

        /*
        ** Make sure the license doesn't have an uplink KID, because leaf
        ** licenses cannot be domain-bound
        */
        ChkBOOL( !XMR_IS_UPLINK_KID_VALID( f_pXmrLicense ), DRM_E_INVALIDLICENSE );

    }

    /* V2+ licenses don't support explicit minimum revocation lists - they use RIV instead */
    if( XMR_IS_MINIMUM_ENVIRONMENT_VALID( f_pXmrLicense )
     && f_pXmrLicense->dwVersion >= XMR_VERSION_2 )
    {
        ChkBOOL( f_pXmrLicense->containerOuter.containerGlobalPolicies.MinimumEnvironment.dwMinimumAppRevocationListVersion     == 0, DRM_E_INVALIDLICENSE );
        ChkBOOL( f_pXmrLicense->containerOuter.containerGlobalPolicies.MinimumEnvironment.dwMinimumDeviceRevocationListVersion  == 0, DRM_E_INVALIDLICENSE );
    }

    /* Validate the rights mask values */
    if( XMR_IS_RIGHTS_VALID( f_pXmrLicense ) )
    {
        /* Validate that the rights mask takes only valid values for the license version */
        switch( f_pXmrLicense->dwVersion )
        {
        case XMR_VERSION_1:
            /* Don't validate rights mask for V1 licenses for compat with legacy components */
            break;
        case XMR_VERSION_3:
            VALIDATE_RIGHTS_MASK(
                f_pXmrLicense,
                ( XMR_RIGHTS_CANNOT_PERSIST
                | XMR_RIGHTS_CANNOT_BIND_LICENSE ) );
            break;
        default:
            AssertChkArg( FALSE ); /* Should never be reached - checked previously */
            break;
        }
    }

ErrorExit:
    return dr;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\ecexpon.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "ecurve.h"

#include <drmpkcrypto.h>

ENTER_PK_NAMESPACE_CODE;

//      File ecexpon.c.    Version 04 December, 2002.
//
//          Exponentiation on an elliptic curve,
//      with or without using tables.  This code uses
//      projective coordinates for intermediate points.
//
//          Let E be the elliptic curve
//
//              y^2      = x^3 + ax + b     modulo a large prime q,
//      or
//              y^2 + xy = x^3 + ax^2 + b   over GF(2^m).
//
//      Given a point Pbase on E, in affine form,
//      we want to find  exponent*Pbase, where
//      exponent is multiple precision and nonnegative.

//          More precisely we are given the affine points
//      (2^table_spacing)^j * Pbase for 0 <= j <= table_last.
//      [When there is no pre-existing table, set table_last = 0,
//      and store only Pbase = 2^0 * Pbase in the `table'.]
//      We allow exponent > (2^table_spacing)^table_last.
//      That is, we will generate beyond the end of the table if needed.

//          Denote table_radix = 2^table_spacing, with table_spacing > 0.
//      We write the exponent in base table_radix
//      with digits -table_radix/2 to table_radix/2.
//      Some exponents have multiple such representations.

//                                                    i
//          Suppose exponent = sum    e  * table_radix  ,
//                                i    i
//
//      where | e_i | <= table_radix/2.  There are 1 + table_radix/2
//      buckets, where bucket  j   has  +- (table_radix^i)*P
//      wherever   e_i = +- j.  Now we must compute
//
//             sum        j * sum                Q
//                j > 0           (Q in bucket j)


//          We do the inner summations (those within individual buckets)
//      in semi-parallel fashion, keeping everything in affine form.
//      If bucket j has b_j members, then try to do FLOOR(b_j/2)
//      independent elliptic curve additions semi-concurrently.
//      Additions within different buckets can occur
//      semi-concurrently, as can two independent additions
//      in one bucket.  ``Semi-concurrently'' means
//      we schedule the additions to be done back-to-back,
//      and the addition code arranges to do only one inversion
//      (over GF(q) or GF(2^m)).

//          After a few iterations
//      [at most ceil(log_2(largest bucket size))],
//      each bucket shrinks to at most a single point.
//      Then we start combining buckets, to evaluate the outer sum
//
//                  sum        j * (contents of bucket j, in affine form)
//                      j > 0
//
//      [In practice, we start this outer sum before all
//      buckets have shrunk, overlapping these additions with
//      the earlier additions.]

//          Suppose table_radix = 128, so the bucket numbers
//      go from 1 to 64 (we can ignore bucket 0).
//      When a bucket shrinks to a single point,
//      we usually move it to two other buckets:

//          Bucket 48 acquires buckets 32 to 64
//          Bucket 24 acquires 17 to 31
//          Bucket 16 acquires 16, -32, 64
//          Bucket 15 acquires 15, -33, 63
//          Bucket 14 acquires 14, -34, 62
//          Bucket 13 acquires 13, -35, 61
//          Bucket 12 acquires 12, -36, 60
//          Bucket 11 acquires 11, -37, 59
//          Bucket 10 acquires 10, -38, 58
//          Bucket  9 acquires  9, -39, 57
//          Bucket  8 acquires  8, -40, 56
//          Bucket  7 acquires  7, -17, 31, -41, 55
//          Bucket  6 acquires  6, -18, 30, -42, 54
//          Bucket  5 acquires  5, -19, 29, -43, 53
//          Bucket  4 acquires  4, -20, 28, -44, 52
//          Bucket  3 acquires  3, -21, 27, -45, 51
//          Bucket  2 acquires  2, -22, 26, -46, 50
//          Bucket  1 acquires  1, -23, 25, -47, 49

//      (a minus sign means we negate the point during the move).
//      For example, we represent 59*Q59 as 48*Q59 + 11*Q59
//      whereas 37*Q37 is represented as 48*Q37 - 11*Q37.

//          The last two sum to 48*(Q59 + Q37) + 11*(Q59 - Q37).
//      We can do Q59 +- Q37 with one elliptic curve combined affine
//      addition-subtraction, inverting the shared denominator only once.
//      The sum goes to bucket 48 and the difference to bucket 11.

//          After two more rounds of intra-bucket merges.
//      bucket 48 has at most 9 members,
//      bucket 24 at most 3 members,
//      buckets 8 to 16 at most 1 member, and
//      buckets 1 to 7 at most 2 members.  Next

//          Bucket 12 acquires 8, 9, 10, 11, 12, 13, 14, 15, 16.
//          Bucket  6 acquires 5, 6, 7 [May need to wait one round.]
//          Bucket  4 acquires 4, -8, 16
//          Bucket  3 acquires 3, -9, 15
//          Bucket  2 acquires 2, -10, 14
//          Bucket  1 acquires 1, -5, 7, -11, 13

//      After the buckets shrink again, we need

//         48*Q48 + 24*Q24 + 12*Q12 + 6*Q6 + 4*Q4 + 3*Q3 + 2*Q2 + Q1.

//      (the 4*Q4 term is not present if table_radix is an even
//      power of 2, such as 64).  We do this final summation
//      in projective form, starting with  2*(2*Q48 + Q24) + Q12.
//      After summing everything else into the Q3, Q2, Q1 terms,
//      we write 3*Q3 + 2*Q2 + Q1 as 2*(Q3 + Q2) + (Q3 + Q1).

//      ---------------   WITHOUT A TABLE -----------------

//           If table_last = 0, then only one point
//      Pbase_powers[0] = Pbase is supplied by the caller.
//      We select table_spacing based on the number of
//      bits in the exponent.

//          We repeatedly double Pbase, but
//      store only into odd-numbered buckets [except possibly
//      at the end, for the leading digits of the exponent].
//      We combine the buckets as above, but typically need
//      fewer steps since most even-numbered buckets are empty.
//      The doublings are done in projective mode,
//      but everything is converted to affine mode (together)
//      before buckets are combined.

//      ----------------   BASIC OPERATIONS ------------------------

//      AFFINIZATION.  Convert the projective point (X, Y, Z)
//      (where X, Y, Z are not all zero) to (x, y) = (X/Z^2, Y/Z^3).

//          IF Z == 0 THEN
//              Return point at infinity;
//          ELSE
//              zinv = 1/Z;
//              zinv2 = zinv^2;
//              x = X*zinv2;
//              y = Y*zinv*zinv2;
//          END IF

//      Costs 1 inversion, 1 squaring, and 3 more multiplications.


//      AFFINE ADDITION.  Given (x1, y1) and (x2, y2) on E,
//      compute (x3, y3) = (x1, y1) + (x2, y2) on E.

//          IF (x1, y1) is point at infinity THEN
//              Set result to (x2, y2);
//          ELSE IF (x2, y2) is point at infinity THEN
//              Set result to (x1, y1);
//          ELSE IF x1 == x2 THEN
//              IF y1 == y2 THEN
//                  Use AFFINE DOUBLING algorithm
//              ELSE
//                  Set result to point at infinity
//              END IF
//          ELSE
//              m = (y1 - y2)/(x1 - x2);
//              IF working over GF(q)
//                  x3 = m^2 - x1 - x2;
//                  y3 = m*(x1 - x3) - y1;
//              ELSE
//                  x3 = m^2 + m - x1 - x2 - a;
//                  y3 = m*(x1 - x3) - y1 - x3;
//              END IF
//          END IF

//      Usually the cost is one division (= multiplication + inversion)
//      plus a squaring and multiplication.


//      AFFINE ADDITION-SUBTRACTION.  Given two affine points
//      (x1, y1) and (x2, y2) on E, compute
//      (x3, y3) = (x1, y1) + (x2, y2) and
//      (x4, y4) = (x1, y1) - (x2, y2).

//          IF (x1, y1) or (x2, y2) is the point at infinity
//              Set answers to other point, or its negative.
//          ELSE IF x1 == x2 THEN
//              One result is the point at infinity.
//              Use AFFINE DOUBLING for the other.
//          ELSE
//              deltax_inv = 1/(x1 - x2)
//              IF working over GF(q) THEN
//                  m3 = (y1 - y2)*deltax_inv;
//                  m4 = (y1 + y2)*deltax_inv;
//                  x3 = m3^2 - x1 - x2;
//                  x4 = m4^2 - x1 - x2;
//                  y3 = m3*(x1 - x3) - y1;
//                  y4 = m4*(x1 - x4) - y1;
//              ELSE
//                  m3 = (y1 - y2)*deltax_inv;
//                  m4 = (y1 + x2 + y2)*deltax_inv;
//                  x3 = m3^2 + m3 - x1 - x2 - a;
//                  x4 = m4^2 + m4 - x1 - x2 - a;
//                  y3 = m3*(x1 - x3) - x3 - y1;
//                  y4 = m4*(x1 - x4) - x4 - y1;
//              END IF
//          END IF

//      Usually the cost is 1 inversion, 2 squarings, 4 multiplications


//      AFFINE DOUBLING.  Given (x1, y1) on E, compute
//      (x2, y2) = 2*(x1, y1) on E.

//          IF working over GF(q) THEN
//              IF (y1 == 0) THEN
//                  Set result to point at infinity
//              ELSE
//                  m = (3*x1^2 + a)/(2*y1);
//                  x2 = m^2 - 2*x1;
//                  y2 = m*(x1 - x2) - y1;
//              END IF
//          ELSE
//              IF (x1 == 0) THEN
//                  Set result to point at infinity
//              ELSE
//                  m = x1 + y1/x1;
//                                 (from (3*x1^2 + 2*a*x1 - y1)/(2*y1 + x1)
//                  x2 = m^2 + m - a;    (from m^2 + m - 2*x1 - a)
//                  y2 = m*(x1 - x2) - y1 - x2;
//              END IF
//          END IF

//      Usual cost is:
//              1 division (inversion + multiplication)
//              1 squaring over GF(2^m), 2 over GF(q)
//              1 multiplication


//      AFFINE NEGATION.  Given an affine point (x1, y1) on E,
//      compute its negative (x2, y2) = -(x1, y1) on E.

//           x2 = x1;
//           IF working over GF(q) THEN
//               y2 = -y1;
//           ELSE
//               y2 = -x1 - y1;
//           END IF

//      No multiplications or inversions needed.

//      PROJECTIVE ADDITION.  Given two projective points (X1, Y1, Z1)
//      and (X2, Y2, Z2) on E, compute
//
//           (X3, Y3, Z3) = (X1, Y1, Z1) + (X2, Y2, Z2)
//
//           IF Z1 == 0 THEN
//               Copy (X2, Y2, Z2) to (X3, Y3, Z3)
//           ELSE IF Z2 == 0 THEN
//               Copy (X1, Y1, Z1) to (X3, Y3, Z3)
//           ELSE
//               U1 = X1*Z2^2;
//               S1 = Y1*Z2^3;
//               U2 = X2*Z1^2;
//               S2 = Y2*Z1^3;
//               W  = U1 - U2;
//               R  = S1 - S2;
//               IF (W == 0) THEN
//                   IF (R == 0) THEN
//                       Use projective doubling algorithm
//                   ELSE
//                       Set result to point at infinity.
//                   END IF
//               ELSE if working over GF(q) THEN
//                   Z3 = W*Z1*Z2
//                   T1 = U1*W^2
//                   T2 = U2*W^2;
//                   X3 = R^2 - T1 - T2;
//                   Y3 = S1*(T2 - T1) - R*(X3 - T1);
//                              // Same as Y3 = -R*X3 + S1*T2 - S2*T1
//               ELSE     // (working over GF(2^m))
//                   Z3 = W*Z1*Z2;
//                   T1 = U1*W^2;
//                   T2 = U2*W^2;
//                   T3 = R + Z3;
//                   X3 = -a Z3^2 + T3*R - T1 - T2;
//                   Y3 = -T3*X3 + S1*T2 - S2*T1
//                          N.B.  This uses one fewer squaring
//                                than the P1363 code of August, 1998.
//               END IF
//           END IF

//      PROJECTIVE-AFFINE ADDITION.  Add a projective point
//      (X1, Y1, Z1) to an affine point (x2, y2).  This is the
//      above code with (X2, Y2, Z2) = (x2, y2, 1).

//      PROJECTIVE DOUBLING.  Given a projective point (X1, Y1, Z1)
//      on E, compute (X2, Y2, Z2) = 2*(X1, Y1, Z1).
//
//          IF z1 == 0 THEN
//              Set (X2, Y2, Z2) to point at infinity
//          ELSE IF working over GF(2^m) THEN
//              X2 = X1^4 + b*Z1^8;
//              Z2 = X1*Z1^2;
//              Y2 = (b*Z1^8)*Z2 + (X1^2 + Y1*Z1)*X2;
//          ELSE
//              S = 4*X1*Y1^2;
//              M = 3*X1^2 + a*Z1^4;
//              X2 = M^2 - 2*S;
//              Y2 = M*(S - X2) - 8*Y1^4;
//              Z2 = 2*Y1*Z1;
//              IF doing several doublings in succession THEN
//                  a*Z2^4 = 2*(a*Z1^4)*(8*Y1^4);
//                           (an observation of Wei Dai)
//              END IF
//          END IF

//       Over GF(q), if we are doing several back-to-back
//       doublings (so a*Z1^4 is known in advance),
//       then the cost per doubling is

//           4 squarings:       X1^2, Y1^2, (2*Y1^2)^2, m^2
//           4 multiplications: X1*Y1^2, M*(S - X2), Y1*Z1, new a*Z1^4

//       Over GF(2^m), this cost is

//           5 squarings:       X1^2, X1^4, Z1^2, Z1^4, Z1^8
//           5 multiplications: b*Z1^8, X1*Z1^2, 3 more for Y2



#define TABLE_SPACING_MAX 7
#define BUCKET_NUMBER_MAX ((DRM_LONG)1 << (TABLE_SPACING_MAX-1))
#define BUCKET_ZERO 0
#define MAX_SLOT 20

typedef enum {ECOP_AFFINIZATION = 1,
              ECOP_ADD,
              ECOP_DOUBLING,
              ECOP_DO_NOTHING} concurrent_op_t;

/*
    digit_t is used for some temporaries.
    It has five field entries packed together (total length 5*elng).
    The first three are a projective point (x, y, z),
    representing the point at infinity if z == 0
    or the affine point (x/z^2, y/z^3) if z != 0.

    The last two entries are optional, and used only over GF(q) fields.
    If nonzero, their product should be a*z^4.
    They are used to speed repeated doublings.
*/
#define ECPROJ5_TEMPS_COUNT 10
       // ecproj5_add_ecaffine needs 10
       // Variable p5temps and typedef digit_t * used
       // for digit_t arrays of length
       // elng*ECPROJ5_TEMPS_OOUNT + ecurve->ndigtemps.
       // (If this changes, be sure to alter test program.)

 /*
        The next struct has much of the temporary data during
        an exponentiation.  It has data shared by multiple
        procedures, as well as large arrays needed locally
        A copy of the struct is malloc-ed early
        in ecaffine_exponentiation_tabular
        and released before exiting.

        The pending_op array holds a queue of requests requiring
        inversions (see operations above).
        The AFFINIZATION, DOUBLING, ADD requests
        take one or two inputs, and produce one output.
        New queue requests may (recursively) be generated
        as outputs are sent to their intended destinations.

        Each bucket (see comments at start of file)
        has a current contents, which may be the identity
        (point at infinity).  It also has an _anticipating_ count.
        The anticipating count is the number of outputs
        in pending_addsubs or pending_op destined for that bucket.
*/

typedef struct {
           DRM_BOOL         OK;          // Error indicator (TRUE if no error)
           DRM_BOOL         char2;       // Characteristic 2?
           DRM_DWORD        slots_in_use;
                             // Next available index in pending_ops
           DRM_LONG         bucket_max;  // Largest bucket number in use
           const ecurve_t  *ecurve;      // Elliptic curve information
           struct {
               DRM_LONG out1;        /* Larger output index */
               DRM_LONG out2;        /* Smaller output index */
                     /* Input buckets are out1 +- out2.
                        Outputs are out1 and out2.  */
           } pending_addsubs[BUCKET_NUMBER_MAX/2];

           struct {
               digit_t    *contents;     // x and y.  Length 2*slng
               DRM_INT     anticipating;
           } bucket[BUCKET_NUMBER_MAX + 1];

           struct {
               digit_t         *inputs;             // Length 4*elng
               DRM_INT          negate_flag;
               concurrent_op_t  operation;
               DRM_LONG         output_bucket;

               DRM_DWORD        denom_index;  // For ec_concurrent_operations
           } pending_op[MAX_SLOT];

           digit_t             *latest_power_known;  // Length 5*elng
           digit_t             *output_point;   // Length 5*elng
           digit_t             *p5temps;        // pointer
           digit_t             *concurrent_ops_temps;  // Length 4*elng
           digit_t             *denoms;         // Length elng*MAX_SLOT
           digit_t             *denom_inverses; // Length elng*MAX_SLOT
           DRM_DWORD            aib_recursion_level;  // Nesting level in
                                            // affine_insert_bucket
           digit_t             *aib_temps[2];   // Two arrays, each length 2*elng
    } ecexpon_data_t;

static DRM_VOID DRM_CALL affine_insert_bucket
     (const digit_t *, const DRM_LONG, ecexpon_data_t*, const DRM_INT, struct bigctx_t *f_pBigCtx);

static DRM_BOOL DRM_CALL ecaffine_to_ecproj5(const digit_t *, digit_t *,
                                const struct ecurve_t*, digit_t *, struct bigctx_t *f_pBigCtx);

static DRM_VOID DRM_CALL ec_concurrent_operations(ecexpon_data_t*, struct bigctx_t *f_pBigCtx);

static DRM_DWORD DRM_CALL get_ec_concurrent_slot(ecexpon_data_t*, struct bigctx_t *f_pBigCtx);

static DRM_VOID DRM_CALL proj5_insert_bucket
        (const digit_t*, const DRM_LONG, ecexpon_data_t*, const DRM_INT, struct bigctx_t *f_pBigCtx);

static DRM_VOID DRM_CALL schedule_affine_add_and_sub
        (const digit_t *, const digit_t *, const DRM_LONG, const DRM_LONG,
            ecexpon_data_t*, struct bigctx_t *f_pBigCtx);

static DRM_VOID DRM_CALL schedule_affine_add_or_sub
          (const digit_t *, const digit_t *,
           const DRM_LONG, ecexpon_data_t*, const DRM_INT, struct bigctx_t *f_pBigCtx);


static DRM_BOOL DRM_CALL ecproj5_add_ecaffine
            (const digit_t *, const digit_t *,
            digit_t *, const struct ecurve_t*, digit_t *, struct bigctx_t *f_pBigCtx);

static DRM_BOOL DRM_CALL ecproj5_add_ecproj5(const digit_t *, const digit_t *,
                                       digit_t *, const struct ecurve_t*,
                                       digit_t *, struct bigctx_t *f_pBigCtx);

static DRM_BOOL DRM_CALL ecproj5_doubling(const digit_t *, digit_t *,
                                    const struct ecurve_t*, digit_t *, struct bigctx_t *f_pBigCtx);

static DRM_BOOL DRM_CALL ecproj5_on_curve(const digit_t *, const struct ecurve_t*,
                                    const DRM_CHAR *, digit_t *, struct bigctx_t *f_pBigCtx);

static DRM_BOOL DRM_CALL ecproj5_set_infinite
             (digit_t *, const struct ecurve_t*, digit_t *);

static DRM_BOOL DRM_CALL ecproj5_to_ecaffine(const digit_t *, digit_t *,
                                const struct ecurve_t*, digit_t *, struct bigctx_t *f_pBigCtx);


// ---------------------------------------------------------------------
// ---------------------------------------------------------------------

DRM_NO_INLINE DRM_BOOL DRM_CALL ecaffine_exponentiation_tabular
                (const digit_t *Pbase_powers,
                 const DRM_DWORD    table_spacing,
                 const DRM_DWORD    table_last,
                 const digit_t     exponent[],
                 const DRM_DWORD    lexpon,
                 digit_t  *result,
                 const ecurve_t   *ecurve,
                 struct bigctx_t *f_pBigCtx)
{
    const DRM_DWORD      nbit_exponent
                       = mp_significant_bit_count(exponent, lexpon);
    const field_desc_t *fdesc = ecurve->fdesc;
    const DRM_DWORD      elng  = fdesc->elng;
    const DRM_LONG  bucket_max
                         = (DRM_LONG)1 << (table_spacing - 1);

    DRM_LONG carry_bits, ibucket;
    DRM_DWORD iaddsub, ibatch, ibit, iop, lg2_latest_power_known, naddsub;
    DRM_BOOL progress;
    DRM_BOOL OK = TRUE;
    const digit_t *Pbase_powers_next;
    digit_t     *dtemps = NULL;
    ecexpon_data_t ecxdat, *pecxdat = &ecxdat;
    const DRM_DWORD num_p5temps = elng*ECPROJ5_TEMPS_COUNT + ecurve->ndigtemps;
    const DRM_DWORD num_dtemps = num_p5temps + 6*MAX_SLOT*elng
             + 2*elng*(bucket_max + 1) + 18*elng;

    /*
    ** Overflow/Underflow check
    */
    if ( num_p5temps < ecurve->ndigtemps
      || elng*ECPROJ5_TEMPS_COUNT < elng
      || num_p5temps < elng*ECPROJ5_TEMPS_COUNT )
    {
        OK = FALSE;
    }

    if (!OK) {
    } else if (table_spacing < 3 || table_spacing > TABLE_SPACING_MAX) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                       "ec_exponentiaton_tabular");

        TRACE( ( "Invalid table_spacing = %ld in ec exponentiation_tabular -- not in [3, %ld]\n",
               ( DRM_LONG )table_spacing, ( DRM_LONG )TABLE_SPACING_MAX ) );      
    } else {
        dtemps = digit_allocate(num_dtemps,
                               "ecaffine_exponentiation_tabular", f_pBigCtx);
        if (dtemps == NULL) OK = FALSE;
    }
    if (OK) {
        digit_t * p5temps = dtemps;
        digit_t *pending_op_inputs = p5temps + num_p5temps;
        digit_t *bucket_contents = pending_op_inputs + 4*MAX_SLOT*elng;
        pecxdat->denoms = bucket_contents + 2*elng*(bucket_max + 1);
        pecxdat->denom_inverses = pecxdat->denoms + MAX_SLOT*elng;
        pecxdat->aib_temps[0] = pecxdat->denom_inverses + MAX_SLOT*elng;
        pecxdat->aib_temps[1] = pecxdat->aib_temps[0] + 2*elng;
        pecxdat->latest_power_known = pecxdat->aib_temps[1] + 2*elng;
        pecxdat->output_point = pecxdat->latest_power_known + 5*elng;
        pecxdat->concurrent_ops_temps = pecxdat->output_point + 5*elng;
        DRMASSERT (pecxdat->concurrent_ops_temps + 4*elng == dtemps + num_dtemps);

        pecxdat->aib_recursion_level = 0;
        pecxdat->bucket_max = bucket_max;
        pecxdat->char2 = CHARACTERISTIC_2(fdesc);
                                          // Characteristic 2?
        pecxdat->ecurve = ecurve;
        pecxdat->OK = OK;
        pecxdat->p5temps = p5temps;
        pecxdat->slots_in_use = 0;

        for (iop = 0; iop != MAX_SLOT; iop++) {
            pecxdat->pending_op[iop].inputs = pending_op_inputs + 4*iop*elng;
        }

        for (ibucket = 0; ibucket <= bucket_max; ibucket++) {
            pecxdat->bucket[ibucket].anticipating = 0;
                 // Not anticipating any exports from other buckets
            pecxdat->bucket[ibucket].contents
                   = bucket_contents + 2*ibucket*elng;
                 // Address for (x, y)
            pecxdat->OK = pecxdat->OK
                 && ecaffine_set_infinite
                         (pecxdat->bucket[ibucket].contents,
                         ecurve, f_pBigCtx);
                     // Empty bucket (i.e., set contents to point at infinity)
         } // for ibucket

/*
            Initialize table of addition-subtraction pairs.
            If table_spacing = 7 (i.e,, bucket_max = 64), we pair

                 48-i  with  48+i  for  1 <= i <= 16
                 24-i  with  24+i  for  1 <= i <= 7
                 12-i  with  12+i  for  1 <= i <= 4
                  6-i  with   6+i  for  1 <= i <= 1

            and have {1, 2, 3, 4, 6, 12, 24, 48} remaining.
            If instead table spacing = 6 (bucket_max = 32), then we pair

                 24-i  with  24+i  for  1 <= i <= 8
                 12-i  with  12+i  for  1 <= i <= 3
                  6-i  with   6+i  for  1 <= i <= 2

            and have {1, 2, 3, 6, 12, 24} remaining.
*/

        naddsub = 0;
        for (ibatch = 0;
             ibatch != table_spacing - 3 && pecxdat->OK;
             ibatch++) {
            const DRM_LONG ipow2 = (DRM_LONG)1
                                  << (table_spacing - 3 - ibatch);

            for (ibucket = 1;
                 ibucket <= ipow2 - (DRM_LONG)(ibatch & 1);
                 ibucket++) {

                /* Pair 3*ipow2 +- ibucket */

                pecxdat->pending_addsubs[naddsub].out1 = 3*ipow2;
                pecxdat->pending_addsubs[naddsub].out2 = ibucket;
                naddsub++;
                pecxdat->bucket[3*ipow2].anticipating++;
                pecxdat->bucket[ibucket].anticipating++;
            }
        } /* for ibatch */
        if (!pecxdat->OK) {
        } else if (naddsub >   SIZEOF(pecxdat->pending_addsubs)
                              /SIZEOF(pecxdat->pending_addsubs[0])) {
            pecxdat->OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                            "ecexpon pending_addsubs overflow");
            TRACE( ( "Pending_addsubs overflow in ecexpon, table_spacing = %ld, naddsub = %ld\n",
                   ( DRM_LONG )table_spacing, ( DRM_LONG )naddsub ) );
        }

               // Plan to use the first point in the
               // supplied table as our latest point.

        lg2_latest_power_known = 0-table_spacing;
        Pbase_powers_next = Pbase_powers;

             // Loop through bits of exponent, right to left.
             // Entire loop is skipped if nbit_exponent = 0.

        carry_bits = 0;
        for (ibit = 0;
            (ibit < nbit_exponent || carry_bits != 0) && pecxdat->OK;
             ibit++) {
            if (ibit < nbit_exponent) {
                carry_bits +=
                    (DRM_LONG)mp_getbit(exponent, ibit)
                 << (ibit - lg2_latest_power_known);
            }
                // We need to add
                // (remaining bits ++ carry_bits)*latest_power_known,
                // where ++ denotes adddition after shifting left operand.
                // The parenthesized quantity is known to be strictly positive.

/*
              As long as the supplied table (Pbase_powers)
              still has useful data, we multiply each table entry
              (or its negative) by an integer up to
              bucket_max = 2^(table_spacing - 1) .
              If the exponent is beyond the range of the table.
              then (after the table has been exhausted),
              we repeatedly double the last entry from the table
              and occasionally multiply that result by an integer.

              As long as ibit <= lg2_latest_power2 + table_spacing,
              we procrastinate deciding which multiple of
              latest_power_known to use
              (i.e., which bucket to deposit it in).

              If carry_bits exceeds bucket_max, or if
              there are more exponent bits to process, then we know
              we'll be multiplying latest_power_known by a large number.
              When there are no more table entries, and we know that
              this multiplier will be even, we divide it by 2
              and double latest_power_known now, to
              reduce the size of the multiplier.
*/
            if (ibit >= lg2_latest_power_known + table_spacing) {
                  /*
                     Choose ibucket == carry_bits (mod 2*bucket_max),
                     with  ABS(ibucket) <= bucket_max.

                     If carry_bits == bucket_max (mod 2*bucket_max),
                     we can choose ibucket = +- bucket_max.
                     Choose the sign so that
                     ibucket == carry_bits (mod 4*bucket_max).
                     Then the new carry_bits
                     (after dividing by 2*bucket_max on next iteration)
                     will be even, and more likely to be zero.

                     When ibit = 0, latest_power_known will be uninitialized,
                     but this is OK since ibucket = 0.
                 */

                ibucket = ((carry_bits + bucket_max) & (4*bucket_max - 1))
                            - bucket_max;  // In [-bucket_max, 3*bucket_max - 1]

                if (ibucket > bucket_max) ibucket -= 2*bucket_max;
                                       // In [-bucket_max, bucket_max]
                carry_bits -= ibucket;

                if (ibucket != BUCKET_ZERO) {
                    DRM_INT negate_flag;
                    if (ibucket < 0) {
                        negate_flag = -1;
                        ibucket = -ibucket;
                    } else {
                        negate_flag = +1;
                    }

                    proj5_insert_bucket(pecxdat->latest_power_known,
                               ibucket, pecxdat, negate_flag, f_pBigCtx);
                }

                if (   carry_bits < 0
                    || carry_bits != (carry_bits >> table_spacing)
                                         << table_spacing) {
                    pecxdat->OK = FALSE;
                    SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                            "ec_exponentiation_tabular carry bits");
                    TRACE( ( "Invalid carry_bits = %ld in ec_exponentiation_tabular\n",
                           ( DRM_LONG )carry_bits ) );
                }

                if (   lg2_latest_power_known + table_spacing
                    <= table_last*table_spacing) {
                                  /* More entries in supplied table */

                    lg2_latest_power_known += table_spacing;
                    carry_bits >>= table_spacing; /* Divide by 2*bucket_max */

                    pecxdat->OK = pecxdat->OK &&
                        ecaffine_to_ecproj5(Pbase_powers_next,
                                            pecxdat->latest_power_known,
                                            ecurve, p5temps, f_pBigCtx);
                    Pbase_powers_next += 2*elng;
                } /* New table entry? */
            } /* if */

            while (     ibit >= lg2_latest_power_known + table_spacing
                    &&  IS_EVEN(carry_bits)
                    &&  pecxdat->OK
                    && (    ibit < nbit_exponent - 1
                         || carry_bits > bucket_max)) {
                            /* Go beyond user-supplied table */
                carry_bits /= 2;
                pecxdat->OK = pecxdat->OK
                        && ecproj5_doubling(pecxdat->latest_power_known,
                                        pecxdat->latest_power_known,
                                        ecurve, p5temps, f_pBigCtx);
                lg2_latest_power_known++;
            } /* while */

            if (   ibit < lg2_latest_power_known
                || ibit > lg2_latest_power_known + table_spacing) {
                pecxdat->OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "ecaffine_exponentiation_tabular -- bad ibit");
                TRACE( ( "ecaffine_exponentiation_tabular -- ibit = %ld, lg2_latest_power_known = %ld\n",
                       ( DRM_LONG )ibit, ( DRM_LONG )lg2_latest_power_known ) );
            }
        } /* for ibit */

/*
        Various powers +- 2*j * Pbase have been inserted into buckets
        (perhaps with an affinization scheduled first).
        Where a bucket has multiple entries,
        start summing those entries, two at a time
        [so its population drops approximately in half].
        When a bucket shrinks to one entry, and nothing else
        is waiting to go there, move the bucket's output elsewhere.
 */
        progress = TRUE;
        while (pecxdat->OK && progress) {
            DRM_DWORD naddsub_new = 0;

            for (iaddsub = 0; iaddsub != naddsub; iaddsub++) {
                const DRM_LONG out1
                      = pecxdat->pending_addsubs[iaddsub].out1;
                const DRM_LONG out2
                      = pecxdat->pending_addsubs[iaddsub].out2;
                const DRM_LONG in1 = out1 + out2;
                const DRM_LONG in2 = out1 - out2;

                if (   pecxdat->bucket[in1].anticipating == 0
                    && pecxdat->bucket[in2].anticipating == 0) {
                    digit_t *p1 = pecxdat->bucket[in1].contents;
                    digit_t *p2 = pecxdat->bucket[in2].contents;
                     /* If neither bucket is anticipating, */
                     /* then both are available to be moved. */
                    schedule_affine_add_and_sub(p1, p2, out1,
                                            out2, pecxdat, f_pBigCtx);
                    pecxdat->OK = pecxdat->OK
                        && ecaffine_set_infinite(p1, ecurve, f_pBigCtx)
                        && ecaffine_set_infinite(p2, ecurve, f_pBigCtx);
                } else {
                    pecxdat->pending_addsubs[naddsub_new].out1 = out1;
                    pecxdat->pending_addsubs[naddsub_new].out2 = out2;
                    naddsub_new++;    /* Put at start of table. */
                                      /* Try again next iteration. */
                }
            } /* for iaddsub */
            progress = (naddsub_new != naddsub);
            naddsub = naddsub_new;

            if (!progress && pecxdat->slots_in_use > 0) {
                progress = TRUE;
                ec_concurrent_operations(pecxdat, f_pBigCtx);
            }
        } // while

        for (ibucket = 1; ibucket <= bucket_max; ibucket++) {
            const DRM_INT antic = pecxdat->bucket[ibucket].anticipating;
            if (antic != 0 && pecxdat->OK) {
                pecxdat->OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                    "ecaffine_exponentiation_tabular -- anticipating nonzero");
                
                TRACE( ( "ecaffine_exponentiation_tabular -- bucket %ld has anticipating = %d\n",
                       ( DRM_LONG )ibucket, ( DRM_INT )antic ) );
            }
        } // for ibucket

        //  Form output_point = 16*Q48 + 8*Q24 + 4*Q12 + 2*Q6 + Q3 (say)

        pecxdat->OK = pecxdat->OK
            && ecproj5_set_infinite(pecxdat->output_point, ecurve,
                                    p5temps);
        for (ibatch = 0;
             ibatch <= table_spacing - 3 && pecxdat->OK;
             ibatch++) {

            const DRM_LONG ipow2 = (DRM_LONG)1
                                    << (table_spacing - 3 - ibatch);
            digit_t *p1 = pecxdat->bucket[3*ipow2].contents;

            pecxdat->OK = pecxdat->OK
                && ecproj5_doubling(pecxdat->output_point,
                                    pecxdat->output_point,
                                    ecurve, p5temps, f_pBigCtx)
                && ecproj5_add_ecaffine(pecxdat->output_point, p1,
                                        pecxdat->output_point,
                                        ecurve, p5temps, f_pBigCtx)
                && ecaffine_set_infinite(p1, ecurve, f_pBigCtx);
        } // for ibatch

//      Finish output_point = 4*Q4 + 3*output_point + 2*Q2 + Q1
//      Q4 will often be the point at infinity.
//      Use latest_power_known for 2*Q4 + Q2.
//      Then write 3*output_point + 2*latest_power_known + Q1
//      as 2*(output_point + latest_power_known) + (output_point + Q1).

        pecxdat->OK = pecxdat->OK
            && ecaffine_to_ecproj5(pecxdat->bucket[4].contents,
                                   pecxdat->latest_power_known,
                                   ecurve, p5temps, f_pBigCtx) // Q4
            && ecproj5_doubling(pecxdat->latest_power_known,
                                pecxdat->latest_power_known,
                                ecurve, p5temps, f_pBigCtx)    // 2*Q4
            && ecproj5_add_ecaffine(pecxdat->latest_power_known,
                                    pecxdat->bucket[2].contents,
                                    pecxdat->latest_power_known,
                                    ecurve, p5temps, f_pBigCtx) // 2*Q4 + Q2
            && ecproj5_add_ecproj5(pecxdat->latest_power_known,
                                   pecxdat->output_point,
                                   pecxdat->latest_power_known,
                                   ecurve, p5temps, f_pBigCtx)
                                                             // 2*Q4 + Q2 + Q3
            && ecproj5_add_ecaffine(pecxdat->output_point,
                                    pecxdat->bucket[1].contents,
                                    pecxdat->output_point,
                                    ecurve, p5temps, f_pBigCtx);   // Q3 + Q1

    //   Now need 2*latest_power_known + output_point.
    //   Convert final output to affine form.

        pecxdat->OK = pecxdat->OK
            && ecproj5_doubling(pecxdat->latest_power_known,
                                pecxdat->latest_power_known,
                                ecurve, p5temps, f_pBigCtx)
            && ecproj5_add_ecproj5(pecxdat->latest_power_known,
                                   pecxdat->output_point,
                                   pecxdat->output_point,
                                   ecurve, p5temps, f_pBigCtx)
            && ecproj5_to_ecaffine(pecxdat->output_point, result,
                                   ecurve, p5temps, f_pBigCtx);

//   Check that we did not neglect any data in the buckets.

        for (ibucket = 1;
             ibucket <= bucket_max && pecxdat->OK; ibucket++) {
            const DRM_INT antic = pecxdat->bucket[ibucket].anticipating;
            const digit_t *contents = pecxdat->bucket[ibucket].contents;

            if (antic != 0) {
                pecxdat->OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                       "ecaffine_exponentiation_tabular, bad anticipating");
                TRACE( ( "ecaffine_exponentiation_tabular -- bucket %ld has anticipating = %d\n",
                       ( DRM_LONG )ibucket, antic ) );
            }
            if (ibucket > 4 && !ecaffine_is_infinite(contents, ecurve,
                                                     f_pBigCtx)) {
                pecxdat->OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                         "ecaffine_exponentiation_tabular -- bucket not used");
                TRACE( ( "ecaffine_exponentiation_tabular -- bucket %ld output not used\n", 
                       ( DRM_LONG )ibucket ) );
            }
        } // for ibucket
             OK = pecxdat->OK;
    }
    if (dtemps != NULL) {Free_Temporaries(dtemps, f_pBigCtx);}
    return OK;
} // end ecaffine_exponentiation_tabular
/* --------------------------------------------------------  */
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL ecaffine_table_construction
        (const digit_t *p0,          // Input point
         const DRM_DWORD   table_spacing,
         const DRM_DWORD   table_last,
         digit_t *table,        // OUT -- size 2*elng*(table_last+1)
         const ecurve_t  *ecurve,
         struct bigctx_t *f_pBigCtx)
/*
     In some problems one point on an elliptic curve is
     raised to multiple powers.  An example is the
     first phase of Diffie-Hellman, where a public
     generator is raised to a random power,
     and may be raised to a different random power later.

     ecaffine_exponentiation_tabular allows the user
     to input a table containing

           g,  g^e, g^(e^2), g^(e^3),

     where e = 2^(table_spacing).

     This routine constructs that table.
     The output array (table) has p0 in its first entry (2*elng words).
     The second entry has e*p0, then (e^2)*p0, ... up to
     (e^table_spacing)*p0.

     The choice of table_spacing depends upon space and speed
     requirements.  For moderate exponents (e.g., 160 bits)
     4 is adequate.  5 or 6 is better for 512-bit exponents.
*/

{
    const field_desc_t *fdesc = ecurve->fdesc;
    const DRM_DWORD elng = fdesc->elng;
    DRM_DWORD i, num_finite_points;

    DRM_BOOL OK = TRUE;

    digit_t *denoms;      // Length elng*table_last
    digit_t *drecips;     // Length elng*table_last
    digit_t *ecpoint;     // Length 5*elng
    digit_t *ectemps;     // Length ecurve->ndigtemps (affine EC operations)
                          // Overlaps ftemps
    digit_t *ftemps;      // Length ecurve->fdesc->ndigtemps_arith;
    digit_t *ftemp1;      // Length elng
    digit_t *p5temps;     // Length ECPROJ5_TEMPS_COUNT * elng

    const DRM_DWORD numdtemps =   elng*(6 + ECPROJ5_TEMPS_COUNT + 2*table_last)
                          + ecurve->ndigtemps;
    digit_t *dtemps = NULL;

    if( numdtemps >= ecurve->ndigtemps 
     && elng*(6 + ECPROJ5_TEMPS_COUNT + 2*table_last) >= elng
     && numdtemps >= elng*(6 + ECPROJ5_TEMPS_COUNT + 2*table_last) )
    {
        dtemps = digit_allocate(numdtemps,
                                "ecaffine_table_construction",
                                f_pBigCtx);
    }
    if (dtemps == NULL) {
        OK = FALSE;
        denoms = drecips = ecpoint = ftemp1 = p5temps
               = ftemps = ectemps = NULL;
    } else {
        denoms = dtemps;
        drecips = denoms + elng*table_last;
        ecpoint = drecips + elng*table_last;
        ftemp1 = ecpoint + 5*elng;
    // p5temps, ftemps, ectemps must remain together
        p5temps = ftemp1 + elng;
        ftemps = ectemps = p5temps + ECPROJ5_TEMPS_COUNT*elng;
        DRMASSERT(ectemps + ecurve->ndigtemps == dtemps + numdtemps);
    }
    OK = OK && ecaffine_on_curve(p0, ecurve,
                      "",
                      ectemps, f_pBigCtx);
    MEMCPY( table,p0,( 2* fdesc->elng)*SIZEOF( digit_t ));// Copy given point
    OK = OK && ecaffine_to_ecproj5(p0, ecpoint, ecurve, p5temps, f_pBigCtx);

    num_finite_points = 0;
    for (i = 1; OK && i <= table_last; i++) {
        digit_t *tablei = table + 2*elng*i;
        digit_t *z = ecpoint + 2*elng;
        DRM_DWORD j;

        for (j = 0; j != table_spacing; j++) {
            OK = OK && ecproj5_doubling(ecpoint, ecpoint, ecurve,
                                        p5temps, f_pBigCtx);
        }

        if (Kiszero(z, fdesc, f_pBigCtx)) {// Doubling gave point at infinity
            OK = OK && ecaffine_set_infinite(tablei, ecurve, f_pBigCtx);
        } else {
            num_finite_points++;
            MEMCPY( tablei,ecpoint,( 2* fdesc->elng)*SIZEOF( digit_t ));        // x and y
            MEMCPY( denoms + elng*(i-1),z,fdesc->elng*SIZEOF( digit_t )); // z (nonzero)
        }
    } // for i

    //  Invert denominators (z values).

    if (!OK) {
    } else if (num_finite_points > table_last) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                       "ecaffine_table_construction");

    } else {      // Invert z values
        OK = OK && Kinvert_many(denoms, drecips,
                                num_finite_points,
                                fdesc, ftemps, f_pBigCtx);

                  // Set each (x, y) to (x/z^2, y/z^3)

        for (i = 0; i != num_finite_points; i++) {
            const digit_t *zinv = drecips + i*elng;
            digit_t *x = table + 2*(i+1)*elng;
            digit_t *y = x + elng;

            OK = OK && Kmul(zinv, zinv, ftemp1, fdesc, ftemps,
                                                       f_pBigCtx)  // 1/z^2
                    && Kmul(y,  zinv, y,        fdesc, ftemps,
                                                       f_pBigCtx)  // y/z
                    && Kmul(y, ftemp1, y,       fdesc, ftemps,
                                                       f_pBigCtx)  // y/z^3
                    && Kmul(x, ftemp1, x,       fdesc, ftemps,
                                                       f_pBigCtx); // x/z^2
        } // for i
    }

#if BIGNUM_EXPENSIVE_DEBUGGING
    for (i = 0; OK && i <= table_last; i++) {
        OK = OK && ecaffine_on_curve(table + 2*elng*i, ecurve,
                           "ecaffine_table_construction output",
                           ectemps, f_pBigCtx);
    } // for i
#endif

    if (dtemps != NULL) {Free_Temporaries(dtemps, f_pBigCtx);}
    return OK;
} // end ecaffine_exponentiation
/* --------------------------------------------------------  */
static DRM_NO_INLINE DRM_VOID DRM_CALL affine_insert_bucket
        (const digit_t     *EC_point,
         const DRM_LONG    jbucket,
         ecexpon_data_t  *pecxdat,
         const DRM_INT        negate_flag,
         struct bigctx_t *f_pBigCtx)
{
    const ecurve_t *ecurve = pecxdat->ecurve;
    digit_t *bucket_point = pecxdat->bucket[jbucket].contents;
    DRM_DWORD recursion_level;    
    DRM_BOOL OK;   

#if BIGNUM_EXPENSIVE_DEBUGGING
    DRM_DWORD elng    = ecurve->fdesc->elng;
    digit_t  *ectemps = pecxdat->p5temps + ECPROJ5_TEMPS_COUNT*elng;

    pecxdat->OK = pecxdat->OK && ecaffine_on_curve(EC_point, ecurve,
                                 "affine_insert_bucket input",
                                 ectemps, f_pBigCtx);
#endif

    OK = pecxdat->OK;
    if (OK) {
        recursion_level = pecxdat->aib_recursion_level;
        pecxdat->aib_recursion_level++;
        if (recursion_level != 0 && recursion_level != 1) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                            "affine_insert_bucket recursion");
            TRACE( ( "affine_insert_bucket, recursion_level = %ld\n",
                   ( DRM_LONG )recursion_level ) );
        } else if (ecaffine_is_infinite(EC_point, ecurve, f_pBigCtx)) {
                      // do nothing
        } else if (ecaffine_is_infinite(bucket_point, ecurve, f_pBigCtx)) {
                      // Vacant destination bucket
            OK = OK && ecaffine_multiply_pm1(EC_point, bucket_point,
                                             negate_flag, ecurve, f_pBigCtx);
        } else {
            digit_t *p1 = pecxdat->aib_temps[recursion_level];
            MEMCPY( p1,bucket_point,( 2*  ecurve->fdesc->elng)*SIZEOF( digit_t ));
            OK = OK && ecaffine_set_infinite(bucket_point,
                                             ecurve, f_pBigCtx);
            schedule_affine_add_or_sub(p1, EC_point,
                                   jbucket, pecxdat, negate_flag, f_pBigCtx);
        }
        pecxdat->OK = pecxdat->OK && OK;
        pecxdat->aib_recursion_level--;
    } // if OK
} // end affine_insert_bucket
// ---------------------------------------------------------------------
static DRM_NO_INLINE DRM_VOID DRM_CALL ec_concurrent_operations(
    ecexpon_data_t  *pecxdat, 
    struct bigctx_t *f_pBigCtx )
{
    const ecurve_t     *ecurve  = pecxdat->ecurve;
    const field_desc_t *fdesc   = ecurve->fdesc;
    const DRM_DWORD      elng    = fdesc->elng;
    const DRM_BOOL     char2   = pecxdat->char2;  // Characteristic 2?
    const DRM_DWORD num_slot_old = pecxdat->slots_in_use;
    digit_t *ectemps = pecxdat->p5temps + ECPROJ5_TEMPS_COUNT*elng;
    digit_t *ftemps = ectemps;

    DRM_DWORD inversion_count, jslot;

    if (!pecxdat->OK) return;
    inversion_count = 0;

    for (jslot = 0; jslot != num_slot_old; jslot++) {
        DRM_DWORD denom_index = inversion_count;
        digit_t* den = pecxdat->denoms + denom_index*elng;
        concurrent_op_t operation
                        = pecxdat->pending_op[jslot].operation;
        const digit_t *x1 = pecxdat->pending_op[jslot].inputs;
        const digit_t *y1 = x1 + elng;
        const digit_t *x2 = y1 + elng;
        const digit_t *y2 = x2 + elng;
        const digit_t *z1 = x2;       // Affinization input

        DRM_BOOL OK = pecxdat->OK;

        switch (operation) {
        case ECOP_ADD:
            OK = OK && Ksub(x1, x2, den, fdesc, f_pBigCtx);
            if (Kiszero(den, fdesc, f_pBigCtx)) {
                if (Kequal(y1, y2, fdesc, f_pBigCtx)) {
                    operation = ECOP_DOUBLING;
                    if (char2) {
                        MEMCPY( den,x1, fdesc->elng*SIZEOF( digit_t ));
                    } else {
                        OK = OK && Kadd(y1, y1, den, fdesc, f_pBigCtx);
                    }
                } else {
                    // Points are negatives -- Keep den = 0
                }
            }
            break;
        case ECOP_AFFINIZATION:
            MEMCPY( den,z1, fdesc->elng*SIZEOF( digit_t ));
            break;
        case ECOP_DO_NOTHING:
        case ECOP_DOUBLING:
        default:
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                            "ec_concurrent_operations");
            TRACE( ( "ec_concurrent_operations -- bad operation = %ld\n", 
                   ( DRM_LONG )operation ) );
            break;
        }
              // A denominator of 0 means the result is
              // the point at infinity, which need not be
              // put in the destination bucket.

              // Sometimes we compute P1 + P2 and P1 + (-P2)
              // back-to-back, where P1 and P2 are points on
              // our elliptic curve.  Both computations require
              // us to invert x(P1) - x(P2).  Test for a duplicate
              // denominator to avoid doing this twice.

        if (Kiszero(den, fdesc, f_pBigCtx)) {
            operation = ECOP_DO_NOTHING;
            denom_index = 0;
        } else if (   denom_index != 0
                   && Kequal(den - elng, den, fdesc, f_pBigCtx)) {
            denom_index--;  // Duplicate denominator
        } else {
            inversion_count++;  /* inversion_count = denom_index + 1 */
        }
        pecxdat->OK = pecxdat->OK && OK;
        pecxdat->pending_op[jslot].denom_index = denom_index;
        pecxdat->pending_op[jslot].operation = operation;
    } // for jslot



         // Invert denominators.

    pecxdat->OK = pecxdat->OK && Kinvert_many(pecxdat->denoms,
                                              pecxdat->denom_inverses,
                                              inversion_count, fdesc,
                                              ftemps, f_pBigCtx);

          // Finish the requested operations

    pecxdat->slots_in_use = 0;

    for (jslot = 0;
         jslot != num_slot_old && pecxdat->OK;
         jslot++) {
        const concurrent_op_t operation
                  = pecxdat->pending_op[jslot].operation;
        const DRM_DWORD denom_index
                  = pecxdat->pending_op[jslot].denom_index;
        const DRM_LONG ibucket
                  = pecxdat->pending_op[jslot].output_bucket;
        DRM_INT negate_flag = pecxdat->pending_op[jslot].negate_flag;
        const digit_t *inverse = pecxdat->denom_inverses + denom_index*elng;
        const digit_t *x1 = pecxdat->pending_op[jslot].inputs;
        const digit_t *y1 = x1 + elng;
        const digit_t *x2 = y1 + elng;
        const digit_t *y2 = x2 + elng;
//        const digit_t *z1 = x2;       // Affinization input

        digit_t *new_point = pecxdat->concurrent_ops_temps;     // Length 2*elng
        digit_t *ftemp1 = pecxdat->concurrent_ops_temps + 2*elng; // Length elng
        digit_t *ftemp2 = pecxdat->concurrent_ops_temps + 3*elng; // Length elng
        DRM_BOOL OK = pecxdat->OK;

           // The calls to affine_insert_bucket below may
           // cause table slots to be used.
           // However, each such call needs at most one slot.
           // New requests are stored at the start of the array.

        if (OK && jslot < pecxdat->slots_in_use) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                            "ec_concurrent_operations slot");
            TRACE( ( "ec_concurrent_operations -- slots re-allocated too fast.\n" ) );
        }
        switch(operation) {
        case ECOP_DO_NOTHING:
            break;
        case ECOP_AFFINIZATION:
                   // Multiply x by inverse^2 and y by inverse^3

            OK = OK && Kmul(inverse, inverse, ftemp1, fdesc,
                            ftemps, f_pBigCtx);
                                                // inverse^2
            OK = OK && Kmul(x1, ftemp1, new_point, fdesc,
                            ftemps, f_pBigCtx);
            OK = OK && Kmul(inverse, ftemp1, ftemp1, fdesc,
                            ftemps, f_pBigCtx);
                                                // inverse^3
            OK = OK && Kmul(y1, ftemp1, new_point + elng, fdesc,
                            ftemps, f_pBigCtx);
            break;
        case ECOP_ADD:
        case ECOP_DOUBLING:
            if (operation == ECOP_ADD) {  // m = (y1 - y2)/(x1 - x2)
                OK = OK && Ksub(y1, y2, ftemp1, fdesc, f_pBigCtx);
                OK = OK && Kmul(inverse, ftemp1, ftemp1, fdesc,
                                ftemps, f_pBigCtx);
            } else if (char2) {          // m = x1 + y1/x1
                OK = OK && Kmul(y1, inverse, ftemp1, fdesc,
                                ftemps, f_pBigCtx);
                OK = OK && Kadd(x1, ftemp1, ftemp1, fdesc, f_pBigCtx);
            } else {          // m = (3*x1^2 + a)/(2*y1)
                OK = OK && Kmul(x1, x1, ftemp1, fdesc,
                                ftemps, f_pBigCtx);
                OK = OK && Kadd(ftemp1, ftemp1, ftemp2, fdesc, f_pBigCtx);
                OK = OK && Kadd(ftemp1, ftemp2, ftemp1, fdesc, f_pBigCtx);
                OK = OK && Kadd(ftemp1, ecurve->a, ftemp1,
                                                   fdesc, f_pBigCtx);
                OK = OK && Kmul(ftemp1, inverse, ftemp1,
                                fdesc, ftemps, f_pBigCtx);
            }
                  // Now ftemp1 = m (slope)

            OK = OK && Kmul(ftemp1, ftemp1, ftemp2, fdesc,
                            ftemps, f_pBigCtx);  // m^2

            if (char2) {          // xnew = m^2 + m - a - x1 - x2
                OK = OK && Kadd(ftemp1, ftemp2, ftemp2, fdesc, f_pBigCtx);
                OK = OK && Ksub(ftemp2, ecurve->a, ftemp2, fdesc, f_pBigCtx);
                OK = OK && Ksub(ftemp2, x1, ftemp2, fdesc, f_pBigCtx);
                OK = OK && Ksub(ftemp2, x2, new_point, fdesc, f_pBigCtx);
                     // TBD -- Write one EOR loop
            } else {              // xnew = m^2 - x1 - x2
                OK = OK && Ksub(ftemp2, x1, ftemp2, fdesc, f_pBigCtx);
                OK = OK && Ksub(ftemp2, x2, new_point, fdesc, f_pBigCtx);
            }
                            // ynew = y1 + m*(xnew - x1)
                            // (xnew, ynew) is the negative sum
                            // Therefore we alter negate_flag.

            OK = OK && Ksub(new_point, x1, ftemp2, fdesc, f_pBigCtx);
            OK = OK && Kmul(ftemp1, ftemp2, ftemp2,
                            fdesc, ftemps, f_pBigCtx);
            OK = OK && Kadd(y1, ftemp2, new_point + elng,
                            fdesc, f_pBigCtx);
            negate_flag = -negate_flag;
            break;
        default:
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                            "ec_concurrent_operations 2nd loop");
            TRACE( ( "ec_concurrent_operations -- bad operation = %ld in second loop\n",
                   ( DRM_LONG )operation ) );
            break;

        } // end switch
        if (!OK) {
        } else if (ibucket <= 0 || ibucket > pecxdat->bucket_max) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                            "ec_concurrent_operations -- ibucket");
            TRACE( ( "ec_concurrent_operations -- bad ibucket = %ld\n", 
                   ( DRM_LONG )ibucket ) );
        } else if (pecxdat->bucket[ibucket].anticipating <= 0) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                            "ec_concurrent_operations, anticipating <= 0");
            TRACE( ( "ec_concurrent_operations -- anticipating = %ld not positive\n",
                   ( DRM_LONG )pecxdat->bucket[ibucket].anticipating ) );
        } else {
            pecxdat->bucket[ibucket].anticipating--;
        }
        if (OK && operation != ECOP_DO_NOTHING) {
#if BIGNUM_EXPENSIVE_DEBUGGING
            OK = OK && ecaffine_on_curve(new_point, ecurve,
                      "ec_concurrent operations new point",
                       ectemps, f_pBigCtx);
            if (!OK) {
                TRACE( ( "New point not on curve, operation = %ld, char2 = %ld\n",
                       ( DRM_LONG )operation, ( DRM_LONG )char2 ) );
            }
#endif
            affine_insert_bucket(new_point, ibucket,
                                 pecxdat, negate_flag, f_pBigCtx);
        }
        pecxdat->OK = pecxdat->OK && OK;
    } // for jslot
} // end ec_concurrent_operations
/* --------------------------------------------------------- */
static DRM_NO_INLINE DRM_DWORD DRM_CALL get_ec_concurrent_slot
       (ecexpon_data_t *pecxdat,
       struct bigctx_t *f_pBigCtx)
{
    while (pecxdat->OK && pecxdat->slots_in_use == MAX_SLOT) {
        ec_concurrent_operations(pecxdat, f_pBigCtx);
    }
    if (pecxdat->OK) {
        const DRM_DWORD islot = pecxdat->slots_in_use;
        pecxdat->slots_in_use++;
        return islot;
    } else {
        return 0;
    }
} // end get_ec_concurrent_slot
// --------------------------------------------------------------------
static DRM_NO_INLINE DRM_VOID DRM_CALL proj5_insert_bucket
        (const digit_t      *EC_point,
         const DRM_LONG    ibucket,
         ecexpon_data_t  *pecxdat,
         const DRM_INT        negate_flag,
         struct bigctx_t *f_pBigCtx)
/*
    Insert the projective point EC_point into
    bucket jbucket, possibly negating it.
*/
{
    const ecurve_t     *ecurve = pecxdat->ecurve;
    const field_desc_t *fdesc  = ecurve->fdesc;
    const DRM_DWORD      elng   = fdesc->elng;
    const digit_t      *pz     = EC_point + 2*elng;

    if (!pecxdat->OK) {
        // Return if earlier error
    } else if (Kiszero(pz, fdesc, f_pBigCtx)) {
                                       // Check for point at infinity
    } else if (ibucket == BUCKET_ZERO) {
                                       // Skip bucket zero
    } else if (Kequal(pz, fdesc->one, fdesc, f_pBigCtx)) {
        affine_insert_bucket(EC_point, ibucket, pecxdat,
                             negate_flag, f_pBigCtx);
                          // N.B. -- x and y occur first in EC_point,
                          // so we can treat it as affine if z == 1.
    } else {
        const DRM_DWORD islot = get_ec_concurrent_slot(pecxdat, f_pBigCtx);

        pecxdat->pending_op[islot].operation = ECOP_AFFINIZATION;
        pecxdat->pending_op[islot].output_bucket = ibucket;
        pecxdat->pending_op[islot].negate_flag = negate_flag;
        pecxdat->bucket[ibucket].anticipating++;
        MEMCPY( pecxdat->pending_op[islot].inputs,EC_point,( 3* fdesc->elng)*SIZEOF( digit_t ));
                              // Copy x, y, z
    }
} // end proj5_insert_bucket
// ----------------------------------------------------------------------
static DRM_NO_INLINE DRM_BOOL DRM_CALL ecaffine_to_ecproj5
        (const digit_t      *p1,
         digit_t        *p2,
         const ecurve_t        *ecurve,
         digit_t *   p5temps,
         struct bigctx_t *f_pBigCtx)
// Convert p1 from affine to projective form, result in p2.
{
    const field_desc_t *fdesc  = ecurve->fdesc;
    const DRM_DWORD      elng   = fdesc->elng;
    DRM_BOOL OK = TRUE;

    if (ecaffine_is_infinite(p1, ecurve, f_pBigCtx)) {
        OK = OK && ecproj5_set_infinite(p2, ecurve, p5temps);
    } else {
        MEMCPY( p2,p1,( 2* fdesc->elng)*SIZEOF( digit_t ));
        MEMCPY( p2 + 2*elng,fdesc->one, fdesc->elng*SIZEOF( digit_t ));
        OK = OK && Kclear_many(p2 + 3*elng, 2, fdesc, f_pBigCtx);
    }
    return OK;
} // end ecaffine_to_ecproj5
// ----------------------------------------------------------------------
static DRM_BOOL DRM_CALL ecproj5_add_ecaffine
        (const digit_t      *p1,
         const digit_t     *p2,
         digit_t       *psum,
         const ecurve_t       *ecurve,
         digit_t *  p5temps,
         struct bigctx_t *f_pBigCtx)
// Add p1 + p2, where p1 is projective and p2 is affine.
// Result (psum) is projective.
{
    const DRM_DWORD elng  = ecurve->fdesc->elng;
    DRM_BOOL OK = TRUE;
// CAUTION -- temp_point must not overlap storage in
//            procedures called by this function.
    digit_t *temp_point = p5temps + 5*elng;
#if ECPROJ5_TEMPS_COUNT < 10
#error "ecproj5_add_ecaffine -- Temps array too short"
#endif

    OK = OK && ecaffine_to_ecproj5(p2, temp_point, ecurve,
                                   p5temps, f_pBigCtx)
            && ecproj5_add_ecproj5(p1, temp_point, psum, ecurve,
                                   p5temps, f_pBigCtx);
    return OK;
} // end ecproj5_add_ecaffine
//-----------------------------------------------------------------------

static DRM_NO_INLINE DRM_BOOL DRM_CALL ecproj5_add_ecproj5
        (const digit_t      *p1,
         const digit_t      *p2,
         digit_t       *psum,
         const ecurve_t       *ecurve,
         digit_t *  p5temps,
         struct bigctx_t *f_pBigCtx)
//  Add p1 + p2 where both are projective.  Sum goes into psum.
//  psum may overlap p1 or p2
{
    const field_desc_t *fdesc = ecurve->fdesc;
    const DRM_DWORD       elng  = fdesc->elng;
    const digit_t *p1x = p1;
    const digit_t *p1y = p1 +   elng;
    const digit_t *p1z = p1 + 2*elng;
    const digit_t *p2x = p2;
    const digit_t *p2y = p2 +   elng;
    const digit_t *p2z = p2 + 2*elng;
    const DRM_BOOL char2 = CHARACTERISTIC_2(fdesc);

    DRM_BOOL OK = TRUE;
    digit_t  *p3x = psum;
    digit_t  *p3y = psum + elng;
    digit_t  *p3z = psum + 2*elng;
    digit_t  *ftemps = p5temps + elng*ECPROJ5_TEMPS_COUNT;

    if (Kiszero(p1z, fdesc, f_pBigCtx)) {
        MEMCPY( psum,p2,5* ecurve->fdesc->elng*SIZEOF( digit_t ));
    } else if (Kiszero(p2z, fdesc, f_pBigCtx)) {
        MEMCPY( psum,p1,5* ecurve->fdesc->elng*SIZEOF( digit_t ));
    } else {
        const DRM_BOOL p1affine = Kequal(p1z, fdesc->one, fdesc, f_pBigCtx);
        const DRM_BOOL p2affine = Kequal(p2z, fdesc->one, fdesc, f_pBigCtx);

        digit_t *T0 = p5temps;
        digit_t *U1 = p5temps + elng;
        digit_t *U2 = p5temps + 2*elng;
        digit_t *S1 = p5temps + 3*elng;
        digit_t *S2 = p5temps + 4*elng;
    // CAUTION -- ecproj5_add_ecaffine assumes nothing
    // beyond here is modified until x, y inputs have been read.
        digit_t *W  = p5temps + 5*elng;
        digit_t *R  = p5temps + 6*elng;

        if (p1affine) {
            MEMCPY( U2,p2x, fdesc->elng*SIZEOF( digit_t ));
            MEMCPY( S2,p2y, fdesc->elng*SIZEOF( digit_t ));
        } else {
            OK = OK && Kmul(p1z, p1z, T0, fdesc,
                            ftemps, f_pBigCtx)  // z1^2
                    && Kmul(p2x, T0, U2, fdesc,
                            ftemps, f_pBigCtx)   // U2 = x2 * z1^2
                    && Kmul(p1z, T0, T0, fdesc,
                            ftemps, f_pBigCtx)   // z1^3
                    && Kmul(p2y, T0, S2, fdesc,
                            ftemps, f_pBigCtx);  // S2 = y2 * z1^3
        }
        if (p2affine) {
            MEMCPY( U1,p1x, fdesc->elng*SIZEOF( digit_t ));
            MEMCPY( S1,p1y, fdesc->elng*SIZEOF( digit_t ));
        } else {
            OK = OK && Kmul(p2z, p2z, T0, fdesc,
                            ftemps, f_pBigCtx)   // z2^2
                    && Kmul(p1x, T0, U1, fdesc,
                            ftemps, f_pBigCtx)    // U1 = x1 * z2^2
                    && Kmul(p2z, T0, T0, fdesc,
                            ftemps, f_pBigCtx)    // z2^3
                    && Kmul(p1y, T0, S1, fdesc,
                            ftemps, f_pBigCtx);   // S1 = t1 * z2^2
        }
        if (Kequal(U1, U2, fdesc, f_pBigCtx)) {
            if (Kequal(S1, S2, fdesc, f_pBigCtx)) {
                OK = OK && ecproj5_doubling(p2, psum, ecurve,
                                            p5temps, f_pBigCtx);
            } else {
                OK = OK && ecproj5_set_infinite(psum, ecurve,
                                                p5temps);
            }
        } else {
            OK = OK && Ksub(U1, U2, W, fdesc, f_pBigCtx)
                    && Ksub(S1, S2, R, fdesc, f_pBigCtx);

            if (p1affine) {
                MEMCPY( T0,W, fdesc->elng*SIZEOF( digit_t ));
            } else {
                OK = OK && Kmul(W, p1z, T0, fdesc, ftemps, f_pBigCtx);
            }
            if (p2affine) {
                MEMCPY( p3z,T0, fdesc->elng*SIZEOF( digit_t ));
            } else {
                OK = OK && Kmul(T0, p2z, p3z, fdesc, ftemps, f_pBigCtx);
            }                              // z3 = W * z1 * z2 (nonzero)

            OK = OK && Kmul(W, W, T0, fdesc, ftemps, f_pBigCtx)
                && Kmul(U1, T0, U1, fdesc,
                        ftemps, f_pBigCtx)    // T1 = U1 * W^2
                    && Kmul(U2, T0, U2, fdesc,
                        ftemps, f_pBigCtx);   // T2 = U2 * W^2
            OK = OK && Kadd(U1, U2, T0, fdesc,
                        f_pBigCtx);   // T1 + T2 */

            if (char2) {
                OK = OK && Kmul(S2, U1, U1, fdesc,
                                ftemps, f_pBigCtx)     // S2 * T1
                        && Kmul(S1, U2, U2, fdesc,
                                ftemps, f_pBigCtx)     // S1 * T2
                        && Ksub(U2, U1, U2,
                                fdesc, f_pBigCtx)          // S1*T2 - S2*T1
                        && Kmul(p3z, p3z, p3x, fdesc,
                                ftemps, f_pBigCtx)  // z3^2
                        && Kmul(ecurve->a, p3x, p3x, fdesc,
                                ftemps, f_pBigCtx) // a*z3^2
                        && Kadd(p3x, T0, p3x, fdesc,
                                f_pBigCtx)  // a*z3^2 + T1 + T2
                        && Kadd(R, p3z, T0, fdesc,
                                f_pBigCtx)    // T3 = R + z3
                        && Kmul(T0, R, R, fdesc, ftemps,
                                f_pBigCtx)      // R*(R + z3)
                        && Ksub(R, p3x, p3x, fdesc,
                                f_pBigCtx)   // New x3
                        && Kmul(T0, p3x, T0, fdesc, ftemps,
                                f_pBigCtx)   // T3*x3
                        && Ksub(U2, T0, p3y, fdesc,
                                f_pBigCtx);  // New y3
            } else {
                OK = OK && Kmul(R, R, p3x, fdesc,
                                ftemps, f_pBigCtx)
                        && Ksub(p3x, T0, p3x, fdesc,
                                f_pBigCtx)          // x3 = R^2 - T1 - T2
                        && Ksub(U2, U1, U2, fdesc,
                                f_pBigCtx)            // T2 - T1
                        && Kmul(S1, U2, U2, fdesc,
                                ftemps, f_pBigCtx)    // S1*(T2 - t1)
                        && Ksub(p3x, U1, T0, fdesc,
                                f_pBigCtx)           // x3 - T1
                        && Kmul(T0, R, T0, fdesc,
                                ftemps, f_pBigCtx)     // R*(x3 - T1)
                        && Ksub(U2, T0, p3y, fdesc,
                                f_pBigCtx);          // New y3
            } // end if characteristic
        } // end if doubling or infinite sum
    } // end if input point infinite
    return OK;
} // end ecproj5_add_ecproj5
// ----------------------------------------------------------------------
static DRM_NO_INLINE DRM_BOOL DRM_CALL ecproj5_doubling
        (const digit_t       *p1,
         digit_t        *p2,
         const ecurve_t        *ecurve,
         digit_t *   p5temps,
         struct bigctx_t *f_pBigCtx)
// Double a projective point on an elliptic curve.
// Return p2 = 2*p1.  p1 and p2 may overlap
{
    const field_desc_t *fdesc = ecurve->fdesc;
    const DRM_DWORD      elng  = fdesc->elng;
    DRM_BOOL OK = TRUE;
    const digit_t *p1x = p1;
    const digit_t *p1y = p1 +   elng;
    const digit_t *p1z = p1 + 2*elng;
    digit_t  *p2x = p2;
    digit_t  *p2y = p2 +   elng;
    digit_t  *p2z = p2 + 2*elng;
    digit_t  *ftemps = p5temps + ECPROJ5_TEMPS_COUNT*elng;

    if (!OK) {
    } else if (Kiszero(p1z, fdesc, f_pBigCtx)) {
        OK = OK && ecproj5_set_infinite(p2, ecurve,
                                        p5temps);
    } else if (CHARACTERISTIC_2(fdesc)) {
        digit_t *xsq   = p5temps;
        digit_t *zsq   = p5temps + elng;
        digit_t *bz8   = p5temps + 2*elng;
        digit_t *temp1 = p5temps + 3*elng;

        OK = OK && Kmul(p1x, p1x, xsq, fdesc,
                        ftemps, f_pBigCtx)
                && Kmul(p1z, p1z, zsq, fdesc,
                        ftemps, f_pBigCtx)
                && Kmul(zsq, zsq, bz8, fdesc,
                        ftemps, f_pBigCtx)        // Z^4
                && Kmul(bz8, bz8, bz8, fdesc,
                        ftemps, f_pBigCtx)        // Z^8
                && Kmul(ecurve->b, bz8, bz8, fdesc,
                        ftemps, f_pBigCtx)  // b * Z^8
                && Kmul(p1y, p1z, temp1, fdesc,
                        ftemps, f_pBigCtx)
                && Kadd(xsq, temp1, temp1, fdesc,
                        f_pBigCtx)            // X^2 + Y*Z
                && Kmul(p1x, zsq, p2z, fdesc, ftemps,
                        f_pBigCtx)        // Z2 = X * Z^2
                && Kmul(xsq, xsq, xsq, fdesc, ftemps,
                        f_pBigCtx)        // X^4
                && Kadd(xsq, bz8, p2x, fdesc,
                        f_pBigCtx)                // X2 = X^4 + bZ^8
                && Kmul(bz8, p2z, bz8, fdesc, ftemps,
                        f_pBigCtx)        // (b Z^8) * Z2
                && Kmul(temp1, p2x, temp1, fdesc, ftemps,
                        f_pBigCtx)    // (X^2 + Y*Z)*X2
                && Kadd(bz8, temp1, p2y, fdesc,
                        f_pBigCtx);             // Y2
    } else {
        // TBD -- check fourth and fifth components of vector
        digit_t *xsq  = p5temps;
        digit_t *S    = p5temps + elng;
        digit_t *az4  = p5temps + 2*elng;
        digit_t *M    = p5temps + 3*elng;
        digit_t *y4th = p5temps + 4*elng;

        OK = OK && Kmul(p1x, p1x, xsq, fdesc,
                        ftemps, f_pBigCtx)     //
                && Kadd(xsq, xsq, M, fdesc,
                        f_pBigCtx)
                && Kadd(xsq, M, M, fdesc,
                        f_pBigCtx)                 // 3 * X^2
                && Kmul(p1z, p1z, az4, fdesc,
                        ftemps, f_pBigCtx)     // Z^2
                && Kmul(az4, az4, az4, fdesc,
                        ftemps, f_pBigCtx)     // Z^4
                && Kmul(ecurve->a, az4, az4, fdesc,
                        ftemps, f_pBigCtx)  // a*Z^4
                && Kadd(M, az4, M, fdesc,
                        f_pBigCtx)                 // M = 3 X^2 + a Z^4
                && Kadd(p1y, p1y, y4th, fdesc,
                        f_pBigCtx)            // 2*Y
                && Kmul(y4th, p1z, p2z, fdesc,
                        ftemps, f_pBigCtx)    // Z2 = (2*Y)*Z
                && Kmul(y4th, y4th, y4th, fdesc,
                        ftemps, f_pBigCtx)  // 4 * Y^2
                && Kmul(p1x, y4th, S, fdesc,
                        ftemps, f_pBigCtx)      // S = 4 * X * Y^2
                && Kmul(y4th, y4th, y4th, fdesc,
                        ftemps, f_pBigCtx)  // 16*Y^4
                && Kmul(M, M, p2x, fdesc,
                        ftemps, f_pBigCtx)
                && Ksub(p2x, S, p2x, fdesc,
                        f_pBigCtx)
                && Ksub(p2x, S, p2x, fdesc,
                        f_pBigCtx)               // X2 = M^2 - 2*S
                && Ksub(S, p2x, S, fdesc,
                        f_pBigCtx)
                && Kmul(M, S, p2y, fdesc,
                        ftemps, f_pBigCtx)         // M*(S - X2)
                && Kmulpower2(y4th, -1, y4th, fdesc,
                       f_pBigCtx)      // 8*Y^4
                && Ksub(p2y, y4th, p2y, fdesc,
                        f_pBigCtx);       // Y2 = M*(S - X2) - 8 Y^4
    }
    return OK;
} // end ecproj5_doubling
// ----------------------------------------------------------------------
static DRM_BOOL DRM_CALL ecproj5_on_curve
        (const digit_t      *p1,
         const ecurve_t       *ecurve,
         const DRM_CHAR      *pdebug_info,
         digit_t *  p5temps,
         struct bigctx_t *f_pBigCtx)
// Test whether a projective point is on the curve.
//
//       GF(2^m) -- Is Y^2 + XYZ == X^3 + a X^2 Z^2 + b Z^6 ?
//
//
//       GF(q) --   Is Y^2       == X^3 + a X Z^4   + b Z^6 ?



{
    const field_desc_t *fdesc = ecurve->fdesc;
    const DRM_DWORD      elng  = fdesc->elng;
    DRM_BOOL OK = TRUE;
    const DRM_BOOL char2 = CHARACTERISTIC_2(fdesc);
    const digit_t *p1x = p1;
    const digit_t *p1y = p1 +   elng;
    const digit_t *p1z = p1 + 2*elng;
// Avoid using over five temporaries.
// to prevent conflict with ecproj5_add_ecaffine.
    digit_t *temp1 = p5temps;
    digit_t *zsq   = p5temps + elng;
    digit_t *xsq   = p5temps + 2*elng;
    digit_t *ysq   = p5temps + 3*elng;
    digit_t *z4th  = p5temps + 4*elng;
    digit_t *ftemps = p5temps + ECPROJ5_TEMPS_COUNT*elng;

    if (    Kiszero(p1x, fdesc, f_pBigCtx)
         && Kiszero(p1y, fdesc, f_pBigCtx)
         && Kiszero(p1z, fdesc, f_pBigCtx)) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_ZERO_OPERAND,
                        "ecproj5_on_curve");
    }
    OK = OK && Kmul(p1x, p1x, xsq, fdesc,
                    ftemps, f_pBigCtx)          // X^2
            && Kmul(p1y, p1y, ysq, fdesc,
                    ftemps, f_pBigCtx)
            && Kmul(p1z, p1z, zsq, fdesc,
                    ftemps, f_pBigCtx)
            && Kmul(zsq, zsq, z4th, fdesc,
                    ftemps, f_pBigCtx)         // Z^4
            && Kmul(p1x, xsq, temp1, fdesc,
                    ftemps, f_pBigCtx)
            && Ksub(ysq, temp1, ysq, fdesc,
                    f_pBigCtx)                // Y^2 - X^3
            && Kmul(ecurve->b, zsq, zsq, fdesc,
                    ftemps, f_pBigCtx);   // b*Z^2

    if (char2) {
        OK = OK && Kmul(zsq, z4th, temp1, fdesc,
                        ftemps, f_pBigCtx)   // b*Z^6
                && Ksub(ysq, temp1, ysq, fdesc,
                        f_pBigCtx)            // Y^2 - X^3 - bZ^6
                && Kmul(p1x, p1z, temp1, fdesc,
                        ftemps, f_pBigCtx)    // X*Z
                && Kmul(ecurve->a, temp1, zsq, fdesc,
                        ftemps, f_pBigCtx)
                && Ksub(zsq, p1y, zsq, fdesc,
                        f_pBigCtx)              // a*X*Z - Y
                && Kmul(temp1, zsq, temp1, fdesc,
                        ftemps, f_pBigCtx); // X*Z*(a*X*Z - Y)
    } else {
        OK = OK && Kmul(ecurve->a, p1x, temp1, fdesc,
                        ftemps, f_pBigCtx)
                && Kadd(temp1, zsq, temp1, fdesc,
                        f_pBigCtx)           // a*X + b*Z^2
                && Kmul(temp1, z4th, temp1, fdesc,
                        ftemps, f_pBigCtx); // (a*X + b*Z^2)*Z^4
    }
    if (OK) {
        const DRM_BOOL on_curve = Kequal(ysq, temp1, fdesc, f_pBigCtx);
        if (!on_curve) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_NOT_ON_CURVE,
                            pdebug_info);
        }
    }
    return OK;
} // end ecproj5_on_curve
// --------------------------------------------------------------------
static DRM_NO_INLINE DRM_BOOL DRM_CALL ecproj5_set_infinite
        (digit_t       *p1,
         const ecurve_t       *ecurve,
         digit_t *  p5temps)
{
    DRM_BOOL OK = TRUE;
    const field_desc_t *fdesc = ecurve->fdesc;
    const DRM_DWORD elng = fdesc->elng;

    MEMCPY( p1,fdesc->one, fdesc->elng*SIZEOF( digit_t ));
    MEMCPY( p1 + elng,fdesc->one, fdesc->elng*SIZEOF( digit_t ));
    Kclear_many(p1 + 2*elng, 3, fdesc, NULL);
    return OK;
} // end ecproj5_set_infinite
// ---------------------------------------------------------------------
static DRM_NO_INLINE DRM_BOOL DRM_CALL ecproj5_to_ecaffine
        (const digit_t       *p1,
         digit_t       *p2,
         const ecurve_t        *ecurve,
         digit_t *   p5temps,
         struct bigctx_t *f_pBigCtx)
// Convert p1 from projective to affine form, result in p2.
// If p1 = (x, y, z, *, *), return (x/z^2, y/z^3)
{
    DRM_BOOL OK = TRUE;
    const field_desc_t *fdesc = ecurve->fdesc;
    const DRM_DWORD elng = fdesc->elng;
    const digit_t *p1z = p1 + 2*elng;
    digit_t *ftemps = p5temps + elng*ECPROJ5_TEMPS_COUNT;

    if (Kiszero(p1z, fdesc, f_pBigCtx)) {
        OK = OK && ecaffine_set_infinite(p2, ecurve, f_pBigCtx);
    } else {
        digit_t *z1inv = p5temps;
        digit_t *z1invsq = p5temps + elng;

        OK = OK && Kinvert(p1z, z1inv, fdesc,
                        ftemps, f_pBigCtx)
                && Kmul(z1inv, z1inv, z1invsq, fdesc,
                        ftemps, f_pBigCtx)
                && Kmul(p1, z1invsq, p2, fdesc,
                        ftemps, f_pBigCtx)       // x2 = X/Z^2
                && Kmul(z1inv, z1invsq, z1invsq, fdesc,
                        ftemps, f_pBigCtx)  // 1/Z^3
                && Kmul(p1 + elng, z1invsq, p2 + elng, fdesc,
                        ftemps, f_pBigCtx);      // y2 = Y/Z^3
    }
    return OK;
} // end ecproj5_to_ecaffine
/* ------------------------------------------------------------ */
static DRM_NO_INLINE DRM_VOID DRM_CALL schedule_affine_add_and_sub(
                      const digit_t     *point1,
                      const digit_t     *point2,
                      const DRM_LONG    out1,
                      const DRM_LONG    out2,
                      ecexpon_data_t  *pecxdat,
                      struct bigctx_t *f_pBigCtx)
/*
          Insert point1 + point2 in bucket out1
          and    point1 - point2 in bucket out2.

          We are replacing

                (out1 + out2)*point1 + (out1 - out2)*point2
          by
                out1*(point1 + point2) + out2*(point1 - point2)

          Buckets out1 +- out2 will acquire no more entries
          during this exponentiation.  We send the data elsewhere
          (i.e., to out1, out2) as we funnel everything into
          fewer buckets, until we do final processing.
*/
{
    const ecurve_t *ecurve = pecxdat->ecurve;
    if (!pecxdat->OK) {
    } else if (    out1 <= 0
                || out2 <= 0
                || out1 > pecxdat->bucket_max
                || out2 > pecxdat->bucket_max
                || pecxdat->bucket[out1].anticipating <= 0
                || pecxdat->bucket[out2].anticipating <= 0) {
        pecxdat->OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "schedule_affine_add_and_sub 1");
        TRACE( ( "schedule_affine_add_and_sub -- Bad output buckets = %ld %ld\n",
               ( DRM_LONG )out1, ( DRM_LONG )out2 ) );
    } else {
        pecxdat->bucket[out1].anticipating--;
                  // Cancel transfers to out1 and out2 scheduled
                  // when pending_addsubs table was created.
                  // They will be rescheduled below if still needed.
        pecxdat->bucket[out2].anticipating--;

        if (   !ecaffine_is_infinite(point1, ecurve, f_pBigCtx)
            && !ecaffine_is_infinite(point2, ecurve, f_pBigCtx) ) {
            if (pecxdat->slots_in_use > MAX_SLOT - 2) {
                ec_concurrent_operations(pecxdat, f_pBigCtx);
                   /* Try to schedule addition and subtraction
                      in adjacent slots, since both need
                      to invert x(point1) - x(point2).
                    */
            }
        }

        schedule_affine_add_or_sub(point1, point2, out1,
                                   pecxdat, +1, f_pBigCtx);
        schedule_affine_add_or_sub(point1, point2, out2,
                                   pecxdat, -1, f_pBigCtx);
    }
} // end schedule_affine_add_and_sub
/* ------------------------------------------------------------ */
static DRM_NO_INLINE DRM_VOID DRM_CALL schedule_affine_add_or_sub(
    const digit_t    *point1,
    const digit_t    *point2,
    const DRM_LONG    jbucket,
    ecexpon_data_t   *pecxdat,
    const DRM_INT     negate_second,
    struct bigctx_t  *f_pBigCtx)
//
//       If negate_second = +1, add affine points point1 and point2.
//       If negate_second = -1, subtract point1 - point2.
//       In either case send the result to bucket jbucket.
//

{
    const ecurve_t *ecurve = pecxdat->ecurve;
    const DRM_DWORD elng = ecurve->fdesc->elng;
    DRM_BOOL OK = pecxdat->OK;
    
    if (!OK) {
    } else if (jbucket < 0 || jbucket > pecxdat->bucket_max) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "schedule_affine_add_or_sub");
        TRACE( ( "schedule_affine_add_or_sub, jbucket = %ld\n",
               ( DRM_LONG )jbucket ) );
    }

    if (!OK) {
    }else if (ecaffine_is_infinite(point1, ecurve, f_pBigCtx)) {
        affine_insert_bucket(point2, jbucket, pecxdat,
                             negate_second, f_pBigCtx);
    } else if (ecaffine_is_infinite(point2, ecurve, f_pBigCtx)) {
        affine_insert_bucket(point1, jbucket, pecxdat,
                             +1, f_pBigCtx);
    } else {
        DRM_DWORD islot = get_ec_concurrent_slot(pecxdat, f_pBigCtx);
        digit_t *inputs = pecxdat->pending_op[islot].inputs;
        MEMCPY( inputs,point1,( 2*  ecurve->fdesc->elng)*SIZEOF( digit_t ));
        OK = OK && ecaffine_multiply_pm1(point2,
            inputs + 2*elng, negate_second, ecurve, f_pBigCtx);
        pecxdat->pending_op[islot].negate_flag = +1;
        pecxdat->pending_op[islot].operation = ECOP_ADD;
        pecxdat->pending_op[islot].output_bucket = jbucket;
        pecxdat->bucket[jbucket].anticipating++;
    }
    pecxdat->OK = pecxdat->OK && OK;
} // end schedule_affine_add_or_sub

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\drmxmlutilities.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include <drmcommon.h>
#include <drmxmlparser.h>
#include <drmutilities.h>
#include <drmxmlutilities.h>

ENTER_PK_NAMESPACE_CODE;

/******************************************************************************
** 
** Function :   DRM_XMU_MatchNodeFromTemplate
** 
** Synopsis :   Deep compare a XML node with a given template. It will be 
**              considered a match ONLY if all subnodes in the template exist 
**              AND exactly match the subnodes in the template. The node might 
**              be a superset of the template
** 
** Arguments :  f_pdstrXmlNodeList  -   List of XML nodes in which we have to 
**                                      find a match
**              f_pdstrXmlTemplate  -   Template for finding match
**              f_fAttributeMatch   -   Match the first attribute (if any) of 
**                                      each node
**              f_pfMatch           -   TRUE/FALSE indicating match or not
** Returns :    
** 
** Notes :      Example:
**              f_pdstrXmlTemplate  :                 
**                      <KID>xyz</KID>
**                      <META>
**                          <LGPUBKEY>abc</LGPUBKEY>
**                      </META>
**                  
**              f_pdstrXmlNodeList  :   No match (LGPUBKEY different)                  
**                      <KID>xyz</KID>
**                      <LID>pqr</LID>
**                      <META>
**                          <LGPUBKEY>sfsgdgddsg</LGPUBKEY>
**                      </META>
**
**              f_pdstrXmlNodeList  :   No match (KID missing)                  
**                      <META>
**                          <LGPUBKEY>abc</LGPUBKEY>
**                      </META>
**
**              f_pdstrXmlNodeList  :   Exact match 
**                      <KID>xyz</KID>
**                      <LID>pqr</LID>
**                      <META>
**                          <LGPUBKEY>abc</LGPUBKEY>
**                      </META>
** 
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XMU_MatchNodeFromTemplate(
    IN  const   DRM_CONST_STRING    *f_pdstrXmlNodeList,
    IN  const   DRM_CONST_STRING    *f_pdstrXmlTemplate,
    IN          DRM_BOOL            f_fAttributeMatch,
        OUT     DRM_BOOL            *f_pfMatch)
{
    DRM_RESULT                  dr                      =   DRM_SUCCESS;
    DRM_BOOL                    fIsLeafNode             =   FALSE;
    DRM_CONST_STRING            dstrNextTag             =   EMPTY_DRM_STRING;
    DRM_CONST_STRING            dstrNextNode            =   EMPTY_DRM_STRING;    
    DRM_CONST_STRING            dstrNextNodeData        =   EMPTY_DRM_STRING; 
    DRM_CONST_STRING            dstrMatchingNodeData    =   EMPTY_DRM_STRING;
    DRM_CONST_STRING            dstrXmlNodeList         =   EMPTY_DRM_STRING;
    DRM_CONST_STRING            dstrXmlTemplate         =   EMPTY_DRM_STRING;
    DRM_CONST_STRING            dstrFirstAttrName       =   EMPTY_DRM_STRING;    
    DRM_CONST_STRING            dstrFirstAttrValue      =   EMPTY_DRM_STRING;    
    DRM_CONST_STRING           *pdstrFirstAttrName      =   NULL;
    DRM_CONST_STRING           *pdstrFirstAttrValue     =   NULL;
    
    /*
    **  Check input
    */
    ChkArg(f_pfMatch);
    
    /*
    **  Clear output
    */
    *f_pfMatch = TRUE;

    if (f_fAttributeMatch)
    {
        pdstrFirstAttrName  = &dstrFirstAttrName;
        pdstrFirstAttrValue = &dstrFirstAttrValue;
    }
    
    ASSIGN_DRM_STRING(dstrXmlNodeList, *f_pdstrXmlNodeList);
    ASSIGN_DRM_STRING(dstrXmlTemplate, *f_pdstrXmlTemplate);      
    
    /*
    **  Enumerate all nodes in the template
    **  Loop will break if there is a mismatch
    */
    while(dstrXmlTemplate.cchString > 0)
    {
        INIT_DRM_STRING(dstrNextTag);
        
        /*
        **  Get next node from template
        */
        ChkDR(  DRM_XML_EnumNextNode(
                    &dstrXmlTemplate,
                    &dstrNextTag,
                    &dstrNextNode,
                    &dstrNextNodeData,
                    pdstrFirstAttrName,
                    pdstrFirstAttrValue,
                    &fIsLeafNode)   );
        
        /*
        **  Find matching node in xml tree
        */
        dr  =   DRM_XML_GetNode(
                    &dstrXmlNodeList, 
                    &dstrNextTag, 
                    pdstrFirstAttrName,
                    pdstrFirstAttrValue,
                    0,
                    NULL,
                    &dstrMatchingNodeData);

        if (dr == DRM_E_XMLNOTFOUND
         || dr == DRM_E_INVALIDARG)
        {
            /*
            **  Corresponding node not found in xml tree - Mismatch
            */
            dr = DRM_SUCCESS;
            *f_pfMatch = FALSE;
            break;            
        }
        ChkDR(dr);
        
        if (fIsLeafNode)
        {            
            if (!DRM_UTL_DSTRStringsEqual(
                    &dstrNextNodeData, 
                    &dstrMatchingNodeData) )            
            {
                *f_pfMatch = FALSE;
                break;
            }
        }
        else
        {
            /*
            **  We do not expect this recursion to go beyond a few levels.
            **  Hence using recursion to keep things simple.
            */
            ChkDR(  DRM_XMU_MatchNodeFromTemplate(
                        &dstrMatchingNodeData,
                        &dstrNextNodeData,
                        f_fAttributeMatch,
                        f_pfMatch)  );
            if (!(*f_pfMatch))
            {
                break;
            }                        
        }   
        
        /*
        **  Advance the template buffer
        */
        dstrXmlTemplate.pwszString  +=  dstrNextNode.cchString;
        dstrXmlTemplate.cchString   -=  dstrNextNode.cchString;        
       
    }   /*  End of while(TRUE) loop */
    
ErrorExit:
    return dr;
}
      


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\ecppq.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bignum.h"
#include "field.h"
#include "ecurve.h"

ENTER_PK_NAMESPACE_CODE;


/*
         File ecPPQ.c.    Version 19 September 2001


   Let P and Q be points on an elliptic curve

          y^2 + xy = x^3 + ax^2 + b        (characteristic 2)
or
          y^2 = x^3 + ax + b               (field GF(p), p odd)

using affine coordinates.  We want R = 2*P + Q (or 2P - Q)

    We optimize for the frequent case where P and Q are distinct and
neither of these nor any intermediate result is the point at infinity,
while designing the code to work properly in all cases.

    Computing P + (P + Q) rather than (2*P) + Q saves a squaring when using
GF(p) arithmetic, where a doubling is more expensive than an addition.
In summer, 2001, Microsoft Research intern Kirsten Eisentrager observed that
we can save another multiplication (both GF(p) and characteristic 2 cases)
by not explicitly computing y(P + Q).  See the `Think' lines below.



Algorithm for 2*P + Q

    if (P = infinity) then
        return Q;
    else if (Q = infinity)
        Use conventional algorithm for 2*P;
    else
        xP = x(P);  yP = y(P);
        xQ = x(Q);  yQ = y(Q);

        char2 = (TRUE if characteristic 2, else FALSE);
        yQplus = yQ;
        yQminus = (char2 ? xQ + yQ : -yQ);

        if (pm1 == -1) then       // 2*P - Q wanted
            exchange yQplus, yQminus
        }

        if (xP <> xQ) then
            m_1 = (yP - yQplus) / (xP - xQ);   // slope of line through P, Q
        else if (yP == yQminus) then
            return P;                    // P and Q are negatives, so 2P + Q = P
        else if (char2) then
            m_1 = xP + yP/xP;              // P = Q, tangent slope
        else
            m_1 = (3*xP^2 + a) / (2*yP);   // P = Q.  tangent slope
        end if;

        if (char2) then
            xPQ = m_1^2 + m_1 - a - xP - xQ;
                       // Think yPQ = xPQ + yP + m_1 * (xPQ - xP);
            if (xPQ = xP) then
                return infinity;    // P + Q and P cannot be same point,
                                    // must be negatives
            end if;
                       // Think m_2 = (yPQ - yP) / (xPQ - xP);
            m_2 + 1 = m_1 + xP / (xPQ - xP);
            xPPQ = m_2^2 + m_2 - a - xPQ - xP;
            yPPQ = xP + yP + (m_2 + 1) * (xPPQ - xP);
        else
            xPQ = m_1^2 - xP - xQ;
                       // Think yPQ = - [yP + m_1 * (xPQ - xP)];
            if (xPQ = xP) then
                return infinity;    // P + Q and P must be negatives
            end if;
                       // Think m_2 = (yPQ - yP) / (xPQ - xP);
            -m_2 = (2*yP) / (xPQ - xP) + m_1;
            xPPQ = m_2^2 - xPQ - xP;
            yPPQ = -[yP + m_2*(xPPQ - xP)];
        end if;
        return (xPPQ, yPPQ);
    end if;
*/

DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL ecaffine_PPQ(
    const digit_t  *P,
    const digit_t  *Q,
    digit_t   *PPQ,    // OUT
    const DRM_INT     pm1,     // +- 1
    const ecurve_t    *E,
    digit_t      *supplied_temps,
    struct bigctx_t *f_pBigCtx)
{
    /*
           Compute PPQ = 2*P + Q if pm1 = +1
                   PPQ = 2*P - Q if pm1 = -1
    */

    DRM_BOOL OK = TRUE;
    DRM_BOOL done = FALSE;
    const field_desc_t *fdesc = E->fdesc;
    const DRM_DWORD elng = fdesc->elng;
    const DRM_BOOL char2 = CHARACTERISTIC_2(fdesc);
                      /* Is field characteristic 2? */

    const digit_t *xP = P,     *yP = P + elng;        // IN
    const digit_t *xQ = Q,     *yQ = Q + elng;        // IN
    digit_t  *xPPQ = PPQ, *yPPQ = PPQ + elng;    // OUT

    digit_t *m1 = NULL, *m2 = NULL;
    digit_t *xtemp = NULL, *ytemp = NULL;
    digit_t *ftemps = NULL;
    DRM_DWORD j;

#if MAX_ECTEMPS < 4
    #error -- Increase MAX_ECTEMPS
#endif

    if (supplied_temps == NULL) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_NULL_POINTER, "ecaffine_PPQ");
    } else {
        m1 = supplied_temps;
        m2 = m1 + elng;
        xtemp = m2 + elng;
        ytemp = xtemp + elng;
        ftemps = ytemp + elng;
    }

    // Check whether either supplied point is infinite.

    if (ecaffine_is_infinite(P, E, f_pBigCtx)) {
                              // P = identity so 2*P +- Q = +-Q
        OK = OK && ecaffine_multiply_pm1(Q, PPQ, pm1, E, f_pBigCtx);
        done = TRUE;
    } else if (ecaffine_is_infinite(Q, E, f_pBigCtx)) {
                              // Q = identity so 2*P +- Q = 2*P = P + P
        OK = OK && ecaffine_addition(P, P, PPQ, +1, E,
                                     supplied_temps, f_pBigCtx);
        done = TRUE;
    } else {
        const digit_t *yQplus, *yQminus;
        OK = OK && Ksub(xP, xQ, xtemp, fdesc, f_pBigCtx);   // xP - xQ
        if (char2) {
            OK = OK && Kadd(yQ, xQ, m2, fdesc, f_pBigCtx);  // m2 = y(-Q)
        } else {
            OK = OK && Knegate(yQ, m2, fdesc, f_pBigCtx);   // m2 = y(-Q)
        }

        if (pm1 == +1) {           // 2*P + Q wanted
            yQplus = yQ;           // y(pm1*Q)
            yQminus = m2;          // y(-pm1*Q)
        } else if (pm1 == -1) {    // 2*P - Q wanted
            yQplus = m2;           // y(pm1*Q)
            yQminus = yQ;          // y(-pm1*Q)
        } else {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                            "ecaffine_PPQ pm1");
            yQplus = yQminus = NULL;
        }

        OK = OK && Ksub(xP, xQ, xtemp, fdesc,
                        f_pBigCtx);       // xtemp = xP - xQ

        if (!Kiszero(xtemp, fdesc, f_pBigCtx)) {
            OK = OK && Kinvert(xtemp, m1, fdesc, ftemps, f_pBigCtx);
            OK = OK && Ksub(yP, yQplus, ytemp, fdesc, f_pBigCtx);
                                                 // ytemp = y(P) - y(pm1*Q)
            OK = OK && Kmul(m1, ytemp, m1, fdesc, ftemps, f_pBigCtx);
                                                 // m1 = ytemp/xtemp
        } else if (Kequal(yP, yQminus, fdesc, f_pBigCtx)) {
                              // Same x, y(P) = y(-pm1*Q). so
                              // P and pm1*Q must be negatives
                              // Therefore 2P + pm1*Q = P.
            MEMCPY( PPQ,P,( 2*  E->fdesc->elng)*SIZEOF( digit_t ));
            done = TRUE;
        } else if (!Kequal(yP, yQplus, fdesc, f_pBigCtx)) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                            "ecaffine_PPQ expected P = pm1*Q");
        } else if (char2) {    // xtemp = 0.    P and pm1*Q are equal
            OK = OK && Kinvert(xP, m1, fdesc, ftemps, f_pBigCtx);
            OK = OK && Kmul(yP, m1, m1, fdesc, ftemps, f_pBigCtx);
            for (j = 0; OK && j != elng; j++) {
                m1[j] ^= xP[j];
            }            // m1 = xP + yP/xP in DRM_CHAR 2
        } else {
            OK = OK && Kmul(xP, xP, m1, fdesc, ftemps, f_pBigCtx);
            OK = OK && Kadd(E->a, m1, xtemp, fdesc, f_pBigCtx);
            OK = OK && Kadd(xtemp, m1, xtemp, fdesc, f_pBigCtx);
            OK = OK && Kadd(xtemp, m1, xtemp, fdesc,
                            f_pBigCtx);    // xtemp = a + 3*xP^2

            OK = OK && Kadd(yP, yP, ytemp, fdesc, f_pBigCtx);
            OK = OK && Kinvert(ytemp, m1, fdesc, ftemps,
                               f_pBigCtx);  // 1/(2*yP)
            OK = OK && Kmul(xtemp, m1, m1, fdesc, ftemps, f_pBigCtx);
        }
    }
    if (!done) {
        OK = OK && Kmul(m1, m1, xtemp, fdesc, ftemps, f_pBigCtx);
        if (char2) {
            digit_t xcompare = 0;
            for (j = 0; OK && j != elng; j++) {
                const digit_t itemp = xtemp[j] ^ m1[j] ^ E->a[j] ^ xQ[j];
                xcompare |= itemp;
                   //  xPQ[j] = xP[j] ^ itemp;
                xtemp[j] = itemp;   // xtemp = xPQ - xP
            }
            if (xcompare == 0) { // if xPQ == xP
                OK = OK && ecaffine_set_infinite(PPQ, E, f_pBigCtx);
                done = TRUE;
            } else {
                digit_t *m2p1 = m2; /* For m2 + 1 */
                OK = OK && Kinvert(xtemp, m2, fdesc, ftemps, f_pBigCtx);
                OK = OK && Kmul(m2, xP, m2, fdesc, ftemps, f_pBigCtx);
                                // xP / (xPQ - xP)
                OK = OK && Kadd(m2, m1, m2p1, fdesc, f_pBigCtx);
                                // m2p1 = m1 + xP / (xPQ - xP)
                OK = OK && Kmul(m2p1, m2p1, m1, fdesc,
                                    ftemps, f_pBigCtx);
                                  // m2^2 + 1
                for (j = 0; OK && j != elng; j++) {
                    const digit_t temp1 = m1[j] ^ m2p1[j] ^ E->a[j] ^ xtemp[j];
                          // m2^2 + m2 - a - xPQ - xP
                    const digit_t temp2 = xP[j] ^ yP[j];

                    xtemp[j] = temp1 ^ xP[j];  // xPPQ - xP
                    xPPQ[j] = temp1;
                    yPPQ[j] = temp2;
                    // N.B.  (xPPQ, yPPQ) may overlap (xP, yP)
                }
                OK = OK && Kmul(m2p1, xtemp, xtemp, fdesc,
                                    ftemps, f_pBigCtx);
                                // (m2 + 1) * (xPPQ - xP)
                OK = OK && Kadd(yPPQ, xtemp, yPPQ, fdesc,
                                f_pBigCtx);
                done = TRUE;
            }
        } else {   // Not characteristic 2
            OK = OK && Ksub(xtemp, xP, xtemp, fdesc, f_pBigCtx);
            OK = OK && Ksub(xtemp, xQ, xtemp, fdesc, f_pBigCtx);
                             // xPQ = m1^2 - xP - xQ
            if (Kequal(xtemp, xP, fdesc, f_pBigCtx)) {
                    // P + Q and P must be negatives
                OK = OK && ecaffine_set_infinite(PPQ, E, f_pBigCtx);
                done = TRUE;
            } else {
                digit_t *m2neg = m2;   // -m2
                OK = OK && Ksub(xtemp, xP, ytemp, fdesc, f_pBigCtx);
                                          // xPQ - xP
                OK = OK && Kinvert(ytemp, m2neg, fdesc, ftemps, f_pBigCtx);
                                   //  1/(xPQ - xP)
                OK = OK && Kmul(yP, m2neg, m2neg, fdesc,
                                    ftemps, f_pBigCtx);
                       // Think m_2 = (yPQ - yP) / (xPQ - xP);
                OK = OK && Kadd(m2neg, m2neg, m2neg, fdesc, f_pBigCtx);
                OK = OK && Kadd(m2neg, m1, m2neg, fdesc, f_pBigCtx);
                    // -m2 = 2*yP / (xPQ - xP) + m1
                OK = OK && Kmul(m2neg, m2neg, m1, fdesc,
                                    ftemps, f_pBigCtx);
                                       // m2^2
                OK = OK && Ksub(m1, xtemp, m1, fdesc, f_pBigCtx);
                OK = OK && Ksub(m1, xP, xtemp, fdesc, f_pBigCtx);
                                      // xtemp = m2^2 - xPQ - xP (new xPPQ)
                OK = OK && Ksub(xtemp, xP, ytemp, fdesc,
                                f_pBigCtx);  // xPPQ - xP
                OK = OK && Kmul(ytemp, m2neg, ytemp, fdesc,
                                ftemps, f_pBigCtx);
                                      // -m2 * (xPPQ - xP);
                OK = OK && Ksub(ytemp, yP, yPPQ, fdesc, f_pBigCtx);
                MEMCPY( xPPQ,xtemp, fdesc->elng*SIZEOF( digit_t ));
                done = TRUE;
            }
        } // if !char2
    } // if !done

    if (OK && !done) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                        "ecaffine_PPQ -- OK = T, done = F");
    }

    return OK;
}  // ecaffine_PPQ

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\kdiv.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
/*
       File kdiv.c.    Version 10 April 2002
*/


#include "fieldpriv.h"

ENTER_PK_NAMESPACE_CODE;

DRM_API DRM_BOOL DRM_CALL Kdiv
        (const digit_t *f1,        // f3 = f1/f2
         const digit_t *f2,
         digit_t*  f3,
         const field_desc_t *fdesc,
         digit_t *supplied_temps,
         struct bigctx_t *f_pBigCtx)
{
    DRM_BOOL OK = TRUE;
    digit_tempinfo_t tempinfo;
    const DRM_DWORD elng = fdesc->elng;

    tempinfo.address = supplied_temps;
    tempinfo.need_to_free = FALSE;
    tempinfo.nelmt = fdesc->ndigtemps_arith;

    OK = OK && possible_digit_allocate(&tempinfo, "Kdiv", f_pBigCtx);

    if (OK) {
        digit_t *f2inv = tempinfo.address;
        digit_t *ftemps = f2inv + elng;

        OK = OK && Kinvert(f2, f2inv, fdesc, ftemps, f_pBigCtx);
        OK = OK && Kmul(f1, f2inv, f3, fdesc, ftemps, f_pBigCtx);
    }
    if (tempinfo.need_to_free) {
        Free_Temporaries(tempinfo.address, f_pBigCtx);
    }
    return OK;
} /* Kdiv */

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\field.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "field.h"
#include "mprand.h"
#include "bigpriv.h"
#include "fieldpriv.h"

ENTER_PK_NAMESPACE_CODE;
/*
        This file (field.c) has the routines in field.h,
        for field arithmetic.
        Arithmetic is defined on GF(q) (q odd prime) or GF(2^m).
        GF(2^m) arithmetic can use normal or polynomial bases over GF(2)
        A field element is an array of type digit_t.

    Arithmetic routines (not necessarily on this file):

        Kadd(f1, f2, f3, &fdesc) -- f3 = f1 + f2
        Kdiv(f1, f2, f3, &fdesc, ftemps) -- f3 = f1 / f2
        Kequal (f1, f2,  &fdesc) -- Is f1 == f2?
        Kimmediate(scalar, f1, &fdesc) -- f1 = scalar (a long)
        Kinvert(f1, f2,  &fdesc, temps) -- f2 = 1/f1, temps supplied
        Kiszero(f1,      &fdesc) -- Is f1 == 0?        
        Kmul(f1, f2, f3, &fdesc, temps) -- f3 = f1 * f2, temps supplied
        Kmuladd(f1, f2, f3, f4, &fdesc, ftemps) -- f4 = f1 * f2 + f3         
        Knegate(f1, f2,  &fdesc) -- f2 = -f1
        Ksub(f1, f2, f3, &fdesc) -- f3 = f1 - f2

    Miscellaneous routines:

        Kclear_many(f1, nelmt,    &fdesc) -- Set nelmt elements to zero.              
        Kfree  (&fdesc)                   -- Free any memory malloc-ed
                                             when field was initialized.
        Kinitialize_prime(&modulus, &modmultemps, &fdesc)
                                       -- Initialize field with prime modulus.   
*/



DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL Kfdesc_initialize
        (field_desc_t *fdesc,                // OUT
         const DRM_DWORD     nalloc,               // IN
         struct bigctx_t *f_pBigCtx)
{
//   Initialize many fields of fdesc,
//   before those for the specific field type are set up by the caller.
//   fdesc->deallocate is set to an array of length nalloc digit_t entities.
//   This array is set to binary zero (not necessarily field zero).
//   For internal use only.

    DRM_BOOL OK = TRUE;

    if (fdesc->deallocate != NULL) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
             "Kfdesc_initialize -- fdesc->deallocate not NULL on entry");
    }

    if (OK) {
        MEMSET(fdesc, 0, SIZEOF(*fdesc));
                                          // In case something missed below

        fdesc->arithmetic = NULL;
        fdesc->base_field = NULL;
        fdesc->degree = 0;
        fdesc->elng = 0;
        fdesc->freduc = NULL;
        fdesc->free_modulus = FALSE;
        fdesc->ftype = FIELD_TYPE_INVALID;
        fdesc->inverse_adjustment = NULL;
        fdesc->leading_inverse = NULL;
        fdesc->lng_mulshifts = 0;
        fdesc->mask_used_bits = RADIXM1;
        fdesc->minimal_polynomial = NULL;
        fdesc->modulo = NULL;
        fdesc->mulshifts = NULL;
        fdesc->ndigtemps_mul = 0;
        fdesc->ndigtemps_invert1 = 0;
        fdesc->ndigtemps_arith = 0x12345678;
        fdesc->nonzero_trace_power = 0;
        fdesc->one = NULL;
        fdesc->T = 0;
        fdesc->unused_bits_top = 0;
    }
    if (OK && nalloc != 0) {
        fdesc->deallocate = digit_allocate(nalloc,
                                           "Kfdesc_initialize",
                                           f_pBigCtx);
        if (fdesc->deallocate == NULL) {
            OK = FALSE;
        } else {
            ZEROMEM(fdesc->deallocate,( nalloc)*SIZEOF( digit_t ));
        }
    }
    return OK;
} // Kfdesc_initialize



DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL Kfree(field_desc_t *fdesc, struct bigctx_t *f_pBigCtx)
/*
   Free any parts of a field descriptor
   which may have been malloc-ed.
*/
{
    DRM_BOOL OK = TRUE;

    if (fdesc->ftype == FIELD_TYPE_INVALID) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "Kfree -- argument does not point to active field");
    }

    OK = OK && (fdesc->arithmetic->freer)(fdesc, f_pBigCtx);
                  // Anything dependent on ftype

    if (OK && fdesc->deallocate != NULL) {
        Free_Temporaries(fdesc->deallocate, f_pBigCtx);
        fdesc->deallocate = NULL;
    }

    fdesc->arithmetic = NULL;
    fdesc->ftype = FIELD_TYPE_INVALID;
    return OK;
} // end Kfree




DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL Kimmediate
        (const sdigit_t scalar,  // Cast a scalar to an element of the field
         digit_t *f3,
         const field_desc_t *fdesc,
         struct bigctx_t *f_pBigCtx)
{
    DRM_BOOL OK = TRUE;

    OK = OK && Kimmediate_many(&scalar, f3, 1, fdesc, f_pBigCtx);
                                // Treat as one-element array
    return OK;
} /* Kimmediate */



DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL Kmul_many
        (const digit_t *f1,     // Set f3 = f1 * f2
         const digit_t *f2,
         digit_t  *f3,
         const DRM_DWORD nelmt,
         const field_desc_t *fdesc,
         digit_t  *supplied_temps,
         struct bigctx_t *f_pBigCtx)
{
    DRM_BOOL OK = TRUE;
    digit_tempinfo_t tempinfo;
    DRM_DWORD i;
    const DRM_DWORD elng = fdesc->elng;

    tempinfo.address = supplied_temps;
    tempinfo.nelmt = fdesc->ndigtemps_mul;
    tempinfo.need_to_free = FALSE;

         // Use user array if supplied.
         // Otherwise allocate our own, if ndigtemps_mul <> 0.

    OK = OK && possible_digit_allocate(&tempinfo, "Kmul_many", f_pBigCtx);

    for (i = 0; OK && i != elng*nelmt; i += elng) {
        OK = OK && (fdesc->arithmetic->multiplier1)(f1 + i, f2 + i, f3 + i,
            fdesc, tempinfo.address, f_pBigCtx);
    }
    if (tempinfo.need_to_free) {
        Free_Temporaries(tempinfo.address, f_pBigCtx);
    }

    if (!OK) {
       TRACE( ( "Kmul_Many error, ftype = %ld, elng = %ld, degree = %ld,"
                "ndigtemps = %ld, supplied_temps = %p\n",
                ( DRM_LONG )fdesc->ftype, ( DRM_LONG )fdesc->elng,
                ( DRM_LONG )fdesc->degree, ( DRM_LONG )fdesc->ndigtemps_mul,
                supplied_temps ) );
    }
    return OK;
} /* Kmul_Many */
 

DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL Kequaler_default
        (const digit_t      *f1,
         const digit_t      *f2,        // Is f1 == f2?
         const DRM_DWORD      nelmt,
         const field_desc_t *fdesc,
         struct bigctx_t *f_pBigCtx)
/*
     Test two arrays of field elements for equality, assuming
     each field element has a unique binary representaiton.
*/
{
    return (compare_same(f1, f2, nelmt * fdesc->elng) == 0);
} /* Kequaler_default */


DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL Kiszeroer_default
        (const digit_t *f1,   // Is f1 == 0?
         const DRM_DWORD nelmt,
         const field_desc_t *fdesc,
         struct bigctx_t *f_pBigCtx)
/*
     Test an array of field elements for zero, assuming the only
     zero field element is a binary zero.
*/
{
    (DRM_VOID)f_pBigCtx;
    return significant_digit_count(f1,  nelmt * fdesc->elng) == 0;
} /* Kiszeroer_default */


DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL Kzeroizer_default
        (digit_t    *f3,
         const DRM_DWORD   nelmt,
         const field_desc_t *fdesc,
         struct bigctx_t *f_pBigCtx)
/*
       This zeros an array of field elements in the
       usual case where the binary zero is also a field zero.
*/
{
    DRM_BOOL OK = TRUE;
    (DRM_VOID)f_pBigCtx;
    ZEROMEM(f3,( nelmt*fdesc->elng)*SIZEOF( digit_t ));
    return OK;
} // end Kzeroizer_default

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\kmuladd.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
/*
       File kmuladd.c. Version  10 April 2002
*/
#include "fieldpriv.h"

ENTER_PK_NAMESPACE_CODE;

DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL Kmuladd
        (const digit_t *f1,     // Set f4 = f1 * f2 + f3
         const digit_t *f2,
         const digit_t *f3,
         digit_t  *f4,
    const field_desc_t *fdesc,
         digit_t  *supplied_temps,
         struct bigctx_t *f_pBigCtx)
{
    DRM_BOOL OK = TRUE;
    const DRM_DWORD elng = fdesc->elng;
    digit_tempinfo_t tempinfo;

    tempinfo.address = supplied_temps;
    tempinfo.nelmt = elng + fdesc->ndigtemps_mul;
    tempinfo.need_to_free = FALSE;

    OK = OK && possible_digit_allocate(&tempinfo, "Kmuladd", f_pBigCtx);

    if (OK) {
        digit_t *prod = tempinfo.address;
        digit_t *ftemps = prod + elng;

        OK = OK && Kmul(f1, f2, prod, fdesc, ftemps, f_pBigCtx);
        OK = OK && Kadd(prod, f3, f4, fdesc, f_pBigCtx);
    }
    if (tempinfo.need_to_free) {
        Free_Temporaries(tempinfo.address, f_pBigCtx);
    }
    return OK;
} /* Kmuladd */


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\kinvert.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
/*
     File kinvert.c.    Version 08 March 2002
*/
#include "fieldpriv.h"

ENTER_PK_NAMESPACE_CODE;

DRM_API DRM_BOOL DRM_CALL Kinvert
        (const digit_t *f1,
         digit_t  *f3,     // OUT
         const field_desc_t *fdesc,
         digit_t  *supplied_temps,
         struct bigctx_t *f_pBigCtx)
{
    DRM_BOOL OK = TRUE;
    digit_tempinfo_t tempinfo;

    tempinfo.address = supplied_temps;
    tempinfo.nelmt = fdesc->ndigtemps_invert1;
    tempinfo.need_to_free = FALSE;

    if (OK && Kiszero(f1, fdesc, f_pBigCtx)) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_DIVIDE_ZERO, "Kinvert");
    }
    OK = OK && possible_digit_allocate(&tempinfo, "Kinvert", f_pBigCtx);

    OK = OK && (fdesc->arithmetic->inverter1)(f1, f3, fdesc, &tempinfo,
                                              f_pBigCtx);

    if (tempinfo.need_to_free) {
        Free_Temporaries(tempinfo.address, f_pBigCtx);
    }
    return OK;
} // end Kinvert


DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL Kinvert_many
        (const digit_t *f1,
         digit_t  *f3,     // OUT
         const DRM_DWORD   nelmt,
         const field_desc_t *fdesc,
         digit_t  *supplied_temps,
         struct bigctx_t *f_pBigCtx)
/*
        Compute f3[i] = 1/f1[i] for 0 <= i < nelmt.
        When nelmt > 1, the f1 and f3 arrays are not allowed to overlap.

        We use the identities 1/x = y*(1/(x*y)) and 1/y = x*(1/(x*y))
        to exchange all but one inversion for three multiplications.

        If the temporaries array is supplied, it must have length
        at least fdesc->ndigtemps_arith .
*/
 {
    const DRM_DWORD elng = fdesc->elng;
    DRM_BOOL OK = TRUE;
    digit_tempinfo_t tempinfo, tempinfo2;

    if (nelmt == 0) return OK;
    if (nelmt > 1 && f1 == f3) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_OVERLAPPING_ARGS,
                        "Kinvert_many -- Arrays overlap, nelmt > 1");
    }

    tempinfo.address = supplied_temps;
    tempinfo.nelmt = fdesc->ndigtemps_arith;
                    // Field element ftemp
                    // Temporaries for Kinvert and Kmul
    tempinfo.need_to_free = FALSE;

    OK = OK && possible_digit_allocate(&tempinfo, "Kinvert_many", f_pBigCtx);

    if (OK) {
/*
                 Suppose the f1 has nelmt = 4 values a0, a1, a2, a3.
                 Successively store the following in f3 and ftemp

             f3[0]       f3[1]       f3[2]      f3[3]         ftemp

               a0
                         a0*a1
                                     a0*a1*a2
                                               a0*a1*a2*a3
                                                             (a0*a1*a2*a3)^(-1)
                                                  a3^(-1)    (a0*a1*a2)^(-1)
                                      a2^(-1)                (a0*a1)^(-1)
                          a1^(-1)                            a0^(-1)
              a0^(-1)

                  We use the identities 1/x = y*(1/(x*y)) and 1/y = x*(1/(x*y))
                  to exchange all but one inversion for three multiplications.

                  When nelmt = 1, we allow f1 == f3 (i.e., same array).
                  The copy of a0 from f1 to f3 becomes a no-op.
*/
        DRM_DWORD i;
        digit_t *ftemp = tempinfo.address;  // Length elng
        digit_t *ftemps = ftemp + elng;  // Length MAX(fdesc->ndigtemps_mul,
                                         //            fdesc->ndigtemps_invert1)

        MEMCPY( f3,f1, fdesc->elng*SIZEOF( digit_t ));

        for (i = elng; OK && i != nelmt*elng; i += elng) {
                                           // CAUTION -- index variable used
                                           // after loop exit

            OK = OK && Kmul(f1 + i, f3 + i - elng, f3 + i,
                                fdesc, ftemps, f_pBigCtx);
                     // Store partial products in f3
        }

        i -= elng;     // (nelmt - 1)*elng

        if (!OK) {
        } else if (Kiszero(f3 + i, fdesc, f_pBigCtx)) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_NOT_INVERTIBLE,
                            "Kinvert_many");
        } else {
            tempinfo2.need_to_free = FALSE;
            tempinfo2.address = ftemps;
            tempinfo2.nelmt = fdesc->ndigtemps_invert1;

            OK = OK && (fdesc->arithmetic->inverter1)(f3 + i, ftemp,
                                              fdesc, &tempinfo2, f_pBigCtx);
                           // Invert product of everything

            while (i != 0) {
                OK = OK && Kmul(ftemp, f3 + i - elng,
                                    f3 + i, fdesc, ftemps, f_pBigCtx);
                OK = OK && Kmul(ftemp, f1 + i, ftemp, fdesc,
                                    ftemps, f_pBigCtx);
                i -= elng;
           } // while

           MEMCPY( f3,ftemp, fdesc->elng*SIZEOF( digit_t ));
        }
    } // if OK

    if (tempinfo.need_to_free) {
        Free_Temporaries(tempinfo.address, f_pBigCtx);
    }
    return OK;
} // end Kinvert_many

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\ecurve.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "ecurve.h"

ENTER_PK_NAMESPACE_CODE;

//           This file (ecurve.c) has routines for
//       elliptic curve arithmetic.  See ecurve.h for
//       background information.

#ifndef MAX_ECTEMPS
    #error -- MAX_ECTEMPS undefined
#endif





//   An elliptic curve over GF(q) is all points (x, y) satisfying
//   y^2 = x^3 + ax + b mod p, plus a point at infinity.
//   The ecurve_t struct has a and b.

//   Points on an elliptic curve may be represented in affine
//   or projective form.  Affine form has simply x and y.
//   If b = 0, the point at infinity has x = 0 and y = 1.
//   If b <> 0, the point at infinity has x = 0 and y = 0.

//   Projective coordinates use a format suggested in
//   the February 6, 1997 IEEE P1363 Working Draft.
//   We represent (x, y) by (X, Y, Z) where x = X/Z^2 and y = Y/Z^2.
//   Then we need Y^2 = X^3 + aX Z^2 + bZ^4.
//   The point at infinity is (lambda^2, lambda^3, 0) where lambda != 0.


//   Over GF(2^m) we use the curves y^2 + x*y = x^3 + a*x^2 + b
//   where b <> 0.  The affine representation of the point at infinity
//   has x = y = 0.  The negative of a point (x, y) is (x, x+y).

DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL ecaffine_addition
        (const digit_t *p1,
         const digit_t *p2,
         digit_t  *p3,     // OUT
         const DRM_INT   addsub,
         const ecurve_t   *E,
         digit_t     *supplied_temps,
         struct bigctx_t *f_pBigCtx)

// Compute p3 = p1 + p2 on an elliptic curve (addsub = +1)
//      or p3 = p1 = p2 (addsub = -1)
// Any or all of p1, p2, p3 can overlap.
{
    DRM_BOOL simple_case = FALSE;
    DRM_BOOL OK = TRUE;
    const field_desc_t *fdesc = E->fdesc;
    const DRM_BOOL char2 = CHARACTERISTIC_2(fdesc);
    DRM_BOOL fFree = FALSE;
                      /* Is field characteristic 2? */
    const DRM_DWORD elng = fdesc->elng;
    const digit_t *x1 = p1, *y1 = p1 + elng;
    const digit_t *x2 = p2, *y2 = p2 + elng;
    digit_t  *x3 = p3, *y3 = p3 + elng;
    digit_t *t1 = NULL;    // Each length elng
    digit_t *t2 = NULL;
    digit_t *t3 = NULL;
    digit_t *ftemps = NULL;

    if (supplied_temps == NULL) 
    {
        /*
        ** Check for integer underflow/overflow 
        */
        if ( 2*elng < elng
          || 3*elng < elng
          || 3*elng+E->ndigtemps < E->ndigtemps 
          || 3*elng+E->ndigtemps < 3*elng
          || 3*elng+E->ndigtemps*SIZEOF(digit_t) < 3*elng+E->ndigtemps)
        {
         return FALSE;
        }
        
        Allocate_Temporaries_Multiple(3*elng+E->ndigtemps, digit_t, t1, f_pBigCtx);
        if( t1 == NULL )
        {
            return FALSE;
        }
        fFree = TRUE;
        t2 = t1 + elng;
        t3 = t2 + elng;
        ftemps = t3 + elng;
    } 
    else 
    {
        t1 = supplied_temps;
        t2 = t1 + elng;
        t3 = t2 + elng;
        ftemps = t3 + elng;
    }
    
    if (   (fdesc->ftype != FIELD_Q_MP && !char2)
               || (addsub != 1 && addsub != -1) )
    {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "ecaffine_addition");
    }

#if MAX_ECTEMPS < 3
#error -- Need more EC temporaries
#endif

    if (ecaffine_is_infinite(p2, E, f_pBigCtx)) {
        MEMCPY( p3,p1,( 2* E->fdesc->elng)*SIZEOF( digit_t ));
        simple_case = TRUE;
    } else if (ecaffine_is_infinite(p1, E, f_pBigCtx)) {
        if (addsub == +1) {
            MEMCPY( p3,p2,( 2* E->fdesc->elng)*SIZEOF( digit_t ));
        } else {
            OK = OK && ecaffine_negate(p2, p3, E, f_pBigCtx);
        }
        simple_case = TRUE;
    } else {                  // t2 = y coordinate of -addsub * (x2, y2)
        if (addsub == -1) {
            MEMCPY( t2,y2, fdesc->elng*SIZEOF( digit_t ));  // t2 = y2
        } else if (char2) {
            OK = OK && Kadd(x2, y2, t2, fdesc,
                            f_pBigCtx);  // t2 = -y2 - x2
        } else {
            OK = OK && Knegate(y2, t2, fdesc,
                                f_pBigCtx);   // t2 = -y2
        }                              // Plan to do (x1, y1) - (x2, t2)
        }
    if (simple_case || !OK) {
        // Done
    } else if (Kequal(x1, x2, fdesc, f_pBigCtx)) {
        if (Kequal(y1, t2, fdesc, f_pBigCtx)) {
                                                // Subtracting equal points
            OK = OK && ecaffine_set_infinite(p3, E, f_pBigCtx);
            simple_case = TRUE;
        } else if (char2) {        // Doubling over GF(2^m)
            OK = OK && Kinvert(x1, t1, fdesc, ftemps,
                                f_pBigCtx);  // t1 = 1/x
            OK = OK && Kmul(y1, t1, t1, fdesc, ftemps, f_pBigCtx);
                                                // t1 = y/x
            OK = OK && Kadd(x1, t1, t1, fdesc,
                            f_pBigCtx);   // t1 = m = y/x + x
        } else {                   // Doubling over GF(q)
            OK = OK && Kadd(y1, y1, t2, fdesc, f_pBigCtx);   // t2 = 2*y
            OK = OK && Kmul(x1, x1, t1, fdesc,
                                ftemps, f_pBigCtx);   // t1 = x^2
            OK = OK && Kadd(t1, E->a, t3, fdesc,
                                f_pBigCtx); // t3 = x^2 + a
            OK = OK && Kadd(t1, t3, t3, fdesc,
                                f_pBigCtx);   // t3 = 2x^2 + a
            OK = OK && Kadd(t1, t3, t3, fdesc,
                                f_pBigCtx);   // t3 = 3x^2 + a
            OK = OK && Kinvert(t2, t1, fdesc, ftemps,
                                f_pBigCtx); // t1 = 1/(2*y)
            OK = OK && Kmul(t3, t1, t1, fdesc,
                                ftemps, f_pBigCtx);
                                                // t1 = m = (3x^2 + a)/(2*y)
        } // if x1 == x2
    } else {   // Distinct x coordinates
        OK = OK && Kadd(y1, t2, t3, fdesc,
                        f_pBigCtx);       // t3 = y1 + t2
        if (char2) {
            OK = OK && Kadd(t3, x2, t3, fdesc,
                            f_pBigCtx);
                                        // Use t3 = y1 + t2 + x2 in DRM_CHAR 2
        }
        OK = OK && Ksub(x1, x2, t2, fdesc,
                        f_pBigCtx);       // t2 = x1 - x2
        OK = OK && Kinvert(t2, t1, fdesc, ftemps,
                        f_pBigCtx);   // t1 = 1/t2
        OK = OK && Kmul(t3, t1, t1, fdesc,
                            ftemps, f_pBigCtx); // t1 = m = t3/t2
    }
    if (simple_case || !OK) {
        // Do nothing
    } else if (char2) {
        DRM_DWORD i;
        OK = OK && Kmul(t1, t1, t2, fdesc,
                            ftemps, f_pBigCtx);   // t2 = m^2
        for (i = 0; i != elng; i++) {
            t2[i] = t2[i] ^ t1[i] ^ E->a[i] ^ x2[i];
        }                                       // t2 = m^2 + m - a - x2
        OK = OK && Kmul(t1, t2, t3, fdesc, ftemps, f_pBigCtx);
                                                // t3 = (t2 - 2*x1)*m
        for (i = 0; i != elng; i++) {
            const digit_t x3i = t2[i] ^ x1[i];   // x3 = t2 - x1
            y3[i] = t3[i] ^ y1[i] ^ x3i;    // y3 = -(t2 - 2*x1)*m - y1 - x3
            x3[i] = x3i;
        }
    } else {
        OK = OK && Kmul(t1, t1, t2, fdesc,
                            ftemps, f_pBigCtx); // t2 = m^2
        OK = OK && Ksub(t2, x1, t2, fdesc,
                        f_pBigCtx);     //  m^2 - x1
        OK = OK && Ksub(t2, x2, t2, fdesc,
                        f_pBigCtx);     // t2 = x3 = m^2 - x1 - x2;
        OK = OK && Ksub(x1, t2, t3, fdesc,
                        f_pBigCtx);     // t3 = x1 - x3
        MEMCPY( x3,t2, fdesc->elng*SIZEOF( digit_t ));
        OK = OK && Kmul(t1, t3, t2, fdesc,
                        ftemps, f_pBigCtx); // t2 = m*(x1 - x3)
        OK = OK && Ksub(t2, y1, y3, fdesc,
                        f_pBigCtx);     // y3 = m*(x1 - x3) - y1
    }

    if( fFree )
    {
        Free_Temporaries( t1, f_pBigCtx );
    }
    return OK;
} // end ecaffine_addition


DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL ecaffine_addition_subtraction
          (const digit_t *p1,
           const digit_t *p2,
           digit_t  *psum,     // OUT
           digit_t  *pdif,     // OUT
           const ecurve_t   *E,
           digit_t     *supplied_temps,
           struct bigctx_t *f_pBigCtx)

// Compute psum = p1 + p2 and pdif = p1 - p2
// on an elliptic curve.
// Do this in a way which uses only one inversion.
// Outputs may overlap inputs.
{
    DRM_BOOL special_case = FALSE;
    DRM_BOOL OK = TRUE;
    const field_desc_t *fdesc = E->fdesc;
    const DRM_BOOL char2 = CHARACTERISTIC_2(fdesc);
                      /* Is field characteristic 2? */
    const DRM_DWORD elng = fdesc->elng;
    const digit_t *x1 = p1, *y1 = p1 + elng;
    const digit_t *x2 = p2, *y2 = p2 + elng;

    DRM_DWORD i;

    if (fdesc->ftype != FIELD_Q_MP && !char2) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "ecaffine_addition_subtraction");
    } else if (supplied_temps == NULL) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_NULL_POINTER,
                        "ecaffine_addition_subtraction");
    }

     if (OK) {
#if !defined(MAX_ECTEMPS) || MAX_ECTEMPS < 5
    #error -- Increase MAX_ECTEMPS
#endif
// WARNING -- ps must come first for special_case code to work.
// This also requires that ecaffine_addition use only three field temps.
        digit_t *ps = supplied_temps;
        digit_t *pd = ps + 2*elng;
        digit_t *t0 = pd + 2*elng;
        digit_t *ftemps = t0 + elng;
        digit_t *special_case_temps = pd;

            // If either input or either output is
            // the point at infinity, use special code.

        if (   ecaffine_is_infinite(p1, E, f_pBigCtx)
            || ecaffine_is_infinite(p2, E, f_pBigCtx)
            || Kequal(x1, x2, fdesc, f_pBigCtx)) {

            special_case = TRUE;
            OK = OK && ecaffine_addition(p1, p2, ps, +1, E,
                                        special_case_temps, f_pBigCtx);
            OK = OK && ecaffine_addition(p1, p2, pdif, -1, E,
                                         special_case_temps, f_pBigCtx);
            MEMCPY( psum,ps,( 2*  E->fdesc->elng)*SIZEOF( digit_t ));
        }

        if (OK && !special_case) {
            digit_t *psx = ps, *psy = ps + elng;
            digit_t *pdx = pd, *pdy = pd + elng;

            OK = OK && Ksub(x1, x2, psx, fdesc, f_pBigCtx);
            OK = OK && Kinvert(psx, t0, fdesc,
                               ftemps, f_pBigCtx);  // t0 = 1/(x1 - x2)
            if (char2) {
                for (i = 0; OK && i != elng; i++) {
                    const digit_t deltay = y1[i] ^ y2[i];   // y1 - y2

                    psy[i] = deltay;
                    pdy[i] = deltay ^ x2[i];           // y1 - (-y2 - x2)
                }
            } else {
                OK = OK && Ksub(y1, y2, psy, fdesc,
                                f_pBigCtx);   // y1 - y2
                OK = OK && Kadd(y1, y2, pdy, fdesc,
                                f_pBigCtx);   // y1 - (-y2)
            }
            OK = OK && Kmul(t0, psy, psy, fdesc, ftemps,
                                f_pBigCtx);
                                             // ms = (y1 - y2)/(x1 - x2)
            OK = OK && Kmul(t0, pdy, pdy, fdesc, ftemps,
                                f_pBigCtx);
                                             // md = (y1 + y2)/(x1 - x2)
                                             // or (y1 + y2 + x2)/(x1 - x2)
            OK = OK && Kmul(psy, psy, psx, fdesc, ftemps,
                                f_pBigCtx);  // ms^2
            OK = OK && Kmul(pdy, pdy, pdx, fdesc, ftemps,
                                f_pBigCtx);  // md^2
            if (char2) {
                for (i = 0; OK && i != elng; i++) {
                    const digit_t itemp = E->a[i] ^ x1[i] ^ x2[i];

                    psx[i] ^= psy[i] ^ itemp;  // ms^2 + ms - a - x1 - x2
                    pdx[i] ^= pdy[i] ^ itemp;  // md^2 + md - a - x1 - x2
                }
            } else {
                OK = OK && Kadd(x1, x2, t0, fdesc,
                                f_pBigCtx);    // x1 + x2
                OK = OK && Ksub(psx, t0, psx, fdesc,
                                f_pBigCtx);  // ms^2 - x1 - x2
                OK = OK && Ksub(pdx, t0, pdx, fdesc,
                                f_pBigCtx);  // md^2 - x1 - x2
            }

              // Now psx has x(P1 + P2) and pdx has x(P1 - P2)
              // Compute y(P1 + P2) = ms*(x1 - psx) - y1
              //     (subtract another psx in characteristic 2
              // Likewise y(P1 - P2) = md*(x1 - pdx) - y1

            OK = OK && Ksub(x1, psx, t0, fdesc,
                            f_pBigCtx);
            OK = OK && Kmul(psy, t0, psy, fdesc, ftemps,
                                f_pBigCtx);
            OK = OK && Ksub(x1, pdx, t0, fdesc,
                            f_pBigCtx);
            OK = OK && Kmul(pdy, t0, pdy, fdesc, ftemps,
                                f_pBigCtx);

            if (char2) {
                for (i = 0; OK && i != elng; i++) {
                    const digit_t y1i = y1[i];
                    const digit_t xsumi = psx[i];
                    const digit_t ysumi = psy[i] ^ y1i ^ xsumi;
                    const digit_t xdifi = pdx[i];
                    const digit_t ydifi = pdy[i] ^ y1i ^ xdifi;

                    psum[i]      = xsumi;
                    psum[i+elng] = ysumi;

                    pdif[i]      = xdifi;
                    pdif[i+elng] = ydifi;
                } // for i
            } else {
                OK = OK && Ksub(psy, y1, psy, fdesc, f_pBigCtx);
                OK = OK && Ksub(pdy, y1, pdy, fdesc, f_pBigCtx);

                for (i = 0; OK && i != elng; i++) {
                    const digit_t xsumi = psx[i];
                    const digit_t ysumi = psy[i];
                    const digit_t xdifi = pdx[i];
                    const digit_t ydifi = pdy[i];

                    psum[i]      = xsumi;
                    psum[i+elng] = ysumi;
                    pdif[i]      = xdifi;
                    pdif[i+elng] = ydifi;
                } // for i
            }
        } // if !special_case
    }
    if (!OK) {
        TRACE( ( "ecaffine_addition_subtraction exiting abnormally\n" ) );
    }
    return OK;
} // end ecaffine_addition_subtraction


DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL ecaffine_is_infinite (
    const digit_t *p1,
    const ecurve_t   *E,
    struct bigctx_t *f_pBigCtx )
    
// Check for point at infinity,
// If b = 0, check whether x = 0 and y = 1.
// If b <> 0, check whether x = y = 0

//    If an error occurs, this routine returns FALSE.
{
    const field_desc_t *fdesc = E->fdesc;
    const DRM_DWORD elng = fdesc->elng;
    DRM_BOOL OK = TRUE, infinite;

    if (Kiszero(p1, fdesc, f_pBigCtx)) {    // If x = 0
        if (E->biszero) {
            infinite = Kequal(p1 + elng, fdesc->one, fdesc, f_pBigCtx);
        } else {
            infinite = Kiszero(p1 + elng, fdesc, f_pBigCtx);
        }
    } else {
        infinite = FALSE;
    }
    return OK && infinite;
} // end ecaffine_is_infinite


DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL ecaffine_multiply_pm1(
    const digit_t *p1,
    digit_t  *p2,
    const DRM_INT    negate_flag,
    const ecurve_t   *E,
    struct bigctx_t *f_pBigCtx)

//      Set p2 =  p1 if negate_flag = +1
//      Set p2 = -p1 if negate_flag = -1

{
    DRM_BOOL OK = TRUE;
    if (negate_flag == +1) {
        MEMCPY( p2,p1,( 2*  E->fdesc->elng)*SIZEOF( digit_t ));
    } else if (negate_flag == -1) {
        OK = OK && ecaffine_negate(p1, p2, E, f_pBigCtx);
    } else {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "ecaffine_multiply_pm1");
    }
    return OK;
} // end ecaffine_multiply_pm1



DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL ecaffine_negate
        (const digit_t *p1,
         digit_t  *p2,
         const ecurve_t   *E,
         struct bigctx_t *f_pBigCtx)

// Compute p2 = -p1 with elliptic curve arithmetic.
{
    DRM_BOOL OK = TRUE;
    const field_desc_t *fdesc = E->fdesc;
    const DRM_DWORD elng = fdesc->elng;

    if (ecaffine_is_infinite(p1, E, f_pBigCtx)) {
        MEMCPY( p2 + elng,p1 + elng, fdesc->elng*SIZEOF( digit_t ));    // y2 = y1
    } else if (CHARACTERISTIC_2(fdesc)) {
        OK = Kadd(p1, p1 + elng, p2 + elng, fdesc,
                  f_pBigCtx); // y2 = x1 + y1
    } else {
        OK = Knegate(p1 + elng, p2 + elng, fdesc,
                  f_pBigCtx);  // y2 = -y1
    }
    MEMCPY( p2,p1, fdesc->elng*SIZEOF( digit_t ));                // x2 = x1
    return OK;
} // end ecaffine_negate



DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL ecaffine_on_curve
            (const digit_t  *p1,
             const ecurve_t    *E,
             const DRM_CHAR   *pdebug_info,
             digit_t      *supplied_temps,
             struct bigctx_t *f_pBigCtx)

// Test whether p1 = (x1, y1) is on the curve.
// In GF(q) case, check whether y1^2 = x1 * (x1^2 + a) + b.
// In GF(2^m) case, check whether y1*(x1 + y1) = x1^2*(x1 + a) + b.

// When the point is not on the curve, we call SetMpErrno_clue,
// using *pdebug_info as a hint
{
    DRM_BOOL OK = TRUE;
    const field_desc_t *fdesc = E->fdesc;
    const DRM_DWORD elng = fdesc->elng;
    const digit_t *x1 = p1, *y1 = p1 + elng;
    digit_t *t1 = NULL, *t2 = NULL, *ftemps = NULL;
    digit_tempinfo_t tempinfo;

    if (ecaffine_is_infinite(p1, E, f_pBigCtx)) return TRUE;

    tempinfo.address = supplied_temps;
    tempinfo.need_to_free = FALSE;
    tempinfo.nelmt = E->ndigtemps;
    OK = OK && possible_digit_allocate(&tempinfo,
                                       "",
                                       f_pBigCtx);

    if (OK) {
        t1 = tempinfo.address;
        t2 = t1 + elng;
        ftemps = t2 + elng;
#if MAX_ECTEMPS < 2
    #error -- "Increase MAX_ECTEMPS"
#endif
    }

    OK = OK && Kmul(x1, x1, t1, fdesc, ftemps, f_pBigCtx);      // x^2

    if (CHARACTERISTIC_2(fdesc)) {       // Characteristic 2
        OK = OK && Kadd(x1, E->a, t2, fdesc,
                        f_pBigCtx);            // t2 = x + a
        OK = OK && Kmul(t1, t2, t1, fdesc, ftemps,
                        f_pBigCtx);  // t1 = x^2*(x + a)
        OK = OK && Kadd(t1, E->b, t1, fdesc,
                        f_pBigCtx);            // t1 = x^2*(x + a) + b
        OK = OK && Kadd(y1, x1, t2, fdesc,
                        f_pBigCtx);              // t2 = y1 + x1;
        OK = OK && Kmul(y1, t2, t2, fdesc, ftemps,
                        f_pBigCtx);  // t2 = y1*(y1 + x1)

    } else {                            // Odd characteristic
        OK = OK && Kadd(t1, E->a, t1, fdesc,
                        f_pBigCtx);            // t1 = x^2 + a
        OK = OK && Kmul(x1, t1, t1, fdesc, ftemps,
                        f_pBigCtx);  // t1 = x*(x^2 + a)
        OK = OK && Kadd(t1, E->b, t1, fdesc,
                        f_pBigCtx);            // t1 = x*(x^2 + a) + b
        OK = OK && Kmul(y1, y1, t2, fdesc, ftemps,
                        f_pBigCtx);  // t2 = y^2
    }
    if (OK && !Kequal(t1, t2, fdesc, f_pBigCtx)) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_NOT_ON_CURVE, pdebug_info);
    }
    if (tempinfo.need_to_free) {
        Free_Temporaries(tempinfo.address, f_pBigCtx);
    }
    return OK;
} // end ecaffine_on_curve



DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL ecaffine_set_infinite
        (digit_t *p1,           // OUT
         const ecurve_t  *E,
         struct bigctx_t *f_pBigCtx)
// Set p1 to identity (point at infinity).
// If b = 0, set x = 0 and y = 1.
// If b <> 0. set x = y = 0.
{
    const field_desc_t *fdesc = E->fdesc;
    const DRM_DWORD elng = fdesc->elng;
    DRM_BOOL OK = TRUE;

    OK = OK && Kclear_many(p1, 2, fdesc, f_pBigCtx);
    if (E->biszero) {
        MEMCPY( p1 + elng,fdesc->one, fdesc->elng*SIZEOF( digit_t ));
    }
    return OK;
} // end ecaffine_set_infinite


DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL ec_free(ecurve_t *E, struct bigctx_t *f_pBigCtx)
// Free the temporaries associated with an elliptic curve.
{
    DRM_BOOL OK = TRUE;
    if (E->free_field && E->fdesc != NULL) {
        OK = OK && Kfree((field_desc_t*)E->fdesc, f_pBigCtx);
                                   // Remove const attribute

        Free_Temporaries((field_desc_t*)E->fdesc, f_pBigCtx);
    }
    if (E->deallocate != NULL) {
        Free_Temporaries(E->deallocate, f_pBigCtx);
    }
    E->deallocate = NULL;
    E->generator = NULL;
    E->a = NULL;
    E->b = NULL;
    E->gorder = NULL;
    E->fdesc = NULL;
    return OK;
} // end ec_free


DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL ec_initialize
        (const digit_t      *a,
         const digit_t      *b,
         const field_desc_t *fdesc,
         ecurve_t      *E,         
         struct bigctx_t *f_pBigCtx,
         struct bigctx_t      *pbigctxGlobal)
// Initialize struct for elliptic curve with parameters a and b
{
    const DRM_DWORD elng = fdesc->elng;
    DRM_BOOL OK = TRUE;
    digit_t *fields = digit_allocate(5*elng + 1, "ec_initialize", pbigctxGlobal);
    E->deallocate = fields;
    E->free_field = FALSE;
    E->ndigtemps = fdesc->ndigtemps_arith + MAX_ECTEMPS*elng;
    E->biszero = Kiszero(b, fdesc, f_pBigCtx);

    if (fields == NULL) {
        OK = FALSE;
    } else {
        E->a = fields;  fields += elng;
        E->b = fields;  fields += elng;
        E->generator = fields;  fields += 2*elng;
        E->gorder = fields; fields += (elng+1);
        E->fexpon = NULL;
    }

    if (CHARACTERISTIC_2(fdesc)) {
        OK = OK && !E->biszero;        // GF(2^m) requires b <> 0
    } else {
        digit_t *ftemps = NULL;
        OK = OK && Kimmediate(27, E->b, fdesc, f_pBigCtx)
                && Kmul(E->b, b, E->b, fdesc, ftemps,
                            f_pBigCtx)        // 27*b
                && Kmul(E->b, b, E->b, fdesc, ftemps,
                            f_pBigCtx)        // 27*b^2
                && Kadd(a, a, E->a, fdesc,
                            f_pBigCtx)                       // 2*a
                && Kmul(E->a, E->a, E->a, fdesc, ftemps,
                            f_pBigCtx)     // 4*a^2
                && Kmuladd(a, E->a, E->b, E->a, fdesc, ftemps,
                            f_pBigCtx)   // 4*a^3 + 27*b^2
                && !Kiszero(E->a, fdesc,
                            f_pBigCtx);   // Ensure discriminant nonzero
    }
    if (OK) {
        E->fdesc = fdesc;
        MEMCPY( E->a,a, fdesc->elng*SIZEOF( digit_t ));
        MEMCPY( E->b,b, fdesc->elng*SIZEOF( digit_t ));

          // Initialize generator to point at infinity
          // and order to 1.  Application can change these.

        OK = OK && ecaffine_set_infinite(E->generator, E, f_pBigCtx)
                && set_immediate(E->gorder, 1, elng+1, f_pBigCtx);
    }
    if (!OK) {
        (DRM_VOID)ec_free(E, f_pBigCtx);
    }
    return OK;
} // end ec_initialize_curve

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\kinitpr.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
/*
       File kinitpr.c.   Version 03 October 2002.

       Routines for fields GF(p), p prime.
*/

#include "fieldpriv.h"
#include "mprand.h"

ENTER_PK_NAMESPACE_CODE;

static DRM_NO_INLINE DRM_BOOL DRM_CALL Kprime_adder
        (const digit_t      *f1,           // IN
         const digit_t      *f2,           // IN
         digit_t       *f3,           // OUT
         const DRM_DWORD      nelmt,        // IN
         const field_desc_t *fdesc,        // IN
         struct bigctx_t *f_pBigCtx)
{
    DRM_BOOL OK = TRUE;
    
    if (OK) {
        DRM_DWORD i;
        const DRM_DWORD elng = fdesc->elng;

        for (i = 0; OK && i != nelmt*elng; i += elng) {
            OK = OK && add_mod(f1 + i, f2 + i, f3 + i,
                               fdesc->modulo->modulus, fdesc->modulo->length);
        }
    }
    return OK;
}  // Kprime_adder


static DRM_BOOL DRM_CALL Kprime_exponentiator1
        (const digit_t      *f1,               // IN
         const digit_t      *exponent,         // IN
         const DRM_DWORD      lng_exponent,     // IN
         digit_t       *f2,               // OUT
         const field_desc_t *fdesc,            // IN
         struct bigctx_t *f_pBigCtx)
{
    DRM_BOOL OK = TRUE;
    
    OK = OK && mod_exp(f1, exponent, lng_exponent, f2,
                       fdesc->modulo, f_pBigCtx);
    return OK;
} // Kprime_exponentiator1


static DRM_NO_INLINE DRM_BOOL DRM_CALL Kprime_freer
        (field_desc_t *fdesc,            // IN/OUT
        struct bigctx_t *f_pBigCtx)
{
    DRM_BOOL OK = TRUE;

    if (    OK
         && fdesc->free_modulus
         && fdesc->modulo != NULL) {
         uncreate_modulus((mp_modulus_t*)fdesc->modulo, f_pBigCtx);
                                             // Remove const attribute
        Free_Temporaries((mp_modulus_t*)fdesc->modulo, f_pBigCtx);
        fdesc->free_modulus = FALSE;
        fdesc->modulo = NULL;
    }
    return OK;
} // Kprime_freer



static DRM_NO_INLINE DRM_BOOL DRM_CALL Kprime_immediater
        (const sdigit_t *scalars,               // IN
         digit_t   *f3,                    // OUT
         const DRM_DWORD  nelmt,                 // IN
         const field_desc_t *fdesc,             // OUT
         struct bigctx_t *f_pBigCtx)
/*
       Convert a signed digit_t value
       (usually a 32-bit signed integer)
       to a field element.

       N.B.  fdesc->one is available to convert a 1.
*/

{
    DRM_BOOL OK = TRUE;
    DRM_DWORD i;
    const DRM_DWORD elng = fdesc->elng;

    for (i = 0; OK && i != nelmt; i++) {
        const sdigit_t scalar = scalars[i];
        const digit_t abssc = (digit_t)(scalar >= 0 ? scalar : -scalar);
        digit_t* f3addr = f3 + i*elng;

        OK = OK && to_modular(&abssc, 1, f3addr, fdesc->modulo, f_pBigCtx);
        if (scalar < 0) {
            OK = OK && neg_mod(f3addr, f3addr, fdesc->modulo->modulus, fdesc->modulo->length);
        }
    }
    return OK;
} // end Kprime_immediater


static DRM_NO_INLINE DRM_BOOL DRM_CALL Kprime_inverter1
        (const digit_t           *f1,        // IN
         digit_t            *f3,        // OUT
         const field_desc_t      *fdesc,     // IN
         const digit_tempinfo_t  *tempinfo,  // IN
         struct bigctx_t *f_pBigCtx)
//
//     Invert one field element f3 = 1/f1.
//     f1 is guaranteed nonzero.

{
    const DRM_DWORD elng = fdesc->elng;
    digit_t *ftemp = tempinfo->address;   // Length elng
    digit_t *ftemps = ftemp + elng;       // Length MAX(fdesc->ndigtemps_mul,
                                          //            mp_invert_ntemps(elng))
    const digit_t *finp = f1;   // Tentative input location
    const mp_modulus_t *modulo = fdesc->modulo;
    DRM_BOOL OK = TRUE;

    DRMASSERT (   tempinfo->address + tempinfo->nelmt
            == ftemps + MAX(fdesc->ndigtemps_mul,
                            mp_invert_ntemps(elng, f_pBigCtx)));

    if (OK && modulo->reddir == FROM_RIGHT) {
        OK = OK && Kmul(finp, fdesc->inverse_adjustment,
                        ftemp, fdesc, ftemps, f_pBigCtx);
        finp = ftemp;
    }
    OK = OK && mp_invert(finp, modulo->modulus, elng,
                        f3, "", ftemps, f_pBigCtx);
    return OK;
} // end Kprime_inverter1



static DRM_NO_INLINE DRM_BOOL DRM_CALL Kprime_mulpower2er
        (const digit_t      *f1,        // IN
         const DRM_INT      ishift,    // IN
         digit_t       *f3,        // OUT
         const DRM_DWORD      nelmt,     // IN
         const field_desc_t *fdesc,     // IN
         struct bigctx_t *f_pBigCtx)
/*
      Multiply field elements in f1 by 2^ishift,
      store results in f3.
*/
{
    DRM_BOOL OK = TRUE;
    const DRM_DWORD elng = fdesc->elng;
    DRM_DWORD i;

    for (i = 0; i != nelmt*elng; i += elng) {
        OK = OK && mod_shift(f1 + i, ishift, f3 + i,
                             fdesc->modulo);
    }
    return OK;
}  // end Kprime_mulpower2er


static DRM_NO_INLINE DRM_BOOL DRM_CALL Kprime_multiplier1
        (const digit_t      *f1,     // IN
         const digit_t      *f2,     // IN
         digit_t       *f3,     // OUT
         const field_desc_t *fdesc,  // IN
         digit_t       *temps,  // IN
         struct bigctx_t *f_pBigCtx)
{
    DRM_BOOL OK = TRUE;

    OK = OK && mod_mul(f1, f2, f3, fdesc->modulo, temps, f_pBigCtx);
    return OK;
} // end Kprime_multiplier1


static DRM_NO_INLINE DRM_BOOL DRM_CALL Kprime_negater
        (const digit_t      *f1,        // IN
         digit_t       *f3,        // OUT
         const DRM_DWORD      nelmt,     // IN
         const field_desc_t *fdesc,     // IN
         struct bigctx_t *f_pBigCtx)
{
    DRM_BOOL OK = TRUE;

    if (OK) {
        DRM_DWORD i;
        const DRM_DWORD elng = fdesc->elng;

        for (i = 0; OK && i != nelmt*elng; i += elng) {
            OK = OK && neg_mod(f1 + i, f3 + i, fdesc->modulo->modulus, fdesc->modulo->length);            
        }  // for i
    }
    return OK;
}  // Kprime_negater


static DRM_BOOL DRM_CALL Kprime_randomizer
        (digit_t       *f3,         // OUT
         const DRM_DWORD      nelmt,      // IN
         const field_desc_t *fdesc,      // IN
         struct bigctx_t *f_pBigCtx)
{
    DRM_DWORD i;
    const DRM_DWORD elng = fdesc->elng;
    DRM_BOOL OK = TRUE;

    for (i = 0; OK && i != nelmt*elng; i += elng) {
        OK = OK && random_mod(fdesc->modulo->modulus,
                              f3 + i, elng, f_pBigCtx);
    }  // for i
    return OK;
}  // Kprime_randomizer


static DRM_NO_INLINE DRM_BOOL DRM_CALL Kprime_sizer
        (digit_t       *size,    // OUT
         const field_desc_t *fdesc,   // IN
         struct bigctx_t *f_pBigCtx)
/*
     Return field size (length elng+1).
     For prime fields, this is the same as its characteristic.
*/
{
    const DRM_DWORD elng = fdesc->elng;
    DRM_BOOL OK = TRUE;

    DRMASSERT(elng == fdesc->modulo->length);

    mp_extend(fdesc->modulo->modulus, elng, size, elng + 1);

    return OK;
}  // end Kprime_sizer

DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL Kprime_sqrter
        (const digit_t *f1,        // IN
         digit_t       *f3,        // OUT
         const DRM_DWORD      nelmt,     // IN
         const field_desc_t *fdesc,     // IN
         DRM_BOOL      *psquares,  // OUT
         struct bigctx_t *f_pBigCtx)
{
    DRM_BOOL OK = TRUE;
    DRM_DWORD i;
    DRM_DWORD elng = fdesc->elng;
    DRM_BOOL all_squares = TRUE;

    for (i = 0; OK && i != nelmt*elng; i += elng) {
        DRM_BOOL square_now = FALSE;
        OK = OK && mod_sqrt(f1 + i, f3 + i,
                            fdesc->modulo, &square_now, f_pBigCtx);
        all_squares = all_squares && square_now;
    }
    if (OK) *psquares = all_squares;
    return OK;
}  // Kprime_sqrter

static DRM_NO_INLINE DRM_BOOL DRM_CALL Kprime_subtracter
        (const digit_t      *f1,     // IN
         const digit_t      *f2,     // IN
         digit_t       *f3,     // OUT
         const DRM_DWORD      nelmt,  // IN
         const field_desc_t *fdesc,  // IN
         struct bigctx_t *f_pBigCtx)
{
    DRM_BOOL OK = TRUE;
    DRM_DWORD i;
    const DRM_DWORD elng = fdesc->elng;

    for (i = 0; OK && i != nelmt*elng; i += elng) {
        OK = OK && sub_mod(f1 + i, f2 + i, f3 + i, fdesc->modulo->modulus, fdesc->modulo->length);
    }
    return OK;
}  // Kprime_subtracter


#pragma prefast(suppress:22112) /* security mitigation warning */
extern const field_arithmetic_t prime_arithmetic = 
{
    Kprime_adder,
    Kequaler_default,
    Kprime_freer,
    Kprime_immediater,
    Kprime_inverter1,
    Kiszeroer_default,
    Kprime_mulpower2er,
    Kprime_multiplier1,
    Kprime_negater,
    Kprime_sizer,    
    Kprime_subtracter,
    Kzeroizer_default
};



DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL Kinitialize_prime
        (const mp_modulus_t *modulo,     // IN
         field_desc_t  *fdesc,      // OUT
         struct bigctx_t      *pbigctxTemp,
         struct bigctx_t *f_pBigCtx)
/*
        Initialize a field descriptor for a prime field.

        CAUTION -- The modulo struct must remain accessible
        (i.e., in scope) as long as the field is being accessed.
        That is, don't use an automatic variable in a function
        for *modulo if the field will be accessed after exiting the function.

        CAUTION -- modulo->modulus should be prime, but we don't check that.
*/

{
    const DRM_DWORD elng = modulo->length;
    const DRM_DWORD ninv_temps = mp_invert_ntemps(elng, pbigctxTemp);
    DRM_BOOL OK = TRUE;

    fdesc->deallocate = NULL;
    OK = OK && Kfdesc_initialize(fdesc, 0, pbigctxTemp);

    fdesc->arithmetic = &prime_arithmetic;
    fdesc->degree = 1;
    fdesc->elng = elng;
    fdesc->ftype = FIELD_Q_MP;
    fdesc->modulo = modulo;
    fdesc->ndigtemps_mul = modulo->modmul_algorithm_temps;
    fdesc->ndigtemps_invert1 = elng + MAX(fdesc->ndigtemps_mul, ninv_temps);
    fdesc->ndigtemps_arith = fdesc->ndigtemps_invert1 + elng;
    fdesc->one = (digit_t*)modulo->one;  // Remove const attribute
          // Set up multiplier for Kinvert.
          // This is 1 for FROM_LEFT arithmetic.
          // For FROM_RIGHT arithmetic, we twice unscale the
          // constant fdesc->one.
    if (!OK) {
    } else if (modulo->reddir == FROM_LEFT) {
        fdesc->inverse_adjustment = fdesc->one;
    } else {
        digit_t *invadj = digit_allocate(elng,
                                         "Kinitialize_prime", f_pBigCtx);
        if (invadj == NULL) {
            OK = FALSE;
        }
        fdesc->deallocate = invadj;
        fdesc->inverse_adjustment = invadj;
        OK = OK && mod_shift(fdesc->one, -2*modulo->scaling_power2,
                             invadj, modulo);
        if (!OK && invadj != NULL) {
            Free_Temporaries(invadj, f_pBigCtx);
        }
    }
    return OK;
} /* Kinitialize_prime */


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\lucas.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bignum.h"

ENTER_PK_NAMESPACE_CODE;
/*
//     mod_LucasUV(C1, C0, exponent, lngexpon, Uout, Vout, modulo) --
//              Compute
//
//                  Vout = alpha^exponent + beta^exponent
//                  Uout = (alpha^exponent - beta^exponent)/(alpha - beta)
//
//              where alpha, beta satisfy X^2 - C1*X + C0 = 0 (mod modulo).
//              Modulus must be odd.
//
//                  Vout[0] = 2     Vout[1] = C1
//                  Uout[0] = 1     Uout[1] = 1
//                  Vout[n+2] = C1*Vout[n+1] - C0*Vout[n]
//                  Uout[n+2] = C1*Uout[n+1] - C0*Uout[n]

*/
/***************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL mod_LucasUV
        (const digit_t C1[],
         const digit_t C0[],
         const digit_t exponent[],
         const DRM_DWORD   lngexpon,
         digit_t  Uout[],
         digit_t  Vout[],
         const mp_modulus_t *modulo,
         struct bigctx_t *f_pBigCtx)
{
/*
       Vout = alpha^exponent + beta^exponent
       Uout = (alpha^exponent - beta^exponent)/(alpha - beta)

    where alpha, beta satisfy X^2 - C1*X + C0 = 0 (mod modulo).
    Modulus must be odd.
*/

    DRM_BOOL OK = TRUE;
    DRM_DWORD bits_left = mp_significant_bit_count(exponent, lngexpon);
    const DRM_DWORD lng = modulo->length;

    /* Check for integer underflow/overflow */
    if (2*lng + modulo->modmul_algorithm_temps < 2*lng)
    {
        OK = FALSE;
    }
    else
    {
        digit_t *dtemps = digit_allocate(2*lng + modulo->modmul_algorithm_temps,
                                         "mod_LucasUV", f_pBigCtx);
        if (dtemps == NULL) {
            OK = FALSE;
        } else if (bits_left == 0) {       /* If exponent is identically zero  */
            OK = OK && add_mod(modulo->one, modulo->one, Vout,
                               modulo->modulus, modulo->length);  // V = 2
            ZEROMEM(Uout,( lng)*SIZEOF( digit_t ));                           // U = 0
        } else {
            digit_t *DELTA = dtemps;        // Length lng
            digit_t *temp1 = dtemps + lng;  // Length lng
            digit_t *modmultemps = dtemps + 2*lng;
                                    // Length modulo->modmul_algorithm_temps

            MEMCPY( Vout,C1,( lng)*SIZEOF( digit_t ));                         // V = C1
            MEMCPY( Uout,modulo->one,( lng)*SIZEOF( digit_t ));                // U = 1
            OK = OK && mod_shift(C0, +2, temp1, modulo);    // 4*C0
            OK = OK && mod_mul(C1, C1, DELTA, modulo,
                              modmultemps, f_pBigCtx);                 // C1*C1
            OK = OK && sub_mod(DELTA, temp1, DELTA, modulo->modulus, modulo->length);            
                                                             // DELTA = C1*C1 - 4*C0

            bits_left--;
            while (OK && bits_left != 0) {
                bits_left--;
                    // First replace n by 2*n
                OK = OK && mod_mul(Uout, Uout, temp1, modulo,
                                   modmultemps, f_pBigCtx);
                OK = OK && mod_mul(temp1, DELTA, temp1, modulo,
                                   modmultemps, f_pBigCtx);
                                                        // DELTA * Uout^2
                OK = OK && mod_mul(Uout, Vout, Uout, modulo,
                                   modmultemps, f_pBigCtx);
                                                        // Uout * Vout
                OK = OK && mod_mul(Vout, Vout, Vout, modulo,
                                   modmultemps, f_pBigCtx);
                                                        // Vout^2
                OK = OK && add_mod(Vout, temp1, Vout, modulo->modulus, modulo->length );
                                                        // Vout^2 + DELTA*Uout^2
                OK = OK && mod_shift(Vout, -1, Vout, modulo);
                                                        // (Vout^2 + DELTA*Uout^2)/2

                if (mp_getbit(exponent, bits_left) != 0) {

                    // Replace 2*n by 2*n + 1
                    // (U, V) := (C1*U + V, C1*V + DELTA*U)/2

                    OK = OK && mod_mul(DELTA, Uout, temp1, modulo,
                                       modmultemps, f_pBigCtx);
                    OK = OK && mod_mul(C1, Uout, Uout, modulo,
                                       modmultemps, f_pBigCtx);
                    OK = OK && add_mod(Uout, Vout, Uout, modulo->modulus, modulo->length);
                    OK = OK && mod_shift(Uout, -1, Uout, modulo);

                    OK = OK && mod_mul(C1, Vout, Vout, modulo,
                                       modmultemps, f_pBigCtx);
                    OK = OK && add_mod(Vout, temp1, Vout, modulo->modulus, modulo->length);
                    OK = OK && mod_shift(Vout, -1, Vout, modulo);
                }
            } /* while */
        }
        if (dtemps != NULL) {
            Free_Temporaries(dtemps, f_pBigCtx);
        }
    }
    return OK;
} /* mod_LucasUV */

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\modmulch1.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bigpriv.h"

ENTER_PK_NAMESPACE_CODE;

/*
       File modmulch1.c.   Version 1 October, 2002.

            This is the first of several modmulchx files with algorithms for
        modular multiplication, both FROM_LEFT and FROM_RIGHT.
        All procedures have an argument list

            (const digit_t *a, *b,           // Two numbers to multiply
                                        // 0 <= a, b < modulus
             digit_t  *c                // Product.  May overlap a or b.
             const mp_modulus_t *pmodulo,    // Struct with information about modulus
             digit_t  *temps,           // Temporaries (length
                                        //     pmodulo->modmul_algorithm_temps)
             struct bigctx_t *f_pBigCtx)

            FROM_LEFT codes return

                c == (a*b) mod modulus

            FROM_RIGHT codes return the Montgomery product

               c == a*b / RADIX^lng  (mod pmodulo->modulus).

        where lng = pmodulo->length.

            This file contains

                modmul_from_left_default
                modmul_from_right_default

        which work on all architectures and lengths.
*/
/******************************************************************************/
static DRM_NO_INLINE DRM_BOOL DRM_CALL modmul_from_left_default
        (const digit_t *a,              // IN
         const digit_t *b,              // IN
         digit_t  *c,              // OUT
         const mp_modulus_t *pmodulo,   // IN
         digit_t  *temps )          // TEMPORARIES, at least 2*lng         
/*
        This implements ordinary modular multiplication.
    Given inputs a, b with 0 <= a, b < modulus < RADIX^lng,
    and where lng > 0, we form

           c == (a*b) mod modulus.
*/
{
    DRM_BOOL OK = TRUE;
    const DRM_DWORD lng = pmodulo->length;
    digit_t *temp1 = temps;     // Length 2*lng

    DRMASSERT (pmodulo->modmul_algorithm_temps == 2*lng);
    OK = OK && multiply(a, lng, b, lng, temp1);     // Double-length product
    OK = OK && divide(temp1, 2*lng, pmodulo->modulus, lng,
                    &pmodulo->left_reciprocal_1, NULL, c);
    return OK;
}  // modmul_from_left_default
/******************************************************************************/


/*
**  General case for mutiplication of arbirtrary long integers 
*/



DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL modmul_from_right_default( 
    IN      const digit_t      *a,
    IN      const digit_t      *b,
    OUT           digit_t      *c,
    IN      const mp_modulus_t *pmodulo,   
    IN OUT        digit_t      *temps )    // TEMPORARIES, at least 2*lng    
/*
        This implements Montgomery (FROM_RIGHT) multiplication.     
    Let lng = pmodulo->length > 0.
    Given inputs a, b with 0 <= a, b < pmodulo->modulus < RADIX^lng, we form

           c == a*b / RADIX^lng  (mod pmodulo->modulus).

        At the start of the loop on i, there exists templow
    (formed by the discarded values of
    DRM_UI64Low32(prod1) = DRM_UI64Low32(prod2)) such that

               0 <= temp1, temp2 < modulus
               temp1*RADIX^j + templow = b[0:j-1] * a
               temp2*RADIX^j + templow == 0 (mod modulus)

    When j = lng, we exit with c == temp1 - temp2 (mod modulus)
*/
{
    DRM_BOOL OK = TRUE;
    const DRM_DWORD lng = pmodulo->length;
    digit_t *temp1 = temps, *temp2 = temps + lng;   // Both length lng
    const digit_t *modulus = pmodulo->modulus;
    const digit_t minv = pmodulo->right_reciprocal_1;
    const digit_t minva0 = minv*a[0];    // mod RADIX
    DRM_DWORD i, j;
    digit_t carry1, carry2, mul1, mul2;
    DRM_UINT64 carryfull;
    DRM_UINT64 prod1, prod2;

    DRMASSERT (pmodulo->modmul_algorithm_temps == 2*lng);
 // Case j = 0 of main loop, with temp1 = temp2 = 0 beforehand.
    mul1 = b[0];
    mul2 = minva0*mul1;   // Modulo RADIX
    
    carryfull = DPRODUU(mul1, a[0]); 
    carry1 = DRM_UI64High32(carryfull);
    
    carryfull = DPRODUU(mul2, modulus[0]);
    carry2 = DRM_UI64High32( carryfull );
    
    DRMASSERT (mul1*a[0] == mul2*modulus[0]);     // mod RADIX

    for (i = 1; i != lng; i++) {
        prod1 = MULTIPLY_ADD1(mul1,       a[i], carry1);
        prod2 = MULTIPLY_ADD1(mul2, modulus[i], carry2);
        temp1[i-1] = DRM_UI64Low32(prod1);
        temp2[i-1] = DRM_UI64Low32(prod2);
        carry1 = DRM_UI64High32(prod1);
        carry2 = DRM_UI64High32(prod2);
    }
    temp1[lng-1] = carry1;
    temp2[lng-1] = carry2;

    for (j = 1; j != lng; j++) {
        mul1 = b[j];
        mul2 = minva0*mul1 + minv*(temp1[0] - temp2[0]);  // Modulo RADIX
        prod1 = MULTIPLY_ADD1(mul1, a[0], temp1[0]);
        prod2 = MULTIPLY_ADD1(mul2, modulus[0], temp2[0]);

        // Replace temp1 by (temp1 + b[j]*a - DRM_UI64Low32(prod1))/RADIX
        // Replace temp2 by (temp2 + mul2*modulus - DRM_UI64Low32(prod2))/RADIX

        DRMASSERT (DRM_UI64Low32(prod1) == DRM_UI64Low32(prod2));

        carry1 = DRM_UI64High32(prod1);
        carry2 = DRM_UI64High32(prod2);

        for (i = 1; i != lng; i++) {
            prod1 = MULTIPLY_ADD2(mul1,       a[i], temp1[i], carry1);
            prod2 = MULTIPLY_ADD2(mul2, modulus[i], temp2[i], carry2);
            temp1[i-1] = DRM_UI64Low32(prod1);
            temp2[i-1] = DRM_UI64Low32(prod2);
            carry1 = DRM_UI64High32(prod1);
            carry2 = DRM_UI64High32(prod2);
        }
        temp1[lng-1] = carry1;
        temp2[lng-1] = carry2;
    }
    OK = OK && sub_mod(temp1, temp2, c, modulus, lng);
    return OK;
} // modmul_from_right_default;

 
/**********************************************************************
** modmul_from_right_default_modulo5 when the size of big integer is 160 bits 
** Performance improved due to access to local temporary array 
** and loop unrolling.
***********************************************************************/

static DRM_NO_INLINE DRM_BOOL DRM_CALL modmul_from_right_default_modulo5( 
    IN      const digit_t      *a,
    IN      const digit_t      *b,
    OUT           digit_t      *c,
    IN      const mp_modulus_t *pmodulo,   
    IN OUT        digit_t      *temps )    // TEMPORARIES, at least 2*lng    
/*
**     This is exactly the same as modmul_from_right_default
**     in the case of pmodulo->length equal to 5
*/
{
    DRM_BOOL OK = TRUE;   
    digit_t temp1[LNGQ_MODULO_5], temp2[LNGQ_MODULO_5];   // Both length LNGQ_MODULO_5
    const digit_t *modulus = pmodulo->modulus;
    const digit_t minv = pmodulo->right_reciprocal_1;
    const digit_t minva0 = minv*a[0];    // mod RADIX
    DRM_DWORD j;
    DRM_UINT64 carry1full, carry2full;
    digit_t mul1, mul2;
    DRM_UINT64 prod1, prod2;

    DRMASSERT (pmodulo->modmul_algorithm_temps == 2*LNGQ_MODULO_5);

 // Case j = 0 of main loop, with temp1 = temp2 = 0 beforehand.
    mul1 = b[0];
    mul2 = minva0*mul1;   // Modulo RADIX
    carry1full = DPRODUU(mul1, a[0]      );
    carry2full = DPRODUU(mul2, modulus[0]);

    DRMASSERT (mul1*a[0] == mul2*modulus[0]);     // mod RADIX
    DRMASSERT ( pmodulo->length == LNGQ_MODULO_5 );

    prod1 = MULTIPLY_ADD1(mul1,       a[1], DRM_UI64High32(carry1full));
    prod2 = MULTIPLY_ADD1(mul2, modulus[1], DRM_UI64High32(carry2full));
    temp1[0] = DRM_UI64Low32(prod1);
    temp2[0] = DRM_UI64Low32(prod2);
    
    prod1 = MULTIPLY_ADD1(mul1,       a[2], DRM_UI64High32(prod1));
    prod2 = MULTIPLY_ADD1(mul2, modulus[2], DRM_UI64High32(prod2));
    temp1[1] = DRM_UI64Low32(prod1);
    temp2[1] = DRM_UI64Low32(prod2);
    
    prod1 = MULTIPLY_ADD1(mul1,       a[3], DRM_UI64High32(prod1));
    prod2 = MULTIPLY_ADD1(mul2, modulus[3], DRM_UI64High32(prod2));
    temp1[2] = DRM_UI64Low32(prod1);
    temp2[2] = DRM_UI64Low32(prod2);

    prod1 = MULTIPLY_ADD1(mul1,       a[4], DRM_UI64High32(prod1));
    prod2 = MULTIPLY_ADD1(mul2, modulus[4], DRM_UI64High32(prod2));
    temp1[3] = DRM_UI64Low32(prod1);
    temp2[3] = DRM_UI64Low32(prod2);
    
    temp1[4] = DRM_UI64High32(prod1);
    temp2[4] = DRM_UI64High32(prod2);

    for (j = 1; j != LNGQ_MODULO_5; j++) {
        mul1 = b[j];
        mul2 = minva0*mul1 + minv*(temp1[0] - temp2[0]);  // Modulo RADIX
        prod1 = MULTIPLY_ADD1(mul1, a[0], temp1[0]);
        prod2 = MULTIPLY_ADD1(mul2, modulus[0], temp2[0]);

        // Replace temp1 by (temp1 + b[j]*a - DRM_UI64Low32(prod1))/RADIX
        // Replace temp2 by (temp2 + mul2*modulus - DRM_UI64Low32(prod2))/RADIX

        DRMASSERT (DRM_UI64Low32(prod1) == DRM_UI64Low32(prod2));

        prod1 = MULTIPLY_ADD2(mul1,       a[1], temp1[1], DRM_UI64High32(prod1));
        prod2 = MULTIPLY_ADD2(mul2, modulus[1], temp2[1], DRM_UI64High32(prod2));
        temp1[0] = DRM_UI64Low32(prod1);
        temp2[0] = DRM_UI64Low32(prod2);
        
        prod1 = MULTIPLY_ADD2(mul1,       a[2], temp1[2], DRM_UI64High32(prod1));
        prod2 = MULTIPLY_ADD2(mul2, modulus[2], temp2[2], DRM_UI64High32(prod2));
        temp1[1] = DRM_UI64Low32(prod1);
        temp2[1] = DRM_UI64Low32(prod2);
        
        prod1 = MULTIPLY_ADD2(mul1,       a[3], temp1[3], DRM_UI64High32(prod1));
        prod2 = MULTIPLY_ADD2(mul2, modulus[3], temp2[3], DRM_UI64High32(prod2));
        temp1[2] = DRM_UI64Low32(prod1);
        temp2[2] = DRM_UI64Low32(prod2);
        
        prod1 = MULTIPLY_ADD2(mul1,       a[4], temp1[4], DRM_UI64High32(prod1));
        prod2 = MULTIPLY_ADD2(mul2, modulus[4], temp2[4], DRM_UI64High32(prod2));
        temp1[3] = DRM_UI64Low32(prod1);
        temp2[3] = DRM_UI64Low32(prod2);
        
        temp1[4] = DRM_UI64High32(prod1);
        temp2[4] = DRM_UI64High32(prod2);
        
    }
    OK = OK && sub_mod(temp1, temp2, c, modulus, LNGQ_MODULO_5);
    return OK;
} // modmul_from_right_default_modulo5;

/**********************************************************************
** modmul_from_right_default_modulo8 when the size of big integer is 256 bits 
** Performance improved due to access to local temporary array 
** and loop unrolling.
***********************************************************************/

DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL modmul_from_right_default_modulo8( 
    IN      const digit_t      *a,
    IN      const digit_t      *b,
    OUT           digit_t      *c,
    IN      const mp_modulus_t *pmodulo,   
    IN OUT        digit_t      *temps )    // TEMPORARIES, at least 2*lng    
/*
**     This is exactly the same as modmul_from_right_default
**     in the case of pmodulo->length equal to 8
*/
{
    DRM_BOOL OK = TRUE;   
    digit_t temp1[LNGQ_MODULO_8], temp2[LNGQ_MODULO_8];   // Both length 8
    const digit_t *modulus = pmodulo->modulus;
    const digit_t minv = pmodulo->right_reciprocal_1;
    const digit_t minva0 = minv*a[0];    // mod RADIX
    DRM_DWORD j;
    DRM_UINT64 carry1full, carry2full;
    digit_t mul1, mul2;
    DRM_UINT64 prod1, prod2;

    DRMASSERT (pmodulo->modmul_algorithm_temps == 2*LNGQ_MODULO_8);

 // Case j = 0 of main loop, with temp1 = temp2 = 0 beforehand.
    mul1 = b[0];
    mul2 = minva0*mul1;   // Modulo RADIX
    carry1full = DPRODUU(mul1, a[0]      );
    carry2full = DPRODUU(mul2, modulus[0]);

    DRMASSERT (mul1*a[0] == mul2*modulus[0]);     // mod RADIX
    DRMASSERT ( pmodulo->length == LNGQ_MODULO_8 );

    prod1 = MULTIPLY_ADD1(mul1,       a[1], DRM_UI64High32(carry1full));
    prod2 = MULTIPLY_ADD1(mul2, modulus[1], DRM_UI64High32(carry2full));
    temp1[0] = DRM_UI64Low32(prod1);
    temp2[0] = DRM_UI64Low32(prod2);
    
    prod1 = MULTIPLY_ADD1(mul1,       a[2], DRM_UI64High32(prod1));
    prod2 = MULTIPLY_ADD1(mul2, modulus[2], DRM_UI64High32(prod2));
    temp1[1] = DRM_UI64Low32(prod1);
    temp2[1] = DRM_UI64Low32(prod2);
    
    prod1 = MULTIPLY_ADD1(mul1,       a[3], DRM_UI64High32(prod1));
    prod2 = MULTIPLY_ADD1(mul2, modulus[3], DRM_UI64High32(prod2));
    temp1[2] = DRM_UI64Low32(prod1);
    temp2[2] = DRM_UI64Low32(prod2);

    prod1 = MULTIPLY_ADD1(mul1,       a[4], DRM_UI64High32(prod1));
    prod2 = MULTIPLY_ADD1(mul2, modulus[4], DRM_UI64High32(prod2));
    temp1[3] = DRM_UI64Low32(prod1);
    temp2[3] = DRM_UI64Low32(prod2);
    
    prod1 = MULTIPLY_ADD1(mul1,       a[5], DRM_UI64High32(prod1));
    prod2 = MULTIPLY_ADD1(mul2, modulus[5], DRM_UI64High32(prod2));
    temp1[4] = DRM_UI64Low32(prod1);
    temp2[4] = DRM_UI64Low32(prod2);
    
    prod1 = MULTIPLY_ADD1(mul1,       a[6], DRM_UI64High32(prod1));
    prod2 = MULTIPLY_ADD1(mul2, modulus[6], DRM_UI64High32(prod2));
    temp1[5] = DRM_UI64Low32(prod1);
    temp2[5] = DRM_UI64Low32(prod2);
    
    prod1 = MULTIPLY_ADD1(mul1,       a[7], DRM_UI64High32(prod1));
    prod2 = MULTIPLY_ADD1(mul2, modulus[7], DRM_UI64High32(prod2));
    temp1[6] = DRM_UI64Low32(prod1);
    temp2[6] = DRM_UI64Low32(prod2);


    temp1[7] = DRM_UI64High32(prod1);
    temp2[7] = DRM_UI64High32(prod2);

    for (j = 1; j != LNGQ_MODULO_8; j++) {
        mul1 = b[j];
        mul2 = minva0*mul1 + minv*(temp1[0] - temp2[0]);  // Modulo RADIX
        prod1 = MULTIPLY_ADD1(mul1, a[0], temp1[0]);
        prod2 = MULTIPLY_ADD1(mul2, modulus[0], temp2[0]);

        // Replace temp1 by (temp1 + b[j]*a - DRM_UI64Low32(prod1))/RADIX
        // Replace temp2 by (temp2 + mul2*modulus - DRM_UI64Low32(prod2))/RADIX

        DRMASSERT (DRM_UI64Low32(prod1) == DRM_UI64Low32(prod2));

        prod1 = MULTIPLY_ADD2(mul1,       a[1], temp1[1], DRM_UI64High32(prod1));
        prod2 = MULTIPLY_ADD2(mul2, modulus[1], temp2[1], DRM_UI64High32(prod2));
        temp1[0] = DRM_UI64Low32(prod1);
        temp2[0] = DRM_UI64Low32(prod2);
        
        prod1 = MULTIPLY_ADD2(mul1,       a[2], temp1[2], DRM_UI64High32(prod1));
        prod2 = MULTIPLY_ADD2(mul2, modulus[2], temp2[2], DRM_UI64High32(prod2));
        temp1[1] = DRM_UI64Low32(prod1);
        temp2[1] = DRM_UI64Low32(prod2);
        
        prod1 = MULTIPLY_ADD2(mul1,       a[3], temp1[3], DRM_UI64High32(prod1));
        prod2 = MULTIPLY_ADD2(mul2, modulus[3], temp2[3], DRM_UI64High32(prod2));
        temp1[2] = DRM_UI64Low32(prod1);
        temp2[2] = DRM_UI64Low32(prod2);
        
        prod1 = MULTIPLY_ADD2(mul1,       a[4], temp1[4], DRM_UI64High32(prod1));
        prod2 = MULTIPLY_ADD2(mul2, modulus[4], temp2[4], DRM_UI64High32(prod2));
        temp1[3] = DRM_UI64Low32(prod1);
        temp2[3] = DRM_UI64Low32(prod2);
        

        prod1 = MULTIPLY_ADD2(mul1,       a[5], temp1[5], DRM_UI64High32(prod1));
        prod2 = MULTIPLY_ADD2(mul2, modulus[5], temp2[5], DRM_UI64High32(prod2));
        temp1[4] = DRM_UI64Low32(prod1);
        temp2[4] = DRM_UI64Low32(prod2);
        
        prod1 = MULTIPLY_ADD2(mul1,       a[6], temp1[6], DRM_UI64High32(prod1));
        prod2 = MULTIPLY_ADD2(mul2, modulus[6], temp2[6], DRM_UI64High32(prod2));
        temp1[5] = DRM_UI64Low32(prod1);
        temp2[5] = DRM_UI64Low32(prod2);
        
        prod1 = MULTIPLY_ADD2(mul1,       a[7], temp1[7], DRM_UI64High32(prod1));
        prod2 = MULTIPLY_ADD2(mul2, modulus[7], temp2[7], DRM_UI64High32(prod2));
        temp1[6] = DRM_UI64Low32(prod1);
        temp2[6] = DRM_UI64Low32(prod2);
        
        
        temp1[7] = DRM_UI64High32(prod1);
        temp2[7] = DRM_UI64High32(prod2);
        
    }
    OK = OK && sub_mod(temp1, temp2, c, modulus, 8);
    return OK;
} // modmul_from_right_default_modulo8;

/******************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL modmul_choices1
        (mp_modulus_t *pmodulo,        // IN/OUT
         DRM_INT          *pindex )         // IN/OUT         
/*
            This procedure (and any other modmul_choicesX ones it calls)
        looks for a suitable modmul_algorithm.  The selection algorithm
        can look at:

              1)  The target architecture (if there is a known target with assembly available)
              2)  Instruction-availability flags
              3)  Fields in the pmodulo struct, such as the length and the
                  FROM_LEFT/FROM_RIGHT flag.  A Karatsuba routine might
                  accept only moduli beyond a specific length.
                  Another routine might accept only Mersenne prime moduli.

            Each modmul_algorithm should be able to do both squarings and
        general multiplications.  It might branch to separate squaring code,
        but that check will be made when the routine is called, not now.

            If *pindex = 5 (say) on entry, then the fifth qualifying routine
        will be used.  During testing, the test routine calls this once
        with *pindex = 0, ending with *pindex = -k where k is the number
        of routines accepting this modulus.  Then it makes one call each with
        *pindex = 1, 2, ..., k, checking that all k procedures
        give consistent results (and perhaps comparing their timings).
        During production, the second call uses *pindex = k, and the
        final qualifying one is chosen.  For this reason, faster codes
        (typically assembly language versions) should appear last.

            Each routine accepting the modulus should save its address,
        its name, and the number of digit_t temporaries it will need.
*/
{
    DRM_BOOL OK = TRUE;
    DRM_INT index = *pindex;
    const DRM_DWORD lng = pmodulo->length;

    if (pmodulo->reddir == FROM_LEFT) {
        index--;
        if (index >= 0) {
            pmodulo->modmul_algorithm = modmul_from_left_default;            
            pmodulo->modmul_algorithm_temps = 2*lng;
        }
    } else if (pmodulo->reddir == FROM_RIGHT) {
        index--;
        if (index >= 0) 
        { /*  If the lenght of the modulo is 5, then we have special 
          **  function that optimized for 5.
          **  It is used in ECC 160 algorithms.
          **  RSA uses lenght of 16, 17 and 32. 
          **  Generic implementation for these cases is modmul_from_right_default
          */
            
            if ( pmodulo->length == LNGQ_MODULO_5 )
            {
                pmodulo->modmul_algorithm = modmul_from_right_default_modulo5;
            }
            else if ( pmodulo->length == LNGQ_MODULO_8 )
            {   
                pmodulo->modmul_algorithm = modmul_from_right_default_modulo8;
            }
            else 
            {   
                pmodulo->modmul_algorithm = modmul_from_right_default;
            }

            pmodulo->modmul_algorithm_temps = 2*lng;
        }
    } 
    *pindex = index;
    return OK;
} // end modmul_choices1

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\modsqrt.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bignum.h"
#include "mprand.h"

ENTER_PK_NAMESPACE_CODE;
/*
//      DRM_BOOL mod_sqrt(base, answer, modulo, psquare) --
//              Compute a square root
//              answer = +- sqrt(base) mod modulo->modulus.
//              modulo->modulus should be a prime.
//              Set *psquare = TRUE if successful, FALSE if unsuccessful
*/
/***************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL mod_sqrt
        (const digit_t       base[],           // IN
         digit_t        answer[],         // OUT
         const mp_modulus_t *modulo,           // IN
         DRM_BOOL          *pperfect_square,  // OUT
         struct bigctx_t *f_pBigCtx)
/*
        Compute a square root answer = +- sqrt(base) mod modulo->modulus.
        modulo->modulus should be prime.
        Set *perfect_square = TRUE is successful, FALSE if not.

        base and answer must not overlap.
*/
{
    DRM_BOOL        OK             = TRUE;
    DRM_BOOL        perfect_square = TRUE;
    const DRM_DWORD   elng           = modulo->length;
    digit_t    *dtemps         = NULL;

    if ((elng > 0) &&
        (6*elng + modulo->modmul_algorithm_temps > 6*elng))  /* check for integer underflow/overflow */
    {
        dtemps = digit_allocate(6*elng + modulo->modmul_algorithm_temps, "mod_sqrt", f_pBigCtx);
    }
    
    if (dtemps == NULL) {
        OK = FALSE;
    } else if (base == NULL || answer == NULL) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_NULL_POINTER, "mod_sqrt");
    } else if (base == answer) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_OVERLAPPING_ARGS, "mod_sqrt");
    } else if (significant_digit_count(base,  elng) == 0) {
        perfect_square = TRUE;
        MEMCPY( answer,base,( elng)*SIZEOF( digit_t ));      // sqrt(0) = 0
    } else {
        DRM_INT ntry = 0;
        DRM_BOOL verified = FALSE;
        digit_t *C0 = dtemps;
        digit_t *exponent = dtemps + elng;
        digit_t *temp1 = dtemps + 2*elng;
        digit_t *temp2 = dtemps + 3*elng;
        digit_t *U = dtemps + 4*elng;
        digit_t *V = dtemps + 5*elng;
        digit_t *modmultemps = dtemps + 6*elng;

        switch (modulo->modulus[0] & 7) {
        case 0:
        case 2:
        case 4:
        case 6:
            if (compare_immediate(modulo->modulus, 2, elng) == 0) {
                MEMCPY(answer, base, elng * SIZEOF( digit_t ) );// sqrt(x) == x mod 2
            } else {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                                "mod_sqrt -- not prime");
            }
            break;
        case 3:
        case 7:
                  // p == 3 mod 4
                  // Let answer == base^((p+1)/4)
                  // Then answer^2 == base*((p+1)/2) == base
                  //      if base is a square

            OK = OK && mp_shift(modulo->modulus, -2, exponent,
                                elng);// (p-3)/4
            if (OK) add_immediate(exponent, 1, exponent, elng);      // (p+1)/4
            OK = OK && mod_exp(base, exponent, elng,
                               answer, modulo, f_pBigCtx);
            break;
        case 5:
            // p == 5 mod 8.
            // Let temp1 == (2*base)^((p - 5)/8))
            // answer = base*temp1 * (2*base*temp1^2 - 1)
            // Then
            //      4*base^2 * temp1^4 = (2 * base)^(2 + (p-5)/2)
            //                         = (2 * base)^ ((p-1)/2) == -1
            //      if base is a square, since 2 is a non-residue.
            // Hence
            //      answer^2
            //       = (base*temp1)^2 * (4*base^2*temp1^4 - 4*base*temp1^2 + 1)
            //       == (base^2 * temp1^2) * (-4*base*temp1^2)
            //       == -4 * base^3 * temp1^4
            //       == base

            OK = OK && mp_shift(modulo->modulus, -3, exponent,
                                elng);// (p-5)/8
            OK = OK && add_mod(base, base, temp2,
                               modulo->modulus, modulo->length);    // 2*base
            OK = OK && mod_exp(temp2, exponent, elng, temp1,
                               modulo, f_pBigCtx);

            OK = OK && mod_mul(base, temp1, temp2, modulo,
                               modmultemps, f_pBigCtx);
                                    // temp2 = base*temp1
            OK = OK && mod_mul(temp2, temp1, temp1, modulo,
                               modmultemps, f_pBigCtx);
            OK = OK && add_mod(temp1, temp1, temp1, modulo->modulus, modulo->length);
            OK = OK && sub_mod(temp1, modulo->one, temp1,
                               modulo->modulus, modulo->length);
            OK = OK && mod_mul(temp2, temp1, answer, modulo,
                               modmultemps, f_pBigCtx);
                                   // answer = temp2 * (2*temp2*temp1 - 1)
            break;
        case 1:
            // p == 1 mod 8
            // Let C0 = base/4
            // Choose C1 in GF(p) randomly.
            // Let alpha, beta satisfy C1 = alpha + beta
            //                     and C0 = alpha * beta

            // Compute
            //        V = alpha^((p+1)/2) + beta^((p+1)/2)
            //        U = (alpha^((p+1)/2) - beta^((p+1)/2)) / (alpha - beta)

            // Observe X^2 - C1*X + C0 = (X - alpha) * (X - beta).

            // If alpha, beta in GF(p),
            //        then alpha^p = alpha and beta^p = beta
            //        (alpha*beta)^((p-1)/2) = C0^((p-1)/2) = 1.
            //        alpha^((p-1)/2) = beta^((p-1)/2)) = k, where k = +-1.
            //        U = (alpha^((p+1)/2) - beta^((p+1)/2)) / (alpha - beta)
            //          = (alpha*k - beta*k)/(alpha - beta) = +- 1.

            // Otherwise alpha, beta in GF(p^2) \ GF(p).
            //        Here alpha^p = beta and beta^p = alpha.
            //        Then V^2 = alpha^(p+1) + 2*(alpha*beta)^((p+1)/2)
            //                               + beta^(p+1)
            //                 = 2*alpha*beta + 2*C0^((p+1)/2)) = 4*C0 = base
            //        if base is a square.

            // In other words, either V^2 = base or U = +- 1,
            //        if base is a square.

            OK = OK && mod_shift(base, -2, C0,
                                 modulo);     // C0 = base/4
            OK = OK && mp_shift(modulo->modulus, -1, exponent,
                                elng);
                                                            // (p-1)/2 (even)
            exponent[0] |= 1;                               // (p+1)/2
            ntry = 0;
            while (OK && !verified) {
                ntry++;
                if (ntry > 100) {
                    OK = FALSE;
                    SetMpErrno_clue(MP_ERRNO_TOO_MANY_ITERATIONS,
                                    "mod_sqrt");
                }
                OK = OK && random_mod(modulo->modulus, temp1,
                                      elng, f_pBigCtx);   // C1
                OK = OK && mod_LucasUV(temp1, C0, exponent,
                                       elng, U, V, modulo, f_pBigCtx);
                OK = OK && mod_mul(V, V, temp2, modulo,
                                   modmultemps, f_pBigCtx);
                if (!OK) {
                } else if (compare_same(temp2, base, elng) == 0) {
                    verified = TRUE;
                    perfect_square = TRUE;
                    MEMCPY( answer,V,( elng)*SIZEOF( digit_t ));
                } else {
                    sub_same(modulo->modulus, modulo->one, temp1, elng);  // -1
                    if (OK && compare_same(U, modulo->one, elng) != 0
                           && compare_same(U, temp1, elng) != 0) {
                        verified = TRUE;
                        perfect_square = FALSE;
                                // non-residue or non-prime modulus
                    }
                }
            } // while
            break;
        } /* switch */

        if (!verified) {
            OK = OK && mod_mul(answer, answer, temp2, modulo,
                               modmultemps, f_pBigCtx);
            if (OK && compare_same(temp2, base, elng) != 0) {
                perfect_square = FALSE;
            }
        }
    }
    if (dtemps != NULL) {
        Free_Temporaries(dtemps, f_pBigCtx);
    }
    if (OK) *pperfect_square = perfect_square;
    return OK;
} /* mod_sqrt */

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\modexp.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bignum.h"

ENTER_PK_NAMESPACE_CODE;
/*
        File modexp.c.  Modular_exponentiation routines.    

        DRM_BOOL mod_exp(base, exponent, lngexpon,
                        answer, modulo)
                     -- Compute answer = base^exponent mod modulo->modulus.                        
                        The 2000 version of the code stores fewer
                        Karatsuba images, to reduce memory requirements
                        and hopefully improve cache utilization.
        
            Function mod_exp (modular exponentiation)
        computes b^e (modulo something).
        Here b and e are multiple precision, typically
        from 512 to 2048 bits.  We strive hard to keep
        the number of multiplications low.

            For a treatise on methods of exponentiation,
        see Section 4.6.3 of Donald E. Knuth, The Art of
        Computer Programming, Volume 2, Seminumerical Algorithms,
        2nd Edition, 1981.

            The classical left-to-right binary method of exponentiation
        (Knuth, p. 441) looks at one bit of the exponent at a
        time, starting from the most significant bit.
        It requires  log2(e) + (number of 1's in e) - 1
        multiplications (or squarings), which averages about
        (3/2)*log2(e) multiplications for a random exponent
        with log2(e)+1 bits.

            When e is large, this cost can be reduced by using
        radix 2^k for suitable k (Knuth, p. 446).
        The cost is 2^k - 2 multiplications to build a table with
        b^0 = 1,  b^1 = b,  b^2,  b^3,  ... ,  b^(2^k - 1).
        After this table is built, there will be about log2(e)/k steps
        consisting of k squarings and a multiplication by a table entry.
        The final multiply can be skipped when the table entry is
        b^0 = 1, which occurs with probability about 2^(-k).
        The approximate cost of the radix 2^k method (Knuth, p. 451) is

                              log2(e)           log2(e)
           2^k + (k+1-2^(-k)) -------  =  2^k + -------(1 - 2^(-k)) + log2(e)
                                 k                 k

            mod_exp1995 (no longer here) usea a modified method with radix
        2^k and cost about

                         log2(e)
(*)            2^(k-1) + -------  + log2(e).
                           k+1

        It resembled that in ``Fast square-and-multiply
        exponentiation for RSA'' by L. C. K. Hui and K.-Y. Lam,
        Electronics Letters, 18 August 1994, Volume 30, No, 17,
        pp. 1396-1397, Electronics Letters Online No. 19940949.

            The upcoming presentation assumes k = 6.
        A recursive formulation of the mod_exp1995 algorithm resembles

                if e is small then
                    Use table look-up for b^e
                else if e is even
                    Compute  b^e  as  (b^(e/2))^2
                else
                    Compute  b^e  as  (b^j)^64 * b^i,
                    where e = 64 * j + i and 0 <= i <= 63
                end if

        Except possibly when initializing the recursion
        (i.e., to compute b^e where e is `small'), the algorithm needs
        only the odd powers  b^1,  b^3,  b^5,  ...,  b^63.
        It costs 32 = 2^(k-1) multiplications to compute
        b^2 and this table.

            Half of the time this value of i
        (i.e., where e = 64*j + i) will be in [0, 31].
        In those cases, we can delay the multiplication by b^i
        for one step, merely replacing x by x^2 at this time
        and awaiting another bit of the exponent.
        This explains the denominator (k+1) in (*).

            The optimal k (i.e., the one requiring the fewest
        multiplications) depends upon the exponent e.
        According to (*), the value k is better than k-1 if

                      log2(e)                           log2(e)
            2^(k-1) + -------  + log2(e)  <   2^(k-2) + ------- + log2(e) .
                        k+1                                k

                                           log2(e)
        This is equivalent to  2^(k-2)  <  -------  and to
                                           k (k+1)

        log2(e) > k (k+1) 2^(k-2)


            k         Approximate log2(e)
                      where k first beats k-1

            2            6
            3           24
            4           80
            5          240
            6          672
            7         1680
            8         4608

        For a 1024-bit exponent, this analysis suggests using k = 6
        since 672 <= 1024 <= 1680.  The estimated costs
        for a 1024-bit exponent are

            k         2^(k-1) + 1024/(k + 1) + 1024

            1         1537
            2         1367.3
            3         1284
            4         1236.8
            5         1210.7
            6         1202.3
            7         1216
            8         1265.8

        The estimated costs for k = 5, 6, 7 vary by less than 1.2%.
        The precise costs will depend upon the bit pattern in
        the exponent.  The code tries multiple values of k,
        determining the cost associated with each radix,
        and selects the one with the smallest cost.

        mod_exp uses a window of width 2^k on the exponent.
        There are bucket_max = 2^k - 1 buckets bucket[1]
        to bucket[bucket_max], all initialized to 1.
        The final result is intended to be

           answer = bucket[1]^1 * bucket[2]^2 * bucket[3]^3 * ...
                                * bucket[bucket_max]^bucket_max

        Except during final processing, all even-numbered buckets
        are empty (i.e., contain 1)


*/

#if defined (_WIN32_WCE)
         // Opt for less memory under Windows CE
#define MAX_BUCKET_WIDTH 5
#else
#define MAX_BUCKET_WIDTH 6
#endif


typedef struct {         // Temps and interface for mod_exp and helpers                
        const mp_modulus_t   *modulo;
        DRM_BOOL             bucket_occupied[1L << MAX_BUCKET_WIDTH];
        digit_t         *bucket_location[1L << MAX_BUCKET_WIDTH];
        digit_t         *modmultemps;  // Length modmul_algorithm_temps
    } temps_t;


/***************************************************************************/

/*
      basepower_squaring and bucket_multiply are helpers to mod_exp.

      bucket_multiply multiplies the contents
      of bucket[ibucket] by multiply_by.

      basepower_squaring replaces basepower by basepower^2.

      The temps struct is used to share miscellaneous
      local and malloc-ed data with mod_exp.
*/

static DRM_BOOL DRM_CALL basepower_squaring(
        digit_t      *basepower,               // IN/OUT
        temps_t  *temps,                   // IN/OUT
        struct bigctx_t *f_pBigCtx)
{
    DRM_BOOL OK = TRUE;
    const mp_modulus_t *modulo = temps->modulo;        
    
    OK = OK && mod_mul(basepower, basepower, basepower,
                           modulo, temps->modmultemps, f_pBigCtx);    
    return OK;
} // end basepower_squaring



static DRM_BOOL bucket_multiply
        (const DRM_DWORD    ibucket,                  // IN
         const digit_t     multiply_by[],            // IN
         temps_t *temps,                    // IN/OUT
         struct bigctx_t *f_pBigCtx)
{
    DRM_BOOL OK = TRUE;
    digit_t       *bloc       = temps->bucket_location[ibucket];
    const mp_modulus_t *modulo     = temps->modulo;
    const DRM_DWORD      elng       = modulo->length;
    
    if (temps->bucket_occupied[ibucket]) {
        
        mod_mul(bloc, multiply_by, bloc, modulo,
                    temps->modmultemps, f_pBigCtx);        
    } else {
        temps->bucket_occupied[ibucket] = TRUE;
    
        MEMCPY( bloc,multiply_by,( elng)*SIZEOF( digit_t ));    
    }
    return OK;
} // end bucket_multiply




DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL mod_exp
        (const digit_t         base[],
         const digit_t         exponent[],
         const DRM_DWORD        lngexpon,
         digit_t          answer[],
         const mp_modulus_t   *modulo,         
         struct bigctx_t *f_pBigCtx)

{
    DRM_BOOL OK = TRUE;    
    const DRM_DWORD elng = modulo->length;
    const DRM_DWORD exponent_bits_used
             = mp_significant_bit_count(exponent, lngexpon);
    const unsigned short width_cutoffs[] = {6, 24, 80, 240, 672};
                                           // (k + 2)*(k + 3) * 2^k

    temps_t *temps = NULL;       // malloc-ed
    digit_t *basepower = answer;           // Same array used for both
    digit_t *bucket_data = NULL;     // malloc-ed

    DRM_DWORD bucket_mask, bucket_width, carried;
    DRM_DWORD ibit, ibucket, max_bucket, ndoubling;
    DRM_BOOL base2;

    bucket_width = 1;
    while (    bucket_width < MAX_BUCKET_WIDTH
            && (DRM_DWORD)width_cutoffs[bucket_width-1] < exponent_bits_used) {
        bucket_width++;
    }

    OK = OK && validate_modular_data(base, modulo->modulus, elng,
                                     "mod_exp");

    bucket_mask = (DIGIT_ONE << bucket_width) - 1;
    max_bucket = bucket_mask;   // Another name for the variable

    Allocate_Temporaries(temps_t, temps, f_pBigCtx);

    if ((elng == 0) ||
        (elng*max_bucket + modulo->modmul_algorithm_temps < elng*max_bucket)) /* check for integer underflow/overlfow */
    {
        bucket_data = NULL;
    }
    else
    {
        bucket_data = digit_allocate(elng*max_bucket + modulo->modmul_algorithm_temps,
                                     "mod_exp", f_pBigCtx);
    }
    
    OK = OK && (temps != NULL) && (bucket_data != NULL);

    base2 = FALSE;
    if (OK) {        
        temps->modulo = modulo;
        temps->bucket_location[0] = NULL;
        temps->modmultemps = bucket_data + elng*max_bucket;

        //  Check for base = 2.  When base = 2, use alternate algorithm.
        //  (squarings and doublings).

        OK = OK && add_mod(modulo->one, modulo->one,
                           bucket_data, modulo->modulus, modulo->length);
                                                        /* bucket_data = 2 */
        base2 = OK && compare_same(base, bucket_data, elng) == 0;
    }
    if (!OK) {
    } else if (base2 && exponent_bits_used != 0) {
        const DRM_DWORD shift_max = MIN(RADIX_BITS*elng, 1024);
        DRM_DWORD ibit;
        DRM_DWORD high_expon_bits = 0;
        DRM_BOOL high_bits_processed = FALSE;
        digit_t *dtemp = bucket_data; /* Some convenient temporary */

        /*
             Start at the most significant end of the exponent.
             Accumulate the first few bits in high_expon_bits.
             As long as 2^high_expon_bits is about the
             same size as the modulus, or smaller,
             continue this accumulation.

             While processing the lower bits of the exponent,
             do repeated squaring, plus a doubling
             where the exponent bit is 1.

        */
        for (ibit = exponent_bits_used; OK && (ibit--) != 0; /*null*/) {
            const DRM_DWORD iexpbit = (DRM_DWORD)mp_getbit(exponent,ibit);

            if (high_bits_processed) {
            
                OK = OK && mod_mul(dtemp, dtemp, dtemp,
                                   modulo, temps->modmultemps,
                                   f_pBigCtx);
                if (iexpbit != 0) {
                    OK = OK && add_mod(dtemp, dtemp, dtemp,
                                       modulo->modulus, modulo->length);
                }                
            } else {  /* high_bits_processed */
                high_expon_bits = 2*high_expon_bits + iexpbit;
                if (   ibit == 0
                    || 2*high_expon_bits >= shift_max) {

                    high_bits_processed = TRUE;
                    OK = OK && mod_shift(modulo->one,
                              (DRM_INT)high_expon_bits,
                              dtemp, modulo);

                }
            } /* high_bits_processed */
        } /* for ibit */
        temps->bucket_location[1] = dtemp;  /* For copy into answer */

        if (!high_bits_processed) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                            "mod_exp -- high_bits_processed = FALSE");
        }
    } else {  /* not base2 */

         // Partition bucket_data array into length-elng
         // pieces for individual buckets.
         // Allocate pieces for odd-numbered buckets
         // contiguously, to lessen cache conflicts.

        for (ibucket = 1; OK && ibucket <= max_bucket; ibucket++) {
            digit_t *bloc = bucket_data
                + elng*(ibucket - 1 + (IS_EVEN(ibucket) ? max_bucket : 0))/2;

            temps->bucket_location[ibucket] = bloc;
            temps->bucket_occupied[ibucket] = FALSE;
            
            MEMCPY( bloc,modulo->one,( elng)*SIZEOF( digit_t ));
                                                      // Set bucket contents = 1        
        }  // for ibucket
        
        if (OK) {
            MEMCPY( basepower,base,( elng)*SIZEOF( digit_t ));    // basepower = base
        }
        carried = 0;
        ndoubling = 0;

        for (ibit = 0; OK && ibit != exponent_bits_used; ibit++) {
            const digit_t bit_now = mp_getbit(exponent, ibit);

            // Want bucket[1]^1 * ... * bucket[max_bucket]^max_bucket
            //  * basepower^ (2^ndoublings * remaining exponent bits + carried)
            // 0 <= carried <= 2^(bucket_width + 2) - 1

            if (carried >> (bucket_width + 2) != 0) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                "mod_exp -- carried overflow");
            }

            if (bit_now != 0) {
                while (OK && ndoubling >= bucket_width + 1) {
                    if (IS_ODD(carried)) {
                        ibucket = carried & bucket_mask;
                        carried -= ibucket;
                        OK = OK && bucket_multiply(ibucket, basepower,
                                                   temps, f_pBigCtx);
                    }
                    OK = OK && basepower_squaring(basepower,
                                                  temps, f_pBigCtx);
                    carried /= 2;
                    ndoubling--;
                }
                carried |= (DRM_DWORD)1 << ndoubling;
            }
            ndoubling++;
        } // for ibit

        while (OK && carried != 0) {
            DRM_BOOL square_now = FALSE;

            if (carried <= max_bucket) {
                ibucket = carried;
            } else if (IS_EVEN(carried)) {
                square_now = TRUE;
            } else if (carried <= 3*max_bucket) {
                ibucket = max_bucket;
            } else {
                ibucket = carried & bucket_mask;
            }
            if (square_now) {
                carried /= 2;
                OK = OK && basepower_squaring(basepower,
                                              temps, f_pBigCtx);
            } else {
                carried -= ibucket;

                OK = OK && bucket_multiply(ibucket, basepower,
                                           temps, f_pBigCtx);
            }
        } // while carried

        for (ibucket = max_bucket; OK && ibucket >= 2; ibucket--) {
            if (temps->bucket_occupied[ibucket]) {
                DRM_BOOL found = FALSE;
                DRM_DWORD jbucket, jbucketlargest, kbucket;
                digit_t *bloci;

                // Try to find jbucket, kbucket, such that
                // jbucket+kbucket = ibucket, both occupied.

                if (IS_EVEN(ibucket)) {
                         // Defaults in case no jbucket found below
                    jbucketlargest = ibucket/2;
                } else {
                    jbucketlargest = 1;
                }
                for (jbucket = ibucket >> 1;
                    jbucket != ibucket && !found;
                    jbucket++) {

                    if (temps->bucket_occupied[jbucket]) {
                        jbucketlargest = jbucket;
                        found = temps->bucket_occupied[ibucket - jbucket];
                    }
                }
                jbucket = jbucketlargest;
                kbucket = ibucket - jbucket;

                   // Deposit ibucket contents at jbucket and kbucket.

                bloci = temps->bucket_location[ibucket];

                OK = OK && bucket_multiply(jbucket, bloci, temps, f_pBigCtx);

                OK = OK && bucket_multiply(kbucket, bloci, temps, f_pBigCtx);

            } // if ibucket occupied
        }  // for ibucket
    } // if base 2
    
    if (OK) {
        MEMCPY( answer,temps->bucket_location[1],( elng)*SIZEOF( digit_t ));
    }
    if (bucket_data != NULL) {
        Free_Temporaries(bucket_data, f_pBigCtx);
    }
    if (temps != NULL) {
        Free_Temporaries(temps, f_pBigCtx);
    } 
    return OK;
} // end mod_exp

#undef MAX_BUCKET_WIDTH

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\mpaddsubcmp.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bigpriv.h"
#include "drmsal.h"

ENTER_PK_NAMESPACE_CODE;

/*
        File mpaddsubcmp.c.  Add/subtract/compare routines.
        These are candidates for assembly code when
        porting this package to a new architecture.

        Many of these are low-level routines.
        Many return a carry flag (digit_t) rather than success/failure (DRM_BOOL).


OK = add_diff(a, lnga, b, lngb, c, pcarry)
                                           -- c := a + b, where lnga >= lngb.
                                              Return carry in *pcarry).

DRM_BOOL add_full(a, lng, b, lngb, c, plngc)
                                -- c := a + b, return length of c in *pargc,
                                   without knowing whether a or b is longer.

carry  = add_immediate(a, iadd, lnga, b)
                                    -- b := a + iadd, where iadd is a scalar.

OK = add_mod(a, b, c, modulus, lng);
                                    -- c := a + b (mod modulus), all length lng

carry  = add_same(a, b, c, lng)     -- c := a + b, where all have length lng.

carry  = add_sub_same(a, b, c, d, lng)
                                 -- d := a + b - c, where all have length lng.
                                    N.B.  carry may be negative.

icomp = compare_diff(a, lnga, b, lngb) -- Return sign of a - b, where a and b
                                          are allowed to have different lengths.

icomp = compare_same(a, b, lng)        -- Return sign of a - b, where a and b
                                          both have length lng.
                                          Declared inline in bignum.h.

icomp =  compare_sum_diff(a, lnga, b, lngb, c, lngc)
                    -- Return sign of a + b - c, where lengths are different.

icomp =  compare_sum_same(a, b, c, lng) -- Return sign of a + b - c,
                                          where all have length lng.

OK     = neg_mod(a, b, modulus, lng)   -- b := -a (mod modulus),
                                                             all length lng

OK = sub_diff(a, lnga, b, lngb, c, pborrow )
                                       -- c := a - b, where lnga >= lngb.
                                          Return borrow in *pborrow.

borrow = sub_immediate(a, isub, lnga, b)
                                    -- b := a - isub, where isub is a scalar.

OK = sub_mod(a, b, c, modulus, lng);
                                       -- c := a - b (mod modulus),
                                                      all length lng

borrow = sub_same(a, b, c, lng)        -- c := a - b, where all have length lng.

OK = validate_modular_data(data, modulus, lng, hint) --
                                      Validate 0 <= data < modulus, where
                                      data and modulus have length lng.
                                      If not, issue an error and return FALSE.

        Each routine (except multiply_low) returns a carry/borrow flag.
        Those returning TRYE/FALSE error flags have the struct bigctx_t *f_pBigCtx argument,
        which an error handler might need.

Assembly language note:

        If the architecture has fast add/subtract with carry/borrow
        instructions (e.g., ADC/SBB on Intel x86,
        ADDE/SUBE on PowerPC, addxcc/subxcc on 32-bit SPARCs),
        then that is the most natural way to code these routines.
                The Alpha architecture has CMPULT and CMPULE
        instructions to do unsigned compares (returning 0 or 1).
        It also has a conditional move.  A possible inner loop is

                sum = a[i] + carry;
                c[i] = b[i] + sum;
                if (sum != 0) carry = (c[i] < sum);

        for addition (c := a + b) and

                dif = a[i] - b[i];
                c[i] = dif - borrow;
                if (dif != 0) borrow = (a[i] < b[i]);
                                            [ or   a[i] < dif  ]

        for subtraction (c := a - b).  Each loop body has
        two adds/subtracts, one compare, and one conditional move
        (plus loads, stores, and loop control).

                The MIPS 32-bit R2000/R3000 architecture has SLTU
        for unsigned compares but lacks conditional moves
        (although later versions of the architecture have
        conditional moves on zero/nonzero).
        One can emulate the Alpha code, with explicit branches
        when sum == 0 or dif == 0 (and with the store into c[i]
        occupying the delay slot).  Or one can use SLTU twice, computing

                carry = (sum < carry) + (c[i] < sum);
                borrow = (dif < borrow) + (a[i] < b[i]);

        (three adds or subtracts, two SLTU).

                The Pentium IV architecture has ADC and SBB, but they are
        much slower than a regular add or subtract.  One solution inspects the
        upper bits of a[i], b[i], a[i] + b[i] + carry (mod 2^32)
        to identify whether a carry has occurred.  That is,

                ai = a[i];
                bi = b[i];
                sum = ai + bi + carry;
                carry = MAJORITY(ai, bi, ~sum) >> 31;

        The MAJORITY function acts bitwise, returning 1 wherever
        two (or all three) operands have a 1 bit, zero elsewhere.
        On the Pentium, it could expand to

                (ai | bi) ^ ( sum & (ai ^ bi))

        with (ai | bi) expanding as bi | (ai & bi).  Only three registers are
        needed for ai, bi, carry (with sum occupying same register as carry):

                 load ai and bi;
                 carry += ai;
                 ai ^= bi;           // ai ^ bi
                 carry += bi;        // sum = ai + bi + carry
                 bi |= ai;           // bi | (ai ^ bi) = ai | bi
                 store low part of carry
                 carry &= ai;        // sum & (ai ^ bi)
                 carry ^= bi;        // (ai | bi) ^ (sum & (ai ^ bi))
                 carry >>= 31;

        (two adds, four boolean, one shift).  On Pentium IV, the
        adds and boolean operations take 0.5 cycle each; shift takes
        4 cycles; ADC takes 8 cycles.

        Similarly, the inner loop of a subtraction a - b can have

                sum = ai - bi - borrow;
                borrow = MAJORITY(~ai, bi, sum) >> 31;

        with MAJORITY expanding as

                 ai ^ ( (ai ^ bi) | (ai ^ sum))

        These methods will work in SIMD (= MMX or SSE) mode,
        where no carry bit is available.
        They can be used when there are more than two operands,
        such as A + B - C.
*/
/***************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL add_diff
        (const digit_t    a[],       // IN
         const DRM_DWORD   lnga,      // IN
         const digit_t    b[],       // IN
         const DRM_DWORD   lngb,      // IN
         digit_t     c[],       // OUT
         digit_t    *pcarry)    // OUT         
/*
        Add c := a + b.
        Arrays a and c have length lnga and array b has length lngb,
        where lnga >= lngb.

        *pcarry is set to 1 if there is a carry out of the left of c.
        Otherwise *pcarry is set to 0.
        The store is suppressed if pcarry = NULL;
*/
{
    DRM_BOOL OK = TRUE;

    if (lnga < lngb || ((lnga | lngb) & DWORD_LEFT_BIT)) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "add_diff length conflict");
    } else {
        digit_t carry = add_same(a, b, c, lngb);
        carry = add_immediate(a + lngb, carry, c + lngb, lnga - lngb);
        if (pcarry != NULL) {
            *pcarry = carry;
        } else if (carry != 0) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_OVERFLOW,
                            "add_diff overflow");
        }
    }
    return OK;
}  /* add_diff */
/***************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL add_full
        (const digit_t  a[],       // IN
         const DRM_DWORD lnga,      // IN
         const digit_t  b[],       // IN
         const DRM_DWORD lngb,      // IN
         digit_t   c[],       // OUT
         DRM_DWORD *plngc)     // OUT         
/*
        Compute c = a + b, where either a or b may be longer.
        Set *plngc to MAX(lnga, lngb, length of c).

        If lnga and lngb are minimal (i.e., no leading zeros in a or b),
        then *plngc will be minimal too.
*/
{
    digit_t carry = 0;
    DRM_DWORD lngc;
    DRM_BOOL OK = TRUE;

    if (lnga < lngb) {
        OK = OK && add_diff(b, lngb, a, lnga, c, &carry);
        lngc = lngb;
    } else {
        OK = OK && add_diff(a, lnga, b, lngb, c, &carry);
        lngc = lnga;
    }
    if (OK) {
        if (carry != 0) c[lngc++] = carry;
        *plngc = lngc;
    }
    return OK;
} /* add_full */
/***************************************************************************/
DRM_API DRM_NO_INLINE digit_t DRM_CALL add_immediate
        (const digit_t   a[],        // IN
         const digit_t   iadd,       // IN
         digit_t    b[],        // IN
         const DRM_DWORD  lng)        // IN
/*
        Compute b = a + iadd, where iadd has length 1.
        Both a and b have length lng.
        Function value is carry out of leftmost digit in b.
*/
{
    digit_t carry = iadd;
    DRM_DWORD i;

    for (i = 0; i != lng; i++) {
        const digit_t bi = a[i] + carry;
        b[i] = bi;

        if (bi >= carry) { // No carry propagation
            if (a != b) {
                MEMCPY( b + i + 1,a + i + 1,( lng - i - 1)*SIZEOF( digit_t ));
            }
            return 0;
        }
        carry = 1;
    } // for i
    return carry;
}  // end add_immediate
/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL add_mod
        (const digit_t a[],         // IN
         const digit_t b[],         // IN
         digit_t  c[],         // OUT
         const digit_t modulus[],   // IN
         const DRM_DWORD lng)        // IN         
/*
    c := a + b (mod modulus),where 0 <= a, b < modulus
*/
{
    DRM_BOOL OK = TRUE;
    sdigit_t carry;

    if (lng == 0) {
        OK = FALSE;
    } else {
        const digit_t alead = a[lng-1], blead = b[lng-1], mlead = modulus[lng-1];
        DRM_INT itest;     // Sign of a + b - modulus

        if (alead >= mlead) {
            OK = OK && validate_modular_data(a, modulus, lng,
                                             "add_mod arg 1");
        }
        if (blead >= mlead) {
            OK = OK && validate_modular_data(b, modulus, lng,
                                             "add_mod arg 2");
        }

        if (OK) {

               // Try to determine whether a + b >= modulus
               // by looking only at the leading digits.

            if (blead > mlead - alead) {
                itest = +1;      // implies a + b > modulus
            } else if (mlead - alead - blead > 1) {
                itest = -1;      // implies a + b < modulus
            } else {
                itest = compare_sum_same(a, b, modulus, lng);
                                 // Compare a + b to modulus
            }

            if (itest >= 0) {
                carry = add_sub_same(a, b, modulus, c, lng);
                                                 // c = a + b - modulus
            } else {
                carry = (sdigit_t)add_same(a, b, c, lng);     // c = a + b
            }
            if (carry != 0) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                "add_mod");
            }
#if BIGNUM_EXPENSIVE_DEBUGGING
            OK = OK && validate_modular_data(c, modulus, lng,
                                              "add_mod result" );
#endif
        }
    }
    return OK;
} // end add_mod
/****************************************************************************/
DRM_API DRM_NO_INLINE digit_t DRM_CALL add_same
        (                    const digit_t  a[],     // IN
                             const digit_t  b[],     // IN
         __inout_ecount(lng) digit_t   c[],     // OUT          c := a + b
                             const DRM_DWORD lng)     // IN
/*
        c := a + b, where all operands have length lng.

        Function value is 1 if there is a carry out of the
        left of c.  Otherwise function value is zero.
*/
{
    digit_t carry = 0;
    DRM_DWORD i;

    for (i = 0; i < lng; i++) {
        const digit_t ai = a[i];
        const digit_t bi = b[i];

        carry += ai + bi;
        c[i] = carry;
        carry = (ai | bi) ^ ((ai ^ bi) & carry);  // MAJORITY(ai, bi, ~carry)
        carry >>= (RADIX_BITS - 1);
    } // for i
    return carry;
}  /* add_same */
/****************************************************************************/
DRM_API DRM_NO_INLINE sdigit_t DRM_CALL add_sub_same
        (                  const digit_t    a[],     // IN
                           const digit_t    b[],     // IN
                           const digit_t    c[],     // IN
         __out_ecount(lng) digit_t     d[],     // OUT
                           const DRM_DWORD   lng)     // IN
/*
        d := a + b - c, where all operands have length lng.

        Function value (0, 1, or -1) reflects any carry or
        borrow out of the left of d.
*/
{
    digit_t carry1 = 0, carry2 = 0;
    DRM_DWORD i;

    for (i = 0; i < lng; i++) {
        const digit_t ai = a[i];
        const digit_t bi = b[i];
        const digit_t ci = c[i];
        const digit_t sum1 = ai + bi + carry1;
        const digit_t sum2 = sum1 - ci - carry2;

        d[i] = sum2;
        carry1 = sum1 ^ ((sum1 ^ ai) | (sum1 ^ bi));  // MAJORITY(ai, bi, ~sum1)
        carry2 = sum1 ^ ((sum1 ^ ci) | (sum1 ^ sum2));
                                                    // MAJORITY(~sum1, ci, sum2)
        carry1 >>= (RADIX_BITS - 1);
        carry2 >>= (RADIX_BITS - 1);
    } // for i
    return (sdigit_t)carry1 - (sdigit_t)carry2;
}  /* add_sub_same */
/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_INT DRM_CALL compare_diff
        (const digit_t    a[],   // IN
         const DRM_DWORD   lnga,  // IN
         const digit_t    b[],   // IN
         const DRM_DWORD   lngb)  // IN

//        Compare two multiple precision numbers a (of length lnga)
//        and b (of length lngb).  Return the sign of a - b, namely

//                +1  if  a > b
//                 0  if  a = b  (after stripping leading zeros)
//                -1  if  a < b .

{
    DRM_DWORD la = lnga, lb = lngb;

    while (la > lb) {
        if (a[la-1] != 0) return +1;
        la--;
    }

    while (lb > la) {
        if (b[lb-1] != 0) return -1;
        lb--;
    }
    DRMASSERT(la == lb);

    while (la != 0) {
        if (a[la-1] != b[la-1]) return (a[la-1] > b[la-1] ? +1 : -1);
        la--;
    }
    return 0;
} // compare_diff
/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_INT DRM_CALL compare_same
        (const digit_t  a[],       // IN
         const digit_t  b[],       // IN
         const DRM_DWORD lng)       // IN
/*
        Compare two multiple precision numbers a and b each of length lng.
        Function value is the sign of a - b, namely

                          +1 if a > b
                           0 if a = b
                          -1 if a < b
*/
{
    DRM_DWORD i;
    for (i = lng; (i--) != 0; /*null*/) {
        if (a[i] != b[i]) return (a[i] > b[i] ? +1 : -1);
    }
    return 0;
}  /* compare_same */
/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_INT DRM_CALL compare_sum_diff
        (const digit_t     a[],
         const DRM_DWORD    lnga,
         const digit_t     b[],
         const DRM_DWORD    lngb,
         const digit_t     c[],
         const DRM_DWORD    lngc)
/*
//        Compare multiple-precision integers a, b, c, of lengths
//        lnga, lngb, lngc, respectively.  Return the sign of a + b - c, namely

//                +1  if  a + b > c
//                 0  if  a + b = c
//                -1  if  a + b < c
*/
{
    const DRM_DWORD lmax = MAX(MAX(lnga, lngb), lngc);
    DRM_DWORD i;
    DRM_INT sum_prev = 0;

    for (i = lmax; (i--) != 0; /*null*/) {
        const digit_t aval = (i >= lnga ? 0 : a[i]);
        const digit_t bval = (i >= lngb ? 0 : b[i]);
        const digit_t cval = (i >= lngc ? 0 : c[i]);
        digit_t  sum_now = aval + bval;

        DRMASSERT(sum_prev == 0 || sum_prev == -1);
        sum_prev += (sum_now < aval) - (sum_now < cval);  // -2, -1, 0, or +1
        sum_now -= cval;
              // Exit unless sum_now = sum_prev = 0 or -1
        if (   (digit_t)sum_prev != sum_now
            || ((sum_prev + 3) & 2) == 0) {   // If -2 or 1
            return ((sum_prev + 2) & 2) - 1;  // 1 if sum_prev > 0, else -1
        }
    }  // for i
    return sum_prev;     // 0 or -1
} // compare_sum_diff
/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_INT DRM_CALL compare_sum_same
       (const digit_t  a[],      // IN
        const digit_t  b[],      // IN
        const digit_t  c[],      // IN
        const DRM_DWORD lng)      // IN
/*
//        Compare multiple-precision integers a, b, c, all of length lng.
//        Return the sign of a + b - c, namely

//                +1  if  a + b > c
//                 0  if  a + b = c
//                -1  if  a + b < c
*/
{
    DRM_DWORD i;
    DRM_INT sum_prev = 0;

    for (i = lng; (i--) != 0; /*null*/) {
        const digit_t aval = a[i];
        const digit_t bval = b[i];
        const digit_t cval = c[i];
        digit_t  sum_now = aval + bval;

        DRMASSERT(sum_prev == 0 || sum_prev == -1);

        sum_prev += (sum_now < aval) - (sum_now < cval);  // -2, -1, 0, or +1
        sum_now -= cval;
              // Exit unless sum_now = sum_prev = 0 or -1
        if (   (digit_t)sum_prev != sum_now
            || ((sum_prev + 3) & 2) == 0) {   // If -2 or 1
            return ((sum_prev + 2) & 2) - 1;  // 1 if sum_prev > 0, else -1
        }
    }
    return sum_prev;     // 0 or -1
} // compare_sum_same
/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL neg_mod
        (                  const digit_t  a[],         // IN
         __out_ecount(lng) digit_t   b[],         // OUT
                           const digit_t  modulus[],   // IN
                           const DRM_DWORD lng )         // IN                           
/* b := -a (mod modulus), where 0 <= a < modulus */
{
    DRM_BOOL OK = TRUE;
    DRM_DWORD i;
    digit_t all_zero = 0;

    for (i = 0; i < lng; i++) {
        all_zero |= a[i];
        b[i] = a[i];
    } // First copy a to b

    if (all_zero != 0) {
        digit_t borrow = sub_same(modulus, b, b, lng);
        if (borrow != 0) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                            "neg_mod input");
        }
    }     // If not identically zero, subtract from modulo->modulus

#if BIGNUM_EXPENSIVE_DEBUGGING
    OK = OK && validate_modular_data(b, modulus, lng,
                                     "neg_mod result" );
#endif
    return OK;
} // end neg_mod
/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL sub_diff
        (const digit_t    a[],        // IN
         const DRM_DWORD   lnga,       // IN
         const digit_t    b[],        // IN
         const DRM_DWORD   lngb,       // IN
         digit_t     c[],        // OUT
         digit_t     *pborrow )  // OUT
/*
        Subtract c := a - b.
        Arrays a and c have length lnga and array b has length lngb,
        where lnga >= lngb.

        *pborrow is set to 1 if there is a borrow out of the left of a.
        Otherwise *pborrow is set to 0.
        This store is suppressed if pborrow = NULL.
*/
{
    DRM_BOOL OK = TRUE;

    if (lnga < lngb || ((lnga | lngb) & DWORD_LEFT_BIT)) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "sub_diff -- length conflict");
    } else {
        digit_t borrow = sub_same(a, b, c, lngb);
        borrow = sub_immediate(a + lngb, borrow, c + lngb, lnga - lngb);
        if (pborrow != NULL) {
            *pborrow = borrow;
        } else if (borrow != 0) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_OVERFLOW,
                            "sub_diff underflow");
        }
    }
    return OK;
}  /* sub_diff */
/****************************************************************************/
DRM_API DRM_NO_INLINE digit_t DRM_CALL sub_immediate
        (const digit_t  a[],   // IN
         const digit_t  isub,  // IN
         digit_t   b[],   // OUT
         const DRM_DWORD lng)   // IN
/*
        Compute b = a - isub, where isub has length 1.
        Both a and b have length lng.
        Function value is borrow out of leftmost digit in b.
*/
{
    digit_t borrow = isub;
    DRM_DWORD i;

    for (i = 0; i != lng; i++) {
        const digit_t ai = a[i];

        b[i] = ai - borrow;
        if (ai >= borrow) { // No carry propagation
            if (a != b) {
                MEMCPY( b + i + 1,a + i + 1,( lng - i - 1)*SIZEOF( digit_t ));
            }
            return 0;
        }
        borrow = 1;
    }  // for i
    return borrow;
} // end sub_immediate
/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL sub_mod
        (const digit_t a[],       // IN
         const digit_t b[],       // IN
         digit_t  c[],       // OUT
         const digit_t modulus[], // IN
         const DRM_DWORD lng )      // IN         
// c := a - b (mod modulus), where 0 <= a, b < modulus
{
    DRM_BOOL OK = TRUE;
    sdigit_t carry;

    if (lng == 0) {
        OK = FALSE;
    } else {
        const digit_t alead = a[lng-1], blead = b[lng-1], mlead = modulus[lng-1];
        DRM_INT itest;

        if (alead == blead) {
            itest = compare_same(a, b, lng-1);    // Sign of a - b
        } else {
            itest = (alead < blead ? -1 : +1);
        }

        if (itest < 0) {   // a < b, set c = a - b + modulus
            if (blead >= mlead && OK) {
                OK = validate_modular_data(b, modulus, lng,
                                           "sub_mod arg 2");
            }
            carry = add_sub_same(a, modulus, b, c, lng);
        } else {          // b <= a, set c = a - b
            if (alead >= mlead && OK) {
                OK = validate_modular_data(a, modulus, lng,
                                           "sub_mod arg 1");
            }
            carry = -(sdigit_t)sub_same(a, b, c, lng);     // c = a - b
        }
        if (!OK) {
        } else if (carry != 0) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR, "sub_mod");
        } else {
#if BIGNUM_EXPENSIVE_DEBUGGING
            OK = OK && validate_modular_data(c, modulus, lng,
                                             "sub_mod output" );
#endif
        }
    }
    return OK;
} // end sub_mod
/****************************************************************************/
DRM_API DRM_NO_INLINE digit_t DRM_CALL sub_same
        (                  const digit_t    a[],       // IN
                           const digit_t    b[],       // IN
         __out_ecount(lng) digit_t     c[],       // OUT
                           const DRM_DWORD   lng)       // IN
/*
        c := a - b, where all operands have length lng.

        Function value is 1 if there is a borrow out of the
        left of a.  Otherwise function value is zero.
*/
{
    digit_t borrow = 0;
    DRM_DWORD i;

    for (i = 0; i < lng; i++) {
        const digit_t ai = a[i];
        const digit_t bi = b[i];
        const digit_t sum = ai - bi - borrow;

        c[i] = sum;
        borrow = ai ^ ((ai ^ bi) | (ai ^ sum));  // MAJORITY(~ai, bi, sum)
        borrow >>= (RADIX_BITS - 1);
    } // for i
    return borrow;
}  /* sub_same */
/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL validate_modular_data
        (const digit_t   data[],          // IN
         const digit_t   modulus[],       // IN
         const DRM_DWORD  lng,             // IN
         const DRM_CHAR *hint )           // IN
{
    DRM_BOOL OK = TRUE;
    if (compare_same(data, modulus, lng) >= 0) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_MODULAR_TOO_BIG, hint);

#if BIGNUM_EXPENSIVE_DEBUGGING
        {
            DRM_DWORD j;
            for (j = 0; j != lng; j++) {
                TRACE( ( "data[%ld] = %x, modulus[%ld] = %x\n",
                        ( DRM_LONG )j, data[j], ( DRM_LONG )j, modulus[j] ) );
            } // for j
        }
#endif
    }
    return OK;
} // validate_modular_data

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\mpalloc.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bigpriv.h"

ENTER_PK_NAMESPACE_CODE;
/*
        File mpalloc.c.   Version 20 November, 2002


        This file has helpers for bignum allocation requests.
        The user must provide

             DRM_VOID* bignum_alloc(DRM_DWORD cblen)
             DRM_VOID  bignum_free(DRM_VOID *pvMem)
             DRM_VOID* bignum_realloc(DRM_VOID * pvMem, DRM_DWORD cblen)

        with semantics matching the standard C
        routines malloc, free, realloc.
        [bignum_realloc is not used as of November, 2002.]
       
    Application-callable routines and macros:

          digit_allocate(DRM_DWORD nelmt, const DRM_CHAR *name)

                 Allocates nelmt elements of type digit_t.
                 In debug mode, -name- will be used to identify this storage.

          possible_digit_allocate(digit_tempinfo_t *tempinfo,
                                          const DRM_CHAR *name)
                 For internal use only.  The tempinfo struct
                 holds the amount of data needed and a possible
                 address supplied (typically be the caller of the user).
                 Use the supplied address if not NULL,
                 but allocate if the supplied address is NULL.

 */


/*****************************************************************************/
DRM_API DRM_NO_INLINE digit_t* DRM_CALL digit_allocate(
    const DRM_DWORD     nelmt,
    const DRM_CHAR      *name,
    struct bigctx_t     *f_pBigCtx )
/*
   Allocate an array with nelmt digit_t elements.
   May return NULL if unsuccessful.
*/
{
    digit_t *temps = NULL;

    if ((nelmt > 0) &&
        (nelmt*SIZEOF(digit_t) > nelmt))  /* check for integer underflow/overflow */
    {
        temps = (digit_t*)bignum_alloc(nelmt*SIZEOF(digit_t), f_pBigCtx);
    }
    
    if (temps == NULL) {
        TRACE( ( "Cannot allocate %ld digit_t entities for %s\n",
               ( DRM_LONG )nelmt, name ) );
    }

    return temps;
} // end digit_allocate
/*****************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL possible_digit_allocate( 
    digit_tempinfo_t        *tempinfo,
    const char              *name,
    struct bigctx_t         *f_pBigCtx )
/*
        Look at tempinfo.address.  If this has a non-NULL
        pointer, assume this array has the required space for
        temporaries.  If tempinfo.address is NULL
        and tempinfo.nelmt > 0, then allocate a temporary array,
        storing its address in tempinfo.address, and set tempinfo.need_to_free.
*/
{
    DRM_BOOL OK = TRUE;

    if (tempinfo->need_to_free) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "possible_digit_allocate");
               // Caller is required to clear flag this beforehand.
    }

    if (OK && tempinfo->address == NULL
           && tempinfo->nelmt != 0) {

        tempinfo->address = digit_allocate(tempinfo->nelmt,
                                           name, f_pBigCtx);
        if (tempinfo->address == NULL) {
            OK = FALSE;
        } else {
            tempinfo->need_to_free = TRUE;
        }
    }
    return OK;
}  // end possible_digit_allocate
/*****************************************************************************/

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\modular.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bigpriv.h"
#include <drmpkcrypto.h>

ENTER_PK_NAMESPACE_CODE;
/*
        File modular.c.  Version 28 November 2002

                create_modulus(a, lnga, reddir, *modulo)
                        Initialize modulo for the modulus a,
                        of length lnga.  reddir can be FROM_LEFT
                        or FROM_RIGHT to specify whether
                        products are reduced from the left or
                        from the right.

                from_modular(a, b, modulo) --
                        The number a (mod modulo) is converted to
                        standard form and stored in b.

                mod_mul(a, b, c, modulo, temps) --
                        Compute c = a * b (mod modulo).

                mod_shift(a, shiftamt, b, modulo) --
                        Compute b = a * 2^shiftamt (mod modulo).
                        The shift count shiftamt can have either
                        sign, but the modulus must be
                        odd if the shift count is negative.
                        Cost is O(shiftamt) (for fixed modulo),
                        so huge values of shiftamt should be avoided.

               to_modular(a, lnga, b, modulo)  --
                        Convert a (of length lnga) to
                        its modular representation b.

               uncreate_modulus(modulo)
                        Release storage allocated by create_modulus
*/


/*
  (December, 1995, note)

       Here is the best way I have found so far to reduce 2048 bits
to 1024 bits.  If the (odd) modulus is N, the method uses two big constants

        Ninv512 = 1/N (mod 2^512)

        N1536 = N * Ninv512 (so N1536 == 1 mod 2^512).

Let the original 2048-bit number be x0.

Step 1)  Reduce to 1536 bits.  Replace x0 by

         x1 = (x0 - N1536 * (lower 512 bits of x0))/2^512.

         (N.B. x1 may be negative).
         Cost: One 512 x 1024-bit multiplication.

Step 2)  Compute q == x1 * Ninv512 (mod 2^512)

         Cost: One 512 x 512-bit multiplication (low half only)

Step 3)  Compute x2 = (x1 - q * N)/2^512.  If negative, add N.

         Cost: One 512 x 1024-bit multiplication,
               where the low 512 bits of the product are known.

In 1) and 3), the 1024-bit operand depends only on N,
         so any additions/subtractions needed to precondition
         the operand for Karatsuba need be done only once.
         The same 512-bit multiplier (bottom of x0, or q)
         is being used for two 512 x 512-bit multiplications,
         and need be preconditioned only once.

In 3), we can do the lower 512 x 512 multiplication with
two 256 x 256 multiplications since the low 512 bits of the product
are known.  Specifically, if we want (a1:a0)*(b1:b0)
where a1, a0, b1, b0 are 256 bits each, then it suffices
to compute a1*b1 and (a1 - a0)*(b1 - b0) if we know the bottom
512 bits of (a1:a0)*(b1:b0).

        The total reduction cost is 6 + 3 + 5 = 14
256 x 256-bit products, whereas the present scheme uses
the equivalent of 16 such products (computed by the classical algorithm).
I estimate the time for a 256 x 256-bit product to be 650 cycles
(on the Pentium), so the total reduction time
(after adding overhead for the additions) will be around 10000 cycles.

        We can do the 512 x 512 low product required by 2)
using 5 full 128 x 128 multiplication and 3 low
128 x 128 multiplications for a slight improvement.
Specifically, we can get the lower half of
(a3:a2:a1:a0) * (b3:b2:b1:b0) if we know
a0*b0, a1*b1, a2*b2, (a1 - a0)*(b1 - b0), (a2 - a0)*(b2 - b0),
and the lower halves of (a2 - a1)*(b2 - b1), a0*b3, a3*b0.

        Or we may skip the first reduction from 2048 to
1536 bits, and compute one 1024-bit q such that
q == x0/N (mod 2^1024) (lower half of 1024 x 1024-bit product).
Then take (x0 - q*N)/2^1024 where the lower half of q*N is known.
The computation of q can be done with eight 256 x 256-bit multiplications,
and q*N with two 512 x 512-bit multiplications, again
for fourteen 256 x 256-bit multiplications.

        If we try to reduce from the left rather than from the right, then
we can do something like 1) (using N1536 = 2^1536 + (number below N)
where N1536 is a multiple of N).  Then we have a 1536-bit remainder,
which we want to further-reduce to 1024 bits.
Define N1280 (slightly above 2^1280) similarly; one 256 x 1024
multiplication will reduce the remainder to 1280 bits.
We can estimate the final quotient at any time, if we
know the reciprocal of the divisor, but this seems to take
more work than working from the right.  It is still desirable to optimize
this case, to avoid the need to convert to/from Montgomery form
when the original exponent is small (e.g., when cubing a number).

        The length 1024 is in the padding table (see kara.c),
as is 512, so nothing is wasted when we pad those operands during
the multiplication.  For an irregular length, such as 608 bits,
the second reduction must be at least 608/2 = 304 bits,
and the first such entry is for 384 bits.  The first reduction
must then be at least 608 - 384 = 224 bits, and we could then
use the entry for 256 bits.  This would require taking
384 x 608 and 256 x 608 products, hence two 384 x 384 products
and three 256 x 256 products.  That is not presently implemented.
Instead, we use 384 bits for both reductions.
When the first padding length is an odd number of words
(namely 1 or 3), the total reduction will exceed the first padding length.

        Question:  Can we do two 2048-bit to 1024-bit
reductions any faster than a single reduction?
If so, we might want to design the exponentiation routine
to allow multiple concurrent exponentiations with same
exponent and modulus.  I am looking for a trick similar to
that used to compute two modular inverses using one
modular inversion and three multiplications:
1/x = y*(1/xy) and 1/y = x*(1/xy).

*/
/******************************************************************************/
/******************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL create_modulus
        (const digit_t       a[],
         const DRM_DWORD      lnga,
         const reddir_t      reddir,
         mp_modulus_t  *pmodulo,
         struct bigctx_t *f_pBigCtx,
         struct bigctx_t *pbigctxGlobal)
/*
        This routine computes modulus-dependent constants
        for the modulus -a-, and stores them in a
        mp_modulus_t structure.  See the struct declaration
        (in bignum.h) for a description of each field.

        Argument reddir should be FROM_RIGHT if one wants to use
        Montgomery-type reductions (from the right)
        rather than traditional reductions (from the left).
        The FROM_RIGHT option is available only if -a- is odd.
*/
{
    DRM_BOOL OK = TRUE;
    const DRM_DWORD lngred2 = (lnga + 1)/2;

    digit_t *dtemps_longterm
        = digit_allocate(3*lnga + lngred2,        "create_modulus_longterm",
                                                   pbigctxGlobal);
    digit_t *dtemps_shortterm
        = digit_allocate(2*lnga + 2*lngred2 + 1,  "create_modulus_shortterm",
                                                   f_pBigCtx);

    if (dtemps_shortterm == NULL || dtemps_longterm == NULL) {
        OK =  FALSE;
    } else if (lnga == 0 || a[lnga-1] == 0) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "create_modulus leading zero");
    } else {
        digit_t *mptmp1    = dtemps_shortterm;        // Length lnga + lngred2
        digit_t *quotient  = dtemps_shortterm + lnga + lngred2;
                                                      // Length lngred2 + 1
        digit_t *remainder = dtemps_shortterm + 1 + lnga + 2*lngred2;
                                                      // Length lnga
        digit_t mod0inv;
        DRM_DWORD i;

        pmodulo->modulus           = dtemps_longterm;           // Length lnga
             // N.B. uncreate_modulus assumes modulus comes first
        pmodulo->one               = dtemps_longterm +   lnga;  // Length lnga
        pmodulo->multiplier_first  = dtemps_longterm + 2*lnga;  // Length lnga
        pmodulo->multiplier_second = dtemps_longterm + 3*lnga; // Length lngred2        

        pmodulo->length = lnga;
        pmodulo->lngred2 = lngred2;
        pmodulo->reddir = reddir;
        MEMCPY( pmodulo->modulus,a,(  lnga)*SIZEOF( digit_t ));

        OK = OK && divide_precondition_1(a, lnga, &pmodulo->left_reciprocal_1);

        mod0inv = 0;
        if (IS_ODD(a[0])) {
            OK = OK && two_adic_inverse(a[0], &mod0inv);
        }
        pmodulo->right_reciprocal_1 = mod0inv;
                               /* For use by mod_shift if modulus is odd */

        if (reddir == FROM_LEFT) {
            const DRM_DWORD shiftamt = pmodulo->left_reciprocal_1.shiftamt;
            const DRM_DWORD ldividend = lnga + lngred2;

            pmodulo->scaling_power2 = 0;

/*
            Compute constants multiplier_first, multiplier_second so that

               0 <= multiplier_first < modulus
               0 <= multiplier_second < RADIX^lngred2

                  modulus * (multiplier_second + RADIX^lngred2 + 1)
                = RADIX^(length + lngred2) / 2^shiftamt + multiplier_first

            That is, if we divide

                  (RADIX^dividend / 2^shiftamt) - 1

            by modulus, the results will be

                   quotient = multiplier_second + RADIX^lngred2
                   remainder = modulus - 1 - multiplier_first
*/
            for (i = 0; i != ldividend; i++) {
                mptmp1[i] = RADIXM1;
            }
            mptmp1[ldividend-1] = RADIXM1 >> shiftamt;

            OK = OK && divide(mptmp1, ldividend, a, lnga,
                              &pmodulo->left_reciprocal_1,
                              quotient, remainder);

            if (quotient[lngred2] != 1) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                          "create_modulus -- divide error");
                       // quotient should start with 1
            }

            add_immediate(remainder, DIGIT_ONE, remainder, lnga);
            sub_same(pmodulo->modulus, remainder, remainder, lnga);
                           // modulus - 1 - remainder
        } else if (reddir == FROM_RIGHT) {
            pmodulo->scaling_power2 = (DRM_INT)(RADIX_BITS*lnga);

            if (mod0inv == 0) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                                "create_modulus FROM_RIGHT even");
            } else {
/*
                Compute multiplier_first, multiplier_second, such that

                    0 <= multipler_first < modulus
                    0 <= multiplier_second < RADIX^lngred2

                       multiplier_second * modulus
                 = 1 + multiplier_first * RADIX^lngred2
*/
                pmodulo->multiplier_second[0] = mod0inv;
                mptmp1[lnga] =
                    multiply_immediate(pmodulo->modulus, mod0inv,
                                       mptmp1, lnga);
                        /* 1 mod RADIX,  0 mod modulo->modulus */
                DRMASSERT(mptmp1[0] == 1);

                for (i = 1; i != lngred2; i++) {
                    const digit_t mul = 0 - mod0inv*mptmp1[i];     /* mod RADIX */

                    pmodulo->multiplier_second[i] = mul;
                    mptmp1[i + lnga] = accumulate(pmodulo->modulus, mul,
                                          &mptmp1[i], lnga);
                       /* New mptmp1[i] = 0 */
                       /* Sum is 1 mod RADIX^(i+1),  0 mod modulo->modulus */
                    DRMASSERT (mptmp1[i] == 0);
                }
                MEMCPY(pmodulo->multiplier_first, mptmp1 + lngred2, lnga* SIZEOF( digit_t ));
                       /* -1/RADIX^lngred2 mod modulus */
            }
        } else {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                         "create_modulus -- neither FROM_LEFT nor FROM_RIGHT");
        }

        {
            const digit_t d1 = 1;
            DRM_INT modmul_algorithm_index = 0;

            OK = OK && modmul_choices1(pmodulo, &modmul_algorithm_index);
            if (!OK) {
            } else if (modmul_algorithm_index == 0) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                    "create_modulus -- no modmul routine found");
                         // No qualifying routine found
            } else {
                modmul_algorithm_index = -modmul_algorithm_index;
                OK = OK && modmul_choices1(pmodulo, &modmul_algorithm_index);
                DRMASSERT (modmul_algorithm_index == 0);
            }

/*
                Generate the constant one.
                Its numerical value is 2^scaling_power2 mod modulus.
*/
            OK = OK && to_modular(&d1, 1, pmodulo->one, pmodulo, f_pBigCtx);
        } // local block
    } // if


    if (dtemps_shortterm != NULL) {
        Free_Temporaries(dtemps_shortterm, f_pBigCtx);
    }
    if (!OK) {
        pmodulo->modulus = NULL;

        if (dtemps_longterm != NULL) {
            Free_Temporaries(dtemps_longterm, pbigctxGlobal);
        }
    }
    return OK;
}   /* create_modulus */
/******************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL from_modular
        (const digit_t        a[],
         digit_t         b[],
         const mp_modulus_t  *pmodulo)
{
    DRM_BOOL OK = TRUE;

    OK = OK && validate_modular_data(a, pmodulo->modulus,
                               pmodulo->length, "from_modular");
    OK = OK && mod_shift(a, -pmodulo->scaling_power2, b, pmodulo);
    return OK;
} /* from_modular */
/******************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL mod_mul
        (const digit_t       a[],
         const digit_t       b[],
         digit_t        c[],
         const mp_modulus_t *pmodulo,
         digit_t       *supplied_temps,   // May be NULL
         struct bigctx_t *f_pBigCtx)
/*
        Compute c = a * b / 2^scaling_power2 (mod modulo->modulus).
        Operands should satisfy 0 <= a, b < modulo->modulus.

        supplied_temps should have pmodulo->modmul_algorithm_temps
        temporaries of type digit_t, or be NULL.
*/
{
    DRM_BOOL OK = TRUE;
    digit_tempinfo_t tempinfo;

    tempinfo.address = supplied_temps;
    tempinfo.nelmt = pmodulo->modmul_algorithm_temps;
    tempinfo.need_to_free = FALSE;

    OK = OK && validate_modular_data(a, pmodulo->modulus,
                                     pmodulo->length, "mod_mul 1");
    if (a != b) {
        OK = OK && validate_modular_data(b, pmodulo->modulus,
                                         pmodulo->length, "mod_mul 2");
    }
    OK = OK && possible_digit_allocate(&tempinfo, "mod_mul", f_pBigCtx);

    OK = OK && (*pmodulo->modmul_algorithm)(a, b, c, pmodulo,
                                            tempinfo.address);

    if (tempinfo.need_to_free) {
        Free_Temporaries(tempinfo.address, f_pBigCtx);
    }
    return OK;
} /* mod_mul */
/***************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL mod_shift
        (const digit_t       a[],
         const DRM_INT           shiftamt,
         digit_t        b[],
         const mp_modulus_t *modulo)
/*
        Compute b = a * 2^shiftamt (mod modulo).
        The shift count, shiftamt, may be positive, negative, or zero.
        If shiftamt < 0, then the modulus must be odd.
        The lengths of a and b should match those of the modulus.
*/
{
    DRM_BOOL OK = TRUE;
    const DRM_DWORD lng = modulo->length;
    DRM_INT shift_remaining = shiftamt;

    if (a != b) MEMCPY( b,a,( lng)*SIZEOF( digit_t ));

    OK = OK && validate_modular_data(a, modulo->modulus, lng,
                                     "mod_shift");

    if (OK && shift_remaining < 0 && IS_EVEN(modulo->modulus[0])) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "mod_shift -- negative count, even modulus");
    }

    while (OK && shift_remaining > 0) {          /* Do left shift, if any */
        const DRM_INT shift_now = MIN(shift_remaining, RADIX_BITS);
                                /* 1 <= shift_now <= RADIX_BITS */
/*
                Multiply b by 2^shift_now and reduce modulo modulo->modulus.
*/
        digit_t carry_out = 0;

        OK = OK && mp_shift_lost(b, shift_now, b, lng,
                                 &carry_out);
        if (OK) {
            const digit_t qest = estimated_quotient_1(carry_out, b[lng-1],
                                                 (lng >= 2 ? b[lng-2] : 0),
                                                 &modulo->left_reciprocal_1);
            carry_out -= decumulate(modulo->modulus, qest, b,lng);

            if (carry_out != 0 || compare_same(b, modulo->modulus, lng) >= 0) {
                carry_out -= sub_same(b, modulo->modulus, b, lng);
            }
            if (carry_out != 0) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                    "mod_shift left carry nonzero");
            }
        }
        shift_remaining -= shift_now;
    } /* while shift_remaining > 0 */

    while (OK && shift_remaining < 0) {
        const DRM_INT shift_now = MIN(-shift_remaining, RADIX_BITS);
                                /* 1 <= shift_now <= RADIX_BITS */
        const digit_t mul =   (0-modulo->right_reciprocal_1 * b[0])
                       & (RADIXM1 >> (RADIX_BITS - shift_now) );
        digit_t carry, low_bits_lost = 0;
/*
                mul has been chosen so that  b + mul * modulo->modulus
                is a multiple of 2^shift_now.
                Replace b by (b + mul * mudulo->modulus)/2^shift_now.
*/
        carry = accumulate(modulo->modulus, mul, b, lng);
        OK = OK && mp_shift_lost(b, -shift_now, b, lng,
                                 &low_bits_lost);
        b[lng-1] |= carry << (RADIX_BITS - shift_now);

        if (OK && low_bits_lost != 0) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                            "mod_shift -- low bits lost");
        }
        shift_remaining += shift_now;
    } /* while shift_remaining < 0 */
    return OK;
} /* mod_shift */
/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL to_modular
        (const digit_t      a[],
         const DRM_DWORD     lnga,
         digit_t       b[],
         const mp_modulus_t *pmodulo,
         struct bigctx_t *f_pBigCtx)
{
    DRM_BOOL OK = TRUE;
    const digit_t *arem;
    DRM_DWORD lngarem;
    const DRM_DWORD lngmod = pmodulo->length;
    digit_t *remainder = NULL;   // Length lngmod

    if (compare_diff(a, lnga, pmodulo->modulus, lngmod) >= 0) {
        remainder = digit_allocate(lngmod, "to_modular", f_pBigCtx);
        if (remainder == NULL) OK = FALSE;

        OK = OK && divide(a, lnga, pmodulo->modulus, lngmod,
                         &pmodulo->left_reciprocal_1,
                         NULL, remainder);
        arem = remainder;
        lngarem = lngmod;
    } else {
        arem = a;
        lngarem = lnga;
    }

    if ( lngarem > lnga )
    {
        OK = FALSE;
    }

    if (OK) {
        lngarem = significant_digit_count(a, lngarem);
        mp_extend(arem, lngarem, b, lngmod);
                /* Copy remainder to b */
        OK = OK && mod_shift(b, pmodulo->scaling_power2, b,
                             pmodulo);
                                    // Scale by power of 2
    }
    if (remainder != NULL) {
        Free_Temporaries(remainder, f_pBigCtx);
    }
    return OK;
} /* to_modular */
/******************************************************************************/
DRM_API DRM_NO_INLINE DRM_VOID DRM_CALL uncreate_modulus
        (mp_modulus_t *pmodulo,
         struct bigctx_t *f_pBigCtx)
/*
        Release storage allocated by create_modulus
*/
{
    if (pmodulo->modulus != NULL) {
        Free_Temporaries(pmodulo->modulus, f_pBigCtx);
        pmodulo->modulus = NULL;
    }
} // uncreate_modulus

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\mpgcdex.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bigpriv.h"

ENTER_PK_NAMESPACE_CODE;
/*
                File mp_gcdex.  Extended GCD algorithm on positive integers.
*/
static DRM_BOOL DRM_CALL lehmer_mat22(const DRM_UINT64, const DRM_UINT64,
                                digit_t[4], struct bigctx_t *f_pBigCtx); // This file

DRM_EXPORTED_INLINE DRM_DWORD DRM_CALL mp_gcdex_ntemps
       (const DRM_DWORD lnga,
        const DRM_DWORD lngb,
        struct bigctx_t *f_pBigCtx)
/* Return temporary count needed by mp_gcdex */
{
    (DRM_VOID)f_pBigCtx;
    return 8*MAX(lnga, lngb) + 6;
} // mp_gcdex_ntemps
/****************************************************************************/
DRM_NO_INLINE DRM_DWORD DRM_CALL mp_invert_ntemps(const DRM_DWORD lng, struct bigctx_t *f_pBigCtx)
/* Return temporary count needed by mp_invert */
{
    return lng + mp_gcdex_ntemps(lng, lng, f_pBigCtx);
} // mp_invert_ntemps
/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL mp_gcdex
        (const digit_t  a[],             // IN  (nonzero)
         const DRM_DWORD lnga,            // IN
         const digit_t  b[],             // IN  (nonzero)
         const DRM_DWORD lngb,            // IN
         digit_t   ainvmodb[],      // OUT
         digit_t   binvmoda[],      // OUT (unless NULL)
         digit_t   gcd[],           // OUT
         digit_t   lcm[],           // OUT (unless NULL)
         DRM_DWORD  *plgcd,          // OUT -- contains length of GCD
         digit_t   *supplied_temps,
                              // TEMPS -- length mp_gcdex_ntemps(lnga, lngb)
         struct bigctx_t *f_pBigCtx)

/*
        Compute gcd = GCD(a, b) and return its length.
        Also return ainvmodb = gcd/a (mod b)
        and binvmoda = gcd/b (mod a), except that binvmoda
        is not computed if the input argument is NULL.
        The length of ainvmodb will be lngb and
        that of binvmoda will be lnga.

        The gcd array should be dimensioned at least MIN(lnga, lngb).
        The output length will be stored in *plgcd.

        We require that a <> 0 and b <> 0.
        If lcm <> NULL. then return lcm = LCM(a, b)
        (least common multiple); the LCM will have length lnga + lngb
        (possibly with leading zeros).
*/
{
    const DRM_DWORD lnga_sig = significant_digit_count(a, lnga);
    const DRM_DWORD lngb_sig = significant_digit_count(b, lngb);
    const DRM_DWORD max_lngab = MAX(lnga, lngb);
    DRM_DWORD  lgcd = 0, lngab[2], lngmuls;
    digit_t *ab[2] = {NULL, NULL};
                // Each subscripts -1 to max_lngab (max_lngab + 2 elements)
    DRM_BOOL OK = TRUE;
    DRM_DWORD iterations;
    digit_tempinfo_t tempinfo;

            // Allocated memory

    digit_t *temps_ab0_padded = NULL;    // max_lngab + 2
    digit_t *temps_ab1_padded = NULL;    // max_lngab + 2
    digit_t *temps_mul[2] = {NULL, NULL};   // each max_lngab
    digit_t *temps_prod = NULL;          // 2*max_lngab
    digit_t *temps_quot = NULL;          // max_lngab + 1

    tempinfo.need_to_free = FALSE;
    tempinfo.nelmt = mp_gcdex_ntemps(lnga, lngb, f_pBigCtx);
    tempinfo.address = supplied_temps;
    OK = OK && possible_digit_allocate(&tempinfo, "mp_gcdex", f_pBigCtx);

    lngab[0] = lnga_sig;  lngab[1] = lngb_sig;
    if (!OK) {
    } else if (lnga_sig == 0 || lngb_sig == 0) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_ZERO_OPERAND, "mp_gcdex");
    } else if (    a == NULL || b == NULL
                || gcd == NULL || ainvmodb == NULL) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_NULL_POINTER, "mp_gcdex");
    } else if (a == gcd || b == gcd || a == ainvmodb || b == ainvmodb) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_OVERLAPPING_ARGS, "mp_gcdex");
    } else {
        digit_t *temps_next = tempinfo.address;

        ZEROMEM(temps_next,( tempinfo.nelmt)*SIZEOF( digit_t ));
        temps_ab0_padded = temps_next; temps_next += max_lngab + 2;
        temps_ab1_padded = temps_next; temps_next += max_lngab + 2;
        temps_mul[0]     = temps_next; temps_next += max_lngab;
        temps_mul[1]     = temps_next; temps_next += max_lngab;
        temps_prod       = temps_next; temps_next += 2*max_lngab;
        temps_quot       = temps_next; temps_next += max_lngab + 1;
                                       temps_next += max_lngab + 1;

        if (temps_next != tempinfo.address + tempinfo.nelmt) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                            "mp_gcdex -- alloc");
        } else {
            ab[0] = temps_ab0_padded + 1; // Subscripts -1 to max_lngab
            ab[1] = temps_ab1_padded + 1;
            //    ab[0][-1] = ab[1][-1] = 0;
            //    ab[0][lnga_sig] = ab[1][lngb_sig] = 0

            MEMCPY( ab[0],a,( lnga_sig)*SIZEOF( digit_t ));
            MEMCPY( ab[1],b,( lngb_sig)*SIZEOF( digit_t ));

           // ZEROMEM(temps_mul[0],( lngb)*SIZEOF( digit_t ));
           // ZEROMEM(temps_mul[1],( lngb)*SIZEOF( digit_t ));
            temps_mul[0][0] = 1;  // mul[0] = 1,  mul[1] = 0
        }
    }
    lngmuls = 1;         // Length of temps_mul[0] and temps_mul[1].
                         // One of these may have leading zeros.

    iterations = 0;
    while (OK && lngab[0] != 0 && lngab[1] != 0) {
        const DRM_DWORD lng0 = lngab[0];
        const DRM_DWORD lng1 = lngab[1];
        digit_t *pab0top = &ab[0][lng0-1];
        digit_t *pab1top = &ab[1][lng1-1];
        digit_t topword0 = *pab0top;
        digit_t topword1 = *pab1top;
        const DRM_DWORD topsigbits0 = significant_bit_count(topword0);
        const DRM_DWORD topsigbits1 = significant_bit_count(topword1);
        const DRM_DWORD sigbits0 = RADIX_BITS*(lng0 - 1) + topsigbits0;
        const DRM_DWORD sigbits1 = RADIX_BITS*(lng1 - 1) + topsigbits1;
        const DRM_DWORD sigbitsmax = MAX(sigbits0, sigbits1);

        // Next was once const DRM_DWORD, but that results in
        // unexpected loop bound on IA64.
        // Problem is subscript labmax - 2 = 0x00000000ffffffff
        // when labmax = 1.  Signed arithmetic gives -1 as desired.
        DRM_LONG labmax = (DRM_LONG)MAX(lng0, lng1);
        const DRM_DWORD ibig = (compare_diff(ab[1], lng1, ab[0], lng0) > 0);
                       // identifies which of ab[0], ab[1] is larger
        const DRM_DWORD ismall = 1 - ibig;
        digit_t mat22[4];

        iterations++;
        if (iterations > RADIX_BITS*(lnga + lngb + 1)) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_TOO_MANY_ITERATIONS,
                            "mp_gcdex");
        }
/*
                        Loop invariants:

                            0 <= ab[ismall] <= ab[ibig]

                            mul[0] and mul[1] have leading zeros to length lngb.

                             {ibig, ismall} = {0, 1}

                            Except possibly on first iteration,
                            mul[ibig] <= mul[ismall].

                            There exist c0 >= 0, c1 > 0 such that

                               ( ab[0] )     ( mul[0]   -c0 )   ( a )
                               (       )  =  (              )   (   ) .
                               ( ab[1] )     (-mul[1]    c1 )   ( b )

                            The 2 x 2 matrix has determinant +1,
                            so GCD(a, b) = GCD(ab[0], ab[1]).

                            Invert the matrix to get

                                a = c1*ab[0] + c0*ab[1]
                                b = mul[1]*ab[0] + mul[0]*ab[1]

                            with everything nonnegative.
                            When, say, ibig = 1 and ab[0] = 0 then
                            a = c0*ab[1] and b = mul[0]*ab[1],
                            The latter implies 0 <= mul[0] <= b.
                            Then mul[ibig] <= mul[ismall] implies
                            0 <= mul[1] <= b
                            (ab[0] cannot vanish on first iteration).

---- Distribution of partial quotients

                Fix a positive integer q0.  Let q be a partial quotient from the
                Euclidean algorithm.  Then (Knuth, Seminumerical Algorithms,
                3rd Edition, Section 4.5.3, Theorem E, p. 368,

                      Prob(q < q0) = log2(2q0/(q0+1))
                      Prob(q = q0) = log2((q0^2 + 2q0 + 1)/(q0^2 + 2q0))
                      Prob(q > q0) = log2((q0+2)/(q0+1))

                where log2 denotes the base-2 logarithm.
                According to this model, small quotients are frequent:

                        q = 1   probability 0.415
                        q = 2   probability 0.170
                        q = 3   probability 0.093
                        q = 4   probability 0.059
                        q = 5   probability 0.041
                        q = 6   probability 0.030
                        q = 7   probability 0.022
                        q >= 8  probability 0.170

                As of 1999, integer division is slow on many processors
                (e.g., Intel Pentium) and non-existent on others
                (e.g., DEC/Compaq Alpha, Intel IA-64).
                We check explicitly for small quotients.
*/
        if (!OK) {
        } else if (labmax == 1) { // Implies lng0 == lng1 == 1
                                  // Use single-precision hereafter
            digit_t ab0, ab1, m00, m01, m10, m11, carrys[2];

            // To ensure the arguments to mp_mul22u are in range,
            // we check whether topword0 + topword1 < RADIX.
            // Observe that (new topword0) + (new topword1)
            //  = MAX(old topword0, old topword1) < RADIX.

            if (topword0 > RADIXM1 - topword1) {
                digit_t carry;
                if (ibig == 0) {
                    topword0 -= topword1;
                } else {
                    topword1 -= topword0;
                }
                carry = add_same(temps_mul[0], temps_mul[1],
                                 temps_mul[ibig], lngmuls);
                if (!OK) {
                } else if (carry == 0) {
                } else if (lngmuls >= lngb) {
                    OK = FALSE;
                    SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                "mp_gcdex -- lngmuls overflow 1");
                } else {
                    temps_mul[ibig][lngmuls] = carry;
                    lngmuls++;
                }
            }  // if topword0 + topword1 >= RADIX

            ab0 = topword0;
            ab1 = topword1;
            m00 = 1; m01 = 0; m10 = 0; m11 = 1;

            while (OK && ab1 != 0) {   // Also exit by break if ab0 == 0
                if (ab0 >= ab1) {
                    if ((ab0 >> 2) >= ab1) {     // Quotient >= 4
                        digit_t q = ab0 / ab1;   // truncated
                        ab0 -= q*ab1;
                        m00 += q*m10;
                        m01 += q*m11;
                    } else {
                        do {
                            ab0 -= ab1;
                            m00 += m10;
                            m01 += m11;
                        } while (ab0 >= ab1);
                    }
                } // if ab0 >= ab1

                DRMASSERT (ab1 > ab0);
                if (ab0 == 0) break;

                if ((ab1 >> 2) >= ab0) {      // Quotient >= 4
                    digit_t q = ab1 / ab0;    // truncated
                    ab1 -= q*ab0;
                    m10 += q*m00;
                    m11 += q*m01;
                } else {
                    do {
                        ab1 -= ab0;
                        m10 += m00;
                        m11 += m01;
                    } while (ab1 >= ab0);
                }
                DRMASSERT (ab0 > ab1);
            } // while


                   // Now    (ab0)     (  m00  -m01 )   ( topword0 )
                   //               =                 *
                   //        (ab1)     ( -m10   m11 )   ( topword1 )

                   // Invert to get

                   //         ( topword0 )   ( m11  m01 )   ( ab0 )
                   //                      =              *
                   //         ( topword1 )   ( m10  m00 )   ( ab1 )


                   // We want to update

                   //        (new mul[0] }   (  m00  m01 )   (old mul[0] )
                   //                      *               *
                   //        (new mul[1] )   (  m10  m11 )   (old mul[1] )

                   // One of ab0, ab1 is zero.  If, say, ab0 = 0 and
                   // ab1 = GCD(topword0, topword1), then

                   //        topword1 = ab1 * m00
                   //        topword0 = ab1 * m01
                   //        ab1 = m11*topword1 - m10*topword0
                   //        0 <= m10 < m00
                   //        1 <= m11 < m01

                   // Hence m10 + m11 < m00 + m11
                   //                 <= topword1 + topword0 < RADIX
                   // A similar inequality holds when ab1 = 0.

            ab[0][0] = ab0;
            ab[1][0] = ab1;
            lngab[0] = (DRM_DWORD)(ab0 != 0);
            lngab[1] = (DRM_DWORD)(ab1 != 0);
            mat22[0] = m00;
            mat22[1] = m01;
            mat22[2] = m10;
            mat22[3] = m11;

            OK = OK && mp_mul22u(mat22, temps_mul[0], temps_mul[1],
                                 lngmuls, carrys);
            if (!OK) {
            } else if (carrys[0] == 0 && carrys[1] == 0) {
            } else if (lngmuls >= lngb) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                "mp_gcdex -- lngmuls overflow 2");
            } else {
                temps_mul[0][lngmuls] = carrys[0];
                temps_mul[1][lngmuls] = carrys[1];
                lngmuls++;
            }
        } else if (   sigbits0 > sigbits1 + RADIX_BITS/2
                   || sigbits1 > sigbits0 + RADIX_BITS/2) {
                       // Big difference in bit lengths.
                       // Use multi-precision division.
            DRM_DWORD  lquot = lngab[ibig] - lngab[ismall] + 1;
            const DRM_DWORD lngmul_small
                   = significant_digit_count(temps_mul[ismall], lngmuls);

            OK = OK && divide(ab[ibig], lngab[ibig], ab[ismall], lngab[ismall],
                   NULL, temps_quot, temps_prod);

            if (OK) {
                lquot = significant_digit_count(temps_quot, lquot);
                lngab[ibig] = significant_digit_count(temps_prod,
                                                      lngab[ismall]);

                MEMCPY( ab[ibig],temps_prod,( lngab[ibig])*SIZEOF( digit_t ));

                OK = OK && multiply(temps_quot, lquot, temps_mul[ismall],
                     lngmul_small, temps_prod);
                if (OK) {
                    DRM_DWORD ltemp = significant_digit_count(temps_prod,
                                                         lquot + lngmul_small);
                    OK = OK && add_full(temps_prod, ltemp,
                        temps_mul[ibig], lngmuls, temps_mul[ibig],
                        &lngmuls);
                }
            }
        } else {  // Not far apart in bit lengths (and at most one word apart)
            const DRM_DWORD normalize = RADIX_BITS*labmax - sigbitsmax;
            DRM_UINT64 lead0, lead1;

            pab0top[1] = pab1top[1] = 0;      /* Insert leading zeros */

            DRMASSERT (labmax >= 2);    // Implies subscripts are -1 or higher

            lead0 = DRM_UI64HL(DOUBLE_SHIFT_LEFT(ab[0][labmax-1],
                                                  ab[0][labmax-2], normalize),
                                DOUBLE_SHIFT_LEFT(ab[0][labmax-2],
                                                  ab[0][labmax-3], normalize));
            lead1 = DRM_UI64HL(DOUBLE_SHIFT_LEFT(ab[1][labmax-1],
                                                  ab[1][labmax-2], normalize),
                                DOUBLE_SHIFT_LEFT(ab[1][labmax-2],
                                                  ab[1][labmax-3], normalize));

                   // Find 2 x 2 matrix M such that M*[ab0  ab1]^T is "small"

            OK = OK && lehmer_mat22(lead0, lead1, mat22, f_pBigCtx);

            if (OK && (mat22[1] | mat22[2]) == 0) {
                DRMASSERT(mat22[0] == 1 && mat22[3] == 1);  // Identity matrix
                mat22[ibig + 1] = 1;        // Set m01 = 1 if ibig = 0,
                                            //     m10 = 1 if ibig = 1
            }
                 //  Do 2 x 2 multiplies, where mat22 holds [m00, m01, m10, m11]

                 //     (  m00  -m01 ) ( ab[0] )
                 //     ( -m10   m11 ) ( ab[1] )

                 //     (  m00   m01 ) ( mul[0] )
                 //     (  m10   m11 ) ( mul[1] )

                 // to update the multi-precision [ab[0], ab[1]]
                 // and [mul[0], mul[1]] vectors.

            if (OK) {
                const DRM_DWORD lab = MAX(lng0, lng1);
                digit_t carrys[2];
                sdigit_t scarrys[2];
                OK = OK && mp_mul22s(mat22, ab[0], ab[1],  lab,
                                     scarrys);
                if (!OK) {
                } else if (scarrys[0] != 0 || scarrys[1] != 0) {
                    OK = FALSE;
                    SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                    "mp_gcdex -- scarrys nonzero\n");
                } else {
                    DRM_LONG lng0new = (DRM_LONG)lab, lng1new = (DRM_LONG)lab;
                    // petmon, September, 2000.
                    //         Lower bounds changed from 1 to 0.
                    //         lng0new and lng1new made signed for IA-64.

                    while (lng0new != 0 && ab[0][lng0new-1] == 0) lng0new--;
                    while (lng1new != 0 && ab[1][lng1new-1] == 0) lng1new--;
                    lngab[0] = (DRM_DWORD)lng0new;
                    lngab[1] = (DRM_DWORD)lng1new;
                }

                OK = OK && mp_mul22u(mat22, temps_mul[0], temps_mul[1],
                                     lngmuls, carrys);
                if (!OK) {
                } else if (carrys[0] == 0 && carrys[1] == 0) {
                } else if (lngmuls >= lngb) {
                    OK = FALSE;
                    SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                               "mp_gcdex -- lngmuls overflow 3");
                } else {
                    temps_mul[0][lngmuls] = carrys[0];
                    temps_mul[1][lngmuls] = carrys[1];
                    lngmuls++;
                }
            } // local block to multiply by 2 x 2 matrix
        } // case where we generate 2 x 2 Lehmer matrix
    } /* while */

    if (OK) {

          // One argument has been reduced to zero (or an error has occurred)

        const DRM_DWORD igcd = (lngab[0] == 0 ? 1 : 0);
        lgcd = lngab[igcd];
        MEMCPY( gcd,ab[igcd],( lgcd)*SIZEOF( digit_t ));

                  // Verify mul[igcd] <= mul[1-igcd] <= b

        if (   compare_same(b, temps_mul[1-igcd], lngb) < 0
            || compare_same(temps_mul[1-igcd], temps_mul[igcd], lngb) < 0) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                       "mp_gcdex -- multiplier out of range");
        }
        if (!OK) {
        } else if (igcd == 0) {
            MEMCPY( ainvmodb,temps_mul[0],( lngb)*SIZEOF( digit_t ));
        } else {
            sub_same(temps_mul[0], temps_mul[1], ainvmodb, lngb);
        }

        if (OK && lcm != NULL) {
/*
                Compute LCM(a, b) = a*b/gcd.
                We know mul[1-igcd] = b/ab[igcd] = b/gcd,
                since b = ab[0]*mul[1] + ab[1]*mul[0] and ab[1-igcd] = 0.
                Therefore LCM(a, b) = a*mul[1-igcd].
*/
            OK = OK && multiply(a, lnga, temps_mul[1-igcd],
                                lngb, lcm);
        }

        if (OK && binvmoda != NULL) {
    /*
                Compute binvmoda so that

                   a*ainvmodb + b*binvmoda = lcm + gcd.
                                           = a*mul[1-igcd] + gcd

                We want [a*(mul[1-igcd] - ainvmodb) + gcd]/b.
    */
            sub_same(temps_mul[1-igcd],
                     ainvmodb, temps_mul[1-igcd], lngb);
            OK = OK && multiply(a, lnga, temps_mul[1-igcd], lngb,
                                temps_prod);
            OK = OK && add_diff(temps_prod, lnga + lngb, gcd, lgcd,
                                temps_prod, NULL);
                 /* Cannot overflow -- at most a*b + MAX(a, b) */
            OK = OK && divide(temps_prod, lnga + lngb_sig, b, lngb_sig,
                          NULL,
                          temps_quot, temps_mul[1-igcd]);
            if (!OK) {
            } else if (significant_digit_count(temps_mul[1-igcd],  lngb_sig) != 0) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                "mp_gcdex -- nonzero remainder\n");
            } else {
                MEMCPY( binvmoda,temps_quot,( lnga)*SIZEOF( digit_t ));
                          /* truncate from lnga + 1 to lnga */
            }
        }  /* if binvmoda */
    }
    if (tempinfo.need_to_free) {
        Free_Temporaries(tempinfo.address, f_pBigCtx);
    }
    if (OK) *plgcd = lgcd;
    return OK;
} /* mp_gcdex */
/****************************************************************************/
#if 1

static DRM_NO_INLINE DRM_BOOL DRM_CALL lehmer_mat22
        (const DRM_UINT64   lead0orig,         // IN
         const DRM_UINT64   lead1orig,         // IN
         digit_t     mat22[4],          // OUT
         struct bigctx_t *f_pBigCtx)
/*
            This invokes the Lehmer variant of the extended GCD.
        We are given the 2*RADIX_BITS most significant bits
        lead0orig and lead1orig of ab0 and ab1
        (up to a power-of-2 scale factor).  That is,

                sc*ab0 = lead0orig + eps0
                sc*ab1 = lead1orig + eps1

        where 0 <= eps0, eps1 < 1.  The larger of lead0orig, lead1orig
        has the full 2*RADIX_BITS significant bits.

            Use the continued fraction expansion of lead0orig/lead1orig
        to get the next several partial quotients and a single-precision
        2 x 2 matrix (m00, m01, m10, m11 stored in mat22)

                             ( m00    -m01)
                        M =
                             (-m10     m11)

        of determinant +1 such that  M * [ab0   ab1]^T is `small'.
        The caller uses M to update [ab0 ab1] and [mul0 mul1].
        We promise 0 <= m00, m01, m10, m11 < RADIX/2.

            Invariants:

                    1 <= m00, m11 < RADIX/2
                    0 <= m01, m10 < RADIX/2

                    m00*m11 - m01*m10 = 1

               If lead0 = DRM_UI64HL(lead0h, lead0l) and
                  lead1 = DRM_UI64HL(lead1h, lead1l), then

                    ( lead0 )   ( m00   -m01) ( sc*ab0 - eps0)
                              =
                    ( lead1 )   (-m10    m11) ( sc*ab1 - eps1)
        so
                    ( lead0 + m00*eps0 - m01*eps1 )   ( m00  -m01 ) ( sc*ab0 )
                                                    =
                    ( lead1 + m11*eps1 - m10*eps0 )   (-m10   m11 ) ( sc*ab1 )

        The right side of this identity represents the new scaled ab0
        and ab1 if we had perfect precision in intermediate calculations.
        Looking at the left side (with the updated lead0, lead1),
        and knowing 0 <= m00, m01, m10, m11 < RADIX/2,
        along with 0 <= eps0, eps1 < 1, we can get estimates and error
        bounds for the scaled, full-precision, sc0*ab0 and sc1*ab1
        There are the intervals RADIX*(lead0h - 1/2, lead0h + 3/2)
        and RADIX*(lead1h - 1/2, lead1h + 3/2).
        The old sc0*ab0 and ac1*ab1 were around RADIX^2.
        We try to make lead0h and lead1h small, which
        should alos help ab0 and ab1.
        (CAUTION -- lead0h + 1 and lead1h + 1 may overflow.)

            Conceptually lead0, lead1 are double-length (2*RADIX_BITS bits),
        initialized to lead0orig and lead1orig.  However, we manipulate
        the high and low pieces of each separately.

            WARNING.  This may return the identity matrix
        when lead0 and lead1 are very close (or equal).
*/
{
    digit_t lead0h = DRM_UI64High32(lead0orig), lead0l = DRM_UI64Low32(lead0orig);
    digit_t lead1h = DRM_UI64High32(lead1orig), lead1l = DRM_UI64Low32(lead1orig);
    DRM_BOOL OK = TRUE, progress = TRUE;
    digit_t m00 = 1, m01 = 0, m10 = 0, m11 = 1;

    if (    lead0h == 0
         || lead1h == 0                      // Matrix entries will be too big
         || ((lead0h | lead1h) & RADIX_HALF) == 0) {  // Neither normalized
             OK = FALSE;
             SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                            "lehmer_mat22 -- Bad lead0h or lead1h");
    }
    while (progress && OK) {
        progress = FALSE;

        if (lead0h - 1 > lead1h && lead0h != 0) {
                //  The (updated) quotient ab0 / ab1 is at least
                //  (lead0h - 1/2)/(lead1h + 3/2) >= lead0h/(lead1h + 2) >= 1
                //  The denominator lead1h + 2 cannot overflow.

            if ((lead0h >> 2) >= lead1h + 2) {   // Quotient >= 4
                const digit_t q = lead0h / (lead1h + 2);
                const DRM_UINT64 prod10_11 = DPRODUU(q, m10 + m11);
                const DRM_UINT64 prod1l = DPRODUU(q, lead1l);

                if (q <= 3) {
                    OK = FALSE;
                    SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                    "lehmer_mat22 -- small quotient 1");
                }
                        // Update m00 = m00 + q*m10;
                        //        m01 = m01 + q*m11;
                        //        lead0 -= q*lead1
                        // but only if (new m00) and (mew m01) are < RADIX/2.
                        // Rather than make two tests, we
                        // check whether (new m00) + (new m01) < RADIX/2

                if (   DRM_UI64High32(prod10_11) == 0
                    && DRM_UI64Low32(prod10_11) <= RADIXM1/2 - m00 - m01) {

                    const digit_t prod10 = q*m10;

                    progress = TRUE;
                    lead0h -= q*lead1h + DRM_UI64High32(prod1l)
                                       + (DRM_UI64Low32(prod1l) > lead0l);
                    lead0l -= DRM_UI64Low32(prod1l);

                    m00 += prod10;
                    m01 += (DRM_UI64Low32(prod10_11) - prod10);

                    if ((m00 | m01) >= RADIX_HALF) {
                        OK = FALSE;
                        SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                        "lehmer_mat22 -- m00 or m01 overflow.");
                    }
                } // if DRM_UI64High32
            } else {  // Estimated quotient <= 3 (actual may be slightly larger)
                digit_t overflow_test;
                do {
                    m00 += m10;
                    m01 += m11;
                    overflow_test = (m00 | m01) & RADIX_HALF;
                    lead0h -= lead1h + (lead1l > lead0l);
                    lead0l -= lead1l;
                } while (overflow_test == 0 && lead0h >= lead1h + 2);

                progress = TRUE;
                if (overflow_test != 0) {
                    progress = FALSE;
                    m00 -= m10;
                    m01 -= m11;
                }
            } // large or small quotient?
        }  // lead0h >= lead1h + 2

        if (lead1h - 1 > lead0h && lead1h != 0) {
            if ((lead1h >> 2) >= lead0h + 2) {  // Quotient >= 4
                const digit_t q = lead1h / (lead0h + 2);
                const DRM_UINT64 prod00_01 = DPRODUU(q, m00 + m01);
                const DRM_UINT64 prod0l = DPRODUU(q, lead0l);

                if (q <= 3) {
                    OK = FALSE;
                    SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                    "lehmer_mat22 -- tiny quotient 2");
                }
                            // Update m10 = m10 + q*m00;
                            //        m11 = m11 + q*m01;
                            //        lead1 -= q*lead0
                            // but only if (new m10) and (mew m11)
                            // are both < RADIX/2.
                            // Rather than make two tests, we
                            // check whether (new m10) + (new m11) < RADIX/2

                if (   DRM_UI64High32(prod00_01) == 0
                    && DRM_UI64Low32(prod00_01) <= RADIXM1/2 - m10 - m11) {

                    const digit_t prod00 = q*m00;

                    progress = TRUE;
                    lead1h -= q*lead0h + DRM_UI64High32(prod0l)
                                       + (DRM_UI64Low32(prod0l) > lead1l);
                    lead1l -= DRM_UI64Low32(prod0l);

                    m10 += prod00;
                    m11 += (DRM_UI64Low32(prod00_01) - prod00);

                    if ((m10 | m11) >= RADIX_HALF) {
                        OK = FALSE;
                        SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                        "lehmer_mat22 -- m10 or m11 overflow.");
                    }
                } // if prod_00_01
            } else {     // Estimated quotient <= 3 (actual may be more)
                digit_t overflow_test;
                do {
                    m10 += m00;
                    m11 += m01;
                    overflow_test = (m10 | m11) & RADIX_HALF;
                    lead1h -= lead0h + (lead0l > lead1l);
                    lead1l -= lead0l;
                } while (overflow_test == 0 && lead1h >= lead0h + 2);

                progress = TRUE;
                if (overflow_test != 0) {
                    progress = FALSE;
                    m10 -= m00;
                    m11 -= m01;
                }
            } // large or small quotient?
        }  // lead1h >= lead0h + 2
    }  // while (progress && OK)

    if (!OK) {
    } else if ((m00 | m01 | m10 | m11) & RADIX_HALF) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                        "lehmer_mat22 -- matrix element too high");
    } else {
        mat22[0] = m00;
        mat22[1] = m01;
        mat22[2] = m10;
        mat22[3] = m11;
    }
    return OK;
} // lehmer_mat22

#endif

/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL mp_invert
        (const digit_t    denom[],        // IN
         const digit_t    modulus[],      // IN
         const DRM_DWORD   lng,            // IN
         digit_t     result[],       // OUT
         const DRM_CHAR *caller,         // IN
         digit_t    *supplied_temps, // TEMPS -- length mp_invert_ntemps(lng)
         struct bigctx_t *f_pBigCtx)
/*
     Return result = 1/denom (mod modulus).
     denom, modulus, result all have length lng.
     supplied_temps may be NULL or have length mp_invet_ntemps(lng)
*/
{
    DRM_BOOL OK = TRUE;
    digit_tempinfo_t tempinfo;

    tempinfo.address = supplied_temps;
    tempinfo.need_to_free = FALSE;
    tempinfo.nelmt = mp_invert_ntemps(lng, f_pBigCtx);

    OK = OK && possible_digit_allocate(&tempinfo, "mp_invert", f_pBigCtx);
    OK = OK && validate_modular_data(denom, modulus, lng,
                                     "mp_invert");

    if (!OK) {
    } else if (significant_digit_count(denom,  lng) == 0) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_DIVIDE_ZERO, caller);
    } else {
        DRM_DWORD lgcd = 0;
        digit_t *gcd         = tempinfo.address;
        digit_t *gcdex_temps = gcd + lng;

        DRMASSERT(   gcdex_temps + mp_gcdex_ntemps(lng, lng, f_pBigCtx)
               == tempinfo.address + tempinfo.nelmt);

        OK = OK && mp_gcdex(denom, lng, modulus, lng, result,
                            NULL, gcd, NULL,
                            &lgcd, gcdex_temps, f_pBigCtx);
        if (!OK) {
        } else if (lgcd != 1 || gcd[0] != 1) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_NOT_INVERTIBLE, caller);
            
            TRACE( ( "Using data from %s, mp_invert got nontrivial GCD\n", caller ) ); 
        }
    }
    if (tempinfo.need_to_free == TRUE) {
        Free_Temporaries(tempinfo.address, f_pBigCtx);
    }
    return OK;
} // mp_invert

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\stdafx.cpp ===
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\mpmul22.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bignum.h"

ENTER_PK_NAMESPACE_CODE;

/*
                File mpmul22.c.  Supplement to mpgcdex.c.

        mp_mul22u(mat, vec1, vec2, lvec, carrys) -- Multiplies the
                  multiple-precision numbers vec1 and vec2 (length lvec)
                  by a 2 x 2 matrix of unsigned scalars.

                        (carrys[0], vec1)   (m11  m12)  (vec1)
                                          =
                        (carrys[1], vec2)   (m21  m22)  (vec2)

                  where mat has m11, m12, m21, m22.
                  Require m11 + m12 < RADIX and m21 + m22 < RADIX.


        mp_mul22s(mat, vec1, vec2, lvec, carrys) -- Multiplies the
                  multiple-precision numbers vec1 and vec2 (length lvec)
                  by a 2 x 2 matrix with signed off-diagonal scalars.

                        (carrys[0], vec1)   (m11  -m12)  (vec1)
                                          =
                        (carrys[1], vec2)   (-m21  m22)  (vec2)

                  where mat has m11, m12, m21, m22.
                  Require m11, m12, m21, m22 all in [0, RADIX/2 - 1]

*/


#if defined(_M_IX86) && DRM_USE_ASSEMBLY

#if defined (_MSC_VER)
#pragma warning(disable: 4100) /* unreferenced formal parameter */
#endif /* _MSC_VER */


/*
            The following are temporary variables in
            some of the X86 assembly codes.
            The entire struct is stored on the stack
            at the start of each routine.
            Each routine uses the data it needs.
*/

typedef struct {
    digit_t carry1;
    digit_t carry2;
    digit_t mat[4];             // Copy of matrix
    __int32 saved_regs22[4];    // ebp, ebx, edi, esi
} mul22_locals_t;

/*
              Assembly language pseudocode for mp_mul22u
              (mp_mul22s is very similar -- carry1, carry2 are signed,
              and some adds of edx:eax are replaced by subtracts).

    save matrix and registers, in struct on stack
    carry1 = ecx = 0

    esp = adjusted stack pointer
    ebp = remaining loop count
    edi = @vec1[i]
    eii = @vec2[i]

loop
        Save carry2 (in ecx)

        edx:eax = m11*vec1[i]
        ebx:ecx = carry1 (zero extended)
        ebx:ecx += edx:eax

        edx:eac = m12*vec2[i]
        ebx:ecx += edx:eax

        edx:eax = m21*vec1[i]
        update carry1 and vec1[i]
        ecx:ebx = carry2 (zero extended)
        ecx:ebx += edx:eax

        edx:eax = m22*vec2[i]
        ecx:ebx += edx:eax

        update  vec2[i]
        adjust ebp, esi, edi
    branch if more iterations

    load carrys address, carry1 (carry2 is in ecx)
    restore ebp, esi, edi
    save carry1
    return
*/

#define mp_mul22u_asm mp_mul22u
__declspec(naked) DRM_BOOL __stdcall mp_mul22u_asm
              (const digit_t mat[4],            // IN  (2 x 2 matrix of scalars)
               digit_t  vec1[],            // INOUT
               digit_t  vec2[],            // INOUT
               const DRM_DWORD lvec,             // IN
               digit_t  carrys[2])         // OUT  (array of 2 scalars)
{
    __asm {
        mov edx,[esp+4]                          ; edx = mat
        sub esp,TYPE mul22_locals_t              ; Allocate space on stack

        xor ecx,ecx                              ; ecx = carry2 = 0
                             ; AGI delay here

        mov [esp].saved_regs22,ebp               ; Save ebp/ebx/edi/esi
        mov [esp+4].saved_regs22,ebx
        mov [esp+8].saved_regs22,edi
        mov [esp+12].saved_regs22,esi

        mov eax,[edx]                            ; Load first two matrix entries
        mov ebx,[edx+4]

        mov ebp,[esp+TYPE mul22_locals_t+4+12]
                                         ; ebp = lvec = remaining loop count
        mov edi,[esp+TYPE mul22_locals_t+4+4]    ; edi = vec1 address

        mov [esp].mat,eax               ; Copy first two matrix entries to stack
        mov [esp+4].mat,ebx

        mov eax,[edx+8]                          ; Load rest of matrix
        mov ebx,[edx+12]

        mov esi,[esp+TYPE mul22_locals_t+4+8]    ; esi = vec2 address
        test ebp,ebp                             ; Check whether loop count == 0

        mov [esp+8].mat,eax                      ; Store rest of matrix
        mov [esp+12].mat,ebx

        mov [esp].carry1,ecx             ; carry1 = 0  (and ecx has carry2 = 0)
        jz mul22u_exit0                          ; Exit if lvec == 0

mul22u_loop1:

        mov edx,[edi]                             ; edx = vec1[i]
        mov eax,[esp].mat                         ; eax = m11

        mov [esp].carry2,ecx                      ; Update carry2
        mov ecx,[esp].carry1

        mul edx                                   ; edx:eax = m11*vec1[i]

        xor ebx,ebx                               ; ebx:ecx = carry1
        add edi,4                                 ; Advance vec1[i] address

        add ecx,eax
        mov eax,[esp+4].mat                       ; eax = m12

        adc ebx,edx                          ; ebx:ecx = m11*vec1[i] + carry1
        mov edx,[esi]                             ; edx = vec2[i]

        mul edx                                   ; edx:eax = m12*vec2[i]

        add ecx,eax
        mov eax,[esp+8].mat                       ; eax = m21

        adc ebx,edx                               ; ebx:ecx += m12*vec2[i]
        mov edx,[edi-4]                           ; edx = vec1[old i]

        mul edx                                   ; edx:eax = m21*vec1[i]

        mov [edi-4],ecx                           ; Update vec1[old i]
        xor ecx,ecx

        mov [esp].carry1,ebx                      ; Update carry1
        mov ebx,[esp].carry2                      ; ecx:ebx = carry2

        add ebx,eax
        mov eax,[esp+12].mat                      ; eax = m22

        adc ecx,edx                           ; ecx:ebx += m21*(old vec1[i])
        mov edx,[esi]                             ; edx = vec2[i]

        mul edx                                   ; edx:eax = m22*vec2[i]

        add esi,4                                 ; Advance vec2[i] address
        add ebx,eax

        adc ecx,edx                               ; ecx:ebx += m22*vec2[i]
        dec ebp                                   ; Decrement loop counter

        mov [esi-4],ebx                           ; Update vec2[old i]
        jnz mul22u_loop1                          ; Continue until ebp == 0

        ; N.B.  ecx = carry2
mul22u_exit0:
        mov eax,[esp+TYPE mul22_locals_t+4+16] ; eax = address of carrys array
        mov edx,[esp].carry1

        mov ebp,[esp].saved_regs22
        mov ebx,[esp+4].saved_regs22

        mov edi,[esp+8].saved_regs22
        mov esi,[esp+12].saved_regs22

        add esp,TYPE mul22_locals_t               ; Remove struct from stack
        mov [eax],edx                             ; carrys[0] = carry1

        mov [eax+4],ecx                           ; carrys[1] = carry2
        mov eax,TRUE
        ret 20                            ; return, remove 5 args from stack

    }  /* end _asm IX86 */
} // mp_mul22u_asm


#define mp_mul22s_asm mp_mul22s
__declspec(naked) DRM_BOOL __stdcall mp_mul22s_asm
              (const digit_t mat[4],            // IN  (2 x 2 matrix of scalars)
               digit_t  vec1[],            // INOUT
               digit_t  vec2[],            // INOUT
               const DRM_DWORD  lvec,            // IN
               sdigit_t scarrys[2])        // OUT  (array of 2 scalars)
{
    __asm {
        mov edx,[esp+4]                          ; edx = mat
        sub esp,TYPE mul22_locals_t              ; Allocate space on stack

        xor ecx,ecx                              ; ecx = carry2 = 0
                             ; AGI delay here

        mov [esp].saved_regs22,ebp               ; Save ebp/ebx/edi/esi
        mov [esp+4].saved_regs22,ebx
        mov [esp+8].saved_regs22,edi
        mov [esp+12].saved_regs22,esi

        mov eax,[edx]                       ; Load first two matrix entries
        mov ebx,[edx+4]

        mov ebp,[esp+TYPE mul22_locals_t+4+12]
                                        ; ebp = lvec = remaining loop count
        mov edi,[esp+TYPE mul22_locals_t+4+4]    ; edi = vec1 address

        mov [esp].mat,eax               ; Copy first two matrix entries to stack
        mov [esp+4].mat,ebx

        mov eax,[edx+8]                          ; Load rest of matrix
        mov ebx,[edx+12]

        mov esi,[esp+TYPE mul22_locals_t+4+8]    ; esi = vec2 address
        test ebp,ebp                          ; Check whether loop count == 0

        mov [esp+8].mat,eax                      ; Store rest of matrix
        mov [esp+12].mat,ebx

        mov [esp].carry1,ecx              ; carry1 = 0  (and ecx has carry2 = 0)
        jz mul22s_exit0                          ; Exit if lvec == 0

mul22s_loop1:

        mov edx,[edi]                             ; edx = vec1[i]
        mov eax,[esp].mat                         ; eax = m11

        mov ebx,[esp].carry1
        mov [esp].carry2,ecx                      ; Update carry2

        mul edx                                   ; edx:eax = m11*vec1[i]

        sar ebx,31
        mov ecx,[esp].carry1                ; ebx:ecx = carry1 (sign extended)

        add ecx,eax
        mov eax,[esp+4].mat                       ; eax = m12

        adc ebx,edx                          ; ebx:ecx = m11*vec1[i] + carry1
        mov edx,[esi]                             ; edx = vec2[i]

        mul edx                                   ; edx:eax = m12*vec2[i]

        sub ecx,eax
        mov eax,[esp+8].mat                       ; eax = m21

        sbb ebx,edx                               ; ebx:ecx -= m12*vec2[i]
        mov edx,[edi]                             ; edx = vec1[i]

        mul edx                                   ; edx:eax = m21*vec1[i]

        mov [esp].carry1,ebx                      ; Update carry1
        mov ebx,[esp].carry2                      ; carry2

        mov [edi],ecx                             ; Update vec1[i]
        mov ecx,ebx                               ; carry2

        sar ecx,31                          ; ecx:ebx = carry2 (sign extended)
        add edi,4                                 ; Advance vec1[i] address

        sub ebx,eax
        mov eax,[esp+12].mat                      ; eax = m22

        sbb ecx,edx                               ; ecx:ebx -= m21*(old vec1[i])
        mov edx,[esi]                             ; edx = vec2[i]

        mul edx                                   ; edx:eax = m22*vec2[i]

        add esi,4                                 ; Advance vec2[i] address
        add ebx,eax

        adc ecx,edx                               ; ecx:ebx += m22*vec2[i]
        dec ebp                                   ; Decrement loop counter

        mov [esi-4],ebx                           ; Update vec2[old i]
        jnz mul22s_loop1                          ; Continue until ebp == 0

        ; N.B.  ecx = carry2
mul22s_exit0:
        mov eax,[esp+TYPE mul22_locals_t+4+16]  ; eax = address of scarrys array
        mov edx,[esp].carry1

        mov ebp,[esp].saved_regs22
        mov ebx,[esp+4].saved_regs22

        mov edi,[esp+8].saved_regs22
        mov esi,[esp+12].saved_regs22

        add esp,TYPE mul22_locals_t               ; Remove struct from stack
        mov [eax],edx                             ; carrys[0] = carry1

        mov [eax+4],ecx                           ; carrys[1] = carry2
        mov eax,TRUE
        ret 20                              ; return, remove 5 args from stack
    }  /* end _asm IX86 */
} // mp_mul22s_asm
#endif
/*
          No assembly code presently (1999) for non-Intel architectures.
          To add others, write an external procedure mp_mul22u or mp_mul22s,
          Then #define mp_mul22u_asm and/or mp_mul22s_asm to be
          the alternate procedure.
*/

#if !defined(mp_mul22u_asm)
#define mp_mul22u_asm mp_mul22u_c
#define mp_mul22u_c mp_mul22u
#endif

#if defined(mp_mul22u_c) 

DRM_API DRM_BOOL DRM_CALL mp_mul22u_c(
   __in_ecount(4)       const digit_t mat[4],            // IN  (2 x 2 matrix of scalars)
   __inout_ecount(lvec) digit_t  vec1[],            // INOUT
   __inout_ecount(lvec) digit_t  vec2[],            // INOUT
   __in const           DRM_DWORD lvec,             // IN
   __out_ecount(2)      digit_t  carrys[2] )         // OUT  (array of 2 scalars)
/*
      This routine is given a 2 x 2 matrix mat with elements m11, m12, m21, m22
      in order.  It is also given two multi-precision numbers vec1 and vec2
      of length lvec.  It does the matrix x vector multiplication

                ( m11  m12 )  ( vec1 )

                ( m21  m22 )  ( vec2 )

      and stores the results back in [vec1, vec2].
      Any carries (beyond lvec words) go into the carrys vector.

      RESTRICTION:  The scalars m11, m12, m21, m22 must be nonnegative
                    and satisfy m11 + m12 < RADIX,  m21 + m22 < RADIX.
                    Given these bounds, it is easy to check by induction
                    that carry1, carry2 are bounded by RADIX - 2.
*/
{
    DRM_DWORD i;
    DRM_BOOL OK = TRUE;
    digit_t carry1 = 0, carry2 = 0;
    const digit_t m11 = mat[0], m12 = mat[1], m21 = mat[2], m22 = mat[3];

    if (m12 > RADIXM1 - m11 || m21 > RADIXM1 - m22) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA, "mp_mul22u");
    }
    if (OK) {
        for (i = 0; i != lvec; i++) {
            const DRM_UINT64 prod11 = MULTIPLY_ADD1(m11, vec1[i], carry1);
            const DRM_UINT64 prod21 = MULTIPLY_ADD1(m21, vec1[i], carry2);
            const DRM_UINT64 prod12 = MULTIPLY_ADD1(m12, vec2[i], DRM_UI64Low32(prod11));
            const DRM_UINT64 prod22 = MULTIPLY_ADD1(m22, vec2[i], DRM_UI64Low32(prod21));
            vec1[i] = DRM_UI64Low32(prod12);
            vec2[i] = DRM_UI64Low32(prod22);
            carry1 = DRM_UI64High32(prod11) + DRM_UI64High32(prod12);
            carry2 = DRM_UI64High32(prod21) + DRM_UI64High32(prod22);
        } // for i
    }
    carrys[0] = carry1;
    carrys[1] = carry2;
    return OK;
} // end mp_mul22u

#endif /* if C code compiled */


#if !defined(mp_mul22s_asm)
#define mp_mul22s_asm mp_mul22s_c
#define mp_mul22s_c mp_mul22s
#endif

#if defined(mp_mul22s_c) 

DRM_UINT64 SDBLINT(sdigit_t s)  // Convert signed value to DBLINT
{
    DRM_INT64 i64 = DRM_I64( s );
    DRM_UINT64 ui64;

    ui64 = *(DRM_UINT64*)&i64;
    return ui64;
}  // SDBLINT

DRM_API DRM_BOOL DRM_CALL mp_mul22s_c(
 __in_ecount(4)        const digit_t mat[4],       // IN  (2 x 2 matrix of scalars)
 __inout_ecount(lvec)  digit_t  vec1[],            // INOUT
 __inout_ecount(lvec)  digit_t  vec2[],            // INOUT
 __in                  const DRM_DWORD lvec,       // IN
 __out_ecount(2)       sdigit_t carrys[2] )        // OUT  (array of 2 scalars)
/*
      This routine resembles mp_mul22u except that the off-diagonal
      elements m12, m21 are treated as negative (with their absolute values
      passed in the array).  It does the matrix x vector multiplication

                (  m11  -m12 )  ( vec1 )

                ( -m21   m22 )  ( vec2 )

      and stores the results back in [vec1, vec2].
      Any carries (beyond lvec words) go into the carrys vector.

      Here carrys has type sdigit_t rather than digit_t.

      RESTRICTION:  The scalars m11, m12, m21, m22 must be nonnegative
                    and at most M, where M < RADIX/2.
                    This is more restrictive than mp_mul22u,
                    which checks only m11 + m12 and m21 + m22.
                    It is easy to check by induction that
                    carry1, carry2 are in [-M, M-1].
*/
{
    DRM_BOOL OK = TRUE;
    DRM_DWORD i;
    sdigit_t carry1 = 0, carry2 = 0;
    const digit_t m11 = mat[0], m12 = mat[1], m21 = mat[2], m22 = mat[3];

    if ((m11 | m12 | m21 | m22) & RADIX_HALF) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA, "mp_mul22s\n");
    }
    if (OK) {
        for (i = 0; i != lvec; i++) {
            const DRM_UINT64 prod11 = DPRODUU(m11, vec1[i]);
            const DRM_UINT64 prod12 = DPRODUU(m12, vec2[i]);
            const DRM_UINT64 prod21 = DPRODUU(m21, vec1[i]);
            const DRM_UINT64 prod22 = DPRODUU(m22, vec2[i]);
            DRM_UINT64 prod1, prod2;

            prod1 = DRM_UI64Add(prod11, SDBLINT(carry1));
            prod2 = DRM_UI64Add(prod22, SDBLINT(carry2));
            prod1 = DRM_UI64Sub(prod1, prod12);
            prod2 = DRM_UI64Sub(prod2, prod21);
            vec1[i] = DRM_UI64Low32(prod1);
            vec2[i] = DRM_UI64Low32(prod2);
            carry1 = (sdigit_t)DRM_UI64High32(prod1);
            carry2 = (sdigit_t)DRM_UI64High32(prod2);
        } // for i
    }
    carrys[0] = carry1;
    carrys[1] = carry2;
    return OK;
} // end mp_mul22s

#endif /* if C code compiled */

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\rc4.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmrc4.h>

ENTER_PK_NAMESPACE_CODE;

#include "rc4_key.inc"

/******************************************************************************/
DRM_API DRM_NO_INLINE DRM_VOID DRM_CALL DRM_RC4_Cipher(
    IN OUT                   RC4_KEYSTRUCT *pKS,
    IN                       DRM_UINT       cbBuffer,
    __inout_bcount(cbBuffer) DRM_BYTE      *pbBuffer )
{
    DRM_BYTE  i = pKS->i;
    DRM_BYTE  j = pKS->j;    
    DRM_BYTE *p = pKS->S;
    DRM_DWORD ib = 0;

    while (cbBuffer--)
    {
        DRM_BYTE bTemp1 = 0;
        DRM_BYTE bTemp2 = 0;

        i = ((i + 1) & (RC4_TABLESIZE - 1));
        bTemp1 = GET_BYTE(p,i);
        j = ((j + bTemp1) & (RC4_TABLESIZE - 1));
        
        PUT_BYTE(p,i,GET_BYTE(p,j));
        PUT_BYTE(p,j,bTemp1);
        bTemp2 = GET_BYTE(pbBuffer,ib);

        bTemp2 ^= GET_BYTE(p, (GET_BYTE(p,i) + bTemp1) & (RC4_TABLESIZE - 1));
        PUT_BYTE(pbBuffer,ib,bTemp2);
        ib++;
    }

    pKS->i = i;
    pKS->j = j;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\multlow.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
      File multiply_low.c.    Version 10 December 2000
*/      
#include "bignum.h"

ENTER_PK_NAMESPACE_CODE;

#if defined (_MSC_VER) && DRM_USE_ASSEMBLY
    #pragma warning(disable : 4100)      /* Unreferenced formal parameter */
#endif

/****************************************************************************/
#if defined(_M_IX86) && DRM_USE_ASSEMBLY
__declspec(naked) DRM_VOID __stdcall multiply_low(const digit_t  a[],
                                    const digit_t  b[],
                                    digit_t   c[],
                                    const DRM_DWORD lng )
#else
DRM_API DRM_NO_INLINE  DRM_VOID DRM_CALL multiply_low(
                                    const digit_t  a[],
                                    const digit_t  b[],
                                    digit_t   c[],
                                    const DRM_DWORD lng )
#endif
/*
        This routine multiplies two integers a and b of length lng,
        returning the low half of the product in c.  That is,
        c == a*b (mod RADIX^lng).  The top of c is unchanged.

        If lng = 2n, then this code uses n^2 + 2n multiplications,
        whereas a full Karatsuba multiplication uses about n^1.58.
        This code uses fewer multiplications for lng <= 20.
        This routine has less overhead than the standard Karatsuba
        multiplication (which gets the full product)

                2n      n^2 + 2n         Karatsuba

                 2          3                3
                 4          8                9
                 6         15               18
                 8         24               27
                10         35
                12         48               54
                14         63
                16         80               81
                24        168              162
                32        288              243

        We rewrite (assuming lng = 5)

                (a0 + a1*R + a2*R^2 + a3*R^3 + a4*R^4)
              * (b0 + b1*R + b2*R^2 + b3*R^3 + b4*R^4)
        as
                  (a0*b0 + a1*b1*R + a2*b2*R^2 + a3*b3*R^3 + a4*b4*R^4)
                * (1 + R + R^2 + R^3 + R^4)
              - R*(a1 - a0)*(b1 - b0)
              - R^2*(a2 - a0)*(b2 - b0)
              - R^3*[(a3 - a0)*(b3 - b0) + (a2 - a1)*(b2 - b1)]
              - R^4*[(a4 - a0)*(b4 - b0) + (a3 - a1)*(b3 - b1)]
              - (multiple of R^5)

        The products (ai - aj)*(bi - bj) can be positive or negative.
        We accumulate positive and negative terms in separate arrays.
        Specifically, the even subscripts in the ctemp array
        (i.e., ctemp[0], ctemp[2], ctemp[4], ...)
        contain the positive terms, while
        its odd subscripts (ctemp[1], ctemp[3], ctemp[5])
        contain the negated terms.  At the end,
        we subtract the negated terms from the positive terms
        and store the difference in the c array.

        To obtain

                  (a0*b0 + a1*b1*R + a2*b2*R^2 + a3*b3*R^3 + a4*b4*R^4)
                * (1 + R + R^2 + R^3 + R^4)

        modulo R^5, we note the second term is 1/(1-R) (mod R^5).
        Define absum[k] by

                  a0*b0 + ... + a[k]*b[k]*R^k
                = (c0 + c1*R + ... + c[k]*R^k)*(1 - R)
                  + absum[k]*R^(k+1).

        The recurrence for absum[k] is

                  absum[-1] = c[-1] = 0

                  absum[k]*R^(k+1) + c[k]*R^k*(1 - R)
                = absum[k-1]*R^k + a[k]*b[k]*R^k
        or
                  R*(absum[k] - c[k]) + c[k] = a[k]*b[k] + absum[k-1]

        Given single-words  absum[k-1] - c[k-1]  and  c[k-1],
        we can form the double-word

                a[k]*b[k]  +  (absum[k-1] - c[k-1])  +  c[k-1]

        From this, we extract  absum[k] - c[k]  and c[k].
*/
{
#if defined(_M_IX86) && DRM_USE_ASSEMBLY

    typedef struct {
             digit_t   *addrc;                   /* &c[0] */
             DRM_DWORD     lng;                      /* Saved value of lng */
             __int32   saved_regs[4];            /* ebp/ebx,edi/esi */
             digit_t   ctemp[2*MP_LONGEST+2];
             digit_t   acopy[MP_LONGEST | 1];    /* Copy of a array */
             digit_t   bcopy[MP_LONGEST | 1];    /* Copy of b array */
                   } mullow_locals_t;

                       /* Note -- copying the arrays to acopy
                          and bcopy simplifies indexing in inner
                          loops, since there are insufficient
                          registers to save &a[0] and &b[0].
                          The acopy array has an odd length,
                          to ensure bcopy - acopy is not
                          a multiple of 32 bytes.
                       */
  _asm {

                /*
                     Load formal parameters.
                     Modify register ebp last.
                */

    mov   ecx,[esp+4+8]             ; c
    sub   esp,TYPE mullow_locals_t  ; Allocate space for local struct
                                    ; AGI delay (esp)
    mov   [esp].saved_regs,ebp
    mov   [esp+4].saved_regs,ebx
    mov   [esp+8].saved_regs,edi
    mov   [esp+12].saved_regs,esi

    mov   ebp,[esp+TYPE mullow_locals_t+4+12] ; lng
    mov   esi,[esp+TYPE mullow_locals_t+4+0]  ; a
    mov   edi,[esp+TYPE mullow_locals_t+4+4]  ; b
    cmp   ebp,0
    je    mullow_exit               ; Exit if lng = 0

    mov   eax,[esi]                 ; eax = a[0]
    mov   ebx,[edi]                 ; ebx = b[0]
    mov   [esp].acopy,eax           ; Store acopy[0]
    mul   ebx                       ; edx:eax = dsum = a[0]*b[0]

    cmp   ebp,2                     ; Compare lng to 2

    jle    mullow_lng_le_2          ; Branch if lng <= 2
/*
                                Case lng > 2
*/
    mov  [esp].lng,ebp             ; Save ebp = lng
    mov  [esp].addrc,ecx           ; Save ecx = &c[0]
    mov  ebp,1                     ; ebp = i = 1
    mov  [esp].bcopy,ebx           ; Store bcopy[0] = ebx = b[0]
    mov  ebx,eax
    mov  ecx,edx                   ; ecx:ebx = dsum

mullow_loop1:
    mov  [esp+8*ebp-8].ctemp,ebx   ; Store ctemp[2*i - 2] = ebx = LOW(dsum)
    add  ebx,ecx                   ;
    mov  eax,[esi+4*ebp]           ; eax = a[i]
    mov  ecx,0

    mov  edx,[edi+4*ebp]           ; edx = b[i]
                                   ; Possible data cache conflict
    mov  [esp+8*ebp-4].ctemp,ecx   ; Store ctemp[2*i - 1] = 0

    adc  ecx,ecx                   ; ecx:ebx = HIGH(dsum) + LOW(dsum)
    mov  [esp+4*ebp].acopy,eax     ; Store acopy[i] = eax = a[i]
    mov  [esp+4*ebp].bcopy,edx     ; Store bcopy[i] = ebx = b[i]
    inc  ebp                       ; Advance i
    mul  edx                       ; edx:eax = a[i]*b[i]
    add  ebx,eax
    mov  eax,[esp].lng             ; eax = lng = loop bound
    adc  ecx,edx                   ; ecx:ebx = dsum
                                   ;         =   a[i]*b[i]
                                   ;           + HIGH(old dsum)
                                   ;           + LOW(old dsum)
    cmp  ebp,eax                   ; Compare (new i) to lng
    jne  mullow_loop1              ; Continue until i = lng
                                /*
                                        At this point

                                        eax = ebp = lng
                                        ecx:ebx = final dsum
                                */
    xor  esi,esi                   ; esi = 2*i = 0
    mov  [esp+8*ebp-8].ctemp,ebx   ; Store ctemp[2*lng-2] = LOW(dsum)

    mov  ebx,[esp].acopy           ; ebx = acopy[0]
    mov  ecx,[esp].bcopy           ; ecx = bcopy[0]
    lea  edi,[2*ebp-2]             ; edi = 2*((first j) + 1) = 2*(lng - 1)

    mov  [esp+8*ebp-4].ctemp,esi   ; Store ctemp[2*lng-1] = 0
    mov  [esp+8*ebp].ctemp,esi     ;       ctemp[2*lng  ] = 0
    mov  [esp+8*ebp+4].ctemp,esi   ;       ctemp[2*lng+1] = 0

mullow_loopi:
                                /*
                                        Before branching here, set

                                            ebp = lng
                                            ebx = acopy[i]
                                            ecx = bcopy[i]
                                            esi = 2*i
                                            edi = 2*(j+1) = 2*(lng - i - 1)
                                */
    mov  eax,[esp+2*edi].acopy         ; eax = acopy[j+1]
    mov  edx,[esp+2*edi].bcopy         ; edx = bcopy[j+1]
    sub  eax,ebx                       ; eax = adif = acopy[j+1] - acopy[i]
    sub  edx,ecx                       ; edx = bdif = bcopy[j+1] - bcopy[i]

    imul eax,edx                       ; eax = LOW(adif*bdif)

    mov  edx,[esp+8*ebp-4].ctemp       ; edx = ctemp[2*lng-1]
    add  esi,2                         ; Advance 2*i by 2

    add  edx,eax                       ; edx = LOW(adif*bdif + ctemp[2*lng-1])
                                       ; TBD -- poor Pentium P5 pairing here
    mov  [esp+8*ebp-4].ctemp,edx       ; Store new ctemp[2*lng-1]

mullow_loopj:
/*
                        Before branching here, set

                                          ebx = acopy[i]
                                          ecx = bcopy[i]
                                          edi = 2*j + 2
                                          esi = 2*i + 2
*/
    mov  eax,[esp+2*edi-4].acopy        ; eax = acopy[j]
    mov  edx,[esp+2*edi-4].bcopy        ; edx = bcopy[j]
    lea  ebp,[edi+esi-3]                ; ebp = 2*i + 2*j + 1
    sub  eax,ebx                        ; eax = adif = acopy[j] - acopy[i]
    sbb  ebx,ebx                        ; ebx = asgn
    sub  edx,ecx                        ; edx = bdif = bcopy[j] - bcopy[i]
    sbb  ecx,ecx                        ; ecx = bsgn

    add  eax,ebx                        ; eax = adif + asgn
    xor  eax,ebx                        ; eax = | adif |
    xor  ebx,ecx                        ; ebx = absgn = asgn^bsgn

    add  edx,ecx                        ; edx = bdif + bsgn
    add  ebp,ebx                        ; ebp = csub = absgn + 2*i + 2*j + 1
    xor  edx,ecx                        ; edx = | bdif |

    mul  edx                            ; edx:eax = |adif|*|bdif|

    mov  ecx,[esp+4*ebp].ctemp          ; ecx = ctemp[csub]
    mov  ebx,[esp+4*ebp+8].ctemp        ; ebx = ctemp[csub+2]
    add  ecx,eax                        ; ctemp[csub] += eax

    lea  edi,[edi-2]                    ; Decrement 2*j + 2 by 2
    mov  [esp+4*ebp].ctemp,ecx          ; Update ctemp[csub]

mullow_carryprop:
    lea  ebp,[ebp+2]                    ; Advance csub by 2
                                        ; (Note -- this pairs with mov
                                        ;  on first iteration of loop.
                                        ;  Loop executes about 10/9 times)

    adc  ebx,edx                        ; ctemp[(old csub) + 2] += edx + CF
    mov  edx,0                          ; Clear edx for future iterations
    mov  [esp+4*ebp].ctemp,ebx          ; Update ctemp[(old csub) + 2]
    mov  ebx,[esp+4*ebp+8].ctemp        ; ebx = ctemp[(new csub) + 2]
    jc   mullow_carryprop               ; If CF <> 0, continue

    cmp  esi,edi                        ; Compare 2*i + 2 to 2*(new j) + 2
    mov  ebx,[esp+2*esi-4].acopy        ; ebx = acopy[i]
    mov  ecx,[esp+2*esi-4].bcopy        ; ecx = bcopy[i]
    jne  mullow_loopj
/*
                                At this point

                                        esi = edi = 2*i + 2 = 2*(new i)
*/
    mov  ebp,[esp].lng               ; ebp = lng
    xor  edi,-2                      ; edi = -2 - (2*i + 2) = -4 - 2*i

                                     ; (both operands are even)

    mov  ebx,[esp+2*esi].acopy       ; ebx = acopy[new i]
    mov  ecx,[esp+2*esi].bcopy       ; ecx = bcopy[new i]

    lea  edx,[esi+2]                 ; edx = 2*(new i) + 2
    lea  edi,[edi+2*ebp]             ; edi = 2*lng - 2*i - 4
                                     ;     = 2*(lng - 1 - (new i))
    cmp  edx,edi                     ; Compare 2*(new i) + 2
                                     ;      to 2*(lng - 1 - (new i))
    jl   mullow_loopi              ; Continue if (new i) + 1 < lng - 1 - (new i)

    shr  ebp,1                       ; ebp = FLOOR(lng/2); set CF
    lea  esi,[esp].ctemp             ; esi = &ctemp[0]
    mov  edi,[esp].addrc             ; edi = &c[0]
    jnc  mullow_final_even           ; Branch if lng is even



    mov  edx,[esi]                  ; edx = ctemp[0]
    mov  ecx,[esi+4]                ; ecx = ctemp[1]
    sub  edx,ecx                    ; edx = ctemp[0] - ctemp[1]

mullow_final_odd_sub:
    mov  ebx,[esi+8]                ; ebx = ctemp[2*i]
    mov  eax,[esi+12]               ; eax = ctemp[2*i+1]
    mov  [edi],edx                  ; Store c[i-1]
    lea  edi,[edi+8]                ; Advance &c[i-1] by 2 dwords
    mov  edx,[esi+16]               ; edx = ctemp[2*i+2]
    mov  ecx,[esi+20]               ; ecx = ctemp[2*i+3]
    sbb  ebx,eax                    ; ebx = ctemp[2*i] - ctemp[2*i+1] - CF
    lea  esi,[esi+16]               ; Advance &ctemp[2*i-2] by 4 dwords
    sbb  edx,ecx                    ; edx = ctemp[2*i+2] - ctemp[2*i+3] - CF
    dec  ebp                        ; Decrement loop counter
    mov  [edi-4],ebx                ; Store c[i]
    jnz  mullow_final_odd_sub

    mov  [edi],edx                  ; Store c[lng-1]
    jz   mullow_exit                ; Exit


mullow_lng_le_2:                    ; Come here is lng <= 2
    mov   [ecx],eax                 ; Store c[0] = LOW(dsum)
    jne   mullow_exit               ; Exit if lng = 1

                                /*
                                        Case lng = 2
                                */

    mov   eax,[esi+4]               ; eax = a[1]
    mov   esi,[esi]                 ; esi = a[0]

    imul  eax,ebx                   ; eax = LOW(a[1]*b[0])
    mov   ebx,[edi+4]               ; ebx = b[1]
    add   edx,eax                   ; edx = HIGH(dsum) + a[1]*b[0] mod RADIX

    imul  esi,ebx                   ; esi = LOW(a[0]*b[1])
    add   edx,esi
    mov   [ecx+4],edx               ; Store c[1]
    jmp   mullow_exit



mullow_final_even:
                                /*
                                      At this point:

                                          ebp = lng/2
                                          edi = @c[0]
                                          esi = @ctemp[0]
                                          ebx = acopy[lng/2 - 1]
                                          ecx = bcopy[lng/2 - 1]
                                */
    mov  eax,[esp+4*ebp].acopy       ; eax = acopy[lng/2]
    mov  edx,[esp+4*ebp].bcopy       ; edx = bcopy[lng/2]
    sub  eax,ebx                     ; eax = adif
    sub  edx,ecx                     ; edx = bdif
    mov  ebx,[esi]                   ; ebx = ctemp[0]
    mov  ecx,[esi+4]                 ; ecx = ctemp[1]

    imul eax,edx                     ; eax = LOW(adif*bdif)
    mov  edx,[esi+8]                 ; edx = ctemp[2]
    sub  ebx,ecx                     ; ebx = ctemp[0] - ctemp[1]
    mov  ecx,[esi+12]                ; ecx = ctemp[3]
    dec  ebp                         ; ebp = lng/2 - 1 = loop count
    sbb  edx,ecx                     ; edx = ctemp[3] - ctemp[2] - CF
    mov  [edi],ebx                   ; Store c[0] = ebx

mullow_final_even_sub:
    mov  ebx,[esi+16]                ; ebx = ctemp[2*i + 2]
    mov  ecx,[esi+20]                ; ecx = ctemp[2*i + 3]
    mov  [edi+4],edx                 ; Store c[i-1] = edx
    lea  edi,[edi+8]                 ; Advance &c[i-2] by 2 dwords
    sbb  ebx,ecx                     ; ebx = ctemp[2*i + 2] - ctemp[2*i + 3] - CF
    mov  edx,[esi+24]                ; ebx = ctemp[2*i + 4]
    mov  ecx,[esi+28]                ; ecx = ctemp[2*i + 5]
    lea  esi,[esi+16]                ; Advance &ctemp[2*i - 2] by 4 dwords
    sbb  edx,ecx                     ; edx = ctemp[2*i + 4] - ctemp[2*i + 5] - CF
    dec  ebp                         ; Decrement loop counter
    mov  [edi],ebx                   ; Store  c[i] = ebx
    jnz  mullow_final_even_sub

    sub  edx,eax                     ; Subtract LOW(adif*bdif)
    mov  [edi+4],edx                 ; Store c[lng-1]


mullow_exit:
    mov  ebp,[esp].saved_regs
    mov  ebx,[esp+4].saved_regs
    mov  edi,[esp+8].saved_regs
    mov  esi,[esp+12].saved_regs
    add  esp,TYPE mullow_locals_t    ; Restore esp
    ret 16                           ; pop off all 4 arguments from the stack
    } /* asm IX86 */
#else

    DRM_UINT64 dsum;

    if (lng == 0) return;

    dsum = DPRODUU(a[0], b[0]);
    if ((lng > 2) && (lng <= MP_LONGEST)) {
        digit_t borrow;
        DRM_DWORD i, j;
        digit_t ctemp[2*MP_LONGEST + 2];

        for (i = 1; i != lng; i++) {
            ctemp[2*i-2] = DRM_UI64Low32(dsum);
            ctemp[2*i-1] = 0;
            dsum = MULTIPLY_ADD2(a[i], b[i], DRM_UI64High32(dsum), DRM_UI64Low32(dsum));
        }
        ctemp[2*lng-2] = DRM_UI64Low32(dsum);
        ctemp[2*lng-1] = 0;
        ctemp[2*lng  ] = 0;
        ctemp[2*lng+1] = 0;  /* So inner loop will terminate */
                             /* (i.e., carries will not propagate beyond here) */

        for (i = 0; 2*i < lng-2; i++) {
            const digit_t ai = a[i];
            const digit_t bi = b[i];

            ctemp[2*lng-1] += (a[lng-1-i] - ai)*(b[lng-1-i] - bi);

            for (j = lng-2-i; j != i; j--) {
                digit_t adif = a[j] - ai;
                digit_t bdif = b[j] - bi;

                const digit_t asgn = -(a[j] < ai);
                const digit_t bsgn = -(b[j] < bi);
                digit_t carry;
                DRM_DWORD csub;

                adif = (adif + asgn)^asgn;
                bdif = (bdif + bsgn)^bsgn;
                csub = 2*(i + j) + (DRM_DWORD)((asgn^bsgn) + 1);
                         /* even subscript if adding, odd if subtracting */
                dsum = MULTIPLY_ADD1(adif, bdif, ctemp[csub]);
                ctemp[csub] = DRM_UI64Low32(dsum);                
                dsum = DRM_UI64Add32(ctemp[csub+2], DRM_UI64High32(dsum) );
                ctemp[csub+2] = DRM_UI64Low32(dsum);
                carry = DRM_UI64High32(dsum);
                do {
                    ctemp[csub+4] += carry;
                    carry = (ctemp[csub+4] < carry);
                    csub += 2;
                } while ((carry != 0) && (csub < (2*MP_LONGEST - 2)));
            } /* for j */

        } /* for i */

        if (IS_EVEN(lng)) {
            const DRM_DWORD lnghalf = lng >> 1;
            ctemp[2*lng-1] +=   (a[lnghalf] - a[lnghalf-1])
                              * (b[lnghalf] - b[lnghalf-1]);
        }

        borrow = 0;
        for (i = 0; i < lng; i++) {
            const digit_t diff = ctemp[2*i] - ctemp[2*i+1];
            const digit_t new_borrow = (ctemp[2*i] < ctemp[2*i+1]);

            c[i] = diff - borrow;
            if (diff != 0) borrow = new_borrow;
        }
    } else if (lng == 2) {
        c[0] = DRM_UI64Low32(dsum);
        c[1] = DRM_UI64High32(dsum) + a[0]*b[1] + a[1]*b[0];  /* mod RADIX */
    } else if (lng == 1) {
        c[0] = DRM_UI64Low32(dsum);
    } else {
        TRACE( ( "Unexpected length %ld in multiply_low.\n", ( DRM_LONG )lng ) );
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA, "multiply_low");
    }
#endif  /* assembly */
} /* multiply low */

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\rc4_key.inc ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
 * This implementation file is #included by Rc4.c
 */
DRM_API DRM_NO_INLINE DRM_VOID DRM_CALL DRM_RC4_KeySetup(
        OUT   RC4_KEYSTRUCT  *pKS,
    IN        DRM_DWORD       cbKey,
    IN  const DRM_BYTE       *pbKey )
{
    DRM_BYTE j;
    DRM_BYTE k;
    DRM_BYTE t;
    DRM_INT  i;

    for (i=0;i<RC4_TABLESIZE;i++)
    {
        PUT_BYTE( pKS->S, i, (DRM_BYTE)i);
    }
    
    pKS->i = 0;
    pKS->j = 0;
    j      = 0;
    k      = 0;
    for (i=0;i<RC4_TABLESIZE;i++)
    {
        t = GET_BYTE(pKS->S,i);
        j = (DRM_BYTE)((j + t + GET_BYTE(pbKey, k)) % RC4_TABLESIZE);        
        PUT_BYTE( pKS->S, i, GET_BYTE(pKS->S, j) );
        PUT_BYTE(pKS->S, j, t);
        k = (DRM_BYTE) ((k + 1) % cbKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\mprand.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
        File mprand.c.  This file has some routines which
        generate random numbers with special distributions.

        DRM_BOOL random_digit_interval(dlow, dhigh, pdout)
              -- Generate pseudorandom value *pdout, dlow <= *pdout <= dhigh.

        DRM_BOOL random_mod(n, array, lng)
                 -- Generate random multiple-precision
                    value -array-, 0 <= array < n.

        DRM_BOOL random_mod_nonzero(n, array, lng)
                 -- Generate random multiple-precision
                    value -array-, 1 <= array < n.

  Alse see file randminv.c
*/
#define MPRAND_C 1   // Tested in mprand.h

#include "bignum.h"
#include "mprand.h"

ENTER_PK_NAMESPACE_CODE;


DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL random_digit_interval
        (const digit_t  dlow,
         const digit_t  dhigh,
         digit_t  *pdout,
         struct bigctx_t *f_pBigCtx)

{                       /* Return random integer in [dlow, dhigh] */
    DRM_BOOL OK = TRUE;

    if (dhigh < dlow) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "random_digit_interval");
    } else {
        const digit_t spread = dhigh - dlow;
        const DRM_DWORD shift_count = RADIX_BITS - significant_bit_count(spread | 1);
        digit_t result = 0;
        do {
            OK = OK && random_digits(&result, 1, f_pBigCtx);
            result >>= shift_count;
        } while (OK && result > spread);
        *pdout = dlow + result;
    }
    return OK;
} /* random_digit_interval */

/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL random_mod
        (const digit_t   n[],
         digit_t    arr[],
         const DRM_DWORD  lng,
         struct bigctx_t *f_pBigCtx)
/*
        Generate pseudorandom value in [0, n - 1].
        n has length lng and must be nonzero.
*/
{
    DRM_DWORD lngsig = lng;
    DRM_BOOL OK = TRUE;

    while (lngsig > 0 && n[lngsig-1] == 0) {
        arr[lngsig-1] = 0;
        lngsig--;
    }

    if (!OK) {
    } else if (n == arr) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_OVERLAPPING_ARGS,
                        "random_mod");
    } else if (lngsig == 0) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_ZERO_OPERAND,
                        "random_mod");
    } else {
        const digit_t nlead = n[lngsig-1];
        DRM_INT ntry = 0;
        do {
            ntry++;
            if (ntry > 100) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_TOO_MANY_ITERATIONS,
                                "random_mod");
            }
            OK = OK && random_digits(arr, lngsig-1, f_pBigCtx);
            OK = OK && random_digit_interval(0, nlead,
                                        &arr[lngsig-1], f_pBigCtx);
        } while (OK && compare_same(arr, n, lngsig) >= 0);
    }
    return OK;
} /* random_mod */
/****************************************************************************/
DRM_API DRM_NO_INLINE DRM_BOOL DRM_CALL random_mod_nonzero
        (const digit_t   n[],
         digit_t    arr[],
         const DRM_DWORD  lng,
         struct bigctx_t *f_pBigCtx)
/*
        Generate pseudorandom value in [1, n-1].  Require n > 1.
*/
{
    DRM_BOOL OK = TRUE;

    if (compare_immediate(n, DIGIT_ONE, lng) <= 0) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "random_mod_nonzero");
    } else {
        DRM_INT ntry = 0;
        do {
            ntry++;
            if (ntry > 100) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_TOO_MANY_ITERATIONS,
                                "random_mod_nonzero");
            } else {
                OK = random_mod(n, arr, lng, f_pBigCtx);
            }
        } while (OK && significant_digit_count(arr,  lng) == 0);
    }
    return OK;
} /* random_mod_nonzero */

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\stdafx.h ===
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_drmplayready_none_12.4.56.0_none_b3b76aec4402d0fe
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_drmplayready_no-public-key_12.4.56.0_x-ww_1dd57206
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=drmplayready
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_drmplayready_no-public-key_12.4.56.0_x-ww_1dd57206
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_drmplayready_no-public-key_12.4.56.0_x-ww_1dd57206.manifest
XP_MANIFEST_PATH=manifests\x86_drmplayready_no-public-key_12.4.56.0_x-ww_1dd57206.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_drmplayready_no-public-key_12.4.56.0_x-ww_1dd57206.cat
XP_CATALOG_PATH=manifests\x86_drmplayready_no-public-key_12.4.56.0_x-ww_1dd57206.cat
XP_PAYLOAD_PATH=x86_drmplayready_no-public-key_12.4.56.0_x-ww_1dd57206
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=drmplayready,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\drm_lib\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_drmplayready_none_12.4.56.0_none_b3b76aec4402d0fe
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_drmplayready_no-public-key_12.4.56.0_x-ww_1dd57206
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=drmplayready
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_drmplayready_no-public-key_12.4.56.0_x-ww_1dd57206
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_drmplayready_no-public-key_12.4.56.0_x-ww_1dd57206.manifest
XP_MANIFEST_PATH=manifests\x86_drmplayready_no-public-key_12.4.56.0_x-ww_1dd57206.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_drmplayready_no-public-key_12.4.56.0_x-ww_1dd57206.cat
XP_CATALOG_PATH=manifests\x86_drmplayready_no-public-key_12.4.56.0_x-ww_1dd57206.cat
XP_PAYLOAD_PATH=x86_drmplayready_no-public-key_12.4.56.0_x-ww_1dd57206
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=drmplayready,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\asfsample.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef NDTASFSAMPLE_H
#define NDTASFSAMPLE_H

#include <asfmediabuffer.h>
#include <drmptrlist.h>

ENTER_PK_NAMESPACE;

#define ASF_SAMPLE_READY             ((DRM_DWORD) 0x00000020)
#define MF_SAMPLE_FLAG_CLEANPOINT    ((DRM_DWORD) 0x00000004)
#define MF_SAMPLE_FLAG_DISCONTINUITY ((DRM_DWORD) 0x00000002)

typedef struct __tagASF_SAMPLE
{
    DRM_DWORD               dwFlags;
    DRM_DWORD               cRef;
                           
    DRM_DWORD               dwStreamNumber;
                           
    DRM_UINT64              hnsSampleTime;
    DRM_UINT64              hnsSampleDuration;
    DRM_DWORD               cbTotalLength;
    PTR_LIST                MediaBuffers;

    DRM_BYTE                bRepData;
    DRM_BYTE                rgbRepData[256]; /* NOTE: dynamic allocation could save space here */

} ASF_SAMPLE;


DRM_RESULT ASFSample_Initialize(
    __out ASF_SAMPLE * const f_pAsfSample
);

DRM_RESULT ASFSample_GetBufferCount(
    __in const  ASF_SAMPLE * const f_pAsfSample,
    __out       DRM_DWORD  * const f_pdwBufferCount
);

DRM_RESULT ASFSample_GetBufferByIndex(
    __in const  ASF_SAMPLE  * const f_pAsfSample,
    __in const  DRM_DWORD           f_dwIndex,
    __out       ASF_MEDIA_BUFFER  **f_ppBuffer
);

DRM_RESULT ASFSample_AddBuffer(
    __inout  ASF_SAMPLE        * const f_pAsfSample,
    __in     ASF_MEDIA_BUFFER  * const f_pBuffer
);

DRM_VOID ASFSample_RemoveBufferByIndex(
    __in        ASF_SAMPLE * const f_pAsfSample,
    __in const  DRM_DWORD          f_dwIndex
);

DRM_RESULT ASFSample_GetTotalLength(
    __in const ASF_SAMPLE * const f_pAsfSample,
    __out      DRM_DWORD  * const f_pcbTotalLength
);

DRM_RESULT ASFSample_CopyToBuffer(
    __in const                 ASF_SAMPLE * const f_pAsfSample,
    __out_bcount(*f_pcbBuffer) DRM_BYTE   * const f_pbBuffer,
    __inout                    DRM_DWORD  * const f_pcbBuffer 
);

DRM_RESULT ASFSample_AddRef(
    __in     ASF_SAMPLE * const f_pAsfSample
);

DRM_VOID ASFSample_Release(
    __in ASF_SAMPLE *pAsfSample
);

EXIT_PK_NAMESPACE;

#endif /* NDTASFSAMPLE_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\asfmediabuffer.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef NDTASFMEDIABUFFER_H
#define NDTASFMEDIABUFFER_H

ENTER_PK_NAMESPACE;

typedef struct __tagASF_MEDIA_BUFFER
{
    DRM_DWORD                     cRef;
    DRM_BYTEBLOB                  blobBuffer;
    DRM_DWORD                     cbCurrentOffset;
    DRM_DWORD                     cbCurrentLength;
    DRM_DWORD                     dwFlags;

    struct __tagASF_MEDIA_BUFFER *pOriginalBuffer;

} ASF_MEDIA_BUFFER;

DRM_RESULT ASFMediaBuffer_Initialize(
    __inout    ASF_MEDIA_BUFFER * const pAsfMediaBuffer,
    __in const DRM_BYTEBLOB             blobBuffer,
    __in const DRM_DWORD                cbOffset
);

DRM_RESULT ASFMediaBuffer_InitializeWrapper(
    __inout    ASF_MEDIA_BUFFER * const pAsfMediaBufferWrapper,
    __in       ASF_MEDIA_BUFFER * const pOriginalAsfMediaBuffer,
    __in const DRM_DWORD                cbOffset,
    __in const DRM_DWORD                cbCurrentLength
);

DRM_VOID ASFMediaBuffer_Uninitialize(
    __inout    ASF_MEDIA_BUFFER * const pAsfMediaBuffer
);

DRM_RESULT ASFMediaBuffer_AddRef(
    __inout    ASF_MEDIA_BUFFER * const pAsfMediaBuffer
);

DRM_VOID ASFMediaBuffer_Release(
    __inout    ASF_MEDIA_BUFFER        *pAsfMediaBuffer
);

EXIT_PK_NAMESPACE;

#endif /* NDTASFMEDIABUFFER_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\bigdefs.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef BIGDEFS_H              /* If not previously #included */
#define BIGDEFS_H 1

//       File bigdefs.h     Version 10 February 2004

//       This file declared the fundamental types and constants used
//       within the bignum code.

//           digit_t
//           sdigit_t
//
//        used within the bignum code and headers.
//        We also declare the most fundamental routines for operating on these.
//
//        If you need to perform arithmetic, not just copy data, see bignum.h .

#include <drmcommon.h>

ENTER_PK_NAMESPACE;

/*
      Occasionally a struct name is used before the struct itself is
      declared.  The Future_Struct macro avoids a warning message
      with Visual C .NET (2002).
*/
#define Future_Struct(strname) struct strname


#if !DRM_INLINING_SUPPORTED

DRM_API DRM_DWORD DRM_CALL significant_bit_count(const digit_t);
                 /* Has special code on some platforms */

DRM_API DRM_DWORD DRM_CALL mp_significant_bit_count
                            (const digit_t *, const DRM_DWORD);

DRM_API DRM_BOOL DRM_CALL digits_to_dwords(const digit_t *, DRM_DWORD*, const DRM_DWORD );

DRM_API DRM_BOOL DRM_CALL dwords_to_digits(const DRM_DWORD*, digit_t *, const DRM_DWORD );

DRM_API DRM_VOID DRM_CALL mp_extend(const digit_t *, const DRM_DWORD, digit_t *, const DRM_DWORD );

DRM_API digit_t DRM_CALL mp_getbit(const digit_t *, const DRM_DWORD);

DRM_API DRM_VOID DRM_CALL mp_setbit(digit_t *, const DRM_DWORD, const digit_t );

DRM_API DRM_DWORD DRM_CALL significant_digit_count(const digit_t *, const DRM_DWORD);
#endif

#if DRM_INLINING_SUPPORTED

DRMINLINE DRM_VOID DRM_CALL mp_extend
        (const digit_t  a[],
         const DRM_DWORD lnga,
         digit_t   b[],
         const DRM_DWORD lngb )
/*
        Copy a to b, while changing its length from
        lnga to lngb (zero fill).  Require lngb >= lnga.
*/
{    
    MEMCPY( b,a,( lnga)*SIZEOF( digit_t ));
    ZEROMEM(b + lnga,( lngb - lnga)*SIZEOF( digit_t ));
}  // mp_extend
/****************************************************************************/
DRMINLINE digit_t DRM_CALL mp_getbit
        (const digit_t a[],
         const DRM_DWORD ibit)
                /* Extract bit of multiple precision number */
{
    return digit_getbit(a[ibit/RADIX_BITS],  ibit % RADIX_BITS);
}
/****************************************************************************/
DRMINLINE DRM_VOID DRM_CALL mp_setbit
        (digit_t   a[],
         const DRM_DWORD ibit,
         const digit_t  new_value)
/*
        Set a bit to 0 or 1,
        when the number is viewed as a bit array.
*/

{
    const DRM_DWORD j       = ibit / RADIX_BITS;
    const DRM_DWORD ishift  = ibit % RADIX_BITS;

    const digit_t mask1 = (DIGIT_ONE &  new_value) << ishift;
    const digit_t mask2 = (DIGIT_ONE & ~new_value) << ishift;
    
    a[j] = (a[j] & ~mask2) | mask1;
} // end mp_setbit
/****************************************************************************/
DRMINLINE DRM_DWORD DRM_CALL significant_digit_count
        (const digit_t  a[],
         const DRM_DWORD    lng)
/*
        Return the number of significant digits in a.
        Function value is zero precisely when a == 0.
*/
{
    DRM_DWORD i = lng;

    while (i != 0 && a[i-1] == 0) i--;
    return i;
}  /* significant_digit_count */
/****************************************************************************/
DRMINLINE DRM_BOOL DRM_CALL digits_to_dwords
        (const digit_t  pdigit[],
         DRM_DWORD     pdword[],
         const DRM_DWORD lng_dwords)
{
    DRM_BOOL OK = TRUE;

#if DWORDS_PER_DIGIT == 1    
    MEMCPY( (digit_t*)pdword,pdigit,( lng_dwords)*SIZEOF( digit_t ));
#elif DWORDS_PER_DIGIT == 2
    const DRM_DWORD lng_half = lng_dwords >> 1;
    DRM_DWORD i;
    
    if (IS_ODD(lng_dwords)) {
        pdword[lng_dwords-1] = (DRM_DWORD)pdigit[lng_half];
    }
    for (i = 0; i != lng_half; i++) {
        const digit_t dig = pdigit[i];
        pdword[2*i    ] = (DRM_DWORD)dig;
        pdword[2*i + 1] = (DRM_DWORD)(dig >> DWORD_BITS);
    }
#else
    #error "Unexpected DWORDS_PER_DIGIT"
#endif
    return OK;
}  /* digits_to_dwords */
/****************************************************************************/
DRMINLINE DRM_BOOL DRM_CALL dwords_to_digits
        (const DRM_DWORD    pdword[],
         digit_t   pdigit[],
         const DRM_DWORD lng_dwords)
{
    DRM_BOOL OK = TRUE;

#if DWORDS_PER_DIGIT == 1    
    MEMCPY( pdigit,(digit_t*)pdword,( lng_dwords)*SIZEOF( digit_t ));
#elif DWORDS_PER_DIGIT == 2
    const DRM_DWORD lng_half = lng_dwords >> 1;
    DRM_DWORD i;    

    if (IS_ODD(lng_dwords)) {
        pdigit[lng_half] = (digit_t)pdword[lng_dwords - 1];  // Zero fill
    }
    for (i = 0; i != lng_half; i++) {
        pdigit[i] =    ((digit_t)pdword[2*i+1] << DWORD_BITS)
                     |  (digit_t)pdword[2*i];
    }
#else
    #error "Unexpected DWORDS_PER_DIGIT"
#endif
    return OK;
}  /* dwords_to_digits */

#undef significant_bit_count    // In case a macro version existed
DRMFORCEINLINE DRM_DWORD DRM_CALL significant_bit_count(const digit_t d)
/*
        Compute the number of significant bits in d.
        This is one more than the truncated base 2 logarithm of d.
        significant_bit_count(0)  is undefined.

        For example, significant_bit_count(d) = 8 for 128 <= d <= 255.

        On platforms which have a Count Leading Zeroes or
        similar instruction, UNIFORM_SIGNIFICANT_BIT_COUNT
        should be 1, with special code used.
        For other platforms, use this algorithm.
        The algorithm performs best when the argument is large,
        a feature used by the GCD routines.
*/
{
    digit_t dadj = d | 1;
    DRM_DWORD width = RADIX_BITS;
    DRM_DWORD width_adj;

    while (dadj < (DIGIT_ONE << (RADIX_BITS - 5))) {
        width -= 5;
        dadj <<= 5;
    }
    dadj >>= (RADIX_BITS - 4);     /* From 0 to 15 */
    width_adj = ((DRM_DWORD)0000000011112234 >> dadj) >> (2*dadj);
                     // Shift by 3*dadj, to index into array of octal digits
    return width - (width_adj & 7);
                    // Subtract 5 - significant_bit_count(2*dadj + 1)
} /* significant_bit_count */

DRMFORCEINLINE DRM_DWORD DRM_CALL mp_significant_bit_count
        (const digit_t  a[],
        const DRM_DWORD  lnga)
/*
        Return the number of significant bits in a, which
        is one more than the truncated base 2 logarithm of a.
        Return 0 if a == 0.
*/
{
    const DRM_DWORD lng_sig = significant_digit_count(a, lnga);
    
    if (lng_sig == 0) {
        return 0;
    } else {
       return    (lng_sig - 1)*RADIX_BITS
               + significant_bit_count(a[lng_sig-1]);
    }
}


/****************************************************************************/
#endif // DRM_INLINING_SUPPORTED

/*
        The application should define the
        following three malloc-like functions.
        Sample definitions appear in bigalloc.h.
*/

DRM_API DRM_VOID* DRM_CALL bignum_alloc(const DRM_DWORD, struct bigctx_t *f_pBigCtx);
DRM_API DRM_VOID  DRM_CALL bignum_free(DRM_VOID*, struct bigctx_t *f_pBigCtx);

EXIT_PK_NAMESPACE;

#endif // BIGDEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\bignum.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#ifndef BIGNUM_H              /* If not previously #included */
#define BIGNUM_H 1

#include "bigdefs.h"


/*
** Expensive debugging adds some additional parameter checks,
** such as whether a point is on the curve as expected
** Note: This is currently unused in the PK
*/
#ifndef BIGNUM_EXPENSIVE_DEBUGGING
#define BIGNUM_EXPENSIVE_DEBUGGING 0
#endif

#define MP_LONGEST_BITS 2048

                        /*
                           Multiple precision moduli can have up to
                           MP_LONGEST_BITS bits, which is
                           MP_LONGEST words.  Some routines allow
                           longer operands.

                           Older codes have used this (and MP_LONGEST, below)
                           to dimension arrays.  New code should avoid
                           referencing MP_LONGEST and MP_LONGEST_BITS.

                        */


#define MP_LONGEST (MP_LONGEST_BITS/RADIX_BITS)

/*
        DOUBLE_SHIFT_LEFT(n1, n0, amt) returns
        n1 shifted left by amt bits,
        with new bits coming in from the top of n0.

        DOUBLE_SHIFT_RIGHT(n1, n0, amt) returns n0 shifted right
        by amt bits, with new bits coming from the bottom of n1.

        The shift counts must satisfy 0 <= amt <= RADIX_BITS - 1.
        The shift by    RADIX_BITS - amt   is done in two stages
        (first by 1, then by RADIX_BITS - 1 - amt),
        to avoid an illegal shift count of RADIX_BITS when amt = 0.
*/

#define DOUBLE_SHIFT_LEFT(n1, n0, amt)  \
        (((n1) << (amt)) | (((n0) >> 1) >> (RADIX_BITS - 1 - (amt))))

#define DOUBLE_SHIFT_RIGHT(n1, n0, amt)  \
        (((n0) >> (amt)) | (((n1) << 1) << (RADIX_BITS - 1 - (amt))))

#include "dblint.h"

ENTER_PK_NAMESPACE;

/*
      Some struct names are referenced in #include files before they are
      defined.  For example, there might be two struct definitions each
      containing a pointer to the other struct type.
      We list some struct names in advance here, to avoid warnings.
*/
Future_Struct(mp_modulus_t);      // See this file
Future_Struct(digit_tempinfo_t);  // See bigpriv.h


/*
        The reciprocal_1_t type is used when div21
        or divide or divide_immediate would otherwise
        divide by the same number repeatedly.  See file divide.c.
*/

typedef struct {
                digit_t    multiplier;
                DRM_DWORD   shiftamt;
               } reciprocal_1_t;

/*
        mp_modulus_t struct has modulus-dependent constants
        used for fast reduction (typically for a fixed modulus,
        which will be used several times, as in modular exponentiation).
        These constants are initialized by function create_modulus:

        modulus -- Modulus used for computations.  Must be nonzero.

        length  -- Length (>= 1) of the modulus, without leading zeros.
                   Operands to mod_add, mod_mul, mod_sub, ...
                   are assumed to have this length.

        reddir  -- Equal to FROM_LEFT if reductions of
                   products are done from the left (traditional
                   division), and to FROM_RIGHT if reductions of
                   products are done from the right (Montgomery reduction).

                   When using FROM_RIGHT, the modulus must be odd.
                   Arguments to mod_mul should be pre-scaled by
                   2^scaling_power2 (mod modulus).
                   The product will be similarly scaled.

        scaling_power2 --  Equal to length*RADIX_BITS when reddir = FROM_RIGHT.
                   Zero if reddir = FROM_LEFT.

        one --     Constant 1 (muldiplicative identity), length length.
                   Nmerical value is 2^scaling_power2 (mod modulus).
    Denote

              length = pmodulo->length
              modulus = pmodulo->modulus
              shiftamt = pmodulo->left_reciprocal_1.shiftamt.

          Then

              0 <= shiftamt < RADIX_BITS
              RADIX^length/2 <= modulus * 2^shiftamt < RADIX^length
              modulus < RADIX^length / 2^shiftamt <= 2*modulus

          Some variants of modmul_algorithm use additional constants
          lngred2, multiplier_first, multiplier_second.
          FROM_LEFT arithmetic, these constants satisfy

              modulus * (multiplier_second + RADIX^lngred2)
            = RADIX^(length + lngred2) / 2^shiftamt + multiplier_first

              0 <= multiplier_first < modulus
              0 <= multiplier_second < RADIX^lngred2
              lngred2 = CEIL(length/2)

         For FROM_RIGHT arithmetic, these constants satisfy

              multiplier_second * modulus
            = 1 + multiplier_first * RADIX^lngred2

              0 <= multipler_first < modulus
              0 <= multiplier_second < RADIX^lngred2
              lngred2 = CEIL(length/2)

        one --     Constant 1 (multiplicative identity).
                   For FROM_LEFT arithmetic, pmodulo->one = 1.
                   For FROM_RIGHT arithmetic,
                       pmodulo->one = (RADIX^length) % pmodulus;

        left_reciprocal_1 -- Reciprocal of the divisor starting at the
                   leftmost digit (i.e., modulus[length-1]);

                   See file divide.c for an explanation
                   about how this constant is used to get accurate
                   quotients when dividing from the left.

        right_reciprocal_1 -- If modulus is odd, this holds
                   1/modulus (mod RADIX), for use in mod_shift.
                   Otherwise the field is zero.

          Denote

              length = pmodulo->length
              modulus = pmodulo->modulus
              shiftamt = pmodulo->left_reciprocal_1.shiftamt.

          Then

              0 <= shiftamt < RADIX_BITS
              RADIX^length/2 <= modulus * 2^shiftamt < RADIX^length
              modulus < RADIX^length / 2^shiftamt <= 2*modulus

        modmul_algorithm --
              This library has a variety of codes for modular multiplication.
              The mp_modulus_t struct has a pointer to the precise code
              being used for a particular number and architecture.  A call

                    (*modmul_algorithm)(a, b, c, pmodulo, temps)

              is supposed to set

                     c = a*b/3^(pmodulo->scaling_power2)  (mod pmodulo->modulus)

              where 0 <= a, b, < pmodulo->modulus.
              The output c may overlap a or b.

              The temps array will have at least pmodulo->modmul_algorithm_temps
              elements of type digit_t, aligned on a digit_t boundary.

              The simplest modmul_algoriuthm procedures,
              modmul_from_left_default and modmul_from_right_default,
              work on all architectures.

              In some implementations of this library, create_modulus may
              examine the precise modulus and the precise hardware
              we are running on, substituting another algorithm
              or an assembly language code.

              Some variants of modmul_algorithm use additional constants
              lngred2, multiplier_first, multiplier_second.
              In FROM_LEFT arithmetic, these constants satisfy

                  modulus * (multiplier_second + RADIX^lngred2 + 1))
                = RADIX^(length + lngred2) / 2^shiftamt + multiplier_first

                  0 <= multiplier_first < modulus
                  0 <= multiplier_second < RADIX^lngred2
                  lngred2 = CEIL(length/2)

             For FROM_RIGHT arithmetic, these constants satisfy

                  multiplier_second * modulus
                = 1 + multiplier_first * RADIX^lngred2

                  0 <= multipler_first < modulus
                  0 <= multiplier_second < RADIX^lngred2
                  lngred2 = CEIL(length/2)
*/

Future_Struct(mp_modulus_t);

typedef DRM_BOOL DRM_CALL modmul_algorithm_t (const digit_t *, const digit_t *, digit_t *,
                                   const struct mp_modulus_t*,
                                   digit_t * );

typedef enum {FROM_LEFT, FROM_RIGHT} reddir_t;

typedef struct mp_modulus_t {
                  DRM_DWORD  length;         // Length passed to create_modulus
                  DRM_DWORD  lngred2;        // CEIL(length/2)
                  DRM_DWORD  modmul_algorithm_temps; // Number of digit_t temps
                                                    // used by modmul_algorithm
                  DRM_INT    scaling_power2; // RADIX_BITS*length for FROM_RIGHT,
                                            // 0 for FROM_LEFT
                  reddir_t  reddir;         // FROM_LEFT or FROM_RIGHT */
                  reciprocal_1_t  left_reciprocal_1;
                  digit_t   right_reciprocal_1;  // 1/modulus[0] mod RADIX,
                                                 // if modulus is odd
                  digit_t   *modulus;
                  digit_t   *multiplier_first;  // See text
                  digit_t   *multiplier_second; // See text
                  digit_t   *one;               // Multiplicative constant 1                  
                  modmul_algorithm_t *modmul_algorithm;
                                  // Function pointer for multiplication
                } mp_modulus_t;


/*
        When an error is detected, the SetMpErrno_clue macro gets
        an error code (below) and an English-language string
        with more information.
        This macro will normally call an application-supplied routine.
        The application routine might print a message or set a global variable.

        The library routine detecting the error will exit with return value
        FALSE, notifying its caller that something abnormal occurred.

        Except for MP_ERRNO_NO_ERROR, the error codes are
        in alphabetical order.
*/

typedef enum {
        MP_ERRNO_NO_ERROR = 0,     // Success
               // Broader codes, introduced September, 2002.
        MP_ERRNO_DEGREE_OVERFLOW,  // Polynomial degree too high
                                   // for allocated memory
        MP_ERRNO_DIVIDE_ZERO, // Divide by zero (or by number with leading zero)
        MP_ERRNO_ELSEWHERE,        // Error indicator returned by some routine
                                   // which may not have called SetMpErrno_clue
                                   // (e.g., CRYPTAPI library, assembly codes)
        MP_ERRNO_INTERNAL_ERROR,   // Internal error found -- please report
        MP_ERRNO_INVALID_DATA,     // Invalid arguments
        MP_ERRNO_MODULAR_TOO_BIG,  // Modular operand >= modulus
        MP_ERRNO_NO_MEMORY,        // malloc failure
        MP_ERRNO_NOT_IMPLEMENTED,  // Case not implemented
        MP_ERRNO_NOT_INVERTIBLE,   // Perhaps trying to invert modulo non-prime
        MP_ERRNO_NOT_ON_CURVE,     // Point is not on elliptic curve
        MP_ERRNO_NULL_POINTER,   // NULL argument where valid argument expected
        MP_ERRNO_OVERFLOW,       // Integer overflow (or unexpectedly negative)
        MP_ERRNO_OVERLAPPING_ARGS, // Overlapping (i.e., duplicate) arguments
                                   // where they are disallowed
        MP_ERRNO_TOO_MANY_ITERATIONS,  // e.g., unable to find large prime
        MP_ERRNO_ZERO_OPERAND,     // Zero operand(s) where nonzero expected

        MP_ERRNO_COUNT             // Number of entries above
    } mp_errno_t;

#define SetMpErrno_clue(errcode, debug_info)   if( errcode != 0 ) { TRACE(( "Bignum Error %d, hint %s", errcode, debug_info )); }

DRM_API digit_t DRM_CALL accumulate(const digit_t *, const digit_t, __inout_ecount(lng) digit_t *, const DRM_DWORD lng);

DRM_API DRM_BOOL DRM_CALL add_diff(const digit_t *, const DRM_DWORD, const digit_t *, const DRM_DWORD,
                            digit_t *, digit_t* );

DRM_API DRM_BOOL DRM_CALL add_full(const digit_t *, const DRM_DWORD, const digit_t *,
                            const DRM_DWORD, digit_t *, DRM_DWORD*);

DRM_API digit_t DRM_CALL add_immediate(const digit_t *, const digit_t, digit_t *, const DRM_DWORD);

DRM_API DRM_BOOL DRM_CALL add_mod(const digit_t *, const digit_t *, digit_t *, const digit_t *, const DRM_DWORD);

DRM_API digit_t DRM_CALL add_same(const digit_t *, const digit_t *, __inout_ecount(lng) digit_t *, const DRM_DWORD lng);

DRM_API sdigit_t DRM_CALL add_sub_same(const digit_t *, const digit_t *, const digit_t *,
                                    __out_ecount(lng) digit_t *, const DRM_DWORD lng);

DRM_API DRM_INT DRM_CALL compare_diff(const digit_t *, const DRM_DWORD, const digit_t *, const DRM_DWORD);

DRM_API DRM_INT DRM_CALL compare_same(const digit_t *, const digit_t *, const DRM_DWORD);

DRM_API DRM_INT DRM_CALL compare_sum_diff(const digit_t *, const DRM_DWORD,
                                   const digit_t *, const DRM_DWORD, const digit_t *, const DRM_DWORD);

DRM_API DRM_INT DRM_CALL compare_sum_same(const digit_t *, const digit_t *, const digit_t *, const DRM_DWORD);

DRM_API DRM_BOOL DRM_CALL create_modulus(const digit_t *, const DRM_DWORD, const reddir_t,
                                  mp_modulus_t*, struct bigctx_t *f_pBigCtx, 
                                  struct bigctx_t *);

DRM_API digit_t DRM_CALL decumulate(const digit_t *, const digit_t, __inout_ecount(lng) digit_t *, const DRM_DWORD lng);

DRM_API digit_t* DRM_CALL digit_allocate(const DRM_DWORD,
                                            const DRM_CHAR*, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL digit_ogcd(const digit_t, const digit_t, digit_t*);

DRM_API DRM_BOOL DRM_CALL div21(const DRM_UINT64, const digit_t, digit_t*, digit_t*);

DRM_EXTERN_INLINE DRM_BOOL DRM_CALL div21_fast(const DRM_UINT64, const digit_t,
                       const reciprocal_1_t*, digit_t*, digit_t*);

DRM_API DRM_BOOL DRM_CALL divide(const digit_t *, const DRM_DWORD, const digit_t *, const DRM_DWORD,
                       const reciprocal_1_t*, digit_t *, digit_t *);

DRM_API DRM_BOOL DRM_CALL divide_precondition_1(const digit_t *, const DRM_DWORD,
                                         reciprocal_1_t*);

DRM_API DRM_BOOL DRM_CALL divide_immediate(const digit_t *, const digit_t,
                         const reciprocal_1_t*, digit_t *, const DRM_DWORD,
                         digit_t*);

DRM_EXTERN_INLINE digit_t DRM_CALL estimated_quotient_1(const digit_t, const digit_t,
                                    const digit_t, const reciprocal_1_t*);

DRM_API DRM_BOOL DRM_CALL from_modular(const digit_t *, digit_t *,
                                const mp_modulus_t*);


DRM_API digit_t* DRM_CALL low_prime_prod_construction(struct bigctx_t *f_pBigCtx, DRM_DWORD *pclowprods);
DRM_API DRM_VOID DRM_CALL low_prime_prod_destruction(digit_t*, struct bigctx_t *f_pBigCtx);
DRM_API DRM_BOOL DRM_CALL low_prime_divisibility(const digit_t *, const DRM_DWORD,
                                          __in_ecount( clowprods ) const digit_t *lowprods,
                                          __in const DRM_DWORD clowprods,
                                          digit_t*, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL mod_exp(const digit_t *, const digit_t *, const DRM_DWORD, digit_t *,
                        const mp_modulus_t*, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL mod_LucasUV(const digit_t *, const digit_t *, const digit_t *, const DRM_DWORD,
                        digit_t *, digit_t *, const mp_modulus_t*, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL mod_mul(const digit_t *, const digit_t *, digit_t *,
                    const mp_modulus_t*, __inout_opt digit_t *, struct bigctx_t *f_pBigCtx);


DRM_API DRM_BOOL DRM_CALL mod_shift(const digit_t *, const DRM_INT, digit_t *,
                             const mp_modulus_t*);

DRM_API DRM_BOOL DRM_CALL mod_sqrt(const digit_t *, digit_t *, const mp_modulus_t*,
                            DRM_BOOL*, struct bigctx_t *f_pBigCtx);

#define Allocate_Temporaries(typename, ptr, ctx) \
        Allocate_Temporaries_Multiple(1, typename, ptr, ctx)

#define Allocate_Temporaries_Multiple(nelmt, typename, ptr, ctx) \
               ptr = (typename*)bignum_alloc((nelmt)*SIZEOF(typename), f_pBigCtx)

#define Free_Temporaries( ptr, ctx ) bignum_free( ptr, ctx )

DRM_API DRM_BOOL DRM_CALL mp_gcdex
       (const digit_t *, const DRM_DWORD,
        const digit_t *, const DRM_DWORD,
        digit_t *, digit_t *,
        digit_t *, digit_t *,
        DRM_DWORD*, digit_t *, struct bigctx_t *f_pBigCtx);

DRM_EXTERN_INLINE DRM_DWORD DRM_CALL mp_gcdex_ntemps
        (const DRM_DWORD, const DRM_DWORD, struct bigctx_t *f_pBigCtx );
           // Temporary count required by last argument to mp_gcdex

DRM_API DRM_BOOL DRM_CALL mp_initialization( struct bigctx_t *f_pBigCtx );

DRM_EXTERN_INLINE DRM_DWORD DRM_CALL mp_invert_ntemps(const DRM_DWORD, struct bigctx_t *f_pBigCtx);
           // Temporary count required by last argument to mp_invert

DRM_API DRM_BOOL DRM_CALL mp_invert(const digit_t *, const digit_t *, const DRM_DWORD,
                             digit_t *, const DRM_CHAR*,
                             digit_t *, struct bigctx_t *f_pBigCtx);


/* The assembly versions of these calls were hardcoded to use stdcall calling
DRM_API    convention. For the C implementation we will use DRM_CALL as it is standard
   throughout the porting kits. */
#if defined(_M_IX86) && DRM_USE_ASSEMBLY
extern DRM_BOOL __stdcall mp_mul22s(const digit_t[4], digit_t *, digit_t *,
                             const DRM_DWORD, sdigit_t[2]);

extern DRM_BOOL __stdcall mp_mul22u(const digit_t[4], digit_t *, digit_t *,
                             const DRM_DWORD,  digit_t[2] );
#else
DRM_API DRM_BOOL DRM_CALL mp_mul22s(
 __in_ecount(4)        const digit_t mat[4],       // IN  (2 x 2 matrix of scalars)
 __inout_ecount(lvec)  digit_t  vec1[],            // INOUT
 __inout_ecount(lvec)  digit_t  vec2[],            // INOUT
 __in                  const DRM_DWORD lvec,       // IN
 __out_ecount(2)       sdigit_t carrys[2] );        // OUT  (array of 2 scalars)

DRM_API DRM_BOOL DRM_CALL mp_mul22u(
   __in_ecount(4)       const digit_t mat[4],       // IN  (2 x 2 matrix of scalars)
   __inout_ecount(lvec) digit_t  vec1[],            // INOUT
   __inout_ecount(lvec) digit_t  vec2[],            // INOUT
   __in const           DRM_DWORD lvec,             // IN
   __out_ecount(2)      digit_t  carrys[2] );      // OUT  (array of 2 scalars)
#endif

extern DRM_DWORD mp_remove2(digit_t *, const DRM_DWORD, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL mp_shift(const digit_t *, const DRM_INT, __inout_ecount(lng) digit_t *,
                            const DRM_DWORD lng);

DRM_API DRM_BOOL DRM_CALL mp_shift_lost(const digit_t *, const DRM_INT, __inout_ecount(lng) digit_t *,
                                 const DRM_DWORD lng, digit_t*);

DRM_API digit_t DRM_CALL multiply_immediate(const digit_t *, const digit_t,
                                         __inout_ecount(lng) digit_t *, const DRM_DWORD lng);


/* The assembly versions of these calls were hardcoded to use stdcall calling
DRM_API    convention. For the C implementation we will use DRM_CALL as it is standard
   throughout the porting kits. */
#if defined(_M_IX86) && DRM_USE_ASSEMBLY
extern DRM_VOID __stdcall multiply_low(const digit_t *, const digit_t *, digit_t *, const DRM_DWORD );
#else
DRM_API DRM_VOID DRM_CALL multiply_low(const digit_t *, const digit_t *, digit_t *, const DRM_DWORD );
#endif

DRM_API DRM_BOOL DRM_CALL neg_mod(const digit_t *, __out_ecount(lng) digit_t *, const digit_t *,
                           const DRM_DWORD lng);

DRM_API DRM_BOOL DRM_CALL set_immediate(digit_t *, const digit_t, const DRM_DWORD, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL validate_modular_data(const digit_t *, const digit_t *,
                                         const DRM_DWORD, const DRM_CHAR *);
#if !DRM_INLINING_SUPPORTED

DRM_API DRM_BOOL DRM_CALL multiply(const digit_t  a[],const DRM_DWORD lnga,const digit_t  b[],const DRM_DWORD lngb,digit_t   c[]);

#else

/****************************************************************************/
DRMFORCEINLINE DRM_BOOL DRM_CALL multiply
        (const digit_t  a[],
         const DRM_DWORD lnga,
         const digit_t  b[],
         const DRM_DWORD lngb,
         digit_t   c[] )
/*
//        Multiply a (length lnga) times b (length lngb),
//        getting a product c (length lnga + lngb).

//        The output should not overlap the inputs.
*/
{
    DRM_BOOL OK = TRUE;
    const digit_t *p1, *p2;
    DRM_DWORD i, lng1, lng2;

    if (lnga > lngb) {           /* Put longer operand in p1 */
        p1 = a; p2 = b; lng1 = lnga; lng2 = lngb;
    } else {
        p2 = a; p1 = b; lng2 = lnga; lng1 = lngb;
    }

    if (!OK) {
    } else if (a == c || b == c) {
        OK = FALSE;        
    } else if (lng2 == 0) {       /* If an operand has length zero */
        ZEROMEM(c,( lng1)*SIZEOF( digit_t ));
    } else {
        c[lng1] = multiply_immediate(p1, p2[0], c, lng1 );
        for (i = 1; i != lng2; i++) {
            c[i + lng1] = accumulate(p1, p2[i], &c[i], lng1);
        }
    }
    return OK;
} /* multiply */

#endif

#if DRM_INLINING_SUPPORTED && defined(_M_IX86) && DRM_USE_ASSEMBLY
    #define significant_bit_count significant_bit_count_ix86
    #define UNIFORM_SIGNIFICANT_BIT_COUNT 1
    #pragma warning(disable : 4035)      /* No return value */
    static DRMINLINE DRM_DWORD significant_bit_count(const digit_t pattern)
    {
    _asm {
            mov  eax,pattern        ; Nonzero pattern
            bsr  eax,eax            ; eax = index of leftmost nonzero bit
            inc  eax                ; Add one to get significant bit count
         }
    }
    #pragma warning(default : 4035)
#else
    #define UNIFORM_SIGNIFICANT_BIT_COUNT 0
           /* Algorithm faster for larger inputs.  See mpmisc.c */
#endif

DRM_API DRM_BOOL DRM_CALL sub_diff(const digit_t *, const DRM_DWORD, const digit_t *, const DRM_DWORD,
                            digit_t *, digit_t* );

DRM_API digit_t DRM_CALL sub_immediate(const digit_t *, const digit_t, digit_t *, const DRM_DWORD);

DRM_API DRM_BOOL DRM_CALL sub_mod(const digit_t *, const digit_t *, digit_t *, const digit_t *,
                           const DRM_DWORD);

DRM_API digit_t DRM_CALL sub_same(const digit_t *, const digit_t *, __out_ecount(lng) digit_t *, const DRM_DWORD lng);

DRM_API DRM_BOOL DRM_CALL to_modular(const digit_t *, const DRM_DWORD, digit_t *,
                              const mp_modulus_t*, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL two_adic_inverse(const digit_t, digit_t*);

DRM_API DRM_VOID DRM_CALL uncreate_modulus(mp_modulus_t*, struct bigctx_t *f_pBigCtx);


#if !DRM_INLINING_SUPPORTED
DRM_API DRM_INT DRM_CALL compare_immediate(const digit_t *, const digit_t, const DRM_DWORD);
DRM_API digit_t DRM_CALL sub_immediate(const digit_t *, const digit_t, digit_t *, const DRM_DWORD);
#endif


#if DRM_INLINING_SUPPORTED
/***************************************************************************/
DRMINLINE DRM_INT DRM_CALL compare_immediate
        (const digit_t  a[],
         const digit_t  ivalue,
         const DRM_DWORD    lng)
/*
        Compare a multiple-precision number to a scalar.
*/
{
    return compare_diff(a, lng, &ivalue, 1);
}
/****************************************************************************/
#define significant_digit_count significant_digit_count_inlined
DRMINLINE DRM_DWORD DRM_CALL significant_digit_count
        (const digit_t  a[],
         const DRM_DWORD lng)
/*
        Return the number of significant digits in a.
        Function value is zero precisely when a == 0.
*/
#if defined(_M_IX86) && DRM_USE_ASSEMBLY
    #pragma warning(disable : 4035)      /* No return value */
{
                /*
                   We could use REPE SCASD,
                   but the REPE overhead is
                   four cycles/compare on early Pentiums.
                   We would also need sld and cld.
                   It is shorter to use RISC instructions.
                   We anticipate that the leading term a[lng-1]
                   will usually be nonzero.
                */

    _asm {
        mov  eax,lng
        mov  edx,a
     label1:
        test eax,eax
        jz   label2             ; If nothing left in number, return 0

        mov  ecx,[edx+4*eax-4]
        dec  eax

        test ecx,ecx            ; Test leading digit
        jz   label1

        inc  eax                ; Nonzero element found; return old eax
     label2:
    }
}
    #pragma warning(default : 4035)
#else
{
    DRM_DWORD i = lng;

    while (i != 0 && a[i-1] == 0) i--;
    return i;
}  /* significant_digit_count */
#endif

#endif  // DRM_INLINING_SUPPORTED

EXIT_PK_NAMESPACE;

#endif // BIGNUM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\bigpriv.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#ifndef __BIGPRIV_H
#define __BIGPRIV_H 1
/*
      File bigpriv.h.   Version 20 September, 2002

      Declarations accessible to bignum library but invisible to application.
      Also see fieldpriv.h
*/

#include "bignum.h"


ENTER_PK_NAMESPACE;

#if defined (_MSC_VER)

    #pragma warning(disable: 4146 4514)  // TBD
         /* 4146 -- unary minus operator applied
            to unsigned type, result still unsigned.
            4514 -- unreferenced inline function
          */
#endif



/*
     Some routines allow the caller to supply temps, but
     accept a NULL argument to say "Allocate them yourself!".
     possible_digit_allocate assists in doing the allocate
     if the caller passed NULL.
*/

typedef struct digit_tempinfo_t {
    digit_t *address;       // Address supplied by user.
                            // Updated to specify address
                            // to use for temporaries.
    DRM_DWORD nelmt;         // Number of digit_t elements needed
    DRM_BOOL  need_to_free;  // Should be set FALSE by application.
                            // Changed to TRUE if a free is required.
} digit_tempinfo_t;

DRM_API DRM_BOOL DRM_CALL possible_digit_allocate(digit_tempinfo_t*,
                                                 const DRM_CHAR*, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL modmul_choices1(mp_modulus_t*, DRM_INT*);

DRM_API DRM_BOOL DRM_CALL modmul_from_right_default( 
    IN      const digit_t      *a,
    IN      const digit_t      *b,
    OUT           digit_t      *c,
    IN      const mp_modulus_t *pmodulo,   
    IN OUT        digit_t      *temps );

DRM_API DRM_BOOL DRM_CALL modmul_from_right_default_modulo8( 
    IN      const digit_t      *a,
    IN      const digit_t      *b,
    OUT           digit_t      *c,
    IN      const mp_modulus_t *pmodulo,   
    IN OUT        digit_t      *temps );

EXIT_PK_NAMESPACE;


#endif  //  __BIGPRIV_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmaescommon.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
**  drmaescommon.h
**
**  Contains common definitions used by OEM AES implementations as well as
**  AES API functions.
**  
*/


#ifndef __DRMAESCOMMON_H__
#define __DRMAESCOMMON_H__

#include <drmcommon.h>

ENTER_PK_NAMESPACE;

/*
** AES Key Sizes
*/
#define DRM_AES_KEYSIZE_128 ( 16 ) /* Size ( in bytes ) of a 128 bit key */
#define DRM_AES_KEYSIZE_192 ( 24 ) /* Size ( in bytes ) of a 192 bit key */
#define DRM_AES_KEYSIZE_256 ( 32 ) /* Size ( in bytes ) of a 256 bit key */
#define DRM_AES_MAXKEYSIZE  DRM_AES_KEYSIZE_256

/*
** Round counts corresponding to key sizes
*/
#define DRM_AES_ROUNDS_128  ( 10 ) 
#define DRM_AES_ROUNDS_192  ( 12 )
#define DRM_AES_ROUNDS_256  ( 14 )
#define DRM_AES_MAXROUNDS   DRM_AES_ROUNDS_256

#define DRM_AES_BLOCKLEN    DRM_AES_KEYSIZE_128 /* Size ( in bytes ) of a single encrypted/decrypted block */
#define DRM_AES_ROUNDS      DRM_AES_ROUNDS_128 

EXIT_PK_NAMESPACE;

#endif /* __DRMAESCOMMON_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmaes.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMAES_H__
#define __DRMAES_H__

#include <oemaes.h>

ENTER_PK_NAMESPACE;

/*
** Supported cipher modes for AES encryption/decryption
*/
typedef enum 
{
    eDRM_AES_CTR_MODE  = 1,
    eDRM_AES_ECB_MODE  = 2,
    eDRM_AES_CBC_MODE  = 3
} DRM_AES_SUPPORTED_MODES;

typedef struct 
{
    DRM_UINT64  qwInitializationVector; 
    DRM_UINT64  qwBlockOffset;
    DRM_BYTE    bByteOffset;  /* Byte offset within the current block */
} DRM_AES_COUNTER_MODE_CONTEXT;


DRM_API DRM_RESULT DRM_CALL DRM_Aes_CtrProcessData(
    __in_ecount( 1 )	        const DRM_AES_KEY                  *f_pKey,
    __inout_bcount( f_cbData )        DRM_BYTE                     *f_pbData,
    __in                              DRM_DWORD                     f_cbData,
    __inout_ecount( 1 )               DRM_AES_COUNTER_MODE_CONTEXT *f_pCtrContext );


DRM_API DRM_RESULT DRM_CALL DRM_Aes_CbcEncryptData(
    __in_ecount( 1 )                const DRM_AES_KEY *f_pKey,
    __inout_bcount( f_cbData )            DRM_BYTE    *f_pbData,
    __in                                  DRM_DWORD    f_cbData,
    __in_bcount( DRM_AES_BLOCKLEN ) const DRM_BYTE     f_rgbIV[__CB_DECL( DRM_AES_BLOCKLEN )] );

DRM_API DRM_RESULT DRM_CALL DRM_Aes_CbcDecryptData(
    __in_ecount( 1 )                const DRM_AES_KEY *f_pKey,
    __inout_bcount( f_cbData )            DRM_BYTE    *f_pbData,
    __in                                  DRM_DWORD    f_cbData,
    __in_bcount( DRM_AES_BLOCKLEN ) const DRM_BYTE     f_rgbIV[__CB_DECL( DRM_AES_BLOCKLEN )] );

DRM_API DRM_RESULT DRM_CALL DRM_Aes_EcbEncryptData(
    __in_ecount( 1 )                const DRM_AES_KEY *f_pKey,
    __inout_bcount( f_cbData )            DRM_BYTE    *f_pbData,
    __in                                  DRM_DWORD    f_cbData );

DRM_API DRM_RESULT DRM_CALL DRM_Aes_EcbDecryptData(
    __in_ecount( 1 )                const DRM_AES_KEY *f_pKey,
    __inout_bcount( f_cbData )            DRM_BYTE    *f_pbData,
    __in                                  DRM_DWORD    f_cbData );

DRM_API DRM_RESULT DRM_CALL DRM_Omac1_Sign(
    __in_ecount( 1 )                       const DRM_AES_KEY *f_pKey,
    __in_bcount( f_ibData + f_cbData )     const DRM_BYTE    *f_pbData,
    __in                                   DRM_DWORD    f_ibData,
    __in                                   DRM_DWORD    f_cbData,
    __out_bcount( DRM_AES_BLOCKLEN )       DRM_BYTE     f_rgbTag[__CB_DECL( DRM_AES_BLOCKLEN )] );

DRM_API DRM_RESULT DRM_CALL DRM_Omac1_Verify(
    __in_ecount( 1 )                const DRM_AES_KEY *f_pKey,
    __in_bcount(f_ibData+f_cbData)  const DRM_BYTE    *f_pbData,
    __in                                  DRM_DWORD    f_ibData,
    __in                                  DRM_DWORD    f_cbData,
    __in_bcount(f_ibSignature+DRM_AES_BLOCKLEN) const DRM_BYTE *f_pbSignature,
    __in                                  DRM_DWORD    f_ibSignature );

EXIT_PK_NAMESPACE;

#endif /*__DRMAES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\byteorder.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __BYTEORDER_H__
#define __BYTEORDER_H__

#include <drmtypes.h>

#define BITS_PER_STANDARD_BYTE 8

#define BYTES2WORD_LE( word, byte)          DRM_BYT_CopyBytes((DRM_BYTE*)&(word),0,(byte),0,SIZEOF(DRM_WORD));
#define WORD2BYTES_LE( byte, word )         DRM_BYT_CopyBytes((byte),0,(DRM_BYTE*)&(word),0,SIZEOF(DRM_WORD));
#define BYTES2DWORD_LE( dword, byte)        DRM_BYT_CopyBytes((DRM_BYTE*)&(dword),0,(byte),0,SIZEOF(DRM_DWORD));
#define DWORD2BYTES_LE( byte, dword )       DRM_BYT_CopyBytes((byte),0,(DRM_BYTE*)&(dword),0,SIZEOF(DRM_DWORD));
#define BYTES2QWORD_LE( qword, byte)        DRM_BYT_CopyBytes((DRM_BYTE*)&(qword),0,(byte),0,SIZEOF(DRM_UINT64));
#define QWORD2BYTES_LE( byte, qword )       DRM_BYT_CopyBytes((byte),0,(DRM_BYTE*)&(qword),0,SIZEOF(DRM_UINT64));

#define BYTES2WORD_BE( word, byte)          {DRM_BYT_CopyBytes((DRM_BYTE*)&(word),0,(byte),0,SIZEOF(DRM_WORD));FIX_ENDIAN_WORD((word));}
#define WORD2BYTES_BE( byte, word )         {FIX_ENDIAN_WORD((word));DRM_BYT_CopyBytes((byte),0,(DRM_BYTE*)&(word),0,SIZEOF(DRM_WORD));FIX_ENDIAN_WORD((word));}
#define BYTES2DWORD_BE( dword, byte)        {DRM_BYT_CopyBytes((DRM_BYTE*)&(dword),0,(byte),0,SIZEOF(DRM_DWORD));FIX_ENDIAN_DWORD((dword));}
#define DWORD2BYTES_BE( byte, dword )       {FIX_ENDIAN_DWORD((dword));DRM_BYT_CopyBytes((byte),0,(DRM_BYTE*)&(dword),0,SIZEOF(DRM_DWORD));FIX_ENDIAN_DWORD((dword));}
#define BYTES2QWORD_BE( qword, byte)        {DRM_BYT_CopyBytes((DRM_BYTE*)&(qword),0,(byte),0,SIZEOF(DRM_UINT64));FIX_ENDIAN_QWORD((qword));}
#define QWORD2BYTES_BE( byte, qword )       {FIX_ENDIAN_QWORD((qword));DRM_BYT_CopyBytes((byte),0,(DRM_BYTE*)&(qword),0,SIZEOF(DRM_UINT64));FIX_ENDIAN_QWORD((qword));}

#define COPY_WORD(byte, index, word)        DRM_BYT_CopyBytes((byte),(index),(DRM_BYTE*)&(word),0,SIZEOF(DRM_WORD));
#define COPY_DWORD(byte, index, dword)      DRM_BYT_CopyBytes((byte),(index),(DRM_BYTE*)&(dword),0,SIZEOF(DRM_DWORD));
#define COPY_QWORD(byte, index, qword)      DRM_BYT_CopyBytes((byte),(index),(DRM_BYTE*)&(qword),0,SIZEOF(DRM_UINT64));

#define COPY_FROMBUFFER(to, from, index, size, buffersize)  {ChkOverflow((index)+(size),(index));ChkBOOL((index)+(size)<=(buffersize),DRM_E_BUFFERTOOSMALL);DRM_BYT_CopyBytes((DRM_BYTE*)&(to),0,(from),(index),(size));(index)+=(size);}

#define REVERSE_BYTES_WORD(w)               DRM_BYT_ReverseBytes((DRM_BYTE*)&(w),SIZEOF(DRM_WORD))
#define REVERSE_BYTES_DWORD(dw)             DRM_BYT_ReverseBytes((DRM_BYTE*)&(dw),SIZEOF(DRM_DWORD))
#define REVERSE_BYTES_QWORD(qw)             DRM_BYT_ReverseBytes((DRM_BYTE*)&(qw),SIZEOF(DRM_UINT64))

#define BYTE2LITTLEENDIAN(dword, byte)     DRM_BYT_CopyBytes((DRM_BYTE*)&(dword),0,(byte),0,SIZEOF(DRM_DWORD));
#define DWORD2LITTLEENDIAN( byte, dword )  DRM_BYT_CopyBytes((byte),0,(DRM_BYTE*)&(dword),0,SIZEOF(DRM_DWORD));

#define BYTE2BIGENDIAN(dword, byte)        {DRM_BYT_CopyBytes((DRM_BYTE*)&(dword),0,(byte),0,SIZEOF(DRM_DWORD));FIX_ENDIAN_DWORD((dword));}
#define DWORD2BIGENDIAN(byte, dword)       {FIX_ENDIAN_DWORD((dword));DRM_BYT_CopyBytes((byte),0,(DRM_BYTE*)&(dword),0,SIZEOF(DRM_DWORD));FIX_ENDIAN_DWORD((dword));}

#if TARGET_LITTLE_ENDIAN

#define BYTES_TO_WORD( word, byte )                 BYTES2WORD_LE( word, byte )
#define WORD_TO_BYTES( byte, word )                 WORD2BYTES_LE( byte, word )
#define BYTES_TO_QWORD( qword, byte )               BYTES2QWORD_LE( qword, byte )
#define QWORD_TO_BYTES( byte, qword )               QWORD2BYTES_LE( byte, qword )

#define WORD_TO_NETWORKBYTES(byte, index, word)     {DRM_WORD wTemp = (word);    REVERSE_BYTES_WORD(wTemp);   COPY_WORD((byte), (index), wTemp);}
#define DWORD_TO_NETWORKBYTES(byte, index, dword)   {DRM_DWORD dwTemp = (dword); REVERSE_BYTES_DWORD(dwTemp); COPY_DWORD((byte), (index), dwTemp);}
#define QWORD_TO_NETWORKBYTES(byte, index, qword)   {DRM_UINT64 qwTemp = (qword); REVERSE_BYTES_QWORD(qwTemp); COPY_QWORD((byte), (index), qwTemp);}
#define NETWORKBYTES_TO_WORD(word, byte, index)     {DRM_BYT_CopyBytes((DRM_BYTE*)&(word),0,(byte),(index),SIZEOF(DRM_WORD));  REVERSE_BYTES_WORD((word));}
#define NETWORKBYTES_TO_DWORD(dword, byte, index)   {DRM_BYT_CopyBytes((DRM_BYTE*)&(dword),0,(byte),(index),SIZEOF(DRM_DWORD)); REVERSE_BYTES_DWORD((dword));}
#define NETWORKBYTES_TO_QWORD(qword, byte, index)   {DRM_BYT_CopyBytes((DRM_BYTE*)&(qword),0,(byte),(index),SIZEOF(DRM_UINT64)); REVERSE_BYTES_QWORD((qword));}

#define NETWORKBYTES_FROMBUFFER(to, from, index, size, buffersize)       {COPY_FROMBUFFER(to,from,index,size,buffersize);DRM_BYT_ReverseBytes((DRM_BYTE*)&(to),(size));}
#define NETWORKBYTES_FROMBUFFER_TO_WORD(word, byte, index, buffersize)   NETWORKBYTES_FROMBUFFER(word,byte,index,SIZEOF(DRM_WORD),buffersize)
#define NETWORKBYTES_FROMBUFFER_TO_DWORD(dword, byte, index, buffersize) NETWORKBYTES_FROMBUFFER(dword, byte,index,SIZEOF(DRM_DWORD),buffersize)

#define BYTES_TO_DWORD BYTE2LITTLEENDIAN
#define DWORD_TO_BYTES DWORD2LITTLEENDIAN
#define FIX_ENDIAN_WORD(w)
#define FIX_ENDIAN_DWORD(dw)
#define FIX_ENDIAN_QWORD(qw)

/* Copies WORD written to buffer in little endian format into WORD variable */
#define LITTLEENDIAN_BYTES_TO_WORD(word, byte, index)     {DRM_BYT_CopyBytes((DRM_BYTE*)&(word),0,(byte),(index),SIZEOF(DRM_WORD)); }

/* Copies DWORD written to buffer in little endian format into DWORD variable */
#define LITTLEENDIAN_BYTES_TO_DWORD(dword, byte, index)   {DRM_BYT_CopyBytes((DRM_BYTE*)&(dword),0,(byte),(index),SIZEOF(DRM_DWORD)); }

/* Copies DWORD variable into buffer with DWORD in little endian format*/
#define DWORD_TO_LITTLEENDIAN_BYTES(byte, index, dword)   {DRM_DWORD dwTemp = (dword); COPY_DWORD((byte), (index), dwTemp);}

/* Copies WORD variable into buffer with WORD in little endian format*/
#define WORD_TO_LITTLEENDIAN_BYTES(byte, index, word)   {DRM_WORD wTemp = (word); COPY_WORD((byte), (index), wTemp);}

#else /* TARGET_LITTLE_ENDIAN */

#define BYTES_TO_WORD( word, byte )                 BYTES2WORD_BE( word, byte )
#define WORD_TO_BYTES( byte, word )                 WORD2BYTES_BE( byte, word )
#define BYTES_TO_QWORD( qword, byte )               BYTES2QWORD_BE( qword, byte )
#define QWORD_TO_BYTES( byte, qword )               QWORD2BYTES_BE( byte, qword )

#define WORD_TO_NETWORKBYTES(byte, index, word)     COPY_WORD(byte, index, word)
#define DWORD_TO_NETWORKBYTES(byte, index, dword)   COPY_DWORD(byte, index, dword)
#define QWORD_TO_NETWORKBYTES(byte, index, qword)   COPY_QWORD(byte, index, qword)
#define NETWORKBYTES_TO_WORD(word, byte, index)     {DRM_BYT_CopyBytes((DRM_BYTE*)&(word),0,(byte),(index),SIZEOF(DRM_WORD)); }
#define NETWORKBYTES_TO_DWORD(dword, byte, index)   {DRM_BYT_CopyBytes((DRM_BYTE*)&(dword),0,(byte),(index),SIZEOF(DRM_DWORD)); }
#define NETWORKBYTES_TO_QWORD(qword, byte, index)   {DRM_BYT_CopyBytes((DRM_BYTE*)&(qword),0,(byte),(index),SIZEOF(DRM_UINT64)); }

#define NETWORKBYTES_FROMBUFFER(to, from, index, size, buffersize)       COPY_FROMBUFFER(to,from,index,size,buffersize)
#define NETWORKBYTES_FROMBUFFER_TO_WORD(word, byte, index, buffersize)   NETWORKBYTES_FROMBUFFER(word,byte,index,SIZEOF(DRM_WORD),buffersize)
#define NETWORKBYTES_FROMBUFFER_TO_DWORD(dword, byte, index, buffersize) NETWORKBYTES_FROMBUFFER(dword,byte,index,SIZEOF(DRM_DWORD),buffersize)

#define BYTES_TO_DWORD BYTE2BIGENDIAN
#define DWORD_TO_BYTES DWORD2BIGENDIAN

#if __TMS320C55X__
/* Work around a uniqueness in the TI compiler */
#define FIX_ENDIAN_WORD(w)   {DRM_DWORD __dw = SIZEOF(DRM_WORD);DRM_BYT_ReverseBytes((DRM_BYTE*)&(w), __dw);}
#define FIX_ENDIAN_DWORD(dw) {DRM_DWORD __dw = SIZEOF(DRM_DWORD);DRM_BYT_ReverseBytes((DRM_BYTE*)&(dw),__dw);}
#define FIX_ENDIAN_QWORD(qw) {DRM_DWORD __dw = SIZEOF(DRM_UINT64);DRM_BYT_ReverseBytes((DRM_BYTE*)&(qw),__dw);NATIVE64_TO_NONNATIVE64((qw));}
#else
#define FIX_ENDIAN_WORD(w)   DRM_BYT_ReverseBytes((DRM_BYTE*)&(w), SIZEOF(DRM_WORD))
#define FIX_ENDIAN_DWORD(dw) DRM_BYT_ReverseBytes((DRM_BYTE*)&(dw),SIZEOF(DRM_DWORD))
#define FIX_ENDIAN_QWORD(qw) {DRM_BYT_ReverseBytes((DRM_BYTE*)&(qw),SIZEOF(DRM_UINT64));NATIVE64_TO_NONNATIVE64((qw));}
#endif


/* Copies WORD written to buffer in little endian format into WORD variable */
#define LITTLEENDIAN_BYTES_TO_WORD(word, byte, index)     {DRM_BYT_CopyBytes((DRM_BYTE*)&(word),0,(byte),(index),SIZEOF(DRM_WORD)); REVERSE_BYTES_WORD((word));}

/* Copies DWORD written to buffer in little endian format into DWORD variable */
#define LITTLEENDIAN_BYTES_TO_DWORD(dword, byte, index)   {DRM_BYT_CopyBytes((DRM_BYTE*)&(dword),0,(byte),(index),SIZEOF(DRM_DWORD)); REVERSE_BYTES_DWORD((dword));}

/* Copies DWORD variable into buffer with DWORD in little endian format*/
#define DWORD_TO_LITTLEENDIAN_BYTES(byte, index, dword)   {DRM_DWORD dwTemp = (dword); REVERSE_BYTES_DWORD(dwTemp); COPY_DWORD((byte), (index), dwTemp);}

/* Copies WORD variable into buffer with WORD in little endian format*/
#define WORD_TO_LITTLEENDIAN_BYTES(byte, index, word)   {DRM_WORD wTemp = (word); REVERSE_BYTES_WORD(wTemp); COPY_WORD((byte), (index), wTemp);}

#endif /* TARGET_LITTLE_ENDIAN */

#endif /* __BYTEORDER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmbcert.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMBCERT_H__
#define __DRMBCERT_H__

#include <drmtypes.h>
#include <drmhash.h>
#include <drmeccp256.h>

ENTER_PK_NAMESPACE;

#define BYTES_PER_DWORD      SIZEOF( DRM_DWORD )
#define PAD_AMOUNT(x)        ( ( (x) > 0 ) ? ( ( BYTES_PER_DWORD - ( (x) % BYTES_PER_DWORD ) ) % BYTES_PER_DWORD ) : 0 )

#define DRM_BCERT_OBJFLAG_EMPTY            0x0000
#define DRM_BCERT_OBJFLAG_MUST_UNDERSTAND  0x0001
#define DRM_BCERT_OBJFLAG_CONTAINER_OBJ    0x0002
 
#define DRM_BCERT_OBJTYPE_BASIC            0x0001
#define DRM_BCERT_OBJTYPE_DOMAIN           0x0002
#define DRM_BCERT_OBJTYPE_PC               0x0003
#define DRM_BCERT_OBJTYPE_DEVICE           0x0004
#define DRM_BCERT_OBJTYPE_FEATURE          0x0005
#define DRM_BCERT_OBJTYPE_KEY              0x0006
#define DRM_BCERT_OBJTYPE_MANUFACTURER     0x0007
#define DRM_BCERT_OBJTYPE_SIGNATURE        0x0008
#define DRM_BCERT_OBJTYPE_SILVERLIGHT      0x0009
#define DRM_BCERT_OBJTYPE_METERING         0x000a
#define DRM_BCERT_OBJTYPE_EXTDATASIGNKEY   0x000b
#define DRM_BCERT_OBJTYPE_EXTDATACONTAINER 0x000c
#define DRM_BCERT_OBJTYPE_EXTDATASIGNATURE 0x000d
#define DRM_BCERT_OBJTYPE_EXTDATA_HWID     0x000e
#define DRM_BCERT_OBJTYPE_SERVER           0x000f

#define DRM_BCERT_OBJTYPE_MAX_VALUE        0x000f

typedef struct _tagDrmBCertObjectHeader
{
    DRM_WORD    wFlags;       /* bit field */
    DRM_WORD    wType; 
    DRM_DWORD   cbLength;
} DRM_BCERT_OBJECT_HEADER;


#define DRM_BCERT_MAX_CERTS_PER_CHAIN   6


/* ------------------------------------------------------------------------- */
/*  CERTIFICATE HEADER  */

#define DRM_BCERT_HEADER_TAG     0x43455254  /* "CERT" */
#define DRM_BCERT_VERSION        0x00000001

typedef struct _tagDrmBCertHeader
{
    DRM_DWORD              dwHeaderTag;
    DRM_DWORD              dwVersion;
    DRM_DWORD              cbCertificate;
    DRM_DWORD              cbCertificateSigned;
} DRM_BCERT_HEADER;


/* ------------------------------------------------------------------------- */
/*  BASIC INFO  */


#define DRM_BCERT_CERT_ID_LENGTH  16  /* 128 bits */
typedef struct _tagDrmBCertCertId
{
    DRM_BYTE    rgb[ __CB_DECL( DRM_BCERT_CERT_ID_LENGTH ) ];
} DRM_BCERT_CERT_ID;

#define DRM_BCERT_SECURITYLEVEL_150    150  /* for testing */
#define DRM_BCERT_SECURITYLEVEL_2000   2000

#define DRM_BCERT_FLAGS_EMPTY             0x00000000 /* default */
#define DRM_BCERT_FLAGS_EXTDATA_PRESENT   0x00000001 /* presence of extended data */

#define DRM_BCERT_CERTTYPE_UNKNOWN       0x00000000
#define DRM_BCERT_CERTTYPE_PC            0x00000001
#define DRM_BCERT_CERTTYPE_DEVICE        0x00000002
#define DRM_BCERT_CERTTYPE_DOMAIN        0x00000003
#define DRM_BCERT_CERTTYPE_ISSUER        0x00000004
#define DRM_BCERT_CERTTYPE_CRL_SIGNER    0x00000005
#define DRM_BCERT_CERTTYPE_SERVICE       0x00000006
#define DRM_BCERT_CERTTYPE_SILVERLIGHT   0x00000007
#define DRM_BCERT_CERTTYPE_APPLICATION   0x00000008
#define DRM_BCERT_CERTTYPE_METERING      0x00000009
#define DRM_BCERT_CERTTYPE_KEYFILESIGNER 0x0000000a
#define DRM_BCERT_CERTTYPE_SERVER        0x0000000b

#define DRM_BCERT_CERTTYPE_MAX_VALUE     0x0000000b

#define DRM_BCERT_DEFAULT_EXPIRATION_DATE  0xFFFFFFFF

#define DRM_BCERT_CLIENT_ID_LENGTH  16  /* 128 bits */
typedef struct _tagDrmBCertClientId
{
    DRM_BYTE    rgb[ __CB_DECL( DRM_BCERT_CLIENT_ID_LENGTH ) ];
} DRM_BCERT_CLIENT_ID;

typedef struct _tagDrmBCertBasicInfo
{
    DRM_BCERT_OBJECT_HEADER  Header;
    DRM_BCERT_CERT_ID        CertificateID;
    DRM_DWORD                dwSecurityLevel;
    DRM_DWORD                dwFlags;           /* bit field */
    DRM_DWORD                dwType;
    DRM_SHA256_Digest        DigestValue;       /* hash of the public key value */
    DRM_DWORD                dwExpirationDate;
    DRM_BCERT_CLIENT_ID      ClientID;
} DRM_BCERT_BASIC_INFO;


/* ------------------------------------------------------------------------- */
/*  DOMAIN INFO  */


#define DRM_BCERT_ACCOUNT_ID_LENGTH  SIZEOF(DRM_GUID)  /* 128 bits */
typedef struct _tagDrmBCertAccountId
{
    DRM_BYTE    rgb[ __CB_DECL( DRM_BCERT_ACCOUNT_ID_LENGTH ) ];
} DRM_BCERT_ACCOUNT_ID;

#define DRM_BCERT_SERVICE_ID_LENGTH  16  /* 128 bits */
typedef struct _tagDrmBCertServiceId
{
    DRM_BYTE    rgb[ __CB_DECL( DRM_BCERT_SERVICE_ID_LENGTH ) ];
} DRM_BCERT_SERVICE_ID;

#define DRM_BCERT_MAX_DOMAIN_URL_LENGTH  4096 
typedef struct _tagDrmBCertDomainURL
{
    DRM_DWORD   cb;  /* URL length */
    DRM_BYTE    rgb[ __CB_DECL( DRM_BCERT_MAX_DOMAIN_URL_LENGTH ) ];
} DRM_BCERT_DOMAIN_URL;

typedef struct _tagDrmBCertDomainInfo
{
    DRM_BCERT_OBJECT_HEADER  Header;
    DRM_BCERT_SERVICE_ID     ServiceID;
    DRM_BCERT_ACCOUNT_ID     AccountID;
    DRM_DWORD                dwRevision;  /* a timestamp */
    DRM_BCERT_DOMAIN_URL     DomainURL;
} DRM_BCERT_DOMAIN_INFO;


/* ------------------------------------------------------------------------- */
/*  PC INFO  */


typedef struct _tagDrmBCertPCInfo
{
    DRM_BCERT_OBJECT_HEADER  Header;
    DRM_DWORD                dwSecurityVersion;  /* A.B.C.D */
} DRM_BCERT_PC_INFO;

/* ------------------------------------------------------------------------- */
/*  SILVERLIGHT INFO  */


typedef struct
{
    DRM_BCERT_OBJECT_HEADER  Header;
    DRM_DWORD                dwSecurityVersion;  /* A.B.C.D */
    DRM_DWORD                dwPlatformIdentifier;
} DRM_BCERT_SILVERLIGHT_INFO;

/*  Platform Identifiers for the SilverLight INFO structure */
#define DRM_BCERT_SILVERLIGHT_PLATFORM_WINDOWS_X86  0
#define DRM_BCERT_SILVERLIGHT_PLATFORM_OSX_X86      1
#define DRM_BCERT_SILVERLIGHT_PLATFORM_MAX          1

/* ------------------------------------------------------------------------- */
/*  DEVICE INFO  */


#define DRM_BCERT_MAX_LICENSE_SIZE         10240  /* 10K */
#define DRM_BCERT_MAX_HEADER_SIZE          15360  /* 15K */
#define DRM_BCERT_MAX_LICENSE_CHAIN_DEPTH      2

typedef struct _tagDrmBCertDeviceInfo
{
    DRM_BCERT_OBJECT_HEADER  Header;
    DRM_DWORD                cbMaxLicense;
    DRM_DWORD                cbMaxHeader;
    DRM_DWORD                dwMaxChainDepth;
} DRM_BCERT_DEVICE_INFO;


/* ------------------------------------------------------------------------- */
/*  METERING INFO  */

#define DRM_BCERT_METERING_ID_LENGTH  SIZEOF(DRM_GUID)  /* 128 bits */
typedef struct _tagDrmBCertMeteringId
{
    DRM_BYTE    rgb[ __CB_DECL( DRM_BCERT_METERING_ID_LENGTH ) ];
} DRM_BCERT_METERING_ID;

#define DRM_BCERT_MAX_METERING_URL_LENGTH  4096 
typedef struct _tagDrmBCertMeteringURL
{
    DRM_DWORD   cb;  /* URL length */
    DRM_BYTE    rgb[ __CB_DECL( DRM_BCERT_MAX_METERING_URL_LENGTH ) ];
} DRM_BCERT_METERING_URL;

typedef struct
{
    DRM_BCERT_OBJECT_HEADER  Header;
    DRM_BCERT_METERING_ID    MeteringID;
    DRM_BCERT_METERING_URL   MeteringURL;
} DRM_BCERT_METERING_INFO;

/* ------------------------------------------------------------------------- */
/*  SERVER INFO  */


typedef struct _tagDrmBCertServerInfo
{
    DRM_BCERT_OBJECT_HEADER  Header;
    DRM_DWORD                dwWarningDays;  /* number of days before expiry to start warning */
} DRM_BCERT_SERVER_INFO;


/* ------------------------------------------------------------------------- */
/*  FEATURE INFO  */

#define DRM_BCERT_MAX_FEATURES 32    /* array size with room to grow */

#define DRM_BCERT_FEATURE_TRANSMITTER             0x00000001
#define DRM_BCERT_FEATURE_RECEIVER                0x00000002
#define DRM_BCERT_FEATURE_SHARED_CERTIFICATE      0x00000003
#define DRM_BCERT_FEATURE_SECURE_CLOCK            0x00000004
#define DRM_BCERT_FEATURE_ANTIROLLBACK_CLOCK      0x00000005
/*
** The next three feature flags should not be explicitly set in the certs
** because for any cert their values are already known 
** (i.e. every device must support metering, license sync and symmetric optimization)
** These features will stay deprecated as long as they are not optional.
*/
#define DRM_BCERT_FEATURE_RESERVED_METERING       0x00000006
#define DRM_BCERT_FEATURE_RESERVED_LICSYNC        0x00000007
#define DRM_BCERT_FEATURE_RESERVED_SYMOPT         0x00000008
#define DRM_BCERT_FEATURE_SUPPORTS_CRLS           0x00000009

#define DRM_BCERT_FEATURE_MAX_VALUE               0x00000009


#define BCERT_FEATURE_BIT(dwFeature)     (1 << ((dwFeature)-1))


typedef struct _tagDrmBCertFeatureInfo
{
    DRM_BCERT_OBJECT_HEADER  Header;
    DRM_DWORD                dwNumFeatureEntries;  /* this can be zero */
    DRM_DWORD                rgdwFeatureSet[ DRM_BCERT_MAX_FEATURES ];
} DRM_BCERT_FEATURE_INFO;


/* ------------------------------------------------------------------------- */
/*  KEY INFO  */


/* List of supported key types. (currently just one) */
#define DRM_BCERT_KEYTYPE_ECC256   0x0001

#define DRM_BCERT_MAX_KEY_USAGES 32  /* array size with room to grow */

#define DRM_BCERT_KEYUSAGE_UNKNOWN             0x00000000                
#define DRM_BCERT_KEYUSAGE_SIGN                0x00000001
#define DRM_BCERT_KEYUSAGE_ENCRYPT_KEY         0x00000002
#define DRM_BCERT_KEYUSAGE_SIGN_CRL            0x00000003
#define DRM_BCERT_KEYUSAGE_ISSUER_ALL          0x00000004
#define DRM_BCERT_KEYUSAGE_ISSUER_INDIV        0x00000005
#define DRM_BCERT_KEYUSAGE_ISSUER_DEVICE       0x00000006
#define DRM_BCERT_KEYUSAGE_ISSUER_LINK         0x00000007
#define DRM_BCERT_KEYUSAGE_ISSUER_DOMAIN       0x00000008
#define DRM_BCERT_KEYUSAGE_ISSUER_SILVERLIGHT  0x00000009
#define DRM_BCERT_KEYUSAGE_ISSUER_APPLICATION  0x0000000a
#define DRM_BCERT_KEYUSAGE_ISSUER_CRL          0x0000000b
#define DRM_BCERT_KEYUSAGE_ISSUER_METERING     0x0000000c
#define DRM_BCERT_KEYUSAGE_ISSUER_SIGN_KEYFILE 0x0000000d
#define DRM_BCERT_KEYUSAGE_SIGN_KEYFILE        0x0000000e
#define DRM_BCERT_KEYUSAGE_ISSUER_SERVER       0x0000000f

#define DRM_BCERT_KEYUSAGE_MAX_VALUE           0x0000000f


#define BCERT_KEYUSAGE_BIT(dwKeyUsage)     (1 << ((dwKeyUsage)-1))


/*
** The following byte value should be equal to the largest public key length supported
*/
#define DRM_BCERT_MAX_PUBKEY_VALUE_LENGTH     SIZEOF( PUBKEY_P256 )

typedef struct _tagDrmBCertPubKey
{
    DRM_BYTE    rgb[ __CB_DECL( DRM_BCERT_MAX_PUBKEY_VALUE_LENGTH ) ];
} DRM_BCERT_PUBKEY;


typedef struct _tagDrmBCertCertKey
{
    DRM_WORD                 wType;
    DRM_WORD                 wLength;           /* in bits */
    DRM_DWORD                dwFlags;           /* bit field; should be ignored */
    DRM_BCERT_PUBKEY         Value;
    DRM_DWORD                dwNumUsageEntries; /* this cannot be zero */
    DRM_DWORD                dwUsageSet[ DRM_BCERT_MAX_KEY_USAGES ];
} DRM_BCERT_CERTKEY;


typedef struct _tagDrmBCertKeyInfo
{
    DRM_BCERT_OBJECT_HEADER  Header;
    DRM_DWORD                dwNumKeys;                             /* actual number of items in array, > 0 */
    DRM_BCERT_CERTKEY        rgoKeys[ DRM_BCERT_MAX_KEY_USAGES ];   /* array of public keys, up to number of various key usages */
}  DRM_BCERT_KEY_INFO;


/* ------------------------------------------------------------------------- */
/*  MANUFACTURER INFO  */


#define DRM_BCERT_MAX_MANUFACTURER_STRING_LENGTH  128   /* bytes */
typedef struct _tagDrmBCertManufacturerString
{
    DRM_DWORD   cb;
    DRM_BYTE    rgb[ __CB_DECL( DRM_BCERT_MAX_MANUFACTURER_STRING_LENGTH ) ];
} DRM_BCERT_MANUFACTURER_STRING;

typedef struct _tagDrmBCertManufacturerStrings
{
    DRM_BCERT_MANUFACTURER_STRING  ManufacturerName; 
    DRM_BCERT_MANUFACTURER_STRING  ModelName;         
    DRM_BCERT_MANUFACTURER_STRING  ModelNumber;     
} DRM_BCERT_MANUFACTURER_STRINGS;

typedef struct _tagDrmBCertManufacturerInfo
{
    DRM_BCERT_OBJECT_HEADER          Header;
    DRM_DWORD                        dwFlags; /* bit field; should be ignored */
    DRM_BCERT_MANUFACTURER_STRINGS   ManufacturerStrings;
} DRM_BCERT_MANUFACTURER_INFO;


/* ------------------------------------------------------------------------- */
/*  EXTENDED DATA SIGNATURE KEY INFO */


typedef struct _tagDrmBCertExtDataSignKeyInfo
{
    DRM_BCERT_OBJECT_HEADER     Header;
    DRM_WORD                    wType; 
    DRM_WORD                    wLength;           /* in bits */
    DRM_DWORD                   dwFlags;           /* bit field; should be ignored */
    DRM_BCERT_PUBKEY            Value;
} DRM_BCERT_EXTDATA_SIGNKEY_INFO;


/* ------------------------------------------------------------------------- */
/*  SIGNATURE INFO  */


#define DRM_BCERT_SIGNATURE_TYPE_P256         0x0001    /* ECDSA-P-256-SHA-256 */

/*
** The following byte value should be equal to the largest signature length supported
*/
#define DRM_BCERT_MAX_SIGNATURE_DATA_LENGTH   SIZEOF( SIGNATURE_P256 )

typedef struct _tagDrmBCertSignatureData
{
    DRM_WORD    cb;   /* bytes */
    DRM_BYTE    rgb[ __CB_DECL( DRM_BCERT_MAX_SIGNATURE_DATA_LENGTH ) ];
} DRM_BCERT_SIGNATURE_DATA;

typedef struct _tagDrmBCertSignatureInfo
{
    DRM_BCERT_OBJECT_HEADER         Header;
    DRM_WORD                        wSignatureType;
    DRM_BCERT_SIGNATURE_DATA        SignatureData;
    DRM_DWORD                       dwIssuerKeyLength;
    DRM_BCERT_PUBKEY                IssuerKey;         /* = public key in next cert */
} DRM_BCERT_SIGNATURE_INFO;


/* ------------------------------------------------------------------------- */
/*  EXTENDED DATA RECORD */


typedef struct _tagBCertExtDataRecord
{
    DRM_BCERT_OBJECT_HEADER     Header;
    DRM_DWORD                   dwDataLength;
    DRM_BYTE                    *pbData;    /* this is a pointer, not a buffer */
} DRM_BCERT_EXTDATA_RECORD;

/* ------------------------------------------------------------------------- */
/*  EXTENDED DATA SIGNATURE */


typedef struct _tagDrmBCertExtDataSignature
{
    DRM_BCERT_OBJECT_HEADER     Header;
    DRM_WORD                    wSignatureType; 
    DRM_BCERT_SIGNATURE_DATA    SignatureData;
} DRM_BCERT_EXTDATA_SIGNATURE;


/* ------------------------------------------------------------------------- */
/*  EXTENDED DATA CONTAINER */


#define DRM_BCERT_MAX_EXTDATA_RECORDS           1

typedef struct _tagBCertExtDataContainer
{
    DRM_BCERT_OBJECT_HEADER     Header;
    DRM_DWORD                   cbRecordsCount;
    DRM_BCERT_EXTDATA_RECORD    Records[DRM_BCERT_MAX_EXTDATA_RECORDS];        
    DRM_BCERT_EXTDATA_SIGNATURE Signature;
} DRM_BCERT_EXTDATA_CONTAINER;


/* ------------------------------------------------------------------------- */
/*  CERTIFICATE STRUCTURE (for reference) */


typedef struct _tagDrmBCertCertificate
{
    DRM_BCERT_HEADER              Header;
    DRM_BCERT_BASIC_INFO          BasicInfo;

    union _tagBCertType
    {
        DRM_BCERT_DOMAIN_INFO       DomainInfo;
        DRM_BCERT_PC_INFO           PCInfo;
        DRM_BCERT_DEVICE_INFO       DeviceInfo;
        DRM_BCERT_SILVERLIGHT_INFO  SilverLightInfo;
        DRM_BCERT_METERING_INFO     MeteringInfo;
        DRM_BCERT_SERVER_INFO       ServerInfo;
    } Type; /* optional */

    DRM_BCERT_FEATURE_INFO        FeatureInfo;
    DRM_BCERT_KEY_INFO            KeyInfo;
    DRM_BCERT_MANUFACTURER_INFO   ManufacturerInfo;  /* optional */

    DRM_BCERT_EXTDATA_SIGNKEY_INFO ExtDataSignatureInfo;
    /* New elements defined post-v1 go here */
    
    DRM_BCERT_SIGNATURE_INFO      SignatureInfo;

    DRM_BCERT_EXTDATA_CONTAINER   ExtDataContainer;
} DRM_BCERT_CERTIFICATE;


/* ------------------------------------------------------------------------- */
/*  CHAIN HEADER  */


#define DRM_BCERT_CHAIN_HEADER_TAG     0x43484149  /* "CHAI" */
#define DRM_BCERT_CHAIN_VERSION        0x00000001

typedef struct _tagDrmBCertChainHeader
{
    DRM_DWORD              dwHeaderTag; /* = DRM_BCERT_CHAIN_HEADER_ID */
    DRM_DWORD              dwVersion;   /* = DRM_BCERT_CHAIN_VERSION   */
    DRM_DWORD              cbChain;
    DRM_DWORD              dwFlags;     /* bit field; should be ignored */
    DRM_DWORD              cCerts;
} DRM_BCERT_CHAIN_HEADER;


/*
** The following two offsets are relative to the beginning of the certificate chain
*/
#define DRM_BCERT_CHAIN_SIZE_OFFSET     ( 2 * SIZEOF( DRM_DWORD ) )
#define DRM_BCERT_CHAIN_COUNT_OFFSET    ( 4 * SIZEOF( DRM_DWORD ) )



/* ------------------------------------------------------------------------- */


EXIT_PK_NAMESPACE;

#endif /* __DRMBCERT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\dblint.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef DBLINT_H
#define DBLINT_H 1

#include <drmint64.h>

ENTER_PK_NAMESPACE;

/*
        File: dblint.h.  Supplement to bignum.h.  Version 10 December, 2002.

        This file has declarations related to double-precision integers,
        such as typedefs, constants, and primitive operations.

        The DRM_UINT64 type is unsigned and holds twice as many bits
        as a digit_t datum.  If (DRM_NO_NATIVE_64_TYPES = 0), then use the type
        already in the language.  Otherwise (DRM_NO_NATIVE_64_TYPES = 1)
        construct one of our own, using a struct with two digit_t fields.

        Let u, u1, u2 have type digit_t and
        d, d1, d2 have type DRM_UINT64.
        The following primitives are defined,
        whether we use the built-in type or our own type:
                                        
                DPRODUU(u1, u2) -- Product of u1 and u2, as a DRM_UINT64.
                HPRODUU(u1, u2) -- Most significant half of product
                                   of u1 and u2, as a digit_t.                
*/

#if !(DRM_NO_NATIVE_64_TYPES)

#if defined (_MSC_VER)
/*
        A problem in Visual C/C++ 4.0 (x86 version, 1995)
        prevents proper inlining of the DPRODUU function
        if we code it in a straightforward way.  Specifically,
        if we have two nearby references DPRODUU(x, y)
        and DPRODUU(x, z), where one argument (here x) is
        repeated, then the compiler calls library function
        __allmul rather than emit a MUL instruction.

        x86 version of VC 4.1 adds an __emulu function.
        VC 7.0 (2002) does not recognize it in C+ programs.
*/
#if DRM_INLINING_SUPPORTED
static __forceinline DRM_UINT64 DRM_CALL DPRODUU(const digit_t u1, const digit_t u2)
{
#if defined(_M_IX86) && !defined(__cplusplus)
        return __emulu(u1, u2);
#else
        return DRM_UI64(u1) * DRM_UI64(u2);
#endif
}
#else // INLINING
#define DPRODUU(u1, u2) (DRM_UI64(u1) * DRM_UI64(u2))
#endif

#else // _MSC_VER

#define DPRODUU(u1, u2) (DRM_UI64(u1) * DRM_UI64(u2))

#endif // _MSC_VER

#define MULTIPLY_ADD1(d1, d2, d3) \
        DRM_UI64Add(DPRODUU(d1, d2), DRM_UI64(d3))
           /* d1*d2 + d3 */

#define MULTIPLY_ADD2(d1, d2, d3, d4) \
        DRM_UI64Add(DRM_UI64Add(DPRODUU(d1, d2), DRM_UI64(d3)), \
                   DRM_UI64(d4))
          /* d1*d2 + d3 + d4 */

#define HPRODUU(u1, u2) DRM_UI64High32(DRM_UI64Mul(DRM_UI64((u1)), DRM_UI64((u2))))

#else  /* DRM_NO_NATIVE_64_TYPES */

/* No native support for 64-bit types */

#if defined( _M_AMD64_ )
    #pragma intrinsic(__umulh)
    #define HPRODUU(u1, u2) __umulh(u1, u2)
#else
    #define HPRODUU(u1, u2) DRM_UI64High32(DRM_UI64Mul(DRM_UI64((u1)), DRM_UI64((u2))))
#endif

#if !DRM_INLINING_SUPPORTED

DRM_API DRM_UINT64 DRM_CALL DPRODUU(const digit_t, const digit_t);
DRM_API DRM_UINT64 DRM_CALL MULTIPLY_ADD1(const digit_t, const digit_t, const digit_t);
DRM_API DRM_UINT64 DRM_CALL MULTIPLY_ADD2(const digit_t, const digit_t,
                                            const digit_t, const digit_t);


#endif // !DRM_INLINING_SUPPORTED

#if DRM_INLINING_SUPPORTED

DRMINLINE DRM_UINT64 DRM_CALL DPRODUU(const digit_t u1, const digit_t u2)
/*
        Multiply two single-precision operands,
        return double precision product.
        This will normally be replaced by an assembly language routine.
        unless the top half of the product (HPRODUU) is available in C.
*/
{
    return DRM_UI64Mul( DRM_UI64( u1 ), DRM_UI64( u2 ) );
}   // end DPRODUU
 


/*
    The MULTIPLY_ADD1. MULTIPLY_ADD2
    functions take single-length (digit_t) operands and
    return double-length (DRM_UINT64) results.
    Overflow is impossible.
*/


DRMINLINE DRM_UINT64 DRM_CALL MULTIPLY_ADD1(const digit_t d1, const digit_t d2,
                                                 const digit_t d3)
{
    return DRM_UI64Add( DRM_UI64Mul( DRM_UI64(d1), DRM_UI64(d2) ), DRM_UI64(d3) );
} // MULTIPLY_ADD1


DRMINLINE DRM_UINT64 DRM_CALL MULTIPLY_ADD2(const digit_t d1, const digit_t d2,
                                                 const digit_t d3, const digit_t d4)
{
    return DRM_UI64Add( DRM_UI64Add( DRM_UI64Mul( DRM_UI64(d1), DRM_UI64(d2) ), DRM_UI64(d3) ), DRM_UI64(d4) );
} // MULTIPLY_ADD2

#endif // DRM_INLINING_SUPPORTED

#endif // DRM_NO_NATIVE_64_TYPES

EXIT_PK_NAMESPACE;

#endif // DBLINT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmbase64.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMBASE64_H__
#define __DRMBASE64_H__

ENTER_PK_NAMESPACE;

/* 
   Using decode in place will cause the decoder to place the decoded output in the 
   last *pcbDestination bytes of pwszSource->pwszString
*/
#define DRM_BASE64_DECODE_IN_PLACE 1


/* DRM normally uses a special base64 encoding.  Use this flag to get standard encoding */
#define DRM_BASE64_ENCODE_WMDRM 2


/* characters required for a binary of size cb expressed as base64*/
#define CCH_BASE64_EQUIV(cb)          ((((cb)/3)+(((cb)%3)?1:0))*4)
/* SAL does not accept modulo% operand, introducing another macro for SAL */
#define CCH_BASE64_EQUIV_SAL(cb)      ((((cb)/3)+(((cb)-((cb)/3)*3)?1:0))*4)
#define CB_BASE64_DECODE(cch)         (((cch)*3)/4)
#define CCH_BASE64_ENC_LARGE(cb)      CCH_BASE64_EQUIV((cb)+DRM_ECC160_CIPHERTEXT_LEN)
#define CCH_BASE64_ENC_LARGE_WCH(cch) CCH_BASE64_ENC_LARGE((cch)*SIZEOF(DRM_WCHAR))

DRM_API DRM_RESULT DRM_CALL DRM_B64_DecodeA(
    __in_ecount( f_pdasstrSource->m_ich + f_pdasstrSource->m_cch ) const DRM_CHAR *f_pszBase,
    IN const DRM_SUBSTRING         *f_pdasstrSource,
    IN OUT DRM_DWORD *pcbDestination, 
    __out_bcount_opt( ( dwFlags & DRM_BASE64_DECODE_IN_PLACE ) == 0 ? *pcbDestination : f_pdasstrSource->m_ich + *pcbDestination ) DRM_BYTE *pbDestination,
    IN       DRM_DWORD              dwFlags);

DRM_API DRM_RESULT DRM_CALL DRM_B64_DecodeW(
    IN const DRM_CONST_STRING      *pdstrSource,
    IN OUT   DRM_DWORD             *pcbDestination, 
    __out_bcount_opt( *pcbDestination ) DRM_BYTE *pbDestination,
    IN       DRM_DWORD              dwFlags);

DRM_API DRM_RESULT DRM_CALL DRM_B64_EncodeA( 
    __in_bcount( cbBuffer ) const DRM_BYTE  *pvBuffer,    /* input buffer */
    IN       DRM_DWORD  cbBuffer,    /* input len */
    __out_ecount_opt( *pcchEncoded ) DRM_CHAR  *pszEncoded,  /* output char */
    IN OUT   DRM_DWORD *pcchEncoded, /* output ch len */
    IN       DRM_DWORD  dwFlags );

DRM_API DRM_RESULT DRM_CALL DRM_B64_EncodeW( 
    __in_bcount( f_cbSource ) const DRM_BYTE *f_pbSource,    /* input buffer */
    IN                                   DRM_DWORD        f_cbSource,    /* input len */
    __out_ecount_opt( *f_pcchEncoded ) DRM_WCHAR *f_pwszEncoded, /* output WCHAR */
    IN OUT                               DRM_DWORD       *f_pcchEncoded, /* output ch len */
    IN                                   DRM_DWORD        f_dwFlags );

EXIT_PK_NAMESPACE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmbcertbuilder.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMBCERTBUILDER_H__
#define __DRMBCERTBUILDER_H__

#include <drmcommon.h>
#include <drmtypes.h>
#include <drmeccp256.h>
#include <drmbcert.h>
#include <drmlicense.h>

ENTER_PK_NAMESPACE;

typedef struct _tagDrmBCertDomainData
{
    DRM_BCERT_SERVICE_ID    *pServiceID;
    DRM_BCERT_ACCOUNT_ID    *pAccountID;
    DRM_DWORD                dwRevision;   /* a timestamp */
    DRM_BCERT_DOMAIN_URL    *pDomainURL;
} DRM_BCERT_DOMAIN_DATA;

typedef struct _tagDrmBCertPCData
{
    DRM_DWORD                dwSecurityVersion;  /* A.B.C.D */   
} DRM_BCERT_PC_DATA;

typedef struct
{
    DRM_DWORD                dwSecurityVersion;  /* A.B.C.D */
    DRM_DWORD                dwPlatformIdentifier;
} DRM_BCERT_SILVERLIGHT_DATA;

typedef struct _tagDrmBCertDeviceData
{
    DRM_DWORD                cbMaxLicense;
    DRM_DWORD                cbMaxHeader;
    DRM_DWORD                dwMaxChainDepth;
} DRM_BCERT_DEVICE_DATA;

typedef struct
{
    DRM_BCERT_METERING_ID     *pMeteringID;
    DRM_BCERT_METERING_URL    *pMeteringURL;
} DRM_BCERT_METERING_DATA;

typedef struct _tagDrmBCertServerData
{
    DRM_DWORD                dwWarningDays;
} DRM_BCERT_SERVER_DATA;


/*
** The following byte value should be equal to the largest private key length supported
*/
#define DRM_BCERT_MAX_PRIVKEY_VALUE_LENGTH     SIZEOF( PRIVKEY_P256 )


typedef struct _tagDrmBCertPrivKey
{
    DRM_BYTE    rgb[ __CB_DECL( DRM_BCERT_MAX_PRIVKEY_VALUE_LENGTH ) ];
} DRM_BCERT_PRIVKEY;


typedef struct _tagDrmBCertExtBuilderData 
{
    DRM_BOOL                          fValid;                  /* if TRUE then add data in this structure to a new cert, otherwise ignore */
    DRM_WORD                          wExtDataKeyType;         
    DRM_WORD                          wExtDataKeyLength;       /* in bits */
    DRM_DWORD                         dwExtDataKeyFlags;       /* bit field; optional/ignored */
    DRM_BCERT_PUBKEY                  oPubKey;                 /* optional. */
    DRM_BCERT_PRIVKEY                 oPrivKey;                /* optional. */
    DRM_DWORD                         dwNumExtDataRecords;     /* 0 or 1 */
    DRM_BCERT_EXTDATA_RECORD         *pExtDataRecords;         /* NULL or present. */
    DRM_WORD                          wExtDataSignatureType;
} DRM_BCERT_EXT_BUILDER_DATA;


typedef struct _tagDrmBCertBuilderCertKey
{
    DRM_WORD                          wKeyType;
    DRM_WORD                          wKeyLength;             /* in bits */
    DRM_DWORD                         dwKeyFlags;             /* bit field; should be ignored */
    DRM_BCERT_PUBKEY                  KeyValue;
    DRM_DWORD                         dwNumKeyUsages;         /* number of key usages */
    DRM_DWORD                         *pKeyUsageSet;          /* ptr to array of key usages, cannot be NULL */

} DRM_BCERT_BUILDER_CERTKEY;


typedef struct _tagDrmBCertBuilderData
{
    DRM_DWORD                         dwChainHeaderFlags;     /* bit field; should be ignored */
       
    DRM_BCERT_CERT_ID                *pCertificateID;
    DRM_DWORD                         dwSecurityLevel;
    DRM_DWORD                         dwBasicFlags;           /* bit field; can be 0x0 or 0x1 */
    DRM_DWORD                         dwType;
    DRM_DWORD                         dwExpirationDate;       /* optional */
    DRM_BCERT_CLIENT_ID               ClientID;
    
    DRM_DWORD                         dwNumFeatureEntries;    /* may be 0 */
    DRM_DWORD                        *prgdwFeatureSet;        /* ptr to an array; may be NULL */
    
    DRM_DWORD                         dwNumCertificateKeys;   /* number of elements in array, must be >= 1 */
    DRM_BCERT_BUILDER_CERTKEY        *pCertificateKeys;       /* ptr to array of cert key structures, cannot be NULL */

    DRM_DWORD                         dwManufacturerFlags;    /* bit field; optional/ignored */
    DRM_BCERT_MANUFACTURER_STRINGS   *pManufacturerStrings;   /* optional */

    PRIVKEY_P256                     *pPrivateKey;
    DRM_DWORD                         dwIssuerKeyLength;      /* in bits */
    DRM_BCERT_PUBKEY                  IssuerKey;
    DRM_WORD                          wSignatureType;

    DRM_BCERT_EXT_BUILDER_DATA        ExtendedData;
    
    union _tagBuilderType    /* optional */
    {
        DRM_BCERT_DOMAIN_DATA       DomainData;
        DRM_BCERT_PC_DATA           PCData;
        DRM_BCERT_DEVICE_DATA       DeviceData;
        DRM_BCERT_SILVERLIGHT_DATA  SilverLightData;
        DRM_BCERT_METERING_DATA     MeteringData;
        DRM_BCERT_SERVER_DATA       ServerData;
    } Type;
} DRM_BCERT_BUILDER_DATA;


DRM_API DRM_VOID DRM_CALL BCert_SetDefaultBuilderData(
   __in         DRM_BCERT_CERT_ID         *f_pCertificateID,
   __in  const  DRM_DWORD                 f_dwType,
   __in         PRIVKEY_P256              *f_pPrivateKey,
   __in         PUBKEY_P256               *f_pIssuerKey,
   __out        DRM_BCERT_BUILDER_DATA    *f_pData
);


DRM_API DRM_VOID DRM_CALL BCert_SetKeyInfoBuilderData(
    __in_ecount(f_dwNumKeys) DRM_BCERT_BUILDER_CERTKEY  *f_pKeys,
    __in                     const DRM_DWORD             f_dwNumKeys,
    __out                    DRM_BCERT_BUILDER_DATA     *f_pData
);

DRM_API DRM_VOID DRM_CALL BCert_SetDomainBuilderData(
   __in         DRM_BCERT_SERVICE_ID    *f_pServiceID,
   __in         DRM_BCERT_ACCOUNT_ID    *f_pAccountID,
   __in  const  DRM_DWORD                f_dwRevision,
   __in         DRM_BCERT_CLIENT_ID     *f_pClientID,
   __in         DRM_BCERT_DOMAIN_URL    *f_pDomainURL,
   __out        DRM_BCERT_BUILDER_DATA  *f_pData
);


DRM_API DRM_VOID DRM_CALL BCert_SetPCBuilderData(
   __in           DRM_BCERT_CLIENT_ID      *f_pHardwareID,
   __in    const  DRM_DWORD                 f_dwSecurityVersion,  /* A.B.C.D */
   __in           PRIVKEY_P256             *f_pPrivateKey,
   __in           PUBKEY_P256              *f_pPublicKey,
   __in           DRM_BCERT_EXTDATA_RECORD *f_oRecord,
   __out          DRM_BCERT_BUILDER_DATA   *f_pData
);

DRM_API DRM_VOID DRM_CALL BCert_SetSilverLightBuilderData(
   __in           DRM_BCERT_CLIENT_ID     *f_pHardwareID,
   __in    const  DRM_DWORD                f_dwSecurityVersion,  /* A.B.C.D */  
   __in    const  DRM_DWORD                f_dwPlatformIdentifier,
   __out          DRM_BCERT_BUILDER_DATA  *f_pData
);

DRM_API DRM_VOID DRM_CALL BCert_SetDeviceBuilderData(
   __in           DRM_BCERT_CLIENT_ID     *f_pSerialNum,
   __out          DRM_BCERT_BUILDER_DATA  *f_pData
);

DRM_API DRM_VOID DRM_CALL BCert_SetMeteringBuilderData(
   __in         DRM_BCERT_METERING_ID    *f_pMeteringID,
   __in         DRM_BCERT_METERING_URL   *f_pMeteringURL,
   __out        DRM_BCERT_BUILDER_DATA   *f_pData
);

DRM_API DRM_VOID DRM_CALL BCert_SetServerBuilderData(
   __in    const  DRM_DWORD                 f_dwWarningDays,
   __out          DRM_BCERT_BUILDER_DATA   *f_pData
);

DRM_API DRM_RESULT DRM_CALL BCert_AddCert(
            DRM_BYTE                *f_pbParentChain,
            DRM_BYTE                *f_pbNewChain,
   __inout  DRM_DWORD               *f_pcbNewChain,
   __in     DRM_BCERT_BUILDER_DATA  *f_pData,
   __inout  DRM_CRYPTO_CONTEXT      *p_pCryptoCtx
);


DRM_API DRM_RESULT DRM_CALL BCert_AddExtendedDataToCert(
   __inout_bcount(f_cbCertData) DRM_BYTE *f_pbCertChain,
   __in     const DRM_DWORD              f_cbCertData,
   __in     DRM_BCERT_EXT_BUILDER_DATA   *f_pExtData,
   __inout  DRM_CRYPTO_CONTEXT           *f_pCryptoCtx
);

EXIT_PK_NAMESPACE

#endif /* __DRMBCERTBUILDER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmbcrl.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMBCRL_H__
#define __DRMBCRL_H__

#include <drmcommon.h>
#include <drmtypes.h>
#include <drmlicense.h>
#include <drmeccp256.h>
#include <drmcontextsizes.h>

ENTER_PK_NAMESPACE;

#define PLAYREADY_DRM_BCRL_SIGNATURE_TYPE 1

typedef DRM_BYTE DRM_RevocationEntry[32]; 
typedef DRM_BYTE DRM_CrlIdentifier[16];

typedef struct __tagDRM_BCRL
{    
    DRM_CrlIdentifier Identifier; 
    DRM_DWORD dwVersion; 

    DRM_DWORD cRevocationEntries;
    DRM_RevocationEntry* Entries;

} DRM_BCRL;

/*
** The following byte value should be equal to the largest signature length supported
*/
#define DRM_BCRL_MAX_SIGNATURE_DATA_LENGTH   SIZEOF( SIGNATURE_P256 )

typedef struct _tagDrmBCrlSignatureData
{   
    DRM_BYTE    type;
    DRM_WORD    cb;   
    DRM_BYTE    rgb[ __CB_DECL( DRM_BCRL_MAX_SIGNATURE_DATA_LENGTH ) ];
} DRM_BCRL_SIGNATURE_DATA;

typedef struct __tagDRM_BCRL_Signed
{    
    DRM_BCRL Crl;
    DRM_BCRL_SIGNATURE_DATA Signature;
    DRM_BYTE* pbCertificateChain;
    DRM_DWORD cbCertificateChain;
} DRM_BCRL_Signed;

/*********************************************************************
**
**  Used to validate the signature on instances of a PlayReady 
**  Binary CRL or RevInfoV2, both of which use the same type of
**  certificate chain and signature structure.
**
*********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_BCrl_VerifySignature (
                 __in_bcount(f_cbSignedBytes) const DRM_BYTE               *f_pbSignedBytes,
                 __in                               DRM_DWORD               f_cbSignedBytes,
                 __in_bcount(f_cbSignature)         DRM_BYTE               *f_pbSignature,
                 __in                               DRM_DWORD               f_cbSignature,
                 __in_bcount(f_cbCertificateChain)  DRM_BYTE               *f_pbCertificateChain,
                 __in                               DRM_DWORD               f_cbCertificateChain,
                 __in_ecount(1)               const PUBKEY_P256            *f_pRootPubkey,
                 __in                               DRM_CRYPTO_CONTEXT     *f_pCryptoCtx,
                 __in_opt                           DRM_BB_CONTEXT         *f_pcontextBBX,
                 __in_opt                           DRM_SECSTORE_CONTEXT   *f_pcontextSST,
                 __in_opt                           DRM_DST                *f_pDatastore );

/*********************************************************************
**
**  Parses Playready/Silverlight CRL from binary to data structure.
**  Verifies signature and certificate chain.
**
**  NOTE: The parser does not make copies of the DRM_RevocationEntry
**        data, it just points to them in the f_pbCrlData buffer so
**        you cannot free the f_pbCrlData and still have a valid f_poCrl
**        data structure.
**
*********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_BCrl_ParseCrl(
 __in_bcount(f_cbCrlData) const DRM_BYTE *f_pbCrlData,
 __in                     const DRM_DWORD f_cbCrlData,
 __out                    DRM_BCRL_Signed *f_poCrl,
 __in_ecount(1)           const PUBKEY_P256  *f_pRootPubkey,
 __inout                  DRM_CRYPTO_CONTEXT *f_pCryptoCtx,
 __in_opt                 DRM_BB_CONTEXT     *f_pcontextBBX,
 __in_opt                 DRM_SECSTORE_CONTEXT *f_pcontextSST,
 __in_opt                 DRM_DST            *f_pDatastore
);

/*********************************************************************
**
**  Checks to see if the given certificate is in the given CRL file.
**  Internally the API uses the DRM_BCrl_ParseCrl method to parse
**  and verify the CRL.  Then it walks through the entries in the CRL
**  to see if the given certificate is revoked.  The API returns
**  DRM_E_CERTIFICATE_REVOKED if any certificate in the chain is revoked.
**
*********************************************************************/


DRM_API DRM_RESULT DRM_CALL DRM_BCrl_CheckIfPlayReadyCertRevoked
(
    __in_bcount(f_cbPlayReadyCert)const DRM_BYTE            *f_pbPlayReadyCert,
    __in                                DRM_DWORD           f_cbPlayReadyCert,
    __in_bcount(f_cbPlayReadyCRL) const DRM_BYTE           *f_pbPlayReadyCRL,
    __in                                DRM_DWORD           f_cbPlayReadyCRL,
    __out_opt                           DRM_SHA256_Digest  *f_pRevokedCertDigest,
    __out_opt                           DRM_DWORD          *f_pdwPlayReadyCRLVer,
    __inout                             DRM_CRYPTO_CONTEXT *f_pCryptoCtx,
    __in_opt                            DRM_BB_CONTEXT     *f_pcontextBBX,
    __in_opt                            DRM_SECSTORE_CONTEXT   *f_pcontextSST,
    __in_opt                            DRM_DST            *f_pDatastore
);

  
EXIT_PK_NAMESPACE;

#endif /* __DRMBCRL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmbcertparser.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMBCERTPARSER_H__
#define __DRMBCERTPARSER_H__

#include <drmtypes.h>
#include <drmbcert.h>
#include <drmlicense.h>
#include <drmblackbox.h>
#include <drmdatastore.h>
#include <drmsecurestore.h>

ENTER_PK_NAMESPACE;

/*
** Minimal length of a certificate chain in bytes - 20
*/
#define DRM_MIN_CERT_CHAIN_LEN ( SIZEOF( DRM_DWORD )   /* Header Constant */ \
                               + SIZEOF( DRM_DWORD )   /* Version */ \
                               + SIZEOF( DRM_DWORD )   /* Length */ \
                               + SIZEOF( DRM_DWORD )   /* Flags */ \
                               + SIZEOF( DRM_DWORD ) ) /* No of certificate entries: zero for minimal cert chain */

/*
** Defines for verification of object lengths in object headers
*/
#define DRM_BCERT_SIGNATURE_OBJECT_LEN ( SIZEOF( DRM_BCERT_OBJECT_HEADER )   /* Object header */ \
                                        + SIZEOF( DRM_DWORD )      /* Signature type and length */ \
                                        + SIZEOF( SIGNATURE_P256 ) /* Signature data */ \
                                        + SIZEOF( DRM_DWORD )      /* Issuer key length */ \
                                        + SIZEOF( PUBKEY_P256 ) )  /* Issuer key data */ 

#define DRM_BCERT_BASIC_INFO_OBJECT_LEN ( SIZEOF( DRM_BCERT_OBJECT_HEADER )  /* Object header */ \
                                        + DRM_BCERT_CERT_ID_LENGTH      /* Certificate ID */ \
                                        + SIZEOF( DRM_DWORD )           /* Security level */ \
                                        + SIZEOF( DRM_DWORD )           /* Certificate Flags */ \
                                        + SIZEOF( DRM_DWORD )           /* Type */ \
                                        + SHA256_DIGEST_SIZE_IN_BYTES   /* Digest Value */ \
                                        + SIZEOF( DRM_DWORD )           /* Expiration Date */ \
                                        + DRM_BCERT_CLIENT_ID_LENGTH )  /* Client ID */
                                        
#define DRM_BCERT_DEVICE_INFO_OBJECT_LEN ( SIZEOF( DRM_BCERT_OBJECT_HEADER ) /* Object header */ \
                                        + SIZEOF( DRM_DWORD )         /* Max License Size */ \
                                        + SIZEOF( DRM_DWORD )         /* Max Header Size */ \
                                        + SIZEOF( DRM_DWORD ) )       /* Max License Chain Depth */

#define DRM_BCERT_FEATURES_OBJECT_MIN_LEN ( SIZEOF( DRM_BCERT_OBJECT_HEADER ) /* Object header */ \
                                          + SIZEOF( DRM_DWORD ) )   /* Number of features: zero for minimal feature info */

#define DRM_BCERT_KEY_OBJECT_MIN_LEN ( SIZEOF( DRM_BCERT_OBJECT_HEADER ) /* Object header */ \
                                     + SIZEOF( DRM_WORD )                /* Type */ \
                                     + SIZEOF( DRM_WORD )                /* Length */ \
                                     + SIZEOF( DRM_DWORD )               /* Flags */ \
                                     + ECC_P256_POINT_SIZE_IN_BYTES      /* Value */ \
                                     + SIZEOF( DRM_DWORD )               /* Number of Entries */ \
                                     + SIZEOF( DRM_DWORD ) )             /* One entry */
                                       
/*
** Minimal length of a certificate:
** Cert header, Basic Info, Feature Info with zero features,
** Key Info and Signature Info.
*/
#define DRM_MIN_CERTIFICATE_LEN ( SIZEOF( DRM_BCERT_HEADER )         \
                                + SIZEOF( DRM_BCERT_BASIC_INFO )     \
                                + DRM_BCERT_FEATURES_OBJECT_MIN_LEN  \
                                + DRM_BCERT_KEY_OBJECT_MIN_LEN       \
                                + DRM_BCERT_SIGNATURE_OBJECT_LEN )
                                

/*
** Minimal information to keep after a single certificate is parsed,
** which is needed verify the whole certificate chain.
*/
typedef struct __tagDRM_BCertMinimalData {
    DRM_BCERT_HEADER          oCertHeader;    
    DRM_BCERT_BASIC_INFO      oBasicInfo;
    DRM_BCERT_PUBKEY          oIssuerKey;
    DRM_BCERT_FEATURE_INFO    oFeatureInfo;
    DRM_BCERT_KEY_INFO        oKeyInfo;
    DRM_BCERT_SIGNATURE_INFO  oSignatureInfo;
} DRM_BCERT_MINIMALDATA;


/*
** Parsing error presentation, used in validation context structure.
*/
typedef struct {
    /* 
    ** Number of the cert in the chain, zero-based with leaf cert as 0 
    */
    DRM_DWORD   cCertNumber;
    /* 
    ** Error code 
    */
    DRM_RESULT  dwResult;
} DRM_BCERT_VERIFICATIONRESULT;

#define DRM_MAX_VERIFICATIONRESULTS 10

/*
** Validation context: structure that controls certificate parser behavior.
** On exit it may contain a list of parsing errors.
*/
typedef struct {
    /* 
    ** [in] The latest expiration time of the cert chain - if 0 then don't verify it 
    */
    DRMFILETIME        ftExpirationTime;
    /* 
    ** [in] Pointer to a public key of the cert chain root - if NULL then skip this verification 
    */
    const PUBKEY_P256  *pRootPubKey;
    /* 
    ** [in] Expected leaf certificate type - if DRM_BCERT_CERTTYPE_UNKNOWN then don't verify 
    */
    DRM_DWORD          dwType;
    /* 
    ** [in] Context for crypto operations 
    */
    DRM_CRYPTO_CONTEXT *pCryptoCtx;
    /*
    ** [in] Blackbox context for certificate caching
    */
    DRM_BB_CONTEXT *pBlackboxCtx;
    /*
    ** [in] Secure store context for certificate caching
    */
    DRM_SECSTORE_CONTEXT *pSecStoreCtx;
    /*
    ** [in] Datastore context for certificate caching
    */
    DRM_DST *pDSTCtx;    
    /* 
    ** [in] Set into TRUE if parser should verify cert signatures up the chain 
    */
    DRM_BOOL           fVerifyCertSignatures;
    /* 
    ** [in] Set into FALSE if parser should ignore absense of extended data and don't verify signature over it
    */
    DRM_BOOL           fDontFailOnMissingExtData;
    /* 
    ** [in] Array of key usages that must be found in a leaf certificate, 
    **      otherwise error out with DRM_E_BCERT_REQUIRED_KEYUSAGE_MISSING 
    */
    DRM_DWORD          rgdwRequiredKeyUsages[DRM_BCERT_MAX_KEY_USAGES];
    /* 
    ** [in] Actual number of elements in rgdwRequiredKeyUsages 
    */
    DRM_DWORD          cRequiredKeyUsages;
    /* 
    ** [in] If set into TRUE then parser will store non-fatal parser errors in array, keep parsing
    **      and return DRM_E_BCERT_VERIFICATION_ERRORS unless this is overriden by a fatal error
    **      (i.e. error after which the cert parsing cannot continue, for instance, length overflow)
    **      If set into FALSE then parsing stops immediately after any error.
    ** By default this field is FALSE.
    */
    DRM_DWORD          fCollectErrorsInArrayAndContinue;    
    /* 
    ** [out] Array to store and return non-fatal verification errors.
    */
    DRM_BCERT_VERIFICATIONRESULT rgoResults[ DRM_MAX_VERIFICATIONRESULTS ];
    /* 
    ** [out] Actual number of members in rgoResults array, should be <= DRM_MAX_VERIFICATIONRESULTS 
    */
    DRM_DWORD                    cResults;
    /* 
    ** [out] Number of a currently parsed certificate, zero-based with leaf cert as 0
    */
    DRM_DWORD                    cCurrentCert;
} DRM_BCERT_VERIFICATIONCONTEXT;


DRM_API DRM_RESULT DRM_CALL DRM_BCert_InitVerificationContext(
    __in_opt DRMFILETIME                      *f_ftExpirationTime,
    __in_opt const PUBKEY_P256                *f_pRootPubKey,
    __in     const DRM_DWORD                  f_dwCertType,
    __in_opt DRM_CRYPTO_CONTEXT               *f_pCryptoCtx,
    __in     DRM_BOOL                         f_fVerifyCertSignatures,
    __in     DRM_BOOL                         f_fDontFailOnMissingExtData,
    __in_ecount_opt(f_NumKeyUsages) DRM_DWORD *f_pKeyUsages,
    __in     DRM_DWORD                        f_NumKeyUsages,
    __in     DRM_BOOL                         f_fCollectErrs,
    __in_opt DRM_BB_CONTEXT                  *f_pcontextBBX,
    __in_opt DRM_SECSTORE_CONTEXT            *f_pcontextSST,
    __in_opt DRM_DST                         *f_pDatastore,
    __inout  DRM_BCERT_VERIFICATIONCONTEXT    *f_pVerificationContext
);


DRM_API DRM_RESULT DRM_CALL DRM_BCert_ParseCertificateChain(
    __in_bcount(f_cbCertData) const DRM_BYTE                      *f_pbCertData,
    __in                      const DRM_DWORD                     f_cbCertData,
    __inout                         DRM_BCERT_VERIFICATIONCONTEXT *f_pVerificationContext );

DRM_API DRM_RESULT DRM_CALL DRM_BCert_GetChainHeader(
    __in_bcount(f_cbCertData) const DRM_BYTE         *f_pbCertData,
    __in                      const DRM_DWORD        f_cbCertData,
    __inout_ecount(1)         DRM_DWORD              *f_bOffset,
    __inout_ecount(1)         DRM_BCERT_CHAIN_HEADER *f_poChain );


DRM_API DRM_RESULT DRM_CALL DRM_BCert_GetCertificate(
    __in_bcount(f_cbCertData) const DRM_BYTE        *f_pbCertData,
    __in                      const DRM_DWORD       f_cbCertData,
    __inout_ecount(1)         DRM_DWORD             *f_pbOffset,
    __inout_ecount_opt(1)     DRM_BCERT_CERTIFICATE *f_poCertificate,
    __in                      const DRM_DWORD        f_dwRequiredCertType );


DRM_API DRM_RESULT DRM_CALL DRM_BCert_GetPublicKeyByUsage(
    __in_bcount(f_cbCertData)           const DRM_BYTE    *f_pbCertData,
    __in                                const DRM_DWORD    f_cbCertData,
    __in                                const DRM_DWORD    f_dwCertIndex,
    __in                                const DRM_DWORD    f_dwKeyUsage,
    __inout_ecount(1)                   PUBKEY_P256       *f_pPubkey,
    __inout_ecount_opt(*f_pcbKeyUsages) DRM_DWORD         *f_pdwKeyUsages,
    __inout_opt                         DRM_DWORD         *f_pcbKeyUsages );


DRM_API DRM_RESULT DRM_CALL DRM_BCert_GetPublicKey(
    __in_bcount(f_cbCertData) const DRM_BYTE      *f_pbCertData,
    __in                      const DRM_DWORD     f_cbCertData,
    __in                      const DRM_DWORD     f_dwCertIndex,
    __inout_ecount(1)         PUBKEY_P256         *f_pPubkey );


DRM_API DRM_RESULT DRM_CALL DRM_BCert_FindObjectInCertByType(
    __in_bcount(f_cbCertData) const DRM_BYTE    *f_pbCertData,
    __in                      const DRM_DWORD   f_cbCertData,
    __inout_ecount(1)         DRM_DWORD         *f_pbOffset,
    __in                      const DRM_DWORD   f_dwObjectType );


DRM_API DRM_RESULT DRM_CALL DRM_BCert_VerifySignature(
    __in_ecount(__CB_DECL( f_dwSignedDataLength)) const DRM_BYTE *f_pbCertificateBegin,
    __in              DRM_DWORD                f_dwSignedDataLength,
    __inout_ecount(1) DRM_BCERT_SIGNATURE_INFO *f_poSignatureInfo,
    __inout_ecount(1) DRM_CRYPTO_CONTEXT       *f_pCryptoCtx,
    __in_opt          DRM_BB_CONTEXT           *f_pcontextBBX,
    __in_opt          DRM_SECSTORE_CONTEXT     *f_pcontextSST,
    __in_opt          DRM_DST                  *f_pDatastore );

#define DRM_BCert_GetLeafSecurityLevel(secLevel, chain) \
    NETWORKBYTES_TO_DWORD( (secLevel), (chain), SIZEOF( DRM_BCERT_CHAIN_HEADER )  \
                                              + SIZEOF( DRM_BCERT_HEADER )        \
                                              + SIZEOF( DRM_BCERT_OBJECT_HEADER ) \
                                              + SIZEOF( DRM_BCERT_CERT_ID ) );


EXIT_PK_NAMESPACE;

#endif /* __DRMBCERTPARSER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmbuild_pk.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMBUILD_PK__
#define __DRMBUILD_PK__

#ifdef __cplusplus
extern "C" {
#endif


#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
#error "Wrong build profile header file"
#endif

/*
#------------------------------------------------------------------------------
# Set this flag to '1' to include the Anti-rollback clock feature. If this
# flag is set to '0', device clock rollback will not be detected. Hence all
# date-time based content/licenses would not be able to be maintained
# accurately.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_ANTIROLLBACK_CLOCK
#define DRM_SUPPORT_ANTIROLLBACK_CLOCK          1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable application revocation functionality.
#
# If this flag is '0', the application revocation list storage and application revocation checks
# do not compile.
#
# If this flag is '1', it will set DRM_SUPPORT_REVOCATION to 1.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_APP_REVOCATION
#define DRM_SUPPORT_APP_REVOCATION              0
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable block header caching support
#
# If this flag is '1', HDS block headers may be cached for improved
# performace. Note that the sample OEM implementation in oemimpl.c
# is not adequate if multiple instances of the porting kit are running
# concurrently. The cache must be global to all instances sharing the
# same HDS file, and should have appropriate resource locking.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_BLOCK_HEADER_CACHING
#define DRM_SUPPORT_BLOCK_HEADER_CACHING        0
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable optimizations that cache the certificates
# validated when verifying a certificate chain.  This allows the asymmetric
# validation of a particular certificate to be performed only once.  Each
# subsequent validation is a symmetric validation, and is therefore much quicker.
# If this flag is set to '0', devices will use more expensive asymmetric operations.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_CERTIFICATE_CACHING
#define DRM_SUPPORT_CERTIFICATE_CACHING         1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable expired license cleanup functionality
#
# If this flag is '1', calling Drm_StoreMgmt_CleanupStore will iterate
# through all licenses and delete those that have expired and are no
# longer usable.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_CLEANUP
#define DRM_SUPPORT_CLEANUP                     1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable device revocation functionality.
#
# If this flag is '0', the Device revocation list storage and device revocation checks
# do not compile.
#
# If this flag is '1', it will set DRM_SUPPORT_REVOCATION to 1.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_DEVICE_REVOCATION
#define DRM_SUPPORT_DEVICE_REVOCATION           1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable device store functionality.
#
# If this flag is '0', the device store functionality will not be compiled.
# The device store is used by the WMDRM-NDT porting kit, and so is only needed if
# linking with it.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_DEVICESTORE
#define DRM_SUPPORT_DEVICESTORE                 1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to include the supoort for the Direct License
# Acquisition. If this flag is '0', devices will only acquire licenses
# via content transfer via a host PC or the License Sync (see below).
#
# The Following License Acquisition API and the supporting 
# functions will be included (if this flag is set to '1'):
# - Drm_LicenseAcq_GenerateChallenge
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_DLA
#define DRM_SUPPORT_DLA                         1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to include the support for License store Sync'ing
# with PC host. It this flag is '0', devices will only be able to acquire
# licenses via content transfer from a host, or through Direct License
# Acquisition with a WMRM license server.
#
# The following License Acquisition, Sync, and Sync List APIs and the 
# supporting functions will be included (if this flag is set to '1'):
# - Drm_LicenseAcq_GetContentHeader,
# - Drm_Sync_GenerateChallenge,
# - Drm_SyncListItem_InitEnum (also requires DRM_SUPPORT_DLA), and
# - Drm_SyncListItem_EnumNext (also requires DRM_SUPPORT_DLA)
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_LICENSE_SYNC
#define DRM_SUPPORT_LICENSE_SYNC                1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable file locking support
# 
# If this flag is '1', file locking support will be enabled
# in oemfileio.c. File locking support is required if the porting
# kit code is ever executed concurrently using the same HDS file
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_LOCKING
#define DRM_SUPPORT_LOCKING                     1
#endif
/*
#------------------------------------------------------------------------------
#
# Set this flag to '1' to enable multithreading support
#
# Note that you must fully implement critical section and locking support in the 
# OEM layer.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_MULTI_THREADING
#define DRM_SUPPORT_MULTI_THREADING             1
#endif
#if DRM_SUPPORT_MULTI_THREADING && !DRM_SUPPORT_LOCKING
#error "We cannot be thread safe unless file locking is supported"
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to include the Metering feature. If this flag is '0',
# licenses with a Metering ID (MID) will not be usable.
#
# The following Metering and Metering Certificate APIs and the supporting 
# functions will be included (if this flag is set to '1'):
# - Drm_MeterCert_InitEnum,
# - Drm_MeterCert_EnumNext,
# - Drm_MeterCert_Update,
# - Drm_MeterCert_Invalidate,
# - Drm_MeterCert_Delete,
# - Drm_Metering_GenerateChallenge,
# - Drm_Metering_ProcessResponse,
# - Drm_MeterCert_GenerateChallenge, and
# - Drm_MeterCert_ProcessResponse
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_METERING
#define DRM_SUPPORT_METERING                    1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to include the Secure Clock feature when clock is set 
# by using a secure time Web service and support a grace period 
# if the content license allows it. Setting the flag into '0' disables this capability.
#
# The Following Secure Clock APIs and the supporting functions will be
# included (if this flag is set to '1'):
# - Drm_SecureClock_ProcessResponse,
# - Drm_SecureClock_GenerateChallenge, and
# - Drm_SecureClock_GetValue
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_SECURE_CLOCK
#define DRM_SUPPORT_SECURE_CLOCK                1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable optimizations that offload asymmetric crypto
# operations to symmetric operations.  For example, some signatures after being
# verified once asymmetrically can be converted to a symmetric signature such that
# subsequent verifications are faster.  The same is true for some asymmetric decrypt
# operations.  If this flag is set to '0', devices will always choose more expensive
# asymmetric operations.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
#define DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS     1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable revocation support for WMDRM Network Devices 
# Transmitter functionality. Setting this flag will enable support for WMDRMNET 
# revocation list storage and revocation checks.
#
# If this flag is '0', the WMDRMNET revocation storage checks do not compile.
#
# If this flag is '1', it will set DRM_SUPPORT_REVOCATION to 1.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_WMDRMNET
#define DRM_SUPPORT_WMDRMNET                    1
#endif
/*
#------------------------------------------------------------------------------
#
# Set this flag to '1' to disable native 64 bit types
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_NO_NATIVE_64_TYPES
#if defined( _WIN64)
/* When building for a 64bit target, there needs to be native 64-bit type support */
#define DRM_NO_NATIVE_64_TYPES                  0
#else
/* Otherwise, we'll not use the native 64-bit types even if available */
#define DRM_NO_NATIVE_64_TYPES                  0
#endif
#endif

/*
#------------------------------------------------------------------------------
# DRM_SUPPORT_TEST_SETTINGS
# Set this flag to '1' to enable various test flags:
# TEST_USE_OFFSET_CLOCK
# DRM_TEST_MEM_ALLOC_CHECK
# DRM_TEST_SUPPORT_NET_IO
# DRM_ERROR_CONTRACT_TEST_MODE
# DRM_TEST_IGNORE_UNIQUE_ID
# 
# If the flag is not set it is 0 by default.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_TEST_SETTINGS
#define DRM_SUPPORT_TEST_SETTINGS               1
#endif

/*
#------------------------------------------------------------------------------
# DRM_SUPPORT_PC_FLAGS
#
# Turns several compile flags for use in PC/host components only. 
# They should be unset or set to 0 for all PlayReady implementations:
#    DRM_SUPPORT_V1_LICENSES
#    DRM_SUPPORT_GRL                 
#    DRM_SUPPORT_THUMBNAIL           
#    DRM_BACKUP_RESTORE_SUPPORT      
#    DRM_SUPPORT_CONTENT_REVOCATION  
#    DRM_SUPPORT_PLAYLIST_BURN       
#    DRM_SUPPORT_PMLICENSE           
#    DRM_SUPPORT_COPY_OPL            
#    DRM_SUPPORT_DELETEDSTORE        
#    DRM_NO_FORCE_ALIGN              
#    DRM_TEMP_LICENSE_STORE_HDS      
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_PC_FLAGS
#define DRM_SUPPORT_PC_FLAGS    0
#endif

/*
#------------------------------------------------------------------------------
# NO_DRM_CRT
# Choose CRT functions implementation, using own DRM version is default for PK
#------------------------------------------------------------------------------
*/
#ifndef NO_DRM_CRT
#define NO_DRM_CRT                      0
#endif

/*
#------------------------------------------------------------------------------
# DRM_USE_ASSEMBLY
# Set to 1 to enable assembly optimized routines where available
#------------------------------------------------------------------------------
*/
#ifndef DRM_USE_ASSEMBLY
#define DRM_USE_ASSEMBLY                0
#endif

/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable pre-computation of G table to enable speed-up
# in ECC operations at a cost of higher memory footprint
#------------------------------------------------------------------------------
*/
#ifndef DRM_PRECOMPUTE_GTABLE
#define DRM_PRECOMPUTE_GTABLE           0
#endif


#ifdef __cplusplus
}
#endif

#endif  /* __DRMBUILD_PKNEXT_DBG__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmbuild_pc.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMBUILD_PK__
#define __DRMBUILD_PK__

#ifdef __cplusplus
extern "C" {
#endif


#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_PC
#error "Wrong build profile header file"
#endif

/*
#------------------------------------------------------------------------------
# Set this flag to '1' to include the Anti-rollback clock feature. If this
# flag is set to '0', device clock rollback will not be detected. Hence all
# date-time based content/licenses would not be able to be maintained
# accurately.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_ANTIROLLBACK_CLOCK
#define DRM_SUPPORT_ANTIROLLBACK_CLOCK          1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable application revocation functionality.
#
# If this flag is '0', the application revocation list storage and application revocation checks
# do not compile.
#
# If this flag is '1', it will set DRM_SUPPORT_REVOCATION to 1.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_APP_REVOCATION
#define DRM_SUPPORT_APP_REVOCATION              0
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable block header caching support
#
# If this flag is '1', HDS block headers may be cached for improved
# performace. Note that the sample OEM implementation in oemimpl.c
# is not adequate if multiple instances of the porting kit are running
# concurrently. The cache must be global to all instances sharing the
# same HDS file, and should have appropriate resource locking.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_BLOCK_HEADER_CACHING
#define DRM_SUPPORT_BLOCK_HEADER_CACHING        0
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable optimizations that cache the certificates
# validated when verifying a certificate chain.  This allows the asymmetric
# validation of a particular certificate to be performed only once.  Each
# subsequent validation is a symmetric validation, and is therefore much quicker.
# If this flag is set to '0', devices will use more expensive asymmetric operations.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_CERTIFICATE_CACHING
#define DRM_SUPPORT_CERTIFICATE_CACHING         1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable expired license cleanup functionality
#
# If this flag is '1', calling Drm_StoreMgmt_CleanupStore will iterate
# through all licenses and delete those that have expired and are no
# longer usable.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_CLEANUP
#define DRM_SUPPORT_CLEANUP                     1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable device revocation functionality.
#
# If this flag is '0', the Device revocation list storage and device revocation checks
# do not compile.
#
# If this flag is '1', it will set DRM_SUPPORT_REVOCATION to 1.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_DEVICE_REVOCATION
#define DRM_SUPPORT_DEVICE_REVOCATION           1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable device store functionality.
#
# If this flag is '0', the device store functionality will not be compiled.
# The device store is used by the WMDRM-NDT porting kit, and so is only needed if
# linking with it.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_DEVICESTORE
#define DRM_SUPPORT_DEVICESTORE                 1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to include the supoort for the Direct License
# Acquisition. If this flag is '0', devices will only acquire licenses
# via content transfer via a host PC or the License Sync (see below).
#
# The Following License Acquisition API and the supporting 
# functions will be included (if this flag is set to '1'):
# - Drm_LicenseAcq_GenerateChallenge
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_DLA
#define DRM_SUPPORT_DLA                         1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to include the support for License store Sync'ing
# with PC host. It this flag is '0', devices will only be able to acquire
# licenses via content transfer from a host, or through Direct License
# Acquisition with a WMRM license server.
#
# The following License Acquisition, Sync, and Sync List APIs and the 
# supporting functions will be included (if this flag is set to '1'):
# - Drm_LicenseAcq_GetContentHeader,
# - Drm_Sync_GenerateChallenge,
# - Drm_SyncListItem_InitEnum (also requires DRM_SUPPORT_DLA), and
# - Drm_SyncListItem_EnumNext (also requires DRM_SUPPORT_DLA)
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_LICENSE_SYNC
#define DRM_SUPPORT_LICENSE_SYNC                1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable file locking support
# 
# If this flag is '1', file locking support will be enabled
# in oemfileio.c. File locking support is required if the porting
# kit code is ever executed concurrently using the same HDS file
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_LOCKING
#define DRM_SUPPORT_LOCKING                     1
#endif
/*
#------------------------------------------------------------------------------
#
# Set this flag to '1' to enable multithreading support
#
# Note that you must fully implement critical section and locking support in the 
# OEM layer.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_MULTI_THREADING
#define DRM_SUPPORT_MULTI_THREADING             1
#endif
#if DRM_SUPPORT_MULTI_THREADING && !DRM_SUPPORT_LOCKING
#error "We cannot be thread safe unless file locking is supported"
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to include the Metering feature. If this flag is '0',
# licenses with a Metering ID (MID) will not be usable.
#
# The following Metering and Metering Certificate APIs and the supporting 
# functions will be included (if this flag is set to '1'):
# - Drm_MeterCert_InitEnum,
# - Drm_MeterCert_EnumNext,
# - Drm_MeterCert_Update,
# - Drm_MeterCert_Invalidate,
# - Drm_MeterCert_Delete,
# - Drm_Metering_GenerateChallenge,
# - Drm_Metering_ProcessResponse,
# - Drm_MeterCert_GenerateChallenge, and
# - Drm_MeterCert_ProcessResponse
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_METERING
#define DRM_SUPPORT_METERING                    1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to include the Secure Clock feature when clock is set 
# by using a secure time Web service and support a grace period 
# if the content license allows it. Setting the flag into '0' disables this capability.
#
# The Following Secure Clock APIs and the supporting functions will be
# included (if this flag is set to '1'):
# - Drm_SecureClock_ProcessResponse,
# - Drm_SecureClock_GenerateChallenge, and
# - Drm_SecureClock_GetValue
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_SECURE_CLOCK
#define DRM_SUPPORT_SECURE_CLOCK                1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable optimizations that offload asymmetric crypto
# operations to symmetric operations.  For example, some signatures after being
# verified once asymmetrically can be converted to a symmetric signature such that
# subsequent verifications are faster.  The same is true for some asymmetric decrypt
# operations.  If this flag is set to '0', devices will always choose more expensive
# asymmetric operations.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
#define DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS     1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable revocation support for WMDRM Network Devices 
# Transmitter functionality. Setting this flag will enable support for WMDRMNET 
# revocation list storage and revocation checks.
#
# If this flag is '0', the WMDRMNET revocation storage checks do not compile.
#
# If this flag is '1', it will set DRM_SUPPORT_REVOCATION to 1.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_WMDRMNET
#define DRM_SUPPORT_WMDRMNET                    1
#endif
/*
#------------------------------------------------------------------------------
#
# Set this flag to '1' to disable native 64 bit types
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_NO_NATIVE_64_TYPES
#if defined( _WIN64)
/* When building for a 64bit target, there needs to be native 64-bit type support */
#define DRM_NO_NATIVE_64_TYPES                  0
#else
/* Otherwise, we'll not use the native 64-bit types even if available */
#define DRM_NO_NATIVE_64_TYPES                  0
#endif
#endif

/*
#------------------------------------------------------------------------------
# DRM_SUPPORT_TEST_SETTINGS
# Set this flag to '1' to enable various test flags:
# TEST_USE_OFFSET_CLOCK
# DRM_TEST_MEM_ALLOC_CHECK
# DRM_TEST_SUPPORT_NET_IO
# DRM_ERROR_CONTRACT_TEST_MODE
# DRM_TEST_IGNORE_UNIQUE_ID
# 
# If the flag is not set it is 0 by default.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_TEST_SETTINGS
#define DRM_SUPPORT_TEST_SETTINGS               1
#endif

/*
#------------------------------------------------------------------------------
# DRM_SUPPORT_PC_FLAGS
#
# Turns several compile flags for use in PC/host components only. 
# They should be unset or set to 0 for all PlayReady implementations:
#    DRM_SUPPORT_V1_LICENSES
#    DRM_SUPPORT_GRL                 
#    DRM_SUPPORT_THUMBNAIL           
#    DRM_BACKUP_RESTORE_SUPPORT      
#    DRM_SUPPORT_CONTENT_REVOCATION  
#    DRM_SUPPORT_PLAYLIST_BURN       
#    DRM_SUPPORT_PMLICENSE           
#    DRM_SUPPORT_COPY_OPL            
#    DRM_SUPPORT_DELETEDSTORE        
#    DRM_NO_FORCE_ALIGN              
#    DRM_TEMP_LICENSE_STORE_HDS      
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_PC_FLAGS
#define DRM_SUPPORT_PC_FLAGS    0
#endif

/*
#------------------------------------------------------------------------------
# NO_DRM_CRT
# Choose CRT functions implementation, using own DRM version is default for PK
#------------------------------------------------------------------------------
*/
#ifndef NO_DRM_CRT
#define NO_DRM_CRT                      0
#endif

/*
#------------------------------------------------------------------------------
# DRM_USE_ASSEMBLY
# Set to 1 to enable assembly optimized routines where available
#------------------------------------------------------------------------------
*/
#ifndef DRM_USE_ASSEMBLY
#define DRM_USE_ASSEMBLY                0
#endif

/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable pre-computation of G table to enable speed-up
# in ECC operations at a cost of higher memory footprint
#------------------------------------------------------------------------------
*/
#ifndef DRM_PRECOMPUTE_GTABLE
#define DRM_PRECOMPUTE_GTABLE           0
#endif


#ifdef __cplusplus
}
#endif

#endif  /* __DRMBUILD_PKNEXT_DBG__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmbuild_oem.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMBUILD_OEM_H__
#define __DRMBUILD_OEM_H__

#ifdef __cplusplus
extern "C" {
#endif

#if DRM_BUILD_PROFILE != DRM_BUILD_PROFILE_OEM
#error "Wrong build profile header file"
#endif

/*
#------------------------------------------------------------------------------
# Set this flag to '1' to include the Anti-rollback clock feature. If this
# flag is set to '0', device clock rollback will not be detected. Hence all
# date-time based content/licenses would not be able to be maintained
# accurately.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_ANTIROLLBACK_CLOCK
#define DRM_SUPPORT_ANTIROLLBACK_CLOCK          0
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable application revocation functionality.
#
# If this flag is '0', the application revocation list storage and application revocation checks
# do not compile.
#
# If this flag is '1', it will set DRM_SUPPORT_REVOCATION to 1.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_APP_REVOCATION
#define DRM_SUPPORT_APP_REVOCATION              0
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable block header caching support
#
# If this flag is '1', HDS block headers may be cached for improved
# performace. Note that the sample OEM implementation in oemimpl.c
# is not adequate if multiple instances of the porting kit are running
# concurrently. The cache must be global to all instances sharing the
# same HDS file, and should have appropriate resource locking.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_BLOCK_HEADER_CACHING
#define DRM_SUPPORT_BLOCK_HEADER_CACHING        0
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable optimizations that cache the certificates
# validated when verifying a certificate chain.  This allows the asymmetric
# validation of a particular certificate to be performed only once.  Each
# subsequent validation is a symmetric validation, and is therefore much quicker.
# If this flag is set to '0', devices will use more expensive asymmetric operations.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_CERTIFICATE_CACHING
#define DRM_SUPPORT_CERTIFICATE_CACHING         1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable expired license cleanup functionality
#
# If this flag is '1', calling Drm_StoreMgmt_CleanupStore will iterate
# through all licenses and delete those that have expired and are no
# longer usable.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_CLEANUP
#define DRM_SUPPORT_CLEANUP                     1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable device revocation functionality.
#
# If this flag is '0', the Device revocation list storage and device revocation checks
# do not compile.
#
# If this flag is '1', it will set DRM_SUPPORT_REVOCATION to 1.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_DEVICE_REVOCATION
#define DRM_SUPPORT_DEVICE_REVOCATION           1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable device store functionality.
#
# If this flag is '0', the device store functionality will not be compiled.
# The device store is used by the WMDRM-NDT porting kit, and so is only needed if
# linking with it.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_DEVICESTORE
#define DRM_SUPPORT_DEVICESTORE                 1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to include the supoort for the Direct License
# Acquisition. If this flag is '0', devices will only acquire licenses
# via content transfer via a host PC or the License Sync (see below).
#
# The Following License Acquisition API and the supporting 
# functions will be included (if this flag is set to '1'):
# - Drm_LicenseAcq_GenerateChallenge
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_DLA
#define DRM_SUPPORT_DLA                         1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to include the support for License store Sync'ing
# with PC host. It this flag is '0', devices will only be able to acquire
# licenses via content transfer from a host, or through Direct License
# Acquisition with a WMRM license server.
#
# The following License Acquisition, Sync, and Sync List APIs and the 
# supporting functions will be included (if this flag is set to '1'):
# - Drm_LicenseAcq_GetContentHeader,
# - Drm_Sync_GenerateChallenge,
# - Drm_SyncListItem_InitEnum (also requires DRM_SUPPORT_DLA), and
# - Drm_SyncListItem_EnumNext (also requires DRM_SUPPORT_DLA)
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_LICENSE_SYNC
#define DRM_SUPPORT_LICENSE_SYNC                1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable file locking support
# 
# If this flag is '1', file locking support will be enabled
# in oemfileio.c. File locking support is required if the porting
# kit code is ever executed concurrently using the same HDS file
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_LOCKING
#define DRM_SUPPORT_LOCKING                     0
#endif
/*
#
# Set this flag to '1' to enable multithreading support
#
# Note that you must fully implement critical section and locking support in the 
# OEM layer.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_MULTI_THREADING
#define DRM_SUPPORT_MULTI_THREADING             0
#endif
#if DRM_SUPPORT_MULTI_THREADING && !DRM_SUPPORT_LOCKING
#error "We cannot be thread safe unless file locking is supported"
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to include the Metering feature. If this flag is '0',
# licenses with a Metering ID (MID) will not be usable.
#
# The following Metering and Metering Certificate APIs and the supporting 
# functions will be included (if this flag is set to '1'):
# - Drm_MeterCert_InitEnum,
# - Drm_MeterCert_EnumNext,
# - Drm_MeterCert_Update,
# - Drm_MeterCert_Invalidate,
# - Drm_MeterCert_Delete,
# - Drm_Metering_GenerateChallenge,
# - Drm_Metering_ProcessResponse,
# - Drm_MeterCert_GenerateChallenge, and
# - Drm_MeterCert_ProcessResponse
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_METERING
#define DRM_SUPPORT_METERING                    1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to include the Secure Clock feature when clock is set 
# by using a secure time Web service and support a grace period 
# if the content license allows it. Setting the flag into '0' disables this capability.
#
# The Following Secure Clock APIs and the supporting functions will be
# included (if this flag is set to '1'):
# - Drm_SecureClock_ProcessResponse,
# - Drm_SecureClock_GenerateChallenge, and
# - Drm_SecureClock_GetValue
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_SECURE_CLOCK
#define DRM_SUPPORT_SECURE_CLOCK                1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable optimizations that offload asymmetric crypto
# operations to symmetric operations.  For example, some signatures after being
# verified once asymmetrically can be converted to a symmetric signature such that
# subsequent verifications are faster.  The same is true for some asymmetric decrypt
# operations.  If this flag is set to '0', devices will always choose more expensive
# asymmetric operations.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
#define DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS     1
#endif
/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable revocation support for WMDRM Network Devices 
# Transmitter functionality. Setting this flag will enable support for WMDRMNET 
# revocation list storage and revocation checks.
#
# If this flag is '0', the WMDRMNET revocation storage checks do not compile.
#
# If this flag is '1', it will set DRM_SUPPORT_REVOCATION to 1.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_WMDRMNET
#define DRM_SUPPORT_WMDRMNET                    1
#endif
/*
#------------------------------------------------------------------------------
#
# Set this flag to '1' to disable native 64 bit types
#
# There are no top level APIs directly affected by this flag.
# 
#------------------------------------------------------------------------------
*/
#ifndef DRM_NO_NATIVE_64_TYPES
#define DRM_NO_NATIVE_64_TYPES                  0
#endif 

/*
#------------------------------------------------------------------------------
# DRM_SUPPORT_TEST_SETTINGS
# Set this flag to '1' to enable various test flags:
# TEST_USE_OFFSET_CLOCK
# DRM_TEST_MEM_ALLOC_CHECK
# DRM_TEST_SUPPORT_NET_IO
# DRM_ERROR_CONTRACT_TEST_MODE
# DRM_TEST_IGNORE_UNIQUE_ID
# 
# If the flag is not set it is 0 by default.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_TEST_SETTINGS
#define DRM_SUPPORT_TEST_SETTINGS               0
#endif

/*
#------------------------------------------------------------------------------
# DRM_SUPPORT_PC_FLAGS
#
# Turns several compile flags for use in PC/host components only. 
# They should be unset or set to 0 for all PlayReady implementations:
#    DRM_SUPPORT_V1_LICENSES
#    DRM_SUPPORT_GRL                 
#    DRM_SUPPORT_THUMBNAIL           
#    DRM_BACKUP_RESTORE_SUPPORT      
#    DRM_SUPPORT_CONTENT_REVOCATION  
#    DRM_SUPPORT_PLAYLIST_BURN       
#    DRM_SUPPORT_PMLICENSE           
#    DRM_SUPPORT_COPY_OPL            
#    DRM_SUPPORT_DELETEDSTORE        
#    DRM_NO_FORCE_ALIGN              
#    DRM_TEMP_LICENSE_STORE_HDS      
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_PC_FLAGS
#define DRM_SUPPORT_PC_FLAGS    0
#endif

/*
#------------------------------------------------------------------------------
# NO_DRM_CRT
# Choose CRT functions implementation, using own DRM version is default for PK
#------------------------------------------------------------------------------
*/
#ifndef NO_DRM_CRT
#define NO_DRM_CRT                      0
#endif

/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable pre-computation of G table to enable speed-up
# in ECC operations at a cost of higher memory footprint
#------------------------------------------------------------------------------
*/
#ifndef DRM_PRECOMPUTE_GTABLE
#define DRM_PRECOMPUTE_GTABLE           0
#endif


#ifdef __cplusplus
}
#endif

#endif  /* __DRMBUILD_OEM_RET_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmblackbox.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMBLACKBOX_H__
#define __DRMBLACKBOX_H__

#include <drmlicense.h>
#include <drmdevcert.h>
#include <drmcipher.h>
#include <drmeccp256.h>
#include <drmxmr.h>
#include <byteorder.h>
#include <drmdomainstore.h>

ENTER_PK_NAMESPACE;

#define DRM_PK_BUFFER_MAX  DRM_ECC160_PLAINTEXT_LEN
#define DRM_MAX_DRMOLDKEYS 20
#define DRMKEYPAIRSIZE    ( SIZEOF( PUBKEY ) + SIZEOF( PRIVKEY ) ) 

typedef struct __tagDRM_BB_CONTEXT
{
    /* Make sure the crypto context is the first member in this struct */
    DRM_CRYPTO_CONTEXT                   CryptoContext;
    DRM_DEVICE_CERTIFICATE_CACHED_VALUES cachedCertValues;
#if DRM_SUPPORT_DOMAINS    
    DRM_DOMAINSTORE_CONTEXT             *pDomainStoreContext; /* Used for domain-bound licenses */
#endif /* DRM_SUPPORT_DOMAINS */
    DRM_BINARY_DEVICE_CERT_CACHED_VALUES cachedBCertValues;
    DRM_VOID                            *pOEMContext;
    DRM_BOOL                             fInited;
} DRM_BB_CONTEXT;

typedef enum _BB_SUPPORTED_ALGORITHMS
{
    eMSDRM_PK  = 1,  /* The key is encrypted with a ECC public key */
    eMSDRM_CK  = 2,  /* This is a chained license key algorithm. ( DES/AES encrypted ) */
    eMSDRM_SYM = 3   /* The license is symmetrically bound.  This means that is was actually rebound to a symmetric key once is was stored on the device */
} BB_SUPPORTED_ALGORITHMS;

#define LEGACY_KID_B64ENC_LEN   24
#define DRM_MAX_CHECKSUM        MAX( MAX( CHECKSUM_LENGTH, LEGACY_KID_B64ENC_LEN ), DRM_AES_CK_CHECKSUM_LENGTH )

/*
** Contains checksum data
*/
typedef struct __tagDRM_BB_CHECKSUM_CONTEXT
{
    DRM_BOOL   m_fIgnoreChecksum;
    DRM_BYTE   m_rgbChecksumData[__CB_DECL( DRM_MAX_CHECKSUM )]; 
    DRM_DWORD  m_cbChecksum;  /* Should be 20 bytes for normal checksum, 24 bytes for V1 header checksum */
    DRM_KID    m_KID;
    DRM_BYTE  *m_pbV1KID;     /* If not NULL then use the old V1 checksum algorithm */
} DRM_BB_CHECKSUM_CONTEXT;

/*
** Contains binding information for XML licenses
*/
typedef DRM_DWORD_ALIGN struct __tagDRM_XML_BINDING_INFO
{
    DRM_BYTE                 m_rgbContentKey[__CB_DECL(DRM_ECC160_CIPHERTEXT_LEN)];
    DRM_BYTE                 m_rgbSignature[__CB_DECL(DRM_ECC160_SIGNATURE_LEN)];
    PUBKEY                   m_oPublKey;
    PUBKEY                   m_oLsPublKey;
    DRM_DWORD                m_dwAlgorithm;  
} DRM_XML_BINDING_INFO;

typedef struct __tagDRM_XMR_BINDING_INFO
{
    DRM_XMR_CONTENT_KEY            *m_pxmrContentKey;
    DRM_XMR_OPTIMIZED_CONTENT_KEY  *m_pxmrOptimizedContentKey; /* Pointer to symmetrically optimized version of content key */
    DRM_XMR_DEVICE_KEY             *m_pxmrDeviceKey;
    DRM_XMR_ECC_DEVICE_KEY         *m_pxmrDeviceEccKey;
    DRM_XMR_SIGNATURE              *m_pxmrSignature;
    DRM_XMR_DOMAIN_ID              *m_pxmrDomainID;
    DRM_XMR_LICENSE                *m_pxmrLicense;    /* An HMAC signature of this license will be calculated and compared to m_pbSignature */        
} DRM_XMR_BINDING_INFO;

typedef struct __tagDRM_BINDING_INFO
{
    DRM_BB_CHECKSUM_CONTEXT m_oChecksum;   /* Contains Checksum data */
    DRM_BOOL                m_fXMRLicense; /* Specifies XMR or XML license type */

    union
    {
        DRM_XMR_BINDING_INFO m_XMR;
        DRM_XML_BINDING_INFO m_XML;
    } m_BindingInfo; 
} DRM_BINDING_INFO;


DRM_API DRM_RESULT DRM_CALL DRM_BBX_Initialize( 
    __in_opt             DRM_VOID           *f_pOEMContext,
    __inout_ecount( 1 )  DRM_BB_CONTEXT     *f_pcontextBBX );

DRM_API DRM_RESULT DRM_CALL DRM_BBX_GetClientId(
    __out_ecount( 1 )    CLIENTID          *f_pClientId,
    __inout_ecount( 1 )  DRM_BB_CONTEXT    *f_pcontextBBX );

DRM_API DRM_RESULT DRM_CALL DRM_BBX_Shutdown( 
    __inout_ecount( 1 )  DRM_BB_CONTEXT     *f_pcontextBBX );

DRM_API DRM_BOOL DRM_CALL DRM_BBX_CanBind( 
    __in_ecount( f_dwChainLength ) const DRM_BINDING_INFO *f_pBindingInfo,
    __in                                 DRM_DWORD         f_dwChainLength,
    __inout_ecount( 1 )                  DRM_BB_CONTEXT   *f_pcontextBBX,
    __out_opt                            DRM_RESULT       *f_pDr );
    
DRM_API DRM_RESULT DRM_CALL DRM_BBX_HashValue(
    __in_bcount( f_cbValue )  const     DRM_BYTE       *f_pbValue,
    __in                                DRM_DWORD       f_cbValue,
    __in_bcount( DRM_SHA1_DIGEST_LEN )  DRM_BYTE        f_rgbHashValue[__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    __inout_ecount( 1 )                 DRM_BB_CONTEXT *f_pcontextBBX );
    
DRM_API DRM_BOOL DRM_CALL DRM_BBX_DecryptLicense(
    __inout_bcount( f_cbEncryptedLicense )   DRM_BYTE       *f_pbEncryptedLicense,
    __in                                     DRM_DWORD       f_cbEncryptedLicense,
    __out_bcount_opt( f_cbEncryptedLicense - DRM_ECC160_CIPHERTEXT_LEN )
                                             DRM_BYTE       *f_pbLicense,
    __inout_ecount( 1 )                      DRM_BB_CONTEXT *f_pcontextBBX );

DRM_API DRM_RESULT DRM_CALL DRM_BBX_CipherKeySetup( 
    __in_ecount( f_dwChainLength ) const DRM_BINDING_INFO    *f_pBindingInfo,    
    __in                                 DRM_DWORD            f_dwChainLength,
    __out_ecount( 1 )                    DRM_CIPHER_CONTEXT  *f_pCipherContext,
    __inout_ecount( 1 )                  DRM_BB_CONTEXT      *f_pcontextBBX );

typedef enum
{
    eBBX_PRIVKEY_MACHINE               = 1,
    eBBX_PRIVKEY_RESTORELICENSESIGNER  = 2,
    eBBX_PRIVKEY_TRANSFERLICENSESIGNER = 3
} eBBX_SIGNING_KEY_TYPES;

DRM_API DRM_RESULT DRM_CALL DRM_BBX_SignData(
    __inout_ecount( 1 )                      DRM_BB_CONTEXT *f_pcontextBBX,
    __in_bcount( f_cbData )  const           DRM_BYTE       *f_pbData,
    __in                                     DRM_DWORD       f_cbData,
    __in                                     DRM_DWORD       f_ePrivKeyType,
    __out_bcount( DRM_ECC160_SIGNATURE_LEN ) DRM_BYTE        f_rgbSignature[__CB_DECL( DRM_ECC160_SIGNATURE_LEN )] );

DRM_API DRM_RESULT DRM_CALL DRM_BBX_SymmetricSign(
    __inout_ecount( 1 )                  DRM_BB_CONTEXT *f_pcontextBBX,
    __in_bcount( f_cbData )  const       DRM_BYTE       *f_pbData,
    __in                                 DRM_DWORD       f_cbData,
    __out_bcount( DRM_SHA1_DIGEST_LEN )  DRM_BYTE        f_rgbSymSig[__CB_DECL( DRM_SHA1_DIGEST_LEN )] );

DRM_API DRM_RESULT DRM_CALL DRM_BBX_SymmetricVerify(
    __inout_ecount( 1 )                      DRM_BB_CONTEXT *f_pcontextBBX,
    __in_bcount( f_cbData )            const DRM_BYTE       *f_pbData,
    __in                                     DRM_DWORD       f_cbData,
    __in_opt                           const DRM_SLK        *f_pslk,
    __in_bcount( DRM_SHA1_DIGEST_LEN ) const DRM_BYTE        f_rgbSymSig[__CB_DECL( DRM_SHA1_DIGEST_LEN )] );

DRM_API DRM_RESULT DRM_CALL DRM_BBX_AsymmetricToSymmetricKeyXML(
    __inout_ecount( 1 )      DRM_BB_CONTEXT       *f_pcontextBBX,
    __inout_ecount_opt( 1 )  DRM_BINDING_INFO     *f_pbindinfo,
    __out_ecount( 1 )        DRM_DWORD            *f_pcbSymmKey );

DRM_API DRM_RESULT DRM_CALL DRM_BBX_AsymmetricToSymmetricKeyXMR(
    __inout_ecount( 1 )               DRM_BB_CONTEXT                *f_pcontextBBX,    
    __inout_ecount_opt( 1 )           DRM_BINDING_INFO              *f_pbindinfo,
    __inout_bcount( f_cbLicense )     DRM_BYTE                      *f_pbLicense,
    __in                              DRM_DWORD                      f_cbLicense,
    __inout_ecount( 1 )               DRM_DWORD                     *f_pcbLicenseUsed,
    __inout_ecount( 1 )               DRM_STACK_ALLOCATOR_CONTEXT   *f_pStack,
    __out_ecount( 1 )                 DRM_DWORD                     *f_pcbSymmKey );

DRM_API DRM_RESULT DRM_CALL DRM_BBX_RebindSymmetricKey(
    __inout_ecount( 1 )                         DRM_BB_CONTEXT  *f_pcontextBBX,
    __in_ecount( 1 )                      const DRM_SLK         *f_pslk,
    __inout_bcount( f_cbSymmKey + f_ibSymmKey ) DRM_BYTE        *f_pbSymmKey,
    __in                                        DRM_DWORD        f_ibSymmKey,
    __in                                        DRM_DWORD        f_cbSymmKey,
    __in_opt                                    DRM_XMR_LICENSE *f_pXmrLicense );

DRM_API DRM_RESULT DRM_CALL DRM_BBX_RebindSLK(
    __inout_ecount( 1 )             DRM_BB_CONTEXT *f_pcontextBBX,
    __in_bcount( f_cbEncSLK ) const DRM_BYTE       *f_pbEncSLK,
    __in                            DRM_DWORD       f_cbEncSLK,
    __out_ecount( 1 )               DRM_SLK        *f_pslk );

#if DRM_SUPPORT_DOMAINS

DRM_API DRM_RESULT DRM_CALL DRM_BBX_StoreDomainPrivateKeys(
    __inout_ecount( 1 )         DRM_BB_CONTEXT *f_poBBXContext,
    __inout_ecount( 1 )         DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    __inout_bcount( f_cbData )  DRM_BYTE *f_pbData,
    __in                        DRM_DWORD f_cbData,
    __inout_ecount( 1 )         DRM_DOMAIN_ID *f_poDomainID,
    __in_ecount( 1 )            PUBKEY_P256 *f_poECC256PubKey,
    __in_ecount( 1 )            DRM_ANSI_STRING *f_pdastrCertificate );

DRM_API DRM_RESULT DRM_CALL DRM_BBX_EncryptDomainPrivateKey(
    __inout_ecount( 1 )                         DRM_BB_CONTEXT   *f_poBBXContext,
    __in_bcount( f_pdasstrInputPrivKey->m_ich + f_pdasstrInputPrivKey->m_cch )
                                                DRM_CHAR         *f_pszBase,
    __in                                        DRM_SUBSTRING    *f_pdasstrInputPrivKey,
    __out_ecount( 1 )                           PRIVKEY_P256     *f_poOutputPrivKey );

#endif /* DRM_SUPPORT_DOMAINS */

DRM_API DRM_RESULT DRM_CALL DRM_BBX_SymmetricCipher(
    __in                         DRM_BOOL        f_fEncrypt,
    __in                         DRM_BOOL        f_fUseLegacyCrypto,
    __in_bcount_opt( f_cbKey )   DRM_BYTE       *f_pbKey,
    __in                         DRM_DWORD       f_cbKey,
    __in_bcount( f_cbData )      DRM_BYTE       *f_pbDataIn,
    __out_bcount_opt( f_cbData ) DRM_BYTE       *f_pbDataOut,
    __in                         DRM_DWORD       f_cbData );

DRM_API DRM_RESULT DRM_CALL DRM_BBX_SymmetricBind(
    __inout_ecount( 1 )          DRM_BB_CONTEXT *f_poBBXContext,
    __in                         DRM_BOOL        f_fEncrypt,
    __in                         DRM_BOOL        f_fUseLegacyCrypto,
    __in_bcount( f_cbData )      DRM_BYTE       *f_pbDataIn,
    __out_bcount_opt( f_cbData ) DRM_BYTE       *f_pbDataOut,
    __in                         DRM_DWORD       f_cbData );

DRM_API DRM_RESULT DRM_CALL DRM_BBX_ECC256_AESCBC_Decrypt(
    __inout_ecount( 1 )          DRM_BB_CONTEXT *f_poBBXContext,
    __in_bcount( f_cbEncryptedKey ) DRM_BYTE       *f_pbEncryptedKey, 
    __in                         DRM_DWORD       f_cbEncryptedKey, 
    __inout_ecount( 1 )          PUBKEY_P256    *f_poECC256PubKey, 
    __inout_bcount( DRM_AES_KEYSIZE_128 ) DRM_BYTE * f_pbIV, 
    __inout_bcount( f_cbData )   DRM_BYTE       *f_pbData,
    __in                         DRM_DWORD       f_cbData );

DRM_API DRM_RESULT DRM_CALL DRM_BBX_ECC256_Decrypt(
    __inout_ecount( 1 )          DRM_BB_CONTEXT *f_poBBXContext,
    __inout_bcount( *f_pcbData ) DRM_BYTE       *f_pbData,
    __inout_ecount( 1 )          DRM_DWORD      *f_pcbData,
    __inout_ecount( 1 )          PUBKEY_P256    *f_poECC256PubKey );

DRM_API DRM_RESULT DRM_CALL DRM_BBX_ECC256_Sign(
    __inout_ecount( 1 )                                DRM_BB_CONTEXT *f_poBBXContext,
    __inout_bcount( f_cbData )                         DRM_BYTE       *f_pbData,
    __in                                               DRM_DWORD       f_cbData,
    __inout_ecount( 1 )                                PUBKEY_P256    *f_poECC256PubKey,
    __out_bcount( ECDSA_P256_SIGNATURE_SIZE_IN_BYTES ) DRM_BYTE        f_rgbECC256Signature[ __CB_DECL( ECDSA_P256_SIGNATURE_SIZE_IN_BYTES ) ] );

EXIT_PK_NAMESPACE;

#endif /* __DRMBLACKBOX_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmbytemanip.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_BYTEMANIP_H__ 
#define __DRM_BYTEMANIP_H__ 

#include "drmcrt.h"

ENTER_PK_NAMESPACE;

DRM_API DRM_VOID DRM_CALL DRM_BYT_ReverseBytes(
    __inout_bcount(cbData) DRM_BYTE  *pbData,
    IN                     DRM_DWORD  cbData );

#if SIXTEEN_BIT_ADDRESSING

/* the distinction between BYTE and NATIVE_BYTE is an artificial one solely for
   testing under x86 and other environments capable of addressing 8-bit quantities.
   Redefining a BYTE to be a WORD allows simulation of 16-bit addressing 
   
   For practical reasons it serves as a reminder that what looks like a BYTE isn't
   necessarily the familiar 8 bits */

typedef DRM_BYTE DRM_NATIVE_BYTE;
typedef DRM_CHAR DRM_NATIVE_CHAR;

DRM_API DRM_VOID DRM_CALL DRM_BYT_CopyBytes( 
    __out_ecount( f_ibTo + f_cb ) DRM_VOID *f_pbTo, 
    IN       DRM_DWORD f_ibTo, 
    __in_ecount( f_ibFrom + f_cb ) const DRM_VOID *f_pbFrom,
    IN       DRM_DWORD f_ibFrom,
    IN       DRM_DWORD f_cb );

DRM_API DRM_VOID DRM_CALL DRM_BYT_MoveBytes( 
    __out_ecount( f_ibTo + f_cb ) DRM_VOID *f_pbTo, 
    IN       DRM_DWORD f_ibTo, 
    __in_ecount( f_ibFrom + f_cb ) const DRM_VOID *f_pbFrom,
    IN       DRM_DWORD f_ibFrom,
    IN       DRM_DWORD f_cb );

DRM_API DRM_VOID DRM_CALL DRM_BYT_SetBytes(
    __out_ecount( f_ib + f_cb ) DRM_VOID *f_pb,
    IN     DRM_DWORD f_ib,
    IN     DRM_DWORD f_cb,
    IN     DRM_BYTE  f_b );

DRM_API DRM_INT DRM_CALL DRM_BYT_CompareBytes(
    __in_ecount( f_ibA + f_cb ) const DRM_VOID *f_pbA,
    IN       DRM_DWORD f_ibA,
    __in_ecount( f_ibB + f_cb ) const DRM_VOID *f_pbB,
    IN       DRM_DWORD f_ibB,
    IN       DRM_DWORD f_cb );



DRM_API DRM_NATIVE_BYTE DRM_CALL DRM_16B_Read8BitByte(
    __in_ecount( f_ib / CB_NATIVE_BYTE ) const DRM_VOID *f_pv,
    IN        DRM_DWORD f_ib);

DRM_API DRM_NATIVE_CHAR DRM_CALL DRM_16B_Read8BitChar(
    __in_ecount( f_ib / CB_NATIVE_BYTE ) DRM_VOID *f_pv,
    IN  DRM_DWORD f_ich);

DRM_API DRM_VOID DRM_CALL DRM_16B_Write8BitByte(
    __out_ecount( f_ib / CB_NATIVE_BYTE ) DRM_VOID *f_pv,
    IN  DRM_DWORD        f_ib,
    IN  DRM_NATIVE_BYTE  f_b);

DRM_API DRM_VOID DRM_CALL DRM_16B_Write8BitChar(
    __out_ecount( f_ib / CB_NATIVE_BYTE ) DRM_VOID *f_pv,
    IN  DRM_DWORD        f_ich,
    IN  DRM_NATIVE_CHAR  f_ch);

DRM_API DRM_VOID DRM_CALL DRM_16B_Read8BitBytes(
    __in_ecount( f_cb / CB_NATIVE_BYTE ) DRM_VOID *f_pv,
    IN  DRM_DWORD        f_cb,
    __out_ecount( f_cb ) DRM_NATIVE_BYTE *f_pb);

DRM_API DRM_VOID DRM_CALL DRM_16B_Write8BitBytes(
    __out_ecount( f_cb / CB_NATIVE_BYTE ) DRM_VOID *f_pv,
    IN  DRM_DWORD        f_cb,
    __in_ecount( f_cb ) DRM_NATIVE_BYTE *f_pb);

DRM_API DRM_VOID DRM_CALL DRM_16B_Read8BitString(
    __in_ecount( f_cch / CB_NATIVE_BYTE ) DRM_VOID *f_pv,
    IN  DRM_DWORD        f_cch,
    __out_ecount( f_cch ) DRM_NATIVE_CHAR *f_pch);

DRM_API DRM_VOID DRM_CALL DRM_16B_Write8BitString(
    __out_ecount( f_cch / CB_NATIVE_BYTE ) DRM_VOID *f_pv,
    IN  DRM_DWORD        f_cch,
    __in_ecount( f_cch ) DRM_NATIVE_CHAR *f_pch);

#define DRM_PACK_BYTES_IN_PLACE 0x00000001

DRM_API DRM_VOID *DRM_CALL DRM_16B_Pack8BitBytes(
    __inout_ecount( f_cbMachine ) DRM_NATIVE_BYTE *f_pbMachine,
    DRM_DWORD        f_cbMachine,
    __out_ecount_opt( f_cbMachine / CB_NATIVE_BYTE ) DRM_VOID *f_pvPacked,
    DRM_DWORD        f_fOptions);

DRM_API DRM_VOID *DRM_CALL DRM_16B_IncrementPackedPointer(
    __inout_ecount( f_cbMachine / / CB_NATIVE_BYTE ) DRM_NATIVE_BYTE *f_pbMachine,
    IN     DRM_DWORD        f_cbMachine,
       OUT DRM_NATIVE_BYTE *f_pbHead);

DRM_API DRM_VOID *DRM_CALL DRM_16B_DecrementPackedPointer(
    __inout_ecount( f_cbMachine / / CB_NATIVE_BYTE ) DRM_NATIVE_BYTE  *f_pbMachine,
    IN     DRM_DWORD         f_cbMachine,
    IN     DRM_NATIVE_BYTE   f_bHead);

#define GET_BYTE(pb,ib)              DRM_16B_Read8BitByte((pb),(ib))
#define PUT_BYTE(pb,ib,b)            DRM_16B_Write8BitByte((pb),(ib),(b))
#define GET_CHAR(pch,ich)            DRM_16B_Read8BitByte((pch),(ich))
#define PUT_CHAR(pch,ich,ch)         DRM_16B_Write8BitByte((pch),(ich),(ch))

#define MAKE_MACHINE_BYTE(b0,b1)   ((DRM_NATIVE_BYTE)(((b0)<<8)|((b1)&0x00FF)))

#define TWO_BYTES(b0,b1)             MAKE_MACHINE_BYTE(b0,b1)
#define ONE_WCHAR(ch0,ch1)           TWO_BYTES(ch0,ch1)

#else /* 8-bit addressing */


#define DRM_BYT_CopyBytes(to,tooffset,from,fromoffset,count) DRMCRT_memcpy(&((to)[(tooffset)]),&((from)[(fromoffset)]),(count))
#define DRM_BYT_MoveBytes(to,tooffset,from,fromoffset,count) DRMCRT_memmove(&((to)[(tooffset)]),&((from)[(fromoffset)]),(count))
#define DRM_BYT_SetBytes(pb,ib,cb,b) DRMCRT_memset(&((pb)[(ib)]),b,cb)
#define DRM_BYT_CompareBytes(pbA,ibA,pbB,ibB,cb) DRMCRT_memcmp(&((pbA)[(ibA)]),&((pbB)[(ibB)]),(cb))

#define GET_BYTE(pb,ib)             (pb)[(ib)]
#define PUT_BYTE(pb,ib,b)           (pb)[(ib)]=(b)
#define GET_CHAR(pch,ich)           (pch)[(ich)]
#define PUT_CHAR(pch,ich,ch)        (pch)[(ich)]=(ch)

#if TARGET_LITTLE_ENDIAN
#define MAKE_MACHINE_WCHAR(ch0,ch1)  ( ((ch1)<<8) | ((ch0) & 0x00FF) )
#else
#define MAKE_MACHINE_WCHAR(ch0,ch1)  ( ((ch0)<<8) | ((ch1) & 0x00FF) )
#endif

#define TWO_BYTES(b0,b1)             b0,b1
#define ONE_WCHAR(ch0,ch1)           MAKE_MACHINE_WCHAR(ch0,ch1)

#endif /* 16/8 bit addressing */

#define MEMSET(pb,ch,cb) DRM_BYT_SetBytes((pb),0,(cb),(ch))
#define ZEROMEM(pb,cb)   DRM_BYT_SetBytes((pb),0,(cb),0)
#define MEMCPY(pbTo,pbFrom,cb)  DRM_BYT_CopyBytes(   (pbTo),0,(pbFrom),0,(cb))
#define MEMMOVE(pbTo,pbFrom,cb) DRM_BYT_MoveBytes(   (pbTo),0,(pbFrom),0,(cb))
#define MEMCMP(pbA,pbB,cb)      DRM_BYT_CompareBytes((pbA) ,0,(pbB),   0,(cb))

EXIT_PK_NAMESPACE;

#endif /* __DRM_BYTEMANIP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmcallbacks.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_CALLBACKS_H__
#define __DRM_CALLBACKS_H__

#include <drmnamespace.h>   /* defining proper namespace (if used) */
#include <drmxmr.h>

ENTER_PK_NAMESPACE;

typedef enum
{
    DRM_STORE_LICENSE_NOTIFY_KID       = 1,  /* Callbacks with this reason will have pvData as a DRM_CONST_STRING */
    DRM_STORE_LICENSE_STORE_V1_LICENSE = 2   /* Callbacks with this reason will have pvData as a DRM_ANSI_CONST_STRING */

#if DRM_SUPPORT_PLAYLIST_BURN
    , DRM_STORE_LICENSE_NOTIFY_PLAYLIST_BURN_UPDATE = 3 /* Callbacks with this reason will have pvData as a DRM_PLAYLIST_NOTIFICATION_STRUCT */
#endif
    , DRM_STORE_LICENSE_NOTIFY_INCLUSION_LIST = 4 /* Callbacks with this reason will have pvData as a DRM_INCLUSION_LIST_CALLBACK_STRUCT, note that dwChain will
                                                          always be 0 as when licenses are stored they are evaluated individually, not in a chain */

} DRM_STORE_LICENSE_CALLBACK_ENUM;

typedef DRM_RESULT (DRM_CALL *pfnLicenseResponseCallback)( 
    IN DRM_VOID                        *pvData, 
    IN DRM_STORE_LICENSE_CALLBACK_ENUM  eReason, 
    IN DRM_VOID                        *pvContext );

#if DRM_SUPPORT_PLAYLIST_BURN
typedef struct 
{
    const DRM_CONST_STRING *pdstrKID;
    DRM_DWORD               cPlaylistBurnIncrement;
} DRM_PLAYLIST_NOTIFICATION_STRUCT;
#endif



typedef enum
{
    DRM_PLAY_OPL_CALLBACK = 0x1,
    DRM_COPY_OPL_CALLBACK = 0x2,
    DRM_INCLUSION_LIST_CALLBACK = 0x3,
    DRM_EXTENDED_RESTRICTION_CONDITION_CALLBACK = 0x4,
    DRM_EXTENDED_RESTRICTION_ACTION_CALLBACK = 0x5,
    DRM_EXTENDED_RESTRICTION_QUERY_CALLBACK = 0x6,
    DRM_SECURE_STATE_TOKEN_RESOLVE_CALLBACK = 0x7
} DRM_POLICY_CALLBACK_TYPE;

typedef DRM_RESULT (DRM_CALL* DRMPFNPOLICYCALLBACK)( 
    IN const DRM_VOID                 *f_pvCallbackData,
    IN       DRM_POLICY_CALLBACK_TYPE  f_dwCallbackType,
    IN const DRM_VOID                 *f_pv );

typedef struct
{
    DRM_CONST_STRING *pdstrAttributeName;

    /* On input contains the token data that now exists on disk, on output the
    ** callback function should update it to the value that should be stored */
    TOKEN            *pOnDisk;

    /* Contains the data that was originally intended to be stored during Bind */
    TOKEN            *pOriginallyIntendedValue;

    /* If TRUE, indicates that during Bind the token didn't exist on disk 
    ** so another instance must have created this attribute as well */
    DRM_BOOL          fNewAttribute;

    /*
    ** Right ID and restriction ID the secure store entry is associated with
    */
    DRM_WORD          wRightID;
    DRM_WORD          wRestrictionID;
    
} DRM_SECURE_STATE_TOKEN_RESOLVE_DATA;

typedef struct
{
    DRM_WORD                             wRightID;
    DRM_XMR_UNKNOWN_OBJECT              *pRestriction;
    DRM_XMR_LICENSE                     *pXMRLicense;
    DRM_SECSTORE_CONTEXT                *pContextSST;
} DRM_EXTENDED_RESTRICTION_CALLBACK_STRUCT;

/*
**  When recieving this struct via a callback you can determine which GUIDs in the list are usabale by checking the 
**  rgfInclusionListValid[dwChainDepth] array to see which ones are TRUE.  Those that are true means that
**  rgInclusionList[x] is usable where rgfInclusionListValid[x][dwChainDepth] is TRUE.
*/

typedef struct __tagDRM_INCLUSION_LIST_CALLBACK_STRUCT
{
    DRM_GUID  rgInclusionList       [DRM_MAX_INCLUSION_GUIDS];
    DRM_BOOL  rgfInclusionListValid [DRM_MAX_INCLUSION_GUIDS][DRM_MAX_LICENSE_CHAIN_DEPTH];
    DRM_DWORD dwChainDepth;
} DRM_INCLUSION_LIST_CALLBACK_STRUCT;

EXIT_PK_NAMESPACE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmcbc.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMCBCMAC_H__
#define __DRMCBCMAC_H__

ENTER_PK_NAMESPACE;

typedef struct _CBCKey 
{
    DRM_UINT a1, b1, c1, d1, e1, f1, a2, b2, c2, d2, e2, f2;
} DRM_CBCKey;

/*********************************************************************
**
**  Function:  DRM_CBC_Mac
**
**  Synopsis:  Create a 64-bit MAC
**
**  Arguments:  
**     [pbData] -- Byte pointer to DWORD blocks that are to be MAC'd
**     [cBlocks] -- Length of pbData in DWORD's
**     [rgdwKey2] -- 2 DWORD array to hold the 64-bit result
**     [pCBCkey] -- Key structure filled by the caller.
**
**  Returns:  None
** Notes: dwNumBlocks must be in DWORDS and it should be multiple of 
**        DWORD. Suppose if length is 8 bytes, dwNumBlocks should be 2
*********************************************************************/
DRM_API DRM_VOID DRM_CALL DRM_CBC_Mac(
    IN        DRM_BYTE  *pbData,
    IN        DRM_DWORD  cBlocks,
    OUT       DRM_DWORD  rgdwKeys[2],
    IN  const DRM_CBCKey *pCBCkey );

/*********************************************************************
**
**  Function:  DRM_CBC_InverseMac
**
**  Synopsis:  Inverse MAC function.  It decrypts the last two bloacks of pdwData
**              ( replaces 64-bit ciphertext pdwData[dwNumBlocks-1] and pdwData[dwNumBlocks-2]
**              with plaintext ).
**
**  Arguments:  
**     [pbData] -- Byte pointer to DWORD blocks that are to be MAC'd( inverse MAC )
**     [cBlocks] -- Length of pbData in DWORD's
**     [key] -- Key structure filled by caller
**     [ikey] -- Inverse key structure filled by caller.
**
**  Returns:  
**
** Notes: dwNumBlocks must be in DWORDS and it should be multiple of 
**        DWORD. Suppose if length is 8 bytes, dwNumBlocks should be 2
**
*********************************************************************/
DRM_API DRM_VOID DRM_CALL DRM_CBC_InverseMac(
    IN OUT   DRM_BYTE  *pbData,
    IN       DRM_DWORD  cBlocks,
    IN const DRM_CBCKey *key,
    IN const DRM_CBCKey *ikey );

/*********************************************************************
**
**  Function:  DRM_MAC_inv32
**
**  Synopsis:  Returns the inverse of n ( inverse in terms of what the CBC Mac inverse code wants ).
**
**  Arguments:  
**     [n] -- Value of n to compute inverse of.
**
**  Returns:  Inverse of n
**
*********************************************************************/
DRM_API DRM_UINT DRM_CALL DRM_MAC_inv32( DRM_UINT n );

typedef struct __tagCBCState
{
    DRM_UINT sum,t;
    DRM_BYTE buf[__CB_DECL(8)];
    DRM_DWORD dwBufLen;
} DRM_CBCState;

DRM_API DRM_VOID DRM_CALL DRM_CBC64Init(
    DRM_CBCKey *cbckey,
    DRM_CBCState *cbcstate,
    __in_bcount( SIZEOF( DRM_UINT ) * 12 ) DRM_BYTE *pKey );

#define DRMV2_MAC_LENGTH 8

DRM_API DRM_VOID DRM_CALL DRM_CBC64Update(
    DRM_CBCKey *key,
    DRM_CBCState *cbcstate,
    DRM_DWORD dwLen,
    __in_bcount( dwLen ) DRM_BYTE *pData );
    
DRM_API DRM_UINT DRM_CALL DRM_CBC64Finalize( DRM_CBCKey *key, DRM_CBCState *cbcstate, DRM_UINT *pKey2 );
DRM_API DRM_UINT DRM_CALL DRM_CBC64Invert( 
    DRM_CBCKey  *key, 
    DRM_CBCKey  *ikey, 
    DRM_UINT     MacA1, 
    DRM_UINT     MacA2,
    DRM_UINT     MacB1, 
    DRM_UINT     MacB2, 
    DRM_UINT    *pInvKey2 );

DRM_API DRM_VOID DRM_CALL DRM_CBC64InitState( DRM_CBCState *cbcstate );

EXIT_PK_NAMESPACE;

#endif /* __DRMCBCKEY_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmcfdalloc.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/******************************************************************************
**    File drmcfdalloc.h - Interface for memory allocation 
**    Two implementation are provided:
**    1. Legacy implementation that allocates memory from global stack
**    2. Dynamic memory allocation (using Oem_MemAlloc)
**
**    Use macro DRM_MSDB_USE_DYNAMIC_MEM_ALLOCATION (values are 0 or 1) 
**    to specify required implementation
**    
**    Notes about stack memory allocation:
**    1. Before using any allocation functions user should call DRM_CFD_InitStackMemory
**    2. Allocation with DRM_CFD_Alloc and freeing with DRM_CFD_free should be symmetrical.
**       It means if memory buffers are allocated in order 1,2,3, they should be freed 
**       in opposite order 3,2,1.
******************************************************************************/

#ifndef __DRMCFDALLOC_H__
#define __DRMCFDALLOC_H__

#include <drmnamespace.h>   /* defining proper namespace (if used) */

ENTER_PK_NAMESPACE;

/*********************************************************************
**
**  Function:  DRM_CFD_InitStackMemory
**
**  Synopsis:  Stack-based memory allocation: provides OEM buffer 
**             Dynamic memory allocation: does nothing
**
**  Arguments:  
**     [f_pbBuffer] -- Pointer to an OEM allocated buffer..
**     [f_cbBufferSize] -- Size of the buffer.
** 
** 
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_CFD_InitStackMemory
(
    __in_bcount_opt(f_cbBufferSize) DRM_VOID *f_pbBuffer, 
    __in                            DRM_DWORD f_cbBufferSize
);

/*********************************************************************
**
**  Function:  DRM_CFD_FreeStackMemory
**
**  Synopsis:  Stack-based memory allocation: Free an OEM stack buffer 
**             Dynamic memory allocation: does nothing 
** 
**  Arguments:  
**     [f_ppbBuffer] -- Pointer to pointer to hold original memory block  
**                   used in DRM_CFD_InitStackMemory.
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_CFD_FreeStackMemory( __out_opt DRM_VOID **f_ppbBuffer );

/*********************************************************************
**
**  Function:  DRM_CFD_GetAllocatedMemory
**
**  Synopsis:  Stack-based memory allocation: 
**                 returns amount of memory currenly allocated by DRM_CFD_Alloc
**             Dynamic memory allocation: returns 0 (zero) 
** 
**  Arguments:  
**     [f_pdwAllocatedMem] -- Pointer to DWORD variable filled with amount of 
**                            allocated memory.
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_CFD_GetAllocatedMemory( __out DRM_DWORD *f_pdwAllocatedMem );

/*********************************************************************
**
**  Function:  DRM_CFD_Alloc
**
**  Synopsis:  Stack-based memory allocation: allocates a buffer from a static stack context
**             Dynamic memory allocation: allocates a buffer of specified size
**
**  Arguments:  
**     [f_cbSize] -- Size of the buffer needed
**      
**  Return value.
**     Returns pointer to buffer is successful, NULL otherwise.
**     The only indication of error - returned NULL pointer.
**     Signature of this function is the same as malloc or Oem_MemAlloc.
**
**  Notes:  If stack allocation is used then pointers must be freed in LIFO order.
**
*********************************************************************/
DRM_API DRM_VOID* DRM_CALL DRM_CFD_Alloc( __in DRM_DWORD f_cbSize );

/*********************************************************************
**
**  Function:  DRM_CFD_free
**
**  Synopsis:  Stack-based memory allocation: 
**                 free a buffer that was allocated using DRM_CFD_Alloc.
**             Dynamic memory allocation: free a memory buffer
**
**  Arguments:  
**     [f_pbBuffer] -- Pointer returned from a call to DRM_CFD_Alloc
**
**  Notes:  If stack allocation is used then pointers must be freed in LIFO order.
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_CFD_Free( __in DRM_VOID *f_pbBuffer );


EXIT_PK_NAMESPACE;

#endif /* __DRMCFDALLOC_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmcertparser.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMCERTPARSER_H__
#define __DRMCERTPARSER_H__


#include "drmbase64.h"
#include "drmrevocation.h"
#include "drmcert.h"

ENTER_PK_NAMESPACE;

#if DRM_SUPPORT_REVOCATION

enum DRM_CERTIFICATE_TYPE
{
    certtypeUnknown = -1,
    certtypeRoot    =  0,
    certtypeCertAuthority,
    certtypeBlackBox,
    certtypeBlackBoxVersion,
    certtypeMachine,
    certtypeIndivBox,
    certtypeExport,
    certtypeExportIncl,
    certtypeDevice,
    certtypeSampleProtection
};

DRM_API DRM_RESULT DRM_CALL DRM_WCP_GetCertificateType(
  IN  const DRM_CHAR             *f_pszBase,
  IN  const DRM_SUBSTRING        *f_pdasstrCert,
  OUT enum DRM_CERTIFICATE_TYPE *f_pcerttype);

DRM_API DRM_RESULT DRM_CALL DRM_WCP_GetAttribute(
  IN const DRM_CHAR                *f_pszBase,
  IN const DRM_SUBSTRING           *f_pdasstrCert,
  IN       DRM_WMDRM_CERT_ATTRIBUTE f_attribute,
     OUT   DRM_SUBSTRING            f_rgdasstrValue [],
  IN OUT   DRM_DWORD               *f_pcEntries);

DRM_API DRM_RESULT DRM_CALL DRM_WCP_GetKeyUsage(
  IN const DRM_CHAR                *f_pszBase,
  IN const DRM_SUBSTRING           *f_pdasstrCert,
     OUT DRM_DWORD                 *f_dwKeyUsage);

DRM_API DRM_RESULT DRM_CALL DRM_WCP_GetFeatures(
  IN const DRM_CHAR                *f_pszBase,
  IN const DRM_SUBSTRING           *f_pdasstrCert,
     OUT DRM_DWORD                 *f_dwFeatures);

DRM_API DRM_RESULT DRM_CALL DRM_WCP_GetSecurityLevel(
  IN const DRM_CHAR                *f_pszBase,
  IN const DRM_SUBSTRING           *f_pdasstrCert,
     OUT DRM_DWORD                 *f_dwSecurityLevel);

DRM_API DRM_RESULT DRM_CALL DRM_WCP_GetPublicKey(
  IN const DRM_CHAR                *f_pszBase,
  IN const DRM_SUBSTRING           *f_pdasstrCert,
     OUT DRM_BYTE                  *f_pbModulus,
     OUT DRM_DWORD                 *f_pcbModulus );

DRM_API DRM_RESULT DRM_CALL DRM_WCP_GetHardwareID(
  IN const DRM_CHAR                *f_pszBase,
  IN const DRM_SUBSTRING           *f_pdasstrCert,
     OUT   DRM_BYTE                 f_rgbHardwareID [DRM_SHA1_DIGEST_LEN]);

DRM_API DRM_RESULT DRM_CALL DRM_WCP_GetSignatureDigest(
  IN const DRM_CHAR                *f_pszBase,
  IN const DRM_SUBSTRING           *f_pdasstrCert,
     OUT   DRM_BYTE                 f_rgbDigest [DRM_SHA1_DIGEST_LEN]);

DRM_API DRM_RESULT DRM_CALL DRM_WCP_GetPKCert(
  IN const DRM_CHAR      *f_pszBase,
  IN const DRM_SUBSTRING *f_pdasstrCert,
     OUT   PKCERT        *f_ppkcert);

DRM_API DRM_RESULT DRM_CALL DRM_WCP_GetManufacturerNodes(
  IN const DRM_CHAR      *f_pszBase,
  IN const DRM_SUBSTRING *f_pdasstrCert,
     OUT   DRM_SUBSTRING *f_pdastrNamespace,
     OUT   DRM_SUBSTRING  f_rgdastrTag       [],
     OUT   DRM_SUBSTRING  f_rgdastrAttrLabel [],
     OUT   DRM_SUBSTRING  f_rgdastrAttrValue [],
     OUT   DRM_SUBSTRING  f_rgdastrValue     [],
  IN OUT   DRM_DWORD     *f_pcEntries);

#define DRM_WCP_VERIFY_CERT_SIGNATURE     0x00000001
#define DRM_WCP_VERIFY_CERT_REQUIRED_TAGS 0x00000002
#define DRM_WCP_VERIFY_CERT_METHODS       0x00000004
#define DRM_WCP_VERIFY_CERT_ALL      (DRM_WCP_VERIFY_CERT_SIGNATURE|DRM_WCP_VERIFY_CERT_REQUIRED_TAGS|DRM_WCP_VERIFY_CERT_METHODS)

DRM_API DRM_RESULT DRM_CALL DRM_WCP_VerifyCertificate(
    IN const DRM_CHAR            *f_pszBase,
    IN const DRM_SUBSTRING       *f_pdasstrCert,
    IN       DRM_DWORD            f_fVerify,
    IN const WMDRMNET_CRL_ENTRY  *f_pRevocationEntries,
    IN       DRM_DWORD            f_cRevocationEntries,
       OUT   DRM_SUBSTRING       *f_pdasstrPublicRSA,
    IN       DRM_CRYPTO_CONTEXT   *f_pCryptoCtx);

DRM_API DRM_RESULT DRM_CALL DRM_WCP_VerifyCertificateCollection(
    IN const DRM_CHAR              *f_pszBase,
    IN const DRM_SUBSTRING         *f_pdasstrCert,
    IN const DRM_ANSI_CONST_STRING *f_pdastrRootPubKey,
    IN const WMDRMNET_CRL_ENTRY    *f_pRevocationEntries,
    IN       DRM_DWORD              f_cRevocationEntries,
       OUT   DRM_SUBSTRING         *f_pdasstrLeafCertificate,
       OUT   DRM_SUBSTRING         *f_pdasstrPubkeyLeafmost,
    IN       DRM_CRYPTO_CONTEXT   *f_pCryptoCtx);

DRM_API DRM_RESULT DRM_CALL DRM_WCP_ReadPubKeyModulus(
    IN                        DRM_CHAR      *f_rgchB64,
    IN                        DRM_SUBSTRING *f_pdasstrB64,
    OUT                       DRM_BYTE      *f_pbMod,
    OUT                       DRM_DWORD     *f_pcbMod);

DRM_API DRM_RESULT DRM_CALL DRM_WCP_VerifyDigitalSignature(
    IN   const DRM_CHAR             *f_pszBase,
    IN   const DRM_SUBSTRING        *f_pdasstrDataInclusive,
    IN   const DRM_SUBSTRING        *f_pdasstrSignatureInclusive,
    IN   const DRM_BOOL              f_fWMDRMNET,
    IN   const WMDRMNET_CRL_ENTRY   *f_pRevocationEntries,
    IN         DRM_DWORD             f_cRevocationEntries,
    IN         DRM_CRYPTO_CONTEXT   *f_pCryptoCtx);
#endif

EXIT_PK_NAMESPACE;

#endif /* __DRMCERTPARSER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmcert.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef _DRM_CERT_H_
#define _DRM_CERT_H_

ENTER_PK_NAMESPACE;

#define DRM_CERTIFICATE_COLLECTION_MIN 1
#define DRM_CERTIFICATE_COLLECTION_MAX 6

#define DRM_DSIG_TYPE_STANDARD FALSE
#define DRM_DSIG_TYPE_WMDRMNET TRUE

typedef enum 
{
    DRM_WMDRM_CERT_ATTR_SECURITY_LEVEL,
    DRM_WMDRM_CERT_ATTR_KEY_USAGE,
    DRM_WMDRM_CERT_ATTR_FEATURES,
    DRM_WMDRM_CERT_ATTR_DIGEST_VALUE,

    /* parser only */

    DRM_WMDRM_CERT_ATTR_SECURITY_VERSION,
    DRM_WMDRM_CERT_ATTR_PUBLIC_KEY_SELF_RSA,
    DRM_WMDRM_CERT_ATTR_PUBLIC_KEY_SIGNER_RSA
} DRM_WMDRM_CERT_ATTRIBUTE;

typedef enum
{
    DRM_WMDRM_CERT_KEYUSAGE_SIGNCRL     = 0x01,
    DRM_WMDRM_CERT_KEYUSAGE_SIGNCERT    = 0x02,
    DRM_WMDRM_CERT_KEYUSAGE_ENCRYPTKEY  = 0x04
} DRM_WMDRM_CERT_KEYUSAGE;

typedef enum
{
    DRM_WMDRM_CERT_FEATURES_TRUSTEDTRANSMITTER     = 0x01,
    DRM_WMDRM_CERT_FEATURES_TRUSTEDRECEIVER        = 0x02,
    DRM_WMDRM_CERT_FEATURES_SAMPLEPROTECTION       = 0x04,
} DRM_WMDRM_CERT_FEATURES;

EXIT_PK_NAMESPACE;

#endif /* _DRM_CERT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmcfdtypes.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMCFDTYPES_H__
#define __DRMCFDTYPES_H__

#include <drmtypes.h>

ENTER_PK_NAMESPACE;

typedef struct __tagDRM_SYMDATA
{
    DRM_SLK    SLK;
    DRM_BYTE   rgbEncryptedSLK[ __CB_DECL( DRM_ECC160_CIPHERTEXT_LEN ) ];
    DRM_ID     idSLK;
} DRM_SYMDATA;



typedef enum
{
    DRM_SIMPLE_LICENSE = 1,
    DRM_ROOT_LICENSE,
    DRM_LEAF_LICENSE
} DRM_LICENSE_TYPE;


EXIT_PK_NAMESPACE;

#endif /* __DRMCFDTYPES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmcfdlicenseutils.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmnamespace.h>   /* defining proper namespace (if used) */

ENTER_PK_NAMESPACE;

/*
**  File drmcfdlicenseutils.h - helper functions to build license response and
**  CRL update license response.
**  Functions are developed and used for MSDB project
*/

DRM_API DRM_RESULT DRM_CALL DRM_LBD_AddXMLNodeFromDWORD
(
    __inout       _XMBContext      *f_pXMLContext,
    __in    const DRM_CONST_STRING *f_dstrName,
    __in    const DRM_DWORD         f_dwVal
);

DRM_API DRM_RESULT DRM_CALL DRM_LBD_AddXMLEncodeDataBase64W
(
    __inout                       _XMBContext      *f_pXMLContext,
    __in                    const DRM_CONST_STRING *f_pdstrName,
    __in_opt                const DRM_CONST_STRING *f_pdstrType,
    __in_bcount(f_cbBufLen) const DRM_BYTE         *f_pbBufValue,
    __in                    const DRM_DWORD         f_cbBufLen
);


DRM_API DRM_RESULT DRM_CALL DRM_LBD_AppendSemiColonIfNotPresent(
    __inout       DRM_STRING *f_pdstrExpression,
    __in    const DRM_DWORD   f_cchMaxStringLen
);

DRM_API DRM_RESULT DRM_CALL DRM_LBD_CalculateCheckSum
(
    __in_ecount(f_cbData)         const DRM_BYTE *f_pbData,
    __in                          const DRM_DWORD f_cbData,
    __out_ecount(CHECKSUM_LENGTH)       DRM_BYTE  f_pbCheckSum[CHECKSUM_LENGTH]
);

DRM_API DRM_RESULT DRM_CALL DRM_LBD_GenerateDateTime
(
    __in  const DRMSYSTEMTIME *f_pDateTime,
    __out       DRM_STRING    *f_pdstrDateTime,
    __in  const DRM_DWORD      f_cchBuffer
);

DRM_DWORD DRM_API DRM_LBD_GetKeySize
(
    __in const DRM_ENCRYPT_KEY_TYPE f_eKeyType
);

DRM_API DRM_RESULT DRM_LBD_GenerateXMRLicenseResponse
(
    __in                             const DRM_ENCRYPT_KEY_CONTEXT   *f_pKeyContext,
    __in_opt                         const DRM_ENCRYPT_KEY_CONTEXT   *f_pBindKeyContext,
    __in_opt                         const DRM_DEVICE_CERT_CONTEXT   *f_pCertContext,
    __in                             const DRM_LICENSE_POLICY        *f_pLicensePolicy,
    __out_ecount(*f_pcchLicenseResp)       DRM_CHAR                  *f_pszLicenseResp,
    __inout                                DRM_DWORD                 *f_pcchLicenseResp
);

DRM_API DRM_RESULT DRM_CALL DRM_LBD_InitBinaryDeviceCertificateContext
(
    __inout                               DRM_APP_CONTEXT         *f_poAppContext,
    __in_bcount(f_cbDeviceCert)     const DRM_BYTE                *f_pbDeviceCert,
    __in                            const DRM_DWORD                f_cbDeviceCert,
    __in_bcount_opt(f_cbDomainCert) const DRM_BYTE                *f_pbDomainCert,
    __in                            const DRM_DWORD                f_cbDomainCert,
    __out                                 DRM_DEVICE_CERT_CONTEXT *f_pCertContext,
    __out                                 DRM_DWORD               *f_pdwFlags
);

/* Maximum length of printed dword */
#define DRM_MAX_DWORD_PRINTED_LEN 12

/* Maximum length of the string with date */
#define MAX_DATE_BUFFER_LEN   32

EXIT_PK_NAMESPACE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmchain.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_CHAIN_H__
#define __DRM_CHAIN_H__

ENTER_PK_NAMESPACE;

#include <drmcallbacks.h>

#define DRM_MAX_COPY_OPL_DATA_SIZE (1024*4)
#define DRM_MAX_PLAY_OPL_DATA_SIZE (128)

typedef DRM_RESULT (DRM_CALL *pfnCheckDeviceRevocation)(DRM_LICEVAL_CONTEXT* pLicEvalContext, DRM_VOID *pv );

#define DRM_POLICY_FLAG_ONLINE_DISABLED              0x00000001
#define DRM_POLICY_FLAG_METERING_DISABLED_ENTERPRISE 0x00000002

#if DRM_SUPPORT_COPY_OPL
typedef struct __tagCOPY_OPL_CHAIN
{
    DRM_BYTE     rgbCopyOPLBuffer[__CB_DECL(DRM_MAX_COPY_OPL_DATA_SIZE)];
    DRM_COPY_OPL oplCopy;
} COPY_OPL_CHAIN;
#endif

typedef struct __tagPLAY_OPL_CHAIN
{
    DRM_BYTE         rgbPlayOPLBuffer[__CB_DECL(DRM_MAX_PLAY_OPL_DATA_SIZE)];
    DRM_PLAY_OPL_EX2 oplPlay;
} PLAY_OPL_CHAIN;


typedef struct _FFLICENSE
{
    IN     DRM_LICSTORE_CONTEXT              *rgpLicStoreCurrent[DRM_MAX_LICENSE_CHAIN_DEPTH]; /* Context to an Open license store for each license in the chain */
    IN     DRM_LICSTORE_CONTEXT              *rgpLicStores[DRM_LICSTORE_MAX_STORES]; /* Array of contexts to Open license stores (for enumeration) */
    IN     DRM_DWORD                          cLicStores; /* Count of elements in pLicStores */
           DRM_LICSTOREENUM_MULTIPLE_CONTEXT *pLicStoreEnum; /* Enumerators for all depths, [0] should be initialized */
    IN OUT DRM_SECSTORE_CONTEXT              *pSecStoreLicense;
    IN     DRM_LICEVAL_CONTEXT               *pLicEval;
    IN     DRM_V1Header                      *pV1Header;
       OUT DRM_BINDING_INFO                  *pBindingInfo;     /* This should point to an array of DRM_MAX_LICENSE_CHAIN_DEPTH binding infos. */
       OUT DRM_XMR_LICENSE                   *pLicenseXMR;
    IN     DRM_BOOL                          *fSkipAESContent;
    IN     DRM_STACK_ALLOCATOR_CONTEXT       *pstack;
    IN     DRM_BYTE                          *pbBuffer;     /* Working buffer */
    IN     DRM_DWORD                          cbBuffer;
    IN     DRM_DWORD                          dwChainDepth; /* The current depth of the chain.  If we are looking for the first license this is 0 */
    IN     DRM_DWORD                          dwPolicyFlags; /* bitmask of policy flags */
    IN     DRM_BYTE                           rgbRevocationPassword [__CB_DECL(DRM_SHA1_DIGEST_LEN)];
           DRM_BYTE                           rgbLicensePassword    [__CB_DECL(DRM_SHA1_DIGEST_LEN)];    
       OUT DRM_BOOL                           fSecStoreOpen         [DRM_MAX_LICENSE_CHAIN_DEPTH]; /* On function exit the caller should close the stores if they are open */
       OUT DRM_BOOL                           rgfDeleteLicense      [DRM_MAX_LICENSE_CHAIN_DEPTH];
       OUT DRM_KID                            rgkid                 [DRM_MAX_LICENSE_CHAIN_DEPTH];
       OUT DRM_LID                            rglid                 [DRM_MAX_LICENSE_CHAIN_DEPTH];
       OUT DRM_DST_SLOT_HINT                  rgslotHint            [DRM_MAX_LICENSE_CHAIN_DEPTH];
#if DRM_SUPPORT_METERING
       OUT DRM_MID                            rgmid                 [DRM_MAX_LICENSE_CHAIN_DEPTH];
       OUT DRM_BOOL                           rgfHasMetering        [DRM_MAX_LICENSE_CHAIN_DEPTH]; /* On function exit the caller should close the stores if they are open */
#endif

#if DRM_SUPPORT_COPY_OPL
       OUT COPY_OPL_CHAIN                     rgCopyOpl             [DRM_MAX_LICENSE_CHAIN_DEPTH];
       OUT DRM_BOOL                           rgfCopyOplValid       [DRM_MAX_LICENSE_CHAIN_DEPTH];
#endif
       OUT PLAY_OPL_CHAIN                     rgPlayOpl             [DRM_MAX_LICENSE_CHAIN_DEPTH];
       OUT DRM_BOOL                           rgfPlayOplValid       [DRM_MAX_LICENSE_CHAIN_DEPTH];
       OUT DRM_INCLUSION_LIST_CALLBACK_STRUCT inclusionListCallback;

#if DRM_SUPPORT_WMDRMNET       
       OUT DRM_DWORD                          dwMinimumRequiredAppSec;
#endif
    IN      DRM_BOOL                          fCanBind;
        OUT DRM_DWORD                         dwSourceid;
#if DRM_SUPPORT_REVOCATION
        OUT DRM_DWORD                         dwLicRevInfoVer;
#endif

    /*
    ** We use this boolean to cache whether the root license MUST
    **  be domain bound due to a leaf license requiring it.
    ** See comments regarding the equivalent flag in drmliceval.h
    **  for more information.
    */
        OUT DRM_BOOL                          fDomainBoundRootRequired;
} DRM_FFLICENSE;

/* This function is recursive!!! 
   INPUTS -- stuff in DRM_FFLICENSE struct
   OUTPUT -- array of binding info structures to pass to CreateDecryptor
             Array of open secure store contexts 
             Array of KID/LID pairs that were used in the chain
  Caller should call CreateDecryptor when ready 
  Will have to read the license in again. 
  Caller should then read each license in and do the DoneWithOperation for each license
  Caller should then update metering data for each license */

DRM_API DRM_RESULT DRM_CALL DRM_LIC_CompleteLicenseChain(
    IN OUT   DRM_FFLICENSE               *f_pFFLicense,
    IN const DRM_CONST_STRING            *f_rgpdstrRights[], /* Array of DRM_CONST_STRING pointers */
    IN       DRM_DWORD                    f_cRights,
       OUT   DRM_DWORD                   *f_pdwChainDepth,
    IN       DRM_DST                     *f_pDatastore,
    IN       DRMPFNPOLICYCALLBACK         f_pfnPolicyCallback,
    IN const DRM_VOID                    *f_pv );

DRM_API DRM_RESULT DRM_CALL DRM_LIC_ReportActions(
    IN OUT   DRM_FFLICENSE                *f_pFFLicense,
    IN const DRM_CONST_STRING             *f_rgpdstrRights[], /* Array of DRM_CONST_STRING pointers */
    IN       DRM_DWORD                     f_cRights,
    IN       DRM_DWORD                     f_dwChainDepth,
    IN       DRM_DST                      *f_pDatastore,
    IN       DRMPFNPOLICYCALLBACK          f_pfnPolicyCallback,
    IN const DRM_VOID                     *f_pv );

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK

DRM_API DRM_RESULT DRM_CALL DRM_LIC_CheckClockRollback(  
    IN DRM_LICEVAL_CONTEXT         *f_pLicEval,
    IN DRM_LICSTORE_CONTEXT        *f_pLicStoreXML,
    IN DRM_LICSTORE_CONTEXT        *f_pLicStoreXMR,
    IN DRM_LICSTOREENUM_CONTEXT    *f_pLicEnum,
    IN DRM_BYTE                    *f_pbBuffer,
    IN DRM_DWORD                    f_cbBuffer,
    IN DRM_DST                     *f_pDatastore,
    IN DRM_STACK_ALLOCATOR_CONTEXT *f_poStack );

#endif /* DRM_SUPPORT_ANTIROLLBACK_CLOCK  */

EXIT_PK_NAMESPACE;

#endif  /* __DRM_CHAIN_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmcipher.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMCIPHER_H__
#define __DRMCIPHER_H__


#include <drmcommon.h>
#include <drmsha1.h>
#include <drmdes.h>
#include <drmrc4.h>
#include <drmcbc.h>
#include <drmaes.h>
#include <oemaes.h>
#include <drmcrt.h>

ENTER_PK_NAMESPACE;

#ifndef DRMCIPHERKEYLEN_RC4 
#define DRMCIPHERKEYLEN_RC4        7
#endif

/*
** Legacy PDRM content acquired through ILA will
** contain a 6-byte Cocktail content key. This is
** only valid for XMR licenses.
*/
#ifndef DRMCIPHERKEYLEN_RC4_PDRM
#define DRMCIPHERKEYLEN_RC4_PDRM   6
#endif

#ifndef DRMCIPHERKEYLEN_MAX
#define DRMCIPHERKEYLEN_MAX max( DRM_AES_MAXKEYSIZE, DRMCIPHERKEYLEN_RC4 )
#endif

typedef enum _DRM_SUPPORTED_CIPHERS
{
    eDRM_CIPHER_INVALID     = 0,
    eDRM_RC4_CIPHER         = 1,
    eDRM_AES_COUNTER_CIPHER = 2,
    eDRM_DES_CIPHER         = 3   /* Used only for chaining in legacy XML licenses */
} DRM_SUPPORTED_CIPHERS;

typedef struct __tagDRM_RC4_CIPHER_CONTEXT
{
    DRM_BYTE      shaOut [__CB_DECL( DRM_SHA1_DIGEST_LEN )];
    DRM_UINT      desS1  [2];
    DRM_UINT      desS2  [2];
    DESTable      destable;
    DRM_CBCKey    mackey;
    DRM_CBCKey    invmackey;    
    RC4_KEYSTRUCT rc4ks;    
    DRM_CBCState  cbcstate;                   
    DRM_DWORD     rc4key[2]; 
    DRM_UINT      rguiLast8[2];
    DRM_DWORD     cbPacket;            
    DRM_DWORD     iPacket;
    DRM_BOOL      fDecryptInited;
} DRM_RC4_CIPHER_CONTEXT;

typedef struct __tagDRM_AES_CIPHER_CONTEXT
{
    DRM_AES_KEY   aesKey;
} DRM_AES_CIPHER_CONTEXT;

typedef struct __tagDRM_CIPHER_CONTEXT
{
    DRM_SUPPORTED_CIPHERS eCipherType; 
    DRM_BOOL              fInited;
    DRM_DWORD             cbContentKey;
    DRM_BYTE              rgbContentKey[__CB_DECL( DRMCIPHERKEYLEN_MAX )];
    union _tagcipher
    {
        DRM_RC4_CIPHER_CONTEXT cipherRC4;
        DRM_AES_CIPHER_CONTEXT cipherAES;
    } cipher;
} DRM_CIPHER_CONTEXT;

#define DRM_CPHR_CB_FOR_INITDECRYPT 15


DRM_API DRM_RESULT DRM_CALL DRM_CPHR_Init(
    __out_ecount( 1 )                              DRM_CIPHER_CONTEXT           *f_pContext,
    __in                                           DRM_SUPPORTED_CIPHERS         f_eCipherType,
    __in                                           DRM_DWORD                     f_cbContKey,
    __in_bcount( f_cbContKey )               const DRM_BYTE                     *f_pbContKey );


DRM_API DRM_RESULT DRM_CALL DRM_CPHR_InitDecrypt(
    __inout_ecount( 1 )                                DRM_CIPHER_CONTEXT *f_pContext,
    __in_bcount_opt( min(DRM_CPHR_CB_FOR_INITDECRYPT,f_cbData) ) DRM_BYTE *f_pbLast15,
    __in                                                        DRM_DWORD  f_cbData );


DRM_API DRM_RESULT DRM_CALL DRM_CPHR_Decrypt(
    __inout_ecount( 1 )                            DRM_CIPHER_CONTEXT           *f_pContext,
    __inout_opt                                    DRM_AES_COUNTER_MODE_CONTEXT *f_pCtrContext,
    __in                                           DRM_DWORD                     f_cbData, 
    __inout_bcount( f_cbData )                     DRM_BYTE                     *f_pbData );


DRM_API DRM_RESULT DRM_CALL DRM_CPHR_Encrypt(
    __inout_ecount( 1 )                            DRM_CIPHER_CONTEXT           *f_pContext,
    __inout_opt                                    DRM_AES_COUNTER_MODE_CONTEXT *f_pCtrContext,
    __in                                           DRM_DWORD                     f_cbData, 
    __inout_bcount( f_cbData )                     DRM_BYTE                     *f_pbData );

EXIT_PK_NAMESPACE;

#endif /* __DRMCIPHER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmcmdlnpars.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __CMDLNPARS_H__
#define __CMDLNPARS_H__

#define DRM_CMD_MAX_ARGUMENTS 15

#ifdef __cplusplus
extern "C" {
#endif

DRM_INT DRM_CALL DRM_Main( 
    IN                  DRM_INT argc, 
    __in_ecount( argc ) DRM_WCHAR** argv );

#ifdef __cplusplus
}
#endif

ENTER_PK_NAMESPACE;

DRM_INT DRM_CALL DRM_CMD_ConvertToArgvArgc( 
    IN OUT __nullterminated  const         DRM_WCHAR *lpCmdLine, 
    __out_ecount( DRM_CMD_MAX_ARGUMENTS )  DRM_WCHAR *argv[DRM_CMD_MAX_ARGUMENTS]);

DRM_BOOL DRM_CALL DRM_CMD_ParseCmdLine(
    IN  const        DRM_WCHAR        *pwszArgument,
    __out_ecount(1)  DRM_WCHAR        *pwchOptionChar,
    OUT              DRM_CONST_STRING *pdstrParam,
    OUT              DRM_CONST_STRING *pdstrExtra);

DRM_BOOL DRM_CALL DRM_CMD_ParseCmdLineMultiChar(
    IN  const DRM_WCHAR        *pwszArgument,
    OUT       DRM_CONST_STRING *pstrOptionStr,
    OUT       DRM_CONST_STRING *pdstrParam,
    OUT       DRM_CONST_STRING *pdstrExtra);

EXIT_PK_NAMESPACE;

#endif /* __CMDLNPARS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmcommon.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMCOMMON_H__
#define __DRMCOMMON_H__

#include "drmfeatures.h"


#define DRM_MAX_ACTIONS 10

#define VERSION_LEN          4
#define DRM_MAX_PATH         256

/*Temporary holding place for these constants */
#ifndef TRUE
    #define TRUE 1
#endif

#ifndef FALSE
    #define FALSE 0
#endif

#ifndef NULL
    #define NULL 0
#endif

#ifndef NO_OF
    #define NO_OF( x )  ( SIZEOF( (x) ) / SIZEOF( (x)[0] ) )
#endif

#ifndef ISODD
    #define ISODD(x) ((x)&1)
#endif

#define DRM_SAFE_INT (int)0x0fffffff
#define DRM_SAFE_UINT (unsigned int)0x0fffffff
#define DRM_UINT_MAX (unsigned int)0xffffffff
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
#define ROTATE_RIGHT(x, n) (((x) >> (n)) | ((x) << (32-(n))))
#define WORDSWAP(d) ( ( (d) >> 16 ) + ( (d) << 16 ) )

/* for good parameter documentation */
#define IN
#define OUT

#include "drmpragmas.h"     /* Handling of compilation warnings */
#include "drmnamespace.h"   /* Defining proper namespace (if used)                 */
#include "drmtypes.h"       /* Core DRM types */
#include "drmresults.h"     /* Return codes that DRM APIs can return */
#include "drmerr.h"

#if NO_DRM_CRT
#include <string.h>
#include <stdlib.h>
#if !defined(__arm) && !defined(__TMS320C55X__)
#include <wchar.h>
#endif
#endif

#include "drmsal.h"         /* SAL annotations */

#include "drmdebug.h"       /* Debug macros & functions */
#include "drmstrings.h"
#include "oemcommon.h"      /* Common OEM definitions */
#include "drmprofile.h"     /* Profiling definitions */
#include "drmbytemanip.h"

/*
**  When PK code is compiled with PC profile, namespace PK must be used
*/
#ifdef __cplusplus
#if DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_PC
#if USE_PK_NAMESPACES
using namespace PK;
#endif /* USE_PK_NAMESPACES */
#endif /* DRM_BUILD_PROFILE */
#endif /* __cplusplus */

#endif  /* __DRMCOMMON_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmcompiler.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMCOMPILER_H__
#define __DRMCOMPILER_H__

/*
** +-----------------------------------+
** | COMPILATION QUALIFIER DEFINITIONS |
** +-----------------------------------+
*/

/* ====================== Microsoft specific qualifiers ======================= */
/* ============================================================================ */
#if defined (_MSC_VER)

#define DRM_CCALL      __cdecl
#define DRM_STDCALL    __stdcall 
#define DRM_FASTCALL   __fastcall

#define DRM_DLLEXPORT  __declspec(dllexport)
#define DRM_DLLIMPORT  __declspec(dllimport)
#define DRM_ALIGN_4    __declspec(align(4))


/* ========================= GNU specific qualifiers ========================== */
/* ============================================================================ */
#elif defined (__GNUC__)

#define DRM_CCALL      __attribute__((cdecl))
#define DRM_STDCALL    __attribute__((stdcall))
#define DRM_FASTCALL   __attribute__((fastcall))

#define DRM_DLLEXPORT  __attribute__((dllexport))
#define DRM_DLLIMPORT  __attribute__((dllimport))
#define DRM_ALIGN_4    __attribute__((aligned(4)))


/* ======================== Default (empty) qualifiers ======================== */
/* ============================================================================ */
#else

#define DRM_CCALL
#define DRM_STDCALL
#define DRM_FASTCALL

#define DRM_DLLEXPORT
#define DRM_DLLIMPORT
#define DRM_ALIGN_4

#endif


#if DRM_NO_FORCE_ALIGN
#undef DRM_ALIGN_4
#define DRM_ALIGN_4
#endif

/*
** This option specifies that assembly routines will be used, if they exist for the given target
** The RMSDK disables this option for use in managed C++ components
*/
#ifndef DRM_USE_ASSEMBLY
#define DRM_USE_ASSEMBLY 1
#endif

    
/*
** +-----------------------------------+
** |   COMPILATION BEHAVIOR SETTINGS   |
** +-----------------------------------+
*/

/* ============================ Microsoft Compiler ============================ */
/* ============================================================================ */
#if defined (_MSC_VER)

/* ------------------------------ MS ANSI build ------------------------------- */
/* ---------------------------------------------------------------------------- */
/* when compiling as ANSI, parameter-passing specifications aren't allowed      */
#if defined (__STDC__) 
#define SIXTEEN_BIT_ADDRESSING 0
#define DRM_CALL
#define DRMINLINE
#define DRMFORCEINLINE
#define DRM_EXTERN_INLINE
#define DRM_EXPORTED_INLINE
#define DRM_INLINING_SUPPORTED 0
#define DRM_DWORD_ALIGN
#define DRM_NO_INLINE

/* ---------------------------- MS non-ANSI build ----------------------------- */
/* ---------------------------------------------------------------------------- */
#else

/* ----------------- Building the PK DLL ----------------- */
/* Set the macros to export the APIs and global variables  */
#if DRM_EXPORT_APIS_TO_DLL
#define DRM_API         DRM_DLLEXPORT
#define DRM_EXPORT_VAR  DRM_DLLEXPORT
#endif

/* ------------ Building the Test Executables ------------ */
/* Set the macro to import the global variables            */
#if DRM_TEST_LINK_TO_DRMAPI_DLL
#define DRM_EXPORT_VAR  DRM_DLLIMPORT
#endif

#define SIXTEEN_BIT_ADDRESSING  0
#define DRM_CALL                DRM_CCALL
#define DRMINLINE               _inline
#define DRMFORCEINLINE          __forceinline
#define DRM_EXTERN_INLINE       extern DRMINLINE
#define DRM_EXPORTED_INLINE     DRMINLINE
#define DRM_INLINING_SUPPORTED  1
#define DRM_DWORD_ALIGN         DRM_ALIGN_4
#define DRM_NO_INLINE           __declspec(noinline)
#endif

/* =============================== GNU Compiler =============================== */
/* ============================================================================ */
#elif defined (__GNUC__)
#define SIXTEEN_BIT_ADDRESSING  0
#define DRM_CALL
#define DRMINLINE               inline
#define DRMFORCEINLINE          inline
#define DRM_EXTERN_INLINE       extern DRMINLINE
#define DRM_EXPORTED_INLINE     DRMINLINE
#define DRM_INLINING_SUPPORTED  1
#define DRM_DWORD_ALIGN         DRM_ALIGN_4
#define DRM_NO_INLINE

/* =============================== TI Compiler ================================ */
/* ============================================================================ */
#elif defined (__TMS320C55X__)
#define SIXTEEN_BIT_ADDRESSING  1
#define DRM_CALL
#define DRMINLINE               inline
#define DRMFORCEINLINE          inline
#define DRM_EXTERN_INLINE       extern 
#define DRM_EXPORTED_INLINE
#define DRM_INLINING_SUPPORTED  1
#define DRM_DWORD_ALIGN         DRM_ALIGN_4
#define DRM_NO_INLINE

/* ============================= Unknown Compiler ============================= */
/* ============================================================================ */
#else
#error Unknown compiler - please supply appropriate definitions for the above
#endif  


/*
** Currently, creating a DLL is only supported on Microsoft compiler non-ANSI builds,
** so ensure that the following DLL specific macros are empty if not set above.
*/
#ifndef DRM_API
#define DRM_API
#endif

#ifndef DRM_EXPORT_VAR
#define DRM_EXPORT_VAR
#endif


/*
** +-----------------------------------+
** |     LITTLE ENDIAN / BIG ENDIAN    |
** +-----------------------------------+
*/
#ifndef TARGET_LITTLE_ENDIAN
#if defined(_M_IX86)       /* Microsoft X86 compiler detected   */
#define TARGET_LITTLE_ENDIAN 1
#elif defined( _M_AMD64 )  /* Microsoft AMD64 compiler detected */
#define TARGET_LITTLE_ENDIAN 1
#elif defined( _M_IA64 )   /* Microsoft IA64 compiler detected  */
#define TARGET_LITTLE_ENDIAN 1
#elif defined( ARM )
#define TARGET_LITTLE_ENDIAN 1
#elif defined(__TMS320C55X__)
#define TARGET_LITTLE_ENDIAN 0
#else
#error Unknown target - you will need to define TARGET_LITTLE_ENDIAN to 0 or 1.
#endif
#endif



/*
** +-----------------------------------+
** |    BASIC TYPE/SIZE DEFINITIONS    |
** +-----------------------------------+
*/

/* 
** In General, 
** DRM_CHAR* is used for null terminated ANSI strings
** DRM_BYTE* is used for just plain byte buffer, w/o any termination
*/

/*
** Wide character is special type in C++ - wchar_t, 
** while for "C" compilation it is just unsigned short.
** So 2 different types for C and C++.
*/

/* ======================== Microsoft compiler sizes ========================== */
/* ============================================================================ */
#if defined (_MSC_VER)
                                                   /* 8-bit addressing    16 bit addressing*/
typedef unsigned __int8         DRM_BYTE;               /* 1 byte              1 byte */
typedef __int8                  DRM_CHAR;               /* 1 byte              1 byte */
typedef unsigned __int16        DRM_WORD;               /* 2 bytes             1 byte */
typedef __int16                 DRM_SHORT;              /* 2 bytes             1 byte */
typedef unsigned __int16        DRM_WCHAR;              /* 2 bytes             1 byte */
typedef __int32                 DRM_BOOL;               /* 4 bytes             2 bytes */
typedef unsigned long           DRM_DWORD;              /* 4 bytes             2 bytes */
typedef unsigned __int32        DRM_WCHAR32;            /* 4 bytes             2 bytes */
typedef long                    DRM_LONG;               /* 4 bytes             2 bytes */
typedef unsigned __int32        DRM_UINT;               /* 4 bytes             2 bytes */
typedef __int32                 DRM_INT;                /* 4 bytes             2 bytes */

#ifdef __cplusplus
typedef wchar_t                 DRM_WCHAR_NATIVE;      /* 2 bytes             1 byte */
#else
typedef unsigned __int16        DRM_WCHAR_NATIVE;      /* 2 bytes             1 byte */
#endif


/* =========================== GNU compiler sizes ============================= */
/* ============================================================================ */
#elif defined (__GNUC__)
                                                   /* 8-bit addressing    16 bit addressing*/
typedef unsigned int8_t         DRM_BYTE;               /* 1 byte              1 byte */
typedef int8_t                  DRM_CHAR;               /* 1 byte              1 byte */
typedef unsigned int16_t        DRM_WORD;               /* 2 bytes             1 byte */
typedef int16_t                 DRM_SHORT;              /* 2 bytes             1 byte */
typedef unsigned int16_t        DRM_WCHAR;              /* 2 bytes             1 byte */
typedef int32_t                 DRM_BOOL;               /* 4 bytes             2 bytes */
typedef unsigned int32_t        DRM_DWORD;              /* 4 bytes             2 bytes */
typedef unsigned int32_t        DRM_WCHAR32;            /* 4 bytes             2 bytes */
typedef int32_t                 DRM_LONG;               /* 4 bytes             2 bytes */
typedef unsigned int32_t        DRM_UINT;               /* 4 bytes             2 bytes */
typedef int32_t                 DRM_INT;                /* 4 bytes             2 bytes */

#ifdef __cplusplus
typedef wchar_t                 DRM_WCHAR_NATIVE;      /* 2 bytes             1 byte */
#else
typedef unsigned int16_t        DRM_WCHAR_NATIVE;      /* 2 bytes             1 byte */
#endif


/* ============================== Default sizes =============================== */
/* ============================================================================ */
#else
                                                   /* 8-bit addressing    16 bit addressing*/
typedef unsigned char           DRM_BYTE;               /* 1 byte              1 byte */
typedef char                    DRM_CHAR;               /* 1 byte              1 byte */
typedef unsigned short          DRM_WORD;               /* 2 bytes             1 byte */
typedef short                   DRM_SHORT;              /* 2 bytes             1 byte */
typedef unsigned short          DRM_WCHAR;              /* 2 bytes             1 byte */
typedef int                     DRM_BOOL;               /* 1 bytes             1 bytes */
typedef unsigned long           DRM_DWORD;              /* 4 bytes             2 bytes */
typedef unsigned int            DRM_WCHAR32;            /* 4 bytes             2 bytes */
typedef long                    DRM_LONG;               /* 4 bytes             2 bytes */

#ifdef __cplusplus
typedef wchar_t                 DRM_WCHAR_NATIVE;      /* 2 bytes             1 byte */
#else
typedef unsigned short          DRM_WCHAR_NATIVE;      /* 2 bytes             1 byte */
#endif

#if SIXTEEN_BIT_ADDRESSING
typedef unsigned long           DRM_UINT;               /*   n/a               2 bytes */
typedef long                    DRM_INT;                /*   n/a               2 bytes */
#else
typedef unsigned int            DRM_UINT;               /* 4 bytes               n/a   */
typedef int                     DRM_INT;                /* 4 bytes               n/a   */
#endif

#endif


/*
** +-----------------------------------+
** | MACRO DEFINITIONS                 |
** +-----------------------------------+
*/

/* ====================== Microsoft specific qualifiers ======================= */
/* ============================================================================ */
#if defined (_MSC_VER)

/* 
** Compile-time asserts cause PREfast warnings regarding the comparison of two constants.
** So, enable this macro only when the PREfast tool is not analyzing the code.
*/
#ifndef _PREFAST_ 

    /* Definition of the compile time assert. */
    #define DRMCASSERT( x ) switch(0){case 0:case (x):;}
     
    /* Assertion of the alignment of a member field within a structure. */
    #define DRMALIGNASSERT( struc, member ) DRMCASSERT( ( DRM_OFFSET_OF( struc, member ) ) % SIZEOF( DRM_WCHAR ) == 0 )

    /* Assertion of adjacency of two member fields within the same structure. */
    #define DRMADJASSERT( struc, member1, member2 ) DRMCASSERT( ENSURE_MEMBERS_ADJACENT( struc, member1, member2 ) )
    
#else
    /* Definition of the compile time assert. */
    #define DRMCASSERT( x )
    
    /* Assertion of the alignment of a member field within a structure. */
    #define DRMALIGNASSERT( struc, member ) DRMASSERT( ( DRM_OFFSET_OF( struc, member ) ) % SIZEOF( DRM_WCHAR ) == 0 )
    
    /* Assertion of adjacency of two member fields within the same structure. */
    #define DRMADJASSERT( struc, member1, member2 ) DRMASSERT( ENSURE_MEMBERS_ADJACENT( struc, member1, member2 ) )
    
#endif

#else

/* Definition of the compile time assert. */
#define DRMCASSERT( x ) switch(0){case 0:case (x):;}

/* Assertion of the alignment of a member field within a structure. */
#define DRMALIGNASSERT( struc, member ) DRMASSERT( ( DRM_OFFSET_OF( struc, member ) ) % SIZEOF( DRM_WCHAR ) == 0 )

/* Assertion of adjacency of two member fields within the same structure. */
#define DRMADJASSERT( struc, member1, member2 ) DRMASSERT( ENSURE_MEMBERS_ADJACENT( struc, member1, member2 ) )

#endif

#endif   /* __DRMCOMPILER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmcontextsizes.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMCONTEXTSIZES_H__
#define __DRMCONTEXTSIZES_H__

/*
** Device cert and licenses will be staged to share the same buffer       
*/
#define MAX_DEVICE_CERT_SIZE          ( 10 * 1024 )                        
#define MAX_DEVICE_CERT_TEMPLATE_SIZE ( ( MAX_DEVICE_CERT_SIZE * 6 ) / 10 )/* 60% of max devcert */
#define DRM_MAX_HEADERDATASIZE        ( 5 * 1024 )                         /* 5K of header data  */
#define DRM_MAX_LICENSESIZE           MAX_DEVICE_CERT_SIZE               /* 10K max license size */
#define MAX_ACTIONS_LENGTH            150
#define MAX_REVOCATION_LIST_SIZE      ( 30 * 1024 )

/* The buffer should be big enough to store a single XMR license. */
#define MAX_NST_BUFFER_SIZE           1024

#include <drmcommon.h>
#include <drmlicense.h>
#include <drmsha1.h>
#include <drmhmac.h>
#include <drmrc4.h>
#include <drmcipher.h>
#include <drmstkalloc.h>
#include <drmdevcert.h>
#include <drmdatastore.h>
#include <drmhds.h>
#include <drmsecurestore.h>
#include <drmexpreval.h>
#include <drmliceval.h>
#include <drmutilities.h>
#include <drmmeterimp.h>
#include <drmblackbox.h>
#include <drmlicstore.h>
#include <drmlicacq.h>
#include <drmoutputleveltypes.h>
#include <drmoutputlevels.h>
#include <drmchain.h>
#include <drmplayreadyobj.h>

#if DRM_SUPPORT_DOMAINS
#include <drmdomainstore.h>
#endif /* DRM_SUPPORT_DOMAINS */

#include <drmnoncestore.h>

typedef enum _DRM_CONTENT_SET_PROPERTY
{
    DRM_CSP_HEADER_NOT_SET    = 0,
    DRM_CSP_V1_HEADER         = 1,
    DRM_CSP_V2_HEADER         = 2,
    DRM_CSP_KID               = 3,
    DRM_CSP_V2_4_HEADER       = 5,
    DRM_CSP_V4_HEADER         = 6,
    DRM_CSP_AUTODETECT_HEADER = 7,
    DRM_CSP_PLAYREADY_OBJ     = 8

} DRM_CONTENT_SET_PROPERTY;

typedef enum _DRM_CONTENT_GET_PROPERTY
{
    DRM_CGP_HEADER_KID        = 0,
    DRM_CGP_HEADER_TYPE       = 1,
    DRM_CGP_HEADER            = 2,
    DRM_CGP_PLAYREADY_OBJ     = 3,
    DRM_CGP_CIPHER_TYPE       = 4

} DRM_CONTENT_GET_PROPERTY;

typedef struct __tagDRM_APP_CONTEXT_INTERNAL
{
    DRM_DWORD                   cbKID;

    DRM_BOOL                    fLicStoreOpenXML;
    DRM_BOOL                    fLicStoreOpenXMR;
    DRM_BOOL                    fSecStoreGlobalContextOpen;
    DRM_CONTENT_SET_PROPERTY    eHeaderInContext;  
    DRM_BOOL                    fCanBind;

    DRM_BOOL                    fResponseSignatureChecked;
    DRM_DWORD                   dwLastResponseProtocol;

    DRM_VOID                   *pOEMContext;

    DRM_KID                     KID;
    DRM_WCHAR                   wszBBVerString[VER_STRING_MAX_LEN];

    DRM_BB_CONTEXT              oBlackBoxContext;
    DRM_BINDING_INFO            oBindInfo[DRM_MAX_LICENSE_CHAIN_DEPTH];    
    DRM_XMR_LICENSE             licenseXMR[DRM_MAX_LICENSE_CHAIN_DEPTH];

    DRM_LICSTORE_CONTEXT        oLicStoreContextXML;
    DRM_LICSTORE_CONTEXT        oLicStoreContextXMR;
    DRM_LICSTORE_CONTEXT        oLicStoreContextEmbedded;
    DRM_LICSTOREENUM_CONTEXT    oLicEnum[DRM_MAX_LICENSE_CHAIN_DEPTH];
    DRM_LICSTOREENUM_MULTIPLE_CONTEXT oLicEnumMultiple[DRM_MAX_LICENSE_CHAIN_DEPTH];

    DRM_VIEW_RIGHTS_CONTEXT     oViewRightsContext;
    DRM_LICEVAL_CONTEXT         oLicEvalContext;    
    DRM_SECSTORE_CONTEXT        oSecStoreGlobalContext;
    
    DRM_DWORD                   dwChainDepth;
    DRM_SECSTORE_CONTEXT        rgcontextSST[DRM_MAX_LICENSE_CHAIN_DEPTH];
#if DRM_SUPPORT_CERTIFICATE_CACHING || DRM_SUPPORT_REVOCATION
    DRM_SECSTORE_CONTEXT        contextSSTCertCache;
#endif

#if DRM_SUPPORT_LICENSE_SYNC
    DRM_SYNC_CONTEXT            contextSync;
#if DRM_SUPPORT_DLA
    DRM_SYNC_ENUM_CONTEXT       contextSyncEnum;
#endif
#endif

#if DRM_SUPPORT_REVOCATION
    DRM_REVLIST_ID_VALUES        idCRLsCurrent;
    DRM_REVOCATIONSTORE_CONTEXT  oRevContext;
#endif
    DRM_BYTE                    *pbRevocationBuffer;
    DRM_DWORD                    cbRevocationBuffer;

    DRM_FFLICENSE                oFFLicense;
#if DRM_SUPPORT_DLA
    DRM_LICENSE_CHALLENGE        licensechallenge;
#endif
#if DRM_SUPPORT_METERING
    DRM_METERCERT_CONTEXT        oMeterCertContext;
#endif
    DRM_DST                      oDatastoreHDS;
    DRM_HDS_CONTEXT              oContextHDS;
    DRM_DST                      oDatastoreEST;
    DRM_EST_CONTEXT              oContextEST;
    DRM_BOOL                     fStoreOpened;
    DRM_DWORD                    cchDeviceStoreName;
    
    union
    {
        /*
        ** These next 2 buffers can be used independently or together in pieces.  
        ** Keep them flush so they have maximum raw bytes usuable.  
        ** See ProcessResponse 
        */
        struct
        {
            DRM_BYTE             rgbDRMHeaderData[__CB_DECL( DWORD_ALIGNED_SIZE( DRM_MAX_PLAYREADYOBJSIZE ) )];
            DRM_BYTE             rgbDRMLicense[__CB_DECL( DWORD_ALIGNED_SIZE( DRM_MAX_LICENSESIZE ) )];
        } oBuffers;
        
        DRM_BYTE                 rgbDRMBuffer[__CB_DECL( DWORD_ALIGNED_SIZE( DRM_MAX_LICENSESIZE ) + DWORD_ALIGNED_SIZE( DRM_MAX_PLAYREADYOBJSIZE ) )];
    } oDRMBuffer;
    
    DRM_WCHAR                   *pwszHeaderData;  /* Used with rgbDRMHeaderData: Points into the PRO at the V4 header */
    DRM_DWORD                    cbHeaderData;
    DRM_BYTE                    *pbEmbeddedStore; /* Used with rgbDRMHeaderData: Points into the PRO at the embedded store */
    DRM_DWORD                    cbEmbeddedStore;
    DRM_DWORD                    cbPROData;       /* Used with rgbDRMHeaderData: Specifies the length of the entire PRO if it is set  */
    DRM_DWORD                    cbTotalHeaderData; /* Used with rgbDRMHeaderData: Specifies the total length of the buffer filled with header data or PRO data */

    DRM_BOOL                     fClockSet;
    DRM_BOOL                     fBindThenCommit;
    DRM_DWORD                    dwSourceid;
#if DRM_SUPPORT_REVOCATION
    DRM_DWORD                    dwLicRevInfoVer;
#endif
#if DRM_SUPPORT_DOMAINS
    DRM_DOMAINSTORE_CONTEXT      oDomainStoreContext;
#endif /* DRM_SUPPORT_DOMAINS */

    DRM_LICSTORE_CONTEXT         oLicStoreContextNST;
    DRM_NONCESTORE_CONTEXT       oNonceStoreContext;
    
    DRM_BYTE                     rgbNSTBuffer[ MAX_NST_BUFFER_SIZE ];
} DRM_APP_CONTEXT_INTERNAL;

#define DRM_APP_CONTEXT_BUFFER_SIZE        SIZEOF( DRM_APP_CONTEXT_INTERNAL )
#define DRM_BINDCONDITIONS_BUFFER_SIZE     SIZEOF( DRM_BIND_CONDITIONS_INTERNAL )      

#endif /* __DRMCONTEXTSIZES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmcontract.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
** Header file for the Error contract mechanism.
*/

#ifndef __DRMCONTRACT_H__
#define __DRMCONTRACT_H__

ENTER_PK_NAMESPACE;

#if DRM_ERROR_CONTRACT_TEST_MODE

/*
** The following are the API IDs for each top-level API with an Error Code Contract (ECC).
** The order here is alphabetical by name to match the ordering in the .chm help file:
**     PlayReady.chm --> Programming Reference --> DRM Functions
**
** IF YOU ADD/DELETE ANY APIs HERE, YOU MUST ALSO:
** 1) ENSURE THAT THE CHM FILE IS UP-TO-DATE
** 2) UPDATE THE g_prgdrErrorCodelist STRUCTURE IN 'drmcontract.c' TO MATCH THIS ORDERING
** 3) POSSIBLY UPDATE THE TEST FILE ...\Test\Utils\ErrorContractTest.pc.pk.ce.txt (HAS HARDCODED API IDs)
*/
enum ECC_DRM_API_List
{
    ECC_DRM_GENERIC_ERROR_LIST = 0,
    
    ECC_Drm_Content_UpdateEmbeddedStore,
    ECC_Drm_Content_SetProperty,
    ECC_Drm_Device_GetProperty,
    ECC_Drm_DomainCert_EnumNext,
    ECC_Drm_DomainCert_Find,
    ECC_Drm_DomainCert_InitEnum,
    ECC_Drm_Envelope_Close,
    ECC_Drm_Envelope_DuplicateFileContext,
    ECC_Drm_Envelope_GetSize,
    ECC_Drm_Envelope_GetOriginalFileName,
    ECC_Drm_Envelope_InitializeRead,
    ECC_Drm_Envelope_Open,
    ECC_Drm_Envelope_Read,
    ECC_Drm_Envelope_Seek,
    ECC_Drm_GetAdditionalResponseData,
    ECC_Drm_Initialize,
    ECC_Drm_JoinDomain_GenerateChallenge,
    ECC_Drm_JoinDomain_ProcessResponse,
    ECC_Drm_LeaveDomain_GenerateChallenge,
    ECC_Drm_LeaveDomain_ProcessResponse,
    ECC_Drm_License_GetProperty,
    ECC_Drm_LicenseAcq_GenerateChallenge,
    ECC_Drm_LicenseAcq_GenerateAck,
    ECC_Drm_LicenseAcq_GetContentHeader,
    ECC_Drm_LicenseAcq_ProcessAckResponse,
    ECC_Drm_LicenseAcq_ProcessResponse,
    ECC_Drm_LicenseQuery_GetState,
    ECC_Drm_LicenseQuery_IsAllowed,
    ECC_Drm_MeterCert_Delete,
    ECC_Drm_MeterCert_EnumNext,
    ECC_Drm_MeterCert_GenerateChallenge,
    ECC_Drm_MeterCert_InitEnum,
    ECC_Drm_MeterCert_Invalidate,
    ECC_Drm_MeterCert_ProcessResponse,
    ECC_Drm_MeterCert_Update,
    ECC_Drm_Metering_GenerateChallenge,
    ECC_Drm_Metering_ProcessResponse,
    ECC_Drm_ProcessCommand,
    ECC_Drm_ProcessRequest,
    ECC_Drm_Reader_Bind,
    ECC_Drm_Reader_Commit,
    ECC_Drm_Reader_Decrypt,
    ECC_Drm_Reader_InitDecrypt,
    ECC_Drm_Reinitialize,
    ECC_Drm_SecureClock_GenerateChallenge,
    ECC_Drm_SecureClock_GetValue,
    ECC_Drm_SecureClock_ProcessResponse,
    ECC_Drm_SecureStore_GetExtendedTokenValue,
    ECC_Drm_SecureStore_SetExtendedTokenValue,
    ECC_Drm_StoreMgmt_CleanupStore,
    ECC_Drm_StoreMgmt_DeleteLicenses,
    ECC_Drm_Sync_GenerateChallenge,         
    ECC_Drm_SyncListItem_EnumNext,
    ECC_Drm_SyncListItem_InitEnum,
    ECC_Drm_Uninitialize,
    ECC_Drm_Content_GetProperty,
    ECC_Drm_Envelope_WritePlayReadyObject,
    ECC_Drm_Content_UpdateEmbeddedStore_Commit,
    ECC_Drm_PlayReadyObject_ConvertFromWmdrmHeader
};

/*
** Macro to interface with the DRM API.
** The argument 'apivalue' should be one of the values defined above
*/
#define ChkECC( apivalue, dr )                                                                     \
     do                                                                                            \
     {                                                                                             \
         if ( DRM_FAILED( dr ) && ( !DRM_ECC_ExpectedErrorCode( apivalue, dr ) ) )                \
         {                                                                                         \
              TRACE( ( "Error code 0x%X doesn't match expected error codes for "#apivalue, dr ) ); \
              DRMASSERT( FALSE ) ;                                                                 \
         }                                                                                         \
     } while ( FALSE )

/*
** Declaring the API arrays containing the error codes 
*/ 
extern DRM_RESULT g_rgdrGenericErrorList[];

extern DRM_RESULT g_rgdrDrm_Content_UpdateEmbeddedStore[];
extern DRM_RESULT g_rgdrDrm_Content_SetProperty[];
extern DRM_RESULT g_rgdrDrm_Device_GetProperty[];
extern DRM_RESULT g_rgdrDrm_DomainCert_EnumNext[];
extern DRM_RESULT g_rgdrDrm_DomainCert_Find[];
extern DRM_RESULT g_rgdrDrm_DomainCert_InitEnum[];
extern DRM_RESULT g_rgdrDrm_Envelope_Close[];
extern DRM_RESULT g_rgdrDrm_Envelope_DuplicateFileContext[];
extern DRM_RESULT g_rgdrDrm_Envelope_GetSize[];
extern DRM_RESULT g_rgdrDrm_Envelope_GetOriginalFileName[];
extern DRM_RESULT g_rgdrDrm_Envelope_InitializeRead[];
extern DRM_RESULT g_rgdrDrm_Envelope_Open[];
extern DRM_RESULT g_rgdrDrm_Envelope_Read[];
extern DRM_RESULT g_rgdrDrm_Envelope_Seek[];
extern DRM_RESULT g_rgdrDrm_GetAdditionalResponseData[];
extern DRM_RESULT g_rgdrDrm_Initialize[];
extern DRM_RESULT g_rgdrDrm_JoinDomain_GenerateChallenge[];
extern DRM_RESULT g_rgdrDrm_JoinDomain_ProcessResponse[];
extern DRM_RESULT g_rgdrDrm_LeaveDomain_GenerateChallenge[];
extern DRM_RESULT g_rgdrDrm_LeaveDomain_ProcessResponse[];
extern DRM_RESULT g_rgdrDrm_License_GetProperty[];
extern DRM_RESULT g_rgdrDrm_LicenseAcq_GenerateChallenge[];
extern DRM_RESULT g_rgdrDrm_LicenseAcq_GenerateAck[];
extern DRM_RESULT g_rgdrDrm_LicenseAcq_GetContentHeader[];
extern DRM_RESULT g_rgdrDrm_LicenseAcq_ProcessAckResponse[];
extern DRM_RESULT g_rgdrDrm_LicenseAcq_ProcessResponse[];
extern DRM_RESULT g_rgdrDrm_LicenseQuery_GetState[];
extern DRM_RESULT g_rgdrDrm_LicenseQuery_IsAllowed[];
extern DRM_RESULT g_rgdrDrm_MeterCert_Delete[];
extern DRM_RESULT g_rgdrDrm_MeterCert_EnumNext[];
extern DRM_RESULT g_rgdrDrm_MeterCert_GenerateChallenge[];
extern DRM_RESULT g_rgdrDrm_MeterCert_InitEnum[];
extern DRM_RESULT g_rgdrDrm_MeterCert_Invalidate[];
extern DRM_RESULT g_rgdrDrm_MeterCert_ProcessResponse[];
extern DRM_RESULT g_rgdrDrm_MeterCert_Update[];
extern DRM_RESULT g_rgdrDrm_Metering_GenerateChallenge[];
extern DRM_RESULT g_rgdrDrm_Metering_ProcessResponse[];
extern DRM_RESULT g_rgdrDrm_ProcessCommand[];
extern DRM_RESULT g_rgdrDrm_ProcessRequest[];
extern DRM_RESULT g_rgdrDrm_Reader_Bind[];
extern DRM_RESULT g_rgdrDrm_Reader_Commit[];
extern DRM_RESULT g_rgdrDrm_Reader_Decrypt[];
extern DRM_RESULT g_rgdrDrm_Reader_InitDecrypt[];
extern DRM_RESULT g_rgdrDrm_Reinitialize[];
extern DRM_RESULT g_rgdrDrm_SecureClock_GenerateChallenge[];
extern DRM_RESULT g_rgdrDrm_SecureClock_GetValue[];
extern DRM_RESULT g_rgdrDrm_SecureClock_ProcessResponse[];
extern DRM_RESULT g_rgdrDrm_SecureStore_GetExtendedTokenValue[];
extern DRM_RESULT g_rgdrDrm_SecureStore_SetExtendedTokenValue[];
extern DRM_RESULT g_rgdrDrm_StoreMgmt_CleanupStore[];
extern DRM_RESULT g_rgdrDrm_StoreMgmt_DeleteLicenses[];
extern DRM_RESULT g_rgdrDrm_Sync_GenerateChallenge[];
extern DRM_RESULT g_rgdrDrm_SyncListItem_EnumNext[];
extern DRM_RESULT g_rgdrDrm_SyncListItem_InitEnum[];
extern DRM_RESULT g_rgdrDrm_Uninitialize[];
extern DRM_RESULT g_rgdrDrm_Content_GetProperty[];
extern DRM_RESULT g_rgdrDrm_Envelope_WritePlayReadyObject[];
extern DRM_RESULT g_rgdrDrm_Content_UpdateEmbeddedStore_Commit[];
extern DRM_RESULT g_rgdrDrm_PlayReadyObject_ConvertFromWmdrmHeader[];

DRM_API DRM_BOOL DRM_CALL DRM_ECC_ExpectedErrorCode(
    __in const DRM_UINT   f_uiAPIid, 
    __in const DRM_RESULT f_dr );
    
#else      
#define ChkECC( apivalue, dr )     
#endif   /* DRM_ERROR_CONTRACT_TEST_MODE */

EXIT_PK_NAMESPACE;

#endif   /* __DRMCONTRACT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmdatastore.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRM_DATASTORE_H__
#define __DRM_DATASTORE_H__

#include <drmdatastorecommon.h>
#include <drmembeddedstore_impl.h>
#include <drmhds_impl.h>

ENTER_PK_NAMESPACE;

/*
** Enumeration of the currently supported DST implementations
*/
typedef enum
{
    eDRM_DST_NONE,
    eDRM_DST_HDS,
    eDRM_DST_EMBEDDED
} DRM_DST_IMPLEMENTATION_TYPE;

/*
** Context sizes which depend on the supported, underlying implementations:
*/
#define DRM_DST_CONTEXT_LEN            MAX( DRM_HDS_CONTEXT_LEN,           DRM_EST_CONTEXT_LEN )
#define DRM_DST_NAMESPACE_CONTEXT_LEN  MAX( DRM_HDS_NAMESPACE_CONTEXT_LEN, DRM_EST_NAMESPACE_CONTEXT_LEN )
#define DRM_DST_NAMESPACE_LEN          MAX( DRM_HDS_NSNAME_SIZE,           DRM_EST_NAMESPACE_LEN )
#define DRM_DST_SLOT_CONTEXT_LEN       MAX( DRM_HDS_SLOT_CONTEXT_LEN,      DRM_EST_SLOT_CONTEXT_LEN )
#define DRM_DST_ENUM_CONTEXT_LEN       MAX( DRM_HDS_ENUM_CONTEXT_LEN,      DRM_EST_ENUM_CONTEXT_LEN )
#define DRM_DST_SLOT_HINT_LEN          MAX( DRM_HDS_SLOT_HINT_LEN,         DRM_EST_SLOT_HINT_LEN )

/*
** Context containing information about a data store.
** This is a maximum size across all implementations.
*/
typedef struct __tagDRM_DST_CONTEXT
{
    DRM_BYTE rgbOpaqueData[__CB_DECL( DRM_DST_CONTEXT_LEN )]; /* Opaque, implementation-specific data */
} DRM_DST_CONTEXT;

/*
** Namespace identification data.
*/
typedef struct __tagDRM_DST_NAMESPACE
{
    DRM_BYTE rgbOpaqueData[__CB_DECL( DRM_DST_NAMESPACE_LEN )];/* Opaque, implementation-specific data */
} DRM_DST_NAMESPACE;

/*
** Context containing information about a namespace within a data store.
*/
typedef struct __tagDRM_DST_NAMESPACE_CONTEXT
{
    DRM_BYTE rgbOpaqueData[__CB_DECL( DRM_DST_NAMESPACE_CONTEXT_LEN )]; /* Opaque, implementation-specific data */
} DRM_DST_NAMESPACE_CONTEXT;

/*
** Context containing information about a data slot within a namespace.
*/
typedef struct __tagDRM_DST_SLOT_CONTEXT
{
    DRM_BYTE rgbOpaqueData[__CB_DECL( DRM_DST_SLOT_CONTEXT_LEN )]; /* Opaque, implementation-specific data */
} DRM_DST_SLOT_CONTEXT;

/*
** Context containing information about a slot enumeration context.
*/
typedef struct __tagDRM_DST_ENUM_CONTEXT
{
    DRM_BYTE rgbOpaqueData[__CB_DECL( DRM_DST_ENUM_CONTEXT_LEN )]; /* Opaque, implementation-specific data */
} DRM_DST_ENUM_CONTEXT;

/*
** Context containing data used to find a slot quickly.
*/
typedef struct __tagDRM_DST_SLOT_HINT
{
    DRM_BYTE rgbOpaqueData[__CB_DECL( DRM_DST_SLOT_HINT_LEN )]; /* Opaque, implementation-specific data */
} DRM_DST_SLOT_HINT;


/*
** ----------------------------------------------------------------------------
** Function typedefs
** ----------------------------------------------------------------------------
*/

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_INIT ) ( __inout DRM_DST_CONTEXT *f_pContextDST );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_UNINIT ) ( __inout DRM_DST_CONTEXT *f_pContextDST );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_CREATESTORE ) ( 
    __in_opt                           DRM_VOID          *f_pbOEMContext,
    __in_bcount( f_cbStoreData ) const DRM_BYTE          *f_pbStoreData,
    __in                               DRM_DWORD          f_cbStoreData,
    __in                         const DRM_DWORD          f_dwBlockSize,
    __in                               DRM_DST_BLKNUMTYPE f_eBlNumType,
    __in                               DRM_BOOL           f_fTruncateExist,
    __in                         const DRM_DWORD          f_dwInitSizeInKB,
    __inout                            DRM_DST_CONTEXT   *f_pContextDST );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_OPENSTORE ) ( 
    __in_opt                     DRM_VOID        *f_pOEMContext,
    __in_bcount( f_cbStoreData ) DRM_BYTE        *f_pbStoreData,
    __in                         DRM_DWORD        f_cbStoreData,
    __in                         DRM_DWORD        f_dwGrowBySizeinKB,
    __inout                      DRM_DST_CONTEXT *f_pContextDST );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_CLOSESTORE )( __inout DRM_DST_CONTEXT *f_pContextDST );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_COMMITSTORE )( __inout DRM_DST_CONTEXT *f_pContextDST );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_CLEANUPSTORE )( 
    __inout DRM_DST_CONTEXT *f_pContextDST,
    __in    DRM_BOOL         f_fWait );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_OPENNAMESPACE )( 
    __inout        DRM_DST_CONTEXT           *f_pContextDST,
    __in    const  DRM_DST_NAMESPACE         *f_pNamespace,
    __in           DRM_DST_OPENMODE           f_eOpenMode,
    __in           DRM_WORD                   f_wMaxNumChildren, 
    __in           DRM_DWORD                  f_dwExpectedSlotSize,
    __out          DRM_DST_NAMESPACE_CONTEXT *f_pContextNS );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_DELETENAMESPACE )( 
    __inout    DRM_DST_CONTEXT   *f_pContextDST,
    __inout    DRM_DST_NAMESPACE *f_pNS,
    __in       DRM_BOOL           f_fWait );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_CLOSENAMESPACE )( 
    __inout    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_COMMITNAMESPACE )( 
    __inout    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_MAKESLOTHINT )( 
    __in    DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __out   DRM_DST_SLOT_HINT     *f_pSlotHint );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_OPENSLOT )( 
    __in       DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
    __in       DRM_DWORD                  f_dwMode,
    __in const DRM_DST_KEY               *f_pKey1,
    __in const DRM_DST_KEY               *f_pKey2,
    __in_opt   DRM_DST_SLOT_HINT         *f_pSlotHint,
    __inout    DRM_DWORD                 *f_pcbSlotSize,
    __out      DRM_DST_SLOT_CONTEXT      *f_pContextSlot );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_CLOSESLOT )( 
    __inout  DRM_DST_SLOT_CONTEXT  *f_pContextSlot );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_DELETESLOT )( 
    __in       DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
    __in const DRM_DST_KEY               *f_pKey1,
    __in const DRM_DST_KEY               *f_pKey2,
    __in_opt   DRM_DST_SLOT_HINT         *f_pSlotHint,
    __in       DRM_BOOL                   f_fWait );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_INITSLOTENUM )( 
    __in           DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
    __in_opt const DRM_DST_KEY               *f_pKey1,
    __in           DRM_DST_LOCKMODE           f_eLockMode,
    __out          DRM_DST_ENUM_CONTEXT      *f_pContextEnum );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_SLOTENUMNEXT )( 
    __inout    DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
    __out      DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __out_opt  DRM_DST_KEY           *f_pKey1,
    __out_opt  DRM_DST_KEY           *f_pKey2,
    __out_opt  DRM_DWORD             *f_pcbSize );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_SLOTENUMRELOADCURRENT )( 
    __inout    DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
    __out      DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __out_opt  DRM_DST_KEY           *f_pKey1,
    __out_opt  DRM_DST_KEY           *f_pKey2,
    __out_opt  DRM_DWORD             *f_pcbSize );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_SLOTENUMDELETECURRENT )( 
    __inout   DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
    __inout   DRM_DST_SLOT_CONTEXT  *f_pContextSlot );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_BLOCKSCANDELETE )( 
    __inout                DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS,
    __in_ecount( f_cKey1 ) DRM_DST_KEY                *f_rgKey1,
    __in                   DRM_DWORD                   f_cKey1,
    __in                   DRM_DST_KEY                *f_pKey2,
    __in                   DRM_BOOL                    f_fWait );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_SLOTRESIZE )( 
    __inout  DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in     DRM_DWORD              f_cbSize );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_SLOTSEEK )( 
    __inout   DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in      DRM_LONG               f_lOffset,
    __in      DRM_DST_SEEKMODE       f_eSeekMode,
    __out_opt DRM_DWORD             *f_pdwSeekPointer );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_SLOTREAD )( 
    __inout                  DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in                     DRM_DWORD              f_cbData,
    __out_bcount( f_cbData ) DRM_BYTE              *f_pbData,
    __out_opt                DRM_DWORD             *f_pcbRead );

typedef DRM_API DRM_RESULT ( DRM_CALL *DRM_DST_SLOTWRITE )( 
    __inout                       DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in                          DRM_DWORD              f_cbData,
    __in_bcount( f_cbData ) const DRM_BYTE              *f_pbData,
    __out_opt                     DRM_DWORD             *f_pcbWritten );


/*
** Meta-structure which contains the function pointers used to access
** data store implementations
*/
typedef struct __tag_DRM_DST_INTERFACE
{
    /*
    ** Methods applied to whole data store 
    */
    DRM_DST_INIT         pfnInit;        /* Pointer to a data store init function */
    DRM_DST_UNINIT       pfnUninit;      /* Pointer to a data store uninit function */
    DRM_DST_CREATESTORE  pfnCreateStore; /* Pointer to a data store creation function */
    DRM_DST_OPENSTORE    pfnOpenStore;   /* Pointer to a data store opem function */
    DRM_DST_CLOSESTORE   pfnCloseStore;  /* Pointer to a data store close function */
    DRM_DST_COMMITSTORE  pfnCommitStore; /* Pointer to a data store commit function */
    DRM_DST_CLEANUPSTORE pfnCleanupStore;/* Pointer to a data store cleanup function */

    /*
    ** Methods used to open and manage namespaces within a data store. 
    */
    DRM_DST_OPENNAMESPACE   pfnOpenNamespace;   /* Pointer to a namespace open function */
    DRM_DST_DELETENAMESPACE pfnDeleteNamespace; /* Pointer to a namespace deletion function */
    DRM_DST_CLOSENAMESPACE  pfnCloseNamespace;  /* Pointer to a namespace close function */
    DRM_DST_COMMITNAMESPACE pfnCommitNamespace; /* Pointer to a namespace commit function */

    /*
    ** Methods to navigate, create, delete, open and close DST dataslots  
    */
    DRM_DST_MAKESLOTHINT          pfnMakeSlotHint;          /* Pointer to a slot hint function */
    DRM_DST_OPENSLOT              pfnOpenSlot;              /* Pointer to an open slot function */
    DRM_DST_CLOSESLOT             pfnCloseSlot;             /* Pointer to a close slot function */
    DRM_DST_DELETESLOT            pfnDeleteSlot;            /* Pointer to a slot deletion function */
    DRM_DST_INITSLOTENUM          pfnInitSlotEnum;          /* Pointer to an init slot enum function */
    DRM_DST_SLOTENUMNEXT          pfnSlotEnumNext;          /* Pointer to a slot enum next function */
    DRM_DST_SLOTENUMRELOADCURRENT pfnSlotEnumReloadCurrent; /* Pointer to a slot enum reload current function */
    DRM_DST_SLOTENUMDELETECURRENT pfnSlotEnumDeleteCurrent; /* Pointer to a slot enum delete current function */
    DRM_DST_BLOCKSCANDELETE       pfnBlockScanDelete;       /* Pointer to a block scan delete function */

    /*
    ** Functions to read, write and seek within a dataslot
    */
    DRM_DST_SLOTRESIZE pfnSlotResize;/* Pointer to a slot resize function. */
    DRM_DST_SLOTSEEK   pfnSlotSeek;  /* Pointer to a slot seek function. */
    DRM_DST_SLOTREAD   pfnSlotRead;  /* Pointer to a slot read function. */
    DRM_DST_SLOTWRITE  pfnSlotWrite; /* Pointer to a slot write function. */
} DRM_DST_INTERFACE;

/*
** Context containing information about a data store.
*/
typedef struct __tagDRM_DST
{
    DRM_DST_IMPLEMENTATION_TYPE       eImplementationType;  /* Specifies the implementation type */
    DRM_DST_INTERFACE                 oDataStoreInterface;  /* Contains the function table for an implementation */
    DRM_DST_CONTEXT                  *poContextDST;         /* Contains the internal data store context */
} DRM_DST;


/*
** ----------------------------------------------------------------------------
** API function definitions to be used for data store interface calls
** ----------------------------------------------------------------------------
*/

/*
** ----------------------------------------------------------------------------
** Methods applied to whole data store 
** ----------------------------------------------------------------------------
*/

DRM_API DRM_RESULT DRM_CALL DRM_DST_Init ( 
    __in                          DRM_DST_IMPLEMENTATION_TYPE       f_eImplementationType, 
    __in_bcount( f_cbDSTContext ) DRM_DST_CONTEXT                  *f_pDSTContext,
    __in                          DRM_DWORD                         f_cbDSTContext,
    __out                         DRM_DST                          *f_pDST );

DRM_API DRM_RESULT DRM_CALL DRM_DST_Uninit ( __inout DRM_DST *f_pDST );

DRM_API DRM_RESULT DRM_CALL DRM_DST_CreateStore ( 
    __in_opt                           DRM_VOID          *f_pbOEMContext,
    __in_bcount( f_cbStoreData ) const DRM_BYTE          *f_pbStoreData,
    __in                               DRM_DWORD          f_cbStoreData,
    __in                         const DRM_DWORD          f_dwBlockSize,
    __in                               DRM_DST_BLKNUMTYPE f_eBlNumType,
    __in                               DRM_BOOL           f_fTruncateExist,
    __in                         const DRM_DWORD          f_dwInitSizeInKB,
    __inout                            DRM_DST            *f_pDST );

DRM_API DRM_RESULT DRM_CALL DRM_DST_OpenStore ( 
    __in_opt                     DRM_VOID   *f_pOEMContext,
    __in_bcount( f_cbStoreData ) DRM_BYTE   *f_pbStoreData,
    __in                         DRM_DWORD   f_cbStoreData,
    __in                         DRM_DWORD   f_dwGrowBySizeinKB,
    __inout                      DRM_DST    *f_pDST );

DRM_API DRM_RESULT DRM_CALL DRM_DST_CloseStore ( __inout DRM_DST *f_pDST );

DRM_API DRM_RESULT DRM_CALL DRM_DST_CommitStore ( __inout DRM_DST *f_pDST );

DRM_API DRM_RESULT DRM_CALL DRM_DST_CleanupStore ( 
    __inout DRM_DST   *f_pDST,
    __in    DRM_BOOL   f_fWait );


/*
** ----------------------------------------------------------------------------
** Methods applied to namespaces within the data store. 
** ----------------------------------------------------------------------------
*/

DRM_API DRM_RESULT DRM_CALL DRM_DST_OpenNamespace ( 
    __inout        DRM_DST                   *f_pDST,
    __in    const  DRM_DST_NAMESPACE         *f_pNamespace,
    __in           DRM_DST_OPENMODE           f_eOpenMode,
    __in           DRM_WORD                   f_wMaxNumChildren,
    __in           DRM_DWORD                  f_dwExpectedSlotSize,
    __out          DRM_DST_NAMESPACE_CONTEXT *f_pContextNS );

DRM_API DRM_RESULT DRM_CALL DRM_DST_DeleteNamespace ( 
    __inout    DRM_DST           *f_pDST,
    __inout    DRM_DST_NAMESPACE *f_pNS,
    __in       DRM_BOOL           f_fWait );

DRM_API DRM_RESULT DRM_CALL DRM_DST_CloseNamespace ( 
    __inout    DRM_DST                    *f_pDST,
    __inout    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS );

DRM_API DRM_RESULT DRM_CALL DRM_DST_CommitNamespace ( 
    __inout    DRM_DST                    *f_pDST,
    __inout    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS );


/*
** ----------------------------------------------------------------------------
** Methods to navigate, create, delete, open and close DST dataslots  
** ----------------------------------------------------------------------------
*/

DRM_API DRM_RESULT DRM_CALL DRM_DST_MakeSlotHint ( 
    __inout DRM_DST               *f_pDST,
    __in    DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __out   DRM_DST_SLOT_HINT     *f_pSlotHint );

DRM_API DRM_RESULT DRM_CALL DRM_DST_OpenSlot ( 
    __inout    DRM_DST                   *f_pDST,
    __in       DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
    __in       DRM_DWORD                  f_dwMode,
    __in const DRM_DST_KEY               *f_pKey1,
    __in const DRM_DST_KEY               *f_pKey2,
    __in_opt   DRM_DST_SLOT_HINT         *f_pSlotHint,
    __inout    DRM_DWORD                 *f_pcbSlotSize,
    __out      DRM_DST_SLOT_CONTEXT      *f_pContextSlot );

DRM_API DRM_RESULT DRM_CALL DRM_DST_CloseSlot ( 
    __inout  DRM_DST               *f_pDST,
    __inout  DRM_DST_SLOT_CONTEXT  *f_pContextSlot );

DRM_API DRM_RESULT DRM_CALL DRM_DST_DeleteSlot ( 
    __inout    DRM_DST                   *f_pDST,
    __in       DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
    __in const DRM_DST_KEY               *f_pKey1,
    __in const DRM_DST_KEY               *f_pKey2,
    __in_opt   DRM_DST_SLOT_HINT         *f_pSlotHint,
    __in       DRM_BOOL                   f_fWait );

DRM_API DRM_RESULT DRM_CALL DRM_DST_InitSlotEnum ( 
    __inout        DRM_DST                   *f_pDST,
    __in           DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
    __in_opt const DRM_DST_KEY               *f_pKey1,
    __in           DRM_DST_LOCKMODE           f_eLockMode,
    __out          DRM_DST_ENUM_CONTEXT      *f_pContextEnum );

DRM_API DRM_RESULT DRM_CALL DRM_DST_SlotEnumNext ( 
    __inout    DRM_DST               *f_pDST,
    __inout    DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
    __out      DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __out_opt  DRM_DST_KEY           *f_pKey1,
    __out_opt  DRM_DST_KEY           *f_pKey2,
    __out_opt  DRM_DWORD             *f_pcbSize );

DRM_API DRM_RESULT DRM_CALL DRM_DST_SlotEnumReloadCurrent ( 
    __inout    DRM_DST               *f_pDST,
    __inout    DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
    __out      DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __out_opt  DRM_DST_KEY           *f_pKey1,
    __out_opt  DRM_DST_KEY           *f_pKey2,
    __out_opt  DRM_DWORD             *f_pcbSize );

DRM_API DRM_RESULT DRM_CALL DRM_DST_SlotEnumDeleteCurrent ( 
    __inout   DRM_DST               *f_pDST,
    __inout   DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
    __inout   DRM_DST_SLOT_CONTEXT  *f_pContextSlot );

DRM_API DRM_RESULT DRM_CALL DRM_DST_BlockScanDelete ( 
    __inout                DRM_DST                    *f_pDST,
    __inout                DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS,
    __in_ecount( f_cKey1 ) DRM_DST_KEY                *f_rgKey1,
    __in                   DRM_DWORD                   f_cKey1,
    __in                   DRM_DST_KEY                *f_pKey2,
    __in                   DRM_BOOL                    f_fWait );


/*
** ----------------------------------------------------------------------------
** Methods to read, write and seek within a dataslot
** ----------------------------------------------------------------------------
*/

DRM_API DRM_RESULT DRM_CALL DRM_DST_SlotResize ( 
    __inout  DRM_DST               *f_pDST,
    __inout  DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in     DRM_DWORD              f_cbSize );

DRM_API DRM_RESULT DRM_CALL DRM_DST_SlotSeek ( 
    __inout   DRM_DST               *f_pDST,
    __inout   DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in      DRM_LONG               f_lOffset,
    __in      DRM_DST_SEEKMODE       f_eSeekMode,
    __out_opt DRM_DWORD             *f_pdwSeekPointer );

DRM_API DRM_RESULT DRM_CALL DRM_DST_SlotRead ( 
    __inout                  DRM_DST               *f_pDST,
    __inout                  DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in                     DRM_DWORD              f_cbData,
    __out_bcount( f_cbData ) DRM_BYTE              *f_pbData,
    __out_opt                DRM_DWORD             *f_pcbRead );

DRM_API DRM_RESULT DRM_CALL DRM_DST_SlotWrite ( 
    __inout                       DRM_DST               *f_pDST,
    __inout                       DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in                          DRM_DWORD              f_cbData,
    __in_bcount( f_cbData ) const DRM_BYTE              *f_pbData,
    __out_opt                     DRM_DWORD             *f_pcbWritten );

EXIT_PK_NAMESPACE;

#endif  /* __DRM_DATASTORE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmdebug.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMDEBUG_H__
#define __DRMDEBUG_H__

#include <oemdebug.h>

ENTER_PK_NAMESPACE;

/*************************************************************************
*
*   debug printf macro
*   Sample calling seq:
*
*   TRACE(("My name is %s", "DRM"));
*
*   Note the double parenthesis.
*************************************************************************/
#if DBG

    #undef TRACE
    #define TRACE(x) do { Oem_Debug_Trace("TRACE at %s(%d): ", __FILE__, __LINE__); Oem_Debug_Trace x; Oem_Debug_Trace("\r\n"); } while( FALSE )

    #undef TRACE_IF_FAILED
    #define TRACE_IF_FAILED(x) do { if ( DRM_FAILED( dr ) ){ TRACE(x); } } while ( FALSE )

#else  // DBG

    #ifndef TRACE
    #define TRACE(x) 
    #endif
    
    #ifndef TRACE_IF_FAILED
    #define TRACE_IF_FAILED(x) 
    #endif

#endif  // DBG


/* 
** Compile-time asserts cause PREfast warnings regarding the comparison of two constants.
** So, enable this macro only when the PREfast tool is not analyzing the code.
*/
#ifndef _PREFAST_ 
    #define DRMSIZEASSERT(x,y)  \
        {switch(0){case ((x)==(y)?0:(y)):case (y):;}} \
        {switch(0){case ((y)==(x)?0:(x)):case (x):;}}
#else
    #define DRMSIZEASSERT(x,y)
#endif


#define DRM_OFFSET_OF(struc,member)   (DRM_DWORD_PTR)&(((struc *)0)->member)
#define ENSURE_MEMBERS_ADJACENT(struc,member1,member2)  ((DRM_OFFSET_OF(struc,member1)+(DRM_DWORD)(SIZEOF(((struc *)0)->member1))) == DRM_OFFSET_OF(struc,member2))

#if DBG
    #undef DRMASSERT
    /* Call the global assert handler function. */
    #define DRMASSERT(x) Oem_Debug_Assert((x), #x, __FILE__, __LINE__)
    
#else
    #ifndef DRMASSERT
        #define DRMASSERT
    #endif
    #ifndef DRMCASSERT
        #define DRMCASSERT
    #endif
#endif

EXIT_PK_NAMESPACE;

#endif  /* __DRMDEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmdes.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMDES_H__
#define __DRMDES_H__

ENTER_PK_NAMESPACE;

#ifndef __DES_H__

typedef struct _destable
{
    DRM_DWORD keytab[16][2];
} DESTable;

#define DES_TABLESIZE    SIZEOF(DESTable)
#define DES_BLOCKLEN    8
#define DES_KEYSIZE        8

#endif // __DES_H__

#define DES_ENCRYPT     1
#define DES_DECRYPT     0


/*********************************************************************
**
**  Function:  deskey
**
**  Synopsis:  Fill in the DESTable struct with the decrypt and encrypt
**               key expansions.
**
**               Assumes that the second parameter points to DES_KEYSIZE
**             bytes of key.
**
**  Arguments:  
**     [pTable] -- A DESTable structure that will be filled according to the DES key-schedule algorithm.
**     [rgbKey] -- The DES symmetric key to be used.
**
**  Returns:  None
**
*********************************************************************/

DRM_API DRM_VOID DRM_CALL DRM_DES_KeySetup(
    OUT       DESTable *pTable,
    __in_bcount( DES_KEYSIZE ) const DRM_BYTE  rgbKey[__CB_DECL(DES_KEYSIZE)] );


/*********************************************************************
**
**  Function:  DRM_DES_Cipher
**
**  Synopsis:  
**
**  Arguments:  
**     [rgbIn] -- Array of bytes to encrypt
**     [rgbOut] -- Encrypted array of bytes
**     [pTable] -- DES table initialized by DRM_DES_KeySetup
**     [op] -- Operation to perform ( DES_ENCRYPT or DES_DECRYPT )
**
**  Returns:  None
**
*********************************************************************/

DRM_API DRM_VOID DRM_CALL DRM_DES_Cipher(
    __in_bcount( DES_BLOCKLEN ) const DRM_BYTE  rgbIn [__CB_DECL(DES_BLOCKLEN)],
    __out_bcount( DES_BLOCKLEN ) DRM_BYTE  rgbOut[__CB_DECL(DES_BLOCKLEN)],
    IN       DESTable *pTable,
    IN       DRM_INT   op);


#define DRM_DES_Encrypt( x, y, z ) \
    DRM_DES_Cipher( (x), (y), (z), DES_ENCRYPT )

#define DRM_DES_Decrypt( x, y, z ) \
    DRM_DES_Cipher( (x), (y), (z), DES_DECRYPT )

EXIT_PK_NAMESPACE;

#endif /* __DRMDES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmcrt.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMCRT_H__
#define __DRMCRT_H__

#include <drmstrsafe.h>

#if !NO_DRM_CRT
/* They want to use the DRM CRT instead of their own CRT (maybe there isn't one) */

ENTER_PK_NAMESPACE;

/* String CRT functions */

DRM_API DRM_BOOL  DRM_CALL DRMCRT_iswspace  (DRM_WCHAR wch);
DRM_API DRM_BOOL  DRM_CALL DRMCRT_iswxdigit (DRM_WCHAR wch);
DRM_API DRM_BOOL  DRM_CALL DRMCRT_iswdigit  (DRM_WCHAR wch);
DRM_API DRM_BOOL  DRM_CALL DRMCRT_iswalpha  (DRM_WCHAR wch);
DRM_API DRM_WCHAR DRM_CALL DRMCRT_towlower  (DRM_WCHAR wch);

DRM_API DRM_INT DRM_CALL DRMCRT_memcmp(
    __in_bcount( count ) const DRM_VOID  *src1,
    __in_bcount( count ) const DRM_VOID  *src2,
    IN       DRM_SIZE_T  count );

DRM_API DRM_VOID DRM_CALL DRMCRT_memset(
    __out_bcount( count ) DRM_VOID  *dst,
    IN       DRM_DWORD  b,
    IN       DRM_SIZE_T  count );

DRM_API DRM_VOID DRM_CALL DRMCRT_memcpy(
    __out_bcount( count ) DRM_VOID  *dst,
    __in_bcount( count ) const DRM_VOID  *src,
    IN       DRM_SIZE_T  count );

DRM_API DRM_VOID * DRM_CALL DRMCRT_memmove (
    __out_bcount( count ) DRM_VOID  *dst,
    __in_bcount( count ) const DRM_VOID  *src,
    IN       DRM_SIZE_T count );


DRM_API DRM_INT DRM_CALL DRMCRT_wcsncmp(
    __in_ecount( count ) const DRM_WCHAR *first,
    __in_ecount( count ) const DRM_WCHAR *last,
    IN       DRM_SIZE_T  count );

DRM_API DRM_SIZE_T DRM_CALL DRMCRT_wcslen(
    __in_z const DRM_WCHAR *wsz );

DRM_API DRM_SIZE_T DRM_CALL DRMCRT_strlen(
    __in_z const DRM_CHAR *sz );

DRM_API DRM_INT DRM_CALL DRMCRT_strncmp (
    __in_ecount( count ) const DRM_CHAR  *first,
    __in_ecount( count ) const DRM_CHAR  *last,
    IN       DRM_SIZE_T  count);

DRM_API DRM_INT DRM_CALL DRMCRT_abs( DRM_INT number );

EXIT_PK_NAMESPACE;

#else /* #ifndef NO_DRM_CRT */

/*
** The #include for all of the regular CRT headers is in drmcommon.h because drmsal.h must be included AFTER
** anything that could pull in the system's SAL annotations.
*/

#define DRMCRT_iswspace(wch)                          iswspace( wch )
#define DRMCRT_iswxdigit(wch)                         iswxdigit( wch )
#define DRMCRT_iswdigit(wch)                          iswdigit( wch )
#define DRMCRT_iswalpha(wch)                          iswalpha( wch )
#define DRMCRT_towlower(wch)                          towlower( wch )

#define DRMCRT_wcsncmp( a, b, c )                     wcsncmp( (const DRM_WCHAR_NATIVE *)a, (const DRM_WCHAR_NATIVE *)b, c )  

#define DRMCRT_wcslen( a )                            (DRM_DWORD)wcslen( (const DRM_WCHAR_NATIVE *)a  )  

#define DRMCRT_strlen( sz )                           (DRM_DWORD)strlen( sz )

#define DRMCRT_strncmp( szFirst, szLast, dwcount )    strncmp( szFirst, szLast, dwcount ) 

#define DRMCRT_memmove( dst, src, dwcount )           memmove( dst, src, dwcount )

#define DRMCRT_memcmp( src1, src2, dwcount )          memcmp( src1, src2, dwcount )

#define DRMCRT_memset( dest, bVal, dwcount )          memset( dest, bVal, dwcount )

#define DRMCRT_memcpy( dst, src, dwcount )            memcpy( dst, src, dwcount )

#define DRMCRT_abs( number )                          abs( (DRM_INT)number )

#endif /* #ifndef NO_DRM_CRT */


#if !defined( min )
    #define min( a, b ) ( (a) < (b) ? (a) : (b) )
#endif

#if !defined( max )
    #define max( a, b ) ( (a) < (b) ? (b) : (a) )
#endif



/**********************************************************************
**
** Set of DRM specific functions that complement C run time.  
*
***********************************************************************/

ENTER_PK_NAMESPACE;

DRM_API DRM_RESULT DRM_CALL DRMCRT_AtoDWORD( 
    __in_ecount( f_cchStringInput ) const DRM_CHAR  *f_pszStringInput,  
    IN       DRM_DWORD  f_cchStringInput,
    IN       DRM_DWORD  f_base,
    OUT      DRM_DWORD *f_pdwValue );

DRM_API DRM_RESULT DRM_CALL DRMCRT_WtoDWORD( 
    __in_ecount( f_cchStringInput ) const DRM_WCHAR *pwszStringInput,  
    __in                                  DRM_DWORD  f_cchStringInput,
    __in                                  DRM_DWORD  f_base,
    __out                                 DRM_DWORD *f_pdwValue );

DRM_API DRM_RESULT DRM_CALL DRMCRT_wcsntol( 
    __in_ecount( cchStringInput ) const DRM_WCHAR *pwszStringInput,
    IN       DRM_DWORD  cchStringInput,
    OUT      DRM_LONG  *plValue );


DRM_API DRM_WCHAR* DRM_CALL DRMCRT_wcsnstr
(
   __in_ecount( cchMaxStr ) const DRM_WCHAR *pwszStr,
   IN       DRM_DWORD  cchMaxStr,
   __in_ecount( cchMaxStrSearch ) const DRM_WCHAR *pwszStrSearch, 
   IN       DRM_DWORD  cchMaxStrSearch
);

EXIT_PK_NAMESPACE;

#endif /* __DRMCRT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmdatastorecommon.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRM_DATASTORECOMMON_H__
#define __DRM_DATASTORECOMMON_H__

#include <drmtypes.h>

ENTER_PK_NAMESPACE;

/*
** DRM_DST_BLKNUMTYPE specifies the block-numbering type for a given store.
*/
typedef enum 
{
    eDRM_DSTBLKNUM_WORD  = 2,  /* Number blocks by WORD */
    eDRM_DSTBLKNUM_DWORD = 4   /* Number blocks by DWORD */
} DRM_DST_BLKNUMTYPE;

/*
** DRM_DST_OPENMODE specifies the open mode for a store or namespace.
*/
typedef enum
{
    eDRM_DST_CREATE_NEW    = 0x1000,      /* Create only, fail if it already exists. */
    eDRM_DST_OPEN_EXISTING = 0x2000,      /* Open if exists, fail if not. */
    eDRM_DST_OPEN_ALWAYS   = 0x4000       /* Open if exists, create if not. */
} DRM_DST_OPENMODE;

/*
** DRM_DST_LOCKMODE specifies the locking mode for a store, namespace, or slot.
*/
typedef enum
{
    eDRM_DST_LOCKSHARED    = 0x0, /* Opened for shared access. */
    eDRM_DST_LOCKEXCLUSIVE = 0x1, /* Opened for exclusive access. */
    eDRM_DST_LOCKWAIT      = 0x2, /* Wait for existing lock before access. */
    eDRM_DST_LOCKMODE_MASK = 0x3  /* Bitmask defining the bits used for the lock mode */
} DRM_DST_LOCKMODE;

/*
** DRM_DST_SEEKMODE specifies the seek mode for seeking within a slot.
*/
typedef enum
{
    eDRM_DST_SEEKCUR = 1, /* Seek from the current position */
    eDRM_DST_SEEKEND = 2, /* Seek from the end of the slot */
    eDRM_DST_SEEKSET = 3  /* Seek from the beginning of the slot */
} DRM_DST_SEEKMODE;

/* 
** Both keys used in the data store are of type DRM_ID.
*/
typedef DRM_ID DRM_DST_KEY;

EXIT_PK_NAMESPACE;

#endif  /* __DRM_DATASTORECOMMON_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmdevcert.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMDEVCERTPARSER_H__
#define __DRMDEVCERTPARSER_H__

#include <drmbcert.h>
#include <drmeccp256.h>

ENTER_PK_NAMESPACE;

typedef enum
{
    DRM_DEVCERT_SERIALNUMBER = 1,       /* CERTIFICATE type="DEVICE"/DATA/UNIQUEID */
    DRM_DEVCERT_DEVICEPUBKEY,           /* CERTIFICATE type="DEVICE"/DATA/PUBLICKEY */
    DRM_DEVCERT_DEVICEPRIVKEY,          /* CERTIFICATE type="DEVICE"/DATA/PRIVATEKEY */
    DRM_DEVCERT_DEVICEDATANODE,         /* CERTIFICATE type="DEVICE"/DATA */ 
    DRM_DEVCERT_DEVICESIGNATURE,        /* CERTIFICATE type="DEVICE"/MSDRM_SIGNATURE_VALUE */
    DRM_DEVCERT_COMPATIBILITYVERSION,   /* FALLBACK/SECURITYVERSION */
    DRM_DEVCERT_COMPATIBILITYCERT,      /* FALLBACK/CERTIFICATE */
    DRM_DEVCERT_SECURECLOCK,            /* CERTIFICATE type="GROUP"/DATA/FEATURE/CLOCK */
    DRM_DEVCERT_SECURECLOCKURL,         /* CERTIFICATE type="GROUP"/DATA/FEATURE/SECURECLOCK/URL */
    DRM_DEVCERT_SECURECLOCKPUBKEY,      /* CERTIFICATE type="GROUP"/DATA/FEATURE/SECURECLOCK/PUBLICKEY */
    DRM_DEVCERT_METERING,               /* CERTIFICATE type="GROUP"/DATA/FEATURE/METERING */
    DRM_DEVCERT_LICENSEACQUISITIONMODE, /* CERTIFICATE type="GROUP"/DATA/FEATURE/LICENSE_ACQ */
    DRM_DEVCERT_LICENSESYNCMODE,        /* CERTIFICATE type="GROUP"/DATA/FEATURE/LICENSE_SYNC */
    DRM_DEVCERT_SYMMETRICOPTIMIZATIONS, /* CERTIFICATE type="GROUP"/DATA/FEATURE/SYMMETRIC_OPT */
    DRM_DEVCERT_ENCRYPTION,             /* CERTIFICATE type="GROUP"/DATA/FEATURE/ENCRYPTION */
    DRM_DEVCERT_MAXCHAINDEPTH,          /* CERTIFICATE type="GROUP"/DATA/LIMITS/MAXCHAINDEPTH */
    DRM_DEVCERT_MAXLICENSESIZE,         /* CERTIFICATE type="GROUP"/DATA/LIMITS/MAXLICENSESIZE */
    DRM_DEVCERT_MAXHEADERSIZE,          /* CERTIFICATE type="GROUP"/DATA/LIMITS/MAXHEADERSIZE */
    DRM_DEVCERT_GROUPSECURITYLEVEL,     /* CERTIFICATE type="GROUP"/DATA/SECURITYLEVEL */
    DRM_DEVCERT_GROUPCERTPUBKEY,        /* CERTIFICATE type="GROUP"/DATA/PUBLICKEY */
    DRM_DEVCERT_GROUPCERTDATANODE,      /* CERTIFICATE type="GROUP"/DATA */ 
    DRM_DEVCERT_GROUPCERTSIGNATURE,     /* CERTIFICATE type="GROUP"/MSDRM_SIGNATURE_VALUE */
    DRM_DEVCERT_DACSECURITYLEVEL,       /* CERTIFICATE type="AUTHORIZATION"/DATA/SECURITYLEVEL */
    DRM_DEVCERT_SUBJECTID,              /* CERTIFICATE type="AUTHORIZATION"/DATA/AUTH_ID */
    DRM_DEVCERT_DACPUBKEY,              /* CERTIFICATE type="AUTHORIZATION"/DATA/PUBLICKEY */
    DRM_DEVCERT_DACDATANODE,            /* CERTIFICATE type="AUTHORIZATION"/DATA */
    DRM_DEVCERT_DACSIGNATURE,           /* CERTIFICATE type="AUTHORIZATION"/MSDRM_SIGNATURE_VALUE */
    DRM_DEVCERT_DACROOTPUBKEY,          /* CERTIFICATE type="AUTHORIZATION_ROOT"/DATA/PUBLICKEY */
    DRM_DEVCERT_AUTHROOTDATANODE,       /* CERTIFICATE type="AUTHORIZATION_ROOT"/DATA */
    DRM_DEVCERT_AUTHROOTSIGNATURE,      /* CERTIFICATE type="AUTHORIZATION_ROOT"/MSDRM_SIGNATURE_VALUE */
    DRM_DEVCERT_SUPPORT_REVOCATION,     /* CERTIFICATE type="GROUP"/DATA/FEATURE/SUPPORT_REVOCATION */
    DRM_DEVCERT_ATTRIB_OTHER,
    DRM_DEVCERT_SUPPORTCRL              /* CERTIFICATE type="GROUP"/DATA/FEATURE/SUPPORT_REVOCATION */
} eDRM_DEVCERT_ATTRIBUTES;


#define DRM_FEATURE_METERING                0x1
#define DRM_FEATURE_ANTI_ROLLBACK_CLOCK     0x2
#define DRM_FEATURE_SECURE_CLOCK            0x4

#define DRM_CLOCK_NONE          0
#define DRM_CLOCK_ANTIROLLBACK  1
#define DRM_CLOCK_SECURE        2

typedef struct
{
    DRM_DWORD appSec;
    DRM_DWORD appcd_subject;
    DRM_DWORD dwFeatureFlags;
    PUBKEY    pubkeyCurrent;
    PUBKEY    pubkeySecureClockServer;
    PKCERT    m_BBCompatibilityCert;
    DRM_BYTE  m_blobDevicePrivkey[__CB_DECL( SIZEOF(PRIVKEY) )];
    DRM_WCHAR wszLegacyVersion[VER_STRING_MAX_LEN];    /* If this device supports a legacy blackbox number and key.  This will be filled in from the devcert */
} DRM_DEVICE_CERTIFICATE_CACHED_VALUES;

#define DRM_BINARY_DEVICE_CERT_MAX_KEYUSAGES    2

typedef enum
{
    DRM_BINARY_DEVICE_CERT_KEY_SIGN = 1,
    DRM_BINARY_DEVICE_CERT_KEY_ENCRYPT
} eDRM_BINARY_DEVICE_CERT_KEYUSAGE;

typedef struct
{
    PUBKEY_P256                 PublicKey;
    DRM_BYTE                    rgbPrivateKey[ __CB_DECL( SIZEOF( PRIVKEY_P256 ) ) ];
} DRM_BINARY_DEVICE_CERT_KEYPAIR;


typedef struct
{
    DRM_BCERT_CLIENT_ID     DeviceSerialNumber;
    DRM_DWORD               dwGroupSecurityLevel;
    DRM_DWORD               dwFeatureFlags;
    DRM_BINARY_DEVICE_CERT_KEYPAIR DeviceKeySign;
    DRM_BINARY_DEVICE_CERT_KEYPAIR DeviceKeyEncrypt;
} DRM_BINARY_DEVICE_CERT_CACHED_VALUES;



/* Get attribute from given devcert */
DRM_API DRM_RESULT DRM_CALL DRM_DCP_GetAttribute(
    IN const DRM_CONST_STRING        *f_pdstrDevCert, /* devcert */
    IN       eDRM_DEVCERT_ATTRIBUTES  f_eAttribute,   /* devcert attr to get */
       OUT   DRM_CONST_STRING        *f_pdstrNode,    /* extracted attr node with <node> tag */
       OUT   DRM_CONST_STRING        *f_pdstrValue);

#define DRM_DCP_VERIFY_DEVICE_CERT  1
#define DRM_DCP_VERIFY_GROUP_CERT   2
#define DRM_DCP_VERIFY_DAC          4

#define DRM_DCP_VERIFY_ENTIRE_DEVCERT (DRM_DCP_VERIFY_DEVICE_CERT \
                                     | DRM_DCP_VERIFY_GROUP_CERT  \
                                     | DRM_DCP_VERIFY_DAC)

DRM_API DRM_RESULT DRM_CALL DRM_DCP_VerifyDeviceCert(
    IN const DRM_CONST_STRING   *f_pdstrDevCert,
    IN       DRM_DWORD           f_dwVerifyFlags,
    IN       DRM_CRYPTO_CONTEXT *f_pcontextCRYP );

DRM_API DRM_RESULT DRM_CALL DRM_DCP_LoadPropertiesCache(
    IN const DRM_CONST_STRING                      *f_pdstrDevCert,
       OUT   DRM_DEVICE_CERTIFICATE_CACHED_VALUES  *f_pcacheDevCert,
    IN       DRM_CRYPTO_CONTEXT                    *f_pcontextCRYP );

#define DRM_DCP_CREATE_DEVCERT_IF_NOT_EXISTING  1
#define DRM_DCP_VERIFY_DEVCERT                  2


DRM_API DRM_RESULT DRM_CALL DRM_DDC_GetDeviceCertificate(
    __in_opt      DRM_VOID           *f_pOEMContext,
    __inout       DRM_STRING         *f_pdstrDevCert,
    __in    const DRM_DWORD           f_dwFlags,
    __inout       DRM_CRYPTO_CONTEXT *f_pcontextCRYP );


DRM_API DRM_RESULT DRM_CALL DRM_DDC_GetBinaryDeviceCertificate(
    __in_opt                                DRM_VOID          *f_pOEMContext,
    __in    const                           DRM_DWORD          f_dwFlags,
    __out_bcount(*f_pcbBinaryDevCertChain)  DRM_BYTE          *f_pBinaryDevCertChain,
    __inout                                 DRM_DWORD         *f_pcbBinaryDevCertChain,
    __inout                                DRM_CRYPTO_CONTEXT *f_pCryptoCtx  );


DRM_API DRM_RESULT DRM_CALL DRM_BCert_LoadPropertiesCache( 
   __in_bcount(f_cbCertData) const DRM_BYTE     *f_pbCertData,
   __in                      const DRM_DWORD    f_cbCertData,
   __inout DRM_BINARY_DEVICE_CERT_CACHED_VALUES *f_pCachedValues,
   __in_opt DRM_VOID                            *f_pOEMContext );


EXIT_PK_NAMESPACE;

#endif /* __DRMDEVCERTPARSER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmdevicestore.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRM_DEVICESTORE_H__
#define __DRM_DEVICESTORE_H__

#include <drmtypes.h>
#include <drmcontextsizes.h>
#include <drmmanager.h>
#include <drmdatastore.h>

ENTER_PK_NAMESPACE;

#if DRM_SUPPORT_DEVICESTORE

/* Number of seconds for validation timeout, should be 48 hours as per NDT spec */
#define NDTDEVICESTORE_VALIDATION_TIMEOUT 172800

/* Initial size of the dirty attribute buffer */
#define DEVICESTORE_NUMDIRTYATTRIBUTES_INTIAL 5

/* Value set in the dwNumAttributes member of a device handle indicating that the number of 
   attributes for the device is not known */
#define DEVICESTORE_NUMATTRIBUTES_UNKNOWN 0


/*
** Device store context stucture. This contains the DST namespace context it is using and
** the local stack info for internal use
*/
typedef struct _tag_DeviceStoreContext
{    
    DRM_DST_SLOT_CONTEXT        oSlotContext;
    DRM_DST_NAMESPACE_CONTEXT   oNamespaceContext;
    DRM_DST                    *pDatastore;
    DRM_BB_CONTEXT             *pBBXContext;
    DRM_SECSTORE_CONTEXT       *pSecureStoreContext;
    DRM_SECSTOREENUM_CONTEXT    oSecStoreEnum;
    DRM_BOOL                    fEnumInited;
} _DeviceStoreContext;

typedef struct _tag_DeviceHandle
{
    DRM_BYTE                   *pbEntry;
    DRM_DWORD                   cbEntry;
    DRM_BYTEBLOB                oDeviceID;
    _DeviceStoreContext        *pDeviceStoreContext;
    DRM_DWORD                  *pdwDirtyAttributes;   /* List of the indices of attributes that have been modified */
    DRM_DWORD                   dwDirtyAttributesSize; /* Size of the dirty attribute buffer as number of DRM_DWORD elements */
    DRM_DWORD                   dwNumDirtyAttributes;  /* Number of attributes marked as dirty */
    DRM_DWORD                   dwNumAttributes;        /* Number of attributes of the device, 0 if unknown (there should always be at least one attribute, DEVICEID) */
    DRM_BOOL                    fDontCommitOnFree;      /* Don't automatically commit when the handle is freed when this flag is set */
} _DeviceHandle;

typedef struct __tagDRM_DEVICESTORE_CONTEXT{
    DRM_BYTE rgbOpaqueBuffer[ __CB_DECL( SIZEOF( _DeviceStoreContext ) ) ];
} DRM_DEVICESTORE_CONTEXT;

typedef DRM_VOID* DRM_DEVICESTORE_HANDLE;

/* 
** API Functions 
*/

/**********************************************************************
** Function:    DRM_DVS_Initialize
**
**
** Parameters
  f_pDeviceStoreContext [in]  Pointer to an allocated context that will be initialized. Must not be NULL.

Return Values
If the function succeeds, it returns DRM_SUCCESS and f_pDeviceStoreContext points to an initialized context. If the function fails, an appropriate error code will be returned. 
Remarks
Defined in OEM Layer (See architectural diagram)
The NDT PK must call DRM_DVS_Initialize with an allocated context before it can invoke any other device store APIs with that context. This function will initialize the incoming context as the OEM deems fit.

***********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_DVS_Initialize(
    IN     DRM_DEVICESTORE_CONTEXT  *f_pDeviceStoreContext,
    IN     DRM_APP_CONTEXT      *f_pDeviceStoreInitData

);



DRM_API DRM_VOID DRM_CALL DRM_DVS_Uninitialize(
    IN OUT DRM_DEVICESTORE_CONTEXT  *f_pDeviceStoreContext
);



DRM_API DRM_VOID DRM_CALL DRM_DVS_FreeDevice(
    IN    DRM_DEVICESTORE_HANDLE     f_hDeviceHandle
);



DRM_API DRM_RESULT DRM_CALL DRM_DVS_RegisterDevice(
    IN OUT DRM_DEVICESTORE_CONTEXT         *f_pDeviceStoreContext,
    IN     DRM_BYTEBLOB                     f_DeviceID,
       OUT DRM_DEVICESTORE_HANDLE          *f_pDeviceHandle
);



DRM_API DRM_RESULT DRM_CALL DRM_DVS_UnRegisterDevice(
    IN OUT DRM_DEVICESTORE_CONTEXT         *f_pDeviceStoreContext,
    IN     DRM_BYTEBLOB                     f_DeviceID
);



DRM_API DRM_RESULT DRM_CALL DRM_DVS_GetFirstDevice(
    IN OUT DRM_DEVICESTORE_CONTEXT      *f_pDeviceStoreContext,
       OUT DRM_DEVICESTORE_HANDLE       *f_pDeviceHandle
);



DRM_API DRM_RESULT DRM_CALL DRM_DVS_GetNextDevice(
    IN OUT DRM_DEVICESTORE_CONTEXT      *f_pDeviceStoreContext,
       OUT DRM_DEVICESTORE_HANDLE       *f_pDeviceHandle
);



DRM_API DRM_RESULT DRM_CALL DRM_DVS_GetDeviceByID(
    IN OUT DRM_DEVICESTORE_CONTEXT      *f_pDeviceStoreContext,
    IN     DRM_BYTEBLOB                  f_DeviceID,
       OUT DRM_DEVICESTORE_HANDLE       *f_pDeviceHandle
);


DRM_API DRM_RESULT DRM_CALL DRM_DVS_GetDeviceID(
    IN     DRM_DEVICESTORE_HANDLE           f_hDeviceHandle,
       OUT DRM_BYTE                        *f_pbDeviceID,
    IN OUT DRM_DWORD                       *f_pcbDeviceID
);



DRM_API DRM_RESULT DRM_CALL DRM_DVS_GetDeviceAttr(
    IN     DRM_DEVICESTORE_HANDLE           f_hDeviceHandle,
    IN     DRM_BYTEBLOB                     f_AttrName,
       OUT DRM_BYTE                        *f_pbAttrValue,
    IN OUT DRM_DWORD                       *f_pcbAttrValue
);



DRM_API DRM_RESULT DRM_CALL DRM_DVS_GetDeviceAttrCount(
    IN     DRM_DEVICESTORE_HANDLE           f_hDeviceHandle,
       OUT DRM_DWORD                       *f_pdwAttrCount
);



DRM_API DRM_RESULT DRM_CALL DRM_DVS_GetDeviceAttrByIndex(
    IN     DRM_DEVICESTORE_HANDLE           f_hDeviceHandle,
    IN     DRM_DWORD                        f_dwAttrIndex,
       OUT DRM_BYTE                        *f_pbAttrName,
    IN OUT DRM_DWORD                       *f_pcbAttrName,
       OUT DRM_BYTE                        *f_pbAttrValue,
    IN OUT DRM_DWORD                       *f_pcbAttrValue
);


DRM_API DRM_RESULT DRM_CALL DRM_DVS_SetDeviceAttr(
    IN     DRM_DEVICESTORE_HANDLE           f_hDeviceHandle,
    IN     DRM_BYTEBLOB                     f_AttrName,
    IN     DRM_BYTEBLOB                     f_AttrValue
);



DRM_API DRM_RESULT DRM_CALL DRM_DVS_CommitDevice(
    IN     DRM_DEVICESTORE_HANDLE           f_hDeviceHandle
);

#endif

EXIT_PK_NAMESPACE;

#endif  /* __DRM_DEVICESTORE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmdevcertacq.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMDEVCERTACQ_H__
#define __DRMDEVCERTACQ_H__

ENTER_PK_NAMESPACE;

/**********************************************************************
** Function:    DRM_DevCert_ProcessResponse
** Synopsis:    Process devcert request response received from server
** Arguments:   [pbResponse] -- Response string received from server
**              [cbResponse] -- size of pbResponse in bytes.
**              [pResult] --pointer to DRM_RESULT to get error from server included in response
**              [pcontextCrypto] --pointer to the DRM_CRYPTO_CONTEXT
** Returns:     DRM_SUCCESS on success, or failed with 
**              DRM_E_INVALIDARG,
**              DRM_E_INVALIDDEVICECERTIFICATE.
**
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_DCA_ProcessResponse(
    IN  DRM_BYTE           *pbResponse,
    IN  DRM_DWORD           cbResponse,
    OUT DRM_RESULT         *pResult,
    IN  DRM_CRYPTO_CONTEXT *pcontextCrypto );

/**********************************************************************
** Function:    DRM_DevCert_CreateChallenge
** Synopsis:    Creates a devcert challenge.
** Arguments:   
**              [pdstrDevCertTemplate] -- pointer to Signed DevCert Template drm string
**              [poSignKey] -- pointer to a Bootstrap private key to sign challenge.
**              [pcontextCrypto] -- pointer to DRM_CRYPTO_CONTEXT
**              [pwszUrl] -- user allocated buffer to get URL in WCHAR
**              [pcchUrl] -- pointer to get size of URL. Can be NULL if URL is not required.
**              [pbData] -- user allocated buffer to be used as output buffer
**              [pcbData] -- size of pbData
** Returns:     DRM_SUCCESS on success. On Failure, it returns:
**              DRM_E_INVALIDARG
**              DRM_E_BUFFERTOOSMALL
** Notes:       To get the minimum size required, first call with pbData=NULL and
**              pcbData points to value 0. This will return DRM_E_BUFFERTOOSMALL 
**              and pcbData will point to a value of minimum context size.
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_DCA_CreateChallenge(
    IN const DRM_CONST_STRING   *pdstrDevCertTemplate,
    IN const PRIVKEY            *poSignKey,
    IN       DRM_CRYPTO_CONTEXT *pcontextCrypto, 
       OUT   DRM_WCHAR          *pwszUrl,
    IN OUT   DRM_DWORD          *pcchUrl,
       OUT   DRM_BYTE           *pbData,
    IN OUT   DRM_DWORD          *pcbData );

EXIT_PK_NAMESPACE;

#endif /* __DRMDEVCERTACQ_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmdomainapi.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_DOMAIN_API_H
#define __DRM_DOMAIN_API_H

#include <drmdomainimp.h>

ENTER_PK_NAMESPACE;

/*
** ---------------------------------------
** Domain API functions
** ---------------------------------------
*/
DRM_API DRM_RESULT DRM_CALL Drm_JoinDomain_GenerateChallenge(
    IN DRM_APP_CONTEXT *f_poAppContext,
    IN DRM_DWORD f_dwFlags,
    IN DRM_DOMAIN_ID *f_poDomainID,
    __in_ecount_opt( f_cchFriendlyName ) DRM_CHAR *f_pchFriendlyName,
    IN DRM_DWORD f_cchFriendlyName,
    __in_ecount_opt( f_cchData ) DRM_CHAR *f_pchData,
    IN DRM_DWORD f_cchData,
    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE *f_pbChallenge,
    IN OUT DRM_DWORD *f_pcbChallenge );

DRM_API DRM_RESULT DRM_CALL Drm_JoinDomain_ProcessResponse(
    IN DRM_APP_CONTEXT *f_poAppContext,
    __in_bcount( f_cbResponse ) DRM_BYTE *f_pbResponse,
    IN DRM_DWORD f_cbResponse,
    OUT DRM_RESULT *f_pResult,
    OUT DRM_DOMAIN_ID *f_poDomainID );

DRM_API DRM_RESULT DRM_CALL Drm_LeaveDomain_GenerateChallenge(
    IN DRM_APP_CONTEXT *f_poAppContext,
    IN DRM_DWORD f_dwFlags,
    IN DRM_DOMAIN_ID *f_poDomainID,
    __in_ecount_opt( f_cchData ) DRM_CHAR *f_pchData,
    IN DRM_DWORD f_cchData,
    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE *f_pbChallenge,
    IN OUT DRM_DWORD *f_pcbChallenge );

DRM_API DRM_RESULT DRM_CALL Drm_LeaveDomain_ProcessResponse(
    IN DRM_APP_CONTEXT *f_poAppContext,
    __in_bcount( f_cbResponse ) DRM_BYTE *f_pbResponse,
    IN DRM_DWORD f_cbResponse,
    OUT DRM_RESULT *f_pResult );

DRM_API DRM_RESULT DRM_CALL Drm_DomainCert_Find(
    IN DRM_APP_CONTEXT *f_poAppContext,
    IN DRM_DOMAIN_ID *f_poDomainID,
    __out_bcount_opt( *f_pcbDomainCert ) DRM_BYTE *f_pbDomainCert,
    IN OUT DRM_DWORD *f_pcbDomainCert );

DRM_API DRM_RESULT DRM_CALL Drm_DomainCert_InitEnum(
    IN DRM_APP_CONTEXT *f_poAppContext,
    OUT DRM_DOMAIN_CERT_ENUM_CONTEXT *f_poDomainCertEnumContext );

DRM_API DRM_RESULT DRM_CALL Drm_DomainCert_EnumNext(
    IN DRM_DOMAIN_CERT_ENUM_CONTEXT *f_poDomainCertEnumContext,
    OUT DRM_DWORD *f_pcchDomainCert,
    OUT DRM_DOMAINCERT_INFO *f_poDomainCertInfo );


EXIT_PK_NAMESPACE;

#endif /* __DRM_DOMAIN_API_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmdomainimp.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_DOMAIN_IMP_H
#define __DRM_DOMAIN_IMP_H

ENTER_PK_NAMESPACE;

/* 
** The following constants define the types of custom data that is sent to
** both the domain join and domain leave challenge.
** Any custom data should belong to one and only one of the following types.
**
** NULL custom data.
*/
#define DRM_REGISTER_NULL_DATA            0

/*
** XML segment that contains only the data.
*/
#define DRM_REGISTER_CUSTOM_DATA          1

/*
** XML segment that contains both the DID and the data.
*/
#define DRM_REGISTER_INDIRECT_QUERY_DATA  2

/*
** Structure that encapsulates the information returned by
** domain cert enumeration APIs.
*/
typedef struct __tagDRM_DOMAINCERT_INFO
{
    /* Domain ID. */
    DRM_DOMAIN_ID    m_oDomainID;

    /* Point to a URL in the domain cert. (not used at the moment) */
    DRM_ANSI_STRING  m_dastrURL;

} DRM_DOMAINCERT_INFO;

typedef DRM_DOMAINSTORE_ENUM_CONTEXT DRM_DOMAIN_CERT_ENUM_CONTEXT;

/*
** ---------------------------------------
** Domain implementation API functions
** ---------------------------------------
*/
DRM_API DRM_RESULT DRM_CALL DRM_DOM_GenerateJoinChallenge(
    IN DRM_VOID *f_poOEMContext,
    IN DRM_BB_CONTEXT *f_poBBXContext,
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_DWORD f_dwFlags,
    IN DRM_DOMAIN_ID *f_poDomainID,
    __in_ecount_opt( f_cchFriendlyName ) const DRM_CHAR *f_pchFriendlyName,
    IN DRM_DWORD f_cchFriendlyName,
    __in_bcount_opt( f_cbDeviceCert ) const DRM_BYTE *f_pbDeviceCert,
    IN DRM_DWORD f_cbDeviceCert,
    __in_ecount_opt( f_cchData) const DRM_CHAR *f_pchData,
    IN DRM_DWORD f_cchData,
    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE *f_pbChallenge,
    IN OUT DRM_DWORD *f_pcbChallenge );

DRM_API DRM_RESULT DRM_CALL DRM_DOM_ProcessJoinResponse(
    IN DRM_BB_CONTEXT *f_poBBXContext,
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    __inout_bcount( f_cbResponse ) DRM_BYTE *f_pbResponse,
    IN DRM_DWORD f_cbResponse,
    OUT DRM_RESULT *f_pResult,
    OUT DRM_DOMAIN_ID *f_poDomainID );

DRM_API DRM_RESULT DRM_CALL DRM_DOM_GenerateLeaveChallenge(
    IN DRM_VOID *f_poOEMContext,
    IN DRM_BB_CONTEXT *f_poBBXContext,
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_DWORD f_dwFlags,
    IN DRM_DOMAIN_ID *f_poDomainID,
    __in_bcount_opt( f_cbDeviceCert ) const DRM_BYTE *f_pbDeviceCert,
    IN DRM_DWORD f_cbDeviceCert,
    __in_ecount_opt( f_cchData) const DRM_CHAR *f_pchData,
    IN DRM_DWORD f_cchData,
    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE *f_pbChallenge,
    IN OUT DRM_DWORD *f_pcbChallenge );

DRM_API DRM_RESULT DRM_CALL DRM_DOM_ProcessLeaveResponse(
    __in_bcount( f_cbResponse ) DRM_BYTE *f_pbResponse,
    IN DRM_DWORD f_cbResponse,
    OUT DRM_RESULT *f_pResult,
    IN DRM_BB_CONTEXT *f_pBBXCtx );

DRM_API DRM_RESULT DRM_CALL DRM_DOM_FindCert(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_DOMAIN_ID *f_poDomainID,
    __out_bcount_opt( *f_pcbDomainCert ) DRM_BYTE *f_pbDomainCert,
    IN OUT DRM_DWORD *f_pcbDomainCert );

DRM_API DRM_RESULT DRM_CALL DRM_DOM_InitCertEnum(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    OUT DRM_DOMAIN_CERT_ENUM_CONTEXT *f_poDomainCertEnumContext );

DRM_API DRM_RESULT DRM_CALL DRM_DOM_EnumNextCert(
    IN DRM_DOMAIN_CERT_ENUM_CONTEXT *f_poDomainCertEnumContext,
    OUT DRM_DWORD *f_pcchDomainCert,
    OUT DRM_DOMAINCERT_INFO *f_poDomainCertInfo );


EXIT_PK_NAMESPACE;

#endif /* __DRM_DOMAIN_IMP_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmdomainkeyxmrparser.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMDOMAINKEYXMRPARSER_H__
#define __DRMDOMAINKEYXMRPARSER_H__

ENTER_PK_NAMESPACE;

#define DRM_DOMKEYXMR_HEADER_CONSTANT 0x444b4559 /* DKEY */
#define DRM_DOMKEYXMR_HEADER_VERSION  1

#define DRM_DOMKEYXMR_SESSIONKEY_ENCTYPE_ECCP256 1

#define DRM_DOMKEYXMR_OBJTYPE_PRIVKEYCONTAINER  0x500
#define DRM_DOMKEYXMR_OBJTYPE_ACCOUNTID         0x501
#define DRM_DOMKEYXMR_OBJTYPE_NONCE             0x502
#define DRM_DOMKEYXMR_OBJTYPE_SESSIOINKEY       0x503
#define DRM_DOMKEYXMR_OBJTYPE_PRIVKEY           0x504

#define DRM_DOMKEYXMR_PRIVKEYOBJ_MIN_LENGTH 20

#define DRM_DOMKEYXMR_PRIVKEY_TYPE_ECCP256         2
#define DRM_DOMKEYXMR_PRIVKEY_ENCTYPE_AESCTR       2
#define DRM_DOMKEYXMR_PRIVKEY_ENCTYPE_MIXED_AESECB 3

/* 
** XMR strucutre for DomainKeys data
*/
typedef struct _tagDRM_DOMKEYXMR_HEADER
{
    DRM_DWORD  dwConstant;
    DRM_DWORD  dwVersion;
    DRM_DWORD  dwLength;
    DRM_DWORD  dwSignedLength;
} DRM_DOMKEYXMR_HEADER;

typedef struct _tagDRM_DOMKEYXMR_SESSIONKEY
{
    DRM_WORD   wFlags;
    DRM_WORD   wType;
    DRM_DWORD  dwLength;
    DRM_WORD   wKeyType;
    DRM_WORD   wEncryptionType;
    DRM_DWORD  dwKeyLength;
    DRM_BYTE  *pbData;
} DRM_DOMKEYXMR_SESSIONKEY;

typedef struct _tagDRM_DOMKEYXMR_PRIVKEYCONTAINER
{
    DRM_WORD  wFlags;
    DRM_WORD  wType;
    DRM_DWORD dwLength;
} DRM_DOMKEYXMR_PRIVKEYCONTAINER;

typedef struct _tagDRM_DOMKEYXMR_PRIVKEY
{
    DRM_WORD  wFlags;
    DRM_WORD  wType;
    DRM_DWORD dwLength;
    DRM_DWORD dwRevision;
    DRM_WORD  wKeyType;
    DRM_WORD  wEncryptionType;
    DRM_DWORD dwKeyLength;
    DRM_BYTE *pbData;
} DRM_DOMKEYXMR_PRIVKEY;

/*
** ---------------------------------------
** DomainKey XMR Parser implementation API functions
** ---------------------------------------
*/

DRM_API DRM_RESULT DRM_CALL DRM_DOMKEYXMR_GetHeader(
   __in_bcount(f_cbData) DRM_BYTE  *f_pbData,
   __in                  DRM_DWORD  f_cbData,
   __inout_ecount(1)     DRM_DWORD *f_pbOffset,
   __inout_ecount(1)     DRM_DOMKEYXMR_HEADER  *f_poHeader);

DRM_API DRM_RESULT DRM_CALL DRM_DOMKEYXMR_GetSessionKey(
   __in_bcount(f_cbData) DRM_BYTE  *f_pbData,
   __in                  DRM_DWORD  f_cbData,
   __inout_ecount(1)     DRM_DWORD *f_pbOffset,
   __inout_ecount(1)     DRM_DOMKEYXMR_SESSIONKEY  *f_poKeyObj);

DRM_API DRM_RESULT DRM_CALL DRM_DOMKEYXMR_GetPrivKeyContainer(
   __in_bcount(f_cbData) DRM_BYTE  *f_pbData,
   __in                  DRM_DWORD  f_cbData,
   __inout_ecount(1)     DRM_DWORD *f_pbOffset,
   __inout_ecount(1)     DRM_DOMKEYXMR_PRIVKEYCONTAINER  *f_poKeyContainer);

DRM_API DRM_RESULT DRM_CALL DRM_DOMKEYXMR_GetPrivkey(
   __in_bcount(f_cbData) DRM_BYTE  *f_pbData,
   __in                  DRM_DWORD  f_cbData,
   __inout_ecount(1)     DRM_DWORD *f_pbOffset,
   __inout_ecount(1)     DRM_DOMKEYXMR_PRIVKEY *f_poKeyObj);

EXIT_PK_NAMESPACE;

#endif /* __DRMDOMAINKEYXMRPARSER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmdomainstore.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_DOMAIN_STORE_H
#define __DRM_DOMAIN_STORE_H

#include <drmdatastore.h>

ENTER_PK_NAMESPACE;

/* The context of the domain store. */
typedef struct _tagDomainStoreContextPrivate
{
    /* Pointer to the underlying DST. */
    DRM_DST *m_poDST;

    /* The underlying DST namespace context. */
    DRM_DST_NAMESPACE_CONTEXT m_oDSTNameSpaceContext;

    /* The underlying DST slot context. */
    DRM_DST_SLOT_CONTEXT m_oDSTSlotContext;

    /* Flag indicating whether the context has been initialized. */
    DRM_BOOL m_fInited;
} DRM_DOMAINSTORE_CONTEXT_PRIVATE;

/* The context of the domain store in the form of a BLOB. */
typedef struct __tagDRM_DOMAINSTORE_CONTEXT
{
    DRM_BYTE rgbOpaqueData [ __CB_DECL( SIZEOF( DRM_DOMAINSTORE_CONTEXT_PRIVATE ) ) ];
} DRM_DOMAINSTORE_CONTEXT;

/* The enumeration context of the domain store. */
typedef struct __tagDRM_DOMAINSTORE_ENUM_CONTEXT
{
    /* The underlying domain store. */
    DRM_DST *m_poDomainStore;

    /* The underlying DST enumeration context. */
    DRM_DST_ENUM_CONTEXT m_oDSTEnumContext;

    /* The underlying DST slot context. */
    DRM_DST_SLOT_CONTEXT m_oDSTSlotContext;

    /*
    ** Flag indicating whether domain certificates
    ** or domain private keys to be enumerated.
    */
    DRM_BOOL m_fCert;

    /* Flag indicating whether the context has been initialized. */
    DRM_BOOL m_fInited;
} DRM_DOMAINSTORE_ENUM_CONTEXT;

DRM_API DRM_RESULT DRM_CALL DRM_DOMST_OpenStore(
    IN  DRM_DST                 *f_pDatastore,
    OUT DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext );


DRM_API DRM_RESULT DRM_CALL DRM_DOMST_CloseStore(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext );


DRM_API DRM_RESULT DRM_CALL DRM_DOMST_AddCert(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_GUID *f_poAccountID,
    IN DRM_GUID *f_poServiceID,
    __in_bcount( f_cbCert ) DRM_BYTE *f_pbCert,
    IN DRM_DWORD f_cbCert );


DRM_API DRM_RESULT DRM_CALL DRM_DOMST_GetCert(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_GUID *f_poAccountID,
    OUT DRM_GUID *f_poServiceID,
    __out_bcount_opt( *f_pcbCert ) DRM_BYTE *f_pbCert,
    IN OUT DRM_DWORD *f_pcbCert );


DRM_API DRM_RESULT DRM_CALL DRM_DOMST_DeleteCert(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_GUID *f_poAccountID );


DRM_API DRM_RESULT DRM_CALL DRM_DOMST_InitEnumCert(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    OUT DRM_DOMAINSTORE_ENUM_CONTEXT *f_poDomainStoreEnumContext );


DRM_API DRM_RESULT DRM_CALL DRM_DOMST_EnumNextCert(
    IN DRM_DOMAINSTORE_ENUM_CONTEXT *f_poDomainStoreEnumContext,
    OUT DRM_GUID *f_poAccountID,
    OUT DRM_GUID *f_poServiceID,
    OUT DRM_DST_SLOT_HINT *f_poSlotHint,
    OUT DRM_DWORD *f_pcbData );


DRM_API DRM_RESULT DRM_CALL DRM_DOMST_AddKey(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_GUID *f_poAccountID,
    IN DRM_DWORD f_dwRevision,
    __in_bcount( f_cbKey ) DRM_BYTE *f_pbKey,
    IN DRM_DWORD f_cbKey );


DRM_API DRM_RESULT DRM_CALL DRM_DOMST_GetKey(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_GUID *f_poAccountID,
    IN DRM_DWORD f_dwRevision,
    __out_bcount_opt( *f_pcbKey ) DRM_BYTE *f_pbKey,
    IN OUT DRM_DWORD *f_pcbKey );


DRM_API DRM_RESULT DRM_CALL DRM_DOMST_DeleteKey(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_GUID *f_poAccountID,
    IN DRM_DWORD f_dwRevision );


DRM_API DRM_RESULT DRM_CALL DRM_DOMST_DeleteKeys(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    IN DRM_GUID *f_poAccountID );


DRM_API DRM_RESULT DRM_CALL DRM_DOMST_InitEnumKey(
    IN DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    OUT DRM_DOMAINSTORE_ENUM_CONTEXT *f_poDomainStoreEnumContext );


DRM_API DRM_RESULT DRM_CALL DRM_DOMST_EnumNextKey(
    IN DRM_DOMAINSTORE_ENUM_CONTEXT *f_poDomainStoreEnumContext,
    OUT DRM_GUID *f_poAccountID,
    OUT DRM_DWORD *f_pdwRevision,
    OUT DRM_DST_SLOT_HINT *f_poSlotHint,
    OUT DRM_DWORD *f_pcbData );


EXIT_PK_NAMESPACE;

#endif /* __DRM_DOMAIN_STORE_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmdomainconstants.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_DOMAIN_CONSTANTS_H
#define __DRM_DOMAIN_CONSTANTS_H

ENTER_PK_NAMESPACE;

/* 
** ---------------------------------------------------------------------
** XML strings used in the construction of domain join challenge
** ---------------------------------------------------------------------
*/
extern const DRM_ANSI_CONST_STRING g_dastrDomJoinRootTag;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinVersionTag;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinChallenge1Tag;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinChallenge2Tag;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinDomainTag;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinDataTag;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinServiceIDTag;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinAccountIDTag;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinRevisionTag;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinFriendlyNameTag;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinCustomDataTag;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinCertificateChainTag;


extern const DRM_ANSI_CONST_STRING g_dastrDomJoinRootAttribName;
extern const DRM_ANSI_CONST_STRING g_dastrDomJoinRootAttribValue;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinChallenge2AttribName;
extern const DRM_ANSI_CONST_STRING g_dastrDomJoinChallenge2AttribValue;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinDomainAttrib1Name;
extern const DRM_ANSI_CONST_STRING g_dastrDomJoinDomainAttrib1Value;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinDomainAttrib2Name;
extern const DRM_ANSI_CONST_STRING g_dastrDomJoinDomainAttrib2Value;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinCertificateChainAttribName;
extern const DRM_ANSI_CONST_STRING g_dastrDomJoinCertificateChainAttribValue;

extern const DRM_ANSI_CONST_STRING g_dastrDomainJoinVersion;



/*
** -----------------------------------------------------------------------
** XML strings used in the construction of domain leave challenge
** -----------------------------------------------------------------------
*/
extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveRootTag;

extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveVersionTag;

extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveChallenge1Tag;

extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveChallenge2Tag;

extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveDomainTag;

extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveDataTag;

extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveAccountIDTag;

extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveCustomDataTag;

extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveCertificateChainTag;


extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveRootAttribName;
extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveRootAttribValue;

extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveChallenge2AttribName;
extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveChallenge2AttribValue;

extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveDomainAttrib1Name;
extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveDomainAttrib1Value;

extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveDomainAttrib2Name;
extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveDomainAttrib2Value;

extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveCertificateChainAttribName;
extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveCertificateChainAttribValue;

extern const DRM_ANSI_CONST_STRING g_dastrDomainLeaveVersion;



/* 
** ---------------------------------------------------------------
** XML strings used in the parsing of domain join response
** ---------------------------------------------------------------
*/
extern const DRM_ANSI_CONST_STRING g_dastrDomJoinResponsePath;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinDataPath;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinSignaturePath;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinDataPath;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinDomainPath;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinEncryptedDataPath;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinKeyInfoPath;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinServiceIDPath;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinAccountIDPath;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinRevisionPath;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinCertificateChainPath;

extern const DRM_ANSI_CONST_STRING g_dastrDomJoinDomainKeysPath;





/*
** -----------------------------------------------------------------
** XML strings used in the parsing of domain leave response
** -----------------------------------------------------------------
*/
extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveDomainPath;

extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveAccountIDPath;

extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveSignaturePath;



/* 
** ----------------------------------------------
** XML strings used in the parsing of custom data
** ----------------------------------------------
*/
extern const DRM_ANSI_CONST_STRING g_dastrDomJoinCustomDataPath;

extern const DRM_ANSI_CONST_STRING g_dastrDomLeaveCustomDataPath;

EXIT_PK_NAMESPACE;

#endif /* __DRM_DOMAIN_CONSTANTS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmdevstore.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef DRMDEVSTORE_H
#define DRMDEVSTORE_H

#include <drmcommon.h>
#include <oemcontextsizes.h>

/* Maximum number of seconds that can pass between the last validation time and a license request */
#define DRM_DEVICESTORE_VALIDATION_TIMEOUT        (48 * 60 * 60)

ENTER_PK_NAMESPACE;

DRM_API DRM_BOOL DRM_CALL DRM_DeviceStore_HasTimedOut(
    __in_opt    DRM_VOID    *f_pOEMContext,
    __in        DRMFILETIME *f_pftStartTime,
    __in const  DRM_DWORD    f_dwTimeoutSeconds
);

DRM_API DRM_RESULT DRM_CALL DRM_DeviceStore_MarkDeviceAsValid(
    __in_opt    DRM_VOID            *f_pOEMContext,
    __in const  OEM_DEVICE_HANDLE    f_hDeviceHandle
);

DRM_API DRM_BOOL DRM_CALL DRM_DeviceStore_IsDeviceValid(
    __in_opt   DRM_VOID           *f_pOEMContext,
    __in const OEM_DEVICE_HANDLE   f_hDeviceHandle
);

DRM_API DRM_VOID DRM_CALL DRM_DeviceStore_FreeDevice(
    __in const   OEM_DEVICE_HANDLE            f_hDeviceHandle
);

DRM_API DRM_RESULT DRM_CALL DRM_DeviceStore_UnRegisterDevice(
    __inout       OEM_DEVICESTORE_CONTEXT *f_pOemDevStoreContext,
    __in const    DRM_BYTEBLOB             f_DeviceCertificate,
    __in const    DRM_ID                   f_DeviceSerialNumber
);

DRM_API DRM_RESULT DRM_CALL DRM_DeviceStore_GetFirstDevice(
    __inout OEM_DEVICESTORE_CONTEXT *       f_pOemDevStoreContext,
    __out   OEM_DEVICE_HANDLE       * const f_phDeviceHandle
);

DRM_API DRM_RESULT DRM_CALL DRM_DeviceStore_GetNextDevice(
    __inout OEM_DEVICESTORE_CONTEXT *       f_pOemDevStoreContext,
    __out   OEM_DEVICE_HANDLE       * const f_phDeviceHandle
);

DRM_API DRM_RESULT DRM_CALL DRM_DeviceStore_GetDeviceByID(
    __inout       OEM_DEVICESTORE_CONTEXT *       f_pOemDevStoreContext,
    __in const    DRM_BYTEBLOB                    f_DeviceCertificate,
    __in const    DRM_ID                          f_DeviceSerialNumber,
    __out         OEM_DEVICE_HANDLE       * const f_phDeviceHandle
);

DRM_API DRM_RESULT DRM_CALL DRM_DeviceStore_GetDeviceInfo(
    __in const                                OEM_DEVICE_HANDLE         f_hDeviceHandle,
    __out_bcount_opt(*f_pcbDeviceCertificate) DRM_BYTE          * const f_pbDeviceCertificate,
    __inout                                   DRM_DWORD         * const f_pcbDeviceCertificate,
    __out                                     DRM_ID            * const f_pDeviceSerialNumber
);

DRM_API DRM_RESULT DRM_CALL DRM_DeviceStore_GetDeviceAttr(
    __in const                        OEM_DEVICE_HANDLE         f_hDeviceHandle,
    __in const                        DRM_BYTEBLOB              f_AttrName,
    __out_bcount_opt(*f_pcbAttrValue) DRM_BYTE          * const f_pbAttrValue,
    __inout                           DRM_DWORD         * const f_pcbAttrValue
);

DRM_API DRM_RESULT DRM_CALL DRM_DeviceStore_GetDeviceAttrCount(
    __in const  OEM_DEVICE_HANDLE            f_hDeviceHandle,
    __out       DRM_DWORD            * const f_pdwAttrCount
);

DRM_API DRM_RESULT DRM_CALL DRM_DeviceStore_GetDeviceAttrByIndex(
    __in const                        OEM_DEVICE_HANDLE         f_hDeviceHandle,
    __in const                        DRM_DWORD                 f_dwAttrIndex,
    __out_bcount_opt(*f_pcbAttrName)  DRM_BYTE          * const f_pbAttrName,
    __inout                           DRM_DWORD         * const f_pcbAttrName,
    __out_bcount_opt(*f_pcbAttrValue) DRM_BYTE          * const f_pbAttrValue,
    __inout                           DRM_DWORD         * const f_pcbAttrValue
);

DRM_API DRM_RESULT DRM_CALL DRM_DeviceStore_SetDeviceAttr(
    __in const   OEM_DEVICE_HANDLE f_hDeviceHandle,
    __in const   DRM_BYTEBLOB      f_AttrName,
    __in const   DRM_BYTEBLOB      f_AttrValue
);

EXIT_PK_NAMESPACE;

#endif   /* DRMDEVSTORE_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmeccp256.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#ifndef __ECC_P256_H__
#define __ECC_P256_H__ 1

#include <drmcommon.h>
#include <ecurve.h>

ENTER_PK_NAMESPACE;

/*
** P256 integer size defines
*/
#define ECC_P256_INTEGER_SIZE_IN_BITS      ( 256 )
#define ECC_P256_INTEGER_SIZE_IN_BYTES     ( 32 )
#define ECC_P256_INTEGER_SIZE_IN_DIGITS    ( BITS_TO_DIGITS( ECC_P256_INTEGER_SIZE_IN_BITS ) )
#define ECC_P256_INTEGER_SIZE_IN_ECAFFINES ( ECC_P256_INTEGER_SIZE_IN_BYTES / SIZEOF( digit_t ) )
#define ECC_P256_PRIVKEY_SIZE_IN_BITS      ( ECC_P256_INTEGER_SIZE_IN_BITS ) /* privkeys are 256bit integers */
#define ECC_P256_PRIVKEY_SIZE_IN_BYTES     ( ECC_P256_INTEGER_SIZE_IN_BYTES )

/*
** P256 point size defines
*/
#define ECC_P256_POINT_SIZE_IN_BITS        ( 2 * ECC_P256_INTEGER_SIZE_IN_BITS )
#define ECC_P256_POINT_SIZE_IN_BYTES       ( 2 * ECC_P256_INTEGER_SIZE_IN_BYTES )
#define ECC_P256_POINT_SIZE_IN_DIGITS      ( BITS_TO_DIGITS( ECC_P256_POINT_SIZE_IN_BITS ) )
#define ECC_P256_POINT_SIZE_IN_ECAFFINES   ( 2 * ( ECC_P256_INTEGER_SIZE_IN_BYTES / SIZEOF( digit_t ) ) ) 
#define ECC_P256_PUBKEY_SIZE_IN_BITS       ( ECC_P256_POINT_SIZE_IN_BITS ) /* pubkeys are EC Points */


/*
** P256 integer size defines
*/
#define ECC_P256_CIPHERTEXT_SIZE_IN_BYTES  ( 2 * ECC_P256_POINT_SIZE_IN_BYTES )
#define ECC_P256_PLAINTEXT_SIZE_IN_BYTES   ( ECC_P256_INTEGER_SIZE_IN_BYTES )
#define ECDSA_P256_SIGNATURE_SIZE_IN_BYTES ( 2 * ECC_P256_INTEGER_SIZE_IN_BYTES )

#define ECC_POINT_ADDITION    ( ( DRM_INT ) 1 )
#define ECC_POINT_SUBTRACTION ( ( DRM_INT ) -1 )

/*
** Supplied temps needed for certain P256 EC functions. Note these are upper bounds,
** some operations may not require as large of temps, this is a potential optimization.
*/
#define ECC_P256_LNGRED2          ( ( ECC_P256_INTEGER_SIZE_IN_DIGITS + 1 ) / 2 )
#define ECC_P256_NDIGTEMPS        ( ( 19 * ECC_P256_INTEGER_SIZE_IN_DIGITS ) + 6 )
#define ECC_P256_VERIFY_TEMPS     ( ECC_P256_NDIGTEMPS )
#define ECC_P256_SIGN_TEMPS       ( ECC_P256_NDIGTEMPS )
#define ECC_P256_ENCRYPT_TEMPS    ( ECC_P256_NDIGTEMPS )
#define ECC_P256_POINTMUL_TEMPS   ( ECC_P256_NDIGTEMPS )
#define ECC_P256_POINTADD_TEMPS   ( ECC_P256_NDIGTEMPS )
#define ECC_P256_INTEGERADD_TEMPS ( ECC_P256_NDIGTEMPS )
#define ECC_P256_DECRYPT_TEMPS    ( ECC_P256_NDIGTEMPS )
#define ECC_P256_GENKEYPAIR_TEMPS ( ECC_P256_NDIGTEMPS )

/*
** Struct Defines for ECC P256 and the AES XMR struct that will be encrypted and decrypted by it.
*/
typedef struct __tagCIPHERTEXT_P256_2POINTS
{
    DRM_BYTE m_rgbC1[ __CB_DECL( ECC_P256_POINT_SIZE_IN_BYTES ) ];
    DRM_BYTE m_rgbC2[ __CB_DECL( ECC_P256_POINT_SIZE_IN_BYTES ) ];
} CIPHERTEXT_P256_2POINTS;

typedef struct __tagPUBKEY_P256
{
    DRM_BYTE m_rgbPubkey[ __CB_DECL( ECC_P256_POINT_SIZE_IN_BYTES ) ];
} PUBKEY_P256;

typedef struct __tagPRIVKEY_P256
{
    DRM_BYTE m_rgbPrivkey[ __CB_DECL( ECC_P256_INTEGER_SIZE_IN_BYTES ) ];
} PRIVKEY_P256;

typedef struct __tagCIPHERTEXT_P256
{
    DRM_BYTE m_rgbCiphertext [__CB_DECL( ECC_P256_CIPHERTEXT_SIZE_IN_BYTES ) ];
} CIPHERTEXT_P256;

typedef struct __tagSIGNATURE_P256
{
    DRM_BYTE m_rgbSignature[ __CB_DECL( ECC_P256_POINT_SIZE_IN_BYTES ) ];
} SIGNATURE_P256;

typedef struct __tagPLAINTEXT_P256
{
    /*
    ** HMAC key goes in 1st half, content key goes in 2nd half.
    */
    DRM_BYTE m_rgbPlaintext[ __CB_DECL( ECC_P256_PLAINTEXT_SIZE_IN_BYTES ) ];
} PLAINTEXT_P256;

/*
** Function Protos
*/

DRM_API DRM_RESULT DRM_CALL DRM_ECC_GenerateHMACKey_P256(
    __inout PLAINTEXT_P256   *f_pKeys, 
    __inout struct bigctx_t  *f_pBigCtx );

DRM_API DRM_RESULT DRM_CALL DRM_ECC_CanMapToPoint_P256(
    __in_ecount( ECC_P256_INTEGER_SIZE_IN_DIGITS ) const  digit_t   f_rgdNumber[], 
    __inout                                        struct bigctx_t *f_pBigCtx );

DRM_API DRM_RESULT DRM_CALL DRM_ECC_MapX2PointP256(
    __in_ecount(ECC_P256_INTEGER_SIZE_IN_DIGITS)  digit_t          *f_pX,
    __out_ecount(ECC_P256_INTEGER_SIZE_IN_DIGITS) digit_t          *f_pY,
    __inout_opt                                   digit_t           f_rgdSuppliedTemps[],
    __inout                                struct bigctx_t         *f_pBigCtx
);

DRM_API DRM_RESULT DRM_CALL DRM_ECC_Decrypt_P256(
    __in    const  PRIVKEY_P256    *f_pPrivkey,
    __in    const  CIPHERTEXT_P256 *f_pCiphertext,
    __out          PLAINTEXT_P256  *f_pPlaintext,
    __inout struct bigctx_t        *f_pBigCtx );

DRM_API DRM_RESULT DRM_CALL DRM_ECC_Encrypt_P256( 
    __in    const  PUBKEY_P256      *f_pPubkey,
    __in    const  PLAINTEXT_P256   *f_pPlaintext,
    __out          CIPHERTEXT_P256  *f_pCiphertext,
    __inout struct bigctx_t         *f_pBigCtx );

DRM_API DRM_RESULT DRM_CALL DRM_ECC_GenKeyPair_P256( 
    __out          PUBKEY_P256  *f_pPubKey,
    __out          PRIVKEY_P256 *f_pPrivKey,
    __inout struct bigctx_t     *f_pBigCtx );

DRM_API DRM_RESULT DRM_CALL DRM_ECC_GenKeyPairRestrictedPriv_P256( 
    __out          PUBKEY_P256  *f_pPubKey,
    __out          PRIVKEY_P256 *f_pPrivKey,
    __inout struct bigctx_t     *f_pBigCtx );

DRM_API DRM_RESULT DRM_CALL DRM_ECDSA_Sign_P256(
    __in_ecount( f_cbMessageLen ) const  DRM_BYTE         f_rgbMessage[],
    __in                          const  DRM_DWORD        f_cbMessageLen,
    __in                          const  PRIVKEY_P256    *f_pPrivkey,
    __out                                SIGNATURE_P256  *f_pSignature,
    __inout                       struct bigctx_t        *f_pBigCtx );

DRM_API DRM_RESULT DRM_CALL DRM_ECDSA_Verify_P256(
    __in_ecount( __CB_DECL( f_cbMessageLen ) ) const  DRM_BYTE         f_rgbMessage[],
    __in                                       const  DRM_DWORD        f_cbMessageLen,
    __in                                       const  PUBKEY_P256     *f_pPubkey,
    __in                                       const  SIGNATURE_P256  *f_pSignature,
    __inout                                    struct bigctx_t        *f_pBigCtx );

DRM_API DRM_RESULT DRM_CALL Convert_BigEndianBytesToDigits(
  __in_ecount( __CB_DECL( ( f_cBits + 7 ) / 8 ) ) const DRM_BYTE  f_rgbInBytes[],
  __out_ecount( BITS_TO_DIGITS( f_cBits ) )             digit_t   f_rgdOutDigits[],
  __in                                            const DRM_DWORD f_cBits );

DRM_API DRM_RESULT DRM_CALL Convert_DigitsToBigEndianBytes(
  __in_ecount( BITS_TO_DIGITS( f_cBits ) )          const digit_t   f_rgdInDigits[],
  __out_ecount( __CB_DECL( ( f_cBits + 7 ) / 8 )  )       DRM_BYTE  f_rgbOutBytes[],
  __in                                              const DRM_DWORD f_cBits );

DRM_API DRM_RESULT DRM_CALL Convert_P256_PointToPlaintext(
    __in_ecount( ECC_P256_POINT_SIZE_IN_ECAFFINES ) const  digit_t          f_rgptPoint[],
    __in_ecount( 1 )                                const  ecurve_t        *f_pEcurve,
    __out_ecount( 1 )                                      PLAINTEXT_P256  *f_pPlaintext );


DRM_API DRM_RESULT DRM_CALL Convert_P256_BigEndianBytesToPoint(
    __in_ecount( __CB_DECL( ECC_P256_POINT_SIZE_IN_BYTES ) ) const  DRM_BYTE   f_rgbInBytes[], 
    __in_ecount( 1 )                                         const  ecurve_t  *f_pEcurve,    
    __out_ecount( ECC_P256_POINT_SIZE_IN_ECAFFINES )                digit_t    f_rgptOutPoint[],
    __inout                                                  struct bigctx_t  *f_pBigCtx );

DRM_API DRM_RESULT DRM_CALL Convert_P256_BigEndianBytesToDigits(
    __in_ecount( __CB_DECL( ECC_P256_INTEGER_SIZE_IN_BYTES ) ) const DRM_BYTE f_rgdInBytes[], 
    __out_ecount( ECC_P256_INTEGER_SIZE_IN_DIGITS )                  digit_t  f_rgbOutDigits[] );

DRM_API DRM_RESULT DRM_CALL Convert_P256_BigEndianBytesToDigitsModOrder(
    __in_ecount( ECC_P256_INTEGER_SIZE_IN_BYTES )   const DRM_BYTE  f_rgbBytes[],
    __in_ecount( 1 )                                const ecurve_t *f_pEcurve,
    __out_ecount( ECC_P256_INTEGER_SIZE_IN_DIGITS )       digit_t   f_rgdDigits[] );

DRM_API DRM_RESULT DRM_CALL Convert_P256_ModularIntToDigitsModOrder(
    __in_ecount( ECC_P256_INTEGER_SIZE_IN_ECAFFINES ) const  digit_t   f_rgecInModularInt[],
    __in_ecount( 1 )                                  const  ecurve_t *f_pEcurve,
    __out_ecount( ECC_P256_INTEGER_SIZE_IN_DIGITS )          digit_t   f_rgbOutDigits[] );

DRM_API DRM_RESULT DRM_CALL Convert_P256_DigitsToBigEndianBytes(
    __in_ecount( ECC_P256_INTEGER_SIZE_IN_DIGITS )              const digit_t  f_rgdInDigits[], 
    __out_ecount( __CB_DECL( ECC_P256_INTEGER_SIZE_IN_BYTES ) )       DRM_BYTE f_rgbOutBytes[] );


EXIT_PK_NAMESPACE;

#endif /* end ifndef __ECC_P256_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmeccp160.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMECCP160_H__
#define __DRMECCP160_H__

#include <drmstkalloc.h>

ENTER_PK_NAMESPACE;

/* The following sizes are in BYTEs */
#define DRM_ECC160_PUBLIC_KEY_LEN   40
#define DRM_ECC160_PRIVATE_KEY_LEN  20
#define DRM_ECC160_PLAINTEXT_LEN    16
#define DRM_ECC160_CIPHERTEXT_LEN   80
#define DRM_ECC160_SIGNATURE_LEN    40
#define DRM_ECC160_SIGNATURE_B64LEN CCH_BASE64_EQUIV_SAL(DRM_ECC160_SIGNATURE_LEN)


#define PKSYMM_KEY_LEN_DRMV2    7
#define PKSYMM_ALG_TYPE_RC4        1

#if ( DRM_SUPPORT_WMDRMNET )
#define DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE ( 5500 + 4100 )
#else
#define DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE ( 5500 )
#endif

/* This is size for PK_DATA structure defined in pkcrypto file.
   This size of structure on x86 is 3036.
   I choose 3100 to allow larger size for different architecture
*/
#define DRM_PK_DATA_SIZE                          3200

#define LNGQDW 5
#define LNGQ DWORDS_TO_DIGITS(LNGQDW)
#define QBITS (LNGQDW * DWORD_BITS)

/*
** Length of ECC integer types in 32 bit values.
** For ECC 160 - lenght is 5 32 bit dwords.
** For ECC 256 - lenght is 8 32 bit dwords.
*/
#define LNGQ_MODULO_5  5
#define LNGQ_MODULO_8  8

#define DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE  ( DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE + SIZEOF( DRM_STACK_ALLOCATOR_CONTEXT ) + DRM_PK_DATA_SIZE + SIZEOF( DRM_DWORD ) + SIZEOF( DRM_VOID* ) ) 

typedef DRM_DWORD_ALIGN struct __tagPUBKEY
{
    DRM_BYTE y[ __CB_DECL(DRM_ECC160_PUBLIC_KEY_LEN) ];
} PUBKEY;

typedef DRM_DWORD_ALIGN struct __tagPRIVKEY
{
    DRM_BYTE x[ __CB_DECL(DRM_ECC160_PRIVATE_KEY_LEN) ];
} PRIVKEY;

typedef struct {
    PUBKEY pk;
    DRM_BYTE version[__CB_DECL(VERSION_LEN)];  
} PKV;

/********************************************************************* 
** Structure for keeping of private key for signing of header. 
** The structure DRM_PRIVATE_KEY keeps ECC private key and
** enumeration value that corresponds to type of the key.
**   
**   privKey  -  The private key for signing of the header:
**   
**   keyType  - Type of the key
**   
**   Currently we have only one type of the key - ECC key.
**   In future new types will be added and new data for private keys
**********************************************************************/
typedef enum { DRM_PRIVATE_KEY_ECC } DRM_PRIVATE_KEY_TYPE;

typedef struct __tagDRM_PRIVATE_KEY

{ 
    DRM_PRIVATE_KEY_TYPE keyType;
    PRIVKEY              privKey;
} DRM_PRIVATE_KEY;


typedef struct {
    PKV pk;  /* pk.version indicates the pubkey needed to verify. */
    DRM_BYTE sign[__CB_DECL(DRM_ECC160_SIGNATURE_LEN)];
} PKCERT;


/* */
/*  A set of old keys. */
/* */
typedef struct __tagDRMKEYPAIR
{
    PRIVKEY PrivKey;     /*  an old private key */
    PUBKEY  PubKey;      /*  an old public key */
} DRMKEYPAIR;


/*********************************************************************
**
**  Function:  DRM_ECC_GenKeyPair_P160
**
**  Synopsis:  Generate a matched public and private key pair
**
**  Arguments:  
**     [f_pContext] -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE
**     [f_ppubkey]  -- New public key
**     [f_pprivkey] -- New private key
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_ECC_GenKeyPair_P160( 
    IN     DRM_VOID *f_pContext,
       OUT PUBKEY   *f_ppubkey,
       OUT PRIVKEY  *f_pprivkey );

/*********************************************************************
**
**  Function:  DRM_ECC_Encrypt_P160
**
**  Synopsis:  Encrypt a block of data with a given public key.
**
**  Arguments:  
**     [f_pContext] -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE
**     [f_ppubkey]  -- Public key to encrypt with
**     [f_rgbIn]    -- Data to be encrypted
**     [f_rgbOut]   -- Buffer to hold the encrypted data value.
**
**  Notes:  Data is not encrpyted in place.  It is put in the rgbOut buffer.
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_ECC_Encrypt_P160( 
    IN        DRM_VOID *f_pContext, 
    IN  const PUBKEY   *f_ppubkey,
    __in_bcount( DRM_ECC160_PLAINTEXT_LEN ) const DRM_BYTE  f_rgbIn [__CB_DECL(DRM_ECC160_PLAINTEXT_LEN) ],
    __out_bcount( DRM_ECC160_CIPHERTEXT_LEN ) DRM_BYTE  f_rgbOut[__CB_DECL(DRM_ECC160_CIPHERTEXT_LEN)] );


/*********************************************************************
**
**  Function:  DRM_ECC_Decrypt_P160
**
**  Synopsis:  
**
**  Arguments:  
**     [f_pContext] -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE
**     [f_pprivkey] -- Private key to decrypt with
**     [f_rgbIn]    -- Encrypted bytes that are to be decrypted
**     [f_rgbOut]   -- Clear text result
**
**  Notes:  Data is not decrpyted in place.  It is put in the rgbOut buffer.
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_ECC_Decrypt_P160(
    IN        DRM_VOID *f_pContext,
    IN  const PRIVKEY  *f_pprivkey,
    __in_bcount( DRM_ECC160_CIPHERTEXT_LEN ) const DRM_BYTE  f_rgbIn [__CB_DECL(DRM_ECC160_CIPHERTEXT_LEN)],
    __out_bcount( DRM_ECC160_PLAINTEXT_LEN ) DRM_BYTE  f_rgbOut[__CB_DECL(DRM_ECC160_PLAINTEXT_LEN) ] );


/*********************************************************************
**
**  Function:  DRM_ECC_Sign_P160
**
**  Synopsis:  Generate a digital signature with a private key
**
**  Arguments:  
**     [f_pContext]     -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE
**     [f_privkey]      -- Private key to create a signature with
**     [f_pbData]       -- Array of bytes to create a signature over
**     [f_cbData]       -- Length of pbBuffer in bytes
**     [f_rgbSignature] -- Buffer to hold result signature
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_ECC_Sign_P160(
    IN       DRM_VOID  *f_pContext,
    IN const PRIVKEY   *f_privkey,
    __out_bcount( f_cbData ) const DRM_BYTE  *f_pbData,
    IN       DRM_DWORD  f_cbData,
    __out_bcount( DRM_ECC160_SIGNATURE_LEN ) DRM_BYTE   f_rgbSignature[__CB_DECL(DRM_ECC160_SIGNATURE_LEN)] );

/*********************************************************************
**
**  Function:  DRM_ECC_Verify_P160
**
**  Synopsis:  Verify a digital signature created by DRM_ECC_Sign_P160.
**
**  Arguments:  
**     [f_pContext]     -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE
**     [f_ppubkey]      -- Pubkey to check the signature with
**     [f_pbData]       -- Data buffer that the signature was created over
**     [f_cbData]       -- Length of pbBuffer in bytes
**     [f_rgbSignature] -- The signature to verify
**
**  Returns:  TRUE if the signature verified correctly.  FALSE is it didn't
**
*********************************************************************/
DRM_API DRM_BOOL DRM_CALL DRM_ECC_Verify_P160( 
    IN       DRM_VOID  *f_pContext,
    IN const PUBKEY    *f_ppubkey, 
    __in_bcount( f_cbData ) const DRM_BYTE  *f_pbData, 
    IN       DRM_DWORD  f_cbData, 
    __in_bcount( DRM_ECC160_SIGNATURE_LEN ) const DRM_BYTE   f_rgbSignature[__CB_DECL(DRM_ECC160_SIGNATURE_LEN)] );

/*********************************************************************
**
**  Function:  DRM_ECC_ThreadUnSafePKInit, DRM_ECC_ThreadSafeInit
**
**  Synopsis:  Initializes DRMBIGNUM_CONTEXT_STRUCT
**
**  Arguments:  
**     [f_pContext]     -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE

**  Returns:  DRM_SUCCESS if context is initialized.
**
*********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_ECC_ThreadUnSafePKInit( 
    IN OUT  DRM_VOID* f_pContext,
    IN      DRM_VOID* f_pOEMContext );

DRM_VOID DRM_CALL DRM_RSA_PKInit(
    IN OUT DRM_VOID *f_pContext );

DRM_VOID DRM_CALL DRM_RSA_PKInitWithSize(
    IN OUT DRM_VOID *f_pContext,
    IN     DRM_DWORD f_dwSize );

DRM_API DRM_RESULT DRM_CALL DRM_ECC_ThreadSafeInit( 
    IN OUT  DRM_VOID* f_pContext,
    IN      DRM_VOID* f_pOEMContext );



#if DRM_THREAD_SAFE
#define DRM_ECC_PKInit( pContext, pOEMContext  ) DRM_ECC_ThreadSafeInit( pContext, pOEMContext )
#else
#define DRM_ECC_PKInit( pContext, pOEMContext  ) DRM_ECC_ThreadUnSafePKInit( pContext, pOEMContext  )
#endif

EXIT_PK_NAMESPACE;

#endif /* __DRMECCP160_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmembeddedstore.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRM_EMBEDDEDSTORE_H__
#define __DRM_EMBEDDEDSTORE_H__

#include <drmdatastore.h>

ENTER_PK_NAMESPACE;

DRM_API DRM_RESULT DRM_CALL DRM_EST_InitializeDST( __out DRM_DST *f_pDst );

DRM_API DRM_RESULT DRM_CALL DRM_EST_Init ( __inout DRM_DST_CONTEXT *f_pContextDST );

DRM_API DRM_RESULT DRM_CALL DRM_EST_Uninit ( __inout DRM_DST_CONTEXT *f_pContextDST );

DRM_API DRM_RESULT DRM_CALL DRM_EST_CreateStore ( 
    __in_opt                           DRM_VOID          *f_pbOEMContext,
    __in_bcount( f_cbStoreData ) const DRM_BYTE          *f_pbStoreData,
    __in                               DRM_DWORD          f_cbStoreData,
    __in                         const DRM_DWORD          f_dwBlockSize,
    __in                               DRM_DST_BLKNUMTYPE f_eBlNumType,
    __in                               DRM_BOOL           f_fTruncateExist,
    __in                         const DRM_DWORD          f_dwInitSizeInKB,
    __inout                            DRM_DST_CONTEXT   *f_pContextDST );

DRM_API DRM_RESULT DRM_CALL DRM_EST_OpenStore ( 
    __in_opt                     DRM_VOID        *f_pOEMContext,
    __in_bcount( f_cbStoreData ) DRM_BYTE        *f_pbStoreData,
    __in                         DRM_DWORD        f_cbStoreData,
    __in                         DRM_DWORD        f_dwGrowBySizeinKB,
    __inout                      DRM_DST_CONTEXT *f_pContextDST );

DRM_API DRM_RESULT DRM_CALL DRM_EST_CloseStore ( __inout DRM_DST_CONTEXT *f_pContextDST );

DRM_API DRM_RESULT DRM_CALL DRM_EST_CommitStore ( __inout DRM_DST_CONTEXT *f_pContextDST );

DRM_API DRM_RESULT DRM_CALL DRM_EST_CleanupStore ( 
    __inout DRM_DST_CONTEXT *f_pContextDST,
    __in    DRM_BOOL         f_fWait );

DRM_API DRM_RESULT DRM_CALL DRM_EST_OpenNamespace ( 
    __inout        DRM_DST_CONTEXT           *f_pContextDST,
    __in    const  DRM_DST_NAMESPACE         *f_pNamespace,
    __in           DRM_DST_OPENMODE           f_eOpenMode,
    __in           DRM_WORD                   f_wMaxNumChildren, 
    __in           DRM_DWORD                  f_dwExpectedSlotSize,
    __out          DRM_DST_NAMESPACE_CONTEXT *f_pContextNS );

DRM_API DRM_RESULT DRM_CALL DRM_EST_DeleteNamespace ( 
    __inout    DRM_DST_CONTEXT   *f_pContextDST,
    __inout    DRM_DST_NAMESPACE *f_pNS,
    __in       DRM_BOOL           f_fWait );

DRM_API DRM_RESULT DRM_CALL DRM_EST_CloseNamespace ( 
    __inout    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS );

DRM_API DRM_RESULT DRM_CALL DRM_EST_CommitNamespace ( 
    __inout    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS );

DRM_API DRM_RESULT DRM_CALL DRM_EST_MakeSlotHint ( 
    __in    DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __out   DRM_DST_SLOT_HINT     *f_pSlotHint );

DRM_API DRM_RESULT DRM_CALL DRM_EST_OpenSlot ( 
    __in       DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
    __in       DRM_DWORD                  f_dwMode,
    __in const DRM_DST_KEY               *f_pKey1,
    __in const DRM_DST_KEY               *f_pKey2,
    __in_opt   DRM_DST_SLOT_HINT         *f_pSlotHint,
    __inout    DRM_DWORD                 *f_pcbSlotSize,
    __out      DRM_DST_SLOT_CONTEXT      *f_pContextSlot );

DRM_API DRM_RESULT DRM_CALL DRM_EST_CloseSlot ( 
    __inout  DRM_DST_SLOT_CONTEXT  *f_pContextSlot );

DRM_API DRM_RESULT DRM_CALL DRM_EST_DeleteSlot ( 
    __in       DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
    __in const DRM_DST_KEY               *f_pKey1,
    __in const DRM_DST_KEY               *f_pKey2,
    __in_opt   DRM_DST_SLOT_HINT         *f_pSlotHint,
    __in       DRM_BOOL                   f_fWait );

DRM_API DRM_RESULT DRM_CALL DRM_EST_InitSlotEnum ( 
    __in           DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
    __in_opt const DRM_DST_KEY               *f_pKey1,
    __in           DRM_DST_LOCKMODE           f_eLockMode,
    __out          DRM_DST_ENUM_CONTEXT      *f_pContextEnum );

DRM_API DRM_RESULT DRM_CALL DRM_EST_SlotEnumNext ( 
    __inout    DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
    __out      DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __out_opt  DRM_DST_KEY           *f_pKey1,
    __out_opt  DRM_DST_KEY           *f_pKey2,
    __out_opt  DRM_DWORD             *f_pcbSize );

DRM_API DRM_RESULT DRM_CALL DRM_EST_SlotEnumReloadCurrent ( 
    __inout    DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
    __out      DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __out_opt  DRM_DST_KEY           *f_pKey1,
    __out_opt  DRM_DST_KEY           *f_pKey2,
    __out_opt  DRM_DWORD             *f_pcbSize );

DRM_API DRM_RESULT DRM_CALL DRM_EST_SlotEnumDeleteCurrent ( 
    __inout   DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
    __inout   DRM_DST_SLOT_CONTEXT  *f_pContextSlot );

DRM_API DRM_RESULT DRM_CALL DRM_EST_BlockScanDelete ( 
    __inout                DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS,
    __in_ecount( f_cKey1 ) DRM_DST_KEY                *f_rgKey1,
    __in                   DRM_DWORD                   f_cKey1,
    __in                   DRM_DST_KEY                *f_pKey2,
    __in                   DRM_BOOL                    f_fWait );

DRM_API DRM_RESULT DRM_CALL DRM_EST_SlotResize ( 
    __inout  DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in     DRM_DWORD              f_cbSize );

DRM_API DRM_RESULT DRM_CALL DRM_EST_SlotSeek ( 
    __inout   DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in      DRM_LONG               f_lOffset,
    __in      DRM_DST_SEEKMODE       f_eSeekMode,
    __out_opt DRM_DWORD             *f_pdwSeekPointer );

DRM_API DRM_RESULT DRM_CALL DRM_EST_SlotRead ( 
    __inout                  DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in                     DRM_DWORD              f_cbData,
    __out_bcount( f_cbData ) DRM_BYTE              *f_pbData,
    __out_opt                DRM_DWORD             *f_pcbRead );

DRM_API DRM_RESULT DRM_CALL DRM_EST_SlotWrite ( 
    __inout                       DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in                          DRM_DWORD              f_cbData,
    __in_bcount( f_cbData ) const DRM_BYTE              *f_pbData,
    __out_opt                     DRM_DWORD             *f_pcbWritten );

EXIT_PK_NAMESPACE;

#endif  /* __DRM_EMBEDDEDSTORE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmembedding.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMEMBEDDING_H__
#define __DRMEMBEDDING_H__

#include <drmcommon.h>
#include <drmlicstore.h>
#include <drmliceval.h>

ENTER_PK_NAMESPACE;

DRM_API DRM_RESULT DRM_CALL DRM_EMB_UpdateEmbeddedStore(
    __in                                                       DRM_LICSTORE_CONTEXT    *f_pEmbeddedStore,
    __in                                                       DRM_LICSTORE_CONTEXT    *f_pLicStore,
    __in                                                       DRM_DOMAINSTORE_CONTEXT *f_poDomainStoreContext,
    __in const                                                 DRM_LICEVAL_CONTEXT     *f_pLicEvalBackup,    
    __in_bcount( __CB_DECL( SIZEOF( DRM_LICEVAL_CONTEXT ) ) )  DRM_BYTE                 f_rgbLicEvalBuffer[ ],
    __in_bcount( *f_pcbScratchBuffer )                         DRM_BYTE                *f_pbScratchBuffer,
    __inout                                                    DRM_DWORD               *f_pcbScratchBuffer,
    __in                                                       DRM_KID                 *f_poKID,
    __out                                                      DRM_BOOL                *f_pfModifiedEST
);


EXIT_PK_NAMESPACE;

#endif /* __DRMEMBEDDING_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmenvelope.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMENVELOPE_H__
#define __DRMENVELOPE_H__

#define DRM_ENVELOPE_FILE_SIGNATURE 0x07455250

#define DRM_ENVELOPE_CURRENT_FORMAT_VERSION 1

/* This is the size in bytes of a v1 envelope header */
#define DRM_ENVELOPE_MINIMUM_HEADER_SIZE 50

#define DRM_ENVELOPE_CIPHER_DATA_SIZE 24

typedef struct __tagDRM_ENVELOPE_HEADER
{
    DRM_DWORD dwFileSignature;
    DRM_DWORD cbHeaderSize;
    DRM_DWORD dwFileDataOffset;
    DRM_WORD  wFormatVersion;
    DRM_WORD  wCompatibleVersion;
    DRM_DWORD dwCipherType;
    DRM_BYTE  rgbCipherData[DRM_ENVELOPE_CIPHER_DATA_SIZE];
    DRM_WORD  cbOriginalFilename;
    DRM_DWORD cbDrmHeaderLen;
} DRM_ENVELOPE_HEADER;

typedef struct __tagDRM_ENVELOPED_FILE_CONTEXT
{
    OEM_FILEHDL pEnvFileHandle;
    
    DRM_DWORD dwFileDataStart;
    
    DRM_CIPHER_CONTEXT oDecrypt;
    DRM_UINT64 qwInitialCipherCounter;
    DRM_ENVELOPE_HEADER oEnvHeader;

} DRM_ENVELOPED_FILE_CONTEXT;

#endif /* __DRMENVELOPE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmembeddedstore_impl.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRM_EMBEDDEDSTORE_IMPL_H__
#define __DRM_EMBEDDEDSTORE_IMPL_H__

#include <drmcommon.h>
#include <drmdatastorecommon.h>

ENTER_PK_NAMESPACE;

#define MAX_EMBEDDED_STORE_LEN 10240

/*
** Context containing information about the embedded store.
*/
typedef struct __tagDRM_EST_CONTEXT
{
    DRM_BOOL   m_fInited;         /* Denotes whether the context has been initialized. */
    DRM_BOOL   m_fStoreOpen;      /* Denotes whether the context contains data for an open store */
    DRM_BOOL   m_fIsDirty;        /* Denotes whether the store has changed since opening */
    DRM_BYTE  *m_pbEmbeddedStore; /* Pointer to the actual store data. */
    DRM_DWORD  m_cbEmbeddedStore; /* Length of m_pbEmbeddedStore that is used in bytes. */
    DRM_DWORD  m_ibUnused;        /* Starting index of the unused buffer within the buffer pointed by m_pbEmbeddedStore. */
    DRM_DWORD  m_cbUnused;        /* Size of the unused buffer within the buffer pointed by m_pbEmbeddedStore. */
    DRM_DWORD  m_dwDeleteCount;   /* Starts at 0, incremented each time a slot is deleted. Used to detect when enumerations should be restarted due to slot deletions */
} DRM_EST_CONTEXT;

/*
** Context containing information about a namespace within an embedded store.
*/
typedef struct __tagDRM_EST_NAMESPACE_CONTEXT
{
    DRM_BOOL          m_fNamespaceOpen; /* Denotes whether the namespace is open */
    DRM_EST_CONTEXT  *m_poESTContext;   /* A pointer to context for the EST used to open the namespace. */
} DRM_EST_NAMESPACE_CONTEXT;

/*
** Context containing information used to find a particular slot.
*/
typedef struct __tagDRM_EST_SLOT_HINT
{
    DRM_DWORD         m_ibOffset;  /* The byte offset of the slot within the current namespace */
    DRM_DWORD         m_cbSlotLen; /* The length of the slot in bytes, without padding */
} DRM_EST_SLOT_HINT;

/*
** Context containing information about a slot.
*/
typedef struct __tagDRM_EST_SLOT_CONTEXT
{
    DRM_BOOL                   m_fSlotOpen;     /* Denotes whether a slot has been opened with this context. */
    DRM_EST_NAMESPACE_CONTEXT *m_poESTNSContext;/* A pointer to context for the namespace  */
    DRM_DST_KEY                m_oKey1;         /* Specifies the first key of the slot */
    DRM_DST_KEY                m_oKey2;         /* Specifies the second key of the slot */
    DRM_DST_LOCKMODE           m_eLockmode;     /* Specifies the lock mode used to open the slot. */
    DRM_DWORD                  m_ibSeekPtr;     /* Maintains the current seek pointer within the slot */
    DRM_EST_SLOT_HINT          m_oSlotLocation; /* Contains the location of the opened slot  */
} DRM_EST_SLOT_CONTEXT;

/*
** Context containing information used to enumerate slots.
*/
typedef struct __tagDRM_EST_ENUM_CONTEXT
{
    DRM_BOOL                    m_fInited;        /* Denotes whether the enum context has been initialized. */
    DRM_EST_NAMESPACE_CONTEXT  *m_poESTNSContext; /* A pointer to context for the namespace. */
    DRM_DWORD                   m_cSlots;         /* Contains the number of slots in the current enumeration */
    DRM_DWORD                   m_iSlot;          /* Contains the index of the current slot in the enumeration. */
    DRM_EST_SLOT_HINT           m_oSlotHint;      /* Slot hint contains the location of current slot */
    DRM_DST_KEY                 m_oKey1;          /* Primary key that is used to find matching slots. */
    DRM_DST_LOCKMODE            m_eLockMode;      /* Locking mode of the enumeration. */
    DRM_BOOL                    m_fSlotValid;     /* Flag indicating whether there is a current slot being enumerated. */
    DRM_DWORD                   m_dwCurrentDeleteCount; /* Delete count when enumeration was started, used to detect if deletions have occurred since starting/restarting */
} DRM_EST_ENUM_CONTEXT;

#define DRM_EST_CONTEXT_LEN             SIZEOF( DRM_EST_CONTEXT )
#define DRM_EST_NAMESPACE_CONTEXT_LEN   SIZEOF( DRM_EST_NAMESPACE_CONTEXT )
#define DRM_EST_SLOT_CONTEXT_LEN        SIZEOF( DRM_EST_SLOT_CONTEXT )
#define DRM_EST_SLOT_HINT_LEN           SIZEOF( DRM_EST_SLOT_HINT )
#define DRM_EST_NAMESPACE_LEN           16
#define DRM_EST_ENUM_CONTEXT_LEN        SIZEOF( DRM_EST_ENUM_CONTEXT )

EXIT_PK_NAMESPACE;

#endif  /* __DRM_EMBEDDEDSTORE_IMPL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmerr.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMERR_H__
#define __DRMERR_H__


#if DBG

//extern void (*g_pfDebugAnalyzeDR)(unsigned long);

//#define SetDbgAnalyzeFunction(pfn) g_pfDebugAnalyzeDR = pfn;

#define SetDbgAnalyzeFunction(pfn) ;

#define ExamineDRValue(_drval_) ;


/*
#define ExamineDRValue(_drval_)                   \
            if(g_pfDebugAnalyzeDR != NULL)        \
            {                                     \
                (*g_pfDebugAnalyzeDR)((_drval_)); \
            }
*/

#else  //DBG


#define SetDbgAnalyzeFunction(pfn)
#define ExamineDRValue(_drval_)


#endif  //DBG


#define ChkDR(expr) {               \
            dr = (expr);            \
            ExamineDRValue(dr);     \
            if ( DRM_FAILED(dr) )   \
            {                       \
                goto ErrorExit;     \
            }                       \
        }

#define ChkMem(expr) {               \
            if ( NULL == (expr) )    \
            {                        \
                TRACE( ("Allocation failure at %s : %d.\n%s\n", __FILE__, __LINE__, #expr) ); \
                dr = DRM_E_OUTOFMEMORY; \
                ExamineDRValue(dr);     \
                goto ErrorExit;     \
            }                       \
        }

#define ChkArg(expr) {               \
            if ( !(expr) )       \
            {                       \
                TRACE( ("Invalid argument at %s : %d.\n%s\n", __FILE__, __LINE__, #expr) ); \
                dr = DRM_E_INVALIDARG; \
                ExamineDRValue(dr);    \
                goto ErrorExit;     \
            }                       \
        }

#define ChkDRMString(s) {    \
            if ( !(s) || (s)->pwszString==NULL || (s)->cchString==0 )   \
            {                       \
                TRACE( ("Invalid argument at %s : %d.\n%s\n", __FILE__, __LINE__, #s) ); \
                dr = DRM_E_INVALIDARG; \
                ExamineDRValue(dr);    \
                goto ErrorExit;     \
            }                       \
        }
        
#define ChkDRMANSIString(s) {    \
            if ( !(s) || (s)->pszString==NULL || (s)->cchString==0 )   \
            {                       \
                TRACE( ("Invalid argument at %s : %d.\n%s\n", __FILE__, __LINE__, #s) ); \
                dr = DRM_E_INVALIDARG; \
                ExamineDRValue(dr);    \
                goto ErrorExit;     \
            }                       \
        }        

#define ChkWR(expr) {               \
            if (!(expr))            \
            {\
                dr = GetLastError();\
                dr = HRESULT_FROM_WIN32(dr);\
                ExamineDRValue(dr); \
                goto ErrorExit;     \
            }\
        }

#define ChkBOOL(fExpr,err){  \
            if (!(fExpr))            \
            {\
                dr = (err);\
                ExamineDRValue(dr);  \
                goto ErrorExit;     \
            }\
        }

#define ChkFAIL(expr) ChkBOOL(expr,DRM_E_FAIL)

#define ChkDRContinue(exp) \
{                          \
    dr=(exp);              \
    ExamineDRValue(dr);    \
    if (DRM_FAILED (dr))   \
    {                      \
        continue;          \
    }                      \
}    

#define ChkOverflow(a,b) do {                       \
            if (a < b)                              \
            {                                       \
                ChkDR(DRM_E_ARITHMETIC_OVERFLOW);   \
            }                                       \
        } while(FALSE)

#define ChkOverflowUI64(a,b) do {                   \
            if ( DRM_UI64Les( a, b ) )              \
            {                                       \
                ChkDR(DRM_E_ARITHMETIC_OVERFLOW);   \
            }                                       \
        } while(FALSE)

#define ChkOverflowI64(a,b) do {                    \
            if ( DRM_I64Les( a, b ) )               \
            {                                       \
                ChkDR(DRM_E_ARITHMETIC_OVERFLOW);   \
            }                                       \
        } while(FALSE)

#define ChkBoundsLT( index, arrSize )               \
do                                                  \
{                                                   \
    if ( index >= arrSize )                         \
    {                                               \
        ChkDR( DRM_E_BUFFER_BOUNDS_EXCEEDED );      \
    }                                               \
}                                                   \
while ( FALSE )

#define SAFE_CHKDR_GETLASTERROR                         \
    {                                                   \
        dr = GetLastError( );                           \
        ChkDR( HRESULT_FROM_WIN32( dr ) );              \
        ChkDR( E_UNEXPECTED );                          \
    }
                                                                                                                                         
#define ChkDRMap( expr, drOriginal, drMapped ) do{                                                                        \
            dr = ( expr );                                                                                                \
            ExamineDRValue(dr);                                                                                           \
            if ( dr == ( drOriginal ) )                                                                                   \
            {                                                                                                             \
                TRACE( ("Error code 0x%X mapped at %s : %d. to 0x%X \n", dr,  __FILE__, __LINE__, drMapped) );            \
                dr = ( drMapped );                                                                                        \
                ExamineDRValue(dr);                                                                                       \
            }                                                                                                             \
            if ( DRM_FAILED( dr ) )                                                                                       \
            {                                                                                                             \
                goto ErrorExit;                                                                                           \
            }                                                                                                             \
     }while( FALSE )   

#define MapDR( drOriginal, drMapped ) do{                                                                                         \
                TRACE( ("Error code 0x%X mapped at %s : %d. to 0x%X \n", drOriginal,  __FILE__, __LINE__, drMapped) );            \
                drOriginal = ( drMapped );                                                                                        \
     }while( FALSE )   

#define AssertChkArg(expr)      \
    do {                        \
        DRM_BOOL _f = (expr);   \
        DRMASSERT( _f );        \
        ChkArg( _f );           \
    } while(FALSE)

#endif /* __DRMERR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmexpreval.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_EXPR_EVAL_H__
#define __DRM_EXPR_EVAL_H__

#include <drmlicstore.h>
#include <drmtoken.h>

ENTER_PK_NAMESPACE;


/* In the following Extract*Token functions if cchExpression == 0 it is assumed that the string is NULL termintated. */
/* Note: These functions modify the pointer they are given. */

DRM_API DRM_RESULT DRM_CALL ExtractStringToken( DRM_CONST_STRING* pdstrExpression, TOKEN* pToken );
DRM_API DRM_RESULT DRM_CALL ExtractLongToken  ( DRM_CONST_STRING* pdstrExpression, TOKEN* pToken );
DRM_API DRM_RESULT DRM_CALL ExtractSymbolToken( DRM_CONST_STRING* pdstrExpression, TOKEN* pToken );
DRM_API DRM_RESULT DRM_CALL ExtractDateToken  ( DRM_CONST_STRING* pdstrExpression, TOKEN *pToken );


typedef DRM_RESULT (DRM_CALL *pfnGetVariable)(const DRM_CONST_STRING*, TOKEN*, DRM_VOID*);
typedef DRM_RESULT (DRM_CALL *pfnSetVariable)(const DRM_CONST_STRING*, const TOKEN*, TOKEN*, DRM_VOID*);

#define DRM_EXPR_EVAL_MAX_TOKEN_STACK_SIZE 15

typedef struct tagEXPR_EVAL_INTERNAL_DATA
{
    TOKEN rgOperandTokenStack[DRM_EXPR_EVAL_MAX_TOKEN_STACK_SIZE];
    TOKEN rgOperatorTokenStack[DRM_EXPR_EVAL_MAX_TOKEN_STACK_SIZE];
    DRM_DWORD dwOperandStack;
    DRM_DWORD dwOperatorStack;
    DRM_BOOL fShortCircuit;
} EXPR_EVAL_INTERNAL_DATA;

typedef struct tagEXPR_EVAL_CONTEXT
{
    /* Data the caller must set  */
    pfnGetVariable GetVariable; /* Function pointers so variables can be fetched/set */
    pfnSetVariable SetVariable;
    DRM_VOID* pvOpaqueData;         /* Pointer to be passed into GetVariable() and SetVariable() */
    DRM_KID KID;
    DRM_LID LID;

    /* Internal memory sandbox for ExprEval to use.  Caller doesn't set this memory */
    EXPR_EVAL_INTERNAL_DATA ExprEvalData;
} EXPR_EVAL_CONTEXT;


DRM_API DRM_RESULT DRM_CALL DRM_EXPR_EvaluateExpression(
    IN const DRM_CONST_STRING  *pdstrExpression, 
    IN OUT   EXPR_EVAL_CONTEXT *pEEContext, 
       OUT   TOKEN             *ptResult );

/*
** Secure store variable accessor/mutator functions. 
** These will be given to the Expression evaluator via it's context structure.  
** The implementation lives in exprvariable.c 
*/
DRM_API DRM_RESULT DRM_CALL GlobalSetVariable(
    const DRM_CONST_STRING *pStringToken, 
    const TOKEN            *pNewValue, 
          TOKEN            *pResult, 
          DRM_VOID         *pvOpaqueData );

DRM_API DRM_RESULT DRM_CALL GlobalGetVariable(
    const DRM_CONST_STRING *pStringToken,
          TOKEN            *pResult,
          DRM_VOID         *pvOpaqueData );

EXIT_PK_NAMESPACE;

#endif /* __DRM_EXPR_EVAL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmhash.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMHASH_H__
#define __DRMHASH_H__

#include <drmsha1.h>
#include <drmsha256.h>

ENTER_PK_NAMESPACE;


/*
** Supported hash algorithms
*/
typedef enum __tageDRM_SHA_SUPPORTED_ALGORITHMS
{
    eDRM_SHA_1   = 0,
    eDRM_SHA_256 = 1
} eDRM_SHA_SUPPORTED_ALGORITHMS;


#define DRM_SHA_DIGEST_LEN_MAX    max( DRM_SHA1_DIGEST_LEN, SHA256_DIGEST_SIZE_IN_BYTES )
#define DRM_SHA_BLOCK_SIZE_MAX    max( DRM_SHA1_BLOCK_SIZE, SHA256_BLOCK_SIZE_IN_BYTES )
#define DRM_SHA_CONTEXT_SIZE_MAX  max( SIZEOF( DRM_SHA1_CONTEXT ), SIZEOF( DRM_SHA256_Context ) )


typedef struct __tagDRM_SHA_CONTEXT
{
    DRM_BOOL                      fInitialized;
    eDRM_SHA_SUPPORTED_ALGORITHMS eAlgorithm;
    union _tagContext
    {
        DRM_SHA1_CONTEXT    sha1Context;
        DRM_SHA256_Context  sha256Context;
    } context;     
} DRM_SHA_CONTEXT;

#define DRM_SHA_CONTEXT_DEFAULT { FALSE, eDRM_SHA_1, { 0 } }


DRM_API DRM_RESULT DRM_CALL DRM_SHA_Init(
    __inout_ecount( 1 ) DRM_SHA_CONTEXT               *f_pShaContext,
    __in                eDRM_SHA_SUPPORTED_ALGORITHMS  f_eAlgorithm ); 


DRM_API DRM_RESULT DRM_CALL DRM_SHA_Update(
    __in_bcount( f_cbData ) const DRM_BYTE         *f_pbData,
    __in                          DRM_DWORD         f_cbData,
    __inout_ecount( 1 )           DRM_SHA_CONTEXT  *f_pShaContext );


DRM_API DRM_RESULT DRM_CALL DRM_SHA_UpdateOffset(
    __in_bcount( f_cbData ) const DRM_BYTE         *f_pbData,
    __in                          DRM_DWORD         f_ibData,
    __in                          DRM_DWORD         f_cbData,
    __inout_ecount( 1 )           DRM_SHA_CONTEXT  *f_pShaContext );
    
        
DRM_API DRM_RESULT DRM_CALL DRM_SHA_Finalize(
    __in_ecount( 1 )            DRM_SHA_CONTEXT *f_pShaContext,
    __in                        DRM_DWORD        f_cbDigest,
    __inout_bcount( f_cbDigest) DRM_BYTE        *f_pbDigest );
            
            
EXIT_PK_NAMESPACE;

#endif /* __DRMHASH_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmhdrbuilder.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMHEADERBUILDER_H__
#define __DRMHEADERBUILDER_H__

ENTER_PK_NAMESPACE;

#define LOCALSTACKSIZE  200

/*************************************************************************
** Local data structures
**************************************************************************/
typedef enum 
{
    eHBCreating=0x0,
    eHBInited, 
    eHBAddingData,
    eHBAddedData,
    eHBSigning,
    eHBCreated
} _EHBContextState;

/*
** Header Builder context stucture. This structure contains the following:
** - A Local stack
** - XML Builder context
** The XML Builder context is physically located at end of the buffer after init - for easier
** realloc a bigger size when necessary.
*/
typedef struct _tag_HBContext
{
    DRM_DWORD                wContextSize;
    _EHBContextState         eState;
    DRM_CONTENT_SET_PROPERTY eHeaderType;
    DRM_DWORD                dwItemsAdded;     /* copied from old context when DRM_LA_ReallocRequest() is called */
    DRM_DWORD                dwItemsTracked;       /* 0 when DRM_LA_ReallocRequest() is called */
    DRM_STRING               szXMLString;
    DRM_BOOL                 fKIDAdded;
    DRM_KID                  KID;
    DRM_BOOL                 fLAINFOAdded;
    DRM_BOOL                 fChecksumAdded;
    DRM_BYTE                 rgbLocalStack[__CB_DECL(LOCALSTACKSIZE)];     /* local stack buffer */
    _XMBContext             *pbXmlContext;
    _XMBContext              rgbXmlContext [1];
} _HBContext;

/* 
** Header Builder
*/

/**********************************************************************
** Function:    DRM_HB_CreateHeader
** Synopsis:    
** Arguments:   [pbContext] -- 
** Returns:     
** Notes:
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_HB_CreateHeader(
    __in_bcount_opt( *pcbHBContext ) DRM_BYTE  *pbHBContext,
    IN     DRM_CONTENT_SET_PROPERTY  eHeaderType,
    IN OUT DRM_DWORD *pcbHBContext);

DRM_API DRM_RESULT DRM_CALL DRM_HB_CloseHeader(
    __in_bcount( SIZEOF( _HBContext ) ) DRM_BYTE*pbHBContext,
    IN  DRM_CRYPTO_CONTEXT *pCryptoContext,
    IN  DRM_CONST_STRING   *pdstrPrivKey,      /* base64 encoded */
    __deref_out_bcount( *pcbHeaderXML ) DRM_BYTE **ppbHeaderXML,
    OUT DRM_DWORD          *pcbHeaderXML);

DRM_API DRM_RESULT DRM_CALL DRM_HB_ReallocHeader(
    __in_bcount( SIZEOF( _HBContext ) ) DRM_BYTE *pbOldHBContext,
    IN DRM_DWORD cbNewHBContext,
    __in_bcount( cbNewHBContext ) DRM_BYTE *pbNewHBContext);

DRM_API DRM_RESULT DRM_CALL DRM_HB_GetContextSize(
    __in_bcount( SIZEOF( _HBContext ) ) DRM_BYTE *pbHBContext,
    OUT DRM_DWORD *pcbContext);

DRM_API DRM_RESULT DRM_CALL DRM_HB_OpenNode(
    __in_bcount( SIZEOF( _HBContext ) ) DRM_BYTE *pbHBContext,
    IN const DRM_CONST_STRING *pdstrNodeName);

DRM_API DRM_RESULT DRM_CALL DRM_HB_CloseCurrNode(
    __in_bcount( SIZEOF( _HBContext ) ) DRM_BYTE *pbHBContext );

DRM_API DRM_RESULT DRM_CALL DRM_HB_AddData(
    __in_bcount( SIZEOF( _HBContext ) ) DRM_BYTE *pbHBContext,
    IN const DRM_CONST_STRING *pdstrXMLData );

DRM_API DRM_RESULT DRM_CALL DRM_HB_SetKeyID(
    __in_bcount( SIZEOF( _HBContext ) ) DRM_BYTE *pbHBContext,
    IN const DRM_CONST_STRING *pdstrKID);      /* base64 encoded */

DRM_API DRM_RESULT DRM_CALL DRM_HB_SetLicAcqUrl(
    __in_bcount( SIZEOF( _HBContext ) ) DRM_BYTE *pbHBContext,
    IN const DRM_CONST_STRING *pdstrURL);

/*
** Perform checksum algo to the given content key and set the check to header
*/
DRM_API DRM_RESULT DRM_CALL DRM_HB_SetChecksum(
    __in_bcount( SIZEOF( _HBContext ) ) DRM_BYTE *pbHBContext,
    IN const DRM_CONST_STRING *pdstrContentKey);     /* base64 encoded */

DRM_API DRM_RESULT DRM_CALL DRM_HB_SetAttribute(
    __in_bcount( SIZEOF( _HBContext ) ) DRM_BYTE *pbHBContext,
    IN const DRM_CONST_STRING *pdstrAttrName,
    IN const DRM_CONST_STRING *pdstrAttrValue);


EXIT_PK_NAMESPACE;

#endif /* __DRMHEADERBUILDER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmfeatures.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMSETFEATURES_H__
#define __DRMSETFEATURES_H__

#ifdef __cplusplus
extern "C" {
#endif

/*                                                                                  
** PK Test build - To validate the ported code build with this profile. It
** enables various test options. Code built under this profile should *NEVER* 
** be shipped.
*/                                                                                  
#define DRM_BUILD_PROFILE_PK             1

/*                                                                                  
** Sample OEM profile - OEMs can take make variants of the two profiles above
** and give them names here.
*/                                                                                  
#define DRM_BUILD_PROFILE_OEM           10

/*                                                                                  
** Microsoft internal profiles: (No value to OEMs)
** -----------------------------------------------
** PK V.NEXT profile - used internally to ensure code for possible future 
**     products compiles.
** PC profile - used internally by PC team (and server).
** MIN and MAX TEST profiles - This range of values is used internally for testing
*/                                                                                  
#define DRM_BUILD_PROFILE_PC                   21
#define DRM_BUILD_PROFILE_PK_TEST_MIN          100
#define DRM_BUILD_PROFILE_PK_TEST_MAX          199

/* 
** Ensure the build profile is properly set. 
*/
#ifndef DRM_BUILD_PROFILE
    #ifndef __BUILDMACHINE__
        #error "DRM_BUILD_PROFILE must be set to one of the above values either by the build environment or here."
        /* Example: #define DRM_BUILD_PROFILE DRM_BUILD_PROFILE_PK */
    #else
        /* For MS internal builds (detected via __BUILDMACHINE__), default to PC profile */
        #define DRM_BUILD_PROFILE DRM_BUILD_PROFILE_PC
    #endif
#endif

/*
** Pick correct compilation options based on a build profile
*/
#if DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_PK
#include <drmbuild_pk.h>
#elif DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_OEM
#include <drmbuild_oem.h>
#elif DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_PC
#include <drmbuild_pc.h>
#elif DRM_BUILD_PROFILE >= DRM_BUILD_PROFILE_PK_TEST_MIN && DRM_BUILD_PROFILE <= DRM_BUILD_PROFILE_PK_TEST_MAX
#include <drmbuild_pk_TestFlagSets.h>
#else
#error "Invalid value of DRM_BUILD_PROFILE in drmfeatures.h"
#endif


/****************************************************************************
** Special case: DRM_SUPPORT_REVOCATION is calculated here and nowhere else.
****************************************************************************/
#if DRM_SUPPORT_APP_REVOCATION  ||  DRM_SUPPORT_DEVICE_REVOCATION  || DRM_SUPPORT_WMDRMNET || DRM_SUPPORT_CONTENT_REVOCATION
#define DRM_SUPPORT_REVOCATION          1
#else
#define DRM_SUPPORT_REVOCATION          0
#endif

/*
#------------------------------------------------------------------------------
# Set this flag to '1' to enable the datastore to be created with a specific size.
# This reduces the fragmentation of the datastore, and increases performance during
# datastore access.
# The following two defines in drmmanager.c control the initial size, and the subsequent
# increment in datastore size.  Set them to suit your specific implementation.
#    #define DATASTORE_INITSIZE      512      prealloc 512 K for initial datastore size
#    #define DATASTORE_GROWSIZE      512      grow 512 K for each datastore expansion
#
# If this flag is '0', the datastore blocks are allocated as they are needed.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_DATASTORE_PREALLOC
#define DRM_SUPPORT_DATASTORE_PREALLOC          1
#endif

/*
#------------------------------------------------------------------------------
# DRM_SUPPORT_DOMAINS
# Set this flag to '1' to include the support for DRM domain
# and be able to play back a domain license. All PlayReady implementations
# must have this feature enabled.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_DOMAINS
#define DRM_SUPPORT_DOMAINS                     1
#endif


/*
#------------------------------------------------------------------------------
# DRM_SUPPORT_PC_FLAGS
# Set this flag to '1' for PC build profile.
#
# The flag must be set into 0 or 1 in drmbuild_*.h
#
# The following compile flags are for use in PC/host components only and should
# be unset or set to 0 for all PlayReady implementations:
#    DRM_SUPPORT_V1_LICENSES
#    DRM_SUPPORT_GRL                 
#    DRM_SUPPORT_THUMBNAIL           
#    DRM_BACKUP_RESTORE_SUPPORT      
#    DRM_SUPPORT_CONTENT_REVOCATION  
#    DRM_SUPPORT_PLAYLIST_BURN       
#    DRM_SUPPORT_PMLICENSE           
#    DRM_SUPPORT_COPY_OPL            
#    DRM_SUPPORT_DELETEDSTORE        
#    DRM_NO_FORCE_ALIGN              
#    DRM_TEMP_LICENSE_STORE_HDS      
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_PC_FLAGS
#error "DRM_SUPPORT_PC_FLAGS is not defined."
#endif

#if DRM_SUPPORT_PC_FLAGS==1

#ifndef DRM_NO_FORCE_ALIGN
#define DRM_NO_FORCE_ALIGN              1
#endif
#ifndef DRM_SUPPORT_CONTENT_REVOCATION
#define DRM_SUPPORT_CONTENT_REVOCATION  0
#endif
#ifndef DRM_SUPPORT_COPY_OPL
#define DRM_SUPPORT_COPY_OPL            1
#endif
#ifndef DRM_SUPPORT_DELETEDSTORE
#define DRM_SUPPORT_DELETEDSTORE        0
#endif
#ifndef DRM_SUPPORT_GRL
#define DRM_SUPPORT_GRL                 1
#endif
#ifndef DRM_SUPPORT_PLAYLIST_BURN
#define DRM_SUPPORT_PLAYLIST_BURN       1
#endif
#ifndef DRM_SUPPORT_PMLICENSE
#define DRM_SUPPORT_PMLICENSE           0
#endif
#ifndef DRM_BACKUP_RESTORE_SUPPORT
#define DRM_BACKUP_RESTORE_SUPPORT      1
#endif
#ifndef DRM_SUPPORT_THUMBNAIL
#define DRM_SUPPORT_THUMBNAIL           1
#endif
#ifndef DRM_SUPPORT_V1_LICENSES
#define DRM_SUPPORT_V1_LICENSES         0
#endif
#ifndef DRM_TEMP_LICENSE_STORE_HDS
#define DRM_TEMP_LICENSE_STORE_HDS      1
#endif

#else

#ifndef DRM_NO_FORCE_ALIGN
#define DRM_NO_FORCE_ALIGN              0
#endif
#ifndef DRM_SUPPORT_CONTENT_REVOCATION
#define DRM_SUPPORT_CONTENT_REVOCATION  0
#endif
#ifndef DRM_SUPPORT_COPY_OPL
#define DRM_SUPPORT_COPY_OPL            0
#endif
#ifndef DRM_SUPPORT_DELETEDSTORE
#define DRM_SUPPORT_DELETEDSTORE        0
#endif
#ifndef DRM_SUPPORT_GRL
#define DRM_SUPPORT_GRL                 0
#endif
#ifndef DRM_SUPPORT_PLAYLIST_BURN
#define DRM_SUPPORT_PLAYLIST_BURN       0
#endif
#ifndef DRM_SUPPORT_PMLICENSE
#define DRM_SUPPORT_PMLICENSE           0
#endif
#ifndef DRM_BACKUP_RESTORE_SUPPORT
#define DRM_BACKUP_RESTORE_SUPPORT      0
#endif
#ifndef DRM_SUPPORT_THUMBNAIL
#define DRM_SUPPORT_THUMBNAIL           0
#endif
#ifndef DRM_SUPPORT_V1_LICENSES
#define DRM_SUPPORT_V1_LICENSES         0
#endif
#ifndef DRM_TEMP_LICENSE_STORE_HDS
#define DRM_TEMP_LICENSE_STORE_HDS      0
#endif

#endif /* DRM_SUPPORT_PC_FLAGS * /

/*
#------------------------------------------------------------------------------
# DRM_SUPPORT_TEST_SETTINGS
# Set this flag to '1' to enable various test flags:
#   - TEST_USE_OFFSET_CLOCK
#   - DRM_TEST_MEM_ALLOC_CHECK
#   - DRM_TEST_SUPPORT_NET_IO
#   - DRM_ERROR_CONTRACT_TEST_MODE
#   - DRM_TEST_IGNORE_UNIQUE_ID
# 
# If the flag is not set it is 0 by default.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_TEST_SETTINGS
#define DRM_SUPPORT_TEST_SETTINGS               0
#endif


/*
# If it's a test mode then set test flags, otherwise turn them off.
*/
#if DRM_SUPPORT_TEST_SETTINGS == 1

#define TEST_USE_OFFSET_CLOCK           1
/*
** mem alloc check should be disabled by default because we run AppVerifier
*/
#ifndef DRM_TEST_MEM_ALLOC_CHECK
#define DRM_TEST_MEM_ALLOC_CHECK        0
#endif

#ifndef DRM_TEST_SUPPORT_NET_IO
#define DRM_TEST_SUPPORT_NET_IO         1
#endif

#ifndef DRM_ERROR_CONTRACT_TEST_MODE
#if DBG
#define DRM_ERROR_CONTRACT_TEST_MODE    1
#else
#define DRM_ERROR_CONTRACT_TEST_MODE    0
#endif
#endif

#ifndef DRM_TEST_IGNORE_UNIQUE_ID
#if defined(WINCE)
#define DRM_TEST_IGNORE_UNIQUE_ID       1
#else
#define DRM_TEST_IGNORE_UNIQUE_ID       0
#endif
#endif


#else
/*
# Test settings off
*/
#ifndef TEST_USE_OFFSET_CLOCK       
#define TEST_USE_OFFSET_CLOCK           0
#endif
#ifndef DRM_TEST_MEM_ALLOC_CHECK    
#define DRM_TEST_MEM_ALLOC_CHECK        0
#endif
#ifndef DRM_TEST_SUPPORT_NET_IO     
#define DRM_TEST_SUPPORT_NET_IO         0
#endif
#ifndef DRM_ERROR_CONTRACT_TEST_MODE
#define DRM_ERROR_CONTRACT_TEST_MODE    0
#endif
#ifndef DRM_TEST_IGNORE_UNIQUE_ID
#define DRM_TEST_IGNORE_UNIQUE_ID       0
#endif
#ifndef DRM_TEST_NO_BUFFER_FLUSH
#define DRM_TEST_NO_BUFFER_FLUSH        0
#endif

#endif /* DRM_SUPPORT_TEST_SETTINGS */

/*
#------------------------------------------------------------------------------
# DRM_SUPPORT_PROFILING
# Set this flag to '1' to enable profiling functionality
# Profiling macros compile to gather performance data and write to a binary
# file named perf.dat or perfagg.dat. The file can be used by external tools
# for further analysis.
# Profiling must be activated by a runtime call of DRM_Start_Profiling(),
# and it can also be turned off at runtime by calling DRM_Stop_Profiling().
# To minimize overhead introduced by the profiling, samples collected during
# profiling are buffered first and flushed to a file when the buffer becomes full.
# The file drmprofile.h defines several contstants to modify the behavior of
# the profiling.
#
# If this flag is '0', the profiling macros compile to nothing.
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_SUPPORT_PROFILING
#define DRM_SUPPORT_PROFILING           0
#endif

/*
#------------------------------------------------------------------------------
# DRM_EXPORT_APIS_TO_DLL
# Set this flag to '1' to mark DRM_API functions to be exported from a DLL.
#------------------------------------------------------------------------------
*/
#ifndef DRM_EXPORT_APIS_TO_DLL
#define DRM_EXPORT_APIS_TO_DLL          0
#endif
/*
#------------------------------------------------------------------------------
# DRM_TEST_LINK_TO_DRMAPI_DLL
# Set this flag to '1' to allow test code executables to link with a DLL.
#------------------------------------------------------------------------------
*/
#ifndef DRM_TEST_LINK_TO_DRMAPI_DLL
#define DRM_TEST_LINK_TO_DRMAPI_DLL     0
#endif

/*
#------------------------------------------------------------------------------
# This setting specifies the size in bytes of the HDS copy buffer. A larger
# size will increase HDS performace, but will require a larger DRM_APP_CONTEXT.
# Also, no performance benefit will be had for buffer sizes above the block 
# size (which is a default of 32kb).
#
# There are no top level APIs directly affected by this flag.
#
#------------------------------------------------------------------------------
*/
#ifndef DRM_HDS_COPY_BUFFER_SIZE      
#define DRM_HDS_COPY_BUFFER_SIZE                32768
#endif

/*
#------------------------------------------------------------------------------
# If the _DATASTORE_WRITE_THRU is set to 0, most HDS writes will be
# immediately flushed to disk with Oem_File_FlushBuffers. So long as all file 
# handles to the same file will see written data immediately, and writes make
# it to physical media in an expidient manner, this option may be set to 1.
#------------------------------------------------------------------------------
*/
#ifndef _DATASTORE_WRITE_THRU
#define _DATASTORE_WRITE_THRU                   1
#endif

/*
#------------------------------------------------------------------------------
# Total number of licenses in a chain support by this DRM implementation 
# Must be set to 2.
#------------------------------------------------------------------------------
*/
#ifndef DRM_MAX_LICENSE_CHAIN_DEPTH
#define DRM_MAX_LICENSE_CHAIN_DEPTH   2                                    
#endif

/*
#------------------------------------------------------------------------------
# MSDB (by default) should use dynamic memory allocation (Oem_Mem_Alloc)
# Legacy alternative is stack allocation (DRM_STK_Alloc)
# For dynamic memory allocation set value to 1
# For stack memory allocation set value to 0
#------------------------------------------------------------------------------
*/
#ifndef DRM_MSDB_USE_DYNAMIC_MEM_ALLOCATION
#define DRM_MSDB_USE_DYNAMIC_MEM_ALLOCATION   1
#endif



/*

To enforce feature value for ALL profiles add the following pragma and then define a feature:

#pragma warning(disable:4005)
#define DRM_SUPPORT_SOMEFEATURE 1

*/

#ifdef __cplusplus
}
#endif

#endif  /* __DRMSETFEATURES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmhds.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRM_HDS_H__
#define __DRM_HDS_H__

#include <drmcommon.h>
#include <drmdatastorecommon.h>
#include <drmdatastore.h>

ENTER_PK_NAMESPACE;

typedef struct __tagDRM_HDS_CONTEXT
{
    DRM_BYTE rgbOpaqueData[__CB_DECL( DRM_HDS_CONTEXT_LEN )];
} DRM_HDS_CONTEXT;


/* 
** API Functions 
*/

/*
** ----------------------------------------------------------------------------
** Methods applied to whole hashed file store 
** ----------------------------------------------------------------------------
*/

/**********************************************************************
** Function:    DRM_HDS_Init
** Synopsis:    Init HDS Context
** Arguments:   [f_pContextDST] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       The function MUST be called in the main thread BEFORE
**              any of the child thread(s) starting sharing the same 
**              context. If this function is called after the child
**              thread(s) started, the result is undefined.
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_HDS_Init( __inout DRM_DST_CONTEXT *f_pContextDST );


/**********************************************************************
** Function:    DRM_HDS_Uninit
** Synopsis:    Uninit HDS Context
** Arguments:   [f_pContextDST] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       This function MUST be called in the main thread AFTER
**              any of the child thread(s) sharing the same context 
**              stopped. If this function is called before the child
**              thread(s) stopped, the result is undefined.
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_HDS_Uninit( __inout DRM_DST_CONTEXT *f_pContextDST );


/**********************************************************************
** Function:    DRM_HDS_CreateStore
** Synopsis:    Create DRM data store file
** Arguments:   [] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_HDS_CreateStore( 
    __in_opt                           DRM_VOID          *f_pvOEMContext,
    __in_bcount( f_cbStoreData ) const DRM_BYTE          *f_pbStoreData,
    __in                               DRM_DWORD          f_cbStoreData,
    __in                         const DRM_DWORD          f_dwBlockSize,
    __in                               DRM_DST_BLKNUMTYPE f_eBlNumType,
    __in                               DRM_BOOL           f_fTruncateExist,
    __in                         const DRM_DWORD          f_dwInitSizeInKB,
    __out                              DRM_DST_CONTEXT   *f_pContextDST );


/**********************************************************************
** Function:    DRM_HDS_OpenStore
** Synopsis:    Initialize the data store
** Arguments:   [] --
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_HDS_OpenStore( 
    __in_opt                     DRM_VOID        *f_pOEMContext,
    __in_bcount( f_cbStoreData ) DRM_BYTE        *f_pbStoreData,
    __in                         DRM_DWORD        f_cbStoreData,
    __in                         DRM_DWORD        f_dwGrowBySizeinKB,
    __out                        DRM_DST_CONTEXT *f_pContextDST );


/**********************************************************************
** Function:    DRM_HDS_CloseStore
** Synopsis:    Close the license store.  This will also Commit before close
** Arguments:   [f_pContextDST] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_HDS_CloseStore( __inout DRM_DST_CONTEXT *f_pContextDST );

/**********************************************************************
** Function:    DRM_HDS_CommitStore
** Synopsis:    flush unwritten data to disk
** Arguments:   [f_pContextDST] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_HDS_CommitStore( __inout DRM_DST_CONTEXT *f_pContextDST );


/**********************************************************************
** Function:    DRM_HDS_CleanupStore
** Synopsis:    clean up empty blocks and hidden slot in store 
** Arguments:   [f_pContextDST] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_HDS_CleanupStore(
    __inout DRM_DST_CONTEXT *f_pContextDST,
    __in    DRM_BOOL         f_fWait );

#define DRM_HDS_OPEN_NAMESPACE_DEFAULT_EXPECTED_SLOT_SIZE 1000
DRM_API DRM_RESULT DRM_CALL DRM_HDS_OpenNamespace(
    __inout                            DRM_DST_CONTEXT           *f_pContextDST,
    __in    const                      DRM_DST_NAMESPACE         *f_pNamespace,
    __in                               DRM_DST_OPENMODE           f_eOpenMode,
    __in                               DRM_WORD                   f_wMaxNumChildren,
    __in                               DRM_DWORD                  f_dwExpectedSlotSize,
    __out                              DRM_DST_NAMESPACE_CONTEXT *f_pContextNS );

/* remove the entire namespace tree and its nodes in the data store */
DRM_API DRM_RESULT DRM_CALL DRM_HDS_DeleteNamespace( 
    __inout    DRM_DST_CONTEXT   *f_pContextDST,
    __inout    DRM_DST_NAMESPACE *f_pNS,
    __in       DRM_BOOL           f_fWait );

/* start using the specified namespace, any subsequent calls will be based on this namespace */
DRM_API DRM_RESULT DRM_CALL DRM_HDS_CloseNamespace(
    __inout    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS );  /* Namespace context returned from DRM_HDS_OpenNamespace */


DRM_API DRM_RESULT DRM_CALL DRM_HDS_CommitNamespace( __inout    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS );

/*
** ----------------------------------------------------------------------------
** Methods to navigate, create, delete, open and close HDS dataslots  
** ----------------------------------------------------------------------------
*/

/* Initialize a slot hint based on the slot context passed */
DRM_API DRM_RESULT DRM_CALL DRM_HDS_MakeSlotHint(
    __in    DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __out   DRM_DST_SLOT_HINT     *f_pSlotHint );

/* Create or open dataslot using given key1 and key2 */
DRM_API DRM_RESULT DRM_CALL DRM_HDS_OpenSlot( 
    __in       DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,/* Namespace context returned from DRM_HDS_OpenNamespace */
    __in       DRM_DWORD                  f_dwMode,    
    __in const DRM_DST_KEY               *f_pHashKey,
    __in const DRM_DST_KEY               *f_pUniqueKey,
    __in_opt   DRM_DST_SLOT_HINT         *f_pSlotHint,
    __inout    DRM_DWORD                 *f_pcbSlotSize,/* current dataslot size */
    __out      DRM_DST_SLOT_CONTEXT      *f_pContextSlot );/* user given Dataslot context buffer */

/* Close an opened dataslot */
DRM_API DRM_RESULT DRM_CALL DRM_HDS_CloseSlot( __inout  DRM_DST_SLOT_CONTEXT  *f_pContextSlot );

/* delete the slot immediately */
DRM_API DRM_RESULT DRM_CALL DRM_HDS_DeleteSlot( 
    __in       DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
    __in const DRM_DST_KEY               *f_pHashKey,
    __in const DRM_DST_KEY               *f_pUniqueKey,
    __in_opt   DRM_DST_SLOT_HINT         *f_pSlotHint,
    __in       DRM_BOOL                   f_fWait );


/**********************************************************************
** Function:    DRM_HDS_InitSlotEnum
** Synopsis:    
** Arguments:   [f_pContextNS]   -- Namespace context init'd by DRM_HDS_OpenNamespace()
**              [f_pHashKey]     -- Hashkey, if given to query, if not, enum all will be performed
**              [f_eLockMode]    -- Flag specifing how to lock the slot
**              [f_pContextEnum] -- returned Enum context
** Returns:     DRM_SUCCESS on success
** Notes:       This is 2 functions in one. If f_pHashKey is given, only the slots
**              with the same hashkey will be enum'ed. if pHashKey is NULL, all
**              slots within the namespace will be enum'ed.
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_HDS_InitSlotEnum(
    __in           DRM_DST_NAMESPACE_CONTEXT *f_pContextNS,
    __in_opt const DRM_DST_KEY               *f_pHashKey,
    __in           DRM_DST_LOCKMODE           f_eLockMode,
    __out          DRM_DST_ENUM_CONTEXT      *f_pContextEnum );


/**********************************************************************
** Function:    DRM_HDS_SlotEnumNext
** Synopsis:    Get the next slot in the enumeration
** Arguments:   [f_pcontextEnum] -- Enum Context init'd by DRM_HDS_InitSlotEnum()
**              [f_pContextSlot] -- Slot Context of the current slot
**              [f_pHashKey] -- Hashkey of the current slot
**              [f_pUniqueKey] -- Uniquekey of the current slot
**              [f_pcbSlot] -- size of the current slot
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_HDS_SlotEnumNext( 
    __inout    DRM_DST_ENUM_CONTEXT  *f_pContextEnum,/* setup by DRM_HDS_InitSlotEnum() */
    __out      DRM_DST_SLOT_CONTEXT  *f_pContextSlot,/* user given Dataslot context buffer */
    __out_opt  DRM_DST_KEY           *f_pHashKey,    /* optional parameter */
    __out_opt  DRM_DST_KEY           *f_pUniqueKey,  /* optional parameter */
    __out_opt  DRM_DWORD             *f_pcbSlot );   /* current dataslot size, optional parameter */
       

/**********************************************************************
** Function:    DRM_HDS_SlotEnumReloadCurrent
** Synopsis:    Load the current slot in the enumeration
** Arguments:   [f_pContextEnum] -- Enum Context init'd by DRM_HDS_InitSlotEnum()
**              [f_pContextSlot] -- Slot Context of the current slot
**              [f_pHashKey] -- Hashkey of the current slot
**              [f_pUniqueKey] -- Uniquekey of the current slot
**              [f_pcbSlot] -- size of the current slot
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_HDS_SlotEnumReloadCurrent(         
    __inout    DRM_DST_ENUM_CONTEXT  *f_pContextEnum,       /* setup by DRM_HDS_InitSlotEnum() */
    __out      DRM_DST_SLOT_CONTEXT  *f_pContextSlot,       /* user given Dataslot context buffer */
    __out_opt  DRM_DST_KEY           *f_pHashKey,           /* optional parameter */
    __out_opt  DRM_DST_KEY           *f_pUniqueKey,         /* optional parameter */
    __out_opt  DRM_DWORD             *f_pcbSlot );          /* current dataslot size, optional parameter */

/**********************************************************************
** Function:    DRM_HDS_SlotEnumDeleteCurrent
** Synopsis:    Delete the current enumerated slot
** Arguments:   [f_pcontextEnum] -- Enum Context init'd by DRM_HDS_InitSlotEnum()
**              [f_pcontextSlot] -- Slot Context of the current slot
** Returns:     DRM_SUCCESS on success
** Notes:       The enumeration must be init'ed with EXCLUSIVE right.
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_HDS_SlotEnumDeleteCurrent( 
    __inout   DRM_DST_ENUM_CONTEXT  *f_pContextEnum,
    __inout   DRM_DST_SLOT_CONTEXT  *f_pContextSlot );


/* Block Scan API: rapid deletion of multiple slots */

DRM_API DRM_RESULT DRM_CALL DRM_HDS_BlockScanDelete(
    __inout                    DRM_DST_NAMESPACE_CONTEXT  *f_pContextNS,
    __in_ecount( f_cKeysHash ) DRM_DST_KEY                *f_rgKeyHash,
    __in                       DRM_DWORD                   f_cKeysHash,
    __in                       DRM_DST_KEY                *f_pkeyUnique,
    __in                       DRM_BOOL                    f_fWait );

/*
** ----------------------------------------------------------------------------
** Methods to read, write and seek within a dataslot
** ----------------------------------------------------------------------------
*/

/**********************************************************************
** Function:    DRM_HDS_SlotResize
** Synopsis:    resize an opened dataslot
** Arguments:   [f_pContextSlot] -- An open slot context
**              [f_cbSize]       -- New size of the slot
** Returns:     DRM_SUCCESS on success
** Notes:       
** Possible cases:
** 
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_HDS_SlotResize( 
    __inout  DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in     DRM_DWORD              f_cbSize );

DRM_API DRM_RESULT DRM_CALL DRM_HDS_SlotSeek( 
    __inout   DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in      DRM_LONG               f_lOffset,
    __in      DRM_DST_SEEKMODE       f_eOrigin,
    __out_opt DRM_DWORD             *f_pdwSeekPointer );/* optional parameter, can be NULL */

DRM_API DRM_RESULT DRM_CALL DRM_HDS_SlotRead( 
    __inout                  DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in                     DRM_DWORD              f_cbData,
    __out_bcount( f_cbData ) DRM_BYTE              *f_pbData,
    __out_opt                DRM_DWORD             *f_pcbRead );

DRM_API DRM_RESULT DRM_CALL DRM_HDS_SlotWrite( 
    __inout                       DRM_DST_SLOT_CONTEXT  *f_pContextSlot,
    __in                          DRM_DWORD              f_cbData,
    __in_bcount( f_cbData ) const DRM_BYTE              *f_pbData,
    __out_opt                     DRM_DWORD             *f_pcbWritten );

DRM_API DRM_RESULT DRM_CALL DRM_HDS_InitializeDST( __out DRM_DST *f_pDst );

EXIT_PK_NAMESPACE;

#endif  /* __DRM_HDS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmheaderparser.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMHEADERPARSER_H__
#define __DRMHEADERPARSER_H__

ENTER_PK_NAMESPACE;

#define DRM_HEADER_MAX_SIZE_IN_BYTES 5120

typedef enum
{
    DRM_HEADER_ATTRIB_VERSION            = 1,
    DRM_HEADER_ATTRIB_KID                = 2,
    DRM_HEADER_ATTRIB_LAINFO             = 3,
    DRM_HEADER_ATTRIB_CHECKSUM           = 4,
    DRM_HEADER_ATTRIB_SECURITYVERSION    = 5,
    DRM_HEADER_ATTRIB_OTHER              = 6,
    DRM_HEADER_ATTRIB_LICENSE_ACQ_V4_URL = 7,
    DRM_HEADER_ATTRIB_LICENSE_UI_URL     = 8,
    DRM_HEADER_ATTRIB_DOMAIN_SERVICE_ID  = 9
} eDRM_HEADER_ATTRIBUTES;

typedef enum
{
    DRM_HEADER_VERSION_UNKNOWN           = 0,
    DRM_HEADER_VERSION_2                 = 1,
    DRM_HEADER_VERSION_2_4               = 3,
    DRM_HEADER_VERSION_4                 = 2,
} eDRM_HEADER_VERSION;

DRM_API DRM_RESULT DRM_CALL DRM_HDR_GetHeaderVersion( 
    IN const DRM_CONST_STRING     *f_pdstrContentHeader,
    OUT      eDRM_HEADER_VERSION  *f_peVersion );

DRM_API DRM_RESULT DRM_CALL DRM_HDR_GetAttribute(
    IN const DRM_CONST_STRING       *pdstrContentHeader,
    IN const DRM_CONST_STRING       *pdstrAttrName,
    IN       eDRM_HEADER_ATTRIBUTES  eAttribute,
    OUT      DRM_CONST_STRING       *pdstrValue,
    IN       DRM_WCHAR               chXPathSeparator);

DRM_API DRM_RESULT DRM_CALL DRM_HDR_GetUplink(
    IN const DRM_CONST_STRING *pdstrContentHeader,
    IN       DRM_DWORD         dwUplinkNumber,
    OUT      DRM_CONST_STRING *pdstrKid );

DRM_API DRM_RESULT DRM_CALL DRM_HDR_Verify(
    IN const DRM_CONST_STRING   *pdstrContentHeader,
    IN const DRM_CONST_STRING   *pdstrPubKey,
    IN       DRM_CRYPTO_CONTEXT *pContext,
    OUT      DRM_LONG           *plResult);

EXIT_PK_NAMESPACE;

#endif /* __DRMHEADERPARSER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmhds_impl.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef _HDS_IMPL_H
#define _HDS_IMPL_H

#include <drmmd5.h>
#include <drmdatastorecommon.h>
#include <oemplatform.h>

ENTER_PK_NAMESPACE;

/*
** uncomment the following if do not need DRM_HDS_InitSlotEnum() and DRM_HDS_SlotEnumNext() 
*/
/* #define _NOENUMALL */


/*
** Note: this is implementation specific. 
*/
#define DRM_HDS_CONTEXT_LENGTH      2068+DRM_HDS_COPY_BUFFER_SIZE
#define MAXSLOTPOS                  0xFFFF
#define ROOTPARENTNUM               0x00


#define DRM_E_HDSINVALIDSTORE     DRM_E_INVALIDLICENSESTORE
#define DRM_E_HDSSRNCORRUPTED     DRM_E_DSTCORRUPTED

#define DRM_HDS_HASHKEY_SIZE        SIZEOF( DRM_DST_KEY )
#define DRM_HDS_UNIQUEKEY_SIZE      SIZEOF( DRM_DST_KEY )
#define DRM_HDS_NSNAME_SIZE         16

/* create a namespace tree in the data store */
#define DRM_HDS_MAXIMUM_CHILDREN 16


/* Bloom filter constants for child block
NOTE: Changing these values will break forward and backward compatibility */
#define HDS_CHILDBLOCK_BLOOM_MAX_M 128 /* Size of Bloom data in bytes */
#define HDS_CHILDBLOCK_BLOOM_MAX_K 710 /* Maximum Bloom K coefficient */

#define HDS_CHILDBLOCK_PRERELEASE_BLOOM_K 7  /* Number of Bloom hash functions for V1 file format */
#define HDS_CHILDBLOCK_PRERELEASE_BLOOM_M 20 /* Size of Bloom data in bytes for V1 file format */

/*
** Useful macros used in this source file only
*/
#define HDS_CONTEXT_LENGTH(srnsize)    \
    (SIZEOF(_HdsContext) - SIZEOF(_SRN) + (srnsize) + DRM_HDS_CONTEXT_LENGTH)

#define ISVALIDCONTEXT(ctx, eSignature) \
    ((ctx)!=NULL && (((ctx)->eContextSignature==(eSignature))?TRUE : FALSE))

#define CALC_SLOTCONTEXTLEN(cfg) \
    (SIZEOF(_SlotContext)+GetMemsize_ChildBlock((cfg))+GetMemsize_DataBlock())

/* There cound be an integer overflow, as pointed out by PREfast */
#define ChkOverflowSLOTCONTEXTLEN(cfg) \
    ChkOverflow( CALC_SLOTCONTEXTLEN(cfg), SIZEOF(_SlotContext) + SIZEOF(_ChildBlockHDR) + GetMemsize_DataBlock() );
    
#define CALC_MAXSLOTCONTEXTLEN \
    (SIZEOF(_SlotContext)+GetMaxMemsize_ChildBlock()+GetMemsize_DataBlock())

#define CALC_MAXENUMCONTEXTLEN \
    (SIZEOF(_EnumContext)+GetMaxMemsize_ChildBlock()-SIZEOF(_CommBlockHDR))

#define CALC_MAXBLOCKHEADERLEN \
    GetMaxMemsize_ChildBlock()

/*
**  NOTE:
**  -Child Node number = (Fileposition / NodeSize) + 1
**  -Node number of the RootNode is always 0
**  -Uses DRM_USHORT for Nodenum gives roughly 64K nodes in a file. On average, if a node
**   can store 5 licenses, a license file can store up to 320K licenses.
**  -If a larger number of licneses need to be stored, DRM_DWORD can be used. This will gives
**   4096M nodes or 20480M licenses.
**  -to search a node containing a particular license, we only have to traverse Log(N) times where
**   N is the number of licenses in the file.
*/




/******************************************************************************
** Major implementation data structure
*******************************************************************************
*/


/* 
** Block Type 
*/
typedef enum 
{
    eINVALIDBLOCK = 0x00,
    eCHILDBLOCK,
    eDATABLOCK,
    eFREEBLOCK
} _EBlockType;

typedef enum
{
    eHdsContextSignature  = 0x01,
    eCfgContextSignature  = 0x02,
    eSlotContextSignature = 0x03,
    eEnumContextSignature = 0x04
} _EContextSignature;


/*
**
*/
typedef enum
{
    eSlotCtxUninit = 0,
    eSlotCtxInited,
    eSlotCtxReady
} _ESlotContextStatus;


typedef enum
{
    eSearchSlotDontCare,
    eSearchDataSlot,
    eSearchNamespace,
    eSearchHiddenOnly
} _ESlotSearchMode;


typedef enum
{
    eRemoveSlotSetHidden = 1,
    eRemoveSlotSetNull   = 2,
    eRemoveSlotPermanent = 3
} _ERemoveSlotMode;


typedef struct __tagDRM_HDS_NAMESPACE_BLOB
{
    DRM_BYTE rgb[__CB_DECL(DRM_HDS_NSNAME_SIZE)];
} DRM_HDS_NAMESPACE;

/*
** Namespace entry in SRN's namespace alloc table
*/
typedef struct _tag_NSEntry
{
    DRM_WORD  wMaxNumChildren;
    DRM_WORD  wPadding;
    DRM_DWORD nNSRBlockNum;                  /* block # of the Namespace Root node */
    DRM_BYTE  bNSName [__CB_DECL(DRM_HDS_NSNAME_SIZE)]; /* Namespace name */
    DRM_WORD  wBloomBytesM;
    DRM_WORD  wBloomK;
} _NSEntry;


/* HDS Namespace cache definitions */

#define DRM_HDS_NAMESPACECACHE_FLAG_VALID 0x01

typedef struct _tag_NamespaceCacheEntry
{
    DRM_DWORD dwCacheFlags;
    _NSEntry nsEntry;        
} _NamespaceCacheEntry;

#if DRM_SUPPORT_DEVICESTORE
/* The device store takes up an extra namespace */
#define DRM_HDS_NAMESPACECACHE_MAX_ENTRIES 8
#else
#define DRM_HDS_NAMESPACECACHE_MAX_ENTRIES 7
#endif

/*
** Super Root Node
*/
typedef struct _tag_SRN
{
    DRM_UINT64    ui64Timestamp;    /* updates every time SRN is updated */
    DRM_DWORD     dwSRNSize;        /* super root node size */
    DRM_DWORD     dwBlockSize;      /* File block size */
    DRM_DWORD     eBlockNumType;    /* DRM_DST_BLKNUMTYPE */
    DRM_DWORD     nFreeListHead;
    DRM_DWORD     nNsStoreRootBlockNum;
    DRM_DWORD     nHighestFormattedBlockNum;  /* block num of the highest formated block */
    DRM_BYTE      bSRNHash [__CB_DECL(MD5DIGESTLEN)];    /* MD5 hash value of SRN */
} _SRN;

/*
** HDS context
*/
typedef struct _tag_Context
{
    DRM_BOOL fCSInited;
    OEM_CRITICAL_SECTION oCS;
    DRM_DWORD   dwContextSize;
    DRM_BOOL    fInited;
    DRM_DWORD   eContextSignature;
    OEM_FILEHDL fp;
    DRM_VOID   *pOEMContext;
    DRM_MD5_CTX contextMD5;
    DRM_DWORD   nGrowbySizeinKB;
    DRM_DWORD   dwStoreVersion;

    /* computed when HDS is 'opened' */
    DRM_DWORD   nImagesize_FileBlockHDR;     /* file image size of _CommBlockHDR, not including payload */
    DRM_DWORD   nImagesize_DataBlockHDR;     /* file image size of _DataBlockHDR, not including payload */
    DRM_DWORD   nImagesize_DataBlockPayload; /* payload size of a _DataBlockHDR */
    DRM_DWORD   nDataBlockPayloadPos;        /* payload pos from begining of a _DataBlockHDR */

    /* Cache for namespace store entries */
    _NamespaceCacheEntry namespaceCache[DRM_HDS_NAMESPACECACHE_MAX_ENTRIES];

    /* work buffer initialized when HDS is opened */
    DRM_STACK_ALLOCATOR_CONTEXT oHeap;

    _SRN oSRN;    /* super root node, pbStack points to the area after oSRN */
} _HdsContext;

/*
** HDS Config context
*/
typedef struct _tag_CfgContext
{
    DRM_DWORD wContextSize;
    DRM_DWORD eContextSignature;
    DRM_BOOL fInited;
    _HdsContext *pHDS;
    DRM_BYTE oNamespace[__CB_DECL(DRM_HDS_NSNAME_SIZE)];

    /* computed when a Namespace is 'used' */
    DRM_DWORD nCfgRootBlockNum;    
    DRM_DWORD wMaxNumChildren;                /* # of children of the current selected Namespace */
    DRM_DWORD nImagesize_ChildBlockHDR;       /* file image size of _ChildBlockHDR, not including payload */
    DRM_DWORD nImagesize_ChildAllocTable;     /* file image size of ChildAlloc table of _ChildBlockHDR and _NSRootBlock */
    DRM_DWORD nImagesize_ChildBlockPayload;   /* payload size of _ChildBlockHDR  */
    DRM_DWORD nChildBlockPayloadPos;          /* payload pos from begining of _ChildBlockHDR */
    DRM_WORD  wBloomBytesM;
    DRM_WORD  wBloomK;
} _NsContext;


#define Memsize_FileBlock  SIZEOF(_CommBlockHDR)
typedef struct _tag_GenericBlockHeader {
    DRM_UINT64  ui64TimeStamp;
    DRM_BYTE    bBlockHash [__CB_DECL(MD5DIGESTLEN)];   /* MD5 hash of the above */
    DRM_DWORD   nParentBlockNum;
    DRM_BYTE    bBlockType;    
} _CommBlockFileHDR;    /*_FileImage; */

typedef struct _tag_FileBlock
{
    /* computed at run time */
    DRM_DWORD nBlockNum;   
    _NsContext *pNS;

    /* read from file */
    union 
    {        
        _CommBlockFileHDR _image;
        DRM_BYTE bFileImage[__CB_DECL(SIZEOF( _CommBlockFileHDR ))];
    } File;
} _CommBlockHDR;


typedef struct _tag_ChildBlockHeader 
{
    DRM_DWORD nFreeMem;
    DRM_BYTE bBloomData[HDS_CHILDBLOCK_BLOOM_MAX_M];
    DRM_BYTE bChildAllocTable[DRM_HDS_MAXIMUM_CHILDREN*eDRM_DSTBLKNUM_DWORD];
    DRM_BYTE bReserved;
} _ChildBlockFileHDR;


#define GetMemsize_ChildBlock(cfg)    (SIZEOF(_ChildBlockHDR))
#define GetMaxMemsize_ChildBlock()    (SIZEOF(_ChildBlockHDR))
typedef struct _tag_ChildBlock
{
    _CommBlockHDR oBlockHeader;    /* derive from _CommBlockHDR */

    /* calculated during init'd */
    DRM_DWORD nCurrSlotPos;
    DRM_DWORD nNextSlotPos;
    DRM_DWORD nPayloadSize;
    union 
    {
        DRM_BYTE bFileImage[__CB_DECL(SIZEOF(_ChildBlockFileHDR))];
        _ChildBlockFileHDR _image;
    } File;
} _ChildBlockHDR;

typedef struct _tag_DataBlockHeader {
    DRM_DWORD nCascadingBlockNum;
} _DataBlockFileHDR;


#define GetMemsize_DataBlock()   SIZEOF(_DataBlockHDR)
typedef struct _tag_DataBlock
{
    _CommBlockHDR oBlockHeader;    /* derive from _CommBlockHDR */

    DRM_DWORD nPayloadSize;
    union 
    {
        DRM_BYTE bFileImage[__CB_DECL(SIZEOF(DRM_DWORD))];
        _DataBlockFileHDR _image;
    } File;
} _DataBlockHDR;



typedef enum
{
    eSlotIsNamespace = 0x00000001,
    eSlotIsHidden    = 0x00000002
} _ESlotAtributes;

/*
** record header structure precedes the actual storage of data record
*/
typedef struct _tag_SlotHeader
{
    DRM_DWORD   dwSlotSize;           /* actual Data Record Size */
    DRM_DWORD   dwAttributes;         /* Attributes for this slot (see _ESlotAtributes) */
    DRM_DST_KEY oHashkey; 
    DRM_DST_KEY oUniquekey; 
} _SlotHeader;


/*
** License FindFirst /  FindNext context
*/
typedef struct _tag_SlotContext
{
    DRM_DWORD dwContextSize;
    DRM_DWORD eContextSignature;
    DRM_DWORD eStatus;
    _NsContext *pNS;
    DRM_DST_LOCKMODE eLockMode;

    /* cache of search result for slot allocation */
    DRM_DWORD nBlockWithLargestFreeSpace;
    DRM_DWORD dwLargestSpace;

    _CommBlockHDR oFileBlock;      /* a copy of the file block in _ChildBlockHDR for verification purpose */
    _CommBlockHDR *pCurrChildBlock; /* pointer of the _ChildBlockHDR containing the Slot, pointing somewhere in bBuff */
    DRM_DWORD dwSlotPosInBlock;   /* the position in ChildBlock's payload where the slot is located (at begining _SlotHeader ) */
    _SlotHeader oSlotHeader;    /* Slot header record in _ChildBlockHDR */
    DRM_DWORD dwSeekPointer;      /* the current position in Slot where next slot read/write occurs */

    /* the following is valid if slot data is stored in _DataBlockHDR chain */
    DRM_DWORD dwNumofDataBlockVisited;  /* num of _DataBlockHDR visited not including current one */
    DRM_DWORD dwFirstDataBlockNum;    /* first _DataBlockHDR number in the chain */
    _CommBlockHDR *pCurrDataBlock;

    /* buffer to contain _ChildBlockHDR and _DataBlockHDR */
    DRM_BYTE bBuff [1];  /* size = dynamic size of _ChildBlockHDR + _DataBlockHDR */
} _SlotContext;


/*
** Slot Enum context
** this structure's size must be greater than or equal to CALC_MAXENUMCONTEXTLEN 
*/
typedef struct _tag_EnumContext
{
    DRM_DWORD wContextSize;
    DRM_DWORD eContextSignature;
    _NsContext *pNS;
    DRM_BOOL fInited;

    _CommBlockHDR oFileBlock;      /* a copy of the file block in _ChildBlockHDR for verification purpose */
    _SlotHeader oSlotHeader;    /* current slot header */

    DRM_DST_LOCKMODE eLockMode;
    DRM_BOOL fIsQuery;             /* TRUE if oHashKey is not NULL, FALSE if enum all */
    DRM_DST_KEY oHashKey;  

    DRM_BOOL fCurrBlockIsValid;
    _CommBlockHDR oCurrBlock;  /* this field must be located at end of structure */
} _EnumContext;

typedef struct _tag_BlockScanContext
{
    DRM_DWORD                cbContext;
    DRM_DWORD                eContextSignature;
    _NsContext              *pcontextNS;
    DRM_BOOL                 fInited;
    _CommBlockHDR            blockheader;  /* a copy of the file block in _ChildBlockHDR for verification purpose */
    _SlotHeader              slotheader;   /* current slot header */
    DRM_DST_LOCKMODE         lockmode;
    DRM_DST_KEY              keyUnique;  
    const DRM_DST_KEY       *pkeyHash;  /* array of KIDs to delete */
    DRM_DWORD                cKeysHash; /* size of array */
    DRM_DWORD                cKeysFound;  /* number of KIDs marked for deletion thus far */
    DRM_DWORD                iKeyCurrent; /* index of next unmarked KID in the array */
    DRM_BOOL                 fCurrBlockIsValid;
    _ChildBlockHDR           blockheaderCurrent;  /* this field must be located at end of structure */
} _BlockScanContext;

typedef struct _tag_SlotHint
{
    DRM_DWORD nSlotPosInBlock;
    DRM_DWORD nBlockNum;
} _SlotHint;

/* HDS context sizes */
#define DRM_HDS_CONTEXT_LEN HDS_CONTEXT_LENGTH(SIZEOF(_SRN))
#define DRM_HDS_NAMESPACE_CONTEXT_LEN (SIZEOF( _NsContext ))
#define DRM_HDS_SLOT_CONTEXT_LEN       CALC_MAXSLOTCONTEXTLEN
#define DRM_HDS_ENUM_CONTEXT_LEN       CALC_MAXENUMCONTEXTLEN
#define DRM_HDS_SLOT_HINT_LEN          (SIZEOF(_SlotHint))

EXIT_PK_NAMESPACE;

#endif  /* _HDS_IMPL_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmkeygenerator.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMKEYGEN_H__
#define __DRMKEYGEN_H__

#include <drmnamespace.h>   /* defining proper namespace (if used) */
#include <drmcipher.h>

ENTER_PK_NAMESPACE;

#define DRM_KEYSEED_BASE64_LEN  40
#define DRM_KEYSEED_BINARY_LEN  CB_BASE64_DECODE(DRM_KEYSEED_BASE64_LEN)


/**************
  NOTE:  All Keygen functions include a NULL termination character
  in the character count and the string on function return
**************/

/**********************************************************************
** Function:    DRM_KG_GenerateKeyseed
** Synopsis:    Generate pseudo random keyseed
** Arguments:   [pwszKeyseed] -- Pointer of Unicode string to receive the keyseed
**              [pchKeyseed] -- size in chars of pwszKeyseed
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
DRM_API DRM_RESULT DRM_CALL DRM_KG_GenerateKeyseed(
    IN                                 DRM_VOID  *f_pOEMContext,
    __out_ecount_opt( *f_pcchKeyseed ) DRM_WCHAR *f_pwszKeyseed,
    IN OUT                             DRM_DWORD *f_pcchKeyseed );

/**********************************************************************
** Function:    DRM_KG_GenerateKeyID
** Synopsis:    Generate pseudo random Key ID 
** Arguments:   [pwszKeyseed] -- Pointer of Unicode string to receive the keyseed
**              [pchKeyseed] -- size in chars of pwszKeyseed
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
DRM_API DRM_RESULT DRM_CALL DRM_KG_GenerateKeyID(
    IN                               DRM_VOID  *f_pOEMContext,
    __out_ecount_opt( *f_pcchKeyID ) DRM_WCHAR *f_pwszKeyID,           /* base64 encoded string */
    IN OUT                           DRM_DWORD *f_pcchKeyID );


/*******************************************************************************
** Function:   DRMGenerateKey
** Parameters: 
**      [in] pbKeySeed:    A byte array representing seed.
**      [in] cbKeySeed:    The length of the pbKeySeed field
**      [in] pbKId:        The key id (KID). Normally, this is base-64 encoded guid.
**      [in] cbKId:        The length of the pbKId field.
**      [out] pwszContentKey: base64  
**      [in] pcchContentKey: 
** Purpose:
**      To generate the key for a given kid based on a license key seed of length up to 20 bytes.
********************************************************************************/
    DRM_API DRM_RESULT DRM_CALL DRM_KG_GenerateContentKeyB64(
        __in_ecount( f_cchKeySeed ) const      DRM_WCHAR *f_pwszKeySeed,          /* base64 encoded string */
        IN                                     DRM_DWORD  f_cchKeySeed,
        __in_ecount( f_cchKeyID ) const        DRM_WCHAR *f_pwszKeyID,            /* base64 encoded string */
        IN                                     DRM_DWORD  f_cchKeyID, 
        IN                                     DRM_SUPPORTED_CIPHERS f_eCipherType,
        IN                                     DRM_DWORD  f_cbContentKey,
        __out_ecount_opt(*f_pcchContentKey)    DRM_WCHAR *f_pwszContentKey,
        IN                                     DRM_DWORD *f_pcchContentKey,
        __out_bcount_opt( f_cbScratchKeySeed ) DRM_BYTE  *f_pbScratchKeySeed,
        IN                                     DRM_DWORD  f_cbScratchKeySeed);



DRM_API DRM_RESULT DRM_CALL DRM_KG_GenerateContentKeyBinary(
    __in_bcount( f_cbKeySeed )             DRM_BYTE  *f_pbKeySeed,
    IN                                     DRM_DWORD  f_cbKeySeed,
    IN                                     DRM_KID   *f_pKID,
    IN                                     DRM_SUPPORTED_CIPHERS f_eCipherType,
    __out_bcount_opt(f_cbContentKey)       DRM_BYTE  *f_pbContentKey,
    IN                                     DRM_DWORD  f_cbContentKey,
    __out_bcount_opt( f_cbScratchKeySeed ) DRM_BYTE  *f_pbScratchKeySeed,
    IN                                     DRM_DWORD  f_cbScratchKeySeed);





/*******************************************************************************
** Function:    DRM_KG_GenerateSigningKeys
** Synopsis:    Generate signing key pair. Generated key pair will be base64 encoded
** Arguments:   [pCrypto] -- pointer to PKCrypto context
**              [pwszPrivKey] -- pointer to unicode string to receive the generated priv key
**              [pcchPrivKey] -- length in char of pwszPrivKey
**              [pwszPubKey] -- pointer to unicode string to receive the generated pub key
**              [pcchPubKey] -- length in char of pwszPubkey
** Returns:     DRM_SUCCESS on success
** Notes:       
********************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_KG_GenerateSigningKeys(
    IN                                 DRM_CRYPTO_CONTEXT *f_pCrypto,
    __out_ecount_opt( *f_pcchPrivKey ) DRM_WCHAR          *f_pwszPrivKey, /* base64 encoded string */
    IN OUT                             DRM_DWORD          *f_pcchPrivKey,
    __out_ecount_opt( *f_pcchPubKey )  DRM_WCHAR          *f_pwszPubKey,  /* base64 encoded string */
    IN OUT                             DRM_DWORD          *f_pcchPubKey);

EXIT_PK_NAMESPACE;

#endif /*__DRMKEYGEN_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmlicacqv3.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_LICACQ_V3_H
#define __DRM_LICACQ_V3_H

#include <drmxmlsig.h>

ENTER_PK_NAMESPACE;

/*
** Define the maximum number of rights
** that can be requested at one time.
*/
#define DRM_MAX_RIGHTS_REQUESTED    1


#if DRM_SUPPORT_REVOCATION
/*
** There are 4 types of revocation data:
** PlayReadyApp, PlayReadyRuntime, WMDRMNET, and REV_INFO v2.
*/
#define MAX_REVLIST_INFO    4
#endif

#if DRM_SUPPORT_REVOCATION
/*
** Structure that stores the version information of
** a particular revocation list.
*/
typedef struct
{
    const DRM_GUID *m_poGUID;

    DRM_DWORD m_dwVersion;
} _REVLIST_INFO;
#endif

/*
** Structure that encapsulates the license state
** information of a uplink KID to be sent to the
** server during license acquisition.
*/
typedef struct
{
    /* KID of the uplink license. */
    DRM_CONST_STRING m_dstrKID;

    /* Raw license state data of the KID above. */
    DRM_LICENSE_STATE_DATA m_oStateData[ DRM_MAX_RIGHTS_REQUESTED ];
} _UPLINK_INFO;

/*
** Structure that encapsulates the all the information
** needed for the license acquisition challenge XML.
** When the structure is first created, it should be
** zeroed to have all of its member fields initialized.
*/
typedef struct
{
    /* The content header. */
    IN DRM_CONST_STRING m_dstrContentHeader;

    /* Total number of rights ( actions ). */
    IN DRM_DWORD m_cRights;

    /*
    ** An array of DRM string pointer that
    ** defines a set of rights ( actions ).
    */
    IN const DRM_CONST_STRING **m_ppdstrRights;

    /* Total number of uplink KIDs. */
    IN DRM_DWORD m_cUplinks;

    /* An array of license state information of uplink KIDs. */
    IN _UPLINK_INFO m_rgoUplinks[ DRM_MAX_LICENSE_CHAIN_DEPTH + 1 ];

    /* A string to contain a B64-encoded uplink KID */
    IN DRM_WCHAR m_rgwchUplinkKID[ CCH_BASE64_EQUIV( SIZEOF( DRM_KID ) ) ];

#if DRM_SUPPORT_REVOCATION
    /* An array of revocation version information. */
    IN _REVLIST_INFO m_rgoRevListInfo[ MAX_REVLIST_INFO ];
#endif

    /* Size ( number of characters ) of a device certificate. */
    OUT DRM_DWORD m_cchDeviceCert;

    /*
    ** Size ( number of characters ) of a collection of domain
    ** certificates to be passed to the server. Please note
    ** it includes the intermediate <CertificateChain>
    ** tags that separate neighboring domain certificates.
    */
    OUT DRM_DWORD m_cchDomainCerts;

    /* The custom data string to be sent to the server. */
    IN DRM_ANSI_CONST_STRING m_dastrCustomData;

    /*
    ** Service ID extracted from the content header. Only those
    ** domain certificates that match the service ID will
    ** be incorporated into the challenge. This field is used
    ** only for domain bound content.
    */
    IN DRM_GUID m_oServiceID;

    /*
    ** Stack allocator used for getting temporary buffers.
    ** User should initialize with a buffer that is big enough.
    */
    IN DRM_STACK_ALLOCATOR_CONTEXT m_oStackAllocatorContext;

    /*
    ** Key information used for XML encryption/signature.
    ** User should call DRM_SOAPXML_InitXMLKey() to initialize.
    */
    IN DRM_XML_KEY m_oXMLKey;

    /* Pointer to a domain store context. */
    IN DRM_DOMAINSTORE_CONTEXT *m_poDomainStoreContext;

    /* Pointer to a black box context. */
    IN DRM_BB_CONTEXT *m_poBBXContext;

    /* Pointer to an OEM specific context. */
    IN DRM_VOID *m_poOEMContext;

    /* Nonce associated with the challenge. */
    DRM_ID m_oNonce;

} DRM_LICCHLG_CONTEXT_V3;

typedef struct
{
    /* Pointer to a license evaluation context. */
    IN DRM_LICEVAL_CONTEXT *m_poLicEvalContext;

    /* Pointer to a license store context. */
    IN DRM_LICSTORE_CONTEXT *m_poLicStoreContext;

    /* Pointer to a sync context. */
    IN DRM_SYNC_CONTEXT *m_poSyncContext;

    /* Pointer to a view rights context. */
    IN DRM_VIEW_RIGHTS_CONTEXT *m_poViewRightsContext;

    /* Pointer to a data store context. */
    IN DRM_DST  *m_poDatastore;

    /* Pointer to a license buffer. */
    IN DRM_BYTE *m_pbLicenseBuffer;

#if DRM_SUPPORT_REVOCATION

    /* Pointer to a black box context. */
    IN DRM_BB_CONTEXT *m_poBBXContext;

    /* Pointer to a revocation store context. */
    IN DRM_REVOCATIONSTORE_CONTEXT *m_poRevStoreContext;

#endif

    /* Pointer to a nonce store context. */
    DRM_NONCESTORE_CONTEXT *m_poNonceStoreContext;

} DRM_LICRESP_CONTEXT_V3;

/* Define the maximum size in bytes of a transaction ID. */
#define DRM_MAX_TRANSACTION_ID  100

/*
** Defines the maximum number of licenses can be contained
** in a single license response.
*/
#define DRM_MAX_LICENSE_ACK     20

/*
** Structure that is used to store the result of
** license processing and storage.
*/
typedef struct
{
    /* KID of the license. */
    DRM_KID m_oKID;

    /* LID of the license. */
    DRM_LID m_oLID;

    /* DRM result code of the processing and storage. */
    DRM_RESULT m_dwResult;

    /* Flag specifying post-processing behavior. */
    DRM_DWORD m_dwFlags;

} DRM_LICENSE_ACK;

/* Values for m_dwFlags */
#define DRM_LICENSE_ACK_FLAGS_EMBED 1


/* Enumeration of license protocols. */
typedef enum
{
    /* Unrecognized protocol. */
    eUnknownProtocol = 0,

    /* V2 protocol. */
    eV2Protocol,

    /* V3 protocol. */
    eV3Protocol

} DRM_LICENSE_PROTOCOL_TYPE;

/* Structure that encapsulates the license processing result. */
typedef struct
{
    /* Type of license protocol detected. */
    DRM_LICENSE_PROTOCOL_TYPE m_eType;

    /* Buffer to store the transaction ID. */
    DRM_BYTE m_rgbTransactionID[ DRM_MAX_TRANSACTION_ID ];
    
    /*
    ** Actual size in bytes of the transaction ID.
    ** Should <= DRM_MAX_TRANSACTION_ID.
    */
    DRM_DWORD m_cbTransactionID;

    /* Array that contains license processing storage results. */
    DRM_LICENSE_ACK m_rgoAcks[ DRM_MAX_LICENSE_ACK ];

    /*
    ** Actual number of element in the array mentioned above.
    ** Should <= DRM_MAX_LICENSE_ACK.
    */
    DRM_DWORD m_cAcks;

    /* Status code parsed from the server response. */
    DRM_RESULT m_dwResult;

} DRM_LICENSE_RESPONSE;

/*
** Internal functions but are called from other files.
*/
DRM_API DRM_RESULT DRM_CALL DRM_LA_ParseServiceID(
    IN  const DRM_CONST_STRING *f_pdstrContentHeader,
    OUT       DRM_GUID         *f_pServiceID );

DRM_API DRM_RESULT DRM_CALL DRM_LA_ParseLicenseAcquisitionURL(
    IN     const DRM_CONST_STRING *f_pdstrContentHeader,
    IN           DRM_BOOL          f_fSilent,
    __out_ecount_opt( *f_pcchURL ) DRM_CHAR *f_pchURL,
    IN OUT       DRM_DWORD        *f_pcchURL );

DRM_API DRM_RESULT DRM_CALL DRM_LA_ProcessRevocationPackage(
    IN DRM_LICRESP_CONTEXT_V3 *f_poLicRespContext,
    IN DRM_ANSI_CONST_STRING *f_pdastrResponse,
    OUT DRM_DWORD *f_pcProcessed );

DRM_API DRM_RESULT DRM_CALL DRM_LA_GenerateChallengeV3(
    IN DRM_LICCHLG_CONTEXT_V3 *f_poLicChlgContext,
    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE *f_pbChallenge,
    IN OUT DRM_DWORD *f_pcbChallenge );

DRM_API DRM_RESULT DRM_CALL DRM_LA_CheckForCustomData(
    __in_bcount( f_cbResponse ) const DRM_BYTE *f_pbResponse,
    IN DRM_DWORD f_cbResponse );

DRM_API DRM_RESULT DRM_CALL DRM_LA_ProcessResponseV3(
    IN DRM_LICRESP_CONTEXT_V3 *f_poLicRespContext,
    IN DRM_ANSI_CONST_STRING *f_pdastrResponse,
    __out_bcount( *f_pcbTransactionID ) DRM_BYTE *f_pbTransactionID,
    IN OUT DRM_DWORD *f_pcbTransactionID,
    __out_ecount_part( DRM_MAX_LICENSE_ACK, *f_pcLicAcks ) DRM_LICENSE_ACK *f_poLicAcks,
    OUT DRM_DWORD *f_pcLicAcks );

DRM_API DRM_RESULT DRM_CALL DRM_LA_ProcessLicenseV3(
    IN DRM_LICRESP_CONTEXT_V3 *f_poLicRespContext,
    __in_ecount( f_pdasstrLicense->m_ich + f_pdasstrLicense->m_cch ) DRM_CHAR *f_pszResponse,
    IN DRM_SUBSTRING *f_pdasstrLicense,
    IN DRM_SLKDATA *f_pSLKData,
    OUT DRM_LICENSE_ACK *f_poLicAck );

DRM_API DRM_RESULT DRM_CALL DRM_LA_GenerateAckV3(
    __in_opt DRM_VOID *f_poOEMContext,
    IN DRM_BB_CONTEXT *f_poBBXContext,
    IN DRM_STACK_ALLOCATOR_CONTEXT *f_poStackAllocatorContext,
    IN DRM_LICENSE_RESPONSE *f_poLicenseResponse,
    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE *f_pbChallenge,
    IN OUT DRM_DWORD *f_pcbChallenge );

/*
** ---------------------------------------
** License acquisition API functions
** ---------------------------------------
*/
DRM_API DRM_RESULT DRM_CALL Drm_LicenseAcq_GenerateAck(
    IN DRM_APP_CONTEXT *f_poAppContext,
    IN DRM_LICENSE_RESPONSE *f_poLicenseResponse,
    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE *f_pbChallenge,
    IN OUT DRM_DWORD *f_pcbChallenge );

DRM_API DRM_RESULT DRM_CALL Drm_LicenseAcq_ProcessAckResponse(
    IN DRM_APP_CONTEXT *f_poAppContext,
    __in_bcount( f_cbResponse ) DRM_BYTE *f_pbResponse,
    IN DRM_DWORD f_cbResponse,
    OUT DRM_RESULT *f_pResult );

EXIT_PK_NAMESPACE;

#endif /* __DRM_LICACQ_V3_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmhmac.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMHMAC_H__
#define __DRMHMAC_H__

#include <drmhash.h>

ENTER_PK_NAMESPACE;

typedef struct __tagDRM_HMAC_CONTEXT
{
    DRM_BOOL        fInitialized;
    DRM_SHA_CONTEXT shaContext;
    DRM_BYTE        shaDigest[__CB_DECL( DRM_SHA_DIGEST_LEN_MAX )];
    DRM_BYTE        rgbBuffer[__CB_DECL( DRM_SHA_BLOCK_SIZE_MAX )];
} DRM_HMAC_CONTEXT;

#define DRM_HMAC_CONTEXT_DEFAULT { FALSE, DRM_SHA_CONTEXT_DEFAULT, { 0 }, { 0 } }

DRM_API DRM_RESULT DRM_CALL DRM_HMAC_Init(
    __inout_ecount( 1 )          DRM_HMAC_CONTEXT              *f_pContextHMAC,
    __in                         eDRM_SHA_SUPPORTED_ALGORITHMS  f_eShaAlgorithm,
    __in_bcount( f_cbKey ) const DRM_BYTE                      *f_pbKey,
    __in                         DRM_DWORD                      f_cbKey );

DRM_API DRM_RESULT DRM_CALL DRM_HMAC_Update(
    __inout_ecount( 1 )           DRM_HMAC_CONTEXT  *f_pContextHMAC,
    __in_bcount( f_cbData ) const DRM_BYTE          *f_pbData,
    __in                          DRM_DWORD          f_cbData );

DRM_API DRM_RESULT DRM_CALL DRM_HMAC_UpdateOffset(
    __inout_ecount( 1 )                 DRM_HMAC_CONTEXT  *f_pContextHMAC,
    __in_bcount( f_cbData + f_ibData )  const DRM_BYTE    *f_pbData,
    __in                                DRM_DWORD          f_ibData,
    __in                                DRM_DWORD          f_cbData  );

DRM_API DRM_RESULT DRM_CALL DRM_HMAC_Finalize(
    __inout_ecount( 1 )           DRM_HMAC_CONTEXT  *f_pContextHMAC,
    __out_bcount( f_cbKeyedHash ) DRM_BYTE          *f_pbKeyedHash,
    __in                          DRM_DWORD          f_cbKeyedHash );    

DRM_API DRM_RESULT DRM_CALL DRM_HMAC_FinalizeOffset(
    __inout_ecount( 1 )                             DRM_HMAC_CONTEXT  *f_pContextHMAC,
    __out_bcount( f_cbKeyedHash + f_ibKeyedHash )   DRM_BYTE          *f_pbKeyedHash,
    __in                                            DRM_DWORD          f_ibKeyedHash,
    __in                                            DRM_DWORD          f_cbKeyedHash ); 

DRM_API DRM_RESULT DRM_CALL DRM_HMAC_CreateMAC(
    __in                                      eDRM_SHA_SUPPORTED_ALGORITHMS  f_eAlgorithm,                                        
    __in_bcount( f_cbKey )              const DRM_BYTE                      *f_pbKey,
    __in                                      DRM_DWORD                      f_cbKey,
    __in_bcount( f_cbData + f_ibData )  const DRM_BYTE                      *f_pbData,
    __in                                      DRM_DWORD                      f_ibData,  
    __in                                      DRM_DWORD                      f_cbData,      
    __out_bcount( f_cbMAC + f_ibMAC )         DRM_BYTE                      *f_pbMAC,
    __in                                      DRM_DWORD                      f_ibMAC,
    __in                                      DRM_DWORD                      f_cbMAC );

DRM_API DRM_RESULT DRM_CALL DRM_HMAC_VerifyMAC(
    __in                                      eDRM_SHA_SUPPORTED_ALGORITHMS  f_eAlgorithm,                                        
    __in_bcount( f_cbKey )              const DRM_BYTE                      *f_pbKey,
    __in                                      DRM_DWORD                      f_cbKey,
    __in_bcount( f_cbData + f_ibData )  const DRM_BYTE                      *f_pbData,
    __in                                      DRM_DWORD                      f_ibData,   
    __in                                      DRM_DWORD                      f_cbData,     
    __in_bcount( f_cbMAC + f_ibMAC )    const DRM_BYTE                      *f_pbMAC,
    __in                                      DRM_DWORD                      f_ibMAC,
    __in                                      DRM_DWORD                      f_cbMAC );

EXIT_PK_NAMESPACE;

#endif /* __DRMHMAC_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmlicense.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMLICENSE_H__
#define __DRMLICENSE_H__

#include "drmpkcrypto.h"

ENTER_PK_NAMESPACE;

#define ISSUER_LEN           4
#define SUBJ_LEN             4
#define DATE_LEN             4
#define SER_NUM_LEN          4
#define INT_LEN              4

#define VER_STRING_MAX_LEN 20

/* Constant indicating the number of times SHA has to be used to get the hash of key. */
/* This hash is used to check whether the key is good or bad. */
/* CHECKSUM_LENGTH indicates the number of bytes in final hash value to use as CHECKSUM. */
#define SHA_ITERATIONS      5
#define CHECKSUM_LENGTH     7
#define DRM_AES_CK_CHECKSUM_LENGTH 8
#define APPSEC_LEN   4
#define RIGHTS_LEN   4

/* V1 rights bits */
extern const DRM_BYTE RIGHT_PLAY_ON_PC            [__CB_DECL(RIGHTS_LEN)];
extern const DRM_BYTE RIGHT_COPY_TO_NONSDMI_DEVICE[__CB_DECL(RIGHTS_LEN)];
extern const DRM_BYTE RIGHT_NO_RESTORE            [__CB_DECL(RIGHTS_LEN)];
extern const DRM_BYTE RIGHT_BURN_TO_CD            [__CB_DECL(RIGHTS_LEN)];
extern const DRM_BYTE RIGHT_COPY_TO_SDMI_DEVICE   [__CB_DECL(RIGHTS_LEN)];
extern const DRM_BYTE RIGHT_ONE_TIME              [__CB_DECL(RIGHTS_LEN)];
extern const DRM_BYTE RIGHT_COPY                  [__CB_DECL(RIGHTS_LEN)];
extern const DRM_BYTE RIGHT_COLLABORATIVE_PLAY    [__CB_DECL(RIGHTS_LEN)];


extern const DRM_LID g_rgbSecStoreGlobalName;


/* Version Format: a.b.c.d */
/*            a = not used. */
/*            b = major version */
/*            c = minor version */
/*            d = revision version */

extern const DRM_CONST_STRING g_dstrDRM_VERSION_STRING;
extern const DRM_BYTE DRM_VERSION    [__CB_DECL(VERSION_LEN)];
extern const DRM_BYTE PK_VER         [__CB_DECL(VERSION_LEN)]; /* Indicates the version of the pubkey to be used for verification of PK CERT. */
extern const DRM_BYTE KEYFILE_VER    [__CB_DECL(VERSION_LEN)]; /* Version of the key file. */
extern const DRM_BYTE LICREQUEST_VER [__CB_DECL(VERSION_LEN)];
extern const DRM_BYTE CERT_VER       [__CB_DECL(VERSION_LEN)]; /* Indicates the public root key needed to verify the license server certificates. */
extern const DRM_BYTE LICENSE_VER    [__CB_DECL(VERSION_LEN)]; /* Indicates the license version delivered. */
extern const DRM_BYTE CLIENT_ID_VER  [__CB_DECL(VERSION_LEN)]; /* The version for client id. */
extern const DRM_BYTE CONTENT_VERSION[__CB_DECL(VERSION_LEN)]; /* Content Version. Keep this in sync with CONTENT_VERSION_STRING above. */
extern const DRM_BYTE PM_LICENSE_VER [__CB_DECL(VERSION_LEN)]; /* Indicates the license version delivered to PMs */


extern const PUBKEY g_pubkeyLicenseServer;

#if DRM_NO_FORCE_ALIGN
#if defined (_MSC_VER)
#pragma pack(push)
#pragma pack(1)
#endif /* #if defined (_MSC_VER) */
#endif /* #if DRM_NO_FORCE_ALIGN */

typedef struct CERTDATAtag{
    PUBKEY pk;
    DRM_BYTE expiryDate  [__CB_DECL(DATE_LEN)];
    DRM_BYTE serialNumber[__CB_DECL(SER_NUM_LEN)];
    DRM_BYTE issuer      [__CB_DECL(ISSUER_LEN)];
    DRM_BYTE subject     [__CB_DECL(SUBJ_LEN)];
} CERTDATA, *PCERTDATA;


typedef struct CERTtag{
    DRM_BYTE certVersion[__CB_DECL(VERSION_LEN)];
    DRM_BYTE datalen    [__CB_DECL(INT_LEN)];
    DRM_BYTE sign       [__CB_DECL(DRM_ECC160_SIGNATURE_LEN)];
    CERTDATA cd;
} CERT, *PCERT;

#if DRM_NO_FORCE_ALIGN
#if defined (_MSC_VER)
#pragma pack(pop)
#endif /* #if defined (_MSC_VER) */
#endif /* #if DRM_NO_FORCE_ALIGN */

typedef struct {
    PKV pk;
    DRM_BYTE appSec [__CB_DECL(APPSEC_LEN)];
    DRM_BYTE subject[__CB_DECL(SUBJ_LEN)];
} APPCERTDATA;

typedef struct {
    DRM_BYTE appcertVersion[__CB_DECL(VERSION_LEN)];
    DRM_BYTE datalen       [__CB_DECL(INT_LEN)];
    DRM_BYTE sign          [__CB_DECL(DRM_ECC160_SIGNATURE_LEN)];
    APPCERTDATA appcd;
} APPCERT;

typedef struct __tagDRM_CRYPTO_CONTEXT
{
    DRM_BYTE rgbCryptoContext[__CB_DECL(DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE)];   /* size of the buffer pkcrypto code needs. Note this may have alignment problems. */
    PUBKEY   pubKey;  /* 40 BYTES */
    PUBKEY   pubKey2; /* 40 BYTES */
    union  _tagcert
    {
        CERT     cert;    /* 108 bytes */
        PKCERT   pkcert;  /* 84 bytes  */
    } union_cert;
    DRM_BYTE signature[__CB_DECL(DRM_ECC160_SIGNATURE_LEN)];   /* 40 BYTES     */
} DRM_CRYPTO_CONTEXT;

typedef struct __tagCLIENTID
{
    DRM_BYTE version[__CB_DECL(VERSION_LEN)];
    DRM_BYTE randNum[__CB_DECL(DRM_ECC160_CIPHERTEXT_LEN)];
    PKCERT pk;
} CLIENTID;


typedef struct __tagDRM_V1Header 
{
    DRM_BYTE  *pbKeyID;
    DRM_DWORD  cbKeyID;
    DRM_BYTE  *pbSecretData;
    DRM_DWORD  cbSecretData;
    DRM_BYTE  *pbURL;
    DRM_DWORD  cbURL;
    DRM_BYTE   bBuffer[1];
} DRM_V1Header;

EXIT_PK_NAMESPACE;

#endif /* __DRMLICENSE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmlicacq.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRM_LA_H__
#define __DRM_LA_H__

#include <drmlicstore.h>
#include <drmliceval.h>
#include <drmviewprops.h>
#include <drmxmlbuilder.h>
#include <drmsyncstore.h>
#include <drmcallbacks.h>

ENTER_PK_NAMESPACE;

#if DRM_SUPPORT_DLA
#define CB_STACK_LICENSE_CHALLENGE ((((SIZEOF(CLIENTID)*4)/3)+8)*SIZEOF(DRM_WCHAR))

typedef struct __tagDRM_LICENSE_CHALLENGE
{
    /* XML context buffer */

    _XMBContext             *pbXML;    
    DRM_DWORD                cbXML;
    
    /* uplink entries */
    
    DRM_LICENSE_STATE_DATA    rglicensestatedata  [DRM_MAX_LICENSE_CHAIN_DEPTH+1];
    DRM_CONST_STRING          rgdstrUplinkKID     [DRM_MAX_LICENSE_CHAIN_DEPTH+1];
    DRM_DWORD                 cUplinks;
    
    /* actions/rights */
    
    const DRM_CONST_STRING **ppdstrRights;
    DRM_DWORD                cRights;
    
    /* miscellaneous client data */
    
    DRM_CONST_STRING         dstrDeviceCert,
                             dstrClientIdentity,
                             dstrHeader,
                             dstrV1Challenge,
                             dstrRevInfo;
    DRM_DWORD                levelAppSecurity, 
                             idSubject;
    DRM_WCHAR               *pwszBBVer;
    CLIENTID                 clientid;

    DRM_BB_CONTEXT          *pcontextBBX;
    
    /* stack buffer */
    
    DRM_BYTE   rgbStack [__CB_DECL(CB_STACK_LICENSE_CHALLENGE)];     
} DRM_LICENSE_CHALLENGE;

/**********************************************************************
** Function:    DRM_LA_CreateChallenge
** Synopsis:    Creates and initializes a request context.
** Arguments:   [f_plicensechallenge] -- pointer to a DRM_LICENSE_CHALLENGE, whose members are initialized by the 
**                                     caller as follows:
**                  cbXML              -- for internal use
**                  pbXML              -- for internal use
**                  dstrHeader         -- WMRM Header extracted from media file
**                  pwszBbVer          -- NULL terminated string containing the blackbox version
**                  pdstrV1Challenge   -- pointer to a pregenerated V1 challenge string.  Can be NULL.
**                  clientid           -- CLIENTID structure created by the blackbox
**                  rgdstrUplinkKID    -- array of DRM_CONST_STRINGs, the KID's that were found in the 
**                                        content header (UPLINK kids)
**                  rglicensestatedata -- The current license state data for each KID in rgdstrKID
**                  cUplinks           -- The number of UPLINKS found in the header.  This is the length 
**                                        of the rgdstrUplinkKID and rglicensestatedata arrays
**                  ppdstrRights       -- array of DRM_CONST_STRING pointerss naming rights/actions
**                  cRights            -- array size of ppdstrRights
**                  dstrEncryptedCert  -- device certificate filled in by the caller.  This should be 
**                                        encrypted and base64 encoded (for privacy).
**                  pdstrClientIdentity-- string representation of the client id (encrypted/encoded old 
**                                        style certificate of the client
**                  levelAppSecurity   -- app security number preparsed from the device certificate
**                  idSubject          -- subject ID preparsed from the device certificate
**
**              [f_pszChallenge]       -- user-allocated buffer for challenge output, B64 encoded; NULL to query size
**              [f_cchChallenge]      -- size of pbChallenge
**
** Returns:     DRM_SUCCESS on success. On Failure, it returns:
**              DRM_E_INVALIDARG
**              DRM_E_BUFFERTOOSMALL
**
** Notes:       To get the minimum size required, first call with pbData and/or pbChallenge set to NULL. 
**              This will return DRM_E_BUFFERTOOSMALL and pcbData and pcbChallenge will point to values 
**              of minimum context size.
***********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_LA_CreateChallenge (
    IN DRM_LICENSE_CHALLENGE *f_plicensechallenge,
    OUT      DRM_CHAR        *f_pszChallenge,
    IN OUT   DRM_DWORD       *f_pcchChallenge);
   
/**********************************************************************
** Function:    DRM_LA_GetClientInfo
** Synopsis:    Creates CLIENTINFO 
** Arguments:   [f_pclientid] -- pointer to CLIENTID
**              [f_pbStack] -- pointer to stack for internal use.
**              [f_pcbStack] --pointer to size of f_pbStack in bytes
**              [f_pdstrClientVersionData] --pointer to drm string containing Client version info
**              [f_pdstrSecurityVersionData] -- pointer to drm string containing security version info
**              [f_AppSecurityData] -- Application security data.
**              [f_SubjectId1] --Subject ID1
**              [f_SubjectId2] --Subject ID2 (0 for no subject id2)
**              [f_pdstrDRMKVersion] --DRMK version(0 for no drmk version).
**              [f_pdstrEncryptedDevcert] --pointer to drm string containing encrypted devcert. Optional
**              [f_pbXML] --pointer to a buffer to get this client info.
**              [f_pcbXML] --pointer to size of f_pbXML in bytes
**              [f_fCreateNewDoc] --Flag. If TRUE, creates a new document otherwise add nodes to an existing document
**              [f_pdstrRevInfo] -- pointer to a string with the clients current revinfo versions.  Optional
** Returns:     DRM_SUCCESS on success, or failed with 
**              DRM_E_INVALIDARG,
**              DRM_E_BUFFERTOOSMALL.
** Sample CLIENTINFO:
**
**
** Add the following node/subnode to the request:
**
** <CLIENTINFO>
**    <CLIENTID>...</CLIENTID>
**    <CLIENTVERSION>...</CLIENTVERSION>
**    <SECURITYVERSION>...</SECURITYVERSION>
**    <APPSECURITY>...</APPSECURITY>
**    <SUBJECTID1>...</SUBJECTID1>
**    <SUBJECTID2>...</SUBJECTID2>
**    <DRMKVERSION>...</DRMKVERSION>
**    <DEVCERT>...</DEVCERT> optional
** </CLIENTINFO>
**
************************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_LA_GetClientInfo (
    IN       CLIENTID               *f_pclientid,
    __in_bcount( *f_pcbStack ) DRM_BYTE *f_pbStack,
    IN OUT   DRM_DWORD              *f_pcbStack,
    IN       DRM_CONST_STRING       *f_pdstrClientVersionData,
    IN       DRM_CONST_STRING       *f_pdstrSecurityVersionData,
    IN       DRM_DWORD               f_AppSecurityData,
    IN       DRM_DWORD               f_SubjectId1,
    IN       DRM_DWORD               f_SubjectId2,
    IN       DRM_CONST_STRING       *f_pdstrDRMKVersion,
    IN       DRM_CONST_STRING       *f_pdstrEncryptedDevcert,
    IN       _XMBContext            *f_pbXML,
    IN OUT   DRM_DWORD              *f_pcbXML,
    IN       DRM_CRYPTO_CONTEXT     *f_pcontextCRYP,
    IN       DRM_VOID               *f_pOEMContext,
    IN       DRM_BOOL                f_fCreateNewDoc,
    IN       DRM_CONST_STRING       *f_pdstrRevInfo );

#endif

DRM_API DRM_RESULT DRM_CALL DRM_LA_ProcessResponse(
    __in_bcount( f_cbResponse ) DRM_BYTE *f_pbResponse,
    IN     DRM_DWORD                             f_cbResponse,
    IN     DRM_LICEVAL_CONTEXT                  *f_pcontextLEVL,
    IN     DRM_LICSTORE_CONTEXT                 *f_pcontextLSTXML,
    IN     DRM_LICSTORE_CONTEXT                 *f_pcontextLSTXMR,
    __in   DRM_LICSTOREENUM_CONTEXT             *f_pLicStoreEnumContext,
    IN     DRM_INCLUSION_LIST_CALLBACK_STRUCT   *f_pInclusionListCallback,
    IN     pfnLicenseResponseCallback            f_pfnCallback,
    IN     DRM_VOID                             *f_pvCallbackContext,
    IN     DRM_DST                              *f_pDatastore,
    IN     DRM_VIEW_RIGHTS_CONTEXT              *f_pcontextASD,
    __in_bcount( DRM_MAX_LICENSESIZE ) DRM_BYTE f_rgbLicenseBuffer[__CB_DECL(DRM_MAX_LICENSESIZE)],
    IN     DRM_SYNC_CONTEXT                     *f_pcontextSync,
       OUT DRM_LONG                             *f_plReason);

DRM_API DRM_RESULT DRM_CALL DRM_LA_EvaluateLicense(   
    IN     DRM_LICEVAL_CONTEXT     *f_pcontextLEVL,
    IN     DRM_DST                 *f_pDatastore,    
    OUT    DRM_CONST_STRING        *f_pdstrLIData );

DRM_API DRM_RESULT DRM_CALL DRM_LA_GetSLK(
    OUT     DRM_SLKDATA           *f_pSLK,
    IN      DRM_DST               *f_pDatastore,    
    IN      DRM_LICEVAL_CONTEXT   *f_pcontextLEVL );

DRM_API DRM_RESULT DRM_CALL DRM_LA_UpdateSLK( 
    IN     DRM_ID               *f_pSLKID,
    __in_bcount( f_cbKeyLength ) DRM_BYTE *f_pbSLKKey,
    IN     DRM_DWORD             f_cbKeyLength,
    IN     DRM_DST              *f_pDatastore,      
    IN     DRM_LICEVAL_CONTEXT  *f_pcontextLEVL,
    OUT    DRM_SLKDATA          *f_pSLK );

EXIT_PK_NAMESPACE;

#endif  /* __DRM_LA_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmint64.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMINT64_H__
#define __DRMINT64_H__

#include <drmnamespace.h>   /* defining proper namespace (if used) */

ENTER_PK_NAMESPACE;

#if DRM_NO_NATIVE_64_TYPES

/* DRM_INT64 and DRM_UINT64 keeps 2 32 bit values
** val[0] keeps low 32 bit 
** val[1] keeps high 32 bit
** This is valid for both big and little endian CPUs
*/

typedef struct _DRM_INT64 { 
    unsigned long val[2];
} DRM_INT64;

typedef struct _DRM_UINT64 {   
    unsigned long val[2];
} DRM_UINT64;


extern DRM_API DRM_INT64 DRM_CALL DRM_I64Add(const DRM_INT64 a, const DRM_INT64 b);
extern DRM_API DRM_INT64 DRM_CALL DRM_I64Sub(const DRM_INT64 a, const DRM_INT64 b);
extern DRM_API DRM_INT64 DRM_CALL DRM_I64Mul(const DRM_INT64 a, const DRM_INT64 b);
extern DRM_API DRM_INT64 DRM_CALL DRM_I64Div(const DRM_INT64 a, const DRM_INT64 b);
extern DRM_API DRM_INT64 DRM_CALL DRM_I64Mod(const DRM_INT64 a, const DRM_INT64 b);
extern DRM_API DRM_INT64 DRM_CALL DRM_I64And(const DRM_INT64 a, const DRM_INT64 b);
extern DRM_API DRM_INT64 DRM_CALL DRM_I64ShR(const DRM_INT64 a, const int unsigned b);
extern DRM_API DRM_INT64 DRM_CALL DRM_I64ShL(const DRM_INT64 a, const int unsigned b);
extern DRM_API int       DRM_CALL DRM_I64Eql(const DRM_INT64 a, const DRM_INT64 b);
extern DRM_API int       DRM_CALL DRM_I64Les(const DRM_INT64 a, const DRM_INT64 b);
extern DRM_API DRM_INT64 DRM_CALL DRM_I64(const long int b);
extern DRM_API DRM_INT64 DRM_CALL DRM_I64Asgn(const long int a, const long int b);
extern DRM_API DRM_INT64 DRM_CALL DRM_UI2I64(const DRM_UINT64 b);
extern DRM_API unsigned long int DRM_CALL DRM_I64ToUI32(const DRM_INT64 b);

extern DRM_API DRM_UINT64 DRM_CALL DRM_UI64Add(const DRM_UINT64 a, const DRM_UINT64 b);
extern DRM_API DRM_UINT64 DRM_CALL DRM_UI64Sub(const DRM_UINT64 a, const DRM_UINT64 b);
extern DRM_API DRM_UINT64 DRM_CALL DRM_UI64Mul(const DRM_UINT64 a, const DRM_UINT64 b);
extern DRM_API DRM_UINT64 DRM_CALL DRM_UI64Div(const DRM_UINT64 a, const DRM_UINT64 b);
extern DRM_API DRM_UINT64 DRM_CALL DRM_UI64Mod(const DRM_UINT64 a, const DRM_UINT64 b);
extern DRM_API DRM_UINT64 DRM_CALL DRM_UI64And(const DRM_UINT64 a, const DRM_UINT64 b);
extern DRM_API DRM_UINT64 DRM_CALL DRM_UI64ShR(const DRM_UINT64 a, const unsigned int b);
extern DRM_API DRM_UINT64 DRM_CALL DRM_UI64ShL(const DRM_UINT64 a, const unsigned int b);
extern DRM_API int        DRM_CALL DRM_UI64Eql(const DRM_UINT64 a, const DRM_UINT64 b);
extern DRM_API int        DRM_CALL DRM_UI64Les(const DRM_UINT64 a, const DRM_UINT64 b);
extern DRM_API DRM_UINT64 DRM_CALL DRM_UI64(const unsigned long int b);

extern DRM_API DRM_UINT64 DRM_CALL DRM_UI64HL(const unsigned long int a, const unsigned long int b);
extern DRM_API unsigned long int DRM_CALL DRM_UI64High32( DRM_UINT64 a );
extern DRM_API unsigned long int DRM_CALL DRM_UI64Low32( DRM_UINT64 a );

/* Low 32 bit are stored first in 
** DRM_UINT64 structure.
** Thus we put "b" in first place
*/
#define DRM_UI64LITERAL(a,b) { b, a  }
#define DRM_I64LITERAL(a,b) { b, a  }

#define FILETIME_TO_UI64( ft, ui64 ) {ui64=DRM_UI64HL((ft).dwHighDateTime,(ft).dwLowDateTime);}
#define UI64_TO_FILETIME( ui64, ft ) {(ft).dwLowDateTime=DRM_UI64Low32(ui64);(ft).dwHighDateTime=DRM_UI64High32((ui64));}
#define NATIVE64_TO_NONNATIVE64( ui64 ) {ui64=DRM_UI64HL(DRM_UI64Low32(ui64),DRM_UI64High32(ui64));} /* Reverse the high and low */

#else

#if defined (_MSC_VER)

typedef          __int64 DRM_INT64;
typedef unsigned __int64 DRM_UINT64;

#elif defined (__GNUC__)

typedef          long long int DRM_INT64;
typedef unsigned long long int DRM_UINT64;

#endif

#define DRM_I64LITERAL(a,b) (DRM_INT64)(((DRM_INT64)a)<<32|b)
#define DRM_UI64LITERAL(a,b)(DRM_UINT64)(((DRM_UINT64)a)<<32|b)

#define FILETIME_TO_UI64( ft, ui64 ) { (ui64) = *((DRM_UINT64*)&(ft)); } 
#define UI64_TO_FILETIME( ui64, ft ) { (ft)   = *((DRMFILETIME*)&(ui64)); }
#define NATIVE64_TO_NONNATIVE64( ui64 )  

#define DRM_I64Add(a, b) ( (a) + (b) )
#define DRM_I64Sub(a, b) ( (a) - (b) )
#define DRM_I64Mul(a, b) ( (a) * (b) )
#define DRM_I64Div(a, b) ( (a) / (b) )
#define DRM_I64Mod(a, b) ( (a) % (b) )
#define DRM_I64And(a, b) ( (a) & (b) )
#define DRM_I64ShR(a, b) ( (a) >> (b) )
#define DRM_I64ShL(a, b) ( (a) << (b) )
#define DRM_I64Eql(a, b) ( (a) == (b) )
#define DRM_I64Les(a, b) ( (a) < (b) )
#define DRM_I64(b) ( (DRM_INT64) (b) )
#define DRM_I64Asgn(a, b) (((DRM_INT64)(a)<<32) | (b))
#define DRM_UI2I64(b) ((DRM_INT64)(b))

#define DRM_I64ToUI32(b) ((DRM_DWORD)(b))



#define DRM_UI64Add(a, b) ( (a) + (b) )
#define DRM_UI64Sub(a, b) ( (a) - (b) )
#define DRM_UI64Mul(a, b) ( (a) * (b) )
#define DRM_UI64Div(a, b) ( (a) / (b) )
#define DRM_UI64Mod(a, b) ( (a) % (b) )
#define DRM_UI64And(a, b) ( (a) & (b) )
#define DRM_UI64ShR(a, b) ( (a) >> (b) )
#define DRM_UI64ShL(a, b) ( (a) << (b) )
#define DRM_UI64Eql(a, b) ( (a) == (b) )
#define DRM_UI64Les(a, b) ( (a) < (b) )
#define DRM_UI64(b) ( (DRM_UINT64) (b) )

#define DRM_UI64HL(a,b) (((DRM_UINT64)(a)<<32) | (b))
#define DRM_UI64High32(a) ((unsigned long int)(a>>32))
#define DRM_UI64Low32(a) ((unsigned long int)(a&DRM_UI64LITERAL(0,0xFFFFFFFF)))

#endif

/* 
** This conversion is common for both native support of 64 bit number and representation as struct
*/
#define DRM_I2UI64(b) (*((DRM_UINT64*)(&(b))))

#define DRM_UI64Add32(a, b) DRM_UI64Add( DRM_UI64(a), DRM_UI64(b) )

EXIT_PK_NAMESPACE;

#endif /* __DRMINT64_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmlicreason.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


/* Description: The error codes to indicate the reason why a license is not usable.
              The error codes are used to give a better feedback to the user.
              These codes are used in the license to indicate the reason.
              drm.reason variable is set to this reason.
*/

#ifndef __LICREASON_H__
#define __LICREASON_H__

ENTER_PK_NAMESPACE;

/* Server can help with these values. These are reasons why a license that was just obtained is not usable. */
/* Clearly, playcount cannot be a reason unless the count started with 0. Similarly, clockrollback is not a reason. */
enum 
{
    LR_LICENSE_EXPIRED = 1,
    LR_LICENSE_NOTENABLED = 2,
    LR_LICENSE_APPSECLOW = 3,
    LR_LICENSE_NEEDINDI = 4,
    LR_LICENSE_STORE_NOT_ALLOWED = 5,
    LR_LICENSE_APP_NOT_ALLOWED = 6,
    LR_LICENSE_PLEDGE_LICENSE = 7,
    LR_LICENSE_CERT_EXPIRED = 8,
    LR_LICENSE_SECLOW = 9,
    LR_LICENSE_CONTENT_REVOKED = 10,
    LR_LICENSE_DEVICE_NOT_REGISTERED = 11,
    LR_LICENSE_TRACK_BURN_LIMIT_EXCEEDED = 12,
    LR_LICENSE_RESTRICTED_SOURCE = 13
};

/* Client side detectable reasons */
enum
{
    LR_LICENSE_NOSAP = 50,
    LR_LICENSE_NOSVP,
    LR_LICENSE_NOWDM,
    LR_LICENSE_NOTRUSTEDCODEC,
    LR_LICENSE_DUMMY_TO_SIGNAL_END2,
    LR_LICENSE_NEED_UPGRADE_MSSAP,        /* special cases as the corresponding error codes in nserror.h are not consecutive to the others */
    LR_LICENSE_INVALID_APPLICATION,
    LR_LICENSE_CLOCK_NOT_SET,
    LR_LICENSE_TIME_CHECK_FAILURE,         /* special case for if the current time is before the first use/store time, rollback is detected, or graceperiod is violated */
    LR_LICENSE_EXTENSIBLE_RIGHT_NOT_FOUND
};

EXIT_PK_NAMESPACE;

#endif /* __LICREASON_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmliceval.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMLICEVAL_H__
#define __DRMLICEVAL_H__

#include <drmsecurestore.h>
#include <drmexpreval.h>
#include <drmblackbox.h>
#if DRM_SUPPORT_REVOCATION
#include <drmrevocationstore.h>
#endif /* DRM_SUPPORT_REVOCATION */
#include <drmmetercertstore.h>
#include <drmsyncstorecontext.h>
#include <drmxmrparser.h>
#include <drmcallbacks.h>

ENTER_PK_NAMESPACE;

/*
** Flags for use with SetLicense method 
*/
enum
{    
    LICEVAL_VERIFY_CERT_WITH_EXPIRYCHECK    = 1,
    LICEVAL_VERIFY_CERT_WITHOUT_EXPIRYCHECK = 2,
    LICEVAL_VERIFY_SIGNATURE                = 4,
    LICEVAL_VERIFY_IGNORE_VERIFICATION      = 8,
    LICEVAL_IGNORE_SECURESTORE_ENTRY        = 16,    
};

#define LICEVAL_STORE_CHECK_SETTINGS ( LICEVAL_VERIFY_CERT_WITH_EXPIRYCHECK | LICEVAL_VERIFY_SIGNATURE ) 
#define LICEVAL_OPEN_CHECK_SETTINGS  ( LICEVAL_VERIFY_CERT_WITHOUT_EXPIRYCHECK | LICEVAL_VERIFY_SIGNATURE )

typedef struct __tagDRM_APPCERT_INFO
{
    DRM_DWORD appSec;
    DRM_DWORD appcd_subject;
} DRM_APPCERT_INFO;

typedef enum
{
    LICEVAL_NOREFERENECE                 = 0,
    LICEVAL_MACHINEDATETIMEREFERENCED    = 1,
    LICEVAL_GRACEPERIODREFERENCED        = 2
} eDRM_LICEVAL_TIMEBASED_STATE;

typedef enum
{    
    eDRM_LIC_CACHED_ATTRIB_KID           = 0,
    eDRM_LIC_CACHED_ATTRIB_LID           = 1,
    eDRM_LIC_CACHED_ATTRIB_CONTENTPUBKEY = 2,
    eDRM_LIC_CACHED_ATTRIB_METERING_ID   = 3,
    eDRM_LIC_CACHED_ATTRIB_CHAINEDKID    = 4,
    eDRM_LIC_CACHED_ATTRIB_LAST          = 5
} eDRM_LIC_CACHED_ATTRIBS;

typedef struct tagDRM_CACHED_EVENT
{
    DRM_CONST_STRING  dstrType;
    DRM_CONST_STRING  dstrAction;
    DRM_CONST_STRING  dstrCondition;
    DRM_CONST_STRING  dstrRestriction;
} DRM_CACHED_EVENT;

#if DRM_SUPPORT_REVOCATION
/*
**  Current revocation list values should be placed in this struct and passed to CompleteChain so licenses can be compared against these
**  values.
*/
typedef struct __tagDRM_REVLIST_ID_VALUES
{
    DRM_BOOL   fUpdatedRevocationList;
    DRM_DWORD  wmdrmapp;
    DRM_DWORD  playreadyapp;
    DRM_DWORD  device;
    DRM_DWORD  wmdrmnet;
    DRM_DWORD  runtime;
    DRM_DWORD  riv;
    DRM_DWORD  riv2;
} DRM_REVLIST_ID_VALUES;
#endif

typedef struct __tagDRM_LICEVAL_CONTEXT
{
    DRM_BB_CONTEXT              *pcontextBBX;
    APPCERT                      appcert;
    EXPR_EVAL_CONTEXT            contextEXPR;
    DRM_CONST_STRING             dstrContentHeader;
    DRM_CONST_STRING             dstrContentLicense;
    DRM_CONST_STRING             dstrBBVer;
    DRM_CONST_STRING             dstrDRMVer;
    DRM_CONST_STRING             dstrDRMKVer;    
    DRM_SECSTORE_CONTEXT        *pcontextSSTLicense;
    DRM_SECSTORE_CONTEXT        *pcontextSSTGlobal;
    DRM_SECSTORE_CONTEXT        *pcontextSSTRevocation;
    DRM_APPCERT_INFO             certinfoSDK;
    DRM_BOOL                     fAppInfoValid;
    DRM_APPCERT_INFO             certinfoApp;
    DRM_BOOL                     fLegacyAppInfoValid;
    DRM_APPCERT_INFO             certinfoAppLegacy;
#if DRM_SUPPORT_CONTENT_REVOCATION
    DRM_DWORD                    dwChainDepth;
#endif
    DRM_BOOL                     fDeviceRegistered;      /* TRUE if the device is registered */
    DRM_LID                      LID;
    DRM_KID                      KID;
    DRM_BOOL                     fGlobalSecStoreWritable;
    DRM_LONG                     lReasonForFail;
    const DRM_CONST_STRING      *pwszPMLicVersion;       /* IN:  Set to a string that represents the PM license version */
    DRM_LONG                     lPMAppSec;              /* IN:  Set to the app sec of the PM */
    DRM_LONG                     lPMRights;              /* This is an OUT param.  If CREATE_PM_LICENSE was queries this will contain the rights bits of the license to create */
    DRMSYSTEMTIME                PMExpiryDate;           /* This is an OUT param.  If CREATE_PM_LICENSE was queries this will contain the expiry date */
    DRM_CONST_STRING             wszDRMKParam;           /* This is an OUT string.  After a license is evaluated this will point to a version string if SAP is required */
    DRM_DWORD                    dwFlags;                /* Default as this LICEVAL_OPEN_CHECK_SETTINGS */
    DRM_BOOL                     fReserved;              /* Must be initialized to 0 */
#if DRM_SUPPORT_SECURE_CLOCK
    DRM_BOOL                     fSSecureTimeDataLoaded; /* Indicates whether we've already attempted to load the proceeding values */
    DRM_BOOL                     fSecureTimeDataValid;   /* Is secure time data valid. Must be initialized to 0 */
    DRM_BOOL                     fInGracePeriod;         /* Is in Grace period */
    DRM_UINT64                   u64GPStartTime;         /*Grace period duration*/
#endif
    DRM_DWORD                    cPlaylistBurnIncrement; /* OUT:  If playlist burn is supported this will set ( if the license also sets it ) */
    DRM_DST                     *pDatastore;
    DRM_BOOL                     fIgnoreTimeBoundLicense;
    eDRM_LICEVAL_TIMEBASED_STATE eTimeBasedState;
#if DRM_SUPPORT_REVOCATION
    DRM_BYTE                    *pbRevocationBuffer;     /* User gives a point to work in.  This is actually going to be used for revocation from the secure store */
    DRM_DWORD                    cbRevocationBuffer;     /* Size of the user supplied pointer */    
    DRM_REVLIST_ID_VALUES        idCRLsCurrent;
    DRM_REVOCATIONSTORE_CONTEXT *pContextRev;
#endif
    DRM_BOOL                     fDeleteLicense;
    DRM_BOOL                     fUseCachedAttribs;
    DRM_CONST_STRING             rgdstrCachedAttribs[ eDRM_LIC_CACHED_ATTRIB_LAST ];
    DRM_CACHED_EVENT             rgCachedEvents[ DRM_MAX_ACTIONS ];
    DRM_DWORD                    cCachedEvents;
#if DRM_SUPPORT_LICENSE_SYNC
    DRM_SYNC_CONTEXT             *pcontextSync;
#endif
#if DRM_SUPPORT_METERING
    DRM_METERCERT_CONTEXT        *pcontextMeterCert;
#endif
    DRM_XMR_LICENSE              *plicenseXMR;
    DRM_BOOL                      fLicenseIsXMR;
    DRM_BOOL                      fTargetStoreTemorary;
    DRM_BOOL                      fIsReadOnlyMode;
    DRM_DWORD                     rgdwAllowedSourceIDs[XMR_SOURCEID_MAXCOUNT];
    DRM_DWORD                     cAllowedSourceIDs;  
    DRM_BOOL                      fAllowAllSourceIDs;

    /*
    ** OUT: When evaluating the Copy right, if the license is domain bound without
    **  an explicit copy right, but is not bound to any of the domains given
    **  (or no domains were given), the evaluation will fail because copy isn't allowed,
    **  but fCopyDestDomainAccountIDRequired will be set to TRUE and the associated data
    **  will indicate to the caller which domain the copy destination must join
    **  in order for the copy to be allowed.
    */
    DRM_BOOL                      fCopyDestDomainAccountIDRequired;
    DRM_GUID                      guidCopyDestDomainAccountIDRequired;
    DRM_DWORD                     dwCopyDestDomainRevisionRequired;

    /*
    ** OUT: When evaluating the Copy right, if the license is a LEAF license,
    **  and the license does not have the Copy right, then evaluation will
    **  still succeed and this value will get set to TRUE.
    ** It is then the caller's responsibility to validate that this license
    **  chains up to a valid domain-bound root license before allowing Copy
    **  to succeed.
    ** This applies to the Copy right by itself as well as the Copy right
    **  with either the Copy To PC or Copy To Device action qualifier.
    ** This does NOT apply to the Copy right with any other action qualifier.
    */
    DRM_BOOL                      fDomainBoundRootRequired;
} DRM_LICEVAL_CONTEXT;

typedef enum
{
    DRM_LICENSE_EVAL_SELECT               = 1,
    DRM_LICENSE_EVAL_DELETE               = 2,
    DRM_LICENSE_EVAL_STORE                = 3,
    DRM_LICENSE_EVAL_REPORTCLOCK_ROLLBACK = 4, /* Only use DRM_LICENSE_EVAL_DONE_WITH_OPERATION for clock rollback. */
    DRM_LICENSE_EVAL_ACTION               = 5  /* With ACTION you must provide an action string */
} eDRM_LICEVAL_OPERATIONS;

typedef enum
{
    DRM_LICENSE_EVAL_CAN_DO_OPERATION    = 1,
    DRM_LICENSE_EVAL_DONE_WITH_OPERATION = 2
} eDRM_LICEVAL_OPERATION_STATE;

DRM_API DRM_RESULT DRM_CALL DRM_LEVL_SearchQualifierGuidInEnablerContainer(
    __in     DRM_GUID const                    *f_pdguidActionQualifier,
    __in     DRM_XMR_UNKNOWN_CONTAINER const   *f_pEnablerContainer,
    __in     DRM_WORD const                     f_wContainerType,
    __in     DRM_WORD const                     f_wObjectType,
    __inout  DRM_BOOL                          *f_pfFound );

DRM_API DRM_RESULT DRM_CALL DRM_LEVL_PerformOperations(
    IN OUT   DRM_LICEVAL_CONTEXT             *f_pContextLicEval,
    IN       eDRM_LICEVAL_OPERATIONS          f_eOperation,
    IN       eDRM_LICEVAL_OPERATION_STATE     f_eOperationState,
    IN const DRM_CONST_STRING                *f_pdstrAction,     
    OUT      DRM_BOOL                        *f_pfPerform,
    OUT      DRM_BOOL                        *f_pfActionExisted,
    IN const DRM_DST                         *f_pDatastore,
    IN       DRMPFNPOLICYCALLBACK             f_pfnPolicyCallback,
    IN const DRM_VOID                        *f_pv );

DRM_API DRM_RESULT DRM_CALL DRM_LEVL_PerformOperationsXMR(
    __inout     DRM_LICEVAL_CONTEXT          *f_pContextLicEval,
    __in        eDRM_LICEVAL_OPERATIONS       f_eOperation,
    __in        eDRM_LICEVAL_OPERATION_STATE  f_eOperationState,
    __in_opt    DRM_GUID const               *f_pdguidAction,
    __in_opt    DRM_GUID const               *f_pdguidActionQualifier,
    __in        DRM_DWORD const               f_dwRightID,
    __out_opt   DRM_BOOL                     *f_pfPerform,
    __out_opt   DRM_BOOL                     *f_pfActionExisted,
    __in        DRM_DST const                *f_pDatastore,
    __in_opt    DRMPFNPOLICYCALLBACK          f_pfnPolicyCallback,
    __in_opt    DRM_VOID const               *f_pv );

DRM_API DRM_RESULT DRM_CALL DRM_LEVL_EvaluateExpression(
    IN OUT    DRM_LICEVAL_CONTEXT            *f_pContextLicEval,
    IN  const DRM_CONST_STRING               *f_pdstrExpression,
    OUT       DRM_BOOL                       *f_pfValue );

DRM_API DRM_RESULT DRM_CALL DRM_LEVL_IsLicenseReadyForDeletion( 
    IN OUT    DRM_LICEVAL_CONTEXT            *f_pContext,
    OUT       DRM_BOOL                       *f_pfDelete );

DRM_API DRM_RESULT DRM_CALL DRM_LEVL_GetLicenseReasonForUnusable(
    IN  const DRM_LICEVAL_CONTEXT           *f_pcontextLicEval,
    OUT       DRM_LONG                      *f_plReasonForUnusable );

EXIT_PK_NAMESPACE;

#endif /* __DRMLICEVAL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmlicacqv3constants.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_LICACQ_V3_CONSTANTS_H
#define __DRM_LICACQ_V3_CONSTANTS_H

ENTER_PK_NAMESPACE;

/*
** ---------------------------------------------------------
** XML strings used in the construction of license challenge
** ---------------------------------------------------------
*/
extern const DRM_ANSI_CONST_STRING g_dastrLicAcqRootTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqVersionTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqChallenge1Tag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqChallenge2Tag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqLATag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqContentHeaderTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqClientInfoTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqClientVersionTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqSecurityVersionTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqAppSecurityTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqSubjectID1Tag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqSubjectID2Tag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqDRMKVersionTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqRevocationListsTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqRevListInfoTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqRevListIDTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqRevVersionTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqCertificateChainsTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqCertificateChainTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqDataTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqUplinksTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqUplinkTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqKIDTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqCategoryTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqCountTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqDateTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqVagueTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqCustomDataTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqLicenseNonceTag;


extern const DRM_ANSI_CONST_STRING g_dastrLicAcqRootAttribName;
extern const DRM_ANSI_CONST_STRING g_dastrLicAcqRootAttribValue;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqChallenge2AttribName;
extern const DRM_ANSI_CONST_STRING g_dastrLicAcqChallenge2AttribValue;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqChallengeVAAttrib1Name;
extern const DRM_ANSI_CONST_STRING g_dastrLicAcqChallengeVAAttrib1Value;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqChallengeVAAttrib2Name;
extern const DRM_ANSI_CONST_STRING g_dastrLicAcqChallengeVAAttrib2Value;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqVersionValue;


/*
** ---------------------------------------------------------------
** XML strings used in the construction of license acknowledgement
** ---------------------------------------------------------------
*/
extern const DRM_ANSI_CONST_STRING g_dastrLicAckRootTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAckVersionTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAckChallenge1Tag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAckChallenge2Tag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAckAckTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAckDataTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAckTransactionIDTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAckLicenseStorageResultsTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAckLicenseTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAckKIDTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAckLIDTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAckResultTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAckCertificateChainTag;


extern const DRM_ANSI_CONST_STRING g_dastrLicAckRootAttribName;
extern const DRM_ANSI_CONST_STRING g_dastrLicAckRootAttribValue;

extern const DRM_ANSI_CONST_STRING g_dastrLicAckChallenge2AttribName;
extern const DRM_ANSI_CONST_STRING g_dastrLicAckChallenge2AttribValue;

extern const DRM_ANSI_CONST_STRING g_dastrLicAckAckAttrib1Name;
extern const DRM_ANSI_CONST_STRING g_dastrLicAckAckAttrib1Value;

extern const DRM_ANSI_CONST_STRING g_dastrLicAckAckAttrib2Name;
extern const DRM_ANSI_CONST_STRING g_dastrLicAckAckAttrib2Value;

extern const DRM_ANSI_CONST_STRING g_dastrLicAckVersionValue;


/*
** -----------------------------------------------------
** XML strings used in the construction of SOAP envelope
** -----------------------------------------------------
*/
extern const DRM_ANSI_CONST_STRING g_dastrXMLRootTag;

extern const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeTag;

extern const DRM_ANSI_CONST_STRING g_dastrSOAPBodyTag;


extern const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib1Name;
extern const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib1Value;

extern const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib2Name;
extern const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib2Value;

extern const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib3Name;
extern const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib3Value;


/*
** ---------------------------------------------------
** XML strings used in the parsing of license response
** ---------------------------------------------------
*/
extern const DRM_ANSI_CONST_STRING g_dastrLicLicenseResponsePath;

extern const DRM_ANSI_CONST_STRING g_dastrLicSignaturePath;

extern const DRM_ANSI_CONST_STRING g_dastrLicLicensesPath;

extern const DRM_ANSI_CONST_STRING g_dastrLicLicensePath;

extern const DRM_ANSI_CONST_STRING g_dastrAcquireLicenseResultTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicRevInfoPath;

extern const DRM_ANSI_CONST_STRING g_dastrRevInfo;

extern const DRM_ANSI_CONST_STRING g_dastrLicRevocationPath;

extern const DRM_ANSI_CONST_STRING g_dastrLicTransactionIDPath;
/*
extern const DRM_ANSI_CONST_STRING g_dastrLicRevocationAttribName;
*/
extern const DRM_ANSI_CONST_STRING g_dastrLicSLKPath;

extern const DRM_ANSI_CONST_STRING g_dastrLicRevocationAttribName;

extern const DRM_ANSI_CONST_STRING g_dastrLicListIdPath;

extern const DRM_ANSI_CONST_STRING g_dastrLicListDataPath;


/*
** ---------------------------------------------------------------
** XML strings used in the parsing of license acknowledge response
** ---------------------------------------------------------------
*/
extern const DRM_ANSI_CONST_STRING g_dastrAcquireLicenseResponseTag;

extern const DRM_ANSI_CONST_STRING g_dastrLicAcqLAckPath;

extern const DRM_ANSI_CONST_STRING g_dastrLicAckSignaturePath;


/*
** ----------------------------------------------
** XML strings used in the parsing of custom data
** ----------------------------------------------
*/
extern const DRM_ANSI_CONST_STRING g_dastrLicAcqCustomDataPath;

extern const DRM_ANSI_CONST_STRING g_dastrLicAckCustomDataPath;

EXIT_PK_NAMESPACE;

#endif /* __DRM_LICACQ_V3_CONSTANTS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmlicenseparser.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMLICENSEPARSER_H__
#define __DRMLICENSEPARSER_H__

ENTER_PK_NAMESPACE;

typedef enum
{
    DRM_LICENSE_ATTRIB_VERSION        =  1,
    DRM_LICENSE_ATTRIB_KID            =  2,
    DRM_LICENSE_ATTRIB_LID            =  3,
    DRM_LICENSE_ATTRIB_REVOCATION     =  4,
    DRM_LICENSE_ATTRIB_ISSUEDATE      =  5,
    DRM_LICENSE_ATTRIB_CONTENTPUBKEY  =  6,
    DRM_LICENSE_ATTRIB_META_ATTRIBUTE =  7,
    DRM_LICENSE_ATTRIB_OTHER          =  8,
    DRM_LICENSE_ATTRIB_PRIORITY       =  9,
    DRM_LICENSE_ATTRIB_METERING_ID    = 10,
    DRM_LICENSE_ATTRIB_CHAINEDKID     = 11,
    DRM_LICENSE_ATTRIB_REVINFO        = 12,
    DRM_LICENSE_ATTRIB_SOURCEID       = 13
} eDRM_LICENSE_ATTRIBUTES;

DRM_API DRM_RESULT DRM_CALL DRM_LIC_GetAttribute(
    IN const DRM_CONST_STRING        *pdstrLicense, 
    IN const DRM_CONST_STRING        *pdstrAttrName,
    IN       eDRM_LICENSE_ATTRIBUTES  eAttribute,
    IN  OUT  DRM_CONST_STRING        *pdstrLIData,
        OUT  DRM_CONST_STRING        *pdstrValue,
    IN       DRM_WCHAR                chXPathSeparator);

DRM_API DRM_RESULT DRM_CALL DRM_LIC_GetEvent(
    IN const DRM_CONST_STRING *pdstrLicense, 
    IN const DRM_CONST_STRING *pdstrEvent, 
    IN const DRM_CONST_STRING *pdstrTypeValue, 
    IN  OUT  DRM_CONST_STRING *pdstrLIData,
    OUT      DRM_CONST_STRING *pdstrCondition,     
    OUT      DRM_CONST_STRING *pdstrAction,
    OUT      DRM_CONST_STRING *pdstrRestriction); /* OPTIONAL */

DRM_API DRM_RESULT DRM_CALL DRM_LIC_GetEnablingBits(
    IN const DRM_CONST_STRING   *pdstrLicense,
    IN       DRM_DWORD           dwIndex,
    OUT      DRM_DWORD          *pdwAlgorithm,
    OUT      PUBKEY             *pPubKey, 
    __out_bcount_opt( *pdValueLen ) DRM_BYTE *pbValue, 
    OUT      DRM_DWORD          *pdValueLen, 
    OUT      PUBKEY             *pVerPubKey, 
    __out_bcount( DRM_ECC160_SIGNATURE_LEN ) DRM_BYTE *pbSignature,
    __out_bcount_opt( CHECKSUM_LENGTH ) DRM_BYTE rgbChainedChecksum[__CB_DECL(CHECKSUM_LENGTH)],
    IN       DRM_CRYPTO_CONTEXT *pcontextCrypto);

DRM_API DRM_RESULT DRM_CALL DRM_LIC_VerifySignature(
    IN const DRM_CONST_STRING   *pdstrLicense,
    IN       DRM_BB_CONTEXT     *pcontextBBX,
    OUT      DRM_LONG           *plResult);

DRM_API DRM_RESULT DRM_CALL DRM_LIC_VerifyCertChain(
    IN const DRM_CONST_STRING    *pdstrLicense, 
    IN       DRM_BOOL             fCheckExpiry,
    IN       DRM_LICEVAL_CONTEXT *pcontextLEVL,
    OUT      DRM_LONG            *plResult);

DRM_API DRM_RESULT DRM_CALL DRM_LIC_GetInclusionList(
    IN const DRM_CONST_STRING  *pdstrContentRevocation, 
    IN OUT   DRM_GUID           rgInclusionList[DRM_MAX_INCLUSION_GUIDS],
    IN OUT   DRM_BOOL           rgfGuidValid[DRM_MAX_INCLUSION_GUIDS][DRM_MAX_LICENSE_CHAIN_DEPTH],
    IN       DRM_DWORD          dwChainDepth );

#if DRM_SUPPORT_CONTENT_REVOCATION

DRM_API DRM_RESULT DRM_CALL DRM_LIC_VerifyContentRevocation(
    IN const DRM_CONST_STRING   *pdstrContentRevocation, 
    OUT      DRM_CONST_STRING   *pdstrLSPubKey,
    OUT      DRM_DWORD          *pdwSequenceNumber,
    OUT      DRM_CONST_STRING   *pdstrContentOwnerPubKey,
    OUT      DRM_CONST_STRING   *pdstrCondition,
    IN       DRM_CRYPTO_CONTEXT *pcontextCrypto);

DRM_API DRM_RESULT DRM_CALL DRM_LIC_GetContentRevocation(
    IN const DRM_CONST_STRING   *pdstrLicense,
    IN       DRM_DWORD           dwSequenceNumber,
    OUT      DRM_DWORD          *pdwSequenceNumber,
    OUT      DRM_CONST_STRING   *pdstrContentRevocation,
    OUT      DRM_CONST_STRING   *pdstrContentOwnerPubKey,
    OUT      DRM_CONST_STRING   *pdstrCondition,
    IN       DRM_CRYPTO_CONTEXT *pcontextCrypto);

#endif

EXIT_PK_NAMESPACE;

#endif /* __DRMLICENSEPARSER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmlicstore.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRM_LICSTORE_H__
#define __DRM_LICSTORE_H__

#include <drmdatastore.h>

ENTER_PK_NAMESPACE;

/*
** License store context size 
*/
#define MAX_PRILIC_LIST     10

typedef enum _tageDRM_LICENSE_STORE_TYPE
{
    eDRM_LICENSE_STORE_XML  = 1,
    eDRM_LICENSE_STORE_XMR  = 2,
    eDRM_LICENSE_STORE_TEMP = 3		// Added for the PC client
} eDRM_LICENSE_STORE_TYPE;

/*
** License store context stucture. 
** This contains the DST namespace context it is using and
** the local stack info for internal use
*/
typedef struct _tagDRM_LICSTORE_CONTEXT
{    
    DRM_DST_SLOT_CONTEXT       SlotContext;
    DRM_DST_NAMESPACE_CONTEXT  DstNamespaceContext;
    DRM_DST                   *pDatastore;
    DRM_BOOL                   fInited;
    eDRM_LICENSE_STORE_TYPE    eType;
} DRM_LICSTORE_CONTEXT;

/*
** License store modes
*/
typedef enum _tageDRM_LICENSE_STORE_MODE
{
    /*
    ** no license found 
    */
    eDRM_LICENSE_STORE_MODE_NONE                = 0, 
    /*
    ** a local list of license's KID and LID is loaded for query 
    */
    eDRM_LICENSE_STORE_MODE_PRIORITIZED         = 1,
    /*
    ** enum for licenses matching given KID 
    */ 
    eDRM_LICENSE_STORE_MODE_FILTERED            = 2,
    /*
    ** enum all licenses 
    */
    eDRM_LICENSE_STORE_MODE_NATURAL             = 3,
    /*
    ** enum licenses matching KID after eDRM_LICENSE_STORE_MODE_PRIORITIZED exhausted 
    */
    eDRM_LICENSE_STORE_MODE_POST_PRIORITIZED    = 4 ,
    /*
    ** enum licenses in reverse priority order
    */
    eDRM_LICENSE_STORE_MODE_REVERSE_PRIORITIZED = 5
} eDRM_LICENSE_STORE_MODE;

/*
** Prioritized license
*/
typedef struct _tagDRM_PRIORITIZED_LICENSE
{
    DRM_DWORD         dwPriority;   /* the higher the value, the higher the priority */
    DRM_LID           LID;
    DRM_BOOL          fDelete;
    DRM_DST_SLOT_HINT slotHint;
} DRM_PRIORITIZED_LICENSE;

/*
** Prioritized license list
*/
typedef struct _tagDRM_PRIORITIZED_LICENSE_LIST 
{
    DRM_KID                 KID;
    DRM_DWORD               iNextLicense;
    DRM_DWORD               cLicenses; /* # of license slot used in the array */
    DRM_PRIORITIZED_LICENSE rgPrioritizedList[MAX_PRILIC_LIST + 1]; /* one extra for working buffer */
} DRM_PRIORITIZED_LICENSE_LIST;

/*
** Non-prioritized license
*/
typedef struct _tagDRM_NONPRIORITIZED_LICENSE
{
    DRM_BOOL  fCurrIsValid;
    DRM_KID   CurrKID;
    DRM_LID   CurrLID;
} DRM_NONPRIORITIZED_LICENSE;

/*
** License Store enumeration context
*/
typedef struct _tag_DRM_LICSTOREENUM_CONTEXT
{
    DRM_LICSTORE_CONTEXT    *pLicContext;
    DRM_DST_ENUM_CONTEXT     DstEnumContext;
    DRM_DST_SLOT_CONTEXT     SlotContext;
    DRM_BOOL                 fInited;
    eDRM_LICENSE_STORE_MODE  eMode;
    
    struct
    {
        DRM_PRIORITIZED_LICENSE_LIST  Prioritized;
        DRM_NONPRIORITIZED_LICENSE    NonPrioritized;
    } List;
    
} DRM_LICSTOREENUM_CONTEXT;

/*
** The maximum number of stores for multiple enumeration
*/
#define DRM_LICSTORE_MAX_STORES 3

/*
** License Store enumeration context for enumeration
** over multiple stores
*/
typedef struct _tag_DRM_LICSTOREENUM_MULTIPLE_CONTEXT
{
    DRM_LICSTOREENUM_CONTEXT   rgLicContexts[DRM_LICSTORE_MAX_STORES];    
    DRM_DWORD                  cLicContexts;

    DRM_BOOL                   fInited;
    eDRM_LICENSE_STORE_MODE    eMode;

    DRM_LICSTOREENUM_CONTEXT  *pCurEnum; /* Pointer to the enumeration context for the next license */

} DRM_LICSTOREENUM_MULTIPLE_CONTEXT;


/* 
** API Functions 
*/

DRM_API DRM_RESULT DRM_CALL DRM_LST_Open( 
    OUT    DRM_LICSTORE_CONTEXT    *f_pLicContext,
    IN     DRM_DST                 *f_pDatastore,
    IN     eDRM_LICENSE_STORE_TYPE  f_eLicenseStoreType ); 

DRM_API DRM_RESULT DRM_CALL DRM_LST_Close( IN OUT DRM_LICSTORE_CONTEXT *f_pLicContext );

DRM_API DRM_RESULT DRM_CALL DRM_LST_AddLicense(
    IN OUT DRM_LICSTORE_CONTEXT     *f_pLicContext,
    IN     DRM_DWORD                 f_cbLicense,
    __in_bcount( f_cbLicense ) DRM_BYTE *f_pbLicense,
    IN     DRM_KID                  *f_pKID,
    IN     DRM_LID                  *f_pLID,
    IN     DRM_DWORD                 f_dwPriority );

DRM_API DRM_RESULT DRM_CALL DRM_LST_GetLicense( 
    IN     DRM_LICSTORE_CONTEXT     *f_pLicContext,
    IN     DRM_KID                  *f_pKID,      
    IN     DRM_LID                  *f_pLID, 
    IN     DRM_DST_SLOT_HINT        *f_pSlotHint,
    __out_bcount_opt( *f_pcbLicense ) DRM_BYTE *f_pbLicense, 
    IN OUT DRM_DWORD                *f_pcbLicense );

DRM_API DRM_RESULT DRM_CALL DRM_LST_DeleteLicense(
    IN OUT DRM_LICSTORE_CONTEXT     *f_pLicContext,
    IN     DRM_KID                  *f_pKID,
    IN     DRM_LID                  *f_pLID, 
    IN     DRM_DST_SLOT_HINT        *f_pSlotHint );

DRM_RESULT DRM_CALL DRM_LST_DeleteLicenseAndSaveDate(
    IN OUT DRM_LICSTORE_CONTEXT *f_pcontextLS,
    IN     DRM_KID              *f_pkid,
    IN     DRM_LID              *f_plid,    
    IN     DRM_DST_SLOT_HINT    *f_pSlotHint,
    IN     DRM_BOOL              f_fSaveDate );

DRM_API DRM_RESULT DRM_CALL DRM_LST_InitEnum(
    IN     DRM_LICSTORE_CONTEXT     *f_pLicContext, 
    IN     DRM_KID                  *f_pKID,         
    IN     DRM_BOOL                  f_fPrioritized, 
    OUT    DRM_LICSTOREENUM_CONTEXT *f_pLicEnumContext ); 

DRM_API DRM_RESULT DRM_CALL DRM_LST_InitReverseEnum(
    IN  DRM_LICSTORE_CONTEXT     *f_pLicContext, 
    IN  DRM_KID                  *f_pKID,           
    OUT DRM_LICSTOREENUM_CONTEXT *f_pLicEnumContext );

DRM_API DRM_RESULT DRM_CALL DRM_LST_EnumNext( 
    IN     DRM_LICSTOREENUM_CONTEXT *f_pLicEnumContext,
    OUT    DRM_KID                  *f_pKID,              
    OUT    DRM_LID                  *f_pLID,
    OUT    DRM_DST_SLOT_HINT        *f_pSlotHint,
    OUT    DRM_DWORD                *f_pcbLicense );       

DRM_API DRM_RESULT DRM_CALL DRM_LST_EnumDelete( IN DRM_LICSTOREENUM_CONTEXT *f_pLicEnumContext );

DRM_API DRM_RESULT DRM_CALL DRM_LST_EnumDeleteAndSaveDate( 
    IN     DRM_LICSTOREENUM_CONTEXT *f_pLicEnumContext,
    IN     DRM_BOOL                  f_fSaveDate );

DRM_API DRM_RESULT DRM_CALL DRM_LST_LicCount( 
    IN     DRM_LICSTOREENUM_CONTEXT *f_pLicEnumContext, 
    OUT    DRM_DWORD                *f_pcLicenses );

DRM_API DRM_RESULT DRM_CALL DRM_LST_InitEnumMultiple(
    __in_ecount( f_cLicContexts )  DRM_LICSTORE_CONTEXT             **f_prgbLicContexts, 
    __in                           DRM_DWORD                          f_cLicContexts,
    __in_opt                       DRM_KID                           *f_pKID,         
    __in                           DRM_BOOL                           f_fPrioritized, 
    __out                          DRM_LICSTOREENUM_MULTIPLE_CONTEXT *f_pLicEnumContext ); 

DRM_API DRM_RESULT DRM_CALL DRM_LST_EnumNextMultiple( 
    __in       DRM_LICSTOREENUM_MULTIPLE_CONTEXT *f_pLicEnumContext,
    __out_opt  DRM_KID                           *f_pKID,              
    __out_opt  DRM_LID                           *f_pLID,
    __out_opt  DRM_LICSTORE_CONTEXT             **f_ppLicStore,
    __out_opt  DRM_DST_SLOT_HINT                 *f_pSlotHint,    
    __out_opt  DRM_DWORD                         *f_pcbLicense );

DRM_API DRM_RESULT DRM_CALL DRM_LST_EnumDeleteMultiple( __in DRM_LICSTOREENUM_MULTIPLE_CONTEXT *f_pLicEnumContext );

/**********************************************************************
** 
** Function :   pfnStoreCleanupProgress
** 
** Synopsis :   Callback function to report progress during License 
**              store cleanup
** 
** Arguments :  
**      [f_pvCallerData]       : Opaque context data provided to DRM_LST_Clean
**      [f_cLicensesProcessed] : Count of licenses processed
**      [f_cTotalLicenses]     : Count of total licenses in the store
**
** Returns :    
**      DRM_SUCCESS
**          Success     
** 
**********************************************************************/
typedef DRM_RESULT ( DRM_CALL *pfnStoreCleanupProgress )( 
    IN  const DRM_VOID    *f_pvCallerData, 
    IN        DRM_DWORD    f_cLicensesProcessed,
    IN        DRM_DWORD    f_cTotalLicenses );

DRM_API DRM_RESULT DRM_CALL DRM_LST_Clean (
    IN DRM_BYTE *f_pContextLEVL,
    __in_bcount( SIZEOF( DRM_LICSTORE_CONTEXT ) ) DRM_BYTE *f_pContextLSTXML,
    __in_bcount( SIZEOF( DRM_LICSTORE_CONTEXT ) ) DRM_BYTE *f_pContextLSTXMR,
    __in DRM_LICSTOREENUM_CONTEXT *f_pLicStoreEnumContext,
    __in_bcount(f_cbBuffer ) DRM_BYTE *f_pbBuffer,
    IN       DRM_DWORD                f_cbBuffer,
    IN const DRM_VOID                *f_pvCallerData,
    IN       DRM_DWORD                f_dwCallbackInterval,
    IN       pfnStoreCleanupProgress  f_pfnCallback,
    IN       DRM_DST                 *f_pDatastore );

EXIT_PK_NAMESPACE;

#endif  /* __DRM_LICSTORE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmmd5.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMMD5_H__
#define __DRMMD5_H__ 1

ENTER_PK_NAMESPACE;

#define MD5DIGESTLEN 16

typedef struct __tagDRM_MD5_CTX {
    DRM_DWORD awaiting_data[16];
                             /* Data awaiting full 512-bit block.       */
                             /* Length (nbit_total[0] % 512) bits.      */
                             /* Unused part of buffer (at end) is zero. */
    DRM_DWORD partial_hash[4];
                             /* Hash through last full block            */
    DRM_DWORD nbit_total[2];       
                             /* Total length of message so far          */
                             /* (bits, mod 2^64)                        */
    DRM_BYTE digest[__CB_DECL(MD5DIGESTLEN)];
                             /* Actual digest after MD5Final completes  */
} DRM_MD5_CTX;

DRM_API DRM_VOID DRM_CALL DRM_MD5_Init( IN OUT DRM_MD5_CTX *f_contextMD5);

DRM_API DRM_VOID DRM_CALL DRM_MD5_Update(
    IN OUT   DRM_MD5_CTX *f_contextMD5, 
    IN const DRM_VOID    *f_pbData, 
    IN       DRM_DWORD    f_cbData);

DRM_API DRM_VOID DRM_CALL DRM_MD5_Final( IN OUT DRM_MD5_CTX *f_contextMD5);

EXIT_PK_NAMESPACE;

#endif /* __DRMMD5_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmmanager.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMMANAGER_H__
#define __DRMMANAGER_H__

#include <drmcommon.h>
#if DRM_SUPPORT_REVOCATION
#include <drmrevocation.h>
#endif /* DRM_SUPPORT_REVOCATION */
#include <drmcontextsizes.h>
#include <drmviewprops.h>
#include <drmenvelope.h>
#include <drmcallbacks.h>

ENTER_PK_NAMESPACE;

typedef struct
{
    DRM_BYTE rgbBuffer[ __CB_DECL( SIZEOF( DRM_CIPHER_CONTEXT ) ) ];
} DRM_DECRYPT_CONTEXT;

#if !DRM_LICENSE_STATE_TYPES_DEFINED
#define DRM_LICENSE_STATE_TYPES_DEFINED 1
#endif /* DRM_LICENSE_STATE_TYPES_DEFINED */

typedef enum
{
    DRM_DGP_DEVICE_CERT_MD    = 1,
    DRM_DGP_DEVICE_CERT_PD    = 2,
    DRM_DGP_CLIENT_INFO       = 3,
    DRM_DGP_PLAYREADY_VERSION = 4,
    DRM_DGP_SECURITY_VERSION  = 5,
    DRM_DGP_WMDRMPD_VERSION   = 6
} DRM_DEVICE_GET_PROPERTY;

/*
** pbKeyID:      Array of bytes that contains the KeyID from the V1 ASF header object.
** cbKeyID:      Count of bytes in pbKeyID.
** pbSecretData: Array of bytes that contains the SecretData from the V1 ASF header.
** cbSecretData: Count of bytes in pbSecretData.
** pbURL:        Array of bytes that contains the license acquisition URL from the V1 ASF header.
** cbURL:        Count of bytes in pbURL.
*/
typedef struct
{
    const DRM_BYTE *pbKeyID;

    DRM_DWORD       cbKeyID;

    const DRM_BYTE *pbSecretData;

    DRM_DWORD       cbSecretData;

    const DRM_BYTE *pbURL;

    DRM_DWORD       cbURL;

} DRM_CSP_V1_HEADER_DATA;

typedef enum
{
    DRM_LGP_MIN_APP_SEC = 1,
    DRM_LGP_SOURCE_ID,
    DRM_LGP_REVINFO_VERSION,
    DRM_LGP_MID,
    DRM_LGP_HAS_INCLUSION_GUID
} DRM_LICENSE_GET_PROPERTY;

typedef struct
{
    DRM_CHAR szMID[ DRM_MAX_LICENSE_CHAIN_DEPTH ][ CCH_BASE64_EQUIV( SIZEOF( DRM_MID ) ) ] ;
} DRM_LGP_MID_EXTRA_DATA;

typedef struct
{
    DRM_GUID guid;
} DRM_LGP_HAS_INCLUSION_GUID_EXTRA_DATA;

/* Strings to be used from DRMManager */
extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_PLAYBACK;

EXIT_PK_NAMESPACE;

#include <drmviewprops.h>

ENTER_PK_NAMESPACE;

typedef struct
{
    /* This data is Opaque.  Do not set any value in it. */
    DRM_BYTE rgbOpaqueBuffer[ __CB_DECL( DRM_APP_CONTEXT_BUFFER_SIZE ) ];
} DRM_APP_CONTEXT;

#define DRM_METER_RESPONSE_PARTIAL              0x00000001

EXIT_PK_NAMESPACE;

#if DRM_SUPPORT_DOMAINS

#include <drmdomainapi.h>

#endif /* DRM_SUPPORT_DOMAINS */

#if DRM_SUPPORT_METERING

#include <drmmeterapi.h>

#endif /* DRM_SUPPORT_METERING */

#include <drmlicacqv3.h>

#include <drmsoapxmlutility.h>

ENTER_PK_NAMESPACE;

DRM_API DRM_RESULT DRM_CALL _SetupLicEvalObjectToShare(
    IN DRM_APP_CONTEXT_INTERNAL *f_poAppContextInternal );

DRM_API DRM_RESULT DRM_CALL Drm_Initialize(
    IN       DRM_APP_CONTEXT  *f_poAppContext,
    IN       DRM_VOID         *f_pOEMContext,
    IN const DRM_CONST_STRING *f_pdstrDeviceStoreName );

DRM_API DRM_VOID DRM_CALL Drm_Uninitialize(
    IN DRM_APP_CONTEXT *f_poAppContext );

DRM_API DRM_RESULT DRM_CALL Drm_Reinitialize(
    IN DRM_APP_CONTEXT *f_poAppContext );

DRM_API DRM_VOID DRM_CALL Drm_ClearAllCaches( DRM_VOID );

DRM_API DRM_RESULT DRM_CALL Drm_Content_SetProperty(
    IN                                        DRM_APP_CONTEXT          *f_poAppContext,
    IN                                        DRM_CONTENT_SET_PROPERTY  f_eProperty,
    __in_bcount_opt( f_cbPropertyData ) const DRM_BYTE                 *f_pbPropertyData,
    IN                                        DRM_DWORD                 f_cbPropertyData );

DRM_API DRM_RESULT DRM_CALL Drm_Content_GetProperty(
    __inout                                DRM_APP_CONTEXT          *f_poAppContext,
    __in                                   DRM_CONTENT_GET_PROPERTY  f_eProperty,
    __out_bcount_opt( *f_pcbPropertyData ) DRM_BYTE                 *f_pbPropertyData,
    __inout                                DRM_DWORD                *f_pcbPropertyData );

DRM_API DRM_RESULT DRM_CALL Drm_Content_UpdateEmbeddedStore(
    __in    DRM_APP_CONTEXT     *f_poAppContext );

DRM_API DRM_RESULT DRM_CALL Drm_Content_UpdateEmbeddedStore_Commit(
    __in    DRM_APP_CONTEXT     *f_poAppContext );

DRM_API DRM_RESULT DRM_CALL Drm_Device_GetProperty(
    IN                                  DRM_APP_CONTEXT         *f_poAppContext,
    IN                                  DRM_DEVICE_GET_PROPERTY  f_eProperty,
     __out_bcount_opt( *f_pcbProperty ) DRM_BYTE                *f_pbProperty,
    IN OUT                              DRM_DWORD               *f_pcbProperty );

#if DRM_SUPPORT_DLA

#if DRM_SUPPORT_LICENSE_SYNC

DRM_API DRM_RESULT DRM_CALL Drm_SyncListItem_InitEnum(
    IN DRM_APP_CONTEXT *f_poAppContext );

DRM_API DRM_RESULT DRM_CALL Drm_SyncListItem_EnumNext(
    IN  DRM_APP_CONTEXT *f_poAppContext,
    IN  DRM_DWORD        f_cMaxCount,
    IN  DRM_DWORD        f_cMaxHours,
    OUT DRM_KID         *f_pKID );

#endif  /* DRM_SUPPORT_LICENSE_SYNC */

DRM_API DRM_RESULT DRM_CALL Drm_LicenseAcq_GenerateChallenge(
    IN                                      DRM_APP_CONTEXT  *f_poAppContext,
    __in_ecount( f_cRights ) const          DRM_CONST_STRING *f_rgpdstrRights[],
    IN                                      DRM_DWORD         f_cRights,
    IN const                                DRM_DOMAIN_ID    *f_poDomainID,
    __in_ecount_opt( f_cchCustomData )      DRM_CHAR         *f_pchCustomData,
    IN                                      DRM_DWORD         f_cchCustomData,
    __out_ecount_opt( *f_pcchSilentURL )    DRM_CHAR         *f_pchSilentURL,
    IN OUT                                  DRM_DWORD        *f_pcchSilentURL,
    __out_ecount_opt( *f_pcchNonSilentURL ) DRM_CHAR         *f_pchNonSilentURL,
    IN OUT                                  DRM_DWORD        *f_pcchNonSilentURL,
    __out_bcount_opt( *f_pcbChallenge )     DRM_BYTE         *f_pbChallenge,
    IN OUT                                  DRM_DWORD        *f_pcbChallenge );

#endif  /* DRM_SUPPORT_DLA */

DRM_API DRM_RESULT DRM_CALL Drm_LicenseAcq_ProcessResponse(
    IN                          DRM_APP_CONTEXT           *f_poAppContext,
    IN                          pfnLicenseResponseCallback f_pfnCallback,
    IN                          DRM_VOID                  *f_pvCallbackContext,
    __in_bcount( f_cbResponse ) DRM_BYTE                  *f_pbResponse,
    IN                          DRM_DWORD                  f_cbResponse,
    OUT                         DRM_LICENSE_RESPONSE      *f_poLicenseResponse );

DRM_API DRM_RESULT DRM_CALL Drm_Reader_Bind(
    IN                             DRM_APP_CONTEXT      *f_poAppContext,
    __in_ecount( f_cRights ) const DRM_CONST_STRING     *f_rgpdstrRights[],
    IN                             DRM_DWORD             f_cRights,
    IN                             DRMPFNPOLICYCALLBACK  f_pfnPolicyCallback,
    IN const                       DRM_VOID             *f_pv,
    OUT                            DRM_DECRYPT_CONTEXT  *f_pcontextDCRY );

DRM_API DRM_RESULT DRM_CALL Drm_Reader_Commit(
    IN       DRM_APP_CONTEXT      *f_poAppContext,
    IN       DRMPFNPOLICYCALLBACK  f_pfnPolicyCallback,
    IN const DRM_VOID             *f_pvCallbackData );

DRM_API DRM_RESULT DRM_CALL Drm_Reader_InitDecrypt(
    __inout_ecount( 1 )                               DRM_DECRYPT_CONTEXT  *f_pDecryptContext,
    __in_bcount_opt( min(DRM_CPHR_CB_FOR_INITDECRYPT,f_cbData) ) DRM_BYTE  *f_pbLast15,
    __in                                                        DRM_DWORD   f_cbData );

DRM_API DRM_RESULT DRM_CALL Drm_Reader_Decrypt(
    __in_ecount( 1 )           DRM_DECRYPT_CONTEXT          *f_pDecryptContext,
    __inout_opt                DRM_AES_COUNTER_MODE_CONTEXT *f_pCtrContext,
    __inout_bcount( f_cbData ) DRM_BYTE                     *f_pbData,
    __in                       DRM_DWORD                     f_cbData );

DRM_API DRM_RESULT DRM_CALL Drm_License_GetProperty(
    IN                                    DRM_APP_CONTEXT           *f_poAppContext,
    IN                                    DRM_LICENSE_GET_PROPERTY   f_eProperty,
    __inout_bcount_opt( *f_pcbExtraData ) DRM_BYTE                  *f_pbExtraData,
    IN                                    DRM_DWORD                 *f_pcbExtraData,
    OUT                                   DRM_DWORD                 *f_pdwOutputData );

DRM_API DRM_RESULT DRM_CALL Drm_LicenseQuery_GetState(
    IN                                    DRM_APP_CONTEXT        *f_poAppContext,
    __in_ecount( f_cRightsQueried ) const DRM_CONST_STRING       *f_rgpdstrRights[],
    IN                                    DRM_DWORD               f_cRightsQueried,
    __out_ecount( f_cRightsQueried )      DRM_LICENSE_STATE_DATA  f_rgStateData[],
    IN                                    DRMPFNPOLICYCALLBACK    f_pfnPolicyCallback,
    IN const                              DRM_VOID               *f_pv );

DRM_API DRM_RESULT DRM_CALL Drm_LicenseQuery_IsAllowed(
    IN       DRM_APP_CONTEXT            *f_poAppContext,
    IN const DRM_CONST_STRING           *f_pdstrQuery,
    IN       DRMPFNPOLICYCALLBACK        f_pfnPolicyCallback,
    IN const DRM_VOID                   *f_pvCallbackData,
    OUT      DRM_LICENSE_STATE_CATEGORY *f_pCategory );

#define DRM_SYNC_IGNORE_THRESHOLD_PARAMETER    0xFFFFFFFF

#if DRM_SUPPORT_LICENSE_SYNC

DRM_API DRM_RESULT DRM_CALL Drm_LicenseAcq_GetContentHeader(
    IN                                       DRM_APP_CONTEXT *f_poAppContext,
    IN                                       DRM_KID         *f_pkid,
    __out_ecount_opt( *f_pcchContentHeader ) DRM_WCHAR       *f_pwszContentHeader,
    IN OUT                                   DRM_DWORD       *f_pcchContentHeader );

DRM_API DRM_RESULT DRM_CALL Drm_Sync_GenerateChallenge(
    IN                             DRM_APP_CONTEXT *f_poAppContext,
    IN                             DRM_DWORD        f_cMaxCount,
    IN                             DRM_DWORD        f_cMaxHours,
    IN                             DRM_DWORD        f_iKIDStart,
    IN                             DRM_DWORD        f_cKIDs,
    OUT                            DRM_DWORD       *f_piKIDNext,
    OUT                            DRM_DWORD       *f_pcKIDs,
    __out_bcount_opt( *f_pcbData ) DRM_BYTE        *f_pbData,
    IN OUT                         DRM_DWORD       *f_pcbData );

#endif /* DRM_SUPPORT_LICENSE_SYNC */

#if DRM_SUPPORT_SECURE_CLOCK

DRM_API DRM_RESULT DRM_CALL Drm_SecureClock_ProcessResponse(
    IN                          DRM_APP_CONTEXT *f_poAppContext,
    __in_bcount( f_cbResponse ) DRM_BYTE        *f_pbResponse,
    IN                          DRM_DWORD        f_cbResponse,
    OUT                         DRM_RESULT      *f_pResult );

DRM_API DRM_RESULT DRM_CALL Drm_SecureClock_GenerateChallenge(
    IN                                  DRM_APP_CONTEXT *f_poAppContext,
    __out_ecount_opt( *f_pcchURL )      DRM_WCHAR       *f_pwszURL,
    IN OUT                              DRM_DWORD       *f_pcchURL,
    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE        *f_pbChallenge,
    IN OUT                              DRM_DWORD       *f_pcbChallenge );

DRM_API DRM_RESULT DRM_CALL Drm_SecureClock_GetValue(
    IN                                            DRM_APP_CONTEXT *f_poAppContext,
    __in_ecount_opt( *f_pcchSecureTime )          DRM_WCHAR       *f_pwszSecureTime,
    IN OUT                                        DRM_DWORD       *f_pcchSecureTime,
    IN                                            DRM_DWORD       *f_pdwFlags,
    __in_bcount_opt( *f_pcbSecureTimeWithStatus ) DRM_BYTE        *f_pbSecureTimeWithStatus,
    IN OUT                                        DRM_DWORD       *f_pcbSecureTimeWithStatus );

#endif /* DRM_SUPPORT_SECURE_CLOCK */

DRM_API DRM_RESULT DRM_CALL Drm_StoreMgmt_CleanupStore(
    IN       DRM_APP_CONTEXT        *f_poAppContext,
    IN const DRM_VOID               *f_pvCallerData,
    IN       DRM_DWORD               f_dwCallbackInterval,
    IN       pfnStoreCleanupProgress f_pfnCallback );

DRM_API DRM_RESULT DRM_CALL Drm_StoreMgmt_DeleteLicenses(
    IN  DRM_APP_CONTEXT  *f_poAppContext,
    IN  DRM_CONST_STRING *f_pdcstrKID,
    OUT DRM_DWORD        *f_pcLicDeleted );

DRM_API DRM_RESULT DRM_CALL Drm_ProcessCommand(
    IN                                   DRM_APP_CONTEXT *f_poAppContext,
    IN                                   DRM_DWORD        f_dwOperationCode,
    IN                                   DRM_DWORD        f_dwRequestArgument1,
    IN                                   DRM_DWORD        f_dwRequestArgument2,
    IN                                   DRM_DWORD        f_dwRequestArgument3,
    IN                                   DRM_DWORD        f_dwRequestArgument4,
    __in_bcount( f_dwRequestDataLength ) DRM_BYTE        *f_pbRequestData,
    IN                                   DRM_DWORD        f_dwRequestDataLength,
    OUT                                  DRM_DWORD       *f_pdwResponseResult1,
    OUT                                  DRM_DWORD       *f_pdwResponseResult2,
    OUT                                  DRM_DWORD       *f_pdwResponseResult3,
    OUT                                  DRM_DWORD       *f_pdwResponseResult4 );

DRM_API DRM_RESULT DRM_CALL Drm_ProcessRequest(
    IN                                       DRM_APP_CONTEXT *f_poAppContext,
    IN                                       DRM_DWORD        f_dwOperationCode,
    IN                                       DRM_DWORD        f_dwRequestArgument1,
    IN                                       DRM_DWORD        f_dwRequestArgument2,
    IN                                       DRM_DWORD        f_dwRequestArgument3,
    IN                                       DRM_DWORD        f_dwRequestArgument4,
    OUT                                      DRM_DWORD       *f_pdwResponseResult1,
    OUT                                      DRM_DWORD       *f_pdwResponseResult2,
    OUT                                      DRM_DWORD       *f_pdwResponseResult3,
    OUT                                      DRM_DWORD       *f_pdwResponseResult4,
    __out_bcount( *f_pdwResponseDataLength ) DRM_BYTE        *f_pbResponseData,
    OUT                                      DRM_DWORD       *f_pdwResponseDataLength );

DRM_API DRM_RESULT DRM_CALL Drm_Envelope_Open(
    IN           DRM_APP_CONTEXT            *f_poAppContext,
    IN           DRM_VOID                   *f_pOEMContext,
    __in_z const DRM_WCHAR                  *f_pwszFilename,
    OUT          DRM_ENVELOPED_FILE_CONTEXT *f_pEnvFile );

DRM_API DRM_RESULT DRM_CALL Drm_Envelope_DuplicateFileContext(
    IN           DRM_VOID                   *f_pOEMContext,
    __in_z const DRM_WCHAR                  *f_pwszFilename,
    IN           DRM_ENVELOPED_FILE_CONTEXT *f_pSourceHandle,
    OUT          DRM_ENVELOPED_FILE_CONTEXT *f_pNewHandle );

DRM_API DRM_RESULT DRM_CALL Drm_Envelope_InitializeRead(
    IN DRM_ENVELOPED_FILE_CONTEXT *f_pEnvFile,
    IN DRM_DECRYPT_CONTEXT        *f_pDecrypt );

DRM_API DRM_RESULT DRM_CALL Drm_Envelope_Close(
    IN DRM_ENVELOPED_FILE_CONTEXT *f_pEnvFile );

DRM_API DRM_RESULT DRM_CALL Drm_Envelope_GetSize(
    IN  DRM_ENVELOPED_FILE_CONTEXT *f_pEnvFile,
    OUT DRM_DWORD                  *f_pcbFileSize );

DRM_API DRM_RESULT DRM_CALL Drm_Envelope_Read(
    IN                                                DRM_ENVELOPED_FILE_CONTEXT *f_pEnvFile,
     __out_ecount_part( f_cbToRead, *f_pcbBytesRead ) DRM_BYTE                   *f_pbBuffer,
    IN                                                DRM_DWORD                   f_cbToRead,
    OUT                                               DRM_DWORD                  *f_pcbBytesRead );

DRM_RESULT DRM_API DRM_CALL Drm_Envelope_WritePlayReadyObject(
    __in         DRM_APP_CONTEXT            *f_poAppContext,
    __inout_opt  DRM_VOID                   *f_pOEMContext,
    __in_z const DRM_WCHAR                  *f_pwszFilename,
    __inout      DRM_ENVELOPED_FILE_CONTEXT *f_pEnvFile );

DRM_API DRM_RESULT DRM_CALL Drm_Envelope_Seek(
    IN  DRM_ENVELOPED_FILE_CONTEXT *f_pEnvFile,
    IN  DRM_LONG                    f_lDistanceToMove,
    IN  DRM_DWORD                   f_dwMoveMethod,
    OUT DRM_DWORD                  *f_pdwNewFilePointer );

DRM_API DRM_RESULT DRM_CALL Drm_Envelope_GetOriginalFilename(
    IN                                          DRM_ENVELOPED_FILE_CONTEXT *f_pEnvFile,
    __out_ecount_opt( *f_pcchOriginalFilename ) DRM_WCHAR                  *f_pwszOriginalFilename,
    IN OUT                                      DRM_DWORD                  *f_pcchOriginalFilename );

DRM_API DRM_RESULT DRM_CALL Drm_SecureStore_GetExtendedTokenValue(
    IN       DRM_SECSTORE_CONTEXT *f_pContextSST,
    IN const DRM_WORD              f_wRightID,
    IN const DRM_WORD              f_wRestrictionID,
    IN const DRM_CONST_STRING     *f_pdstrAttribute,
    OUT      TOKEN                *f_pToken );

DRM_API DRM_RESULT DRM_CALL Drm_SecureStore_SetExtendedTokenValue(
    IN       DRM_SECSTORE_CONTEXT *f_pContextSST,
    IN const DRM_WORD              f_wRightID,
    IN const DRM_WORD              f_wRestrictionID,
    IN const DRM_CONST_STRING     *f_pdstrAttribute,
    IN const TOKEN                *f_pToken,
    IN       DRM_DWORD             f_dwFlags );

#if DRM_SUPPORT_REVOCATION

/* Recommeded revocation buffer size. */
#define REVOCATION_BUFFER_SIZE                  30 * 1024

DRM_API DRM_RESULT DRM_CALL Drm_Revocation_SetBuffer(
    __inout                                 DRM_APP_CONTEXT *f_poAppContext,
    __in_bcount_opt( f_cbRevocationBuffer ) DRM_BYTE        *f_pbRevocationBuffer,
    __in                                    DRM_DWORD        f_cbRevocationBuffer );

DRM_API DRM_RESULT DRM_CALL Drm_Revocation_GetBuffer(
    __inout                                      DRM_APP_CONTEXT  *f_poAppContext,
    __deref_out_bcount( *f_pcbRevocationBuffer ) DRM_BYTE        **f_ppbRevocationBuffer,
    __out                                        DRM_DWORD        *f_pcbRevocationBuffer );

DRM_API DRM_RESULT DRM_CALL Drm_Revocation_StoreRevListArray(
    __inout                           DRM_APP_CONTEXT *f_poAppContext,
    __in                              DRM_DWORD        f_cRevocationLists,
    __in_ecount( f_cRevocationLists ) DRM_RVK_LIST    *f_pRevocationLists );

DRM_API DRM_RESULT DRM_CALL Drm_Revocation_GetList(
    __inout                          DRM_APP_CONTEXT          *f_poAppContext,
    __in                             DRM_REVOCATION_TYPE_ENUM  f_eRevType,
    __out_bcount_opt( *f_pcbBuffer ) DRM_BYTE                 *f_pbBuffer,
    __inout_opt                      DRM_DWORD                *f_pcbBuffer,
    __out_opt                        DRM_DWORD                *f_pdwVersion );

#endif /* DRM_SUPPORT_REVOCATION */

/**********************************************************************
**
** Function:    Drm_Writer_Encrypt
**
** Synopsis:    Encrypts cleartext content using the DRM content encryption algorithm and the given encryption context.
**
** Arguments:   [pEncryptContext] -- Encryption context previously initialized.
**              [pCtrContext]     -- If encrypting with AES counter mode, pointer to a counter mode context
**              [pbData]          -- Input data that is encrypted in place
**              [cbData]          -- Count of bytes in pbData
**
** Returns:     DRM_SUCECSS on succes or
**              DRM_E_INVALIDARG if any parameter is invalid or
**              any return code as defined in drmresults.h
**
** Notes:       Content is encrypted in place.  The input buffer will be modified.
**
**********************************************************************/
DRM_RESULT DRM_API Drm_Writer_Encrypt(
    IN                      DRM_CIPHER_CONTEXT           *pEncryptContext,
    __inout_opt             DRM_AES_COUNTER_MODE_CONTEXT *pCtrContext,
    __inout_bcount(cbData)  DRM_BYTE                     *pbData,
    IN                      DRM_DWORD                     cbData );

EXIT_PK_NAMESPACE;

#endif /* __DRMMANAGER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmmetercertprivkey.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMMETER_CERT_PRIV_KEY_H__
#define __DRMMETER_CERT_PRIV_KEY_H__

ENTER_PK_NAMESPACE;

const PRIVKEY g_privkeyMeterCert = 
{
//    TWO_ZEROES, TWO_ZEROES, TWO_ZEROES, TWO_ZEROES, TWO_ZEROES, 
//    TWO_ZEROES, TWO_ZEROES, TWO_ZEROES, TWO_ZEROES, TWO_ZEROES
    0xB6, 0x18, 0xCA, 0x39, 0xCF, 0xD6, 0x09, 0x8E, 
    0xCC, 0x1A, 0x43, 0xA6, 0x25, 0xD4, 0xFF, 0xC0, 
    0xE4, 0x52, 0x23, 0x5E
};

EXIT_PK_NAMESPACE;

#endif /* __DRMMETER_CERT_PRIV_KEY_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmmetercertstore.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_METERCERT_STORE__
#define __DRM_METERCERT_STORE__

ENTER_PK_NAMESPACE;

typedef struct _tagMeterCertContext
{    
    DRM_DST_SLOT_CONTEXT      contextDSTSlot;
    DRM_DST_NAMESPACE_CONTEXT contextNameSpace;
    DRM_DST                  *pDatastore;
    DRM_BYTE                 *pbBuffer;
    DRM_DWORD                 cbBuffer;
    DRM_BOOL                  fInited;
} DRM_METERCERT_CONTEXT_PRIVATE;

typedef struct _tagMeterCertEnumContext
{
    DRM_METERCERT_CONTEXT_PRIVATE *pcontextMeterCert;
    DRM_DST_ENUM_CONTEXT      contextDSTEnum;
    DRM_DST_SLOT_CONTEXT      contextDSTSlot;
    DRM_BOOL                  fInited;
    DRM_BOOL                  fAny;
    DRM_BOOL                  fSkipEnumNext;
} DRM_METERCERT_ENUM_PRIVATE;

typedef struct __tagDRM_METERCERT_CONTEXT
{
    DRM_BYTE rgbOpaqueData [__CB_DECL(SIZEOF(DRM_METERCERT_CONTEXT_PRIVATE) )];
} DRM_METERCERT_CONTEXT;

typedef struct __tagDRM_METERCERT_ENUM
{
    DRM_BYTE rgbOpaqueData [__CB_DECL(SIZEOF(DRM_METERCERT_ENUM_PRIVATE))];
} DRM_METERCERT_ENUM;

/* low-level access to the meter cert store */


/*********************************************************************
**
** Function: DRM_MCS_OpenStore
**
** Synopsis: Opens the metercert store
**
** Arguments:
**
** [f_pDataStore]           -- initialized data store.
** [f_pbBuffer]             -- Scratch buffer to be used by the store
** [f_cbBuffer]             -- Size of the scratch buffer, should be at least as big as the
**                             largest anticipated metercert
** [f_pcontextMeterCert]    -- returned meter cert context
**
** Returns:     DRM_SUCCESS on success or DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_MCS_OpenStore  (
    IN  DRM_DST                 *f_pDataStore,
    __in_bcount( f_cbBuffer ) DRM_BYTE *f_pbBuffer,
    IN  DRM_DWORD                f_cbBuffer,
    OUT DRM_METERCERT_CONTEXT   *f_pcontextMeterCert);

/*********************************************************************
**
** Function: DRM_MCS_CloseStore
**
** Synopsis: Closes the metercert store
**
** Arguments:
**
** [f_pcontextMeterCert]    -- initialized meter cert context
**
** Returns:     DRM_SUCCESS on success or DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_MCS_CloseStore (
    IN  DRM_METERCERT_CONTEXT *f_pcontextMeterCert);


/**********************************************************************
**
** Function:    DRM_MCS_InitEnum
**
** Synopsis:    Initializes an enumeration of metercert store entries
**              
**
** Arguments:   [pDrmContext]             -- Opaque DRM Manager context initialized by a call to Drm_Initialize
**              [f_pcontextMeterCertEnum] -- Opaque context initialized
**
** Returns:     DRM_SUCCESS on success or DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_MCS_InitEnum   (
    IN  DRM_METERCERT_CONTEXT       *f_pcontextMeterCert, 
    OUT DRM_METERCERT_ENUM          *f_pcontextMeterCertEnum);

/**********************************************************************
**
** Function:    DRM_MCS_EnumNext
**
** Synopsis:    Enumerates the next entry in the meter cert store
**              
**
** Arguments:   [f_pcontextMeterCertEnum] -- Opaque context initialized by a call to DRM_MCS_InitEnum
**              [f_pmid]                  -- pointer to the MID of the enumerated entry
**              [f_pslotHint]             -- slot hint of the enumerated entry
**
** Returns:     DRM_SUCCESS on success or DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_MCS_EnumNext   (
    IN  DRM_METERCERT_ENUM          *f_pcontextMeterCertEnum, 
    OUT DRM_MID                     *f_pmid,
    OUT DRM_DST_SLOT_HINT           *f_pslotHint);

/*********************************************************************
**
** Function: DRM_MCS_GetMeterCertByMID
**
** Synopsis: Looks up the LAINFO and meter cert for a given MID if it exists
**
** Arguments:
**
** [f_pcontextMeterCert]    -- initialized meter cert context
** [f_pmid]                 -- pointer to MID to be looked up
** [f_pwszLAINFO]           -- pointer to a buffer that will hold the LAINFO
** [f_pcchLAINFO]           -- pointer to the number of wide characters in the LAINFO
** [f_pfIsV2]               -- specifies whether the LAINFO is a V2 server or V4
** [f_pwszMeterCert]        -- pointer to a buffer that will hold the meter cert
** [f_pcchMeterCert]        -- pointer to the number of wide characters in the meter cert
**
** Returns:     DRM_SUCCESS on success or DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_MCS_GetMeterCertByMID(
    IN                                   DRM_METERCERT_CONTEXT   *f_pcontextMeterCert, 
    IN const                             DRM_MID                 *f_pmid,
       __out_ecount_opt(*f_pcchLAINFO)   DRM_WCHAR               *f_pwszLAINFO,
    IN OUT                               DRM_DWORD               *f_pcchLAINFO,
       OUT                               DRM_BOOL                *f_pfIsV2,
       __out_bcount_opt(*f_pcbMeterCert) DRM_BYTE                *f_pbMeterCert,
    IN OUT                               DRM_DWORD               *f_pcbMeterCert );

/*********************************************************************
**
** Function: DRM_MCS_UpdateMeterCert
**
** Synopsis: 
**
** Arguments:
**
** [f_pcontextMeterCert]          -- initialized meter cert context
** [f_pdstrLAINFO]                -- optional LAINFO to store
** [f_pfIsV2]                     -- specifies whether the LAINFO is a V2 server or V4
** [f_pbMeterCert]                -- optional meter cert to store
** [f_cbMeterCert]                -- optional size of meter cert to store
** [f_pmid]                       -- pointer to MID to be added/updated
**
** Returns:     DRM_SUCCESS on success or DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/


DRM_API DRM_RESULT DRM_CALL DRM_MCS_UpdateMeterCert(
    IN       DRM_METERCERT_CONTEXT      *f_pcontextMeterCert, 
    IN       DRM_CONST_STRING           *f_pdstrLAINFO,
    IN       DRM_BOOL                   *f_pfIsV2,
    __in_bcount_opt( f_cbMeterCert )
             DRM_BYTE                   *f_pbMeterCert,
    __in     DRM_DWORD                   f_cbMeterCert,
    IN const DRM_MID                    *f_pmid);


/*********************************************************************
**
** Function: DRM_MCS_DeleteMeterCert
**
** Synopsis: delete the indicated meter cert from the meter cert store; its absense
**           is not an error
**
** Arguments:
**
** [f_pcontextMeterCert]    -- initialized METERCERT context
** [f_pmid]                 -- pointer to MID to be added/updated
**
** Returns:     DRM_SUCCESS on success or DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_MCS_DeleteMeterCert(
    IN       DRM_METERCERT_CONTEXT  *f_pcontextMeterCert, 
    IN const DRM_MID                *f_pmid);


/*********************************************************************
**
** Function: DRM_MCS_InvalidateMeterCert
**
** Synopsis: invalidate the indicated meter cert from the meter cert store; its absense
**           is not an error
**
** Arguments:
**
** [f_pcontextMeterCert]    -- initialized METERCERT context
** [f_pmid]                 -- pointer to MID to be added/updated
**
** Returns:     DRM_SUCCESS on success or DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_MCS_InvalidateMeterCert(
    IN       DRM_METERCERT_CONTEXT  *f_pcontextMeterCert, 
    IN const DRM_MID                *f_pmid);

EXIT_PK_NAMESPACE;

#endif /* __DRM_SYNC_STORE__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmmeterimp.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMMETERIMPL_H__
#define __DRMMETERIMPL_H__

#include <drmxmlbuilder.h>

ENTER_PK_NAMESPACE;

#define DRM_METERING_CONTEXT        DRM_SECSTORE_CONTEXT

typedef struct __tagDRM_METERINGENUM_CONTEXT
{
    DRM_MID                     oMID;
    DRM_SECSTOREENUM_CONTEXT    oSecStoreEnum;
} DRM_METERINGENUM_CONTEXT;

#define DRM_METER_RESPONSE_PARTIAL 0x00000001

extern DRM_EXPORT_VAR const DRM_KID g_kidTID;

extern const DRM_KID g_kidTIDPrev;

DRM_RESULT DRM_MTR_GetKIDData (IN  DRM_METERING_CONTEXT        *f_pmeterstore,
                               IN  DRM_STACK_ALLOCATOR_CONTEXT *f_pstack,
                               OUT DRM_BYTE                   **f_ppbDataOut,
                               OUT DRM_DWORD                   *f_pcbDataOut);

DRM_RESULT DRM_MTR_CreateNewTID (DRM_VOID *f_pOEMContext, DRM_TID *f_ptid);

DRM_RESULT DRM_MTR_ReadTIDFromMeteringStore (DRM_METERING_CONTEXT   *f_pmeterstore,
                                             DRM_BYTE                f_rgbPasswordSST [__CB_DECL(DRM_SHA1_DIGEST_LEN)],
                                             const DRM_MID          *f_pmid,
                                             DRM_TID                *f_ptid,
                                             DRM_CONST_STRING       *f_pdstrTidBase64,
                                             IN DRM_DST             *f_pDatastore);

DRM_RESULT DRM_MTR_WriteTIDToMeteringStore (IN  DRM_METERING_CONTEXT *f_pmeterstore,
                                            IN  DRM_BYTE              f_rgbPasswordSST [__CB_DECL(DRM_SHA1_DIGEST_LEN)],
                                            IN  const DRM_MID        *f_pmid,
                                            IN  DRM_TID              *f_ptid,
                                            IN  DRM_DST              *f_pDatastore);

DRM_API DRM_RESULT DRM_CALL DRM_MTR_GetAllData (
    IN     DRM_METERING_CONTEXT *f_pcontextMTR,
    __out_bcount_opt( *f_pcbData ) DRM_BYTE *f_pbData,
    IN OUT DRM_DWORD            *f_pcbData);

DRM_API DRM_RESULT DRM_CALL DRM_MTR_InitEnum (
    IN const DRM_MID                   *pmid,
       OUT   DRM_METERINGENUM_CONTEXT  *pcontextMeteringEnum,
    IN       DRM_DST                   *pDataStore);

DRM_API DRM_RESULT DRM_CALL DRM_MTR_EnumNext (
    IN     DRM_METERINGENUM_CONTEXT *pcontextMeteringEnum,
       OUT DRM_KID                  *pkid,
       OUT DRM_DWORD                *pcbData);

DRM_API DRM_RESULT DRM_CALL DRM_MTR_GenerateMeterChallenge(
    IN                           DRM_LICEVAL_CONTEXT *f_pcontextLEVL,
    __in_bcount( f_cbStack )     DRM_BYTE            *f_pbStack,
    IN                           DRM_DWORD            f_cbStack,
    IN const                     DRM_CONST_STRING    *f_pdstrMeterCert,
       OUT                       _XMBContext         *f_pChallenge,
    IN OUT                       DRM_DWORD           *f_pcbChallenge,
     __out_ecount_opt(*f_pcchURL)DRM_CHAR            *f_pszURL,
    IN OUT                       DRM_DWORD           *f_pcchURL);

DRM_API DRM_RESULT DRM_CALL DRM_MTR_ProcessMeterResponse(
    IN     DRM_LICEVAL_CONTEXT *f_pcontextLEVL,
    __in_bcount( f_cbStack ) DRM_BYTE *f_pbStack,
    IN     DRM_DWORD            f_cbStack,
    __in_bcount( f_cbData ) DRM_BYTE *f_pbData,
    IN     DRM_DWORD            f_cbData,
       OUT DRM_DWORD           *f_pfFlags);

DRM_API DRM_RESULT DRM_CALL DRM_MTR_CloseContext(
    IN DRM_METERING_CONTEXT *pcontextMetering,
    IN DRM_DST              *pDataStore);

DRM_API DRM_RESULT DRM_CALL DRM_MTR_OpenId(
    IN       DRM_METERING_CONTEXT *pcontextMetering,
    IN const DRM_MID              *pmid,
    IN const DRM_KID              *pkid,
    __in_bcount( DRM_SHA1_DIGEST_LEN ) const DRM_BYTE rgbPassword [ __CB_DECL( DRM_SHA1_DIGEST_LEN ) ],
    IN DRM_DST                    *pDataStore );

DRM_API DRM_RESULT DRM_CALL DRM_MTR_IncrementCount(
    IN       DRM_METERING_CONTEXT *pcontextMetering,
    IN const DRM_CONST_STRING     *pdstrAction );

DRM_API DRM_RESULT DRM_CALL DRM_MTR_CreateMeterStorePassword(
    IN     DRM_CONST_STRING *f_pdstrMID,
    __out_bcount( DRM_SHA1_DIGEST_LEN ) DRM_BYTE f_rgbPasswordSST[ __CB_DECL( DRM_SHA1_DIGEST_LEN ) ],
    IN     DRM_BB_CONTEXT   *f_pbcontextBBX);

DRM_API DRM_RESULT DRM_CALL DRM_MTR_CreateMeterStorePasswordFromBinaryMID(
    IN const DRM_MID           *f_pmid,
    __out_bcount( DRM_SHA1_DIGEST_LEN ) DRM_BYTE f_rgbPasswordSST[ __CB_DECL( DRM_SHA1_DIGEST_LEN ) ],
    IN       DRM_BB_CONTEXT    *f_pbcontextBBX);

DRM_API DRM_RESULT DRM_CALL DRM_MTR_UpdateData(
    DRM_MID                 *f_pmid,
    DRM_LID                 *f_plid,
    DRM_KID                 *f_pkid,
    const DRM_CONST_STRING **f_ppdstrActions,
    DRM_DWORD                f_cActions,
    DRM_METERING_CONTEXT    *f_pcontextMTR,
    DRM_DST                 *pDataStore,
    __in_bcount( SIZEOF( DRM_BB_CONTEXT ) ) DRM_BYTE *f_pbcontextBBX);

DRM_API DRM_RESULT DRM_CALL DRM_MTR_EnumLoadCurrent (
    IN       DRM_METERINGENUM_CONTEXT *f_pcontextMTREnum,
    IN       DRM_METERING_CONTEXT     *f_pcontextMTR,
    __in_bcount( DRM_SHA1_DIGEST_LEN ) const DRM_BYTE f_rgbPasswordMTR[__CB_DECL(DRM_SHA1_DIGEST_LEN)],
       OUT   DRM_KID                  *f_pkid,
       OUT   DRM_DWORD                *f_pcbData);

DRM_API DRM_RESULT DRM_CALL DRM_MTR_EnumDeleteCurrent(
    IN       DRM_METERINGENUM_CONTEXT *f_pcontextMTREnum,
    IN       DRM_METERING_CONTEXT     *f_pcontextMTR);

DRM_API DRM_RESULT DRM_CALL DRM_MTR_ParseMeterCert(
    IN const DRM_CONST_STRING    *f_pdstrMeterCert,
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL,
       OUT   PUBKEY              *f_ppubkeyMAS,
       OUT   DRM_CONST_STRING    *f_pdstrDataMID,
       OUT   DRM_MID             *f_pmid,
       OUT   DRM_CONST_STRING    *f_pdstrDataURL);

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_MTR_GenerateMeterDataChallenge(
    __inout                                DRM_BB_CONTEXT *f_poBBXContext,
    __inout                                DRM_DST        *f_poDSTContext,
    __inout                                DRM_SECSTORE_CONTEXT *f_poSSTContext,
    __inout                                DRM_REVOCATIONSTORE_CONTEXT *f_poRevStore,
    __in_bcount(f_cbRevocationBuffer)      DRM_BYTE       *f_pbRevocationBuffer,
    __in                                   DRM_DWORD       f_cbRevocationBuffer,
    __in_bcount(f_cbStack)                 DRM_BYTE       *f_pbStack,
    __in                                   DRM_DWORD       f_cbStack,
    __in_bcount(f_cbMeterCert)       const DRM_BYTE       *f_pbMeterCert,
    __in                                   DRM_DWORD       f_cbMeterCert,
    __in_bcount(f_cbDeviceCert)      const DRM_BYTE       *f_pbDeviceCert,
    __in                                   DRM_DWORD       f_cbDeviceCert,
    __in_ecount_opt(f_cchCustomData) const DRM_CHAR       *f_pchCustomData,
    __in                                   DRM_DWORD       f_cchCustomData,
    __out_ecount_opt(*f_pcchURL)           DRM_CHAR       *f_pchURL,
    __inout                                DRM_DWORD      *f_pcchURL,
    __out_bcount_opt( *f_pcbChallenge )    DRM_BYTE       *f_pbChallenge,
    __inout                                DRM_DWORD      *f_pcbChallenge );

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_MTR_ProcessMeterDataResponse(
    __in                                    DRM_BB_CONTEXT              *f_poBBXContext,
    __in                                    DRM_DST                     *f_poDSTContext,
    __inout                                 DRM_SECSTORE_CONTEXT        *f_poSSTContext,
    __inout                                 DRM_REVOCATIONSTORE_CONTEXT *f_poRevStore,
    __in_bcount(f_cbRevocationBuffer)       DRM_BYTE                    *f_pbRevocationBuffer,
    __in                                    DRM_DWORD                    f_cbRevocationBuffer,
    __inout_bcount(*f_pcbScratch)           DRM_BYTE                    *f_pbScratch,
    __inout                                 DRM_DWORD                   *f_pcbScratch,
    __inout_bcount(f_cbResponse)            DRM_BYTE                    *f_pbResponse,
    __in                                    DRM_DWORD                    f_cbResponse,
    __inout                                 DRM_BOOL                    *f_pfResponseSignatureChecked,
    __inout                                 DRM_DWORD                   *f_pdwProtocol,
    __out_opt                               DRM_RESULT                  *f_pResult );

DRM_API DRM_RESULT DRM_CALL DRM_MTR_GenerateMeterCertChallenge(
    __in                                    DRM_MID   *f_poMID,
    __in_ecount_opt(f_cchCustomData)  const DRM_CHAR  *f_pchCustomData,
    __in                                    DRM_DWORD  f_cchCustomData,
    __out_bcount_opt(*f_pcbChallenge)       DRM_BYTE  *f_pbChallenge,
    __inout                                 DRM_DWORD *f_pcbChallenge );

DRM_API DRM_RESULT DRM_CALL DRM_MTR_ProcessMeterCertResponse(
    __in                       DRM_LICEVAL_CONTEXT   *f_poLicEvalContext,
    __in                       DRM_METERCERT_CONTEXT *f_poMeterCertStoreContext,
    __in_bcount(*f_pcbScratch) DRM_BYTE              *f_pbScratch,
    __inout                    DRM_DWORD             *f_pcbScratch,
    __in_bcount(f_cbResponse)  DRM_BYTE              *f_pbResponse,
    __in                       DRM_DWORD              f_cbResponse,
    __out_opt                  DRM_RESULT            *f_pResult );

EXIT_PK_NAMESPACE;

#endif /* __DRMMETERIMPL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmmetercertpubkey.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMMETER_CERT_PUBLIC_KEY_H__
#define __DRMMETER_CERT_PUBLIC_KEY_H__

ENTER_PK_NAMESPACE;

const PUBKEY g_pubkeyMeteringCertVerify =
{
    TWO_BYTES(0xAE, 0xF2), TWO_BYTES(0x91, 0xD5), TWO_BYTES(0xDA, 0xBE), TWO_BYTES(0x13, 0x37), 
    TWO_BYTES(0x46, 0x0F), TWO_BYTES(0xC3, 0x43), TWO_BYTES(0xD8, 0x88), TWO_BYTES(0x64, 0x9F), 
    TWO_BYTES(0x43, 0x8F), TWO_BYTES(0x12, 0x85), TWO_BYTES(0x99, 0x64), TWO_BYTES(0xA0, 0xB0), 
    TWO_BYTES(0x82, 0x27), TWO_BYTES(0x69, 0xED), TWO_BYTES(0x8E, 0x52), TWO_BYTES(0x1D, 0x1F), 
    TWO_BYTES(0x8D, 0x14), TWO_BYTES(0x92, 0x5A), TWO_BYTES(0xCD, 0xD3), TWO_BYTES(0xD6, 0x7C)
};

const PUBKEY g_pubkeyRootMeteringCert = /* "pub" */
{
    TWO_BYTES(0x45, 0xB1), TWO_BYTES(0xA7, 0xE1), TWO_BYTES(0x90, 0x81), TWO_BYTES(0x98, 0x37), 
    TWO_BYTES(0x00, 0xCC), TWO_BYTES(0x89, 0xA7), TWO_BYTES(0x57, 0x24), TWO_BYTES(0x72, 0xB9), 
    TWO_BYTES(0xC1, 0x29), TWO_BYTES(0xA3, 0x62), TWO_BYTES(0xD9, 0x55), TWO_BYTES(0x74, 0x04), 
    TWO_BYTES(0x02, 0x7D), TWO_BYTES(0x6E, 0x69), TWO_BYTES(0x79, 0xE9), TWO_BYTES(0x6A, 0xD9), 
    TWO_BYTES(0x7A, 0x92), TWO_BYTES(0xE4, 0xF3), TWO_BYTES(0x4B, 0x6B), TWO_BYTES(0x42, 0x6C)
};

EXIT_PK_NAMESPACE;

#endif /* __DRMMETER_CERT_PUBLIC_KEY_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmnamespace.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMNAMESPACE_H__
#define __DRMNAMESPACE_H__

/*  
# Abstract:
#
# This file contains compiler directives for disabling certain compiler-time warnings
# and allow the PK environment to be compiled under elevated warning level
#
#
*/

/*
** Set namespace, USE_PK_NAMESPACES is defined in build profile
*/
#ifdef __cplusplus

#if USE_PK_NAMESPACES
/*
**  Place PK functions in a specific namespace
*/
#define ENTER_PK_NAMESPACE namespace PK {
#define EXIT_PK_NAMESPACE };
#define ENTER_PK_NAMESPACE_CODE namespace PK {
#define EXIT_PK_NAMESPACE_CODE };
#else /* USE_PK_NAMESPACES */
/*
**  Make PK functions appear as simple C functions
*/
#define ENTER_PK_NAMESPACE extern "C" {
#define EXIT_PK_NAMESPACE }
#define ENTER_PK_NAMESPACE_CODE
#define EXIT_PK_NAMESPACE_CODE
#endif /* USE_PK_NAMESPACES */

#else /* __cplusplus */

/*
**  Building as C - no need to change prototypes
*/
#define ENTER_PK_NAMESPACE
#define EXIT_PK_NAMESPACE
#define ENTER_PK_NAMESPACE_CODE
#define EXIT_PK_NAMESPACE_CODE

#endif /* __cplusplus */

#endif  /* __DRMNAMESPACE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmmeterapi.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_METER_API_H
#define __DRM_METER_API_H

ENTER_PK_NAMESPACE;

#include <drmmeterimp.h>

/**********************************************************************
**
** Function:    Drm_MeterCert_InitEnum
**
** Synopsis:    Initializes an enumeration context to enumerate through all metering certificates stored
**
** Arguments:   [pAppContext]           -- Opaque DRM Application context initialized by a call to Drm_Initialize
**              [pMeterCertEnumContext] -- Meter cert enumeration context to be initialized
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if any of the parameters are invalid or
**              any of the return codes as defined in drmresults.h
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL Drm_MeterCert_InitEnum(
    IN       DRM_APP_CONTEXT     *pAppContext,
       OUT   DRM_METERCERT_ENUM  *pMeterCertEnumContext );

/**********************************************************************
**
** Function:    Drm_MeterCert_EnumNext
**
** Synopsis:    Enumerates to the next metering cert in the metering cert store
**
** Arguments:   [f_pMeterCertEnumContext] -- Meter cert enumeration context
**              [f_pmid]                  -- Buffer to hold the meter ID of the enumerated meter cert
**              [f_pwszLAINFO]            -- Buffer to hold the enumerated LAINFO
**              [f_pcchLAINFO]            -- On input specifies the number of wide characters available in the buffer,
**                                           on output specifies the number of characters in the returned LAINFO
**              [f_pfIsV2]                -- Returns whether the server pointed to by the LAINFO URL is a V2 or V4 server (ie WMDRM-PD or PlayReady )
**              [f_pbMeterCert]           -- Buffer to hold the enumerated meter cert
**              [f_pcbMeterCert]          -- On input specifies the number of bytes available in the buffer,
**                                           on output specifies the number of bytes in the returned meter cert
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if any of the parameters are invalid or
**              any of the return codes as defined in drmresults.h
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL Drm_MeterCert_EnumNext(
    IN      DRM_METERCERT_ENUM  *pMeterCertEnumContext,
    IN OUT  DRM_MID             *pmid,
    __out_ecount_opt( *f_cchLAINFO ) DRM_WCHAR *pwszLAINFO,
       OUT  DRM_DWORD           *f_cchLAINFO,
       OUT   DRM_BOOL            *f_pfIsV2,
    __out_bcount_opt( *f_pcbMeterCert ) DRM_BYTE *f_pbMeterCert,
       OUT  DRM_DWORD           *f_pcbMeterCert );

/**********************************************************************
**
** Function:    Drm_MeterCert_Update
**
** Synopsis:    Updates a metering certificate in the metering certificate store
**
** Arguments:   [pAppContext]     -- initialized DRM Application context
**              [pbMeterCert]     -- meter cert to store
**              [cbMeterCert]     -- size of meter cert to store.
**              [pmid]            -- optional pointer to MID that was added/updated
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if any of the parameters are invalid or
**              any of the return codes as defined in drmresults.h
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL Drm_MeterCert_Update(
    IN       DRM_APP_CONTEXT    *pAppContext,
    __in_bcount( cbMeterCert )
             DRM_BYTE           *pbMeterCert,
    __in     DRM_DWORD           cbMeterCert,
       OUT   DRM_MID            *pmid);

/**********************************************************************
**
** Function:    Drm_MeterCert_Invalidate
**
** Synopsis:    Invalidates a metering certificate
**
** Arguments:   [pAppContext]  -- Opaque DRM Application context initialized by a call to Drm_Initialize
**              [pmid]         -- Meter ID of the meter cert to invalidate
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if any of the parameters are invalid or
**              any of the return codes as defined in drmresults.h
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL Drm_MeterCert_Invalidate(
    IN       DRM_APP_CONTEXT  *pAppContext,
       OUT   DRM_MID          *pmid );

/**********************************************************************
**
** Function:    Drm_MeterCert_Delete
**
** Synopsis:    Deletes a metering certificate
**
** Arguments:   [pAppContext]  -- Opaque DRM Application context initialized by a call to Drm_Initialize
**              [pmid]         -- Meter ID of the meter cert to delete
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if any of the parameters are invalid or
**              any of the return codes as defined in drmresults.h
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL Drm_MeterCert_Delete(
    IN       DRM_APP_CONTEXT  *pAppContext,
       OUT   DRM_MID          *pmid );

DRM_API DRM_RESULT DRM_CALL Drm_Metering_GenerateChallenge(
    IN        DRM_APP_CONTEXT    *f_poAppContext,
    __in_bcount( f_cbMeterCert ) const DRM_BYTE *f_pbMeterCert,
    IN        DRM_DWORD           f_cbMeterCert,
    __in_ecount_opt( f_cchCustomData ) DRM_CHAR *f_pchCustomData,
    IN        DRM_DWORD  f_cchCustomData,    
    __out_ecount_opt( *f_pcchURL ) DRM_CHAR *f_pchURL,
    IN OUT    DRM_DWORD          *f_pcchURL,
    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE *f_pbChallenge,
    IN OUT    DRM_DWORD          *f_pcbChallenge );

DRM_API DRM_RESULT DRM_CALL Drm_Metering_ProcessResponse(
    IN      DRM_APP_CONTEXT  *f_poAppContext,
    __in_bcount( f_cbResponse ) DRM_BYTE *f_pbResponse,
    IN      DRM_DWORD         f_cbResponse,
       OUT  DRM_DWORD        *f_pfFlags );

DRM_API DRM_RESULT DRM_CALL Drm_MeterCert_GenerateChallenge(
    IN DRM_MID *f_poMID,
    __in_ecount_opt( f_cchCustomData) const DRM_CHAR *f_pchCustomData,
    IN DRM_DWORD f_cchCustomData,    
    __out_bcount_opt( *f_pcbChallenge ) DRM_BYTE *f_pbChallenge,
    IN OUT DRM_DWORD *f_pcbChallenge );

DRM_API DRM_RESULT DRM_CALL Drm_MeterCert_ProcessResponse(
    IN DRM_APP_CONTEXT *f_poAppContext,
    __in_bcount( f_cbResponse ) DRM_BYTE *f_pbResponse,
    IN DRM_DWORD f_cbResponse,
    OUT DRM_RESULT *f_pResult );    

EXIT_PK_NAMESPACE;

#endif /* __DRM_METER_API_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmmeterconstants.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_METER_CONSTANTS_H
#define __DRM_METER_CONSTANTS_H

ENTER_PK_NAMESPACE;

/*
** ------------------------------------------------------------
** XML strings used in the construction of meter data challenge
** ------------------------------------------------------------
*/
extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataRootTag;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataChallenge1Tag;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataChallenge2Tag;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataMeteringDataTag;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataVersionTag;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataMIDTag;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataTIDTag;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataCustomDataTag;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataPartialDataTag;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataDataTag;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataDeviceCertTag;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataRecordsTag;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataRecordTag;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataActionTag;


extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataRootAttribName;
extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataRootAttribValue;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataChallenge2AttribName;
extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataChallenge2AttribValue;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataMeteringDataAttrib1Name;
extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataMeteringDataAttrib1Value;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataMeteringDataAttrib2Name;
extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataMeteringDataAttrib2Value;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataRecordAttribName;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataActionAttrib1Name;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataActionAttrib2Name;


extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataVersionValue;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataPartialDataValue;


/*
** ------------------------------------------------------
** XML strings used in the parsing of meter data response
** ------------------------------------------------------
*/
extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataMeteringResponsePath;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataMeterCertPath;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataEncryptedDataPath;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataMIDPath;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataTIDPath;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataRecordsPath;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataKIDPath;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataSignaturePath;

/*
** ------------------------------------------------------------
** XML strings used in the construction of meter cert challenge
** ------------------------------------------------------------
*/
extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertRootTag;


extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertChallenge1Tag;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertChallenge2Tag;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeteringMeterCertTag;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertMIDTag;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrSupportsMeterCertSignatureTag;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrTrueValue;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertVersionTag;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertCustomDataTag;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertRootAttribName;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertRootAttribValue;


extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertVersion;


/*
** ------------------------------------------------------
** XML strings used in the parsing of meter cert response
** ------------------------------------------------------
*/
extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertResponsePath;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertMeterCertPath;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertSignaturePath;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertMeteringCertificateResponsePath;

/*
** ----------------------------------------------
** XML strings used in the parsing of custom data
** ----------------------------------------------
*/
extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterDataCustomDataPath;

extern const DRM_EXPORT_VAR DRM_ANSI_CONST_STRING g_dastrMeterCertCustomDataPath;

EXIT_PK_NAMESPACE;

#endif /* __DRM_METER_CONSTANTS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmndr.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef _DRMNDR_H_
#define _DRMNDR_H_

#include <drmcommon.h>
#include <drmmanager.h>
#include <drmstkalloc.h>
#include <oemaes.h>

ENTER_PK_NAMESPACE;

enum NDRState
{
    NDR_InitialState,
    NDR_RegisteredState,
    NDR_ChallengedState,
    NDR_ProximityDetectedState,
    NDR_HaveLicenseState
};

/*
** Define a context for Proximity Detection
*/
typedef struct
{
    enum NDRState   State;
    
    /*
    ** Data from the Registration Response message
    ** This data is valid in the RegisteredState and ChallengedState
    */
    DRM_AES_KEY  *ProximityContentEncryptionKey;
    DRM_ID        SessionId;
    DRM_WORD      AddressSize;
    DRM_BYTE     *Address;

    /*
    ** Data from the proximity challenge message
    ** This data is valid in the ChallengedState
    */
    DRM_ID   Challenge;
    DRM_BYTE Sequence;

    /*
    ** Data for the License Request message
    ** This data is valid in the ProximityDetectedState and HaveLicenseState
    */
    DRM_ID RightsId;
} DRM_ND_PROXIMITY_CONTEXT;


DRM_API DRM_RESULT DRM_CALL Drm_Ndr_Registration_GenerateChallenge(
    __in_opt DRM_VOID                                    *f_pOEMContext,
    __deref_out_bcount_full(*f_pcbMessageSize) DRM_BYTE **f_ppbMessage,
    __out DRM_DWORD                                      *f_pcbMessageSize
);


DRM_API DRM_RESULT DRM_CALL Drm_Ndr_Registration_ProcessResponse(
    __in_opt DRM_VOID                                         *f_pOEMContext,
    __in DRM_ND_PROXIMITY_CONTEXT                             *f_pProximityContext,
    __in_bcount(f_cbRegistrationResponseMessageSize) DRM_BYTE *f_pbRegistrationResponseMessage,
    __in const DRM_DWORD                                       f_cbRegistrationResponseMessageSize,
    __in DRM_CRYPTO_CONTEXT                                   *f_pCryptoCtx
    
);


DRM_API DRM_RESULT DRM_CALL Drm_Ndr_License_GenerateChallenge(
    __in_opt DRM_VOID                                     *f_pOEMContext,
    __out DRM_ID                                          *f_pRightsId,
    __deref_out_bcount_full(*f_pcbMessageSize) DRM_BYTE  **f_ppbMessage,
    __out DRM_DWORD                                       *f_pcbMessageSize
);


DRM_API DRM_RESULT DRM_CALL Drm_Ndr_License_ProcessResponse(
    __in_opt       DRM_VOID                              *f_pOEMContext,
    __in           DRM_ND_PROXIMITY_CONTEXT              *f_pProximityContext,
    __in_bcount(f_cbLicenseResponseMessageSize) DRM_BYTE *f_pbLicenseResponseMessage,
    __in const     DRM_DWORD                              f_cbLicenseResponseMessageSize,
    __in           DRM_STACK_ALLOCATOR_CONTEXT           *f_pStack,
    __in_opt       DRMPFNPOLICYCALLBACK                   f_pfnPolicyCallback,
    __in_opt const DRM_VOID                              *f_pv,
    __out          DRM_DECRYPT_CONTEXT                   *f_pcontextDCRY,
    __in           DRM_CRYPTO_CONTEXT                    *f_pCryptoCtx 
);


DRM_API DRM_RESULT DRM_CALL Drm_Ndr_Proximity_GenerateStart(
    __in_opt DRM_VOID                                    *f_pOEMContext,
    __in DRM_ND_PROXIMITY_CONTEXT                        *f_pProximityContext,
    __deref_out_bcount_full(*f_pcbMessageSize) DRM_BYTE **f_ppbMessage,
    __out DRM_DWORD                                      *f_pcbMessageSize
);


DRM_API DRM_RESULT DRM_CALL Drm_Ndr_Proximity_GenerateResponse(
    __in_opt DRM_VOID                                    *f_pOEMContext,
    __in DRM_ND_PROXIMITY_CONTEXT                        *f_pProximityContext,
    __deref_out_bcount_full(*f_pcbMessageSize) DRM_BYTE **f_ppbMessage,
    __out DRM_DWORD                                      *f_pcbMessageSize
);


DRM_API DRM_RESULT DRM_CALL Drm_Ndr_Proximity_ProcessChallenge(
    __in_opt DRM_VOID                     *f_pOEMContext,
    __in DRM_ND_PROXIMITY_CONTEXT         *f_pProximityContext,
    __in_bcount(f_cbMessageSize) DRM_BYTE *f_pbMessage,
    __in const DRM_DWORD                   f_cbMessageSize
);


DRM_API DRM_RESULT DRM_CALL Drm_Ndr_Proximity_ProcessResult(
    __in_opt DRM_VOID                     *f_pOEMContext,
    __in DRM_ND_PROXIMITY_CONTEXT         *f_pProximityContext,
    __in_bcount(f_cbMessageSize) DRM_BYTE *f_pbMessage,
    __in const DRM_DWORD                   f_cbMessageSize,
    __out      DRM_WORD                   *f_pwResult
);


DRM_API DRM_BYTE DRM_CALL Drm_Ndr_GetMessageType(
    __in_bcount(f_cbMessageSize) const DRM_BYTE  * const f_pbMessage,
    __in                         const DRM_DWORD         f_cbMessageSize
);


EXIT_PK_NAMESPACE;

#endif    /* _DRMNDR_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmopcodes.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMOPCODES_H__
#define __DRMOPCODES_H__

ENTER_PK_NAMESPACE;

/*Defines for generic function call thru MTP/RAPI*/
#define OpGetVersion                        1
#define OpProcessLicenseRevocationList      2

EXIT_PK_NAMESPACE;

#endif /*__DRMOPCODES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmnoncestore.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_NONCE_STORE_H
#define __DRM_NONCE_STORE_H

#include <drmdatastore.h>
#include <drmembeddedstore_impl.h>
#include <drmlicstore.h>

ENTER_PK_NAMESPACE;

/* The data structure of a nonce token. */
typedef struct _tag_DRM_NONCE_TOKEN
{
    /* Nonce value. */
    DRM_ID m_oNonce;

    /* Associated KID. */
    DRM_ID m_oKID;

    /* Flag indicating whether the token has an associated license. */
    DRM_BOOL m_fAllocated;
} DRM_NONCE_TOKEN;

/* The context of the nonce store. */
typedef struct _tagDRM_NONCESTORE_CONTEXT_INTERNAL
{   
    /* Pointer to an OEM context. */
    DRM_VOID *m_pvOEMContext;

    /* Data store context. */
    DRM_DST m_oDataStore;

    /* Data store context using embedded store implementation. */
    DRM_EST_CONTEXT m_oESTContext;

    /* License store context. */
    DRM_LICSTORE_CONTEXT *m_poLicStoreContext;

    /* Nonce store buffer. */
    DRM_BYTE *m_pbBuffer;

    /* Size of nonce store buffer. */
    DRM_DWORD m_cbBuffer;

    /* Flag indicating whether this structure is initialized. */
    DRM_BOOL m_fInited;
    
    /* A single nonce token. */
    DRM_NONCE_TOKEN m_oToken;
} DRM_NONCESTORE_CONTEXT_INTERNAL;

/* The context of the nonce store in the form of a BLOB. */
typedef struct __tagDRM_NONCESTORE_CONTEXT
{
    DRM_BYTE rgbOpaqueData[ __CB_DECL( SIZEOF( DRM_NONCESTORE_CONTEXT_INTERNAL ) ) ];
} DRM_NONCESTORE_CONTEXT;

DRM_API DRM_RESULT DRM_CALL DRM_NST_Open(
    __in_opt DRM_VOID *f_pvOEMContext,
    __in_bcount( f_cbNonceStore ) DRM_BYTE *f_pbNonceStore,
    __in DRM_DWORD f_cbNonceStore,
    __out DRM_LICSTORE_CONTEXT *f_poLicStoreContext,
    __out DRM_NONCESTORE_CONTEXT *f_poNonceStore );

DRM_API DRM_RESULT DRM_CALL DRM_NST_Close(
    __in DRM_NONCESTORE_CONTEXT *f_poNonceStore );

DRM_API DRM_RESULT DRM_CALL DRM_NST_GenerateNonce(
    __in DRM_NONCESTORE_CONTEXT *f_poNonceStore,
    __out DRM_ID *f_poNonce );

DRM_API DRM_RESULT DRM_CALL DRM_NST_AddLicense(
    __in DRM_NONCESTORE_CONTEXT *f_poNonceStore,
    __in DRM_DWORD f_cbLicense,
    __in_bcount( f_cbLicense ) DRM_BYTE *f_pbLicense,
    __in DRM_KID *f_poKID,
    __in DRM_LID *f_poLID,
    __in DRM_DWORD f_dwPriority );

EXIT_PK_NAMESPACE;

#endif /* __DRM_NONCE_STORE_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmndtasf.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMNDTASF_H__
#define __DRMNDTASF_H__

ENTER_PK_NAMESPACE;

DRM_API DRM_RESULT DRM_CALL Drm_Ndt_Asf_Init (
    __in_opt   DRM_VOID                 *f_pOEMContext,
    __in       NDTMGR_CONTEXT           *f_pNdtMgrContext,
    __in const DRM_STRING                f_dstrFilePath,
    __in const NDT_ASFDELIVERY_MODE      f_ASFDeliveryMode,
    __in       DRM_APP_CONTEXT          *f_pAppContext,
    __in const DRM_BOOL                  f_fEncryptClear,
    __out      DRM_ID                   *f_pidSession,
    __out      DRM_DWORD                *f_pdwFlags
);

DRM_API DRM_RESULT DRM_CALL Drm_Ndt_Asf_InitTranscryption(
    __in_opt   DRM_VOID                 *f_pOEMContext,
    __in       NDTMGR_CONTEXT           *f_pNdtMgrContext,
    __in const DRM_ID                    f_idSession,
    __in const DRM_BYTEBLOB              f_LicenseChallenge,
    __out      DRM_KID                  *f_pKID,
    __out_bcount_opt(*f_pcbLicenseResponse) DRM_BYTE *f_pbLicenseResponse,
    __inout    DRM_DWORD                *f_pcbLicenseResponse
);

DRM_API DRM_RESULT DRM_CALL Drm_Ndt_Asf_GetHeader(
    __in_opt   DRM_VOID                 *f_pOEMContext,
    __in       NDTMGR_CONTEXT           *f_pNdtMgrContext,
    __in const DRM_ID                    f_idSession,
    __out_bcount(*f_pcbHeader) DRM_BYTE *f_pbHeader,
    __inout    DRM_DWORD                *f_pcbHeader
);

DRM_API DRM_RESULT DRM_CALL Drm_Ndt_Asf_GenerateLeafLicenseResponse(
    __in_opt   DRM_VOID                 *f_pOEMContext,
    __in       NDTMGR_CONTEXT           *f_pNdtMgrContext,
    __in const DRM_ID                    f_idSession,
    __out      DRM_KID                  *f_pKID,
    __out_bcount(*f_pcbLeafLicenseResponse) DRM_BYTE *f_pbLeafLicenseResponse,
    __inout    DRM_DWORD                *f_pcbLeafLicenseResponse
);

DRM_API DRM_RESULT DRM_CALL Drm_Ndt_Asf_Seek (
    __in_opt   DRM_VOID                 *f_pOEMContext,
    __in       NDTMGR_CONTEXT           *f_pNdtMgrContext,
    __in const DRM_ID                    f_idSession,
    __in const DRM_UINT64                f_qwSeekTimeNS
);

DRM_API DRM_RESULT DRM_CALL Drm_Ndt_Asf_ReadData(
    __in_opt   DRM_VOID                 *f_pOEMContext,
    __in       NDTMGR_CONTEXT           *f_pNdtMgrContext,
    __in const DRM_ID                    f_idSession,
    __out_bcount(*f_pcbData) DRM_BYTE   *f_pbData,
    __inout    DRM_DWORD                *f_pcbData
);

DRM_API DRM_RESULT DRM_CALL Drm_Ndt_Asf_ReadSample(
    __in_opt   DRM_VOID                 *f_pOEMContext,
    __in       NDTMGR_CONTEXT           *f_pNdtMgrContext,
    __in const DRM_ID                    f_idSession,
    __out      NDT_SAMPLEINFO           *f_pSampleInfo,
    __out_bcount(*f_pcbSampleData) DRM_BYTE *f_pbSampleData,
    __inout    DRM_DWORD                *f_pcbSampleData
);

DRM_API DRM_RESULT DRM_CALL Drm_Ndt_Asf_Close(
    __in       NDTMGR_CONTEXT           *f_pNdtMgrContext,
    __in const DRM_ID                    f_idSession,
    __out_opt  DRM_APP_CONTEXT         **f_ppAppContext
);

EXIT_PK_NAMESPACE;

#endif /* __DRMNDTASF_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmndtmanager.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMNDTMANAGER_H__
#define __DRMNDTMANAGER_H__

#include <drmcommon.h>
#include <ndtcontextsizes.h>
#include <ndttypes.h>

ENTER_PK_NAMESPACE;

typedef struct _tagNDTMGR_CONTEXT {
    DRM_BYTE rgbOpaqueBuffer[ __CB_DECL( NDTMGR_CONTEXT_BUFFER_SIZE ) ];
} NDTMGR_CONTEXT;

/* Maximum number of seconds that can pass between a registration request and a registration response */
#define NDT_REGISTRATION_TIMEOUT      120

/* Maximum number of milliseconds for round trip proximity timeout */
#define PROXIMITY_RTT_THRESHOLD_MS    7


DRM_API DRM_RESULT DRM_CALL Drm_Ndt_Initialize(
    __out    NDTMGR_CONTEXT             *f_pNdtMgrContext,
    __in     DRM_APP_CONTEXT            *f_pAppContext
);

DRM_API DRM_VOID DRM_CALL Drm_Ndt_Uninitialize(
    __in     NDTMGR_CONTEXT             *f_pNdtMgrContext
);

DRM_API DRM_RESULT DRM_CALL Drm_Ndt_Session_Create(
    __in_opt    DRM_VOID                *f_pOEMContext,
    __in        NDTMGR_CONTEXT          *f_pNdtMgrContext,
    __in const  NDTMGR_SESSION_TYPE      f_eSessionType,
    __in_opt    DRM_APP_CONTEXT         *f_pAppContext,
    __out       DRM_ID                  *f_pID
);

DRM_API DRM_RESULT DRM_CALL Drm_Ndt_Session_Close(
    __in        NDTMGR_CONTEXT          *f_pNdtMgrContext,
    __in const  DRM_ID                   f_idSession,
    __out_opt   DRM_APP_CONTEXT        **f_ppAppContext
);

DRM_API DRM_RESULT DRM_CALL Drm_Ndt_Registration_ProcessRequest(
    __in_opt DRM_VOID                   *f_pOEMContext,
    __in     NDTMGR_CONTEXT             *f_pNdtMgrContext,
    __in     DRM_ID                      f_idRegistrationSession,
    __in     DRM_BYTEBLOB                f_RegistrationRequest,
    __out_bcount_opt(*f_pcbRegistrationResponse) DRM_BYTE *f_pbRegistrationResponse,
    __inout  DRM_DWORD                  *f_pcbRegistrationResponse
);

DRM_API DRM_RESULT DRM_CALL Drm_Ndt_Proximity_ProcessStartMsg (
    __in_opt DRM_VOID                   *f_pOEMContext,
    __in     NDTMGR_CONTEXT             *f_pNdtMgrContext,
    __in     DRM_BYTEBLOB                f_ProximityStartMsg,
    __out_bcount(*f_pcbProximityChallengeMsg) DRM_BYTE *f_pbProximityChallengeMsg,
    __inout  DRM_DWORD                  *f_pcbProximityChallengeMsg
);

DRM_API DRM_RESULT DRM_CALL Drm_Ndt_Proximity_ProcessResponseMsg (
    __in_opt DRM_VOID                   *f_pOEMContext,
    __in     NDTMGR_CONTEXT             *f_pNdtMgrContext,
    __in     DRM_BYTEBLOB                f_ProximityResponseMsg,
    __out_bcount(*f_pcbProximityResultMsg) DRM_BYTE *f_pbProximityResultMsg,
    __inout  DRM_DWORD                  *f_pcbProximityResultMsg
);

DRM_API DRM_RESULT DRM_CALL Drm_Ndt_License_ProcessChallenge(
    __in_opt   DRM_VOID                 *f_pOEMContext,
    __in       NDTMGR_CONTEXT           *f_pNdtMgrContext,
    __in const DRM_ID                    f_idSession,
    __in const DRM_BYTEBLOB              f_LicenseChallenge,
    __in const NDT_LICENSE_MODE          f_LicenseMode,
    __in       WMDRMNET_POLICY          *f_pPolicy,
    __out      DRM_KID                  *f_pKID,
    __out_bcount(*f_pcbLicenseResponse) DRM_BYTE *f_pbLicenseResponse,
    __inout    DRM_DWORD                *f_pcbLicenseResponse
);

DRM_API DRM_RESULT DRM_CALL Drm_Ndt_License_GenerateLeafResponse(
    __in_opt   DRM_VOID                 *f_pOEMContext,
    __in       NDTMGR_CONTEXT           *f_pNdtMgrContext,
    __in const DRM_ID                    f_idSession,
    __in       WMDRMNET_POLICY          *f_pPolicy,
    __out      DRM_KID                  *f_pKID,
    __out_bcount(*f_pcbLicenseResponse) DRM_BYTE *f_pbLicenseResponse,
    __inout    DRM_DWORD                *f_pcbLicenseResponse
);

DRM_API DRM_RESULT DRM_CALL Drm_Ndt_RevocationList_GenerateChallenge(
    __in       NDTMGR_CONTEXT           *f_pNdtMgrContext,
    __in const DRM_REVOCATION_LIST_TYPE  f_eRevocationList,
    __out_bcount_opt(*f_pcbRevocationListRequest) DRM_BYTE *f_pbRevocationListRequest,
    __inout    DRM_DWORD                *f_pcbRevocationListRequest
);

DRM_API DRM_RESULT DRM_CALL Drm_Ndt_RevocationList_ProcessRequest(
    __in       NDTMGR_CONTEXT          *f_pNdtMgrContext,
    __in const DRM_BYTEBLOB             f_RevocationListRequest,
    __out_bcount_opt(*f_pcbRevocationListResponse) DRM_BYTE *f_pbRevocationListResponse,
    __inout    DRM_DWORD               *f_pcbRevocationListResponse
);

DRM_API DRM_RESULT DRM_CALL Drm_Ndt_RevocationList_ProcessResponse(
    __in       NDTMGR_CONTEXT          *f_pNdtMgrContext,
    __in const DRM_BYTEBLOB             f_RevocationListResponse
);

EXIT_PK_NAMESPACE;

#endif /* __DRMNDTMANAGER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmorderedlist.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef DRMORDEREDLIST_H
#define DRMORDEREDLIST_H

ENTER_PK_NAMESPACE;

typedef struct tagORDERED_LIST_ENTRY
{
    DRM_UINT64                    qwValue;
    DRM_VOID                     *pbData; 
    struct tagORDERED_LIST_ENTRY *pNext;
} ORDERED_LIST_ENTRY;

typedef struct tagORDERED_LIST
{
    DRM_DWORD                     dwCurrentSize;
    DRM_DWORD                     dwMaxSize;
    ORDERED_LIST_ENTRY           *pHead;
} ORDERED_LIST;


DRM_RESULT DRM_CALL DRM_OrderedList_Initialize(
    __out      ORDERED_LIST            *pOrderedList,
    __in const DRM_DWORD                dwSize
);

DRM_VOID DRM_CALL DRM_OrderedList_Uninitialize(
    __out ORDERED_LIST * const pOrderedList
);

DRM_RESULT DRM_CALL DRM_OrderedList_GetCount(
    __in const ORDERED_LIST * const pOrderedList,
    __out      DRM_DWORD    * const pdwCount
);

DRM_RESULT DRM_CALL DRM_OrderedList_AddEntry(
    __inout    ORDERED_LIST * const pOrderedList,
    __in const DRM_UINT64           qwValue,
    __in       DRM_VOID     * const pbData
);

DRM_RESULT DRM_CALL DRM_OrderedList_RemoveEntry(
    __inout    ORDERED_LIST  * const pOrderedList,
    __in const DRM_DWORD             dwFirstEntryToConsider,
    __out      DRM_UINT64    * const pqwValue,
    __out      DRM_VOID            **ppbData
);

DRM_RESULT DRM_CALL DRM_OrderedList_AddLeadingEntry(
    __inout    ORDERED_LIST  * const pOrderedList,
    __in const DRM_UINT64            qwValue,
    __in       DRM_VOID      * const pbData
);

DRM_RESULT DRM_CALL DRM_OrderedList_GetEntry(
    __in const ORDERED_LIST  * const pOrderedList,
    __in const DRM_DWORD             dwFirstEntryToConsider,
    __out      DRM_UINT64    * const pqwValue,
    __out      DRM_VOID            **ppbData
);

EXIT_PK_NAMESPACE;

#endif /* DRMORDEREDLIST_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmoutputleveltypes.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_OUTPUTLEVELTYPES_H__
#define __DRM_OUTPUTLEVELTYPES_H__

#include <drmxmr.h>

ENTER_PK_NAMESPACE;

static const DRM_WORD DRM_DEFAULT_MINIMUM_SECURITY_LEVEL = 100;

#define DRM_MAX_INCLUSION_GUIDS 20

typedef struct __tagDRM_MINIMUM_OUTPUT_PROTECTION_LEVELS
{
    DRM_WORD wCompressedDigitalVideo;
    DRM_WORD wUncompressedDigitalVideo;
    DRM_WORD wAnalogVideo;
    DRM_WORD wCompressedDigitalAudio;
    DRM_WORD wUncompressedDigitalAudio;
    
} DRM_MINIMUM_OUTPUT_PROTECTION_LEVELS;

typedef struct __tagDRM_OPL_OUTPUT_IDS
{
    DRM_WORD  cIds;
    DRM_GUID  *rgIds;
    
} DRM_OPL_OUTPUT_IDS;

#define VER_DRM_PLAY_OPL_V1                     1
#define VER_DRM_PLAY_OPL                        2
#define VER_DRM_VIDEO_OUTPUT_PROTECTION         2
#define VER_DRM_PLAY_OPL_V2                     3
#define VER_DRM_VIDEO_AUDIO_OUTPUT_PROTECTION   3

typedef struct __tagDRM_OUTPUT_PROTECTION
{
    DRM_GUID guidId;
    DRM_BYTE bConfigData;

} DRM_OUTPUT_PROTECTION;

typedef struct __tagDRM_OUTPUT_PROTECTION_EX
{
    DRM_DWORD   dwVersion;
    DRM_GUID    guidId;
    DRM_DWORD   dwConfigData;
} DRM_OUTPUT_PROTECTION_EX;

typedef DRM_OUTPUT_PROTECTION DRM_AUDIO_OUTPUT_PROTECTION;
typedef DRM_OUTPUT_PROTECTION DRM_VIDEO_OUTPUT_PROTECTION;

typedef DRM_OUTPUT_PROTECTION_EX DRM_AUDIO_OUTPUT_PROTECTION_EX;
typedef DRM_OUTPUT_PROTECTION_EX DRM_VIDEO_OUTPUT_PROTECTION_EX;

typedef struct __tagDRM_VIDEO_OUTPUT_PROTECTION_IDS
{
    DRM_WORD cEntries;
    DRM_VIDEO_OUTPUT_PROTECTION *rgVop;

} DRM_VIDEO_OUTPUT_PROTECTION_IDS;

typedef struct __tagDRM_VIDEO_OUTPUT_PROTECTION_IDS_EX
{
    DRM_DWORD   dwVersion;
    DRM_WORD    cEntries;
    DRM_VIDEO_OUTPUT_PROTECTION_EX *rgVop;

} DRM_VIDEO_OUTPUT_PROTECTION_IDS_EX;

typedef struct __tagDRM_AUDIO_OUTPUT_PROTECTION_IDS
{
    DRM_WORD cEntries;
    DRM_AUDIO_OUTPUT_PROTECTION *rgAop;

} DRM_AUDIO_OUTPUT_PROTECTION_IDS;

typedef struct __tagDRM_AUDIO_OUTPUT_PROTECTION_IDS_EX
{
    DRM_DWORD   dwVersion;
    DRM_WORD    cEntries;
    DRM_AUDIO_OUTPUT_PROTECTION_EX *rgAop;

} DRM_AUDIO_OUTPUT_PROTECTION_IDS_EX;

typedef struct __tagDRM_PLAY_OPL
{
    DRM_MINIMUM_OUTPUT_PROTECTION_LEVELS minOPL;
    DRM_OPL_OUTPUT_IDS                   oplIdReserved;
    DRM_VIDEO_OUTPUT_PROTECTION_IDS      vopi;

} DRM_PLAY_OPL;

typedef struct __tagDRM_PLAY_OPL_EX
{
    DRM_DWORD                            dwVersion;
    DRM_MINIMUM_OUTPUT_PROTECTION_LEVELS minOPL;
    DRM_OPL_OUTPUT_IDS                   oplIdReserved;
    DRM_VIDEO_OUTPUT_PROTECTION_IDS_EX   vopi;

} DRM_PLAY_OPL_EX;

typedef struct __tagDRM_PLAY_OPL_EX2
{
    DRM_DWORD                            dwVersion;
    DRM_MINIMUM_OUTPUT_PROTECTION_LEVELS minOPL;
    DRM_OPL_OUTPUT_IDS                   oplIdReserved;
    DRM_VIDEO_OUTPUT_PROTECTION_IDS_EX   vopi;
    DRM_AUDIO_OUTPUT_PROTECTION_IDS_EX   aopi;
} DRM_PLAY_OPL_EX2;

typedef struct __tagDRM_COPY_OPL
{
    DRM_WORD           wMinimumCopyLevel;
    DRM_OPL_OUTPUT_IDS oplIdIncludes;
    DRM_OPL_OUTPUT_IDS oplIdExcludes;
    
} DRM_COPY_OPL;


EXIT_PK_NAMESPACE;

#endif /* __DRM_OUTPUTLEVELS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmoutputlevels.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_OUTPUTLEVELS_H__
#define __DRM_OUTPUTLEVELS_H__

ENTER_PK_NAMESPACE;

DRM_API DRM_RESULT DRM_CALL DRM_OPL_ProcessPlayOutputLevelData( 
    IN const DRM_CONST_STRING             *f_pdstrRestrictions,
    IN OUT   DRM_PLAY_OPL_EX2             *f_pPlayOPL,
    IN       DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack );

DRM_API DRM_RESULT DRM_CALL DRM_OPL_ProcessCopyOutputLevelData( 
    IN const DRM_CONST_STRING             *f_pdstrRestrictions,
    IN OUT   DRM_COPY_OPL                 *f_pCopyOPL,
    IN       DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack );


DRM_API DRM_RESULT DRM_CALL DRM_OPL_ProcessPlayOutputLevelDataXMR( 
    IN const DRM_XMR_PLAYBACK_RIGHTS      *f_pdstrRestrictions,
    IN OUT   DRM_PLAY_OPL_EX2             *f_pPlayOPL,
    IN       DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack );

DRM_API DRM_RESULT DRM_CALL DRM_OPL_ProcessCopyOutputLevelDataXMR( 
    IN const DRM_XMR_COPY_RIGHTS          *f_pdstrRestrictions,
    IN OUT   DRM_COPY_OPL                 *f_pCopyOPL,
    IN       DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack );

EXIT_PK_NAMESPACE;

#endif /* __DRM_OUTPUTLEVELS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmpkcrypto.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMPKCRYPTO_H__
#define __DRMPKCRYPTO_H__

#include <drmtypes.h>
#include <drmeccp160.h>
#include <drmrsacommon.h>

ENTER_PK_NAMESPACE;

/*
** Enum: Supported asymmetric crypto algorithms for sign/verify and encrypt/decrypt
*/
typedef enum __tagDRM_PKCRYPTO_SUPPORTED_ALGORITHMS
{
    eDRM_ECC_P160  = 1,
    eDRM_ECC_P256  = 2,
    eDRM_RSA       = 3
} DRM_PKCRYPTO_SUPPORTED_ALGORITHMS;


DRM_API DRM_RESULT DRM_CALL DRM_PK_GenKeyPair( 
    __in_opt                            DRM_VOID                           *f_pContext,
    __in                                DRM_PKCRYPTO_SUPPORTED_ALGORITHMS   f_eAlgorithm,
    __in                                DRM_RSA_SUPPORTED_KEY_LENGTHS       f_eRSAKeyLength,
    __inout_ecount( 1 )                 DRM_DWORD                          *f_pcbPublicKey,
    __out_bcount( *f_pcbPublicKey )     DRM_BYTE                           *f_pbPublicKey,
    __inout_ecount( 1 )                 DRM_DWORD                          *f_pcbPrivateKey,
    __out_bcount( *f_pcbPrivateKey )    DRM_BYTE                           *f_pbPrivateKey );
    
    
DRM_API DRM_RESULT DRM_CALL DRM_PK_Encrypt( 
    __in_opt                            DRM_VOID                           *f_pOEMContext,
    __in_opt                            DRM_VOID                           *f_pContext,
    __in                                DRM_PKCRYPTO_SUPPORTED_ALGORITHMS   f_eAlgorithm,
    __in                                DRM_DWORD                           f_cbPublicKey,
    __in_bcount( f_cbPublicKey )  const DRM_BYTE                           *f_pbPublicKey,
    __in                                DRM_DWORD                           f_cbPlainText,
    __in_bcount( f_cbPlainText )  const DRM_BYTE                           *f_pbPlainText,
    __inout_ecount( 1 )                 DRM_DWORD                          *f_pcbCipherText,
    __out_bcount( *f_pcbCipherText )    DRM_BYTE                           *f_pbCipherText );


DRM_API DRM_RESULT DRM_CALL DRM_PK_Decrypt(
    __in_opt                            DRM_VOID                           *f_pContext,
    __in                                DRM_PKCRYPTO_SUPPORTED_ALGORITHMS   f_eAlgorithm,
    __in                                DRM_DWORD                           f_cbPrivateKey,
    __in_bcount( f_cbPrivateKey ) const DRM_BYTE                           *f_pbPrivateKey,
    __in                                DRM_DWORD                           f_cbCipherText,
    __in_bcount( f_cbCipherText ) const DRM_BYTE                           *f_pbCipherText,
    __inout_ecount( 1 )                 DRM_DWORD                          *f_pcbPlainText,
    __out_bcount( *f_pcbPlainText )     DRM_BYTE                           *f_pbPlainText );


DRM_API DRM_RESULT DRM_CALL DRM_PK_Sign(
    __in_opt                            DRM_VOID                           *f_pContext,
    __in                                DRM_PKCRYPTO_SUPPORTED_ALGORITHMS   f_eAlgorithm,
    __in                                DRM_DWORD                           f_cbPrivateKey,
    __in_bcount( f_cbPrivateKey ) const DRM_BYTE                           *f_pbPrivateKey,
    __in                                DRM_DWORD                           f_cbData,
    __in_bcount( f_cbData )       const DRM_BYTE                           *f_pbData,
    __inout_ecount( 1 )                 DRM_DWORD                          *f_pcbSignature,
    __out_bcount( *f_pcbSignature )     DRM_BYTE                           *f_pbSignature );


DRM_API DRM_RESULT DRM_CALL DRM_PK_Verify(     
    __in_opt                            DRM_VOID                           *f_pContext,
    __in                                DRM_PKCRYPTO_SUPPORTED_ALGORITHMS   f_eAlgorithm,
    __in                                DRM_DWORD                           f_cbPublicKey,
    __in_bcount( f_cbPublicKey )  const DRM_BYTE                           *f_pbPublicKey,
    __in                                DRM_DWORD                           f_cbData,
    __in_bcount( f_cbData )       const DRM_BYTE                           *f_pbData,
    __in                                DRM_DWORD                           f_cbSignature,
    __in_bcount( f_cbSignature )  const DRM_BYTE                           *f_pbSignature );

EXIT_PK_NAMESPACE;

#endif /* __DRMPKCRYPTO_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmpfd.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMPFD_H__
#define __DRMPFD_H__

#include <drmpfdmanager.h>

ENTER_PK_NAMESPACE;

DRM_RESULT _PfdDrmManagerFreeContentSession(
    __inout    PFDMGR_CONTEXT_INTERNAL *f_pContext,
    __in const DRM_DWORD                f_dwSessionId
);

DRM_RESULT _PfdDrmManagerFreeAllContentSessions(
    __inout    PFDMGR_CONTEXT_INTERNAL *f_pContext
);

DRM_RESULT _PfdDrmManagerGetSession(
    __inout    PFDMGR_CONTEXT_INTERNAL                  *f_pContext,
    __in const DRM_DWORD                                 f_dwSessionId,
    __out      PFDMGR_CONTENT_SESSION_CONTEXT_INTERNAL **f_pContentSession
);

EXIT_PK_NAMESPACE;
    
#endif  /* __DRMPFD_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmprivkeydeviceexclusion.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_PRIVKEY_DEVICE_REVOCATION__
#define __DRM_PRIVKEY_DEVICE_REVOCATION__

ENTER_PK_NAMESPACE;

PRIVKEY g_privkeyDeviceRevocation = 
{
    TWO_BYTES(0, 0), TWO_BYTES(0, 0), TWO_BYTES(0, 0), TWO_BYTES(0, 0), TWO_BYTES(0, 0), 
    TWO_BYTES(0, 0), TWO_BYTES(0, 0), TWO_BYTES(0, 0), TWO_BYTES(0, 0), TWO_BYTES(0, 0)
};

EXIT_PK_NAMESPACE;

#endif  /* __DRM_PRIVKEY_DEVICE_REVOCATION__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmplayreadyobj.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMPLAYREADYOBJ_H__
#define __DRMPLAYREADYOBJ_H__

ENTER_PK_NAMESPACE;

#include <drmcipher.h>
#include <drmembeddedstore_impl.h>

/*
** PlayReady Data Header Format
**
** Field         | Type
** -----------------------------
** Data Size     | DWORD
** Record Count  | WORD
*/
#define SIZE_OF_DRM_PLAYREADY_DATA_HEADER   ( SIZEOF( DRM_DWORD ) + SIZEOF( DRM_WORD ) )

/*
** PlayReady Record Header Format
**
** Field         | Type
** -----------------------------
** Record Type   | WORD
** Record Size   | WORD
*/
#define SIZE_OF_DRM_PLAYREADY_RECORD_HEADER ( 2 * SIZEOF( DRM_WORD ) )
#define SIZE_OF_PLAYREADY_EMBEDDED_LICENSE_SPACE (1024*10)

/*
** Contains space for the PlayReady Object header, two record headers,
** WMDRM header data, and the embedded license store.
*/
#define DRM_MAX_PLAYREADYOBJSIZE            ( SIZE_OF_DRM_PLAYREADY_DATA_HEADER + \
                                              2 * SIZE_OF_DRM_PLAYREADY_RECORD_HEADER + \
                                              DRM_MAX_HEADERDATASIZE + \
                                              MAX_EMBEDDED_STORE_LEN  )

typedef enum 
{
    PLAYREADY_V4_XML_HEADER          = 0x0001,
    PLAYREADY_V4_SIGNATURE           = 0x0002,
    PLAYREADY_EMBEDDED_LICENSE_STORE = 0x0003
} eDRMPlayReady_RECORD_TYPES;

typedef enum
{
    RM_HEADER_VERSION_UNKNOWN = 0,
    RM_HEADER_VERSION_2       = 2,
    RM_HEADER_VERSION_4       = 4,
} eRMHeaderVersion;

DRM_API DRM_RESULT DRM_CALL DRM_PRO_GetRMHeaderVersion(
    __in_bcount( f_cbHeader ) const DRM_BYTE        *f_pbHeader,
    __in                      const DRM_DWORD        f_cbHeader,
    __out_ecount( 1 )               eRMHeaderVersion *f_peVersion );

DRM_API DRM_RESULT DRM_CALL DRM_PRO_IsValidObject( 
    __in_bcount( f_cbBuffer ) const DRM_BYTE *f_pbBuffer, 
    __in                      const DRM_DWORD f_cbBuffer ); 

DRM_API DRM_RESULT DRM_CALL DRM_PRO_GetRecord( 
    __in_bcount( f_cbBuffer )   const DRM_BYTE   *f_pbBuffer,
    __in                        const DRM_DWORD   f_cbBuffer,
    __in                              DRM_WORD    f_wRecordType,
    __out                             DRM_BYTE  **f_ppbEmbeddedRecord,
    __out                             DRM_DWORD  *f_pcbEmbeddedRecord );

DRM_API DRM_RESULT DRM_CALL DRM_PRO_Create
(
    __in    DRM_CONST_STRING           *f_pdstrPlayReadyHeader,
    __out_bcount_opt( *f_pcbPlayReadyObject )
            DRM_BYTE                   *f_pbPlayReadyObject,
    __inout DRM_DWORD                  *f_pcbPlayReadyObject
);

DRM_API DRM_RESULT DRM_CALL DRM_PRO_GetCipherTypeFromPlayReadyHeader(
    __in_bcount( f_cbPlayReadyHeader )
            DRM_BYTE  *f_pbPlayReadyHeader,
    __in    DRM_DWORD f_cbPlayReadyHeader,
    __out   DRM_SUPPORTED_CIPHERS *f_peCipherType );

DRM_API DRM_RESULT DRM_CALL DRM_PRO_GetCipherType(
    __in_bcount( f_cbPlayReadyObject )
            DRM_BYTE  *f_pbPlayReadyObject,
    __in    DRM_DWORD f_cbPlayReadyObject,
    __out   DRM_SUPPORTED_CIPHERS *f_peCipherType );

DRM_API DRM_RESULT DRM_CALL DRM_PRO_ConvertHeaderFromWmdrmToPlayReady( 
    __in_bcount( f_cbWmdrmHeader )      const DRM_BYTE  *f_pbWmdrmHeader,
    __in                                const DRM_DWORD  f_cbWmdrmHeader,
    __in_ecount_nz_opt( f_cchPlayReadySilentURL )
                                        const DRM_WCHAR *f_pwchPlayReadySilentURL,
    __in                                const DRM_DWORD  f_cchPlayReadySilentURL,
    __in_ecount_nz_opt( f_cchPlayReadyNonSilentURL )
                                        const DRM_WCHAR *f_pwchPlayReadyNonSilentURL,
    __in                                const DRM_DWORD  f_cchPlayReadyNonSilentURL,
    __in_ecount_nz_opt( f_cchServiceID )
                                        const DRM_WCHAR *f_pwchServiceID,
    __in                                const DRM_DWORD  f_cchServiceID,
    __inout_bcount_opt( *f_pcbPlayReadyHeader )      
                                              DRM_BYTE  *f_pbPlayReadyHeader,
    __in                                      DRM_DWORD *f_pcbPlayReadyHeader );

DRM_API DRM_RESULT DRM_CALL Drm_PlayReadyObject_ConvertFromWmdrmHeader( 
    __in_bcount( f_cbWmdrmHeader )  const DRM_BYTE  *f_pbWmdrmHeader,
    __in                            const DRM_DWORD  f_cbWmdrmHeader,
    __in_ecount_nz_opt( f_cchPlayReadySilentURL )
                                    const DRM_WCHAR *f_pwchPlayReadySilentURL,
    __in                            const DRM_DWORD  f_cchPlayReadySilentURL,
    __in_ecount_nz_opt( f_cchPlayReadyNonSilentURL )
                                    const DRM_WCHAR *f_pwchPlayReadyNonSilentURL,
    __in                            const DRM_DWORD  f_cchPlayReadyNonSilentURL,
    __in_ecount_nz_opt( f_cchServiceID )
                                    const DRM_WCHAR *f_pwchServiceID,
    __in                            const DRM_DWORD  f_cchServiceID,
    __inout_bcount_opt( *f_pcbPlayReadyObject )
                                          DRM_BYTE  *f_pbPlayReadyObject,
    __in                                  DRM_DWORD *f_pcbPlayReadyObject );


EXIT_PK_NAMESPACE;

#endif /* __DRMPLAYREADYOBJ_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmpfdmanager.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef _DRMPFDMANAGER_H_
#define _DRMPFDMANAGER_H_

#include <drmcommon.h>
#include <pfddrmcontextsizes.h>

#define PFD_MAX_CONTENT_SESSIONS 1

ENTER_PK_NAMESPACE;

typedef struct __tagPFDMGR_CONTEXT
{
    /* This data is Opaque.  Do not set any value in it. */
    DRM_BYTE rgbOpaqueBuffer[ __CB_DECL( PFDMGR_CONTEXT_BUFFER_SIZE ) ];
} PFDMGR_CONTEXT;


DRM_API DRM_WORD DRM_CALL Drm_Pfd_GetMTPStatusFromDRMRESULT(
    __in const DRM_RESULT f_drRes
);

DRM_API DRM_RESULT DRM_CALL Drm_Pfd_Initialize(
    __out    PFDMGR_CONTEXT   *f_pPfdMgrContext,
    __in_opt DRM_VOID         *f_pOEMContext,
    __in     DRM_CONST_STRING *f_pdstrDeviceStoreName   
);

DRM_API DRM_VOID DRM_CALL Drm_Pfd_Uninitialize(
    __in     PFDMGR_CONTEXT *f_pPfdMgrContext
);

DRM_API DRM_RESULT DRM_CALL Drm_Pfd_Registration_ProcessRequest(
    __in_opt   DRM_VOID       *f_pOEMContext,
    __inout    PFDMGR_CONTEXT *f_pPfdMgrContext, 
    __in_bcount(f_cbRegistrationRequestMsg) DRM_BYTE *f_pbRegistrationRequestMsg,
    __in const DRM_DWORD       f_cbRegistrationRequestMsg,
    __out      DRM_DWORD      *f_pdwRegistrationTransactionID
);

DRM_API DRM_RESULT DRM_CALL Drm_Pfd_Registration_GenerateResponse(
    __inout    PFDMGR_CONTEXT *f_pPfdMgrContext, 
    __in const DRM_DWORD       f_dwRegistrationTransactionID,
    __out_bcount(*f_pcbRegistrationResponseMsg) DRM_BYTE *f_pbRegistrationResponseMsg,
    __inout    DRM_DWORD      *f_pcbRegistrationResponseMsg
);

DRM_API DRM_RESULT DRM_CALL Drm_Pfd_Proximity_GenerateChallenge(
    __in_opt   DRM_VOID       *f_pOEMContext,
    __inout    PFDMGR_CONTEXT *f_pPfdMgrContext, 
    __in const DRM_DWORD       f_dwRegistrationTransactionID,
    __out      DRM_DWORD      *f_pdwChallenge1,
    __out      DRM_DWORD      *f_pdwChallenge2,
    __out      DRM_DWORD      *f_pdwChallenge3,
    __out      DRM_DWORD      *f_pdwChallenge4
);

DRM_API DRM_RESULT DRM_CALL Drm_Pfd_Proximity_ProcessResponse(
    __in_opt   DRM_VOID       *f_pOEMContext,
    __inout    PFDMGR_CONTEXT *f_pPfdMgrContext, 
    __in const DRM_DWORD       f_dwRegistrationTransactionID,
    __in const DRM_DWORD       f_dwEncryptedChallenge1,
    __in const DRM_DWORD       f_dwEncryptedChallenge2,
    __in const DRM_DWORD       f_dwEncryptedChallenge3,
    __in const DRM_DWORD       f_dwEncryptedChallenge4
);

DRM_API DRM_RESULT DRM_CALL Drm_Pfd_License_ProcessRequest(    
    __in_opt                               DRM_VOID       *f_pOEMContext,
    __inout                                PFDMGR_CONTEXT *f_pPfdMgrContext,
    __in const                             DRM_DWORD       f_dwSessionID,
    __in_bcount(f_cbLicenseRequestMsg)     DRM_BYTE       *f_pbLicenseRequestMsg,
    __in const                             DRM_DWORD       f_cbLicenseRequestMsg
);

DRM_API DRM_RESULT DRM_CALL Drm_Pfd_License_GenerateResponse(    
    __inout                                PFDMGR_CONTEXT *f_pPfdMgrContext,
    __in const                             DRM_DWORD       f_dwSessionID,
    __out_bcount(*f_pcbLicenseResponseMsg) DRM_BYTE       *f_pbLicenseResponseMsg,
    __inout                                DRM_DWORD      *f_pcbLicenseResponseMsg
);

DRM_API DRM_RESULT DRM_CALL Drm_Pfd_Aavt_OpenMediaSession(
    __in_opt   DRM_VOID       *f_pOEMContext,
    __inout    PFDMGR_CONTEXT *f_pPfdMgrContext,
    __in     DRM_CONST_STRING *f_pdstrDeviceStoreName,
    __in       DRM_WCHAR      *f_pwszFileName,
    __in const DRM_WORD        f_wFileType,
    __in const DRM_DWORD       f_dwForceNewSession,
    __in const DRM_BOOL        f_fEncryptClear,
    __out      DRM_DWORD      *f_pdwSessionID,
    __out      DRM_DWORD      *f_pdwControlCapabilities,
    __out      DRM_DWORD      *f_pdwDRMStatus,
    __out      DRM_DWORD      *f_pdwLicenseStatus,
    __out      DRM_DWORD      *f_pdwDRMDeliveryOptions
);

DRM_API DRM_RESULT DRM_CALL Drm_Pfd_Aavt_CloseMediaSession(
    __inout    PFDMGR_CONTEXT *f_pPfdMgrContext,
    __in const DRM_DWORD       f_dwSessionID
);

DRM_API DRM_RESULT DRM_CALL Drm_Pfd_Aavt_GetNextDataBlock(
    __in_opt   DRM_VOID       *f_pOEMContext,
    __inout    PFDMGR_CONTEXT *f_pPfdMgrContext,
    __in const DRM_DWORD       f_dwSessionID,
    __out      DRM_DWORD      *f_pdwEndOfData,
    __out_bcount(*f_pcbNextDataBlock) DRM_BYTE *f_pbNextDataBlock,
    __out      DRM_DWORD      *f_pcbNextDataBlock
);

DRM_API DRM_RESULT DRM_CALL Drm_Pfd_Aavt_SetCurrentTimePosition(
    __in_opt   DRM_VOID       *f_pOEMContext,
    __inout    PFDMGR_CONTEXT *f_pPfdMgrContext,
    __in const DRM_DWORD       f_dwSessionID,
    __in const DRM_DWORD       f_dwTimeOffsetInMilliseconds
);

EXIT_PK_NAMESPACE;

#endif  /* _DRMPFDMANAGER_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmprofile.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMPROFILE_H__
#define __DRMPROFILE_H__

#include <drmcommon.h>
#include <drmprofileconstants.h>
#include <drmtrace.h>

ENTER_PK_NAMESPACE;

/* Maxmimum size of cached sample buffer in bytes, should be a multiple of 16 bytes. */
#define MAX_PROFILE_BUFFER_SIZE     92160

/*
** Scope ID is made up of three components: Module ID (12 bits), Function ID (12 bits) and Block ID (7 bits)
** This Macro has been moved out from conditional compilation so that perftool can access it without turning
** ON profiling.
*/
#define PERF_SCOPE_ID( ModuleID, FuncID, BlockID )  ( ( ( ( ModuleID ) & 0x0fff ) << 19 ) + ( ( ( FuncID ) & 0x0fff ) << 7 ) + ( ( BlockID ) & 0x007f ) )

#if DRM_SUPPORT_PROFILING

    /* Flag to indicate whether to enable user data logging. */
    /* User data logging is not supported under aggregated scope sampling. */
    #define PROFILE_USER_DATA       0

    /* PROFILE_USE_SCOPE is defined to use normal scope sampling mechanism. */
    #define PROFILE_USE_SCOPE       1

    /* PROFILE_USE_AGG_SCOPE is defined to use aggregated scope sampling mechanism. */
    #define PROFILE_USE_AGG_SCOPE   0

    /* PROFILE_STACK_SIZE should be turned on to get the max. stack utilization by DRM APIs. */
    #define PROFILE_STACK_SIZE      0

    /* Note: One and only one of the above two definitions can be 1. */
    #if ( PROFILE_USE_SCOPE && PROFILE_USE_AGG_SCOPE ) || ( !PROFILE_USE_SCOPE && !PROFILE_USE_AGG_SCOPE )
        #error One and only one of PROFILE_USE_SCOPE and PROFILE_USE_AGG_SCOPE can be 1.
    #endif

    #if ( PROFILE_USER_DATA && !PROFILE_USE_SCOPE )
        #error User data logging is supported only under normal scope sampling.
    #endif

    #if ( PROFILE_USER_DATA && PROFILE_USE_AGG_SCOPE )
        #error User data logging is not supported under aggregated scope sampling.
    #endif

    /* Maximum levels of nested scope calls. */
    #define MAX_PROFILE_SCOPE_LEVEL     512

    /* Maximum number of aggregated scopes. */
    #define MAX_PROFILE_AGG_SCOPES      1024

    /*
    ** PERF_AGG_SCOPE_CONTEXT is used to store aggregated information of a scope.
    ** All PERF_AGG_SCOPE_CONTEXT structures are stored in global memory and
    ** are persisted at the end of profiling.
    */
    typedef struct _perf_scope_agg_context
    {
        /* Define detail level of logging for this scope. 0: do not check detail level. */
        DRM_UINT m_nDetailLevel;
        
        /* Define feature set this scope belongs to. 0: do not check feature set. */
        DRM_UINT m_nFeatureSet;

        /* Scope ID. */
        DRM_DWORD m_dwScopeID;
        
        /* Aggregated duration of the scope. */
        DRM_DWORD m_dwDuration;

        /* Total call count of the scope. */
        DRM_DWORD m_dwCallCount;

    } PERF_AGG_SCOPE_CONTEXT;

    /* PERF_GLOBAL_CONTEXT is the global context of the profiling machanism. */
    typedef struct _perf_global_context
    {
        /* Scope stack. */
        DRM_DWORD m_dwScopeID[ MAX_PROFILE_SCOPE_LEVEL ];
        
        /* Point to top of the scope stack. */
        DRM_UINT m_nCurrScope;

        /* Logging scopes with detail level < this value.  */
        DRM_UINT m_nDetailLevel;

        /* Logging scopes within a specific group of feature sets. */
        DRM_UINT m_nFeatureSet;

        /* Next PER_AGG_SCOPE_CONTEXT slot number to be assigned. */
        DRM_UINT m_nCurrAggScope;
 
        /* File handle for normal scope samples. */
        OEM_FILEHDL m_fp;
 
        /* File handle for aggregated scope samples. */
        OEM_FILEHDL m_fpAgg;
 
        /* Buffer to cache normal scope samples to minimize I/O. */
        DRM_BYTE m_bBuffer[ MAX_PROFILE_BUFFER_SIZE ];

        /* Next m_bBuffer slot to be assigned. */
        DRM_DWORD m_dwBufferIndex;

        /* Global aggregated scope context. */
        PERF_AGG_SCOPE_CONTEXT m_AggScopes[ MAX_PROFILE_AGG_SCOPES ];

        /* Flag indicating whether the profiling machanism is enable or not. */
        DRM_BOOL m_bRunning;

        /* Flag to prevent recursive profiling. */
        DRM_BOOL m_bInProfile;

        /* Time spent in writing profiling logs to the disk. */
        DRM_DWORD m_dwLogWriteDuration;

        #if PROFILE_USER_DATA    
            /* File handle for user data logging. */
            OEM_FILEHDL * m_fpUserData;

            /* Buffer to cache user data to minimize I/O. */
            DRM_BYTE m_bBufferUserData[ MAX_PROFILE_BUFFER_SIZE ];

            /* Next m_bBufferUserData slot to be assigned. */
            DRM_DWORD m_dwBufferUserDataIndex;
        #endif

        #if PROFILE_STACK_SIZE
            /* File handle for logging stack size data. */
            OEM_FILEHDL  m_fpStackSize;

            /* Max stack usage deteted so far for current PK API (scopelevel = 2). */
            DRM_DWORD m_dwMaxStackSize;

            /* Stack base - relative to this stack size will be calculated. */
            DRM_DWORD_PTR m_dwStackBase;

            /* Scope ID of the PK API leading to max stack usage. */
            DRM_DWORD m_dwMaxStackSizeScopeID;
 
            /* Max stack usage over all the PK APIs involved in a specific scenario. */
            DRM_DWORD m_dwMaxStackSizeinScenario;
        #endif

    } PERF_GLOBAL_CONTEXT;

    typedef struct _perf_scope_context
    {
        /* Define detail level of logging for this scope. 0: do not check detail level. */
        DRM_UINT m_nDetailLevel;

        /* Define feature set this scope belongs to. 0: do not check feature set. */
        DRM_UINT m_nFeatureSet;

        /* Scope ID. */
        DRM_DWORD m_dwScopeID;

        /* Parent scope ID. */
        DRM_DWORD m_dwParentScopeID;

        /* Duration of the scope. */
        DRM_DWORD m_dwDuration;
    
        #if PROFILE_USER_DATA
            /* Custom user data per context. */
            DRM_DWORD m_dwUserData1;
            
            DRM_DWORD m_dwUserData2;
            
            /* More user data can be defined afterwards. */
        #endif    

        /*
        ** Trace level of the current scope.
        ** If both profiling and tracing are enabled, the
        ** scope level tracing control will stay in the
        ** perf scope context.
        **/
        eTraceLevel m_eTraceLevel;
            
        /* Current component ID. */
        DRM_DWORD m_dwComponent;

    } PERF_SCOPE_CONTEXT;

EXIT_PK_NAMESPACE;

    /* OEM function to retrieve global prifile context. */
    #include <oemprofile.h>

ENTER_PK_NAMESPACE;

    extern DRM_DWORD Perf_String_Data( DRM_CONST_STRING * pdstrIn );

    extern DRM_DWORD Perf_Binary_Data( DRM_BYTE * pbIn, DRM_DWORD dwSize );

    extern DRM_RESULT Perf_Log_Profile( PERF_SCOPE_CONTEXT * pScopeContext, DRM_UINT nScopeLevel );

    extern DRM_RESULT Perf_Enter_Scope( PERF_SCOPE_CONTEXT * pScopeContext );

    extern DRM_RESULT Perf_Leave_Scope( PERF_SCOPE_CONTEXT * pScopeContext );

    extern DRM_RESULT Perf_Enter_Agg_Scope( PERF_AGG_SCOPE_CONTEXT ** ppAggScopeContext, DRM_DWORD dwScopeID );

    extern DRM_RESULT Perf_Leave_Agg_Scope( PERF_AGG_SCOPE_CONTEXT * pAggScopeContext, DRM_DWORD dwDuration );

    extern DRM_RESULT Perf_Start_Profiling( DRM_VOID *pOEMContext, DRM_CONST_STRING *dstrPerfFileName );

    extern DRM_RESULT Perf_Stop_Profiling();

    extern DRM_RESULT Perf_Init_ProfileStack();

    /* Macro definitions. */

    /* Returns the performance counter's currrent count in microseconds. */    
#if DRM_NO_NATIVE_64_TYPES
    static DRM_UINT64 PERF_MICROSECONDS_PER_SECOND = DRM_UI64LITERAL( 0,1000000 );
    #define PERF_CURRENT_MICROSECOND_COUNT  \
        ( DRM_UI64Low32( DRM_UI64Div( DRM_UI64Mul( Oem_Profiling_QueryPerformanceCounter(), PERF_MICROSECONDS_PER_SECOND ), Oem_Profiling_QueryPerformanceFrequency() ) ) )
#else
    #define PERF_MICROSECONDS_PER_SECOND 1000000.0
    #define PERF_CURRENT_MICROSECOND_COUNT  \
        ( ( DRM_DWORD )( ( ( double )Oem_Profiling_QueryPerformanceCounter() ) * ( PERF_MICROSECONDS_PER_SECOND / ( ( double )Oem_Profiling_QueryPerformanceFrequency() ) ) ) )
#endif /* DRM_NO_NATIVE_64_TYPES */

    /* Macros used for normal scope sampling. */
    #define PERF_SCOPE_DETAIL_LEVEL_X( DetailLevel)         ScopeContext.m_nDetailLevel = ( DetailLevel );

    #define PERF_SCOPE_FEATURE_SET_X( FeatureSet)           ScopeContext.m_nFeatureSet = ( FeatureSet );

    #define PERF_ENTER_SCOPE_X( ModuleID, FuncID, BlockID ) { \
                                                            PERF_SCOPE_CONTEXT ScopeContext = { 0 }; \
                                                            ScopeContext.m_dwScopeID = PERF_SCOPE_ID( ( ModuleID ), ( FuncID ), ( BlockID ) ); \
                                                            ScopeContext.m_nDetailLevel = 1; \
                                                            ScopeContext.m_nFeatureSet = 0; \
                                                            ScopeContext.m_eTraceLevel = TRACE_FATAL; \
                                                            Perf_Enter_Scope(&ScopeContext); \
                                                            DRM_TRACE_ENTER_SCOPE( TRACE_DEFAULT_ROBUST, ScopeContext.m_dwScopeID );

    #define PERF_LEAVE_SCOPE_X                              Perf_Leave_Scope( &ScopeContext );  \
                                                            DRM_TRACE_LEAVE_SCOPE( TRACE_DEFAULT_ROBUST, ScopeContext.m_dwScopeID, dr ); \
                                                            }

    #define PERF_ENTER_SCOPE( ModuleID, FuncID )            PERF_ENTER_SCOPE_X( ModuleID, FuncID, 1 )

    #define PERF_LEAVE_SCOPE                                PERF_LEAVE_SCOPE_X;

    /* Macros used for aggregated scope sampling. */
    #define PERF_AGG_SCOPE_DETAIL_LEVEL_X( DetailLevel )    pAggScopeContext->m_nDetailLevel = ( DetailLevel );

    #define PERF_AGG_SCOPE_FEATURE_SET_X( FeatureSet )      pAggScopeContext->m_nFeatureSet = ( FeatureSet );

    #define PERF_ENTER_AGG_SCOPE_X( ModuleID, FuncID, BlockID ) { \
                                                            static PERF_AGG_SCOPE_CONTEXT * pAggScopeContext = NULL; \
                                                            DRM_DWORD dwPerfAggEnterTick = PERF_CURRENT_MICROSECOND_COUNT; \
                                                            Perf_Enter_Agg_Scope( &pAggScopeContext, PERF_SCOPE_ID( ( ModuleID ), ( FuncID ), ( BlockID ) ) );

    #define PERF_LEAVE_AGG_SCOPE_X                          dwPerfAggEnterTick = PERF_CURRENT_MICROSECOND_COUNT - dwPerfAggEnterTick; \
                                                            Perf_Leave_Agg_Scope( pAggScopeContext, dwPerfAggEnterTick ); \
                                                            }

    #define PERF_ENTER_AGG_SCOPE( ModuleID, FuncID )        PERF_ENTER_AGG_SCOPE_X( ModuleID, FuncID, 1 )

    #define PERF_LEAVE_AGG_SCOPE                            PERF_LEAVE_AGG_SCOPE_X;

    /* Below are macros that are used externally by the code to be profiled. */

    /* Macros used for global context setup. */
    #define DRM_PROFILING_GLOBAL_DETAIL_LEVEL( DetailLevel )    \
                                                            Oem_Profiling_GetProfileContext()->m_nDetailLevel = ( DetailLevel );

    #define DRM_PROFILING_GLOBAL_FEATURE_SET( FeatureSet )  Oem_Profiling_GetProfileContext()->m_nFeatureSet = ( FeatureSet );

    #define DRM_PROFILING_STRING_HASH( pstrIn )             ( Perf_String_Data( ( DRM_CONST_STRING * )pstrIn ) )

    #define DRM_PROFILING_BINARY_HASH( pbIn, dwSize )       ( Perf_Binary_Data( pbIn, dwSize ) )

    #if PROFILE_USER_DATA

        #define DRM_PROFILING_USER_DATA_1( UserData )       ScopeContext.m_dwUserData1 = ( UserData );

        #define DRM_PROFILING_USER_DATA_2( UserData )       ScopeContext.m_dwUserData2 = ( UserData );

    #else 

        #define DRM_PROFILING_USER_DATA_1( UserData )

        #define DRM_PROFILING_USER_DATA_2( UserData )

    #endif  /* PROFILE_USER_DATA */

    /* Define generic macros used in the source code. */
    #if PROFILE_USE_SCOPE

        #define DRM_PROFILING_DETAIL_LEVEL( DetailLevel )   PERF_SCOPE_DETAIL_LEVEL_X( DetailLevel )

        #define DRM_PROFILING_FEATURE_SET( FeatureSet )     PERF_SCOPE_FEATURE_SET_X( FeatureSet )

        #define DRM_PROFILING_ENTER_SCOPE_X                 PERF_ENTER_SCOPE_X

        #define DRM_PROFILING_LEAVE_SCOPE_X                 PERF_LEAVE_SCOPE_X

        #define DRM_PROFILING_ENTER_SCOPE                   PERF_ENTER_SCOPE

        #define DRM_PROFILING_LEAVE_SCOPE                   PERF_LEAVE_SCOPE

    #endif  /* PROFILE_USE_SCOPE */

    #if PROFILE_USE_AGG_SCOPE

        #define DRM_PROFILING_DETAIL_LEVEL( DetailLevel )   PERF_AGG_SCOPE_DETAIL_LEVEL_X(DetailLevel)

        #define DRM_PROFILING_FEATURE_SET( FeatureSet )     PERF_AGG_SCOPE_FEATURE_SET_X(FeatureSet)

        #define DRM_PROFILING_ENTER_SCOPE_X                 PERF_ENTER_AGG_SCOPE_X

        #define DRM_PROFILING_LEAVE_SCOPE_X                 PERF_LEAVE_AGG_SCOPE_X

        #define DRM_PROFILING_ENTER_SCOPE                   PERF_ENTER_AGG_SCOPE

        #define DRM_PROFILING_LEAVE_SCOPE                   PERF_LEAVE_AGG_SCOPE

    #endif  /* PROFILE_USE_AGG_SCOPE */

    #define DRM_Start_Profiling( x, y ) Perf_Start_Profiling( x, y )

    #define DRM_Stop_Profiling()        Perf_Stop_Profiling()

    #define DRM_Init_ProfileStack()     Perf_Init_ProfileStack()

#else   /* DRM_SUPPORT_PROFILING */

    #define DRM_PROFILING_USER_DATA_1( UserData )

    #define DRM_PROFILING_USER_DATA_2( UserData )

    #define DRM_PROFILING_DETAIL_LEVEL( DetailLevel )

    #define DRM_PROFILING_FEATURE_SET( FeatureSet )

    #define DRM_PROFILING_ENTER_SCOPE_X( ModuleID, FuncID, BlockID )    

    #define DRM_PROFILING_LEAVE_SCOPE_X()

    #if DRM_SUPPORT_TRACING

        typedef struct _trace_scope_context
        {
            /* Scope ID. */
            DRM_DWORD m_dwScopeID;

            /* Trace level of the current scope. */
            eTraceLevel m_eTraceLevel;
            
            /* Current component ID. */
            DRM_DWORD m_dwComponent;

        } TRACE_SCOPE_CONTEXT;

        #define DRM_PROFILING_ENTER_SCOPE( ModuleID, FuncID )       { \
                                                                    TRACE_SCOPE_CONTEXT ScopeContext = { 0 }; \
                                                                    ScopeContext.m_dwScopeID = PERF_SCOPE_ID( ( ModuleID ), ( FuncID ), 1 ); \
                                                                    ScopeContext.m_eTraceLevel = TRACE_FATAL; \
                                                                    DRM_TRACE_ENTER_SCOPE( TRACE_DEFAULT_ROBUST, ScopeContext.m_dwScopeID );

        #define DRM_PROFILING_LEAVE_SCOPE                           DRM_TRACE_LEAVE_SCOPE( TRACE_DEFAULT_ROBUST, ScopeContext.m_dwScopeID, dr ); }

    #else

        #define DRM_PROFILING_ENTER_SCOPE( ModuleID, FuncID )

        #define DRM_PROFILING_LEAVE_SCOPE

    #endif  /* DRM_SUPPORT_TRACING */

    #define DRM_PROFILING_GLOBAL_DETAIL_LEVEL( DetailLevel )

    #define DRM_PROFILING_GLOBAL_FEATURE_SET( FeatureSet )

    #define DRM_PROFILING_STRING_HASH( pstrIn )

    #define DRM_PROFILING_BINARY_HASH( pstrIn )

    #define DRM_Start_Profiling( x, y ) DRM_SUCCESS

    #define DRM_Stop_Profiling()        DRM_SUCCESS

    #define DRM_Init_ProfileStack()     DRM_SUCCESS

#endif /* DRM_SUPPORT_PROFILING */

EXIT_PK_NAMESPACE;

#endif    /* __DBMPROFILE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmpragmas.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMPRAGMAS_H__
#define __DRMPRAGMAS_H__

/*  
# Abstract:
#
# This file contains compiler directives for disabling certain compiler-time warnings
# and allow the PK environment to be compiled under elevated warning level
#
# For example, Microsoft compiler can use warning level /W4
#
*/

#if defined (_MSC_VER)

/* 
** need to ignore unknown pragmas if not using prefast 
*/
#ifndef _PREFAST_
    #pragma warning(disable:4068)
#endif

/*  
** Pragmas to disable. These /W4 warnings are expected. 
*/
#pragma warning(disable:4100) /* unreferenced formal parameter */
#pragma warning(disable:4127) /* "conditional expression is constant" */
#pragma warning(disable:4244) /* conversion from 'type1' to 'type2', possible loss of data */
#pragma warning(disable:4245) /* conversion from 'type1' to 'type2', signed/unsigned mismatch */
#pragma warning(disable:4505) /* unreferenced local function has been removed */
#pragma warning(disable:4510) /* default constructor not possible for structure w/const field */
#pragma warning(disable:4512) /* assignment operator not possible for struct w/const field */
#pragma warning(disable:4610) /* struct non-instantiatable due to const field */
#pragma warning(disable:4152) /* nonstandard extension, function/data pointer conversion in expression */

/*
** some W4 warnings are not fixed in PC code
*/
#if DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_PC
#pragma warning(disable:4204) /* nonstandard extension used : non-constant aggregate initializer */
#pragma warning(disable:4189) /* local variable is initialized but not referenced */
#pragma warning(disable:4706) /* assignment within conditional expression */
#endif

/* 
** amd64 and ia64 specific errors 
*/
#if defined(_M_AMD64) || defined(_M_IA64)
#pragma warning(disable:4152) /* nonstandard extension, function/data pointer conversion in expression */
#pragma warning(disable:4306) /* 'type cast' : conversion from 'type1' to 'type2' of greater size */
#pragma warning(disable:4366) /* The result of the unary operator may be unaligned */
#endif /* _M_AMD64 */

#endif /* _MSC_VER */

#endif  /* __DRMPRAGMAS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmprofileconstantscfd.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMPROFILECONSTANTSCFD_H__
#define __DRMPROFILECONSTANTSCFD_H__

#define PERF_FUNC_DRM_MSDB_InitDeviceCertificateContext         2
#define PERF_FUNC_DRM_MSDB_InitPackagingContext                 3
#define PERF_FUNC_DRM_MSDB_InitEncrypt                          4
#define PERF_FUNC_DRM_MSDB_CreateEncryptionHeader               5
#define PERF_FUNC_DRM_MSDB_GenerateCRLUpdateResponse            6
#define PERF_FUNC_DRM_MSDB_GenerateLicenseResponse              7
#define PERF_FUNC_DRM_MSDB_InitBinaryDeviceCertificateContext   8

#endif /* __DRMPROFILECONSTANTSCFD_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmpubkeydeviceexclusion.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_PUBKEY_DEVICE_REVOCATION__
#define __DRM_PUBKEY_DEVICE_REVOCATION__

ENTER_PK_NAMESPACE;

extern const PUBKEY g_pubkeyDeviceRevocation;
extern const PUBKEY g_pubkeyWMDRMNDRevocation;

EXIT_PK_NAMESPACE;

#endif  /* __DRM_PUBKEY_DEVICE_REVOCATION__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmpubkeyrevocation.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_PUBKEY_REVOCATION__
#define __DRM_PUBKEY_REVOCATION__

ENTER_PK_NAMESPACE;

PUBKEY g_pubkeyRevocation = 
{
    TWO_BYTES(0x02, 0x14), TWO_BYTES(0xEF, 0x99), TWO_BYTES(0xD4, 0x80), TWO_BYTES(0x0C, 0x96), 
    TWO_BYTES(0x5E, 0xB4), TWO_BYTES(0x57, 0x5C), TWO_BYTES(0xE7, 0x16), TWO_BYTES(0x67, 0x60), 
    TWO_BYTES(0x40, 0x4E), TWO_BYTES(0x6D, 0x23), TWO_BYTES(0x30, 0x42), TWO_BYTES(0xBB, 0xBA), 
    TWO_BYTES(0x68, 0x35), TWO_BYTES(0x42, 0x30), TWO_BYTES(0xA1, 0xB6), TWO_BYTES(0x10, 0x95), 
    TWO_BYTES(0x4C, 0x40), TWO_BYTES(0xF9, 0xAA), TWO_BYTES(0x10, 0x85), TWO_BYTES(0xE5, 0x70)
};

EXIT_PK_NAMESPACE;

#endif  /* __DRM_PUBKEY_REVOCATION__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmprofileconstants.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMPROFILECONSTANTS_H__
#define __DRMPROFILECONSTANTS_H__

#define PERF_MOD_BLACKBOX                       1
#define PERF_MOD_DRMCHAIN                       2
#define PERF_MOD_DRMHDS                         3
#define PERF_MOD_DRMHDSIMPL                     4
#define PERF_MOD_DRMLICACQREQ                   5
#define PERF_MOD_DRMLICACQRESP                  6
#define PERF_MOD_DRMLICEVAL                     7
#define PERF_MOD_DRMLICSTORE                    8
#define PERF_MOD_DRMSECSTORE                    9
#define PERF_MOD_DEVCERT                        10
#define PERF_MOD_DEVICEDEVCERT                  11
#define PERF_MOD_DRM_APP                        12
#define PERF_MOD_METERING                       13
#define PERF_MOD_OEMFILEIO                      14
#define PERF_MOD_SECURECLOCKREQUEST             15
#define PERF_MOD_SECURECLOCKRESPONSE            16
#define PERF_MOD_DRMGENSYNCCHALLENGE            17
#define PERF_MOD_DRMHDRPARSER                   18
#define PERF_MOD_DRMVIEWRIGHTS                  19
#define PERF_MOD_DRMLICPARSER                   20
#define PERF_MOD_DRM_ECC_P160                   21
#define PERF_MOD_DRMSYNCSTORE                   22
#define PERF_MOD_DRMUTILITIES                   23
#define PERF_MOD_DRMXMLPARSER                   24
#define PERF_MOD_DRMBASE64                      25
#define PERF_MOD_OEMINFO                        26
#define PERF_MOD_DRMCIPHER                      27
#define PERF_MOD_DESKEY                         28
#define PERF_MOD_RC4                            29
#define PERF_MOD_DRMCBC                         30
#define PERF_MOD_CFD                            31      /* Copy From Device Porting Kit */
#define PERF_MOD_OEMAES                         32
#define PERF_MOD_DRMAES                         33
#define PERF_MOD_DRMRSA                         34
#define PERF_MOD_DRMSHA256                      35
#define PERF_MOD_DRM_ECC_P256                   36
#define PERF_MOD_BCERT                          37      /* Binary Certificates */
#define PERF_MOD_DOMAINSTORE                    38      /* Domain store */
#define PERF_MOD_DOMAINAPI                      39      /* Domain APIs */
#define PERF_MOD_XMLSIG                         40      /* XML encryption/signature */
#define PERF_MOD_SOAPXML                        41      /* SOAP/XML utility */
#define PERF_MOD_LICACQV3                       42      /* V3 license acquisition */
#define PERF_MOD_UTF8                           43      /* UTF-8 */
#define PERF_MOD_DRMHMAC                        44
#define PERF_MOD_NDR                            45      /* Network Device - Receiver */
#define PERF_MOD_NDT                            46      /* Network Device - Transmitter */
#define PERF_MOD_DEVICESTORE                    47
#define PERF_MOD_REVOCATION                     48
#define PERF_MOD_RSA                            49
#define PERF_MOD_NDT_NETMSG                     50
#define PERF_MOD_NDT_ASF                        51
#define PERF_MOD_NDT_ASF_SAMPLE                 52
#define PERF_MOD_NDT_ASF_MUX                    53
#define PERF_MOD_NDT_ASF_STREAM                 54
#define PERF_MOD_DRMPRO                         55      /* PlayReady Object APIs */
#define PERF_MOD_DRMEMB                         56      /* License Embedding APIs */
#define PERF_MOD_DRMXMLBUILDER                  57      /* Both UTF-16 and UTF-8 XML builders */
#define PERF_MOD_NDCERT                         58      /* ND Certificates */


/* blackbox\blackbox.c */
#define PERF_FUNC_DRM_BBX_CipherKeySetup        1
#define PERF_FUNC_DRM_BBX_LegacyCipherKeySetup  2
#define PERF_FUNC_DRM_BBX_HashValue             3
#define PERF_FUNC_DRM_BBX_SymmetricVerify       4
#define PERF_FUNC_DRM_BBX_Initialize            5
#define PERF_FUNC_DRM_BBX_CanBind               6
#define PERF_FUNC__DecryptContentKey            7
#define PERF_FUNC_VerifyChecksum                8
#define PERF_FUNC__GetDevicePrivkey             9
#define PERF_FUNC_DRM_BBX_RebindSLK             10
#define PERF_FUNC_DRM_BBX_DecryptLicense        11
#define PERF_FUNC_DRM_BBX_SymmetricCipher       12
#define PERF_FUNC_DRM_BBX_StoreDomainPrivateKeys 13

/* core\drmchain.c */
#define PERF_FUNC__PerformActions               1
#define PERF_FUNC__ProcessEndOfChain            2
#define PERF_FUNC_DRM_LIC_CompleteLicenseChain  3
#define PERF_FUNC_DRM_LIC_ReportActions         4
#define PERF_FUNC_DRM_LIC_CheckClockRollback    5
#define PERF_FUNC__GetLicenseInfoAndSetup       6
#define PERF_FUNC__ValidateRevocationVersions   7
#define PERF_FUNC_DRM_LIC_GetInclusionList      8

/* core\drmhds.c */
#define PERF_FUNC_DRM_HDS_OpenStore2            1
#define PERF_FUNC_DRM_HDS_CloseStore            2
#define PERF_FUNC_DRM_HDS_OpenNamespace         3
#define PERF_FUNC_DRM_HDS_OpenSlot              4
#define PERF_FUNC_DRM_HDS_InitSlotEnum          5
#define PERF_FUNC_DRM_HDS_SlotEnumNext          6
#define PERF_FUNC_DRM_HDS_Init                  7

/* core\drmhds.c */
#define PERF_FUNC__HdsGetPutBlockHDR            1
#define PERF_FUNC__HdsGetPutBlockPayload        2
#define PERF_FUNC__HdsSearchSlotInFile          3
#define PERF_FUNC__HdsHashToChildBlock          4
#define PERF_FUNC__HdsSearchSlotInBlock         5
#define PERF_FUNC__HdsCopyBlockBuffer           6
#define PERF_FUNC__HdsAllocBlockBuffer          7
#define PERF_FUNC__HdsHashKeyToIndex            8
#define PERF_FUNC__HdsLoadBlockHDR              9
#define PERF_FUNC__HdsLoadSRN                   10
#define PERF_FUNC__HdsGenSRNHash                11
#define PERF_FUNC__WriteSRN                     12
#define PERF_FUNC__ReadSRN                      13
#define PERF_FUNC__WriteCommonBlockHeader       14
#define PERF_FUNC__ReadCommonBlockHeader        15
#define PERF_FUNC__WriteChildBlockHeader        16
#define PERF_FUNC__ReadChildBlockHeader         17
#define PERF_FUNC__WriteDataBlockHeader         18
#define PERF_FUNC__ReadDataBlockHeader          19
#define PERF_FUNC__HdsGenBlockHash              20
#define PERF_FUNC__HdsGetPutChildBlockNum       21
#define PERF_FUNC__HdsExpandStore               22
#define PERF_FUNC__HdsUpdateSRN                 23
#define PERF_FUNC__HdsAllocBlock                24
#define PERF_FUNC__HdsFreeBlock                 25
#define PERF_FUNC__HdsLocateFreeBlockForSlot    26
#define PERF_FUNC__HdsCreateOversizedSlot       27
#define PERF_FUNC__HdsOpenSlotFromHint          28
#define PERF_FUNC__HdsAllocSlotInFile           29
#define PERF_FUNC__HdsCreateAndOpenSlot         30
#define PERF_FUNC__HdsOpenSlot                  31
#define PERF_FUNC__HdsVerifySlotContext         32
#define PERF_FUNC__HdsReadWriteSlot             33
#define PERF_FUNC__HdsAdjustChildPayload        34
#define PERF_FUNC__HdsFindLeftmostLeafBlock     35
#define PERF_FUNC__HdsCopySlot_Child2Child      36
#define PERF_FUNC__HdsCopyChildPayload          37
#define PERF_FUNC__HdsDefragmentFile            38
#define PERF_FUNC__HdsDeleteSubTree             39
#define PERF_FUNC__HdsTraverseNextRightSiblingBlock 40
#define PERF_FUNC__HdsTraverseBlocksInPostOrder     41
#define PERF_FUNC__HdsGetPutSlotAttributes          42

/* core\drmlicacqreq.c */
#define PERF_FUNC_DRM_LA_CreateChallenge        1
#define PERF_FUNC_DRM_LA_GetClientInfo          2

/* core\drmlicacqresp.c */
#define PERF_FUNC_DRM_LA_ProcessResponse                1
#define PERF_FUNC__UpdateLicenseWithSymmetricData       2
#define PERF_FUNC__UpdateLicenseWithSymmetricKey        3
#define PERF_FUNC__UpdateLicenseWithSymmetricSignature  4

/* core\drmliceval.c */
#define PERF_FUNC_DRM_LEVL_PerformOperationsXML         1
#define PERF_FUNC_DRM_LEVL_GetLicenseReasonForUnusable  2
#define PERF_FUNC_Eval                                  3
#define PERF_FUNC_SetOrUpdateContentRevocation          4
#define PERF_FUNC_DRM_LEVL_EvaluateExpression           5
#define PERF_FUNC_DRM_LEVL_PerformOperationsXMR         6
#define PERF_FUNC__SetOrUpdateContentRevocation         7

/* core\drmlicstore.c */
#define PERF_FUNC__InitEnum                     1
#define PERF_FUNC_DRM_LST_EnumNext              2
#define PERF_FUNC_DRM_LST_Open                  3
#define PERF_FUNC_DRM_LST_Close                 4
#define PERF_FUNC_DRM_LST_GetLicense            5

/* core\drmsecstore.c */
#define PERF_FUNC_DRM_SST_OpenKeyTokens                 1
#define PERF_FUNC_DRM_SST_CreateGlobalStorePassword     2
#define PERF_FUNC_DRM_SST_CreateLicenseStatePassword    3
#define PERF_FUNC_DRM_SST_CloseKey                      4
#define PERF_FUNC_DRM_SST_GetData                       5
#define PERF_FUNC_DRM_SST_SetData                       6
#define PERF_FUNC_DRM_SST_GetExtendedTokenValue         7
#define PERF_FUNC_DRM_SST_SetExtendedTokenValue         8
#define PERF_FUNC__VerifySlotHash                       9

/* core\drmplayreadyobj.c */
#define PERF_FUNC_DRM_PRO_Create                          1
#define PERF_FUNC_DRM_PRO_GetCipherTypeFromPlayReadyHeader  2
#define PERF_FUNC_DRM_PRO_GetCipherType                 3
#define PERF_FUNC_DRM_PRO_ConvertHeaderFromWmdrmToPlayReady 4
#define PERF_FUNC_Drm_PlayReadyObject_ConvertFromWmdrmHeader 5

/* devcertparser\devcert.c */
#define PERF_FUNC_DRM_DCP_GetAttribute          1
#define PERF_FUNC_DRM_DCP_LoadPropertiesCache   2

/* devicedevcert\devicedevcert.c */
#define PERF_FUNC__CompareMachineId                  1
#define PERF_FUNC__VerifySymmetricSignature          2
#define PERF_FUNC_DRM_DDC_GetDeviceCertificate       3
#define PERF_FUNC_DRM_DDC_GetBinaryDeviceCertificate 4
#define PERF_FUNC_DRM_DDC_XMLCertificate_Initialize  5
#define PERF_FUNC_DRM_DDC_BINCertificate_Initialize  6

/* drmmanager\drmmanager.c */
#define PERF_FUNC_Drm_Initialize                            1
#define PERF_FUNC_Drm_Uninitialize                          2
#define PERF_FUNC_Drm_LicenseAcq_GenerateChallenge          3
#define PERF_FUNC_Drm_Device_GetProperty                    4
#define PERF_FUNC_Drm_LicenseAcq_ProcessResponse            5
#define PERF_FUNC_Drm_Reader_Bind                           6
#define PERF_FUNC_Drm_Reader_Commit                         7
#define PERF_FUNC_Drm_LicenseQuery_GetState                 8
#define PERF_FUNC_Drm_Sync_GenerateChallenge                9
#define PERF_FUNC_Drm_SecureClock_ProcessResponse           10
#define PERF_FUNC_Drm_SecureClock_GenerateChallenge         11
#define PERF_FUNC_Drm_SecureClock_GetValue                  12
#define PERF_FUNC_Drm_StoreMgmt_CleanupStore                13
#define PERF_FUNC_Drm_LicenseQuery_IsAllowed                14
#define PERF_FUNC__CheckSecureClock                         15
#define PERF_FUNC__SetupLicEvalObjectToShare                16
#define PERF_FUNC__CreateDeviceStore                        17
#define PERF_FUNC_Drm_SyncListItem_InitEnum                 18
#define PERF_FUNC_Drm_SyncListItem_EnumNext                 19
#define PERF_FUNC_Drm_Envelope_Open                         20
#define PERF_FUNC_Drm_Envelope_InitializeRead               21
#define PERF_FUNC_Drm_Envelope_Close                        22
#define PERF_FUNC_Drm_Envelope_GetSize                      23
#define PERF_FUNC_Drm_Envelope_Read                         24
#define PERF_FUNC_Drm_Envelope_Seek                         25
#define PERF_FUNC_Drm_StoreMgmt_DeleteLicenses              26
#define PERF_FUNC_Drm_License_GetProperty                   27
#define PERF_FUNC_Drm_Content_UpdateEmbeddedStore           28
#define PERF_FUNC_Drm_Content_GetProperty                   29
#define PERF_FUNC_Drm_Envelope_WritePlayReadyObject         30
#define PERF_FUNC_Drm_Content_UpdateEmbeddedStore_Commit    31

/* metering\drmmeterimpv1.c */
/* metering\drmmeterimp.c */
/* metering\drmmeterapi.c */
#define PERF_FUNC_DRM_MTR_UpdateData                1
#define PERF_FUNC_DRM_MTR_ProcessMeterResponse      2
#define PERF_FUNC__BuildMeterCertChallengeXML       3
#define PERF_FUNC__ProcessMeterCertInResponse       4
#define PERF_FUNC_DRM_MTR_GenerateMeterCertChallenge    5
#define PERF_FUNC_DRM_MTR_ProcessMeterCertResponse  6
#define PERF_FUNC_Drm_Metering_GenerateChallenge    7
#define PERF_FUNC_Drm_Metering_ProcessResponse      8
#define PERF_FUNC_Drm_MeterCert_Update              9
#define PERF_FUNC_Drm_MeterCert_InitEnum            10
#define PERF_FUNC_Drm_MeterCert_EnumNext            11
#define PERF_FUNC_Drm_GetMeterCert_By_MID           12
#define PERF_FUNC_Drm_MeterCert_GenerateChallenge   13
#define PERF_FUNC_Drm_MeterCert_ProcessResponse     14
#define PERF_FUNC_DRM_MTR_GenerateMeterDataChallenge    15
#define PERF_FUNC_DRM_MTR_ProcessMeterDataResponse  16
#define PERF_FUNC__VerifyMeterDataResponse          17
#define PERF_FUNC__ProcessMeterDataResponse         18
#define PERF_FUNC__CalcMaximumChallengeCharCount    19
#define PERF_FUNC__CalcFixedUnencryptedChallengeCharCount   20
#define PERF_FUNC__CalcFixedEncryptedChallengeCharCount     21
#define PERF_FUNC__CalcVariableChallengeCharCount   22
#define PERF_FUNC__ProcessAllKIDs                   23
#define PERF_FUNC__CalcKIDDataCharCount             24
#define PERF_FUNC__BuildKIDDataXML                  25
#define PERF_FUNC__BuildMeterDataChallengeXML       26
#define PERF_FUNC__BuildMeterDataChallengeDataXML   27
#define PERF_FUNC__PrepareMeterChallengeContext     28
#define PERF_FUNC__ParseMeterCert                   29


/* oem\ansi\oemfileio.c */
#define PERF_FUNC_Oem_File_SetFilePointer        1
#define PERF_FUNC_Oem_File_Lock                  2
#define PERF_FUNC_Oem_File_Unlock                3
#define PERF_FUNC_Oem_File_Open                  4
#define PERF_FUNC_Oem_File_Read                  5
#define PERF_FUNC_Oem_File_Write                 6
#define PERF_FUNC_Oem_File_GetSize               7
#define PERF_FUNC_Oem_File_FlushBuffers          8

/* secure_clock\secureclockrequest.c */
#define PERF_FUNC_DRM_CLK_CreateChallenge       1
#define PERF_FUNC_DRM_CLK_InitCheckSecureClock  2

/* secure_clock\secureclockresponse.c */
#define PERF_FUNC_DRM_CLK_ProcessResponse       1

/* synclist\drmgensyncchallenge.c */
#define PERF_FUNC_DRM_SNC_GenerateSyncChallenge 1

/* core\drmhdrparser.c */
#define PERF_FUNC_DRM_HDR_GetAttribute          1
#define PERF_FUNC_DRM_HDR_Verify                2
#define PERF_FUNC_DRM_ASD_GetLicenseAggregateData       1
#define PERF_FUNC_DRM_ASD_ParseV2License                2
#define PERF_FUNC__QueryAndAggregateLicStatesForKID     3
#define PERF_FUNC__LoadNextLicense                      4
#define PERF_FUNC__QueryAndAggregateLicStatesForKID 3
#define PERF_FUNC__QueryRightForAction                  6
#define PERF_FUNC__CollectLicStateforRequestedActions   5
#define PERF_FUNC__QueryRightForAction          6

/* core\drmlicparser.c */
#define PERF_FUNC_DRM_LIC_VerifySignature       1
#define PERF_FUNC_DRM_LIC_VerifyCertChain       2
#define PERF_FUNC_DRM_LIC_GetAttribute          3
#define PERF_FUNC_DRM_LIC_GetEnablingBits       4

/* crypto\pkcrypto\drmeccp160.c */
#define PERF_FUNC_DRM_ECC_Verify_P160           1
#define PERF_FUNC_DRM_ECC_GenKeyPair_P160       2
#define PERF_FUNC_DRM_ECC_Sign_P160             3
#define PERF_FUNC_DRM_ECC_Decrypt_P160          4

/* crypto\pkcrypto\drmeccp256.c */
#define PERF_FUNC_DRM_ECDSA_Verify_P256                             1
#define PERF_FUNC_DRM_ECDSA_Sign_P256                               2
#define PERF_FUNC_DRM_ECC_GenKeyPair_P256                           3
#define PERF_FUNC_DRM_ECC_Encrypt_P256                              4
#define PERF_FUNC_DRM_ECC_Decrypt_P256                              5
#define PERF_FUNC_DRM_ECC_CanMapToPoint_P256                        6
#define PERF_FUNC_DRM_AES_GenerateHMACKey                           7
#define PERF_FUNC_Convert_P256_PointToPlaintext                     8
#define PERF_FUNC_Convert_P256_PointToDigits                        9
#define PERF_FUNC_Convert_P256_PointToBigEndianBytes                10
#define PERF_FUNC_Convert_P256_PlaintextToPoint                     11
#define PERF_FUNC_Convert_P256_ModularIntToDigitsModOrder           12
#define PERF_FUNC_Convert_P256_ModularIntToBigEndianBytesModOrder   13
#define PERF_FUNC_Convert_P256_DigitsToBigEndianBytes               14
#define PERF_FUNC_Convert_P256_DigitsToPoint                        15
#define PERF_FUNC_Convert_P256_BigEndianBytesToPoint                16
#define PERF_FUNC_Convert_P256_BigEndianBytesToModular              17
#define PERF_FUNC_Convert_P256_BigEndianBytesToDigitsModOrder       18
#define PERF_FUNC_Convert_DigitsToBigEndianBytes                    19
#define PERF_FUNC_Convert_P256_BigEndianBytesToDigits               20
#define PERF_FUNC_Convert_BigEndianBytesToDigits                    21
#define PERF_FUNC_DRM_ECC_MapX2PointP256                            22

/* crypto\drmsha256\drmsha256.c */
#define PERF_FUNC_DRM_SHA256_Init               1
#define PERF_FUNC_DRM_SHA256_Update             2
#define PERF_FUNC_DRM_SHA256_Finalize           3
#define PERF_FUNC_SHA256_Transform              4

/* synclist\drmsyncstore.c */
#define PERF_FUNC_DRM_SNC_OpenStore             1
#define PERF_FUNC_DRM_SNC_GetSyncStoreEntry     2
#define PERF_FUNC_DRM_SNC_UpdateKID             3

/* core\drmutilities.c */
#define PERF_FUNC_DRM_UTL_DecodeKID             1
#define PERF_FUNC__AddCachedCertificate         2
#define PERF_FUNC__CheckCertificate             3
#define PERF_FUNC__VerifyCachedCertificate      4

/* core\drmxmlparser.c */
#define PERF_FUNC__GetXMLSubNodeW               1
#define PERF_FUNC_DRM_XML_GetSubNodeByPath      2
#define PERF_FUNC_DRM_XML_GetNodeAttribute      3
#define PERF_FUNC_DRM_XML_GetSubNode            4
#define PERF_FUNC__ScanTagW                     5
#define PERF_FUNC__CheckTagW                    6
#define PERF_FUNC_DRM_XML_GetSubNodeA           7

/* core\drmbase64.c */
#define PERF_FUNC_DRM_B64_DecodeW               1
#define PERF_FUNC_DRM_B64_DecodeA               2
#define PERF_FUNC_DRM_B64_EncodeW               3
#define PERF_FUNC_DRM_B64_EncodeA               4

/* oem\ansi\oeminfo.c */
#define PERF_FUNC_Oem_Device_GetCert            1
#define PERF_FUNC__GetPrivateKey                2
#define PERF_FUNC_Oem_Clock_GetResetState       3
#define PERF_FUNC_Oem_Clock_SetResetState       4

/* core\drmcipher.c */
#define PERF_FUNC_DRM_CPHR_InitDecrypt          1
#define PERF_FUNC_DRM_CPHR_Decrypt              2
#define PERF_FUNC_DRM_CPHR_Encrypt              3
#define PERF_FUNC_DRM_CPHR_Init                 4

/* crypto\drmcrypto\deskey.c */
#define PERF_FUNC_DRM_DES_Cipher                1

/* crypto\drmcrypto\rc4.c */
#define PERF_FUNC_DRM_RC4_KeySetup              1
#define PERF_FUNC_DRM_RC4_Cipher                2

/* core\drmcbc.c */
#define PERF_FUNC_DRM_CBC64Update               1

/* oem\ansi\oemaes.c */
#define PERF_FUNC_Oem_Aes_SetKey                1
#define PERF_FUNC_Oem_Aes_EncryptOne            2
#define PERF_FUNC_Oem_Aes_DecryptOne            3

/* core\drmaes.c */
#define PERF_FUNC_DRM_Aes_CtrProcessData        1
#define PERF_FUNC_DRM_Aes_EcbEncryptData        2
#define PERF_FUNC_DRM_Aes_EcbDecryptData        3
#define PERF_FUNC_Omac1_GenerateSignTag         4
#define PERF_FUNC_Omac1_GenerateSignInfo        5
#define PERF_FUNC_DRM_Omac1_Sign                6
#define PERF_FUNC_DRM_Omac1_Verify              7
#define PERF_FUNC_DRM_Aes_CbcEncryptData        8
#define PERF_FUNC_DRM_Aes_CbcDecryptData        9

/* core\drmrsa.c */
#define PERF_FUNC_DRM_RSA_OaepDecrypt           1
#define PERF_FUNC_DRM_RSA_OaepEncrypt           2
#define PERF_FUNC_DRM_RSA_PssSign               3
#define PERF_FUNC_DRM_RSA_PssVerify             4

/* certs\drmbcertbuilder.c */
/* certs\drmbcertparser.c */
#define PERF_FUNC_calcManufacturerInfoSize      1
#define PERF_FUNC_calcKeyInfoSize               2
#define PERF_FUNC_calcFeatureInfoSize           3
#define PERF_FUNC_calcSignatureInfoSize         4
#define PERF_FUNC_calcDomainInfoSize            5
#define PERF_FUNC_calcCertSize                  6
#define PERF_FUNC_checkBuffer                   7
#define PERF_FUNC_addAlignedData                8
#define PERF_FUNC_updateCertChainHeader         9
#define PERF_FUNC_addCertChainHeader           10
#define PERF_FUNC_addCertHeader                11
#define PERF_FUNC_addCertObjectHeader          12
#define PERF_FUNC_addCertBasicInfo             13
#define PERF_FUNC_addCertFeatureInfo           14
#define PERF_FUNC_addCertKeyInfo               15
#define PERF_FUNC_addCertManufacturerString    16
#define PERF_FUNC_addCertManufacturerInfo      17
#define PERF_FUNC_addCertSignatureInfo         18
#define PERF_FUNC_addCertDomainInfo            19
#define PERF_FUNC_addCertPCInfo                20
#define PERF_FUNC_addCertDeviceInfo            21
#define PERF_FUNC_DRM_BCert_Add_Cert           22
#define PERF_FUNC_verifyKeyUsage               23
#define PERF_FUNC_verifyFeature                24
#define PERF_FUNC_verifyAdjacentCerts          25
#define PERF_FUNC_getObjectHeader              26
#define PERF_FUNC_parseCertHeader              27
#define PERF_FUNC_parseCertBasicInfo           28
#define PERF_FUNC_parseDomainInfo              29
#define PERF_FUNC_parsePCInfo                  30
#define PERF_FUNC_parseDeviceInfo              31
#define PERF_FUNC_parseFeatureInfo             32
#define PERF_FUNC_parseManufacturerString      33
#define PERF_FUNC_parseSignatureInfo           34
#define PERF_FUNC_parseKeyInfo                 35
#define PERF_FUNC_parseCertificate             36
#define PERF_FUNC_FindObjectInCertByType       37
#define PERF_FUNC_GetChainHeader               38
#define PERF_FUNC_ParseCertificateChain        39
#define PERF_FUNC_GetCertificate               40
#define PERF_FUNC_GetPublicKey                 41
#define PERF_FUNC_addCertSilverLightInfo       42
#define PERF_FUNC_parseSilverLightInfo         43
#define PERF_FUNC_verifySignatureInfo          44
#define PERF_FUNC_calcExtDataSignKeyInfoSize   45
#define PERF_FUNC_calcExtDataContainerSize     46
#define PERF_FUNC_addExtDataSignKeyInfo        47
#define PERF_FUNC_addExtDataContainer          48
#define PERF_FUNC_DRM_BCert_AddExtDataToCert   49
#define PERF_FUNC_verifyExtDataSignature       50
#define PERF_FUNC_parseExtDataSignKeyInfo      51
#define PERF_FUNC_parseExtDataContainer        52
#define PERF_FUNC_addCertMeteringInfo          53
#define PERF_FUNC_calcMeteringInfoSize         54
#define PERF_FUNC_parseMeteringInfo            55
#define PERF_FUNC_GetPublicKeyByUsage          56
#define PERF_FUNC_parseServerInfo              57
#define PERF_FUNC_addCertServerInfo            58

/* domain\drmdomainstore.c */
#define PERF_FUNC__DomainStore_AddData          1
#define PERF_FUNC__DomainStore_GetData          2
#define PERF_FUNC__DomainStore_DeleteData       3
#define PERF_FUNC__DomainStore_InitEnumData     4
#define PERF_FUNC__DomainStore_EnumNextData     5
#define PERF_FUNC_DRM_DOMST_OpenStore           6
#define PERF_FUNC_DRM_DOMST_CloseStore          7
#define PERF_FUNC_DRM_DOMST_DeleteKeys          8

/* domain\drmdomainapi.c */
/* domain\drmdomainimp.c */
/* domain\drmdomainkeyxmrparser.c */
#define PERF_FUNC__BuildJoinChallengeDataXML    1
#define PERF_FUNC__BuildLeaveChallengeDataXML   2
#define PERF_FUNC__BuildJoinChallengeXML        3
#define PERF_FUNC__BuildLeaveChallengeXML       4
#define PERF_FUNC__VerifyJoinResponse           5
#define PERF_FUNC__VerifyLeaveResponse          6
#define PERF_FUNC__StoreDomainJoinData          7
#define PERF_FUNC__StoreDomainJoinPreviousKeys  8
#define PERF_FUNC__ProcessJoinDataFromResponse  9
#define PERF_FUNC__ExtractLeaveDataFromResponse 10
#define PERF_FUNC_DRM_DOM_GenerateJoinChallenge 11
#define PERF_FUNC_DRM_DOM_ProcessJoinResponse   12
#define PERF_FUNC_DRM_DOM_GenerateLeaveChallenge    13
#define PERF_FUNC_DRM_DOM_ProcessLeaveResponse  14
#define PERF_FUNC_DRM_DOM_FindCert              15
#define PERF_FUNC_DRM_DOM_InitCertEnum          16
#define PERF_FUNC_DRM_DOM_EnumNextCert          17
#define PERF_FUNC__ParseJoinDomainChallengeQueryData 18
#define PERF_FUNC__ParseLeaveDomainChallengeQueryData 19
#define PERF_FUNC_DRM_DOMKEYXMR_HEADER          20
#define PERF_FUNC_DRM_DOMKEYXMR_SESSIONKEY      21
#define PERF_FUNC_DRM_DOMKEYXMR_GetPrivKeyContainer 22
#define PERF_FUNC_DRM_DOMKEYXMR_GetPrivKey      23


#define PERF_FUNC__

/* core\drmxmlsig.c */
#define PERF_FUNC__CalcSHA256Hash               1
#define PERF_FUNC__VerifySHA256Hash             2
#define PERF_FUNC__BuildCipherDataNode          3
#define PERF_FUNC__ExtractCipherData            4
#define PERF_FUNC__BuildSignedInfoNode          5
#define PERF_FUNC__BuildSignatureValueNode      6
#define PERF_FUNC__BuildPublicKeyInfoNodeWithName   7
#define PERF_FUNC__ExtractPublicKeyByName       8
#define PERF_FUNC__BuildECC256PublicKeyInfoNode 9
#define PERF_FUNC__ExtractECC256PublicKey       10
#define PERF_FUNC_DRM_XMLSIG_BuildEncryptedKeyInfoNode  11
#define PERF_FUNC_DRM_XMLSIG_ExtractEncryptedKey   12
#define PERF_FUNC_DRM_XMLSIG_BuildSignatureNode     13
#define PERF_FUNC_DRM_XMLSIG_VerifySignature        14
#define PERF_FUNC_DRM_XMLSIG_BuildEncryptedDataNode 15
#define PERF_FUNC_DRM_XMLSIG_ExtractEncryptedData   16

/* core\drmsoapxmlutility.c */
#define PERF_FUNC_DRM_SOAPXML_EncodeData                 1
#define PERF_FUNC_DRM_SOAPXML_DecodeData                 2
#define PERF_FUNC_DRM_SOAPXML_GetDeviceCert              3
#define PERF_FUNC_DRM_SOAPXML_InitXMLKey                 4
#define PERF_FUNC_DRM_SOAPXML_EncryptDataWithXMLKey      5
#define PERF_FUNC_DRM_SOAPXML_BuildSOAPHeaderXML         6
#define PERF_FUNC__ParseCustomData                       7
#define PERF_FUNC__ParseCustomDataByPath                 8
#define PERF_FUNC_DRM_SOAPXML_ParseStatusCode            9
#define PERF_FUNC_Drm_GetAdditionalResponseData          10
#define PERF_FUNC_DRM_SOAPXML_GetAdditionalResponseData  11
#define PERF_FUNC_DRM_SOAPXML_ParseCustomDataForProtocol 12
#define PERF_FUNC_DRM_SOAPXML_ValidateProtocolSignature  13


/* core\drmlicacqv3.c */
#define PERF_FUNC__CalcDeviceCertCharCount      1
#define PERF_FUNC__CalcDomainCertsCharCount     2
#define PERF_FUNC__BuildDomainCertsXML          3
#define PERF_FUNC__BuildCertChainsXML           4
#define PERF_FUNC__BuildClientInfoXML           5
#define PERF_FUNC__BuildRevListInfoXML          6
#define PERF_FUNC__BuildLicenseChallengeDataXML 7
#define PERF_FUNC__BuildLicenseAcknowledgementDataXML   8
#define PERF_FUNC__BuildLicenseChallengeXML     9
#define PERF_FUNC__BuildLicenseAcknowledgementXML   10
#define PERF_FUNC__PrepareViewRights            11
#define PERF_FUNC__GetLicenseState              12
#define PERF_FUNC__PrepareUplinks               13
#define PERF_FUNC__PrepareLicenseChallenge      14
#define PERF_FUNC__ParseLicenseAcquisitionURL   15
#define PERF_FUNC__ProcessRevInfo               16
#define PERF_FUNC__ExtractLicensesFromLicenseResponse   17
#define PERF_FUNC__ExtractRevInfoFromLicenseResponse    18
#define PERF_FUNC__ExtractDataFromLicenseResponse   19
#define PERF_FUNC__GenerateLicenseChallengeV3   20
#define PERF_FUNC__ProcessLicenseResponseV3     21
#define PERF_FUNC_Drm_LicenseAcq_GenerateAck    22
#define PERF_FUNC_Drm_LicenseAcq_ProcessAckResponse 23
#define PERF_FUNC_DRM_LA_ProcessLicenseV3       24

/* core\drmutf.c */
#define PERF_FUNC_DRM_UTF8_VerifyBytes          1

/* core\drmhmac.c */
#define PERF_FUNC_DRM_HMAC_CreateMAC            1
#define PERF_FUNC_DRM_HMAC_VerifyMAC            2

/* ndr\drmndr.c */
#define PERF_FUNC_Drm_Ndr_Registration_GenerateChallenge   1
#define PERF_FUNC_Drm_Ndr_Registration_ProcessResponse     2
#define PERF_FUNC_Drm_Ndr_License_GenerateChallenge        3
#define PERF_FUNC_Drm_Ndr_License_ProcessResponse          4
#define PERF_FUNC_Drm_Ndr_Proximity_GenerateStart          5
#define PERF_FUNC_Drm_Ndr_Proximity_GenerateResponse       6
#define PERF_FUNC_Drm_Ndr_Proximity_ProcessChallenge       7
#define PERF_FUNC_Drm_Ndr_Proximity_ProcessResult          8


/* Device Store */
#define PERF_FUNC__SetDirtyFlag                                     1
#define PERF_FUNC__GetDirtyFlag                                     2
#define PERF_FUNC__InitDeviceHandle                                 3
#define PERF_FUNC_DRM_DVS_Initialize                                4
#define PERF_FUNC_DRM_DVS_RegisterDevice                            5
#define PERF_FUNC__CalculateStoreID                                 6
#define PERF_FUNC__WriteDeviceStoreEntryItem                        7
#define PERF_FUNC_DRM_DVS_UnRegisterDevice                          8
#define PERF_FUNC_DRM_DVS_GetFirstDevice                            9
#define PERF_FUNC_DRM_DVS_GetNextDevice                             10
#define PERF_FUNC_DRM_DVS_GetDeviceByID                             11
#define PERF_FUNC_DRM_DVS_GetDeviceID                               12
#define PERF_FUNC_DRM_DVS_GetDeviceAttr                             13
#define PERF_FUNC__ReadDeviceStoreEntryItem                         14
#define PERF_FUNC_DRM_DVS_GetDeviceAttrCount                        15
#define PERF_FUNC_DRM_DVS_GetDeviceAttrByIndex                      16
#define PERF_FUNC_DRM_DVS_SetDeviceAttr                             17
#define PERF_FUNC_DRM_DVS_CommitDevice                              18
#define PERF_FUNC_DRM_DeviceStore_MarkDeviceAsValid                 19
#define PERF_FUNC_DRM_DeviceStore_UnRegisterDevice                  20
#define PERF_FUNC__GenerateDeviceID                                 21
#define PERF_FUNC_DRM_DeviceStore_GetDeviceByID                     22
#define PERF_FUNC_DRM_DeviceStore_GetDeviceInfo                     23
#define PERF_FUNC__ExtractDeviceInfo                                24

/* Revocation */
#define PERF_FUNC_DRM_RVK_PerformAppRevocationCheck                 1
#define PERF_FUNC_DRM_RVK_GetCurrentAppRevocationList               2
#define PERF_FUNC__CheckCertInRevocationList                        3
#define PERF_FUNC_DRM_RVK_UpdateAppRevocationListA                  4
#define PERF_FUNC_DRM_RVK_UpdateAppRevocationListW                  5
#define PERF_FUNC_DRM_RVK_UpdateAppRevocationListDecoded            6
#define PERF_FUNC_DRM_RVK_UpdateRevocationVersionsCache             7
#define PERF_FUNC_DRM_RVK_VerifyRevocationList                      8
#define PERF_FUNC_DRM_RVK_UpdateRevocationList                      9
#define PERF_FUNC__UpdateRevocationList                             10
#define PERF_FUNC__GetSSTRevocationList                             11
#define PERF_FUNC__VerifyWMDRMNETRevocationList                     12
#define PERF_FUNC_DRM_RVK_UpdateWMDRMNETRevocationList              13
#define PERF_FUNC__UpdateWMDRMNETRevocationList                     14
#define PERF_FUNC__VerifyCRLSignature                               15
#define PERF_FUNC_DRM_RVK_GetWMDRMNETRevocationEntries              16
#define PERF_FUNC__VerifyBinaryWMDRMNETSignature                    17
#define PERF_FUNC_DRM_RVK_VerifyRevocationInfo                      18
#define PERF_FUNC_DRM_RVK_GetCurrentRevocationInfo                  19
#define PERF_FUNC_DRM_RVK_StoreRevocationLists                      20
#define PERF_FUNC_DRM_RVK_StoreRevInfo                              21
#define PERF_FUNC_DRM_RVK_ProcessRevocationInfo                     22
#define PERF_FUNC__ExtractRevocationList                            23
#define PERF_FUNC_DRM_RVK_GetCRL                                    24
#define PERF_FUNC_DRM_RVK_SetCRL                                    25
#define PERF_FUNC_DRM_RVS_InitRevocationStore                       26
#define PERF_FUNC_DRM_RVS_StoreRevocationData                       27
#define PERF_FUNC__CreateRevocationStorePassword                    28
#define PERF_FUNC__LoopkupRevocationLIDFromGUID                     29
#define PERF_FUNC_DRM_RVS_GetRevocationData                         30
#define PERF_FUNC_DRM_BCrl_VerifySignature                          31
#define PERF_FUNC_DRM_RVK_StoreMsdbCRLPackage                       32

/* RSA */
#define PERF_FUNC__OAEPDecode                                       1
#define PERF_FUNC__GenerateMGF1Mask                                 2
#define PERF_FUNC__OAEPEncode                                       3
#define PERF_FUNC__PSSEncode                                        4
#define PERF_FUNC__PSSVerify                                        5
#define PERF_FUNC__BigEndianBytesToDigits                           6
#define PERF_FUNC__DigitsToBigEndianBytes                           7
#define PERF_FUNC_OEM_RSA_SetPublicKey                              8
#define PERF_FUNC_OEM_RSA_SetPrivateKey                             9
#define PERF_FUNC_OEM_RSA_ParsePublicKey                            10
#define PERF_FUNC_OEM_RSA_ZeroPublicKey                             11
#define PERF_FUNC_OEM_RSA_ZeroPrivateKey                            12
#define PERF_FUNC__ModularExponentiate                              13
#define PERF_FUNC_OEM_RSA_Decrypt                                   14

/* ND Certificates */
#define PERF_FUNC__AddDSigPublicKeyNode                             1
#define PERF_FUNC__AddPublicKeyNode                                 2
#define PERF_FUNC_DRM_ND_CB_CreateDigitalSignature                  3
#define PERF_FUNC_DRM_ND_CB_CreateCertificateInit                   4
#define PERF_FUNC_DRM_ND_CB_CreateCertificateAddTemplateData        5
#define PERF_FUNC_DRM_ND_CB_CreateCertificateSignAndClose           6
#define PERF_FUNC_DRM_NDCert_CreateDeviceCertificate                7
#define PERF_FUNC_DRM_ND_CB_AddAttribute                            8
#define PERF_FUNC_DRM_ND_CB_AddManufacturerNodes                    9
#define PERF_FUNC_DRM_ND_CB_SignCertificate                        10
#define PERF_FUNC_DRM_ND_CB_CreateCertificateFile                  11
#define PERF_FUNC_DRM_XML_RSA_WritePublicKeyNodeA                  12
#define PERF_FUNC_DRM_XML_RSA_WritePublicKeyNode                   13
#define PERF_FUNC__ConvertB64DStrToASCII                           14
#define PERF_FUNC_DRM_XML_RSA_ParseBase64PublicKey                 15
#define PERF_FUNC_DRM_XML_RSA_ParseBase64PublicKeyA                16
#define PERF_FUNC_DRM_XML_RSA_WritePrivateKeyNode                  17
#define PERF_FUNC_DRM_XML_RSA_ParseBase64PrivateKey                18
#define PERF_FUNC_DRM_NDCert_Certificate_Initialize                19
#define PERF_FUNC_DRM_NDCert_GetDeviceCertificate                  20
#define PERF_FUNC__VerifyRSACertCollectionOnDevice                 21
#define PERF_FUNC__GetModelRSAPrivKeyOnDevice                      22
#define PERF_FUNC__UpdateDeviceCertificateProperties               23
#define PERF_FUNC_DRM_ND_CB_CreateCertificate                      24


/* NDT */
#define PERF_FUNC_DRM_WCP_GetCertificateType                        1
#define PERF_FUNC_DRM_WCP_GetAttribute                              2
#define PERF_FUNC__ExtractValueFromAttribute                        3
#define PERF_FUNC_DRM_WCP_GetKeyUsage                               4
#define PERF_FUNC_DRM_WCP_GetFeatures                               5
#define PERF_FUNC_DRM_WCP_GetSecurityLevel                          6
#define PERF_FUNC_DRM_WCP_GetPublicKey                              7
#define PERF_FUNC_DRM_WCP_GetHardwareID                             8
#define PERF_FUNC_DRM_WCP_GetSignatureDigest                        9
#define PERF_FUNC_DRM_WCP_GetManufacturerNodes                      10
#define PERF_FUNC_DRM_WCP_VerifyCertificate                         11
#define PERF_FUNC__VerifyCertificateMethods                         12
#define PERF_FUNC__VerifyCertificateSignature                       13
#define PERF_FUNC__VerifyCertificateRequiredTags                    14
#define PERF_FUNC_DRM_WCP_VerifyCertificateCollection               15
#define PERF_FUNC__GetPublicKey                                     16
#define PERF_FUNC_DRM_WCP_VerifyDigitalSignature                    17
#define PERF_FUNC__ExtractPublicKey                                 18
#define PERF_FUNC_Drm_Pfd_Initialize                                19
#define PERF_FUNC_Drm_Pfd_Registration_ProcessRequest               20
#define PERF_FUNC_Drm_Pfd_Registration_GenerateResponse             21
#define PERF_FUNC_Drm_Pfd_Proximity_GenerateChallenge               22
#define PERF_FUNC_Drm_Pfd_Proximity_ProcessResponse                 23
#define PERF_FUNC_Drm_Pfd_License_ProcessRequest                    24
#define PERF_FUNC_Drm_Pfd_License_GenerateResponse                  25
#define PERF_FUNC__OutputLevelsCallback                             26
#define PERF_FUNC_NDT_RetrieveLicenseDataV1                         27
#define PERF_FUNC__RetrieveLicense                                  28
#define PERF_FUNC_NDT_RetrieveLicenseDataV2                         29
#define PERF_FUNC__DRM_XMR_RootSignatureCallback                    30
#define PERF_FUNC__DRM_XMR_LeafSignatureCallback                    31
#define PERF_FUNC_NDT_License_BuildSimpleXMR                        32
#define PERF_FUNC_NDT_License_BuildRootXMR                          33
#define PERF_FUNC_NDT_License_BuildLeafXMR                          34
#define PERF_FUNC_Drm_Ndt_Initialize                                35
#define PERF_FUNC_Drm_Ndt_Session_Create                            36
#define PERF_FUNC_Drm_Ndt_Session_Close                             37
#define PERF_FUNC_Drm_Ndt_Registration_ProcessRequest               38
#define PERF_FUNC_DRM_NDT_Proximity_GetChallenge                    39
#define PERF_FUNC_Drm_Ndt_Proximity_ProcessStartMsg                 40
#define PERF_FUNC_DRM_NDT_Proximity_VerifyEncryptedChallenge        41
#define PERF_FUNC__DecryptNonce                                     42
#define PERF_FUNC_Drm_Ndt_Proximity_ProcessResponseMsg              43
#define PERF_FUNC_Drm_Ndt_License_ProcessChallenge                  44
#define PERF_FUNC_DRM_NDT_License_GenerateKeys                      45
#define PERF_FUNC__GetDeviceHandle                                  46
#define PERF_FUNC_DRM_NDT_License_SetRootPolicy                     47
#define PERF_FUNC_Drm_Ndt_License_GenerateLeafResponse              48
#define PERF_FUNC_Drm_Ndt_RevocationList_GenerateChallenge          49
#define PERF_FUNC_Drm_Ndt_RevocationList_ProcessRequest             50
#define PERF_FUNC__GUIDFromDrmRevocationTypeEnum                    51
#define PERF_FUNC_Drm_Ndt_RevocationList_ProcessResponse            52
#define PERF_FUNC_GetWMDRMNETRevocationEntries                      53
#define PERF_FUNC_GetWMDRMNDRevocationList                          54
#define PERF_FUNC_NDTMGR_Internal_FindSession                       55
#define PERF_FUNC_NDTMGR_Internal_CreateSession                     56
#define PERF_FUNC_NDTMGR_Internal_RemoveSession                     57
#define PERF_FUNC__NdtManagerFreeContentSession                     58
#define PERF_FUNC_NDT_ValidateCertificate                           59
#define PERF_FUNC_NDT_GetCertificateAttributes                      60
#define PERF_FUNC_NDT_EncryptSeed                                   61
#define PERF_FUNC_NDT_SignRegistrationMessage                       62
#define PERF_FUNC_NDTMGR_Encrypt                                    63
#define PERF_FUNC__PackDataSegmentDescriptor                        64
#define PERF_FUNC_Drm_Pfd_Aavt_OpenMediaSession                     65
#define PERF_FUNC_Drm_Pfd_Aavt_CloseMediaSession                    66
#define PERF_FUNC_Drm_Pfd_Aavt_GetNextDataBlock                     67
#define PERF_FUNC_Drm_Pfd_Aavt_SetCurrentTimePosition               68
#define PERF_FUNC__PfdDrmManagerFreeContentSession                  69
#define PERF_FUNC__PfdDrmManagerFreeAllContentSessions              70
#define PERF_FUNC__PfdDrmManagerGetSession                          71
#define PERF_FUNC_OEM_NDT_AllowNewDeviceRegistration                72
#define PERF_FUNC_OEM_NDT_GetProximityDetectionAddress              73
#define PERF_FUNC_OEM_NDT_GetLicenseOPLs                            74
#define PERF_FUNC_OEM_NDT_GetLicenseInclusionList                   75
#define PERF_FUNC_OEM_NDT_GetSourceID                               76
#define PERF_FUNC_OEM_NDT_GetLicenseRevInfoVersion                  77
#define PERF_FUNC_OEM_NDT_GetWMDRMNETMinAppSec                      78

/* NDT NetMsg */
#define PERF_FUNC_WmdrmNetAllocateMessageDescriptor                 1
#define PERF_FUNC_WmdrmNetValidateMessage                           2
#define PERF_FUNC_WmdrmNetUnpackRegistrationRequestMessage          3
#define PERF_FUNC_WmdrmNetPackRegistrationResponseMessage           4
#define PERF_FUNC_WmdrmNetPackRegistrationMessage                   5
#define PERF_FUNC_WmdrmNetUnpackRegistrationResponseMessage         6
#define PERF_FUNC_WmdrmNetUnpackProximityStartMessage               7
#define PERF_FUNC_WmdrmNetPackProximityChallengeMessage             8
#define PERF_FUNC_WmdrmNetUnpackProximityResponseMessage            9
#define PERF_FUNC_WmdrmNetPackProximityResultMessage                10
#define PERF_FUNC_WmdrmNetPackProximityResponseMessage              11
#define PERF_FUNC_WmdrmNetUnpackProximityChallengeMessage           12
#define PERF_FUNC_WmdrmNetUnpackProximityResultMessage              13
#define PERF_FUNC_WmdrmNetPackProximityStartMessage                 14
#define PERF_FUNC_WmdrmNetUnpackLicenseRequestMessage               15
#define PERF_FUNC_WmdrmNetPackLicenseResponseMessage                16
#define PERF_FUNC_WmdrmNetPackLicenseRequestMessage                 17
#define PERF_FUNC_WmdrmNetUnpackLicenseResponseMessage              18
#define PERF_FUNC_WmdrmNetUnpackRevocationListRequestMessage        19
#define PERF_FUNC_WmdrmNetPackRevocationListResponseMessage         20
#define PERF_FUNC_WmdrmNetPackRevocationListRequestMessage          21
#define PERF_FUNC_WmdrmNetUnpackRevocationListResponseMessage       22

/* NDT ASF */
#define PERF_FUNC__CreateDefaultPolicy                              1
#define PERF_FUNC_Drm_Ndt_Asf_Init                                  2
#define PERF_FUNC_Drm_Ndt_Asf_InitTranscryption                     3
#define PERF_FUNC_Drm_Ndt_Asf_GetHeader                             4
#define PERF_FUNC_Drm_Ndt_Asf_GenerateLeafLicenseResponse           5
#define PERF_FUNC_Drm_Ndt_Asf_Seek                                  6
#define PERF_FUNC_Drm_Ndt_Asf_ReadData                              7
#define PERF_FUNC_Drm_Ndt_Asf_ReadSample                            8
#define PERF_FUNC_Drm_Ndt_Asf_Close                                 9
#define PERF_FUNC_NDTMGR_ASF_Internal_CheckFileDRM                  10
#define PERF_FUNC__ASFParsePacketHeader                             11
#define PERF_FUNC__ASFReadData                                      12
#define PERF_FUNC__ASFParseLengthType                               13
#define PERF_FUNC__ASFParsePayloadHeader                            14
#define PERF_FUNC_NDTMGR_ASF_Internal_InitializeTranscryption       15
#define PERF_FUNC_NDTMGR_ASF_Internal_Initialize                    16
#define PERF_FUNC_NDTMGR_ASF_Internal_GetFileInfo                   17
#define PERF_FUNC__ASFParseHeaders                                  18
#define PERF_FUNC__ASFLoadHeaderObject                              19
#define PERF_FUNC__ASFLoadObjectHeader                              20
#define PERF_FUNC__ASFParseFilePropertiesObject                     21
#define PERF_FUNC__ASFParseStreamPropertiesObject                   22
#define PERF_FUNC__AddToStreamInfoList                              23
#define PERF_FUNC__FindStreamInStreamInfoList                       24
#define PERF_FUNC__ASFParseHeaderExtensionObject                    25
#define PERF_FUNC__ASFParseStreamPropertiesObjectEx                 26
#define PERF_FUNC__ASFParseStreamBitratePropertiesObject            27
#define PERF_FUNC_NDTMGR_ASF_Internal_TranscryptNextBlock           28
#define PERF_FUNC__ASFSetHeaderDone                                 29
#define PERF_FUNC__ASFTranscryptHeader                              30
#define PERF_FUNC__ASFProcessHeaders                                31
#define PERF_FUNC__CopyObjectToHeaderBuffer                         32
#define PERF_FUNC__AppendToHeaderBuffer                             33
#define PERF_FUNC__SaveHeaderObjectToNewHeader                      34
#define PERF_FUNC__ASFProcessContentEncryptionObject                35
#define PERF_FUNC__ASFProcessFilePropertiesObject                   36
#define PERF_FUNC__ASFProcessStreamPropertiesObject                 37
#define PERF_FUNC__ASFProcessHeaderExtensionObject                  38
#define PERF_FUNC__ASFProcessStreamPropertiesObjectEx               39
#define PERF_FUNC__ASFAppendStreamPropertiesObjectEx                40
#define PERF_FUNC__ASFAppendAdvContentEncryptionObject              41
#define PERF_FUNC__ASFTranscryptNextPackets                         42
#define PERF_FUNC__ASFTranscryptData                                43
#define PERF_FUNC__ASFTranscryptPacket                              44
#define PERF_FUNC__AppendToDataBuffer                               45
#define PERF_FUNC__ASFProcessPacketHeader                           46
#define PERF_FUNC__ParseLengthType                                  47
#define PERF_FUNC__ASFProcessPayloadHeader                          48
#define PERF_FUNC__DRMDecrypt                                       49
#define PERF_FUNC__ASFTranscryptDataObjectHeader                    50
#define PERF_FUNC__FillOutputBufferWithMuxPackets                   51
#define PERF_FUNC__ASFSeekToTimePosition                            52
#define PERF_FUNC_NDTMGR_ASF_Internal_SetTimePosition               53
#define PERF_FUNC_NDTMGR_ASF_Internal_Uninitialize                  54
#define PERF_FUNC_NDTMGR_ASF_Internal_GetHeader                     55
#define PERF_FUNC_NDTMGR_ASF_Internal_ReadSample                    56
#define PERF_FUNC__GetNextReadySample                               57
#define PERF_FUNC__GetSampleInProgress                              58
#define PERF_FUNC_NDTMGR_ASF_Internal_ReadData                      59
#define PERF_FUNC__ASFSetupTranscryption                            60

/* NDT ASF Sample */
#define PERF_FUNC_ASFSample_Initialize                              1
#define PERF_FUNC_ASFSample_GetBufferByIndex                        2
#define PERF_FUNC_ASFSample_AddBuffer                               3
#define PERF_FUNC_ASFSample_CopyToBuffer                            4

/* NDT ASF Mux */
#define PERF_FUNC_ASFMux_Initialize                                 1
#define PERF_FUNC_ASFMux_ProcessSample                              2
#define PERF_FUNC_ASFMux_GetNextPacket                              3
#define PERF_FUNC_ASFMux_Flush                                      4
#define PERF_FUNC_ASFMux_OnCompletedPacket                          5
#define PERF_FUNC_ASFMux_GetMinStreamSendtimeCutoff                 6
#define PERF_FUNC_ASFMux_AdjustSendTimeForOffset                    7
#define PERF_FUNC_CreateMuxStream                                   8
#define PERF_FUNC_SizeQueueObjectsArray                             9
#define PERF_FUNC_ASFMuxStream_Initialize                           10
#define PERF_FUNC_ASFMuxStream_HowManyObjectsWillBeReturned         11
#define PERF_FUNC_ASFMuxStream_OnSample                             12
#define PERF_FUNC_OnSample                                          13
#define PERF_FUNC_ASFMuxStream_GetObjectSizeForBandwidthPolicing    14
#define PERF_FUNC_ASFMuxStream_ApproxSampleDuration                 15
#define PERF_FUNC_ApproxSampleDuration                              16
#define PERF_FUNC_ASFMuxStream_GetEndTime                           17
#define PERF_FUNC_GetEndTime                                        18
#define PERF_FUNC_ASFMuxStream_GetHappyCutoffSendtime               19
#define PERF_FUNC_GetHappyCutoffSendtime                            20
#define PERF_FUNC_ASFMuxStream_AdjustSendTimeForOffset              21
#define PERF_FUNC_AdjustSendTimeForOffset                           22
#define PERF_FUNC_ASFMuxStream_UpdateStreamPropertiesEx             23
#define PERF_FUNC_ASFMuxStream_IsAvgTimePerFrameKnown               24
#define PERF_FUNC_ASFMuxStream_ReadMediaType                        25
#define PERF_FUNC_InternalInit                                      26
#define PERF_FUNC_SetupLeakyBucket                                  27
#define PERF_FUNC_ProcessNewWriterSample                            28
#define PERF_FUNC_SendTimeFromPresTime                              29
#define PERF_FUNC_GetAdjustedSampleTime                             30
#define PERF_FUNC_ASFAudioMuxStream_HowManyObjectsWillBeReturned    31
#define PERF_FUNC_ASFAudioMuxStream_OnSample                        32
#define PERF_FUNC_ASFAudioMuxStream_ApproxSampleDuration            33
#define PERF_FUNC_ASFAudioMuxStream_GetHappyCutoffSendtime          34
#define PERF_FUNC_ASFVideoMuxStream_OnSample                        35
#define PERF_FUNC_ASFVideoMuxStream_ApproxSampleDuration            36
#define PERF_FUNC_ASFVideoMuxStream_GetHappyCutoffSendtime          37
#define PERF_FUNC_ASFVideoMuxStream_ReadMediaType                   38

/* NDT ASF Streaming */
#define PERF_FUNC_ASFMuxSendWindow_Initialize                       1
#define PERF_FUNC_ASFMuxSendWindow_AddObjectsAndSendPackets         2
#define PERF_FUNC_ASFMuxSendWindow_Flush                            3
#define PERF_FUNC_InitializeWritePacket                             4
#define PERF_FUNC_PacketizeAndSend                                  5
#define PERF_FUNC_PacketizeSample                                   6
#define PERF_FUNC_AddPayload                                        7
#define PERF_FUNC_FindFirstSampleThatFits                           8
#define PERF_FUNC_SendOffWritePacket                                9
#define PERF_FUNC_PackageAndSend                                    10
#define PERF_FUNC_HandleFinishedQueueObject                         11
#define PERF_FUNC_ASFMuxQueueObject_Initialize                      12
#define PERF_FUNC_ASFMuxQueueObject_GeneratePayload                 13
#define PERF_FUNC_ASFMuxQueueObject_FillInASFPayloadInfo            14
#define PERF_FUNC_ASFMuxQueueObject_PopUsedSample                   15
#define PERF_FUNC_ASFMuxQueueObject_AddSegment                      16
#define PERF_FUNC_FragmentableObject_GeneratePayload                17
#define PERF_FUNC_FragmentableObject_PopUsedSample                  18
#define PERF_FUNC_UnfragmentableObject_Initialize                   19
#define PERF_FUNC_UnfragmentableObject_GeneratePayload              20
#define PERF_FUNC_UnfragmentableObject_PopUsedSample                21
#define PERF_FUNC_UnfragmentableObject_AddSegment                   22
#define PERF_FUNC_UnfragmentableObject_StartMFSample                23
#define PERF_FUNC_ASFLeakyBucket_AddToBucket                        24
#define PERF_FUNC_ASFPacketWriter_Initialize                        25
#define PERF_FUNC_ASFPacketWriter_SetPacketInfo                     26
#define PERF_FUNC_ASFPacketWriter_GetPacketInfo                     27
#define PERF_FUNC_ASFPacketWriter_GetDataSpaceAvailable             28
#define PERF_FUNC_ASFPacketWriter_AddPayload                        29
#define PERF_FUNC_ASFPacketWriter_WritePacket                       30
#define PERF_FUNC_ASFPacketWriter_Clear                             31
#define PERF_FUNC_InitializePacketInfoForWrite                      32
#define PERF_FUNC_GetCurrentPacketSnapshot                          33
#define PERF_FUNC_RestorePacket                                     34
#define PERF_FUNC_InternalAddPayloadInfo                            35
#define PERF_FUNC_CalcPayloadSize                                   36
#define PERF_FUNC_GetReplicatedData                                 37
#define PERF_FUNC_WritePacketHeader                                 38
#define PERF_FUNC_WritePayloadHeader                                39
#define PERF_FUNC_WritePayloadData                                  40
#define PERF_FUNC_WritePadding                                      41
#define PERF_FUNC_WritePayloadDataWithoutEncrypt                    42
#define PERF_FUNC_SaveVarField                                      43
#define PERF_FUNC_ASFMediaBuffer_Initialize                         44
#define PERF_FUNC_ASFMediaBuffer_InitializeWrapper                  45


/* core\drmembedding.c */
#define PERF_FUNC_DRM_EMB_UpdateEmbeddedStore                       1

/* core\drmxmlbuilder.c & core\drmxmlbuildera.c */
#define PERF_FUNC_DRM_XMB_CreateDocumentA                  1
#define PERF_FUNC_DRM_XMB_CloseDocumentA                   2
#define PERF_FUNC_DRM_XMB_OpenNodeA                        3
#define PERF_FUNC_DRM_XMB_CloseCurrNodeA                   4
#define PERF_FUNC_DRM_XMB_AddAttributeA                    5
#define PERF_FUNC_DRM_XMB_AddDataA                         6
#define PERF_FUNC_DRM_XMB_WriteTagA                        7
#define PERF_FUNC_DRM_XMB_AddCDataA                        8
#define PERF_FUNC_DRM_XMB_WriteCDATATagA                   9
#define PERF_FUNC_DRM_XMB_ReserveSpaceA                   10
#define PERF_FUNC_DRM_XMB_ShiftDataFromCurrentPositionA   11
#define PERF_FUNC_DRM_XMB_ShiftCurrentPointerA            12
#define PERF_FUNC_DRM_XMB_GetCurrentBufferPointerA        13
#define PERF_FUNC_DRM_XMB_AppendNodeA                     14

#define PERF_FUNC_DRM_XMB_AESEncryptAndCloseCurrNodeA     15
#define PERF_FUNC_DRM_XMB_RSASignAndCloseCurrNodeA        16
#define PERF_FUNC_DRM_XMB_HashAndRSASignAndCloseCurrNodeA 17
#define PERF_FUNC_DRM_XMB_HashAndCloseCurrNodeA           18

/* Start wide-char function with some gap in values */
#define PERF_FUNC_DRM_XMB_SimulateCreateDocument          21
#define PERF_FUNC_DRM_XMB_CreateDocument                  22
#define PERF_FUNC_DRM_XMB_ReallocDocument                 23
#define PERF_FUNC_DRM_XMB_CloseDocument                   24
#define PERF_FUNC_DRM_XMB_OpenNode                        25
#define PERF_FUNC_DRM_XMB_CloseCurrNode                   26
#define PERF_FUNC_DRM_XMB_GetCurrNodeName                 27
#define PERF_FUNC_DRM_XMB_AddAttribute                    28
#define PERF_FUNC_DRM_XMB_AddData                         29
#define PERF_FUNC_DRM_XMB_ReserveSpace                    30
#define PERF_FUNC_DRM_XMB_AddCData                        31
#define PERF_FUNC_DRM_XMB_AppendNode                      32
#define PERF_FUNC_DRM_XMB_AddXMLNode                      33
#define PERF_FUNC_DRM_XMB_WriteTag                        34
#define PERF_FUNC_DRM_XMB_WriteCDATATag                   35

#define PERF_FUNC_DRM_XMB_EncryptAndCloseCurrNode         36
#define PERF_FUNC_DRM_XMB_SignAndCloseCurrNode            37
#define PERF_FUNC_DRM_XMB_KeyedHashAndCloseCurrNode       38

#endif   /* #ifndef __DRMPROFILECONSTANTS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmptrlist.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef DRMPTRLIST_H
#define DRMPTRLIST_H

ENTER_PK_NAMESPACE;

typedef struct tagPTR_LIST_ENTRY
{
    DRM_VOID                 *pbData;
    struct tagPTR_LIST_ENTRY *pNext;
} PTR_LIST_ENTRY;

typedef struct tagPTR_LIST
{
    DRM_DWORD       dwMaxSize;
    DRM_DWORD       dwCurrentSize;
    PTR_LIST_ENTRY *pHead;
} PTR_LIST;


DRM_API DRM_RESULT DRM_CALL DRM_PtrList_Initialize(
    __out       PTR_LIST  * const f_pPtrList,
    __in const  DRM_DWORD         f_dwSize
);

DRM_API DRM_VOID DRM_CALL DRM_PtrList_Uninitialize(
    __out PTR_LIST * const pPtrList
);

DRM_API DRM_RESULT DRM_CALL DRM_PtrList_GetFront(
    __in const PTR_LIST  * const f_pPtrList,
    __out      DRM_VOID        **f_ppbData
);

DRM_API DRM_RESULT DRM_CALL DRM_PtrList_RemoveHead(
    __in    PTR_LIST  * const f_pPtrList,
    __out   DRM_VOID        **f_ppbData
);

DRM_API DRM_RESULT DRM_CALL DRM_PtrList_AddTail(
    __in  PTR_LIST * const f_pPtrList,
    __in  DRM_VOID * const f_pbData
);

DRM_API DRM_RESULT DRM_CALL DRM_PtrList_GetTail(
    __in const   PTR_LIST * const f_pPtrList,
    __out        DRM_VOID       **f_ppbData
);

DRM_API DRM_RESULT DRM_CALL DRM_PtrList_GetByIndex(
    __in const PTR_LIST * const   f_pPtrList,
    __in const DRM_DWORD          f_dwIndex,
    __out      DRM_VOID         **f_ppbData
);

DRM_API DRM_RESULT DRM_CALL DRM_PtrList_RemoveByIndex(
    __in       PTR_LIST * const   f_pPtrList,
    __in const DRM_DWORD          f_dwIndex,
    __out      DRM_VOID         **f_ppbData
);

EXIT_PK_NAMESPACE;

#endif /* DRMPTRLIST_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmrc4.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_RC4_H__
#define __DRM_RC4_H__

#include <drmcommon.h>

#if DRM_USE_RSA_IMPL
#include <rc4.h>

#define DRM_RC4_KeySetup(ks,cb,pb) rc4_key((ks),(cb),(pb))
#define DRM_RC4_Cipher(ks,cb,pb) rc4((ks),(cb),(pb))


#else /* DRM_USE_RSA_IMPL */

ENTER_PK_NAMESPACE;

#define RC4_TABLESIZE 256

/* Key structure */
typedef struct __tagRC4_KEYSTRUCT
{
    DRM_BYTE S[__CB_DECL(RC4_TABLESIZE)];     /* State table */
    DRM_BYTE i, j;        /* Indices */
} RC4_KEYSTRUCT;

/*********************************************************************
**
**  Function:  DRM_RC4_KeySetup
**
**  Synopsis:  Generate the key control structure.  Key can be any size.
**
**  Arguments:  
**     [pKS] -- A KEYSTRUCT structure that will be initialized.
**     [cbKey] -- Size of the key, in bytes.
**     [pbKey] -- Pointer to the key.
**
**  Returns:  None
**
*********************************************************************/

DRM_API DRM_VOID DRM_CALL DRM_RC4_KeySetup(
    OUT       RC4_KEYSTRUCT  *pKS,
    IN        DRM_DWORD       cbKey,
    IN  const DRM_BYTE       *pbKey );

/*********************************************************************
**
**  Function:  DRM_RC4_Cipher
**
**  Synopsis:  
**
**  Arguments:  
**     [pKS] -- Pointer to the KEYSTRUCT created using DRM_RC4_KeySetup.
**     [cbBuffer] -- Size of buffer, in bytes.
**     [pbBuffer] -- Buffer to be encrypted in place.
**
**  Returns:  None
*********************************************************************/

DRM_API DRM_VOID DRM_CALL DRM_RC4_Cipher(
    IN OUT                   RC4_KEYSTRUCT *pKS,
    IN                       DRM_UINT       cbBuffer,
    __inout_bcount(cbBuffer) DRM_BYTE      *pbBuffer );

EXIT_PK_NAMESPACE;

#endif /* DRM_USE_RSA_IMPL */

#endif /* __DRM_RC4_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmresults.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMRESULTS_H__
#define __DRMRESULTS_H__

/*
** This file contains all the DRM_RESULTS required for building Porting Kit
** applications.
**
** NOTE: PC error codes should ****NOT**** be added here, but rather to the
**       files discussed in the comment further down regarding them.
**
** NOTE: DRM_RESULTS can be converted into Windows HRESULTS without any
**       changes. The FACILITY values below are carefully selected to allow
**       for this.
**
*/

#if SIXTEEN_BIT_ADDRESSING
#define DRM_FAILED(Status) (((DRM_RESULT)(Status)&0x80000000)!=0)
#define DRM_SUCCEEDED(Status) (((DRM_RESULT)(Status)&0x80000000)==0)
#else
#define DRM_FAILED(Status) ((DRM_RESULT)(Status)<0)
#define DRM_SUCCEEDED(Status) ((DRM_RESULT)(Status) >= 0)
#endif

#define DRM_S_BASECODE                          0xC000
#define DRM_E_BASECODE                          0xC000
#define DRM_E_PK_BASECODE                       0xA000


/*
*  !!!!!!  VERY IMPORTANT, PLEASE READ !!!!!
*
*   There's a range of error codes that is only applicable to the PC and should
*   not be included here. These errors are in common\include, files:
*   msprerr.h
*   drmndbridgeerr.h
*   To prevent overlaps of PK and PC error codes, please assume that:
*   The range from 0x8004B000 to 0x8004BFFF is reserved for the PC (error codes).
*   The range from 0x0004B000 to 0x0004BFFF is reserved for the PC (success codes).
*   The following two defines represent the basecodes for the PC.
*/
#define DRM_E_NDBRIDGEONLY_BASECODE     0xB000
#define DRM_E_MSPRSDK_BASECODE          0xB800

#define DRM_FACILITY_ITF DRM_FACILITY_CORE

#define MAKE_DRM_RESULT(sev,fac,code) \
    ((DRM_RESULT) (((unsigned long)(sev)<<30) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

/* ============================================================
**
** Standard Success values
**
** ============================================================
*/

#define DRM_SUCCESS                             ((DRM_RESULT)0x00000000L)
#define DRM_S_FALSE                             ((DRM_RESULT)0x00000001L)
#define DRM_S_MORE_DATA                         ((DRM_RESULT)0x00000002L)


/* ============================================================
**
** Standard error messages (0x8000xxxx)
**
** ============================================================
*/

/*
 *  Values are 32 bit values laid out as follows:
 *
 *   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+-+-+-+-+---------------------+-------------------------------+
 *  |S|R|C|N|r|    Facility         |               Code            |
 *  +-+-+-+-+-+---------------------+-------------------------------+
 *
 *  where
 *
 *      S - Severity - indicates success/fail
 *
 *          0 - Success
 *          1 - Fail (COERROR)
 *
 *      R - reserved portion of the facility code, corresponds to NT's
 *              second severity bit.
 *
 *      C - reserved portion of the facility code, corresponds to NT's
 *              C field.
 *
 *      N - reserved portion of the facility code. Used to indicate a
 *              mapped NT status value.
 *
 *      r - reserved portion of the facility code. Reserved for internal
 *              use. Used to indicate HRESULT values that are not status
 *              values, but are instead message ids for display strings.
 *
 *      Facility - is the facility code
 *
 *      Code - is the facility's status code
 *
 *
 * Define the facility codes
 *
 */
#define DRM_FACILITY_WIN32               0x7
#define DRM_FACILITY_STANDARD            0x0
#define DRM_FACILITY_NETSHOW             0xD
#define DRM_FACILITY_CORE                0x4
#define DRM_FACILITY_COM_STORAGE         0x3


/*
 * Define the severity codes
 *
 */
#define DRM_SEVERITY_SUCCESS             0x0
#define DRM_SEVERITY_NETSHOW_ERROR       0x3
#define DRM_SEVERITY_ERROR               0x2


/*
 * MessageId: DRM_E_OUTOFMEMORY
 *
 * MessageText:
 *
 * Insufficient resources exist to complete the request.
 *
 */
#define DRM_E_OUTOFMEMORY                ((DRM_RESULT)0x80000002L)

/*
 * MessageId: DRM_E_NOTIMPL
 *
 * MessageText:
 *
 * The requested operation is not implemented.
 *
 */
#define DRM_E_NOTIMPL                    ((DRM_RESULT)0x80004001L)

/*
 * MessageId: DRM_E_FAIL
 *
 * MessageText:
 *
 * The requested operation failed.
 *
 */
#define DRM_E_FAIL                       ((DRM_RESULT)0x80004005L)


/* ============================================================
**
** Error messages shared with Win32 (0x8007xxxx)
**
** ============================================================
*/

/*
 * MessageId: DRM_E_WIN32_FILE_NOT_FOUND
 *
 * MessageText:
 *
 * The system cannot find the file specified.
 *
 */
#define DRM_E_WIN32_FILE_NOT_FOUND       ((DRM_RESULT)0x80070002L)

/*
 * MessageId: DRM_E_WIN32_NO_MORE_FILES
 *
 * MessageText:
 *
 * There are no more files.
 *
 */
#define DRM_E_WIN32_NO_MORE_FILES        ((DRM_RESULT)0x80070012L)

/*
 * MessageId: DRM_E_INVALIDARG
 *
 * MessageText:
 *
 * The parameter is incorrect.
 *
 */
#define DRM_E_INVALIDARG                 ((DRM_RESULT)0x80070057L)

/*
 * MessageId: DRM_E_BUFFERTOOSMALL
 *
 * MessageText:
 *
 * The data area passed to a function is too small.
 *
 */
#define DRM_E_BUFFERTOOSMALL             ((DRM_RESULT)0x8007007AL)

/*
 * MessageId: DRM_E_NOMORE
 *
 * MessageText:
 *
 * No more data is available.
 *
 */
#define DRM_E_NOMORE                     ((DRM_RESULT)0x80070103L)

/*
 * MessageId: DRM_E_ARITHMETIC_OVERFLOW
 *
 * MessageText:
 *
 * Arithmetic result exceeded maximum value.
 *
 */
#define DRM_E_ARITHMETIC_OVERFLOW        ((DRM_RESULT)0x80070216L)

/*
 * MessageId: DRM_E_INVALID_COMMAND_LINE
 *
 * MessageText:
 *
 * Invalid command line argument.
 *
 */
#define DRM_E_INVALID_COMMAND_LINE       ((DRM_RESULT)0x80070667L)


/* ============================================================
**
** Error messages shared with COM Storage (mostly file errors)
** (0x8003xxxx)
**
** ============================================================
*/

/*
 * MessageId: DRM_E_FILENOTFOUND
 *
 * MessageText:
 *
 * A requested file could not be found.
 *
 */
#define DRM_E_FILENOTFOUND               ((DRM_RESULT)0x80030002L)

/*
 * MessageId: DRM_E_FILEOPEN
 *
 * MessageText:
 *
 * A request failed due to a file being open.
 *
 */
#define DRM_E_FILEOPEN                   ((DRM_RESULT)0x8003006EL)


/* ============================================================
**
** NetShow Errors from NsError.h (0xc00Dxxxx)
**
** ============================================================
*/

/*
 * MessageId: DRM_E_PARAMETERS_MISMATCHED
 *
 * MessageText:
 *
 * A problem has occurred in the Digital Rights Management component.
 *
 */
#define DRM_E_PARAMETERS_MISMATCHED      ((DRM_RESULT)0xC00D272FL)

/*
 * MessageId: DRM_E_FAILED_TO_STORE_LICENSE
 *
 * MessageText:
 *
 * License storage is not working.
 *
 */
#define DRM_E_FAILED_TO_STORE_LICENSE    ((DRM_RESULT)0xC00D2712L)

/*
 * MessageId: DRM_E_NOT_ALL_STORED
 *
 * MessageText:
 *
 * Some of the licenses could not be stored.
 *
 */
#define DRM_E_NOT_ALL_STORED             ((DRM_RESULT)0xC00D275FL)


/* ============================================================
**
** Vista crypto errors, 0x80040e80-0x80040e8f.
**
** ============================================================
*/

/*
 * MessageId: DRM_E_VERIFICATION_FAILURE
 *
 * MessageText:
 *
 * Validation of a Longhorn certificate failed.
 *
 */
#define DRM_E_VERIFICATION_FAILURE       ((DRM_RESULT)0x80040E80L)

/*
 * MessageId: DRM_E_RSA_SIGNATURE_ERROR
 *
 * MessageText:
 *
 * Error in RSA(PSS) signature.
 *
 */
#define DRM_E_RSA_SIGNATURE_ERROR        ((DRM_RESULT)0x80040E82L)

/*
 * MessageId: DRM_E_BAD_RSA_EXPONENT
 *
 * MessageText:
 *
 * An incorrect RSA exponent was supplied for a public key.
 *
 */
#define DRM_E_BAD_RSA_EXPONENT           ((DRM_RESULT)0x80040E86L)

/*
 * MessageId: DRM_E_P256_CONVERSION_FAILURE
 *
 * MessageText:
 *
 * An error occurred while converting between P256 types.
 *
 */
#define DRM_E_P256_CONVERSION_FAILURE    ((DRM_RESULT)0x80040E87L)

/*
 * MessageId: DRM_E_P256_PKCRYPTO_FAILURE
 *
 * MessageText:
 *
 * An error occurred in an asymmetric P256 cryptographic operation.
 *
 */
#define DRM_E_P256_PKCRYPTO_FAILURE      ((DRM_RESULT)0x80040E88L)

/*
 * MessageId: DRM_E_P256_PLAINTEXT_MAPPING_FAILURE
 *
 * MessageText:
 *
 * An error occurred while attempting to map a plaintext array to a EC Point: There is no conversion for this byte array to a EC Point.
 *
 */
#define DRM_E_P256_PLAINTEXT_MAPPING_FAILURE ((DRM_RESULT)0x80040E89L)

/*
 * MessageId: DRM_E_P256_INVALID_SIGNATURE
 *
 * MessageText:
 *
 * The ECDSA signature to be verified was not a valid signature format.
 *
 */
#define DRM_E_P256_INVALID_SIGNATURE     ((DRM_RESULT)0x80040E8AL)

/*
 * MessageId: DRM_E_P256_ECDSA_VERIFICATION_ERROR
 *
 * MessageText:
 *
 * The ECDSA verification algorithm encountered an unknown error.
 *
 */
#define DRM_E_P256_ECDSA_VERIFICATION_ERROR ((DRM_RESULT)0x80040E8BL)

/*
 * MessageId: DRM_E_P256_ECDSA_SIGNING_ERROR
 *
 * MessageText:
 *
 * The ECDSA signature algorithm encountered an unknown error.
 *
 */
#define DRM_E_P256_ECDSA_SIGNING_ERROR   ((DRM_RESULT)0x80040E8CL)

/*
 * MessageId: DRM_E_P256_HMAC_KEYGEN_FAILURE
 *
 * MessageText:
 *
 * Could not generate a valid HMAC key under constraint where CK || HMACK is a valid x coord on the EC (P256).
 *
 */
#define DRM_E_P256_HMAC_KEYGEN_FAILURE   ((DRM_RESULT)0x80040E8DL)


/* ============================================================
**
** IContentHeader errors: error codes from DRM_E_CH_BASECODE+0
** to DRM_E_CH_BASECODE+0xFF, 0x80041100-0x800411ff.
**
** ============================================================
*/

#define DRM_E_CH_BASECODE                ((DRM_RESULT)0x80041100L)

/*
 * MessageId: DRM_E_CH_VERSION_MISSING
 *
 * MessageText:
 *
 * Missing content header version.
 *
 */
#define DRM_E_CH_VERSION_MISSING         ((DRM_RESULT)0x80041103L)

/*
 * MessageId: DRM_E_CH_KID_MISSING
 *
 * MessageText:
 *
 * Missing KID attribute in content header.
 *
 */
#define DRM_E_CH_KID_MISSING             ((DRM_RESULT)0x80041104L)

/*
 * MessageId: DRM_E_CH_LAINFO_MISSING
 *
 * MessageText:
 *
 * Missing LAINFO attribute in content header.
 *
 */
#define DRM_E_CH_LAINFO_MISSING          ((DRM_RESULT)0x80041105L)

/*
 * MessageId: DRM_E_CH_CHECKSUM_MISSING
 *
 * MessageText:
 *
 * Missing content header checksum.
 *
 */
#define DRM_E_CH_CHECKSUM_MISSING        ((DRM_RESULT)0x80041106L)

/*
 * MessageId: DRM_E_CH_ATTR_MISSING
 *
 * MessageText:
 *
 * Missing content header attribute.
 *
 */
#define DRM_E_CH_ATTR_MISSING            ((DRM_RESULT)0x80041107L)

/*
 * MessageId: DRM_E_CH_INVALID_HEADER
 *
 * MessageText:
 *
 * Invalid content header.
 *
 */
#define DRM_E_CH_INVALID_HEADER          ((DRM_RESULT)0x80041108L)

/*
 * MessageId: DRM_E_CH_INVALID_CHECKSUM
 *
 * MessageText:
 *
 * Invalid checksum in the header.
 *
 */
#define DRM_E_CH_INVALID_CHECKSUM        ((DRM_RESULT)0x80041109L)

/*
 * MessageId: DRM_E_CH_UNABLE_TO_VERIFY
 *
 * MessageText:
 *
 * Unable to verify signature of content header.
 *
 */
#define DRM_E_CH_UNABLE_TO_VERIFY        ((DRM_RESULT)0x8004110AL)

/*
 * MessageId: DRM_E_CH_UNSUPPORTED_VERSION
 *
 * MessageText:
 *
 * Unsupported content header version.
 *
 */
#define DRM_E_CH_UNSUPPORTED_VERSION     ((DRM_RESULT)0x8004110BL)

/*
 * MessageId: DRM_E_CH_UNSUPPORTED_HASH_ALGORITHM
 *
 * MessageText:
 *
 * Unsupported hash algorithm.
 *
 */
#define DRM_E_CH_UNSUPPORTED_HASH_ALGORITHM ((DRM_RESULT)0x8004110CL)

/*
 * MessageId: DRM_E_CH_UNSUPPORTED_SIGN_ALGORITHM
 *
 * MessageText:
 *
 * Unsupported signature algorithm.
 *
 */
#define DRM_E_CH_UNSUPPORTED_SIGN_ALGORITHM ((DRM_RESULT)0x8004110DL)

/*
 * MessageId: DRM_E_CH_BAD_KEY
 *
 * MessageText:
 *
 * Invalid key.
 *
 */
#define DRM_E_CH_BAD_KEY                 ((DRM_RESULT)0x8004110EL)

/*
 * MessageId: DRM_E_CH_INCOMPATIBLE_HEADER_TYPE
 *
 * MessageText:
 *
 * Incompatible content header type.
 *
 */
#define DRM_E_CH_INCOMPATIBLE_HEADER_TYPE ((DRM_RESULT)0x8004110FL)

/*
 * MessageId: DRM_E_HEADER_ALREADY_SET
 *
 * MessageText:
 *
 * Content header type is already set. Reinitialize is required.
 *
 */
#define DRM_E_HEADER_ALREADY_SET         ((DRM_RESULT)0x80041110L)

/*
 * MessageId: DRM_E_CH_NOT_SIGNED
 *
 * MessageText:
 *
 * The header was not signed.
 *
 */
#define DRM_E_CH_NOT_SIGNED              ((DRM_RESULT)0x80041113L)

/*
 * MessageId: DRM_E_CH_UNKNOWN_ERROR
 *
 * MessageText:
 *
 * Unknown Error.
 *
 */
#define DRM_E_CH_UNKNOWN_ERROR           ((DRM_RESULT)0x80041116L)


/* ============================================================
**
** License parsing results: error codes from 0x80041200-0x800412ff.
**
** ============================================================
*/

#define LIC_BASECODE           ((DRM_RESULT)080041200L)

/*
 * MessageId: LIC_INIT_FAILURE
 *
 * MessageText:
 *
 *  LIC_INIT_FAILURE
 *
 */
#define LIC_INIT_FAILURE                 ((DRM_RESULT)0x80041201L)

/*
 * MessageId: LIC_LICENSE_NOTSET
 *
 * MessageText:
 *
 *  LIC_LICENSE_NOTSET
 *
 */
#define LIC_LICENSE_NOTSET               ((DRM_RESULT)0x80041202L)

/*
 * MessageId: LIC_PARAM_NOT_OPTIONAL
 *
 * MessageText:
 *
 *  LIC_PARAM_NOT_OPTIONAL
 *
 */
#define LIC_PARAM_NOT_OPTIONAL           ((DRM_RESULT)0x80041203L)

/*
 * MessageId: LIC_MEMORY_ALLOCATION_ERROR
 *
 * MessageText:
 *
 *  LIC_MEMORY_ALLOCATION_ERROR
 *
 */
#define LIC_MEMORY_ALLOCATION_ERROR      ((DRM_RESULT)0x80041204L)

/*
 * MessageId: LIC_INVALID_LICENSE
 *
 * MessageText:
 *
 *  LIC_INVALID_LICENSE
 *
 */
#define LIC_INVALID_LICENSE              ((DRM_RESULT)0x80041205L)

/*
 * MessageId: LIC_FIELD_MISSING
 *
 * MessageText:
 *
 *  LIC_FIELD_MISSING
 *
 */
#define LIC_FIELD_MISSING                ((DRM_RESULT)0x80041206L)

/*
 * MessageId: LIC_UNSUPPORTED_VALUE
 *
 * MessageText:
 *
 *  LIC_UNSUPPORTED_VALUE
 *
 */
#define LIC_UNSUPPORTED_VALUE            ((DRM_RESULT)0x80041207L)

/*
 * MessageId: LIC_UNKNOWN_ERROR
 *
 * MessageText:
 *
 *  LIC_UNKNOWN_ERROR
 *
 */
#define LIC_UNKNOWN_ERROR                ((DRM_RESULT)0x80041208L)

/*
 * MessageId: LIC_INVALID_REVLIST
 *
 * MessageText:
 *
 *  LIC_INVALID_REVLIST
 *
 */
#define LIC_INVALID_REVLIST              ((DRM_RESULT)0x80041209L)

/*
 * MessageId: LIC_EXPIRED_CERT
 *
 * MessageText:
 *
 *  LIC_EXPIRED_CERT
 *
 */
#define LIC_EXPIRED_CERT                 ((DRM_RESULT)0x8004120AL)


/* ============================================================
**
** Expression evaluator results: error codes from 0x80041400-0x800414ff.
**
** ============================================================
*/

#define CPRMEXP_BASECODE       ((DRM_RESULT)0x80041400L)

/*
 * MessageId: CPRMEXP_NOERROR
 *
 * MessageText:
 *
 *  CPRMEXP_NOERROR
 *
 */
#define CPRMEXP_NOERROR                  ((DRM_RESULT)0x00041400L)

/*
 * MessageId: CPRMEXP_PARAM_NOT_OPTIONAL
 *
 * MessageText:
 *
 *  CPRMEXP_PARAM_NOT_OPTIONAL
 *
 */
#define CPRMEXP_PARAM_NOT_OPTIONAL       ((DRM_RESULT)0x80041401L)

/*
 * MessageId: CPRMEXP_MEMORY_ALLOCATION_ERROR
 *
 * MessageText:
 *
 *  CPRMEXP_MEMORY_ALLOCATION_ERROR
 *
 */
#define CPRMEXP_MEMORY_ALLOCATION_ERROR  ((DRM_RESULT)0x80041402L)

/*
 * MessageId: CPRMEXP_NO_OPERANDS_IN_EXPRESSION
 *
 * MessageText:
 *
 *  CPRMEXP_NO_OPERANDS_IN_EXPRESSION
 *
 */
#define CPRMEXP_NO_OPERANDS_IN_EXPRESSION ((DRM_RESULT)0x80041403L)

/*
 * MessageId: CPRMEXP_INVALID_TOKEN
 *
 * MessageText:
 *
 *  CPRMEXP_INVALID_TOKEN
 *
 */
#define CPRMEXP_INVALID_TOKEN            ((DRM_RESULT)0x80041404L)

/*
 * MessageId: CPRMEXP_INVALID_CONSTANT
 *
 * MessageText:
 *
 *  CPRMEXP_INVALID_CONSTANT
 *
 */
#define CPRMEXP_INVALID_CONSTANT         ((DRM_RESULT)0x80041405L)

/*
 * MessageId: CPRMEXP_INVALID_VARIABLE
 *
 * MessageText:
 *
 *  CPRMEXP_INVALID_VARIABLE
 *
 */
#define CPRMEXP_INVALID_VARIABLE         ((DRM_RESULT)0x80041406L)

/*
 * MessageId: CPRMEXP_INVALID_FUNCTION
 *
 * MessageText:
 *
 *  CPRMEXP_INVALID_FUNCTION
 *
 */
#define CPRMEXP_INVALID_FUNCTION         ((DRM_RESULT)0x80041407L)

/*
 * MessageId: CPRMEXP_INVALID_ARGUMENT
 *
 * MessageText:
 *
 *  CPRMEXP_INVALID_ARGUMENT
 *
 */
#define CPRMEXP_INVALID_ARGUMENT         ((DRM_RESULT)0x80041408L)

/*
 * MessageId: CPRMEXP_INVALID_CONTEXT
 *
 * MessageText:
 *
 *  CPRMEXP_INVALID_CONTEXT
 *
 */
#define CPRMEXP_INVALID_CONTEXT          ((DRM_RESULT)0x80041409L)

/*
 * MessageId: CPRMEXP_ENDOFBUFFER
 *
 * MessageText:
 *
 *  CPRMEXP_ENDOFBUFFER
 *
 */
#define CPRMEXP_ENDOFBUFFER              ((DRM_RESULT)0x8004140AL)

/*
 * MessageId: CPRMEXP_MISSING_OPERAND
 *
 * MessageText:
 *
 *  CPRMEXP_MISSING_OPERAND
 *
 */
#define CPRMEXP_MISSING_OPERAND          ((DRM_RESULT)0x8004140BL)

/*
 * MessageId: CPRMEXP_OVERFLOW
 *
 * MessageText:
 *
 *  CPRMEXP_OVERFLOW
 *
 */
#define CPRMEXP_OVERFLOW                 ((DRM_RESULT)0x8004140CL)

/*
 * MessageId: CPRMEXP_UNDERFLOW
 *
 * MessageText:
 *
 *  CPRMEXP_UNDERFLOW
 *
 */
#define CPRMEXP_UNDERFLOW                ((DRM_RESULT)0x8004140DL)

/*
 * MessageId: CPRMEXP_INCORRECT_NUM_ARGS
 *
 * MessageText:
 *
 *  CPRMEXP_INCORRECT_NUM_ARGS
 *
 */
#define CPRMEXP_INCORRECT_NUM_ARGS       ((DRM_RESULT)0x8004140EL)

/*
 * MessageId: CPRMEXP_VARIABLE_EXPECTED
 *
 * MessageText:
 *
 *  CPRMEXP_VARIABLE_EXPECTED
 *
 */
#define CPRMEXP_VARIABLE_EXPECTED        ((DRM_RESULT)0x8004140FL)

/*
 * MessageId: CPRMEXP_RETRIEVAL_FAILURE
 *
 * MessageText:
 *
 *  CPRMEXP_RETRIEVAL_FAILURE
 *
 */
#define CPRMEXP_RETRIEVAL_FAILURE        ((DRM_RESULT)0x80041410L)

/*
 * MessageId: CPRMEXP_UPDATE_FAILURE
 *
 * MessageText:
 *
 *  CPRMEXP_UPDATE_FAILURE
 *
 */
#define CPRMEXP_UPDATE_FAILURE           ((DRM_RESULT)0x80041411L)

/*
 * MessageId: CPRMEXP_STRING_UNTERMINATED
 *
 * MessageText:
 *
 *  CPRMEXP_STRING_UNTERMINATED
 *
 */
#define CPRMEXP_STRING_UNTERMINATED      ((DRM_RESULT)0x80041412L)

/*
 * MessageId: CPRMEXP_UPDATE_UNSUPPORTED
 *
 * MessageText:
 *
 *  CPRMEXP_UPDATE_UNSUPPORTED
 *
 */
#define CPRMEXP_UPDATE_UNSUPPORTED       ((DRM_RESULT)0x80041413L)

/*
 * MessageId: CPRMEXP_ISOLATED_OPERAND_OR_OPERATOR
 *
 * MessageText:
 *
 *  CPRMEXP_ISOLATED_OPERAND_OR_OPERATOR
 *
 */
#define CPRMEXP_ISOLATED_OPERAND_OR_OPERATOR ((DRM_RESULT)0x80041414L)

/*
 * MessageId: CPRMEXP_UNMATCHED
 *
 * MessageText:
 *
 *  CPRMEXP_UNMATCHED
 *
 */
#define CPRMEXP_UNMATCHED                ((DRM_RESULT)0x80041415L)

/*
 * MessageId: CPRMEXP_WRONG_TYPE_OPERAND
 *
 * MessageText:
 *
 *  CPRMEXP_WRONG_TYPE_OPERAND
 *
 */
#define CPRMEXP_WRONG_TYPE_OPERAND       ((DRM_RESULT)0x80041416L)

/*
 * MessageId: CPRMEXP_TOO_MANY_OPERANDS
 *
 * MessageText:
 *
 *  CPRMEXP_TOO_MANY_OPERANDS
 *
 */
#define CPRMEXP_TOO_MANY_OPERANDS        ((DRM_RESULT)0x80041417L)

/*
 * MessageId: CPRMEXP_UNKNOWN_PARSE_ERROR
 *
 * MessageText:
 *
 *  CPRMEXP_UNKNOWN_PARSE_ERROR
 *
 */
#define CPRMEXP_UNKNOWN_PARSE_ERROR      ((DRM_RESULT)0x80041418L)

/*
 * MessageId: CPRMEXP_UNSUPPORTED_FUNCTION
 *
 * MessageText:
 *
 *  CPRMEXP_UNSUPPORTED_FUNCTION
 *
 */
#define CPRMEXP_UNSUPPORTED_FUNCTION     ((DRM_RESULT)0x80041419L)

/*
 * MessageId: CPRMEXP_CLOCK_REQUIRED
 *
 * MessageText:
 *
 *  CPRMEXP_CLOCK_REQUIRED
 *
 */
#define CPRMEXP_CLOCK_REQUIRED           ((DRM_RESULT)0x8004141AL)


/* ============================================================
**
** Legacy errors: error codes from 0x80048000-0x800480ff.
**
** ============================================================
*/

#define DRM_E_LEGACY_BASECODE                ((DRM_RESULT)0x80048000L)

/*
 * MessageId: DRM_E_LIC_KEY_DECODE_FAILURE
 *
 * MessageText:
 *
 * Key decode failure.
 *
 */
#define DRM_E_LIC_KEY_DECODE_FAILURE     ((DRM_RESULT)0x80048007L)

/*
 * MessageId: DRM_E_LIC_SIGNATURE_FAILURE
 *
 * MessageText:
 *
 * License signature failure.
 *
 */
#define DRM_E_LIC_SIGNATURE_FAILURE      ((DRM_RESULT)0x80048008L)

/*
 * MessageId: DRM_E_LIC_KEY_AND_CERT_MISMATCH
 *
 * MessageText:
 *
 * Key and cert mismatch.
 *
 */
#define DRM_E_LIC_KEY_AND_CERT_MISMATCH  ((DRM_RESULT)0x80048013L)

/*
 * MessageId: DRM_E_KEY_MISMATCH
 *
 * MessageText:
 *
 * A public/private keypair is mismatched.
 *
 */
#define DRM_E_KEY_MISMATCH               ((DRM_RESULT)0x80048014L)

/*
 * MessageId: DRM_E_INVALID_SIGNATURE
 *
 * MessageText:
 *
 * License signature failure.
 *
 */
#define DRM_E_INVALID_SIGNATURE          ((DRM_RESULT)0x800480CFL)

/*
 * MessageId: DRM_E_SYNC_ENTRYNOTFOUND
 *
 * MessageText:
 *
 * An entry was not found in the sync store.
 *
 */
#define DRM_E_SYNC_ENTRYNOTFOUND         ((DRM_RESULT)0x800480D0L)

/*
 * MessageId: DRM_E_STACKTOOSMALL
 *
 * MessageText:
 *
 * The stack supplied to the DRM API was too small.
 *
 */
#define DRM_E_STACKTOOSMALL              ((DRM_RESULT)0x800480D1L)

/*
 * MessageId: DRM_E_CIPHER_NOTINITIALIZED
 *
 * MessageText:
 *
 * The DRM Cipher routines were not correctly initialized before calling encryption/decryption routines.
 *
 */
#define DRM_E_CIPHER_NOTINITIALIZED      ((DRM_RESULT)0x800480D2L)

/*
 * MessageId: DRM_E_DECRYPT_NOTINITIALIZED
 *
 * MessageText:
 *
 * The DRM decrypt routines were not correctly initialized before trying to decrypt data.
 *
 */
#define DRM_E_DECRYPT_NOTINITIALIZED     ((DRM_RESULT)0x800480D3L)

/*
 * MessageId: DRM_E_SECURESTORE_LOCKNOTOBTAINED
 *
 * MessageText:
 *
 * Before reading or writing data to securestore in raw mode, first the lock must be obtained using DRM_SST_OpenData.
 *
 */
#define DRM_E_SECURESTORE_LOCKNOTOBTAINED ((DRM_RESULT)0x800480D4L)

/*
 * MessageId: DRM_E_PKCRYPTO_FAILURE
 *
 * MessageText:
 *
 * An error occurred in an asymmetric cryptographic operation.
 *
 */
#define DRM_E_PKCRYPTO_FAILURE           ((DRM_RESULT)0x800480D5L)

/*
 * MessageId: DRM_E_INVALID_DSTSLOTSIZE
 *
 * MessageText:
 *
 * Invalid DST slot size is specified.
 *
 */
#define DRM_E_INVALID_DSTSLOTSIZE        ((DRM_RESULT)0x800480D6L)


/* ============================================================
**
** DRM utility results: error codes from 0x80049000-0x800490ff.
**
** ============================================================
*/

#define DRMUTIL_BASECODE       ((DRM_RESULT)0x80049000L)

/*
 * MessageId: DRMUTIL_UNSUPPORTED_VERSION
 *
 * MessageText:
 *
 *  DRMUTIL_UNSUPPORTED_VERSION
 *
 */
#define DRMUTIL_UNSUPPORTED_VERSION      ((DRM_RESULT)0x80049005L)

/*
 * MessageId: DRMUTIL_EXPIRED_CERT
 *
 * MessageText:
 *
 *  DRMUTIL_EXPIRED_CERT
 *
 */
#define DRMUTIL_EXPIRED_CERT             ((DRM_RESULT)0x80049006L)

/*
 * MessageId: DRMUTIL_INVALID_CERT
 *
 * MessageText:
 *
 *  DRMUTIL_INVALID_CERT
 *
 */
#define DRMUTIL_INVALID_CERT             ((DRM_RESULT)0x80049007L)


/* ============================================================
**
** PK specific errors (from 0x8004a000 to 0x8004bfff)
**
** ============================================================
*/

/*
 * MessageId: DRM_E_DEVICE_NOT_REGISTERED
 *
 * MessageText:
 *
 * The DEVICEID does not exist in the device store
 *
 */
#define DRM_E_DEVICE_NOT_REGISTERED      ((DRM_RESULT)0x8004A000L)

/*
 * MessageId: DRM_E_TOO_MANY_INCLUSION_GUIDS
 *
 * MessageText:
 *
 * The license contained more than DRM_MAX_INCLUSION_GUIDS entries in its inclusion list
 *
 */
#define DRM_E_TOO_MANY_INCLUSION_GUIDS   ((DRM_RESULT)0x8004A001L)

/*
 * MessageId: DRM_E_REVOCATION_GUID_NOT_RECOGNIZED
 *
 * MessageText:
 *
 * The revocation list type GUID was not recognized
 *
 */
#define DRM_E_REVOCATION_GUID_NOT_RECOGNIZED ((DRM_RESULT)0x8004A002L)

/*
 * MessageId: DRM_E_LIC_CHAIN_TOO_DEEP
 *
 * MessageText:
 *
 * The license chained deeper than this implementation can handle
 *
 */
#define DRM_E_LIC_CHAIN_TOO_DEEP         ((DRM_RESULT)0x8004A003L)

/*
 * MessageId: DRM_E_DEVICE_SECURITY_LEVEL_TOO_LOW
 *
 * MessageText:
 *
 * The security level of the remote device is too low to receive the license
 *
 */
#define DRM_E_DEVICE_SECURITY_LEVEL_TOO_LOW ((DRM_RESULT)0x8004A004L)

/*
 * MessageId: DRM_E_DST_BLOCK_CACHE_CORRUPT
 *
 * MessageText:
 *
 * The block header cache returned invalid data
 *
 */
#define DRM_E_DST_BLOCK_CACHE_CORRUPT    ((DRM_RESULT)0x8004A005L)

/*
 * MessageId: DRM_E_CONTRACT_FAILED
 *
 * MessageText:
 *
 * The error code returned by the API is not present in the contract
 *
 */
#define DRM_E_CONTRACT_FAILED            ((DRM_RESULT)0x8004A006L)

/*
 * MessageId: DRM_E_DST_BLOCK_CACHE_MISS
 *
 * MessageText:
 *
 * The block header cache didn't contain the requested block header
 *
 */
#define DRM_E_DST_BLOCK_CACHE_MISS       ((DRM_RESULT)0x8004A007L)

/*
 * MessageId: DRM_E_INVALID_METERRESPONSE_SIGNATURE
 *
 * MessageText:
 *
 * Invalid signature in meter response
 *
 */
#define DRM_E_INVALID_METERRESPONSE_SIGNATURE ((DRM_RESULT)0x8004A013L)

/*
 * MessageId: DRM_E_INVALID_LICENSE_REVOCATION_LIST_SIGNATURE
 *
 * MessageText:
 *
 * Invalid signature in license revocation list.
 *
 */
#define DRM_E_INVALID_LICENSE_REVOCATION_LIST_SIGNATURE ((DRM_RESULT)0x8004A014L)

/*
 * MessageId: DRM_E_INVALID_METERCERT_SIGNATURE
 *
 * MessageText:
 *
 * Invalid signature in metering certificate
 *
 */
#define DRM_E_INVALID_METERCERT_SIGNATURE ((DRM_RESULT)0x8004A015L)

/*
 * MessageId: DRM_E_METERSTORE_DATA_NOT_FOUND
 *
 * MessageText:
 *
 * Metering data slot not found due to bad data in response file
 *
 */
#define DRM_E_METERSTORE_DATA_NOT_FOUND  ((DRM_RESULT)0x8004A016L)

/*
 * MessageId: DRM_E_NO_LICENSES_TO_SYNC
 *
 * MessageText:
 *
 * No more licenses to sync
 *
 */
#define DRM_E_NO_LICENSES_TO_SYNC        ((DRM_RESULT)0x8004A017L)

/*
 * MessageId: DRM_E_INVALID_REVOCATION_LIST
 *
 * MessageText:
 *
 * The revocation list version does not match the current revocation version
 *
 */
#define DRM_E_INVALID_REVOCATION_LIST    ((DRM_RESULT)0x8004A018L)

/*
 * MessageId: DRM_E_ENVELOPE_CORRUPT
 *
 * MessageText:
 *
 * The envelope archive or file is corrupt
 *
 */
#define DRM_E_ENVELOPE_CORRUPT           ((DRM_RESULT)0x8004A019L)

/*
 * MessageId: DRM_E_ENVELOPE_FILE_NOT_COMPATIBLE
 *
 * MessageText:
 *
 * The envelope file is not compatible with this version of the porting kit
 *
 */
#define DRM_E_ENVELOPE_FILE_NOT_COMPATIBLE ((DRM_RESULT)0x8004A01AL)

/*
 * MessageId: DRM_E_EXTENDED_RESTRICTION_NOT_UNDERSTOOD
 *
 * MessageText:
 *
 * An extensible restriction was not understood by the app, and is mark as being required
 *
 */
#define DRM_E_EXTENDED_RESTRICTION_NOT_UNDERSTOOD ((DRM_RESULT)0x8004A01BL)

/*
 * MessageId: DRM_E_INVALID_SLK
 *
 * MessageText:
 *
 * An ILA SLK (symmetric session key) was found, but did not contain valid data
 *
 */
#define DRM_E_INVALID_SLK                ((DRM_RESULT)0x8004A01CL)


/* ============================================================
**
** Drm Core errors (from 0x8004c000 to 0x8004dfff)
**
** ============================================================
*/

/*
 * MessageId: DRM_E_DEVICENOTINIT
 *
 * MessageText:
 *
 * This device has not been initialized against a DRM init service
 *
 */
#define DRM_E_DEVICENOTINIT              ((DRM_RESULT)0x8004C001L)

/*
 * MessageId: DRM_E_DRMNOTINIT
 *
 * MessageText:
 *
 * The app has not call DRM_Init properly
 *
 */
#define DRM_E_DRMNOTINIT                 ((DRM_RESULT)0x8004C002L)

/*
 * MessageId: DRM_E_INVALIDRIGHT
 *
 * MessageText:
 *
 * A right in the license in invalid
 *
 */
#define DRM_E_INVALIDRIGHT               ((DRM_RESULT)0x8004C003L)

/*
 * MessageId: DRM_E_INCOMPATABLELICENSESIZE
 *
 * MessageText:
 *
 * The size of the license is incompatable. DRM doesn't understand this license
 *
 */
#define DRM_E_INCOMPATABLELICENSESIZE    ((DRM_RESULT)0x8004C004L)

/*
 * MessageId: DRM_E_INVALIDLICENSEFLAGS
 *
 * MessageText:
 *
 * The flags in the license are invalid. DRM either doesn't understand them or they are conflicting
 *
 */
#define DRM_E_INVALIDLICENSEFLAGS        ((DRM_RESULT)0x8004C005L)

/*
 * MessageId: DRM_E_INVALIDLICENSE
 *
 * MessageText:
 *
 * The license is invalid
 *
 */
#define DRM_E_INVALIDLICENSE             ((DRM_RESULT)0x8004C006L)

/*
 * MessageId: DRM_E_CONDITIONFAIL
 *
 * MessageText:
 *
 * A condition in the license failed to pass
 *
 */
#define DRM_E_CONDITIONFAIL              ((DRM_RESULT)0x8004C007L)

/*
 * MessageId: DRM_E_CONDITIONNOTSUPPORTED
 *
 * MessageText:
 *
 * A condition in the license is not supported by this verison of DRM
 *
 */
#define DRM_E_CONDITIONNOTSUPPORTED      ((DRM_RESULT)0x8004C008L)

/*
 * MessageId: DRM_E_LICENSEEXPIRED
 *
 * MessageText:
 *
 * The license has expired either by depleting a play count or via an end time.
 *
 */
#define DRM_E_LICENSEEXPIRED             ((DRM_RESULT)0x8004C009L)

/*
 * MessageId: DRM_E_LICENSENOTYETVALID
 *
 * MessageText:
 *
 * The license start time had not come to pass yet.
 *
 */
#define DRM_E_LICENSENOTYETVALID         ((DRM_RESULT)0x8004C00AL)

/*
 * MessageId: DRM_E_RIGHTSNOTAVAILABLE
 *
 * MessageText:
 *
 * The rights the app has requested are not available in the license
 *
 */
#define DRM_E_RIGHTSNOTAVAILABLE         ((DRM_RESULT)0x8004C00BL)

/*
 * MessageId: DRM_E_LICENSEMISMATCH
 *
 * MessageText:
 *
 * The license content id/ sku id doesn't match that requested by the app
 *
 */
#define DRM_E_LICENSEMISMATCH            ((DRM_RESULT)0x8004C00CL)

/*
 * MessageId: DRM_E_WRONGTOKENTYPE
 *
 * MessageText:
 *
 * The token parameter was of an incompatible type.
 *
 */
#define DRM_E_WRONGTOKENTYPE             ((DRM_RESULT)0x8004C00DL)

/*
 * MessageId: DRM_E_NORIGHTSREQUESTED
 *
 * MessageText:
 *
 * The app has not requested any rights before trying to bind
 *
 */
#define DRM_E_NORIGHTSREQUESTED          ((DRM_RESULT)0x8004C00EL)

/*
 * MessageId: DRM_E_LICENSENOTBOUND
 *
 * MessageText:
 *
 * A license has not been bound to. Decrypt can not happen without a successful bind call
 *
 */
#define DRM_E_LICENSENOTBOUND            ((DRM_RESULT)0x8004C00FL)

/*
 * MessageId: DRM_E_HASHMISMATCH
 *
 * MessageText:
 *
 * A Keyed Hash check failed.
 *
 */
#define DRM_E_HASHMISMATCH               ((DRM_RESULT)0x8004C010L)

/*
 * MessageId: DRM_E_INVALIDTIME
 *
 * MessageText:
 *
 * A time structure is invalid
 *
 */
#define DRM_E_INVALIDTIME                ((DRM_RESULT)0x8004C011L)

/*
 * MessageId: DRM_E_LICENSESTORENOTFOUND
 *
 * MessageText:
 *
 * The external license store was not found
 *
 */
#define DRM_E_LICENSESTORENOTFOUND       ((DRM_RESULT)0x8004C012L)

/*
 * MessageId: DRM_E_LICENSENOTFOUND
 *
 * MessageText:
 *
 * A license was not found in the external license store
 *
 */
#define DRM_E_LICENSENOTFOUND            ((DRM_RESULT)0x8004C013L)

/*
 * MessageId: DRM_E_LICENSEVERSIONNOTSUPPORTED
 *
 * MessageText:
 *
 * The DRM license version is not supported by the DRM version on the device.
 *
 */
#define DRM_E_LICENSEVERSIONNOTSUPPORTED ((DRM_RESULT)0x8004C014L)

/*
 * MessageId: DRM_E_INVALIDBINDID
 *
 * MessageText:
 *
 * The bind id is invalid.
 *
 */
#define DRM_E_INVALIDBINDID              ((DRM_RESULT)0x8004C015L)

/*
 * MessageId: DRM_E_UNSUPPORTEDALGORITHM
 *
 * MessageText:
 *
 * The encryption algorithm required for this operation is not supported.
 *
 */
#define DRM_E_UNSUPPORTEDALGORITHM       ((DRM_RESULT)0x8004C016L)

/*
 * MessageId: DRM_E_ALGORITHMNOTSET
 *
 * MessageText:
 *
 * The encryption algorithm required for this operation is not supported.
 *
 */
#define DRM_E_ALGORITHMNOTSET            ((DRM_RESULT)0x8004C017L)

/*
 * MessageId: DRM_E_LICENSESERVERNEEDSKEY
 *
 * MessageText:
 *
 * The license server needs a version of the device bind key from the init service.
 *
 */
#define DRM_E_LICENSESERVERNEEDSKEY      ((DRM_RESULT)0x8004C018L)

/*
 * MessageId: DRM_E_INVALIDLICENSESTORE
 *
 * MessageText:
 *
 * The license store version number is incorrect, or the store is invalid in some other way.
 *
 */
#define DRM_E_INVALIDLICENSESTORE        ((DRM_RESULT)0x8004C019L)

/*
 * MessageId: DRM_E_FILEREADERROR
 *
 * MessageText:
 *
 * There was an error reading a file.
 *
 */
#define DRM_E_FILEREADERROR              ((DRM_RESULT)0x8004C01AL)

/*
 * MessageId: DRM_E_FILEWRITEERROR
 *
 * MessageText:
 *
 * There was an error writing a file.
 *
 */
#define DRM_E_FILEWRITEERROR             ((DRM_RESULT)0x8004C01BL)

/*
 * MessageId: DRM_E_CLIENTTIMEINVALID
 *
 * MessageText:
 *
 * The time/clock on the device is not in sync with the license server within tolerance.
 *
 */
#define DRM_E_CLIENTTIMEINVALID          ((DRM_RESULT)0x8004C01CL)

/*
 * MessageId: DRM_E_DSTSTOREFULL
 *
 * MessageText:
 *
 * The data store is full.
 *
 */
#define DRM_E_DSTSTOREFULL               ((DRM_RESULT)0x8004C01DL)

/*
 * MessageId: DRM_E_NOXMLOPENTAG
 *
 * MessageText:
 *
 * XML open tag not found
 *
 */
#define DRM_E_NOXMLOPENTAG               ((DRM_RESULT)0x8004C01EL)

/*
 * MessageId: DRM_E_NOXMLCLOSETAG
 *
 * MessageText:
 *
 * XML close tag not found
 *
 */
#define DRM_E_NOXMLCLOSETAG              ((DRM_RESULT)0x8004C01FL)

/*
 * MessageId: DRM_E_INVALIDXMLTAG
 *
 * MessageText:
 *
 * Invalid XML tag
 *
 */
#define DRM_E_INVALIDXMLTAG              ((DRM_RESULT)0x8004C020L)

/*
 * MessageId: DRM_E_NOXMLCDATA
 *
 * MessageText:
 *
 * No XML CDATA found
 *
 */
#define DRM_E_NOXMLCDATA                 ((DRM_RESULT)0x8004C021L)

/*
 * MessageId: DRM_E_DSTNAMESPACEFULL
 *
 * MessageText:
 *
 * No more room for DST Namespace
 *
 */
#define DRM_E_DSTNAMESPACEFULL           ((DRM_RESULT)0x8004C022L)

/*
 * MessageId: DRM_E_DSTNAMESPACENOTFOUND
 *
 * MessageText:
 *
 * No DST Namespace found
 *
 */
#define DRM_E_DSTNAMESPACENOTFOUND       ((DRM_RESULT)0x8004C023L)

/*
 * MessageId: DRM_E_DSTSLOTNOTFOUND
 *
 * MessageText:
 *
 * DST Dataslot not found
 *
 */
#define DRM_E_DSTSLOTNOTFOUND            ((DRM_RESULT)0x8004C024L)

/*
 * MessageId: DRM_E_DSTSLOTEXIST
 *
 * MessageText:
 *
 * DST Dataslot already exists
 *
 */
#define DRM_E_DSTSLOTEXIST               ((DRM_RESULT)0x8004C025L)

/*
 * MessageId: DRM_E_DSTCORRUPTED
 *
 * MessageText:
 *
 * The data store is corrupted
 *
 */
#define DRM_E_DSTCORRUPTED               ((DRM_RESULT)0x8004C026L)

/*
 * MessageId: DRM_E_DSTSEEKERROR
 *
 * MessageText:
 *
 * There was an error attempting to seek in the Data Store
 *
 */
#define DRM_E_DSTSEEKERROR               ((DRM_RESULT)0x8004C027L)

/*
 * MessageId: DRM_E_DSTNAMESPACEINUSE
 *
 * MessageText:
 *
 * No DST Namespace in use
 *
 */
#define DRM_E_DSTNAMESPACEINUSE          ((DRM_RESULT)0x8004C028L)

/*
 * MessageId: DRM_E_INVALID_SECURESTORE_PASSWORD
 *
 * MessageText:
 *
 * The password used to open the secure store key was not able to validate the secure store hash.
 *
 */
#define DRM_E_INVALID_SECURESTORE_PASSWORD ((DRM_RESULT)0x8004C029L)

/*
 * MessageId: DRM_E_SECURESTORE_CORRUPT
 *
 * MessageText:
 *
 * The secure store is corrupt
 *
 */
#define DRM_E_SECURESTORE_CORRUPT        ((DRM_RESULT)0x8004C02AL)

/*
 * MessageId: DRM_E_SECURESTORE_FULL
 *
 * MessageText:
 *
 * The current secure store key is full. No more data can be added.
 *
 */
#define DRM_E_SECURESTORE_FULL           ((DRM_RESULT)0x8004C02BL)

/*
 * MessageId: DRM_E_NOACTIONINLICENSEREQUEST
 *
 * MessageText:
 *
 * No action(s) added for license request
 *
 */
#define DRM_E_NOACTIONINLICENSEREQUEST   ((DRM_RESULT)0x8004C02CL)

/*
 * MessageId: DRM_E_DUPLICATEDHEADERATTRIBUTE
 *
 * MessageText:
 *
 * Duplicated attribute in Header
 *
 */
#define DRM_E_DUPLICATEDHEADERATTRIBUTE  ((DRM_RESULT)0x8004C02DL)

/*
 * MessageId: DRM_E_NOKIDINHEADER
 *
 * MessageText:
 *
 * No KID attribute in Header
 *
 */
#define DRM_E_NOKIDINHEADER              ((DRM_RESULT)0x8004C02EL)

/*
 * MessageId: DRM_E_NOLAINFOINHEADER
 *
 * MessageText:
 *
 * No LAINFO attribute in Header
 *
 */
#define DRM_E_NOLAINFOINHEADER           ((DRM_RESULT)0x8004C02FL)

/*
 * MessageId: DRM_E_NOCHECKSUMINHEADER
 *
 * MessageText:
 *
 * No Checksum attribute in Header
 *
 */
#define DRM_E_NOCHECKSUMINHEADER         ((DRM_RESULT)0x8004C030L)

/*
 * MessageId: DRM_E_DSTBLOCKMISMATCH
 *
 * MessageText:
 *
 * DST block mismatch
 *
 */
#define DRM_E_DSTBLOCKMISMATCH           ((DRM_RESULT)0x8004C031L)

/*
 * MessageId: DRM_E_BACKUP_EXISTS
 *
 * MessageText:
 *
 * Backup file already exist.
 *
 */
#define DRM_E_BACKUP_EXISTS              ((DRM_RESULT)0x8004C032L)

/*
 * MessageId: DRM_E_LICENSE_TOOLONG
 *
 * MessageText:
 *
 * License size is too long
 *
 */
#define DRM_E_LICENSE_TOOLONG            ((DRM_RESULT)0x8004C033L)

/*
 * MessageId: DRM_E_DSTEXISTS
 *
 * MessageText:
 *
 * A DST already exists in the specified location
 *
 */
#define DRM_E_DSTEXISTS                  ((DRM_RESULT)0x8004C034L)

/*
 * MessageId: DRM_E_INVALIDDEVICECERTIFICATE
 *
 * MessageText:
 *
 * The device certificate is invalid.
 *
 */
#define DRM_E_INVALIDDEVICECERTIFICATE   ((DRM_RESULT)0x8004C035L)

/*
 * MessageId: DRM_E_DSTLOCKFAILED
 *
 * MessageText:
 *
 * Locking a segment of the DST failed.
 *
 */
#define DRM_E_DSTLOCKFAILED              ((DRM_RESULT)0x8004C036L)

/*
 * MessageId: DRM_E_FILESEEKERROR
 *
 * MessageText:
 *
 * File Seek Error
 *
 */
#define DRM_E_FILESEEKERROR              ((DRM_RESULT)0x8004C037L)

/*
 * MessageId: DRM_E_DSTNOTLOCKEDEXCLUSIVE
 *
 * MessageText:
 *
 * Existing lock is not exclusive
 *
 */
#define DRM_E_DSTNOTLOCKEDEXCLUSIVE      ((DRM_RESULT)0x8004C038L)

/*
 * MessageId: DRM_E_DSTEXCLUSIVELOCKONLY
 *
 * MessageText:
 *
 * Only exclusive lock is accepted
 *
 */
#define DRM_E_DSTEXCLUSIVELOCKONLY       ((DRM_RESULT)0x8004C039L)

/*
 * MessageId: DRM_E_DSTRESERVEDKEYDETECTED
 *
 * MessageText:
 *
 * DST reserved key value detected in UniqueKey
 *
 */
#define DRM_E_DSTRESERVEDKEYDETECTED     ((DRM_RESULT)0x8004C03AL)

/*
 * MessageId: DRM_E_V1_NOT_SUPPORTED
 *
 * MessageText:
 *
 * V1 Lic Acquisition is not supported
 *
 */
#define DRM_E_V1_NOT_SUPPORTED           ((DRM_RESULT)0x8004C03BL)

/*
 * MessageId: DRM_E_HEADER_NOT_SET
 *
 * MessageText:
 *
 * Content header is not set
 *
 */
#define DRM_E_HEADER_NOT_SET             ((DRM_RESULT)0x8004C03CL)

/*
 * MessageId: DRM_E_NEEDDEVCERTINDIV
 *
 * MessageText:
 *
 * The device certificate is template. It need Devcert Indiv
 *
 */
#define DRM_E_NEEDDEVCERTINDIV           ((DRM_RESULT)0x8004C03DL)

/*
 * MessageId: DRM_E_MACHINEIDMISMATCH
 *
 * MessageText:
 *
 * The device has Machine Id different from that in devcert.
 *
 */
#define DRM_E_MACHINEIDMISMATCH          ((DRM_RESULT)0x8004C03EL)

/*
 * MessageId: DRM_E_CLK_INVALID_RESPONSE
 *
 * MessageText:
 *
 * The secure clock response is invalid.
 *
 */
#define DRM_E_CLK_INVALID_RESPONSE       ((DRM_RESULT)0x8004C03FL)

/*
 * MessageId: DRM_E_CLK_INVALID_DATE
 *
 * MessageText:
 *
 * The secure clock response is invalid.
 *
 */
#define DRM_E_CLK_INVALID_DATE           ((DRM_RESULT)0x8004C040L)

/*
 * MessageId: DRM_E_CLK_UNSUPPORTED_VALUE
 *
 * MessageText:
 *
 * The secure clock response has unsupported value.
 *
 */
#define DRM_E_CLK_UNSUPPORTED_VALUE      ((DRM_RESULT)0x8004C041L)

/*
 * MessageId: DRM_E_INVALIDDEVICECERTIFICATETEMPLATE
 *
 * MessageText:
 *
 * The device certificate is invalid.
 *
 */
#define DRM_E_INVALIDDEVICECERTIFICATETEMPLATE ((DRM_RESULT)0x8004C042L)

/*
 * MessageId: DRM_E_DEVCERTEXCEEDSIZELIMIT
 *
 * MessageText:
 *
 * The device certificate exceeds max size
 *
 */
#define DRM_E_DEVCERTEXCEEDSIZELIMIT     ((DRM_RESULT)0x8004C043L)

/*
 * MessageId: DRM_E_DEVCERTTEMPLATEEXCEEDSSIZELIMIT
 *
 * MessageText:
 *
 * The device certificate template exceeds max size
 *
 */
#define DRM_E_DEVCERTTEMPLATEEXCEEDSSIZELIMIT ((DRM_RESULT)0x8004C044L)

/*
 * MessageId: DRM_E_DEVCERTREADERROR
 *
 * MessageText:
 *
 * Can't get the device certificate
 *
 */
#define DRM_E_DEVCERTREADERROR           ((DRM_RESULT)0x8004C045L)

/*
 * MessageId: DRM_E_DEVCERTWRITEERROR
 *
 * MessageText:
 *
 * Can't store the device certificate
 *
 */
#define DRM_E_DEVCERTWRITEERROR          ((DRM_RESULT)0x8004C046L)

/*
 * MessageId: DRM_E_PRIVKEYREADERROR
 *
 * MessageText:
 *
 * Can't get device private key
 *
 */
#define DRM_E_PRIVKEYREADERROR           ((DRM_RESULT)0x8004C047L)

/*
 * MessageId: DRM_E_PRIVKEYWRITEERROR
 *
 * MessageText:
 *
 * Can't store device private key
 *
 */
#define DRM_E_PRIVKEYWRITEERROR          ((DRM_RESULT)0x8004C048L)

/*
 * MessageId: DRM_E_DEVCERTTEMPLATEREADERROR
 *
 * MessageText:
 *
 * Can't get the device certificate template
 *
 */
#define DRM_E_DEVCERTTEMPLATEREADERROR   ((DRM_RESULT)0x8004C049L)

/*
 * MessageId: DRM_E_CLK_NOT_SUPPORTED
 *
 * MessageText:
 *
 * The secure clock is not supported.
 *
 */
#define DRM_E_CLK_NOT_SUPPORTED          ((DRM_RESULT)0x8004C04AL)

/*
 * MessageId: DRM_E_DEVCERTINDIV_NOT_SUPPORTED
 *
 * MessageText:
 *
 * The Devcert Indiv is not supported.
 *
 */
#define DRM_E_DEVCERTINDIV_NOT_SUPPORTED ((DRM_RESULT)0x8004C04BL)

/*
 * MessageId: DRM_E_METERING_NOT_SUPPORTED
 *
 * MessageText:
 *
 * The Metering is not supported.
 *
 */
#define DRM_E_METERING_NOT_SUPPORTED     ((DRM_RESULT)0x8004C04CL)

/*
 * MessageId: DRM_E_CLK_RESETSTATEREADERROR
 *
 * MessageText:
 *
 * Can not read Secure clock Reset State.
 *
 */
#define DRM_E_CLK_RESETSTATEREADERROR    ((DRM_RESULT)0x8004C04DL)

/*
 * MessageId: DRM_E_CLK_RESETSTATEWRITEERROR
 *
 * MessageText:
 *
 * Can not write Secure clock Reset State.
 *
 */
#define DRM_E_CLK_RESETSTATEWRITEERROR   ((DRM_RESULT)0x8004C04EL)

/*
 * MessageId: DRM_E_XMLNOTFOUND
 *
 * MessageText:
 *
 * a required XML tag was not found
 *
 */
#define DRM_E_XMLNOTFOUND                ((DRM_RESULT)0x8004C04FL)

/*
 * MessageId: DRM_E_METERING_WRONG_TID
 *
 * MessageText:
 *
 * wrong TID sent on metering response
 *
 */
#define DRM_E_METERING_WRONG_TID         ((DRM_RESULT)0x8004C050L)

/*
 * MessageId: DRM_E_METERING_INVALID_COMMAND
 *
 * MessageText:
 *
 * wrong command sent on metering response
 *
 */
#define DRM_E_METERING_INVALID_COMMAND   ((DRM_RESULT)0x8004C051L)

/*
 * MessageId: DRM_E_METERING_STORE_CORRUPT
 *
 * MessageText:
 *
 * The metering store is corrupt
 *
 */
#define DRM_E_METERING_STORE_CORRUPT     ((DRM_RESULT)0x8004C052L)

/*
 * MessageId: DRM_E_CERTIFICATE_REVOKED
 *
 * MessageText:
 *
 * A certificate given to DRM was revoked.
 *
 */
#define DRM_E_CERTIFICATE_REVOKED        ((DRM_RESULT)0x8004C053L)

/*
 * MessageId: DRM_E_CRYPTO_FAILED
 *
 * MessageText:
 *
 * A cryptographic operation failed.
 *
 */
#define DRM_E_CRYPTO_FAILED              ((DRM_RESULT)0x8004C054L)

/*
 * MessageId: DRM_E_STACK_CORRUPT
 *
 * MessageText:
 *
 * The stack allocator context is corrupt. Likely a buffer overrun problem.
 *
 */
#define DRM_E_STACK_CORRUPT              ((DRM_RESULT)0x8004C055L)

/*
 * MessageId: DRM_E_UNKNOWN_BINDING_KEY
 *
 * MessageText:
 *
 * A matching binding key could not be found for the license.
 *
 */
#define DRM_E_UNKNOWN_BINDING_KEY        ((DRM_RESULT)0x8004C056L)

/*
 * MessageId: DRM_E_V1_LICENSE_CHAIN_NOT_SUPPORTED
 *
 * MessageText:
 *
 * License chaining with V1 content is not supported.
 *
 */
#define DRM_E_V1_LICENSE_CHAIN_NOT_SUPPORTED ((DRM_RESULT)0x8004C057L)

/*
 * MessageId: DRM_E_WRONG_TOKEN_TYPE
 *
 * MessageText:
 *
 * The wrong type of token was used.
 *
 */
#define DRM_E_WRONG_TOKEN_TYPE           ((DRM_RESULT)0x8004C058L)

/*
 * MessageId: DRM_E_POLICY_METERING_DISABLED
 *
 * MessageText:
 *
 * Metering code was called but metering is disabled by group or user policy
 *
 */
#define DRM_E_POLICY_METERING_DISABLED   ((DRM_RESULT)0x8004C059L)

/*
 * MessageId: DRM_E_POLICY_ONLINE_DISABLED
 *
 * MessageText:
 *
 * online communication is disabled by group policy
 *
 */
#define DRM_E_POLICY_ONLINE_DISABLED     ((DRM_RESULT)0x8004C05AL)

/*
 * MessageId: DRM_E_CLK_NOT_SET
 *
 * MessageText:
 *
 * License may be there but can not be used as secure clock not set.
 *
 */
#define DRM_E_CLK_NOT_SET                ((DRM_RESULT)0x8004C05BL)

/*
 * MessageId: DRM_E_NO_CLK_SUPPORTED
 *
 * MessageText:
 *
 * This device does not support any Clock. So time bound licenses can not be played
 *
 */
#define DRM_E_NO_CLK_SUPPORTED           ((DRM_RESULT)0x8004C05CL)

/*
 * MessageId: DRM_E_NO_URL
 *
 * MessageText:
 *
 * Can not find URL info.
 *
 */
#define DRM_E_NO_URL                     ((DRM_RESULT)0x8004C05DL)

/*
 * MessageId: DRM_E_UNKNOWN_DEVICE_PROPERTY
 *
 * MessageText:
 *
 * Unknown device property.
 *
 */
#define DRM_E_UNKNOWN_DEVICE_PROPERTY    ((DRM_RESULT)0x8004C05EL)

/*
 * MessageId: DRM_E_METERING_MID_MISMATCH
 *
 * MessageText:
 *
 * The metering ID is not same in Metering Cert and metering response data
 *
 */
#define DRM_E_METERING_MID_MISMATCH      ((DRM_RESULT)0x8004C05FL)

/*
 * MessageId: DRM_E_METERING_RESPONSE_DECRYPT_FAILED
 *
 * MessageText:
 *
 * The encrypted section of metering response can not be decrypted
 *
 */
#define DRM_E_METERING_RESPONSE_DECRYPT_FAILED ((DRM_RESULT)0x8004C060L)

/*
 * MessageId: DRM_E_RIV_TOO_SMALL
 *
 * MessageText:
 *
 * RIV on the machine is too small.
 *
 */
#define DRM_E_RIV_TOO_SMALL              ((DRM_RESULT)0x8004C063L)

/*
 * MessageId: DRM_E_STACK_ALREADY_INITIALIZED
 *
 * MessageText:
 *
 * DRM_STK_Init called for initialized stack
 *
 */
#define DRM_E_STACK_ALREADY_INITIALIZED  ((DRM_RESULT)0x8004C064L)

/*
 * MessageId: DRM_E_DEVCERT_REVOKED
 *
 * MessageText:
 *
 * The device certificate given to DRM is revoked.
 *
 */
#define DRM_E_DEVCERT_REVOKED            ((DRM_RESULT)0x8004C065L)

/*
 * MessageId: DRM_E_OEM_RSA_DECRYPTION_ERROR
 *
 * MessageText:
 *
 * Error in OEM RSA Decryption.
 *
 */
#define DRM_E_OEM_RSA_DECRYPTION_ERROR   ((DRM_RESULT)0x8004C066L)

/*
 * MessageId: DRM_E_INVALID_DEVSTORE_ATTRIBUTE
 *
 * MessageText:
 *
 * Invalid device attributes in the device store
 *
 */
#define DRM_E_INVALID_DEVSTORE_ATTRIBUTE ((DRM_RESULT)0x8004C067L)

/*
 * MessageId: DRM_E_INVALID_DEVSTORE_ENTRY
 *
 * MessageText:
 *
 * The device store data entry is corrupted
 *
 */
#define DRM_E_INVALID_DEVSTORE_ENTRY     ((DRM_RESULT)0x8004C068L)

/*
 * MessageId: DRM_E_OEM_RSA_ENCRYPTION_ERROR
 *
 * MessageText:
 *
 * Error in OEM RSA Encryption process
 *
 */
#define DRM_E_OEM_RSA_ENCRYPTION_ERROR   ((DRM_RESULT)0x8004C069L)

/*
 * MessageId: DRM_E_DSTNAMESPACEEXIST
 *
 * MessageText:
 *
 * The DST Namespace already exists.
 *
 */
#define DRM_E_DSTNAMESPACEEXIST          ((DRM_RESULT)0x8004C06AL)

/*
 * MessageId: DRM_E_PERF_SCOPING_ERROR
 *
 * MessageText:
 *
 * Error in performance scope context
 *
 */
#define DRM_E_PERF_SCOPING_ERROR         ((DRM_RESULT)0x8004C06BL)

/*
 * MessageId: DRM_E_PRECISION_ARITHMETIC_FAIL
 *
 * MessageText:
 *
 * Operation involving multiple precision arithmetic fails
 *
 */
#define DRM_E_PRECISION_ARITHMETIC_FAIL  ((DRM_RESULT)0x8004C06CL)

/*
 * MessageId: DRM_E_OEM_RSA_INVALID_PRIVATE_KEY
 *
 * MessageText:
 *
 * Invalid private key.
 *
 */
#define DRM_E_OEM_RSA_INVALID_PRIVATE_KEY ((DRM_RESULT)0x8004C06DL)

/*
 * MessageId: DRM_E_NO_OPL_CALLBACK
 *
 * MessageText:
 *
 * There is no callback function to process the output restrictions specified in the license
 *
 */
#define DRM_E_NO_OPL_CALLBACK            ((DRM_RESULT)0x8004C06EL)

/*
 * MessageId: DRM_E_INVALID_PLAYREADY_OBJECT
 *
 * MessageText:
 *
 * Structure of PlayReady object is invalid
 *
 */
#define DRM_E_INVALID_PLAYREADY_OBJECT   ((DRM_RESULT)0x8004C06FL)

/*
 * MessageId: DRM_E_DUPLICATE_LICENSE
 *
 * MessageText:
 *
 * There is already a license in the store with the same KID & LID
 *
 */
#define DRM_E_DUPLICATE_LICENSE          ((DRM_RESULT)0x8004C070L)

/*
 * MessageId: DRM_E_REVOCATION_NOT_SUPPORTED
 *
 * MessageText:
 *
 * Device does not support revocation, while revocation data was placed into license policy structure.
 *
 */
#define DRM_E_REVOCATION_NOT_SUPPORTED   ((DRM_RESULT)0x8004C071L)

/*
 * MessageId: DRM_E_RECORD_NOT_FOUND
 *
 * MessageText:
 *
 * Record with requested type was not found in PlayReady object.
 *
 */
#define DRM_E_RECORD_NOT_FOUND           ((DRM_RESULT)0x8004C072L)

/*
 * MessageId: DRM_E_BUFFER_BOUNDS_EXCEEDED
 *
 * MessageText:
 *
 * An array is being referenced outside of it's bounds.
 *
 */
#define DRM_E_BUFFER_BOUNDS_EXCEEDED     ((DRM_RESULT)0x8004C073L)


/* ------------------------------------------------------------
**
** License revocation errors: error codes from DRM_E_BASECODE+0xA0 (+160) to
** DRM_E_BASECODE+0xBF, 0x8004c0a0-0x8004c0bf.
**
** ------------------------------------------------------------
*/

#define DRM_E_LRB_BASECODE                      DRM_E_BASECODE+0xA0

/*
 * MessageId: DRM_E_LRB_NOLGPUBKEY
 *
 * MessageText:
 *
 * LRB does not contain a valid LGPUBKEY.
 *
 */
#define DRM_E_LRB_NOLGPUBKEY             ((DRM_RESULT)0x8004C0A0L)

/*
 * MessageId: DRM_E_LRB_INVALIDSIGNATURE
 *
 * MessageText:
 *
 * Signature inside LRB is invalid.
 *
 */
#define DRM_E_LRB_INVALIDSIGNATURE       ((DRM_RESULT)0x8004C0A1L)

/*
 * MessageId: DRM_E_LRB_LGPUBKEY_MISMATCH
 *
 * MessageText:
 *
 * LRB is signed with a pubkey different from LGPUBKEY
 *
 */
#define DRM_E_LRB_LGPUBKEY_MISMATCH      ((DRM_RESULT)0x8004C0A2L)

/*
 * MessageId: DRM_E_LRB_INVALIDLICENSEDATA
 *
 * MessageText:
 *
 * LRB is signed with a pubkey different from LGPUBKEY
 *
 */
#define DRM_E_LRB_INVALIDLICENSEDATA     ((DRM_RESULT)0x8004C0A3L)


/* ------------------------------------------------------------
**
** License evaluator errors: error codes from DRM_E_BASECODE+0xC0 to
** DRM_E_BASECODE+0xDF, 0x8004c0c0-0x8004c0df.
**
** ------------------------------------------------------------
*/

#define DRM_E_LICEVAL_BASECODE                  DRM_E_BASECODE+0xC0

/*
 * MessageId: DRM_E_LICEVAL_LICENSE_NOT_SUPPLIED
 *
 * MessageText:
 *
 * License not supplied in the liceval context
 *
 */
#define DRM_E_LICEVAL_LICENSE_NOT_SUPPLIED ((DRM_RESULT)0x8004C0C0L)

/*
 * MessageId: DRM_E_LICEVAL_KID_MISMATCH
 *
 * MessageText:
 *
 * Mismatch between KID from header and the one inside license
 *
 */
#define DRM_E_LICEVAL_KID_MISMATCH       ((DRM_RESULT)0x8004C0C1L)

/*
 * MessageId: DRM_E_LICEVAL_LICENSE_REVOKED
 *
 * MessageText:
 *
 * License for this content has been revoked
 *
 */
#define DRM_E_LICEVAL_LICENSE_REVOKED    ((DRM_RESULT)0x8004C0C2L)

/*
 * MessageId: DRM_E_LICEVAL_UPDATE_FAILURE
 *
 * MessageText:
 *
 * Failed to update content revocation
 *
 */
#define DRM_E_LICEVAL_UPDATE_FAILURE     ((DRM_RESULT)0x8004C0C3L)

/*
 * MessageId: DRM_E_LICEVAL_REQUIRED_REVOCATION_LIST_NOT_AVAILABLE
 *
 * MessageText:
 *
 * Failed to update content revocation
 *
 */
#define DRM_E_LICEVAL_REQUIRED_REVOCATION_LIST_NOT_AVAILABLE ((DRM_RESULT)0x8004C0C4L)


/* ------------------------------------------------------------
**
** XMR parser and builder errors: error codes from DRM_E_BASECODE+0xE0 to
** DRM_E_BASECODE+0xFF, 0x8004c0e0-0x8004c0ff.
**
** ------------------------------------------------------------
*/

#define DRM_E_XMR_BASECODE                      DRM_E_BASECODE+0xE0

/*
 * MessageId: DRM_E_XMR_OBJECT_ALREADY_EXISTS
 *
 * MessageText:
 *
 * XMR builder context already has this object.
 *
 */
#define DRM_E_XMR_OBJECT_ALREADY_EXISTS  ((DRM_RESULT)0x8004C0E0L)

/*
 * MessageId: DRM_E_XMR_OBJECT_NOTFOUND
 *
 * MessageText:
 *
 * XMR object was not found.
 *
 */
#define DRM_E_XMR_OBJECT_NOTFOUND        ((DRM_RESULT)0x8004C0E1L)

/*
 * MessageId: DRM_E_XMR_REQUIRED_OBJECT_MISSING
 *
 * MessageText:
 *
 * XMR license doesn't have one or more required objects.
 *
 */
#define DRM_E_XMR_REQUIRED_OBJECT_MISSING ((DRM_RESULT)0x8004C0E2L)

/*
 * MessageId: DRM_E_XMR_INVALID_UNKNOWN_OBJECT
 *
 * MessageText:
 *
 * Invalid unknown object
 *
 */
#define DRM_E_XMR_INVALID_UNKNOWN_OBJECT ((DRM_RESULT)0x8004C0E3L)

/*
 * MessageId: DRM_E_XMR_LICENSE_BINDABLE
 *
 * MessageText:
 *
 * XMR license does not contain the Cannot Bind right
 *
 */
#define DRM_E_XMR_LICENSE_BINDABLE       ((DRM_RESULT)0x8004C0E4L)

/*
 * MessageId: DRM_E_XMR_LICENSE_NOT_BINDABLE
 *
 * MessageText:
 *
 * XMR license cannot be bound to because of the Cannot Bind right
 *
 */
#define DRM_E_XMR_LICENSE_NOT_BINDABLE   ((DRM_RESULT)0x8004C0E5L)

/*
 * MessageId: DRM_E_XMR_UNSUPPORTED_XMR_VERSION
 *
 * MessageText:
 *
 * The version of XMR license is not supported for the current action
 *
 */
#define DRM_E_XMR_UNSUPPORTED_XMR_VERSION ((DRM_RESULT)0x8004C0E6L)


/* ------------------------------------------------------------
**
** CRL parsing and validation errors: error codes from DRM_E_BASECODE+0x100 to
** DRM_E_BASECODE+0x1FF, 0x8004c100-0x8004c1ff.
**
** ------------------------------------------------------------
*/

#define DRM_E_CRL_BASECODE                  DRM_E_BASECODE+0x100

/*
 * MessageId: DRM_E_NOT_CRL_BLOB
 *
 * MessageText:
 *
 * CRL blob provided for parsing does not start with CBLB. It means file is not CRL blob at all.
 *
 */
#define DRM_E_NOT_CRL_BLOB               ((DRM_RESULT)0x8004C100L)

/*
 * MessageId: DRM_E_BAD_CRL_BLOB
 *
 * MessageText:
 *
 * The file is structured as CRL blob, but there is some error in file structure or one of CRLs inside is invalid.
 *
 */
#define DRM_E_BAD_CRL_BLOB               ((DRM_RESULT)0x8004C101L)


/* ------------------------------------------------------------
**
** Device certificate errors: error codes from DRM_E_BASECODE+0x200 to
** DRM_E_BASECODE+0x4FF, 0x8004c200-0x8004c2ff.
**
** ------------------------------------------------------------
*/

#define DRM_E_CERT_BASECODE                  DRM_E_BASECODE+0x200

/*
 * MessageId: DRM_E_INVALID_DEVCERT_ATTRIBUTE
 *
 * MessageText:
 *
 * The attributes in the Device certificate are invalid
 *
 */
#define DRM_E_INVALID_DEVCERT_ATTRIBUTE  ((DRM_RESULT)0x8004C200L)


/* ------------------------------------------------------------
**
** Test errors: error codes from DRM_E_BASECODE+0x300 to
** DRM_E_BASECODE+0x3E7, 0x8004c300-0x8004c3e7.
**
** ------------------------------------------------------------
*/

#define DRM_E_TEST_BASECODE        DRM_E_BASECODE+0x300
#define DRM_S_TEST_BASECODE        DRM_S_BASECODE+0x300

/*
 * MessageId: DRM_S_TEST_SKIP_FILE
 *
 * MessageText:
 *
 * Skip processing this file, not an eror.
 *
 */
#define DRM_S_TEST_SKIP_FILE             ((DRM_RESULT)0x0004C300L)

/*
 * MessageId: DRM_E_TEST_PKCRYPTO_FAILURE
 *
 * MessageText:
 *
 * Error in PK encryption/decryption crypto test cases.
 *
 */
#define DRM_E_TEST_PKCRYPTO_FAILURE      ((DRM_RESULT)0x8004C300L)

/*
 * MessageId: DRM_E_TEST_PKSIGN_VERIFY_ERROR
 *
 * MessageText:
 *
 * Digital signature verification failed.
 *
 */
#define DRM_E_TEST_PKSIGN_VERIFY_ERROR   ((DRM_RESULT)0x8004C301L)

/*
 * MessageId: DRM_E_TEST_ENCRYPT_ERROR
 *
 * MessageText:
 *
 * Error in encryption of cipher text.
 *
 */
#define DRM_E_TEST_ENCRYPT_ERROR         ((DRM_RESULT)0x8004C302L)

/*
 * MessageId: DRM_E_TEST_RC4KEY_FAILED
 *
 * MessageText:
 *
 * RC4 key failed during crypto operations.
 *
 */
#define DRM_E_TEST_RC4KEY_FAILED         ((DRM_RESULT)0x8004C303L)

/*
 * MessageId: DRM_E_TEST_DECRYPT_ERROR
 *
 * MessageText:
 *
 * Error in cipher text decryption.
 *
 */
#define DRM_E_TEST_DECRYPT_ERROR         ((DRM_RESULT)0x8004C304L)

/*
 * MessageId: DRM_E_TEST_DESKEY_FAILED
 *
 * MessageText:
 *
 * Decrypted data not equal to original data in a DES operation.
 *
 */
#define DRM_E_TEST_DESKEY_FAILED         ((DRM_RESULT)0x8004C305L)

/*
 * MessageId: DRM_E_TEST_CBC_INVERSEMAC_FAILURE
 *
 * MessageText:
 *
 * Decrypted data not equal to original in Inverse MAC operation.
 *
 */
#define DRM_E_TEST_CBC_INVERSEMAC_FAILURE ((DRM_RESULT)0x8004C306L)

/*
 * MessageId: DRM_E_TEST_HMAC_FAILURE
 *
 * MessageText:
 *
 * Error in hashed data in HMAC operation.
 *
 */
#define DRM_E_TEST_HMAC_FAILURE          ((DRM_RESULT)0x8004C307L)

/*
 * MessageId: DRM_E_TEST_INVALIDARG
 *
 * MessageText:
 *
 * Error in the number of arguments or argument data in Test files.
 *
 */
#define DRM_E_TEST_INVALIDARG            ((DRM_RESULT)0x8004C308L)

/*
 * MessageId: DRM_E_TEST_DEVICE_PRIVATE_KEY_INCORRECTLY_STORED
 *
 * MessageText:
 *
 * DRMManager context should not contain the device private key.
 *
 */
#define DRM_E_TEST_DEVICE_PRIVATE_KEY_INCORRECTLY_STORED ((DRM_RESULT)0x8004C30AL)

/*
 * MessageId: DRM_E_TEST_DRMMANAGER_CONTEXT_NULL
 *
 * MessageText:
 *
 * DRMManager context is NULL.
 *
 */
#define DRM_E_TEST_DRMMANAGER_CONTEXT_NULL ((DRM_RESULT)0x8004C30BL)

/*
 * MessageId: DRM_E_TEST_UNEXPECTED_REVINFO_RESULT
 *
 * MessageText:
 *
 * Revocation cache result was not as expected.
 *
 */
#define DRM_E_TEST_UNEXPECTED_REVINFO_RESULT ((DRM_RESULT)0x8004C30CL)

/*
 * MessageId: DRM_E_TEST_RIV_MISMATCH
 *
 * MessageText:
 *
 * Revocation Info Version(RIV) mismatch.
 *
 */
#define DRM_E_TEST_RIV_MISMATCH          ((DRM_RESULT)0x8004C30DL)

/*
 * MessageId: DRM_E_TEST_URL_ERROR
 *
 * MessageText:
 *
 * There is an error in the URL from the challenge generated.
 *
 */
#define DRM_E_TEST_URL_ERROR             ((DRM_RESULT)0x8004C310L)

/*
 * MessageId: DRM_E_TEST_MID_MISMATCH
 *
 * MessageText:
 *
 * The MIDs returned from the DRM_MANAGER_CONTEXT does not match the test input.
 *
 */
#define DRM_E_TEST_MID_MISMATCH          ((DRM_RESULT)0x8004C311L)

/*
 * MessageId: DRM_E_TEST_METER_CERTIFICATE_MISMATCH
 *
 * MessageText:
 *
 * The input data does not match with the Metering certificate returned from the license.
 *
 */
#define DRM_E_TEST_METER_CERTIFICATE_MISMATCH ((DRM_RESULT)0x8004C312L)

/*
 * MessageId: DRM_E_TEST_LICENSE_STATE_MISMATCH
 *
 * MessageText:
 *
 * The input data and license state returned from the license do not match.
 *
 */
#define DRM_E_TEST_LICENSE_STATE_MISMATCH ((DRM_RESULT)0x8004C313L)

/*
 * MessageId: DRM_E_TEST_SOURCE_ID_MISMATCH
 *
 * MessageText:
 *
 * The input data and license state returned from the license do not match.
 *
 */
#define DRM_E_TEST_SOURCE_ID_MISMATCH    ((DRM_RESULT)0x8004C316L)

/*
 * MessageId: DRM_E_TEST_UNEXPECTED_LICENSE_COUNT
 *
 * MessageText:
 *
 * The input data and the number of license from the KID do not match.
 *
 */
#define DRM_E_TEST_UNEXPECTED_LICENSE_COUNT ((DRM_RESULT)0x8004C317L)

/*
 * MessageId: DRM_E_TEST_UNEXPECTED_DEVICE_PROPERTY
 *
 * MessageText:
 *
 * Unknown device property.
 *
 */
#define DRM_E_TEST_UNEXPECTED_DEVICE_PROPERTY ((DRM_RESULT)0x8004C318L)

/*
 * MessageId: DRM_E_TEST_DRMMANAGER_MISALIGNED_BYTES
 *
 * MessageText:
 *
 * Error due to misalignment of bytes.
 *
 */
#define DRM_E_TEST_DRMMANAGER_MISALIGNED_BYTES ((DRM_RESULT)0x8004C319L)

/*
 * MessageId: DRM_E_TEST_LICENSE_RESPONSE_ERROR
 *
 * MessageText:
 *
 * The license response callbacks did not provide the expected data.
 *
 */
#define DRM_E_TEST_LICENSE_RESPONSE_ERROR ((DRM_RESULT)0x8004C31AL)

/*
 * MessageId: DRM_E_TEST_OPL_MISMATCH
 *
 * MessageText:
 *
 * The minimum levels of the compressed/uncompressed Digital and Analog Video do not match the OPL.
 *
 */
#define DRM_E_TEST_OPL_MISMATCH          ((DRM_RESULT)0x8004C31BL)

/*
 * MessageId: DRM_E_TEST_INVALID_OPL_CALLBACK
 *
 * MessageText:
 *
 * The callback type supplied is not valid.
 *
 */
#define DRM_E_TEST_INVALID_OPL_CALLBACK  ((DRM_RESULT)0x8004C31CL)

/*
 * MessageId: DRM_E_TEST_INCOMPLETE
 *
 * MessageText:
 *
 * The test function failed to complete.
 *
 */
#define DRM_E_TEST_INCOMPLETE            ((DRM_RESULT)0x8004C31DL)

/*
 * MessageId: DRM_E_TEST_UNEXPECTED_OUTPUT
 *
 * MessageText:
 *
 * The output of the function being tested does not match the expected output.
 *
 */
#define DRM_E_TEST_UNEXPECTED_OUTPUT     ((DRM_RESULT)0x8004C31EL)

/*
 * MessageId: DRM_E_TEST_DLA_NO_CONTENT_HEADER
 *
 * MessageText:
 *
 * Content Header Information was not retrieved correctly in DLA Sync Tests.
 *
 */
#define DRM_E_TEST_DLA_NO_CONTENT_HEADER ((DRM_RESULT)0x8004C31FL)

/*
 * MessageId: DRM_E_TEST_DLA_CONTENT_HEADER_FOUND
 *
 * MessageText:
 *
 * Content Header Information was found when it should not have been in DLA Sync Tests.
 *
 */
#define DRM_E_TEST_DLA_CONTENT_HEADER_FOUND ((DRM_RESULT)0x8004C320L)

/*
 * MessageId: DRM_E_TEST_SYNC_LSD_INCORRECT
 *
 * MessageText:
 *
 * DRM_SNC_GetSyncStoreEntry returned incorrect License State Data.
 *
 */
#define DRM_E_TEST_SYNC_LSD_INCORRECT    ((DRM_RESULT)0x8004C321L)

/*
 * MessageId: DRM_E_TEST_TOO_SLOW
 *
 * MessageText:
 *
 * The performance test failed because DRM took longer than its maximum time.
 *
 */
#define DRM_E_TEST_TOO_SLOW              ((DRM_RESULT)0x8004C322L)

/*
 * MessageId: DRM_E_TEST_LICENSESTORE_NOT_OPEN
 *
 * MessageText:
 *
 * The License Store contexts in the App Manager context are not open.
 *
 */
#define DRM_E_TEST_LICENSESTORE_NOT_OPEN ((DRM_RESULT)0x8004C323L)

/*
 * MessageId: DRM_E_TEST_DEVICE_NOT_INITED
 *
 * MessageText:
 *
 * The device instance has not been initialized prior to use.
 *
 */
#define DRM_E_TEST_DEVICE_NOT_INITED     ((DRM_RESULT)0x8004C324L)

/*
 * MessageId: DRM_E_TEST_VARIABLE_NOT_SET
 *
 * MessageText:
 *
 * A global variable needed for test execution has not been set correctly.
 *
 */
#define DRM_E_TEST_VARIABLE_NOT_SET      ((DRM_RESULT)0x8004C325L)

/*
 * MessageId: DRM_E_TEST_NOMORE
 *
 * MessageText:
 *
 * The same as DRM_E_NOMORE, only explicitly used in test code.
 *
 */
#define DRM_E_TEST_NOMORE                ((DRM_RESULT)0x8004C326L)

/*
 * MessageId: DRM_E_TEST_FILE_LOAD_ERROR
 *
 * MessageText:
 *
 * There was an error loading a test data file.
 *
 */
#define DRM_E_TEST_FILE_LOAD_ERROR       ((DRM_RESULT)0x8004C327L)

/*
 * MessageId: DRM_E_TEST_LICENSE_ACQ_FAILED
 *
 * MessageText:
 *
 * The attempt to acquire a license failed.
 *
 */
#define DRM_E_TEST_LICENSE_ACQ_FAILED    ((DRM_RESULT)0x8004C328L)

/*
 * MessageId: DRM_E_TEST_UNSUPPORTED_FILE_FORMAT
 *
 * MessageText:
 *
 * A file format is being used which is not supported by the test function.
 *
 */
#define DRM_E_TEST_UNSUPPORTED_FILE_FORMAT ((DRM_RESULT)0x8004C329L)

/*
 * MessageId: DRM_E_TEST_PARSING_ERROR
 *
 * MessageText:
 *
 * There was an error parsing input parameter.
 *
 */
#define DRM_E_TEST_PARSING_ERROR         ((DRM_RESULT)0x8004C32AL)

/*
 * MessageId: DRM_E_TEST_NOTIMPL
 *
 * MessageText:
 *
 * The specified test API is not implemented.
 *
 */
#define DRM_E_TEST_NOTIMPL               ((DRM_RESULT)0x8004C32BL)

/*
 * MessageId: DRM_E_TEST_VARIABLE_NOTFOUND
 *
 * MessageText:
 *
 * The specified test varaible was not found in the shared variable table.
 *
 */
#define DRM_E_TEST_VARIABLE_NOTFOUND     ((DRM_RESULT)0x8004C32CL)

/*
 * MessageId: DRM_E_TEST_VARIABLE_LISTFULL
 *
 * MessageText:
 *
 * The shared test variable table is full.
 *
 */
#define DRM_E_TEST_VARIABLE_LISTFULL     ((DRM_RESULT)0x8004C32DL)

/*
 * MessageId: DRM_E_TEST_UNEXPECTED_CONTENT_PROPERTY
 *
 * MessageText:
 *
 * Unknown content property.
 *
 */
#define DRM_E_TEST_UNEXPECTED_CONTENT_PROPERTY ((DRM_RESULT)0x8004C32EL)

/*
 * MessageId: DRM_E_TEST_PRO_HEADER_NOT_SET
 *
 * MessageText:
 *
 * PlayReady Object Header not set.
 *
 */
#define DRM_E_TEST_PRO_HEADER_NOT_SET    ((DRM_RESULT)0x8004C32FL)

/*
 * MessageId: DRM_E_TEST_NON_PRO_HEADER_TYPE
 *
 * MessageText:
 *
 * Incompatible header - PlayReady Object Header expected.
 *
 */
#define DRM_E_TEST_NON_PRO_HEADER_TYPE   ((DRM_RESULT)0x8004C330L)

/*
 * MessageId: DRM_E_TEST_INVALID_DEVICE_WRAPPER
 *
 * MessageText:
 *
 * The Device Simulator Device Wrapper is not valid.
 *
 */
#define DRM_E_TEST_INVALID_DEVICE_WRAPPER ((DRM_RESULT)0x8004C331L)

/*
 * MessageId: DRM_E_TEST_INVALID_WMDM_WRAPPER
 *
 * MessageText:
 *
 * The Device Simulator WMDM Wrapper is not valid.
 *
 */
#define DRM_E_TEST_INVALID_WMDM_WRAPPER  ((DRM_RESULT)0x8004C332L)

/*
 * MessageId: DRM_E_TEST_INVALID_WPD_WRAPPER
 *
 * MessageText:
 *
 * The Device Simulator WPD Wrapper is not valid.
 *
 */
#define DRM_E_TEST_INVALID_WPD_WRAPPER   ((DRM_RESULT)0x8004C333L)

/*
 * MessageId: DRM_E_TEST_INVALID_FILE
 *
 * MessageText:
 *
 * The data file given was invalid.
 *
 */
#define DRM_E_TEST_INVALID_FILE          ((DRM_RESULT)0x8004C334L)

/*
 * MessageId: DRM_E_TEST_PROPERTY_NOT_FOUND
 *
 * MessageText:
 *
 * The object did not have the property which was queried.
 *
 */
#define DRM_E_TEST_PROPERTY_NOT_FOUND    ((DRM_RESULT)0x8004C335L)

/*
 * MessageId: DRM_E_TEST_METERING_DATA_INCORRECT
 *
 * MessageText:
 *
 * The metering data reported is incorrect.
 *
 */
#define DRM_E_TEST_METERING_DATA_INCORRECT ((DRM_RESULT)0x8004C336L)

/*
 * MessageId: DRM_E_TEST_FILE_ALREADY_OPEN
 *
 * MessageText:
 *
 * The handle variable for a test file is not NULL. This indicates that a file was opened and not closed properly.
 *
 */
#define DRM_E_TEST_FILE_ALREADY_OPEN     ((DRM_RESULT)0x8004C337L)

/*
 * MessageId: DRM_E_TEST_FILE_NOT_OPEN
 *
 * MessageText:
 *
 * The handle variable for a test file is NULL. This indicates that a file was not opened.
 *
 */
#define DRM_E_TEST_FILE_NOT_OPEN         ((DRM_RESULT)0x8004C338L)

/*
 * MessageId: DRM_E_TEST_PICT_COLUMN_TOO_WIDE
 *
 * MessageText:
 *
 * The PICT input file contains a column which is too wide for the test parser to handle.
 *
 */
#define DRM_E_TEST_PICT_COLUMN_TOO_WIDE  ((DRM_RESULT)0x8004C339L)

/*
 * MessageId: DRM_E_TEST_PICT_COLUMN_MISMATCH
 *
 * MessageText:
 *
 * The PICT input file contains a row which doesn't have the same number of columns as the header row.
 *
 */
#define DRM_E_TEST_PICT_COLUMN_MISMATCH  ((DRM_RESULT)0x8004C33AL)


/* ------------------------------------------------------------
**
** Errors of the range 0x8004c3e8-0x8004c3f8 (range is where
** *decimal* +1000 starts.
**
** ------------------------------------------------------------
*/

/*
 * MessageId: DRM_E_LOGICERR
 *
 * MessageText:
 *
 * DRM code has a logic error in it.  This result should never be returned.  There is an unhandled code path if it is returned.
 *
 */
#define DRM_E_LOGICERR                   ((DRM_RESULT)0x8004C3E8L)

/*
 * MessageId: DRM_E_INVALIDREVINFO
 *
 * MessageText:
 *
 * The device certificate is invalid.
 *
 */
#define DRM_E_INVALIDREVINFO             ((DRM_RESULT)0x8004C3E9L)

/*
 * MessageId: DRM_E_SYNCLISTNOTSUPPORTED
 *
 * MessageText:
 *
 * The device does not support synclist.
 *
 */
#define DRM_E_SYNCLISTNOTSUPPORTED       ((DRM_RESULT)0x8004C3EAL)

/*
 * MessageId: DRM_E_REVOCATION_BUFFERTOOSMALL
 *
 * MessageText:
 *
 * The revocation buffer is too small.
 *
 */
#define DRM_E_REVOCATION_BUFFERTOOSMALL  ((DRM_RESULT)0x8004C3EBL)

/*
 * MessageId: DRM_E_DEVICE_ALREADY_REGISTERED
 *
 * MessageText:
 *
 * There exists already a device in the device store with the same DEVICEID that was given.
 *
 */
#define DRM_E_DEVICE_ALREADY_REGISTERED  ((DRM_RESULT)0x8004C3ECL)

/*
 * MessageId: DRM_E_DST_NOT_COMPATIBLE
 *
 * MessageText:
 *
 * The data store version is incompatible with this version of DRM.
 *
 */
#define DRM_E_DST_NOT_COMPATIBLE         ((DRM_RESULT)0x8004C3EDL)

/*
 * MessageId: DRM_E_RSA_DECRYPTION_ERROR
 *
 * MessageText:
 *
 * The data block/Encoded message used in OAEP decoding is incorrect.
 *
 */
#define DRM_E_RSA_DECRYPTION_ERROR       ((DRM_RESULT)0x8004C3F0L)

/*
 * MessageId: DRM_E_OEM_RSA_MESSAGE_TOO_BIG
 *
 * MessageText:
 *
 * The base message buffer is larger than the given modulus.
 *
 */
#define DRM_E_OEM_RSA_MESSAGE_TOO_BIG    ((DRM_RESULT)0x8004C3F1L)

/*
 * MessageId: DRM_E_METERCERTNOTFOUND
 *
 * MessageText:
 *
 * The metering certificate was not found in the store.
 *
 */
#define DRM_E_METERCERTNOTFOUND          ((DRM_RESULT)0x8004C3F2L)

/*
 * MessageId: DRM_E_MODULAR_ARITHMETIC_FAILURE
 *
 * MessageText:
 *
 * A failure occurred in bignum modular arithmetic.
 *
 */
#define DRM_E_MODULAR_ARITHMETIC_FAILURE ((DRM_RESULT)0x8004C3F3L)

/*
 * MessageId: DRM_E_FEATURE_NOT_SUPPORTED
 *
 * MessageText:
 *
 * The feature is not supported in this release.
 *
 */
#define DRM_E_FEATURE_NOT_SUPPORTED      ((DRM_RESULT)0x8004C3F4L)

/*
 * MessageId: DRM_E_REVOCATION_INVALID_PACKAGE
 *
 * MessageText:
 *
 * The revocation package is invalid
 *
 */
#define DRM_E_REVOCATION_INVALID_PACKAGE ((DRM_RESULT)0x8004C3F5L)


/* ------------------------------------------------------------
**
** Domain errors: error codes from DRM_E_BASECODE+0x500 to
** DRM_E_BASECODE+0x57F, 0x8004c500-0x8004c57f.
**
** ------------------------------------------------------------
*/

#define DRM_E_DOMAIN_BASECODE       DRM_E_BASECODE + 0x500

/*
 * MessageId: DRM_E_DOMAIN_INVALID_GUID
 *
 * MessageText:
 *
 * Not a correct GUID.
 *
 */
#define DRM_E_DOMAIN_INVALID_GUID        ((DRM_RESULT)0x8004C500L)

/*
 * MessageId: DRM_E_DOMAIN_INVALID_CUSTOM_DATA_TYPE
 *
 * MessageText:
 *
 * Not a valid custom data type.
 *
 */
#define DRM_E_DOMAIN_INVALID_CUSTOM_DATA_TYPE ((DRM_RESULT)0x8004C501L)

/*
 * MessageId: DRM_E_DOMAIN_STORE_ADD_DATA
 *
 * MessageText:
 *
 * Failed to add data into the domain store.
 *
 */
#define DRM_E_DOMAIN_STORE_ADD_DATA      ((DRM_RESULT)0x8004C502L)

/*
 * MessageId: DRM_E_DOMAIN_STORE_GET_DATA
 *
 * MessageText:
 *
 * Failed to retrieve data from the domain store.
 *
 */
#define DRM_E_DOMAIN_STORE_GET_DATA      ((DRM_RESULT)0x8004C503L)

/*
 * MessageId: DRM_E_DOMAIN_STORE_DELETE_DATA
 *
 * MessageText:
 *
 * Failed to delete data from the domain store.
 *
 */
#define DRM_E_DOMAIN_STORE_DELETE_DATA   ((DRM_RESULT)0x8004C504L)

/*
 * MessageId: DRM_E_DOMAIN_STORE_OPEN_STORE
 *
 * MessageText:
 *
 * Failed to open the domain store.
 *
 */
#define DRM_E_DOMAIN_STORE_OPEN_STORE    ((DRM_RESULT)0x8004C505L)

/*
 * MessageId: DRM_E_DOMAIN_STORE_CLOSE_STORE
 *
 * MessageText:
 *
 * Failed to close the domain store.
 *
 */
#define DRM_E_DOMAIN_STORE_CLOSE_STORE   ((DRM_RESULT)0x8004C506L)

/*
 * MessageId: DRM_E_DOMAIN_BIND_LICENSE
 *
 * MessageText:
 *
 * Failed to bind to the domain license.
 *
 */
#define DRM_E_DOMAIN_BIND_LICENSE        ((DRM_RESULT)0x8004C507L)

/*
 * MessageId: DRM_E_DOMAIN_INVALID_CUSTOM_DATA
 *
 * MessageText:
 *
 * Not a valid custom data.
 *
 */
#define DRM_E_DOMAIN_INVALID_CUSTOM_DATA ((DRM_RESULT)0x8004C508L)

/*
 * MessageId: DRM_E_DOMAIN_NOT_FOUND
 *
 * MessageText:
 *
 * No domain information is found.
 *
 */
#define DRM_E_DOMAIN_NOT_FOUND           ((DRM_RESULT)0x8004C509L)

/*
 * MessageId: DRM_E_DOMAIN_INVALID_DOMKEYXMR_DATA
 *
 * MessageText:
 *
 * The domain join response contains invalid domain privkey XMR data.
 *
 */
#define DRM_E_DOMAIN_INVALID_DOMKEYXMR_DATA ((DRM_RESULT)0x8004C50AL)


/* ------------------------------------------------------------
**
** PC errors returned by core logic: error codes from DRM_E_BASECODE+0x580 to
** DRM_E_BASECODE+0x5FF, 0x8004c580-0x8004c5ff.
**
** ------------------------------------------------------------
*/

#define DRM_E_PC_BASECODE           DRM_E_BASECODE + 0x580

/*
 * MessageId: DRM_E_DEVICE_DOMAIN_JOIN_REQUIRED
 *
 * MessageText:
 *
 * This error code communicates to the application that the device is not a member of a domain. The app can uses this error code in turn to decide whether it needs to join the domain or not
 *
 */
#define DRM_E_DEVICE_DOMAIN_JOIN_REQUIRED ((DRM_RESULT)0x8004C580L)


/* ------------------------------------------------------------
**
** Server errors returned by core logic: error codes from DRM_E_BASECODE+0x600
** to DRM_E_BASECODE+0x6FF, 0x8004c600-0x8004c6ff.
**
** ------------------------------------------------------------
*/

#define DRM_E_SERVER_BASECODE       DRM_E_BASECODE + 0x600

/*
 * MessageId: DRM_E_SERVER_INTERNAL_ERROR
 *
 * MessageText:
 *
 * An internal server error occurred.
 *
 */
#define DRM_E_SERVER_INTERNAL_ERROR      ((DRM_RESULT)0x8004C600L)

/*
 * MessageId: DRM_E_SERVER_INVALID_MESSAGE
 *
 * MessageText:
 *
 * The message sent to the server was invalid.
 *
 */
#define DRM_E_SERVER_INVALID_MESSAGE     ((DRM_RESULT)0x8004C601L)

/*
 * MessageId: DRM_E_SERVER_DEVICE_LIMIT_REACHED
 *
 * MessageText:
 *
 * The device limit for the domain has been reached.
 *
 */
#define DRM_E_SERVER_DEVICE_LIMIT_REACHED ((DRM_RESULT)0x8004C602L)

/*
 * MessageId: DRM_E_SERVER_INDIV_REQUIRED
 *
 * MessageText:
 *
 * Individualization of the client is required.
 *
 */
#define DRM_E_SERVER_INDIV_REQUIRED      ((DRM_RESULT)0x8004C603L)

/*
 * MessageId: DRM_E_SERVER_SERVICE_SPECIFIC
 *
 * MessageText:
 *
 * An error specific to the service has occurred.
 *
 */
#define DRM_E_SERVER_SERVICE_SPECIFIC    ((DRM_RESULT)0x8004C604L)

/*
 * MessageId: DRM_E_SERVER_DOMAIN_REQUIRED
 *
 * MessageText:
 *
 * A Domain certificate is required.
 *
 */
#define DRM_E_SERVER_DOMAIN_REQUIRED     ((DRM_RESULT)0x8004C605L)

/*
 * MessageId: DRM_E_SERVER_RENEW_DOMAIN
 *
 * MessageText:
 *
 * The Domain certificate needs to be renewed.
 *
 */
#define DRM_E_SERVER_RENEW_DOMAIN        ((DRM_RESULT)0x8004C606L)

/*
 * MessageId: DRM_E_SERVER_UNKNOWN_METERINGID
 *
 * MessageText:
 *
 * The metering identifier is unknown.
 *
 */
#define DRM_E_SERVER_UNKNOWN_METERINGID  ((DRM_RESULT)0x8004C607L)

/*
 * MessageId: DRM_E_SERVER_COMPUTER_LIMIT_REACHED
 *
 * MessageText:
 *
 * The computer limit for the domain has been reached.
 *
 */
#define DRM_E_SERVER_COMPUTER_LIMIT_REACHED ((DRM_RESULT)0x8004C608L)

/*
 * MessageId: DRM_E_SERVER_PROTOCOL_FALLBACK
 *
 * MessageText:
 *
 * The client should fallback to the V2 license acquisition protocol.
 *
 */
#define DRM_E_SERVER_PROTOCOL_FALLBACK   ((DRM_RESULT)0x8004C609L)

/*
 * MessageId: DRM_E_SERVER_NOT_A_MEMBER
 *
 * MessageText:
 *
 * The client was removed from the domain in an offline fashion and thus still has a domain cert, but not a valid domain membership.
 *
 */
#define DRM_E_SERVER_NOT_A_MEMBER        ((DRM_RESULT)0x8004C60AL)

/*
 * MessageId: DRM_E_SERVER_PROTOCOL_VERSION_MISMATCH
 *
 * MessageText:
 *
 * The protocol version specified was not supported by the server.
 *
 */
#define DRM_E_SERVER_PROTOCOL_VERSION_MISMATCH ((DRM_RESULT)0x8004C60BL)

/*
 * MessageId: DRM_E_SERVER_UNKNOWN_ACCOUNTID
 *
 * MessageText:
 *
 * The account identifier is unknown.
 *
 */
#define DRM_E_SERVER_UNKNOWN_ACCOUNTID   ((DRM_RESULT)0x8004C60CL)

/*
 * MessageId: DRM_E_SERVER_PROTOCOL_REDIRECT
 *
 * MessageText:
 *
 * The account identifier is unknown.
 *
 */
#define DRM_E_SERVER_PROTOCOL_REDIRECT   ((DRM_RESULT)0x8004C60DL)


/* ------------------------------------------------------------
** DRM_E_BASECODE + 0x680 - DRM_E_BASECODE + 0x6ff (0x8004c680-0x8004c6ff)
** are reserved for DRM Services.
**
** See multimedia\common\services\inc\svcerrors.h for Services error codes.
**
** ------------------------------------------------------------
*/

#define DRM_E_SERVICES_BASECODE     (DRM_E_BASECODE + 0x680)

/* ------------------------------------------------------------
**
** License acquisition protocol errors: error codes from DRM_E_BASECODE+0x700
** to DRM_E_BASECODE+0x77F, 0x8004c700-0x8004c77f.
**
** ------------------------------------------------------------
*/

#define DRM_E_LICACQ_BASECODE       DRM_E_BASECODE + 0x700

/*
 * MessageId: DRM_E_LICACQ_TOO_MANY_LICENSES
 *
 * MessageText:
 *
 * There are too many licenses in the license response.
 *
 */
#define DRM_E_LICACQ_TOO_MANY_LICENSES   ((DRM_RESULT)0x8004C700L)

/*
 * MessageId: DRM_E_LICACQ_ACK_TRANSACTIONID_TOO_BIG
 *
 * MessageText:
 *
 * The Transaction ID specified by the server exceeds the allocated buffer.
 *
 */
#define DRM_E_LICACQ_ACK_TRANSACTIONID_TOO_BIG ((DRM_RESULT)0x8004C701L)

/*
 * MessageId: DRM_E_LICACQ_ACK_MESSAGE_NOT_CREATED
 *
 * MessageText:
 *
 * The license acquisition acknowledgement message could not be created.
 *
 */
#define DRM_E_LICACQ_ACK_MESSAGE_NOT_CREATED ((DRM_RESULT)0x8004C702L)


/* ------------------------------------------------------------
**
** PlayReady initiator format errors: error codes from DRM_E_BASECODE+0x780
** to DRM_E_BASECODE+0x7FF, 0x8004c780-0x8004c7ff.
**
** ------------------------------------------------------------
*/

#define DRM_E_INITIATORS_BASECODE      DRM_E_BASECODE + 0x780

/*
 * MessageId: DRM_E_INITIATORS_UNKNOWN_TYPE
 *
 * MessageText:
 *
 * The initiator type is unknown.
 *
 */
#define DRM_E_INITIATORS_UNKNOWN_TYPE    ((DRM_RESULT)0x8004C780L)

/*
 * MessageId: DRM_E_INITIATORS_INVALID_SERVICEID
 *
 * MessageText:
 *
 * The service ID data is not valid.
 *
 */
#define DRM_E_INITIATORS_INVALID_SERVICEID ((DRM_RESULT)0x8004C781L)

/*
 * MessageId: DRM_E_INITIATORS_INVALID_ACCOUNTID
 *
 * MessageText:
 *
 * The account ID data is not valid.
 *
 */
#define DRM_E_INITIATORS_INVALID_ACCOUNTID ((DRM_RESULT)0x8004C782L)

/*
 * MessageId: DRM_E_INITIATORS_INVALID_MID
 *
 * MessageText:
 *
 * The account ID data is not valid.
 *
 */
#define DRM_E_INITIATORS_INVALID_MID     ((DRM_RESULT)0x8004C783L)

/*
 * MessageId: DRM_E_INITIATORS_MISSING_DC_URL
 *
 * MessageText:
 *
 * Domain Controller URL is missing.
 *
 */
#define DRM_E_INITIATORS_MISSING_DC_URL  ((DRM_RESULT)0x8004C784L)

/*
 * MessageId: DRM_E_INITIATORS_MISSING_CONTENT_HEADER
 *
 * MessageText:
 *
 * Content header is missing.
 *
 */
#define DRM_E_INITIATORS_MISSING_CONTENT_HEADER ((DRM_RESULT)0x8004C785L)

/*
 * MessageId: DRM_E_INITIATORS_MISSING_LAURL_IN_CONTENT_HEADER
 *
 * MessageText:
 *
 * Missing license acquisition URL in content header.
 *
 */
#define DRM_E_INITIATORS_MISSING_LAURL_IN_CONTENT_HEADER ((DRM_RESULT)0x8004C786L)

/*
 * MessageId: DRM_E_INITIATORS_MISSING_METERCERT_URL
 *
 * MessageText:
 *
 * Meter certificate server URL is missing.
 *
 */
#define DRM_E_INITIATORS_MISSING_METERCERT_URL ((DRM_RESULT)0x8004C787L)


/* ------------------------------------------------------------
**
** Binary certificate errors: error codes from DRM_E_BASECODE+0x800
** to DRM_E_BASECODE+0x8FF, 0x8004c800-0x8004c8ff.
**
** ------------------------------------------------------------
*/

#define DRM_E_BCERT_BASECODE     DRM_E_BASECODE + 0x800

/*
 * MessageId: DRM_E_BCERT_INVALID_SIGNATURE_TYPE
 *
 * MessageText:
 *
 * An invalid signature type was encountered
 *
 */
#define DRM_E_BCERT_INVALID_SIGNATURE_TYPE ((DRM_RESULT)0x8004C800L)

/*
 * MessageId: DRM_E_BCERT_CHAIN_TOO_DEEP
 *
 * MessageText:
 *
 * There are, or there would be, too many certificates in the certificate chain
 *
 */
#define DRM_E_BCERT_CHAIN_TOO_DEEP       ((DRM_RESULT)0x8004C801L)

/*
 * MessageId: DRM_E_BCERT_INVALID_CERT_TYPE
 *
 * MessageText:
 *
 * An invalid certificate type was encountered
 *
 */
#define DRM_E_BCERT_INVALID_CERT_TYPE    ((DRM_RESULT)0x8004C802L)

/*
 * MessageId: DRM_E_BCERT_INVALID_FEATURE
 *
 * MessageText:
 *
 * An invalid feature entry was encountered
 *
 */
#define DRM_E_BCERT_INVALID_FEATURE      ((DRM_RESULT)0x8004C803L)

/*
 * MessageId: DRM_E_BCERT_INVALID_KEY_USAGE
 *
 * MessageText:
 *
 * An invalid public key usage was encountered
 *
 */
#define DRM_E_BCERT_INVALID_KEY_USAGE    ((DRM_RESULT)0x8004C804L)

/*
 * MessageId: DRM_E_BCERT_INVALID_SECURITY_VERSION
 *
 * MessageText:
 *
 * An invalid Indiv Box security version was encountered
 *
 */
#define DRM_E_BCERT_INVALID_SECURITY_VERSION ((DRM_RESULT)0x8004C805L)

/*
 * MessageId: DRM_E_BCERT_INVALID_KEY_TYPE
 *
 * MessageText:
 *
 * An invalid public key type was encountered
 *
 */
#define DRM_E_BCERT_INVALID_KEY_TYPE     ((DRM_RESULT)0x8004C806L)

/*
 * MessageId: DRM_E_BCERT_INVALID_KEY_LENGTH
 *
 * MessageText:
 *
 * An invalid public key length was encountered
 *
 */
#define DRM_E_BCERT_INVALID_KEY_LENGTH   ((DRM_RESULT)0x8004C807L)

/*
 * MessageId: DRM_E_BCERT_INVALID_MAX_LICENSE_SIZE
 *
 * MessageText:
 *
 * An invalid maximum license size value was encountered
 *
 */
#define DRM_E_BCERT_INVALID_MAX_LICENSE_SIZE ((DRM_RESULT)0x8004C808L)

/*
 * MessageId: DRM_E_BCERT_INVALID_MAX_HEADER_SIZE
 *
 * MessageText:
 *
 * An invalid maximum license header size value was encountered
 *
 */
#define DRM_E_BCERT_INVALID_MAX_HEADER_SIZE ((DRM_RESULT)0x8004C809L)

/*
 * MessageId: DRM_E_BCERT_INVALID_MAX_LICENSE_CHAIN_DEPTH
 *
 * MessageText:
 *
 * An invalid maximum license chain depth was encountered
 *
 */
#define DRM_E_BCERT_INVALID_MAX_LICENSE_CHAIN_DEPTH ((DRM_RESULT)0x8004C80AL)

/*
 * MessageId: DRM_E_BCERT_INVALID_SECURITY_LEVEL
 *
 * MessageText:
 *
 * An invalid security level was encountered
 *
 */
#define DRM_E_BCERT_INVALID_SECURITY_LEVEL ((DRM_RESULT)0x8004C80BL)

/*
 * MessageId: DRM_E_BCERT_PRIVATE_KEY_NOT_SPECIFIED
 *
 * MessageText:
 *
 * A private key for signing the certificate was not provided to the builder
 *
 */
#define DRM_E_BCERT_PRIVATE_KEY_NOT_SPECIFIED ((DRM_RESULT)0x8004C80CL)

/*
 * MessageId: DRM_E_BCERT_ISSUER_KEY_NOT_SPECIFIED
 *
 * MessageText:
 *
 * An issuer key was not provided to the builder
 *
 */
#define DRM_E_BCERT_ISSUER_KEY_NOT_SPECIFIED ((DRM_RESULT)0x8004C80DL)

/*
 * MessageId: DRM_E_BCERT_ACCOUNT_ID_NOT_SPECIFIED
 *
 * MessageText:
 *
 * An account ID was not provided to the builder
 *
 */
#define DRM_E_BCERT_ACCOUNT_ID_NOT_SPECIFIED ((DRM_RESULT)0x8004C80EL)

/*
 * MessageId: DRM_E_BCERT_SERVICE_ID_NOT_SPECIFIED
 *
 * MessageText:
 *
 * A service provider ID was not provided to the builder
 *
 */
#define DRM_E_BCERT_SERVICE_ID_NOT_SPECIFIED ((DRM_RESULT)0x8004C80FL)

/*
 * MessageId: DRM_E_BCERT_CLIENT_ID_NOT_SPECIFIED
 *
 * MessageText:
 *
 * A client ID was not provided to the builder
 *
 */
#define DRM_E_BCERT_CLIENT_ID_NOT_SPECIFIED ((DRM_RESULT)0x8004C810L)

/*
 * MessageId: DRM_E_BCERT_DOMAIN_URL_NOT_SPECIFIED
 *
 * MessageText:
 *
 * A domain URL was not provided to the builder
 *
 */
#define DRM_E_BCERT_DOMAIN_URL_NOT_SPECIFIED ((DRM_RESULT)0x8004C811L)

/*
 * MessageId: DRM_E_BCERT_DOMAIN_URL_TOO_LONG
 *
 * MessageText:
 *
 * The domain URL contains too many ASCII characters
 *
 */
#define DRM_E_BCERT_DOMAIN_URL_TOO_LONG  ((DRM_RESULT)0x8004C812L)

/*
 * MessageId: DRM_E_BCERT_HARDWARE_ID_NOT_SPECIFIED
 *
 * MessageText:
 *
 * A hardware ID was not provided to the builder
 *
 */
#define DRM_E_BCERT_HARDWARE_ID_NOT_SPECIFIED ((DRM_RESULT)0x8004C813L)

/*
 * MessageId: DRM_E_BCERT_HARDWARE_ID_TOO_LONG
 *
 * MessageText:
 *
 * A hardware ID is longer than the maximum supported bytes
 *
 */
#define DRM_E_BCERT_HARDWARE_ID_TOO_LONG ((DRM_RESULT)0x8004C814L)

/*
 * MessageId: DRM_E_BCERT_SERIAL_NUM_NOT_SPECIFIED
 *
 * MessageText:
 *
 * A device serial number was not provided to the builder
 *
 */
#define DRM_E_BCERT_SERIAL_NUM_NOT_SPECIFIED ((DRM_RESULT)0x8004C815L)

/*
 * MessageId: DRM_E_BCERT_CERT_ID_NOT_SPECIFIED
 *
 * MessageText:
 *
 * A certificate ID was not provided to the builder
 *
 */
#define DRM_E_BCERT_CERT_ID_NOT_SPECIFIED ((DRM_RESULT)0x8004C816L)

/*
 * MessageId: DRM_E_BCERT_PUBLIC_KEY_NOT_SPECIFIED
 *
 * MessageText:
 *
 * A public key for the certificate was not provided to the builder or not found by the parser
 *
 */
#define DRM_E_BCERT_PUBLIC_KEY_NOT_SPECIFIED ((DRM_RESULT)0x8004C817L)

/*
 * MessageId: DRM_E_BCERT_KEY_USAGES_NOT_SPECIFIED
 *
 * MessageText:
 *
 * The public key usage information was not provided to the builder or not found by the parser
 *
 */
#define DRM_E_BCERT_KEY_USAGES_NOT_SPECIFIED ((DRM_RESULT)0x8004C818L)

/*
 * MessageId: DRM_E_BCERT_STRING_NOT_NULL_TERMINATED
 *
 * MessageText:
 *
 * Data string is not null-teminated
 *
 */
#define DRM_E_BCERT_STRING_NOT_NULL_TERMINATED ((DRM_RESULT)0x8004C819L)

/*
 * MessageId: DRM_E_BCERT_OBJECTHEADER_LEN_TOO_BIG
 *
 * MessageText:
 *
 * Object length in object header is too big
 *
 */
#define DRM_E_BCERT_OBJECTHEADER_LEN_TOO_BIG ((DRM_RESULT)0x8004C81AL)

/*
 * MessageId: DRM_E_BCERT_INVALID_ISSUERKEY_LENGTH
 *
 * MessageText:
 *
 * IssuerKey Length value is invalid
 *
 */
#define DRM_E_BCERT_INVALID_ISSUERKEY_LENGTH ((DRM_RESULT)0x8004C81BL)

/*
 * MessageId: DRM_E_BCERT_BASICINFO_CERT_EXPIRED
 *
 * MessageText:
 *
 * Certificate is expired
 *
 */
#define DRM_E_BCERT_BASICINFO_CERT_EXPIRED ((DRM_RESULT)0x8004C81CL)

/*
 * MessageId: DRM_E_BCERT_UNEXPECTED_OBJECT_HEADER
 *
 * MessageText:
 *
 * Object header has unexpected values
 *
 */
#define DRM_E_BCERT_UNEXPECTED_OBJECT_HEADER ((DRM_RESULT)0x8004C81DL)

/*
 * MessageId: DRM_E_BCERT_ISSUERKEY_KEYINFO_MISMATCH
 *
 * MessageText:
 *
 * The cert's Issuer Key does not match key info in the next cert
 *
 */
#define DRM_E_BCERT_ISSUERKEY_KEYINFO_MISMATCH ((DRM_RESULT)0x8004C81EL)

/*
 * MessageId: DRM_E_BCERT_INVALID_MAX_KEY_USAGES
 *
 * MessageText:
 *
 * Number of key usage entries is invalid
 *
 */
#define DRM_E_BCERT_INVALID_MAX_KEY_USAGES ((DRM_RESULT)0x8004C81FL)

/*
 * MessageId: DRM_E_BCERT_INVALID_MAX_FEATURES
 *
 * MessageText:
 *
 * Number of features is invalid
 *
 */
#define DRM_E_BCERT_INVALID_MAX_FEATURES ((DRM_RESULT)0x8004C820L)

/*
 * MessageId: DRM_E_BCERT_INVALID_CHAIN_HEADER_TAG
 *
 * MessageText:
 *
 * Cert chain header tag is invalid
 *
 */
#define DRM_E_BCERT_INVALID_CHAIN_HEADER_TAG ((DRM_RESULT)0x8004C821L)

/*
 * MessageId: DRM_E_BCERT_INVALID_CHAIN_VERSION
 *
 * MessageText:
 *
 * Cert chain version is invalid
 *
 */
#define DRM_E_BCERT_INVALID_CHAIN_VERSION ((DRM_RESULT)0x8004C822L)

/*
 * MessageId: DRM_E_BCERT_INVALID_CHAIN_LENGTH
 *
 * MessageText:
 *
 * Cert chain length value is invalid
 *
 */
#define DRM_E_BCERT_INVALID_CHAIN_LENGTH ((DRM_RESULT)0x8004C823L)

/*
 * MessageId: DRM_E_BCERT_INVALID_CERT_HEADER_TAG
 *
 * MessageText:
 *
 * Cert header tag is invalid
 *
 */
#define DRM_E_BCERT_INVALID_CERT_HEADER_TAG ((DRM_RESULT)0x8004C824L)

/*
 * MessageId: DRM_E_BCERT_INVALID_CERT_VERSION
 *
 * MessageText:
 *
 * Cert version is invalid
 *
 */
#define DRM_E_BCERT_INVALID_CERT_VERSION ((DRM_RESULT)0x8004C825L)

/*
 * MessageId: DRM_E_BCERT_INVALID_CERT_LENGTH
 *
 * MessageText:
 *
 * Cert length value is invalid
 *
 */
#define DRM_E_BCERT_INVALID_CERT_LENGTH  ((DRM_RESULT)0x8004C826L)

/*
 * MessageId: DRM_E_BCERT_INVALID_SIGNEDCERT_LENGTH
 *
 * MessageText:
 *
 * Length of signed portion of certificate is invalid
 *
 */
#define DRM_E_BCERT_INVALID_SIGNEDCERT_LENGTH ((DRM_RESULT)0x8004C827L)

/*
 * MessageId: DRM_E_BCERT_INVALID_PLATFORM_IDENTIFIER
 *
 * MessageText:
 *
 * An invalid Platform Identifier was specified
 *
 */
#define DRM_E_BCERT_INVALID_PLATFORM_IDENTIFIER ((DRM_RESULT)0x8004C828L)

/*
 * MessageId: DRM_E_BCERT_INVALID_NUMBER_EXTDATARECORDS
 *
 * MessageText:
 *
 * An invalid number of extended data records
 *
 */
#define DRM_E_BCERT_INVALID_NUMBER_EXTDATARECORDS ((DRM_RESULT)0x8004C829L)

/*
 * MessageId: DRM_E_BCERT_INVALID_EXTDATARECORD
 *
 * MessageText:
 *
 * An invalid extended data record
 *
 */
#define DRM_E_BCERT_INVALID_EXTDATARECORD ((DRM_RESULT)0x8004C82AL)

/*
 * MessageId: DRM_BCERT_EXTDATA_LENGTH_MUST_PRESENT
 *
 * MessageText:
 *
 * Extended data record length must be present.
 *
 */
#define DRM_BCERT_EXTDATA_LENGTH_MUST_PRESENT ((DRM_RESULT)0x8004C82BL)

/*
 * MessageId: DRM_BCERT_EXTDATA_PRIVKEY_MUST_PRESENT
 *
 * MessageText:
 *
 * Extended data record length must be present.
 *
 */
#define DRM_BCERT_EXTDATA_PRIVKEY_MUST_PRESENT ((DRM_RESULT)0x8004C82CL)

/*
 * MessageId: DRM_E_BCERT_INVALID_EXTDATA_LENGTH
 *
 * MessageText:
 *
 * Calculated and written extended data object lengths do not match.
 *
 */
#define DRM_E_BCERT_INVALID_EXTDATA_LENGTH ((DRM_RESULT)0x8004C82DL)

/*
 * MessageId: DRM_E_BCERT_EXTDATA_IS_NOT_PROVIDED
 *
 * MessageText:
 *
 * Extended data is not provided, the cert builder cannot write it.
 *
 */
#define DRM_E_BCERT_EXTDATA_IS_NOT_PROVIDED ((DRM_RESULT)0x8004C82EL)

/*
 * MessageId: DRM_E_BCERT_HWIDINFO_IS_MISSING
 *
 * MessageText:
 *
 * The PC certificate is correct but is not ready to use because has no HWID information
 *
 */
#define DRM_E_BCERT_HWIDINFO_IS_MISSING  ((DRM_RESULT)0x8004C82FL)

/*
 * MessageId: DRM_E_BCERT_INVALID_EXTDATA_SIGNED_LENGTH
 *
 * MessageText:
 *
 * Length of signed portion of extended data info is invalid
 *
 */
#define DRM_E_BCERT_INVALID_EXTDATA_SIGNED_LENGTH ((DRM_RESULT)0x8004C830L)

/*
 * MessageId: DRM_E_BCERT_INVALID_EXTDATA_RECORD_TYPE
 *
 * MessageText:
 *
 * Extended data record type is invalid
 *
 */
#define DRM_E_BCERT_INVALID_EXTDATA_RECORD_TYPE ((DRM_RESULT)0x8004C831L)

/*
 * MessageId: DRM_E_BCERT_EXTDATAFLAG_CERT_TYPE_MISMATCH
 *
 * MessageText:
 *
 * Certificate of this type cannot have extended data flag set
 *
 */
#define DRM_E_BCERT_EXTDATAFLAG_CERT_TYPE_MISMATCH ((DRM_RESULT)0x8004C832L)

/*
 * MessageId: DRM_E_BCERT_METERING_ID_NOT_SPECIFIED
 *
 * MessageText:
 *
 * An metering ID was not provided to the builder
 *
 */
#define DRM_E_BCERT_METERING_ID_NOT_SPECIFIED ((DRM_RESULT)0x8004C833L)

/*
 * MessageId: DRM_E_BCERT_METERING_URL_NOT_SPECIFIED
 *
 * MessageText:
 *
 * A metering URL was not provided to the builder
 *
 */
#define DRM_E_BCERT_METERING_URL_NOT_SPECIFIED ((DRM_RESULT)0x8004C834L)

/*
 * MessageId: DRM_E_BCERT_METERING_URL_TOO_LONG
 *
 * MessageText:
 *
 * The metering URL contains too many ASCII characters
 *
 */
#define DRM_E_BCERT_METERING_URL_TOO_LONG ((DRM_RESULT)0x8004C835L)

/*
 * MessageId: DRM_E_BCERT_VERIFICATION_ERRORS
 *
 * MessageText:
 *
 * Verification errors are found while parsing cert chain
 *
 */
#define DRM_E_BCERT_VERIFICATION_ERRORS  ((DRM_RESULT)0x8004C836L)

/*
 * MessageId: DRM_E_BCERT_REQUIRED_KEYUSAGE_MISSING
 *
 * MessageText:
 *
 * Required key usage is missing
 *
 */
#define DRM_E_BCERT_REQUIRED_KEYUSAGE_MISSING ((DRM_RESULT)0x8004C837L)

/*
 * MessageId: DRM_E_BCERT_NO_PUBKEY_WITH_REQUESTED_KEYUSAGE
 *
 * MessageText:
 *
 * The certificate does not contain a public key with the requested key usage
 *
 */
#define DRM_E_BCERT_NO_PUBKEY_WITH_REQUESTED_KEYUSAGE ((DRM_RESULT)0x8004C838L)

/*
 * MessageId: DRM_E_BCERT_MANUFACTURER_STRING_TOO_LONG
 *
 * MessageText:
 *
 * The manufacturer string is too long
 *
 */
#define DRM_E_BCERT_MANUFACTURER_STRING_TOO_LONG ((DRM_RESULT)0x8004C839L)

/*
 * MessageId: DRM_E_BCERT_TOO_MANY_PUBLIC_KEYS
 *
 * MessageText:
 *
 * There are too many public keys in the certificate
 *
 */
#define DRM_E_BCERT_TOO_MANY_PUBLIC_KEYS ((DRM_RESULT)0x8004C83AL)

/*
 * MessageId: DRM_E_BCERT_OBJECTHEADER_LEN_TOO_SMALL
 *
 * MessageText:
 *
 * Object length in object header is too small
 *
 */
#define DRM_E_BCERT_OBJECTHEADER_LEN_TOO_SMALL ((DRM_RESULT)0x8004C83BL)

/*
 * MessageId: DRM_E_BCERT_INVALID_WARNING_DAYS
 *
 * MessageText:
 *
 * An invalid server certificate expiration warning days. Warning days must be greater than zero.
 *
 */
#define DRM_E_BCERT_INVALID_WARNING_DAYS ((DRM_RESULT)0x8004C83CL)


/* ------------------------------------------------------------
**
** XML Signature/Encryption errors: error codes from DRM_E_BASECODE+0x900
** to DRM_E_BASECODE+0x9FF, 0x8004c900-0x8004c9ff.
**
** ------------------------------------------------------------
*/

#define DRM_E_XMLSIG_BASECODE       DRM_E_BASECODE + 0x900

/*
 * MessageId: DRM_E_XMLSIG_ECDSA_VERIFY_FAILURE
 *
 * MessageText:
 *
 * Error in ECDSA signature verification.
 *
 */
#define DRM_E_XMLSIG_ECDSA_VERIFY_FAILURE ((DRM_RESULT)0x8004C900L)

/*
 * MessageId: DRM_E_XMLSIG_SHA_VERIFY_FAILURE
 *
 * MessageText:
 *
 * Error in SHA verification.
 *
 */
#define DRM_E_XMLSIG_SHA_VERIFY_FAILURE  ((DRM_RESULT)0x8004C901L)

/*
 * MessageId: DRM_E_XMLSIG_FORMAT
 *
 * MessageText:
 *
 * The format of XML signature or encryption segment is incorrect.
 *
 */
#define DRM_E_XMLSIG_FORMAT              ((DRM_RESULT)0x8004C902L)

/*
 * MessageId: DRM_E_XMLSIG_PUBLIC_KEY_ID
 *
 * MessageText:
 *
 * Invalud pre-shared public key ID.
 *
 */
#define DRM_E_XMLSIG_PUBLIC_KEY_ID       ((DRM_RESULT)0x8004C903L)

/*
 * MessageId: DRM_E_XMLSIG_INVALID_KEY_FORMAT
 *
 * MessageText:
 *
 * Invalid type of public/private key format.
 *
 */
#define DRM_E_XMLSIG_INVALID_KEY_FORMAT  ((DRM_RESULT)0x8004C904L)

/*
 * MessageId: DRM_E_XMLSIG_SHA_HASH_SIZE
 *
 * MessageText:
 *
 * Size of hash is unexpected.
 *
 */
#define DRM_E_XMLSIG_SHA_HASH_SIZE       ((DRM_RESULT)0x8004C905L)

/*
 * MessageId: DRM_E_XMLSIG_ECDSA_SIGNATURE_SIZE
 *
 * MessageText:
 *
 * Size of ECDSA signature is unexpected.
 *
 */
#define DRM_E_XMLSIG_ECDSA_SIGNATURE_SIZE ((DRM_RESULT)0x8004C906L)


/* ------------------------------------------------------------
**
** UTF8 encoding errors: error codes from DRM_E_BASECODE+0xA00
** to DRM_E_BASECODE+0xAFF, 0x8004ca00-0x8004caff.
**
** ------------------------------------------------------------
*/

#define DRM_E_UTF_BASECODE       DRM_E_BASECODE + 0xa00

/*
 * MessageId: DRM_E_UTF_UNEXPECTED_END
 *
 * MessageText:
 *
 * Unexpected end of data in the middle of multibyte character.
 *
 */
#define DRM_E_UTF_UNEXPECTED_END         ((DRM_RESULT)0x8004CA00L)

/*
 * MessageId: DRM_E_UTF_INVALID_CODE
 *
 * MessageText:
 *
 * UTF character maps into a code with invalid value.
 *
 */
#define DRM_E_UTF_INVALID_CODE           ((DRM_RESULT)0x8004CA01L)


/* ------------------------------------------------------------
**
** XML SOAP errors: error codes from DRM_E_BASECODE+0xB00
** to DRM_E_BASECODE+0xBFF, 0x8004cb00-0x8004cbff.
**
** ------------------------------------------------------------
*/

#define DRM_E_SOAPXML_BASECODE       DRM_E_BASECODE + 0xb00

/*
 * MessageId: DRM_E_SOAPXML_INVALID_STATUS_CODE
 *
 * MessageText:
 *
 * Status code contained in the server error response is invalid.
 *
 */
#define DRM_E_SOAPXML_INVALID_STATUS_CODE ((DRM_RESULT)0x8004CB00L)

/*
 * MessageId: DRM_E_SOAPXML_XML_FORMAT
 *
 * MessageText:
 *
 * Cannot parse out expected XML node.
 *
 */
#define DRM_E_SOAPXML_XML_FORMAT         ((DRM_RESULT)0x8004CB01L)

/*
 * MessageId: DRM_E_SOAPXML_WRONG_MESSAGE_TYPE
 *
 * MessageText:
 *
 * The message type associated with the soap message is wrong.
 *
 */
#define DRM_E_SOAPXML_WRONG_MESSAGE_TYPE ((DRM_RESULT)0x8004CB02L)

/*
 * MessageId: DRM_E_SOAPXML_SIGNATURE_MISSING
 *
 * MessageText:
 *
 * The message did not have a signature and needed one
 *
 */
#define DRM_E_SOAPXML_SIGNATURE_MISSING  ((DRM_RESULT)0x8004CB03L)

/*
 * MessageId: DRM_E_SOAPXML_PROTOCOL_NOT_SUPPORTED
 *
 * MessageText:
 *
 * The requested protocol is not supported by the DRM SOAP parser.
 *
 */
#define DRM_E_SOAPXML_PROTOCOL_NOT_SUPPORTED ((DRM_RESULT)0x8004CB04L)


/* ------------------------------------------------------------
**
** Generic crypto errors: error codes from DRM_E_BASECODE+0xC00
** to DRM_E_BASECODE+0xCFF, 0x8004cc00-0x8004ccff.
**
** ------------------------------------------------------------
*/

#define DRM_E_CRYPTO_BASECODE       DRM_E_BASECODE + 0xc00

/*
 * MessageId: DRM_E_CRYPTO_PUBLIC_KEY_NOT_MATCH
 *
 * MessageText:
 *
 * The public key associated with an encrypted domain private from the server does not match any public key on the device.
 *
 */
#define DRM_E_CRYPTO_PUBLIC_KEY_NOT_MATCH ((DRM_RESULT)0x8004CC00L)


/* ------------------------------------------------------------
**
** Secure tracing errors: error codes from DRM_E_BASECODE+0xD00
** to DRM_E_BASECODE+0xDFF, 0x8004cd00-0x8004cdff.
**
** ------------------------------------------------------------
*/

#define DRM_E_SECURETRACE_BASECODE       DRM_E_BASECODE + 0xd00

/*
 * MessageId: DRM_E_SECURE_TRACE_BAD_GLOBAL_DATA_POINTER
 *
 * MessageText:
 *
 * The secure trace global data pointer is NULL
 *
 */
#define DRM_E_SECURE_TRACE_BAD_GLOBAL_DATA_POINTER ((DRM_RESULT)0x8004CD00L)

/*
 * MessageId: DRM_E_SECURE_TRACE_INVALID_GLOBAL_DATA
 *
 * MessageText:
 *
 * The secure trace global data structure is invalid
 *
 */
#define DRM_E_SECURE_TRACE_INVALID_GLOBAL_DATA ((DRM_RESULT)0x8004CD01L)

/*
 * MessageId: DRM_E_SECURE_TRACE_FORMATTING_ERROR
 *
 * MessageText:
 *
 * An error occured in formatting the trace message
 *
 */
#define DRM_E_SECURE_TRACE_FORMATTING_ERROR ((DRM_RESULT)0x8004CD02L)

/*
 * MessageId: DRM_E_SECURE_TRACE_BAD_SCHEME_DATA_POINTER
 *
 * MessageText:
 *
 * A secure trace scheme data pointer is NULL
 *
 */
#define DRM_E_SECURE_TRACE_BAD_SCHEME_DATA_POINTER ((DRM_RESULT)0x8004CD03L)

/*
 * MessageId: DRM_E_SECURE_TRACE_BAD_PER_THREAD_AES_DATA_POINTER
 *
 * MessageText:
 *
 * The secure trace per thread AES data pointer is NULL
 *
 */
#define DRM_E_SECURE_TRACE_BAD_PER_THREAD_AES_DATA_POINTER ((DRM_RESULT)0x8004CD04L)

/*
 * MessageId: DRM_E_SECURE_TRACE_BAD_PER_THREAD_AES_BUFFER_POINTER
 *
 * MessageText:
 *
 * A secure trace per thread AES buffer pointer is NULL
 *
 */
#define DRM_E_SECURE_TRACE_BAD_PER_THREAD_AES_BUFFER_POINTER ((DRM_RESULT)0x8004CD05L)

/*
 * MessageId: DRM_E_SECURE_TRACE_AES_INSUFFICIENT_BUFFER
 *
 * MessageText:
 *
 * There is no space left in the secure trace AES buffer
 *
 */
#define DRM_E_SECURE_TRACE_AES_INSUFFICIENT_BUFFER ((DRM_RESULT)0x8004CD06L)

/*
 * MessageId: DRM_E_SECURE_TRACE_VERSION_MISMATCH
 *
 * MessageText:
 *
 * All drm dlls do not agree on the same secure trace version
 *
 */
#define DRM_E_SECURE_TRACE_VERSION_MISMATCH ((DRM_RESULT)0x8004CD07L)

/*
 * MessageId: DRM_E_SECURE_TRACE_UNEXPECTED_ERROR
 *
 * MessageText:
 *
 * An expected error was encountered in secure tracing system
 *
 */
#define DRM_E_SECURE_TRACE_UNEXPECTED_ERROR ((DRM_RESULT)0x8004CD08L)


/* ------------------------------------------------------------
**
** NDT/NDR results: error codes from DRM_E_BASECODE+0xE00
** to DRM_E_BASECODE+0xEFF, 0x8004ce00-0x8004ceff.
**
** ------------------------------------------------------------
*/

#define DRM_ND_BASECODE           DRM_E_BASECODE + 0xE00

/*
 * MessageId: DRM_E_ND_MUST_REVALIDATE
 *
 * MessageText:
 *
 * The client must be revalidated before executing the intended operation.
 *
 */
#define DRM_E_ND_MUST_REVALIDATE         ((DRM_RESULT)0x8004CE00L)

/*
 * MessageId: DRM_E_ND_INVALID_MESSAGE
 *
 * MessageText:
 *
 * A received message is garbled.
 *
 */
#define DRM_E_ND_INVALID_MESSAGE         ((DRM_RESULT)0x8004CE01L)

/*
 * MessageId: DRM_E_ND_INVALID_MESSAGE_TYPE
 *
 * MessageText:
 *
 * A received message contains an invalid message type.
 *
 */
#define DRM_E_ND_INVALID_MESSAGE_TYPE    ((DRM_RESULT)0x8004CE02L)

/*
 * MessageId: DRM_E_ND_INVALID_MESSAGE_VERSION
 *
 * MessageText:
 *
 * A received message contains an invalid message version.
 *
 */
#define DRM_E_ND_INVALID_MESSAGE_VERSION ((DRM_RESULT)0x8004CE03L)

/*
 * MessageId: DRM_E_ND_INVALID_SESSION
 *
 * MessageText:
 *
 * The requested session is invalid.
 *
 */
#define DRM_E_ND_INVALID_SESSION         ((DRM_RESULT)0x8004CE04L)

/*
 * MessageId: DRM_E_ND_MEDIA_SESSION_LIMIT_REACHED
 *
 * MessageText:
 *
 * A new session cannot be opened because the maximum number of sessions has already been opened.
 *
 */
#define DRM_E_ND_MEDIA_SESSION_LIMIT_REACHED ((DRM_RESULT)0x8004CE05L)

/*
 * MessageId: DRM_E_ND_UNABLE_TO_VERIFY_PROXIMITY
 *
 * MessageText:
 *
 * The proximity detection procedure could not confirm that the receiver is near the transmitter in the network.
 *
 */
#define DRM_E_ND_UNABLE_TO_VERIFY_PROXIMITY ((DRM_RESULT)0x8004CE06L)

/*
 * MessageId: DRM_E_ND_INVALID_PROXIMITY_RESPONSE
 *
 * MessageText:
 *
 * The response to the proximity detection challenge is invalid.
 *
 */
#define DRM_E_ND_INVALID_PROXIMITY_RESPONSE ((DRM_RESULT)0x8004CE07L)

/*
 * MessageId: DRM_E_ND_DEVICE_LIMIT_REACHED
 *
 * MessageText:
 *
 * The maximum number of devices in use has been reached. Unable to open additional devices.
 *
 */
#define DRM_E_ND_DEVICE_LIMIT_REACHED    ((DRM_RESULT)0x8004CE08L)

/*
 * MessageId: DRM_E_ND_BAD_REQUEST
 *
 * MessageText:
 *
 * The message format is invalid.
 *
 */
#define DRM_E_ND_BAD_REQUEST             ((DRM_RESULT)0x8004CE09L)

/*
 * MessageId: DRM_E_ND_FAILED_SEEK
 *
 * MessageText:
 *
 * It is not possible to seek to the specified mark-in point.
 *
 */
#define DRM_E_ND_FAILED_SEEK             ((DRM_RESULT)0x8004CE0AL)

/*
 * MessageId: DRM_E_ND_INVALID_CONTEXT
 *
 * MessageText:
 *
 * Manager context or at least one of it's children is missing (or corrupt).
 *
 */
#define DRM_E_ND_INVALID_CONTEXT         ((DRM_RESULT)0x8004CE0BL)


/* ------------------------------------------------------------
**
** ASF results: error codes from DRM_E_BASECODE+0xF00
** to DRM_E_BASECODE+0xFFF, 0x8004ce00-0x8004cfff.
**
** ------------------------------------------------------------
*/

#define DRM_ASF_BASECODE           DRM_E_BASECODE + 0xF00

/* ASF Parsing Errors */
/* ------------------ */

/*
 * MessageId: DRM_E_ASF_BAD_ASF_HEADER
 *
 * MessageText:
 *
 * The ASF file has a bad ASF header.
 *
 */
#define DRM_E_ASF_BAD_ASF_HEADER         ((DRM_RESULT)0x8004CF00L)

/*
 * MessageId: DRM_E_ASF_BAD_PACKET_HEADER
 *
 * MessageText:
 *
 * The ASF file has a bad packet header.
 *
 */
#define DRM_E_ASF_BAD_PACKET_HEADER      ((DRM_RESULT)0x8004CF01L)

/*
 * MessageId: DRM_E_ASF_BAD_PAYLOAD_HEADER
 *
 * MessageText:
 *
 * The ASF file has a bad payload header.
 *
 */
#define DRM_E_ASF_BAD_PAYLOAD_HEADER     ((DRM_RESULT)0x8004CF02L)

/*
 * MessageId: DRM_E_ASF_BAD_DATA_HEADER
 *
 * MessageText:
 *
 * The ASF file has a bad data header.
 *
 */
#define DRM_E_ASF_BAD_DATA_HEADER        ((DRM_RESULT)0x8004CF03L)

/*
 * MessageId: DRM_E_ASF_INVALID_OPERATION
 *
 * MessageText:
 *
 * The intended operation is invalid given the current processing state of the ASF file.
 *
 */
#define DRM_E_ASF_INVALID_OPERATION      ((DRM_RESULT)0x8004CF04L)

/*
 * MessageId: DRM_E_ASF_AES_PAYLOAD_FOUND
 *
 * MessageText:
 *
 * ND payload extension system found; the file may be encrypted with AES already.
 *
 */
#define DRM_E_ASF_AES_PAYLOAD_FOUND      ((DRM_RESULT)0x8004CF05L)


/* ASF Muxing Errors */
/* ----------------- */

/*
 * MessageId: DRM_E_ASF_INVALID_DATA
 *
 * MessageText:
 *
 * The packet is overstuffed with data.
 *
 */
#define DRM_E_ASF_INVALID_DATA           ((DRM_RESULT)0x8004CF20L)

/*
 * MessageId: DRM_E_ASF_TOO_MANY_PAYLOADS
 *
 * MessageText:
 *
 * The number of payloads in the packet is greater than the maximum allowed.
 *
 */
#define DRM_E_ASF_TOO_MANY_PAYLOADS      ((DRM_RESULT)0x8004CF21L)

/*
 * MessageId: DRM_E_ASF_BANDWIDTH_OVERRUN
 *
 * MessageText:
 *
 * An object is overflowing the leaky bucket.
 *
 */
#define DRM_E_ASF_BANDWIDTH_OVERRUN      ((DRM_RESULT)0x8004CF22L)

/*
 * MessageId: DRM_E_ASF_INVALID_STREAM_NUMBER
 *
 * MessageText:
 *
 * The stream number is invalid; it is either zero, greater than the maximum value allowed, or has no associated data.
 *
 */
#define DRM_E_ASF_INVALID_STREAM_NUMBER  ((DRM_RESULT)0x8004CF23L)

/*
 * MessageId: DRM_E_ASF_LATE_SAMPLE
 *
 * MessageText:
 *
 * A sample was encountered with a presentation time outside of the mux's send window.
 *
 */
#define DRM_E_ASF_LATE_SAMPLE            ((DRM_RESULT)0x8004CF24L)

/*
 * MessageId: DRM_E_ASF_NOT_ACCEPTING
 *
 * MessageText:
 *
 * The sample does not fit in the remaining payload space.
 *
 */
#define DRM_E_ASF_NOT_ACCEPTING          ((DRM_RESULT)0x8004CF25L)

/*
 * MessageId: DRM_E_ASF_UNEXPECTED
 *
 * MessageText:
 *
 * An unexpected error occurred.
 *
 */
#define DRM_E_ASF_UNEXPECTED             ((DRM_RESULT)0x8004CF26L)


/* ------------------------------------------------------------
**
** Nonce store errors: error codes from DRM_E_BASECODE+0x1000
** to DRM_E_BASECODE+0x10FF, 0x8004d000-0x8004d0ff.
**
** ------------------------------------------------------------
*/

#define DRM_E_NONCE_STORE_BASECODE       DRM_E_BASECODE + 0x1000

/*
 * MessageId: DRM_E_NONCE_STORE_TOKEN_NOT_FOUND
 *
 * MessageText:
 *
 * The matching nonce store token is not found.
 *
 */
#define DRM_E_NONCE_STORE_TOKEN_NOT_FOUND ((DRM_RESULT)0x8004D000L)

/*
 * MessageId: DRM_E_NONCE_STORE_OPEN_STORE
 *
 * MessageText:
 *
 * Fail to open nonce store.
 *
 */
#define DRM_E_NONCE_STORE_OPEN_STORE     ((DRM_RESULT)0x8004D001L)

/*
 * MessageId: DRM_E_NONCE_STORE_CLOSE_STORE
 *
 * MessageText:
 *
 * Fail to close nonce store.
 *
 */
#define DRM_E_NONCE_STORE_CLOSE_STORE    ((DRM_RESULT)0x8004D002L)

/*
 * MessageId: DRM_E_NONCE_STORE_ADD_LICENSE
 *
 * MessageText:
 *
 * There is already a license associated with the nonce store token.
 *
 */
#define DRM_E_NONCE_STORE_ADD_LICENSE    ((DRM_RESULT)0x8004D003L)


/* ------------------------------------------------------------
**
** License Generation errors: error codes from DRM_E_BASECODE+0x1100 to
** DRM_E_BASECODE+0x11FF, 0x8004d100-0x8004d1ff.
**
** ------------------------------------------------------------
*/

#define DRM_E_LICGEN_BASECODE                  DRM_E_BASECODE+0x1100

/*
 * MessageId: DRM_E_LICGEN_POLICY_NOT_SUPPORTED
 *
 * MessageText:
 *
 * The license generation policy combination is not supported.
 *
 */
#define DRM_E_LICGEN_POLICY_NOT_SUPPORTED ((DRM_RESULT)0x8004D100L)


/* ------------------------------------------------------------
**
** Available range 0x8004d200-0x8004dfff.
**
** ------------------------------------------------------------
*/

/* Insert new PKCore sub-error facilities here */


/* ============================================================
**
** PC specific errors (from 0x8004e000 to 0x8004ffff)
**
** ============================================================
*/

/* Nothing should be added here - PC error codes are found in DrmPcErrors.h */

#endif /*__DRMRESULTS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmrevocationtypes.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMREVOCATIONTYPES_H__
#define __DRMREVOCATIONTYPES_H__


#ifdef __cplusplus
extern "C" {
#endif

typedef enum _DRM_REVOCATION_TYPE_ENUM
{
    DRM_REVOCATION_TYPE_WMDRM_APP = 0,
    DRM_REVOCATION_TYPE_WMDRM_DEVICE,
    DRM_REVOCATION_TYPE_WMDRM_ND,
    DRM_REVOCATION_TYPE_WMDRM_REVINFO,
    DRM_REVOCATION_TYPE_PLAYREADY_APP,
    DRM_REVOCATION_TYPE_PLAYREADY_RUNTIME,
    DRM_REVOCATION_TYPE_PLAYREADY_REVINFO2
} DRM_REVOCATION_TYPE_ENUM;

typedef struct __tagDRM_RLVI_RECORD
{
    DRM_GUID   listID;
    DRM_UINT64 qwVersion;
} DRM_RLVI_RECORD;

typedef struct __tagDRM_RLVI_HEAD
{
    DRM_DWORD   dwID;
    DRM_DWORD   cbSignedBytes;
    DRM_BYTE    bFormatVersion;
    DRM_BYTE    bReserved[3];
    DRM_DWORD   dwRIV;
    DRMFILETIME ftIssuedTime;
    DRM_DWORD   dwRecordCount;
} DRM_RLVI_HEAD;

typedef struct __tagDRM_RLVI_SIGNATURE
{
    DRM_BYTE  bSignatureType;
    DRM_DWORD ibSignature;
} DRM_RLVI_SIGNATURE;

typedef struct __tagDRM_RLVI_CERTCHAIN
{
    DRM_DWORD  cbCertChain;
    DRM_DWORD  ibCertChain;
} DRM_RLVI_CERTCHAIN;

typedef struct __tagDRM_RLVI
{
    DRM_RLVI_HEAD       head;
    DRM_DWORD           ibEntries;    /* Byte offset to the entries in the revocation info */
    DRM_RLVI_SIGNATURE  signature;
    DRM_RLVI_CERTCHAIN  certchain; 
} DRM_RLVI;

typedef struct
{    DRM_GUID guidRevocationList;
    DRM_BYTE *pbRevocationList;
    DRM_DWORD cbRevocationList;
} DRM_RVK_LIST;

#define RLVI_MAGIC_NUM_V1   ((DRM_DWORD) 0x524C5649) /* 'RLVI' */
#define RLVI_MAGIC_NUM_V2   ((DRM_DWORD) 0x524C5632) /* 'RLV2' */

#define RLVI_FORMAT_VERSION_V1 ((DRM_BYTE) 1)
#define RLVI_FORMAT_VERSION_V2 ((DRM_BYTE) 2)
#define RLVI_SIGNATURE_TYPE_1 ((DRM_BYTE) 1)
#define RLVI_SIGNATURE_SIZE_1 ((DRM_DWORD) 128)
#define RLVI_SIGNATURE_TYPE_2 ((DRM_BYTE) 2)
#define RLVI_SIGNATURE_SIZE_2 ((DRM_DWORD) 256)

#define DRM_NO_PREVIOUS_CRL 0xFFFFFFFF


#if DRM_SUPPORT_APP_REVOCATION

typedef DRM_DWORD DRM_CERT_TYPE;
#define CERTTYPE_V1APP 0

typedef struct __tagDRM_REVOCATION_LIST_ELEMENT
{
    DRM_CERT_TYPE certificatetype;
    DRM_DWORD     cbCert;
    DRM_BYTE      rgbCert [1];
}DRM_REVOCATION_LIST_ELEMENT;

typedef struct __tagDRM_REVOCATION_LIST
{
    DRM_BYTE  rgbSignature [__CB_DECL( DRM_ECC160_SIGNATURE_LEN) ];
    DRM_DWORD dwVersion;
    DRM_DWORD cb;
    DRM_DWORD idSerial;
    DRM_BYTE  rgbData [1]; /* An array of DRM_REVOCATION_LIST_ELEMENT structs which are variable length */
} DRM_REVOCATION_LIST;

#endif /*DRM_SUPPORT_APP_REVOCATION*/

/*
** CRL defines
*/
#define WMDRMNET_CRL_ENTRY_SIZE                     DRM_SHA1_DIGEST_LEN
#define WMDRMNET_CRL_SIGNATURE_TYPE_RSA_SHA1        2
#define WMDRMNET_CRL_SIGNATURE_LEN_RSA_SHA1         128
    
typedef struct
{
    DRM_BYTE val[ __CB_DECL( WMDRMNET_CRL_ENTRY_SIZE ) ];
    
} WMDRMNET_CRL_ENTRY;


#ifdef __cplusplus
}
#endif

#endif /* __DRMREVOCATIONTYPES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmrevocationstore.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#if DRM_SUPPORT_REVOCATION

#ifndef __DRM_REVOCATIONSTORE_H__
#define __DRM_REVOCATIONSTORE_H__

#include <drmdatastore.h>
#include <drmsecurestore.h>
#include <drmblackbox.h>

ENTER_PK_NAMESPACE;

typedef struct _tag_RevocationStoreContext
{
    DRM_DST                      *pDatastore;
    DRM_SECSTORE_CONTEXT         *pContextSST;
    DRM_BB_CONTEXT               *pContextBB;
    DRM_BOOL                      fInitedPassword;
    DRM_BYTE                      rgbPassword[__CB_DECL(DRM_SHA1_DIGEST_LEN)];
} _RevocationStoreContext;

typedef struct __tagDRM_REVOCATIONSTORE_CONTEXT{
    DRM_BYTE rgbOpaqueBuffer[ __CB_DECL( SIZEOF( _RevocationStoreContext ) ) ];
} DRM_REVOCATIONSTORE_CONTEXT;

/**********************************************************************
**
** Function:    DRM_RVS_InitRevocationStore
**
** Synopsis:    Initializes a revocation store context
**
** Arguments:   [f_pDatastore]         -- DST context
**              [f_pContextSST]        -- secure store context
**              [f_pContextBB]         -- blackbox context
**              [f_pContextRev]        -- revocation store context
**
** Returns:     DRM_SUCCESS on success or failed with,
**              DRM_E_INVALIDARG if a parameter is incorrect or
**              other errors found in drmresults.h
**
** Notes:
**
**********************************************************************/

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_RVS_InitRevocationStore(
    __in  const DRM_DST                      *f_pDatastore,
    __in  const DRM_SECSTORE_CONTEXT         *f_pContextSST,
    __in  const DRM_BB_CONTEXT               *f_pContextBB,
    __out       DRM_REVOCATIONSTORE_CONTEXT  *f_pContextRev );

/**********************************************************************
**
** Function:    DRM_RVS_StoreRevocationData
**
** Synopsis:    Stores data in the revocation store
**
** Arguments:   [f_pContextRev]        -- revocation store context
**              [f_pRevGUID]           -- GUID of data to store
**              [f_pbRevocationData]   -- pointer to data to store
**              [f_cbRevocationData]   -- size of data to store
**
** Returns:     DRM_SUCCESS on success or failed with,
**              DRM_E_INVALIDARG if a parameter is incorrect or
**              other errors found in drmresults.h
**
** Notes:
**
**********************************************************************/

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_RVS_StoreRevocationData(
    __inout                               DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    __in                            const DRM_GUID                    *f_pRevGUID,
    __in_bcount(f_cbRevocationData) const DRM_BYTE                    *f_pbRevocationData,
    __in                            const DRM_DWORD                    f_cbRevocationData );

/**********************************************************************
**
** Function:    DRM_RVS_GetRevocationData
**
** Synopsis:    Retrieves data from the revocation store
**
** Arguments:   [f_pContextRev]        -- revocation store context
**              [f_pRevGUID]           -- GUID of data to retrieve
**              [f_pbRevocationData]   -- pointer to buffer to hold returned data
**              [f_cbRevocationData]   -- size of buffer
**
** Returns:     DRM_SUCCESS on success or failed with,
**              DRM_E_INVALIDARG if a parameter is incorrect or
**              other errors found in drmresults.h
**
** Notes:
**
**********************************************************************/

DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL DRM_RVS_GetRevocationData(
    __inout                                      DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    __in                                   const DRM_GUID                    *f_pRevGUID,
    __out_bcount_opt(*f_pcbRevocationData)       DRM_BYTE                    *f_pbRevocationData,
    __inout                                      DRM_DWORD                   *f_pcbRevocationData );

EXIT_PK_NAMESPACE;

#endif  /* __DRM_REVOCATIONSTORE_H__ */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmrsacommon.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMRSACOMMON_H__
#define __DRMRSACOMMON_H__

#include <byteorder.h>

ENTER_PK_NAMESPACE;

/*
** Supported key lengths
*/
typedef enum __tageDRM_RSA_SUPPORTED_KEY_LENGTHS
{
    eDRM_RSA_UNKNOWN = 0,
    eDRM_RSA_1024 = 1024,
    eDRM_RSA_2048 = 2048,
} DRM_RSA_SUPPORTED_KEY_LENGTHS;

/* Value cannot from enum because it used to define DRM_RSA_CB_PRIME_MAX that used for SAL annotations */
#define eDRM_RSA_MAXIMUM_KEY_LENGTH               2048

#if DRM_SUPPORT_WMDRMNET
#define IS_VALID_DRM_RSA_KEY_LENGTH( keyLength )  ( ( eDRM_RSA_1024 == ( keyLength ) )   \
                                                 || ( eDRM_RSA_2048 == ( keyLength ) ) )
#else /* DRM_SUPPORT_WMDRMNET */
#define IS_VALID_DRM_RSA_KEY_LENGTH( keyLength )  ( eDRM_RSA_1024 == ( keyLength ) )
#endif /* DRM_SUPPORT_WMDRMNET */

/*
** Primes are either 1024 or 2048 bits (128 or 256 bytes) each
*/
#define DRM_RSA_CB_PRIME( keyLength )           ( ( keyLength ) / BITS_PER_STANDARD_BYTE )
#define DRM_RSA_CB_PRIME_MAX                    DRM_RSA_CB_PRIME( eDRM_RSA_MAXIMUM_KEY_LENGTH )

/*
** Modulus is 128/256 bytes or 1024/2048 bits
*/
#define DRM_RSA_CB_MODULUS( keyLength )         DRM_RSA_CB_PRIME( keyLength )
#define DRM_RSA_CB_MODULUS_MAX                  DRM_RSA_CB_MODULUS( eDRM_RSA_MAXIMUM_KEY_LENGTH )

#define DRM_RSA_CBITS_MODULUS( keyLength )    ( DRM_RSA_CB_MODULUS( keyLength ) * BITS_PER_STANDARD_BYTE )
#define DRM_RSA_CBITS_MODULUS_MAX               DRM_RSA_CBITS_MODULUS( eDRM_RSA_MAXIMUM_KEY_LENGTH )

/*
** RSA ciphertext length is the same as the prime length
*/
#define DRM_RSA_CB_CIPHERTEXT( keyLength )      DRM_RSA_CB_MODULUS( keyLength )
#define DRM_RSA_CB_CIPHERTEXT_MAX               DRM_RSA_CB_CIPHERTEXT( eDRM_RSA_MAXIMUM_KEY_LENGTH )

/*
** Public and private exponent sizes
*/
#define DRM_RSA_CB_PUBEXP                       4
#define DRM_RSA_CB_PRIVEXP( keyLength )         DRM_RSA_CB_MODULUS( keyLength )
#define DRM_RSA_CB_PRIVEXP_MAX                  DRM_RSA_CB_PRIVEXP( eDRM_RSA_MAXIMUM_KEY_LENGTH )

/*
** For regular encryption (not large encryption) the plaintext must be smaller than the modulus
*/
#define DRM_RSA_CB_MAX_PLAINTEXT( keyLength ) ( DRM_RSA_CB_MODULUS( keyLength ) - ( 2 * DRM_SHA1_DIGEST_LEN + 2 ) )
#define DRM_RSA_CB_MAX_PLAINTEXT_MAX            DRM_RSA_CB_MAX_PLAINTEXT( eDRM_RSA_MAXIMUM_KEY_LENGTH )

EXIT_PK_NAMESPACE;

#endif /* _DRMRSACOMMON_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmrevocation.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMREVOCATION_H__
#define __DRMREVOCATION_H__

#include <drmcontextsizes.h>
#include <drmliceval.h>
#include <drmrevocationstore.h>

ENTER_PK_NAMESPACE;
#include <drmrevocationtypes.h>

#if DRM_SUPPORT_REVOCATION

#define DRM_ALL_REVOCATIONS NULL
DRM_API DRM_RESULT DRM_CALL DRM_RVK_GetCurrentRevocationInfo(
    IN     DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    IN     const DRM_GUID              *f_pguidRevocationType,
       OUT DRM_BYTE                    *f_pbBuffer,
    IN OUT DRM_DWORD                   *f_pcbBuffer,
       OUT DRM_RLVI                    *f_pRLVI,
    IN     DRM_CRYPTO_CONTEXT          *f_pCryptoCtx );

DRM_API DRM_RESULT DRM_CALL DRM_RVK_ProcessRevocationInfo (
    IN     DRM_CRYPTO_CONTEXT          *f_pContextCrypto,
    IN     DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    IN     DRM_ANSI_CONST_STRING       *f_pdastrLicenseResponse,
    IN     DRM_BYTE                    *f_pbRevocationBuffer,
    IN     DRM_DWORD                    f_cbRevocationBuffer,
    IN     APPCERT                     *f_pAppcert,
    IN OUT DRM_REVLIST_ID_VALUES       *f_pRevList );

DRM_API DRM_RESULT DRM_CALL DRM_RVK_UpdateRevocationVersionsCache(
 IN OUT DRM_REVOCATIONSTORE_CONTEXT  *f_pContextRev,
 IN     DRM_CRYPTO_CONTEXT           *f_pContextCrypto,
 IN OUT DRM_REVLIST_ID_VALUES        *f_pRevListIDs,
 IN     DRM_BYTE                     *f_pbRevocationBuffer,
 IN     DRM_DWORD                     f_cbRevocationBuffer,
    OUT DRM_BOOL                     *f_pfUpdated);

DRM_API DRM_RESULT DRM_CALL DRM_RVK_StoreRevInfo (
    IN     DRM_CRYPTO_CONTEXT          *f_pContextCrypto,
    IN     DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    IN     const DRM_GUID              *f_pguidRevocationType,
    IN     DRM_BYTE                    *f_pbRevocationInfo,
    IN     DRM_DWORD                    f_cbRevocationInfo,
    IN     DRM_BYTE                    *f_pbRevocationBuffer,
    IN     DRM_DWORD                    f_cbRevocationBuffer,
    IN OUT DRM_REVLIST_ID_VALUES       *f_pRevList,
       OUT DRM_BOOL                    *f_fWasStored );

DRM_RESULT DRM_RVK_StoreRevocationLists(
    IN     DRM_CRYPTO_CONTEXT    *f_pContextCrypto,
    IN     DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    IN     DRM_DWORD              f_cRevocationLists,
    IN     DRM_RVK_LIST          *f_pRevocationLists,
    IN     APPCERT               *f_pAppcert,
    IN     DRM_BYTE              *f_pbRevocationBuffer,
    IN     DRM_DWORD              f_cbRevocationBuffer,
    IN OUT DRM_REVLIST_ID_VALUES *f_pRevList );

DRM_API DRM_RESULT DRM_CALL DRM_RVK_FindEntryInRevInfo(
    __in                        DRM_RLVI    *f_prlvi,
    __in_bcount(f_cbRevInfo)    DRM_BYTE    *f_pbRevInfo,
    __in                        DRM_DWORD    f_cbRevInfo,
    __in                  const DRM_GUID    *f_pguidEntry,
    __out                       DRM_DWORD   *f_pdwVersion );

DRM_API DRM_RESULT DRM_CALL DRM_RVK_VerifyRevocationInfo(
    __in_bcount( f_cbRevInfo ) DRM_BYTE           *f_pbRevInfo,
    __in                       DRM_DWORD           f_cbRevInfo,
    __out                      DRM_RLVI           *f_pRLVI,
    __in                       DRM_CRYPTO_CONTEXT *f_pCryptoCtx,
    __in_opt                   DRM_BB_CONTEXT     *f_pcontextBBX,
    __in_opt                   DRM_SECSTORE_CONTEXT *f_pcontextSST,
    __in_opt                   DRM_DST            *f_pDatastore );

DRM_API DRM_RESULT DRM_CALL DRM_RVK_VerifyRevocationList(
    IN          DRM_CRYPTO_CONTEXT *f_pcontextCRYP,
    IN          DRM_CONST_STRING   *f_pdstrList,
    IN  const   PUBKEY             *f_ppubkey,
        OUT     DRM_DWORD          *f_pidSerial);

DRM_API DRM_RESULT DRM_CALL DRM_RVK_ProcessRevInfo(
    IN          DRM_CHAR                    *f_pszResponse,
    IN          DRM_SUBSTRING               *f_pdasstrRevType,
    IN          DRM_SUBSTRING               *f_pdasstrRevData,
    IN          DRM_CRYPTO_CONTEXT          *f_pcontextCRYP,
    IN          DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    IN          DRM_BYTE                    *f_pbRevocationBuffer,
    IN          DRM_DWORD                    f_cbRevocationBuffer,
    IN          APPCERT                     *f_pAppCert,
    IN          DRM_DWORD                    f_idCRLAppCurrent,
       OUT      DRM_BOOL                    *f_pfUpdatedAppRevocationList );

DRM_API DRM_RESULT DRM_CALL DRM_RVK_VerifyBinaryWMDRMNETSignature(
    IN     DRM_BYTE  *f_pbData,
    IN     DRM_DWORD  f_cbData,
    IN OUT DRM_DWORD *f_pidSerial);

DRM_API DRM_RESULT DRM_CALL DRM_RVK_StoreMsdbCRLPackage
(
    __inout                             DRM_REVOCATIONSTORE_CONTEXT *f_poRevContext,
    __inout_opt                         DRM_VOID                    *f_pOEMContext,
    __in_bcount(f_cbCRLData)      const DRM_BYTE                    *f_pbCRLData,
    __in                          const DRM_DWORD                    f_cbCRLData,
    __in_bcount( f_cbRevocationBuffer ) DRM_BYTE                    *f_pbRevocationBuffer,
    __in                          const DRM_DWORD                    f_cbRevocationBuffer
);


#define DRM_APP_REVOCATION_VERSION_NONE    0xFFFFFFFF

#if DRM_SUPPORT_APP_REVOCATION


DRM_API DRM_RESULT DRM_CALL DRM_RVK_GetCurrentAppRevocationList(
    IN      DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    __in_bcount( *f_pcbBuffer ) DRM_BYTE *f_pbBuffer,
    IN  OUT DRM_DWORD            *f_pcbBuffer,
    OUT     DRM_DWORD            *f_pidCRLApp);

DRM_API DRM_RESULT DRM_CALL DRM_RVK_PerformAppRevocationCheck(
    IN     DRM_CRYPTO_CONTEXT          *f_pContextCrypto,
    IN     DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    IN     DRM_CONST_STRING            *f_pdstrContentLicense,
    IN     APPCERT                     *f_pAppCert,
    __in_bcount( f_cbRevocationBuffer ) DRM_BYTE *f_pbRevocationBuffer,
    IN     DRM_DWORD                    f_cbRevocationBuffer,
    IN OUT DRM_REVLIST_ID_VALUES       *f_pRevListIDs );

DRM_API DRM_RESULT DRM_CALL DRM_RVK_CheckAppCertForRevocation(
    __in_bcount( f_cbBuffer ) DRM_BYTE *f_pbBuffer,
    IN  DRM_DWORD             f_cbBuffer,
    IN  APPCERT              *f_pappcert);

DRM_API DRM_RESULT DRM_CALL DRM_RVK_UpdateAppRevocationListA(
        DRM_CRYPTO_CONTEXT   *f_pcontextCRY,
        DRM_REVOCATIONSTORE_CONTEXT * f_pContextRev,
        __in_bcount( f_cbBuffer ) DRM_BYTE *f_pbBuffer,
        DRM_DWORD             f_cbBuffer,
        __in_ecount( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch ) DRM_CHAR *f_rgchBase,
  const DRM_SUBSTRING        *f_pdasstrRevocationList,
        APPCERT              *f_pappcert,
        DRM_DWORD             f_idCRLAppCurrent,
        DRM_BOOL             *f_pfUpdatedAppRevocationList);

DRM_API DRM_RESULT DRM_CALL DRM_RVK_UpdateAppRevocationListW(
    DRM_CRYPTO_CONTEXT   *f_pcontextCRY,
    DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    __in_bcount( f_cbBuffer ) DRM_BYTE *f_pbBuffer,
    DRM_DWORD             f_cbBuffer,
    DRM_CONST_STRING     *f_pdstrRevocationList,
    APPCERT              *f_pappcert,
    DRM_DWORD             f_idCRLAppCurrent,
    DRM_BOOL             *f_pfUpdatedAppRevocationList,
    OUT DRM_DWORD        *f_pdwVersion);

DRM_RESULT DRM_CALL DRM_RVK_UpdateAppRevocationListDecoded(
    DRM_CRYPTO_CONTEXT   *f_pcontextCRY,
    DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    __in_bcount( f_cbRevocationList ) DRM_BYTE *f_pbRevocationList,
    DRM_DWORD             f_cbRevocationList,
    APPCERT              *f_pappcert,
    DRM_DWORD             f_idCRLAppCurrent,
    DRM_BOOL             *f_pfUpdatedAppRevocationList,
    OUT DRM_DWORD        *f_pdwVersion);

#endif

#if DRM_SUPPORT_DEVICE_REVOCATION

DRM_RESULT DRM_RVK_UpdateRevocationList(
    IN          DRM_CRYPTO_CONTEXT   *f_pcontextCrypto,
    IN          DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    __in_ecount( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch ) DRM_CHAR *f_rgchBase,
    IN  const   DRM_SUBSTRING        *f_pdasstrRevocationList,
    __in_bcount( f_cbRevocationBuffer ) DRM_BYTE *f_pbRevocationBuffer,
    IN          DRM_DWORD             f_cbRevocationBuffer,
    IN  const   DRM_GUID             *f_pGUID,
    IN  const   PUBKEY               *f_ppubkey );

DRM_API DRM_RESULT DRM_CALL DRM_RVK_GetDeviceRevocationList(
    IN     DRM_CRYPTO_CONTEXT   *f_pcontextCRYP,
    IN     DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    __out_bcount_opt( *f_pcbRevocationData ) DRM_BYTE *f_pbRe