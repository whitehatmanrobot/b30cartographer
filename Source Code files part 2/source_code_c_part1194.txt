/
NTSTATUS CMUSB_CreateClose(
                          IN PDEVICE_OBJECT DeviceObject,
                          IN PIRP Irp
                          )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   PDEVICE_EXTENSION DeviceExtension;
   PSMARTCARD_EXTENSION  SmartcardExtension;
   PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!CreateClose: Enter\n",DRIVER_NAME));

   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;

   //
   //	dispatch major function
   //
   switch (IrpStack->MajorFunction)
      {
      case IRP_MJ_CREATE:
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!CreateClose: IRP_MJ_CREATE\n",DRIVER_NAME));
         if (DeviceExtension->RemoveDeviceRequested)
            {
            NTStatus = STATUS_DEVICE_BUSY;
            }
         else
            {
            if (InterlockedIncrement(&DeviceExtension->lOpenCount) > 1)
               {
               InterlockedDecrement(&DeviceExtension->lOpenCount);
               NTStatus = STATUS_ACCESS_DENIED;
               }
            }
         break;

      case IRP_MJ_CLOSE:
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!CreateClose: IRP_MJ_CLOSE\n",DRIVER_NAME));
         if (InterlockedDecrement(&DeviceExtension->lOpenCount) < 0)
            {
            InterlockedIncrement(&DeviceExtension->lOpenCount);
            }

         // check if the device has been removed
         // if so free the resources
         if (DeviceExtension->DeviceRemoved == TRUE)
            {
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!CreateClose: freeing resources\n",DRIVER_NAME));

            if (DeviceExtension->fPnPResourceManager == FALSE)
               {
               //
               // Free all allocated buffer
               //
               ExFreePool(DeviceExtension->DosDeviceName.Buffer);
               }

            ExFreePool(SmartcardExtension->ReaderExtension);
            SmartcardExtension->ReaderExtension = NULL;
            //
            // Let the lib free the send/receive buffers
            //
            SmartcardExit(SmartcardExtension);
            }

         break;


      default:
         //
         // unrecognized command
         //
         NTStatus = STATUS_INVALID_DEVICE_REQUEST;
         break;
      }

   Irp->IoStatus.Information = 0;
   Irp->IoStatus.Status = NTStatus;
   IoCompleteRequest(Irp, IO_NO_INCREMENT);

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!CreateClose: Exit %lx\n",DRIVER_NAME,NTStatus));
   return NTStatus;
}


/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_Transmit(
                       IN PSMARTCARD_EXTENSION SmartcardExtension
                       )
{
   NTSTATUS NTStatus;

   //this seems to make problems in Windows 98
   //KeSetPriorityThread(KeGetCurrentThread(),HIGH_PRIORITY);


   switch (SmartcardExtension->CardCapabilities.Protocol.Selected)
      {
      case SCARD_PROTOCOL_RAW:
         NTStatus = STATUS_INVALID_DEVICE_REQUEST;
         break;

      case SCARD_PROTOCOL_T0:

         NTStatus = CMUSB_TransmitT0(SmartcardExtension);

         break;

      case SCARD_PROTOCOL_T1:
         NTStatus = CMUSB_TransmitT1(SmartcardExtension);
         break;

      default:
         NTStatus = STATUS_INVALID_DEVICE_REQUEST;
         break;

      }
   //KeSetPriorityThread(KeGetCurrentThread(),LOW_REALTIME_PRIORITY);

   return NTStatus;

}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_ResetT0ReadBuffer(
                                PSMARTCARD_EXTENSION SmartcardExtension
                                )
{

   SmartcardExtension->ReaderExtension->T0ReadBuffer_OffsetLastByte     = -1;
   SmartcardExtension->ReaderExtension->T0ReadBuffer_OffsetLastByteRead = -1;

   return STATUS_SUCCESS;
}



/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_ReadT0(
                     PSMARTCARD_EXTENSION SmartcardExtension
                     )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   NTSTATUS DebugStatus;
   LONG  lBytesToRead;
   LONG  lBytesRead;
   LONG  lLastByte;
   LONG  lLastByteRead;
   PDEVICE_EXTENSION DeviceExtension;
   PUSBD_PIPE_INFORMATION pipeHandle = NULL;
   PUSBD_INTERFACE_INFORMATION interface;


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ReadT0: Enter\n",DRIVER_NAME));


   DeviceExtension =  SmartcardExtension->OsData->DeviceObject->DeviceExtension;
   interface       = DeviceExtension->UsbInterface;
   pipeHandle      =  &interface->Pipes[0];

   lBytesToRead = (LONG)SmartcardExtension->SmartcardReply.BufferLength;
   lLastByte     = SmartcardExtension->ReaderExtension->T0ReadBuffer_OffsetLastByte;
   lLastByteRead = SmartcardExtension->ReaderExtension->T0ReadBuffer_OffsetLastByteRead;

   // check if further bytes must be read from pipe 1
   while (lLastByteRead + lBytesToRead > lLastByte)
      {
      SmartcardExtension->SmartcardReply.BufferLength = 1;
      SmartcardExtension->ReaderExtension->ulTimeoutP1 = 1000 +
                                                         (ULONG)((SmartcardExtension->CardCapabilities.T0.WT/1000) * lBytesToRead);
      NTStatus = CMUSB_ReadP1(SmartcardExtension->OsData->DeviceObject);
      if (NTStatus == STATUS_DEVICE_DATA_ERROR)
         {
         DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);
         goto ExitReadT0;
         }
      else if (NTStatus != STATUS_SUCCESS)
         {
         goto ExitReadT0;
         }


      lBytesRead = (LONG)SmartcardExtension->SmartcardReply.BufferLength;

      RtlCopyBytes((PVOID)(SmartcardExtension->ReaderExtension->T0ReadBuffer + (lLastByte +1)),
                   (PVOID)SmartcardExtension->SmartcardReply.Buffer,
                   lBytesRead);

      lLastByte  += lBytesRead;


      } // end of while

   // copy bytes
   SmartcardExtension->SmartcardReply.BufferLength  = lBytesToRead;
   RtlCopyBytes ((PVOID)SmartcardExtension->SmartcardReply.Buffer,
                 (PVOID)(SmartcardExtension->ReaderExtension->T0ReadBuffer + (lLastByteRead +1)),
                 lBytesToRead);

   lLastByteRead  += lBytesToRead;

/*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!lBytesToRead=%ld lLastByte=%ld lLastByteRead=%ld\n",
                   DRIVER_NAME,
                   lBytesToRead,
                   lLastByte,
                   lLastByteRead)
                 );
*/


   SmartcardExtension->ReaderExtension->T0ReadBuffer_OffsetLastByte     = lLastByte;
   SmartcardExtension->ReaderExtension->T0ReadBuffer_OffsetLastByteRead = lLastByteRead;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ReadT0: Exit %lx\n",DRIVER_NAME,NTStatus));

   ExitReadT0:
   return NTStatus;
}


/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
#define T0_HEADER_LEN               0x05
#define T0_STATE_LEN                0x02
#define TIMEOUT_CANCEL_READ_P1     30000

NTSTATUS CMUSB_TransmitT0(
                         PSMARTCARD_EXTENSION SmartcardExtension
                         )
{
   NTSTATUS NTStatus;
   NTSTATUS DebugStatus;
   UCHAR    bWriteBuffer[CMUSB_BUFFER_SIZE];
   UCHAR    bReadBuffer [CMUSB_BUFFER_SIZE];
   ULONG    ulWriteBufferOffset;
   ULONG    ulReadBufferOffset;
   ULONG    ulBytesToWrite;
   ULONG    ulBytesToRead;
   ULONG    ulBytesToWriteThisStep;
   ULONG    ulBytesToReadThisStep;
   ULONG    ulBytesStillToWrite;
   ULONG    ulBytesRead;
   ULONG    ulBytesStillToRead;
   BOOLEAN  fDataDirectionFromCard;
   BYTE     bProcedureByte;
   BYTE     bINS;
   BOOLEAN  fT0TransferToCard;
   BOOLEAN  fT0TransferFromCard;
   BOOLEAN  fSW1SW2Sent;
   ULONG    ulUsedCWT;
   UCHAR    bUsedCWTHi;
   LARGE_INTEGER liTimeout;
   PDEVICE_EXTENSION DeviceExtension;
   UCHAR    bTmp;
   ULONG    i;
   PUSBD_PIPE_INFORMATION pipeHandle = NULL;
   PUSBD_INTERFACE_INFORMATION interface;


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!TransmitT0 : Enter\n",DRIVER_NAME));

   fT0TransferToCard = FALSE;
   fT0TransferFromCard = FALSE;
   fSW1SW2Sent = FALSE;

   // resync CardManUSB by reading the NTStatus byte
   SmartcardExtension->SmartcardRequest.BufferLength = 0;
   NTStatus = CMUSB_WriteP0(SmartcardExtension->OsData->DeviceObject,
                            0x20,         //bRequest,
                            0x00,         //bValueLo,
                            0x00,         //bValueHi,
                            0x00,         //bIndexLo,
                            0x00          //bIndexHi,
                           );

   if (NTStatus != STATUS_SUCCESS)
      {
      // if we can't read the NTStatus there must be a serious error
      goto ExitTransmitT0;
      }

   SmartcardExtension->ReaderExtension->ulTimeoutP1 = DEFAULT_TIMEOUT_P1;
   SmartcardExtension->SmartcardReply.BufferLength = 1;
   NTStatus = CMUSB_ReadP1(SmartcardExtension->OsData->DeviceObject);
   if (NTStatus == STATUS_DEVICE_DATA_ERROR)
      {
      DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);
      goto ExitTransmitT0;
      }
   else if (NTStatus != STATUS_SUCCESS)
      {
      // if we can't read the NTStatus there must be a serious error
      goto ExitTransmitT0;
      }



   DeviceExtension =  SmartcardExtension->OsData->DeviceObject->DeviceExtension;
   interface       = DeviceExtension->UsbInterface;
   pipeHandle      =  &interface->Pipes[0];

   SmartcardExtension->ReaderExtension->ulTimeoutP1 = (ULONG)(SmartcardExtension->CardCapabilities.T0.WT/1000);


   //
   // Let the lib build a T=0 packet
   //

   SmartcardExtension->SmartcardRequest.BufferLength = 0;  // no bytes additionally needed
   NTStatus = SmartcardT0Request(SmartcardExtension);
   if (NTStatus != STATUS_SUCCESS)
      {
      //
      // This lib detected an error in the data to send.
      //
      goto ExitTransmitT0;
      }


   ulBytesStillToWrite = ulBytesToWrite = T0_HEADER_LEN + SmartcardExtension->T0.Lc;
   ulBytesStillToRead  = ulBytesToRead  = SmartcardExtension->T0.Le;
   if (SmartcardExtension->T0.Lc)
      fT0TransferToCard = TRUE;
   if (SmartcardExtension->T0.Le)
      fT0TransferFromCard = TRUE;



   // ----------------------------
   // smart card ==> CardMan USB
   // ----------------------------
   if (fT0TransferFromCard)
      {
      SmartcardDebug(DEBUG_PROTOCOL,
                     ("%s!TransmitT0: MODE 3\n",DRIVER_NAME));

      // granularity 256 ms
      ulUsedCWT = (ULONG)(SmartcardExtension->CardCapabilities.T0.WT/1000);
      SmartcardDebug(DEBUG_PROTOCOL,
                     ("%s!TransmitT0: ulUsedCWT= %ld\n",DRIVER_NAME,ulUsedCWT));

      bUsedCWTHi = (UCHAR)(((ulUsedCWT & 0x0000FF00)>>8) + 1 + 5) ;

      // copy data to the write buffer
      SmartcardDebug(DEBUG_PROTOCOL,
                     ("%s!TransmitT0: CLA = %x INS = %x P1 = %x P2 = %x L = %x\n", DRIVER_NAME,
                      SmartcardExtension->SmartcardRequest.Buffer[0],
                      SmartcardExtension->SmartcardRequest.Buffer[1],
                      SmartcardExtension->SmartcardRequest.Buffer[2],
                      SmartcardExtension->SmartcardRequest.Buffer[3],
                      SmartcardExtension->SmartcardRequest.Buffer[4]));


      RtlCopyBytes((PVOID)bWriteBuffer,
                   (PVOID)SmartcardExtension->SmartcardRequest.Buffer,
                   ulBytesToWrite);

      bINS = bWriteBuffer[1];

      ulWriteBufferOffset = 0;
      ulReadBufferOffset = 0;


      // STEP 1 : write CLA INS P1 P2 Lc

      ulBytesToWriteThisStep = 5;
      RtlCopyBytes((PVOID)(SmartcardExtension->SmartcardRequest.Buffer),
                   (PVOID)(bWriteBuffer+ulWriteBufferOffset),
                   ulBytesToWriteThisStep);

      if (SmartcardExtension->ReaderExtension->fInverseAtr == TRUE)
         {
         CMUSB_InverseBuffer(SmartcardExtension->SmartcardRequest.Buffer,
                             SmartcardExtension->SmartcardRequest.BufferLength);
         }

      SmartcardExtension->SmartcardReply.BufferLength = 512;
      NTStatus = CMUSB_ReadP1_T0(SmartcardExtension->OsData->DeviceObject);
      if (NTStatus != STATUS_SUCCESS)
         {
         SmartcardDebug(DEBUG_PROTOCOL,
                        ("%s!TransmitT0: CMUSB_ReadP1_T0 returned = %x\n",DRIVER_NAME,NTStatus));
         goto ExitTransmitT0;
         }


      SmartcardExtension->SmartcardRequest.BufferLength = ulBytesToWriteThisStep;
      NTStatus = CMUSB_WriteP0(SmartcardExtension->OsData->DeviceObject,
                               0x03,                       // mode 3
                               bUsedCWTHi,                 //bValueLo,
                               0x00,                       //bValueHi,
                               (UCHAR)(ulBytesToRead%256), //bIndexLo,
                               (UCHAR)(SmartcardExtension->SmartcardRequest.Buffer[1]) //bIndexHi,
                              );
      if (NTStatus != STATUS_SUCCESS)
         {
         SmartcardDebug(DEBUG_PROTOCOL,
                        ("%s!TransmitT0: CMUSB_WriteP0 returned %x\n",DRIVER_NAME,NTStatus));
         goto ExitTransmitT0;
         }




      liTimeout = RtlConvertLongToLargeInteger(TIMEOUT_CANCEL_READ_P1 * -10000);

      SmartcardDebug(DEBUG_PROTOCOL,
                     ("%s!TransmitT0: waiting for P1 event\n",DRIVER_NAME,NTStatus));

      NTStatus = KeWaitForSingleObject(&DeviceExtension->ReadP1Completed,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       &liTimeout);

      // -----------------------------
      // check if P1 has been stalled
      // -----------------------------
      if (SmartcardExtension->ReaderExtension->fP1Stalled == TRUE)
         {
         SmartcardDebug(DEBUG_PROTOCOL,
                        ("%s!STransmitT0: TATUS_DEVICE_DATA_ERROR\n",DRIVER_NAME));
         NTStatus = STATUS_DEVICE_DATA_ERROR;

         // P1 has been stalled ==> we must reset the pipe and send a NTStatus to enable it again
         DebugStatus = CMUSB_ResetPipe(SmartcardExtension->OsData->DeviceObject,
                                       pipeHandle);

         DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);

         SmartcardExtension->SmartcardReply.BufferLength = 0;
         goto ExitTransmitT0;
         }
      // -------------------------------
      // check if a timeout has occured
      // -------------------------------
      else if (NTStatus == STATUS_TIMEOUT)
         {
         // probably the smart card does not work
         // cancel T0 read operation by sending any P0 command
         SmartcardDebug(DEBUG_PROTOCOL,
                        ("%s!TransmitT0: cancelling read operation\n",DRIVER_NAME));
         SmartcardExtension->SmartcardRequest.BufferLength = 0;
         NTStatus = CMUSB_WriteP0(SmartcardExtension->OsData->DeviceObject,
                                  0x20,         //bRequest,
                                  0x00,         //bValueLo,
                                  0x00,         //bValueHi,
                                  0x00,         //bIndexLo,
                                  0x00          //bIndexHi,
                                 );

         NTStatus = STATUS_IO_TIMEOUT;
         goto ExitTransmitT0;
         }
      // -------------------------------------------
      // check if at least 9 bytes have been sent
      // -------------------------------------------
      else if (SmartcardExtension->SmartcardReply.BufferLength < 9)
         {
         NTStatus = STATUS_UNSUCCESSFUL;
         goto ExitTransmitT0;
         }
      else
         {


#if DBG
         SmartcardDebug(DEBUG_PROTOCOL,
                        ("%s!<==[P1] ",DRIVER_NAME));
         for (i=0;i< SmartcardExtension->SmartcardReply.BufferLength;i++)
            {
            bTmp =  SmartcardExtension->SmartcardReply.Buffer[i];
            if (SmartcardExtension->ReaderExtension->fInverseAtr &&
                SmartcardExtension->ReaderExtension->ulTimeoutP1 != DEFAULT_TIMEOUT_P1)
               {
               //CMUSB_InverseBuffer(&bTmp,1);
               SmartcardDebug(DEBUG_PROTOCOL,("%x ",bTmp));
               }
            else
               {
               SmartcardDebug(DEBUG_PROTOCOL,("%x ",bTmp));
               }
            }
         SmartcardDebug(DEBUG_PROTOCOL,
                        ("(%ld)\n",SmartcardExtension->SmartcardReply.BufferLength));
#endif

         // ignore the first 8 dummy bytes
         SmartcardExtension->SmartcardReply.BufferLength -= 8;
         RtlCopyBytes((PVOID)(bReadBuffer),
                      (PVOID)(SmartcardExtension->SmartcardReply.Buffer+8),
                      SmartcardExtension->SmartcardReply.BufferLength);

         RtlCopyBytes((PVOID)(SmartcardExtension->SmartcardReply.Buffer),
                      (PVOID)(bReadBuffer),
                      SmartcardExtension->SmartcardReply.BufferLength);

         if (SmartcardExtension->ReaderExtension->fInverseAtr)
            {
            CMUSB_InverseBuffer(SmartcardExtension->SmartcardReply.Buffer,
                                SmartcardExtension->SmartcardReply.BufferLength);
            }

         }
      }

   // -----------------------------
   // CardMan USB ==> smart card or
   // no transfer
   // -----------------------------
   else
      {


      SmartcardDebug(DEBUG_PROTOCOL,
                     ("%s!TransmitT0: MODE 2\n",DRIVER_NAME));

      // copy data to the write buffer
      SmartcardDebug(DEBUG_PROTOCOL,
                     ("%s!TransmitT0: CLA = %x INS = %x P1 = %x P2 = %X L = %x\n",DRIVER_NAME,
                      SmartcardExtension->SmartcardRequest.Buffer[0],
                      SmartcardExtension->SmartcardRequest.Buffer[1],
                      SmartcardExtension->SmartcardRequest.Buffer[2],
                      SmartcardExtension->SmartcardRequest.Buffer[3],
                      SmartcardExtension->SmartcardRequest.Buffer[4]));


      RtlCopyBytes((PVOID)bWriteBuffer,
                   (PVOID)SmartcardExtension->SmartcardRequest.Buffer,
                   ulBytesToWrite);




      // SendingToCard:

      ulWriteBufferOffset = 0;
      ulReadBufferOffset = 0;
      bINS = bWriteBuffer[1];



      // STEP 1 : write CLA INS P1 P2 Lc

      ulBytesToWriteThisStep = 5;
      RtlCopyBytes((PVOID)(SmartcardExtension->SmartcardRequest.Buffer),
                   (PVOID)(bWriteBuffer+ulWriteBufferOffset),
                   ulBytesToWriteThisStep);
      SmartcardExtension->SmartcardRequest.BufferLength = ulBytesToWriteThisStep;

      if (SmartcardExtension->ReaderExtension->fInverseAtr == TRUE)
         {
         CMUSB_InverseBuffer(SmartcardExtension->SmartcardRequest.Buffer,
                             SmartcardExtension->SmartcardRequest.BufferLength);
         }


      NTStatus = CMUSB_WriteP0(SmartcardExtension->OsData->DeviceObject,
                               0x02,         //T=0
                               0x00,         //bValueLo,
                               0x00,         //bValueHi,
                               0x00,         //bIndexLo,
                               0x00          //bIndexHi,
                              );
      if (NTStatus != STATUS_SUCCESS)
         {
         goto ExitTransmitT0;
         }


      ulWriteBufferOffset += ulBytesToWriteThisStep;
      ulBytesStillToWrite -= ulBytesToWriteThisStep;

      NTStatus = CMUSB_ResetT0ReadBuffer(SmartcardExtension);

      // STEP 2 : read procedure byte
      do
         {
         do
            {
            SmartcardExtension->SmartcardReply.BufferLength = 1;
            NTStatus = CMUSB_ReadT0(SmartcardExtension);
            if (NTStatus != STATUS_SUCCESS)
               {
               goto ExitTransmitT0;
               }
            ulBytesRead = SmartcardExtension->SmartcardReply.BufferLength;
            bProcedureByte = SmartcardExtension->SmartcardReply.Buffer[0];

            if (SmartcardExtension->ReaderExtension->fInverseAtr)
               {
               CMUSB_InverseBuffer(&bProcedureByte,1);
               }

            SmartcardDebug(DEBUG_PROTOCOL,
                           ("%s!TransmitT0: procedure byte = %x\n",
                            DRIVER_NAME,
                            bProcedureByte));
            if (bProcedureByte == 0x60)
               {
               // wait work waitung time;
               // we just try to read again
               }
            } while (bProcedureByte == 0x60);


         // check for ACK
         if ((bProcedureByte & 0xFE) ==  (bINS & 0xFE) )
            {
            ulBytesToWriteThisStep = ulBytesStillToWrite;
            if (ulBytesToWriteThisStep > 0) // at least one byte must be sent to the card
               {
               RtlCopyBytes((PVOID)(SmartcardExtension->SmartcardRequest.Buffer),
                            (PVOID)(bWriteBuffer+ulWriteBufferOffset),
                            ulBytesToWriteThisStep);

               SmartcardExtension->SmartcardRequest.BufferLength = ulBytesToWriteThisStep;
               if (SmartcardExtension->ReaderExtension->fInverseAtr == TRUE)
                  {
                  CMUSB_InverseBuffer(SmartcardExtension->SmartcardRequest.Buffer,
                                      SmartcardExtension->SmartcardRequest.BufferLength);
                  }
               NTStatus = CMUSB_WriteP0(SmartcardExtension->OsData->DeviceObject,
                                        0x02,         //bRequest,
                                        0x00,         //bValueLo,
                                        0x00,         //bValueHi,
                                        0x00,         //bIndexLo,
                                        0x00          //bIndexHi,
                                       );
               if (NTStatus != STATUS_SUCCESS)
                  {
                  goto ExitTransmitT0;
                  }
               ulWriteBufferOffset += ulBytesToWriteThisStep;
               ulBytesStillToWrite -= ulBytesToWriteThisStep;
               }
            }
         // check for NAK
         else if ( (~bProcedureByte & 0xFE) == (bINS & 0xFE))
            {
            ulBytesToWriteThisStep = 1;
            RtlCopyBytes((PVOID)SmartcardExtension->SmartcardRequest.Buffer,
                         (PVOID)(bWriteBuffer+ulWriteBufferOffset),
                         ulBytesToWriteThisStep);

            SmartcardExtension->SmartcardRequest.BufferLength = ulBytesToWriteThisStep;
            if (SmartcardExtension->ReaderExtension->fInverseAtr == TRUE)
               {
               CMUSB_InverseBuffer(SmartcardExtension->SmartcardRequest.Buffer,
                                   SmartcardExtension->SmartcardRequest.BufferLength);
               }
            NTStatus = CMUSB_WriteP0(SmartcardExtension->OsData->DeviceObject,
                                     0x02,         //bRequest,
                                     0x00,         //bValueLo,
                                     0x00,         //bValueHi,
                                     0x00,         //bIndexLo,
                                     0x00          //bIndexHi,
                                    );
            if (NTStatus != STATUS_SUCCESS)
               {
               goto ExitTransmitT0;
               }
            ulWriteBufferOffset += ulBytesToWriteThisStep;
            ulBytesStillToWrite -= ulBytesToWriteThisStep;

            }
         // check for SW1
         else if ( (bProcedureByte > 0x60 && bProcedureByte <= 0x6F) ||
                   (bProcedureByte >= 0x90 && bProcedureByte <= 0x9F)   )
            {
            bReadBuffer[ulReadBufferOffset] = SmartcardExtension->SmartcardReply.Buffer[0];
            ulReadBufferOffset++;

            SmartcardExtension->SmartcardReply.BufferLength = 1;
            NTStatus = CMUSB_ReadT0(SmartcardExtension);
            if (NTStatus != STATUS_SUCCESS)
               {
               goto ExitTransmitT0;
               }
            ulBytesRead = SmartcardExtension->SmartcardReply.BufferLength;
            RtlCopyBytes((PVOID)(bReadBuffer + ulReadBufferOffset),
                         (PVOID)(SmartcardExtension->SmartcardReply.Buffer),
                         SmartcardExtension->SmartcardReply.BufferLength);
            ulReadBufferOffset += ulBytesRead;

            fSW1SW2Sent = TRUE;
            }
         else
            {
            NTStatus =  STATUS_UNSUCCESSFUL;
            goto ExitTransmitT0;
            }

         }while (!fSW1SW2Sent);

      if (SmartcardExtension->ReaderExtension->fInverseAtr)
         {
         CMUSB_InverseBuffer(bReadBuffer,
                             ulReadBufferOffset);
         }

      // copy received bytes
      RtlCopyBytes((PVOID)SmartcardExtension->SmartcardReply.Buffer,
                   (PVOID)bReadBuffer,
                   ulReadBufferOffset);
      SmartcardExtension->SmartcardReply.BufferLength = ulReadBufferOffset;

      }


   // let the lib copy the received bytes to the user buffer
   NTStatus = SmartcardT0Reply(SmartcardExtension);



   ExitTransmitT0:

   // ------------------------------------------
   // ITSEC E2 requirements: clear write buffers
   // ------------------------------------------
   RtlFillMemory((PVOID)bWriteBuffer,sizeof(bWriteBuffer),0x00);
   RtlFillMemory((PVOID)SmartcardExtension->SmartcardRequest.Buffer,
                 SmartcardExtension->SmartcardRequest.BufferSize,0x00);

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!TransmitT0 : Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}
#undef T0_HEADER_LEN
#undef T0_STATE_LEN
#undef TIMEOUT_CANCEL_READ_P1






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_TransmitT1(
                         PSMARTCARD_EXTENSION SmartcardExtension
                         )
{
   NTSTATUS NTStatus;
   NTSTATUS DebugStatus;
   ULONG  ulBytesToRead;
   ULONG  ulCurrentWaitTime;
   ULONG  ulWTXWaitTime;
   LARGE_INTEGER   waitTime;
   BOOLEAN         fStateTimer;
   ULONG   ulTemp;
   PDEVICE_EXTENSION DeviceExtension;
   PUSBD_INTERFACE_INFORMATION interface;
   PUSBD_PIPE_INFORMATION pipeHandle = NULL;
   BOOLEAN   fCancelTimer = FALSE;
   BYTE bTemp;
   BYTE  bMultiplier;

   SmartcardDebug(DEBUG_PROTOCOL,
                  ("%s!TransmitT1: CWT = %ld(ms)\n",DRIVER_NAME,
                   SmartcardExtension->CardCapabilities.T1.CWT/1000));
   SmartcardDebug(DEBUG_PROTOCOL,
                  ("%s!TransmitT1: BWT = %ld(ms)\n",DRIVER_NAME,
                   SmartcardExtension->CardCapabilities.T1.BWT/1000));


   DeviceExtension = SmartcardExtension->OsData->DeviceObject->DeviceExtension;
   interface       = DeviceExtension->UsbInterface;
   pipeHandle      =  &interface->Pipes[0];


   ulCurrentWaitTime = (ULONG)(1000 + SmartcardExtension->CardCapabilities.T1.BWT/1000);
   ulWTXWaitTime     = 0;

   do
      {


      SmartcardExtension->SmartcardRequest.BufferLength = 0;


      NTStatus = SmartcardT1Request(SmartcardExtension);
      if (NTStatus != STATUS_SUCCESS)
         {
         // this should never happen, so we return immediately
         goto ExitTransmitT1;
         }



      NTStatus = CMUSB_WriteP0(SmartcardExtension->OsData->DeviceObject,
                               0x01,         //T=1
                               0x00,         //bValueLo,
                               0x00,         //bValueHi,
                               0x00,         //bIndexLo,
                               0x00          //bIndexHi,
                              );

      if (NTStatus != STATUS_SUCCESS)
         break;  // there must be severe error

      if (ulWTXWaitTime ==  0 ) // use BWT
         {
         /*
         SmartcardDebug(
            DEBUG_TRACE,
            ( "%s!ulCurrentWaitTime = %ld\n",
              DRIVER_NAME,ulCurrentWaitTime)
            );
         */
         waitTime = RtlConvertLongToLargeInteger(ulCurrentWaitTime * -10000);
         }
      else // use WTX time
         {
         /*
         SmartcardDebug(
            DEBUG_TRACE,
            ( "%s!ulCurrentWaitTime = %ld\n",
              DRIVER_NAME,ulWTXWaitTime)
            );
         */
         waitTime = RtlConvertLongToLargeInteger(ulWTXWaitTime * -10000);
         }
      KeSetTimer(&SmartcardExtension->ReaderExtension->WaitTimer,
                 waitTime,
                 NULL);
      // timer is now in the queue
      fCancelTimer = TRUE;
      ulTemp = 0;
      do
         {
         NTStatus = CMUSB_ReadP1(SmartcardExtension->OsData->DeviceObject);
         if (NTStatus == STATUS_DEVICE_DATA_ERROR)
            {
            DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);
            goto ExitTransmitT1;
            }

         fStateTimer = KeReadStateTimer(&SmartcardExtension->ReaderExtension->WaitTimer);
         if (fStateTimer == TRUE)
            {
            // timer has been removed from the queue
            fCancelTimer = FALSE;
            SmartcardDebug(DEBUG_PROTOCOL,
                           ("%s!TransmitT1: T1 card does not respond in time\n",DRIVER_NAME));
            NTStatus = STATUS_IO_TIMEOUT;
            break;
            }

         if (SmartcardExtension->SmartcardReply.Buffer[0] >= 3)
            {
            if (SmartcardExtension->SmartcardReply.Buffer[1] > ulTemp)
               {
               // restart CWT for 32 bytes
               ulCurrentWaitTime = (ULONG)(100 + 32*(SmartcardExtension->CardCapabilities.T1.CWT/1000));
               waitTime = RtlConvertLongToLargeInteger(ulCurrentWaitTime * -10000);
               KeSetTimer(&SmartcardExtension->ReaderExtension->WaitTimer,
                          waitTime,
                          NULL);
               // timer is in the queue
               fCancelTimer = TRUE;
               ulTemp = SmartcardExtension->SmartcardReply.Buffer[1];
               }
            else
               {
               // CardMan USB has not received further bytes
               // do nothing
               }

            }


         } while (SmartcardExtension->SmartcardReply.Buffer[0] < 3   ||
                  (SmartcardExtension->SmartcardReply.Buffer[0] !=
                   SmartcardExtension->SmartcardReply.Buffer[1] + 4 )  );


      // cancel timer now
      if (fCancelTimer == TRUE)
         {
         fCancelTimer = FALSE;
         KeCancelTimer(&SmartcardExtension->ReaderExtension->WaitTimer);
         // timer is removed from the queue
         }




      if (NTStatus != STATUS_SUCCESS)
         {
         SmartcardExtension->SmartcardReply.BufferLength = 0L;
         }
      else
         {
         ulBytesToRead = SmartcardExtension->SmartcardReply.Buffer[0];

         SmartcardExtension->SmartcardReply.BufferLength = SmartcardExtension->SmartcardReply.Buffer[0];
         NTStatus = CMUSB_ReadP0(SmartcardExtension->OsData->DeviceObject);

         }


      bTemp = SmartcardExtension->SmartcardReply.Buffer[1];
      bMultiplier = SmartcardExtension->SmartcardReply.Buffer[3];
      if (SmartcardExtension->ReaderExtension->fInverseAtr == TRUE)
         {
         CMUSB_InverseBuffer(&bTemp,1);
         CMUSB_InverseBuffer(&bMultiplier,1);
         }


      if (bTemp == T1_WTX_REQUEST)
         {
         SmartcardDebug(DEBUG_PROTOCOL,
                        ("%s!TransmitT1: T1_WTX_REQUEST received\n",DRIVER_NAME));

         ulWTXWaitTime = (ULONG)(1000 +
                                 bMultiplier * (SmartcardExtension->CardCapabilities.T1.BWT/1000));
         }
      else
         {
         ulWTXWaitTime = 0;
         }




      // bug fix for smclib
      if (SmartcardExtension->T1.State         == T1_IFS_RESPONSE &&
          SmartcardExtension->T1.OriginalState == T1_I_BLOCK)
         {
         SmartcardExtension->T1.State = T1_I_BLOCK;
         }

      NTStatus = SmartcardT1Reply(SmartcardExtension);
      }
   while (NTStatus == STATUS_MORE_PROCESSING_REQUIRED);



   ExitTransmitT1:
   // ------------------------------------------
   // ITSEC E2 requirements: clear write buffers
   // ------------------------------------------
   RtlFillMemory((PVOID)SmartcardExtension->SmartcardRequest.Buffer,
                 SmartcardExtension->SmartcardRequest.BufferSize,0x00);

   // timer will be cancelled here if there was an error
   if (fCancelTimer == TRUE)
      {
      KeCancelTimer(&SmartcardExtension->ReaderExtension->WaitTimer);
      // timer is removed from the queue
      }
   return NTStatus;
}


/*****************************************************************************
Routine Description:
This function sets the desired protocol . If necessary a PTS is performed


Arguments:  pointer to SMARTCARD_EXTENSION



Return Value: NT NTStatus

*****************************************************************************/
NTSTATUS CMUSB_SetProtocol(
                          PSMARTCARD_EXTENSION SmartcardExtension
                          )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   NTSTATUS DebugStatus;
   ULONG ulNewProtocol;
   UCHAR abPTSRequest[4];
   UCHAR abReadBuffer[6];
   UCHAR abPTSReply [4];
   ULONG ulBytesRead;
   LARGE_INTEGER   liWaitTime;
   BOOLEAN         fStateTimer;
   ULONG           ulWaitTime;
   PDEVICE_EXTENSION DeviceExtension;
   PUSBD_PIPE_INFORMATION pipeHandle = NULL;
   PUSBD_INTERFACE_INFORMATION interface;
   UCHAR bTemp;
   BOOLEAN fCancelTimer = FALSE;


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SetProtocol : Enter\n",DRIVER_NAME));

   DeviceExtension =  SmartcardExtension->OsData->DeviceObject->DeviceExtension;
   interface       = DeviceExtension->UsbInterface;
   pipeHandle      =  &interface->Pipes[0];


   //
   // Check if the card is already in specific state
   // and if the caller wants to have the already selected protocol.
   // We return success if this is the case.
   //

   if ((SmartcardExtension->CardCapabilities.Protocol.Selected & SmartcardExtension->MinorIoControlCode))
      {
      NTStatus = STATUS_SUCCESS;
      goto ExitSetProtocol;
      }

   ulNewProtocol = SmartcardExtension->MinorIoControlCode;



   while (TRUE)
      {

      // set initial character of PTS
      abPTSRequest[0] = 0xFF;

      // set the format character
      if (SmartcardExtension->CardCapabilities.Protocol.Supported &
          ulNewProtocol &
          SCARD_PROTOCOL_T1)
         {
         // select T=1 and indicate that PTS1 follows
         abPTSRequest[1] = 0x11;
         SmartcardExtension->CardCapabilities.Protocol.Selected =
         SCARD_PROTOCOL_T1;
         }
      else if (SmartcardExtension->CardCapabilities.Protocol.Supported &
               ulNewProtocol &
               SCARD_PROTOCOL_T0)
         {
         // select T=1 and indicate that PTS1 follows
         abPTSRequest[1] = 0x10;
         SmartcardExtension->CardCapabilities.Protocol.Selected =
         SCARD_PROTOCOL_T0;
         }
      else
         {
         NTStatus = STATUS_INVALID_DEVICE_REQUEST;
         goto ExitSetProtocol;
         }


      // CardMan USB support higher baudrates only for T=1
      // ==> Dl=1
      if (abPTSRequest[1] == 0x10)
         {
         SmartcardDebug(DEBUG_PROTOCOL,
                        ("%s! overwriting PTS1 for T=0\n",DRIVER_NAME));
         SmartcardExtension->CardCapabilities.PtsData.Dl = 0x01;
         }

      // set pts1 which codes Fl and Dl
      bTemp = (BYTE) (SmartcardExtension->CardCapabilities.PtsData.Fl << 4 |
                      SmartcardExtension->CardCapabilities.PtsData.Dl);

      switch (bTemp)
         {
         case 0x11:
         case 0x12:
         case 0x13:
         case 0x14:
         case 0x18:
         case 0x91:
         case 0x92:
         case 0x93:
         case 0x94:
         case 0x98:
            // do nothing
            // we support these Fl/Dl parameters
            break ;

         default:
            SmartcardDebug(DEBUG_PROTOCOL,
                           ("%s! overwriting PTS1(0x%x)\n",DRIVER_NAME,bTemp));
            // we must correct Fl/Dl
            SmartcardExtension->CardCapabilities.PtsData.Dl = 0x01;
            SmartcardExtension->CardCapabilities.PtsData.Fl = 0x01;
            bTemp = (BYTE) (SmartcardExtension->CardCapabilities.PtsData.Fl << 4 |
                            SmartcardExtension->CardCapabilities.PtsData.Dl);
            break;


         }

      abPTSRequest[2] = bTemp;

      // set pck (check character)
      abPTSRequest[3] = (BYTE)(abPTSRequest[0] ^ abPTSRequest[1] ^ abPTSRequest[2]);

      SmartcardDebug(DEBUG_PROTOCOL,
                     ("%s! writing PTS request\n",DRIVER_NAME));

      RtlCopyBytes((PVOID)SmartcardExtension->SmartcardRequest.Buffer,
                   (PVOID)abPTSRequest,
                   4);
      SmartcardExtension->SmartcardRequest.BufferLength = 4;
      NTStatus = CMUSB_WriteP0(SmartcardExtension->OsData->DeviceObject,
                               0x01,         //we can use T=1 setting for direct communication
                               0x00,         //bValueLo,
                               0x00,         //bValueHi,
                               0x00,         //bIndexLo,
                               0x00);        //bIndexHi,
      if (NTStatus != STATUS_SUCCESS)
         {
         SmartcardDebug(DEBUG_ERROR,
                        ("%s! writing PTS request failed\n",DRIVER_NAME));
         goto ExitSetProtocol;
         }


      // read back pts data
      SmartcardDebug(DEBUG_PROTOCOL,
                     ("%s! reading PTS reply\n",DRIVER_NAME));
      // maximim initial waiting time is 9600 * etu
      // => 1 sec is sufficient
      ulWaitTime = 1000;
      liWaitTime = RtlConvertLongToLargeInteger(ulWaitTime * -10000);
      KeSetTimer(&SmartcardExtension->ReaderExtension->WaitTimer,
                 liWaitTime,
                 NULL);
      // timer is now in the queue
      fCancelTimer = TRUE;

      do
         {
         SmartcardExtension->ReaderExtension->ulTimeoutP1 = ulWaitTime;
         DebugStatus = CMUSB_ReadP1(SmartcardExtension->OsData->DeviceObject);
         // -----------------------------
         // check if P1 has been stalled
         // -----------------------------
         if (SmartcardExtension->ReaderExtension->fP1Stalled == TRUE)
            {
            DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);

            SmartcardExtension->SmartcardReply.BufferLength = 0;
            goto ExitSetProtocol;
            }

         fStateTimer = KeReadStateTimer(&SmartcardExtension->ReaderExtension->WaitTimer);
         if (fStateTimer == TRUE)
            {
            // timer has timed out and has been removed from the queue
            fCancelTimer = FALSE;
            SmartcardDebug(DEBUG_PROTOCOL,
                           ("%s! Timeout while PTS reply\n",DRIVER_NAME));
            NTStatus = STATUS_IO_TIMEOUT;
            break;
            }



         } while (SmartcardExtension->SmartcardReply.Buffer[0] < 4 );


      if (fCancelTimer == TRUE)
         {
         fCancelTimer = FALSE;
         // timer is still in the queue, remove it
         KeCancelTimer(&SmartcardExtension->ReaderExtension->WaitTimer);
         }

      if (NTStatus == STATUS_IO_TIMEOUT)
         {
         if (SmartcardExtension->SmartcardReply.Buffer[0] == 3)
            {
            SmartcardExtension->SmartcardReply.BufferLength = 3;
            }
         else
            {
            if (SmartcardExtension->CardCapabilities.PtsData.Type !=
                PTS_TYPE_DEFAULT)
               {
               SmartcardDebug(DEBUG_PROTOCOL,
                              ("%s! PTS failed : Trying default parameters\n",DRIVER_NAME));

               // the card did either not reply or it replied incorrectly
               // so try default values
               SmartcardExtension->CardCapabilities.PtsData.Type = PTS_TYPE_DEFAULT;

               SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;
               NTStatus = CMUSB_CardPower(SmartcardExtension);
               continue;
               }
            goto ExitSetProtocol;
            }
         }
      else
         {
         SmartcardExtension->SmartcardReply.BufferLength = 4;
         }

      NTStatus = CMUSB_ReadP0(SmartcardExtension->OsData->DeviceObject);
      ulBytesRead = SmartcardExtension->SmartcardReply.BufferLength;
      if (NTStatus != STATUS_SUCCESS ||
          !(ulBytesRead == 4 || ulBytesRead == 3))
         {
         SmartcardDebug(DEBUG_ERROR,
                        ("%s! reading PTS reply failed\n",DRIVER_NAME));
         goto ExitSetProtocol;
         }

      RtlCopyBytes((PVOID)abPTSReply,
                   (PVOID)SmartcardExtension->SmartcardReply.Buffer,
                   ulBytesRead);


      if (ulBytesRead == 4 &&
          abPTSReply[0] == abPTSRequest[0] &&
          abPTSReply[1] == abPTSRequest[1] &&
          abPTSReply[2] == abPTSRequest[2] &&
          abPTSReply[3] == abPTSRequest[3] )
         {
         SmartcardDebug(DEBUG_PROTOCOL,
                        ("%s! PTS request and reply match\n",DRIVER_NAME));

         NTStatus = STATUS_SUCCESS;

         switch (abPTSRequest[2])
            {
            // Fl/Dl
            case 0x11:
               SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
               CMUSB_FREQUENCY_3_72MHZ + CMUSB_BAUDRATE_9600;
               break ;

            case 0x12:
               SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
               CMUSB_FREQUENCY_3_72MHZ + CMUSB_BAUDRATE_19200;
               break ;


            case 0x13:
               SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
               CMUSB_FREQUENCY_3_72MHZ + CMUSB_BAUDRATE_38400;
               break ;

            case 0x14:
               SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
               CMUSB_FREQUENCY_3_72MHZ + CMUSB_BAUDRATE_76800;
               break ;

            case 0x18:
               SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
               CMUSB_FREQUENCY_3_72MHZ + CMUSB_BAUDRATE_115200;
               break ;


            case 0x91:
               SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
               CMUSB_FREQUENCY_5_12MHZ + CMUSB_BAUDRATE_9600;
               break ;

            case 0x92:
               SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
               CMUSB_FREQUENCY_5_12MHZ + CMUSB_BAUDRATE_19200;
               break ;

            case 0x93:
               SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
               CMUSB_FREQUENCY_5_12MHZ + CMUSB_BAUDRATE_38400;
               break ;

            case 0x94:
               SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
               CMUSB_FREQUENCY_5_12MHZ + CMUSB_BAUDRATE_76800;
               break ;

            case 0x98:
               SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
               CMUSB_FREQUENCY_5_12MHZ + CMUSB_BAUDRATE_115200;
               break ;
            }

         break;
         }

      if (ulBytesRead == 3 &&
          abPTSReply[0] == abPTSRequest[0] &&
          (abPTSReply[1] & 0x7F) == (abPTSRequest[1] & 0x0F) &&
          abPTSReply[2] == (BYTE)(abPTSReply[0] ^ abPTSReply[1] ))
         {
         SmartcardDebug(DEBUG_PROTOCOL,
                        ("%s! short PTS reply received\n",DRIVER_NAME));

         NTStatus = STATUS_SUCCESS;

         if ((abPTSRequest[2] & 0x90) == 0x90)
            {
            SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
            CMUSB_FREQUENCY_5_12MHZ + CMUSB_BAUDRATE_9600;
            }
         else
            {
            SmartcardExtension->ReaderExtension->CardParameters.bBaudRate =
            CMUSB_FREQUENCY_3_72MHZ + CMUSB_BAUDRATE_9600;
            }

         break ;
         }


      if (SmartcardExtension->CardCapabilities.PtsData.Type !=
          PTS_TYPE_DEFAULT)
         {
         SmartcardDebug(DEBUG_PROTOCOL,
                        ("%s! PTS failed : Trying default parameters\n",DRIVER_NAME));

         // the card did either not reply or it replied incorrectly
         // so try default values
         SmartcardExtension->CardCapabilities.PtsData.Type = PTS_TYPE_DEFAULT;

         SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;
         NTStatus = CMUSB_CardPower(SmartcardExtension);
         continue;
         }

      // the card failed the pts request
      NTStatus = STATUS_DEVICE_PROTOCOL_ERROR;
      goto ExitSetProtocol;
      }


   ExitSetProtocol:
   switch (NTStatus)
      {
      case STATUS_IO_TIMEOUT:
         SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
         *SmartcardExtension->IoRequest.Information = 0;
         break;


      case STATUS_SUCCESS:

         // now indicate that we're in specific mode
         SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;

         // return the selected protocol to the caller
         *(PULONG) SmartcardExtension->IoRequest.ReplyBuffer =
         SmartcardExtension->CardCapabilities.Protocol.Selected;

         *SmartcardExtension->IoRequest.Information =
         sizeof(SmartcardExtension->CardCapabilities.Protocol.Selected);
         SmartcardDebug(DEBUG_PROTOCOL,
                        ("%s! Selected protocol: T=%ld\n",DRIVER_NAME,
                         SmartcardExtension->CardCapabilities.Protocol.Selected-1));

         // -----------------------
         // set parameters
         // -----------------------
         if (SmartcardExtension->CardCapabilities.N != 0xff)
            {
            // 0 <= N <= 254
//            if (SmartcardExtension->ReaderExtension->CardParameters.bBaudRate ==
//                CMUSB_FREQUENCY_5_12MHZ + CMUSB_BAUDRATE_115200                   ||
//                SmartcardExtension->ReaderExtension->CardParameters.bBaudRate ==
//                CMUSB_FREQUENCY_3_72MHZ + CMUSB_BAUDRATE_115200                      )
//               {
//               SmartcardExtension->ReaderExtension->CardParameters.bStopBits = 1 + SmartcardExtension->CardCapabilities.N;
//               }
//            else
//               {
            SmartcardExtension->ReaderExtension->CardParameters.bStopBits = 2 + SmartcardExtension->CardCapabilities.N;
//               }
            }
         else
            {
            // N = 255
            if (SmartcardExtension->CardCapabilities.Protocol.Selected & SCARD_PROTOCOL_T0)
               {
               // 12 etu for T=0;
               SmartcardExtension->ReaderExtension->CardParameters.bStopBits = 2;
               }
            else
               {
               // 11 etu for T=1
               SmartcardExtension->ReaderExtension->CardParameters.bStopBits = 1;
               }
            }


         NTStatus = CMUSB_SetCardParameters (SmartcardExtension->OsData->DeviceObject,
                                             SmartcardExtension->ReaderExtension->CardParameters.bCardType,
                                             SmartcardExtension->ReaderExtension->CardParameters.bBaudRate,
                                             SmartcardExtension->ReaderExtension->CardParameters.bStopBits);



         break;

      default :
         SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
         *SmartcardExtension->IoRequest.Information = 0;
         break;
      }



   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SetProtocol : Exit %lx\n",DRIVER_NAME,NTStatus));
   return NTStatus;

}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
CMUSB_CardPower(IN PSMARTCARD_EXTENSION SmartcardExtension)
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   NTSTATUS DebugStatus = STATUS_SUCCESS;
   UCHAR  pbAtrBuffer[MAXIMUM_ATR_LENGTH];
   ULONG  ulAtrLength;
#if DBG
   ULONG i;
#endif;


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!CardPower: Enter\n",DRIVER_NAME));

#if DBG
   switch (SmartcardExtension->MinorIoControlCode)
      {
      case SCARD_WARM_RESET:
         SmartcardDebug(DEBUG_ATR,
                        ("%s!CardPower: SCARD_WARM_RESTART\n",DRIVER_NAME));
         break;
      case SCARD_COLD_RESET:
         SmartcardDebug(DEBUG_ATR,
                        ("%s!CardPower: SCARD_COLD_RESTART\n",DRIVER_NAME));
         break;
      case SCARD_POWER_DOWN:
         SmartcardDebug(DEBUG_ATR,
                        ("%s!CardPower: SCARD_POWER_DOWN\n",DRIVER_NAME));
         break;
      }
#endif

   //DbgBreakPoint();

   switch (SmartcardExtension->MinorIoControlCode)
      {
      case SCARD_WARM_RESET:
      case SCARD_COLD_RESET:

         // try asynchronous cards first
         // because some asynchronous cards
         // do not return 0xFF in the first byte
         NTStatus = CMUSB_PowerOnCard(SmartcardExtension,
                                      pbAtrBuffer,
                                      &ulAtrLength);

         if (NTStatus != STATUS_SUCCESS && NTStatus!= STATUS_NO_MEDIA)
            {
            NTStatus = CMUSB_PowerOnSynchronousCard(SmartcardExtension,
                                                    pbAtrBuffer,
                                                    &ulAtrLength);
            }

         if (NTStatus != STATUS_SUCCESS)
            {
            goto ExitCardPower;
            }

         if (SmartcardExtension->ReaderExtension->fRawModeNecessary == FALSE)
            {
            // copy ATR to smart card structure
            // the lib needs the ATR for evaluation of the card parameters

            RtlCopyBytes((PVOID)SmartcardExtension->CardCapabilities.ATR.Buffer,
                         (PVOID)pbAtrBuffer,
                         ulAtrLength);

            SmartcardExtension->CardCapabilities.ATR.Length = (UCHAR)ulAtrLength;

            SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_NEGOTIABLE;

            SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;

            NTStatus = SmartcardUpdateCardCapabilities(SmartcardExtension);
            if (NTStatus != STATUS_SUCCESS)
               {
               goto ExitCardPower;
               }

            // -----------------------
            // set parameters
            // -----------------------
            if (SmartcardExtension->CardCapabilities.N != 0xff)
               {
               // 0 <= N <= 254
               SmartcardExtension->ReaderExtension->CardParameters.bStopBits = 2 + SmartcardExtension->CardCapabilities.N;
               }
            else
               {
               // N = 255
               if (SmartcardExtension->CardCapabilities.Protocol.Selected & SCARD_PROTOCOL_T0)
                  {
                  // 12 etu for T=0;
                  SmartcardExtension->ReaderExtension->CardParameters.bStopBits = 2;
                  }
               else
                  {
                  // 11 etu for T=1
                  SmartcardExtension->ReaderExtension->CardParameters.bStopBits = 1;
                  }
               }


            NTStatus = CMUSB_SetCardParameters (SmartcardExtension->OsData->DeviceObject,
                                                SmartcardExtension->ReaderExtension->CardParameters.bCardType,
                                                SmartcardExtension->ReaderExtension->CardParameters.bBaudRate,
                                                SmartcardExtension->ReaderExtension->CardParameters.bStopBits);


#if DBG
            SmartcardDebug(DEBUG_ATR,("%s!CardPower: ATR : ",DRIVER_NAME));
            for (i = 0;i < ulAtrLength;i++)
               SmartcardDebug(DEBUG_ATR,("%2.2x ",SmartcardExtension->CardCapabilities.ATR.Buffer[i]));
            SmartcardDebug(DEBUG_ATR,("\n"));

#endif

            }
         else
            {
            SmartcardExtension->CardCapabilities.ATR.Buffer[0] = 0x3B;
            SmartcardExtension->CardCapabilities.ATR.Buffer[1] = 0x04;

            RtlCopyBytes((PVOID)&SmartcardExtension->CardCapabilities.ATR.Buffer[2],
                         (PVOID)pbAtrBuffer,
                         ulAtrLength);

            ulAtrLength += 2;
            SmartcardExtension->CardCapabilities.ATR.Length = (UCHAR)ulAtrLength;

            SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;
            SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T0;

            NTStatus = SmartcardUpdateCardCapabilities(SmartcardExtension);
            if (NTStatus != STATUS_SUCCESS)
               {
               goto ExitCardPower;
               }

            SmartcardDebug(DEBUG_ATR,("CardPower: ATR of synchronous smart card : %2.2x %2.2x %2.2x %2.2x\n",
                                      pbAtrBuffer[0],pbAtrBuffer[1],pbAtrBuffer[2],pbAtrBuffer[3]));

            // copied from serial CardMan
            //SmartcardExtension->ReaderExtension->SyncParameters.fCardResetRequested = TRUE;

            }

         // copy ATR to user space
         RtlCopyBytes((PVOID)SmartcardExtension->IoRequest.ReplyBuffer,
                      (PVOID)SmartcardExtension->CardCapabilities.ATR.Buffer,
                      SmartcardExtension->CardCapabilities.ATR.Length);

         *SmartcardExtension->IoRequest.Information = ulAtrLength;
         break;

      case SCARD_POWER_DOWN:
         NTStatus = CMUSB_PowerOffCard(SmartcardExtension);
         if (NTStatus != STATUS_SUCCESS)
            {
            goto ExitCardPower;
            }


         SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SWALLOWED;
         SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;

         break;
      }



   ExitCardPower:

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!CardPower: Exit %lx\n",DRIVER_NAME,NTStatus));
   return NTStatus;

}




/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_PowerOffCard (
                            IN PSMARTCARD_EXTENSION SmartcardExtension
                            )
{
   NTSTATUS NTStatus;
   NTSTATUS DebugStatus;
   PDEVICE_OBJECT DeviceObject;
   ULONG ulBytesRead;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!PowerOffCard: Enter\n",DRIVER_NAME));

   DeviceObject = SmartcardExtension->OsData->DeviceObject;

   SmartcardExtension->SmartcardRequest.BufferLength = 0;
   NTStatus = CMUSB_WriteP0(DeviceObject,
                            0x11,         //bRequest,
                            0x00,         //bValueLo,
                            0x00,         //bValueHi,
                            0x00,         //bIndexLo,
                            0x00          //bIndexHi,
                           );


   // now read the NTStatus
   SmartcardExtension->ReaderExtension->ulTimeoutP1 = DEFAULT_TIMEOUT_P1;
   NTStatus = CMUSB_ReadP1(DeviceObject);
   if (NTStatus == STATUS_DEVICE_DATA_ERROR)
      {
      DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);
      goto ExitPowerOff;
      }



   ExitPowerOff:

   // set card state for update thread
   // otherwise a card removal/insertion would be recognized
   if (SmartcardExtension->ReaderExtension->ulOldCardState == POWERED)
      SmartcardExtension->ReaderExtension->ulOldCardState = INSERTED;


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!PowerOffCard: Exit %lx\n",DRIVER_NAME,NTStatus));
   return NTStatus;
}

/*****************************************************************************
Routine Description:


Arguments:


Return Value:


*****************************************************************************/
NTSTATUS CMUSB_ReadStateAfterP1Stalled(
                                      IN PDEVICE_OBJECT DeviceObject
                                      )
{
   NTSTATUS NTStatus;
   PSMARTCARD_EXTENSION SmartcardExtension;
   PDEVICE_EXTENSION DeviceExtension;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ReadStateAfterP1Stalled: Enter\n",DRIVER_NAME));

   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;

   SmartcardExtension->SmartcardRequest.BufferLength = 0;
   NTStatus = CMUSB_WriteP0(DeviceObject,
                            0x20,         //bRequest,
                            0x00,         //bValueLo,
                            0x00,         //bValueHi,
                            0x00,         //bIndexLo,
                            0x00          //bIndexHi,
                           );

   if (NTStatus != STATUS_SUCCESS)
      {
      // if we can't read the NTStatus there must be a serious error
      goto ExitReadState;
      }
   SmartcardExtension->ReaderExtension->ulTimeoutP1 = DEFAULT_TIMEOUT_P1;
   SmartcardExtension->SmartcardReply.BufferLength = 1;
   NTStatus = CMUSB_ReadP1(DeviceObject);
   if (NTStatus != STATUS_SUCCESS)
      {
      // if we can't read the NTStatus there must be a serious error
      goto ExitReadState;
      }

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ReadStateAfterP1Stalled: Exit %lx\n",DRIVER_NAME,NTStatus));

   ExitReadState:
   return NTStatus;

}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_PowerOnCard  (
                            IN  PSMARTCARD_EXTENSION SmartcardExtension,
                            IN  PUCHAR pbATR,
                            OUT PULONG pulATRLength
                            )
{
   UCHAR  abMaxAtrBuffer[SCARD_ATR_LENGTH];
   ULONG  ulCurrentLengthOfAtr;
   ULONG  ulPtrToCurrentAtrByte;
   ULONG  ulExpectedLengthOfAtr;
   BOOLEAN fTryNextCard;
   BOOLEAN fValidAtrReceived = FALSE;
   ULONG  ulBytesRead;
   NTSTATUS NTStatus;
   PDEVICE_OBJECT DeviceObject;
   NTSTATUS DebugStatus;
   BOOLEAN   fInverseAtr = FALSE;
   ULONG  ulHistoricalBytes;
   ULONG  i;
   BOOLEAN   fTDxSent;
   BOOLEAN   fOnlyT0;
   UCHAR  bResetMode;
   UCHAR  abFrequency[2] = {CMUSB_FREQUENCY_3_72MHZ,
      CMUSB_FREQUENCY_5_12MHZ};
   ULONG ulCardType;
   UCHAR bCardType;
   UCHAR bStopBits;
   UCHAR bBaudRate;


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!PowerOnCard: Enter\n",DRIVER_NAME));

   DeviceObject = SmartcardExtension->OsData->DeviceObject;
   if (SmartcardExtension->MinorIoControlCode == SCARD_COLD_RESET)
      bResetMode = SMARTCARD_COLD_RESET;
   else
      bResetMode = SMARTCARD_WARM_RESET;


   // clear card parameters
   SmartcardExtension->ReaderExtension->CardParameters.bBaudRate = 0;
   SmartcardExtension->ReaderExtension->CardParameters.bCardType = 0;
   SmartcardExtension->ReaderExtension->CardParameters.bStopBits = 0;



   // set default card parameters
   // asnyc, 9600 baud, even parity
   bStopBits = 2;
   bBaudRate = CMUSB_BAUDRATE_9600;
   bCardType = CMUSB_SMARTCARD_ASYNCHRONOUS;



   for (ulCardType = 0;ulCardType < 2;ulCardType++)
      {
#if DBG
      switch (ulCardType)
         {
         case 0:
            SmartcardDebug(DEBUG_ATR,
                           ("%s!PowerOnCard: trying 3.72 Mhz smart card\n",DRIVER_NAME));
            break;

         case 1:
            SmartcardDebug(DEBUG_ATR,
                           ("%s!PowerOnCard: trying 5.12 Mhz smart card\n",DRIVER_NAME));
            break;

         }
#endif
      bBaudRate |= abFrequency[ulCardType];

      NTStatus = CMUSB_SetCardParameters (SmartcardExtension->OsData->DeviceObject,
                                          bCardType,
                                          bBaudRate,
                                          bStopBits);
      if (NTStatus != STATUS_SUCCESS)
         {
         // if we can't set the card parameters there must be a serious error
         goto ExitPowerOnCard;
         }

      ulCurrentLengthOfAtr  = 0L;
      ulPtrToCurrentAtrByte = 0L;
      fOnlyT0 = TRUE;
      fTryNextCard = FALSE;
      fValidAtrReceived = FALSE;
      RtlFillMemory((PVOID)abMaxAtrBuffer,
                    sizeof(abMaxAtrBuffer),
                    0x00);


      // resync CardManUSB by reading the NTStatus byte
      SmartcardExtension->SmartcardRequest.BufferLength = 0;
      NTStatus = CMUSB_WriteP0(DeviceObject,
                               0x20,         //bRequest,
                               0x00,         //bValueLo,
                               0x00,         //bValueHi,
                               0x00,         //bIndexLo,
                               0x00          //bIndexHi,
                              );

      if (NTStatus != STATUS_SUCCESS)
         {
         // if we can't read the NTStatus there must be a serious error
         goto ExitPowerOnCard;
         }

      SmartcardExtension->ReaderExtension->ulTimeoutP1 = DEFAULT_TIMEOUT_P1;
      SmartcardExtension->SmartcardReply.BufferLength = 1;
      NTStatus = CMUSB_ReadP1(DeviceObject);
      if (NTStatus == STATUS_DEVICE_DATA_ERROR)
         {
         DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);
         goto ExitPowerOnCard;
         }
      else if (NTStatus != STATUS_SUCCESS)
         {
         // if we can't read the NTStatus there must be a serious error
         goto ExitPowerOnCard;
         }


      // check if card is really inserted
      if (SmartcardExtension->SmartcardReply.Buffer[0] == 0x00)
         {
         NTStatus = STATUS_NO_MEDIA;
         goto ExitPowerOnCard;
         }



      // issue power on command
      NTStatus = CMUSB_WriteP0(DeviceObject,
                               0x10,         //bRequest,
                               bResetMode,   //bValueLo,
                               0x00,         //bValueHi,
                               0x00,         //bIndexLo,
                               0x00          //bIndexHi,
                              );
      if (NTStatus != STATUS_SUCCESS)
         {
         // if we can't issue the power on command there must be a serious error
         goto ExitPowerOnCard;
         }


      SmartcardExtension->ReaderExtension->ulTimeoutP1 = DEFAULT_TIMEOUT_P1;
      NTStatus = CMUSB_ReadP1(DeviceObject);
      if (NTStatus == STATUS_DEVICE_DATA_ERROR)
         {
         DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);
         goto ExitPowerOnCard;
         }
      else if (NTStatus != STATUS_SUCCESS)
         {
         continue;
         }


      ulBytesRead = SmartcardExtension->SmartcardReply.BufferLength;

      RtlCopyBytes((PVOID)(abMaxAtrBuffer+ulCurrentLengthOfAtr),
                   (PVOID)SmartcardExtension->SmartcardReply.Buffer,
                   ulBytesRead);

      // check if inverse convention used
      if (abMaxAtrBuffer[0] == 0x03)
         {
         fInverseAtr = TRUE;
         }

      if (fInverseAtr)
         {
         CMUSB_InverseBuffer(abMaxAtrBuffer+ulCurrentLengthOfAtr,
                             ulBytesRead);
         }

      if (abMaxAtrBuffer[0] != 0x3B &&
          abMaxAtrBuffer[0] != 0x3F    )
         {
         continue; // try next card
         }


      ulCurrentLengthOfAtr += ulBytesRead;


      // ---------------------
      // TS character
      // ---------------------
      SmartcardDebug(DEBUG_ATR,("PowerOnCard: TS = %2.2x\n",abMaxAtrBuffer[0]));
      if (abMaxAtrBuffer[ulPtrToCurrentAtrByte] != 0x3B &&
          abMaxAtrBuffer[ulPtrToCurrentAtrByte] != 0x3F    )
         {
         continue;
         }


      // ---------------------
      // T0 character
      // ---------------------
      ulExpectedLengthOfAtr = 2;
      if (ulCurrentLengthOfAtr < ulExpectedLengthOfAtr)
         {
         NTStatus = CMUSB_ReadP1(DeviceObject);
         if (NTStatus == STATUS_DEVICE_DATA_ERROR)
            {
            DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);
            goto ExitPowerOnCard;
            }
         else if (NTStatus != STATUS_SUCCESS)
            {
            continue;
            }
         ulBytesRead = SmartcardExtension->SmartcardReply.BufferLength;

         RtlCopyBytes((PVOID)(abMaxAtrBuffer+ulCurrentLengthOfAtr),
                      (PVOID)SmartcardExtension->SmartcardReply.Buffer,
                      ulBytesRead);
         if (fInverseAtr)
            {
            CMUSB_InverseBuffer(abMaxAtrBuffer+ulCurrentLengthOfAtr,
                                ulBytesRead);
            }
         ulCurrentLengthOfAtr += ulBytesRead;
         }

      SmartcardDebug(DEBUG_ATR,("PowerOnCard: T0 = %2.2x\n",abMaxAtrBuffer[1]));
      ulHistoricalBytes = abMaxAtrBuffer[1] & 0x0F;

      do
         {
         ulPtrToCurrentAtrByte = ulExpectedLengthOfAtr - 1;
         fTDxSent = FALSE;

         if (abMaxAtrBuffer[ulPtrToCurrentAtrByte] & 0x10)
            ulExpectedLengthOfAtr++;
         if (abMaxAtrBuffer[ulPtrToCurrentAtrByte] & 0x20)
            ulExpectedLengthOfAtr++;
         if (abMaxAtrBuffer[ulPtrToCurrentAtrByte] & 0x40)
            ulExpectedLengthOfAtr++;
         if (abMaxAtrBuffer[ulPtrToCurrentAtrByte] & 0x80)
            {
            ulExpectedLengthOfAtr++;
            fTDxSent = TRUE;
            }

         if (fOnlyT0 == TRUE                                &&
             ulPtrToCurrentAtrByte != 1                     &&   // check if not T0
             (abMaxAtrBuffer[ulPtrToCurrentAtrByte ] & 0x0f)  )
            {
            fOnlyT0 = FALSE;
            }

         // TA1, TB1, TC1 , TD1
         while (ulCurrentLengthOfAtr < ulExpectedLengthOfAtr)
            {
            NTStatus = CMUSB_ReadP1(DeviceObject);
            if (NTStatus == STATUS_DEVICE_DATA_ERROR)
               {
               DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);
               goto ExitPowerOnCard;
               }
            else if (NTStatus != STATUS_SUCCESS)
               {
               fTryNextCard = TRUE;
               break;
               }
            ulBytesRead = SmartcardExtension->SmartcardReply.BufferLength;

            RtlCopyBytes((PVOID)(abMaxAtrBuffer+ulCurrentLengthOfAtr),
                         (PVOID)SmartcardExtension->SmartcardReply.Buffer,
                         ulBytesRead);
            if (fInverseAtr)
               {
               CMUSB_InverseBuffer(abMaxAtrBuffer+ulCurrentLengthOfAtr,
                                   ulBytesRead);
               }

            ulCurrentLengthOfAtr += ulBytesRead;
            } // end of while


         if (fTryNextCard == TRUE)
            {
            break;
            }


#ifdef DBG
         SmartcardDebug(DEBUG_ATR,("PowerOnCard: ATR read bytes: "));
         for (i = 0;i < ulExpectedLengthOfAtr;i++)
            SmartcardDebug(DEBUG_ATR,("%2.2x ",abMaxAtrBuffer[i]));
         SmartcardDebug(DEBUG_ATR,("\n"));
#endif

         } while (fTDxSent == TRUE);

      if (fTryNextCard == TRUE)
         {
         continue;
         }


      // read historical bytes

      // bug fix : old SAMOS cards have a damaged ATR
      if (abMaxAtrBuffer[0] == 0x3b   &&
          abMaxAtrBuffer[1] == 0xbf   &&
          abMaxAtrBuffer[2] == 0x11   &&
          abMaxAtrBuffer[3] == 0x00   &&
          abMaxAtrBuffer[4] == 0x81   &&
          abMaxAtrBuffer[5] == 0x31   &&
          abMaxAtrBuffer[6] == 0x90   &&
          abMaxAtrBuffer[7] == 0x73      )
         {
         ulHistoricalBytes = 4;
         }




      ulExpectedLengthOfAtr += ulHistoricalBytes;
      if (fOnlyT0 == FALSE)
         {
         ulExpectedLengthOfAtr ++;
         }

      while (ulCurrentLengthOfAtr < ulExpectedLengthOfAtr)
         {
         NTStatus = CMUSB_ReadP1(DeviceObject);
         if (NTStatus == STATUS_DEVICE_DATA_ERROR)
            {
            DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);
            goto ExitPowerOnCard;
            }
         else if (NTStatus != STATUS_SUCCESS)
            {
            fTryNextCard = TRUE;
            break;
            }
         ulBytesRead = SmartcardExtension->SmartcardReply.BufferLength;

         RtlCopyBytes((PVOID)(abMaxAtrBuffer+ulCurrentLengthOfAtr),
                      (PVOID)SmartcardExtension->SmartcardReply.Buffer,
                      ulBytesRead);
         if (fInverseAtr)
            {
            CMUSB_InverseBuffer(abMaxAtrBuffer+ulCurrentLengthOfAtr,
                                ulBytesRead);
            }
         ulCurrentLengthOfAtr += ulBytesRead;
         }
      if (fTryNextCard == TRUE)
         {
         continue;
         }


      // check ATR
      if (ulCurrentLengthOfAtr < 3                ||
          ulCurrentLengthOfAtr > SCARD_ATR_LENGTH   )
         {
         goto ExitPowerOnCard;
         }


      // check if the ATR of a SAMOS card with damaged ATR msut be corrected
      CMUSB_CheckAtrModified(abMaxAtrBuffer,ulCurrentLengthOfAtr);

      NTStatus = STATUS_SUCCESS;
      fValidAtrReceived = TRUE;
      RtlCopyBytes((PVOID)pbATR,
                   (PVOID)abMaxAtrBuffer,
                   ulCurrentLengthOfAtr);
      *pulATRLength = ulCurrentLengthOfAtr;

      if (fInverseAtr)
         {
         SmartcardExtension->ReaderExtension->fInverseAtr = TRUE;
         }
      else
         {
         SmartcardExtension->ReaderExtension->fInverseAtr = FALSE;
         }
      SmartcardExtension->ReaderExtension->fRawModeNecessary = FALSE;

      // -------------------
      // set card parameters
      // -------------------
      if (SmartcardExtension->ReaderExtension->fInverseAtr)
         {
         SmartcardExtension->ReaderExtension->CardParameters.bBaudRate |= CMUSB_ODD_PARITY;
         }
      SmartcardExtension->ReaderExtension->CardParameters.bBaudRate |= abFrequency[ulCardType];
      SmartcardExtension->ReaderExtension->CardParameters.bBaudRate |= CMUSB_BAUDRATE_9600;
      SmartcardExtension->ReaderExtension->CardParameters.bCardType = CMUSB_SMARTCARD_ASYNCHRONOUS;
      break;
      }



   ExitPowerOnCard:
   // return correct error code
   if (NTStatus != STATUS_NO_MEDIA && fValidAtrReceived == FALSE)
      {
      SmartcardDebug(DEBUG_ATR,
                     ("%s!PowerOnCard: no valid ATR received\n",DRIVER_NAME));
      NTStatus = STATUS_UNRECOGNIZED_MEDIA;
      }

   if (NTStatus!=STATUS_SUCCESS)
      {
      // turn off VCC again
      CMUSB_PowerOffCard (SmartcardExtension );
      // ignor NTStatus
      }

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!PowerOnCard: Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_CardTracking(
                           PSMARTCARD_EXTENSION pSmartcardExtension
                           )
{
   KIRQL oldIrql;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!CardTracking: Enter\n",DRIVER_NAME ));

   //
   // Set cancel routine for the notification irp
   //
   IoAcquireCancelSpinLock(&oldIrql);
   IoSetCancelRoutine(pSmartcardExtension->OsData->NotificationIrp,
                      CMUSB_CancelCardTracking);
   IoReleaseCancelSpinLock(oldIrql);

   //
   // Mark notification irp pending
   //
   IoMarkIrpPending(pSmartcardExtension->OsData->NotificationIrp);

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!CardTracking: Exit\n",DRIVER_NAME ));

   return STATUS_PENDING;
}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_Cleanup(
                      IN PDEVICE_OBJECT DeviceObject,
                      IN PIRP Irp
                      )
{
   PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension = &DeviceExtension->SmartcardExtension;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!Cleanup: Enter\n",DRIVER_NAME));

   if (SmartcardExtension->OsData->NotificationIrp != NULL &&
       // test if there is a pending IRP at all
       SmartcardExtension->ReaderExtension != NULL &&
       // if the device has been removed ReaderExtension == NULL
       DeviceExtension->lOpenCount == 1 )
   // complete card tracking only if this is the the last close call
   // otherwise the card tracking of the resource manager is canceled
      {
      //
      // We need to complete the notification irp
      //
      CMUSB_CompleteCardTracking(SmartcardExtension);
      }

   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!Cleanup: Completing IRP %lx\n",DRIVER_NAME,Irp));

   Irp->IoStatus.Information = 0;
   Irp->IoStatus.Status = STATUS_SUCCESS;

   IoCompleteRequest(Irp,IO_NO_INCREMENT);

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!Cleanup: Exit\n",DRIVER_NAME));

   return STATUS_SUCCESS;
}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_CancelCardTracking(
                                 IN PDEVICE_OBJECT DeviceObject,
                                 IN PIRP Irp)
{
   PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension = &DeviceExtension->SmartcardExtension;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!CancelCardTracking: Enter\n",DRIVER_NAME));

   ASSERT(Irp == SmartcardExtension->OsData->NotificationIrp);

   IoReleaseCancelSpinLock(Irp->CancelIrql);

   CMUSB_CompleteCardTracking(SmartcardExtension);

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!CancelCardTracking: Exit\n",DRIVER_NAME));

   return STATUS_CANCELLED;
}



/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_IoCtlVendor(
                          PSMARTCARD_EXTENSION SmartcardExtension
                          )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   NTSTATUS DebugStatus;
   UCHAR  pbAtrBuffer[MAXIMUM_ATR_LENGTH];
   ULONG  ulAtrLength;


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!IoCtlVendor : Enter\n",DRIVER_NAME));

   switch (SmartcardExtension->MajorIoControlCode)
      {
      case CM_IOCTL_CR80S_SAMOS_SET_HIGH_SPEED:
         NTStatus = CMUSB_SetHighSpeed_CR80S_SAMOS(SmartcardExtension);
         break;

      case CM_IOCTL_GET_FW_VERSION:
         NTStatus = CMUSB_GetFWVersion(SmartcardExtension);
         break;

      case CM_IOCTL_READ_DEVICE_DESCRIPTION:
         NTStatus = CMUSB_ReadDeviceDescription(SmartcardExtension);
         break;

      case CM_IOCTL_SET_READER_9600_BAUD:
         NTStatus = CMUSB_SetReader_9600Baud(SmartcardExtension);
         break;

      case CM_IOCTL_SET_READER_38400_BAUD:
         NTStatus = CMUSB_SetReader_38400Baud(SmartcardExtension);
         break;

      case CM_IOCTL_SET_SYNC_PARAMETERS:
         // in case of CardManUSB do nothing
         NTStatus = STATUS_SUCCESS;
         break;

      case CM_IOCTL_SYNC_CARD_POWERON:
         NTStatus = CMUSB_PowerOnSynchronousCard(SmartcardExtension,
                                                 pbAtrBuffer,
                                                 &ulAtrLength);
         break;

      case CM_IOCTL_2WBP_RESET_CARD:
         SmartcardExtension->MinorIoControlCode = SMARTCARD_WARM_RESET;
         NTStatus = CMUSB_PowerOnSynchronousCard(SmartcardExtension,
                                                 pbAtrBuffer,
                                                 &ulAtrLength);
         break;

      case CM_IOCTL_2WBP_TRANSFER:
         NTStatus = CMUSB_Transmit2WBP(SmartcardExtension);
         break;

      case CM_IOCTL_3WBP_TRANSFER:
         NTStatus = CMUSB_Transmit3WBP(SmartcardExtension);
         break;


      default:
         NTStatus = STATUS_INVALID_DEVICE_REQUEST;
         break;
      }





   SmartcardDebug(DEBUG_TRACE,
                  ("%s!IoCtlVendor : Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;

}

/*****************************************************************************
Routine Description:



Arguments:



Return Value: STATUS_UNSUCCESSFUL
              STATUS_SUCCESS

*****************************************************************************/
NTSTATUS CMUSB_SetHighSpeed_CR80S_SAMOS (
                                        IN PSMARTCARD_EXTENSION SmartcardExtension
                                        )
{
   NTSTATUS NTStatus;
   NTSTATUS DebugStatus;
   UCHAR abReadBuffer[16];
   ULONG ulBytesRead;
   BYTE abCR80S_SAMOS_SET_HIGH_SPEED[4] = {0xFF,0x11,0x94,0x7A};
   ULONG ulAtrLength;
   BYTE abAtr[MAXIMUM_ATR_LENGTH];
   LARGE_INTEGER   liWaitTime;
   BOOLEAN         fStateTimer;
   ULONG           ulWaitTime;
   BOOLEAN         fCancelTimer = FALSE;


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SetHighSpeed_CR80S_SAMOS: Enter\n",DRIVER_NAME));

   SmartcardDebug(DEBUG_PROTOCOL,
                  ("%s!SetHighSpeed_CR80S_SAMOS: writing high speed command\n",DRIVER_NAME));


   RtlCopyBytes((PVOID)SmartcardExtension->SmartcardRequest.Buffer,
                (PVOID)abCR80S_SAMOS_SET_HIGH_SPEED,
                sizeof(abCR80S_SAMOS_SET_HIGH_SPEED));
   SmartcardExtension->SmartcardRequest.BufferLength = 4;
   NTStatus = CMUSB_WriteP0(SmartcardExtension->OsData->DeviceObject,
                            0x01,         //we can use T=1 setting for direct communication
                            0x00,         //bValueLo,
                            0x00,         //bValueHi,
                            0x00,         //bIndexLo,
                            0x00);        //bIndexHi,
   if (NTStatus != STATUS_SUCCESS)
      {
      SmartcardDebug(DEBUG_ERROR,
                     ("%s!SetHighSpeed_CR80S_SAMOS: writing high speed command failed\n",DRIVER_NAME));
      goto ExitSetHighSpeed;
      }

   // read back pts data
   SmartcardDebug(DEBUG_PROTOCOL,
                  ("%s!SetHighSpeed_CR80S_SAMOS: reading echo\n",DRIVER_NAME));

   // maximim initial waiting time is 9600 * etu
   // => 1 sec is sufficient
   ulWaitTime = 1000;
   liWaitTime = RtlConvertLongToLargeInteger(ulWaitTime * -10000);
   KeSetTimer(&SmartcardExtension->ReaderExtension->WaitTimer,
              liWaitTime,
              NULL);

   fCancelTimer = TRUE;


   do
      {
      SmartcardExtension->ReaderExtension->ulTimeoutP1 = ulWaitTime;
      NTStatus = CMUSB_ReadP1(SmartcardExtension->OsData->DeviceObject);
      if (NTStatus == STATUS_DEVICE_DATA_ERROR)
         {
         DebugStatus = CMUSB_ReadStateAfterP1Stalled(SmartcardExtension->OsData->DeviceObject);
         break;
         }

      fStateTimer = KeReadStateTimer(&SmartcardExtension->ReaderExtension->WaitTimer);
      if (fStateTimer == TRUE)
         {
         fCancelTimer =FALSE;
         SmartcardDebug(DEBUG_PROTOCOL,
                        ("%s!SetHighSpeed_CR80S_SAMOS: timeout while reading echo\n",DRIVER_NAME));
         break;
         }



      } while (SmartcardExtension->SmartcardReply.Buffer[0] < 4 );

   if (NTStatus != STATUS_SUCCESS)
      {
      goto ExitSetHighSpeed;
      }


   SmartcardExtension->SmartcardReply.BufferLength = 4;
   NTStatus = CMUSB_ReadP0(SmartcardExtension->OsData->DeviceObject);
   if (NTStatus != STATUS_SUCCESS)
      {
      SmartcardDebug(DEBUG_ERROR,
                     ("%s!SetHighSpeed_CR80S_SAMOS: reading echo failed\n",DRIVER_NAME));
      goto ExitSetHighSpeed;
      }
   ulBytesRead = SmartcardExtension->SmartcardReply.BufferLength;

   RtlCopyBytes((PVOID)abReadBuffer,
                (PVOID)SmartcardExtension->SmartcardReply.Buffer,
                ulBytesRead);



   // if the card has accepted this string , the string is echoed
   if (abReadBuffer[0] == abCR80S_SAMOS_SET_HIGH_SPEED[0]  &&
       abReadBuffer[1] == abCR80S_SAMOS_SET_HIGH_SPEED[1]  &&
       abReadBuffer[2] == abCR80S_SAMOS_SET_HIGH_SPEED[2]  &&
       abReadBuffer[3] == abCR80S_SAMOS_SET_HIGH_SPEED[3]      )
      {
      SmartcardExtension->ReaderExtension->CardParameters.bBaudRate = 0;

      SmartcardExtension->ReaderExtension->CardParameters.bBaudRate |= CMUSB_FREQUENCY_5_12MHZ;
      SmartcardExtension->ReaderExtension->CardParameters.bBaudRate |= CMUSB_BAUDRATE_76800;
      SmartcardExtension->ReaderExtension->CardParameters.bCardType  = CMUSB_SMARTCARD_ASYNCHRONOUS;


      NTStatus = CMUSB_SetCardParameters (SmartcardExtension->OsData->DeviceObject,
                                          SmartcardExtension->ReaderExtension->CardParameters.bCardType,
                                          SmartcardExtension->ReaderExtension->CardParameters.bBaudRate,
                                          SmartcardExtension->ReaderExtension->CardParameters.bStopBits);


      }
   else
      {
      DebugStatus = CMUSB_PowerOffCard(SmartcardExtension);

      // a cold reset is necessary now
      SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;
      DebugStatus = CMUSB_PowerOnCard(SmartcardExtension,abAtr,&ulAtrLength);
      NTStatus = STATUS_UNSUCCESSFUL;
      }




   ExitSetHighSpeed:
   if (fCancelTimer == TRUE)
      {
      KeCancelTimer(&SmartcardExtension->ReaderExtension->WaitTimer);
      }

   *SmartcardExtension->IoRequest.Information = 0L;
   if (NTStatus != STATUS_SUCCESS)
      NTStatus = STATUS_UNSUCCESSFUL;
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SetHighSpeed_CR80S_SAMOS: Exit %lx\n",DRIVER_NAME,NTStatus));
   return NTStatus;
}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_GetFWVersion (
                            IN PSMARTCARD_EXTENSION SmartcardExtension
                            )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!GetFWVersion : Enter\n",DRIVER_NAME));


   if (SmartcardExtension->IoRequest.ReplyBufferLength  < sizeof (ULONG))
      {
      NTStatus = STATUS_BUFFER_OVERFLOW;
      goto ExitGetFWVersion;
      }
   else
      {
      *(PULONG)(SmartcardExtension->IoRequest.ReplyBuffer) =
      SmartcardExtension->ReaderExtension->ulFWVersion;
      }


   ExitGetFWVersion:
   *SmartcardExtension->IoRequest.Information = sizeof(ULONG);
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!GetFWVersion : Exit %lx\n",DRIVER_NAME,NTStatus));
   return NTStatus;
}

/*****************************************************************************
Routine Description:


Arguments:


Return Value: STATUS_UNSUCCESSFUL
              STATUS_SUCCESS

*****************************************************************************/
NTSTATUS CMUSB_SetReader_9600Baud (
                                  IN PSMARTCARD_EXTENSION SmartcardExtension
                                  )
{
   NTSTATUS    NTStatus = STATUS_SUCCESS;;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SetReader_9600Baud: Enter\n",DRIVER_NAME));

   // check if card is already in specific mode
   if (SmartcardExtension->ReaderCapabilities.CurrentState != SCARD_SPECIFIC)
      {
      NTStatus = STATUS_INVALID_DEVICE_REQUEST;
      goto ExitSetReader9600;
      }

   // set 9600 Baud for 3.58 MHz
   SmartcardExtension->ReaderExtension->CardParameters.bBaudRate = CMUSB_FREQUENCY_3_72MHZ + CMUSB_BAUDRATE_9600;
   SmartcardExtension->ReaderExtension->CardParameters.bCardType  = CMUSB_SMARTCARD_ASYNCHRONOUS;
   NTStatus = CMUSB_SetCardParameters (SmartcardExtension->OsData->DeviceObject,
                                       SmartcardExtension->ReaderExtension->CardParameters.bCardType,
                                       SmartcardExtension->ReaderExtension->CardParameters.bBaudRate,
                                       SmartcardExtension->ReaderExtension->CardParameters.bStopBits);

   ExitSetReader9600:
   *SmartcardExtension->IoRequest.Information = 0L;
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SetReader_9600Baud: Exit %lx\n",DRIVER_NAME,NTStatus));

   return(NTStatus);
}


/*****************************************************************************
Routine Description:


Arguments:


Return Value: STATUS_UNSUCCESSFUL
              STATUS_SUCCESS

*****************************************************************************/
NTSTATUS CMUSB_SetReader_38400Baud (
                                   IN PSMARTCARD_EXTENSION SmartcardExtension
                                   )
{
   NTSTATUS    NTStatus = STATUS_SUCCESS;;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SetReader_38400Baud: Enter\n",DRIVER_NAME));

   // check if card is already in specific mode
   if (SmartcardExtension->ReaderCapabilities.CurrentState != SCARD_SPECIFIC)
      {
      NTStatus = STATUS_INVALID_DEVICE_REQUEST;
      goto ExitSetReader38400;
      }

   // set 384000 Baud for 3.58 MHz card
   SmartcardExtension->ReaderExtension->CardParameters.bBaudRate = CMUSB_FREQUENCY_3_72MHZ + CMUSB_BAUDRATE_38400;
   SmartcardExtension->ReaderExtension->CardParameters.bCardType  = CMUSB_SMARTCARD_ASYNCHRONOUS;
   NTStatus = CMUSB_SetCardParameters (SmartcardExtension->OsData->DeviceObject,
                                       SmartcardExtension->ReaderExtension->CardParameters.bCardType,
                                       SmartcardExtension->ReaderExtension->CardParameters.bBaudRate,
                                       SmartcardExtension->ReaderExtension->CardParameters.bStopBits);

   ExitSetReader38400:
   *SmartcardExtension->IoRequest.Information = 0L;
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SetReader_38400Baud: Exit %lx\n",DRIVER_NAME,NTStatus));

   return(NTStatus);
}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
CMUSB_InitializeSmartcardExtension(
                                  IN PSMARTCARD_EXTENSION SmartcardExtension
                                  )
{
   // ==================================
   // Fill the Vendor_Attr structure
   // ==================================
   RtlCopyBytes((PVOID)SmartcardExtension->VendorAttr.VendorName.Buffer,
                (PVOID)CM2020_VENDOR_NAME,
                sizeof(CM2020_VENDOR_NAME)
               );

   //
   // Length of vendor name
   //
   SmartcardExtension->VendorAttr.VendorName.Length = sizeof(CM2020_VENDOR_NAME);


   //
   // Reader name
   //
   RtlCopyBytes((PVOID)SmartcardExtension->VendorAttr.IfdType.Buffer,
                (PVOID)CM2020_PRODUCT_NAME,
                sizeof(CM2020_PRODUCT_NAME));

   //
   // Length of reader name
   //
   SmartcardExtension->VendorAttr.IfdType.Length = sizeof(CM2020_PRODUCT_NAME);



   //
   // Version number
   //
   SmartcardExtension->VendorAttr.IfdVersion.BuildNumber  = BUILDNUMBER_CARDMAN_USB;
   SmartcardExtension->VendorAttr.IfdVersion.VersionMinor = VERSIONMINOR_CARDMAN_USB;
   SmartcardExtension->VendorAttr.IfdVersion.VersionMajor = VERSIONMAJOR_CARDMAN_USB;


   //
   // Unit number which is zero based
   //
   SmartcardExtension->VendorAttr.UnitNo = SmartcardExtension->ReaderExtension->ulDeviceInstance;



   // ================================================
   // Fill the SCARD_READER_CAPABILITIES structure
   // ===============================================
   //
   // Supported protoclols by the reader
   //

   SmartcardExtension->ReaderCapabilities.SupportedProtocols = SCARD_PROTOCOL_T1 | SCARD_PROTOCOL_T0;




   //
   // Reader type serial, keyboard, ....
   //
   SmartcardExtension->ReaderCapabilities.ReaderType = SCARD_READER_TYPE_USB;

   //
   // Mechanical characteristics like swallows etc.
   //
   SmartcardExtension->ReaderCapabilities.MechProperties = 0;


   //
   // Current state of the reader
   //
   SmartcardExtension->ReaderExtension->ulOldCardState = UNKNOWN;
   SmartcardExtension->ReaderExtension->ulNewCardState = UNKNOWN;
   SmartcardExtension->ReaderCapabilities.CurrentState  = SCARD_UNKNOWN;



   //
   // Data Rate
   //
   SmartcardExtension->ReaderCapabilities.DataRate.Default =
   SmartcardExtension->ReaderCapabilities.DataRate.Max =
   dataRatesSupported[0];


   // reader could support higher data rates
   SmartcardExtension->ReaderCapabilities.DataRatesSupported.List =
   dataRatesSupported;
   SmartcardExtension->ReaderCapabilities.DataRatesSupported.Entries =
   sizeof(dataRatesSupported) / sizeof(dataRatesSupported[0]);


   //
   // CLK Frequency
   //


   SmartcardExtension->ReaderCapabilities.CLKFrequency.Default =
   SmartcardExtension->ReaderCapabilities.CLKFrequency.Max =
   CLKFrequenciesSupported[0];

   // reader could support higher frequencies
   SmartcardExtension->ReaderCapabilities.CLKFrequenciesSupported.List =
   CLKFrequenciesSupported;
   SmartcardExtension->ReaderCapabilities.CLKFrequenciesSupported.Entries =
   sizeof(CLKFrequenciesSupported) / sizeof(CLKFrequenciesSupported[0]);


   //
   // MaxIFSD
   //
   SmartcardExtension->ReaderCapabilities.MaxIFSD = ATTR_MAX_IFSD_CARDMAN_USB;





}


/*****************************************************************************
Routine Description:
This function always returns 'CardManUSB'.


Arguments:     pointer to SMARTCARD_EXTENSION



Return Value:  NT NTStatus

*****************************************************************************/
NTSTATUS
CMUSB_ReadDeviceDescription(IN PSMARTCARD_EXTENSION SmartcardExtension )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   BYTE abDeviceDescription[] = "CardManUSB";

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ReadDeviceDescription : Enter\n",DRIVER_NAME));

   if (SmartcardExtension->IoRequest.ReplyBufferLength  < sizeof(abDeviceDescription))
      {
      NTStatus = STATUS_BUFFER_OVERFLOW;
      *SmartcardExtension->IoRequest.Information = 0L;
      goto ExitReadDeviceDescription;
      }
   else
      {
      RtlCopyBytes((PVOID)SmartcardExtension->IoRequest.ReplyBuffer,
                   (PVOID)abDeviceDescription,
                   sizeof(abDeviceDescription));
      *SmartcardExtension->IoRequest.Information = sizeof(abDeviceDescription);
      }



   ExitReadDeviceDescription:
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ReadDeviceDescription : Exit %lx\n",DRIVER_NAME,NTStatus));
   return NTStatus;
}



/*****************************************************************************
Routine Description:

This routine always returns FALSE.

Arguments:    pointer to SMARDCARD_EXTENSION


Return Value: NT NTStatus


*****************************************************************************/
NTSTATUS
CMUSB_IsSPESupported (IN PSMARTCARD_EXTENSION SmartcardExtension )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!IsSPESupported: Enter\n",DRIVER_NAME));

   if (SmartcardExtension->IoRequest.ReplyBufferLength  < sizeof (ULONG))
      {
      NTStatus = STATUS_BUFFER_OVERFLOW;
      *SmartcardExtension->IoRequest.Information = 0;
      goto ExitIsSPESupported;
      }
   else
      {
      *(PULONG)(SmartcardExtension->IoRequest.ReplyBuffer) = FALSE;
      *SmartcardExtension->IoRequest.Information = sizeof(ULONG);
      }



   ExitIsSPESupported:
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!IsSPESupported: Exit %lx\n",DRIVER_NAME,NTStatus));
   return NTStatus;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_SetCardParameters (
                                 IN PDEVICE_OBJECT DeviceObject,
                                 IN UCHAR bCardType,
                                 IN UCHAR bBaudRate,
                                 IN UCHAR bStopBits
                                 )
{
   NTSTATUS NTStatus;
   PDEVICE_EXTENSION    DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;




   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SetCardParameters: Enter\n",DRIVER_NAME));

   SmartcardDebug(DEBUG_PROTOCOL,
                  ("%s!SetCardParameters: ##################################################\n",DRIVER_NAME));
   SmartcardDebug(DEBUG_PROTOCOL,
                  ("%s!SetCardParameters: bCardType = %x bBaudRate = %x bStopBits = %x\n",DRIVER_NAME,
                   bCardType,bBaudRate,bStopBits));
   SmartcardDebug(DEBUG_PROTOCOL,
                  ("%s!SetCardParameters: ##################################################\n",DRIVER_NAME));

   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;

   SmartcardExtension->SmartcardRequest.BufferLength = 0;
   NTStatus = CMUSB_WriteP0(DeviceObject,
                            0x30,         //bRequest,
                            bCardType,    //bValueLo,
                            bBaudRate,    //bValueHi,
                            bStopBits,    //bIndexLo,
                            0x00          //bIndexHi,
                           );



   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SetCardParameters: Exit %lx\n",DRIVER_NAME,NTStatus));
   return NTStatus;
}

/*****************************************************************************
Routine Description:

 Bit0 -> Bit 7
 Bit1 -> Bit 6
 Bit2 -> Bit 5
 Bit3 -> Bit 4
 Bit4 -> Bit 3
 Bit5 -> Bit 2
 Bit6 -> Bit 1
 Bit7 -> Bit 0

Arguments:



Return Value:

*****************************************************************************/
VOID CMUSB_InverseBuffer (
                         PUCHAR pbBuffer,
                         ULONG  ulBufferSize
                         )
{
   ULONG i;
   ULONG j;
   ULONG m;
   ULONG n;

   for (i=0; i<ulBufferSize; i++)
      {
      n = 0;
      for (j=1; j<=8; j++)
         {
         m  = (pbBuffer[i] << j);
         m &= 0x00000100;
         n  |= (m >> (9-j));
         }
      pbBuffer[i] = (UCHAR)~n;
      }

   return;
}

/*****************************************************************************
Routine Description:

 This function checks if an incorrect ATR has been received.
 It corrects the number of historical bytes and the checksum byte

Arguments:  pointer to current ATR
            length of ATR


Return Value: none

*****************************************************************************/
VOID CMUSB_CheckAtrModified (
                            PUCHAR pbBuffer,
                            ULONG  ulBufferSize
                            )
{
   UCHAR bNumberHistoricalBytes;
   UCHAR bXorChecksum;
   ULONG i;

   if (ulBufferSize < 0x09)  // mininmum length of a modified ATR
      return ;               // ATR is ok


   // variant 2
   if (pbBuffer[0] == 0x3b   &&
       pbBuffer[1] == 0xbf   &&
       pbBuffer[2] == 0x11   &&
       pbBuffer[3] == 0x00   &&
       pbBuffer[4] == 0x81   &&
       pbBuffer[5] == 0x31   &&
       pbBuffer[6] == 0x90   &&
       pbBuffer[7] == 0x73   &&
       ulBufferSize == 13   )
      {
      // correct number of historical bytes
      bNumberHistoricalBytes = 4;

      pbBuffer[1] &= 0xf0;
      pbBuffer[1] |= bNumberHistoricalBytes;

      // correct checksum byte
      bXorChecksum = pbBuffer[1];
      for (i=2;i<ulBufferSize-1;i++)
         bXorChecksum ^= pbBuffer[i];

      pbBuffer[ulBufferSize -1 ] = bXorChecksum;
      SmartcardDebug(DEBUG_ATR,
                     ("%s!CheckAtrModified: correcting SAMOS ATR (variant 2)\n",
                      DRIVER_NAME));
      }




   // variant 1
   if (pbBuffer[0] == 0x3b   &&
       pbBuffer[1] == 0xb4   &&
       pbBuffer[2] == 0x11   &&
       pbBuffer[3] == 0x00   &&
       pbBuffer[4] == 0x81   &&
       pbBuffer[5] == 0x31   &&
       pbBuffer[6] == 0x90   &&
       pbBuffer[7] == 0x73   &&
       ulBufferSize == 13      )
      {
      // correct checksum byte
      bXorChecksum = pbBuffer[1];
      for (i=2;i<ulBufferSize-1;i++)
         bXorChecksum ^= pbBuffer[i];


      if (pbBuffer[ulBufferSize -1 ] != bXorChecksum )
         {
         pbBuffer[ulBufferSize -1 ] = bXorChecksum;
         SmartcardDebug(DEBUG_ATR,
                        ("%s!CheckAtrModified: correcting SAMOS ATR (variant 1)\n",
                         DRIVER_NAME));

         }
      }



   // variant 3
   if (pbBuffer[0] == 0x3b   &&
       pbBuffer[1] == 0xbf   &&
       pbBuffer[2] == 0x11   &&
       pbBuffer[3] == 0x00   &&
       pbBuffer[4] == 0x81   &&
       pbBuffer[5] == 0x31   &&
       pbBuffer[6] == 0x90   &&
       pbBuffer[7] == 0x73   &&
       ulBufferSize ==  9      )
      {
      // correct number of historical bytes
      bNumberHistoricalBytes = 0;

      pbBuffer[1] &= 0xf0;
      pbBuffer[1] |= bNumberHistoricalBytes;

      // correct checksum byte
      bXorChecksum = pbBuffer[1];
      for (i=2;i<ulBufferSize-1;i++)
         bXorChecksum ^= pbBuffer[i];

      pbBuffer[ulBufferSize -1 ] = bXorChecksum;
      SmartcardDebug(DEBUG_ATR,
                     ("%s!CheckAtrModified: correcting SAMOS ATR (variant 3)\n",
                      DRIVER_NAME));
      }



}

/*****************************************************************************
* History:
* $Log: scusbcb.c $
* Revision 1.9  2001/01/17 12:36:04  WFrischauf
* No comment given
*
* Revision 1.8  2000/09/25 13:38:21  WFrischauf
* No comment given
*
* Revision 1.7  2000/08/24 09:04:38  TBruendl
* No comment given
*
* Revision 1.6  2000/08/16 14:35:03  WFrischauf
* No comment given
*
* Revision 1.5  2000/08/16 08:25:06  TBruendl
* warning :uninitialized memory removed
*
* Revision 1.4  2000/07/24 11:34:59  WFrischauf
* No comment given
*
* Revision 1.1  2000/07/20 11:50:14  WFrischauf
* No comment given
*
*
*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\scmstcs\cbhndlr.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       cbhndlr.c
//
//--------------------------------------------------------------------------

#if defined( SMCLIB_VXD )
#include "Driver98.h"
#else
#include "DriverNT.h"
#endif

#include "SerialIF.h"
#include "STCCmd.h"
#include "CBHndlr.h"
#include "T0Hndlr.h"

NTSTATUS
CBCardPower(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
/*++

CBCardPower:
	callback handler for SMCLIB RDF_CARD_POWER

Arguments:
	SmartcardExtension	context of call

Return Value:
	STATUS_SUCCESS
	STATUS_NO_MEDIA
	STATUS_TIMEOUT
	STATUS_BUFFER_TOO_SMALL

--*/
{
	NTSTATUS			NTStatus = STATUS_SUCCESS;
	UCHAR				ATRBuffer[ ATR_SIZE ];
	ULONG				ATRLength;
	PREADER_EXTENSION	ReaderExtension;
    SERIAL_TIMEOUTS Timeouts;

	SmartcardDebug( DEBUG_TRACE, ("SCMSTCS!CBCardPower Enter\n" ));

	ReaderExtension = SmartcardExtension->ReaderExtension;

	//	discard old ATR
	SmartcardExtension->CardCapabilities.ATR.Length = 0;
	SmartcardExtension->CardCapabilities.Protocol.Selected = 
        SCARD_PROTOCOL_UNDEFINED;

    // set standard timeouts for the worker thread
   	Timeouts.ReadIntervalTimeout = SR_READ_INTERVAL_TIMEOUT;
	Timeouts.ReadTotalTimeoutConstant = SR_READ_TOTAL_TIMEOUT_CONSTANT;
	Timeouts.ReadTotalTimeoutMultiplier	= 0;
	Timeouts.WriteTotalTimeoutConstant = SR_WRITE_TOTAL_TIMEOUT_CONSTANT;
	Timeouts.WriteTotalTimeoutMultiplier = 0;

   	NTStatus = IFSerialIoctl(
		ReaderExtension,
        IOCTL_SERIAL_SET_TIMEOUTS,
		&Timeouts,
        sizeof(Timeouts),
		NULL,
		0
		);
    ASSERT(NTStatus == STATUS_SUCCESS);

    // set the ATR timeout in milli sec
   	ReaderExtension->ReadTimeout = 1500;

	switch (SmartcardExtension->MinorIoControlCode)
	{
		case SCARD_WARM_RESET:

			//	if the card was not powerd, fall through to cold reset
			if( SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_SWALLOWED )
			{
				//	reset the card
				ATRLength = ATR_SIZE;
				NTStatus = STCReset(
					ReaderExtension,
					0,					// not used: ReaderExtension->Device,
					TRUE,				// warm reset
					ATRBuffer,
					&ATRLength
					);

				break;
			}
			//	warm reset not possible because card was not powerd

		case SCARD_COLD_RESET:
			//	reset the card
			ATRLength = ATR_SIZE;
			NTStatus = STCReset(
				ReaderExtension,
				0,						// not used: ReaderExtension->Device,
				FALSE,					// cold reset
				ATRBuffer,
				&ATRLength
				);
			break;

		case SCARD_POWER_DOWN:

			//	discard old card status
			ATRLength = 0;
			STCPowerOff( ReaderExtension );
			NTStatus = STATUS_SUCCESS;
			CBUpdateCardState( SmartcardExtension, SCARD_PRESENT );
			break;
	}

	//	finish the request
	if( NTStatus == STATUS_SUCCESS )
	{
		//	update all neccessary data if an ATR was received
		if( ATRLength > 2 )
		{
			//	copy ATR to user buffer buffer
			if( ATRLength <= SmartcardExtension->IoRequest.ReplyBufferLength )
			{
				SysCopyMemory(
					SmartcardExtension->IoRequest.ReplyBuffer,
					ATRBuffer,
					ATRLength
					);
				*SmartcardExtension->IoRequest.Information = ATRLength;
			}
			else
			{
				NTStatus = STATUS_BUFFER_TOO_SMALL;
			}

			//	copy ATR to card capability buffer
			if( ATRLength <= MAXIMUM_ATR_LENGTH )
			{
				SysCopyMemory(
					SmartcardExtension->CardCapabilities.ATR.Buffer,
					ATRBuffer,
					ATRLength
					);

				SmartcardExtension->CardCapabilities.ATR.Length = 
                    (UCHAR)ATRLength;

				//	let the lib update the card capabilities
				NTStatus = SmartcardUpdateCardCapabilities( 
                    SmartcardExtension
                    );
			}
			else
			{
				NTStatus = STATUS_BUFFER_TOO_SMALL;
			}

			if( NTStatus == STATUS_SUCCESS )
			{
                ULONG minWaitTime;

				//	set the stc registers
				CBSynchronizeSTC( SmartcardExtension );

                // now set the new - card specific - timeouts
				if( SmartcardExtension->CardCapabilities.Protocol.Selected == 
                    SCARD_PROTOCOL_T1 )
				{
					ReaderExtension->ReadTimeout = 
   	                Timeouts.ReadTotalTimeoutConstant = 
                        SmartcardExtension->CardCapabilities.T1.BWT / 1000;

   	                Timeouts.ReadIntervalTimeout = 
                        SmartcardExtension->CardCapabilities.T1.CWT / 1000;
				}
				else 
				{
					ReaderExtension->ReadTimeout = 
   	                Timeouts.ReadIntervalTimeout = 
   	                Timeouts.ReadTotalTimeoutConstant = 
                        SmartcardExtension->CardCapabilities.T0.WT / 1000 * 5;
				}
                minWaitTime = (KeQueryTimeIncrement() / 10000) * 5;

                if (Timeouts.ReadTotalTimeoutConstant < minWaitTime) {

                    Timeouts.ReadTotalTimeoutConstant = minWaitTime;         	
                }

                if (Timeouts.ReadIntervalTimeout < minWaitTime) {

                    Timeouts.ReadIntervalTimeout = minWaitTime;         	
                }

				if (ReaderExtension->ReadTimeout < minWaitTime) {

					ReaderExtension->ReadTimeout = minWaitTime;
				}

                // set standard timeouts for the worker thread
	            Timeouts.ReadTotalTimeoutMultiplier	= 0;

   	            NTStatus = IFSerialIoctl(
		            ReaderExtension,
                    IOCTL_SERIAL_SET_TIMEOUTS,
		            &Timeouts,
                    sizeof(Timeouts),
		            NULL,
		            0
		            );
                ASSERT(NTStatus == STATUS_SUCCESS);
			}
		}
	}

	SmartcardDebug( 
        DEBUG_TRACE,
        ( "SCMSTCS!CBCardPower Exit: %X\n", 
        NTStatus )
        );

	return( NTStatus );
}

NTSTATUS
CBSetProtocol(		
	PSMARTCARD_EXTENSION SmartcardExtension
	)
/*++

CBSetProtocol:
	callback handler for SMCLIB RDF_SET_PROTOCOL

Arguments:
	SmartcardExtension	context of call

Return Value:
	STATUS_SUCCESS
	STATUS_NO_MEDIA
	STATUS_TIMEOUT
	STATUS_BUFFER_TOO_SMALL
	STATUS_INVALID_DEVICE_STATE
	STATUS_INVALID_DEVICE_REQUEST

--*/
{
	NTSTATUS			NTStatus = STATUS_PENDING;
	UCHAR				PTSRequest[5], PTSReply[5];
	ULONG				NewProtocol;
	PREADER_EXTENSION	ReaderExtension;

	SmartcardDebug( DEBUG_TRACE, ("SCMSTCS!CBSetProtocol Enter\n" ));

	ReaderExtension = SmartcardExtension->ReaderExtension;
	NewProtocol		= SmartcardExtension->MinorIoControlCode;

	//	check if the card is already in specific state
	if( ( SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC )  &&
		( SmartcardExtension->CardCapabilities.Protocol.Selected & NewProtocol ))
	{
		NTStatus = STATUS_SUCCESS;	
	}

	//	protocol supported?
	if( !( SmartcardExtension->CardCapabilities.Protocol.Supported & NewProtocol ) || 
		!( SmartcardExtension->ReaderCapabilities.SupportedProtocols & NewProtocol ))
	{
		NTStatus = STATUS_INVALID_DEVICE_REQUEST;	
	}

	//	send PTS
	while( NTStatus == STATUS_PENDING )
	{
		// set initial character of PTS
		PTSRequest[0] = 0xFF;

		// set the format character
		if( NewProtocol & SCARD_PROTOCOL_T1 )
		{
			PTSRequest[1] = 0x11;
			SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T1;
		}
		else
		{
			PTSRequest[1] = 0x10;
			SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T0;
		}

		//	PTS1 codes Fl and Dl
		PTSRequest[2] = 
			SmartcardExtension->CardCapabilities.PtsData.Fl << 4 |
			SmartcardExtension->CardCapabilities.PtsData.Dl;

		//	check character
		PTSRequest[3] = PTSRequest[0] ^ PTSRequest[1] ^ PTSRequest[2];   

		//	write PTSRequest
		NTStatus = STCWriteICC1( ReaderExtension, PTSRequest, 4 );

		//	get response
		if( NTStatus == STATUS_SUCCESS )
		{
			ULONG BufferLength = sizeof(PTSReply);
			NTStatus = STCReadICC1( 
                ReaderExtension, 
                PTSReply, 
				&BufferLength,
                4
                );

			if(( NTStatus == STATUS_SUCCESS ) && !SysCompareMemory( PTSRequest, PTSReply, 4))
			{
				//	set the stc registers
				SmartcardExtension->CardCapabilities.Dl =
					SmartcardExtension->CardCapabilities.PtsData.Dl;
				SmartcardExtension->CardCapabilities.Fl = 
					SmartcardExtension->CardCapabilities.PtsData.Fl;

				CBSynchronizeSTC( SmartcardExtension );

				// the card replied correctly to the PTS-request
				break;
			}
		}

		//
		//	The card did either NOT reply or it replied incorrectly
		//	so try default values
		//
		SmartcardExtension->CardCapabilities.PtsData.Type	= PTS_TYPE_DEFAULT;
		SmartcardExtension->MinorIoControlCode				= SCARD_COLD_RESET;
		NTStatus = CBCardPower( SmartcardExtension );

		if( NTStatus == STATUS_SUCCESS )
		{
			NTStatus = STATUS_PENDING;
		}
		else
		{
			NTStatus = STATUS_DEVICE_PROTOCOL_ERROR;
		}
	}

	if( NTStatus == STATUS_TIMEOUT )
	{
		NTStatus = STATUS_IO_TIMEOUT;		 	
	}

	if( NTStatus == STATUS_SUCCESS )
	{
        ULONG minWaitTime;
        SERIAL_TIMEOUTS Timeouts;

		if( SmartcardExtension->CardCapabilities.Protocol.Selected == 
            SCARD_PROTOCOL_T1 )
		{
			ReaderExtension->ReadTimeout = 
   	        Timeouts.ReadTotalTimeoutConstant = 
                SmartcardExtension->CardCapabilities.T1.BWT / 1000;

   	        Timeouts.ReadIntervalTimeout = 
                SmartcardExtension->CardCapabilities.T1.CWT / 1000;
		}
		else 
		{
			ReaderExtension->ReadTimeout = 
   	        Timeouts.ReadIntervalTimeout = 
   	        Timeouts.ReadTotalTimeoutConstant = 
                SmartcardExtension->CardCapabilities.T0.WT / 1000 * 5;
		}

        minWaitTime = (KeQueryTimeIncrement() / 10000) * 5;

        if (Timeouts.ReadTotalTimeoutConstant < minWaitTime) {

            Timeouts.ReadTotalTimeoutConstant = minWaitTime;         	
        }

        if (Timeouts.ReadIntervalTimeout < minWaitTime) {

            Timeouts.ReadIntervalTimeout = minWaitTime;         	
        }

		if (ReaderExtension->ReadTimeout < minWaitTime) {

			ReaderExtension->ReadTimeout = minWaitTime;
		}

	    Timeouts.WriteTotalTimeoutConstant = SR_WRITE_TOTAL_TIMEOUT_CONSTANT;
	    Timeouts.WriteTotalTimeoutMultiplier = 0;
	    Timeouts.ReadTotalTimeoutMultiplier	= 0;

   	    NTStatus = IFSerialIoctl(
		    ReaderExtension,
            IOCTL_SERIAL_SET_TIMEOUTS,
		    &Timeouts,
            sizeof(Timeouts),
		    NULL,
		    0
		    );
        ASSERT(NTStatus == STATUS_SUCCESS);

		//	indicate that the card is in specific mode 
		SmartcardExtension->ReaderCapabilities.CurrentState = 
            SCARD_SPECIFIC;

		// return the selected protocol to the caller
		*(PULONG) SmartcardExtension->IoRequest.ReplyBuffer = 
            SmartcardExtension->CardCapabilities.Protocol.Selected;
		*SmartcardExtension->IoRequest.Information = 
            sizeof(SmartcardExtension->CardCapabilities.Protocol.Selected);
	}
	else
	{
		SmartcardExtension->CardCapabilities.Protocol.Selected = 
            SCARD_PROTOCOL_UNDEFINED;
		*(PULONG) SmartcardExtension->IoRequest.ReplyBuffer = 0;
		*SmartcardExtension->IoRequest.Information = 0;
	}

	SmartcardDebug( DEBUG_TRACE, ("SCMSTCS!CBSetProtocol: Exit %X\n", NTStatus ));

	return( NTStatus ); 
}

NTSTATUS
CBTransmit(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
/*++

CBTransmit:
	callback handler for SMCLIB RDF_TRANSMIT

Arguments:
	SmartcardExtension	context of call

Return Value:
	STATUS_SUCCESS
	STATUS_NO_MEDIA
	STATUS_TIMEOUT
	STATUS_INVALID_DEVICE_REQUEST

--*/
{
	NTSTATUS  NTStatus = STATUS_SUCCESS;

	SmartcardDebug( DEBUG_TRACE, ("SCMSTCS!CBTransmit Enter\n" ));

	//	dispatch on the selected protocol
	switch( SmartcardExtension->CardCapabilities.Protocol.Selected )
	{
		case SCARD_PROTOCOL_T0:
			NTStatus = CBT0Transmit( SmartcardExtension );
			break;

		case SCARD_PROTOCOL_T1:
			NTStatus = CBT1Transmit( SmartcardExtension );
			break;

		case SCARD_PROTOCOL_RAW:
			NTStatus = CBRawTransmit( SmartcardExtension );
			break;

		default:
			NTStatus = STATUS_INVALID_DEVICE_REQUEST;
			break;
	}

	SmartcardDebug( DEBUG_TRACE, ("SCMSTCS!CBTransmit Exit: %X\n", NTStatus ));

	return( NTStatus );
}

NTSTATUS
CBT0Transmit(		
	PSMARTCARD_EXTENSION SmartcardExtension
	)
/*++

CBT0Transmit:
	finishes the callback RDF_TRANSMIT for the T0 protocol

Arguments:
	SmartcardExtension	context of call

Return Value:
	STATUS_SUCCESS
	STATUS_NO_MEDIA
	STATUS_TIMEOUT
	STATUS_INVALID_DEVICE_REQUEST

--*/
{
    NTSTATUS				NTStatus = STATUS_SUCCESS;

	SmartcardDebug( DEBUG_TRACE, ("SCMSTCS!CBT0Transmit Enter\n" ));

	SmartcardExtension->SmartcardRequest.BufferLength = 0;
    SmartcardExtension->SmartcardReply.BufferLength = 
        SmartcardExtension->SmartcardReply.BufferSize;

	//	let the lib setup the T=1 APDU & check for errors
	NTStatus = SmartcardT0Request( SmartcardExtension );

	if( NTStatus == STATUS_SUCCESS )
	{
		NTStatus = T0_ExchangeData(
			SmartcardExtension->ReaderExtension,
			SmartcardExtension->SmartcardRequest.Buffer,
			SmartcardExtension->SmartcardRequest.BufferLength,
			SmartcardExtension->SmartcardReply.Buffer,
			&SmartcardExtension->SmartcardReply.BufferLength
			);

		if( NTStatus == STATUS_SUCCESS )
		{
			//	let the lib evaluate the result & tansfer the data
			NTStatus = SmartcardT0Reply( SmartcardExtension );
		}
	}

	SmartcardDebug( DEBUG_TRACE,("SCMSTCS!CBT0Transmit Exit: %X\n", NTStatus ));

    return( NTStatus );
}

NTSTATUS
CBT1Transmit(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
/*++

CBT1Transmit:
	finishes the callback RDF_TRANSMIT for the T1 protocol

Arguments:
	SmartcardExtension	context of call

Return Value:
	STATUS_SUCCESS
	STATUS_NO_MEDIA
	STATUS_TIMEOUT
	STATUS_INVALID_DEVICE_REQUEST

--*/
{
    NTSTATUS	NTStatus = STATUS_SUCCESS;
    ULONG       BufferLength,AlreadyRead;

	SmartcardDebug( DEBUG_TRACE, ("SCMSTCS!CBT1Transmit Enter\n" ));

	//KJ
	RtlZeroMemory( SmartcardExtension->SmartcardReply.Buffer, 
				   sizeof(SmartcardExtension->SmartcardReply.Buffer));

	//	use the lib support to construct the T=1 packets
	do {
		//	no header for the T=1 protocol
		SmartcardExtension->SmartcardRequest.BufferLength = 0;
		
		SmartcardExtension->T1.NAD = 0;

		//	let the lib setup the T=1 APDU & check for errors
		NTStatus = SmartcardT1Request( SmartcardExtension );
		if( NTStatus == STATUS_SUCCESS )
		{
			//	send command (don't calculate LRC because CRC may be used!)
			NTStatus = STCWriteICC1(
				SmartcardExtension->ReaderExtension,
				SmartcardExtension->SmartcardRequest.Buffer,
				SmartcardExtension->SmartcardRequest.BufferLength
				);

			//
			//	extend the timeout if a Wtx request was sent by the card. if the 
			//	card responds before the waiting time extension expires, the data are
			//	buffered in the reader. A delay without polling the reader status
			//	slows down the performance of the driver, but wtx is an exeption,
			//	not the rule.
			//
			if (SmartcardExtension->T1.Wtx)
			{

					SysDelay(
					(( SmartcardExtension->T1.Wtx * 
					SmartcardExtension->CardCapabilities.T1.BWT + 999L )/
					1000L) 
					);

			}

			//	get response
			SmartcardExtension->SmartcardReply.BufferLength = 0;

			if( NTStatus == STATUS_SUCCESS )
			{
                BufferLength = SmartcardExtension->SmartcardReply.BufferSize;
				NTStatus = STCReadICC1(
					SmartcardExtension->ReaderExtension,
					SmartcardExtension->SmartcardReply.Buffer,
					&BufferLength,
					3
					);
				// if we have read more then 3 bytes
				if(BufferLength > 3)
				{
					AlreadyRead = BufferLength - 3;
				}
				else
				{
					AlreadyRead = 0;
				}

				if( NTStatus == STATUS_SUCCESS )
				{
					ULONG Length;

					Length = (ULONG)SmartcardExtension->SmartcardReply.Buffer[ LEN_IDX ] + 1;

					if( Length + 3 < MIN_BUFFER_SIZE )
					{
						BufferLength = 
							SmartcardExtension->SmartcardReply.BufferSize - 
							Length;

						NTStatus = STCReadICC1(
							SmartcardExtension->ReaderExtension,
							(&SmartcardExtension->SmartcardReply.Buffer[ DATA_IDX ]) + AlreadyRead,
							&BufferLength,
							Length-AlreadyRead
							);

						SmartcardExtension->SmartcardReply.BufferLength = Length + 3;
					}
					else
					{
						NTStatus = STATUS_BUFFER_TOO_SMALL;
					}
				}
				//
				//	if STCRead detects an LRC error, ignore it (maybe CRC used). Timeouts will
				//	be detected by the lib if len=0
				//
				if(( NTStatus == STATUS_CRC_ERROR ) || ( NTStatus == STATUS_IO_TIMEOUT ))
				{
					NTStatus = STATUS_SUCCESS;
				}

				if( NTStatus == STATUS_SUCCESS )
				{
					//	let the lib evaluate the result & setup the next APDU
					NTStatus = SmartcardT1Reply( SmartcardExtension );
				}
			}
		}

	//	continue if the lib wants to send the next packet
	} while( NTStatus == STATUS_MORE_PROCESSING_REQUIRED );

	if( NTStatus == STATUS_IO_TIMEOUT )
	{
		NTStatus = STATUS_DEVICE_PROTOCOL_ERROR;
	}

	SmartcardDebug( DEBUG_TRACE,( "SCMSTCS!CBT1Transmit Exit: %X\n", NTStatus ));

	return ( NTStatus );
}

NTSTATUS
CBRawTransmit(		
	PSMARTCARD_EXTENSION SmartcardExtension
	)
/*++

CBRawTransmit:
	finishes the callback RDF_TRANSMIT for the RAW protocol

Arguments:
	SmartcardExtension	context of call

Return Value:
	STATUS_SUCCESS
	STATUS_NO_MEDIA
	STATUS_TIMEOUT
	STATUS_INVALID_DEVICE_REQUEST

--*/
{
    NTSTATUS			NTStatus = STATUS_SUCCESS;

	NTStatus = STATUS_UNSUCCESSFUL;
	SmartcardDebug( DEBUG_TRACE, ("SCMSTCS!CBRawTransmit Exit: %X\n", NTStatus ));
	return ( NTStatus );
}

NTSTATUS
CBCardTracking(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
/*++

CBCardTracking:
	callback handler for SMCLIB RDF_CARD_TRACKING. the requested event was 
	validated by the smclib (i.e. a card removal request will only be passed 
	if a card is present).
	for a win95 build STATUS_PENDING will be returned without any other action. 
	for NT the cancel routine for the irp will be set to the drivers cancel
	routine.

Arguments:
	SmartcardExtension	context of call

Return Value:
	STATUS_PENDING

--*/
{
	SmartcardDebug( DEBUG_TRACE, ("SCMSTCS!CBCardTracking Enter\n" ));

#if defined( SMCLIB_VXD )

#else

	{
		KIRQL		CurrentIrql;

		//	set cancel routine
		IoAcquireCancelSpinLock( &CurrentIrql );
		IoSetCancelRoutine(
			SmartcardExtension->OsData->NotificationIrp, 
			DrvCancel
			);

		IoReleaseCancelSpinLock( CurrentIrql );
	}

#endif

	SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!CBCardTracking Exit\n" ));

	return( STATUS_PENDING );

}

VOID
CBUpdateCardState(
	PSMARTCARD_EXTENSION SmartcardExtension,
    ULONG RequestedState
	)
/*++

CBUpdateCardState:
	updates the variable CurrentState in SmartcardExtension

Arguments:
	SmartcardExtension	context of call

Return Value:
	STATUS_SUCCESS

--*/
{
	NTSTATUS	NTStatus = STATUS_SUCCESS;
	UCHAR		Status;
    KIRQL       Irql;
    BOOLEAN     StateChanged = FALSE;
    ULONG       NewState = RequestedState;

    if (RequestedState == SCARD_UNKNOWN) {
     	
	    //	read card state from reader
	    NTStatus = STCReadSTCRegister(
		    SmartcardExtension->ReaderExtension,
		    ADR_IO_CONFIG,
		    1,
		    &Status
		    );

        ASSERT(NTStatus == STATUS_SUCCESS);

        if (NTStatus == STATUS_SUCCESS) {

            if ((Status & M_SD) == 0) {

                NewState = SCARD_ABSENT;

            } else {

                NewState = SCARD_SWALLOWED;         	
            }
        }
    } 

    if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_UNKNOWN ||
		SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT && 
        NewState <= SCARD_ABSENT ||
        SmartcardExtension->ReaderCapabilities.CurrentState <= SCARD_ABSENT && 
        NewState > SCARD_ABSENT) {

        StateChanged = TRUE;  	
    }

    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock, &Irql);

	if(RequestedState != SCARD_UNKNOWN || 
       NTStatus == STATUS_SUCCESS && StateChanged)
	{
        SmartcardExtension->ReaderCapabilities.CurrentState = NewState;
	}

#if defined( SMCLIB_VXD )
	//
	//	if a tracking request is pending, finish it (even if an error occured!)
	//	to prevent a hangup of an application
	//
	if( SmartcardExtension->OsData->NotificationOverlappedData != NULL ) 
	{
		SmartcardCompleteCardTracking( SmartcardExtension );
	}
	
#else

	if(StateChanged && SmartcardExtension->OsData->NotificationIrp != NULL)
	{
		KIRQL CurrentIrql;
		IoAcquireCancelSpinLock( &CurrentIrql );

		IoSetCancelRoutine( SmartcardExtension->OsData->NotificationIrp, NULL );
		IoReleaseCancelSpinLock( CurrentIrql );

		SmartcardExtension->OsData->NotificationIrp->IoStatus.Status = 
            STATUS_SUCCESS;
		SmartcardExtension->OsData->NotificationIrp->IoStatus.Information = 0;

		IoCompleteRequest( 
            SmartcardExtension->OsData->NotificationIrp, 
            IO_NO_INCREMENT 
            );

		SmartcardExtension->OsData->NotificationIrp = NULL;
	}

    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock, Irql);
#endif
}

NTSTATUS
CBSynchronizeSTC(
	PSMARTCARD_EXTENSION SmartcardExtension 
	)
/*++

CBSynchronizeSTC:
	updates the card dependend data of the stc (wait times, ETU...)

Arguments:
	SmartcardExtension	context of call

Return Value:
	STATUS_SUCCESS

--*/

{
	NTSTATUS				NTStatus = STATUS_SUCCESS;
	PREADER_EXTENSION		ReaderExtension;
	ULONG					CWT,
							BWT,
							CGT,
							ETU;
	UCHAR					Dl,
							Fl,
							N;

	PCLOCK_RATE_CONVERSION	ClockRateConversion;
	PBIT_RATE_ADJUSTMENT	BitRateAdjustment;

	ReaderExtension		= SmartcardExtension->ReaderExtension;
	ClockRateConversion	= SmartcardExtension->CardCapabilities.ClockRateConversion;
	BitRateAdjustment	= SmartcardExtension->CardCapabilities.BitRateAdjustment;

	//	cycle length
	Dl = SmartcardExtension->CardCapabilities.Dl;
	Fl = SmartcardExtension->CardCapabilities.Fl;

	ETU = ClockRateConversion[Fl & 0x0F].F;

	ETU /= BitRateAdjustment[ Dl & 0x0F ].DNumerator;
	ETU *= BitRateAdjustment[ Dl & 0x0F ].DDivisor;

	// ETU += (ETU % 2 == 0) ? 0 : 1;

	//	a extra guard time of 0xFF means minimum delay in both directions
	N = SmartcardExtension->CardCapabilities.N;
	if( N == 0xFF )
	{
		N = 0;
	}

	//	set character waiting & guard time
	switch ( SmartcardExtension->CardCapabilities.Protocol.Selected )
	{
		case SCARD_PROTOCOL_T0:
			CWT = 960 * SmartcardExtension->CardCapabilities.T0.WI;
			CGT =  14 + N;
			break;

		case SCARD_PROTOCOL_T1:
			CWT = 1000 + ( 0x01 << SmartcardExtension->CardCapabilities.T1.CWI );
			BWT = 11 + ( 0x01 << SmartcardExtension->CardCapabilities.T1.BWI ) * 960;

			CGT = 15 + N;	//	12 + N;		sicrypt error

			NTStatus = STCSetBWT( ReaderExtension, BWT * ETU );

			break;

		default:
			NTStatus = STATUS_UNSUCCESSFUL;
			break;
	}

	if(( NTStatus == STATUS_SUCCESS ) && ETU )
	{
		NTStatus = STCSetETU( ReaderExtension, ETU );

		if( NTStatus == STATUS_SUCCESS )
		{
			NTStatus = STCSetCGT( ReaderExtension, CGT );

			if( NTStatus == STATUS_SUCCESS )
			{
				NTStatus = STCSetCWT( ReaderExtension, CWT * ETU );
			}
		}
	}
	return( NTStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\sccmusbm\scusbwdm.c ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmeu0/sw/sccmusbm.ms/rcs/scusbwdm.c $
* $Revision: 1.9 $
*-----------------------------------------------------------------------------
* $Author: WFrischauf $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  2000 OMNIKEY AG
******************************************************************************/



#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include "usbdi.h"
#include "usbdlib.h"
#include "sccmusbm.h"

BOOLEAN DeviceSlot[MAXIMUM_USB_READERS];

STRING   OemName[MAXIMUM_OEM_NAMES];
CHAR     OemNameBuffer[MAXIMUM_OEM_NAMES][64];
BOOLEAN  OemDeviceSlot[MAXIMUM_OEM_NAMES][MAXIMUM_USB_READERS];


/*****************************************************************************
Routine Description:

Arguments:


Return Value:

*****************************************************************************/
PURB CMUSB_BuildAsyncRequest(
                            IN PDEVICE_OBJECT DeviceObject,
                            IN PIRP Irp,
                            IN PUSBD_PIPE_INFORMATION PipeHandle
                            )
{
   ULONG siz;
   ULONG length;
   PURB urb = NULL;
   PDEVICE_EXTENSION DeviceExtension;
   PUSBD_INTERFACE_INFORMATION interface;
   PUSBD_PIPE_INFORMATION pipeHandle = NULL;
   PSMARTCARD_EXTENSION SmartcardExtension;


   siz = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
   urb = ExAllocatePool(NonPagedPool, siz);

   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;


   if (urb != NULL)
      {
      RtlZeroMemory(urb, siz);

      urb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT) siz;
      urb->UrbBulkOrInterruptTransfer.Hdr.Function =
      URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
      urb->UrbBulkOrInterruptTransfer.PipeHandle =
      PipeHandle->PipeHandle;
      urb->UrbBulkOrInterruptTransfer.TransferFlags =
      USBD_TRANSFER_DIRECTION_IN;

      // short packet is not treated as an error.
      urb->UrbBulkOrInterruptTransfer.TransferFlags |=
      USBD_SHORT_TRANSFER_OK;

      //
      // not using linked urb's
      //
      urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;

      urb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;

      urb->UrbBulkOrInterruptTransfer.TransferBufferLength =
      SmartcardExtension->SmartcardReply.BufferLength;

      urb->UrbBulkOrInterruptTransfer.TransferBuffer =
      SmartcardExtension->SmartcardReply.Buffer;

      }


   return urb;
}


/*****************************************************************************
Routine Description:

Arguments:


Return Value:

*****************************************************************************/
NTSTATUS CMUSB_AsyncReadComplete(
                                IN PDEVICE_OBJECT DeviceObject,
                                IN PIRP Irp,
                                IN PVOID Context
                                )
{
   PURB                 urb;
   PCMUSB_RW_CONTEXT context = Context;
   PIO_STACK_LOCATION   irpStack;
   PDEVICE_OBJECT       deviceObject;
   PDEVICE_EXTENSION    DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;

   urb = context->Urb;
   deviceObject = context->DeviceObject;
   DeviceExtension = deviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;

   //
   // set the length based on the TransferBufferLength
   // value in the URB
   //
   if (Irp->IoStatus.Status  == STATUS_SUCCESS)
      {
      SmartcardExtension->SmartcardReply.BufferLength = urb->UrbBulkOrInterruptTransfer.TransferBufferLength;
      SmartcardExtension->ReaderExtension->fP1Stalled = FALSE;
      }
   else
      {
      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!Irp->IoStatus.Status = %lx\n",DRIVER_NAME,Irp->IoStatus.Status));

      SmartcardExtension->SmartcardReply.BufferLength = 0;
      SmartcardExtension->ReaderExtension->fP1Stalled = TRUE;
      }


   SmartcardExtension->SmartcardReply.BufferLength = urb->UrbBulkOrInterruptTransfer.TransferBufferLength;


   CMUSB_DecrementIoCount(deviceObject);


   ExFreePool(context);
   ExFreePool(urb);
   IoFreeIrp(Irp);

   /*
   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!AsyncReadWriteComplete <%ld>\n",
                   DRIVER_NAME,SmartcardExtension->SmartcardReply.BufferLength)
                 );
   */
   KeSetEvent(&DeviceExtension->ReadP1Completed,0,FALSE);

   return STATUS_MORE_PROCESSING_REQUIRED;
}



/*****************************************************************************
Routine Description:

Arguments:


Return Value:
        NT NTStatus

*****************************************************************************/
#define TIMEOUT_P1_RESPONSE       100
NTSTATUS CMUSB_ReadP1(
                     IN PDEVICE_OBJECT DeviceObject
                     )
{
   NTSTATUS NTStatus;
   NTSTATUS DebugStatus;
   PIO_STACK_LOCATION nextStack;
   PURB urb;
   PCMUSB_RW_CONTEXT context = NULL;
   PDEVICE_EXTENSION DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;
   PUSBD_INTERFACE_INFORMATION interface;
   PUSBD_PIPE_INFORMATION pipeHandle = NULL;
   CHAR cStackSize;
   PIRP IrpToUSB = NULL;
   ULONG ulBytesToRead;
   ULONG i;
   LARGE_INTEGER   liTimeoutP1;
   LARGE_INTEGER   liTimeoutP1Response;
   BOOLEAN         fStateTimer;
   UCHAR           bTmp;
   LONG            lNullPackets;
   BOOLEAN         fCancelTimer = FALSE;

   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ReadP1: Enter\n",DRIVER_NAME)
                 );
   */

   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;
   interface       = DeviceExtension->UsbInterface;
   pipeHandle      =  &interface->Pipes[0];
   if (pipeHandle == NULL)
      {
      NTStatus = STATUS_INVALID_HANDLE;
      goto ExitCMUSB_ReadP1;
      }




   liTimeoutP1 = RtlConvertLongToLargeInteger(SmartcardExtension->ReaderExtension->ulTimeoutP1 * -10000);
   KeSetTimer(&SmartcardExtension->ReaderExtension->P1Timer,
              liTimeoutP1,
              NULL);
   fCancelTimer = TRUE;


   // we will always read a whole packet (== 8 bytes)
   ulBytesToRead = 8;

   cStackSize = (CCHAR)(DeviceExtension->TopOfStackDeviceObject->StackSize+1);

   lNullPackets = -1;
   do
      {
      fStateTimer = KeReadStateTimer(&SmartcardExtension->ReaderExtension->P1Timer);
      if (fStateTimer == TRUE)
         {
         fCancelTimer = FALSE;
         NTStatus = STATUS_IO_TIMEOUT;
         SmartcardExtension->SmartcardReply.BufferLength = 0L;
         SmartcardDebug(DEBUG_PROTOCOL,
                        ("%s!Timeout (%ld)while reading from P1\n",
                         DRIVER_NAME,SmartcardExtension->ReaderExtension->ulTimeoutP1)
                       );
         break;
         }



      SmartcardExtension->SmartcardReply.BufferLength = ulBytesToRead;

      IrpToUSB = IoAllocateIrp(cStackSize,FALSE);
      if (IrpToUSB==NULL)
         {
         SmartcardExtension->SmartcardReply.BufferLength = 0L;
         NTStatus = STATUS_INSUFFICIENT_RESOURCES;
         goto ExitCMUSB_ReadP1;
         }


      urb = CMUSB_BuildAsyncRequest(DeviceObject,
                                    IrpToUSB,
                                    pipeHandle
                                   );


      if (urb != NULL)
         {
         context = ExAllocatePool(NonPagedPool, sizeof(CMUSB_RW_CONTEXT));
         }

      if (urb != NULL && context != NULL)
         {
         context->Urb = urb;
         context->DeviceObject = DeviceObject;
         context->Irp =  IrpToUSB;

         nextStack = IoGetNextIrpStackLocation(IrpToUSB);
         ASSERT(nextStack != NULL);
         ASSERT(DeviceObject->StackSize>1);

         nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
         nextStack->Parameters.Others.Argument1 = urb;
         nextStack->Parameters.DeviceIoControl.IoControlCode =
         IOCTL_INTERNAL_USB_SUBMIT_URB;


         IoSetCompletionRoutine(IrpToUSB,
                                CMUSB_AsyncReadComplete,
                                context,
                                TRUE,
                                TRUE,
                                TRUE);


         ASSERT(DeviceExtension->TopOfStackDeviceObject);
         ASSERT(IrpToUSB);


         KeClearEvent(&DeviceExtension->ReadP1Completed);

         CMUSB_IncrementIoCount(DeviceObject);

         NTStatus = IoCallDriver(DeviceExtension->TopOfStackDeviceObject,
                                 IrpToUSB);


         liTimeoutP1Response = RtlConvertLongToLargeInteger(TIMEOUT_P1_RESPONSE * -10000);


         NTStatus = KeWaitForSingleObject(&DeviceExtension->ReadP1Completed,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          &liTimeoutP1Response);
         if (NTStatus == STATUS_TIMEOUT)
            {
            // probably the device has been removed
            // there must be at least a null packet received during liTimeoutReponse
            SmartcardExtension->SmartcardReply.BufferLength = 0L;
            break;
            }

         // -----------------------------
         // check if P1 has been stalled
         // -----------------------------
         if (SmartcardExtension->ReaderExtension->fP1Stalled == TRUE)
            {
            break;
            }
         }
      else
         {
         SmartcardExtension->SmartcardReply.BufferLength = 0L;
         NTStatus = STATUS_INSUFFICIENT_RESOURCES;
         break;
         }


      lNullPackets++;
      } while (SmartcardExtension->SmartcardReply.BufferLength == 0L);



   // -----------------------------
   // check if P1 has been stalled
   // -----------------------------
   if (SmartcardExtension->ReaderExtension->fP1Stalled == TRUE)
      {
      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!P1 stalled \n",DRIVER_NAME));
      NTStatus = STATUS_DEVICE_DATA_ERROR;

      // wait to be sure that we have a stable card state
      CMUSB_Wait (50);

      // P1 has been stalled ==> we must reset the pipe and send a NTStatus to enable it again
      DebugStatus = CMUSB_ResetPipe(DeviceObject,pipeHandle);

      }
   else
      {
      // if no bytes have been received , NTStatus has already been set
      // to STATUS_TIMEOUT
      if (SmartcardExtension->SmartcardReply.BufferLength > 0 )
         {
         NTStatus = STATUS_SUCCESS;

#if DBG
         SmartcardDebug(DEBUG_PROTOCOL,("%s!<==[P1] <%ld> ",DRIVER_NAME,lNullPackets));

         for (i=0;i< SmartcardExtension->SmartcardReply.BufferLength;i++)
            {
            bTmp =  SmartcardExtension->SmartcardReply.Buffer[i];
            if (SmartcardExtension->ReaderExtension->fInverseAtr &&
                SmartcardExtension->ReaderExtension->ulTimeoutP1 != DEFAULT_TIMEOUT_P1)
               {
               //CMUSB_InverseBuffer(&bTmp,1);
               SmartcardDebug(DEBUG_PROTOCOL,("%x ",bTmp));
               }
            else
               {
               SmartcardDebug(DEBUG_PROTOCOL,("%x ",bTmp));
               }
            }

         SmartcardDebug(DEBUG_PROTOCOL,("(%ld)\n",SmartcardExtension->SmartcardReply.BufferLength));
#endif

         }
      }



   ExitCMUSB_ReadP1:
   if (fCancelTimer == TRUE)
      {
      // cancel timer
      // TRUE if the timer is in the queue
      // FALSE if the timer is not in queue
      KeCancelTimer(&SmartcardExtension->ReaderExtension->P1Timer);
      }

   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ReadP1: Exit %lx\n",DRIVER_NAME,NTStatus));
   */

   return NTStatus;

}


/*****************************************************************************
Routine Description:

Arguments:


Return Value:
        NT NTStatus

*****************************************************************************/
NTSTATUS CMUSB_ReadP1_T0(
                        IN PDEVICE_OBJECT DeviceObject
                        )
{
   NTSTATUS NTStatus;
   PIO_STACK_LOCATION nextStack;
   PURB urb;
   PCMUSB_RW_CONTEXT context = NULL;
   PDEVICE_EXTENSION DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;
   PUSBD_INTERFACE_INFORMATION interface;
   PUSBD_PIPE_INFORMATION pipeHandle = NULL;
   CHAR cStackSize;
   PIRP IrpToUSB = NULL;
   ULONG ulBytesToRead;

   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ReadP1_T0: Enter\n",DRIVER_NAME));
   */


   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;
   interface       = DeviceExtension->UsbInterface;
   pipeHandle      =  &interface->Pipes[0];
   if (pipeHandle == NULL)
      {
      NTStatus = STATUS_INVALID_HANDLE;
      goto ExitCMUSB_ReadP1;
      }


   ulBytesToRead = SmartcardExtension->SmartcardReply.BufferLength;
   cStackSize = (CCHAR)(DeviceExtension->TopOfStackDeviceObject->StackSize+1);


   IrpToUSB = IoAllocateIrp(cStackSize,FALSE);
   if (IrpToUSB==NULL)
      {
      SmartcardExtension->SmartcardReply.BufferLength = 0L;
      NTStatus = STATUS_INSUFFICIENT_RESOURCES;
      goto ExitCMUSB_ReadP1;
      }

   urb = CMUSB_BuildAsyncRequest(DeviceObject,IrpToUSB,pipeHandle);

   if (urb != NULL)
      {
      context = ExAllocatePool(NonPagedPool, sizeof(CMUSB_RW_CONTEXT));
      }

   if (urb != NULL && context != NULL)
      {
      context->Urb = urb;
      context->DeviceObject = DeviceObject;
      context->Irp =  IrpToUSB;

      nextStack = IoGetNextIrpStackLocation(IrpToUSB);
      ASSERT(nextStack != NULL);
      ASSERT(DeviceObject->StackSize>1);

      nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
      nextStack->Parameters.Others.Argument1 = urb;
      nextStack->Parameters.DeviceIoControl.IoControlCode =
      IOCTL_INTERNAL_USB_SUBMIT_URB;


      IoSetCompletionRoutine(IrpToUSB,
                             CMUSB_AsyncReadComplete,
                             context,
                             TRUE,
                             TRUE,
                             TRUE);


      ASSERT(DeviceExtension->TopOfStackDeviceObject);
      ASSERT(IrpToUSB);


      KeClearEvent(&DeviceExtension->ReadP1Completed);

      CMUSB_IncrementIoCount(DeviceObject);
      /*
      SmartcardDebug(DEBUG_PROTOCOL,
                     ("%s!bytes to read from P1 =%ld\n",DRIVER_NAME,ulBytesToRead));
      */
      NTStatus = IoCallDriver(DeviceExtension->TopOfStackDeviceObject,
                              IrpToUSB);
      /*
      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!IoCallDriver returned %lx\n",DRIVER_NAME,NTStatus));
      */
      if (NTStatus == STATUS_PENDING)
         NTStatus = STATUS_SUCCESS;

      }
   else
      {
      SmartcardExtension->SmartcardReply.BufferLength = 0L;
      NTStatus = STATUS_INSUFFICIENT_RESOURCES;
      }



   ExitCMUSB_ReadP1:
   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ReadP1_T0: Exit %lx\n",DRIVER_NAME,NTStatus));
   */
   return NTStatus;

}



/*****************************************************************************
Routine Description:

    Dispatch table routine for IRP_MJ_PNP.
    Process the Plug and Play IRPs sent to this device.

Arguments:

    DeviceObject - pointer to our FDO (Functional Device Object)

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT NTStatus code

*****************************************************************************/
NTSTATUS CMUSB_ProcessPnPIrp(
                            IN PDEVICE_OBJECT DeviceObject,
                            IN PIRP           Irp
                            )
{
   PIO_STACK_LOCATION irpStack;
   PDEVICE_EXTENSION DeviceExtension;
   NTSTATUS NTStatus = STATUS_SUCCESS;
   NTSTATUS waitStatus;
   NTSTATUS DebugStatus;
   PDEVICE_OBJECT stackDeviceObject;
   KEVENT startDeviceEvent;
   PDEVICE_CAPABILITIES DeviceCapabilities;
   KEVENT               event;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ProcessPnPIrp: Enter\n",DRIVER_NAME));

   //
   // Get a pointer to the device extension
   //
   DeviceExtension = DeviceObject->DeviceExtension;
   stackDeviceObject = DeviceExtension->TopOfStackDeviceObject;

   //
   // Acquire remove lock,
   // so that device can not be removed while
   // this function is executed
   //
   NTStatus = SmartcardAcquireRemoveLock(&DeviceExtension->SmartcardExtension);
   ASSERT(NTStatus == STATUS_SUCCESS);
   if (NTStatus != STATUS_SUCCESS)
      {
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = NTStatus;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return NTStatus;
      }

   //
   // Get a pointer to the current location in the Irp. This is where
   // the function codes and parameters are located.
   //
   irpStack = IoGetCurrentIrpStackLocation (Irp);

   // inc the FDO device extension's pending IO count for this Irp
   CMUSB_IncrementIoCount(DeviceObject);

   CMUSB_ASSERT( IRP_MJ_PNP == irpStack->MajorFunction );

   switch (irpStack->MinorFunction)
      {
      // ---------------------
      // IRP_MN_START_DEVICE
      // ---------------------
      case IRP_MN_START_DEVICE:
         // The PnP Manager sends this IRP after it has assigned resources,
         // if any, to the device. The device may have been recently enumerated
         // and is being started for the first time, or the device may be
         // restarting after being stopped for resource reconfiguration.

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!IRP_MN_START_DEVICE received\n",DRIVER_NAME));

         // Initialize an event we can wait on for the PDO to be done with this irp
         KeInitializeEvent(&startDeviceEvent, NotificationEvent, FALSE);
         IoCopyCurrentIrpStackLocationToNext(Irp);

         // Set a completion routine so it can signal our event when
         // the PDO is done with the Irp
         IoSetCompletionRoutine(Irp,
                                CMUSB_IrpCompletionRoutine,
                                &startDeviceEvent,  // pass the event to the completion routine as the Context
                                TRUE,    // invoke on success
                                TRUE,    // invoke on error
                                TRUE);   // invoke on cancellation


         // let the PDO process the IRP
         NTStatus = IoCallDriver(stackDeviceObject,Irp);

         // if PDO is not done yet, wait for the event to be set in our completion routine
         if (NTStatus == STATUS_PENDING)
            {
            // wait for irp to complete

            waitStatus = KeWaitForSingleObject(&startDeviceEvent,
                                               Suspended,
                                               KernelMode,
                                               FALSE,
                                               NULL);

            NTStatus = Irp->IoStatus.Status;
            }

         if (NT_SUCCESS(NTStatus))
            {
            // Now we're ready to do our own startup processing.
            // USB client drivers such as us set up URBs (USB Request Packets) to send requests
            // to the host controller driver (HCD). The URB structure defines a format for all
            // possible commands that can be sent to a USB device.
            // Here, we request the device descriptor and store it,
            // and configure the device.
            NTStatus = CMUSB_StartDevice(DeviceObject);

            Irp->IoStatus.Status = NTStatus;
            }

         IoCompleteRequest (Irp,IO_NO_INCREMENT);
         CMUSB_DecrementIoCount(DeviceObject);

         // Release the remove lock
         SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

         return NTStatus;  // end, case IRP_MN_START_DEVICE


         // ------------------------
         // IRP_MN_QUERY_STOP_DEVICE
         // ------------------------
      case IRP_MN_QUERY_STOP_DEVICE:
         // The IRP_MN_QUERY_STOP_DEVICE/IRP_MN_STOP_DEVICE sequence only occurs
         // during "polite" shutdowns, such as the user explicitily requesting the
         // service be stopped in, or requesting unplug from the Pnp tray icon.
         // This sequence is NOT received during "impolite" shutdowns,
         // such as someone suddenly yanking the USB cord or otherwise
         // unexpectedly disabling/resetting the device.

         // If a driver sets STATUS_SUCCESS for this IRP,
         // the driver must not start any operations on the device that
         // would prevent that driver from successfully completing an IRP_MN_STOP_DEVICE
         // for the device.
         // For mass storage devices such as disk drives, while the device is in the
         // stop-pending state,the driver holds IRPs that require access to the device,
         // but for most USB devices, there is no 'persistent storage', so we will just
         // refuse any more IO until restarted or the stop is cancelled

         // If a driver in the device stack determines that the device cannot be
         // stopped for resource reconfiguration, the driver is not required to pass
         // the IRP down the device stack. If a query-stop IRP fails,
         // the PnP Manager sends an IRP_MN_CANCEL_STOP_DEVICE to the device stack,
         // notifying the drivers for the device that the query has been cancelled
         // and that the device will not be stopped.


         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!IRP_MN_QUERY_STOP_DEVICE\n",DRIVER_NAME));

         // It is possible to receive this irp when the device has not been started
         //  ( as on a boot device )
         if (DeviceExtension->DeviceStarted == FALSE)  // if get when never started, just pass on
            {
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!ProcessPnPIrp: IRP_MN_QUERY_STOP_DEVICE when device not started\n",DRIVER_NAME));
            IoSkipCurrentIrpStackLocation (Irp);
            NTStatus = IoCallDriver (DeviceExtension->TopOfStackDeviceObject, Irp);
            CMUSB_DecrementIoCount(DeviceObject);

            // Release the remove lock
            SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

            return NTStatus;
            }

         // We'll not veto it; pass it on and flag that stop was requested.
         // Once StopDeviceRequested is set no new IOCTL or read/write irps will be passed
         // down the stack to lower drivers; all will be quickly failed
         DeviceExtension->StopDeviceRequested = TRUE;

         break; // end, case IRP_MN_QUERY_STOP_DEVICE


         // -------------------------
         // IRP_MN_CANCEL_STOP_DEVICE
         // -------------------------
      case IRP_MN_CANCEL_STOP_DEVICE:
         // The PnP Manager uses this IRP to inform the drivers for a device
         // that the device will not be stopped for resource reconfiguration.
         // This should only be received after a successful IRP_MN_QUERY_STOP_DEVICE.

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!IRP_MN_CANCEL_STOP_DEVICE received\n",DRIVER_NAME));

         // It is possible to receive this irp when the device has not been started
         if (DeviceExtension->DeviceStarted == FALSE)  // if get when never started, just pass on
            {
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!ProcessPnPIrp: IRP_MN_CANCEL_STOP_DEVICE when device not started\n",DRIVER_NAME));
            IoSkipCurrentIrpStackLocation (Irp);
            NTStatus = IoCallDriver (DeviceExtension->TopOfStackDeviceObject, Irp);
            CMUSB_DecrementIoCount(DeviceObject);

            // Release the remove lock
            SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

            return NTStatus;
            }

         // Reset this flag so new IOCTL and IO Irp processing will be re-enabled
         DeviceExtension->StopDeviceRequested = FALSE;
         Irp->IoStatus.Status = STATUS_SUCCESS;
         break; // end, case IRP_MN_CANCEL_STOP_DEVICE

         // -------------------
         // IRP_MN_STOP_DEVICE
         // -------------------
      case IRP_MN_STOP_DEVICE:
         // The PnP Manager sends this IRP to stop a device so it can reconfigure
         // its hardware resources. The PnP Manager only sends this IRP if a prior
         // IRP_MN_QUERY_STOP_DEVICE completed successfully.

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!IRP_MN_STOP_DEVICE received\n",DRIVER_NAME));

         // Cancel any pending io requests.  (there shouldn't be any)
         //CMUSB_CancelPendingIo( DeviceObject );

         //
         // Send the select configuration urb with a NULL pointer for the configuration
         // handle, this closes the configuration and puts the device in the 'unconfigured'
         // state.
         //
         NTStatus = CMUSB_StopDevice(DeviceObject);
         Irp->IoStatus.Status = NTStatus;

         break; // end, case IRP_MN_STOP_DEVICE


         // --------------------------
         // IRP_MN_QUERY_REMOVE_DEVICE
         // --------------------------
      case IRP_MN_QUERY_REMOVE_DEVICE:
         //  In response to this IRP, drivers indicate whether the device can be
         //  removed without disrupting the system.
         //  If a driver determines it is safe to remove the device,
         //  the driver completes any outstanding I/O requests, arranges to hold any subsequent
         //  read/write requests, and sets Irp->IoStatus.Status to STATUS_SUCCESS. Function
         //  and filter drivers then pass the IRP to the next-lower driver in the device stack.
         //  The underlying bus driver calls IoCompleteRequest.

         //  If a driver sets STATUS_SUCCESS for this IRP, the driver must not start any
         //  operations on the device that would prevent that driver from succesfully completing
         //  an IRP_MN_REMOVE_DEVICE for the device. If a driver in the device stack determines
         //  that the device cannot be removed, the driver is not required to pass the
         //  query-remove IRP down the device stack. If a query-remove IRP fails, the PnP Manager
         //  sends an IRP_MN_CANCEL_REMOVE_DEVICE to the device stack, notifying the drivers for
         //  the device that the query has been cancelled and that the device will not be removed.

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!IRP_MN_QUERY_REMOVE_DEVICE received\n",DRIVER_NAME));

         // It is possible to receive this irp when the device has not been started
         if (DeviceExtension->DeviceStarted == FALSE)  // if get when never started, just pass on
            {
            SmartcardDebug( DEBUG_DRIVER,
                            ("%s!ProcessPnPIrp: IRP_MN_QUERY_STOP_DEVICE when device not started\n",
                             DRIVER_NAME)
                          );
            IoSkipCurrentIrpStackLocation (Irp);
            NTStatus = IoCallDriver (DeviceExtension->TopOfStackDeviceObject, Irp);
            CMUSB_DecrementIoCount(DeviceObject);

            // Release the remove lock
            SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

            return NTStatus;
            }


         if (DeviceExtension->fPnPResourceManager == TRUE)
            {
            // disable the reader
            DebugStatus = IoSetDeviceInterfaceState(&DeviceExtension->PnPDeviceName,FALSE);
            ASSERT(DebugStatus == STATUS_SUCCESS);
            }

         // Once RemoveDeviceRequested is set no new IOCTL or read/write irps will be passed
         // down the stack to lower drivers; all will be quickly failed
         DeviceExtension->RemoveDeviceRequested = TRUE;

         // Wait for any io request pending in our driver to
         // complete before returning success.
         // This  event is set when DeviceExtension->PendingIoCount goes to 1
         waitStatus = KeWaitForSingleObject(&DeviceExtension->NoPendingIoEvent,
                                            Suspended,
                                            KernelMode,
                                            FALSE,
                                            NULL);

         Irp->IoStatus.Status = STATUS_SUCCESS;
         break; // end, case IRP_MN_QUERY_REMOVE_DEVICE

         // ---------------------------
         // IRP_MN_CANCEL_REMOVE_DEVICE
         // ---------------------------
      case IRP_MN_CANCEL_REMOVE_DEVICE:

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!IRP_MN_CANCEL_REMOVE_DEVICE received\n",DRIVER_NAME));
         // The PnP Manager uses this IRP to inform the drivers
         // for a device that the device will not be removed.
         // It is sent only after a successful IRP_MN_QUERY_REMOVE_DEVICE.

         if (DeviceExtension->DeviceStarted == FALSE) // if get when never started, just pass on
            {
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!ProcessPnPIrp: IRP_MN_CANCEL_REMOVE_DEVICE when device not started\n",DRIVER_NAME));
            IoSkipCurrentIrpStackLocation (Irp);
            NTStatus = IoCallDriver (DeviceExtension->TopOfStackDeviceObject, Irp);
            CMUSB_DecrementIoCount(DeviceObject);

            // Release the remove lock
            SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

            return NTStatus;
            }

         if (DeviceExtension->fPnPResourceManager == TRUE)
            {
            DebugStatus = IoSetDeviceInterfaceState(&DeviceExtension->PnPDeviceName,
                                                    TRUE);
            ASSERT(DebugStatus == STATUS_SUCCESS);
            }

         // Reset this flag so new IOCTL and IO Irp processing will be re-enabled
         DeviceExtension->RemoveDeviceRequested = FALSE;
         Irp->IoStatus.Status = STATUS_SUCCESS;

         break; // end, case IRP_MN_CANCEL_REMOVE_DEVICE

         // ---------------------
         // IRP_MN_SURPRISE_REMOVAL
         // ---------------------
      case IRP_MN_SURPRISE_REMOVAL:
         // For a surprise-style device removal ( i.e. sudden cord yank ),
         // the physical device has already been removed so the PnP Manager sends
         // the remove IRP without a prior query-remove. A device can be in any state
         // when it receives a remove IRP as a result of a surprise-style removal.

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!IRP_MN_SURPRISE_REMOVAL received\n",DRIVER_NAME));

         // match the inc at the begining of the dispatch routine
         CMUSB_DecrementIoCount(DeviceObject);

         if (DeviceExtension->fPnPResourceManager == TRUE)
            {
            // disable the reader
            DebugStatus = IoSetDeviceInterfaceState(&DeviceExtension->PnPDeviceName,FALSE);
            ASSERT(DebugStatus == STATUS_SUCCESS);
            }

         // Once RemoveDeviceRequested is set no new IOCTL or read/write irps will be passed
         // down the stack to lower drivers; all will be quickly failed
         DeviceExtension->DeviceSurpriseRemoval = TRUE;


         //
         // Mark this handled
         //
         Irp->IoStatus.Status = STATUS_SUCCESS;

         // We don't explicitly wait for the below driver to complete, but just make
         // the call and go on, finishing cleanup
         IoCopyCurrentIrpStackLocationToNext(Irp);

         NTStatus = IoCallDriver(stackDeviceObject,Irp);

         // Release the remove lock
         SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

         return NTStatus;

         // ---------------------
         // IRP_MN_REMOVE_DEVICE
         // ---------------------
      case IRP_MN_REMOVE_DEVICE:
         // The PnP Manager uses this IRP to direct drivers to remove a device.
         // For a "polite" device removal, the PnP Manager sends an
         // IRP_MN_QUERY_REMOVE_DEVICE prior to the remove IRP. In this case,
         // the device is in the remove-pending state when the remove IRP arrives.
         // For a surprise-style device removal ( i.e. sudden cord yank ),
         // the physical device has already been removed so the PnP Manager sends
         // the remove IRP without a prior query-remove. A device can be in any state
         // when it receives a remove IRP as a result of a surprise-style removal.

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!IRP_MN_REMOVE_DEVICE received\n",DRIVER_NAME));

         // match the inc at the begining of the dispatch routine
         CMUSB_DecrementIoCount(DeviceObject);

         //
         // Once DeviceRemoved is set no new IOCTL or read/write irps will be passed
         // down the stack to lower drivers; all will be quickly failed
         //
         DeviceExtension->DeviceRemoved = TRUE;

         // Cancel any pending io requests; we may not have gotten a query first!
         //CMUSB_CancelPendingIo( DeviceObject );

         // It is possible to receive this irp when the device has not been started
         if (DeviceExtension->DeviceStarted == TRUE)  // if get when never started, just pass on
            {
            // If any pipes are still open, call USBD with URB_FUNCTION_ABORT_PIPE
            // This call will also close the pipes; if any user close calls get through,
            // they will be noops
            CMUSB_AbortPipes( DeviceObject );
            }


         // We don't explicitly wait for the below driver to complete, but just make
         // the call and go on, finishing cleanup
         IoCopyCurrentIrpStackLocationToNext(Irp);

         NTStatus = IoCallDriver(stackDeviceObject,Irp);
         //
         // The final decrement to device extension PendingIoCount == 0
         // will set DeviceExtension->RemoveEvent, enabling device removal.

         // If there is no pending IO at this point, the below decrement will be it.
         // If there is still pending IO,
         // the following CancelPendingIo() call will handle it.
         //
         CMUSB_DecrementIoCount(DeviceObject);


         // wait for any io request pending in our driver to
         // complete for finishing the remove
         KeWaitForSingleObject(&DeviceExtension->RemoveEvent,
                               Suspended,
                               KernelMode,
                               FALSE,
                               NULL);

         //
         // Delete the link and FDO we created
         //
         CMUSB_RemoveDevice(DeviceObject);

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!ProcessPnPIrp: Detaching from %08X\n",DRIVER_NAME,
                         DeviceExtension->TopOfStackDeviceObject));

         IoDetachDevice(DeviceExtension->TopOfStackDeviceObject);

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!ProcessPnPIrp: Deleting %08X\n",DRIVER_NAME,DeviceObject));

         IoDeleteDevice (DeviceObject);

         // don't release remove lock here
         // because it's relesed in RemoveDevice
         return NTStatus; // end, case IRP_MN_REMOVE_DEVICE



         // ---------------------
         // IRP_MN_QUERY_CAPABILITIES
         // ---------------------
      case IRP_MN_QUERY_CAPABILITIES:

         //
         // Get the packet.
         //
         DeviceCapabilities=irpStack->Parameters.DeviceCapabilities.Capabilities;

         if (DeviceCapabilities->Version < 1 ||
             DeviceCapabilities->Size < sizeof(DEVICE_CAPABILITIES))
            {
            //
            // We don't support this version. Fail the requests
            //
            NTStatus = STATUS_UNSUCCESSFUL;
            break;
            }


         //
         // Prepare to pass the IRP down
         //

         // init an event to tell us when the completion routine's been called
         KeInitializeEvent(&event, NotificationEvent, FALSE);

         IoCopyCurrentIrpStackLocationToNext(Irp);
         IoSetCompletionRoutine (Irp,
                                 CMUSB_IrpCompletionRoutine,
                                 &event,  // pass the event as Context to completion routine
                                 TRUE,    // invoke on success
                                 TRUE,    // invoke on error
                                 TRUE);   // invoke on cancellation of the Irp


         NTStatus = IoCallDriver(stackDeviceObject,Irp);
         if (NTStatus == STATUS_PENDING)
            {
            // wait for irp to complete
            NTStatus = KeWaitForSingleObject(&event,
                                             Suspended,
                                             KernelMode,
                                             FALSE,
                                             NULL);
            }

         // We cannot wake the system.
         DeviceCapabilities->SystemWake = PowerSystemUnspecified;
         DeviceCapabilities->DeviceWake = PowerDeviceUnspecified;

         // We have no latencies
         DeviceCapabilities->D1Latency = 0;
         DeviceCapabilities->D2Latency = 0;
         DeviceCapabilities->D3Latency = 0;

         // No locking or ejection
         DeviceCapabilities->LockSupported = FALSE;
         DeviceCapabilities->EjectSupported = FALSE;

         // Device can be physically removed.
         // Technically there is no physical device to remove, but this bus
         // driver can yank the PDO from the PlugPlay system, when ever it
         // receives an IOCTL_GAMEENUM_REMOVE_PORT device control command.
         DeviceCapabilities->Removable = TRUE;

         // Docking device
         DeviceCapabilities->DockDevice = FALSE;

         // Device can not be removed any time
         // it has a removeable media!!
         DeviceCapabilities->SurpriseRemovalOK  = FALSE;

         Irp->IoStatus.Status = NTStatus;
         IoCompleteRequest (Irp,IO_NO_INCREMENT);

         // Decrement IO count
         CMUSB_DecrementIoCount(DeviceObject);
         // Release the remove lock
         SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

         return NTStatus; // end, case IRP_MN_QUERY_CAPABILITIES




         // ---------------------
         // IRP_MN_ not handled
         // ---------------------
      default:
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!ProcessPnPIrp: Minor PnP IOCTL not handled\n",DRIVER_NAME));
      } /* case MinorFunction  */


   if (!NT_SUCCESS(NTStatus))
      {

      // if anything went wrong, return failure  without passing Irp down
      Irp->IoStatus.Status = NTStatus;
      IoCompleteRequest (Irp,IO_NO_INCREMENT);
      CMUSB_DecrementIoCount(DeviceObject);

      // Release the remove lock
      SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

      SmartcardDebug(DEBUG_TRACE,
                     ("%s!ProcessPnPIrp: Exit %lx\n",DRIVER_NAME,NTStatus));
      return NTStatus;
      }

   IoCopyCurrentIrpStackLocationToNext(Irp);

   //
   // All PNP_POWER messages get passed to the TopOfStackDeviceObject
   // we were given in PnPAddDevice
   //
   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!ProcessPnPIrp: Passing PnP Irp down, NTStatus = %x\n",DRIVER_NAME,NTStatus));

   NTStatus = IoCallDriver(stackDeviceObject,Irp);
   CMUSB_DecrementIoCount(DeviceObject);

   // Release the remove lock
   SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ProcessPnPIrp: Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}



/*****************************************************************************
Routine Description:

    This routine is called to create and initialize our Functional Device Object (FDO).
    For monolithic drivers, this is done in DriverEntry(), but Plug and Play devices
    wait for a PnP event

Arguments:

    DriverObject - pointer to the driver object for this instance of CMUSB

    PhysicalDeviceObject - pointer to a device object created by the bus

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

*****************************************************************************/
NTSTATUS CMUSB_PnPAddDevice(
                           IN PDRIVER_OBJECT DriverObject,
                           IN PDEVICE_OBJECT PhysicalDeviceObject
                           )
{
   NTSTATUS                NTStatus = STATUS_SUCCESS;
   PDEVICE_OBJECT          deviceObject = NULL;
   PDEVICE_EXTENSION       DeviceExtension;
   USBD_VERSION_INFORMATION versionInformation;
   ULONG i;



   SmartcardDebug(DEBUG_TRACE,
                  ("%s!PnPAddDevice: Enter\n",DRIVER_NAME));



   //
   // create our funtional device object (FDO)
   //

   NTStatus = CMUSB_CreateDeviceObject(DriverObject,
                                       PhysicalDeviceObject,
                                       &deviceObject);

   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!PnPAddDevice: DeviceObject = %p\n",DRIVER_NAME,deviceObject));


   if (NT_SUCCESS(NTStatus))
      {
      DeviceExtension = deviceObject->DeviceExtension;

      deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

      //
      // we support direct io for read/write
      //
      deviceObject->Flags |= DO_DIRECT_IO;

      //Set this flag causes the driver to not receive a IRP_MN_STOP_DEVICE
      //during suspend and also not get an IRP_MN_START_DEVICE during resume.
      //This is neccesary because during the start device call,
      // the GetDescriptors() call  will be failed by the USB stack.
      deviceObject->Flags |= DO_POWER_PAGABLE;


      // initialize our device extension
      //
      // remember the Physical device Object
      //
      DeviceExtension->PhysicalDeviceObject=PhysicalDeviceObject;

      //
      // Attach to the PDO
      //

      DeviceExtension->TopOfStackDeviceObject =
      IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

      // Get a copy of the physical device's capabilities into a
      // DEVICE_CAPABILITIES struct in our device extension;
      // We are most interested in learning which system power states
      // are to be mapped to which device power states for handling
      // IRP_MJ_SET_POWER Irps.
      CMUSB_QueryCapabilities(PhysicalDeviceObject,
                              &DeviceExtension->DeviceCapabilities);


      // We want to determine what level to auto-powerdown to; This is the lowest
      // sleeping level that is LESS than D3;
      // If all are set to D3, auto powerdown/powerup will be disabled.

      DeviceExtension->PowerDownLevel = PowerDeviceUnspecified; // init to disabled
      for (i=PowerSystemSleeping1; i<= PowerSystemSleeping3; i++)
         {
         if ( DeviceExtension->DeviceCapabilities.DeviceState[i] < PowerDeviceD3 )
            DeviceExtension->PowerDownLevel = DeviceExtension->DeviceCapabilities.DeviceState[i];
         }

#if DBG

      //
      // display the device  caps
      //

      SmartcardDebug( DEBUG_DRIVER,("%s!PnPAddDevice: ----------- DeviceCapabilities ------------\n",
                                    DRIVER_NAME));
      SmartcardDebug( DEBUG_DRIVER,  ("%s!PnPAddDevice: SystemWake  = %s\n",
                                      DRIVER_NAME,
                                      CMUSB_StringForSysState( DeviceExtension->DeviceCapabilities.SystemWake ) ));
      SmartcardDebug( DEBUG_DRIVER,  ("%s!PnPAddDevice: DeviceWake  = %s\n",
                                      DRIVER_NAME,
                                      CMUSB_StringForDevState( DeviceExtension->DeviceCapabilities.DeviceWake) ));

      for (i=PowerSystemUnspecified; i< PowerSystemMaximum; i++)
         {
         SmartcardDebug(DEBUG_DRIVER,("%s!PnPAddDevice: sysstate %s = devstate %s\n",
                                      DRIVER_NAME,
                                      CMUSB_StringForSysState( i ),
                                      CMUSB_StringForDevState( DeviceExtension->DeviceCapabilities.DeviceState[i] ))
                       );
         }
      SmartcardDebug( DEBUG_DRIVER,("PnPAddDevice: ---------------------------------------------\n"));
#endif

      // We keep a pending IO count ( extension->PendingIoCount )  in the device extension.
      // The first increment of this count is done on adding the device.
      // Subsequently, the count is incremented for each new IRP received and
      // decremented when each IRP is completed or passed on.

      // Transition to 'one' therefore indicates no IO is pending and signals
      // DeviceExtension->NoPendingIoEvent. This is needed for processing
      // IRP_MN_QUERY_REMOVE_DEVICE

      // Transition to 'zero' signals an event ( DeviceExtension->RemoveEvent )
      // to enable device removal. This is used in processing for IRP_MN_REMOVE_DEVICE
      //
      CMUSB_IncrementIoCount(deviceObject);

      }

   USBD_GetUSBDIVersion(&versionInformation);



   SmartcardDebug(DEBUG_TRACE,
                  ("%s!PnPAddDevice: Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}


/*****************************************************************************
Routine Description:

    Called from CMUSB_ProcessPnPIrp, the dispatch routine for IRP_MJ_PNP.
    Initializes a given instance of the device on the USB.
    USB client drivers such as us set up URBs (USB Request Packets) to send requests
    to the host controller driver (HCD). The URB structure defines a format for all
    possible commands that can be sent to a USB device.
    Here, we request the device descriptor and store it, and configure the device.


Arguments:

    DeviceObject - pointer to the FDO (Functional Device Object)

Return Value:

    NT NTStatus code

*****************************************************************************/
NTSTATUS CMUSB_StartDevice(
                          IN  PDEVICE_OBJECT DeviceObject
                          )
{
   PDEVICE_EXTENSION DeviceExtension;
   NTSTATUS NTStatus;
   PUSB_DEVICE_DESCRIPTOR deviceDescriptor = NULL;
   PURB urb;
   ULONG siz;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!StartDevice: Enter\n",DRIVER_NAME));

   DeviceExtension = DeviceObject->DeviceExtension;

   urb = ExAllocatePool(NonPagedPool,
                        sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

   if (urb != NULL)
      {
      siz = sizeof(USB_DEVICE_DESCRIPTOR);

      deviceDescriptor = ExAllocatePool(NonPagedPool,siz);
      if (deviceDescriptor != NULL)
         {
         UsbBuildGetDescriptorRequest(urb,
                                      (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                      USB_DEVICE_DESCRIPTOR_TYPE,
                                      0,
                                      0,
                                      deviceDescriptor,
                                      NULL,
                                      siz,
                                      NULL);

         NTStatus = CMUSB_CallUSBD(DeviceObject, urb);

         if (NT_SUCCESS(NTStatus))
            {
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: Device Descriptor = %x, len %x\n",DRIVER_NAME,deviceDescriptor,
                                          urb->UrbControlDescriptorRequest.TransferBufferLength));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: CardMan USB Device Descriptor:\n",DRIVER_NAME));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: -------------------------\n",DRIVER_NAME));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: bLength %d\n",DRIVER_NAME,deviceDescriptor->bLength));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: bDescriptorType 0x%x\n",DRIVER_NAME,deviceDescriptor->bDescriptorType));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: bcdUSB 0x%x\n",DRIVER_NAME,deviceDescriptor->bcdUSB));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: bDeviceClass 0x%x\n",DRIVER_NAME,deviceDescriptor->bDeviceClass));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: bDeviceSubClass 0x%x\n",DRIVER_NAME,deviceDescriptor->bDeviceSubClass));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: bDeviceProtocol 0x%x\n",DRIVER_NAME,deviceDescriptor->bDeviceProtocol));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: bMaxPacketSize0 0x%x\n",DRIVER_NAME,deviceDescriptor->bMaxPacketSize0));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: idVendor 0x%x\n",DRIVER_NAME,deviceDescriptor->idVendor));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: idProduct 0x%x\n",DRIVER_NAME,deviceDescriptor->idProduct));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: bcdDevice 0x%x\n",DRIVER_NAME,deviceDescriptor->bcdDevice));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: iManufacturer 0x%x\n",DRIVER_NAME,deviceDescriptor->iManufacturer));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: iProduct 0x%x\n",DRIVER_NAME,deviceDescriptor->iProduct));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: iSerialNumber 0x%x\n",DRIVER_NAME,deviceDescriptor->iSerialNumber));
            SmartcardDebug( DEBUG_DRIVER,("%s!StartDevice: bNumConfigurations 0x%x\n",DRIVER_NAME,deviceDescriptor->bNumConfigurations));
            }
         }
      else
         {
         // if we got here we failed to allocate deviceDescriptor
         SmartcardDebug(DEBUG_ERROR,
                        ( "%s!StartDevice: ExAllocatePool for deviceDescriptor failed\n",DRIVER_NAME));
         NTStatus = STATUS_INSUFFICIENT_RESOURCES;
         }

      if (NT_SUCCESS(NTStatus))
         {
         DeviceExtension->UsbDeviceDescriptor = deviceDescriptor;
         // -------------------------------------------------------------
         // copy the firmware version to the reader extension structure
         // -------------------------------------------------------------
         DeviceExtension->SmartcardExtension.ReaderExtension->ulFWVersion =
         (ULONG)(((DeviceExtension->UsbDeviceDescriptor->bcdDevice/256)*100)+
                 (DeviceExtension->UsbDeviceDescriptor->bcdDevice&0x00FF));
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!StartDevice: FW version = %ld\n",DRIVER_NAME,DeviceExtension->SmartcardExtension.ReaderExtension->ulFWVersion));
         }
      else if (deviceDescriptor != NULL)
         {
         ExFreePool(deviceDescriptor);
         }

      ExFreePool(urb);

      }
   else
      {
      // if we got here we failed to allocate the urb
      SmartcardDebug(DEBUG_ERROR,
                     ("%s!StartDevice: ExAllocatePool for usb failed\n",DRIVER_NAME));
      NTStatus = STATUS_INSUFFICIENT_RESOURCES;
      }

   if (NT_SUCCESS(NTStatus))
      {
      NTStatus = CMUSB_ConfigureDevice(DeviceObject);
      }


   if (NT_SUCCESS(NTStatus))
      {
      NTStatus = CMUSB_StartCardTracking(DeviceObject);
      }

   if (NT_SUCCESS(NTStatus) && DeviceExtension->fPnPResourceManager == TRUE)
      {
      // enable interface
      NTStatus = IoSetDeviceInterfaceState(&DeviceExtension->PnPDeviceName,TRUE);
      }

   if (NT_SUCCESS(NTStatus))
      {
      DeviceExtension->DeviceStarted = TRUE;
      }

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!StartDevice: Exit %ld\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}





/*****************************************************************************

Routine Description:

   Called from CMUSB_ProcessPnPIrp: to
   clean up our device instance's allocated buffers; free symbolic links

Arguments:

    DeviceObject - pointer to the FDO

Return Value:

    NT NTStatus code from free symbolic link operation

*****************************************************************************/
NTSTATUS CMUSB_RemoveDevice(
                           IN  PDEVICE_OBJECT DeviceObject
                           )
{
   PDEVICE_EXTENSION DeviceExtension;
   PSMARTCARD_EXTENSION  SmartcardExtension;
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UNICODE_STRING deviceLinkUnicodeString;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!RemoveDevice: Enter\n",DRIVER_NAME));

   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;


   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!RemoveDevice: DeviceStarted=%ld\n",DRIVER_NAME,DeviceExtension->DeviceStarted));
   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!RemoveDevice: DeviceOpened=%ld\n",DRIVER_NAME,DeviceExtension->lOpenCount));

   if (SmartcardExtension->OsData != NULL)
      {
      // complete pending card tracking requests (if any)
      if (SmartcardExtension->OsData->NotificationIrp != NULL)
         {
         CMUSB_CompleteCardTracking(SmartcardExtension);
         }
      ASSERT(SmartcardExtension->OsData->NotificationIrp == NULL);
      }

   // Wait until we can safely unload the device
   SmartcardReleaseRemoveLockAndWait(SmartcardExtension);

   if (DeviceExtension->DeviceStarted == TRUE)
      {
      if (DeviceExtension->fPnPResourceManager == FALSE)
         {
         KeWaitForSingleObject(&SmartcardExtension->ReaderExtension->CardManIOMutex,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

         // issue a card removal event for the resource manager
         if (SmartcardExtension->ReaderExtension->ulOldCardState == INSERTED  ||
             SmartcardExtension->ReaderExtension->ulOldCardState == POWERED     )
            {
            // card has been removed

            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!RemoveDevice: Smartcard removed\n",DRIVER_NAME));

            CMUSB_CompleteCardTracking(SmartcardExtension);

            SmartcardExtension->ReaderExtension->ulOldCardState = UNKNOWN;
            SmartcardExtension->ReaderExtension->ulNewCardState = UNKNOWN;
            SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_ABSENT;
            SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
            SmartcardExtension->CardCapabilities.ATR.Length        = 0;

            RtlFillMemory((PVOID)&SmartcardExtension->ReaderExtension->CardParameters,
                          sizeof(CARD_PARAMETERS),0x00);

            }
         KeReleaseMutex(&SmartcardExtension->ReaderExtension->CardManIOMutex,FALSE);
         }

      CMUSB_StopDevice(DeviceObject);
      }

   if (DeviceExtension->fPnPResourceManager == TRUE)
      {
      // disable interface

      NTStatus = IoSetDeviceInterfaceState(&DeviceExtension->PnPDeviceName,
                                           FALSE);

      if (DeviceExtension->PnPDeviceName.Buffer != NULL)
         {
         RtlFreeUnicodeString(&DeviceExtension->PnPDeviceName);
         DeviceExtension->PnPDeviceName.Buffer = NULL;
         }

      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!RemoveDevice: PnPDeviceName.Buffer  = %lx\n",DRIVER_NAME,
                      DeviceExtension->PnPDeviceName.Buffer));
      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!RemoveDevice: PnPDeviceName.BufferLength  = %lx\n",DRIVER_NAME,
                      DeviceExtension->PnPDeviceName.Length));
      }
   else
      {
      //
      // Delete the symbolic link of the smart card reader
      //
      IoDeleteSymbolicLink(&DeviceExtension->DosDeviceName);
      }

   DeviceSlot[SmartcardExtension->ReaderExtension->ulDeviceInstance] = FALSE;
   OemDeviceSlot[SmartcardExtension->ReaderExtension->ulOemNameIndex][SmartcardExtension->ReaderExtension->ulOemDeviceInstance] = FALSE;

   if (DeviceExtension->lOpenCount == 0)
      {
      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!RemoveDevice: freeing resources\n",DRIVER_NAME));

      if (DeviceExtension->fPnPResourceManager == FALSE)
         {
         //
         // Free all allocated buffer
         //
         ExFreePool(DeviceExtension->DosDeviceName.Buffer);
         }

      ExFreePool(SmartcardExtension->ReaderExtension);
      SmartcardExtension->ReaderExtension = NULL;
      //
      // Let the lib free the send/receive buffers
      //
      SmartcardExit(SmartcardExtension);
      }

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!RemoveDevice: Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}




/*****************************************************************************

Routine Description:

    Stops a given instance of a 82930 device on the USB.
    We basically just tell USB this device is now 'unconfigured'

Arguments:

    DeviceObject - pointer to the device object for this instance of a 82930

Return Value:

    NT NTStatus code

*****************************************************************************/
NTSTATUS CMUSB_StopDevice(
                         IN  PDEVICE_OBJECT DeviceObject
                         )
{
   PDEVICE_EXTENSION DeviceExtension;
   PSMARTCARD_EXTENSION  SmartcardExtension;
   NTSTATUS NTStatus = STATUS_SUCCESS;
   PURB urb;
   ULONG siz;


   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!StopDevice: Enter\n",DRIVER_NAME));

   DeviceExtension = DeviceObject->DeviceExtension;


   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!StopDevice: DeviceStarted=%ld\n",DRIVER_NAME,
                   DeviceExtension->DeviceStarted));
   SmartcardDebug( DEBUG_DRIVER,
                   ("%s!StopDevice: DeviceOpened=%ld\n",DRIVER_NAME,
                    DeviceExtension->lOpenCount));

   // stop update thread
   CMUSB_StopCardTracking(DeviceObject);

   // power down the card for saftey reasons
   if (DeviceExtension->SmartcardExtension.ReaderExtension->ulOldCardState == POWERED)
      {
      // we have to wait for the mutex before
      KeWaitForSingleObject(&DeviceExtension->SmartcardExtension.ReaderExtension->CardManIOMutex,
                            Executive,
                            KernelMode,
                            FALSE,
                            NULL);
      CMUSB_PowerOffCard(&DeviceExtension->SmartcardExtension);
      KeReleaseMutex(&DeviceExtension->SmartcardExtension.ReaderExtension->CardManIOMutex,
                     FALSE);
      }


   //
   // Send the select configuration urb with a NULL pointer for the configuration
   // handle. This closes the configuration and puts the device in the 'unconfigured'
   // state.
   //
   siz = sizeof(struct _URB_SELECT_CONFIGURATION);
   urb = ExAllocatePool(NonPagedPool,siz);
   if (urb != NULL)
      {
      UsbBuildSelectConfigurationRequest(urb,
                                         (USHORT) siz,
                                         NULL);
      NTStatus = CMUSB_CallUSBD(DeviceObject, urb);
      ExFreePool(urb);
      }
   else
      {
      NTStatus = STATUS_INSUFFICIENT_RESOURCES;
      }

   // now clear the flag whcih indicates if the device is started
   DeviceExtension->DeviceStarted = FALSE;

   DeviceExtension->StopDeviceRequested = FALSE;


   //
   // Free device descriptor structure
   //
   if (DeviceExtension->UsbDeviceDescriptor != NULL)
      {
      SmartcardDebug( DEBUG_DRIVER,
                      ("%s!StopDevice: freeing UsbDeviceDescriptor\n",DRIVER_NAME,NTStatus));
      ExFreePool(DeviceExtension->UsbDeviceDescriptor);
      DeviceExtension->UsbDeviceDescriptor = NULL;
      }

   //
   // Free up the UsbInterface structure
   //
   if (DeviceExtension->UsbInterface != NULL)
      {
      SmartcardDebug( DEBUG_DRIVER,
                      ("%s!StopDevice: freeing UsbInterface\n",DRIVER_NAME,NTStatus));
      ExFreePool(DeviceExtension->UsbInterface);
      DeviceExtension->UsbInterface = NULL;
      }

   // free up the USB config discriptor
   if (DeviceExtension->UsbConfigurationDescriptor != NULL)
      {
      SmartcardDebug( DEBUG_DRIVER,
                      ("%s!StopDevice: freeing UsbConfiguration\n",DRIVER_NAME,NTStatus));
      ExFreePool(DeviceExtension->UsbConfigurationDescriptor);
      DeviceExtension->UsbConfigurationDescriptor = NULL;
      }


   SmartcardDebug( DEBUG_TRACE,
                   ("%s!StopDevice: Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}



/*****************************************************************************

Routine Description:

    Used as a general purpose completion routine so it can signal an event,
    passed as the Context, when the next lower driver is done with the input Irp.
    This routine is used by both PnP and Power Management logic.

    Even though this routine does nothing but set an event, it must be defined and
    prototyped as a completetion routine for use as such


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context, in this case a pointer to an event.

Return Value:

    The function value is the final NTStatus from the operation.

*****************************************************************************/
NTSTATUS CMUSB_IrpCompletionRoutine(
                                   IN PDEVICE_OBJECT DeviceObject,
                                   IN PIRP Irp,
                                   IN PVOID Context
                                   )
{
   PKEVENT event = Context;

   // Set the input event
   KeSetEvent(event,
              1,       // Priority increment  for waiting thread.
              FALSE);  // Flag this call is not immediately followed by wait.

   // This routine must return STATUS_MORE_PROCESSING_REQUIRED because we have not yet called
   // IoFreeIrp() on this IRP.
   return STATUS_MORE_PROCESSING_REQUIRED;

}



/*****************************************************************************

Routine Description:

    This is our FDO's dispatch table function for IRP_MJ_POWER.
    It processes the Power IRPs sent to the PDO for this device.

    For every power IRP, drivers must call PoStartNextPowerIrp and use PoCallDriver
    to pass the IRP all the way down the driver stack to the underlying PDO.


Arguments:

    DeviceObject - pointer to our device object (FDO)

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT NTStatus code

*****************************************************************************/
NTSTATUS CMUSB_ProcessPowerIrp(
                              IN PDEVICE_OBJECT DeviceObject,
                              IN PIRP           Irp
                              )
{
   PIO_STACK_LOCATION irpStack;
   NTSTATUS NTStatus = STATUS_SUCCESS;
   PDEVICE_EXTENSION DeviceExtension;
   BOOLEAN fGoingToD0 = FALSE;
   POWER_STATE sysPowerState, desiredDevicePowerState;
   KEVENT event;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ProcessPowerIrp Enter\n",DRIVER_NAME));

   DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
   irpStack = IoGetCurrentIrpStackLocation (Irp);
   CMUSB_IncrementIoCount(DeviceObject);

   switch (irpStack->MinorFunction)
      {
      // ----------------
      // IRP_MN_WAIT_WAKE
      // ----------------
      case IRP_MN_WAIT_WAKE:
         // A driver sends IRP_MN_WAIT_WAKE to indicate that the system should
         // wait for its device to signal a wake event. The exact nature of the event
         // is device-dependent.
         // Drivers send this IRP for two reasons:
         // 1) To allow a device to wake the system
         // 2) To wake a device that has been put into a sleep state to save power
         //    but still must be able to communicate with its driver under certain circumstances.
         // When a wake event occurs, the driver completes the IRP and returns
         // STATUS_SUCCESS. If the device is sleeping when the event occurs,
         // the driver must first wake up the device before completing the IRP.
         // In a completion routine, the driver calls PoRequestPowerIrp to send a
         // PowerDeviceD0 request. When the device has powered up, the driver can
         //  handle the IRP_MN_WAIT_WAKE request.

         SmartcardDebug( DEBUG_DRIVER,
                         ("%s!IRP_MN_WAIT_WAKE received\n",DRIVER_NAME));

         // DeviceExtension->DeviceCapabilities.DeviceWake specifies the lowest device power state (least powered)
         // from which the device can signal a wake event
         DeviceExtension->PowerDownLevel = DeviceExtension->DeviceCapabilities.DeviceWake;


         if ( ( PowerDeviceD0 == DeviceExtension->CurrentDevicePowerState )  ||
              ( DeviceExtension->DeviceCapabilities.DeviceWake > DeviceExtension->CurrentDevicePowerState ) )
            {
            //    STATUS_INVALID_DEVICE_STATE is returned if the device in the PowerD0 state
            //    or a state below which it can support waking, or if the SystemWake state
            //    is below a state which can be supported. A pending IRP_MN_WAIT_WAKE will complete
            //    with this error if the device's state is changed to be incompatible with the wake
            //    request.

            //  If a driver fails this IRP, it should complete the IRP immediately without
            //  passing the IRP to the next-lower driver.
            NTStatus = STATUS_INVALID_DEVICE_STATE;
            Irp->IoStatus.Status = NTStatus;
            IoCompleteRequest (Irp,IO_NO_INCREMENT );
            SmartcardDebug( DEBUG_DRIVER,
                            ("%s!ProcessPowerIrp Exit %lx\n",DRIVER_NAME,NTStatus));
            CMUSB_DecrementIoCount(DeviceObject);
            return NTStatus;
            }

         // flag we're enabled for wakeup
         DeviceExtension->EnabledForWakeup = TRUE;

         // init an event for our completion routine to signal when PDO is done with this Irp
         KeInitializeEvent(&event, NotificationEvent, FALSE);

         // If not failing outright, pass this on to our PDO for further handling
         IoCopyCurrentIrpStackLocationToNext(Irp);

         // Set a completion routine so it can signal our event when
         //  the PDO is done with the Irp
         IoSetCompletionRoutine(Irp,
                                CMUSB_IrpCompletionRoutine,
                                &event,  // pass the event to the completion routine as the Context
                                TRUE,    // invoke on success
                                TRUE,    // invoke on error
                                TRUE);   // invoke on cancellation

         PoStartNextPowerIrp(Irp);
         NTStatus = PoCallDriver(DeviceExtension->TopOfStackDeviceObject,
                                 Irp);

         // if PDO is not done yet, wait for the event to be set in our completion routine
         if (NTStatus == STATUS_PENDING)
            {
            // wait for irp to complete

            NTSTATUS waitStatus = KeWaitForSingleObject(&event,
                                                        Suspended,
                                                        KernelMode,
                                                        FALSE,
                                                        NULL);

            SmartcardDebug( DEBUG_DRIVER,
                            ("%s!waiting for PDO to finish IRP_MN_WAIT_WAKE completed\n",DRIVER_NAME));
            }

         // now tell the device to actually wake up
         CMUSB_SelfSuspendOrActivate( DeviceObject, FALSE );

         // flag we're done with wakeup irp
         DeviceExtension->EnabledForWakeup = FALSE;

         CMUSB_DecrementIoCount(DeviceObject);

         break;


         // ------------------
         // IRP_MN_SET_POWER
         // ------------------
      case IRP_MN_SET_POWER:
         // The system power policy manager sends this IRP to set the system power state.
         // A device power policy manager sends this IRP to set the device power state for a device.
         // Set Irp->IoStatus.Status to STATUS_SUCCESS to indicate that the device
         // has entered the requested state. Drivers cannot fail this IRP.

         SmartcardDebug( DEBUG_DRIVER,
                         ("%s!IRP_MN_SET_POWER\n",DRIVER_NAME));

         switch (irpStack->Parameters.Power.Type)
            {
            // +++++++++++++++++++
            // SystemPowerState
            // +++++++++++++++++++
            case SystemPowerState:
               // Get input system power state
               sysPowerState.SystemState = irpStack->Parameters.Power.State.SystemState;

               SmartcardDebug( DEBUG_DRIVER,
                               ("%s!SystemPowerState = %s\n",DRIVER_NAME,
                                CMUSB_StringForSysState( sysPowerState.SystemState)));

               // If system is in working state always set our device to D0
               // regardless of the wait state or system-to-device state power map
               if (sysPowerState.SystemState ==  PowerSystemWorking)
                  {
                  desiredDevicePowerState.DeviceState = PowerDeviceD0;

                  SmartcardDebug( DEBUG_DRIVER,
                                  ("%s!PowerSystemWorking, will set D0, not use state map\n",DRIVER_NAME));
                  }
               else
                  {
                  // set to corresponding system state if IRP_MN_WAIT_WAKE pending
                  if ( DeviceExtension->EnabledForWakeup )  // got a WAIT_WAKE IRP pending?
                     {
                     // Find the device power state equivalent to the given system state.
                     // We get this info from the DEVICE_CAPABILITIES struct in our device
                     // extension (initialized in CMUSB_PnPAddDevice() )
                     desiredDevicePowerState.DeviceState =
                     DeviceExtension->DeviceCapabilities.DeviceState[ sysPowerState.SystemState ];

                     SmartcardDebug(DEBUG_DRIVER,
                                    ("%s!IRP_MN_WAIT_WAKE pending, will use state map\n",DRIVER_NAME));
                     }
                  else
                     {
                     // if no wait pending and the system's not in working state, just turn off
                     desiredDevicePowerState.DeviceState = PowerDeviceD3;

                     SmartcardDebug(DEBUG_DRIVER,
                                    ("%s!Not EnabledForWakeup and the system's not in working state,\n            settting PowerDeviceD3 (off)\n",DRIVER_NAME));
                     }

                  if (sysPowerState.SystemState ==  PowerSystemShutdown)
                     {
                     // power down the card for saftey reasons
                     if (DeviceExtension->SmartcardExtension.ReaderExtension->ulOldCardState == POWERED)
                        {
                        // we have to wait for the mutex before
                        KeWaitForSingleObject(&DeviceExtension->SmartcardExtension.ReaderExtension->CardManIOMutex,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              NULL);
                        CMUSB_PowerOffCard(&DeviceExtension->SmartcardExtension);
                        KeReleaseMutex(&DeviceExtension->SmartcardExtension.ReaderExtension->CardManIOMutex,
                                       FALSE);
                        }
                     }
                  }

               //
               // We've determined the desired device state; are we already in this state?
               //

               SmartcardDebug(DEBUG_DRIVER,
                              ("%s!desiredDevicePowerState = %s\n",DRIVER_NAME,CMUSB_StringForDevState(desiredDevicePowerState.DeviceState)));

               if (desiredDevicePowerState.DeviceState != DeviceExtension->CurrentDevicePowerState)
                  {
                  CMUSB_IncrementIoCount(DeviceObject);

                  // No, request that we be put into this state
                  // by requesting a new Power Irp from the Pnp manager
                  DeviceExtension->PowerIrp = Irp;
                  IoMarkIrpPending(Irp);
                  NTStatus = PoRequestPowerIrp(DeviceExtension->PhysicalDeviceObject,
                                               IRP_MN_SET_POWER,
                                               desiredDevicePowerState,
                                               // completion routine will pass the Irp down to the PDO
                                               CMUSB_PoRequestCompletion,
                                               DeviceObject,
                                               NULL);
                  }
               else
                  {
                  // Yes, just pass it on to PDO (Physical Device Object)
                  IoCopyCurrentIrpStackLocationToNext(Irp);
                  PoStartNextPowerIrp(Irp);
                  NTStatus = PoCallDriver(DeviceExtension->TopOfStackDeviceObject,Irp);

                  CMUSB_DecrementIoCount(DeviceObject);
                  }
               break;

               // ++++++++++++++++++
               // DevicePowerState
               // ++++++++++++++++++
            case DevicePowerState:
               // For requests to D1, D2, or D3 ( sleep or off states ),
               // sets DeviceExtension->CurrentDevicePowerState to DeviceState immediately.
               // This enables any code checking state to consider us as sleeping or off
               // already, as this will imminently become our state.

               SmartcardDebug(DEBUG_DRIVER,
                              ("%s!DevicePowerState = %s\n",DRIVER_NAME,
                               CMUSB_StringForDevState(irpStack->Parameters.Power.State.DeviceState)));

               // For requests to DeviceState D0 ( fully on ), sets fGoingToD0 flag TRUE
               // to flag that we must set a completion routine and update
               // DeviceExtension->CurrentDevicePowerState there.
               // In the case of powering up to fully on, we really want to make sure
               // the process is completed before updating our CurrentDevicePowerState,
               // so no IO will be attempted or accepted before we're really ready.

               fGoingToD0 = CMUSB_SetDevicePowerState(DeviceObject,
                                                      irpStack->Parameters.Power.State.DeviceState); // returns TRUE for D0

               IoCopyCurrentIrpStackLocationToNext(Irp);

               if (fGoingToD0 == TRUE)
                  {
                  SmartcardDebug( DEBUG_DRIVER,("%s!going to D0\n",DRIVER_NAME));

                  IoSetCompletionRoutine(Irp,
                                         CMUSB_PowerIrp_Complete,
                                         // Always pass FDO to completion routine as its Context;
                                         // This is because the DriverObject passed by the system to the routine
                                         // is the Physical Device Object ( PDO ) not the Functional Device Object ( FDO )
                                         DeviceObject,
                                         TRUE,            // invoke on success
                                         TRUE,            // invoke on error
                                         TRUE);           // invoke on cancellation of the Irp
                  }

               PoStartNextPowerIrp(Irp);
               NTStatus = PoCallDriver(DeviceExtension->TopOfStackDeviceObject,
                                       Irp);

               if (fGoingToD0 == FALSE) // completion routine will decrement
                  CMUSB_DecrementIoCount(DeviceObject);

               break;
            } /* case irpStack->Parameters.Power.Type */
         break; /* IRP_MN_SET_POWER */

         // ------------------
         // IRP_MN_QUERY_POWER
         // ------------------
      case IRP_MN_QUERY_POWER:
         //
         // A power policy manager sends this IRP to determine whether it can change
         // the system or device power state, typically to go to sleep.
         //

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!IRP_MN_QUERY_POWER received\n",DRIVER_NAME));

         switch (irpStack->Parameters.Power.Type)
            {
            // +++++++++++++++++++
            // SystemPowerState
            // +++++++++++++++++++
            case SystemPowerState:
               SmartcardDebug( DEBUG_DRIVER,
                               ("%s!SystemPowerState = %s\n",DRIVER_NAME,
                                CMUSB_StringForSysState(irpStack->Parameters.Power.State.SystemState)));
               break;

               // ++++++++++++++++++
               // DevicePowerState
               // ++++++++++++++++++
            case DevicePowerState:
               // For requests to D1, D2, or D3 ( sleep or off states ),
               // sets DeviceExtension->CurrentDevicePowerState to DeviceState immediately.
               // This enables any code checking state to consider us as sleeping or off
               // already, as this will imminently become our state.

               SmartcardDebug(DEBUG_DRIVER,
                              ("%s!DevicePowerState = %s\n",DRIVER_NAME,
                               CMUSB_StringForDevState(irpStack->Parameters.Power.State.DeviceState)));
               break;
            }

         // we do nothing special here, just let the PDO handle it
         IoCopyCurrentIrpStackLocationToNext(Irp);
         PoStartNextPowerIrp(Irp);
         NTStatus = PoCallDriver(DeviceExtension->TopOfStackDeviceObject,
                                 Irp);
         CMUSB_DecrementIoCount(DeviceObject);

         break; /* IRP_MN_QUERY_POWER */

      default:

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!unknown POWER IRP received\n",DRIVER_NAME));

         //
         // All unhandled power messages are passed on to the PDO
         //

         IoCopyCurrentIrpStackLocationToNext(Irp);
         PoStartNextPowerIrp(Irp);
         NTStatus = PoCallDriver(DeviceExtension->TopOfStackDeviceObject, Irp);

         CMUSB_DecrementIoCount(DeviceObject);

      } /* irpStack->MinorFunction */

   SmartcardDebug( DEBUG_TRACE,
                   ("%s!ProcessPowerIrp Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}


/*****************************************************************************

Routine Description:

   This is the completion routine set in a call to PoRequestPowerIrp()
   that was made in CMUSB_ProcessPowerIrp() in response to receiving
   an IRP_MN_SET_POWER of type 'SystemPowerState' when the device was
   not in a compatible device power state. In this case, a pointer to
   the IRP_MN_SET_POWER Irp is saved into the FDO device extension
   (DeviceExtension->PowerIrp), and then a call must be
   made to PoRequestPowerIrp() to put the device into a proper power state,
   and this routine is set as the completion routine.

    We decrement our pending io count and pass the saved IRP_MN_SET_POWER Irp
   on to the next driver

Arguments:

    DeviceObject - Pointer to the device object for the class device.
        Note that we must get our own device object from the Context

    Context - Driver defined context, in this case our own functional device object ( FDO )

Return Value:

    The function value is the final NTStatus from the operation.

*****************************************************************************/
NTSTATUS CMUSB_PoRequestCompletion(
                                  IN PDEVICE_OBJECT   DeviceObject,
                                  IN UCHAR            MinorFunction,
                                  IN POWER_STATE      PowerState,
                                  IN PVOID            Context,
                                  IN PIO_STATUS_BLOCK IoStatus
                                  )
{
   PIRP irp;
   PDEVICE_EXTENSION DeviceExtension;
   PDEVICE_OBJECT deviceObject = Context;
   NTSTATUS NTStatus;

   SmartcardDebug(DEBUG_TRACE,("%s!PoRequestCompletion Enter\n",DRIVER_NAME));

   DeviceExtension = deviceObject->DeviceExtension;

   // Get the Irp we saved for later processing in CMUSB_ProcessPowerIrp()
   // when we decided to request the Power Irp that this routine
   // is the completion routine for.
   irp = DeviceExtension->PowerIrp;

   // We will return the NTStatus set by the PDO for the power request we're completing
   NTStatus = IoStatus->Status;


   // we should not be in the midst of handling a self-generated power irp
   CMUSB_ASSERT( !DeviceExtension->SelfPowerIrp );

   // we must pass down to the next driver in the stack
   IoCopyCurrentIrpStackLocationToNext(irp);

   // Calling PoStartNextPowerIrp() indicates that the driver is finished
   // with the previous power IRP, if any, and is ready to handle the next power IRP.
   // It must be called for every power IRP.Although power IRPs are completed only once,
   // typically by the lowest-level driver for a device, PoStartNextPowerIrp must be called
   // for every stack location. Drivers must call PoStartNextPowerIrp while the current IRP
   // stack location points to the current driver. Therefore, this routine must be called
   // before IoCompleteRequest, IoSkipCurrentStackLocation, and PoCallDriver.

   PoStartNextPowerIrp(irp);

   // PoCallDriver is used to pass any power IRPs to the PDO instead of IoCallDriver.
   // When passing a power IRP down to a lower-level driver, the caller should use
   // IoSkipCurrentIrpStackLocation or IoCopyCurrentIrpStackLocationToNext to copy the IRP to
   // the next stack location, then call PoCallDriver. Use IoCopyCurrentIrpStackLocationToNext
   // if processing the IRP requires setting a completion routine, or IoSkipCurrentStackLocation
   // if no completion routine is needed.

   PoCallDriver(DeviceExtension->TopOfStackDeviceObject,irp);

   CMUSB_DecrementIoCount(deviceObject);


   DeviceExtension->PowerIrp = NULL;

   SmartcardDebug(DEBUG_TRACE,("%s!PoRequestCompletion Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}




/*****************************************************************************

Routine Description:

    This routine is called when An IRP_MN_SET_POWER of type 'DevicePowerState'
    has been received by CMUSB_ProcessPowerIrp(), and that routine has  determined
        1) the request is for full powerup ( to PowerDeviceD0 ), and
        2) We are not already in that state
    A call is then made to PoRequestPowerIrp() with this routine set as the completion routine.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final NTStatus from the operation.

*****************************************************************************/
NTSTATUS CMUSB_PowerIrp_Complete(
                                IN PDEVICE_OBJECT NullDeviceObject,
                                IN PIRP           Irp,
                                IN PVOID          Context
                                )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   PDEVICE_OBJECT deviceObject;
   PIO_STACK_LOCATION irpStack;
   PDEVICE_EXTENSION DeviceExtension;

   SmartcardDebug(DEBUG_TRACE,("%s!PowerIrp_Complete Enter\n",DRIVER_NAME));

   deviceObject = (PDEVICE_OBJECT) Context;

   DeviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;


   // if there was a card in the reader set the state to unknown,
   // because we dont know if the card instered is the same as before power down
   if (DeviceExtension->SmartcardExtension.ReaderExtension->ulNewCardState == INSERTED ||
       DeviceExtension->SmartcardExtension.ReaderExtension->ulNewCardState == POWERED    )
      {
      DeviceExtension->SmartcardExtension.ReaderExtension->ulOldCardState = UNKNOWN;
      DeviceExtension->SmartcardExtension.ReaderExtension->ulNewCardState = UNKNOWN;
      }
   KeSetEvent(&DeviceExtension->CanRunUpdateThread, 0, FALSE);


   //  If the lower driver returned PENDING, mark our stack location as pending also.
   if (Irp->PendingReturned == TRUE)
      {
      IoMarkIrpPending(Irp);
      }

   irpStack = IoGetCurrentIrpStackLocation (Irp);

   // We can assert that we're a  device powerup-to D0 request,
   // because that was the only type of request we set a completion routine
   // for in the first place
   CMUSB_ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);
   CMUSB_ASSERT(irpStack->MinorFunction == IRP_MN_SET_POWER);
   CMUSB_ASSERT(irpStack->Parameters.Power.Type==DevicePowerState);
   CMUSB_ASSERT(irpStack->Parameters.Power.State.DeviceState==PowerDeviceD0);

   // Now that we know we've let the lower drivers do what was needed to power up,
   //  we can set our device extension flags accordingly
   DeviceExtension->CurrentDevicePowerState = PowerDeviceD0;

   Irp->IoStatus.Status = NTStatus;

   CMUSB_DecrementIoCount(deviceObject);

   KeSetEvent(&DeviceExtension->ReaderEnabled, 0, FALSE);

   SmartcardDebug(DEBUG_TRACE,("%s!PowerIrp_Complete Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}



/*****************************************************************************

Routine Description:

        Called on CMUSB_PnPAddDevice() to power down until needed (i.e., till a pipe is actually opened).
        Called on CMUSB_Create() to power up device to D0 before opening 1st pipe.
        Called on CMUSB_Close() to power down device if this is the last pipe.

Arguments:

    DeviceObject - Pointer to the device object

    fSuspend; TRUE to Suspend, FALSE to acivate.


Return Value:

    If the operation is not attemtped, SUCCESS is returned.
    If the operation is attemtped, the value is the final NTStatus from the operation.


*****************************************************************************/
NTSTATUS CMUSB_SelfSuspendOrActivate(
                                    IN PDEVICE_OBJECT DeviceObject,
                                    IN BOOLEAN fSuspend
                                    )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;

   POWER_STATE PowerState;
   PDEVICE_EXTENSION DeviceExtension;


   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardDebug( DEBUG_TRACE,("%s!SelfSuspendOrActivate: Enter, fSuspend = %d\n",DRIVER_NAME,fSuspend));


   // Can't accept request if:
   //  1) device is removed,
   //  2) has never been started,
   //  3) is stopped,
   //  4) has a remove request pending,
   //  5) has a stop device pending
   if (CMUSB_CanAcceptIoRequests( DeviceObject ) == FALSE)
      {
      NTStatus = STATUS_DELETE_PENDING;

      SmartcardDebug( DEBUG_TRACE,("%s!SelfSuspendOrActivate: ABORTING\n",DRIVER_NAME));
      return NTStatus;
      }


   // don't do anything if any System-generated Device Pnp irps are pending
   if ( DeviceExtension->PowerIrp != NULL)
      {
      SmartcardDebug( DEBUG_TRACE,("%s!SelfSuspendOrActivate: Exit, refusing on pending DeviceExtension->PowerIrp 0x%x\n",DRIVER_NAME,DeviceExtension->PowerIrp));
      return NTStatus;
      }

   // don't do anything if any self-generated Device Pnp irps are pending
   if ( DeviceExtension->SelfPowerIrp == TRUE)
      {
      SmartcardDebug( DEBUG_TRACE,("%s!SelfSuspendOrActivate: Exit, refusing on pending DeviceExtension->SelfPowerIrp\n",DRIVER_NAME));
      return NTStatus;
      }


   // dont do anything if registry CurrentControlSet\Services\CMUSB\Parameters\PowerDownLevel
   //  has been set to  zero, PowerDeviceD0 ( 1 ), or a bogus high value
   if ( ( DeviceExtension->PowerDownLevel == PowerDeviceD0 )         ||
        ( DeviceExtension->PowerDownLevel == PowerDeviceUnspecified) ||
        ( DeviceExtension->PowerDownLevel >= PowerDeviceMaximum )      )
      {
      SmartcardDebug( DEBUG_TRACE,("%s!SelfSuspendOrActivate: Exit, refusing on DeviceExtension->PowerDownLevel == %d\n",DRIVER_NAME,DeviceExtension->PowerDownLevel));
      return NTStatus;
      }

   if ( fSuspend == TRUE)
      PowerState.DeviceState = DeviceExtension->PowerDownLevel;
   else
      PowerState.DeviceState = PowerDeviceD0;  // power up all the way; we're probably just about to do some IO

   NTStatus = CMUSB_SelfRequestPowerIrp( DeviceObject, PowerState );

   SmartcardDebug( DEBUG_TRACE,("%s!SelfSuspendOrActivate: Exit, NTStatus 0x%x on setting dev state %s\n",DRIVER_NAME,NTStatus, CMUSB_StringForDevState(PowerState.DeviceState ) ));

   return NTStatus;

}


/*****************************************************************************

Routine Description:

    This routine is called by CMUSB_SelfSuspendOrActivate() to
    actually make the system request for a powerdown/up to PowerState.
    It first checks to see if we are already in Powerstate and immediately
    returns  SUCCESS with no further processing if so


Arguments:

    DeviceObject - Pointer to the device object

    PowerState. power state requested, e.g PowerDeviceD0.


Return Value:

    The function value is the final NTStatus from the operation.

*****************************************************************************/
NTSTATUS CMUSB_SelfRequestPowerIrp(
                                  IN PDEVICE_OBJECT DeviceObject,
                                  IN POWER_STATE PowerState
                                  )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   NTSTATUS waitStatus;
   PDEVICE_EXTENSION DeviceExtension;
   PIRP pIrp = NULL;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SelfRequestPowerIrp: request power irp to state %s\n",DRIVER_NAME));

   DeviceExtension =  DeviceObject->DeviceExtension;

   // This should have been reset in completion routine
   CMUSB_ASSERT( !DeviceExtension->SelfPowerIrp );

   if (  DeviceExtension->CurrentDevicePowerState ==  PowerState.DeviceState )
      return STATUS_SUCCESS;  // nothing to do

   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!SelfRequestPowerIrp: request power irp to state %s\n",DRIVER_NAME,
                   CMUSB_StringForDevState( PowerState.DeviceState )));

   CMUSB_IncrementIoCount(DeviceObject);

   // flag we're handling a self-generated power irp
   DeviceExtension->SelfPowerIrp = TRUE;

   // actually request the Irp
   NTStatus = PoRequestPowerIrp(DeviceExtension->PhysicalDeviceObject,
                                IRP_MN_SET_POWER,
                                PowerState,
                                CMUSB_PoSelfRequestCompletion,
                                DeviceObject,
                                NULL);


   if ( NTStatus == STATUS_PENDING )
      {
      // NTStatus pending is the return code we wanted

      // We only need to wait for completion if we're powering up
      if ( (ULONG) PowerState.DeviceState < DeviceExtension->PowerDownLevel )
         {
         waitStatus = KeWaitForSingleObject(&DeviceExtension->SelfRequestedPowerIrpEvent,
                                            Suspended,
                                            KernelMode,
                                            FALSE,
                                            NULL);
         }

      NTStatus = STATUS_SUCCESS;

      DeviceExtension->SelfPowerIrp = FALSE;
      }
   else
      {
      // The return NTStatus was not STATUS_PENDING; any other codes must be considered in error here;
      //  i.e., it is not possible to get a STATUS_SUCCESS  or any other non-error return from this call;
      }


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SelfRequestPowerIrp: Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}



/*****************************************************************************

Routine Description:

    This routine is called when the driver completes a self-originated power IRP
   that was generated by a call to CMUSB_SelfSuspendOrActivate().
    We power down whenever the last pipe is closed and power up when the first pipe is opened.

    For power-up , we set an event in our FDO extension to signal this IRP done
    so the power request can be treated as a synchronous call.
    We need to know the device is powered up before opening the first pipe, for example.
    For power-down, we do not set the event, as no caller waits for powerdown complete.

Arguments:

    DeviceObject - Pointer to the device object for the class device. ( Physical Device Object )

    Context - Driver defined context, in this case our FDO ( functional device object )

Return Value:

    The function value is the final NTStatus from the operation.

*****************************************************************************/
NTSTATUS CMUSB_PoSelfRequestCompletion(
                                      IN PDEVICE_OBJECT       DeviceObject,
                                      IN UCHAR                MinorFunction,
                                      IN POWER_STATE          PowerState,
                                      IN PVOID                Context,
                                      IN PIO_STATUS_BLOCK     IoStatus
                                      )
{
   PDEVICE_OBJECT deviceObject = Context;
   PDEVICE_EXTENSION DeviceExtension = deviceObject->DeviceExtension;
   NTSTATUS NTStatus = IoStatus->Status;

   // we should not be in the midst of handling a system-generated power irp
   CMUSB_ASSERT( NULL == DeviceExtension->PowerIrp );

   // We only need to set the event if we're powering up;
   // No caller waits on power down complete
   if ( (ULONG) PowerState.DeviceState < DeviceExtension->PowerDownLevel )
      {
      // Trigger Self-requested power irp completed event;
      //  The caller is waiting for completion
      KeSetEvent(&DeviceExtension->SelfRequestedPowerIrpEvent, 1, FALSE);
      }

   CMUSB_DecrementIoCount(deviceObject);


   return NTStatus;
}


/*****************************************************************************

Routine Description:

    This routine is called when An IRP_MN_SET_POWER of type 'DevicePowerState'
    has been received by CMUSB_ProcessPowerIrp().


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    DeviceState - Device specific power state to set the device in to.


Return Value:

    For requests to DeviceState D0 ( fully on ), returns TRUE to signal caller
    that we must set a completion routine and finish there.

*****************************************************************************/
BOOLEAN CMUSB_SetDevicePowerState(
                                 IN PDEVICE_OBJECT DeviceObject,
                                 IN DEVICE_POWER_STATE DeviceState
                                 )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   PDEVICE_EXTENSION DeviceExtension;
   BOOLEAN fRes = FALSE;

   SmartcardDebug(DEBUG_TRACE,("%s!SetDevicePowerState Enter\n",DRIVER_NAME));

   DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

   switch (DeviceState)
      {
      case PowerDeviceD3:
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!SetDevicePowerState PowerDeviceD3 \n",DRIVER_NAME));


         DeviceExtension->CurrentDevicePowerState = DeviceState;

         KeClearEvent(&DeviceExtension->ReaderEnabled);

         CMUSB_StopCardTracking(DeviceObject);

         break;

      case PowerDeviceD1:
      case PowerDeviceD2:
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!SetDevicePowerState PowerDeviceD1/2 \n",DRIVER_NAME));
         //
         // power states D1,D2 translate to USB suspend


         DeviceExtension->CurrentDevicePowerState = DeviceState;
         break;

      case PowerDeviceD0:
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!SetDevicePowerState PowerDeviceD0 \n",DRIVER_NAME));


         // We'll need to finish the rest in the completion routine;
         //   signal caller we're going to D0 and will need to set a completion routine
         fRes = TRUE;

         // Caller will pass on to PDO ( Physical Device object )

         //
         // start update thread be signal that it should not run now
         // this thread should be started in completion rourine
         // but there we have a wrong IRQL for creating a thread
         //
         KeClearEvent(&DeviceExtension->CanRunUpdateThread);
         NTStatus = CMUSB_StartCardTracking(DeviceObject);

         break;

      default:
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!SetDevicePowerState Inalid device power state \n",DRIVER_NAME));

      }

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SetDevicePowerState Exit\n",DRIVER_NAME));
   return fRes;
}



/*****************************************************************************

Routine Description:

    This routine generates an internal IRP from this driver to the PDO
    to obtain information on the Physical Device Object's capabilities.
    We are most interested in learning which system power states
    are to be mapped to which device power states for honoring IRP_MJ_SET_POWER Irps.

    This is a blocking call which waits for the IRP completion routine
    to set an event on finishing.

Arguments:

    DeviceObject        - Physical DeviceObject for this USB controller.

Return Value:

    NTSTATUS value from the IoCallDriver() call.

*****************************************************************************/
NTSTATUS CMUSB_QueryCapabilities(
                                IN PDEVICE_OBJECT PdoDeviceObject,
                                IN PDEVICE_CAPABILITIES DeviceCapabilities
                                )
{
   PIO_STACK_LOCATION nextStack;
   PIRP irp;
   NTSTATUS NTStatus;
   KEVENT event;


   // This is a DDK-defined DBG-only macro that ASSERTS we are not running pageable code
   // at higher than APC_LEVEL.
   PAGED_CODE();


   // Build an IRP for us to generate an internal query request to the PDO
   irp = IoAllocateIrp(PdoDeviceObject->StackSize, FALSE);

   if (irp == NULL)
      {
      return STATUS_INSUFFICIENT_RESOURCES;
      }


   //
   // Preinit the device capability structures appropriately.
   //
   RtlZeroMemory( DeviceCapabilities, sizeof(DEVICE_CAPABILITIES) );
   DeviceCapabilities->Size = sizeof(DEVICE_CAPABILITIES);
   DeviceCapabilities->Version = 1;
   DeviceCapabilities->Address = -1;
   DeviceCapabilities->UINumber = -1;

   // IoGetNextIrpStackLocation gives a higher level driver access to the next-lower
   // driver's I/O stack location in an IRP so the caller can set it up for the lower driver.
   nextStack = IoGetNextIrpStackLocation(irp);
   CMUSB_ASSERT(nextStack != NULL);
   nextStack->MajorFunction= IRP_MJ_PNP;
   nextStack->MinorFunction= IRP_MN_QUERY_CAPABILITIES;

   // init an event to tell us when the completion routine's been called
   KeInitializeEvent(&event, NotificationEvent, FALSE);

   // Set a completion routine so it can signal our event when
   //  the next lower driver is done with the Irp
   IoSetCompletionRoutine(irp,
                          CMUSB_IrpCompletionRoutine,
                          &event,  // pass the event as Context to completion routine
                          TRUE,    // invoke on success
                          TRUE,    // invoke on error
                          TRUE);   // invoke on cancellation of the Irp


   // set our pointer to the DEVICE_CAPABILITIES struct
   nextStack->Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

   // preset the irp to report not supported
   irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

   NTStatus = IoCallDriver(PdoDeviceObject,
                           irp);


   if (NTStatus == STATUS_PENDING)
      {
      // wait for irp to complete

      KeWaitForSingleObject(&event,
                            Suspended,
                            KernelMode,
                            FALSE,
                            NULL);

      NTStatus = irp->IoStatus.Status;
      }


   IoFreeIrp(irp);

   return NTStatus;
}





/*****************************************************************************
Routine Description:

  Installable driver initialization entry point.
  This entry point is called directly by the I/O system.

Arguments:


Return Value:

*****************************************************************************/
NTSTATUS DriverEntry(
                    IN PDRIVER_OBJECT DriverObject,
                    IN PUNICODE_STRING RegistryPath
                    )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   PDEVICE_OBJECT deviceObject = NULL;
   BOOLEAN fRes;
   ULONG ulIndex;

//#if DBG
//   SmartcardSetDebugLevel(DEBUG_ALL);
//#endif

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!DriverEntry: Enter - %s %s\n",DRIVER_NAME,__DATE__,__TIME__));

   //
   // Create dispatch points for create, close, unload
   DriverObject->MajorFunction[IRP_MJ_CREATE]  = CMUSB_CreateClose;
   DriverObject->MajorFunction[IRP_MJ_CLOSE]   = CMUSB_CreateClose;
   DriverObject->MajorFunction[IRP_MJ_CLEANUP] = CMUSB_Cleanup;
   DriverObject->DriverUnload                  = CMUSB_Unload;

   // User mode DeviceIoControl() calls will be routed here
   DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = CMUSB_ProcessIOCTL;

   // routines for handling system PNP and power management requests
   DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = CMUSB_ProcessSysControlIrp;
   DriverObject->MajorFunction[IRP_MJ_PNP] = CMUSB_ProcessPnPIrp;
   DriverObject->MajorFunction[IRP_MJ_POWER] = CMUSB_ProcessPowerIrp;

   // The Functional Device Object (FDO) will not be created for PNP devices until
   // this routine is called upon device plug-in.
   DriverObject->DriverExtension->AddDevice = CMUSB_PnPAddDevice;

   for (ulIndex = 0;ulIndex < MAXIMUM_OEM_NAMES;ulIndex++)
      {
      OemName[ulIndex].Buffer = OemNameBuffer[ulIndex];
      OemName[ulIndex].MaximumLength = sizeof(OemNameBuffer[ulIndex]);
      }

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!DriverEntry: Exit\n",DRIVER_NAME));
   return NTStatus;
}





/*****************************************************************************
Routine Description:

   Main dispatch table routine for IRP_MJ_SYSTEM_CONTROL
   We basically just pass these down to the PDO

Arguments:

    DeviceObject - pointer to FDO device object

    Irp          - pointer to an I/O Request Packet

Return Value:

   Status returned from lower driver
*****************************************************************************/
NTSTATUS CMUSB_ProcessSysControlIrp(
                                   IN PDEVICE_OBJECT DeviceObject,
                                   IN PIRP           Irp
                                   )
{

   PIO_STACK_LOCATION irpStack;
   PDEVICE_EXTENSION DeviceExtension;
   NTSTATUS NTStatus = STATUS_SUCCESS;
   NTSTATUS waitStatus;
   PDEVICE_OBJECT stackDeviceObject;

   //
   // Get a pointer to the current location in the Irp. This is where
   //     the function codes and parameters are located.
   //

   irpStack = IoGetCurrentIrpStackLocation (Irp);

   //
   // Get a pointer to the device extension
   //

   DeviceExtension = DeviceObject->DeviceExtension;
   stackDeviceObject = DeviceExtension->TopOfStackDeviceObject;


   CMUSB_IncrementIoCount(DeviceObject);

   CMUSB_ASSERT( IRP_MJ_SYSTEM_CONTROL == irpStack->MajorFunction );

   IoCopyCurrentIrpStackLocationToNext(Irp);


   NTStatus = IoCallDriver(stackDeviceObject,
                           Irp);

   CMUSB_DecrementIoCount(DeviceObject);

   return NTStatus;
}


/*****************************************************************************
Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object

Return Value:

*****************************************************************************/
VOID CMUSB_Unload(
                 IN PDRIVER_OBJECT DriverObject
                 )
{

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!Unload enter\n",DRIVER_NAME));

   //
   // Free any global resources allocated
   // in DriverEntry.
   // We have few or none because for a PNP device, almost all
   // allocation is done in PnpAddDevice() and all freeing
   // while handling IRP_MN_REMOVE_DEVICE:
   //


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!Unload exit\n",DRIVER_NAME));
}


/*****************************************************************************
Routine Description:
   Trys to read the reader name from the registry

Arguments:
   DriverObject context of call
   SmartcardExtension   ptr to smartcard extension

Return Value:
   none

******************************************************************************/
NTSTATUS CMUSB_SetVendorAndIfdName(
                                  IN  PDEVICE_OBJECT PhysicalDeviceObject,
                                  IN  PSMARTCARD_EXTENSION SmartcardExtension
                                  )
{

   RTL_QUERY_REGISTRY_TABLE   parameters[3];
   UNICODE_STRING             vendorNameU;
   ANSI_STRING                vendorNameA;
   UNICODE_STRING             ifdTypeU;
   ANSI_STRING                ifdTypeA;
   HANDLE                     regKey = NULL;
   ULONG                      ulIndex;
   ULONG                      ulInstance;
   CHAR                       strBuffer[64];
   USHORT                     usStrLength;

   RtlZeroMemory (parameters, sizeof(parameters));
   RtlZeroMemory (&vendorNameU, sizeof(vendorNameU));
   RtlZeroMemory (&vendorNameA, sizeof(vendorNameA));
   RtlZeroMemory (&ifdTypeU, sizeof(ifdTypeU));
   RtlZeroMemory (&ifdTypeA, sizeof(ifdTypeA));

   try
      {
      //
      // try to read the reader name from the registry
      // if that does not work, we will use the default
      // (hardcoded) name
      //
      if (IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                  PLUGPLAY_REGKEY_DEVICE,
                                  KEY_READ,
                                  &regKey) != STATUS_SUCCESS)
         {
         SmartcardDebug(DEBUG_ERROR,
                        ("%s!SetVendorAndIfdName: IoOpenDeviceRegistryKey failed\n",DRIVER_NAME));
         leave;
         }

      parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
      parameters[0].Name = L"VendorName";
      parameters[0].EntryContext = &vendorNameU;
      parameters[0].DefaultType = REG_SZ;
      parameters[0].DefaultData = &vendorNameU;
      parameters[0].DefaultLength = 0;

      parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
      parameters[1].Name = L"IfdType";
      parameters[1].EntryContext = &ifdTypeU;
      parameters[1].DefaultType = REG_SZ;
      parameters[1].DefaultData = &ifdTypeU;
      parameters[1].DefaultLength = 0;

      if (RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                 (PWSTR) regKey,
                                 parameters,
                                 NULL,
                                 NULL) != STATUS_SUCCESS)
         {
         SmartcardDebug(DEBUG_ERROR,
                        ("%s!SetVendorAndIfdName: RtlQueryRegistryValues failed\n",DRIVER_NAME));
         leave;
         }

      if (RtlUnicodeStringToAnsiString(&vendorNameA,&vendorNameU,TRUE) != STATUS_SUCCESS)
         {
         SmartcardDebug(DEBUG_ERROR,
                        ("%s!SetVendorAndIfdName: RtlUnicodeStringToAnsiString failed\n",DRIVER_NAME));
         leave;
         }

      if (RtlUnicodeStringToAnsiString(&ifdTypeA,&ifdTypeU,TRUE) != STATUS_SUCCESS)
         {
         SmartcardDebug(DEBUG_ERROR,
                        ("%s!SetVendorAndIfdName: RtlUnicodeStringToAnsiString failed\n",DRIVER_NAME));
         leave;
         }

      if (vendorNameA.Length == 0 ||
          vendorNameA.Length > MAXIMUM_ATTR_STRING_LENGTH ||
          ifdTypeA.Length == 0 ||
          ifdTypeA.Length > MAXIMUM_ATTR_STRING_LENGTH)
         {
         SmartcardDebug(DEBUG_ERROR,
                        ("%s!SetVendorAndIfdName: vendor name or ifdtype not found or to long\n",DRIVER_NAME));
         leave;
         }

      RtlCopyMemory(SmartcardExtension->VendorAttr.VendorName.Buffer,
                    vendorNameA.Buffer,
                    vendorNameA.Length);
      SmartcardExtension->VendorAttr.VendorName.Length = vendorNameA.Length;

      RtlCopyMemory(SmartcardExtension->VendorAttr.IfdType.Buffer,
                    ifdTypeA.Buffer,
                    ifdTypeA.Length);
      SmartcardExtension->VendorAttr.IfdType.Length = ifdTypeA.Length;

      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!SetVendorAndIfdName: overwritting vendor name and ifdtype\n",DRIVER_NAME));

      }

   finally
      {
      if (vendorNameU.Buffer != NULL)
         {
         RtlFreeUnicodeString(&vendorNameU);
         }
      if (vendorNameA.Buffer != NULL)
         {
         RtlFreeAnsiString(&vendorNameA);
         }
      if (ifdTypeU.Buffer != NULL)
         {
         RtlFreeUnicodeString(&ifdTypeU);
         }
      if (ifdTypeA.Buffer != NULL)
         {
         RtlFreeAnsiString(&ifdTypeA);
         }
      if (regKey != NULL)
         {
         ZwClose (regKey);
         }
      }

   // correct the unit number
   ifdTypeA.Buffer=strBuffer;
   ifdTypeA.MaximumLength=sizeof(strBuffer);
   usStrLength = (SmartcardExtension->VendorAttr.IfdType.Length < ifdTypeA.MaximumLength) ? SmartcardExtension->VendorAttr.IfdType.Length : ifdTypeA.MaximumLength;
   RtlCopyMemory(ifdTypeA.Buffer,
                 SmartcardExtension->VendorAttr.IfdType.Buffer,
                 usStrLength);
   ifdTypeA.Length = usStrLength;

   ulIndex=0;
   while (ulIndex < MAXIMUM_OEM_NAMES &&
          OemName[ulIndex].Length > 0 &&
          RtlCompareMemory (ifdTypeA.Buffer, OemName[ulIndex].Buffer, OemName[ulIndex].Length) != OemName[ulIndex].Length)
      {
      ulIndex++;
      }

   if (ulIndex == MAXIMUM_OEM_NAMES)
      {
      // maximum number of OEM names reached
      return STATUS_INSUFFICIENT_RESOURCES;
      }

   if (OemName[ulIndex].Length == 0)
      {
      // new OEM reader name
      usStrLength = (ifdTypeA.Length < OemName[ulIndex].MaximumLength) ? ifdTypeA.Length : OemName[ulIndex].MaximumLength;
      RtlCopyMemory(OemName[ulIndex].Buffer,
                    ifdTypeA.Buffer,
                    usStrLength);
      OemName[ulIndex].Length = usStrLength;
      }

   for (ulInstance = 0;ulInstance < MAXIMUM_USB_READERS;ulInstance++)
      {
      if (OemDeviceSlot[ulIndex][ulInstance] == FALSE)
         {
         OemDeviceSlot[ulIndex][ulInstance] = TRUE;
         break;
         }
      }

   if (ulInstance == MAXIMUM_USB_READERS)
      {
      return STATUS_INSUFFICIENT_RESOURCES;
      }

   SmartcardExtension->VendorAttr.UnitNo = ulInstance;
   SmartcardExtension->ReaderExtension->ulOemDeviceInstance = ulInstance;
   SmartcardExtension->ReaderExtension->ulOemNameIndex = ulIndex;

   return STATUS_SUCCESS;
}


/*****************************************************************************
Routine Description:

    Creates a Functional DeviceObject

Arguments:

    DriverObject - pointer to the driver object for device

    DeviceObject - pointer to DeviceObject pointer to return
                    created device object.

    Instance - instance of the device create.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

*****************************************************************************/
NTSTATUS CMUSB_CreateDeviceObject(
                                 IN PDRIVER_OBJECT DriverObject,
                                 IN PDEVICE_OBJECT PhysicalDeviceObject,
                                 IN PDEVICE_OBJECT *DeviceObject
                                 )
{
   UNICODE_STRING             deviceNameUnicodeString;
   UNICODE_STRING             Tmp;
   NTSTATUS                   NTStatus = STATUS_SUCCESS;
   ULONG                      deviceInstance;
   PDEVICE_EXTENSION          DeviceExtension;
   PREADER_EXTENSION          readerExtension;
   PSMARTCARD_EXTENSION       SmartcardExtension;
   WCHAR                      Buffer[64];


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!CreateDeviceObject: Enter\n",DRIVER_NAME));

   for ( deviceInstance = 0;deviceInstance < MAXIMUM_USB_READERS;deviceInstance++ )
      {
      if (DeviceSlot[deviceInstance] == FALSE)
         {
         DeviceSlot[deviceInstance] = TRUE;
         break;
         }
      }

   if (deviceInstance == MAXIMUM_USB_READERS)
      {
      return STATUS_INSUFFICIENT_RESOURCES;
      }

   //
   //   construct the device name
   //
   deviceNameUnicodeString.Buffer = Buffer;
   deviceNameUnicodeString.MaximumLength = sizeof(Buffer);
   deviceNameUnicodeString.Length = 0;
   RtlInitUnicodeString(&Tmp,CARDMAN_USB_DEVICE_NAME);
   RtlCopyUnicodeString(&deviceNameUnicodeString,&Tmp);
   Tmp.Buffer =  deviceNameUnicodeString.Buffer + deviceNameUnicodeString.Length / sizeof(WCHAR);
   Tmp.MaximumLength = 2 * sizeof(WCHAR);
   Tmp.Length = 0;
   RtlIntegerToUnicodeString(deviceInstance,10,&Tmp);
   deviceNameUnicodeString.Length = (USHORT)( deviceNameUnicodeString.Length+Tmp.Length);



   // Create the device object
   NTStatus = IoCreateDevice(DriverObject,
                             sizeof(DEVICE_EXTENSION),
                             &deviceNameUnicodeString,
                             FILE_DEVICE_SMARTCARD,
                             0,
                             TRUE,
                             DeviceObject);

   if (NTStatus != STATUS_SUCCESS)
      {
      return NTStatus;
      }


   // ----------------------------------------------
   //   initialize device extension
   // ----------------------------------------------

   DeviceExtension = (*DeviceObject)->DeviceExtension;
   DeviceExtension->DeviceInstance =  deviceInstance;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;


   // Used for reading from pipe 1
   KeInitializeEvent(&DeviceExtension->ReadP1Completed,
                     NotificationEvent,
                     FALSE);

   // Used to keep track of open close calls
   KeInitializeEvent(&DeviceExtension->RemoveEvent,
                     NotificationEvent,
                     TRUE);

   KeInitializeSpinLock(&DeviceExtension->SpinLock);

   // this event is triggered when self-requested power irps complete
   KeInitializeEvent(&DeviceExtension->SelfRequestedPowerIrpEvent, NotificationEvent, FALSE);

   // this event is triggered when there is no pending io  (pending io count == 1 )
   KeInitializeEvent(&DeviceExtension->NoPendingIoEvent, NotificationEvent, FALSE);


   // Used for update thread notification after hibernation
   KeInitializeEvent(&DeviceExtension->CanRunUpdateThread,
                     NotificationEvent,
                     TRUE);

   // Blocks IOControls during hibernation
   KeInitializeEvent(&DeviceExtension->ReaderEnabled,
                     NotificationEvent,
                     TRUE);



   // ----------------------------------------------
   //   create reader extension
   // ----------------------------------------------
   SmartcardExtension->ReaderExtension = ExAllocatePool(NonPagedPool,
                                                        sizeof(READER_EXTENSION));

   if (SmartcardExtension->ReaderExtension == NULL)
      {
      return STATUS_INSUFFICIENT_RESOURCES;
      }

   readerExtension = SmartcardExtension->ReaderExtension;
   RtlZeroMemory(readerExtension, sizeof(READER_EXTENSION));


   // ----------------------------------------------
   //   initialize timers
   // ----------------------------------------------
   KeInitializeTimer(&SmartcardExtension->ReaderExtension->WaitTimer);

   KeInitializeTimer(&SmartcardExtension->ReaderExtension->P1Timer);

   // ----------------------------------------------
   //   initialize mutex
   // ----------------------------------------------
   KeInitializeMutex(&SmartcardExtension->ReaderExtension->CardManIOMutex,0L);

   // ----------------------------------------------
   //   create smartcard extension
   // ----------------------------------------------
   // write the version of the lib we use to the smartcard extension
   SmartcardExtension->Version = SMCLIB_VERSION;
   SmartcardExtension->SmartcardRequest.BufferSize = CMUSB_BUFFER_SIZE;
   SmartcardExtension->SmartcardReply.BufferSize   = CMUSB_BUFFER_SIZE;

   //
   // Now let the lib allocate the buffer for data transmission
   // We can either tell the lib how big the buffer should be
   // by assigning a value to BufferSize or let the lib
   // allocate the default size
   //
   NTStatus = SmartcardInitialize(SmartcardExtension);

   if (NTStatus != STATUS_SUCCESS)
      {
      // free reader extension
      ExFreePool(DeviceExtension->SmartcardExtension.ReaderExtension);
      SmartcardExtension->ReaderExtension = NULL;
      return NTStatus;
      }

   // ----------------------------------------------
   //   initialize smartcard extension
   // ----------------------------------------------
   // Save deviceObject
   SmartcardExtension->OsData->DeviceObject = *DeviceObject;

   // Set up call back functions

   SmartcardExtension->ReaderFunction[RDF_TRANSMIT] =      CMUSB_Transmit;
   SmartcardExtension->ReaderFunction[RDF_SET_PROTOCOL] =  CMUSB_SetProtocol;
   SmartcardExtension->ReaderFunction[RDF_CARD_POWER] =    CMUSB_CardPower;
   SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING] = CMUSB_CardTracking;
   SmartcardExtension->ReaderFunction[RDF_IOCTL_VENDOR] =  CMUSB_IoCtlVendor;


   SmartcardExtension->ReaderExtension->ulDeviceInstance = deviceInstance;
   CMUSB_InitializeSmartcardExtension(SmartcardExtension);

   // try to overwrite with registry values
   NTStatus = CMUSB_SetVendorAndIfdName(PhysicalDeviceObject, SmartcardExtension);
   if (NTStatus != STATUS_SUCCESS)
      {
      // free reader extension
      ExFreePool(DeviceExtension->SmartcardExtension.ReaderExtension);
      SmartcardExtension->ReaderExtension = NULL;
      return NTStatus;
      }


   // W2000 is till now the only OS which supports WDM version 1.10
   // So check this to determine if we have an Plug&Play able resource manager
   DeviceExtension->fPnPResourceManager = IoIsWdmVersionAvailable (1,10);
   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!CreateDeviceObject: fPnPManager=%ld\n",DRIVER_NAME,DeviceExtension->fPnPResourceManager));

   if (DeviceExtension->fPnPResourceManager == TRUE)
      {
      if (DeviceExtension->PnPDeviceName.Buffer == NULL)
         {
         // register our new device
         NTStatus = IoRegisterDeviceInterface(PhysicalDeviceObject,
                                              &SmartCardReaderGuid,
                                              NULL,
                                              &DeviceExtension->PnPDeviceName);

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!CreateDeviceObject: PnPDeviceName.Buffer  = %lx\n",DRIVER_NAME,
                         DeviceExtension->PnPDeviceName.Buffer));
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!CreateDeviceObject: PnPDeviceName.BufferLength  = %lx\n",DRIVER_NAME,
                         DeviceExtension->PnPDeviceName.Length));

         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!CreateDeviceObject: IoRegisterDeviceInterface returned=%lx\n",DRIVER_NAME,NTStatus));
         }
      else
         {
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!CreateDeviceObject: Interface already exists\n",DRIVER_NAME));
         }
      }
   else
      {
      // ----------------------------------------------
      //    create symbolic link
      // ----------------------------------------------

      NTStatus = SmartcardCreateLink(&DeviceExtension->DosDeviceName,&deviceNameUnicodeString);

      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!CreateDeviceObject: SmartcardCreateLink returned=%lx\n",DRIVER_NAME,NTStatus));
      }


   if (NTStatus != STATUS_SUCCESS)
      {
      ExFreePool(DeviceExtension->SmartcardExtension.ReaderExtension);
      SmartcardExtension->ReaderExtension = NULL;
      SmartcardExit(&DeviceExtension->SmartcardExtension);
      IoDeleteDevice(*DeviceObject);
      }


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!CreateDeviceObject: Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}



/*****************************************************************************
Routine Description:

   Passes a URB to the USBD class driver
   The client device driver passes USB request block (URB) structures
   to the class driver as a parameter in an IRP with Irp->MajorFunction
   set to IRP_MJ_INTERNAL_DEVICE_CONTROL and the next IRP stack location
   Parameters.DeviceIoControl.IoControlCode field set to
   IOCTL_INTERNAL_USB_SUBMIT_URB.

Arguments:

    DeviceObject - pointer to the physical device object (PDO)

    Urb - pointer to an already-formatted Urb request block

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

*****************************************************************************/
NTSTATUS
CMUSB_CallUSBD(
              IN PDEVICE_OBJECT DeviceObject,
              IN PURB Urb
              )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   NTSTATUS DebugStatus;
   PDEVICE_EXTENSION DeviceExtension;
   PIRP irp;
   KEVENT event;
   IO_STATUS_BLOCK ioStatus;
   PIO_STACK_LOCATION nextStack;


   DeviceExtension = DeviceObject->DeviceExtension;

   //
   // issue a synchronous request
   //

   KeInitializeEvent(&event, NotificationEvent, FALSE);

   irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_USB_SUBMIT_URB,
                                       DeviceExtension->TopOfStackDeviceObject, //Points to the next-lower driver's device object
                                       NULL,       // optional input bufer; none needed here
                                       0,          // input buffer len if used
                                       NULL,       // optional output bufer; none needed here
                                       0,          // output buffer len if used
                                       TRUE,       // If InternalDeviceControl is TRUE the target driver's Dispatch
                                       //  outine for IRP_MJ_INTERNAL_DEVICE_CONTROL or IRP_MJ_SCSI
                                       // is called; otherwise, the Dispatch routine for
                                       // IRP_MJ_DEVICE_CONTROL is called.
                                       &event,     // event to be signalled on completion
                                       &ioStatus); // Specifies an I/O NTStatus block to be set when the request is completed the lower driver.

   if (irp == NULL)
      {
      NTStatus = STATUS_INSUFFICIENT_RESOURCES;
      goto ExitCallUSBD;
      }


   //
   // Call the class driver to perform the operation.  If the returned NTStatus
   // is PENDING, wait for the request to complete.
   //

   nextStack = IoGetNextIrpStackLocation(irp);
   CMUSB_ASSERT(nextStack != NULL);

   //
   // pass the URB to the USB driver stack
   //
   nextStack->Parameters.Others.Argument1 = Urb;


   NTStatus = IoCallDriver(DeviceExtension->TopOfStackDeviceObject, irp);


   if (NTStatus == STATUS_PENDING)
      {
      DebugStatus = KeWaitForSingleObject(&event,
                                          Suspended,
                                          KernelMode,
                                          FALSE,
                                          NULL);
      }
   else
      {
      ioStatus.Status = NTStatus;
      }
   /*
   SmartcardDebug( DEBUG_TRACE,("CMUSB_CallUSBD() URB NTStatus = %x NTStatus = %x irp NTStatus %x\n",
       Urb->UrbHeader.Status, NTStatus, ioStatus.Status));
   */
   //
   // USBD maps the error code for us
   //
   NTStatus = ioStatus.Status;

   ExitCallUSBD:
   return NTStatus;
}



/*****************************************************************************
Routine Description:

    Initializes a given instance of the device on the USB and
   selects and saves the configuration.

Arguments:

    DeviceObject - pointer to the physical device object for this instance of the 82930
                    device.


Return Value:

    NT NTStatus code
*****************************************************************************/
NTSTATUS
CMUSB_ConfigureDevice(
                     IN  PDEVICE_OBJECT DeviceObject
                     )
{
   PDEVICE_EXTENSION DeviceExtension;
   NTSTATUS NTStatus;
   PURB urb;
   ULONG siz;


   DeviceExtension = DeviceObject->DeviceExtension;

   CMUSB_ASSERT( DeviceExtension->UsbConfigurationDescriptor == NULL );

   urb = ExAllocatePool(NonPagedPool,
                        sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
   if (urb == NULL)
      return STATUS_INSUFFICIENT_RESOURCES;

   // When USB_CONFIGURATION_DESCRIPTOR_TYPE is specified for DescriptorType
   // in a call to UsbBuildGetDescriptorRequest(),
   // all interface, endpoint, class-specific, and vendor-specific descriptors
   // for the configuration also are retrieved.
   // The caller must allocate a buffer large enough to hold all of this
   // information or the data is truncated without error.
   // Therefore the 'siz' set below is just a 'good guess', and we may have to retry

   siz = sizeof(USB_CONFIGURATION_DESCRIPTOR) + 512;

   // We will break out of this 'retry loop' when UsbBuildGetDescriptorRequest()
   // has a big enough DeviceExtension->UsbConfigurationDescriptor buffer not to truncate
   while ( 1 )
      {

      DeviceExtension->UsbConfigurationDescriptor = ExAllocatePool(NonPagedPool, siz);

      if (DeviceExtension->UsbConfigurationDescriptor == NULL)
         {
         ExFreePool(urb);
         return STATUS_INSUFFICIENT_RESOURCES;
         }

      UsbBuildGetDescriptorRequest(urb,
                                   (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                   USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                   0,
                                   0,
                                   DeviceExtension->UsbConfigurationDescriptor,
                                   NULL,
                                   siz,
                                   NULL);

      NTStatus = CMUSB_CallUSBD(DeviceObject, urb);

      //
      // if we got some data see if it was enough.
      // NOTE: we may get an error in URB because of buffer overrun
      if (urb->UrbControlDescriptorRequest.TransferBufferLength>0 &&
          DeviceExtension->UsbConfigurationDescriptor->wTotalLength > siz)
         {

         siz = DeviceExtension->UsbConfigurationDescriptor->wTotalLength;
         ExFreePool(DeviceExtension->UsbConfigurationDescriptor);
         DeviceExtension->UsbConfigurationDescriptor = NULL;
         }
      else
         {
         break;  // we got it on the first try
         }

      } // end, while (retry loop )

   ExFreePool(urb);
   CMUSB_ASSERT( DeviceExtension->UsbConfigurationDescriptor );

   //
   // We have the configuration descriptor for the configuration we want.
   // Now we issue the select configuration command to get
   // the  pipes associated with this configuration.
   //



   NTStatus = CMUSB_SelectInterface(DeviceObject,
                                    DeviceExtension->UsbConfigurationDescriptor);




   return NTStatus;
}

/*****************************************************************************
Routine Description:

   Initializes an CardMan USB
   This minidriver only supports one interface with one endpoint

Arguments:

    DeviceObject - pointer to the device object for this instance of the
                   CardMan USB device

    ConfigurationDescriptor - pointer to the USB configuration
                    descriptor containing the interface and endpoint
                    descriptors.

Return Value:

    NT NTStatus code

*****************************************************************************/
NTSTATUS
CMUSB_SelectInterface(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
                     )
{
   PDEVICE_EXTENSION DeviceExtension;
   NTSTATUS NTStatus;
   PURB urb = NULL;
   ULONG i;
   PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor = NULL;
   PUSBD_INTERFACE_INFORMATION Interface = NULL;
   USHORT siz;


   DeviceExtension = DeviceObject->DeviceExtension;


   //
   // CMUSB driver only supports one interface, we must parse
   // the configuration descriptor for the interface
   // and remember the pipes.
   //

   urb = USBD_CreateConfigurationRequest(ConfigurationDescriptor, &siz);

   if (urb != NULL)
      {

      //
      // USBD_ParseConfigurationDescriptorEx searches a given configuration
      // descriptor and returns a pointer to an interface that matches the
      //  given search criteria. We only support one interface on this device
      //
      interfaceDescriptor =
      USBD_ParseConfigurationDescriptorEx(ConfigurationDescriptor,
                                          ConfigurationDescriptor, //search from start of config  descriptro
                                          -1, // interface number not a criteria; we only support one interface
                                          -1,   // not interested in alternate setting here either
                                          -1,   // interface class not a criteria
                                          -1,   // interface subclass not a criteria
                                          -1    // interface protocol not a criteria
                                         );

      if (interfaceDescriptor == NULL)
         {
         ExFreePool(urb);
         return STATUS_INSUFFICIENT_RESOURCES;
         }

      Interface = &urb->UrbSelectConfiguration.Interface;

      for (i=0; i< Interface->NumberOfPipes; i++)
         {
         //
         // perform any pipe initialization here
         //
         Interface->Pipes[i].MaximumTransferSize = 1000;
         Interface->Pipes[i].PipeFlags = 0;
         }

      UsbBuildSelectConfigurationRequest(urb,
                                         (USHORT) siz,
                                         ConfigurationDescriptor);


      NTStatus = CMUSB_CallUSBD(DeviceObject, urb);

      DeviceExtension->UsbConfigurationHandle =
      urb->UrbSelectConfiguration.ConfigurationHandle;

      }
   else
      {
      NTStatus = STATUS_INSUFFICIENT_RESOURCES;
      }


   if (NT_SUCCESS(NTStatus))
      {

      //
      // Save the configuration handle for this device
      //

      DeviceExtension->UsbConfigurationHandle =
      urb->UrbSelectConfiguration.ConfigurationHandle;

      DeviceExtension->UsbInterface = ExAllocatePool(NonPagedPool,
                                                     Interface->Length);

      if (DeviceExtension->UsbInterface != NULL)
         {
         ULONG j;

         //
         // save a copy of the interface information returned
         //
         RtlCopyMemory(DeviceExtension->UsbInterface, Interface, Interface->Length);



         //
         // Dump the interface to the debugger
         //
         SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: ---------\n",
                                       DRIVER_NAME));
         SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: NumberOfPipes 0x%x\n",
                                       DRIVER_NAME,
                                       DeviceExtension->UsbInterface->NumberOfPipes));
         SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: Length 0x%x\n",
                                       DRIVER_NAME,
                                       DeviceExtension->UsbInterface->Length));
         SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: Alt Setting 0x%x\n",
                                       DRIVER_NAME,
                                       DeviceExtension->UsbInterface->AlternateSetting));
         SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: Interface Number 0x%x\n",
                                       DRIVER_NAME,
                                       DeviceExtension->UsbInterface->InterfaceNumber));
         SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: Class, subclass, protocol 0x%x 0x%x 0x%x\n",
                                       DRIVER_NAME,
                                       DeviceExtension->UsbInterface->Class,
                                       DeviceExtension->UsbInterface->SubClass,
                                       DeviceExtension->UsbInterface->Protocol));

         // Dump the pipe info

         for (j=0; j<Interface->NumberOfPipes; j++)
            {
            PUSBD_PIPE_INFORMATION pipeInformation;

            pipeInformation = &DeviceExtension->UsbInterface->Pipes[j];

            pipeInformation->MaximumTransferSize = 256;
            pipeInformation->PipeFlags = TRUE;

            SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: ---------\n",
                                          DRIVER_NAME));
            SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: PipeType 0x%x\n",
                                          DRIVER_NAME,
                                          pipeInformation->PipeType));
            SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: EndpointAddress 0x%x\n",
                                          DRIVER_NAME,
                                          pipeInformation->EndpointAddress));
            SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: MaxPacketSize 0x%x\n",
                                          DRIVER_NAME,
                                          pipeInformation->MaximumPacketSize));
            SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: Interval 0x%x\n",
                                          DRIVER_NAME,
                                          pipeInformation->Interval));
            SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: Handle 0x%x\n",
                                          DRIVER_NAME,
                                          pipeInformation->PipeHandle));
            SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: MaximumTransferSize 0x%x\n",
                                          DRIVER_NAME,
                                          pipeInformation->MaximumTransferSize));
            }

         SmartcardDebug( DEBUG_DRIVER,("%s!SelectInterface: ---------\n",
                                       DRIVER_NAME));
         }
      }

   if (urb != NULL)
      {
      ExFreePool(urb);
      }

   return NTStatus;
}


/*****************************************************************************
Routine Description:

    Reset a given USB pipe.

    NOTES:

    This will reset the host to Data0 and should also reset the device to Data0

Arguments:

    Ptrs to our FDO and a USBD_PIPE_INFORMATION struct

Return Value:

    NT NTStatus code

*****************************************************************************/
NTSTATUS
CMUSB_ResetPipe(
               IN PDEVICE_OBJECT DeviceObject,
               IN PUSBD_PIPE_INFORMATION PipeInfo
               )


{
   NTSTATUS NTStatus;
   PURB urb;
   PDEVICE_EXTENSION DeviceExtension;

   DeviceExtension = DeviceObject->DeviceExtension;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!ResetPipe : Enter\n",
                   DRIVER_NAME)
                 );

   urb = ExAllocatePool(NonPagedPool,
                        sizeof(struct _URB_PIPE_REQUEST));

   if (urb != NULL)
      {

      urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
      urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
      urb->UrbPipeRequest.PipeHandle =
      PipeInfo->PipeHandle;

      NTStatus = CMUSB_CallUSBD(DeviceObject, urb);

      ExFreePool(urb);

      }
   else
      {
      NTStatus = STATUS_INSUFFICIENT_RESOURCES;
      }


   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!ResetPipe : Exit %lx\n",
                   DRIVER_NAME,NTStatus)
                 );
   return NTStatus;
}




/*****************************************************************************
Routine Description:

        We keep a pending IO count ( extension->PendingIoCount )  in the device extension.
        The first increment of this count is done on adding the device.
        Subsequently, the count is incremented for each new IRP received and
        decremented when each IRP is completed or passed on.

        Transition to 'one' therefore indicates no IO is pending and signals
        DeviceExtension->NoPendingIoEvent. This is needed for processing
        IRP_MN_QUERY_REMOVE_DEVICE

        Transition to 'zero' signals an event ( DeviceExtension->RemoveEvent )
        to enable device removal. This is used in processing for IRP_MN_REMOVE_DEVICE

Arguments:

        DeviceObject -- ptr to our FDO

Return Value:

        DeviceExtension->PendingIoCount
*****************************************************************************/
VOID
CMUSB_DecrementIoCount(
                      IN PDEVICE_OBJECT DeviceObject
                      )
{
   LONG ioCount;
   PDEVICE_EXTENSION DeviceExtension;

   DeviceExtension = DeviceObject->DeviceExtension;

/*
    SmartcardDebug( DEBUG_TRACE,
                    ("%s!DecrementIoCount: Enter (PendingIoCount=%x)\n",
                     DRIVER_NAME,
                     DeviceExtension->PendingIoCount
                     )
                   );
*/
   ioCount = InterlockedDecrement(&DeviceExtension->PendingIoCount);



   if (ioCount==1)
      {
      // trigger no pending io
      /*
       SmartcardDebug( DEBUG_TRACE,
                       ("%s!DecrementIoCount: setting NoPendingIoEvent\n",
                        DRIVER_NAME
                        )
                      );
      */
      KeSetEvent(&DeviceExtension->NoPendingIoEvent,
                 1,
                 FALSE);
      }


   if (ioCount==0)
      {
      // trigger remove-device event

      SmartcardDebug( DEBUG_DRIVER,
                      ("%s!DecrementIoCount: setting RemoveEvent\n",
                       DRIVER_NAME
                      )
                    );


      KeSetEvent(&DeviceExtension->RemoveEvent,
                 1,
                 FALSE);
      }


/*
    SmartcardDebug( DEBUG_TRACE,
                    ("%s!DecrementIoCount: Exit (PendingIoCount=%x)\n",
                     DRIVER_NAME,
                     DeviceExtension->PendingIoCount
                     )
                   );
*/
   return ;
}


/*****************************************************************************
Routine Description:

        We keep a pending IO count ( extension->PendingIoCount )  in the device extension.
        The first increment of this count is done on adding the device.
        Subsequently, the count is incremented for each new IRP received and
        decremented when each IRP is completed or passed on.


Arguments:

        DeviceObject -- ptr to our FDO

Return Value:

        None
*****************************************************************************/
VOID
CMUSB_IncrementIoCount(
                      IN PDEVICE_OBJECT DeviceObject
                      )
{
   PDEVICE_EXTENSION DeviceExtension;

   DeviceExtension = DeviceObject->DeviceExtension;

   /*
    SmartcardDebug( DEBUG_TRACE,
                    ("%s!IncrementIoCount: Enter (PendingIoCount=%x)\n",
                     DRIVER_NAME,
                     DeviceExtension->PendingIoCount
                     )
                   );
   */

   InterlockedIncrement(&DeviceExtension->PendingIoCount);
   /*
   SmartcardDebug( DEBUG_TRACE,
                   ("%s!IncrementIoCount: Exit (PendingIoCount=%x)\n",
                    DRIVER_NAME,
                    DeviceExtension->PendingIoCount
                    )
                  );
   */

}





/*****************************************************************************
Routine Description:

    Dispatch table handler for IRP_MJ_DEVICE_CONTROL;
    Handle DeviceIoControl() calls  from User mode


Arguments:

    DeviceObject - pointer to the FDO for this instance of the 82930 device.


Return Value:

    NT NTStatus code
*****************************************************************************/
NTSTATUS
CMUSB_ProcessIOCTL(
                  IN PDEVICE_OBJECT DeviceObject,
                  IN PIRP Irp
                  )
{
   NTSTATUS             NTStatus;
   PDEVICE_EXTENSION    DeviceExtension = DeviceObject->DeviceExtension;
   PIO_STACK_LOCATION   irpSL;

   irpSL = IoGetCurrentIrpStackLocation(Irp);

#if DBG
   switch (irpSL->Parameters.DeviceIoControl.IoControlCode)
      {
      case IOCTL_SMARTCARD_EJECT:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_EJECT"));
         break;
      case IOCTL_SMARTCARD_GET_ATTRIBUTE:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_GET_ATTRIBUTE"));
         break;
      case IOCTL_SMARTCARD_GET_LAST_ERROR:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_GET_LAST_ERROR"));
         break;
      case IOCTL_SMARTCARD_GET_STATE:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_GET_STATE"));
         break;
      case IOCTL_SMARTCARD_IS_ABSENT:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_IS_ABSENT"));
         break;
      case IOCTL_SMARTCARD_IS_PRESENT:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_IS_PRESENT"));
         break;
      case IOCTL_SMARTCARD_POWER:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_POWER"));
         break;
      case IOCTL_SMARTCARD_SET_ATTRIBUTE:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_SET_ATTRIBUTE"));
         break;
      case IOCTL_SMARTCARD_SET_PROTOCOL:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_SET_PROTOCOL"));
         break;
      case IOCTL_SMARTCARD_SWALLOW:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_SWALLOW"));
         break;
      case IOCTL_SMARTCARD_TRANSMIT:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_TRANSMIT"));
         break;
      default:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!ProcessIOCTL: %s\n", DRIVER_NAME, "Vendor specific or unexpected IOCTL"));
         break;
      }
#endif

   CMUSB_IncrementIoCount(DeviceObject);

   NTStatus = KeWaitForSingleObject(&DeviceExtension->ReaderEnabled,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL);

   ASSERT(NTStatus == STATUS_SUCCESS);

   // Can't accept a new io request if:
   //  1) device is removed,
   //  2) has never been started,
   //  3) is stopped,
   //  4) has a remove request pending,
   //  5) has a stop device pending
   if (CMUSB_CanAcceptIoRequests( DeviceObject ) == FALSE )
      {
      NTStatus = STATUS_DELETE_PENDING;

      Irp->IoStatus.Status = NTStatus;
      Irp->IoStatus.Information = 0;
      IoCompleteRequest( Irp, IO_NO_INCREMENT );

      CMUSB_DecrementIoCount(DeviceObject);
      return NTStatus;
      }

   NTStatus = SmartcardAcquireRemoveLock(&DeviceExtension->SmartcardExtension);
   if (NTStatus != STATUS_SUCCESS)
      {
      // the device has been removed. Fail the call
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_DELETE_PENDING;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);

      return STATUS_DELETE_PENDING;
      }

   KeWaitForSingleObject(&DeviceExtension->SmartcardExtension.ReaderExtension->CardManIOMutex,
                         Executive,
                         KernelMode,
                         FALSE,
                         NULL);

   NTStatus = CMUSB_UpdateCurrentState (DeviceObject);

   NTStatus = SmartcardDeviceControl(&DeviceExtension->SmartcardExtension,Irp);

   KeReleaseMutex(&DeviceExtension->SmartcardExtension.ReaderExtension->CardManIOMutex,
                  FALSE);

   SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

   CMUSB_DecrementIoCount(DeviceObject);
   return NTStatus;
}






/*****************************************************************************
Routine Description:

Arguments:


Return Value:

*****************************************************************************/
NTSTATUS
CMUSB_ReadP0(
            IN PDEVICE_OBJECT DeviceObject
            )
{
   PURB urb = NULL;
   NTSTATUS NTStatus;
   ULONG i;
   PDEVICE_EXTENSION DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;

   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;

   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ReadP0: Enter\n",
                  DRIVER_NAME)
                  );
   */
   urb = ExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));


   if (urb != NULL)
      {
      RtlZeroMemory(urb, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));


      UsbBuildVendorRequest(urb,
                            URB_FUNCTION_VENDOR_ENDPOINT,
                            (USHORT)sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
                            USBD_TRANSFER_DIRECTION_IN,
                            0,
                            0,
                            0,
                            0,
                            SmartcardExtension->SmartcardReply.Buffer,
                            NULL,
                            SmartcardExtension->SmartcardReply.BufferLength,
                            NULL);


      NTStatus = CMUSB_CallUSBD(DeviceObject,urb);


      if (NTStatus == STATUS_SUCCESS)
         {
         SmartcardExtension->SmartcardReply.BufferLength = urb->UrbControlVendorClassRequest.TransferBufferLength;

#if DBG
         SmartcardDebug(DEBUG_PROTOCOL,
                        ("%s!<==[P0] ",
                         DRIVER_NAME),
                       )
         for (i=0;i<SmartcardExtension->SmartcardReply.BufferLength;i++)
            {
            SmartcardDebug(DEBUG_PROTOCOL,
                           ("%x ",
                            SmartcardExtension->SmartcardReply.Buffer[i]
                           )
                          );
            }
         SmartcardDebug(DEBUG_PROTOCOL,("\n"));
#endif

         }
      ExFreePool(urb);
      }
   else
      {
      NTStatus = STATUS_INSUFFICIENT_RESOURCES;
      }


   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ReadP0  Exit %lx\n",
                  DRIVER_NAME,
                  NTStatus)
                  );
   */

   return NTStatus;
}








/*****************************************************************************
Routine Description:

    Write data through the control pipe to the CardMan USB


Arguments:



Return Value:

    NT NTStatus code
*****************************************************************************/
NTSTATUS
CMUSB_WriteP0(
             IN PDEVICE_OBJECT DeviceObject,
             IN UCHAR bRequest,
             IN UCHAR bValueLo,
             IN UCHAR bValueHi,
             IN UCHAR bIndexLo,
             IN UCHAR bIndexHi
             )
{
   PURB urb = NULL;
   NTSTATUS NTStatus = STATUS_UNSUCCESSFUL;
   USHORT usValue;
   USHORT usIndex;
   ULONG length;
   PDEVICE_EXTENSION DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;
   ULONG ulBytesToWrite;
   ULONG i;

   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;

   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!WriteP0: Enter\n",
                    DRIVER_NAME)
                  );
   */

#if DBG
   SmartcardDebug(DEBUG_PROTOCOL,
                  ("%s!==>[P0] ",DRIVER_NAME));

   for (i=0;i< SmartcardExtension->SmartcardRequest.BufferLength;i++)
      {
      SmartcardDebug(DEBUG_PROTOCOL,
                     ("%x ",SmartcardExtension->SmartcardRequest.Buffer[i]));
      }

   SmartcardDebug(DEBUG_PROTOCOL,
                  ("(%ld)\n",SmartcardExtension->SmartcardRequest.BufferLength));
#endif
   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ulBytesToWrite = %ld\n",
                  DRIVER_NAME,SmartcardExtension->SmartcardRequest.BufferLength)
                  );
   */


   ulBytesToWrite = SmartcardExtension->SmartcardRequest.BufferLength;

   urb = ExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));


   if (urb != NULL)
      {
      RtlZeroMemory(urb, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));

      usValue  = bValueHi * 256 + bValueLo;
      usIndex  = bIndexHi * 256 + bIndexLo;

      if (ulBytesToWrite != 0)
         {
         UsbBuildVendorRequest (urb,
                                URB_FUNCTION_VENDOR_ENDPOINT,
                                (USHORT)sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
                                0,
                                0,
                                bRequest,
                                usValue,
                                usIndex,
                                SmartcardExtension->SmartcardRequest.Buffer,
                                NULL,
                                ulBytesToWrite,
                                NULL);
         }
      else
         {
         UsbBuildVendorRequest (urb,
                                URB_FUNCTION_VENDOR_ENDPOINT,
                                (USHORT)sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
                                0,
                                0,
                                bRequest,
                                usValue,
                                usIndex,
                                NULL,
                                NULL,
                                0L,
                                NULL);
         }
      NTStatus = CMUSB_CallUSBD(DeviceObject,urb);
      ExFreePool(urb);
      }

   if (NTStatus != STATUS_SUCCESS)
      {
      SmartcardDebug(DEBUG_PROTOCOL,
                     ("%s!WriteP0: Error on exit %lx\n",DRIVER_NAME,NTStatus));
      }
   return NTStatus;
}








/*****************************************************************************
/*++

Routine Description:

   Called as part of sudden device removal handling.
   Cancels any pending transfers for all open pipes.
   If any pipes are still open, call USBD with URB_FUNCTION_ABORT_PIPE
   Also marks the pipe 'closed' in our saved  configuration info.

Arguments:

    Ptrs to our FDO

Return Value:

    NT NTStatus code

*****************************************************************************/
NTSTATUS
CMUSB_AbortPipes(
                IN PDEVICE_OBJECT DeviceObject
                )
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   PURB urb;
   PDEVICE_EXTENSION DeviceExtension;
   PUSBD_INTERFACE_INFORMATION interface;
   PUSBD_PIPE_INFORMATION PipeInfo;

   SmartcardDebug(DEBUG_TRACE,
                  ( "%s!AbortPipes: Enter\n",DRIVER_NAME));

   DeviceExtension = DeviceObject->DeviceExtension;
   interface = DeviceExtension->UsbInterface;

   PipeInfo =  &interface->Pipes[0];

   if (PipeInfo->PipeFlags == TRUE) // we set this if open, clear if closed
      {
      urb = ExAllocatePool(NonPagedPool,sizeof(struct _URB_PIPE_REQUEST));
      if (urb != NULL)
         {

         urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
         urb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
         urb->UrbPipeRequest.PipeHandle = PipeInfo->PipeHandle;

         NTStatus = CMUSB_CallUSBD(DeviceObject, urb);

         ExFreePool(urb);
         }
      else
         {
         NTStatus = STATUS_INSUFFICIENT_RESOURCES;
         SmartcardDebug(DEBUG_ERROR,
                        ("%s!AbortPipes: ExAllocatePool failed\n",DRIVER_NAME));
         }


      if (NTStatus == STATUS_SUCCESS)
         {
         PipeInfo->PipeFlags = FALSE; // mark the pipe 'closed'
         }

      } // end, if pipe open


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!AbortPipes: Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}



/*****************************************************************************
Routine Description:

  Check device extension NTStatus flags;

     Can't accept a new io request if device:
      1) is removed,
      2) has never been started,
      3) is stopped,
      4) has a remove request pending, or
      5) has a stop device pending


Arguments:

    DeviceObject - pointer to the device object for this instance of the 82930
                    device.


Return Value:

    return TRUE if can accept new io requests, else FALSE
*****************************************************************************/
BOOLEAN
CMUSB_CanAcceptIoRequests(
                         IN PDEVICE_OBJECT DeviceObject
                         )
{
   PDEVICE_EXTENSION DeviceExtension;
   BOOLEAN fCan = FALSE;

   DeviceExtension = DeviceObject->DeviceExtension;

   //flag set when processing IRP_MN_REMOVE_DEVICE
   if ( DeviceExtension->DeviceRemoved == FALSE &&
        // device must be started( enabled )
        DeviceExtension->DeviceStarted == TRUE &&
        // flag set when driver has answered success to IRP_MN_QUERY_REMOVE_DEVICE
        DeviceExtension->RemoveDeviceRequested == FALSE&&
        //flag set when processing IRP_MN_SURPRISE_REMOVAL
        DeviceExtension->DeviceSurpriseRemoval == FALSE&&
        // flag set when driver has answered success to IRP_MN_QUERY_STOP_DEVICE
        DeviceExtension->StopDeviceRequested == FALSE)
      {
      fCan = TRUE;
      }

#if DBG
   if (fCan == FALSE)
      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!CanAcceptIoRequests: return FALSE \n",DRIVER_NAME));
#endif

   return fCan;
}




/*****************************************************************************
* History:
* $Log: scusbwdm.c $
* Revision 1.9  2001/01/17 12:36:06  WFrischauf
* No comment given
*
* Revision 1.8  2000/09/25 13:38:23  WFrischauf
* No comment given
*
* Revision 1.7  2000/08/24 09:04:39  TBruendl
* No comment given
*
* Revision 1.6  2000/08/16 08:25:23  TBruendl
* warning :uninitialized memory removed
*
* Revision 1.5  2000/07/24 11:35:01  WFrischauf
* No comment given
*
* Revision 1.1  2000/07/20 11:50:16  WFrischauf
* No comment given
*
*
******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\scmstcs\drivernt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       drivernt.h
//
//--------------------------------------------------------------------------

#if !defined( __DRIVER_NT_H__ )
#define __DRIVER_NT_H__

#include <NTDDK.H>
#include "STCLog.h"
#include "SMCLIB.h"
#include "WINSMCRD.h"
#include "SerialNT.h"

#define SMARTCARD_POOL_TAG '3BCS'

#if !defined( STATUS_DEVICE_REMOVED	)
#define STATUS_DEVICE_REMOVED	STATUS_UNSUCCESSFUL
#endif

void SystemTime( void );
void DataOut( PUCHAR p, ULONG l );

#define LOBYTE( any )	((UCHAR)( any & 0xFF ) )
#define HIBYTE( any )	((UCHAR)( ( any >> 8) & 0xFF ))

#define SysCompareMemory( p1, p2, Len )			( RtlCompareMemory( p1,p2, Len ) != Len )
#define SysCopyMemory( pDest, pSrc, Len )		RtlCopyMemory( pDest, pSrc, Len )
#define SysFillMemory( pDest, Value, Len )		RtlFillMemory( pDest, Len, Value )

typedef struct _DEVICE_EXTENSION
{
	SMARTCARD_EXTENSION		SmartcardExtension;

#if defined( __NT4__ )
	BOOLEAN					OpenFlag;
	UNICODE_STRING			LinkID;
#else
    KEVENT					ReaderStarted;		    //	Used to signal that the reader is able to process reqeusts
    LONG					ReaderOpen;				//  Used to signal the the reader has been closed
	KSPIN_LOCK				SpinLock;
	UNICODE_STRING			PnPDeviceName;			//	The pnp device name of our smart card reader
	PVOID					RemoveLock;
    ULONG					DeviceInstance;
    LONG					PowerState;				//	Used to keep track of the current power state the reader is in
    LONG					IoCount;			    //	The current number of io-requests
#endif



} DEVICE_EXTENSION, *PDEVICE_EXTENSION;
		
#define IOCTL_SR_COMMAND		SCARD_CTL_CODE( 0x800 )
#define IOCTL_GET_VERSIONS		SCARD_CTL_CODE( 0x801 )

typedef struct _VERSION_CONTROL
{
	ULONG	SmclibVersion;
	UCHAR	DriverMajor,
			DriverMinor,
			FirmwareMajor, 
			FirmwareMinor;

} VERSION_CONTROL, *PVERSION_CONTROL;

#define MAX_READERS				4

NTSTATUS
DriverEntry(
	PDRIVER_OBJECT	DriverObject,
	PUNICODE_STRING	RegistryPath
	);


NTSTATUS 
DrvGetConfiguration(
	PDRIVER_OBJECT	DriverObject,
	PUNICODE_STRING	RegistryPath,
	PULONG			pComPort
	);

NTSTATUS
DrvInitDeviceObject(
	PDRIVER_OBJECT	DriverObject,
	ULONG			ComPort
	);

VOID
DrvUnloadDevice( 
	PDEVICE_OBJECT	DeviceObject
	);

VOID
DrvUnloadDriver( 
	PDRIVER_OBJECT	DriverObject
	);

NTSTATUS 
DrvOpenClose(
	PDEVICE_OBJECT	DeviceObject,
	PIRP			Irp
	);

NTSTATUS 
DrvDeviceIoControl(
	PDEVICE_OBJECT	DeviceObject,
	PIRP			Irp
	);

NTSTATUS
DrvGenericIOCTL(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

void
DrvSetupSmartcardExtension(
	PSMARTCARD_EXTENSION	SmartcardExtension
	);

NTSTATUS
DrvCancel(
	PDEVICE_OBJECT DeviceObject,
	PIRP Irp
    );

void
SysDelay(
	ULONG Timeout
	);

#endif	// !__DRIVER_NT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\scmstcs\drvnt5.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       drvnt5.c
//
//--------------------------------------------------------------------------

#include "DriverNT.h"
#include "DrvNT5.h"
#include "CBHndlr.h"
#include "STCCmd.h"
#include "SRVers.h"

// declare pageable/initialization code
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( PAGEABLE, DrvAddDevice )
#pragma alloc_text( PAGEABLE, DrvCreateDevice )
#pragma alloc_text( PAGEABLE, DrvRemoveDevice )
#pragma alloc_text( PAGEABLE, DrvDriverUnload )


//________________________________ D R I V E R   E N T R Y ________________________________________

NTSTATUS
DriverEntry(
   IN  PDRIVER_OBJECT  DriverObject,
   IN  PUNICODE_STRING RegistryPath
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   
   SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!DriverEntry: Enter\n"));

   // initialization of the drivers entry points
   DriverObject->DriverUnload                   = DrvDriverUnload;
   DriverObject->MajorFunction[IRP_MJ_CREATE]         = DrvCreateClose;
   DriverObject->MajorFunction[IRP_MJ_CLOSE]       = DrvCreateClose;
   DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = DrvCleanup;
   DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DrvDeviceIoControl;
   DriverObject->MajorFunction[IRP_MJ_PNP]            = DrvPnPHandler;
   DriverObject->MajorFunction[IRP_MJ_POWER]       = DrvPowerHandler;
   DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = DrvSystemControl;
   DriverObject->DriverExtension->AddDevice        = DrvAddDevice;

   SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!DriverEntry: Exit\n"));

   return( NTStatus );
}

//________________________________ I N I T I A L I Z A T I O N ____________________________________

NTSTATUS
DrvAddDevice(
   IN PDRIVER_OBJECT DriverObject,
   IN PDEVICE_OBJECT PhysicalDeviceObject
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   PDEVICE_OBJECT DeviceObject = NULL;
   NTSTATUS NTStatus = STATUS_SUCCESS;
   ULONG deviceInstance;
   UNICODE_STRING vendorNameU, ifdTypeU;
   ANSI_STRING vendorNameA, ifdTypeA;
   HANDLE regKey = NULL;

    // this is a list of our supported data rates
    static ULONG dataRatesSupported[] = {
      9600, 19200, 28800, 38400, 48000, 57600, 67200, 76800, 86400, 96000, 115200
      };

   PAGED_CODE();

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvAddDevice: Enter\n" ));

   __try
   {
      PDEVICE_EXTENSION DeviceExtension;
      PSMARTCARD_EXTENSION SmartcardExtension;
      PREADER_EXTENSION ReaderExtension;
      RTL_QUERY_REGISTRY_TABLE parameters[3];

      RtlZeroMemory(parameters, sizeof(parameters));
      RtlZeroMemory(&vendorNameU, sizeof(vendorNameU));
      RtlZeroMemory(&ifdTypeU, sizeof(ifdTypeU));
      RtlZeroMemory(&vendorNameA, sizeof(vendorNameA));
      RtlZeroMemory(&ifdTypeA, sizeof(ifdTypeA));

      // create the device object
      NTStatus = IoCreateDevice(
         DriverObject,
         sizeof( DEVICE_EXTENSION ),
         NULL,
         FILE_DEVICE_SMARTCARD,
         0,
         TRUE,
         &DeviceObject
         );

      if( NTStatus != STATUS_SUCCESS )
      {
         SmartcardLogError( DriverObject, STC_CANT_CREATE_DEVICE, NULL, 0 );
         __leave;
      }

      // initialize device extension
      DeviceExtension   = DeviceObject->DeviceExtension;
      SmartcardExtension = &DeviceExtension->SmartcardExtension;

      KeInitializeEvent(
            &DeviceExtension->ReaderStarted,
            NotificationEvent,
            FALSE
            );
      // Used to keep track of open close calls
      DeviceExtension->ReaderOpen = FALSE;

      KeInitializeSpinLock(&DeviceExtension->SpinLock);

      // initialize smartcard extension - version & callbacks

      SmartcardExtension->Version = SMCLIB_VERSION;

      SmartcardExtension->ReaderFunction[RDF_TRANSMIT] = CBTransmit;
      SmartcardExtension->ReaderFunction[RDF_SET_PROTOCOL] = CBSetProtocol;
      SmartcardExtension->ReaderFunction[RDF_CARD_POWER] = CBCardPower;
      SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING] = CBCardTracking;

      // initialize smartcard extension - vendor attribute
      RtlCopyMemory(
         SmartcardExtension->VendorAttr.VendorName.Buffer,
         SR_VENDOR_NAME,
         sizeof( SR_VENDOR_NAME )
         );

      SmartcardExtension->VendorAttr.VendorName.Length =
            sizeof( SR_VENDOR_NAME );

      RtlCopyMemory(
         SmartcardExtension->VendorAttr.IfdType.Buffer,
         SR_PRODUCT_NAME,
         sizeof( SR_PRODUCT_NAME )
         );

      SmartcardExtension->VendorAttr.IfdType.Length =
            sizeof( SR_PRODUCT_NAME );

      SmartcardExtension->VendorAttr.UnitNo = MAXULONG;

      for (deviceInstance = 0; deviceInstance < MAXULONG; deviceInstance++) {

         PDEVICE_OBJECT devObj;

         for (devObj = DeviceObject;
             devObj != NULL;
             devObj = devObj->NextDevice) {

             PDEVICE_EXTENSION devExt = devObj->DeviceExtension;
             PSMARTCARD_EXTENSION smcExt = &devExt->SmartcardExtension;

             if (deviceInstance == smcExt->VendorAttr.UnitNo) {

                break;
             }
         }
         if (devObj == NULL) {

            SmartcardExtension->VendorAttr.UnitNo = deviceInstance;
            break;
         }
      }

      SmartcardExtension->VendorAttr.IfdVersion.BuildNumber = 0;

      // initialize smartcard extension - reader capabilities
      SmartcardExtension->ReaderCapabilities.SupportedProtocols =
            SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;
      SmartcardExtension->ReaderCapabilities.ReaderType =
            SCARD_READER_TYPE_SERIAL;
      SmartcardExtension->ReaderCapabilities.MechProperties = 0;
      SmartcardExtension->ReaderCapabilities.Channel = 0;
      SmartcardExtension->ReaderCapabilities.MaxIFSD =
         STC_BUFFER_SIZE - PACKET_OVERHEAD;

      SmartcardExtension->ReaderCapabilities.CLKFrequency.Default = 3571;
      SmartcardExtension->ReaderCapabilities.CLKFrequency.Max = 3571;

      SmartcardExtension->ReaderCapabilities.DataRate.Default =
      SmartcardExtension->ReaderCapabilities.DataRate.Max =
          dataRatesSupported[0];

      // reader could support higher data rates
      SmartcardExtension->ReaderCapabilities.DataRatesSupported.List =
         dataRatesSupported;
      SmartcardExtension->ReaderCapabilities.DataRatesSupported.Entries =
         sizeof(dataRatesSupported) / sizeof(dataRatesSupported[0]);

      SmartcardExtension->ReaderCapabilities.CurrentState   = (ULONG) SCARD_UNKNOWN;

      SmartcardExtension->SmartcardRequest.BufferSize = MIN_BUFFER_SIZE;
      SmartcardExtension->SmartcardReply.BufferSize = MIN_BUFFER_SIZE;

      // allocate & initialize reader extension
      SmartcardExtension->ReaderExtension = ExAllocatePool(
            NonPagedPool,
            sizeof( READER_EXTENSION )
            );

      if( SmartcardExtension->ReaderExtension == NULL )
      {
         SmartcardLogError( DriverObject, STC_NO_MEMORY, NULL, 0 );
         NTStatus = STATUS_INSUFFICIENT_RESOURCES;
         __leave;
      }

      ReaderExtension = SmartcardExtension->ReaderExtension;

      ASSERT( ReaderExtension != NULL );

      RtlZeroMemory(ReaderExtension, sizeof( READER_EXTENSION ));

        ReaderExtension->SmartcardExtension = SmartcardExtension;
        ReaderExtension->ReadTimeout = 5000;

      KeInitializeEvent(
         &ReaderExtension->SerialCloseDone,
         NotificationEvent,
         TRUE
         );

      ReaderExtension->CloseSerial = IoAllocateWorkItem(
         DeviceObject
         );

      ReaderExtension->ReadWorkItem = IoAllocateWorkItem(
         DeviceObject
         );

      if (ReaderExtension->CloseSerial == NULL ||
         ReaderExtension->ReadWorkItem == NULL) {

         NTStatus = STATUS_INSUFFICIENT_RESOURCES;
         __leave;
      }

      KeInitializeEvent(
         &ReaderExtension->DataAvailable,
         NotificationEvent,
         FALSE
         );

      KeInitializeEvent(
         &ReaderExtension->IoEvent,
         NotificationEvent,
         FALSE
         );

      NTStatus = SmartcardInitialize( SmartcardExtension );

      if( NTStatus != STATUS_SUCCESS )
      {
         SmartcardLogError(
            DriverObject,
            (SmartcardExtension->OsData ? STC_WRONG_LIB_VERSION : STC_NO_MEMORY ),
            NULL,
            0
            );
         __leave;
      }
      // Save deviceObject
      SmartcardExtension->OsData->DeviceObject = DeviceObject;

      // save the current Power state of the reader
      SmartcardExtension->ReaderExtension->ReaderPowerState = PowerReaderWorking;

      DeviceExtension   = DeviceObject->DeviceExtension;
      ReaderExtension   = DeviceExtension->SmartcardExtension.ReaderExtension;

      // attach the device object to the physical device object
      ReaderExtension->SerialDeviceObject =
         IoAttachDeviceToDeviceStack(
         DeviceObject,
         PhysicalDeviceObject
         );

      ASSERT( ReaderExtension->SerialDeviceObject != NULL );

      if( ReaderExtension->SerialDeviceObject == NULL )
      {
         SmartcardLogError(
            DriverObject,
            STC_CANT_CONNECT_TO_ASSIGNED_PORT,
            NULL,
            NTStatus
            );
         NTStatus = STATUS_UNSUCCESSFUL;
         __leave;
      }

      // register our new device
      NTStatus = IoRegisterDeviceInterface(
         PhysicalDeviceObject,
         &SmartCardReaderGuid,
         NULL,
         &DeviceExtension->PnPDeviceName
         );

      ASSERT( NTStatus == STATUS_SUCCESS );

      DeviceObject->Flags |= DO_BUFFERED_IO;
      DeviceObject->Flags |= DO_POWER_PAGABLE;
      DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

      //
      // try to read the reader name from the registry
      // if that does not work, we will use the default
      // (hardcoded) name
      //
      if (IoOpenDeviceRegistryKey(
         PhysicalDeviceObject,
         PLUGPLAY_REGKEY_DEVICE,
         KEY_READ,
         &regKey
         ) != STATUS_SUCCESS) {

         __leave;
      }

      parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
      parameters[0].Name = L"VendorName";
      parameters[0].EntryContext = &vendorNameU;
      parameters[0].DefaultType = REG_SZ;
      parameters[0].DefaultData = &vendorNameU;
      parameters[0].DefaultLength = 0;

      parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
      parameters[1].Name = L"IfdType";
      parameters[1].EntryContext = &ifdTypeU;
      parameters[1].DefaultType = REG_SZ;
      parameters[1].DefaultData = &ifdTypeU;
      parameters[1].DefaultLength = 0;

      if (RtlQueryRegistryValues(
          RTL_REGISTRY_HANDLE,
          (PWSTR) regKey,
          parameters,
          NULL,
          NULL
          ) != STATUS_SUCCESS) {

         __leave;
      }

      if (RtlUnicodeStringToAnsiString(
         &vendorNameA,
         &vendorNameU,
         TRUE
         ) != STATUS_SUCCESS) {

         __leave;
      }

      if (RtlUnicodeStringToAnsiString(
         &ifdTypeA,
         &ifdTypeU,
         TRUE
         ) != STATUS_SUCCESS) {

         __leave;
      }

      if (vendorNameA.Length == 0 ||
         vendorNameA.Length > MAXIMUM_ATTR_STRING_LENGTH ||
         ifdTypeA.Length == 0 ||
         ifdTypeA.Length > MAXIMUM_ATTR_STRING_LENGTH) {

         __leave;
      }

      RtlCopyMemory(
         SmartcardExtension->VendorAttr.VendorName.Buffer,
         vendorNameA.Buffer,
         vendorNameA.Length
         );
      SmartcardExtension->VendorAttr.VendorName.Length =
         vendorNameA.Length;

      RtlCopyMemory(
         SmartcardExtension->VendorAttr.IfdType.Buffer,
         ifdTypeA.Buffer,
         ifdTypeA.Length
         );
      SmartcardExtension->VendorAttr.IfdType.Length =
         ifdTypeA.Length;
   }
   __finally
   {
      if (vendorNameU.Buffer) {

         RtlFreeUnicodeString(&vendorNameU);
      }

      if (ifdTypeU.Buffer) {

         RtlFreeUnicodeString(&ifdTypeU);
      }

      if (vendorNameA.Buffer) {

         RtlFreeAnsiString(&vendorNameA);
      }

      if (ifdTypeA.Buffer) {

         RtlFreeAnsiString(&ifdTypeA);
      }

      if (regKey != NULL) {

         ZwClose(regKey);
      }

      if (NTStatus != STATUS_SUCCESS) {

         DrvRemoveDevice( DeviceObject );
      }

      SmartcardDebug(
         DEBUG_TRACE,
         ( "SCMSTCS!DrvAddDevice: Exit (%lx)\n", NTStatus )
         );
   }
    return NTStatus;
}

NTSTATUS
DrvStartDevice(
   IN PDEVICE_OBJECT DeviceObject
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS NTStatus;
   PIRP     Irp;

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvStartDevice: Enter\n" ));

   Irp = IoAllocateIrp((CCHAR)( DeviceObject->StackSize + 1 ), FALSE );

   ASSERT( Irp != NULL );

   if( Irp != NULL )
   {
      PDEVICE_EXTENSION    DeviceExtension;
      PIO_STACK_LOCATION      IrpStack;
      IO_STATUS_BLOCK         IoStatusBlock;
      PSMARTCARD_EXTENSION SmartcardExtension;
      PREADER_EXTENSION    ReaderExtension;

      DeviceExtension      = DeviceObject->DeviceExtension;
      SmartcardExtension   = &DeviceExtension->SmartcardExtension;
      ReaderExtension      = SmartcardExtension->ReaderExtension;

      ASSERT( DeviceExtension != NULL );
      ASSERT( SmartcardExtension != NULL );
      ASSERT( ReaderExtension != NULL );

      KeClearEvent( &ReaderExtension->SerialCloseDone );

      //
      // send MJ_CREATE to the serial driver. a side effect of this call is that the serial
      // enumerator will be informed about the device and not longer poll the interface
      //
      Irp->UserIosb = &IoStatusBlock;

      IoSetNextIrpStackLocation( Irp );
      IrpStack = IoGetCurrentIrpStackLocation( Irp );

      IrpStack->MajorFunction                = IRP_MJ_CREATE;
      IrpStack->Parameters.Create.Options       = 0;
      IrpStack->Parameters.Create.ShareAccess      = 0;
      IrpStack->Parameters.Create.FileAttributes   = 0;
      IrpStack->Parameters.Create.EaLength      = 0;

      NTStatus = DrvCallSerialDriver(
            ReaderExtension->SerialDeviceObject,
            Irp
            );

      if( NTStatus == STATUS_SUCCESS )
      {
         SERIAL_PORT_CONFIG      COMConfig;

         // configure the serial port
         COMConfig.BaudRate.BaudRate         = SR_BAUD_RATE;
         COMConfig.LineControl.StopBits      = SR_STOP_BITS;
         COMConfig.LineControl.Parity     = SR_PARITY;
         COMConfig.LineControl.WordLength = SR_DATA_LENGTH;

         // timeouts
         COMConfig.Timeouts.ReadIntervalTimeout =
                SR_READ_INTERVAL_TIMEOUT;
         COMConfig.Timeouts.ReadTotalTimeoutConstant  =
                SR_READ_TOTAL_TIMEOUT_CONSTANT;
         COMConfig.Timeouts.ReadTotalTimeoutMultiplier = 0;

         COMConfig.Timeouts.WriteTotalTimeoutConstant =
            SR_WRITE_TOTAL_TIMEOUT_CONSTANT;
         COMConfig.Timeouts.WriteTotalTimeoutMultiplier = 0;

         // special characters
         COMConfig.SerialChars.ErrorChar     = 0;
         COMConfig.SerialChars.EofChar    = 0;
         COMConfig.SerialChars.EventChar     = 0;
         COMConfig.SerialChars.XonChar    = 0;
         COMConfig.SerialChars.XoffChar      = 0;
         COMConfig.SerialChars.BreakChar     = 0;

         // handflow
         COMConfig.HandFlow.XonLimit         = 0;
         COMConfig.HandFlow.XoffLimit     = 0;
         COMConfig.HandFlow.ControlHandShake = 0;
         COMConfig.HandFlow.FlowReplace      =
              SERIAL_XOFF_CONTINUE;

         // miscellenaeous
         COMConfig.WaitMask               = SR_NOTIFICATION_EVENT;
         COMConfig.Purge                  = SR_PURGE;

         NTStatus = IFInitializeInterface( ReaderExtension, &COMConfig );

         if( NTStatus == STATUS_SUCCESS )
         {
            // configure the reader & initialize the card state
            NTStatus = STCConfigureSTC(
                    ReaderExtension,
                    ( PSTC_REGISTER ) STCInitialize
                    );

            CBUpdateCardState( SmartcardExtension, SCARD_UNKNOWN );
            //
            // store firmware revision in ifd version
            //
            STCGetFirmwareRevision( ReaderExtension );
            SmartcardExtension->VendorAttr.IfdVersion.VersionMajor =
               ReaderExtension->FirmwareMajor;
            SmartcardExtension->VendorAttr.IfdVersion.VersionMinor =
               ReaderExtension->FirmwareMinor;
            SmartcardExtension->VendorAttr.IfdSerialNo.Length     = 0;

            if( NTStatus == STATUS_SUCCESS )
            {
               NTStatus = IoSetDeviceInterfaceState(
                        &DeviceExtension->PnPDeviceName,
                        TRUE
                        );

               if( NTStatus == STATUS_SUCCESS )
               {
                  KeSetEvent( &DeviceExtension->ReaderStarted, 0, FALSE );
               }
            }
            else
            {
               SmartcardLogError( DeviceObject, STC_NO_READER_FOUND, NULL, 0 );
            }
         }
         else
         {
            SmartcardLogError( DeviceObject, STC_ERROR_INIT_INTERFACE, NULL, 0 );
         }
      }
      else
      {
         SmartcardLogError( DeviceObject, STC_CONNECT_FAILS, NULL, 0 );
      }
      IoFreeIrp( Irp );
   }
   else
   {
      SmartcardLogError( DeviceObject, STC_NO_MEMORY, NULL, 0 );
      NTStatus = STATUS_NO_MEMORY;
   }

    if (NTStatus != STATUS_SUCCESS) {

        DrvStopDevice(DeviceObject->DeviceExtension);
    }

   SmartcardDebug(
        (NTStatus == STATUS_SUCCESS ? DEBUG_TRACE : DEBUG_ERROR),
        ( "SCMSTCS!DrvStartDevice: Exit %lx\n",
        NTStatus )
        );

   return( NTStatus );
}

//________________________________________ U N L O A D ____________________________________________

VOID
DrvStopDevice(
   IN PDEVICE_EXTENSION DeviceExtension
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/

{
   PSMARTCARD_EXTENSION SmartcardExtension;

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvStopDevice: Enter\n" ));

   SmartcardExtension = &DeviceExtension->SmartcardExtension;

   if( KeReadStateEvent( &SmartcardExtension->ReaderExtension->SerialCloseDone ) == 0l )
   {
      NTSTATUS NTStatus;
      ULONG    WaitMask;

      SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvStopDevice: Power Down\n" ));

      // power down the reader
      STCConfigureSTC(
            SmartcardExtension->ReaderExtension,
            ( PSTC_REGISTER ) STCClose
            );

      // the following delay is neccessary to make sure the last read operation is completed
      // and a IOCTL_SERIAL_WAIT_ON_MASK is started
      SysDelay( 2 * SR_READ_TOTAL_TIMEOUT_CONSTANT );

      //
      // no more event notification neccessary. a side effect is the
      // finishing of all pending notification irp's by the serial driver,
      // so the callback will complete the irp & initiate the close of the
      // connection to the serial driver
      //
      WaitMask = 0;
      SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!Set Wait Mask\n" ));

      NTStatus = IFSerialIoctl(
         SmartcardExtension->ReaderExtension,
         IOCTL_SERIAL_SET_WAIT_MASK,
         &WaitMask,
         sizeof( ULONG ),
         NULL,
         0
         );

      SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!Wait For Done\n" ));

      // wait until the connetion to the serial driver is closed
      NTStatus = KeWaitForSingleObject(
         &SmartcardExtension->ReaderExtension->SerialCloseDone,
         Executive,
         KernelMode,
         FALSE,
         NULL
         );

   }

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvStopDevice: Exit\n" ));
}


VOID
DrvRemoveDevice(
   PDEVICE_OBJECT DeviceObject
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS          NTStatus;
   PDEVICE_EXTENSION    DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvRemoveDevice: Enter\n" ));

   PAGED_CODE();

   if( DeviceObject != NULL )
   {
      DeviceExtension      = DeviceObject->DeviceExtension;
      SmartcardExtension   = &DeviceExtension->SmartcardExtension;

      DrvStopDevice( DeviceExtension );

      if( SmartcardExtension->OsData )
      {
         ASSERT( SmartcardExtension->OsData->NotificationIrp == NULL );

         // Wait until we can safely unload the device
         SmartcardReleaseRemoveLockAndWait( SmartcardExtension );
      }

      if( SmartcardExtension->ReaderExtension->SerialDeviceObject )
      {
         IoDetachDevice( SmartcardExtension->ReaderExtension->SerialDeviceObject );
      }

      if( DeviceExtension->PnPDeviceName.Buffer != NULL )
      {
         RtlFreeUnicodeString( &DeviceExtension->PnPDeviceName );
      }

      if( SmartcardExtension->OsData != NULL )
      {
         SmartcardExit( SmartcardExtension );
      }

      if( SmartcardExtension->ReaderExtension != NULL )
      {
         if (SmartcardExtension->ReaderExtension->CloseSerial != NULL) {

            IoFreeWorkItem(SmartcardExtension->ReaderExtension->CloseSerial);
         }

         if (SmartcardExtension->ReaderExtension->ReadWorkItem != NULL) {

            IoFreeWorkItem(SmartcardExtension->ReaderExtension->ReadWorkItem);
         }

         ExFreePool( SmartcardExtension->ReaderExtension );
      }

      IoDeleteDevice( DeviceObject );
   }
   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvRemoveDevice: Exit\n" ));
}

VOID
DrvDriverUnload(
   IN PDRIVER_OBJECT DriverObject
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   PDEVICE_OBJECT DeviceObject;
   NTSTATUS    NTStatus;

   PAGED_CODE();

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvDriverUnload: Enter\n" ));

   // just make sure that all device instances have been unloaded
   while( DeviceObject = DriverObject->DeviceObject )
   {
      DrvRemoveDevice( DeviceObject );

   } while( DeviceObject = DriverObject->DeviceObject );

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvDriverUnload: Exit\n" ));
}

NTSTATUS
DrvSystemControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )

/*++

Routine Description:

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_SUCCESS.

--*/
{
   
   PDEVICE_EXTENSION DeviceExtension; 
   PSMARTCARD_EXTENSION SmartcardExtension; 
   PREADER_EXTENSION ReaderExtension; 
   NTSTATUS status = STATUS_SUCCESS;

   DeviceExtension      = DeviceObject->DeviceExtension;
   SmartcardExtension   = &DeviceExtension->SmartcardExtension;
   ReaderExtension      = SmartcardExtension->ReaderExtension;

   IoSkipCurrentIrpStackLocation(Irp);
   status = IoCallDriver(ReaderExtension->SerialDeviceObject, Irp);
      
   return status;

} 



//______________________________ D E V I C E   I O   C O N T R O L ________________________________



NTSTATUS
DrvCreateClose(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )

/*++

Routine Description:

    This routine is called by the I/O system when the device is opened or closed.

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_SUCCESS.

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;

   __try {

      if (irpStack->MajorFunction == IRP_MJ_CREATE) {

         status = SmartcardAcquireRemoveLockWithTag(
            &deviceExtension->SmartcardExtension,
            'lCrC'
            );

         if (status != STATUS_SUCCESS) {

            status = STATUS_DEVICE_REMOVED;
            __leave;
         }

         // test if the device has been opened already
         if (InterlockedCompareExchange(
            &deviceExtension->ReaderOpen,
            TRUE,
            FALSE) == FALSE) {

            SmartcardDebug(
               DEBUG_DRIVER,
               ("%s!DrvCreateClose: Open\n",
               DRIVER_NAME)
               );

         } else {

            // the device is already in use
            status = STATUS_UNSUCCESSFUL;

            // release the lock
            SmartcardReleaseRemoveLockWithTag(
               &deviceExtension->SmartcardExtension,
               'lCrC'
               );

         }

      } else {

         SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!DrvCreateClose: Close\n",
            DRIVER_NAME)
            );

         SmartcardReleaseRemoveLockWithTag(
            &deviceExtension->SmartcardExtension,
            'lCrC'
            );
         deviceExtension->ReaderOpen = FALSE;
      }
   }
   __finally {

      Irp->IoStatus.Status = status;
      Irp->IoStatus.Information = 0;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
   }

    return status;
}

NTSTATUS
DrvDeviceIoControl(
   PDEVICE_OBJECT DeviceObject,
   PIRP        Irp
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS          NTStatus=STATUS_SUCCESS;
   PDEVICE_EXTENSION    DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;
   KIRQL             CurrentIrql;

   DeviceExtension      = DeviceObject->DeviceExtension;
   SmartcardExtension   = &DeviceExtension->SmartcardExtension;

   if (KeReadStateEvent(&(SmartcardExtension->ReaderExtension->SerialCloseDone))) {

      //
      // we have no connection to serial, the device was either
      // surprise-removed or politely removed
      //
      NTStatus = STATUS_DEVICE_REMOVED;
   }
   if (NTStatus == STATUS_SUCCESS)
   {
      KeAcquireSpinLock( &DeviceExtension->SpinLock, &CurrentIrql );

      // make sure that the reader is already started
      if( DeviceExtension->IoCount == 0 )
      {
         KeReleaseSpinLock( &DeviceExtension->SpinLock, CurrentIrql );

         // wait until the pnp manager has started the device
         NTStatus = KeWaitForSingleObject(
            &DeviceExtension->ReaderStarted,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );


         KeAcquireSpinLock( &DeviceExtension->SpinLock, &CurrentIrql );
      }


      DeviceExtension->IoCount++;

      KeReleaseSpinLock( &DeviceExtension->SpinLock, CurrentIrql );

      NTStatus = SmartcardAcquireRemoveLockWithTag(SmartcardExtension, 'tcoI');
   }
   if( NTStatus != STATUS_SUCCESS )
   {
      // if no remove lock can be acquired, the device has been removed
      Irp->IoStatus.Information  = 0;
      Irp->IoStatus.Status    = STATUS_DEVICE_REMOVED;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      NTStatus = STATUS_DEVICE_REMOVED;
      SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvDeviceIoControl: the device has been removed\n" ));

   }
   else
   {
      // let the lib process the call
      NTStatus = SmartcardDeviceControl( SmartcardExtension, Irp );

       SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'tcoI');

      KeAcquireSpinLock( &DeviceExtension->SpinLock, &CurrentIrql );

      DeviceExtension->IoCount--;

      KeReleaseSpinLock(&DeviceExtension->SpinLock, CurrentIrql);
   }
   return( NTStatus );
}


NTSTATUS
DrvGenericIOCTL(
   PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

DrvGenericIOCTL:
   Performs generic callbacks to the reader

Arguments:
   SmartcardExtension   context of the call

Return Value:
   STATUS_SUCCESS

--*/
{
   NTSTATUS          NTStatus;
   PIRP              Irp;
   PIO_STACK_LOCATION      IrpStack;

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvGenericIOCTL: Enter\n" ));

   // get pointer to current IRP stack location
   Irp         = SmartcardExtension->OsData->CurrentIrp;
   IrpStack = IoGetCurrentIrpStackLocation( Irp );

   // assume error
   NTStatus = STATUS_INVALID_DEVICE_REQUEST;
   Irp->IoStatus.Information = 0;

   // dispatch IOCTL
   switch( IrpStack->Parameters.DeviceIoControl.IoControlCode )
   {
      case IOCTL_GET_VERSIONS:

         if( IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof( VERSION_CONTROL ))
         {
            NTStatus = STATUS_BUFFER_TOO_SMALL;
         }
         else
         {
            PVERSION_CONTROL  VersionControl;

            VersionControl = (PVERSION_CONTROL)Irp->AssociatedIrp.SystemBuffer;

            VersionControl->SmclibVersion = SmartcardExtension->Version;
            VersionControl->DriverMajor      = SCMSTCS_MAJOR_VERSION;
            VersionControl->DriverMinor      = SCMSTCS_MINOR_VERSION;

            // update firmware version
            STCGetFirmwareRevision( SmartcardExtension->ReaderExtension );

            VersionControl->FirmwareMajor =
               SmartcardExtension->ReaderExtension->FirmwareMajor;

            VersionControl->FirmwareMinor =
               SmartcardExtension->ReaderExtension->FirmwareMinor;

            Irp->IoStatus.Information = sizeof( VERSION_CONTROL );
            NTStatus = STATUS_SUCCESS;
         }
         break;

      default:
         break;
   }

   // set status of the packet
   Irp->IoStatus.Status = NTStatus;

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvGenericIOCTL: Exit\n" ));

   return( NTStatus );
}

NTSTATUS
DrvCancel(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )

/*++

Routine Description:
    This function is called whenever the caller wants to
    cancel a pending irp.

Arguments:
    DeviceObject - Our device object
    Irp - the pending irp that we should cancel
--*/
{
   PDEVICE_EXTENSION    DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvCancel: Enter\n" ));

   DeviceExtension      = DeviceObject->DeviceExtension;
   SmartcardExtension   = &DeviceExtension->SmartcardExtension;

   ASSERT( Irp == SmartcardExtension->OsData->NotificationIrp );

   Irp->IoStatus.Information  = 0;
   Irp->IoStatus.Status    = STATUS_CANCELLED;

   SmartcardExtension->OsData->NotificationIrp = NULL;
   IoReleaseCancelSpinLock( Irp->CancelIrql );

   SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!Cancel Irp %lx\n", Irp ));
   IoCompleteRequest( Irp, IO_NO_INCREMENT );

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvCancel: Exit\n" ));

   return( STATUS_CANCELLED );
}

NTSTATUS
DrvCleanup(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )

/*++

Routine Description:
    This function is called, when the 'calling app' terminates (unexpectedly).
    We have to clean up all pending irps. In our case it can only be the
    notification irp.

--*/
{
   NTSTATUS          NTStatus = STATUS_SUCCESS;
   PDEVICE_EXTENSION    DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;
    KIRQL                   CancelIrql;

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvCleanup: Enter\n" ));

   DeviceExtension      = DeviceObject->DeviceExtension;
   SmartcardExtension   = &DeviceExtension->SmartcardExtension;

   IoAcquireCancelSpinLock(&CancelIrql);

   ASSERT( Irp != SmartcardExtension->OsData->NotificationIrp );

   // cancel pending notification irps
   if( SmartcardExtension->OsData->NotificationIrp )
   {
        // reset the cancel function so that it won't be called anymore
        IoSetCancelRoutine(
            SmartcardExtension->OsData->NotificationIrp,
            NULL
            );
        SmartcardExtension->OsData->NotificationIrp->CancelIrql =
            CancelIrql;

        // DrvCancel will release the cancel spin lock
      DrvCancel(
            DeviceObject,
            SmartcardExtension->OsData->NotificationIrp
            );

   } else {

        IoReleaseCancelSpinLock(CancelIrql);
    }

   SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!Completing Irp %lx\n", Irp ));

    // complete the irp that was passed to this function
   Irp->IoStatus.Information  = 0;
   Irp->IoStatus.Status    = STATUS_SUCCESS;
   IoCompleteRequest( Irp, IO_NO_INCREMENT );

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvCleanup: Exit\n" ));

   return( STATUS_SUCCESS );
}

VOID
DrvWaitForDeviceRemoval(
   IN PDEVICE_OBJECT DeviceObject,
   IN PVOID Context
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS       NTStatus;
   PDEVICE_EXTENSION DeviceExtension;
   PREADER_EXTENSION ReaderExtension;
   PIRP           Irp;
   PIO_STACK_LOCATION   IrpStack;
   IO_STATUS_BLOCK      IoStatusBlock;

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvWaitForDeviceRemoval: Enter\n" ));

   DeviceExtension = DeviceObject->DeviceExtension;
   ReaderExtension = DeviceExtension->SmartcardExtension.ReaderExtension;

   ASSERT( DeviceExtension != NULL );
   ASSERT( ReaderExtension != NULL );

   // mark the device as invalid, so no application can re-open it
   IoSetDeviceInterfaceState( &DeviceExtension->PnPDeviceName, FALSE );

   // close the connection to the serial driver
   Irp = IoAllocateIrp( (CCHAR)( DeviceObject->StackSize + 1 ), FALSE );

   ASSERT( Irp != NULL );

   if( Irp != NULL )
   {
      SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!DrvWaitForDeviceRemoval: Sending IRP_MJ_CLOSE\n" ));

      IoSetNextIrpStackLocation( Irp );
      //
      // send MJ_CLOSE to the serial driver. a side effect of this call is that the serial
      // enumerator will be informed about changes at the COM port, so it will trigger the
      // appropriate pnp calls
      //
      Irp->UserIosb        = &IoStatusBlock;
      IrpStack          = IoGetCurrentIrpStackLocation( Irp );
      IrpStack->MajorFunction = IRP_MJ_CLOSE;

      NTStatus = DrvCallSerialDriver( ReaderExtension->SerialDeviceObject, Irp );

      IoFreeIrp( Irp );
   }

   // inform waiting threads that the close to the serial driver has finished
   KeSetEvent( &ReaderExtension->SerialCloseDone, 0, FALSE );

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvWaitForDeviceRemoval: Exit\n" ));

   return;
}

NTSTATUS
DrvIoCompletion (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp,
   IN PKEVENT        Event
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   UNREFERENCED_PARAMETER( DeviceObject );

   if( Irp->Cancel )
   {

      Irp->IoStatus.Status = STATUS_CANCELLED;
   }
   else
   {
      Irp->IoStatus.Status = STATUS_MORE_PROCESSING_REQUIRED;
   }

   KeSetEvent( Event, 0, FALSE );

   return( STATUS_MORE_PROCESSING_REQUIRED );
}

NTSTATUS
DrvCallSerialDriver(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   KEVENT      Event;

   // copy the stack location of the actual call to the next position
   IoCopyCurrentIrpStackLocationToNext( Irp );

   // this event will be passed to the completion routine & signaled if the call
   // is finished
   KeInitializeEvent( &Event, NotificationEvent, FALSE );

   // the DrvIoCompletion signals the event & keeps the irp alive by setting the
   // status to STATUS_MORE_PROCESSING_REQUIRED
   IoSetCompletionRoutine (
      Irp,
      DrvIoCompletion,
      &Event,
      TRUE,
      TRUE,
      TRUE
      );

   // call the appropriate driver
   if( IoGetCurrentIrpStackLocation( Irp )->MajorFunction == IRP_MJ_POWER )
   {
      NTStatus = PoCallDriver( DeviceObject, Irp );
   }
   else
   {
      NTStatus = IoCallDriver( DeviceObject, Irp );
   }

   // wait until the irp was processed
   if( NTStatus == STATUS_PENDING )
   {
      NTStatus = KeWaitForSingleObject(
            &Event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

      NTStatus = Irp->IoStatus.Status;
   }
   return( NTStatus );
}

//__________________________________ P L U G ' N ' P L A Y ________________________________________

NTSTATUS
DrvPnPHandler(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS          NTStatus = STATUS_SUCCESS;
   PDEVICE_EXTENSION    DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;
   PREADER_EXTENSION    ReaderExtension;

   PAGED_CODE();

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvPnPDeviceControl: Enter\n" ));

   DeviceExtension      = DeviceObject->DeviceExtension;
   SmartcardExtension   = &DeviceExtension->SmartcardExtension;
   ReaderExtension      = SmartcardExtension->ReaderExtension;

   NTStatus = SmartcardAcquireRemoveLockWithTag(SmartcardExtension, ' PnP');

   if( NTStatus != STATUS_SUCCESS )
   {
      Irp->IoStatus.Information  = 0;
      Irp->IoStatus.Status    = NTStatus;
      IoCompleteRequest( Irp, IO_NO_INCREMENT );
   }
   else
   {
      PDEVICE_OBJECT AttachedDeviceObject;
      BOOLEAN        DeviceRemoved,
                  IrpSkipped;

      AttachedDeviceObject = ReaderExtension->SerialDeviceObject;

      DeviceRemoved  = FALSE,
      IrpSkipped     = FALSE;


      // dispatch on pnp minor function
      switch(  IoGetCurrentIrpStackLocation( Irp )->MinorFunction )
      {
         case IRP_MN_START_DEVICE:

            SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!IRP_MN_START_DEVICE\n" ));

            // call the serial driver first to make sure the interface is ready
            NTStatus = DrvCallSerialDriver(AttachedDeviceObject, Irp );

            if( NT_SUCCESS(NTStatus))
            {
               NTStatus = DrvStartDevice(DeviceObject);
            }
            break;

         case IRP_MN_QUERY_STOP_DEVICE:
         {
            KIRQL CurrentIrql;

            SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!IRP_MN_QUERY_STOP_DEVICE\n" ));

            KeAcquireSpinLock(&DeviceExtension->SpinLock, &CurrentIrql );

            if( DeviceExtension->IoCount > 0 )
            {
               // don't stop if any io requests are pending
               KeReleaseSpinLock(&DeviceExtension->SpinLock, CurrentIrql );
               NTStatus = STATUS_DEVICE_BUSY;

            }
            else
            {
               // don't allow further io requests
               KeClearEvent( &DeviceExtension->ReaderStarted );
               KeReleaseSpinLock( &DeviceExtension->SpinLock, CurrentIrql );
               NTStatus = DrvCallSerialDriver( AttachedDeviceObject, Irp );
            }
            break;
         }

         case IRP_MN_CANCEL_STOP_DEVICE:

            SmartcardDebug( DEBUG_DRIVER,  ( "SCMSTCS!IRP_MN_CANCEL_STOP_DEVICE\n" ));

            NTStatus = DrvCallSerialDriver( AttachedDeviceObject, Irp );

            if( NTStatus == STATUS_SUCCESS )
            {
               // driver is ready to process io requests
               KeSetEvent( &DeviceExtension->ReaderStarted, 0, FALSE );
            }
            break;

         case IRP_MN_STOP_DEVICE:

            SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!IRP_MN_STOP_DEVICE\n" ));

            DrvStopDevice( DeviceExtension );

            NTStatus = DrvCallSerialDriver(AttachedDeviceObject, Irp );
            break;

         case IRP_MN_QUERY_REMOVE_DEVICE:

            SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!IRP_MN_QUERY_REMOVE_DEVICE\n" ));

            // disable the reader (and ignore possibles errors)
            IoSetDeviceInterfaceState(
               &DeviceExtension->PnPDeviceName,
               FALSE
               );

               // check if the reader is in use
               if(DeviceExtension->ReaderOpen)
               {
                  //
                  // someone is connected, fail the call
                  // we will enable the device interface in
                  // IRP_MN_CANCEL_REMOVE_DEVICE again
                  //
                  NTStatus = STATUS_UNSUCCESSFUL;
               }
               else
               {
                  // ready to remove the device
                  NTStatus = DrvCallSerialDriver(AttachedDeviceObject, Irp );
               }
            break;

         case IRP_MN_CANCEL_REMOVE_DEVICE:

            SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!IRP_MN_CANCEL_REMOVE_DEVICE\n" ));

            NTStatus = DrvCallSerialDriver( AttachedDeviceObject, Irp );

            //
            // reenable the interface only in case that the reader is
            // still connected. This covers the following case:
            // hibernate machine, disconnect reader, wake up, stop device
            // (from task bar) and stop fails since an app. holds the device open
            //
            if(( NTStatus == STATUS_SUCCESS )&&
               (KeReadStateEvent(&(ReaderExtension->SerialCloseDone))!= TRUE))
            {
               // enable the reader
               SmartcardDebug( DEBUG_DRIVER, ( "IoSetDeviceInterfaceState( &DeviceExtension->PnPDeviceName, TRUE )\n" ));

               NTStatus = IoSetDeviceInterfaceState( &DeviceExtension->PnPDeviceName, TRUE );
            }
            break;

         case IRP_MN_REMOVE_DEVICE:

            SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!IRP_MN_REMOVE_DEVICE\n" ));

            DrvRemoveDevice( DeviceObject );
            NTStatus    = DrvCallSerialDriver( AttachedDeviceObject, Irp );
            DeviceRemoved  = TRUE;
            break;

         default:

            // the irp is not handled by the driver, so pass it to theserial driver
            SmartcardDebug(
               DEBUG_DRIVER,
               ( "SCMSTCS!IRP_MN_%lx\n",  IoGetCurrentIrpStackLocation( Irp )->MinorFunction )
               );

            IoSkipCurrentIrpStackLocation( Irp );
            NTStatus = IoCallDriver( AttachedDeviceObject, Irp );
            IrpSkipped  = TRUE;
            break;
      }

      if( IrpSkipped == FALSE)
      {
         Irp->IoStatus.Status = NTStatus;
         IoCompleteRequest( Irp, IO_NO_INCREMENT );
      }

      if( DeviceRemoved == FALSE)
      {
           SmartcardReleaseRemoveLockWithTag(SmartcardExtension, ' PnP');
      }
   }

   SmartcardDebug( DEBUG_TRACE, ( "SCMSTCS!DrvPnPDeviceControl: Exit %X\n", NTStatus ));
   return( NTStatus );
}

//__________________________________________ P O W E R ____________________________________________


VOID
DrvSystemPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:
    This function is called when the underlying stacks
    completed the power transition.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (MinorFunction);
    UNREFERENCED_PARAMETER (PowerState);
    UNREFERENCED_PARAMETER (IoStatus);

    KeSetEvent(Event, 0, FALSE);
}

NTSTATUS
DrvDevicePowerCompletion(
   IN PDEVICE_OBJECT    DeviceObject,
   IN PIRP              Irp,
   IN PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS NTStatus;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    BOOLEAN CardPresent;

    if(Irp->PendingReturned) {
       IoMarkIrpPending(Irp);
    }

   // re-initialize the the reader & get the current card state
   NTStatus = STCConfigureSTC(
      SmartcardExtension->ReaderExtension,
      ( PSTC_REGISTER ) STCInitialize
      );

    // Save the state of the card BEFORE stand by / hibernation
    CardPresent =
        SmartcardExtension->ReaderCapabilities.CurrentState >= SCARD_ABSENT;

    // get the current state of the card
    CBUpdateCardState(SmartcardExtension, SCARD_UNKNOWN);

    if (CardPresent ||
        SmartcardExtension->ReaderCapabilities.CurrentState >= SCARD_ABSENT) {

        //
        // If a card was present before power down or now there is
        // a card in the reader, we complete any pending card monitor
        // request, since we do not really know what card is now in the
        // reader.
        //
        SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_ABSENT;
        CBUpdateCardState(SmartcardExtension, SCARD_UNKNOWN);
    }

   // save the current Power state of the reader
   SmartcardExtension->ReaderExtension->ReaderPowerState = PowerReaderWorking;

    SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'rwoP');

   // inform the Power manager of our state.
   PoSetPowerState (
      DeviceObject,
      DevicePowerState,
      IoGetCurrentIrpStackLocation( Irp )->Parameters.Power.State
      );

   PoStartNextPowerIrp( Irp );

    // signal that we can process ioctls again
    KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);

   return( STATUS_SUCCESS );
}

typedef enum _ACTION
{
   Undefined = 0,
   SkipRequest,
   WaitForCompletion,
   CompleteRequest,
   MarkPending

} ACTION;


NTSTATUS
DrvPowerHandler(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS          NTStatus = STATUS_SUCCESS;
   PIO_STACK_LOCATION      IrpStack;
   PDEVICE_EXTENSION    DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;
   PDEVICE_OBJECT       AttachedDeviceObject;
   POWER_STATE           PowerState;
   ACTION               Action;
   KEVENT               event;

   PAGED_CODE();

   SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!DrvPowerHandler: Enter\n" ));

   IrpStack       = IoGetCurrentIrpStackLocation( Irp );
   DeviceExtension      = DeviceObject->DeviceExtension;
   SmartcardExtension   = &DeviceExtension->SmartcardExtension;
   AttachedDeviceObject = SmartcardExtension->ReaderExtension->SerialDeviceObject;

    NTStatus = SmartcardAcquireRemoveLockWithTag(SmartcardExtension, 'rwoP');

   if( !NT_SUCCESS( NTStatus ))
   {
      PoStartNextPowerIrp( Irp );
      Irp->IoStatus.Status = NTStatus;
      IoCompleteRequest( Irp, IO_NO_INCREMENT );
   }
   else
   {

      switch (IrpStack->Parameters.Power.Type) {
      case DevicePowerState:

         if (IrpStack->MinorFunction == IRP_MN_SET_POWER ) {
            switch ( IrpStack->Parameters.Power.State.DeviceState ) {
            case PowerDeviceD0:

               // turn the reader on
               SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!DrvPowerHandler: PowerDevice D0\n" ));
               //
               // send the request to the serial driver to power up the port.
               // the reader will be powered from our completion routine
               //
               IoCopyCurrentIrpStackLocationToNext( Irp );
               IoSetCompletionRoutine (
                                      Irp,
                                      DrvDevicePowerCompletion,
                                      SmartcardExtension,
                                      TRUE,
                                      TRUE,
                                      TRUE
                                      );

               Action = WaitForCompletion;
               break;

            case PowerDeviceD3:

               // turn the reader off
               SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!DrvPowerHandler: PowerDevice D3\n" ));

               PoSetPowerState (
                               DeviceObject,
                               DevicePowerState,
                               IrpStack->Parameters.Power.State
                               );

               //
               // check if we're still connected to the reader
               // someone might have pulled the plug without re-scanning for hw/changes
               //
               if (KeReadStateEvent( &SmartcardExtension->ReaderExtension->SerialCloseDone ) == 0l) {

                  //   power down the card
                  if ( SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT ) {
                     SmartcardExtension->MinorIoControlCode = SCARD_POWER_DOWN;
                     NTStatus = CBCardPower( SmartcardExtension );
                     //
                     // This will trigger the card monitor, since we do not really
                     // know if the user will remove / re-insert a card while the
                     // system is asleep
                     //
                  }

                  //   power down the reader
                  STCConfigureSTC(
                                 SmartcardExtension->ReaderExtension,
                                 ( PSTC_REGISTER ) STCClose
                                 );
               }

               // wait until the last read is finished to make sure we go to power
               // down with a pending tracking irp
               SysDelay( 2 * SR_READ_TOTAL_TIMEOUT_CONSTANT );

               // save the current Power state of the reader
               SmartcardExtension->ReaderExtension->ReaderPowerState = PowerReaderOff;

               Action = SkipRequest;
               break;

            default:
               Action = SkipRequest;
               break;
            }
         } else {
            Action = SkipRequest;
            break;
         }
         break;

      case SystemPowerState: {
            //
            // The system wants to change the power state.
            // We need to translate the system power state to
            // a corresponding device power state.
            //
            POWER_STATE_TYPE  PowerType = DevicePowerState;

            ASSERT(SmartcardExtension->ReaderExtension->ReaderPowerState !=
                   PowerReaderUnspecified);

            switch ( IrpStack->MinorFunction ) {

            KIRQL irql;

            case IRP_MN_QUERY_POWER:

               SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!DrvPowerHandler: Query Power\n" ));

               switch (IrpStack->Parameters.Power.State.SystemState) {

               case PowerSystemMaximum:
               case PowerSystemWorking:
               case PowerSystemSleeping1:
               case PowerSystemSleeping2:
                  Action = SkipRequest;
                  break;

               case PowerSystemSleeping3:
               case PowerSystemHibernate:
               case PowerSystemShutdown:
                  KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);
                  if (DeviceExtension->IoCount == 0) {

                     // Block any further ioctls
                     KeClearEvent(&DeviceExtension->ReaderStarted);
                     Action = SkipRequest;

                  } else {

                     // can't go to sleep mode since the reader is busy.
                     NTStatus = STATUS_DEVICE_BUSY;
                     Action = CompleteRequest;
                  }
                  KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);
                  break;
               }
               break;

            case IRP_MN_SET_POWER:

               SmartcardDebug(
                             DEBUG_DRIVER,
                             ( "SCMSTCS!DrvPowerHandler: PowerSystem S%d\n", IrpStack->Parameters.Power.State.SystemState - 1 )
                             );

               switch (IrpStack->Parameters.Power.State.SystemState) {
               case PowerSystemMaximum:
               case PowerSystemWorking:
               case PowerSystemSleeping1:
               case PowerSystemSleeping2:

                  if ( SmartcardExtension->ReaderExtension->ReaderPowerState ==
                       PowerReaderWorking) {
                     // We're already in the right state
                     KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);
                     Action = SkipRequest;
                     break;
                  }

                  PowerState.DeviceState = PowerDeviceD0;

                  // wake up the underlying stack...
                  Action = MarkPending;
                  break;

               case PowerSystemSleeping3:
               case PowerSystemHibernate:
               case PowerSystemShutdown:

                  if ( SmartcardExtension->ReaderExtension->ReaderPowerState == PowerReaderOff ) {
                     // We're already in the right state
                     Action = SkipRequest;
                     break;
                  }

                  PowerState.DeviceState = PowerDeviceD3;

                  // first, inform the Power manager of our new state.
                  PoSetPowerState (
                                  DeviceObject,
                                  SystemPowerState,
                                  PowerState
                                  );
                  Action = MarkPending;
                  break;

               default:
                  Action = CompleteRequest;
                  break;
               }
               break;

            default:
               Action = SkipRequest;
               break;
            }
         }
         break;

      default:
         Action = CompleteRequest;
         break;
      }


      switch( Action )
      {
         case CompleteRequest:
            Irp->IoStatus.Status    = NTStatus;
            Irp->IoStatus.Information  = 0;

            SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'rwoP');

            PoStartNextPowerIrp( Irp );

            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            break;

         case MarkPending:

            // initialize the event we need in the completion function
            KeInitializeEvent(
               &event,
               NotificationEvent,
               FALSE
               );

            // request the device power irp
            NTStatus = PoRequestPowerIrp (
               DeviceObject,
               IRP_MN_SET_POWER,
               PowerState,
               DrvSystemPowerCompletion,
               &event,
               NULL
               );

            if (NTStatus == STATUS_PENDING) {

               // wait until the device power irp completed
               NTStatus = KeWaitForSingleObject(
                  &event,
                  Executive,
                  KernelMode,
                  FALSE,
                  NULL
                  );

               SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'rwoP');

               if (PowerState.SystemState == PowerSystemWorking) {

                  PoSetPowerState (
                     DeviceObject,
                     SystemPowerState,
                     PowerState
                     );
               }

               PoStartNextPowerIrp(Irp);
               IoSkipCurrentIrpStackLocation(Irp);
               NTStatus = PoCallDriver(AttachedDeviceObject, Irp);

            } else {

               SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'rwoP');
               Irp->IoStatus.Status = NTStatus;
               IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }

            break;

         case SkipRequest:
            SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'rwoP');

            PoStartNextPowerIrp( Irp );
            IoSkipCurrentIrpStackLocation( Irp );
            NTStatus = PoCallDriver( AttachedDeviceObject, Irp );
            break;

         case WaitForCompletion:
            NTStatus = PoCallDriver( AttachedDeviceObject, Irp );
            break;

         default:
            break;
      }
   }
   SmartcardDebug( DEBUG_DRIVER, ( "SCMSTCS!DrvPowerHandler: Exit %X\n", NTStatus ));

   return( NTStatus );
}



void
SysDelay(
   ULONG Timeout
   )
/*++

SysDelay:
   performs a required delay

Arguments:
   Timeout     delay in milliseconds

--*/
{

   if( KeGetCurrentIrql() >= DISPATCH_LEVEL )
   {
      ULONG Cnt = 20 * Timeout;
      while( Cnt-- )
      {
         // KeStallExecutionProcessor: counted in us
         KeStallExecutionProcessor( 50 );
      }
   }
   else
   {
      LARGE_INTEGER SysTimeout;

      SysTimeout.QuadPart =
         (LONGLONG) Timeout * -10 * 1000;

      // KeDelayExecutionThread: counted in 100 ns
      KeDelayExecutionThread( KernelMode, FALSE, &SysTimeout );
   }
   return;
}

//_________________________________________ END OF FILE _________________________________________
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\scmstcs\serialif.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       serialif.h
//
//--------------------------------------------------------------------------

#if !defined( __SERIAL_IF_H__ )
#define __SERIAL_IF_H__

#if defined( SMCLIB_VXD )
#include "Driver98.h"
#else
#include "DriverNT.h"
#endif

typedef void ( *PTRACKING_COMPLETION )( PVOID TrackingContext, USHORT SW );

NTSTATUS
IFRead(
	PREADER_EXTENSION		ReaderExtension,
	PUCHAR					InData,
	ULONG					InDataLen
	);

NTSTATUS
IFWrite(
	PREADER_EXTENSION		ReaderExtension,
	PUCHAR					OutData,
	ULONG					OutDataLen
	);

NTSTATUS
IFInitializeInterface(
	PREADER_EXTENSION		ReaderExtension,
	PVOID					ConfigData
	);

UCHAR
IFCalcLRC(
	PUCHAR	IOData,
	ULONG	IODataLen
	);

#endif	//	!__SERIAL_IF_H__


//---------------------------------------- END OF FILE ----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\scmstcs\srvers.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       srvers.h
//
//--------------------------------------------------------------------------

/*++

Copyright (c) 1998 SCM Microsystems, Inc.

Module Name:

    SRVers.h

Abstract:

	header file for version information

Author:

	Andreas Straub

Environment:

	Win 95, Win NT

Revision History:

	AS	1.00		2/06/1998	Initial Version

--*/
#if !defined( __SRVERS_H__ )
#define __SRVERS_H__

#define SCMSTCS_VERSION_STR		"1.06"
#define SCMSTCS_MAJOR_VERSION	1
#define SCMSTCS_MINOR_VERSION	6

#endif	//	__SRVERS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\scmstcs\stc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       stc.h
//
//--------------------------------------------------------------------------

#if !defined( __STC_H__ )

#define __STC_H__

#define	NAD_IDX				0x00
#define PCB_IDX				0x01
#define LEN_IDX				0x02
#define DATA_IDX			0x03
#define PROLOGUE_LEN		0x03
#define EPILOGUE_LEN		0x01
#define PACKET_OVERHEAD		4

#define OSC					16000
#define FREQ				3580
#define CYC_TO_MS( cyc )	((ULONG)( cyc / FREQ ))

#define SW_SUCCESS			0x0090
#define SW_OE				0x0020
#define SW_FE				0x0040
#define SW_INSERTED			0xA064
#define SW_REMOVED			0xA164

//	register addresses
#define ADR_ETULENGTH15			0x00
#define ADR_ETULENGTH7			0x01
#define ADR_CGT8				0x02
#define ADR_CGT7				0x03
#define ADR_CWT31				0x04
#define ADR_CWT23				0x05
#define ADR_CWT15				0x06
#define ADR_CWT7				0x07
#define	ADR_BGT8				0x08
#define ADR_BGT7				0x09
#define ADR_BWT31				0x0A
#define ADR_BWT23				0x0B
#define ADR_BWT15				0x0C
#define ADR_BWT7				0x0D
#define ADR_TCON				0x0E
#define ADR_UART_CONTROL		0x0F
#define ADR_FIFO_CONFIG			0x10
#define ADR_INT_CONTROL			0x11
#define ADR_INT_STATUS			0x12
#define ADR_DATA				0x13
#define ADR_IO_CONFIG			0x14
#define ADR_SC_CONTROL			0x15
#define ADR_CLOCK_CONTROL		0x16
		

//	clock control register
#define M_CKE				0x01
#define M_OEN				0x02

//	ETU length register
#define M_ETU_RST			0x80
#define M_DIV				0x30
#define M_DIV1				0x20
#define M_DIV0				0x10
#define M_ETUH				0x0F

#define M_ETUL				0xFF

//	CGT length register 
#define M_CGTH				0x01
#define M_CGTL				0XFF

//	BGT length register
#define M_BGTH				0x01
#define M_BGTL				0xFF

//	CWT register
#define M_CWT4				0xFF
#define M_CWT3				0xFF
#define M_CWT2				0xFF
#define M_CWT1				0xFF

//	TCON register
#define M_MGT				0x80
#define M_MWT				0x40
#define M_WTR				0x04
#define M_GT				0x02
#define M_WT				0x01

//	UART control register
#define M_UEN				0x40
#define M_UART_RST			0x20
#define M_CONV				0x10
#define	M_TS				0x08
#define	M_PE				0x04
#define	M_R					0x03

//	FIFO config register
#define M_RFP				0x80
#define M_LD				0x0F

//	INT control register
#define	M_SSL				0x20
#define M_DRM				0x10
#define M_DSM				0x08
#define M_WTE				0x04
#define M_SIM				0x02
#define M_MEM				0x01
#define M_DRM_MEM			0x11

//	INT status register
#define M_FNE				0x80
#define M_FE				0x40
#define M_OE				0x20
#define M_DR				0x10
#define M_TRE				0x08
#define M_WTOVF				0x04
#define M_SENSE				0x02
#define M_MOV				0x01

//	SMART card interface
#define M_ALT1				0x20
#define M_ALT2				0x10
#define M_ALT0				0x08
#define M_SDE				0x04
#define M_SL				0x02
#define M_SD				0x01

//	SMART card control register
#define M_IO				0x80
#define M_VCE				0x40
#define M_SC_RST			0x20
#define M_SCE				0x10
#define M_SCK				0x08
#define M_C8				0x04
#define M_C4				0x02
#define M_VPE				0x01


//	Nad
#define HOST_TO_STC1				0x12	  
#define HOST_TO_STC2				0x52	  
#define HOST_TO_ICC1				0x02
#define HOST_TO_ICC2				0x42
#define STC1_TO_HOST				0x21
#define STC2_TO_HOST				0x25
#define ICC1_TO_HOST				0x20
#define ICC2_TO_HOST				0x24

//	PCB
#define PCB							0x00	 


#define CLA_READ_REGISTER			0x00
#define INS_READ_REGISTER			0xB0

#define CLA_WRITE_REGISTER			0x00
#define INS_WRITE_REGISTER			0xD0

#define CLA_READ_FIRMWARE_REVISION	0x00
#define INS_READ_FIRMWARE_REVISION	0xB1

#define PCB_DEFAULT					0x00
#define TLV_BUFFER_SIZE				0x20
#define ATR_SIZE					0x40	//	TS + 32 + SW + PROLOGUE + EPILOGUE...

#define MAX_T1_BLOCK_SIZE			270

//	ATR interface byte coding in TS
#define TAx							0x01
#define TBx							0x02
#define TCx							0x04
#define TDx							0x08


#define FREQ_DIV		1	//	3,58 MHz XTAL -> SC Clock = 3.58MHz
//#define FREQ_DIV	0x08	/* 30MHz XTAL -> SC Clock = 3.75MHz */ 

#define PROTOCOL_TO 		0
#define PROTOCOL_T1			1
#define PROTOCOL_T14		14
#define PROTOCOL_T15		15

//
//	DATA TYPES
//
typedef struct _STC_REGISTER
{
	UCHAR	Register;
	UCHAR	Size;
	ULONG	Value;

} STC_REGISTER, *PSTC_REGISTER;

#endif	//	! __STC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\scmstcs\drvnt5.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       drvnt5.h
//
//--------------------------------------------------------------------------

#if !defined( __DRIVER_NT5_H__ )
#define __DRIVER_NT5_H__

#define MAXIMUM_SERIAL_READERS      10

// Prototypes
NTSTATUS
DrvAddDevice(
    PDRIVER_OBJECT          DriverObject,
    PDEVICE_OBJECT          PhysicalDeviceObject
    );


NTSTATUS
DrvCreateDevice(
    PDRIVER_OBJECT          DriverObject,
    PDEVICE_OBJECT          *DeviceObject
    );

NTSTATUS
DrvStartDevice(
    PDEVICE_OBJECT          DeviceObject
    );

VOID
DrvStopDevice(
    PDEVICE_EXTENSION       DeviceExtension
    );

VOID 
DrvCloseSerialDriver(
    PDEVICE_OBJECT          DeviceObject
    );

NTSTATUS
DrvSerialCallComplete(
    PDEVICE_OBJECT          DeviceObject,
    PIRP                    Irp,
    PKEVENT                 Event
    );

NTSTATUS 
DrvCallSerialDriver(
    IN PDEVICE_OBJECT       DeviceObject, 
    IN PIRP                 Irp
    );

NTSTATUS
DrvSystemControl(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
DrvGenericIOCTL(
    PSMARTCARD_EXTENSION    SmartcardExtension
    );

NTSTATUS
DrvPnPHandler(
    PDEVICE_OBJECT          DeviceObject, 
    PIRP                    Irp
    );

NTSTATUS
DrvPowerHandler(
    PDEVICE_OBJECT          DeviceObject,
    PIRP                    Irp
    );

NTSTATUS
DrvCreateClose(
    PDEVICE_OBJECT          DeviceObject,
    PIRP                    Irp
    );

NTSTATUS
DrvCleanup(
    PDEVICE_OBJECT          DeviceObject,
    PIRP                    Irp
    );

VOID
DrvRemoveDevice( 
    PDEVICE_OBJECT          DeviceObject
    );

VOID
DrvDriverUnload(
    PDRIVER_OBJECT          DriverObject
    );

VOID 
DrvWaitForDeviceRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

#endif  //  !__DRIVER_NT5_H__


//---------------------------------------- END OF FILE ----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\scmstcs\serialnt.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       serialnt.c
//
//--------------------------------------------------------------------------

#include "drivernt.h"
#include "stc.h"
#include "cbhndlr.h"
#include "drvnt5.h"

const ULONG ConfigTable[] =
{
    IOCTL_SERIAL_SET_BAUD_RATE,
    IOCTL_SERIAL_SET_LINE_CONTROL,
    IOCTL_SERIAL_SET_CHARS,
    IOCTL_SERIAL_SET_TIMEOUTS,
    IOCTL_SERIAL_SET_HANDFLOW,
#if !defined( __NT4__ )
    IOCTL_SERIAL_PURGE,
#endif
    IOCTL_SERIAL_SET_BREAK_OFF,
    IOCTL_SERIAL_SET_WAIT_MASK,
    0
};

NTSTATUS
IFInitializeInterface(
    PREADER_EXTENSION   ReaderExtension,
    PVOID               ConfigData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS            NTStatus = STATUS_SUCCESS;
    ULONG               OutDataLen;
    PVOID               OutData;
    PULONG              ActIoctl;
    PSERIAL_PORT_CONFIG SerialPortConfig = (PSERIAL_PORT_CONFIG) ConfigData;
    //
    //  set all parameters defined in config table
    //

    ActIoctl = (PULONG) ConfigTable;
    do
    {
        switch( *ActIoctl )
        {
            case IOCTL_SERIAL_SET_BAUD_RATE:
                OutData     = &SerialPortConfig->BaudRate;
                OutDataLen  = sizeof( SERIAL_BAUD_RATE );
                break;

            case IOCTL_SERIAL_SET_LINE_CONTROL:
                OutData     = &SerialPortConfig->LineControl;
                OutDataLen  = sizeof( SERIAL_LINE_CONTROL );
                break;

            case IOCTL_SERIAL_SET_CHARS:
                OutData     = &SerialPortConfig->SerialChars;
                OutDataLen  = sizeof( SERIAL_CHARS );
                break;

            case IOCTL_SERIAL_SET_TIMEOUTS:
                OutData     = &SerialPortConfig->Timeouts;
                OutDataLen  = sizeof( SERIAL_TIMEOUTS );
                break;

            case IOCTL_SERIAL_SET_HANDFLOW:
                OutData     = &SerialPortConfig->HandFlow;
                OutDataLen  = sizeof( SERIAL_HANDFLOW );
                break;

            case IOCTL_SERIAL_SET_WAIT_MASK:
                OutData     = &SerialPortConfig->WaitMask;
                OutDataLen  = sizeof( ULONG );
                break;

            case IOCTL_SERIAL_PURGE:
                OutData     = &SerialPortConfig->Purge;
                OutDataLen  = sizeof( ULONG );
                break;

            case IOCTL_SERIAL_SET_BREAK_OFF:
                OutData     = NULL;
                OutDataLen  = 0;
                break;
        }

        NTStatus = IFSerialIoctl(
            ReaderExtension,
            *ActIoctl,
            OutData,
            OutDataLen,
            NULL,
            0
            );

        SysDelay(25);

    } while( *(++ActIoctl) && ( NTStatus == STATUS_SUCCESS ));

    if( NTStatus == STATUS_SUCCESS )
    {
        //  initialize the read thread
        NTStatus = IFSerialWaitOnMask( ReaderExtension );
    }

    return( NTStatus );
}

NTSTATUS
IFWrite(
    PREADER_EXTENSION   ReaderExtension,
    PUCHAR              OutData,
    ULONG               OutDataLen
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS            NTStatus = STATUS_INSUFFICIENT_RESOURCES;
    IO_STATUS_BLOCK     IoStatus;
    KEVENT              Event;
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpStack;

    if (KeReadStateEvent(&(ReaderExtension->SerialCloseDone))) {

        //
        // we have no connection to serial, fail the call
        // this could be the case if the reader was removed 
        // during stand by / hibernation
        //
        return STATUS_UNSUCCESSFUL;
    }
    ReaderExtension->Available = 0;
    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    //
    //  build irp to be send to serial driver
    //
    Irp = IoBuildDeviceIoControlRequest(
        SERIAL_WRITE,
        ReaderExtension->SerialDeviceObject, 
        OutData,
        OutDataLen,
        NULL,
        0,
        FALSE,
        &Event,
        &IoStatus
        );

    if( Irp != NULL )
    {
        IrpStack = IoGetNextIrpStackLocation( Irp );

        IrpStack->MajorFunction = IRP_MJ_WRITE;
        IrpStack->Parameters.Write.Length = OutDataLen;
        IrpStack->Parameters.Write.ByteOffset.QuadPart = 0;

        NTStatus = IoCallDriver( ReaderExtension->SerialDeviceObject, Irp );

        if( NTStatus == STATUS_PENDING )
        {
            KeWaitForSingleObject( 
                &Event, 
                Executive, 
                KernelMode, 
                FALSE, 
                NULL
                );
            NTStatus = IoStatus.Status;
        }
    }
    return( NTStatus );
}

NTSTATUS
IFRead(
    PREADER_EXTENSION   ReaderExtension,
    PUCHAR              InData,
    ULONG               InDataLen
    )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    NTSTATUS NTStatus = STATUS_UNSUCCESSFUL;
    KIRQL CurrentIrql;                                    

    //  acquire spinlock to protect buffer/flag manipulation
    KeAcquireSpinLock( &ReaderExtension->ReadSpinLock, &CurrentIrql );

    //  check if data already available
    if( ReaderExtension->Available >= InDataLen )
    {
        
        NTStatus = STATUS_SUCCESS;

    }
    else
    {
        LARGE_INTEGER Timeout;

        //  setup read thread
        ReaderExtension->Expected = InDataLen;
        KeClearEvent( &ReaderExtension->DataAvailable );

        KeReleaseSpinLock( &ReaderExtension->ReadSpinLock, CurrentIrql );

        // setup wait time (in 100 ns)
        Timeout.QuadPart = 
            (LONGLONG) ReaderExtension->ReadTimeout * -10L * 1000;

        NTStatus = KeWaitForSingleObject(
            &ReaderExtension->DataAvailable,
            Executive,          
            KernelMode,
            FALSE,
            &Timeout
            );

        KeAcquireSpinLock(&ReaderExtension->ReadSpinLock, &CurrentIrql);

        //  reset the read queue
        KeClearEvent(&ReaderExtension->DataAvailable);
    }

    if( NTStatus == STATUS_SUCCESS )
    {

        if (ReaderExtension->Available >= InDataLen) {

            SysCopyMemory( 
                InData,
                &ReaderExtension->TPDUStack[0],
                InDataLen
                );

            ReaderExtension->Available -= InDataLen;

            SysCopyMemory(
                &ReaderExtension->TPDUStack[ 0 ],
                &ReaderExtension->TPDUStack[ InDataLen ],
                ReaderExtension->Available
                );

        } else {

            //
            // oops, that should not happen.
            // InDataLen should not be bigger than 
            // the number of bytes available
            //

            ASSERT(FALSE);
            NTStatus = STATUS_IO_TIMEOUT;
        }
    }
    else
    {
        // ReaderExtension->Available = 0;;
        NTStatus = STATUS_IO_TIMEOUT;
    }

    if( NTStatus != STATUS_SUCCESS )
    {

        NTStatus = STATUS_IO_TIMEOUT;
    }

    ReaderExtension->Expected = 0;

    KeReleaseSpinLock( &ReaderExtension->ReadSpinLock, CurrentIrql );

    return( NTStatus );
}

NTSTATUS
IFSerialIoctl(
    PREADER_EXTENSION   ReaderExtension,
    ULONG               IoctlCode,
    PVOID               OutData,
    ULONG               OutDataLen,
    PVOID               InData,
    ULONG               InDataLen
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS            NTStatus = STATUS_INSUFFICIENT_RESOURCES;
    IO_STATUS_BLOCK     IoStatus;
    KEVENT              Event;
    PIRP                Irp;



    if (KeReadStateEvent(&(ReaderExtension->SerialCloseDone))) {

        //
        // we have no connection to serial, fail the call
        // this could be the case if the reader was removed 
        // during stand by / hibernation
        //
        return STATUS_UNSUCCESSFUL;
    }

    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    //
    //  build irp to be send to serial driver
    //
    Irp = IoBuildDeviceIoControlRequest(
        IoctlCode,
        ReaderExtension->SerialDeviceObject, 
        OutData,
        OutDataLen,
        InData,
        InDataLen,
        FALSE,
        &Event,
        &IoStatus
        );

    if( Irp != NULL )
    {
        NTStatus = IoCallDriver( ReaderExtension->SerialDeviceObject, Irp );

        if( NTStatus == STATUS_PENDING )
        {
            LARGE_INTEGER Timeout;

            Timeout.QuadPart = 
                (LONGLONG) ReaderExtension->ReadTimeout * -10 * 1000;

            KeWaitForSingleObject( 
                &Event, 
                Executive, 
                KernelMode, 
                FALSE, 
                &Timeout
                );

            NTStatus = IoStatus.Status;
        }
    }

    return( NTStatus );
}



NTSTATUS
IFSerialRead(
    PREADER_EXTENSION   ReaderExtension,
    PUCHAR              InData,
    ULONG               InDataLen
    )
{
    NTSTATUS            NTStatus = STATUS_INSUFFICIENT_RESOURCES;
    IO_STATUS_BLOCK     IoStatus;
    KEVENT              Event;
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpStack;

    if (KeReadStateEvent(&(ReaderExtension->SerialCloseDone))) {

        //
        // we have no connection to serial, fail the call
        // this could be the case if the reader was removed 
        // during stand by / hibernation
        //
        return STATUS_UNSUCCESSFUL;
    }
    //  build irp to be send to serial driver
    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    Irp = IoBuildDeviceIoControlRequest(
        SERIAL_READ,
        ReaderExtension->SerialDeviceObject, 
        NULL,
        0,
        InData,
        InDataLen,
        FALSE,
        &Event,
        &IoStatus
        );

    if( Irp != NULL )
    {
        IrpStack = IoGetNextIrpStackLocation( Irp );

        IrpStack->MajorFunction = IRP_MJ_READ;
        IrpStack->Parameters.Read.Length = InDataLen;

        NTStatus = IoCallDriver( ReaderExtension->SerialDeviceObject, Irp );

        if( NTStatus == STATUS_PENDING )
        {
            KeWaitForSingleObject( 
                &Event, 
                Executive, 
                KernelMode, 
                FALSE, 
                NULL
                );
            NTStatus = IoStatus.Status;

        }
    }

    return( NTStatus );
}

NTSTATUS 
IFSerialWaitOnMask( PREADER_EXTENSION ReaderExtension )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;
    NTSTATUS NTStatus;


    if (KeReadStateEvent(&(ReaderExtension->SerialCloseDone))) {

        //
        // we have no connection to serial, fail the call
        // this could be the case if the reader was removed 
        // during stand by / hibernation
        //
        return STATUS_UNSUCCESSFUL;
    }

    irp = IoAllocateIrp(
        (CCHAR) (ReaderExtension->SerialDeviceObject->StackSize + 1),
        FALSE
        );

    ASSERT(irp != NULL);

    if (irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;

    irpSp->Parameters.DeviceIoControl.InputBufferLength = 0;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = 
        sizeof(ReaderExtension->EventMask);
    irpSp->Parameters.DeviceIoControl.IoControlCode = 
        IOCTL_SERIAL_WAIT_ON_MASK;
    
    irp->AssociatedIrp.SystemBuffer = &ReaderExtension->EventMask;

    //  set completion routine & start io
    IoSetCompletionRoutine( 
        irp, 
        IFReadThreadCallback, 
        ReaderExtension, 
        TRUE, 
        TRUE, 
        TRUE 
        );

    NTStatus = IoCallDriver( ReaderExtension->SerialDeviceObject, irp );

    return (NTStatus == STATUS_PENDING ? STATUS_SUCCESS : NTStatus);
}

NTSTATUS
IFReadThreadCallback(
    PDEVICE_OBJECT          DeviceObject,
    PIRP                    Irp,
    PREADER_EXTENSION       ReaderExtension
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    //  event_rx?
    if( ReaderExtension->EventMask & SERIAL_EV_RXCHAR )
    {
        IoQueueWorkItem(
            ReaderExtension->ReadWorkItem,
            (PIO_WORKITEM_ROUTINE) IFReadWorkRoutine,
            CriticalWorkQueue,
            ReaderExtension
            );
    }
    else 
    {
        SmartcardDebug( 
            DEBUG_TRACE, 
            ("SCMSTCS!IFReadThreadCallback: Device removed\n" )
            );

        ReaderExtension->SmartcardExtension->ReaderCapabilities.CurrentState = 
            (ULONG) SCARD_UNKNOWN;
        //  last call: disconnect from the serial driver 
        IoQueueWorkItem(
            ReaderExtension->CloseSerial,
            (PIO_WORKITEM_ROUTINE) DrvWaitForDeviceRemoval,
            DelayedWorkQueue,
            NULL
            );
    }

    IoFreeIrp(Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
IFReadWorkRoutine( 
    IN PDEVICE_OBJECT DeviceObject,
    IN PREADER_EXTENSION ReaderExtension 
    )
{
    NTSTATUS            NTStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION  IrpStack;
    PIRP                Irp;
    SERIAL_STATUS       CommStatus;
    PUCHAR              IOData;
    BOOLEAN             purgePort = FALSE;
    BOOLEAN             bUpdatCardState = FALSE;
    USHORT              shrtBuf;
    
    ASSERT( ReaderExtension != NULL );


    if (ReaderExtension == NULL) {

        return;
    }

    __try {

        IOData = &ReaderExtension->IOData[0];

        while (NTStatus == STATUS_SUCCESS) {

            //  read head
            NTStatus = IFSerialRead( 
                ReaderExtension, 
                &IOData[0], 
                3 
                );

            if (NTStatus != STATUS_SUCCESS) {
            
                __leave;
            }

            if ((IOData[NAD_IDX] & 0x20) != 0x20) {

                SmartcardDebug( 
                    DEBUG_ERROR, 
                    ("SCMSTCS!IFReadWorkRoutine: Invalid packet received\n" )
                    );

                purgePort = TRUE;
                __leave;
            }


            if (IOData[LEN_IDX] > STC_BUFFER_SIZE - 4) {

                purgePort = TRUE;
                __leave;
            }

            //  read tail
            NTStatus = IFSerialRead(
                ReaderExtension,
                &IOData[DATA_IDX],
                IOData[LEN_IDX] + 1
                );

            ASSERT(NTStatus == STATUS_SUCCESS);

            if (NTStatus != STATUS_SUCCESS) {

                purgePort = TRUE;
                __leave;
            }

            if (IOData[LEN_IDX] == 0) {

                purgePort = TRUE;
                __leave;
            }

            //  check for card insertion / removal
            RtlRetrieveUshort(&shrtBuf, &IOData[DATA_IDX]);

            if( ( IOData[NAD_IDX] == STC1_TO_HOST ) &&
                ( IOData[LEN_IDX] == 2 ) &&
                ( (shrtBuf == SW_INSERTED) ||
                  (shrtBuf == SW_REMOVED))) {
                   
               CBUpdateCardState(
                  ReaderExtension->SmartcardExtension,
                  (shrtBuf == SW_INSERTED ? SCARD_PRESENT : SCARD_ABSENT)
                  );
                

            } else {

                KIRQL   CurrentIrql;


                //  acquire spinlock to protect buffer/flag manipulation
                KeAcquireSpinLock( 
                    &ReaderExtension->ReadSpinLock, 
                    &CurrentIrql 
                    );

                //  check size & copy data to TPDU stack
                ASSERT(
                    ReaderExtension->Available+IOData[LEN_IDX] + 4 < 
                    TPDU_STACK_SIZE
                    );

                if (ReaderExtension->Available + IOData[LEN_IDX] + 4 < 
                    TPDU_STACK_SIZE ) {

                    SysCopyMemory( 
                        &ReaderExtension->TPDUStack[ReaderExtension->Available],
                        &IOData[ 0 ],
                        IOData[ LEN_IDX ] + 4
                        );

                    ReaderExtension->Available += 
                        IOData[LEN_IDX] + 4;

                    if(ReaderExtension->Available >= ReaderExtension->Expected ) {
                      
                        KeSetEvent( 
                            &ReaderExtension->DataAvailable, 
                            IO_SERIAL_INCREMENT, 
                            FALSE
                            );
                    }
                }

                KeReleaseSpinLock( &ReaderExtension->ReadSpinLock, CurrentIrql );
            }
        } 
    }
    __finally { 


        if (purgePort) {

            ULONG   request;
            KIRQL   CurrentIrql;

            //  acquire spinlock to protect buffer/flag manipulation
            KeAcquireSpinLock( 
                &ReaderExtension->ReadSpinLock, 
                &CurrentIrql 
                );

            ReaderExtension->Available = 0;

            KeReleaseSpinLock( 
                &ReaderExtension->ReadSpinLock, 
                CurrentIrql 
                );

            // we got an error and need to clean up the port
            request = SR_PURGE;
            NTStatus = IFSerialIoctl(
                ReaderExtension,
                IOCTL_SERIAL_PURGE,
                &request,
                sizeof(request),
                NULL,
                0
                );

            ASSERT(NTStatus == STATUS_SUCCESS);
        }

        IFSerialWaitOnMask( ReaderExtension );
    }
}

UCHAR IFCalcLRC( PUCHAR IOData, ULONG IODataLen )
{
    ULONG   Idx = 0;
    UCHAR   CS = 0;

    do  CS ^= IOData[ Idx ];
    while( ++Idx < IODataLen );

    return( CS );
}


//---------------------------------------- END OF FILE ----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\scmstcs\stccmd.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       stccmd.c
//
//--------------------------------------------------------------------------


#if defined( SMCLIB_VXD )
#include "Driver98.h"
#include "Serial98.h"
#else
#include "DriverNT.h"
#include "SerialNT.h"
#endif  //      SMCLIB_VXD

#include "SerialIF.h"
#include "STCCmd.h"
#include "STC.h"

const STC_REGISTER STCInitialize[] = 
{
        { ADR_SC_CONTROL,               0x01,   0x00            },              //      reset
        { ADR_CLOCK_CONTROL,    0x01,   0x01            },
        { ADR_CLOCK_CONTROL,    0x01,   0x03            },
        { ADR_UART_CONTROL,             0x01,   0x27            },
        { ADR_UART_CONTROL,             0x01,   0x4F            },
        { ADR_IO_CONFIG,                0x01,   0x02            },              //      0x10 eva board
        { ADR_FIFO_CONFIG,              0x01,   0x81            },
        { ADR_INT_CONTROL,              0x01,   0x11            },
        { 0x0E,                                 0x01,   0xC0            },
        { 0x00,                                 0x00,   0x00            },
};

const STC_REGISTER STCClose[] = 
{
        { ADR_INT_CONTROL,              0x01,   0x00            },
        { ADR_SC_CONTROL,               0x01,   0x00            },              //      reset
        { ADR_UART_CONTROL,             0x01,   0x40            },
        { ADR_CLOCK_CONTROL,    0x01,   0x01            },
        { ADR_CLOCK_CONTROL,    0x01,   0x00            },
        { 0x00,                                 0x00,   0x00            },
};



NTSTATUS
STCReset( 
        PREADER_EXTENSION       ReaderExtension,
        UCHAR                           Device,
        BOOLEAN                         WarmReset,
        PUCHAR                          pATR,
        PULONG                          pATRLength
        )
/*++
STCReset:
        performs a reset of ICC

Arguments:
        ReaderExtension         context of call
        Device                          device requested ( ICC_1, ICC_2, PSCR )
        WarmReset                       kind of ICC reset
        pATR                            ptr to ATR buffer, NULL if no ATR required
        pATRLength                      size of ATR buffer / length of ATR

Return Value:
        STATUS_SUCCESS
        STATUS_NO_MEDIA
        STATUS_UNRECOGNIZED_MEDIA
        error values from IFRead / IFWrite

--*/
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;

        //      set UART to autolearn mode
        NTStatus = STCInitUART( ReaderExtension, TRUE );        

        if( NTStatus == STATUS_SUCCESS)
        {
                //
                //      set default frequency for ATR
                //
                NTStatus = STCSetFDIV( ReaderExtension, FREQ_DIV );     

                if( NTStatus == STATUS_SUCCESS && ( !WarmReset ))
                {
                        //
                        //      deactivate contacts
                        //
                        NTStatus = STCPowerOff( ReaderExtension );
                }

                if( NTStatus == STATUS_SUCCESS)
                {
                        BOOLEAN Detected;
                        //
                        //      short circuit test
                        //
                        NTStatus = STCShortCircuitTest( ReaderExtension, &Detected );   

                        if( ( NTStatus == STATUS_SUCCESS ) && ( Detected ))
                        {
                                NTStatus = STATUS_DATA_ERROR;
                        }
                        //
                        //      set power to card
                        //
                        if( NTStatus == STATUS_SUCCESS)
                        {
                                NTStatus = STCPowerOn( ReaderExtension );

                                if( NTStatus == STATUS_SUCCESS)
                                {
                                        NTStatus = STCReadATR( ReaderExtension, pATR, pATRLength );
                                }
                        }
                }
        }
        
        if( NTStatus != STATUS_SUCCESS )
        {
                STCPowerOff( ReaderExtension );
        }
        return( NTStatus );
}

NTSTATUS 
STCReadATR(
        PREADER_EXTENSION       ReaderExtension, 
        PUCHAR                          pATR, 
        PULONG                          pATRLen
        )
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           T0_Yx, T0_K, Protocol;
        ULONG           ATRLen, BufferLength;

    ReaderExtension->ReadTimeout = 250;

        //      read TS if active low reset
        BufferLength = *pATRLen;
        NTStatus = STCReadICC1( 
        ReaderExtension, 
        pATR, 
        &BufferLength,
        1
        );

        if( NTStatus == STATUS_IO_TIMEOUT )
        {
                NTStatus = STCSetRST( ReaderExtension, TRUE );

                if( NTStatus == STATUS_SUCCESS )
                {
            BufferLength = *pATRLen;
                        NTStatus = STCReadICC1( 
                ReaderExtension, 
                pATR, 
                &BufferLength,
                1
                );
                }
        }

    ReaderExtension->ReadTimeout = 1200;
        Protocol = PROTOCOL_TO;
        ATRLen = 1;

        if( NTStatus == STATUS_SUCCESS )
        {
        BufferLength = *pATRLen - ATRLen;
                NTStatus = STCReadICC1( 
            ReaderExtension, 
            pATR + ATRLen, 
            &BufferLength,
            1
            );
                ATRLen++;
        
                if ( pATR[0] == 0x03 )          /* Direct convention */
                {
                        pATR[0] = 0x3F;
                }

                if ( ( pATR[0] != 0x3F ) && ( pATR[0] != 0x3B ) )
                {
                        NTStatus = STATUS_DATA_ERROR;
                }
                        
                if( NTStatus == STATUS_SUCCESS )
                {
                        ULONG   Request;

                        //      number of historical bytes
                        T0_K = (UCHAR) ( pATR[ATRLen-1] & 0x0F );

                        //      coding of TA, TB, TC, TD
                        T0_Yx = (UCHAR) ( pATR[ATRLen-1] & 0xF0 ) >> 4; 

                        while(( NTStatus == STATUS_SUCCESS ) && T0_Yx ) 
                        {       
                                UCHAR Mask;

                                //      evaluate presence of TA, TB, TC, TD 
                                Mask    = T0_Yx;
                                Request = 0;
                                while( Mask )
                                {
                                        if( Mask & 1 )
                                        {
                                                Request++;
                                        }
                                        Mask >>= 1;
                                }

                BufferLength = *pATRLen - ATRLen;
                                NTStatus = STCReadICC1( 
                    ReaderExtension, 
                    pATR + ATRLen, 
                    &BufferLength,
                    Request
                    );
                                ATRLen += Request;

                                if( T0_Yx & TDx )
                                {
                                        //      high nibble of TD codes the next set of TA, TB, TC, TD
                                        T0_Yx = ( pATR[ATRLen-1] & 0xF0 ) >> 4;
                                        //      low nibble of TD codes the protocol
                                        Protocol = pATR[ATRLen-1] & 0x0F;
                                }
                                else
                                {
                                        break;
                                }
                        }

                        if( NTStatus == STATUS_SUCCESS )
                        {
                                //      historical bytes
                BufferLength = *pATRLen - ATRLen;
                                NTStatus = STCReadICC1( 
                    ReaderExtension, 
                    pATR + ATRLen, 
                                        &BufferLength,
                    T0_K
                    );

                                //      check sum
                                if( NTStatus == STATUS_SUCCESS )
                                {
                                        ATRLen += T0_K;

                                        if( Protocol == PROTOCOL_T1 )
                                        {
                        BufferLength = *pATRLen - ATRLen;
                                                NTStatus = STCReadICC1( 
                            ReaderExtension, 
                            pATR + ATRLen, 
                                                        &BufferLength,
                            1
                            );
                                                if( NTStatus == STATUS_SUCCESS )
                                                {
                                                        ATRLen++;
                                                }
                                                else if( NTStatus == STATUS_IO_TIMEOUT )
                                                {
                                                        //      some cards don't support the TCK
                                                        NTStatus = STATUS_SUCCESS;
                                                }
                                        }
                                }
                        }
                }
        }

        if( NTStatus == STATUS_IO_TIMEOUT )
        {
                NTStatus = STATUS_UNRECOGNIZED_MEDIA;
        }

        if(NTStatus == STATUS_SUCCESS && pATRLen != NULL)
        {
                *pATRLen = ATRLen;
        }
        return( NTStatus );
}

NTSTATUS
STCWriteICC1(
        PREADER_EXTENSION       ReaderExtension,
        PUCHAR                          Data,
        ULONG                           DataLen
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        ULONG           BytesWritten = 0, Partial;      
        USHORT          SW = 0;
        UCHAR           IOData[STC_BUFFER_SIZE + 10];

        do
        {
                if(DataLen - BytesWritten > STC_BUFFER_SIZE - PACKET_OVERHEAD)
                {
                        Partial = STC_BUFFER_SIZE - PACKET_OVERHEAD;
                }
                else
                {
                        Partial = DataLen - BytesWritten;
                }

                IOData[NAD_IDX] = HOST_TO_ICC1;
                IOData[PCB_IDX] = PCB;
                IOData[LEN_IDX] = (UCHAR) Partial;

                SysCopyMemory( 
                        &IOData[DATA_IDX], 
                        Data + BytesWritten, 
                        Partial 
                        );

                IOData[Partial + 3] = IFCalcLRC(IOData, Partial + 3);

                NTStatus = IFWrite( 
                        ReaderExtension, 
                        IOData, 
                        Partial + 4 
                        );

                if( NTStatus == STATUS_SUCCESS )
                {
                        // read the status back from the reader
                        NTStatus = IFRead( 
                                ReaderExtension, 
                                IOData, 
                                6
                                );

                        if(NTStatus == STATUS_SUCCESS && 
                           *(PUSHORT) &IOData[DATA_IDX] != SW_SUCCESS ) {

                                SmartcardDebug( 
                                        DEBUG_ERROR,
                                        ("SCMSTCS!STCWriteICC1: Reader reported error %x\n", 
                                         *(PUSHORT) &IOData[DATA_IDX])
                                        );

                                NTStatus = STATUS_UNSUCCESSFUL;
                        }
                }

                BytesWritten += Partial;

        } while(BytesWritten < DataLen && NTStatus == STATUS_SUCCESS);

        return NTStatus;
}

NTSTATUS
STCReadICC1(
        PREADER_EXTENSION               ReaderExtension,
        PUCHAR                                  InData,
        PULONG                                  InDataLen,
    ULONG                   BytesRead
        )
{

        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           IOData[ STC_BUFFER_SIZE ];
        ULONG           Total = 0;

        while(NTStatus == STATUS_SUCCESS && Total < BytesRead)
        {
                //      read head
                NTStatus = IFRead( ReaderExtension, &IOData[0], 3 );

                if(NTStatus == STATUS_SUCCESS && IOData[LEN_IDX] < STC_BUFFER_SIZE - 4)
                {
                        //      read tail
                        NTStatus = IFRead( 
                                ReaderExtension, 
                                &IOData[DATA_IDX], 
                                IOData[LEN_IDX] + 1 
                                );

                        if( NTStatus == STATUS_SUCCESS )
                        {
                                if (IOData[NAD_IDX] == STC1_TO_HOST) {

                                        //
                                        // this is not good. We want to read smart card data, 
                                        // but the reader sent us a status packet, which can
                                        // only mean that something went wrong
                                        //
                                        SmartcardDebug( 
                                                DEBUG_ERROR,
                                                ( "SCMSTCS!STCReadICC1: Reader reported error %x\n",
                                                *(PUSHORT) &IOData[DATA_IDX])
                                                );

                                        NTStatus = STATUS_DEVICE_PROTOCOL_ERROR;
                                        break;
                                }

                if (Total + IOData[LEN_IDX] > *InDataLen) {

                    NTStatus = STATUS_BUFFER_TOO_SMALL;
                    break;                      
                }

                                SysCopyMemory( &InData[ Total ], &IOData[ DATA_IDX ], IOData[ LEN_IDX ] );
                                Total += IOData[ LEN_IDX ];
                        }
                }
        }

    *InDataLen = Total;

        return NTStatus;
}

NTSTATUS
STCPowerOff( PREADER_EXTENSION  ReaderExtension )
/*++
STCPowerOff:
        Deactivates the requested device

Arguments:
        ReaderExtension         context of call

Return Value:
        STATUS_SUCCESS
        error values from IFRead / IFWrite

--*/
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           SCCtrl;

        SCCtrl = 0x00;
        NTStatus = STCWriteSTCRegister( ReaderExtension, ADR_SC_CONTROL, 1, &SCCtrl );

        return( NTStatus );
}

NTSTATUS
STCPowerOn( PREADER_EXTENSION ReaderExtension )
/*++
STCPowerOn:
        Deactivates the requested device

Arguments:
        ReaderExtension         context of call

Return Value:
        STATUS_SUCCESS
        error values from IFRead / IFWrite

--*/
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           SCCtrl;

        SCCtrl = 0x40;                  //      vcc
        NTStatus = STCWriteSTCRegister( ReaderExtension, ADR_SC_CONTROL, 1, &SCCtrl );

        if( NTStatus == STATUS_SUCCESS )
        {
                SCCtrl = 0x41;          //      vpp
                NTStatus = STCWriteSTCRegister( ReaderExtension, ADR_SC_CONTROL, 1, &SCCtrl );

                if( NTStatus == STATUS_SUCCESS )
                {
                        SCCtrl=0xD1;    //       vcc, clk, io
                        NTStatus = STCWriteSTCRegister( ReaderExtension, ADR_SC_CONTROL, 1, &SCCtrl );
                }
        }
        return( NTStatus );
}


NTSTATUS
STCSetRST(
        PREADER_EXTENSION       ReaderExtension,
        BOOLEAN                         On
        )
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           SCCtrl;

        NTStatus = STCReadSTCRegister( ReaderExtension, ADR_SC_CONTROL, 1,&SCCtrl );
        if( NTStatus == STATUS_SUCCESS )
        {
                if( On )
                {
                        SCCtrl |= 0x20;
                }
                else
                {
                        SCCtrl &= ~0x20;
                }

                NTStatus = STCWriteSTCRegister( ReaderExtension, ADR_SC_CONTROL, 1,&SCCtrl );
        }
        return(NTStatus);
}

NTSTATUS
STCConfigureSTC(        
        PREADER_EXTENSION       ReaderExtension,
        PSTC_REGISTER           pConfiguration
        )
{
        NTSTATUS                        NTStatus = STATUS_SUCCESS;
        UCHAR                           Value;

        do
        {

                if( pConfiguration->Register == ADR_INT_CONTROL )
                {
                        // Read interrupt status register to acknoledge wrong states
                        NTStatus = STCReadSTCRegister( ReaderExtension,ADR_INT_STATUS,1,&Value );
                }

                Value = (UCHAR)pConfiguration->Value;
                NTStatus = STCWriteSTCRegister(
                        ReaderExtension,
                        pConfiguration->Register,
                        pConfiguration->Size,
                        (PUCHAR)&pConfiguration->Value
                        );

                // delay to stabilize the oscilator clock:
                if( pConfiguration->Register == ADR_CLOCK_CONTROL )
                {
                        SysDelay( 50 );
                }
                pConfiguration++;

        } while(( NTStatus == STATUS_SUCCESS ) && ( pConfiguration->Size ));

        return (NTStatus);      
}

NTSTATUS STCReadSTCRegister(
        PREADER_EXTENSION       ReaderExtension,
        UCHAR                           Address,
        ULONG                           Size,
        PUCHAR                          pValue
        )
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           IOData[ STC_BUFFER_SIZE ] =
        {
                HOST_TO_STC1,
                PCB,
                6,
                CLA_READ_REGISTER,
                INS_READ_REGISTER,
                0x00,
                Address,
                0x00,
                (UCHAR) Size
        };

        IOData[ 9 ] = IFCalcLRC( IOData, 9 );

        NTStatus = IFWrite( ReaderExtension, IOData, 10 );
        ASSERT(NTStatus == STATUS_SUCCESS);

        if( NTStatus == STATUS_SUCCESS )
        {
                NTStatus = IFRead( ReaderExtension, IOData, Size + 2 + 4 );

                if( NTStatus == STATUS_SUCCESS )
                {
                        //
                        //      check return code & size
                        //
                        USHORT shrtBuf;

                        RtlRetrieveUshort(&shrtBuf, &IOData[DATA_IDX + Size]);

                        if( shrtBuf == SW_SUCCESS )
                        {
                                SysCopyMemory( pValue, &IOData[ DATA_IDX ] , Size );
                        }
                        else
                        {
                                ASSERT(FALSE);
                                NTStatus = STATUS_DATA_ERROR;
                        }
                }
        }
        return( NTStatus );
}


NTSTATUS
STCWriteSTCRegister(
        PREADER_EXTENSION       ReaderExtension,
        UCHAR                           Address,
        ULONG                           Size,
        PUCHAR                          pValue
        )
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           IOData[STC_BUFFER_SIZE] =
        {
                HOST_TO_STC1,
                PCB,
                (UCHAR)( 5+Size ),
                CLA_WRITE_REGISTER,
                INS_WRITE_REGISTER,
                0x00,
                Address,
                (UCHAR) Size
        };

        SysCopyMemory( &IOData[ 8 ], pValue, Size );

        IOData[ 8+Size ] = IFCalcLRC( IOData, 8 + Size );

        NTStatus = IFWrite( ReaderExtension, IOData, 9 + Size );

        if( NTStatus == STATUS_SUCCESS )
        {
                NTStatus = IFRead( ReaderExtension, IOData, 6 );

                if(( NTStatus == STATUS_SUCCESS ) && ( *(PUSHORT)&IOData[ DATA_IDX ] != 0x0090 ))
                {
                        NTStatus = STATUS_DATA_ERROR;
                }
        }
        return( NTStatus );
}

NTSTATUS
STCSetETU(
        PREADER_EXTENSION       ReaderExtension,
        ULONG                           NewETU
        )
{
        NTSTATUS        NTStatus = STATUS_DATA_ERROR;
        UCHAR           ETU[2];

        if( NewETU < 0x0FFF )
        {
                NTStatus = STCReadSTCRegister(
                        ReaderExtension,
                        ADR_ETULENGTH15,
                        1,
                        ETU
                        );

                if( NTStatus == STATUS_SUCCESS )
                {
                        //
                        //      save all RFU bits
                        //
                        ETU[1]  = (UCHAR) NewETU;
                        ETU[0]  = (UCHAR)(( ETU[0] & 0xF0 ) | ( NewETU >> 8 ));

                        NTStatus = STCWriteSTCRegister(
                                ReaderExtension,
                                ADR_ETULENGTH15,
                                2,
                                ETU
                                );
                }
        }
        return(NTStatus);
}

NTSTATUS
STCSetCGT(
        PREADER_EXTENSION       ReaderExtension,
        ULONG                           NewCGT
        )
{
        NTSTATUS        NTStatus = STATUS_DATA_ERROR;
        UCHAR           CGT[2];
        
        if( NewCGT < 0x01FF )
        {
                NTStatus = STCReadSTCRegister(
                        ReaderExtension,
                        ADR_CGT8,
                        2,
                        CGT
                        );

                if( NTStatus == STATUS_SUCCESS )
                {
                        //
                        //      save all RFU bits
                        //
                        CGT[1] = ( UCHAR )NewCGT;
                        CGT[0] = (UCHAR)(( CGT[0] & 0xFE ) | ( NewCGT >> 8 ));
                                
                        NTStatus = STCWriteSTCRegister(
                                ReaderExtension,
                                ADR_CGT8,
                                2,
                                CGT
                                );
                }
        }
        return(NTStatus);
}

NTSTATUS
STCSetCWT(
        PREADER_EXTENSION       ReaderExtension,
        ULONG                           NewCWT
        )
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           CWT[4];

        //      little indians...
        CWT[0] = (( PUCHAR )&NewCWT )[3];
        CWT[1] = (( PUCHAR )&NewCWT )[2];
        CWT[2] = (( PUCHAR )&NewCWT )[1];
        CWT[3] = (( PUCHAR )&NewCWT )[0];
        
        NTStatus = STCWriteSTCRegister( ReaderExtension, ADR_CWT31, 4, CWT );
        return(NTStatus);
}

NTSTATUS
STCSetBWT(
        PREADER_EXTENSION       ReaderExtension,
        ULONG                           NewBWT
        )
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           BWT[4];

        //      little indians...
        BWT[0] = (( PUCHAR )&NewBWT )[3];
        BWT[1] = (( PUCHAR )&NewBWT )[2];
        BWT[2] = (( PUCHAR )&NewBWT )[1];
        BWT[3] = (( PUCHAR )&NewBWT )[0];
        
        NTStatus = STCWriteSTCRegister( ReaderExtension, ADR_BWT31, 4, BWT );

        return(NTStatus);
}


NTSTATUS 
STCShortCircuitTest(
        PREADER_EXTENSION       ReaderExtension,
        BOOLEAN                         *Detected
        )
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;

        //      set vcc to 1
#if     0       // eva board
        UCHAR           Value_VCC;
        UCHAR           Value_SENSE;

        NTStatus = STCReadSTCRegister( ReaderExtension,ADR_SC_CONTROL,1,&Value_VCC );

        if( NTStatus == STATUS_SUCCESS )
        {
                Value_VCC |= M_VCE;
                NTStatus = STCWriteSTCRegister( ReaderExtension,ADR_SC_CONTROL,1,&Value_VCC );

                if( NTStatus == STATUS_SUCCESS )
                {
                        //      read sense int status
                        NTStatus = STCReadSTCRegister( ReaderExtension,ADR_INT_STATUS,1,&Value_SENSE );
                        
                        if( Value_SENSE &= M_SENSE )
                        {
                                *Detected = TRUE;
                        }
                        else
                        {
                                *Detected = FALSE;
                        }
                }

                Value_VCC &= ~M_VCE;
                NTStatus = STCWriteSTCRegister( ReaderExtension,ADR_SC_CONTROL,1,&Value_VCC);
        }
#else
        *Detected = FALSE;
#endif
        return(NTStatus);
}

NTSTATUS
STCSetFDIV(
        PREADER_EXTENSION       ReaderExtension,
        ULONG                           Factor
        )
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           DIV;
        
        NTStatus = STCReadSTCRegister( ReaderExtension, ADR_ETULENGTH15, 1, &DIV );

        if( NTStatus == STATUS_SUCCESS ) 
        {
                switch( Factor )
                {
                        case 1:
                                DIV &= ~M_DIV0;
                                DIV &= ~M_DIV1;
                                break;
                        
                        case 2:
                                DIV |= M_DIV0;
                                DIV &= ~M_DIV1;
                                break;
                        
                        case 4  :
                                DIV &= ~M_DIV0;
                                DIV |= M_DIV1;
                                break;
                        
                        case 8  :
                                DIV |= M_DIV0;
                                DIV |= M_DIV1;
                                break;

                        default :
                                NTStatus = STATUS_DATA_ERROR;
                }
                if( NTStatus == STATUS_SUCCESS ) 
                {
                        NTStatus = STCWriteSTCRegister( ReaderExtension, ADR_ETULENGTH15, 1, &DIV );
                }
        }
        return(NTStatus);       
}

NTSTATUS 
STCInitUART(
        PREADER_EXTENSION       ReaderExtension,
        BOOLEAN                         AutoLearn
        )
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           Value;

        Value = AutoLearn ? 0x6F : 0x66;

        NTStatus = STCWriteSTCRegister( ReaderExtension, ADR_UART_CONTROL, 1, &Value );

        return( NTStatus );
}

NTSTATUS
STCGetFirmwareRevision(
        PREADER_EXTENSION       ReaderExtension
        )
{
        NTSTATUS        NTStatus = STATUS_SUCCESS;
        UCHAR           IOData[ STC_BUFFER_SIZE ] =
        {
                HOST_TO_STC1,
                PCB,
                6,
                CLA_READ_FIRMWARE_REVISION,
                INS_READ_FIRMWARE_REVISION,
                0x00,
                0x00,
                0x00,
                0x02
        };

        IOData[ 9 ] = IFCalcLRC( IOData, 9 );

        NTStatus = IFWrite( ReaderExtension, IOData, 10 );

        if( NTStatus == STATUS_SUCCESS )
        {
                NTStatus = IFRead( ReaderExtension, IOData, 6 );

                if( NTStatus == STATUS_SUCCESS )
                {
                        ReaderExtension->FirmwareMajor = IOData[ DATA_IDX ];
                        ReaderExtension->FirmwareMinor = IOData[ DATA_IDX + 1 ];
                }
        }
        return( STATUS_SUCCESS );
}

//---------------------------------------- END OF FILE ----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\scmstcs\serialnt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       serialnt.h
//
//--------------------------------------------------------------------------

#if !defined( __SERIAL_NT_H__ )
#define __SERIAL_NT_H__

#include "DriverNT.h"
#include <ntddser.h>

#include "SerialIF.h"

#define STC_BUFFER_SIZE		32
#define TPDU_STACK_SIZE		2048

typedef struct _SERIAL_PORT_CONFIG
{
    SERIAL_HANDFLOW		HandFlow;           // flow control
    SERIAL_CHARS		SerialChars;        // special characters
    SERIAL_TIMEOUTS		Timeouts;           // read/write timeouts
    SERIAL_BAUD_RATE	BaudRate;          	// Baudrate for reader
    SERIAL_LINE_CONTROL	LineControl;    	// Stop bits, parity configuration
    ULONG				WaitMask,           // notification events
						Purge;
} SERIAL_PORT_CONFIG, *PSERIAL_PORT_CONFIG;

typedef struct _READER_EXTENSION
{
	//
	//	serial port driver data
	//
	ULONG				SerialPortNumber;
	PDEVICE_OBJECT		SerialDeviceObject;
	PFILE_OBJECT		SerialFileObject;
	PIO_WORKITEM		CloseSerial;		//	worker thread that closes the serial driver

	//	back pointer to smart card extension
    PSMARTCARD_EXTENSION    SmartcardExtension;

	//	read thread data
	UCHAR				IOData[ 2 * STC_BUFFER_SIZE ];
	UCHAR				TPDUStack[ TPDU_STACK_SIZE ];
	ULONG				Available;
	ULONG				Expected;

	ULONG				EventMask;
	ULONG				ReadTimeout;			//	read timeout in ms

	IO_STATUS_BLOCK		IoStatus;
	KEVENT				IoEvent;
	KEVENT				DataAvailable;

	PIO_WORKITEM		ReadWorkItem;
	KSPIN_LOCK			ReadSpinLock;

	//	miscellaneous
	ULONG				ReaderPowerState;
	BOOLEAN				PowerRequest;
	UCHAR				FirmwareMajor,
						FirmwareMinor;

    BOOLEAN             CardPresent;

	KEVENT				SerialCloseDone;		//	signaled if the connection to the serial driver has been closed

} READER_EXTENSION, *PREADER_EXTENSION;

typedef enum _READER_POWER_STATE
{
    PowerReaderUnspecified = 0,
    PowerReaderWorking,
    PowerReaderOff
} READER_POWER_STATE, *PREADER_POWER_STATE;

//
//	CONSTANTS
//
#define SR_VENDOR_NAME			"STCS"
#define SR_PRODUCT_NAME			"Serial Reader"
//
//	serial communication defines
//
#define SR_BAUD_RATE						115200
#define SR_STOP_BITS						STOP_BIT_1
#define SR_PARITY							NO_PARITY
#define SR_DATA_LENGTH						SERIAL_DATABITS_8
//
//	COM timeout values in ms
//
#define SR_READ_TOTAL_TIMEOUT_CONSTANT		2000
#define SR_READ_INTERVAL_TIMEOUT			2000

#define SR_WRITE_TOTAL_TIMEOUT_CONSTANT		2000
#define SR_WRITE_TOTAL_TIMEOUT_MULTIPLIER	0

#define SR_FLOW_REPLACE						0       
#define SR_HAND_SHAKE						0
#define SR_XON_LIMIT						0
#define SR_XOFF_LIMIT						0

#define SR_ON_CHAR							0x11
#define SR_OFF_CHAR							0x13

#define SR_NOTIFICATION_EVENT				( SERIAL_EV_RXCHAR | SERIAL_EV_DSR )

#define SR_PURGE							( SERIAL_PURGE_RXCLEAR | SERIAL_PURGE_TXCLEAR )

//
//	not clear, how these ctl codes are interpreted; the actual command is passed by the IrpStack.MajorFunction
//
#define SERIAL_READ							SCARD_CTL_CODE( 0x1000 )
#define SERIAL_WRITE						SCARD_CTL_CODE( 0x2000 )

//
//	READ THREAD
//
#define RT_FINISH				0x00
#define RT_READ_HEAD			0x01
#define RT_READ_TAIL			0x02
#define RT_READ_MORE			0x03
#define RT_GET_MODEM_STATUS		0x04
#define RT_WAIT_EMPTY			0x05
#define RT_WAIT_DATA			0x06

NTSTATUS
IFReadThreadCallback(
	PDEVICE_OBJECT			DeviceObject,
	PIRP					Irp,
	PREADER_EXTENSION		ReaderExtension
	);

//
//	LOCAL PROTOTYPES
//
NTSTATUS
IFSerialIoctl(
	PREADER_EXTENSION	ReaderExtension,
	ULONG				IoctlCode,
	PVOID				OutData,
	ULONG				OutDataLen,
	PVOID				InData,
	ULONG				InDataLen
	);

NTSTATUS
IFSerialRead(
	PREADER_EXTENSION	ReaderExtension,
	PUCHAR				InData,
	ULONG				InDataLen
	);

NTSTATUS 
IFSerialWaitOnMask(
	PREADER_EXTENSION		ReaderExtension
	);

VOID
IFReadWorkRoutine(
	IN PDEVICE_OBJECT DeviceObject,
	IN PREADER_EXTENSION ReaderExtension 
	);


#endif	//	!__SERIAL_NT_H__


//---------------------------------------- END OF FILE ----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\scmstcs\stccmd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       stccmd.h
//
//--------------------------------------------------------------------------

#if !defined( __STC_COMMAND_H__ )
#define __STC_COMMAND_H__

#include "STC.h"

NTSTATUS
STCReset( 
	PREADER_EXTENSION	ReaderExtension,
	UCHAR				Device,
	BOOLEAN				WarmReset,
	PUCHAR				pATR,
	PULONG				pATRLength
	);

NTSTATUS 
STCReadATR(
	PREADER_EXTENSION	ReaderExtension, 
	PUCHAR				pATR, 
	PULONG				pATRLength
	);

NTSTATUS
STCPowerOff(
	PREADER_EXTENSION	ReaderExtension
	);

NTSTATUS
STCPowerOn(
	PREADER_EXTENSION	ReaderExtension
	);

NTSTATUS
STCSetRST(
	PREADER_EXTENSION	ReaderExtension,
	BOOLEAN				On
	);

NTSTATUS
STCConfigureSTC( 	
	PREADER_EXTENSION	ReaderExtension,
	PSTC_REGISTER		pConfiguration
	);

NTSTATUS
STCWriteICC1 (
	PREADER_EXTENSION	ReaderExtension,
	PUCHAR				APDU,
	ULONG				APDULen
	);

NTSTATUS
STCReadICC1(
	PREADER_EXTENSION		ReaderExtension,
	PUCHAR					InData,
	PULONG					InDataLen,
	ULONG                   BytesRead
	);

NTSTATUS
STCReadSTCRegister(
	PREADER_EXTENSION	ReaderExtension,
	UCHAR				Address,
	ULONG				Size,
	PUCHAR				pValue
	);
	
NTSTATUS
STCWriteSTCRegister(
	PREADER_EXTENSION	ReaderExtension,
	UCHAR				Address,
	ULONG				Size,
	PUCHAR				pValue
	);

NTSTATUS
STCSetETU(
	PREADER_EXTENSION	ReaderExtension,
	ULONG				NewETU
	);

NTSTATUS
STCSetCGT(
	PREADER_EXTENSION	ReaderExtension,
	ULONG				NewCGT
	);

NTSTATUS
STCSetCWT(
	PREADER_EXTENSION	ReaderExtension,
	ULONG				NewCWT
	);

NTSTATUS
STCSetBWT(
	PREADER_EXTENSION	ReaderExtension,
	ULONG				NewBWT
	);

NTSTATUS 
STCShortCircuitTest(
	PREADER_EXTENSION	ReaderExtension,
	BOOLEAN				*Detected
	);


NTSTATUS
STCSetFDIV(
	PREADER_EXTENSION	ReaderExtension,
	ULONG				Factor
	);


NTSTATUS 
STCInitUART(
	PREADER_EXTENSION	ReaderExtension,
	BOOLEAN				AutoLearn
	);

NTSTATUS
STCGetFirmwareRevision(
	PREADER_EXTENSION	ReaderExtension
	);

extern const STC_REGISTER STCInitialize[];
extern const STC_REGISTER STCClose[];

#endif	//	!__STC_COMMAND_H__


//---------------------------------------- END OF FILE ----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\scmstcs\t0hndlr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       t0hndlr.h
//
//--------------------------------------------------------------------------

#if !defined( __T0_HANDLER_H__ )
#define __T0_HANDLER_H__

NTSTATUS
T0_ExchangeData(
	PREADER_EXTENSION	ReaderExtension,
	PUCHAR				pRequest,
	ULONG				RequestLen,
	PUCHAR				pReply,
	PULONG				pReplyLen
	);

#endif	//	!__T0_HANDLER_H__


//---------------------------------------- END OF FILE ----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\scmstcs\t0hndlr.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       t0hndlr.c
//
//--------------------------------------------------------------------------

#if defined( SMCLIB_VXD )
#include "Driver98.h"
#else
#include "DriverNT.h"
#endif	//	SMCLIB_VXD

#include "SerialIF.h"
#include "STCCmd.h"
#include "T0Hndlr.h"

NTSTATUS
T0_ExchangeData(
	PREADER_EXTENSION	ReaderExtension,
	PUCHAR				pRequest,
	ULONG				RequestLen,
	PUCHAR				pReply,
	PULONG				pReplyLen
	)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
	NTSTATUS	NTStatus = STATUS_SUCCESS;
    BOOLEAN     restartWorkWaitingTime = FALSE;
    ULONG       bytesWritten, totalBytesToWrite, totalBytesToRead;
    ULONG       bytesToWrite, bytesRead, ioBufferLen;
    UCHAR       ioBuffer[512];

    totalBytesToWrite = RequestLen;
    totalBytesToRead = ReaderExtension->SmartcardExtension->T0.Le + 2;
    bytesRead = 0;

    // start with writing the header of the request
    bytesToWrite = 5;
    bytesWritten = 0;

    __try {

        do {

            if (restartWorkWaitingTime == FALSE) {

                NTStatus = STCWriteICC1( 
                    ReaderExtension, 
                    pRequest + bytesWritten, 
                    bytesToWrite
                    );
                ASSERT(NTStatus != STATUS_BUFFER_TOO_SMALL);

                if (NTStatus != STATUS_SUCCESS) {

                    __leave;
                }

                bytesWritten += bytesToWrite;
                totalBytesToWrite -= bytesToWrite;
            }

            //
            // try to read the pcb, the card could 
            // also answer with a status word
            //
            ioBufferLen = sizeof(ioBuffer);
	        NTStatus = STCReadICC1( 
                ReaderExtension, 
                ioBuffer, 
				&ioBufferLen,
                1
                );
            ASSERT(NTStatus != STATUS_BUFFER_TOO_SMALL);

            restartWorkWaitingTime = FALSE;

            if (NTStatus != STATUS_SUCCESS) {

                __leave;
            }

            if (ioBuffer[0] == 0x60) {

                //
                // Set flag that we only should read the proc byte
                // without writing data to the card
                //
                restartWorkWaitingTime = TRUE;
                continue;
            }

            if ((ioBuffer[0] & 0xFE) == pRequest[1]) {
        
                // we can send all remaining bytes at once.
                bytesToWrite = totalBytesToWrite;

            } else if(ioBuffer[0] == (UCHAR) ~pRequest[1]) {
                
                // we can only send the next byte
                bytesToWrite = 1;

            } else {

                // this must be a status word

                totalBytesToWrite = 0;
                totalBytesToRead = 0;

                pReply[0] = ioBuffer[0];

                if (ioBufferLen == 2) {
                 	
                    //
                    // the reader returned already the 
                    // 2nd byte of the status word
                    //
                    pReply[1] = ioBuffer[1];

                } else {
                 	
                    // we have to read the 2nd byte of the status word
                    ioBufferLen = sizeof(ioBuffer);
	                NTStatus = STCReadICC1( 
                        ReaderExtension, 
                        ioBuffer, 
						&ioBufferLen,
                        1
                        );
                    ASSERT(NTStatus != STATUS_BUFFER_TOO_SMALL);

                    if (NTStatus != STATUS_SUCCESS) {

                        __leave;
                    }
                    if (ioBufferLen != 1) {

                        NTStatus = STATUS_DEVICE_PROTOCOL_ERROR;
                        __leave;
                    }
                    pReply[1] = ioBuffer[0];
                }

                *pReplyLen = 2;
            }

        } while (totalBytesToWrite || restartWorkWaitingTime);

        if (totalBytesToRead != 0) {

            ioBufferLen = *pReplyLen;
	        NTStatus = STCReadICC1( 
                ReaderExtension, 
                pReply, 
				&ioBufferLen,
                totalBytesToRead
                );

            if (NTStatus != STATUS_SUCCESS) {

                __leave;
            }

            *pReplyLen = ioBufferLen;
        }
    }
    __finally {

    }

	return NTStatus;		
}

//---------------------------------------- END OF FILE ----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\smclib\smcioctl.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    smcioctl.c

Abstract:

    This module handles all IOCTL requests to the smart card reader.

Environment:

    Kernel mode only.

Notes:

    This module is shared by Windows NT and Windows 9x

Revision History:

    - Created June 1997 by Klaus Schutz

--*/

#define _ISO_TABLES_

#ifndef SMCLIB_VXD
#ifndef SMCLIB_CE
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <ntddk.h>
#endif
#endif

#include "smclib.h"

#define IOCTL_SMARTCARD_DEBUG        SCARD_CTL_CODE(98) 

#define CheckUserBuffer(_len_) \
	if (SmartcardExtension->IoRequest.ReplyBuffer == NULL || \
		SmartcardExtension->IoRequest.ReplyBufferLength < (_len_)) { \
		status = STATUS_BUFFER_TOO_SMALL; \
		break; \
	}
#define CheckMinCardStatus(_status_) \
	if (SmartcardExtension->ReaderCapabilities.CurrentState < (_status_)) { \
		status = STATUS_INVALID_DEVICE_STATE; \
		break; \
	}
#define ReturnULong(_value_) \
	{ \
		CheckUserBuffer(sizeof(ULONG)) \
		*(PULONG) SmartcardExtension->IoRequest.ReplyBuffer = (_value_); \
		*SmartcardExtension->IoRequest.Information = sizeof(ULONG); \
	}
#define ReturnUChar(_value_) \
	{ \
		CheckUserBuffer(sizeof(UCHAR)) \
		*(PUCHAR) SmartcardExtension->IoRequest.ReplyBuffer = (_value_); \
		*SmartcardExtension->IoRequest.Information = sizeof(UCHAR); \
    }

#define DIM(_array_) (sizeof(_array_) / sizeof(_array_[0]))

PTCHAR 
MapIoControlCodeToString(
    ULONG IoControlCode
    )
{
    ULONG i;

    static struct {

        ULONG   IoControlCode;
        PTCHAR  String;

    } IoControlList[] = {
     	
        IOCTL_SMARTCARD_POWER,          TEXT("POWER"),
        IOCTL_SMARTCARD_GET_ATTRIBUTE,  TEXT("GET_ATTRIBUTE"),
        IOCTL_SMARTCARD_SET_ATTRIBUTE,  TEXT("SET_ATTRIBUTE"),
        IOCTL_SMARTCARD_CONFISCATE,     TEXT("CONFISCATE"),
        IOCTL_SMARTCARD_TRANSMIT,       TEXT("TRANSMIT"),
        IOCTL_SMARTCARD_EJECT,          TEXT("EJECT"),
        IOCTL_SMARTCARD_SWALLOW,        TEXT("SWALLOW"),       
        IOCTL_SMARTCARD_IS_PRESENT,     TEXT("IS_PRESENT"),
        IOCTL_SMARTCARD_IS_ABSENT,      TEXT("IS_ABSENT"),
        IOCTL_SMARTCARD_SET_PROTOCOL,   TEXT("SET_PROTOCOL"),
        IOCTL_SMARTCARD_GET_STATE,      TEXT("GET_STATE"),
        IOCTL_SMARTCARD_GET_LAST_ERROR, TEXT("GET_LAST_ERROR")
    };

    for (i = 0; i < DIM(IoControlList); i++) {

        if (IoControlCode == IoControlList[i].IoControlCode) {

            return IoControlList[i].String;
        }
    }

    return TEXT("*** UNKNOWN ***");
}

NTSTATUS
SmartcardDeviceIoControl(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:
	
    This routine handles the smart card lib specific io control requests.
    The driver has to call the function from the driver's io control request.
    It checks the parameters of the call and depending on the type of 
    the call returns the requested value or calls the driver in order
    to perform an operation like POWER or TRANSMIT.

    NOTE: This function is used by Windows NT and VxD driver

Arguments:

    SmartcardExtension - The pointer to the smart card data struct

Return Value:

    NTSTATUS value 

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
#ifdef SMCLIB_NT
    KIRQL Irql;
#endif

    switch (SmartcardExtension->MajorIoControlCode) {

#if DEBUG
        ULONG CurrentDebugLevel, bytesTransferred;
#endif
        PSCARD_IO_REQUEST scardIoRequest;

        case IOCTL_SMARTCARD_GET_ATTRIBUTE:
			//
			// Please refer to the Interoperrability standard for ICC
			//
			switch (SmartcardExtension->MinorIoControlCode) {

				case SCARD_ATTR_VENDOR_NAME:
					CheckUserBuffer(SmartcardExtension->VendorAttr.VendorName.Length);

					RtlCopyMemory(
						SmartcardExtension->IoRequest.ReplyBuffer,
						SmartcardExtension->VendorAttr.VendorName.Buffer,
						SmartcardExtension->VendorAttr.VendorName.Length
						);
		            *SmartcardExtension->IoRequest.Information = 
		            	SmartcardExtension->VendorAttr.VendorName.Length;
					break;

				case SCARD_ATTR_VENDOR_IFD_TYPE:
					CheckUserBuffer(SmartcardExtension->VendorAttr.IfdType.Length);

					RtlCopyMemory(
						SmartcardExtension->IoRequest.ReplyBuffer,
						SmartcardExtension->VendorAttr.IfdType.Buffer,
						SmartcardExtension->VendorAttr.IfdType.Length
						);
		            *SmartcardExtension->IoRequest.Information = 
		            	SmartcardExtension->VendorAttr.IfdType.Length;
					break;

                case SCARD_ATTR_VENDOR_IFD_VERSION:
                    ReturnULong(
                        SmartcardExtension->VendorAttr.IfdVersion.BuildNumber | 
                        SmartcardExtension->VendorAttr.IfdVersion.VersionMinor << 16 | 
                        SmartcardExtension->VendorAttr.IfdVersion.VersionMajor << 24 
                        );
                	break;

                case SCARD_ATTR_VENDOR_IFD_SERIAL_NO:
                    if (SmartcardExtension->VendorAttr.IfdSerialNo.Length == 0) {

                        status = STATUS_NOT_SUPPORTED;
                     	
                    } else {
                     	
					    CheckUserBuffer(SmartcardExtension->VendorAttr.IfdSerialNo.Length);

					    RtlCopyMemory(
						    SmartcardExtension->IoRequest.ReplyBuffer,
						    SmartcardExtension->VendorAttr.IfdSerialNo.Buffer,
						    SmartcardExtension->VendorAttr.IfdSerialNo.Length
						    );
		                *SmartcardExtension->IoRequest.Information = 
		            	    SmartcardExtension->VendorAttr.IfdSerialNo.Length;
                    }

                	break;

				case SCARD_ATTR_DEVICE_UNIT:
					// Return the unit number of this device
					ReturnULong(SmartcardExtension->VendorAttr.UnitNo);
					break;

				case SCARD_ATTR_CHANNEL_ID:
					//
					// Return reader type / channel id in form
					// 0xDDDDCCCC where D is reader type and C is channel number
					//
					ReturnULong(
						SmartcardExtension->ReaderCapabilities.ReaderType << 16l |
						SmartcardExtension->ReaderCapabilities.Channel
						);
					break;

				case SCARD_ATTR_CHARACTERISTICS:
					// Return mechanical characteristics of the reader
					ReturnULong(
						SmartcardExtension->ReaderCapabilities.MechProperties
						)
					break;

				case SCARD_ATTR_CURRENT_PROTOCOL_TYPE:
					// Return the currently selected protocol
					CheckMinCardStatus(SCARD_NEGOTIABLE);

					ReturnULong(
						SmartcardExtension->CardCapabilities.Protocol.Selected
						);
					break;

				case SCARD_ATTR_CURRENT_CLK:
					//
					// Return the current ICC clock freq. encoded as little
					// endian integer value (3.58 MHZ is 3580)
					//
					CheckMinCardStatus(SCARD_NEGOTIABLE);

                    if(SmartcardExtension->CardCapabilities.PtsData.CLKFrequency) {
                        ReturnULong(SmartcardExtension->CardCapabilities.PtsData.CLKFrequency);
					} else {
                        ReturnULong(SmartcardExtension->ReaderCapabilities.CLKFrequency.Default);
					}
					break;

				case SCARD_ATTR_CURRENT_F:
					// Return the current F value encoded as little endian integer
					CheckMinCardStatus(SCARD_NEGOTIABLE);

                    ASSERT(SmartcardExtension->CardCapabilities.Fl < 
                        DIM(ClockRateConversion));

					ReturnULong(
						SmartcardExtension->CardCapabilities.ClockRateConversion[
							SmartcardExtension->CardCapabilities.Fl
							].F
						);
					break;

				case SCARD_ATTR_CURRENT_D:
					//
					// Return the current D value encoded as little endian integer
					// in units of 1/64. So return 1 if D is 1/64.
					//
					CheckMinCardStatus(SCARD_NEGOTIABLE);

                    ASSERT(
                        SmartcardExtension->CardCapabilities.Dl < 
                        DIM(BitRateAdjustment)
                        );

                    ASSERT(
                        SmartcardExtension->CardCapabilities.BitRateAdjustment[
							SmartcardExtension->CardCapabilities.Dl
							].DDivisor != 0
                        );

                    //
                    // Check the current value of Dl.
                    // It should definitely not be greater than the array bounds
                    // and the value in the array is not allowed to be zero
                    //
                    if (SmartcardExtension->CardCapabilities.Dl >=
                        DIM(BitRateAdjustment) ||                        
                        SmartcardExtension->CardCapabilities.BitRateAdjustment[
							SmartcardExtension->CardCapabilities.Dl
							].DDivisor == 0) {

                        status = STATUS_UNRECOGNIZED_MEDIA;
                        break;                             	
                    }

					ReturnULong(
						SmartcardExtension->CardCapabilities.BitRateAdjustment[
							SmartcardExtension->CardCapabilities.Dl
							].DNumerator /
						SmartcardExtension->CardCapabilities.BitRateAdjustment[
							SmartcardExtension->CardCapabilities.Dl
							].DDivisor
						);
					break;

				case SCARD_ATTR_CURRENT_W:
					// Return the work waiting time (integer) for T=0
					CheckMinCardStatus(SCARD_NEGOTIABLE);
					ReturnULong(SmartcardExtension->CardCapabilities.T0.WI);
					break;

                case SCARD_ATTR_CURRENT_N:
					// Return extra guard time
					CheckMinCardStatus(SCARD_NEGOTIABLE);
					ReturnULong(SmartcardExtension->CardCapabilities.N);
                	break;

				case SCARD_ATTR_CURRENT_IFSC:
					// Return the current information field size card
					CheckMinCardStatus(SCARD_NEGOTIABLE);
					if (SmartcardExtension->T1.IFSC) {
					    ReturnULong(SmartcardExtension->T1.IFSC);
					} else {
					    ReturnULong(SmartcardExtension->CardCapabilities.T1.IFSC);
					}
					break;

				case SCARD_ATTR_CURRENT_IFSD:
					// Return the current information field size card
					CheckMinCardStatus(SCARD_NEGOTIABLE);
					if (SmartcardExtension->T1.IFSD) {
					    ReturnULong(SmartcardExtension->T1.IFSD);
					} else {
						ReturnULong(SmartcardExtension->ReaderCapabilities.MaxIFSD);
					}
					break;

				case SCARD_ATTR_CURRENT_BWT:
					// Return the current block waiting time for T=1
					CheckMinCardStatus(SCARD_NEGOTIABLE);
					ReturnULong(SmartcardExtension->CardCapabilities.T1.BWI);
					break;

				case SCARD_ATTR_CURRENT_CWT:
					// Return the current character waiting time for T=1
					CheckMinCardStatus(SCARD_NEGOTIABLE);
					ReturnULong(SmartcardExtension->CardCapabilities.T1.CWI);
					break;

				case SCARD_ATTR_CURRENT_EBC_ENCODING:
					// Return the current error checking method
					CheckMinCardStatus(SCARD_NEGOTIABLE);
					ReturnULong(SmartcardExtension->CardCapabilities.T1.EDC);
					break;

                case SCARD_ATTR_DEFAULT_CLK:
                    ReturnULong(
                        SmartcardExtension->ReaderCapabilities.CLKFrequency.Default
                        );
                	break;

                case SCARD_ATTR_MAX_CLK:
                    ReturnULong(
                        SmartcardExtension->ReaderCapabilities.CLKFrequency.Max
                        );
                	break;

                case SCARD_ATTR_DEFAULT_DATA_RATE:
                    ReturnULong(
                        SmartcardExtension->ReaderCapabilities.DataRate.Default
                        );
                	break;

                case SCARD_ATTR_MAX_DATA_RATE:
                    ReturnULong(
                        SmartcardExtension->ReaderCapabilities.DataRate.Max
                        );
                	break;

				case SCARD_ATTR_ATR_STRING:
					// Return ATR of currently inserted card
					CheckUserBuffer(MAXIMUM_ATR_LENGTH);
					CheckMinCardStatus(SCARD_NEGOTIABLE);
					RtlCopyMemory(
						SmartcardExtension->IoRequest.ReplyBuffer,
						SmartcardExtension->CardCapabilities.ATR.Buffer,
						SmartcardExtension->CardCapabilities.ATR.Length
						);
		            *SmartcardExtension->IoRequest.Information = 
		            	SmartcardExtension->CardCapabilities.ATR.Length;
					break;

				case SCARD_ATTR_ICC_TYPE_PER_ATR:
					//
					// Return ICC type, based on ATR.
					// We currently support only T=0 and T=1, so return
					// 1 for those protocols otherwise 0 (unknown ICC type)
					//
					CheckMinCardStatus(SCARD_NEGOTIABLE);
					ReturnUChar(
						((SmartcardExtension->CardCapabilities.Protocol.Selected & 
						(SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1)) ? 1 : 0)
						);
					break;

				case SCARD_ATTR_ICC_PRESENCE:
					// Return the status of the card
                    AccessUnsafeData(&Irql);
                    switch (SmartcardExtension->ReaderCapabilities.CurrentState) {
                     	
                        case SCARD_UNKNOWN:
                            status = STATUS_INVALID_DEVICE_STATE;
                            break;

                        case SCARD_ABSENT:
					        ReturnUChar(0);
                        	break;

                        case SCARD_PRESENT:
					        ReturnUChar(1);
                        	break;

                        default:
					        ReturnUChar(2);
                        	break;

                    }
                    EndAccessUnsafeData(Irql);
					break;

				case SCARD_ATTR_ICC_INTERFACE_STATUS:
					// Return if card contacts are active 
					ReturnUChar(
						(SmartcardExtension->ReaderCapabilities.CurrentState >=
							SCARD_SWALLOWED ? (UCHAR) -1 : 0)
						);
					break;

                case SCARD_ATTR_PROTOCOL_TYPES:
                    ReturnULong(
                        SmartcardExtension->ReaderCapabilities.SupportedProtocols
                        );
                	break;

                case SCARD_ATTR_MAX_IFSD:
                    ReturnULong(
                        SmartcardExtension->ReaderCapabilities.MaxIFSD
                        );
                	break;

                case SCARD_ATTR_POWER_MGMT_SUPPORT:
                    ReturnULong(
                        SmartcardExtension->ReaderCapabilities.PowerMgmtSupport
                        );
                	break;

				default:
					status = STATUS_NOT_SUPPORTED;
					break;
			}
			break;

        case IOCTL_SMARTCARD_SET_ATTRIBUTE:
			switch (SmartcardExtension->MinorIoControlCode) {

                case SCARD_ATTR_SUPRESS_T1_IFS_REQUEST:
                    //
                    // The card does not support ifs request, so 
                    // we turn off ifs negotiation
                    //
                    SmartcardExtension->T1.State = T1_START;
                	break;

                default:
                    status = STATUS_NOT_SUPPORTED;
                    break;
            }
            break;

#if defined(DEBUG) && defined(SMCLIB_NT)
        case IOCTL_SMARTCARD_GET_PERF_CNTR:
			switch (SmartcardExtension->MinorIoControlCode) {

                case SCARD_PERF_NUM_TRANSMISSIONS:
                    ReturnULong(SmartcardExtension->PerfInfo->NumTransmissions);
                	break;

                case SCARD_PERF_BYTES_TRANSMITTED:
                    ReturnULong(
                        SmartcardExtension->PerfInfo->BytesSent +
                        SmartcardExtension->PerfInfo->BytesReceived
                        );
                	break;

                case SCARD_PERF_TRANSMISSION_TIME:
                    ReturnULong( 
                        (ULONG) (SmartcardExtension->PerfInfo->IoTickCount.QuadPart *
                        KeQueryTimeIncrement() /
                        10)
                        );
                	break;
            }
        	break;
#endif
        case IOCTL_SMARTCARD_CONFISCATE:
			if (SmartcardExtension->ReaderFunction[RDF_CARD_CONFISCATE] == NULL) {

				status = STATUS_NOT_SUPPORTED;
				break;
			}

			status = SmartcardExtension->ReaderFunction[RDF_CARD_CONFISCATE](
				SmartcardExtension
				);

            break;

        case IOCTL_SMARTCARD_EJECT:
			if (SmartcardExtension->ReaderFunction[RDF_CARD_EJECT] == NULL) {

				status = STATUS_NOT_SUPPORTED;
				break;
			}

			status = SmartcardExtension->ReaderFunction[RDF_CARD_EJECT](
				SmartcardExtension
				);
            break;

#ifdef SMCLIB_VXD
        case IOCTL_SMARTCARD_GET_LAST_ERROR:
            //
            // Return error of the last overlapped operation
            // Used for Windows VxD's that can't return the 
            // error code within IoComplete like NT can
            //
            ReturnULong(SmartcardExtension->LastError);
        	break;                                            
#endif
            
        case IOCTL_SMARTCARD_GET_STATE:
            // Return current state of the smartcard
			CheckUserBuffer(sizeof(ULONG));

            AccessUnsafeData(&Irql); 

            *(PULONG) SmartcardExtension->IoRequest.ReplyBuffer = 
				SmartcardExtension->ReaderCapabilities.CurrentState;

            *SmartcardExtension->IoRequest.Information = 
            	sizeof(ULONG);

            EndAccessUnsafeData(Irql);
            break;

        case IOCTL_SMARTCARD_POWER:
			if (SmartcardExtension->ReaderFunction[RDF_CARD_POWER] == NULL) {

				status = STATUS_NOT_SUPPORTED;
				break;
			}

			// Check if a card is present
			if (SmartcardExtension->ReaderCapabilities.CurrentState <= 
				SCARD_ABSENT) {

				status = STATUS_INVALID_DEVICE_STATE;
				break;
			}

			// Initialize the card capabilities struct
			SmartcardInitializeCardCapabilities(
				SmartcardExtension
				);

            switch (SmartcardExtension->MinorIoControlCode) {

                case SCARD_COLD_RESET:
                case SCARD_WARM_RESET:
					CheckUserBuffer(MAXIMUM_ATR_LENGTH);

                case SCARD_POWER_DOWN:

					status = SmartcardExtension->ReaderFunction[RDF_CARD_POWER](
						SmartcardExtension
						);
                    break;
                    
                default:
                    status = STATUS_INVALID_DEVICE_REQUEST;
                    break;    
            }
            break;

        case IOCTL_SMARTCARD_SET_PROTOCOL:
			//
			// Since we return the selected protocol, the return buffer
			// must be large enough to hold the result
			//
			CheckUserBuffer(sizeof(ULONG));

            // Set the protocol to be used with the current card
			if (SmartcardExtension->ReaderFunction[RDF_SET_PROTOCOL] == NULL) {

				status = STATUS_NOT_SUPPORTED;
				break;
			}

            // Check if we're already in specific state
	        if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC &&
		        (SmartcardExtension->CardCapabilities.Protocol.Selected & 
		         SmartcardExtension->MinorIoControlCode)) {

		        status = STATUS_SUCCESS;	
                break;
            }

			// Check if a card is present and not already in specific mode
			if (SmartcardExtension->ReaderCapabilities.CurrentState <= 
				SCARD_ABSENT) {

				status = STATUS_INVALID_DEVICE_STATE;
				break;
			}

            // We only check the ATR when the user selects T=0 or T=1 
            if (SmartcardExtension->MinorIoControlCode & (SCARD_PROTOCOL_Tx)) {
             	
                if (SmartcardExtension->MinorIoControlCode & SCARD_PROTOCOL_DEFAULT) {

                    // Select default PTS values
                    SmartcardExtension->CardCapabilities.PtsData.Type = PTS_TYPE_DEFAULT;

                } else {
                
                    // Select best possible PTS data
                    SmartcardExtension->CardCapabilities.PtsData.Type = PTS_TYPE_OPTIMAL;
                }

			    // Evaluate ATR
			    status = SmartcardUpdateCardCapabilities(SmartcardExtension);

            } else {
             	
                // caller doesn't want neither T=0 nor T=1 -> force callback
                status = STATUS_UNRECOGNIZED_MEDIA;
            }

            if (status == STATUS_UNRECOGNIZED_MEDIA && 
                SmartcardExtension->ReaderFunction[RDF_ATR_PARSE] != NULL) {

                // let the driver evaluate the ATR, since we don't know it
                status = SmartcardExtension->ReaderFunction[RDF_ATR_PARSE](
                    SmartcardExtension
                    );
            }

			if (status != STATUS_SUCCESS) {

                // Evaluation of the ATR failed It doesn't make sense to continue
				break;
			} 

			// Check if card is now in the right status
            if (SmartcardExtension->ReaderCapabilities.CurrentState <
    			SCARD_NEGOTIABLE) {

				status = STATUS_INVALID_DEVICE_STATE;
				break;
            }

			//
			// Check if the user tries to select a protocol that
			// the card doesn't support
			//
			if ((SmartcardExtension->CardCapabilities.Protocol.Supported & 
				 SmartcardExtension->MinorIoControlCode) == 0) {

                //
                // Since the card does not support the request protocol
                // we need to set back any automatic seletions done by
                // SmartcardUpdateCardCapabilities()
                //
                SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_NEGOTIABLE;
                SmartcardExtension->CardCapabilities.Protocol.Selected = 0;

				status = STATUS_NOT_SUPPORTED;
				break;
			}

			status = SmartcardExtension->ReaderFunction[RDF_SET_PROTOCOL](
				SmartcardExtension
				);
			break;

        case IOCTL_SMARTCARD_TRANSMIT:
			if (SmartcardExtension->ReaderFunction[RDF_TRANSMIT] == NULL) {

				status = STATUS_NOT_SUPPORTED;
				break;
			}

   			//
			// Check if card is in the right status
			//
			if (SmartcardExtension->ReaderCapabilities.CurrentState != 
				SCARD_SPECIFIC) {

				status = STATUS_INVALID_DEVICE_STATE;
				break;
			}

            if (SmartcardExtension->IoRequest.RequestBufferLength < 
                sizeof(SCARD_IO_REQUEST)) {

                status = STATUS_INVALID_PARAMETER;
                break;             	
            }

			//
			// Check if the requested io-protocol matches 
			// the prev. seleced protocol
			//
			scardIoRequest = (PSCARD_IO_REQUEST)
				SmartcardExtension->IoRequest.RequestBuffer;

			if (scardIoRequest->dwProtocol != 
				SmartcardExtension->CardCapabilities.Protocol.Selected) {

				status = STATUS_INVALID_DEVICE_STATE;
				break;
			}

			SmartcardExtension->SmartcardRequest.BufferLength = 0;

#if defined(DEBUG) && defined(SMCLIB_NT)

            SmartcardExtension->PerfInfo->NumTransmissions += 1;
            if (SmartcardExtension->IoRequest.RequestBufferLength >= 
                sizeof(SCARD_IO_REQUEST)) {

	            bytesTransferred = 
                    SmartcardExtension->IoRequest.RequestBufferLength - 
                    sizeof(SCARD_IO_REQUEST);

                SmartcardExtension->PerfInfo->BytesSent +=
					bytesTransferred;
            }
            KeQueryTickCount(&SmartcardExtension->PerfInfo->TickStart);
#endif
			status = SmartcardExtension->ReaderFunction[RDF_TRANSMIT](
				SmartcardExtension
				);

#if defined(DEBUG) && defined(SMCLIB_NT)

            KeQueryTickCount(&SmartcardExtension->PerfInfo->TickEnd);

            if (*SmartcardExtension->IoRequest.Information >=
                sizeof(SCARD_IO_REQUEST)) {
             	
                SmartcardExtension->PerfInfo->BytesReceived +=
                    *SmartcardExtension->IoRequest.Information - 
                    sizeof(SCARD_IO_REQUEST);

				bytesTransferred += 
                    *SmartcardExtension->IoRequest.Information - 
                    sizeof(SCARD_IO_REQUEST);
            }

            SmartcardExtension->PerfInfo->IoTickCount.QuadPart += 
                SmartcardExtension->PerfInfo->TickEnd.QuadPart - 
                SmartcardExtension->PerfInfo->TickStart.QuadPart;

            if (FALSE) {

				ULONG timeInMilliSec = (ULONG) 
					((SmartcardExtension->PerfInfo->TickEnd.QuadPart - 
					 SmartcardExtension->PerfInfo->TickStart.QuadPart) *
					 KeQueryTimeIncrement() /
					 10000);

				// check for a transferrate of < 400 bps
				if (status == STATUS_SUCCESS &&
					timeInMilliSec > 0 && 
					bytesTransferred * 5 < timeInMilliSec * 2) {

					SmartcardDebug(
						DEBUG_PERF,
						("%s!SmartcardDeviceControl: Datarate for reader %*s was %3ld Baud (%3ld)\n",
						DRIVER_NAME,
						SmartcardExtension->VendorAttr.VendorName.Length,
						SmartcardExtension->VendorAttr.VendorName.Buffer,
						bytesTransferred * 1000 / timeInMilliSec,
						bytesTransferred)
						);             	
				}
            }
#endif
            break;

        case IOCTL_SMARTCARD_SWALLOW:
			if (SmartcardExtension->ReaderFunction[RDF_READER_SWALLOW] == NULL) {

				status = STATUS_NOT_SUPPORTED;
				break;
			}
			status = SmartcardExtension->ReaderFunction[RDF_READER_SWALLOW](
				SmartcardExtension
				);
            break;
            
#if DEBUG
		case IOCTL_SMARTCARD_DEBUG:
            //
            // Toggle debug bit
            //
            CurrentDebugLevel = 
                SmartcardGetDebugLevel();

			SmartcardSetDebugLevel( 
                SmartcardExtension->MinorIoControlCode ^ CurrentDebugLevel
                );
			break;
#endif

        default:
            //
            // check if the bit for a vendor ioctl is set and if the driver
            // has registered a callback function
            //
            if ((SmartcardExtension->MajorIoControlCode & CTL_CODE(0, 2048, 0, 0)) == 0 ||
                SmartcardExtension->ReaderFunction[RDF_IOCTL_VENDOR] == NULL) {
             	
				status = STATUS_INVALID_DEVICE_REQUEST;

            } else {
             	
                //
                // Call the driver if it has registered a callback for vendor calls
                //
			    status = SmartcardExtension->ReaderFunction[RDF_IOCTL_VENDOR](
				    SmartcardExtension
				    );
            }
            break;

    } // end switch

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\scrcp8t\scrcp8t.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    scrcp8t.h

Abstract:

    smartcard CP8 serial miniport defines and structures

Author:

    Klaus U. Schutz


Revision History:

--*/


#ifndef _SCRCP8T_
#define _SCRCP8T_

#define DRIVER_NAME "SCRCP8T"
#define SMARTCARD_POOL_TAG '8bCS'

#include <ntddk.h>
#include <ntddser.h>

#include "smclib.h"
#include "cp8tlog.h"

#define MAXIMUM_SERIAL_READERS	4
#define SMARTCARD_READ          SCARD_CTL_CODE(1000)
#define SMARTCARD_WRITE         SCARD_CTL_CODE(1001)

#define READ_INTERVAL_TIMEOUT_DEFAULT       1000
#define READ_TOTAL_TIMEOUT_CONSTANT_DEFAULT 3000

#define READ_INTERVAL_TIMEOUT_ATR           0
#define READ_TOTAL_TIMEOUT_CONSTANT_ATR     50

typedef struct _SERIAL_READER_CONFIG {

	//
	// flow control
	//
    SERIAL_HANDFLOW HandFlow;           

	//
	// special characters
	//
    SERIAL_CHARS SerialChars;

	//
	// read/write timeouts
	//
    SERIAL_TIMEOUTS Timeouts;           

	//
	// Baudrate for reader
	//
    SERIAL_BAUD_RATE BaudRate;          

	//
	// Stop bits, parity configuration
	//
    SERIAL_LINE_CONTROL LineControl;    

	//
	// Event serial reader uses to signal insert/removal
	//
    ULONG WaitMask;                     

} SERIAL_READER_CONFIG, *PSERIAL_READER_CONFIG;

//
// Define the reader specific portion of the smart card extension
//
typedef struct _READER_EXTENSION {

    //
    // DeviceObject pointer to serial port
    //
    PDEVICE_OBJECT ConnectedSerialPort;

	//
	// The dos device name of our smart card reader
	//
	UNICODE_STRING DosDeviceName;

    //
    // Used to synchronize access to the smartcard-extension
    //
	KSPIN_LOCK	SpinLock;

	//
	// This FileObject is needed to close the connection to the serial port.
	//
	PFILE_OBJECT SerialFileObject;

    //
    // This struct is used for CardTracking
    //
	struct {

		PIRP	Irp;

		KEVENT 	Event;

	    IO_STATUS_BLOCK IoStatus;

		KDPC	Dpc;

	} CardStatus;

    //
    // IoRequest to be send to serial driver
    //
	ULONG	SerialIoControlCode;

    //
    // Flag that indicates we're getting the ModemStatus (used in a DPC)
    //
	BOOLEAN	GetModemStatus;

    //
    // Variable used to receive the modem status
    //
	ULONG 	ModemStatus;

    //
    // Flag that indicates that the caller requests a power-down or a reset
    //
	BOOLEAN	PowerRequest;

	SERIAL_READER_CONFIG SerialConfigData;

} READER_EXTENSION, *PREADER_EXTENSION;

typedef struct _DEVICE_EXTENSION {

	SMARTCARD_EXTENSION SmartcardExtension;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Prototypes
//
NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

VOID
CP8Unload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
CP8CreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
CP8AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING SerialDeviceName
    );

VOID
CP8RemoveDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
CP8DeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
CP8CreateDevice(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING SmartcardDeviceName,
	IN PUNICODE_STRING SerialDeviceName
    );

NTSTATUS
CP8Initialize(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
CP8ConfigureSerialPort(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
CP8SerialIo(
	IN PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS 
CP8InitializeCardTracking(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS 
CP8StartCardTracking(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

VOID
CP8UpdateCardStatus(
    IN PKDPC EventDpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
CP8SerialCtsChanged(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
CP8Cleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
CP8ReaderPower(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
CP8SetProtocol(
   	PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
CP8Transmit(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CP8CardTracking(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\scrcp8t\scrcp8t.c ===
/*++


Copyright (c) 1996 Microsoft Corporation

Module Name:

    scrcp8t.c

Abstract:

    Author:

Environment:

    Kernel mode

Revision History :

    Nov. 1997 - 1.0 Release
    Jan. 1998 - Fix for vendor defined IOCTLs
                CP8SerialIo now write the whole data packet if GT is 0
                Support for higher data rates added

--*/
                                            
#include <stdio.h> 
#include "scrcp8t.h"

//
// We do not need these functions after init anymore
//
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, CP8AddDevice)
#pragma alloc_text(INIT, CP8CreateDevice)
#pragma alloc_text(INIT, CP8Initialize)

#if DBG
#pragma optimize ("", off)
#endif

NTSTATUS
CP8VendorIoctl(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,   
    IN  PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine is called at system initialization time to initialize
    this driver.

Arguments:

    DriverObject    - Supplies the driver object.
    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS          - We could initialize at least one device.
    STATUS_NO_SUCH_DEVICE   - We could not initialize even one device.

--*/
{
    RTL_QUERY_REGISTRY_TABLE paramTable[2];
    BOOLEAN detectReader = FALSE;
	ULONG i, noOfDevices = 0;
	UNICODE_STRING serialPort, parameters, parameterPath;
    NTSTATUS status;
    WCHAR buffer[128];

    SmartcardDebug(
        DEBUG_DRIVER,
	    ("%s!DriverEntry: Enter - %s %s\n", 
        DRIVER_NAME,
        __DATE__,
        __TIME__)
        )
        
    //
    // Initialize the Driver Object with driver's entry points
    //
    DriverObject->DriverUnload = CP8Unload;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = CP8CreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = CP8CreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = CP8Cleanup;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = CP8DeviceControl;

	RtlZeroMemory(
		paramTable,
		sizeof(paramTable)
		);

    paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name = L"Device0";
    paramTable[0].EntryContext = &serialPort;
    paramTable[0].DefaultType = REG_SZ;  
    paramTable[0].DefaultData = &serialPort;
    paramTable[0].DefaultLength = 0;

    parameterPath.MaximumLength = sizeof(buffer);
    parameterPath.Length = 0;
    parameterPath.Buffer = buffer;

    RtlCopyUnicodeString(
        &parameterPath,
        RegistryPath
        );

    RtlInitUnicodeString(
        &parameters,
        L"\\Parameters"
        );

    RtlAppendUnicodeStringToString(
        &parameterPath,
        &parameters
        );

	//
	// We now search the registry for DeviceN value
	//
	for (i = 0; i < MAXIMUM_SERIAL_READERS; i++) {

		UNICODE_STRING serialDeviceName;

		RtlInitUnicodeString(
			&serialDeviceName,
			L"\\Device\\Serial "
			);

  	    RtlInitUnicodeString(
		    &serialPort,
		    L"COM?"
		    );

        if (detectReader == FALSE) {
         	
            //
            // create string like DeviceN
            //
            paramTable[0].Name[6] = L'0' + (WCHAR) i;

            //
            // now try to find the entry in the registry
            //
	        status = RtlQueryRegistryValues(
	            RTL_REGISTRY_ABSOLUTE,
	            parameterPath.Buffer,
	            &paramTable[0],
	            NULL,
	            NULL
	            );

            if (status != STATUS_SUCCESS) {
             
                //
                // The entry does no exist in the registry
                //
                if (i > 0) {

                    break;
                }

                //
                // we found not even an entry for device0.
                // Try to detect readers. We assume now that 
                // the user has inserted a card into the reader
                // Actually we try to detect the card, not the reader
                //
                detectReader = TRUE;             	
            }
        }

        if (detectReader) {
         	
            serialPort.Buffer[3] = L'1' + (WCHAR) i;
        }

        //
        // create string like \Device\SerialN
        //
        serialDeviceName.Buffer[14] = serialPort.Buffer[3] - (WCHAR) 1;

		//
		// Now try to create a device and connect to the serial port
		//
		status = CP8AddDevice(
		    DriverObject, 
		    &serialDeviceName
		    );

		if (status == STATUS_SUCCESS) {

			//
			// We have successfully created a device
			//
			PDEVICE_OBJECT deviceObject = DriverObject->DeviceObject;
			PDEVICE_EXTENSION deviceExtension = deviceObject->DeviceExtension;
			PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;

			//
			// Save the serial port number this device is connected to
			//
			smartcardExtension->ReaderCapabilities.Channel = 
                serialPort.Buffer[3] - L'0';

            if (detectReader) {
                //
                // We now assume that the user has inserted a smart card 
                // and we try to get an ATR in order to figure out if there
                // is really a reader connected to this port
                //
                smartcardExtension->IoRequest.ReplyBuffer = NULL;
                smartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;
                status = CP8ReaderPower(smartcardExtension);

                if (status == STATUS_SUCCESS) {

                    //
                    // create an entry in the registry
                    //
                    paramTable[0].Name[6] = L'0' + (WCHAR) noOfDevices;

                    RtlWriteRegistryValue(
                        RTL_REGISTRY_ABSOLUTE,
                        parameterPath.Buffer,
                        paramTable[0].Name,
                        REG_SZ,
                        serialPort.Buffer,
                        serialPort.Length
                        ); 

               		SmartcardLogError(
			            DriverObject,
			            CP8_NEW_DEVICE_ADDED,
			            &serialPort,
			            status
			            );


                } else {
                 	
                    //
                    // We were unable to get an ATR from the card.
                    // So remove the device again.
                    //
                    CP8RemoveDevice(deviceObject);
                }
            }

            if (status == STATUS_SUCCESS) {
             	
    			noOfDevices++;
            }
 		} 
	}

    if (noOfDevices == 0) {

		SmartcardLogError(
			DriverObject,
			CP8_NO_SUCH_DEVICE,
			NULL,
			status
			);

        return STATUS_NO_SUCH_DEVICE;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
CP8AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING SerialDeviceName
    )
/*++

Routine Description:

    This is the add-device routine for the miniport.

Arguments:

    DriverObject 		- a pointer to the driver object for this device

	SerialDeviceName 	- The device name of the serial port to attach to 

Return Value:

    NT_STATUS

--*/

{
	UNICODE_STRING smartcardDeviceName, deviceNo, device;
	WCHAR buffer[32];
	ULONG i;
	NTSTATUS status;

	for (i = 0; i < MAXIMUM_SERIAL_READERS; i++) {

		//
		// Build a device name for the smart card reader
		// \Device\BullCP8TN (N is the 0 based device number)
		//
		smartcardDeviceName.Buffer = buffer;
		smartcardDeviceName.MaximumLength = sizeof(buffer);
		smartcardDeviceName.Length = 0;

		RtlInitUnicodeString(
			&device,
			L"\\Device\\BullCP8T"
			);

		RtlCopyUnicodeString(
			&smartcardDeviceName,
			&device
			);

		deviceNo.Buffer = 
			smartcardDeviceName.Buffer + 
			smartcardDeviceName.Length / sizeof(WCHAR);

		deviceNo.MaximumLength = 2 * sizeof(WCHAR);
		deviceNo.Length = 0;

		RtlIntegerToUnicodeString(
			i,
			10,
			&deviceNo
			);

		smartcardDeviceName.Length += deviceNo.Length;

		//
		// Try to create a device with the just created device name
		// It is possible that a smart card device with this name
		// already exists from a previous call.
		// It is possible to have up to 4 devices in a system
		//
	    status = CP8CreateDevice(
	    	DriverObject, 
	    	&smartcardDeviceName,
			SerialDeviceName
	    	);

		if (status == STATUS_SUCCESS) {

			PDEVICE_OBJECT deviceObject = DriverObject->DeviceObject;
		    PDEVICE_EXTENSION deviceExtension = deviceObject->DeviceExtension;
			PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;

            // this is a list of our supported data rates
            static ULONG dataRatesSupported[] = { 9600, 19200 };

			//
			// Initialize the vendor information
			//
			strcpy(
				deviceExtension->SmartcardExtension.VendorAttr.VendorName.Buffer,
				"Bull"
				);

			deviceExtension->SmartcardExtension.VendorAttr.VendorName.Length = 
				strlen(deviceExtension->SmartcardExtension.VendorAttr.VendorName.Buffer);

			strcpy(
				deviceExtension->SmartcardExtension.VendorAttr.IfdType.Buffer,
				"CP8 Transac"
				);

			deviceExtension->SmartcardExtension.VendorAttr.IfdType.Length = 
				strlen(deviceExtension->SmartcardExtension.VendorAttr.IfdType.Buffer);

 			smartcardExtension->VendorAttr.UnitNo = i;

            //
            // Set reader info
            //

            //
            // Clk frequency in KHz encoded as little endian integer
            //
            smartcardExtension->ReaderCapabilities.CLKFrequency.Default = 3571;
            smartcardExtension->ReaderCapabilities.CLKFrequency.Max = 3571;

            smartcardExtension->ReaderCapabilities.DataRate.Default = 9600;
            smartcardExtension->ReaderCapabilities.DataRate.Max = 19200;

            smartcardExtension->ReaderCapabilities.DataRatesSupported.List = 
                dataRatesSupported;
            smartcardExtension->ReaderCapabilities.DataRatesSupported.Entries = 
                sizeof(dataRatesSupported) / sizeof(dataRatesSupported[0]);

            smartcardExtension->ReaderCapabilities.MaxIFSD = 254;
			break;
		}

		if (status != STATUS_OBJECT_NAME_COLLISION) {
			
			//
			// The corresponding serial port is already in use
			// So don't try to create a smart card device with a different name
			//
			break;
		}
	}

    return status;
}

NTSTATUS
CP8SerialCallComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )
/*++

Routine Description:
	Completion routine for an Irp sent to the serial driver. 
    It sets only an event that we can use to wait for.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);

    Irp->IoStatus.Information = 0;

    if (Irp->Cancel) {

        Irp->IoStatus.Status = STATUS_CANCELLED;

    } else {
     	
        Irp->IoStatus.Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    KeSetEvent (Event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
CP8CreateDevice(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING SmartcardDeviceName,
	IN PUNICODE_STRING SerialDeviceName
    )
/*++

Routine Description:

    This routine creates an object for the physical device specified and
    sets up the deviceExtension.

Arguments:

Return Value:

    NTSTATUS

--*/
{
    PFILE_OBJECT serialFileObject;
	PDEVICE_OBJECT deviceObject, serialDeviceObject;
    PDEVICE_EXTENSION deviceExtension;
	NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack;
    IO_STATUS_BLOCK ioStatusBlock;
    KEVENT Event;
    PIRP irp;
	ULONG i;

    status = IoGetDeviceObjectPointer( 
    	SerialDeviceName,
        FILE_ALL_ACCESS,
        &serialFileObject,
        &serialDeviceObject
        );

    if (!NT_SUCCESS(status)) {

        UNICODE_STRING comPortNumber;
        WCHAR buffer[2];

        // Extract the com-port-number
        comPortNumber.Buffer = buffer;
        comPortNumber.Length = 2;
        comPortNumber.MaximumLength = sizeof(buffer);

        comPortNumber.Buffer[0] = SerialDeviceName->Buffer[14] + (WCHAR) 1;

        // Write an event-log msg that this com port is not available
		SmartcardLogError(
			DriverObject,
			CP8_CANT_CONNECT_TO_SERIAL_PORT,
			&comPortNumber,
			status
			);

        return status;
    }

    status = IoCreateDevice(
    	DriverObject,
        sizeof(DEVICE_EXTENSION),
        SmartcardDeviceName,
        FILE_DEVICE_SMARTCARD,
        0,
#if DBG
		FALSE,
#else
        TRUE,
#endif
        &deviceObject
        );

    if (!NT_SUCCESS(status)) {

	    ObDereferenceObject(
	    	serialFileObject
	    	);

		SmartcardLogError(
			DriverObject,
			CP8_CANT_CREATE_DEVICE,
			SmartcardDeviceName,
			status
			);

        return status;
    }

    deviceExtension = deviceObject->DeviceExtension;

    deviceObject->Flags = deviceObject->Flags | DO_BUFFERED_IO;

    RtlZeroMemory(
    	deviceExtension,
    	sizeof(PDEVICE_EXTENSION)
    	);

	//
	// Allocate data struct space for smart card reader
	//
	deviceExtension->SmartcardExtension.ReaderExtension = ExAllocatePool(
		NonPagedPool,
		sizeof(READER_EXTENSION)
		);

	if (deviceExtension->SmartcardExtension.ReaderExtension == NULL) {

		SmartcardLogError(
			DriverObject,
			CP8_NO_MEMORY,
			NULL,
			0
			);

		status = STATUS_INSUFFICIENT_RESOURCES;
	}

	if (status == STATUS_SUCCESS) {

		RtlZeroMemory(
			deviceExtension->SmartcardExtension.ReaderExtension,
			sizeof(READER_EXTENSION)
			);

        //
        // Write the version of the lib we use to the smartcard extension
        //
        deviceExtension->SmartcardExtension.Version = SMCLIB_VERSION;

		//
		// Now let the lib allocate the buffer for data transmission
		// We can either tell the lib how big the buffer should be
		// by assigning a value to BufferSize or let the lib
		// allocate the default size
		//
		status = SmartcardInitialize(
			&deviceExtension->SmartcardExtension
			);
	}

	if (status == STATUS_SUCCESS) {

		//
		// Set up call back functions 
		//
		deviceExtension->SmartcardExtension.ReaderFunction[RDF_TRANSMIT] = 
			CP8Transmit;
		deviceExtension->SmartcardExtension.ReaderFunction[RDF_SET_PROTOCOL] = 
			CP8SetProtocol;
		deviceExtension->SmartcardExtension.ReaderFunction[RDF_CARD_POWER] = 
			CP8ReaderPower;
		deviceExtension->SmartcardExtension.ReaderFunction[RDF_CARD_TRACKING] = 
			CP8CardTracking;
		deviceExtension->SmartcardExtension.ReaderFunction[RDF_IOCTL_VENDOR] = 
			CP8VendorIoctl;
		//
		// Save deviceObject
		//
		deviceExtension->SmartcardExtension.OsData->DeviceObject = 
			deviceObject;

		//
		// Save the deviceObject for the connected serial port
		//
		deviceExtension->SmartcardExtension.ReaderExtension->ConnectedSerialPort = 
			serialDeviceObject;

		//
		// The fileObject is used in the unload function for dereferencing
		//
		deviceExtension->SmartcardExtension.ReaderExtension->SerialFileObject = 
			serialFileObject;

	    //
	    // Configure serial reader
	    //
	    status = CP8Initialize(
	    	&deviceExtension->SmartcardExtension
	    	);

		if (NT_SUCCESS(status)) {

			//
			// Create a symbolic link 
			//
			status = SmartcardCreateLink(
				&deviceExtension->SmartcardExtension.ReaderExtension->DosDeviceName,
				SmartcardDeviceName
				);
		}
	}

	if (status != STATUS_SUCCESS) {

		ExFreePool(
			deviceExtension->SmartcardExtension.ReaderExtension
			);

		SmartcardExit(
			&deviceExtension->SmartcardExtension
			);
																		    
        IoDeleteDevice(
        	deviceObject
        	);

	    ObDereferenceObject(
	    	serialFileObject
	    	);

	} else {
		
	    SmartcardDebug(
	        DEBUG_INFO,
	        ("%s!CP8CreateDevice: Device %ws created\n", 
            DRIVER_NAME,
	        deviceExtension->SmartcardExtension.ReaderExtension->DosDeviceName.Buffer)
	        );
	}

	return status;
}                                          

NTSTATUS
CP8Initialize(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )

/*++

Routine Description:

    This routine reads the default configuraton values for this device.

Arguments:

    DriverObject - Pointer to driver object created by system.

Return Value:

    none

--*/

{
	PREADER_EXTENSION readerExtension = SmartcardExtension->ReaderExtension;
	NTSTATUS status;

    readerExtension->SerialConfigData.WaitMask = SERIAL_EV_CTS;
    readerExtension->SerialConfigData.BaudRate.BaudRate = 9600;

    readerExtension->SerialConfigData.LineControl.StopBits = STOP_BITS_2;
    readerExtension->SerialConfigData.LineControl.Parity = EVEN_PARITY;
    readerExtension->SerialConfigData.LineControl.WordLength = SERIAL_DATABITS_8;

    //
    // set timeouts
    //
    readerExtension->SerialConfigData.Timeouts.ReadIntervalTimeout = 
        READ_INTERVAL_TIMEOUT_DEFAULT;
    readerExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant = 
        READ_TOTAL_TIMEOUT_CONSTANT_DEFAULT;
    readerExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier = 0;

    //
    // set special characters
    //
	readerExtension->SerialConfigData.SerialChars.ErrorChar = 0;
    readerExtension->SerialConfigData.SerialChars.EofChar = 0;
    readerExtension->SerialConfigData.SerialChars.EventChar = 0;
    readerExtension->SerialConfigData.SerialChars.XonChar = 0;
    readerExtension->SerialConfigData.SerialChars.XoffChar = 0;
    readerExtension->SerialConfigData.SerialChars.BreakChar = 0xFF;

    //
    // Set handflow
    //
    readerExtension->SerialConfigData.HandFlow.XonLimit = 0;
    readerExtension->SerialConfigData.HandFlow.XoffLimit = 0;
    readerExtension->SerialConfigData.HandFlow.FlowReplace = SERIAL_XOFF_CONTINUE ;
    readerExtension->SerialConfigData.HandFlow.ControlHandShake = 0;

    //
    // Now setup information in our deviceExtension
    //
    SmartcardExtension->ReaderCapabilities.CurrentState = (ULONG) SCARD_UNKNOWN;

	//
	// This reader supports T=0 and T=1
	//
    SmartcardExtension->ReaderCapabilities.SupportedProtocols = 
        SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;

    SmartcardExtension->ReaderCapabilities.MechProperties = 0;

    status = CP8ConfigureSerialPort(
    	SmartcardExtension
    	);

	if (status == STATUS_SUCCESS) {

		status = CP8InitializeCardTracking(
			SmartcardExtension
			);
	}

	return status;
}

NTSTATUS
CP8ConfigureSerialPort(
    PSMARTCARD_EXTENSION SmartcardExtension
    )

/*++

Routine Description:

    This routine will appropriately configure the serial port.
    It makes synchronous calls to the serial port.

Arguments:

    SmartcardExtension - Pointer to smart card struct

Return Value:

    NTSTATUS

--*/

{
    PSERIAL_READER_CONFIG configData = &SmartcardExtension->ReaderExtension->SerialConfigData;
    NTSTATUS status = STATUS_SUCCESS;
    USHORT i;
	PUCHAR request = SmartcardExtension->SmartcardRequest.Buffer;
    
	SmartcardExtension->SmartcardRequest.BufferLength = 0;
	SmartcardExtension->SmartcardReply.BufferLength = 
		SmartcardExtension->SmartcardReply.BufferSize;

	for (i = 0; NT_SUCCESS(status); i++) {

        switch (i) {

			case 0:
			    //
			    // Set up baudrate for the CP8 reader
			    //
				SmartcardExtension->ReaderExtension->SerialIoControlCode =
					IOCTL_SERIAL_SET_BAUD_RATE;

			    SmartcardExtension->SmartcardRequest.Buffer = 
			    	(PUCHAR) &configData->BaudRate;

				SmartcardExtension->SmartcardRequest.BufferLength =
			    	sizeof(SERIAL_BAUD_RATE);

				break;

	        case 1:
	            //
	            // Set up line control parameters
	            //
				SmartcardExtension->ReaderExtension->SerialIoControlCode =
			        IOCTL_SERIAL_SET_LINE_CONTROL;

			    SmartcardExtension->SmartcardRequest.Buffer = 
	            	(PUCHAR) &configData->LineControl;

				SmartcardExtension->SmartcardRequest.BufferLength =
	            	sizeof(SERIAL_LINE_CONTROL);
	            break;

	        case 2:
	            //
	            // Set serial special characters
	            //
				SmartcardExtension->ReaderExtension->SerialIoControlCode =
			        IOCTL_SERIAL_SET_CHARS;

		    	SmartcardExtension->SmartcardRequest.Buffer = 
	            	(PUCHAR) &configData->SerialChars;

				SmartcardExtension->SmartcardRequest.BufferLength =
	            	sizeof(SERIAL_CHARS);
	            break;

	        case 3:
	            //
	            // Set up timeouts
	            //
				SmartcardExtension->ReaderExtension->SerialIoControlCode =
		     	   IOCTL_SERIAL_SET_TIMEOUTS;

			    SmartcardExtension->SmartcardRequest.Buffer =
	            	(PUCHAR) &configData->Timeouts;

				SmartcardExtension->SmartcardRequest.BufferLength =
	            	sizeof(SERIAL_TIMEOUTS);
	            break;

	        case 4:
	            //
	            // Set flowcontrol and handshaking
	            //
				SmartcardExtension->ReaderExtension->SerialIoControlCode =
			        IOCTL_SERIAL_SET_HANDFLOW;

			    SmartcardExtension->SmartcardRequest.Buffer =
	            	(PUCHAR) &configData->HandFlow;

				SmartcardExtension->SmartcardRequest.BufferLength =
	            	sizeof(SERIAL_HANDFLOW);
	            break;

	        case 5:
	            //
	            // Set break off
	            //
				SmartcardExtension->ReaderExtension->SerialIoControlCode =
			        IOCTL_SERIAL_SET_BREAK_OFF;
	            break;

			case 6:
		        SmartcardExtension->ReaderExtension->SerialIoControlCode = 
		        	IOCTL_SERIAL_SET_DTR;
				break;

			case 7:
			    return STATUS_SUCCESS;
        }

	    status = CP8SerialIo(
			SmartcardExtension
	        );

		//
		// restore pointer to original request buffer
		//
		SmartcardExtension->SmartcardRequest.Buffer = request;
    }

    return status;
}

NTSTATUS
CP8CreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system when the device is opened or closed.

Arguments:

    DeviceObject 	- Pointer to device object for this miniport
    Irp 			- IRP involved.

Return Value:

    STATUS_SUCCESS.

--*/

{
#if DBG
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
	PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    if (irpStack->MajorFunction == IRP_MJ_CREATE) {

	    SmartcardDebug(
	        DEBUG_DRIVER,
	        ("%s!CP8CreateClose: Device %ws opened\n", 
            DRIVER_NAME,
	        smartcardExtension->ReaderExtension->DosDeviceName.Buffer)
	        );
		
	} else {

	    SmartcardDebug(
	        DEBUG_DRIVER,
	        ("%s!CP8CreateClose: Device %ws closed\n", 
            DRIVER_NAME,
	        smartcardExtension->ReaderExtension->DosDeviceName.Buffer)
	        );
    }
#endif
	Irp->IoStatus.Information = 0;
	Irp->IoStatus.Status = STATUS_SUCCESS;

    return STATUS_SUCCESS;
}

NTSTATUS
CP8Cancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system
    when the irp should be cancelled

Arguments:

    DeviceObject 	- Pointer to device object for this miniport
    Irp 			- IRP involved.

Return Value:

    STATUS_CANCELLED

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
	PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!CP8Cancel: Enter\n",
        DRIVER_NAME)
        );

    ASSERT(Irp == smartcardExtension->OsData->NotificationIrp);

    smartcardExtension->OsData->NotificationIrp->CancelRoutine = NULL;
	smartcardExtension->OsData->NotificationIrp->IoStatus.Information = 0;
	smartcardExtension->OsData->NotificationIrp->IoStatus.Status = STATUS_CANCELLED;

    IoReleaseCancelSpinLock(
        Irp->CancelIrql
        );

	SmartcardDebug(
		DEBUG_DRIVER,
		("%s!CP8Cancel: Completing wait for Irp = %lx\n",
        DRIVER_NAME,
        smartcardExtension->OsData->NotificationIrp)
		);

	IoCompleteRequest(
		smartcardExtension->OsData->NotificationIrp,
		IO_NO_INCREMENT
		);

  	smartcardExtension->OsData->NotificationIrp = NULL;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!CP8Cancel: Exit\n",
        DRIVER_NAME)
        );

    return STATUS_CANCELLED;
}

NTSTATUS
CP8Cleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system when the calling thread terminates

Arguments:

    DeviceObject 	- Pointer to device object for this miniport
    Irp 			- IRP involved.

Return Value:

    STATUS_CANCELLED

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
	PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
	NTSTATUS status = STATUS_SUCCESS;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!CP8Cleanup: Enter\n",
        DRIVER_NAME)
        );

    if (smartcardExtension->OsData->NotificationIrp) {

        //
        // We need to complete the notification irp
        //
        IoAcquireCancelSpinLock(
            &(Irp->CancelIrql)
            );

        CP8Cancel(
            DeviceObject,
            smartcardExtension->OsData->NotificationIrp
            );
    }

	SmartcardDebug(
		DEBUG_DRIVER,
		("%s!CP8Cleanup: Completing IRP %lx\n",
        DRIVER_NAME,
        Irp)
		);

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

	IoCompleteRequest(
		Irp,
		IO_NO_INCREMENT
		);

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!CP8Cleanup: Exit\n",
        DRIVER_NAME)
        );

    return STATUS_SUCCESS;
}

VOID
CP8RemoveDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
{
	PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
	PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;

	SmartcardDebug(
	    DEBUG_INFO,
	    ("%s!CP8RemoveDevice: Unloading device %ws\n", 
        DRIVER_NAME,
	    smartcardExtension->ReaderExtension->DosDeviceName.Buffer)
	    );

	//
	// Tell the serial driver that we don't need the 
	// call back (IoCompletion) anymore
	//
	smartcardExtension->ReaderExtension->SerialConfigData.WaitMask = 0;

	*(PULONG) smartcardExtension->SmartcardRequest.Buffer = 
		smartcardExtension->ReaderExtension->SerialConfigData.WaitMask;

	smartcardExtension->SmartcardRequest.BufferLength = 
		sizeof(ULONG);

	smartcardExtension->ReaderExtension->SerialIoControlCode = 
		IOCTL_SERIAL_SET_WAIT_MASK;

	//
	// We don't expect to get bytes back
	//
	smartcardExtension->SmartcardReply.BufferLength = 0;

	CP8SerialIo(
		smartcardExtension
		);

	//
	// We do not longet need the reference to the serial reader
	//
	ObDereferenceObject(
	    smartcardExtension->ReaderExtension->SerialFileObject
	    );

	//
	// Delete the symbolic link of the smart card reader
	//
	IoDeleteSymbolicLink(
	    &smartcardExtension->ReaderExtension->DosDeviceName
	    );

	//
	// Let the lib free the send/receive buffers
	//
	SmartcardExit(
		smartcardExtension
		);

	// 
	// Free all allocated buffer
	// 
	ExFreePool(
		smartcardExtension->ReaderExtension->DosDeviceName.Buffer
		);

	ExFreePool(
		smartcardExtension->ReaderExtension
		);

	//
	// Delete the device from the system 
	//
	IoDeleteDevice(
	    DeviceObject
	    );
}

VOID
CP8Unload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    The driver unload routine.  This is called by the I/O system
    when the device is unloaded from memory.

Arguments:

    DriverObject - Pointer to driver object created by system.

Return Value:

    STATUS_SUCCESS.

--*/
{
    PDEVICE_OBJECT deviceObject = DriverObject->DeviceObject;
	NTSTATUS status;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!CP8Unload: Enter\n",
        DRIVER_NAME)
        );

	do {

        CP8RemoveDevice(deviceObject);

	} while(deviceObject = DriverObject->DeviceObject);

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!CP8Unload: Exit\n",
        DRIVER_NAME)
        );
}

NTSTATUS
CP8SerialIo(
	IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine sends IOCTL's to the serial driver. It waits on for their
    completion, and then returns.

    Arguments:

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;
	ULONG currentByte = 0;

    //
    // Check if the buffers are large enough
    //
    ASSERT(SmartcardExtension->SmartcardReply.BufferLength <= 
        SmartcardExtension->SmartcardReply.BufferSize);

    ASSERT(SmartcardExtension->SmartcardRequest.BufferLength <= 
        SmartcardExtension->SmartcardRequest.BufferSize);

	if (SmartcardExtension->SmartcardReply.BufferLength > 
        SmartcardExtension->SmartcardReply.BufferSize ||
        SmartcardExtension->SmartcardRequest.BufferLength >
        SmartcardExtension->SmartcardRequest.BufferSize) {

		SmartcardLogError(
			SmartcardExtension->OsData->DeviceObject,
			CP8_BUFFER_TOO_SMALL,
			NULL,
			0
			);

		return STATUS_BUFFER_TOO_SMALL;
	}

	do {

	    IO_STATUS_BLOCK ioStatus;
	    KEVENT event;
    	PIRP irp;
	    PIO_STACK_LOCATION irpNextStack;
		PUCHAR requestBuffer = NULL;
        PUCHAR replyBuffer = SmartcardExtension->SmartcardReply.Buffer;
		ULONG requestBufferLength = SmartcardExtension->SmartcardRequest.BufferLength;
        ULONG replyBufferLength = SmartcardExtension->SmartcardReply.BufferLength;

	    KeInitializeEvent(
	    	&event, 
	    	NotificationEvent, 
	    	FALSE
	    	);

		if (SmartcardExtension->ReaderExtension->SerialIoControlCode == 
			SMARTCARD_WRITE) {
            
            if (SmartcardExtension->CardCapabilities.GT != 0) {
             	
			    //
			    // If the guardtime isn't 0 and we write data to the smart card 
                // we only write byte by byte, because we have to insert a delay 
                // between every sent byte     
			    //
			    requestBufferLength = 1;
            }

			requestBuffer = 
				&SmartcardExtension->SmartcardRequest.Buffer[currentByte++];

            replyBuffer = NULL;
            replyBufferLength = 0;

		} else {
			
			requestBuffer = 
				(requestBufferLength ? 
				 SmartcardExtension->SmartcardRequest.Buffer : NULL);
		}

		// Build irp to be sent to serial driver
	    irp = IoBuildDeviceIoControlRequest(
			SmartcardExtension->ReaderExtension->SerialIoControlCode,
	    	SmartcardExtension->ReaderExtension->ConnectedSerialPort, 
			requestBuffer,
			requestBufferLength,
            replyBuffer,
            replyBufferLength,
	        FALSE,
	        &event,
	        &ioStatus
	        );

        ASSERT(irp != NULL);

	    if (irp == NULL) {
                                                       
	        return STATUS_INSUFFICIENT_RESOURCES;
	    }

	    irpNextStack = IoGetNextIrpStackLocation(irp);

		switch (SmartcardExtension->ReaderExtension->SerialIoControlCode) {

            //
            // The serial driver trasfers data from/to irp->AssociatedIrp.SystemBuffer
            //
			case SMARTCARD_WRITE:
                //
                // Since we 'manually' change parameters, the io-manager
                // does not really know if this is an input or an ouput operation
                // unless the reply buffer is 0. We do the assertion here, because
                // if the reply buffer is not NULL, the io-manager will copy 
                // data back to the reply buffer.
                //
                ASSERT(replyBuffer == NULL);
                irpNextStack->MajorFunction = IRP_MJ_WRITE;
				irpNextStack->Parameters.Write.Length = requestBufferLength;
                irpNextStack->Parameters.Write.ByteOffset.QuadPart = 0;
				break;

			case SMARTCARD_READ:
				irpNextStack->MajorFunction = IRP_MJ_READ;
				irpNextStack->Parameters.Read.Length = replyBufferLength;
                irpNextStack->Parameters.Read.ByteOffset.QuadPart = 0;
				break;
		}

	    status = IoCallDriver(
	    	SmartcardExtension->ReaderExtension->ConnectedSerialPort, 
	    	irp
	    	);

	    if (status == STATUS_PENDING) {

	        KeWaitForSingleObject(
	        	&event, 
	        	Suspended, 
	        	KernelMode, 
	        	FALSE, 
	        	NULL
	        	);

		    status = ioStatus.Status;

            // save the number of bytes received
            SmartcardExtension->SmartcardReply.BufferLength = 
                ioStatus.Information;
		}

        // Check if we have to write more bytes to the reader
		if (SmartcardExtension->ReaderExtension->SerialIoControlCode ==
            SMARTCARD_WRITE &&
			SmartcardExtension->CardCapabilities.GT != 0 &&
            currentByte < 
			SmartcardExtension->SmartcardRequest.BufferLength) {

            // Now wait the required guard time
            KeStallExecutionProcessor(SmartcardExtension->CardCapabilities.GT);

			status = STATUS_MORE_PROCESSING_REQUIRED;
        }

	} while (status == STATUS_MORE_PROCESSING_REQUIRED);

	return status;
}

NTSTATUS 
CP8InitializeCardTracking(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
/*++

Routine Description:

    This routine initialized card tracking. It calls the serial driver to 
	set a wait mask for CTS tracking. After that it installs a completion
	routine to be called when CTS changes state.

Arguments:

	SmartcardExtension - Pointer to our smartcard structure

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;

    KeInitializeEvent(
    	&SmartcardExtension->ReaderExtension->CardStatus.Event, 
    	NotificationEvent, 
    	FALSE
    	);

	//
	// Send a wait mask to the serial driver.
	// This call only sets the wait mask. 
	// We want to be informed when CTS changes its state
	//
    SmartcardExtension->ReaderExtension->CardStatus.Irp = IoBuildDeviceIoControlRequest(
    	IOCTL_SERIAL_SET_WAIT_MASK,
    	SmartcardExtension->ReaderExtension->ConnectedSerialPort, 
        &SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask,
        sizeof(SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask),
        NULL,
		0,
        FALSE,
        &(SmartcardExtension->ReaderExtension->CardStatus.Event),
        &(SmartcardExtension->ReaderExtension->CardStatus.IoStatus)
        );

    if (SmartcardExtension->ReaderExtension->CardStatus.Irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(
    	SmartcardExtension->ReaderExtension->ConnectedSerialPort, 
		SmartcardExtension->ReaderExtension->CardStatus.Irp,
    	);

	if (status == STATUS_SUCCESS) {

		KIRQL oldIrql;
        ULONG ioctlCode = IOCTL_SERIAL_WAIT_ON_MASK | 0x03;

		//
		// Now tell the serial driver that we want to be informed
		// when CTS changes its state.
        // Changing the lowest two bits tells IoBuildDeviceIoControlRequest
        // NOT to allocate a system buffer for the I/O operation.
        // We don't need a system buffer since we use our own buffers.
		//
	    SmartcardExtension->ReaderExtension->CardStatus.Irp = IoBuildDeviceIoControlRequest(
	    	ioctlCode,
	    	SmartcardExtension->ReaderExtension->ConnectedSerialPort, 
	        &SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask,
	        sizeof(SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask),
	        &SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask,
	        sizeof(SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask),
	        FALSE,
	        &SmartcardExtension->ReaderExtension->CardStatus.Event,
	        &SmartcardExtension->ReaderExtension->CardStatus.IoStatus
	        );

	    if (SmartcardExtension->ReaderExtension->CardStatus.Irp == NULL) {

	        return STATUS_INSUFFICIENT_RESOURCES;
	    }
        
        //
        // We simulate a callback now that triggers the card supervision
        //
        CP8SerialCtsChanged(
            SmartcardExtension->OsData->DeviceObject,
            SmartcardExtension->ReaderExtension->CardStatus.Irp,
            SmartcardExtension
            );

		status = STATUS_SUCCESS;
	}

    return status;                                        
}	

NTSTATUS 
CP8SerialCtsChanged(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine is called when CTS changes its status, which means a card was
	inserted or removed. 

Arguments:

Return Value:

    NTSTATUS

--*/
{
    UNREFERENCED_PARAMETER(DeviceObject);

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!CP8SerialCtsChanged: Enter\n",
        DRIVER_NAME)
        );

	if (SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask) {

	    NTSTATUS status;

	    //
	    // Only inform the user of a card insertion/removal event 
	    // if this function isn't called due to a power down - power up cycle
	    //
	    if (SmartcardExtension->ReaderExtension->PowerRequest == FALSE &&
		    SmartcardExtension->OsData->NotificationIrp) {

		    KIRQL oldIrql;
		    //
		    // If the user had setup an irp for event tracking complete that irp now
		    //
            IoAcquireCancelSpinLock(
                &oldIrql
                );
            
            IoSetCancelRoutine(
                SmartcardExtension->OsData->NotificationIrp,
                NULL
                );
            
            IoReleaseCancelSpinLock(
                oldIrql
                );        
            
		    SmartcardExtension->OsData->NotificationIrp->IoStatus.Information = 0;
		    SmartcardExtension->OsData->NotificationIrp->IoStatus.Status = STATUS_SUCCESS;

		    SmartcardDebug(
			    DEBUG_DRIVER,
			    ("%s!CP8SerialCtsChanged: Completing IRP %lx\n", 
                DRIVER_NAME,
			    SmartcardExtension->OsData->NotificationIrp);
			    );

		    IoCompleteRequest(
			    SmartcardExtension->OsData->NotificationIrp,
			    IO_NO_INCREMENT
			    );

		    SmartcardExtension->OsData->NotificationIrp = NULL;
	    }

	    if (SmartcardExtension->ReaderExtension->GetModemStatus) {

		    //
		    // This function requested the modem status previously.
            // As part of the io-completion, this function is then
            // called again. When we're here we can read the actual 
            // modem-status to figure out if the card is in the reader
		    //

		    PIO_STACK_LOCATION irpStack;
		    KIRQL oldIrql;

		    KeAcquireSpinLock(
			    &SmartcardExtension->ReaderExtension->SpinLock,
			    &oldIrql
			    );

		    if (SmartcardExtension->ReaderExtension->ModemStatus & SERIAL_CTS_STATE) {

			    //
			    // Card is inserted
			    //
	            SmartcardExtension->ReaderCapabilities.CurrentState = 
	        	    SCARD_SWALLOWED;

			    SmartcardExtension->CardCapabilities.Protocol.Selected = 
				    SCARD_PROTOCOL_UNDEFINED;

			    SmartcardDebug(
				    DEBUG_DRIVER,
				    ("%s!CP8SerialCtsChanged: Smart card inserted\n",
                    DRIVER_NAME)
				    );

		    } else {
			    
			    //
			    // Card is removed
			    // 
                SmartcardExtension->CardCapabilities.ATR.Length = 0;

	            SmartcardExtension->ReaderCapabilities.CurrentState = 
	        	    SCARD_ABSENT;

			    SmartcardExtension->CardCapabilities.Protocol.Selected = 
				    SCARD_PROTOCOL_UNDEFINED;

			    SmartcardDebug(
				    DEBUG_DRIVER,
				    ("%s!CP8SerialCtsChanged: Smart card removed\n",
                    DRIVER_NAME)
				    );
		    }

		    KeReleaseSpinLock(
			    &SmartcardExtension->ReaderExtension->SpinLock,
			    oldIrql
			    );

		    irpStack = IoGetNextIrpStackLocation(
			    SmartcardExtension->ReaderExtension->CardStatus.Irp
			    );

		    irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
	        irpStack->MinorFunction = 0UL;
	        irpStack->Parameters.DeviceIoControl.OutputBufferLength = 
	            sizeof(SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask);
	        irpStack->Parameters.DeviceIoControl.IoControlCode = 
	    	    IOCTL_SERIAL_WAIT_ON_MASK;

		    SmartcardExtension->ReaderExtension->CardStatus.Irp->AssociatedIrp.SystemBuffer = 
	            &SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask;

		    SmartcardExtension->ReaderExtension->GetModemStatus = FALSE;

		    SmartcardDebug(
			    DEBUG_DRIVER,
			    ("%s!CP8SerialCtsChanged: IOCTL_SERIAL_WAIT_ON_MASK\n",
                DRIVER_NAME)
			    );

	    } else {

		    //
		    // Setup call for device control to get modem status.
		    // The CTS signal tells us if the card is inserted or removed. 
		    // CTS is high if the card is inserted.
		    //
		    PIO_STACK_LOCATION irpStack;

		    irpStack = IoGetNextIrpStackLocation(
			    SmartcardExtension->ReaderExtension->CardStatus.Irp
			    );

		    irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
	        irpStack->MinorFunction = 0UL;
	        irpStack->Parameters.DeviceIoControl.OutputBufferLength = 
	    	    sizeof(SmartcardExtension->ReaderExtension->ModemStatus);
	        irpStack->Parameters.DeviceIoControl.IoControlCode = 
	    	    IOCTL_SERIAL_GET_MODEMSTATUS;

		    SmartcardExtension->ReaderExtension->CardStatus.Irp->AssociatedIrp.SystemBuffer = 
			    &SmartcardExtension->ReaderExtension->ModemStatus;

		    SmartcardExtension->ReaderExtension->GetModemStatus = TRUE;

		    SmartcardDebug(
			    DEBUG_DRIVER,
			    ("%s!CP8SerialCtsChanged: IOCTL_SERIAL_GET_MODEMSTATUS\n",
                DRIVER_NAME)
			    );
	    }

	    IoSetCompletionRoutine(
		    SmartcardExtension->ReaderExtension->CardStatus.Irp,
		    CP8SerialCtsChanged,
		    SmartcardExtension,
		    TRUE,
		    TRUE,
		    TRUE
		    );

        status = IoCallDriver(
    	    SmartcardExtension->ReaderExtension->ConnectedSerialPort, 
    	    SmartcardExtension->ReaderExtension->CardStatus.Irp
    	    );

        SmartcardDebug(                          
            DEBUG_TRACE,
            ("%s!CP8SerialCtsChanged: Exit\n",
            DRIVER_NAME)
            );

        return STATUS_MORE_PROCESSING_REQUIRED;

    } else {
     	
        SmartcardDebug(
            DEBUG_TRACE,
            ("%s!CP8SerialCtsChanged: Exit (Release IRP)\n",
            DRIVER_NAME)
            );

        return STATUS_SUCCESS;
    }
}	

NTSTATUS
CP8DeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
	PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

	return SmartcardDeviceControl(
		&(deviceExtension->SmartcardExtension),
		Irp
		);
}

static 
ULONG
NumBitsSet(
	ULONG value
	)
{
	ULONG i, numBits = 0;

	for (i = 0; i < sizeof(value) * 8; i++) {

		if (value & (1 << i))  {

			numBits ++;
		}
	}

	return numBits;
}	
 
NTSTATUS
CP8ReaderPower(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

	The smart card lib requires to have this function. It is called 
	for certain power requests to the card. We do nothing here, because
	this action is performed in the StartIo function.

Arguments:

    SmartcardExtension - Pointer to smart card data struct.

Return Value:

    NTSTATUS

--*/
{
	ULONG step, waitTime, TdIndex, numTry = 0, minWaitTime;
	NTSTATUS status = STATUS_SUCCESS;
	PSERIAL_STATUS serialStatus;
	KIRQL oldIrql;
    PSERIAL_READER_CONFIG serialConfigData = 
        &SmartcardExtension->ReaderExtension->SerialConfigData;

	SmartcardDebug(
		DEBUG_TRACE,
		("%s!CP8ReaderPower: Enter (%lx)\n",
        DRIVER_NAME,
        SmartcardExtension->MinorIoControlCode)
		);

    _try {
     	
        serialConfigData->LineControl.Parity = EVEN_PARITY;
        serialConfigData->LineControl.StopBits = STOP_BITS_2;

        serialConfigData->BaudRate.BaudRate = 
            SmartcardExtension->ReaderCapabilities.DataRate.Default;

        // we set very short timeouts to get the ATR as fast as possible
        serialConfigData->Timeouts.ReadIntervalTimeout = 
            READ_INTERVAL_TIMEOUT_ATR;
        serialConfigData->Timeouts.ReadTotalTimeoutConstant =
            READ_TOTAL_TIMEOUT_CONSTANT_ATR;

        status = CP8ConfigureSerialPort(SmartcardExtension);

        ASSERT(status == STATUS_SUCCESS);

        if (status != STATUS_SUCCESS) {

            leave;
        }                     

        status = CP8ConfigureSerialPort(
		    SmartcardExtension
		    );

        if (status != STATUS_SUCCESS) {

            leave;
        }                     

	    //
	    // We don't send data to the reader, so set Number of bytes to send = 0
	    //
	    SmartcardExtension->SmartcardRequest.BufferLength = 0;

	    //
	    // Default number of bytes we expect to get back
	    //
	    SmartcardExtension->SmartcardReply.BufferLength = 0;

	    //
	    // Since power down triggers the UpdateCardStatus function, we have
	    // to inform it that we forced the change of the status and not the user
	    // (who might have removed and inserted a card)
	    //
	    SmartcardExtension->ReaderExtension->PowerRequest = TRUE;

	    for (step = 0; NT_SUCCESS(status) ; step++) {

	        switch(SmartcardExtension->MinorIoControlCode) {

	        case SCARD_WARM_RESET:
		    //
		    // Skip the power down (clear DTR) - power up (set DTR) sequence
		    //
		    switch (step) {

		    case 0:
			    step = 1;
			    break;

		    case 2:
			    step = 3;
			    break;
		    }
		    //
		    // No break here !!!           
		    //

	        case SCARD_COLD_RESET:

	        //
	        // Send a power-down followed by a power-up
	        //
		    switch (step) {

		    case 0:
			    SmartcardExtension->ReaderExtension->SerialIoControlCode = 
				    IOCTL_SERIAL_CLR_DTR;
			    waitTime = 15000;
			    break;

		    case 1:
			    SmartcardExtension->ReaderExtension->SerialIoControlCode = 
				    IOCTL_SERIAL_CLR_RTS;
			    waitTime = 15000;
			    break;

		    case 2:
			    SmartcardExtension->ReaderExtension->SerialIoControlCode = 
				    IOCTL_SERIAL_SET_DTR;
			    waitTime = 15000;
			    break;

		    case 3:
			    SmartcardExtension->ReaderExtension->SerialIoControlCode = 
				    IOCTL_SERIAL_PURGE;

			    *(PULONG) SmartcardExtension->SmartcardRequest.Buffer = 
				    SERIAL_PURGE_RXCLEAR;

			    SmartcardExtension->SmartcardRequest.BufferLength = 
				    sizeof(ULONG);
                waitTime = 0;
			    break;

		    case 4:
			    SmartcardExtension->ReaderExtension->SerialIoControlCode = 
				    IOCTL_SERIAL_SET_RTS;
			    waitTime = 0;
			    break;

            case 5:
                //
                // We now try to get the ATR as fast as possible.
                // Therefor we prev. set a very short read timeout and
                // 'hope' that the card delivered its ATR within this 
                // short time. To verify the correctness of the ATR we call
                // SmartcardUpdateCardCapabilities(). If this call returns
                // with STATUS_SUCCESS we know that the ATR is complete.
                // Otherwise we read again and append the new data to the 
                // ATR buffer in the CardCapabilities and try again.
                //
			    SmartcardExtension->ReaderExtension->SerialIoControlCode = 
				    SMARTCARD_READ;

			    SmartcardExtension->SmartcardReply.BufferLength = 
                    MAXIMUM_ATR_LENGTH - 
                    SmartcardExtension->CardCapabilities.ATR.Length;

			    waitTime = 0;
			    break;

            case 6:

                if (SmartcardExtension->SmartcardReply.BufferLength != 0) {

                    ASSERT(
                        SmartcardExtension->CardCapabilities.ATR.Length +
                        SmartcardExtension->SmartcardReply.BufferLength <
                        MAXIMUM_ATR_LENGTH
                        );
             
                    // we got some ATR bytes. 
				    RtlCopyMemory(
					    SmartcardExtension->CardCapabilities.ATR.Buffer + 
                            SmartcardExtension->CardCapabilities.ATR.Length,
					    SmartcardExtension->SmartcardReply.Buffer,
					    SmartcardExtension->SmartcardReply.BufferLength
					    );

				    SmartcardExtension->CardCapabilities.ATR.Length += 
                        (UCHAR) SmartcardExtension->SmartcardReply.BufferLength;

                    status = SmartcardUpdateCardCapabilities(
                        SmartcardExtension
                        );
                }

                if (status != STATUS_SUCCESS && numTry < 100) {

                    // ATR is incomplete. Try again to get ATR bytes.
                    numTry += 1;
                    // continue with step 5 
                    step = 4;
                    status = STATUS_TIMEOUT;
                    continue;                     	
                }

                if (status != STATUS_SUCCESS) {

                    leave;
                }
                // No break

		    case 7:
                KeAcquireSpinLock(
				    &SmartcardExtension->OsData->SpinLock,
				    &oldIrql
				    );

			    if (SmartcardExtension->ReaderCapabilities.CurrentState <=
				    SCARD_ABSENT) {

				    status = STATUS_MEDIA_CHANGED;
			    } 

			    KeReleaseSpinLock(
				    &SmartcardExtension->OsData->SpinLock,
				    oldIrql
				    );

                if (status != STATUS_SUCCESS) {

                    leave;
                }

			    // Copy ATR to user space
                if (SmartcardExtension->IoRequest.ReplyBuffer) {
        
				    RtlCopyMemory(
					    SmartcardExtension->IoRequest.ReplyBuffer,
					    SmartcardExtension->CardCapabilities.ATR.Buffer,
					    SmartcardExtension->CardCapabilities.ATR.Length
					    );

				    // Tell user length of ATR
				    *SmartcardExtension->IoRequest.Information =
					    SmartcardExtension->CardCapabilities.ATR.Length;
                }

			    //
			    // If the card uses invers convention we need to switch
			    // the serial driver to odd paritiy
			    //
			    if (SmartcardExtension->CardCapabilities.InversConvention) {

				    serialConfigData->LineControl.Parity = ODD_PARITY;
			    }

                //
                // If the extra guard time is 255 it means that our
                // frame with have to expect from the card has only
                // 1 instead of 2 stop bits 
                // 1start bit + 8data bits + 1parity + 1stop == 11 etu
                // see iso 7816-3 6.1.4.4 Extra Guard Time N
                //
                if (SmartcardExtension->CardCapabilities.PtsData.StopBits == 1) {

                    serialConfigData->LineControl.StopBits = STOP_BIT_1;      
                }

                // depending on the protocol set the timeout values
                if (SmartcardExtension->CardCapabilities.Protocol.Selected &
                    SCARD_PROTOCOL_T1) {

                    // set timeouts
                    serialConfigData->Timeouts.ReadTotalTimeoutConstant =
                    serialConfigData->Timeouts.ReadIntervalTimeout =  
                        SmartcardExtension->CardCapabilities.T1.CWT / 1000;

                } else if (SmartcardExtension->CardCapabilities.Protocol.Selected &
                           SCARD_PROTOCOL_T0) {

                    // set timeouts
                    serialConfigData->Timeouts.ReadTotalTimeoutConstant =
                    serialConfigData->Timeouts.ReadIntervalTimeout =  
                        SmartcardExtension->CardCapabilities.T0.WT / 1000;
                }

                // Now make some adjustments depending on the system speed
                minWaitTime = (KeQueryTimeIncrement() / 10000) * 5;

                if (serialConfigData->Timeouts.ReadTotalTimeoutConstant < 
                    minWaitTime) {

                    serialConfigData->Timeouts.ReadTotalTimeoutConstant = 
                        minWaitTime;         	
                }

                if (serialConfigData->Timeouts.ReadIntervalTimeout < 
                    minWaitTime) {

                    serialConfigData->Timeouts.ReadIntervalTimeout = 
                        minWaitTime;         	
                }
                status = CP8ConfigureSerialPort(SmartcardExtension);
                ASSERT(status == STATUS_SUCCESS);

                leave;
            }
            break;
	            
	        case SCARD_POWER_DOWN:
		    switch (step) {

		    case 0:
			    SmartcardExtension->ReaderExtension->SerialIoControlCode = 
				    IOCTL_SERIAL_CLR_DTR;
			    waitTime = 15000;
			    break;

		    case 1:
			    SmartcardExtension->ReaderExtension->SerialIoControlCode = 
				    IOCTL_SERIAL_CLR_RTS;
			    waitTime = 15000;
			    break;

		    case 2:
			    SmartcardExtension->ReaderExtension->SerialIoControlCode = 
				    IOCTL_SERIAL_SET_DTR;
			    waitTime = 15000;
			    break;

		    case 3:
	            SmartcardExtension->ReaderCapabilities.CurrentState = 
	                SCARD_SWALLOWED;
	                    
			    SmartcardExtension->CardCapabilities.Protocol.Selected = 
				    SCARD_PROTOCOL_UNDEFINED;

                leave;
		    }
	        break;
	        }

	        status = CP8SerialIo(SmartcardExtension);

            if (!NT_SUCCESS(status)) {

                leave;
            }

		    if (waitTime) {

		        LARGE_INTEGER delayPeriod;

     	  	    delayPeriod.HighPart = -1;
			    delayPeriod.LowPart = waitTime * (-10);

	            KeDelayExecutionThread(
	        	    KernelMode,
	        	    FALSE,
	        	    &delayPeriod
	        	    );
		    }
	    } 
    }
    _finally {
     	
        if (status == STATUS_TIMEOUT) {

            status = STATUS_UNRECOGNIZED_MEDIA;
        }

	    SmartcardExtension->ReaderExtension->PowerRequest = FALSE;
    }

	SmartcardDebug(
		DEBUG_TRACE,
		("%s!CP8ReaderPower: Exit (%lxh)\n",
        DRIVER_NAME,
        status)
		);
	return status;
}

NTSTATUS
CP8SetProtocol(
   	PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

	The smart card lib requires to have this function. It is called 
	to set a the transmission protocol and parameters. If this function 
    is called with a protocol mask (which means the caller doesn't card 
    about a particular protocol to be set) we first look if we can 
    set T=1 and the T=0

Arguments:

    SmartcardExtension - Pointer to smart card data struct.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;

    PAGED_CODE();

	SmartcardDebug(
		DEBUG_TRACE,
		("%s!CP8SetProtocol: Enter\n",
        DRIVER_NAME)
		);


    try {
      	
		PUCHAR ptsRequest = SmartcardExtension->SmartcardRequest.Buffer;
		PUCHAR ptsReply = SmartcardExtension->SmartcardReply.Buffer;
        PSERIAL_READER_CONFIG serialConfigData = 
            &SmartcardExtension->ReaderExtension->SerialConfigData;
        ULONG minWaitTime, newProtocol;

	    //
	    // Check if the card is already in specific state
	    // and if the caller wants to have the already selected protocol.
	    // We return success if this is the case.
	    //
	    if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC &&
		    (SmartcardExtension->CardCapabilities.Protocol.Selected & 
		     SmartcardExtension->MinorIoControlCode)) {

		    status = STATUS_SUCCESS;	
            leave;
        }

        // set normal timeout
        serialConfigData->Timeouts.ReadIntervalTimeout = 
            READ_INTERVAL_TIMEOUT_DEFAULT;
        serialConfigData->Timeouts.ReadTotalTimeoutConstant = 
            READ_TOTAL_TIMEOUT_CONSTANT_DEFAULT;

        status = CP8ConfigureSerialPort(SmartcardExtension);

        ASSERT(status == STATUS_SUCCESS);

        if (status != STATUS_SUCCESS) {

            leave;
        }         
        
        //
        // Assemble and send a pts selection
        //
        newProtocol = SmartcardExtension->MinorIoControlCode;

        while(TRUE) {

		    // set initial character of PTS
		    ptsRequest[0] = 0xff;

            // set the format character
		    if (SmartcardExtension->CardCapabilities.Protocol.Supported &
                newProtocol & 
                SCARD_PROTOCOL_T1) {

                // select T=1 and indicate that pts1 follows
		        ptsRequest[1] = 0x11;
	            SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T1;

		    } else if (SmartcardExtension->CardCapabilities.Protocol.Supported & 
                       newProtocol & 
                       SCARD_PROTOCOL_T0) {

                // select T=0 and indicate that pts1 follows
		        ptsRequest[1] = 0x10;
	            SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T0;

		    } else {
			    
			    status = STATUS_INVALID_DEVICE_REQUEST;
                leave;
		    }

            // set pts1 which codes Fl and Dl
            ptsRequest[2] = 
                SmartcardExtension->CardCapabilities.PtsData.Fl << 4 |
                SmartcardExtension->CardCapabilities.PtsData.Dl;

		    // set pck (check character)
	        ptsRequest[3] = ptsRequest[0] ^ ptsRequest[1] ^ ptsRequest[2];   

		    SmartcardExtension->SmartcardRequest.BufferLength = 4;
		    SmartcardExtension->ReaderExtension->SerialIoControlCode = SMARTCARD_WRITE;

	        status = CP8SerialIo(SmartcardExtension);

            if (status != STATUS_SUCCESS) {
             	
                leave;
            }

            // read back the echo of the reader
		    SmartcardExtension->SmartcardReply.BufferLength = 4;
		    SmartcardExtension->ReaderExtension->SerialIoControlCode = SMARTCARD_READ;

		    status = CP8SerialIo(SmartcardExtension);

            if (status != STATUS_SUCCESS) {
             	
                leave;
            }

            // read back the pts data
		    status = CP8SerialIo(SmartcardExtension);

            if (status != STATUS_SUCCESS && 
                status != STATUS_TIMEOUT) {
                
                leave;       
            }

	        if (status != STATUS_TIMEOUT && 
                memcmp(ptsRequest, ptsReply, 4) == 0) {

                // the card replied correctly to our pts-request
                break;
            }

            if (SmartcardExtension->CardCapabilities.PtsData.Type !=
                PTS_TYPE_DEFAULT) {

	            SmartcardDebug(
		            DEBUG_TRACE,
		            ("%s!CP8SetProtocol: PTS failed. Trying default parameters...\n",
                    DRIVER_NAME,
                    status)
		            );
                //
                // The card did either NOT reply or it replied incorrectly
                // so try default values
                //
                SmartcardExtension->CardCapabilities.PtsData.Type = 
                    PTS_TYPE_DEFAULT;

                SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;

                status = CP8ReaderPower(SmartcardExtension);

                continue;
            } 
            
            // the card failed the pts-request
            status = STATUS_DEVICE_PROTOCOL_ERROR;
            leave;
        } 

        //
        // The card replied correctly to the pts request
        // Set the appropriate parameters for the port
        //
        if (SmartcardExtension->CardCapabilities.Protocol.Selected &
            SCARD_PROTOCOL_T1) {

            // set timeouts
            serialConfigData->Timeouts.ReadTotalTimeoutConstant =
                SmartcardExtension->CardCapabilities.T1.BWT / 1000;

            serialConfigData->Timeouts.ReadIntervalTimeout =    
                SmartcardExtension->CardCapabilities.T1.CWT / 1000;

        } else if (SmartcardExtension->CardCapabilities.Protocol.Selected &
                   SCARD_PROTOCOL_T0) {

            // set timeouts
            serialConfigData->Timeouts.ReadTotalTimeoutConstant =
            serialConfigData->Timeouts.ReadIntervalTimeout =  
                SmartcardExtension->CardCapabilities.T0.WT / 1000;
        }

        // Now make some adjustments depending on the system speed
        minWaitTime = (KeQueryTimeIncrement() / 10000) * 5;

        if (serialConfigData->Timeouts.ReadTotalTimeoutConstant < minWaitTime) {

            serialConfigData->Timeouts.ReadTotalTimeoutConstant = minWaitTime;         	
        }

        if (serialConfigData->Timeouts.ReadIntervalTimeout < minWaitTime) {

            serialConfigData->Timeouts.ReadIntervalTimeout = minWaitTime;         	
        }

        // Change data rate according to the new settings
        serialConfigData->BaudRate.BaudRate = 
            SmartcardExtension->CardCapabilities.PtsData.DataRate;

        status = CP8ConfigureSerialPort(SmartcardExtension);          

        ASSERT(status == STATUS_SUCCESS);

	    // now indicate that we're in specific mode 
	    SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;

		// return the selected protocol to the caller
		*(PULONG) SmartcardExtension->IoRequest.ReplyBuffer = 
			SmartcardExtension->CardCapabilities.Protocol.Selected;

		*SmartcardExtension->IoRequest.Information = 
			sizeof(SmartcardExtension->CardCapabilities.Protocol.Selected);
    } 
    finally {

        if (status == STATUS_TIMEOUT) {

            // STATUS_TIMEOUT is not mapped to a Win32 error code
            status = STATUS_IO_TIMEOUT;         	

		    *SmartcardExtension->IoRequest.Information = 0;

        } else if (status != STATUS_SUCCESS) {
		    
            SmartcardExtension->CardCapabilities.Protocol.Selected = 
                SCARD_PROTOCOL_UNDEFINED;

		    *SmartcardExtension->IoRequest.Information = 0;
	    } 
    }

	SmartcardDebug(
		DEBUG_TRACE,
		("%s!CP8SetProtocol: Exit(%lx)\n",
        DRIVER_NAME,
        status)
		);

   return status;
}

NTSTATUS
CP8TransmitT0(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
/*++

Routine Description:

	This function performs a T=0 transmission.

Arguments:

    SmartcardExtension - Pointer to smart card data struct.

Return Value:

    NTSTATUS

--*/
{
	PUCHAR requestBuffer = SmartcardExtension->SmartcardRequest.Buffer;
	PUCHAR replyBuffer = SmartcardExtension->SmartcardReply.Buffer;
	PULONG requestLength = &SmartcardExtension->SmartcardRequest.BufferLength;
	PULONG replyLength = &SmartcardExtension->SmartcardReply.BufferLength;
	PULONG serialIoControlCode = &SmartcardExtension->ReaderExtension->SerialIoControlCode;
	ULONG bytesToSend, bytesToRead, currentByte = 0;
    BOOLEAN restartWorkWaitingTime = FALSE;
	NTSTATUS status;

    SmartcardDebug(
        DEBUG_PROTOCOL,
        ("%s!CP8TransmitT0: Enter\n",
        DRIVER_NAME)
        );

    try {
	
	    // Let the lib build a T=0 packet
	    status = SmartcardT0Request(
		    SmartcardExtension
		    );

	    if (status != STATUS_SUCCESS) 
            leave;

	    //
	    // The number of bytes we expect from the card
	    // is Le + 2 status bytes
	    //
	    bytesToSend = *requestLength;
	    bytesToRead = SmartcardExtension->T0.Le + 2;

	    //
	    // Send the first 5 bytes to the card
	    //
	    *requestLength = 5;

	    do {

    	    UCHAR procByte;

            //
            // According to ISO 7816 a procedure byte of 
            // 60 should be treated as a request for a one time wait.
            // In this case we do not write anything to the card
            //
            if (restartWorkWaitingTime == FALSE) {

                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    ("%s!CP8TransmitT0: -> Sending %s (%ld bytes)\n",
                    DRIVER_NAME,
                    (currentByte == 0 ? "header" : "data"),
                    *requestLength)
                    );
		        //
		        // Write to the card
		        //
		        *serialIoControlCode = SMARTCARD_WRITE;
		        SmartcardExtension->SmartcardRequest.Buffer = &requestBuffer[currentByte];

		        status = CP8SerialIo(
			        SmartcardExtension
			        );

		        if (status != STATUS_SUCCESS)
                    leave;

		        //
		        // The CP8 echos all sent bytes. We read the echo 
		        // back into our send buffer
		        //
		        *serialIoControlCode = SMARTCARD_READ;
		        *replyLength = *requestLength;
		        SmartcardExtension->SmartcardReply.Buffer = &requestBuffer[currentByte];
                                                    
		        status = CP8SerialIo(
			        SmartcardExtension
			        );

		        if (status != STATUS_SUCCESS)
                    leave;

		        currentByte += *requestLength;
		        bytesToSend -= *requestLength;
            }

		    // Read the 'Procedure byte'.
		    SmartcardExtension->SmartcardReply.Buffer = &procByte;
		    *serialIoControlCode = SMARTCARD_READ;
		    *replyLength = 1;

		    status = CP8SerialIo(
			    SmartcardExtension
			    );

		    if (status != STATUS_SUCCESS) 
                leave;

            restartWorkWaitingTime = FALSE;
		    //
		    // Check the procedure byte. 
		    // Please take a look at ISO 7816 Part 3 Section 8.2.2
		    //
		    if (procByte == requestBuffer[1] || 
			    procByte == requestBuffer[1] + 1) {

                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    ("%s!CP8TransmitT0: <- ACK (send all)\n",
                    DRIVER_NAME)
                    );

			    // All remaining data bytes can be sent at once
			    *requestLength = bytesToSend;

		    } else if (procByte == (UCHAR) ~requestBuffer[1] ||
				       procByte == (UCHAR) ~(requestBuffer[1] + 1)) {

                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    ("%s!CP8TransmitT0: <- ACK (send single)\n",
                    DRIVER_NAME)
                    );

			    // We can send only one byte
			    *requestLength = 1;

		    } else if (procByte == 0x60 ||
                       SmartcardExtension->CardCapabilities.InversConvention &&
                       procByte == 0xf9) {

                //
                // We have to reset the wait time and try again to read
                //
                ULONG TimeRes;
			    LARGE_INTEGER delayTime;

                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    ("%s!CP8TransmitT0: <- NULL (%ldms)\n",
                    DRIVER_NAME,
                    SmartcardExtension->CardCapabilities.T0.WT / 1000)
                    );

                TimeRes = KeQueryTimeIncrement();

			    delayTime.HighPart = -1;
			    delayTime.LowPart = 
                    (-1) * 
                    TimeRes * 
                    ((SmartcardExtension->CardCapabilities.T0.WT * 10l / TimeRes) + 1); 

			    KeDelayExecutionThread(
				    KernelMode,
				    FALSE,
				    &delayTime
				    );

                //
                // Set flag that we only should read the proc byte
                // without writing data to the card
                //
                restartWorkWaitingTime = TRUE;

            } else {
         	    
			    //
			    // The card returned a status byte.
			    // Status bytes are always two bytes long.
			    // Store this byte first and then read the next
			    //
			    replyBuffer[0] = procByte;

			    *serialIoControlCode = SMARTCARD_READ;
			    *replyLength = 1;
			    bytesToSend = 0;
			    bytesToRead = 0;

			    //
			    // Read in the second status byte
			    //
			    SmartcardExtension->SmartcardReply.Buffer = 
				    &replyBuffer[1];

			    status = CP8SerialIo(
				    SmartcardExtension
				    );

			    SmartcardExtension->SmartcardReply.BufferLength = 2;

                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    ("%s!CP8TransmitT0: <- SW1=%02x SW2=%02x\n",
                    DRIVER_NAME,
                    replyBuffer[0], 
                    replyBuffer[1])
                    );
		    }

	    } while(bytesToSend || restartWorkWaitingTime);

	    if (status != STATUS_SUCCESS)
		    leave;

	    if (bytesToRead != 0) {

		    *serialIoControlCode = SMARTCARD_READ;
		    *replyLength = bytesToRead;

	        SmartcardExtension->SmartcardReply.Buffer = 
		        replyBuffer;

		    status = CP8SerialIo(
			    SmartcardExtension
			    );

#if DEBUG
            if (status == STATUS_SUCCESS) {
         	    
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    ("%s!CP8TransmitT0: <- Data %ld bytes, SW1=%02x SW2=%02x\n",
                    DRIVER_NAME,
                    bytesToRead,
                    replyBuffer[bytesToRead - 2], 
                    replyBuffer[bytesToRead - 1])
                    );
            }
#endif
	    }
    }
    finally {

	    // Restore pointers to their original location
	    SmartcardExtension->SmartcardRequest.Buffer = 
		    requestBuffer;

	    SmartcardExtension->SmartcardReply.Buffer = 
		    replyBuffer;

        if (status == STATUS_SUCCESS) {
         	
	        status = SmartcardT0Reply(
		        SmartcardExtension
		        );
        }
    }

    SmartcardDebug(
        DEBUG_PROTOCOL,
        ("%s!CP8TransmitT0: Exit(%lx)\n",
        DRIVER_NAME,
        status)
        );

	return status;
}	

NTSTATUS
CP8Transmit(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
/*++

Routine Description:

	This function is called by the smart card library whenever a transmission
	is required. 

Arguments:

    SmartcardExtension - Pointer to smart card data struct.

Return Value:

    NTSTATUS

--*/
{
	NTSTATUS status;

    _try {
     	
	    do {

		    PUCHAR requestBuffer = SmartcardExtension->SmartcardRequest.Buffer;
		    PUCHAR replyBuffer = SmartcardExtension->SmartcardReply.Buffer;
		    PULONG requestLength = &SmartcardExtension->SmartcardRequest.BufferLength;
		    PULONG replyLength = &SmartcardExtension->SmartcardReply.BufferLength;
		    PULONG serialIoControlCode = &SmartcardExtension->ReaderExtension->SerialIoControlCode;

		    //
		    // Tell the lib function how many bytes I need for the prologue
		    //
		    *requestLength = 0;

		    switch (SmartcardExtension->CardCapabilities.Protocol.Selected) {

			    case SCARD_PROTOCOL_RAW:
				    status = SmartcardRawRequest(SmartcardExtension);
				    break;

			    case SCARD_PROTOCOL_T0:
				    //
				    // T=0 requires a bit more work.
				    // So we do this in a seperate function.
				    //
				    status = CP8TransmitT0(SmartcardExtension);
                    leave;
				    
			    case SCARD_PROTOCOL_T1:
				    status = SmartcardT1Request(SmartcardExtension);
				    break;

			    default:
				    status = STATUS_INVALID_DEVICE_REQUEST;
                    leave;
				    
		    }

		    if (status != STATUS_SUCCESS) {

			    leave;
		    }

		    //
		    // Write the command to the card
		    //
		    *replyLength = 0;
		    *serialIoControlCode = SMARTCARD_WRITE;

		    status = CP8SerialIo(SmartcardExtension);

		    if (status != STATUS_SUCCESS) {

			    leave;
		    }

		    //
		    // The Bull reader always echos the bytes sent, so read that echo back
		    //
		    *serialIoControlCode = SMARTCARD_READ;
		    *replyLength = *requestLength;

		    status = CP8SerialIo(SmartcardExtension);

		    if (status != STATUS_SUCCESS) {

			    leave;
		    }

		    switch (SmartcardExtension->CardCapabilities.Protocol.Selected) {

			    case SCARD_PROTOCOL_RAW:
				    status = SmartcardRawReply(SmartcardExtension);
				    break;

			    case SCARD_PROTOCOL_T1:
                    //
                    // Check if the card requested a waiting time extension
                    //
                    if (SmartcardExtension->T1.Wtx) {

                        LARGE_INTEGER waitTime;
     	  	            waitTime.HighPart = -1;
			            waitTime.LowPart = 
                            SmartcardExtension->T1.Wtx * 
                            SmartcardExtension->CardCapabilities.T1.BWT * 
                            (-10);

                        KeDelayExecutionThread(
                            KernelMode,
                            FALSE,
                            &waitTime
                            );
                    }

				    //
				    // Read NAD, PCB and LEN fields
				    //
				    *replyLength = 3;

				    status = CP8SerialIo(SmartcardExtension);

                    // 
                    // Check for timeout first. If the card did not reply 
                    // we need to send a resend request
                    //
                    if (status != STATUS_TIMEOUT) {

				        if (status != STATUS_SUCCESS) {

                            leave;
				        }

				        //
				        // The third byte contains the length of the data in the packet
				        // and we additinally want to have the EDC bytes which 
				        // is one for LRC and 2 for CRC
				        //
				        *replyLength = 
					        replyBuffer[2] + 
					        (SmartcardExtension->CardCapabilities.T1.EDC & 0x01 ? 2 : 1);

				        //
				        // We want to have the remaining bytes just after the first 3
				        //
				        SmartcardExtension->SmartcardReply.Buffer += 3;

				        status = CP8SerialIo(SmartcardExtension);

				        SmartcardExtension->SmartcardReply.Buffer -= 3;
				        SmartcardExtension->SmartcardReply.BufferLength += 3;


				        if (status != STATUS_SUCCESS && status != STATUS_TIMEOUT) {

					        leave;
				        }                     	
                    }

                    if (status == STATUS_TIMEOUT) {

                        //
                        // Since the card did not reply we set the number of 
                        // bytes received to 0. This will trigger a resend 
                        // request 
                        //
                        SmartcardDebug(
                            DEBUG_PROTOCOL,
                            ("%s!TLP3TransmitT1: Timeout\n",
                            DRIVER_NAME)
                            );
                        SmartcardExtension->SmartcardReply.BufferLength = 0;                     	
                    }

				    status = SmartcardT1Reply(SmartcardExtension);
				    break;

			    default:
				    status = STATUS_INVALID_DEVICE_REQUEST;
                    leave;
		    }

	    } while (status == STATUS_MORE_PROCESSING_REQUIRED);
    }
    _finally {

        if (status == STATUS_TIMEOUT) {

            // STATUS_TIMEOUT is not mapped to a Win32 error code
            status = STATUS_IO_TIMEOUT;         	
        }
    }

	return status;
}

NTSTATUS
CP8CardTracking(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
/*++

Routine Description:

	The smart card lib requires to have this function. It is called 
	to setup event tracking for card insertion and removal events.

Arguments:

    SmartcardExtension - pointer to the smart card data struct.

Return Value:

    NTSTATUS

--*/
{
	KIRQL oldIrql;

	//
	// Set cancel routine for the notification irp
	//
    IoAcquireCancelSpinLock(
        &oldIrql
        );
    
	IoSetCancelRoutine(
        SmartcardExtension->OsData->NotificationIrp, 
        CP8Cancel
        );
        
    IoReleaseCancelSpinLock(
        oldIrql
        );

	return STATUS_PENDING;
}

NTSTATUS
CP8VendorIoctl(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
{
	if (SmartcardExtension->IoRequest.ReplyBuffer != NULL && 
		SmartcardExtension->IoRequest.ReplyBufferLength >= sizeof(ULONG)) { 
		
        *(PULONG) SmartcardExtension->IoRequest.ReplyBuffer = 0xCDAB3412;
        *SmartcardExtension->IoRequest.Information = sizeof(ULONG);
        return STATUS_SUCCESS;

	}	

    return STATUS_BUFFER_TOO_SMALL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\smclib\smcprot.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    smcprot.c

Author:

    Klaus U. Schutz 

Environment:

    Kernel mode only.

Revision History:

    - Dec. 96:  Initial version
    - Nov. 97:  Release 1.0
    - Feb. 98:  T=1 uses now the min of IFSC, IFSD for SmartcardT1Request
                T=1 fixed number of bytes to invert for inverse convention cards
                

--*/

#ifdef SMCLIB_VXD

#define try 
#define leave goto __label
#define finally __label:

#else

#ifndef SMCLIB_CE
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <ntddk.h>
#endif // SMCLIB_CE
#endif

#include "smclib.h"
#define SMARTCARD_POOL_TAG 'bLCS'

#ifdef DEBUG_INTERFACE
BOOLEAN
DebugT1Reply(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

void
DebugGetT1Request(
    PSMARTCARD_EXTENSION SmartcardExtension,
    NTSTATUS Status
    );

BOOLEAN
DebugSetT1Request(
    PSMARTCARD_EXTENSION SmartcardExtension
    );
#endif // DEBUG_INTERFACE

void
DumpData(
    const ULONG DebugLevel,
    PUCHAR Data,
    ULONG DataLen
    );

//
// Usually an io-request consists only of the SCARD_IO_REQUEST header
// followed by the data to be transmitted. To allow modification of 
// protocol data, it is possible to pass down the data to be modified.
// These data are ASN1 encoded.
//
typedef struct _IO_HEADER {
    SCARD_IO_REQUEST ScardIoRequest;
    UCHAR Asn1Data[1];      
} IO_HEADER, *PIO_HEADER;

NTSTATUS
#ifdef SMCLIB_VXD
SMCLIB_SmartcardRawRequest(
#else
SmartcardRawRequest(
#endif
    PSMARTCARD_EXTENSION SmartcardExtension
    )
    
/*++

Routine Description:

Arguments:

Return Value:

   -

--*/
{
    PSMARTCARD_REQUEST smartcardRequest = &(SmartcardExtension->SmartcardRequest);

    if (smartcardRequest->BufferLength + 
        SmartcardExtension->IoRequest.RequestBufferLength >=
        smartcardRequest->BufferSize) {

        return STATUS_BUFFER_TOO_SMALL;
    }
    
    //
    // Copy request data to the buffer
    //        
    RtlCopyMemory(
        &smartcardRequest->Buffer[smartcardRequest->BufferLength],
        SmartcardExtension->IoRequest.RequestBuffer,
        SmartcardExtension->IoRequest.RequestBufferLength
        );
        
    //
    // If the card uses invers convention invert the data
    // 
    if (SmartcardExtension->CardCapabilities.InversConvention) {

        SmartcardInvertData(
            &smartcardRequest->Buffer[smartcardRequest->BufferLength],
            SmartcardExtension->IoRequest.RequestBufferLength
            );
    }

    //
    // number of bytes to send to the reader 
    //    
    smartcardRequest->BufferLength += 
        SmartcardExtension->IoRequest.RequestBufferLength;

    return STATUS_SUCCESS;
}    

NTSTATUS
#ifdef SMCLIB_VXD
SMCLIB_SmartcardRawReply(
#else
SmartcardRawReply(
#endif
    PSMARTCARD_EXTENSION SmartcardExtension
    )
    
/*++

Routine Description:

Arguments:

Return Value:

   -

--*/
{
    if (SmartcardExtension->IoRequest.ReplyBufferLength <
        SmartcardExtension->SmartcardReply.BufferLength) {
        
        return STATUS_BUFFER_TOO_SMALL;
    }
    
    //
    // Copy data to user buffer
    //
    RtlCopyMemory(
        SmartcardExtension->IoRequest.ReplyBuffer,
        SmartcardExtension->SmartcardReply.Buffer,
        SmartcardExtension->SmartcardReply.BufferLength
        );

    // 
    // Length of data to return
    //        
    *SmartcardExtension->IoRequest.Information = 
        SmartcardExtension->SmartcardReply.BufferLength;
              
    return STATUS_SUCCESS;
}   

NTSTATUS
#ifdef SMCLIB_VXD
SMCLIB_SmartcardT0Request(
#else
SmartcardT0Request(
#endif
    PSMARTCARD_EXTENSION SmartcardExtension
    )
    
/*++

Routine Description:

    Prepares the buffer SmartcardExtension->SmartcardRequest.Buffer 
    to send data to the smart card

Arguments:

    NOTE: On input SmartcardExtension->SmartcardRequest.BufferLenght indicates
          the offset where we should copy the data to. This is usually
          used by readers that needs to have some bytes as header bytes
          to send to the reader before the data bytes for the card

Return Value:

   -

--*/
{
    PSMARTCARD_REQUEST smartcardRequest = &SmartcardExtension->SmartcardRequest;
    PSCARD_IO_REQUEST scardIoRequest;
    PUCHAR ioRequestData;
    ULONG ioRequestDataLength, headerSize;
    
    if (smartcardRequest->BufferLength + 
        SmartcardExtension->IoRequest.RequestBufferLength >=
        smartcardRequest->BufferSize) {

        SmartcardDebug(
            DEBUG_ERROR,
            (TEXT("%s!SmartcardT0Request: IoRequest.RequestBuffer too big\n"),
            DRIVER_NAME)
            );

        return STATUS_BUFFER_OVERFLOW;
    }

    scardIoRequest = (PSCARD_IO_REQUEST) 
        SmartcardExtension->IoRequest.RequestBuffer;

    ioRequestData = 
        SmartcardExtension->IoRequest.RequestBuffer + 
        sizeof(SCARD_IO_REQUEST);

    ioRequestDataLength = 
        SmartcardExtension->IoRequest.RequestBufferLength - 
        sizeof(SCARD_IO_REQUEST);

    //
    // Copy T=0 protocol-info into buffer
    //
    RtlCopyMemory(
        &smartcardRequest->Buffer[smartcardRequest->BufferLength],
        ioRequestData,
        ioRequestDataLength
        );
        
    //
    // Remember number of bytes for the header offset
    //
    headerSize = 
        smartcardRequest->BufferLength;

    //
    // Number of bytes to send to the reader 
    //    
    smartcardRequest->BufferLength += 
        ioRequestDataLength;

    if (ioRequestDataLength < 4) {

        //
        // A T=0 request needs at least 4 bytes
        //
        SmartcardDebug(
            DEBUG_ERROR,
            (TEXT("%s!SmartcardT0Request: TPDU is too short (%d). Must be at least 4 bytes\n"),
            DRIVER_NAME,
            ioRequestDataLength)
            );

        return STATUS_INVALID_PARAMETER;

    } else {

        PUCHAR requestBuffer = SmartcardExtension->SmartcardRequest.Buffer;

        if (ioRequestDataLength <= 5) {

            //
            // We request to read data from the card
            //
            SmartcardExtension->T0.Lc = 0;

            if (ioRequestDataLength == 4) {

                //
                // This is a special case where a 4 byte APDU is mapped to 
                // a 5 byte TPDU (ISO 7816 - Part 4, Annex A, A.1 Case 1)
                // This case requires that we append a 0 to the 
                // APDU to make it a TPDU
                //
                SmartcardExtension->T0.Le = 0;
                smartcardRequest->Buffer[headerSize + 4] = 0;
                smartcardRequest->BufferLength += 1;

            } else {
                
                SmartcardExtension->T0.Le = 
                    (requestBuffer[headerSize + 4] ? requestBuffer[headerSize + 4] : 256);
            }

        } else {
            
            //
            // We want to send data to the card
            //
            SmartcardExtension->T0.Lc = requestBuffer[headerSize + 4];
            SmartcardExtension->T0.Le = 0;

            if (SmartcardExtension->T0.Lc != ioRequestDataLength - 5) {

                SmartcardDebug(
                    DEBUG_ERROR,
                    (TEXT("%s!SmartcardT0Request: Lc(%d) in TPDU doesn't match number of bytes to send(%d).\n"),
                    DRIVER_NAME,
                    SmartcardExtension->T0.Lc,
                    ioRequestDataLength - 5)
                    );

                return STATUS_INVALID_PARAMETER;
            }
        }

#if DEBUG
        {
            PUCHAR T0Data = requestBuffer + headerSize;

            SmartcardDebug(
                DEBUG_PROTOCOL,
                (TEXT(" CLA:  %02X\n INS:  %02X\n P1:   %02X\n P2:   %02X\n Lc:   %02X\n Le:   %02X\n"), 
                T0Data[0], T0Data[1], T0Data[2], T0Data[3],
                SmartcardExtension->T0.Lc,
                SmartcardExtension->T0.Le)
                );

            if (SmartcardExtension->T0.Lc) {

                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT(" Data: ")), 
                    );

                DumpData(
                    DEBUG_PROTOCOL,
                    T0Data + 5, 
                    SmartcardExtension->T0.Lc
                    );
            }
        }
#endif 

        //
        // If the card uses invers convention invert the data
        // 
        if (SmartcardExtension->CardCapabilities.InversConvention) {

            SmartcardInvertData(
                &smartcardRequest->Buffer[headerSize], 
                smartcardRequest->BufferLength - headerSize
                );
        }

        return STATUS_SUCCESS;

#ifdef APDU_SUPPORT
        ULONG requestLength = SmartcardExtension->SmartcardRequest.BufferLength;
        ULONG L;

        //
        // Figure out Lc and Le
        // (See 'Decoding of the command APDUs' in ISO Part 4, 5.3.2)
        // (Variable names used are according to ISO designations)
        //
        L = requestLength - 4;

        if (L > 65536) {

            return STATUS_INVALID_PARAMETER;
        }

        if (L == 0) {

            //
            // Lc = 0, No Data, Le = 0;
            //
            SmartcardExtension->T0.Lc = 0;
            SmartcardExtension->T0.Le = 0;

        } else if (L == 1) {
            
            //
            // Case 2S, Lc = 0, Le = B1
            //
            SmartcardExtension->T0.Lc = 0;
            SmartcardExtension->T0.Le = requestBuffer[4];

        } else {

            UCHAR B1 = requestBuffer[4];

            if (B1 != 0) {

                //
                // Short form
                //
                if (L == (ULONG) (1 + B1)) {

                    //
                    // Case 3S, Lc = B1, Le = 0
                    //
                    SmartcardExtension->T0.Lc = B1;
                    SmartcardExtension->T0.Le = 0;

                } else {
                    
                    //
                    // Case 4S, Lc = B1, Le = BL
                    // 
                    SmartcardExtension->T0.Lc = B1;
                    SmartcardExtension->T0.Le = requestBuffer[L - 1];
                }

            } else {
                
                //
                // Extended form
                //
                if (L == 3) {

                    //
                    // Case 2E, Lc = 0, Le = B(L - 1, L)
                    //
                    LENGTH length;

                    length.l.l0 = 0;
                    length.b.b0 = requestBuffer[L - 1];
                    length.b.b1 = requestBuffer[L - 2];

                    SmartcardExtension->T0.Lc = 0;
                    SmartcardExtension->T0.Le = (length.l.l0 ? length.l.l0 : 65536);

                } else {

                    LENGTH length;
                    
                    length.l.l0 = 0;
                    length.b.b0 = requestBuffer[6];
                    length.b.b1 = requestBuffer[5];

                    SmartcardExtension->T0.Lc = length.l.l0;

                    if (L == 3 + length.l.l0) {

                        //
                        // Case 3E, Lc = B(2,3)
                        //
                        SmartcardExtension->T0.Le = 0;

                    } else {

                        //
                        // Case 4E, Lc = B(2,3), Le = B(L - 1, L)
                        //
                        LENGTH length;
                        
                        length.l.l0 = 0;
                        length.b.b0 = requestBuffer[L - 1];
                        length.b.b1 = requestBuffer[L - 2];

                        SmartcardExtension->T0.Le = (length.l.l0 ? length.l.l0 : 65536);
                    }
                }
            }
        }
#endif
    }

    return STATUS_SUCCESS;
}    

NTSTATUS
#ifdef SMCLIB_VXD
SMCLIB_SmartcardT0Reply(
#else
SmartcardT0Reply(
#endif
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

Arguments:

Return Value:

   -

--*/
{
    PSMARTCARD_REPLY smartcardReply = &SmartcardExtension->SmartcardReply;

    //
    // The reply must be at least to 2 bytes long. These 2 bytes are
    // the return value (StatusWord) from the smart card
    //
    if (smartcardReply->BufferLength < 2) {

        return STATUS_DEVICE_PROTOCOL_ERROR;
    }
    
    if (SmartcardExtension->IoRequest.ReplyBufferLength < 
        smartcardReply->BufferLength + sizeof(SCARD_IO_REQUEST)) {
        
        SmartcardDebug(
            DEBUG_ERROR,
            (TEXT("%s!SmartcardT0Request: ReplyBuffer too small\n"),
            DRIVER_NAME)
            );

        return STATUS_BUFFER_TOO_SMALL;
    }

    // Copy protocol header to user buffer
    RtlCopyMemory(
        SmartcardExtension->IoRequest.ReplyBuffer,
        SmartcardExtension->IoRequest.RequestBuffer,
        sizeof(SCARD_IO_REQUEST)
        );
        
    // If the card uses invers convention invert the data
    if (SmartcardExtension->CardCapabilities.InversConvention) {

        SmartcardInvertData(
            smartcardReply->Buffer,
            smartcardReply->BufferLength
            );
    }

    // Copy all data to user buffer
    RtlCopyMemory(
        SmartcardExtension->IoRequest.ReplyBuffer + sizeof(SCARD_IO_REQUEST),
        smartcardReply->Buffer,
        smartcardReply->BufferLength
        );
              
    // Length of answer
    *SmartcardExtension->IoRequest.Information = 
        smartcardReply->BufferLength + 
        sizeof(SCARD_IO_REQUEST);

    return STATUS_SUCCESS;
}    

BOOLEAN
SmartcardT1Chksum(
    PUCHAR Block,
    UCHAR Edc,
    BOOLEAN Verify
    )
/*++

Routine Description:

    This routine calculates the epilogue field for a T1 block. It calculates the LRC
    for all the data in the IBlock.

Arguments:

    Block - T1 Information block, to be sent, or just read, from the card.
    Edc - ErrorDetectionCode as described in ISO 
    Verify - If this is a block that was recieved form the card, TRUE will cause this routine
              to check the epilogue field, included with this buffer, against the calculated one

Return Value:

    TRUE if Verify = TRUE and epilogue fields match or Verify = FALSE
    FALSE if Verify = TRUE and an error was detected (mismatch)


--*/

{
    USHORT i;
    UCHAR lrc;
    USHORT crc = 0;
    USHORT offset = Block[2] + SCARD_T1_PROLOGUE_LENGTH;

    unsigned short crc16a[] = {
        0000000,  0140301,  0140601,  0000500,
        0141401,  0001700,  0001200,  0141101,
        0143001,  0003300,  0003600,  0143501,
        0002400,  0142701,  0142201,  0002100,
    };
    unsigned short crc16b[] = {
        0000000,  0146001,  0154001,  0012000,
        0170001,  0036000,  0024000,  0162001,
        0120001,  0066000,  0074000,  0132001,
        0050000,  0116001,  0104001,  0043000,
    };

    if (Edc & T1_CRC_CHECK) {

        UCHAR tmp;

        // Calculate CRC using tables.
        for ( i = 0; i < offset;  i++) {

             tmp = Block[i] ^ (UCHAR) crc;
             crc = (crc >> 8) ^ crc16a[tmp & 0x0f] ^ crc16b[tmp >> 4];
        }

        if (Verify) {

            if (crc == (Block[offset + 1] | (Block[offset] << 8))) {

                return TRUE;

            } else {

                return FALSE;
            }

        } else {

            Block[offset] = (UCHAR) (crc >> 8 );       //MSB of crc
            Block[offset + 1] = (UCHAR) (crc & 0x00ff);  //LSB of crc
            return TRUE;
        }

    } else {

        // Calculate LRC by X-Oring all the bytes.
        lrc = Block[0];

        for(i = 1; i < offset; i++){

            lrc ^= Block[i];
        }

        if (Verify) {

            return (lrc == Block[offset] ? TRUE : FALSE);

        } else {

            Block[offset] = lrc;
            return TRUE;
        }
    }
    return TRUE;
}

#if (DEBUG)
static 
void
DumpT1Block(
    PUCHAR Buffer,
    UCHAR Edc
    )
{

    SmartcardDebug(
        DEBUG_PROTOCOL,
        (TEXT("   NAD: %02X\n   PCB: %02X\n   LEN: %02X\n   INF: "), 
        Buffer[0], Buffer[1], Buffer[2])
        );

    if (Buffer[2] == 0) {
        
        SmartcardDebug(
            DEBUG_PROTOCOL,
            (TEXT("- "))
            );
    }

    DumpData(
        DEBUG_PROTOCOL,
        Buffer + 3,
        Buffer[2]
        );

    if (Edc & T1_CRC_CHECK) {
        
        SmartcardDebug(
            DEBUG_PROTOCOL,
            (TEXT("\n   CRC: %02X %02X"),
            Buffer[Buffer[2] + 3],
            Buffer[Buffer[2] + 4])
            );

    } else {
        
        SmartcardDebug(
            DEBUG_PROTOCOL,
            (TEXT("\n   LRC: %02X"),
            Buffer[Buffer[2] + 3])
            );
    }

    SmartcardDebug(
        DEBUG_PROTOCOL,
        (TEXT("\n"))
        );
}   
#endif

#if DEBUG
#pragma optimize( "", off )
#endif

NTSTATUS
#ifdef SMCLIB_VXD
SMCLIB_SmartcardT1Request(
#else
SmartcardT1Request(
#endif
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++                     
                         
 Routine Description:
 
 Arguments:
 
    SmartcardExtension - Supplies a pointer to the smart card data
    
 Return Value:
                         
--*/
    
{
    PSMARTCARD_REQUEST smartcardRequest = &(SmartcardExtension->SmartcardRequest);
    PIO_HEADER IoHeader = (PIO_HEADER) SmartcardExtension->IoRequest.RequestBuffer;
    T1_BLOCK_FRAME t1SendFrame;
    NTSTATUS status = STATUS_SUCCESS;

#if (DEBUG)
    ULONG headerSize = smartcardRequest->BufferLength;
#endif

#ifdef DEBUG_INTERFACE
    if (DebugSetT1Request(SmartcardExtension)) {
        
        //
        // the debugger gave us a new packet that we have to 
        // send instead of the original packet which will be sent later
        //
        return STATUS_SUCCESS;
    }
#endif

    if (SmartcardExtension->T1.WaitForReply) {

        // we did not get an answer to our last request
        SmartcardExtension->T1.State = T1_INIT;
    }
    SmartcardExtension->T1.WaitForReply = TRUE;

    __try {
        
        switch (SmartcardExtension->T1.State) {

            case T1_INIT:
                SmartcardExtension->T1.State = T1_IFS_REQUEST;

                // NO break here !!!

            case T1_START:
                //
                // Since this is the very first block in a 
                // transmission we reset the resynch counter
                //
                SmartcardExtension->T1.Resynch = 0;

                //
                // Allocate a buffer that receives the result.
                // This is necessary since we otherwise overwite our
                // request data which we might wish to resend in case
                // of an error
                //
                if (SmartcardExtension->T1.ReplyData != NULL) {

#ifdef SMCLIB_VXD
                    _HeapFree(SmartcardExtension->T1.ReplyData, 0);
#elif defined(SMCLIB_CE)
                    LocalFree(SmartcardExtension->T1.ReplyData);
#else                
                    ExFreePool(SmartcardExtension->T1.ReplyData);
#endif
                    SmartcardExtension->T1.ReplyData = NULL;
                }

                if (SmartcardExtension->IoRequest.ReplyBufferLength <
                    IoHeader->ScardIoRequest.cbPciLength + 2) {

                    //
                    // We should at least be able to store 
                    // the io-header plus SW1 and SW2
                    //
                    status = STATUS_BUFFER_TOO_SMALL;               
                    __leave;
                }
#ifdef SMCLIB_VXD
                SmartcardExtension->T1.ReplyData = (PUCHAR) _HeapAllocate(
                    SmartcardExtension->IoRequest.ReplyBufferLength, 
                    0
                    );
#elif defined(SMCLIB_CE)
                SmartcardExtension->T1.ReplyData = (PUCHAR) LocalAlloc(LPTR,
                    SmartcardExtension->IoRequest.ReplyBufferLength 
                    );

#else
                SmartcardExtension->T1.ReplyData = ExAllocatePool(
                    NonPagedPool,
                    SmartcardExtension->IoRequest.ReplyBufferLength
                    );
#endif
                ASSERT(SmartcardExtension->T1.ReplyData != NULL);

                if (SmartcardExtension->T1.ReplyData == NULL) {

                    status = STATUS_INSUFFICIENT_RESOURCES;
                    __leave;
                }

                // No break here !!!

            case T1_RESTART:
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Request: T1_%s\n"),
                    DRIVER_NAME,
                    (SmartcardExtension->T1.State == T1_START ? TEXT("START") : TEXT("RESTART")))
                    );

                // Copy protocol header back to user buffer
                RtlCopyMemory(
                    SmartcardExtension->T1.ReplyData,
                    SmartcardExtension->IoRequest.RequestBuffer,
                    IoHeader->ScardIoRequest.cbPciLength
                    );

                //
                // Check for the special case where the io-header is followed 
                // by asn1 data that contains the NAD value to be used.
                // This was done for VISA, because they need access to the NAD.
                // The NAD is ASN1 encoded as 81h 00h NAD 00h
                //
                if (IoHeader->ScardIoRequest.cbPciLength > sizeof(SCARD_IO_REQUEST) &&
                    IoHeader->Asn1Data[0] == 0x81 &&
                    IoHeader->Asn1Data[1] == 0x01 &&
                    IoHeader->Asn1Data[3] == 0x00) {

                    SmartcardExtension->T1.NAD = IoHeader->Asn1Data[2]; 

                    SmartcardDebug(
                        DEBUG_PROTOCOL,
                        (TEXT("%s!SmartcardT1Request: NAD set to %02xh\n"),
                        DRIVER_NAME,
                        SmartcardExtension->T1.NAD)
                        );
                } 

                // Initialize the T1 protocol data 
                SmartcardExtension->T1.BytesToSend = 
                    SmartcardExtension->IoRequest.RequestBufferLength - 
                    IoHeader->ScardIoRequest.cbPciLength;
                
                SmartcardExtension->T1.BytesSent = 0;
                SmartcardExtension->T1.BytesReceived = 0;
                //
                // This is the maximum number of bytes that the smartcard can
                // accept in a single block. The smartcard can extend this size
                // during the transmission
                //
                SmartcardExtension->T1.IFSC = 
                    SmartcardExtension->CardCapabilities.T1.IFSC;
                
                //
                // Since this is the first block in a transmission we reset 
                // the re-transmission counter. 
                //
                SmartcardExtension->T1.Resend = 0;
                SmartcardExtension->T1.OriginalState = 0;
            
                SmartcardExtension->T1.MoreData = FALSE;
                //
                // NO break here !!!
                //
                // After a card reset we first send an IFS-Request to the card.
                // Otherwise we start with an I-Block
                //

            case T1_IFS_REQUEST:
                if (SmartcardExtension->T1.State == T1_IFS_REQUEST) {
                    
                    SmartcardDebug(
                        DEBUG_PROTOCOL,
                        (TEXT("%s!SmartcardT1Request: T1_IFSD_REQUEST\n"),
                        DRIVER_NAME)
                        );

                    SmartcardExtension->T1.State = 
                        T1_IFS_REQUEST;

                    t1SendFrame.Nad = SmartcardExtension->T1.NAD;
                    //
                    // IFS request.
                    // Send our IFSD size to the card
                    //
                    t1SendFrame.Pcb = 0xC1;
                    t1SendFrame.Len = 1;
                    t1SendFrame.Inf = &SmartcardExtension->T1.IFSD;

                    break;

                } else {
                    
                    SmartcardExtension->T1.State = T1_I_BLOCK;
                }

                // No break here !!
            
            case T1_I_BLOCK:
                SmartcardExtension->T1.State = T1_I_BLOCK;

                //
                // Set the number of bytes we will transmit to the card.
                // This is the lesser of IFSD and IFSC
                //
                SmartcardExtension->T1.InfBytesSent = SmartcardExtension->T1.IFSC;
    
                if (SmartcardExtension->T1.InfBytesSent > SmartcardExtension->T1.IFSD) {

                    SmartcardExtension->T1.InfBytesSent = SmartcardExtension->T1.IFSD;
                }

                // Send either max frame size or remaining bytes
                if (SmartcardExtension->T1.BytesToSend > SmartcardExtension->T1.InfBytesSent) {
                    
                    SmartcardExtension->T1.MoreData = TRUE;
                    t1SendFrame.Len = SmartcardExtension->T1.InfBytesSent;

                } else {

                    SmartcardExtension->T1.MoreData = FALSE;                
                    t1SendFrame.Len = (UCHAR) SmartcardExtension->T1.BytesToSend;
                }
                
                t1SendFrame.Nad = SmartcardExtension->T1.NAD;

                //
                // ProtocolControlByte:
                //      b7 - SendSequenceNumber
                //      b6 - MoreDatatBit
                //
                t1SendFrame.Pcb = 
                    (SmartcardExtension->T1.SSN) << 6 |
                    (SmartcardExtension->T1.MoreData ? T1_MORE_DATA : 0);
            
                t1SendFrame.Inf = 
                    SmartcardExtension->IoRequest.RequestBuffer + 
                    IoHeader->ScardIoRequest.cbPciLength +
                    SmartcardExtension->T1.BytesSent;

                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Request: I(%d.%d) ->\n"),
                    DRIVER_NAME,
                    SmartcardExtension->T1.SSN,
                    (SmartcardExtension->T1.MoreData ? 1 : 0))
                    );
                break; 
            
            case T1_R_BLOCK:
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Request: R(%d) ->\n"),
                    DRIVER_NAME,
                    SmartcardExtension->T1.RSN)
                    );

                t1SendFrame.Nad = SmartcardExtension->T1.NAD;
                //
                // ProtocolControlByte:
                //      b5 -    SequenceNumber
                //      b1-4 -  ErrorCode
                //
                t1SendFrame.Pcb = 
                    0x80 | 
                    (SmartcardExtension->T1.RSN) << 4 |
                    (SmartcardExtension->T1.LastError);
            
                //
                // If this R-Block is a response to an error
                // we have to restore to the original state we had before 
                //
                if (SmartcardExtension->T1.LastError) {

                    SmartcardExtension->T1.LastError = 0;

                    //
                    // We must have a defined original state here
                    //
                    ASSERT(SmartcardExtension->T1.OriginalState != 0);

                    if (SmartcardExtension->T1.OriginalState == 0) {

                        SmartcardExtension->T1.State = T1_START;
                        status = STATUS_INTERNAL_ERROR;                     
                        __leave;
                    }

                    SmartcardExtension->T1.State = 
                        SmartcardExtension->T1.OriginalState;
                }
                
                t1SendFrame.Len = 0;
                t1SendFrame.Inf = NULL;
                break;    

            case T1_IFS_RESPONSE:
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Request: T1_IFSD_RESPONSE\n"),
                    DRIVER_NAME)
                    );
                
                // Restore to the original state we had before
                ASSERT(SmartcardExtension->T1.OriginalState != 0);

                SmartcardExtension->T1.State = 
                    SmartcardExtension->T1.OriginalState;

                t1SendFrame.Nad = SmartcardExtension->T1.NAD;

                // Send IFS response
                t1SendFrame.Pcb = 0xE1;
                t1SendFrame.Len = 1;

                // New length of INF-Field
                t1SendFrame.Inf = &SmartcardExtension->T1.IFSC;
                break;    
            
            case T1_RESYNCH_REQUEST:
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Request: T1_RESYNCH_REQUEST\n"),
                    DRIVER_NAME)
                    );

                t1SendFrame.Nad = SmartcardExtension->T1.NAD;

                // Resynch request
                t1SendFrame.Pcb = 0xC0;
                t1SendFrame.Len = 0;
                t1SendFrame.Inf = NULL;

                // Set the send sequence number to 0
                SmartcardExtension->T1.SSN = 0;    
                break;
            
            case T1_ABORT_REQUEST:
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Request: T1_ABORT_REQUEST\n"),
                    DRIVER_NAME)
                    );
                
                t1SendFrame.Nad = SmartcardExtension->T1.NAD;

                // Send ABORT request
                t1SendFrame.Pcb = 0xC2;
                t1SendFrame.Len = 0;
                t1SendFrame.Inf = NULL;
                break;    
            
            case T1_ABORT_RESPONSE:
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Request: T1_ABORT_RESPONSE\n"),
                    DRIVER_NAME)
                    );
                SmartcardExtension->T1.State = T1_START;
                
                t1SendFrame.Nad = SmartcardExtension->T1.NAD;

                // Send ABORT response
                t1SendFrame.Pcb = 0xE2;
                t1SendFrame.Len = 0;
                t1SendFrame.Inf = NULL;
                break;    
            
            case T1_WTX_RESPONSE:
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Request: T1_WTX_RESPONSE\n"),
                    DRIVER_NAME)
                    );

                // Restore to the original state we had before
                ASSERT(SmartcardExtension->T1.OriginalState != 0);

                SmartcardExtension->T1.State = 
                    SmartcardExtension->T1.OriginalState;

                SmartcardExtension->T1.OriginalState = 0;

                t1SendFrame.Nad = SmartcardExtension->T1.NAD;

                // Send WTX response
                t1SendFrame.Pcb = 0xE3;
                t1SendFrame.Len = 1;
                t1SendFrame.Inf = &SmartcardExtension->T1.Wtx;
                break;    
            
        }

        // Insert Node Address byte
        smartcardRequest->Buffer[smartcardRequest->BufferLength] = 
            t1SendFrame.Nad;
        
        // Insert ProtocolControlByte
        smartcardRequest->Buffer[smartcardRequest->BufferLength + 1] = 
            t1SendFrame.Pcb;
        
        // Length of INF field
        smartcardRequest->Buffer[smartcardRequest->BufferLength + 2] = 
            t1SendFrame.Len;

        // Insert INF field data
        if (t1SendFrame.Len > 0) {
    
            RtlCopyMemory(
                &smartcardRequest->Buffer[smartcardRequest->BufferLength + 3],
                t1SendFrame.Inf,
                t1SendFrame.Len
            );
        }

        // Compute checksum
        SmartcardT1Chksum(
            &smartcardRequest->Buffer[smartcardRequest->BufferLength],
            SmartcardExtension->CardCapabilities.T1.EDC,
            FALSE
            );

#if defined(DEBUG)
#if defined(SMCLIB_NT)
        if (SmartcardGetDebugLevel() & DEBUG_T1_TEST) {
    
            LARGE_INTEGER Ticks;
            UCHAR RandomVal;
            KeQueryTickCount(&Ticks);

            RandomVal = (UCHAR) Ticks.LowPart % 4;

            if (RandomVal == 0) {

                smartcardRequest->Buffer[smartcardRequest->BufferLength - 1] += 1;

                SmartcardDebug(
                    DEBUG_ERROR,
                    (TEXT("%s!SmartcardT1Request: Simulating bad checksum\n"),
                    DRIVER_NAME)
                    );
            }
        }
#endif

        DumpT1Block(
            smartcardRequest->Buffer + headerSize,
            SmartcardExtension->CardCapabilities.T1.EDC
            );
#endif

        //
        // If the card uses invers convention invert the data
        // NOTE: do not invert any header data the reader may use
        //
        if (SmartcardExtension->CardCapabilities.InversConvention) {

            SmartcardInvertData(
                &smartcardRequest->Buffer[smartcardRequest->BufferLength],
                (SmartcardExtension->CardCapabilities.T1.EDC & T1_CRC_CHECK ? 5 : 4) +
                t1SendFrame.Len
                );
        }

        //
        // Update the number of bytes that are in the buffer
        // A T1 block is at least 4 bytes long with LRC check and 5 bytes with CRC check
        //
        smartcardRequest->BufferLength +=
            (SmartcardExtension->CardCapabilities.T1.EDC & T1_CRC_CHECK ? 5 : 4) +
            t1SendFrame.Len;
    }
    __finally {
        
#ifdef DEBUG_INTERFACE
        DebugGetT1Request(SmartcardExtension, status);
#endif
    }

    return status;
}        

NTSTATUS
#ifdef SMCLIB_VXD
SMCLIB_SmartcardT1Reply(
#else
SmartcardT1Reply(
#endif
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++                     
                         
 Routine Description:
 
 Arguments:
 
    DeviceObject - Supplies a pointer to the device object for this request.
    
 Return Value:
                         
--*/
    
{
    T1_BLOCK_FRAME t1RecFrame;
    NTSTATUS status = STATUS_MORE_PROCESSING_REQUIRED;
    PIO_HEADER IoHeader = (PIO_HEADER) SmartcardExtension->T1.ReplyData;
    BOOLEAN packetOk = TRUE, chksumOk = TRUE;

    ASSERT(IoHeader != NULL);

    if (IoHeader == NULL) {

        return STATUS_INTERNAL_ERROR;
    }

#ifdef DEBUG_INTERFACE
    if (DebugT1Reply(SmartcardExtension)) {
        
        // the debugger processed this packet which means
        // that we should not parse it.
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
#endif

    // signal that we received an answer
    SmartcardExtension->T1.WaitForReply = FALSE;

    // Invert the data of an inverse convention card
    if (SmartcardExtension->CardCapabilities.InversConvention) {

        SmartcardInvertData(
            SmartcardExtension->SmartcardReply.Buffer,
            SmartcardExtension->SmartcardReply.BufferLength
            );
    }

    // Clear waiting time extension
    SmartcardExtension->T1.Wtx = 0;

    try {                

        ULONG expectedLength = 
            SCARD_T1_PROLOGUE_LENGTH +
            SmartcardExtension->SmartcardReply.Buffer[2] +
            (SmartcardExtension->CardCapabilities.T1.EDC & T1_CRC_CHECK ? 2 : 1);

        if (SmartcardExtension->SmartcardReply.BufferLength < 4 ||
            SmartcardExtension->SmartcardReply.BufferLength != expectedLength) {

            SmartcardDebug(
                DEBUG_ERROR,
                (TEXT("%s!SmartcardT1Reply: Packet length incorrect\n"),
                DRIVER_NAME)
                );

            packetOk = FALSE;

        } else {
            
            // calculate the checksum
            chksumOk = SmartcardT1Chksum(
                SmartcardExtension->SmartcardReply.Buffer,
                SmartcardExtension->CardCapabilities.T1.EDC,
                TRUE
                );

#if DEBUG
#ifndef SMCLIB_VXD
            if (SmartcardGetDebugLevel() & DEBUG_T1_TEST) {

                // inject some checksum errors

                LARGE_INTEGER Ticks;
                UCHAR RandomVal;
                KeQueryTickCount(&Ticks);

                RandomVal = (UCHAR) Ticks.LowPart % 4;

                if (RandomVal == 0) {

                    chksumOk = FALSE;

                    SmartcardDebug(
                        DEBUG_ERROR,
                        (TEXT("%s!SmartcardT1Reply: Simulating bad checksum\n"),
                        DRIVER_NAME)
                        );
                }
            }
#endif
#endif
        }

        if (chksumOk == FALSE) {

            SmartcardDebug(
                DEBUG_ERROR,
                (TEXT("%s!SmartcardT1Reply: Bad checksum\n"), 
                DRIVER_NAME)
                );
        }

        if (packetOk == FALSE || chksumOk == FALSE) {

            SmartcardExtension->T1.LastError = 
                (chksumOk ? T1_ERROR_OTHER : T1_ERROR_CHKSUM);

            if (SmartcardExtension->T1.OriginalState == 0) {

                SmartcardExtension->T1.OriginalState = 
                    SmartcardExtension->T1.State;
            }
        
            if (SmartcardExtension->T1.Resend++ == T1_MAX_RETRIES) {
        
                SmartcardExtension->T1.Resend = 0;
            
                // Try to resynchronize since the resend requests have failed
                SmartcardExtension->T1.State = T1_RESYNCH_REQUEST;
                __leave;

            } 
            
            // If the last request was a resynch we try again to resynch
            if (SmartcardExtension->T1.State != T1_RESYNCH_REQUEST) {
        
                // Chksum not OK; request resend of last block
                SmartcardExtension->T1.State = T1_R_BLOCK;
            }
            __leave;
        }

        //
        // The checksum of the packet is ok.
        // Now check the rest of the packet
        //

        // Clear the last error
        SmartcardExtension->T1.LastError = 0;

        t1RecFrame.Nad = SmartcardExtension->SmartcardReply.Buffer[0];
        t1RecFrame.Pcb = SmartcardExtension->SmartcardReply.Buffer[1];
        t1RecFrame.Len = SmartcardExtension->SmartcardReply.Buffer[2];
        t1RecFrame.Inf = &SmartcardExtension->SmartcardReply.Buffer[3];

        // 
        // If the last block we sent was a ifs request, 
        // we expect the card to reply with an ifs response.
        //
        if (SmartcardExtension->T1.State == T1_IFS_REQUEST) {

            // Check if the card properly responded to an ifs request
            if (t1RecFrame.Pcb == T1_IFS_RESPONSE) {

                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Reply:   T1_IFSC_RESPONSE\n"),
                    DRIVER_NAME)
                    );

                // The smart card acked our ifsd size
                SmartcardExtension->T1.State = T1_I_BLOCK;
                __leave;
            }

            if ((t1RecFrame.Pcb & 0x82) == 0x82) {

                //
                // The card does not support ifs request, so we stop 
                // sending this and continue with a data block
                // (the card is NOT ISO conform)
                //
                SmartcardDebug(
                    DEBUG_ERROR,
                    (TEXT("%s!SmartcardT1Reply:   Card does not support IFS REQUEST\n"),
                    DRIVER_NAME)
                    );

                SmartcardExtension->T1.State = T1_I_BLOCK;
                __leave;
            }

            //
            // The card replied with junk to our ifs request.
            // It doesn't make sense to continue.
            //
            status = STATUS_DEVICE_PROTOCOL_ERROR;
            __leave;
        }
    
        // 
        // If the last block was a resync. request,
        // we expect the card to answer with a resynch response.
        //
        if (SmartcardExtension->T1.State == T1_RESYNCH_REQUEST) {

            // Check if the card properly responded to an resynch request
            if (t1RecFrame.Pcb != T1_RESYNCH_RESPONSE) {
        
                SmartcardDebug(
                    DEBUG_ERROR,
                    (TEXT("%s!SmartcardT1Reply:   Card response is not ISO conform! Aborting...\n"),
                    DRIVER_NAME)
                    );

                status = STATUS_DEVICE_PROTOCOL_ERROR;
                __leave;

            } 
            
            SmartcardDebug(
                DEBUG_PROTOCOL,
                (TEXT("%s!SmartcardT1Reply:   T1_RESYNCH_RESPONSE\n"),
                DRIVER_NAME)
                );

            // Reset error counter
            SmartcardExtension->T1.Resend = 0;

            // The smart card has successfully responded to a resynch request
            SmartcardExtension->T1.RSN = 0;
            SmartcardExtension->T1.SSN = 0;

            //
            // Do a complete restart of the whole transmission
            // but without resetting the resynch counter
            //
            SmartcardExtension->T1.State = T1_RESTART;
            __leave;
        }

        //
        // Now check for other protocol states...
        //
    
        //
        // Copy NAD value back to user buffer if this is an extended io-header
        // containing the nad
        //
        if (IoHeader->ScardIoRequest.cbPciLength > sizeof(SCARD_IO_REQUEST) &&
            IoHeader->Asn1Data[0] == 0x81 &&
            IoHeader->Asn1Data[1] == 0x01 &&
            IoHeader->Asn1Data[3] == 0x00) {

            IoHeader->Asn1Data[2] = t1RecFrame.Nad;             
        }

        if ((t1RecFrame.Pcb & 0x80) == 0) {

            // This is an I-block

            SmartcardDebug(
                DEBUG_PROTOCOL,
                (TEXT("%s!SmartcardT1Reply:   I(%d.%d) <-\n"),
                DRIVER_NAME,
                (t1RecFrame.Pcb & 0x40) >> 6,
                (t1RecFrame.Pcb & 0x20) >> 5)
                );

            if (((t1RecFrame.Pcb & 0x40) >> 6) == SmartcardExtension->T1.RSN) {

                // I-Block with correct sequence number
    
                PUCHAR data;
                ULONG minBufferSize;

                // Reset error counter and error indicator
                SmartcardExtension->T1.Resend = 0;
                SmartcardExtension->T1.OriginalState = 0;

                // We can 'increase' the number of correctly received I-Blocks
                SmartcardExtension->T1.RSN ^= 1;

                if (SmartcardExtension->T1.State == T1_I_BLOCK) {

                    // This I-Block is also an acknowledge for the I-Block we sent 
                    SmartcardExtension->T1.SSN ^= 1;
                }
        
                // Check size of user buffer
                minBufferSize = 
                    IoHeader->ScardIoRequest.cbPciLength +
                    SmartcardExtension->T1.BytesReceived +
                    t1RecFrame.Len;
        
                if (SmartcardExtension->IoRequest.ReplyBufferLength < minBufferSize) {
            
                    status = STATUS_BUFFER_TOO_SMALL;
                    __leave;
                }

                ASSERT(SmartcardExtension->T1.ReplyData);
                //
                // Let data pointer point behind struct.
                // All reply data will be stored there.
                // 
                data = 
                    SmartcardExtension->T1.ReplyData + 
                    IoHeader->ScardIoRequest.cbPciLength +
                    SmartcardExtension->T1.BytesReceived;

                // Copy data to user buffer
                RtlCopyMemory(
                    data,
                    t1RecFrame.Inf,
                    t1RecFrame.Len
                    );
              
                SmartcardExtension->T1.BytesReceived += t1RecFrame.Len;
        
                if (t1RecFrame.Pcb & T1_MORE_DATA) {
    
                    // Ack this block and request the next block
                    SmartcardExtension->T1.State = T1_R_BLOCK;
        
                } else {
        
                    //
                    // This was the last block of the transmission
                    // Set number of bytes returned by this transmission
                    //
                    *SmartcardExtension->IoRequest.Information = 
                        IoHeader->ScardIoRequest.cbPciLength + 
                        SmartcardExtension->T1.BytesReceived;

                    // Copy the result back to the user buffer
                    ASSERT(SmartcardExtension->IoRequest.ReplyBuffer != NULL);

                    RtlCopyMemory(
                        SmartcardExtension->IoRequest.ReplyBuffer,
                        SmartcardExtension->T1.ReplyData,
                        IoHeader->ScardIoRequest.cbPciLength +
                            SmartcardExtension->T1.BytesReceived                        
                        );
        
                    status = STATUS_SUCCESS;
                }
                __leave;
            }

            //
            // I-Block with wrong sequence number
            // We try T1_MAX_RETRIES times to resend the last block.
            // If this is unsuccessfull, we try to resynch.
            // If resynch is unsuccessfull we abort the transmission.
            //
            SmartcardDebug(
                DEBUG_ERROR,
                (TEXT("%s!SmartcardT1Reply: Block number incorrect\n"),
                DRIVER_NAME)
                );

            SmartcardExtension->T1.LastError = T1_ERROR_OTHER;

            if (SmartcardExtension->T1.OriginalState == 0) {
                
                SmartcardExtension->T1.OriginalState = 
                    SmartcardExtension->T1.State;
            }

            if (SmartcardExtension->T1.Resend++ == T1_MAX_RETRIES) {
    
                SmartcardExtension->T1.Resend = 0;
        
                // Try to resynchronize
                SmartcardExtension->T1.State = T1_RESYNCH_REQUEST;
                __leave;
            }

            // request the block again.
            SmartcardExtension->T1.State = T1_R_BLOCK;
            __leave;
        } 
    
        if ((t1RecFrame.Pcb & 0xC0) == 0x80) {

            // This is an R-block

            UCHAR RSN = (t1RecFrame.Pcb & 0x10) >> 4;
    
            SmartcardDebug(
                DEBUG_PROTOCOL,
                (TEXT("%s!SmartcardT1Reply:   R(%d) <-\n"),
                DRIVER_NAME,
                RSN)
                );
    
            if (RSN != SmartcardExtension->T1.SSN &&  
                SmartcardExtension->T1.MoreData) {
    
                // The ICC has acked the last block
                SmartcardExtension->T1.Resend = 0;

                SmartcardExtension->T1.BytesSent += SmartcardExtension->T1.InfBytesSent;
                SmartcardExtension->T1.BytesToSend -= SmartcardExtension->T1.InfBytesSent;
                SmartcardExtension->T1.SSN ^= 1;
                SmartcardExtension->T1.State = T1_I_BLOCK;

                __leave;
            } 

            //
            // We have an error condition...
            //

            ASSERT(t1RecFrame.Pcb & 0x0f);
            
            if ((t1RecFrame.Pcb & 0x02) && 
                SmartcardExtension->T1.State == T1_IFS_REQUEST) {

                //
                // The card does not support ifs request, so 
                // we stop sending this and continue with a data block
                // (the card is NOT ISO conform)
                //
                SmartcardDebug(
                    DEBUG_ERROR,
                    (TEXT("%s!SmartcardT1Reply:   Card does not support IFS REQUEST\n"),
                    DRIVER_NAME)
                    );

                SmartcardExtension->T1.State = T1_I_BLOCK;
                __leave;
            } 

            // We have to resend the last block
            SmartcardDebug(
                DEBUG_ERROR,
                (TEXT("%s!SmartcardT1Reply:   Card reports error\n"),
                DRIVER_NAME)
                );

            if (SmartcardExtension->T1.Resend++ == T1_MAX_RETRIES) {

                SmartcardExtension->T1.Resend = 0;
    
                if (SmartcardExtension->T1.OriginalState == 0) {
                
                    // Save current state
                    SmartcardExtension->T1.OriginalState = 
                        SmartcardExtension->T1.State;
                }

                // Try to resynchronize
                SmartcardExtension->T1.State = T1_RESYNCH_REQUEST;
            } 
            __leave;        
        } 

        //
        // This is an S-block
        // 

        switch (t1RecFrame.Pcb) {

            case T1_IFS_REQUEST:
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Reply:   T1_IFSC_REQUEST\n"),
                    DRIVER_NAME)
                    );

                // The smart card wants to exend the IFS - size
                SmartcardExtension->T1.IFSC = 
                    SmartcardExtension->SmartcardReply.Buffer[3];
       
                // Save current state
                ASSERT(SmartcardExtension->T1.OriginalState == 0);

                SmartcardExtension->T1.OriginalState =
                    SmartcardExtension->T1.State;

                SmartcardExtension->T1.State = T1_IFS_RESPONSE;
                break;
        
            case T1_ABORT_REQUEST:
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Reply:   T1_ABORT_REQUEST\n"),
                    DRIVER_NAME)
                    );

                SmartcardExtension->T1.State = T1_ABORT_RESPONSE;
                break;
        
            case T1_WTX_REQUEST:
                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    (TEXT("%s!SmartcardT1Reply:   T1_WTX_REQUEST\n"),
                    DRIVER_NAME)
                    );
            
                // Smart card needs longer wait time
                SmartcardExtension->T1.Wtx = 
                    SmartcardExtension->SmartcardReply.Buffer[3];

                // Save current state
                ASSERT(SmartcardExtension->T1.OriginalState == 0 ||
                       SmartcardExtension->T1.OriginalState == T1_WTX_RESPONSE);

                SmartcardExtension->T1.OriginalState =
                    SmartcardExtension->T1.State;
            
                SmartcardExtension->T1.State = T1_WTX_RESPONSE;
                break;
        
            case T1_VPP_ERROR:
                SmartcardDebug(
                    DEBUG_ERROR,
                    (TEXT("%s!SmartcardT1Reply:   T1_VPP_ERROR\n"),
                    DRIVER_NAME)
                    );

                status = STATUS_DEVICE_POWER_FAILURE;
                break;

            default:
                ASSERTMSG(
                    TEXT("SmartcardT1Reply: Invalid Pcb "),
                    FALSE
                    );

                status = STATUS_DEVICE_PROTOCOL_ERROR;
                break;
        }
    }
    finally {
        
#if DEBUG
        if (packetOk && chksumOk) {
            
            DumpT1Block(
                SmartcardExtension->SmartcardReply.Buffer,
                SmartcardExtension->CardCapabilities.T1.EDC
                );
        }
#endif

        if (SmartcardExtension->T1.State == T1_RESYNCH_REQUEST && 
            SmartcardExtension->T1.Resynch++ == T1_MAX_RETRIES) {
    
            SmartcardDebug(
                DEBUG_ERROR,
                (TEXT("%s!SmartcardT1Reply: Too many errors! Aborting...\n"),
                DRIVER_NAME)
                );

            status = STATUS_DEVICE_PROTOCOL_ERROR;
        }
            
        if (status != STATUS_MORE_PROCESSING_REQUIRED) {

            if (SmartcardExtension->T1.OriginalState == T1_IFS_REQUEST) {
        
                SmartcardExtension->T1.State = T1_IFS_REQUEST;

            } else {
        
                SmartcardExtension->T1.State = T1_START;
            }

            if (SmartcardExtension->T1.ReplyData) {
                
                // free the reply data buffer
#ifdef SMCLIB_VXD
                _HeapFree(SmartcardExtension->T1.ReplyData, 0);
#elif defined(SMCLIB_CE)
                LocalFree(SmartcardExtension->T1.ReplyData);
#else               
                
                ExFreePool(SmartcardExtension->T1.ReplyData);
#endif
                SmartcardExtension->T1.ReplyData = NULL;                
            }
            SmartcardExtension->T1.OriginalState = 0;
            SmartcardExtension->T1.NAD = 0;
        }

    }
    return status;
}

#if DEBUG
#pragma optimize( "", on )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\smclib\smcnt.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    smcnt.c

Abstract:

    This module handles all IOCTL requests to the smart card reader.

Environment:

    Kernel mode only.

Notes:

Revision History:

    - Created December 1996 by Klaus Schutz 

--*/

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>
#include <ntddk.h>

#define SMARTCARD_POOL_TAG 'bLCS'
#define _ISO_TABLES_
#include "smclib.h"

typedef struct _TAG_LIST_ENTRY {

    ULONG Tag;
    LIST_ENTRY List;

} TAG_LIST_ENTRY, *PTAG_LIST_ENTRY;

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

void
SmartcardDeleteLink(
    IN PUNICODE_STRING LinkName
    );

#pragma alloc_text(PAGEABLE,DriverEntry)
#pragma alloc_text(PAGEABLE,SmartcardCreateLink)
#pragma alloc_text(PAGEABLE,SmartcardDeleteLink)
#pragma alloc_text(PAGEABLE,SmartcardInitialize)
#pragma alloc_text(PAGEABLE,SmartcardExit)

NTSTATUS
SmartcardDeviceIoControl(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

PUCHAR 
MapIoControlCodeToString(
    ULONG IoControlCode
    );

#if DEBUG_INTERFACE
#include "smcdbg.c"
#else
NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )
{
    return STATUS_SUCCESS;  
}
#endif


NTSTATUS
SmartcardCreateLink(
    IN OUT PUNICODE_STRING LinkName,
    IN PUNICODE_STRING DeviceName
    )
/*++

Routine Description:

    This routine creates a symbolic link name for the given device name.
    NOTE: The buffer for the link name will be allocated here. The caller
    is responsible for freeing the buffer. 
    If the function fails no buffer is allocated.

Arguments:

    LinkName    - receives the created link name

    DeviceName  - the device name for which the link should be created

Return Value:

    None

--*/
{
    NTSTATUS status;
    ULONG i;
    PWCHAR buffer;

    ASSERT(LinkName != NULL);
    ASSERT(DeviceName != NULL);

    if (LinkName == NULL) {

        return STATUS_INVALID_PARAMETER_1;              
    }

    if (DeviceName == NULL) {

        return STATUS_INVALID_PARAMETER_2;              
    }

    buffer = ExAllocatePool(
        NonPagedPool,
        32 * sizeof(WCHAR)
        );

    ASSERT(buffer != NULL);
    if (buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;       
    }

    for (i = 0; i < MAXIMUM_SMARTCARD_READERS; i++) {

        swprintf(buffer, L"\\DosDevices\\SCReader%d", i);
        RtlInitUnicodeString(
            LinkName,
            buffer
            );

        status = IoCreateSymbolicLink(
            LinkName,
            DeviceName
            );

        if (NT_SUCCESS(status)) {

            SmartcardDebug(
                DEBUG_INFO,
                ("%s!SmartcardCreateLink: %ws linked to %ws\n",
                DRIVER_NAME,
                DeviceName->Buffer,
                LinkName->Buffer)
                );

            return status;
        }
    }

    ExFreePool(LinkName->Buffer);

    return status;
}   

void
SmartcardDeleteLink(
    IN PUNICODE_STRING LinkName
    )
{
    //
    // Delete the symbolic link of the smart card reader
    //
    IoDeleteSymbolicLink(
        LinkName
        );

    // 
    // Free allocated buffer
    // 
    ExFreePool(
        LinkName->Buffer
        );  
}

NTSTATUS
SmartcardInitialize(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This function allocated the send and receive buffers for smart card 
    data. It also sets the pointer to 2 ISO tables to make them accessible 
    to the driver
    
Arguments:

    SmartcardExtension 

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    SmartcardDebug(
        DEBUG_INFO,
        ("%s!SmartcardInitialize: Enter. Version %lx, %s %s\n",
        DRIVER_NAME,
        SMCLIB_VERSION,
        __DATE__,
        __TIME__)
        );

    ASSERT(SmartcardExtension != NULL);
    ASSERT(SmartcardExtension->OsData == NULL);

    if (SmartcardExtension == NULL) {

        return STATUS_INVALID_PARAMETER_1;      
    }

    if (SmartcardExtension->Version > SMCLIB_VERSION ||
        SmartcardExtension->Version < SMCLIB_VERSION_REQUIRED) {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!SmartcardInitialize: Incompatible version in SMARTCARD_EXTENSION.\n",
            DRIVER_NAME)
            );

        return STATUS_UNSUCCESSFUL;
    }

    if (SmartcardExtension->SmartcardRequest.BufferSize < MIN_BUFFER_SIZE) {

        SmartcardDebug(
            DEBUG_ERROR, 
            ("%s!SmartcardInitialize: WARNING: SmartcardRequest.BufferSize (%ld) < MIN_BUFFER_SIZE (%ld)\n",
            DRIVER_NAME,
            SmartcardExtension->SmartcardRequest.BufferSize,
            MIN_BUFFER_SIZE)
            );
        
        SmartcardExtension->SmartcardRequest.BufferSize = MIN_BUFFER_SIZE;
    }   

    if (SmartcardExtension->SmartcardReply.BufferSize < MIN_BUFFER_SIZE) {

        SmartcardDebug(
            DEBUG_ERROR, 
            ("%s!SmartcardInitialize: WARNING: SmartcardReply.BufferSize (%ld) < MIN_BUFFER_SIZE (%ld)\n",
            DRIVER_NAME,
            SmartcardExtension->SmartcardReply.BufferSize,
            MIN_BUFFER_SIZE)
            );
        
        SmartcardExtension->SmartcardReply.BufferSize = MIN_BUFFER_SIZE;
    }   

    SmartcardExtension->SmartcardRequest.Buffer = ExAllocatePool(
        NonPagedPool,
        SmartcardExtension->SmartcardRequest.BufferSize
        );

    SmartcardExtension->SmartcardReply.Buffer = ExAllocatePool(
        NonPagedPool,
        SmartcardExtension->SmartcardReply.BufferSize
        );

    SmartcardExtension->OsData = ExAllocatePool(
        NonPagedPool,
        sizeof(OS_DEP_DATA)
        );

#if defined(DEBUG) && defined(SMCLIB_NT)
    SmartcardExtension->PerfInfo = ExAllocatePool(
        NonPagedPool,
        sizeof(PERF_INFO)
        );
#endif

    //
    // Check if one of the above allocations failed
    //
    if (SmartcardExtension->SmartcardRequest.Buffer == NULL ||
        SmartcardExtension->SmartcardReply.Buffer == NULL ||
        SmartcardExtension->OsData == NULL 
#if defined(DEBUG) && defined(SMCLIB_NT)
        || SmartcardExtension->PerfInfo == NULL
#endif
        ) {

        status = STATUS_INSUFFICIENT_RESOURCES;

        if (SmartcardExtension->SmartcardRequest.Buffer) {

            ExFreePool(SmartcardExtension->SmartcardRequest.Buffer);        
        }

        if (SmartcardExtension->SmartcardReply.Buffer) {
            
            ExFreePool(SmartcardExtension->SmartcardReply.Buffer);      
        }

        if (SmartcardExtension->OsData) {
            
            ExFreePool(SmartcardExtension->OsData);         
        }
#if defined(DEBUG) && defined(SMCLIB_NT)
        if (SmartcardExtension->PerfInfo) {
            
            ExFreePool(SmartcardExtension->PerfInfo);       
        }
#endif
    }

    if (status != STATUS_SUCCESS) {

        return status;      
    }

    RtlZeroMemory(
        SmartcardExtension->OsData,
        sizeof(OS_DEP_DATA)
        );

#if defined(DEBUG) && defined(SMCLIB_NT)
    RtlZeroMemory(
        SmartcardExtension->PerfInfo,
        sizeof(PERF_INFO)
        );
#endif

    // Initialize the mutex that is used to synch. access to the driver
    KeInitializeMutex(
        &(SmartcardExtension->OsData->Mutex),
        0
        );

    KeInitializeSpinLock(
        &(SmartcardExtension->OsData->SpinLock)
        );

    // initialize the remove lock
    SmartcardExtension->OsData->RemoveLock.Removed = FALSE;
    SmartcardExtension->OsData->RemoveLock.RefCount = 1;
    KeInitializeEvent(
        &SmartcardExtension->OsData->RemoveLock.RemoveEvent,
        SynchronizationEvent,
        FALSE
        );
    InitializeListHead(&SmartcardExtension->OsData->RemoveLock.TagList);

    // Make the 2 ISO tables accessible to the driver
    SmartcardExtension->CardCapabilities.ClockRateConversion = 
        &ClockRateConversion[0];

    SmartcardExtension->CardCapabilities.BitRateAdjustment = 
        &BitRateAdjustment[0];

#ifdef DEBUG_INTERFACE
    SmclibCreateDebugInterface(SmartcardExtension);
#endif

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!SmartcardInitialize: Exit\n",
        DRIVER_NAME)
        );

    return status;
}

VOID 
SmartcardExit(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine frees the send and receive buffer.
    It is usually called when the driver unloads.
    
Arguments:

    SmartcardExtension 

--*/
{
    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!SmartcardExit: Enter\n",
        DRIVER_NAME)
        );

#ifdef DEBUG_INTERFACE
    SmclibDeleteDebugInterface(SmartcardExtension);
#endif

    //
    // Free all allocated buffers
    //
    if (SmartcardExtension->SmartcardRequest.Buffer) {

        ExFreePool(SmartcardExtension->SmartcardRequest.Buffer);
        SmartcardExtension->SmartcardRequest.Buffer = NULL;
    }   

    if (SmartcardExtension->SmartcardReply.Buffer) {

        ExFreePool(SmartcardExtension->SmartcardReply.Buffer);
        SmartcardExtension->SmartcardReply.Buffer = NULL;
    }

    if (SmartcardExtension->OsData) {

        ExFreePool(SmartcardExtension->OsData);
        SmartcardExtension->OsData = NULL;
    }

#if defined(DEBUG) && defined(SMCLIB_NT)
    if (SmartcardExtension->PerfInfo) {
        
        ExFreePool(SmartcardExtension->PerfInfo);
        SmartcardExtension->OsData = NULL;
    }
#endif

    if (SmartcardExtension->T1.ReplyData) {
        
        // free the reply data buffer for T=1 transmissions
        ExFreePool(SmartcardExtension->T1.ReplyData);
        SmartcardExtension->T1.ReplyData = NULL;                
    }

    SmartcardDebug(
        DEBUG_INFO,
        ("%s!SmartcardExit: Exit - Device %.*s\n",
        DRIVER_NAME,
        SmartcardExtension->VendorAttr.VendorName.Length,
        SmartcardExtension->VendorAttr.VendorName.Buffer)
        );
}   

NTSTATUS
SmartcardAcquireRemoveLockWithTag(
    IN PSMARTCARD_EXTENSION SmartcardExtension,
    ULONG Tag
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    LONG refCount;
#ifdef DEBUG
    PTAG_LIST_ENTRY tagListEntry;
#endif

    refCount = InterlockedIncrement(
        &SmartcardExtension->OsData->RemoveLock.RefCount
        );

    ASSERT(refCount > 0);

    if (SmartcardExtension->OsData->RemoveLock.Removed == TRUE) {

        if (InterlockedDecrement (
                &SmartcardExtension->OsData->RemoveLock.RefCount
                ) == 0) {

            KeSetEvent(
                &SmartcardExtension->OsData->RemoveLock.RemoveEvent, 
                0, 
                FALSE
                );
        }
        status = STATUS_DELETE_PENDING;
    }

#ifdef DEBUG
    tagListEntry = (PTAG_LIST_ENTRY) ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(TAG_LIST_ENTRY),
        SMARTCARD_POOL_TAG
        );

    ASSERT(tagListEntry);

    if (tagListEntry == NULL) {

        return status;
    }

    tagListEntry->Tag = Tag;

    InsertHeadList(
        &SmartcardExtension->OsData->RemoveLock.TagList,
        &tagListEntry->List
        );
#endif

    return status;
}

NTSTATUS
SmartcardAcquireRemoveLock(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
{
    return SmartcardAcquireRemoveLockWithTag(
        SmartcardExtension,
        0
        );
}

VOID
SmartcardReleaseRemoveLockWithTag(
    IN PSMARTCARD_EXTENSION SmartcardExtension,
    IN ULONG Tag
    )
{
    LONG refCount;
#ifdef DEBUG
    PLIST_ENTRY entry;
    BOOLEAN tagFound = FALSE;
#endif
    
    refCount = InterlockedDecrement(
        &SmartcardExtension->OsData->RemoveLock.RefCount
        );

    ASSERT(refCount >= 0);

#ifdef DEBUG
    for (entry = SmartcardExtension->OsData->RemoveLock.TagList.Flink;
         entry->Flink != SmartcardExtension->OsData->RemoveLock.TagList.Flink;
         entry = entry->Flink) {

        PTAG_LIST_ENTRY tagListEntry = CONTAINING_RECORD(entry, TAG_LIST_ENTRY, List);

        if (Tag == tagListEntry->Tag) {

            tagFound = TRUE;
            RemoveEntryList(entry);
            ExFreePool(tagListEntry);
            break;
        }
    }

    ASSERTMSG("SmartcardReleaseRemoveLock() called with unknown tag", tagFound == TRUE);
#endif  

    if (refCount == 0) {

        ASSERT (SmartcardExtension->OsData->RemoveLock.Removed);

        //
        // The device needs to be removed.  Signal the remove event
        // that it's safe to go ahead.
        //
        KeSetEvent(
            &SmartcardExtension->OsData->RemoveLock.RemoveEvent,
            IO_NO_INCREMENT,
            FALSE
            );
    }
}

VOID
SmartcardReleaseRemoveLock(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
{
    SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 0);
}

VOID
SmartcardReleaseRemoveLockAndWait(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
{   
    LONG refCount;

    PAGED_CODE ();

    ASSERT(SmartcardExtension->OsData->RemoveLock.Removed == FALSE);

    SmartcardExtension->OsData->RemoveLock.Removed = TRUE;

    refCount = InterlockedDecrement (
        &SmartcardExtension->OsData->RemoveLock.RefCount
        );

    ASSERT (refCount > 0);

    if (InterlockedDecrement (
            &SmartcardExtension->OsData->RemoveLock.RefCount
            ) > 0) {

#ifdef DEBUG
        // walk the tag list and print all currently held locks
        PLIST_ENTRY entry;

        for (entry = SmartcardExtension->OsData->RemoveLock.TagList.Flink;
             entry->Flink != SmartcardExtension->OsData->RemoveLock.TagList.Flink;
             entry = entry->Flink) {

            PTAG_LIST_ENTRY tagListEntry = CONTAINING_RECORD(entry, TAG_LIST_ENTRY, List);

            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!SmartcardReleaseRemoveLockAndWait: Device %.*s holds lock '%.4s'\n",
                DRIVER_NAME,
                SmartcardExtension->VendorAttr.VendorName.Length,
                SmartcardExtension->VendorAttr.VendorName.Buffer,
                &(tagListEntry->Tag))
                );
        }
#endif

        KeWaitForSingleObject (
            &SmartcardExtension->OsData->RemoveLock.RemoveEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

#ifdef DEBUG
        // free all locks.
        entry = SmartcardExtension->OsData->RemoveLock.TagList.Flink;

        while (entry->Flink != 
               SmartcardExtension->OsData->RemoveLock.TagList.Flink) {

            PTAG_LIST_ENTRY tagListEntry = CONTAINING_RECORD(entry, TAG_LIST_ENTRY, List);
            RemoveEntryList(entry);
            ExFreePool(tagListEntry);
            entry = SmartcardExtension->OsData->RemoveLock.TagList.Flink;
        }
#endif
    }

    SmartcardDebug(
        DEBUG_INFO,
        ("%s!SmartcardReleaseRemoveLockAndWait: Exit - Device %.*s\n",
        DRIVER_NAME,
        SmartcardExtension->VendorAttr.VendorName.Length,
        SmartcardExtension->VendorAttr.VendorName.Buffer)
        );
}
    

VOID
SmartcardLogError(
    IN  PVOID Object,
    IN  NTSTATUS ErrorCode,
    IN  PUNICODE_STRING Insertion,
    IN  ULONG DumpData
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DeviceObject -  Supplies a pointer to the device object associated
                    with the device that had the error, early in
                    initialization, one may not yet exist.

    Insertion -     An insertion string that can be used to log
                    additional data. Note that the message file
                    needs %2 for this insertion, since %1
                    is the name of the driver

    ErrorCode -     Supplies the IO status for this particular error.

    DumpData -      One word to dump

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;

    errorLogEntry = IoAllocateErrorLogEntry(
        Object,
        (UCHAR) (
            sizeof(IO_ERROR_LOG_PACKET) + 
            (Insertion ? Insertion->Length + sizeof(WCHAR) : 0)
            )
        );

    ASSERT(errorLogEntry != NULL);

    if (errorLogEntry == NULL) {

        return;
    }

    errorLogEntry->ErrorCode = ErrorCode;
    errorLogEntry->SequenceNumber = 0;
    errorLogEntry->MajorFunctionCode = 0;
    errorLogEntry->RetryCount = 0;
    errorLogEntry->UniqueErrorValue = 0;
    errorLogEntry->FinalStatus = STATUS_SUCCESS;
    errorLogEntry->DumpDataSize = (DumpData ? sizeof(ULONG) : 0);
    errorLogEntry->DumpData[0] = DumpData;

    if (Insertion) {

        errorLogEntry->StringOffset = 
            sizeof(IO_ERROR_LOG_PACKET);

        errorLogEntry->NumberOfStrings = 1;

        RtlCopyMemory(
            ((PCHAR)(errorLogEntry) + errorLogEntry->StringOffset),
            Insertion->Buffer,
            Insertion->Length
            );
    } 

    IoWriteErrorLogEntry(errorLogEntry);
}

NTSTATUS
SmartcardDeviceControl(
    PSMARTCARD_EXTENSION SmartcardExtension,
    PIRP Irp
    )
/*++

Routine Description:

    The routine is the general device control dispatch function. 

Arguments:

    SmartcardExtension  - The pointer to the smart card datae 
    Irp                 - Supplies the Irp making the request.

Return Value:

   NTSTATUS

--*/

{
    PIO_STACK_LOCATION  ioStackLocation = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN ClearCurrentIrp = TRUE;
    UNICODE_STRING Message;
    static BOOLEAN logged = FALSE;
    ULONG ioControlCode = ioStackLocation->Parameters.DeviceIoControl.IoControlCode;

    // Check the pointer to the smart card extension
    ASSERT(SmartcardExtension != NULL);

    if (SmartcardExtension == NULL) {
        
        return STATUS_INVALID_PARAMETER_1;
    }

    // Check the version that the driver requires
    ASSERT(SmartcardExtension->Version >= SMCLIB_VERSION_REQUIRED);

    if (SmartcardExtension->Version < SMCLIB_VERSION_REQUIRED) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Check the OsData pointer. This can be NULL if SmartcardInit 
    // has not been called or SmartcardExit has already been called
    //
    ASSERT(SmartcardExtension->OsData != NULL);

    // Check that the driver has set the DeviceObject
    ASSERT(SmartcardExtension->OsData->DeviceObject != NULL);

    if (SmartcardExtension->OsData == NULL ||
        SmartcardExtension->OsData->DeviceObject == NULL) {

        return STATUS_INVALID_PARAMETER;        
    }

    // We must run at passive level otherwise IoCompleteRequest won't work properly
    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    // check that no one wants us to do unbuffered io
    if (ioControlCode & (METHOD_IN_DIRECT | METHOD_OUT_DIRECT)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // This resource acts as a mutex. We can't use a 'real' mutex here,
    // since a mutex rises the Irql to APC_LEVEL. This leads to some
    // side effects we don't want.
    // E.g. IoCompleteRequest() will not copy requested data at APC_LEVEL
    //
    KeWaitForMutexObject(
        &(SmartcardExtension->OsData->Mutex),
        UserRequest,
        KernelMode,
        FALSE,
        NULL
        );

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    // Check if this is really an IOCTL for a smart card driver
    ASSERT((ioControlCode >> 16) == FILE_DEVICE_SMARTCARD);

#ifdef developerversion
#if DEBUG
    if(!logged) {
        
        RtlInitUnicodeString(
            &Message,
            L"Developer version of smclib.sys installed"
            );

        SmartcardLogError(
            SmartcardExtension->OsData->DeviceObject,
            STATUS_LICENSE_VIOLATION, 
            &Message,
            0            
            );

        logged = TRUE;
    }
#endif
#endif

    SmartcardDebug(
        DEBUG_IOCTL,
        ("SMCLIB!SmartcardDeviceControl: Enter <%.*s:%1d>, IOCTL = %s, IRP = %lx\n",
        SmartcardExtension->VendorAttr.VendorName.Length,
        SmartcardExtension->VendorAttr.VendorName.Buffer,
        SmartcardExtension->VendorAttr.UnitNo,
        MapIoControlCodeToString(ioControlCode),
        Irp)
        );

    // Return if device is busy
    if (SmartcardExtension->OsData->CurrentIrp != NULL) {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!SmartcardDeviceControl: Device %.*s is busy\n",
            DRIVER_NAME,
            SmartcardExtension->VendorAttr.VendorName.Length,
            SmartcardExtension->VendorAttr.VendorName.Buffer)
            );

        // This flag is used to signal that we can't set the current irp to NULL
        ClearCurrentIrp = FALSE;

        status = STATUS_DEVICE_BUSY;    
    }

    if (status == STATUS_SUCCESS) {

        PIRP notificationIrp;
        ULONG currentState;
        KIRQL irql;

        AccessUnsafeData(&irql);
        notificationIrp = SmartcardExtension->OsData->NotificationIrp;
        currentState = SmartcardExtension->ReaderCapabilities.CurrentState;
        EndAccessUnsafeData(irql);

        switch (ioControlCode) {

            //
            // We have to check for _IS_ABSENT and _IS_PRESENT first, 
            // since these are (the only allowed) asynchronous requests
            //
            case IOCTL_SMARTCARD_IS_ABSENT:

                ClearCurrentIrp = FALSE;

                if (SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING] == NULL) {

                    status = STATUS_NOT_SUPPORTED;
                    break;
                }


                // Now check if the driver is already processing a notification irp
                if (notificationIrp != NULL) {

                    status = STATUS_DEVICE_BUSY;
                    break;                  
                }

                //
                // if the current state is not known, it doesn't make sense 
                // to process this call
                //
                if (currentState == SCARD_UNKNOWN) {

                    status = STATUS_INVALID_DEVICE_STATE;
                    break;
                }

                //
                // If the card is already (or still) absent, we can return immediatly.
                // Otherwise we must statrt event tracking.
                // 
                if (currentState > SCARD_ABSENT) {

                    AccessUnsafeData(&irql);

                    SmartcardExtension->OsData->NotificationIrp = Irp;
                    SmartcardExtension->MajorIoControlCode = 
                        IOCTL_SMARTCARD_IS_ABSENT;

                    EndAccessUnsafeData(irql);

                    status = SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING](
                        SmartcardExtension
                        );
                }
                break;
                
            case IOCTL_SMARTCARD_IS_PRESENT:

                ClearCurrentIrp = FALSE;

                if (SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING] == NULL) {

                    status = STATUS_NOT_SUPPORTED;
                    break;
                }

                // Now check if the driver is already processing a notification irp
                if (notificationIrp != NULL) {

                    status = STATUS_DEVICE_BUSY;
                    break;                  
                }

                //
                // if the current state is not known, it doesn't make sense 
                // to process this call
                //
                if (currentState == SCARD_UNKNOWN) {

                    status = STATUS_INVALID_DEVICE_STATE;
                    break;
                }

                //
                // If the card is already (or still) present, we can return immediatly.
                // Otherwise we must statrt event tracking.
                // 
                if (currentState <= SCARD_ABSENT) {

#if defined(DEBUG) && defined(SMCLIB_NT)
                    ULONG timeInMilliSec = (ULONG)
                        SmartcardExtension->PerfInfo->IoTickCount.QuadPart *
                        KeQueryTimeIncrement() /
                        10000;

                    ULONG bytesTransferred = 
                        SmartcardExtension->PerfInfo->BytesSent + 
                        SmartcardExtension->PerfInfo->BytesReceived;

                    // to avoid div. errors and to display only useful information
                    // we check for a valid time.
                    if (timeInMilliSec > 0) {
                        
                        SmartcardDebug(
                            DEBUG_PERF,
                            ("%s!SmartcardDeviceControl: I/O statistics for device %.*s:\n    Transferrate: %5ld bps\n     Total bytes: %5ld\n        I/O time: %5ld ms\n   Transmissions: %5ld\n",
                            DRIVER_NAME,
                            SmartcardExtension->VendorAttr.VendorName.Length,
                            SmartcardExtension->VendorAttr.VendorName.Buffer,
                            bytesTransferred * 1000 / timeInMilliSec,
                            bytesTransferred,
                            timeInMilliSec,
                            SmartcardExtension->PerfInfo->NumTransmissions)
                            );                              
                    }
                    // reset performance info
                    RtlZeroMemory(
                        SmartcardExtension->PerfInfo, 
                        sizeof(PERF_INFO)
                        );
#endif
                    AccessUnsafeData(&irql);

                    SmartcardExtension->OsData->NotificationIrp = Irp;
                    SmartcardExtension->MajorIoControlCode = 
                        IOCTL_SMARTCARD_IS_PRESENT;

                    EndAccessUnsafeData(irql);

                    status = SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING](
                        SmartcardExtension
                        );
                }
                break;

            default:
                // Get major io control code
                SmartcardExtension->MajorIoControlCode = ioControlCode;

                // Check if buffers are properly allocated
                ASSERT(SmartcardExtension->SmartcardRequest.Buffer);
                ASSERT(SmartcardExtension->SmartcardReply.Buffer);

                if (Irp->AssociatedIrp.SystemBuffer && 
                    ioStackLocation->Parameters.DeviceIoControl.InputBufferLength >= 
                    sizeof(ULONG)) {

                    //
                    // Transfer minor io control code, even if it doesn't make sense for
                    // this particular major code
                    //
                    SmartcardExtension->MinorIoControlCode = 
                        *(PULONG) (Irp->AssociatedIrp.SystemBuffer);
                }

                SmartcardExtension->OsData->CurrentIrp = Irp;

                // Save pointer to and length of request buffer
                SmartcardExtension->IoRequest.RequestBuffer = 
                    Irp->AssociatedIrp.SystemBuffer;
                SmartcardExtension->IoRequest.RequestBufferLength = 
                    ioStackLocation->Parameters.DeviceIoControl.InputBufferLength,

                // Save pointer to and length of reply buffer
                SmartcardExtension->IoRequest.ReplyBuffer = 
                    Irp->AssociatedIrp.SystemBuffer;
                SmartcardExtension->IoRequest.ReplyBufferLength = 
                    ioStackLocation->Parameters.DeviceIoControl.OutputBufferLength;

                //
                // Pointer to variable that receives the actual number 
                // of bytes returned
                //
                SmartcardExtension->IoRequest.Information = 
                    (PULONG) &Irp->IoStatus.Information;

                // Default number of bytes returned
                Irp->IoStatus.Information = 0;
//                Irp->IoStatus.Status = STATUS_PENDING;
//                IoMarkIrpPending(Irp);

                // Process the device io-control-request
                status = SmartcardDeviceIoControl(SmartcardExtension);
                if (status == STATUS_PENDING) {
                   IoMarkIrpPending(Irp);
                }
#ifndef NO_LOG
                if (!NT_SUCCESS(status) && status != STATUS_NOT_SUPPORTED) {

                    UNICODE_STRING error;
                    WCHAR buffer[128];

                    swprintf(
                        buffer, 
                        L"IOCTL %S failed with status 0x%lx", 
                        MapIoControlCodeToString(ioControlCode),
                        status
                        );
                        
                    RtlInitUnicodeString(
                        &error,
                        buffer
                        );

                    SmartcardLogError(
                        SmartcardExtension->OsData->DeviceObject,
                        0,
                        &error,
                        0            
                        );
                }
#endif
                break;
        }
    }

    if (status == STATUS_PENDING)  {

        KIRQL irql;
        BOOLEAN pending = FALSE;
        
        //
        // Send command to smartcard. The ISR receives the result and queues a dpc function
        // that handles the completion of the call;
        //
        SmartcardDebug(
            DEBUG_IOCTL,
            ("%s!SmartcardDeviceControl: IoMarkIrpPending. IRP = %x\n",
            DRIVER_NAME,
            Irp)
            );

        //
        // When the driver completes an Irp (Notification or Current) it has 
        // to set either the Irp back to 0 in order to show that it completed 
        // the Irp. 
        // 
        AccessUnsafeData(&irql);

        if (Irp == SmartcardExtension->OsData->NotificationIrp || 
            Irp == SmartcardExtension->OsData->CurrentIrp) {
            
            pending = TRUE;
        }

        EndAccessUnsafeData(irql);

        if (pending && 
            SmartcardExtension->OsData->DeviceObject->DriverObject->DriverStartIo) {

            SmartcardDebug(
                DEBUG_IOCTL,
                ("%s!SmartcardDeviceControl: IoStartPacket. IRP = %x\n",
                DRIVER_NAME,
                Irp)
                );

            // Start io-processing of a lowest level driver
            IoStartPacket(
                SmartcardExtension->OsData->DeviceObject, 
                Irp, 
                NULL, 
                NULL
                );
        }
        
    } else {
    
        SmartcardDebug(
            DEBUG_IOCTL,
            ("%s!SmartcardDeviceControl: IoCompleteRequest. IRP = %x (%lxh)\n",
            DRIVER_NAME,
            Irp,
            status)
            );
            
        Irp->IoStatus.Status = status;
    
        IoCompleteRequest(
            Irp, 
            IO_NO_INCREMENT
            );

        if (ClearCurrentIrp) {

            //
            // If the devcie is not busy, we can set the current irp back to NULL
            //
            SmartcardExtension->OsData->CurrentIrp = NULL;
            RtlZeroMemory(
                &(SmartcardExtension->IoRequest),
                sizeof(SmartcardExtension->IoRequest)
                );
        }
    }

    SmartcardDebug(
        (NT_SUCCESS(status) ? DEBUG_IOCTL : DEBUG_ERROR),
        ("SMCLIB!SmartcardDeviceControl: Exit. IOCTL = %s, IRP = %x (%lxh)\n",
        MapIoControlCodeToString(ioControlCode),
        Irp,
        status)
        );

    //
    // Release our 'mutex'
    //
    KeReleaseMutex(
        &(SmartcardExtension->OsData->Mutex),
        FALSE
        );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\smclib\vxd\smcvxd.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    smcvxd.c

Abstract:

    This is the Windows 9x specific driver file for the smart card library.
    The smart card library is actually more a library as a driver.
    It contains support functions for smart card driver/reader systems.
    This driver should be loaded through an entry in the registry.

Environment:

    Windows 9x Static VxD

Notes:

Revision History:

    - Created June 1997 by Klaus Schutz

--*/

#define _ISO_TABLES_
#define WIN40SERVICES
#include "..\..\inc\smclib.h"

#define REGISTRY_PATH_LEN 128
static PUCHAR DevicePath = "System\\CurrentControlSet\\Services\\VxD\\Smclib\\Devices";
static BOOLEAN DriverInitialized;

#include "errmap.h"

DWORD
_stdcall
SMCLIB_Init(void)
/*++

Routine Description:

    This function will be called by the Windows Kernel upon init of this driver

Arguments:

    -

Return Value:

    VXD_SUCCESS - This driver loaded successfully
    VXD_FAILURE - Load was not successful

--*/
{
    if (DriverInitialized == FALSE) {

        HANDLE hKey;
        ULONG i;

        DriverInitialized = TRUE;

        SmartcardDebug(
            DEBUG_DRIVER,
            ("%s(SMCLIB_Init): Enter. %s %s\n",
            DRIVER_NAME,
            __DATE__,
            __TIME__)
            );

        //
        // Delete old device names
        //
        if(_RegOpenKey(
            HKEY_LOCAL_MACHINE,
            DevicePath,
            &hKey
            ) != ERROR_SUCCESS) {

            SmartcardDebug(
                DEBUG_ERROR,
                ("%s(SMCLIB_Init): Unable to open registry key\n",
                DRIVER_NAME)
                );

        } else {

            _RegDeleteKey(
                hKey,
                ""
                );

            _RegCloseKey(hKey);
        }

        //
        // Create new device sub-key
        //
        _RegCreateKey(
            HKEY_LOCAL_MACHINE,
            DevicePath,
            &hKey
            );

        _RegCloseKey(hKey);
    }

    return(VXD_SUCCESS);
}

ULONG
SMCLIB_MapNtStatusToWinError(
    NTSTATUS status
    )
/*++

Routine Description:

  Maps a NT status code to a Win32 error value

Arguments:

  status - nt status code to map to a Win32 error value

Return Value:

  Win32 error value

--*/
{
    ULONG i;

    for (i = 0;i < sizeof(CodePairs) / sizeof(CodePairs[0]); i += 2) {

        if (CodePairs[i] == status) {

            return CodePairs[i + 1];

        }
    }

    SmartcardDebug(
        DEBUG_ERROR,
        ("%s(MapNtStatusToWinError): NTSTATUS %lx unknown\n",
        DRIVER_NAME,
        status)
        );

    //
    // We were unable to map the error code
    //
    return ERROR_GEN_FAILURE;
}

void
SMCLIB_Assert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    )
/*++

Routine Description:

    This is a simple assert function that gets called using the ASSERT
    macro. Windows 9x does not offer this functionality

Arguments:

    FailedAssertion - The assertion we tested
    FileName - Yes, this is the name of the source file
    LineNumber - What might this be ?
    Message - An additional message supplied using ASSERTMSG

Return Value:

    -

--*/
{
#ifdef DEBUG

    Debug_Printf(
        "Assertion Failed: %s in %s(%ld)",
        FailedAssertion,
        FileName,
        LineNumber
        );

    if (Message)
        Debug_Printf(" %s",Message);

    Debug_Printf("\n");

#endif
}

//#ifdef _vmm_add_ddb_to_do
BOOL
VXDINLINE
_VMM_Add_DDB(
   struct VxD_Desc_Block *pDeviceDDB
   )
/*++

Routine Description:

    This routine is used to create a new device instance for a driver
    that supports multiple instances - like a serial based driver that
    supports more than one device -

Arguments:

    pDeviceDDB - The DDB struct that is to be added to the system

Return Value:

    TRUE - Yope, it worked
    FALSE - Out of business (May be the device name already exists)

--*/
{
    _asm mov edi, pDeviceDDB
    VxDCall(VMM_Add_DDB)
    _asm {

        mov     eax, 1
        jnc     exit
        mov     eax, 0
exit:
    }
}

BOOL
VXDINLINE
_VMM_Remove_DDB(
   struct VxD_Desc_Block *pDeviceDDB
    )
/*++

Routine Description:

    Removes a DDB (device) that was created using VMM_Add_DDB

Arguments:

    The address of the DDB to remove

Return Value:

    TRUE - OK, DDB removed otherwise FALSE

--*/
{
    _asm mov edi, pDeviceDDB
    VxDCall(VMM_Remove_DDB)
    _asm {

        mov     eax, 1
        jnc     exit
        mov     eax, 0
exit:
    }
}
//#endif

PVMMDDB
SMCLIB_VxD_CreateDevice(
    char *Device,
    void (*ControlProc)(void)
    )
/*++

Routine Description:

    Creates a new device. This routine allows a driver to create additional devices.

Arguments:

    Device - Name of the device to be created. At most 8 characters
    ControlProc - Address of the VxD control procedure. (NOT the DeviceIoControl function!)

Return Value:

    The newly created DDB if successful or NULL otherwise

--*/
{
    PVMMDDB pDDB;
    UCHAR DeviceName[9];

    ASSERT(Device != NULL);
    ASSERT(strlen(Device) <= 8);
    ASSERT(ControlProc != NULL);

    if (strlen(Device) > 8) {

        return NULL;
    }

    _Sprintf(DeviceName, "%-8s", Device);

    //
    // Allocate space for the VxD description block
    //
    pDDB = (PVMMDDB) _HeapAllocate(
        sizeof(struct VxD_Desc_Block),
        HEAPZEROINIT
        );

    if (pDDB)
    {
        pDDB->DDB_SDK_Version         = DDK_VERSION;
        pDDB->DDB_Req_Device_Number   = UNDEFINED_DEVICE_ID;
        pDDB->DDB_Dev_Major_Version   = 1;
        pDDB->DDB_Dev_Minor_Version   = 0;
        memcpy(pDDB->DDB_Name, DeviceName, 8);
        pDDB->DDB_Init_Order          = UNDEFINED_INIT_ORDER;
        pDDB->DDB_Control_Proc        = (ULONG) ControlProc;
        pDDB->DDB_Reference_Data      = 0;
        pDDB->DDB_Prev                = 'Prev';
        pDDB->DDB_Size                = sizeof(struct VxD_Desc_Block);
        pDDB->DDB_Reserved1           = 'Rsv1';
        pDDB->DDB_Reserved2           = 'Rsv2';
        pDDB->DDB_Reserved3           = 'Rsv3';

        //
        // Now create the DDB
        //
        if (!_VMM_Add_DDB(pDDB)) {

            _HeapFree(pDDB, 0);
            return NULL;
        }
    }

    return pDDB;
}

BOOL
SMCLIB_VxD_DeleteDevice(
    PVMMDDB pDDB
    )
/*++

Routine Description:

    Deleted a device. This function can be used to delete
    a device that was created using VxD_CreateDevice

Arguments:

    pDDB - The DDB to be deleted

Return Value:

    TRUE - device successfully deleted
    FALSE - device not deleted

--*/
{
    ASSERT(pDDB != NULL);

    if(pDDB == NULL || !_VMM_Remove_DDB(pDDB)) {

        return FALSE;
    }

    _HeapFree(pDDB, 0);

    return TRUE;
}

DWORD
_stdcall
VxD_PageLock(
   DWORD lpMem,
   DWORD cbSize
   )
/*++

Routine Description:

  This function lock the page

Arguments:

  lpMem  - pointer to the datablock which has to be locked
  cbSize - length of the datablock

Return Value:

  - pointer to the locked datablock

--*/
{
    DWORD LinPageNum;
   DWORD LinOffset;
   DWORD nPages;
   DWORD dwRet;

    LinOffset = lpMem & 0xfff; // page offset of memory to map
    LinPageNum = lpMem >> 12;  // generate page number

    // Calculate # of pages to map globally
    nPages = ((lpMem + cbSize) >> 12) - LinPageNum + 1;

    //
    // Return global mapping of passed in pointer, as this new pointer
    // is how the memory must be accessed out of context.
    //
   dwRet = _LinPageLock(LinPageNum, nPages, PAGEMAPGLOBAL | PAGEMARKDIRTY);

   ASSERT(dwRet != 0);

    SmartcardDebug(
        DEBUG_ERROR,
        ("%s!VxD_PageLock: LinPageNum = %lx, nPages = %lx, dwRet = %lx\n",
        DRIVER_NAME,
        LinPageNum,
        nPages,
        dwRet)
        );

    return (dwRet + LinOffset);
}

void
_stdcall
VxD_PageUnlock(
   DWORD lpMem,
   DWORD cbSize
   )
/*++

Routine Description:

    This function unlocks a datablock

Arguments:

    lpMem - pointer to the datablock which has to be unlocked
    cbSize - length of the datablock

Return Value:

    -

--*/
{
    DWORD LinPageNum;
   DWORD nPages;
   DWORD dwRet;

    LinPageNum = lpMem >> 12;
    nPages = ((lpMem + cbSize) >> 12) - LinPageNum + 1;

    SmartcardDebug(
        DEBUG_ERROR,
        ("%s!VxD_PageUnlock: LinPageNum = %lx, nPages = %lx\n",
        DRIVER_NAME,
        LinPageNum,
        nPages)
        );

    // Free globally mapped memory
    dwRet = _LinPageUnlock(LinPageNum, nPages, PAGEMAPGLOBAL);

   ASSERT(dwRet != 0);
}

void
SMCLIB_SmartcardCompleteCardTracking(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine calls i/o completion for the pending
    card tracking operation. It also unlocks the previously
    locked memory that was used for the overlapped strucutre

Arguments:

    SmartcardExtension

Return Value:

    -

--*/
{
    if (SmartcardExtension->OsData->NotificationOverlappedData) {

        DWORD O_Internal = SmartcardExtension->OsData->NotificationOverlappedData->O_Internal;

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s(SmartcardCompleteCardTracking): Completing %lx\n",
            DRIVER_NAME,
         SmartcardExtension->OsData->NotificationOverlappedData)
            );

       //
       // set number of bytes returned to 0
       //
       SmartcardExtension->OsData->NotificationOverlappedData->O_InternalHigh = 0;

        _asm mov ebx, O_Internal

        VxDCall(VWIN32_DIOCCompletionRoutine)

       _HeapFree(
          SmartcardExtension->OsData->NotificationOverlappedData,
          0
          );

        SmartcardExtension->OsData->NotificationOverlappedData = NULL;
    }
}

void
SMCLIB_SmartcardCompleteRequest(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine calls i/o completion for a pending
    io operation. It also unlocks the previously
    locked memory that was used for the overlapped structure

Arguments:

    SmartcardExtension

Return Value:

    -

--*/
{
    DWORD O_Internal = SmartcardExtension->OsData->CurrentOverlappedData->O_Internal;

    _asm mov ebx, O_Internal

    VxDCall(VWIN32_DIOCCompletionRoutine)

   VxD_PageUnlock(
      (DWORD) SmartcardExtension->OsData->CurrentOverlappedData,
      sizeof(OVERLAPPED)
      );

   VxD_PageUnlock(
      (DWORD) SmartcardExtension->IoRequest.RequestBuffer,
        SmartcardExtension->IoRequest.RequestBufferLength
      );

   VxD_PageUnlock(
      (DWORD) SmartcardExtension->IoRequest.ReplyBuffer,
        SmartcardExtension->IoRequest.ReplyBufferLength
      );

    SmartcardExtension->OsData->CurrentDiocParams = NULL;
}

NTSTATUS
SMCLIB_SmartcardCreateLink(
   PUCHAR LinkName,
   PUCHAR DeviceName
   )
/*++

Routine Description:

    This routine creates a symbolic link name for the given device name.
    It means it creates a 'STRING-value' in the registry ..VxD\smclib\devices
    like SCReader[0-9] = DeviceName.
    The smart card resource manager uses these entries in order to figure out
    what smart card devices are currently running.
    We do this because we don't have the ability to create a dynamic device
    name like we can do in Windows NT.

Arguments:

   LinkName - receives the created link name
   DeviceName  - the device name for which the link should be created

Return Value:

    NTSTATUS

--*/
{
    PUCHAR Value;
    ULONG i;
    HANDLE hKey;

    if (DriverInitialized == FALSE) {

        SMCLIB_Init();
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s(SmartcardCreateLink): Enter\n",
        DRIVER_NAME)
        );

    ASSERT(LinkName != NULL);
    ASSERT(DeviceName != NULL);
    ASSERT(strlen(DeviceName) <= 12);

    if (LinkName == NULL) {

        return STATUS_INVALID_PARAMETER_1;
    }

    if (DeviceName == NULL) {

        return STATUS_INVALID_PARAMETER_2;
    }

    //
    // Open the key where the device names are stored
    //
    if(_RegOpenKey(
        HKEY_LOCAL_MACHINE,
        DevicePath,
        &hKey
        ) != ERROR_SUCCESS) {

        return STATUS_UNSUCCESSFUL;
    }

    //
    // Allocate a buffer for enumeration of the registry
    //
    Value = (PUCHAR) _HeapAllocate(REGISTRY_PATH_LEN, 0);

    if (Value == NULL) {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s(SmartcardCreateLink): Allocation failed\n",
            DRIVER_NAME)
            );

      return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now find a free device name
    //
    for (i = 0; i < MAXIMUM_SMARTCARD_READERS ; i++) {

        _Sprintf(
            Value,
            "SCReader%d",
            i
            );

        //
        // Check for existence of the key
        //

        if(_RegQueryValueEx(
            hKey,
            Value,
            NULL,
            NULL,
            NULL,
            NULL
            ) != ERROR_SUCCESS) {

            break;
        }
    }

    //
    // Free the buffer since we don't need it anymore
    //
    _HeapFree(Value, 0);

    if (i >= MAXIMUM_SMARTCARD_READERS) {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s(SmartcardCreateLink): Can't create link: Too many readers\n",
            DRIVER_NAME)
            );

        return STATUS_UNSUCCESSFUL;
    }

    //
    // Create the link name...
    //
    _Sprintf(
        LinkName,
        "SCReader%d",
        i
        );

    //
    // ...and store it in the registry
    //
    _RegSetValueEx(
        hKey,
        LinkName,
        NULL,
        REG_SZ,
        DeviceName,
        strlen(DeviceName)
        );

    _RegCloseKey(hKey);

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s(SmartcardCreateLink): Link %s created for Driver %s\n",
        DRIVER_NAME,
        LinkName,
        DeviceName)
        );

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s(SmartcardCreateLink): Exit\n",
        DRIVER_NAME)
        );

    return STATUS_SUCCESS;
}

NTSTATUS
SMCLIB_SmartcardDeleteLink(
   PUCHAR LinkName
   )
/*++

Routine Description:

   Deletes the link previously created with SmartcardCreateLink()
    This routine deletes the symbolic link name that is stored in the
    registry. A driver ususally calls this function upon unload.

Arguments:

    LinkName - The link that is to be deleted

Return Value:

    NTSTATUS

--*/
{
    HANDLE hKey;
    NTSTATUS status;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s(SmartcardDeleteLink): Enter\n",
        DRIVER_NAME)
        );

    ASSERT(LinkName);
    ASSERT(strlen(LinkName) <= 10);

    //
    // Open the key where the device names are stored
    //
    if(_RegOpenKey(
        HKEY_LOCAL_MACHINE,
        DevicePath,
        &hKey
        ) != ERROR_SUCCESS) {

        return STATUS_UNSUCCESSFUL;
    }

    if(_RegDeleteValue(
        hKey,
        LinkName
        ) == ERROR_SUCCESS) {

        SmartcardDebug(
            DEBUG_DRIVER,
            ("%s(SmartcardDeleteLink): Link %s deleted\n",
            DRIVER_NAME,
            LinkName)
            );

        status = STATUS_SUCCESS;

    } else {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s(SmartcardDeleteLink): Can't delete link %s\n",
            DRIVER_NAME,
            LinkName)
            );

        status = STATUS_UNSUCCESSFUL;
    }

    _RegCloseKey(hKey);

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s(SmartcardDeleteLink): Exit",
        DRIVER_NAME)
        );

    return status;
}

NTSTATUS
SMCLIB_SmartcardInitialize(
   PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

Routine Description:

   This function allocated the send and receive buffers for smart card
   data. It also sets the pointer to 2 ISO tables to make them accessible
   to the driver

Arguments:

    SmartcardExtension

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s(SmartcardInitialize): Enter - Version %lx, %s %s\n",
        DRIVER_NAME,
        SMCLIB_VERSION,
        __DATE__,
        __TIME__)
        );

    ASSERT(SmartcardExtension != NULL);
    ASSERT(SmartcardExtension->OsData == NULL);

    if (SmartcardExtension == NULL) {

        return STATUS_INVALID_PARAMETER;
    }

    if (SmartcardExtension->Version < SMCLIB_VERSION_REQUIRED) {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s(SmartcardInitialize): Invalid Version in SMARTCARD_EXTENSION. Must be %lx\n",
            DRIVER_NAME,
            SMCLIB_VERSION)
            );

        return STATUS_UNSUCCESSFUL;
    }

   if (SmartcardExtension->SmartcardRequest.BufferSize < MIN_BUFFER_SIZE) {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s(SmartcardInitialize): WARNING: SmartcardRequest.BufferSize (%ld) < MIN_BUFFER_SIZE (%ld)\n",
            DRIVER_NAME,
            SmartcardExtension->SmartcardRequest.BufferSize,
            MIN_BUFFER_SIZE)
            );

      SmartcardExtension->SmartcardRequest.BufferSize = MIN_BUFFER_SIZE;
      }

   if (SmartcardExtension->SmartcardReply.BufferSize < MIN_BUFFER_SIZE) {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s(SmartcardInitialize): WARNING: SmartcardReply.BufferSize (%ld) < MIN_BUFFER_SIZE (%ld)\n",
            DRIVER_NAME,
            SmartcardExtension->SmartcardReply.BufferSize,
            MIN_BUFFER_SIZE)
            );

      SmartcardExtension->SmartcardReply.BufferSize = MIN_BUFFER_SIZE;
      }

   SmartcardExtension->SmartcardRequest.Buffer = _HeapAllocate(
      SmartcardExtension->SmartcardRequest.BufferSize,
        0
      );

   SmartcardExtension->SmartcardReply.Buffer = _HeapAllocate(
      SmartcardExtension->SmartcardReply.BufferSize,
        0
      );

   SmartcardExtension->OsData = _HeapAllocate(
      sizeof(OS_DEP_DATA),
        0
      );

    //
    // Check if one of the above allocations failed
    //
    if (SmartcardExtension->SmartcardRequest.Buffer == NULL ||
        SmartcardExtension->SmartcardReply.Buffer == NULL ||
        SmartcardExtension->OsData == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;

        if (SmartcardExtension->SmartcardRequest.Buffer) {

            _HeapFree(SmartcardExtension->SmartcardRequest.Buffer, 0);
        }

        if (SmartcardExtension->SmartcardReply.Buffer) {

            _HeapFree(SmartcardExtension->SmartcardReply.Buffer, 0);
        }

        if (SmartcardExtension->OsData == NULL) {

            _HeapFree(SmartcardExtension->OsData, 0);
        }
    }

    if (status != STATUS_SUCCESS) {

        return status;
    }

    memset(SmartcardExtension->OsData, 0, sizeof(OS_DEP_DATA));

    //
    // Create mutex that is used to synch access to the driver
    //
    SmartcardExtension->OsData->Mutex = _CreateMutex(0, 0);

   //
   // Make the 2 ISO tables accessible to the driver
   //
   SmartcardExtension->CardCapabilities.ClockRateConversion =
      &ClockRateConversion[0];

   SmartcardExtension->CardCapabilities.BitRateAdjustment =
      &BitRateAdjustment[0];

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s(SmartcardInitialize): Exit\n",
        DRIVER_NAME)
        );

   return status;
}

VOID
SMCLIB_SmartcardExit(
   PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

Routine Description:

    This routine frees the send and receive buffer.
   It is usually called when the driver unloads.

Arguments:

    SmartcardExtension

Return Value:

    NTSTATUS

--*/
{
    SmartcardDebug(
        DEBUG_TRACE,
        ("%s(SmartcardExit): Enter\n",
        DRIVER_NAME)
        );

   if (SmartcardExtension->SmartcardRequest.Buffer) {

      _HeapFree(SmartcardExtension->SmartcardRequest.Buffer, 0);
   }

   if (SmartcardExtension->SmartcardReply.Buffer) {

      _HeapFree(SmartcardExtension->SmartcardReply.Buffer, 0);
   }

   if (SmartcardExtension->OsData) {

      _HeapFree(SmartcardExtension->OsData, 0);
   }

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s(SmartcardExit): Exit\n",
        DRIVER_NAME)
        );
}

VOID
SMCLIB_SmartcardLogError(
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:
Return Value:

--*/

{
    SmartcardDebug(
        DEBUG_ERROR,
        ("%s(SmartcardLogError): Not yet implemented\n",
        DRIVER_NAME)
        );
}


NTSTATUS
SMCLIB_SmartcardDeviceControl(
    PSMARTCARD_EXTENSION SmartcardExtension,
    DIOCPARAMETERS *lpDiocParams
    )
/*++

Routine Description:

    The routine is the general device control dispatch function for VxD drivers.

Arguments:

    SmartcardExtension  - The pointer to the smart card datae
    lpDiocParams - struct containing the caller parameter

Return Value:

   NTSTATUS

--*/

{
    NTSTATUS status = STATUS_SUCCESS;

    ASSERT(SmartcardExtension != NULL);

    if (SmartcardExtension == NULL) {

        return STATUS_INVALID_PARAMETER_1;
    }

    ASSERT(lpDiocParams != NULL);

    if (lpDiocParams == NULL) {

        return STATUS_INVALID_PARAMETER_2;
    }

    ASSERT(lpDiocParams->lpoOverlapped != 0);

    if (lpDiocParams->lpoOverlapped == 0) {

        return STATUS_INVALID_PARAMETER;
    }

    // Check the version that the driver requires
    ASSERT(SmartcardExtension->Version >= SMCLIB_VERSION_REQUIRED);

    if (SmartcardExtension->Version < SMCLIB_VERSION_REQUIRED) {

        return STATUS_INVALID_PARAMETER;
    }

    // Synchronize access to the driver
    _EnterMutex(
        SmartcardExtension->OsData->Mutex,
        BLOCK_SVC_INTS | BLOCK_THREAD_IDLE
        );

    if (status == STATUS_SUCCESS) {

        SmartcardDebug(
            DEBUG_IOCTL,
            ("SMCLIB(SmartcardDeviceControl): Ioctl = %s, DIOCP = %lx\n",
            MapIoControlCodeToString(lpDiocParams->dwIoControlCode),
            lpDiocParams)
            );

        // Return if device is busy
        if (SmartcardExtension->OsData->CurrentDiocParams != NULL) {

           SmartcardDebug(
               DEBUG_IOCTL,
               ("%s(SmartcardDeviceControl): Device is busy\n",
                DRIVER_NAME)
               );

            status = STATUS_DEVICE_BUSY;
        }
    }

    if (status == STATUS_SUCCESS) {

        if (lpDiocParams->lpcbBytesReturned) {

            // Default number of bytes returned
            *(PULONG) lpDiocParams->lpcbBytesReturned = 0;
        }

        switch (lpDiocParams->dwIoControlCode) {

            //
            // We have to check for _IS_ABSENT and _IS_PRESENT first,
            // since these are (the only allowed) asynchronous requests
            //
            case IOCTL_SMARTCARD_IS_ABSENT:
            case IOCTL_SMARTCARD_IS_PRESENT:

             if (SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING] == NULL) {

                status = STATUS_NOT_SUPPORTED;
                break;
             }

                // Now check if the driver is already processing notification
                if (SmartcardExtension->OsData->NotificationOverlappedData != NULL) {

                    status = STATUS_DEVICE_BUSY;
                    break;
                }

                //
                // Lock the overlapped structure that has to be notified
                // about the completion into memory
                //
                  SmartcardExtension->OsData->NotificationOverlappedData =
               _HeapAllocate( sizeof(OVERLAPPED), HEAPZEROINIT );

            if (SmartcardExtension->OsData->NotificationOverlappedData == NULL) {

               return STATUS_INSUFFICIENT_RESOURCES;
            }

            memcpy(
               SmartcardExtension->OsData->NotificationOverlappedData,
               (PVOID) lpDiocParams->lpoOverlapped,
               sizeof(OVERLAPPED)
               );

                if (lpDiocParams->dwIoControlCode == IOCTL_SMARTCARD_IS_ABSENT) {

                 //
                 // If the card is already (or still) absent, we can return immediatly.
                 // Otherwise we must statrt event tracking.
                 //
                 if (SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT) {

                    status = SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING](
                       SmartcardExtension
                       );
                 }

                } else {

                 //
                 // If the card is already (or still) present, we can return immediatly.
                 // Otherwise we must statrt event tracking.
                 //
                 if (SmartcardExtension->ReaderCapabilities.CurrentState <= SCARD_ABSENT) {

                    status = SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING](
                       SmartcardExtension
                       );
                 }
                }

                if (status != STATUS_PENDING) {

                    //
                    // Unlock the overlapped structure again since the driver
                    // doesn't need it anymore
                    //
                    _HeapFree(
                      SmartcardExtension->OsData->NotificationOverlappedData,
                      0
                      );

                    SmartcardExtension->OsData->NotificationOverlappedData = NULL;
                }
             break;

            default:
               // Check if buffers are properly allocated
               ASSERT(SmartcardExtension->SmartcardRequest.Buffer);
               ASSERT(SmartcardExtension->SmartcardReply.Buffer);

               SmartcardExtension->OsData->CurrentDiocParams = lpDiocParams;

               // Get major io control code
               SmartcardExtension->MajorIoControlCode =
                    lpDiocParams->dwIoControlCode;

               if (lpDiocParams->lpvInBuffer) {

                  //
                  // Transfer minor io control code, even if it doesn't make sense for
                  // this particular major code
                  //
                  SmartcardExtension->MinorIoControlCode =
                     *(PULONG) (lpDiocParams->lpvInBuffer);

                   // Lock memory and save pointer to and length of request buffer
                   SmartcardExtension->IoRequest.RequestBuffer = (PUCHAR) VxD_PageLock(
                      lpDiocParams->lpvInBuffer,
                        lpDiocParams->cbInBuffer
                        );

                   SmartcardExtension->IoRequest.RequestBufferLength =
                        lpDiocParams->cbInBuffer;

               } else {

                    SmartcardExtension->IoRequest.RequestBuffer = NULL;
                   SmartcardExtension->IoRequest.RequestBufferLength = 0;
                }

                if (lpDiocParams->lpvOutBuffer) {

                   // Lock memory an save pointer to and length of reply buffer
                   SmartcardExtension->IoRequest.ReplyBuffer = (PUCHAR) VxD_PageLock(
                      lpDiocParams->lpvOutBuffer,
                        lpDiocParams->cbOutBuffer
                        );

                   SmartcardExtension->IoRequest.ReplyBufferLength =
                        lpDiocParams->cbOutBuffer;

                } else {

                    SmartcardExtension->IoRequest.ReplyBuffer = NULL;
                   SmartcardExtension->IoRequest.ReplyBufferLength = 0;
                }

                // Lock overlapped struct into memory
                SmartcardExtension->OsData->CurrentOverlappedData =
                    (OVERLAPPED *) VxD_PageLock(
                  lpDiocParams->lpoOverlapped,
                  sizeof(OVERLAPPED)
                  );

                if (SmartcardExtension->OsData->CurrentOverlappedData) {

                   //
                   // Pointer to variable that receives the actual number
                   // of bytes returned. Since we don't know yet if the
                    // driver will return STATUS_PENDING, we use the
                    // overlapped data to store the number of bytes returned
                   //
                   SmartcardExtension->IoRequest.Information =
                        &SmartcardExtension->OsData->CurrentOverlappedData->O_InternalHigh;

                    // Set the default number of bytes returned to 0
                    *SmartcardExtension->IoRequest.Information = 0;

                    // Process the ioctl-request
                    status = SmartcardDeviceIoControl(SmartcardExtension);

                    if (status != STATUS_PENDING) {

                        if(lpDiocParams->lpcbBytesReturned) {

                           *(PULONG) (lpDiocParams->lpcbBytesReturned) =
                                *(SmartcardExtension->IoRequest.Information);
                        }

                        //
                        // The driver satisfied the call immediatly. So we don't use the overlapped
                        // data to return information to the caller. We can transfer the 'number
                        // of bytes returned' directly
                        //
                        if (SmartcardExtension->OsData->CurrentOverlappedData) {

                            // Unlock all memory
                           VxD_PageUnlock(
                              (DWORD) SmartcardExtension->OsData->CurrentOverlappedData,
                              sizeof(OVERLAPPED)
                              );
                        }

                        if (SmartcardExtension->IoRequest.RequestBuffer) {

                           VxD_PageUnlock(
                              (DWORD) SmartcardExtension->IoRequest.RequestBuffer,
                                SmartcardExtension->IoRequest.RequestBufferLength
                              );
                        }

                        if (SmartcardExtension->IoRequest.ReplyBuffer) {

                           VxD_PageUnlock(
                              (DWORD) SmartcardExtension->IoRequest.ReplyBuffer,
                                SmartcardExtension->IoRequest.ReplyBufferLength
                              );
                        }

                        //
                        // If the devcie is not busy, we can set the
                        // current parameters back to NULL
                        //
                        SmartcardExtension->OsData->CurrentDiocParams = NULL;
                    }

                } else {

                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
             break;
        }
    }

    SmartcardDebug(
        DEBUG_IOCTL,
        ("SMCLIB(SmartcardDeviceControl): Exit\n")
        );

    _LeaveMutex(SmartcardExtension->OsData->Mutex);

    return status;
}



DWORD
_stdcall
SMCLIB_DeviceIoControl(
    DWORD  dwService,
    DWORD  dwDDB,
    DWORD  hDevice,
    DIOCPARAMETERS *lpDIOCParms
    )
{
    return 0;
}

SMCLIB_Get_Version()
{
    return SMCLIB_VERSION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\smclib\smcutil.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    smcutil.c

Abstract:

    This module contains some utility fucntions

Environment:

    Kernel mode only.

Notes:

Revision History:

    - Created December 1996 by Klaus Schutz 
    - Nov 97:   Released Version 1.0 
    - Jan 98:   Calc. of GT changed. (Now set to 0 if N = 0 or N = 255)
                Rules for setting card status to SCARD_SPECIFIC changed
                Default clock freq. is now used for initial etu calculation

--*/

#define _ISO_TABLES_
#ifdef SMCLIB_VXD

#define try 
#define leave goto __label
#define finally __label:

#else
#if !defined(SMCLIB_CE)

#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <ntddk.h>

#endif
#endif

#ifdef SMCLIB_TEST
#define DbgPrint printf
#define DbgBreakPoint()
#define RtlAssert
#endif


#define _SMCUTIL_
#include "smclib.h"

#define IS_VENDOR(a) (memcmp(SmartcardExtension->VendorAttr.VendorName.Buffer, a, SmartcardExtension->VendorAttr.VendorName.Length) == 0)
#define IS_IFDTYPE(a) (memcmp(SmartcardExtension->VendorAttr.IfdType.Buffer, a, SmartcardExtension->VendorAttr.IfdType.Length) == 0)

void
DumpData(
    const ULONG DebugLevel,
    PUCHAR Data,
    ULONG DataLen
    );

//
// This is the time resolution.
// We calculate all times not in seconds, but in micro seconds
//
#define TR ((ULONG)(1000l * 1000l))

static ULONG 
Pow2(
    UCHAR Exponent
    )
{
    ULONG result = 1;

    while(Exponent--)
        result *= 2;

    return result;
}   

#ifdef _X86_ 
#pragma optimize("", off) 
#endif 

#if (DEBUG && DEBUG_VERBOSE)
#pragma message("Debug Verbose is turned on")
ULONG DebugLevel = DEBUG_PERF | DEBUG_ATR;
#else
ULONG DebugLevel = 0;
#endif

ULONG
#ifdef SMCLIB_VXD
SMCLIB_SmartcardGetDebugLevel(
#else
SmartcardGetDebugLevel(
#endif
    void
    )
{
    return DebugLevel;
}   

void
#ifdef SMCLIB_VXD
SMCLIB_SmartcardSetDebugLevel(
#else
SmartcardSetDebugLevel(
#endif
    ULONG Level
    )
{
    DebugLevel = Level;
}   

#ifdef _X86_ 
#pragma optimize("", on) 
#endif 

#if DEBUG
void
DumpData(
    const ULONG DebugLevel,
    PUCHAR Data,
    ULONG DataLen
    )
{
    ULONG i, line = 0;
    TCHAR buffer[72], *pbuffer;

    while(DataLen) {

        pbuffer = buffer;
        sprintf(pbuffer, "%*s", sizeof(buffer) - 1, "");

        if (line > 0) {

            pbuffer += 8;
        }

        for (i = 0; i < 8 && DataLen; i++, DataLen--, Data++) {

            sprintf(pbuffer + i * 3, "%02X ", *Data);
            sprintf(pbuffer + i + 26, "%c", (isprint(*Data) ? *Data : '.'));
        }

        pbuffer[i * 3] = ' ';
        pbuffer[i + 26] = '\n';
        pbuffer[i + 27] = '\0';

        SmartcardDebug(DebugLevel, (buffer));

        line += 1;
    }
}
#endif

VOID
SmartcardInitializeCardCapabilities(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine initializes all fields in the CardCapabilities structure,
    which can be calculated by the SmartcardUpdateCardCapabilities function.
    
Arguments:

    SmartcardExtension 

Return Value:

    None

--*/
{
    //
    // Save the pointers to the two tables
    //
    PCLOCK_RATE_CONVERSION ClockRateConversion = SmartcardExtension->CardCapabilities.ClockRateConversion;
    PBIT_RATE_ADJUSTMENT BitRateAdjustment = SmartcardExtension->CardCapabilities.BitRateAdjustment;

    //
    // Right now it is fine to zero the whole struct
    //
    RtlZeroMemory(
        &SmartcardExtension->CardCapabilities,
        sizeof(SmartcardExtension->CardCapabilities)
        );

    // Restore the pointers
    SmartcardExtension->CardCapabilities.ClockRateConversion = ClockRateConversion;
    SmartcardExtension->CardCapabilities.BitRateAdjustment = BitRateAdjustment;

    //
    // Every card has to support the 'raw' protocol
    // It enables the usage of cards that have their own protocol defined
    //
    SmartcardExtension->CardCapabilities.Protocol.Supported = 
        SCARD_PROTOCOL_RAW;

    //
    // Reset T=1 specific data
    //

    // force the T=1 protocol to start with an ifsd request
    SmartcardExtension->T1.State = T1_INIT;

    //
    // Initialize the send sequence number and 
    // the 'receive sequence number'
    //
    SmartcardExtension->T1.SSN = 0;
    SmartcardExtension->T1.RSN = 0;

    SmartcardExtension->T1.IFSC = 0;

    ASSERT(SmartcardExtension->ReaderCapabilities.MaxIFSD != 0);

    // Initialize the interface information field size
    if (SmartcardExtension->ReaderCapabilities.MaxIFSD != 0 &&
        SmartcardExtension->ReaderCapabilities.MaxIFSD <= T1_IFSD) {
        SmartcardExtension->T1.IFSD = 
            (UCHAR) SmartcardExtension->ReaderCapabilities.MaxIFSD;

    } else {
        
        SmartcardExtension->T1.IFSD = T1_IFSD_DEFAULT;
    }
}   

VOID
SmartcardInvertData(
    PUCHAR Buffer,
    ULONG Length
    )
/*++

Routine Description:

    This routine converts the passed buffer from inverse to direct or the other way

Arguments:


Return Value:

    None

--*/

{
    ULONG i;

    for (i = 0; i < Length; i++) {

        UCHAR j, inv = 0;

        for (j = 0; j < 8; j++) {

            if (Buffer[i] & (1 << j)) {

                inv |= 1 << (7 - j);
            }
        }
        Buffer[i] = (inv ^ 0xFF);
    }
}

NTSTATUS
#ifdef SMCLIB_VXD
SMCLIB_SmartcardUpdateCardCapabilities(
#else
SmartcardUpdateCardCapabilities(
#endif
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine updates the CardCapabilities structure, which holds information about
    the smartcard that has just been reset and is currently in use. It reads the 
    ATR string and retrieves all the relevent information.

    Please refer to ISO 7816-3 ,section 6.1.4 for the format of the ATR string
    
Arguments:

    SmartcardExtension 

Return Value:

    NTSTATUS

--*/
{
    PSCARD_CARD_CAPABILITIES cardCapabilities = &SmartcardExtension->CardCapabilities;
    PSCARD_READER_CAPABILITIES readerCapabilities = &SmartcardExtension->ReaderCapabilities;
    PUCHAR atrString = cardCapabilities->ATR.Buffer;
    ULONG atrLength = (ULONG) cardCapabilities->ATR.Length;
    UCHAR Y, Tck, TA[MAXIMUM_ATR_CODES], TB[MAXIMUM_ATR_CODES];
    UCHAR TC[MAXIMUM_ATR_CODES], TD[MAXIMUM_ATR_CODES];
    ULONG i, fs, numProtocols = 0, protocolTypes = 0;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN TA2Present = FALSE;
#if DEBUG
    TCHAR *ptsType[] = {TEXT("PTS_TYPE_DEFAULT"), TEXT("PTS_TYPE_OPTIMAL"), TEXT("PTS_TYPE_USER")};
#endif
#if defined (SMCLIB_NT) 
    KIRQL irql;
#endif

    SmartcardDebug(
        DEBUG_ATR,
        (TEXT("%s!SmartcardUpdateCardCapabilities:\n"),
        DRIVER_NAME)
        );

    if (atrLength < 2) {
        
        SmartcardDebug(
            DEBUG_ATR,
            (TEXT("   ATR is too short (Min. length is 2) \n"))
            );

        return STATUS_UNRECOGNIZED_MEDIA;
    }

#if DEBUG

    SmartcardDebug(
        DEBUG_ATR,
        (TEXT("   ATR: "))
        );

    DumpData(
        DEBUG_ATR,
        atrString,
        atrLength
        );
#endif

    if (atrString[0] != 0x3b && atrString[0] != 0x3f && atrString[0] != 0x03) {

        SmartcardDebug(
            DEBUG_ATR,
            (TEXT("   Initial character %02xh of ATR is invalid\n"),
            atrString[0])
            );

        return STATUS_UNRECOGNIZED_MEDIA;
    }

    // Test for invers convention
    if (*atrString == 0x03) {

        cardCapabilities->InversConvention = TRUE;

        //
        // When the ATR starts with 0x03 then it 
        // has not been inverted already            
        //
        SmartcardInvertData(
            cardCapabilities->ATR.Buffer, 
            cardCapabilities->ATR.Length
            );              

        SmartcardDebug(
            DEBUG_ATR,
            (TEXT("   Card uses Inverse Convention\n"))
            );
    } 

    __try {

        //
        // The caller might be calling this function repeatedly in order to 
        // test if the ATR is valid. If the ATR we currently have here is
        // not valid then we need to be able re-invert an inverted ATR.
        //

        atrString += 1;
        atrLength -= 1;

        //
        // Calculate check char, but do not test now since if only T=0 
        // is present the ATR doesn't contain a check char
        //
        for (i = 0, Tck = 0; i < atrLength; i++) {

            Tck ^= atrString[i];
        }

        // Initialize various data
        cardCapabilities->Protocol.Supported = 0;

        RtlZeroMemory(TA, sizeof(TA));
        RtlZeroMemory(TB, sizeof(TB));
        RtlZeroMemory(TC, sizeof(TC));
        RtlZeroMemory(TD, sizeof(TD));

        //
        // Set default values as described in ISO 7816-3
        //
    
        // TA1 codes Fl in high-byte and Dl in low-byte;
        TA[0] = 0x11;
        // TB1 codes II in bits b7/b6 and Pl1 in b5-b1. b8 has to be 0
        TB[0] = 0x25;
        // TC2 codes T=0 WI
        TC[1] = 10;

        // Translate ATR string to TA to TD values (See ISO)
        cardCapabilities->HistoricalChars.Length = *atrString & 0x0f;

        Y = *atrString++ & 0xf0;
        atrLength -= 1;

        for (i = 0; i < MAXIMUM_ATR_CODES; i++) {

            if (Y & 0x10) {

                if (i == 1) {

                    TA2Present = TRUE;                  
                }

                TA[i] = *atrString++;
                atrLength -= 1;
            }

            if (Y & 0x20) {

                TB[i] = *atrString++;
                atrLength -= 1;
            }

            if (Y & 0x40) {

                TC[i] = *atrString++;
                atrLength -= 1;
            }

            if (Y & 0x80) {

                Y = *atrString & 0xf0;
                TD[i] = *atrString++ & 0x0f;
                atrLength -= 1;

                // Check if the next parameters are for a new protocol.
                if (((1 << TD[i]) & protocolTypes) == 0) {

                    // Count the number of protocols that the card supports
                    numProtocols++;
                }
                protocolTypes |= 1 << TD[i];

            } else {
                
                break;
            }
        } 

        // Check if the card supports a protocol other than T=0
        if (protocolTypes & ~1) {

            //
            // The atr contains a checksum byte.
            // Exclude that from the historical byte length check
            //
            atrLength -=1;      

            //
            // This card supports more than one protocol or a protocol 
            // other than T=0, so test if the checksum is correct
            //
            if (Tck != 0) {

                SmartcardDebug(
                    DEBUG_ATR,
                    (TEXT("   ATR Checksum is invalid\n"))
                    );

                status = STATUS_UNRECOGNIZED_MEDIA;
                __leave;
            }
        }

        if (/* atrLength < 0 || */
            atrLength != cardCapabilities->HistoricalChars.Length) {
            
            SmartcardDebug(
                DEBUG_ATR,
                (TEXT("   ATR length is inconsistent\n"))
                );

            status = STATUS_UNRECOGNIZED_MEDIA;
            __leave;
        }
    }
    __finally {

        if (status != STATUS_SUCCESS) {

            if (cardCapabilities->InversConvention == TRUE) {

                SmartcardInvertData(
                    cardCapabilities->ATR.Buffer, 
                    cardCapabilities->ATR.Length
                    );              

                cardCapabilities->InversConvention = FALSE;
            }

        }
    }

    if (status != STATUS_SUCCESS)
        return status;
        
    // store historical characters
    RtlCopyMemory(
        cardCapabilities->HistoricalChars.Buffer,
        atrString,
        cardCapabilities->HistoricalChars.Length
        );

    //
    // Now convert TA - TD values to global interface bytes
    //

    // Clock rate conversion
    cardCapabilities->Fl = (TA[0] & 0xf0) >> 4;

    // bit rate adjustment
    cardCapabilities->Dl = (TA[0] & 0x0f);

    // Maximum programming current factor
    cardCapabilities->II = (TB[0] & 0xc0) >> 6;

    // Programming voltage in 0.1 Volts
    cardCapabilities->P = (TB[1] ? TB[1] : (TB[0] & 0x1f) * 10);

    // Extra guard time
    cardCapabilities->N = TC[0];

    //
    // Check if the Dl and Fl values are valid
    // 
    if (BitRateAdjustment[cardCapabilities->Dl].DNumerator == 0 ||
        ClockRateConversion[cardCapabilities->Fl].F == 0) {

        SmartcardDebug(
            DEBUG_ATR,
            (TEXT("   Dl = %02x or Fl = %02x invalid\n"),
            cardCapabilities->Dl,
            cardCapabilities->Fl)
            );

        return STATUS_UNRECOGNIZED_MEDIA;
    }

    ASSERT(readerCapabilities->CLKFrequency.Max != 0);
    ASSERT(readerCapabilities->CLKFrequency.Default != 0);

    SmartcardDebug(
        DEBUG_ATR,
        (TEXT("   Card parameters from ATR:\n      Fl = %02x (%ld KHz), Dl = %02x, I = %02x, P = %02x, N = %02x\n"),
        cardCapabilities->Fl,
        ClockRateConversion[cardCapabilities->Fl].fs / 1000,
        cardCapabilities->Dl,
        cardCapabilities->II,
        cardCapabilities->P,
        cardCapabilities->N)
        );

    //
    // assume default clock frequency
    //
    fs = readerCapabilities->CLKFrequency.Default * 1000l;
    if (fs == 0) {

        fs = 372 * 9600l;
    }

    if (cardCapabilities->PtsData.Type == PTS_TYPE_DEFAULT) {

        //
        // Assume default parameters
        //
        cardCapabilities->PtsData.Fl = 1;
        cardCapabilities->PtsData.Dl = 1;

        cardCapabilities->PtsData.DataRate = 
            readerCapabilities->DataRate.Default;

        cardCapabilities->PtsData.CLKFrequency = 
            readerCapabilities->CLKFrequency.Default;
    }

    if (cardCapabilities->PtsData.Type != PTS_TYPE_DEFAULT) {

        //
        // Try to find optimal parameters:
        // Highest possible clock frequency of the card 
        // combined with fastes data rate
        //

        //
        // We now try to find a working Fl and Dl combination
        //

        if (cardCapabilities->PtsData.Type == PTS_TYPE_OPTIMAL) {
            
            cardCapabilities->PtsData.Fl = cardCapabilities->Fl;
        }

        ASSERT(cardCapabilities->PtsData.Fl < 16);
        ASSERT(ClockRateConversion[cardCapabilities->PtsData.Fl].F);

        if (cardCapabilities->PtsData.Fl > 15 ||
            ClockRateConversion[cardCapabilities->PtsData.Fl].F == 0) {

            return STATUS_INVALID_PARAMETER;
        }

        do {
            
            ULONG cardFreq, maxFreq;

            if (readerCapabilities->CLKFrequenciesSupported.Entries == 0 ||
                readerCapabilities->CLKFrequenciesSupported.List == NULL) {

                //
                // The clock freq. list supplied by the reader is empty
                // We take the standard values supplied by the reader
                //
                readerCapabilities->CLKFrequenciesSupported.List =
                    &readerCapabilities->CLKFrequency.Default;

                readerCapabilities->CLKFrequenciesSupported.Entries = 2;
            }

            //
            // Find the highest possible clock freq. supported 
            // by the card and the reader
            //
            cardFreq = 
                ClockRateConversion[cardCapabilities->PtsData.Fl].fs / 
                1000;

            cardCapabilities->PtsData.CLKFrequency = 0;

            for (i = 0; i < readerCapabilities->CLKFrequenciesSupported.Entries; i++) {

                // look for highest possible reader frequency
                if (readerCapabilities->CLKFrequenciesSupported.List[i] > 
                    cardCapabilities->PtsData.CLKFrequency &&
                    readerCapabilities->CLKFrequenciesSupported.List[i] <= 
                    cardFreq) {

                    cardCapabilities->PtsData.CLKFrequency =
                        readerCapabilities->CLKFrequenciesSupported.List[i];
                }
            }

            fs = cardCapabilities->PtsData.CLKFrequency * 1000;
            cardCapabilities->PtsData.DataRate = 0;

            ASSERT(fs != 0);
            if (fs == 0) {

                return STATUS_INVALID_PARAMETER;                
            }

            if (cardCapabilities->PtsData.Type == PTS_TYPE_OPTIMAL) {
                
                cardCapabilities->PtsData.Dl = cardCapabilities->Dl;
            }

            ASSERT(cardCapabilities->PtsData.Dl < 16);
            ASSERT(BitRateAdjustment[cardCapabilities->PtsData.Dl].DNumerator);

            if (cardCapabilities->PtsData.Dl > 15 ||
                BitRateAdjustment[cardCapabilities->PtsData.Dl].DNumerator == 0) {

                return STATUS_INVALID_PARAMETER;
            }

            if (readerCapabilities->DataRatesSupported.Entries == 0 ||
                readerCapabilities->DataRatesSupported.List == NULL) {

                //
                // The data rate list supplied by the reader is empty.
                // We take the standard min/max values of the reader
                //
                readerCapabilities->DataRatesSupported.List =
                    &readerCapabilities->DataRate.Default;

                readerCapabilities->DataRatesSupported.Entries = 2;
            }

            //
            // Now try to find the highest possible matching data rate
            // (A matching data rate is one that VERY close 
            // to one supplied by the reader)
            //
            while(cardCapabilities->PtsData.Dl > 1) {

                ULONG dataRate;

                //
                // Calculate the data rate using the current values
                //
                dataRate = 
                    (BitRateAdjustment[cardCapabilities->PtsData.Dl].DNumerator * 
                    fs) / 
                    (BitRateAdjustment[cardCapabilities->PtsData.Dl].DDivisor * 
                    ClockRateConversion[cardCapabilities->PtsData.Fl].F);

                //
                // Try to find a matching data rate
                //
                for (i = 0; i < readerCapabilities->DataRatesSupported.Entries; i++) {

                    if (readerCapabilities->DataRatesSupported.List[i] * 101 > dataRate * 100 &&
                        readerCapabilities->DataRatesSupported.List[i] * 99 < dataRate * 100) {

                        cardCapabilities->PtsData.DataRate = 
                            readerCapabilities->DataRatesSupported.List[i];

                        break;                          
                    }
                }

                if (cardCapabilities->PtsData.DataRate) {

                    break;                  
                }

                //
                // Select the next valid lower D value
                //
                while (BitRateAdjustment[--cardCapabilities->PtsData.Dl].DNumerator == 0)
                    ;
            }
                 
            if (cardCapabilities->PtsData.Fl == 1 && 
                cardCapabilities->PtsData.Dl == 1) {

                cardCapabilities->PtsData.DataRate =
                    readerCapabilities->DataRate.Default;                    

                cardCapabilities->PtsData.CLKFrequency = 
                    readerCapabilities->CLKFrequency.Default;

                break;
            }

            if (cardCapabilities->PtsData.DataRate) {

                break;                  
            }
            //
            // Select the next valid lower F value
            //
            maxFreq = ClockRateConversion[cardCapabilities->Fl].fs;

            do {

                cardCapabilities->PtsData.Fl -= 1;

            } while (ClockRateConversion[cardCapabilities->PtsData.Fl].F == 0 ||
                     ClockRateConversion[cardCapabilities->PtsData.Fl].fs > 
                     maxFreq);

        } while(cardCapabilities->PtsData.DataRate == 0);
    }

    ASSERT(fs != 0);
    ASSERT(cardCapabilities->PtsData.Dl < 16);
    ASSERT(BitRateAdjustment[cardCapabilities->PtsData.Dl].DNumerator != 0);

    //
    // We calculate the ETU on basis of the timing supplied by the 
    // clk-frequency of the reader
    //
    //
    // Work etu in units of time resolution(TR) (NOT in seconds)
    //
    cardCapabilities->etu = 
        1 +     // required to round up
        (TR * 
        BitRateAdjustment[cardCapabilities->PtsData.Dl].DDivisor *
        ClockRateConversion[cardCapabilities->PtsData.Fl].F) /
        (BitRateAdjustment[cardCapabilities->PtsData.Dl].DNumerator * 
        fs);

    //
    // guard time in micro seconds
    // the guard time is the gap between the end of the
    // current character and the beginning of the next character
    //
    cardCapabilities->GT = 0;
    cardCapabilities->PtsData.StopBits = 2;

    if (cardCapabilities->N == 255) {

        cardCapabilities->PtsData.StopBits = 1;     

    } else if (cardCapabilities->N > 0) {
        
        cardCapabilities->GT = cardCapabilities->N * cardCapabilities->etu;
    }

    SmartcardDebug(
        DEBUG_ATR,
        (TEXT("   PTS parameters (%s):\n      Fl = %02x (%ld KHz), Dl = %02x (%ld Bps, %d Stop Bits)\n"),
        ptsType[cardCapabilities->PtsData.Type],
        cardCapabilities->PtsData.Fl,
        cardCapabilities->PtsData.CLKFrequency,
        cardCapabilities->PtsData.Dl,
        cardCapabilities->PtsData.DataRate,
        cardCapabilities->PtsData.StopBits)
        );

    SmartcardDebug(
        DEBUG_ATR,
        (TEXT("   Calculated timing values:\n      Work etu = %ld micro sec, Guard time = %ld micro sec\n"),
        cardCapabilities->etu,
        cardCapabilities->GT)
        );

#if defined (SMCLIB_NT) && !defined(SMCLIB_TEST)
    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock, &irql);
#endif
    if(SmartcardExtension->ReaderCapabilities.CurrentState >= SCARD_PRESENT) {

        if (TA2Present || numProtocols <= 1 && 
            cardCapabilities->Fl == 1 && 
            cardCapabilities->Dl == 1) {

            //
            // If the card supports only one protocol (or T=0 as default)
            // and only standard paramters then PTS selection is not available
            //
            SmartcardExtension->ReaderCapabilities.CurrentState = 
                SCARD_SPECIFIC;

        } else {
            
            SmartcardExtension->ReaderCapabilities.CurrentState = 
                SCARD_NEGOTIABLE;
        }
    }
#if defined (SMCLIB_NT) && !defined(SMCLIB_TEST)
    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock, irql);
#endif


    //
    // Now find protocol specific data
    //

    if (TD[0] == 0) {
        
        cardCapabilities->Protocol.Supported |=
            SCARD_PROTOCOL_T0;

        cardCapabilities->T0.WI = TC[1];

        if (cardCapabilities->PtsData.Dl > 0 && 
            cardCapabilities->PtsData.Dl < 6) {

            cardCapabilities->T0.WT = 1 +
                cardCapabilities->T0.WI *
                960 * cardCapabilities->etu * 
                Pow2((UCHAR) (cardCapabilities->PtsData.Dl - 1));

        } else { 

            cardCapabilities->T0.WT = 1+
                cardCapabilities->T0.WI *
                960 * cardCapabilities->etu /
                Pow2((UCHAR) (cardCapabilities->PtsData.Dl - 1));                   
        } 

        SmartcardDebug(
            DEBUG_ATR,
            (TEXT("   T=0 Values from ATR:\n      WI = %ld\n"),
            cardCapabilities->T0.WI)
            );
        SmartcardDebug(
            DEBUG_ATR,
            (TEXT("   T=0 Timing from ATR:\n      WT = %ld ms\n"),
            cardCapabilities->T0.WT / 1000)
            );
    }

    if (protocolTypes & SCARD_PROTOCOL_T1) {

        for (i = 0; TD[i] != 1 && i < MAXIMUM_ATR_CODES; i++)
            ;
    
        for (; TD[i] == 1 && i < MAXIMUM_ATR_CODES; i++) 
            ;

        if (i == MAXIMUM_ATR_CODES) {

            return STATUS_UNRECOGNIZED_MEDIA;           
        }

        cardCapabilities->Protocol.Supported |= 
            SCARD_PROTOCOL_T1;

        cardCapabilities->T1.IFSC = 
            (TA[i] ? TA[i] : 32);

        cardCapabilities->T1.CWI = 
            ((TB[i] & 0x0f) ? (TB[i] & 0x0f) : T1_CWI_DEFAULT);

        cardCapabilities->T1.BWI = 
            ((TB[i] & 0xf0) >> 4 ? (TB[i] & 0xf0) >> 4 : T1_BWI_DEFAULT);

        cardCapabilities->T1.EDC = 
            (TC[i] & 0x01);

        cardCapabilities->T1.CWT = 1 +
            (Pow2(cardCapabilities->T1.CWI) + 11) * cardCapabilities->etu;

        cardCapabilities->T1.BWT = 1 +
            (((Pow2(cardCapabilities->T1.BWI) * 960l * 372l) / 
                cardCapabilities->PtsData.CLKFrequency) + 
            (11 * cardCapabilities->etu)) * 1000;

        SmartcardDebug(
            DEBUG_ATR,
            (TEXT("   T=1 Values from ATR:\n      IFSC = %ld, CWI = %ld, BWI = %ld, EDC = %02x\n"),
            cardCapabilities->T1.IFSC,
            cardCapabilities->T1.CWI,
            cardCapabilities->T1.BWI,
            cardCapabilities->T1.EDC)
            );
        SmartcardDebug(
            DEBUG_ATR,
            (TEXT("   T=1 Timing from ATR:\n      CWT = %ld ms, BWT = %ld ms\n"),
            cardCapabilities->T1.CWT / 1000,
            cardCapabilities->T1.BWT / 1000)
            );
    }

    if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC) {
        
        if (TA2Present) {

            //
            // TA2 is present in the ATR, so use 
            // the protocol indicated in the ATR
            //
            cardCapabilities->Protocol.Selected = 1 << (TA[1] & 0xf);
            
        } else {
            
            //
            // The card only supports one protocol
            // So make that one protocol the current one to use
            //
            cardCapabilities->Protocol.Selected = 
                cardCapabilities->Protocol.Supported;
        }

        SmartcardDebug(
            DEBUG_ATR,
            (TEXT("   Mode: Specific %s\n\n"),          
            TA2Present ? TEXT("set by TA(2)") : TEXT(""))
            );

    } else {

        SmartcardDebug(
            DEBUG_ATR,
            (TEXT("   Mode: Negotiable\n\n"))
            );
    }

    //
    // Every card has to support the 'raw' protocol
    // It enables the usage of cards that have their own protocol defined
    //
    SmartcardExtension->CardCapabilities.Protocol.Supported |= 
        SCARD_PROTOCOL_RAW;

    return STATUS_SUCCESS;
}

#ifdef SMCLIB_TEST

__cdecl
main()
{
    SMARTCARD_EXTENSION SmartcardExtension;
    static ULONG dataRatesSupported[] = { 9909 };

    memset(&SmartcardExtension, 0, sizeof(SmartcardExtension));

    // Gemplus T=0 card
    // memcpy(SmartcardExtension.CardCapabilities.ATR.Buffer, "\x3b\x2a\x00\x80\x65\xa2\x01\x02\x01\x31\x72\xd6\x43", 13);
    // SmartcardExtension.CardCapabilities.ATR.Length = 13;

    // MS card with TA2 set - card won't work due to incorrect parameters
    memcpy(SmartcardExtension.CardCapabilities.ATR.Buffer, "\x3b\x98\x13\x91\x81\x31\x20\x55\x00\x57\x69\x6e\x43\x61\x72\x64\xbb", 17);
    SmartcardExtension.CardCapabilities.ATR.Length = 17;

    SmartcardExtension.ReaderCapabilities.CLKFrequency.Default = 3686;
    SmartcardExtension.ReaderCapabilities.CLKFrequency.Max = 3686;

    SmartcardExtension.ReaderCapabilities.DataRate.Default =
    SmartcardExtension.ReaderCapabilities.DataRate.Max = 9909;

    SmartcardExtension.ReaderCapabilities.DataRatesSupported.List =
       dataRatesSupported;
    SmartcardExtension.ReaderCapabilities.DataRatesSupported.Entries =
       sizeof(dataRatesSupported) / sizeof(dataRatesSupported[0]);

    SmartcardExtension.ReaderCapabilities.CurrentState = SCARD_PRESENT;

    SmartcardSetDebugLevel(DEBUG_ALL);
    SmartcardUpdateCardCapabilities(&SmartcardExtension);
}

#define DbgPrint printf

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\smclib\vxd\errmap.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    errmap.h

Abstract:

    defines an array for mapping nt-status codes to win32 error codes

Environment:

    Windows95 / Memphis static VxD

Notes:

    This files stems originally from \nt\private\ntos\rtl\error.h

Revision History:

    - Copied June 1997 by Klaus Schutz 

--*/

LONG CodePairs[] = {

    //
    // These are also defined in WINNT.H, but we are stuck with these
    // mappings.
    //

    STATUS_DATATYPE_MISALIGNMENT, ERROR_NOACCESS,
    STATUS_ACCESS_VIOLATION, ERROR_NOACCESS,

    STATUS_CTL_FILE_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,
    STATUS_PORT_ALREADY_SET, ERROR_INVALID_PARAMETER,
    STATUS_SECTION_NOT_IMAGE, ERROR_INVALID_PARAMETER,
    STATUS_BAD_WORKING_SET_LIMIT, ERROR_INVALID_PARAMETER,
    STATUS_WORKING_SET_LIMIT_RANGE, ERROR_INVALID_PARAMETER,
    STATUS_INCOMPATIBLE_FILE_MAP, ERROR_INVALID_PARAMETER,
    STATUS_PORT_DISCONNECTED, ERROR_INVALID_HANDLE,
    STATUS_NOT_LOCKED, ERROR_NOT_LOCKED,
    STATUS_NOT_MAPPED_VIEW, ERROR_INVALID_ADDRESS,
    STATUS_UNABLE_TO_FREE_VM, ERROR_INVALID_PARAMETER,
    STATUS_UNABLE_TO_DELETE_SECTION, ERROR_INVALID_PARAMETER,
    STATUS_MORE_PROCESSING_REQUIRED, ERROR_MORE_DATA,
    STATUS_INVALID_CID, ERROR_INVALID_PARAMETER,
    STATUS_STACK_OVERFLOW, ERROR_STACK_OVERFLOW,
    STATUS_BAD_INITIAL_STACK, ERROR_STACK_OVERFLOW,
    STATUS_INVALID_VOLUME_LABEL, ERROR_LABEL_TOO_LONG,
    STATUS_SECTION_NOT_EXTENDED, ERROR_OUTOFMEMORY,
    STATUS_NOT_MAPPED_DATA, ERROR_INVALID_ADDRESS,

    STATUS_INFO_LENGTH_MISMATCH, ERROR_BAD_LENGTH,
    STATUS_INVALID_INFO_CLASS, ERROR_INVALID_PARAMETER,

    STATUS_SUSPEND_COUNT_EXCEEDED, ERROR_SIGNAL_REFUSED,

    STATUS_NOTIFY_ENUM_DIR, ERROR_NOTIFY_ENUM_DIR,

    STATUS_REGISTRY_RECOVERED, ERROR_REGISTRY_RECOVERED,

    STATUS_REGISTRY_IO_FAILED, ERROR_REGISTRY_IO_FAILED,

    STATUS_NOT_REGISTRY_FILE, ERROR_NOT_REGISTRY_FILE,

    STATUS_KEY_DELETED, ERROR_KEY_DELETED,

    STATUS_NO_LOG_SPACE, ERROR_NO_LOG_SPACE,

    STATUS_KEY_HAS_CHILDREN, ERROR_KEY_HAS_CHILDREN,

    STATUS_CHILD_MUST_BE_VOLATILE, ERROR_CHILD_MUST_BE_VOLATILE,

    STATUS_REGISTRY_CORRUPT, ERROR_BADDB,

    STATUS_DLL_NOT_FOUND, ERROR_MOD_NOT_FOUND,

    STATUS_DLL_INIT_FAILED, ERROR_DLL_INIT_FAILED,

    STATUS_ORDINAL_NOT_FOUND, ERROR_INVALID_ORDINAL,
    STATUS_DRIVER_ORDINAL_NOT_FOUND, ERROR_INVALID_ORDINAL,
    STATUS_DRIVER_UNABLE_TO_LOAD, ERROR_BAD_DRIVER,

    STATUS_ENTRYPOINT_NOT_FOUND, ERROR_PROC_NOT_FOUND,
    STATUS_DRIVER_ENTRYPOINT_NOT_FOUND, ERROR_PROC_NOT_FOUND,

    STATUS_PENDING, ERROR_IO_PENDING,

    STATUS_MORE_ENTRIES, ERROR_MORE_DATA,

    STATUS_INTEGER_OVERFLOW, ERROR_ARITHMETIC_OVERFLOW,

    STATUS_BUFFER_OVERFLOW, ERROR_MORE_DATA,

    STATUS_NO_MORE_FILES, ERROR_NO_MORE_FILES,

    STATUS_NO_INHERITANCE, ERROR_NO_INHERITANCE,

    STATUS_NO_MORE_EAS, ERROR_NO_MORE_ITEMS,
    STATUS_NO_MORE_ENTRIES, ERROR_NO_MORE_ITEMS,
    STATUS_GUIDS_EXHAUSTED, ERROR_NO_MORE_ITEMS,
    STATUS_AGENTS_EXHAUSTED, ERROR_NO_MORE_ITEMS,

    STATUS_UNSUCCESSFUL, ERROR_GEN_FAILURE,

    STATUS_TOO_MANY_LINKS, ERROR_TOO_MANY_LINKS,

    STATUS_NOT_IMPLEMENTED, ERROR_INVALID_FUNCTION,
    STATUS_ILLEGAL_FUNCTION, ERROR_INVALID_FUNCTION,

    STATUS_IN_PAGE_ERROR, ERROR_SWAPERROR,

    STATUS_PAGEFILE_QUOTA, ERROR_PAGEFILE_QUOTA,
    STATUS_COMMITMENT_LIMIT, ERROR_COMMITMENT_LIMIT,
    STATUS_SECTION_TOO_BIG, ERROR_NOT_ENOUGH_MEMORY,

    STATUS_INVALID_HANDLE, ERROR_INVALID_HANDLE,
    STATUS_OBJECT_TYPE_MISMATCH, ERROR_INVALID_HANDLE,
    STATUS_FILE_CLOSED, ERROR_INVALID_HANDLE,
    STATUS_INVALID_PORT_HANDLE, ERROR_INVALID_HANDLE,
    STATUS_HANDLE_NOT_CLOSABLE, ERROR_INVALID_HANDLE,

    STATUS_NOT_COMMITTED, ERROR_INVALID_ADDRESS,
    STATUS_PARTIAL_COPY, ERROR_PARTIAL_COPY,

    STATUS_LPC_REPLY_LOST, ERROR_INTERNAL_ERROR,
    STATUS_INVALID_PARAMETER, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_1, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_2, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_3, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_4, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_5, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_6, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_7, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_8, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_9, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_10, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_11, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_12, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_MIX, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PAGE_PROTECTION, ERROR_INVALID_PARAMETER,
    STATUS_SECTION_PROTECTION, ERROR_INVALID_PARAMETER,

    STATUS_RESOURCE_DATA_NOT_FOUND, ERROR_RESOURCE_DATA_NOT_FOUND,
    STATUS_RESOURCE_TYPE_NOT_FOUND, ERROR_RESOURCE_TYPE_NOT_FOUND,
    STATUS_RESOURCE_NAME_NOT_FOUND, ERROR_RESOURCE_NAME_NOT_FOUND,
    STATUS_RESOURCE_LANG_NOT_FOUND, ERROR_RESOURCE_LANG_NOT_FOUND,

    STATUS_NO_SUCH_DEVICE, ERROR_FILE_NOT_FOUND,
    STATUS_NO_SUCH_FILE, ERROR_FILE_NOT_FOUND,

    STATUS_INVALID_DEVICE_REQUEST, ERROR_INVALID_FUNCTION,

    STATUS_END_OF_FILE, ERROR_HANDLE_EOF,
    STATUS_FILE_FORCED_CLOSED, ERROR_HANDLE_EOF,

    STATUS_WRONG_VOLUME, ERROR_WRONG_DISK,

    STATUS_NO_MEDIA, ERROR_NO_MEDIA_IN_DRIVE,

    STATUS_NO_MEDIA_IN_DEVICE, ERROR_NOT_READY,

    STATUS_VOLUME_DISMOUNTED, ERROR_NOT_READY,

    STATUS_NONEXISTENT_SECTOR, ERROR_SECTOR_NOT_FOUND,

    STATUS_WORKING_SET_QUOTA, ERROR_WORKING_SET_QUOTA,
    STATUS_NO_MEMORY, ERROR_NOT_ENOUGH_MEMORY,
    STATUS_CONFLICTING_ADDRESSES, ERROR_INVALID_ADDRESS,

    STATUS_INVALID_SYSTEM_SERVICE, ERROR_INVALID_FUNCTION,

    STATUS_THREAD_IS_TERMINATING, ERROR_ACCESS_DENIED,
    STATUS_PROCESS_IS_TERMINATING, ERROR_ACCESS_DENIED,
    STATUS_INVALID_LOCK_SEQUENCE, ERROR_ACCESS_DENIED,
    STATUS_INVALID_VIEW_SIZE, ERROR_ACCESS_DENIED,
    STATUS_ALREADY_COMMITTED, ERROR_ACCESS_DENIED,
    STATUS_ACCESS_DENIED, ERROR_ACCESS_DENIED,
    STATUS_FILE_IS_A_DIRECTORY, ERROR_ACCESS_DENIED,
    STATUS_CANNOT_DELETE, ERROR_ACCESS_DENIED,
    STATUS_INVALID_COMPUTER_NAME, ERROR_INVALID_COMPUTERNAME,
    STATUS_FILE_DELETED, ERROR_ACCESS_DENIED,
    STATUS_DELETE_PENDING, ERROR_ACCESS_DENIED,
    STATUS_PORT_CONNECTION_REFUSED, ERROR_ACCESS_DENIED,

    STATUS_NO_SUCH_PRIVILEGE, ERROR_NO_SUCH_PRIVILEGE,

    STATUS_PRIVILEGE_NOT_HELD, ERROR_PRIVILEGE_NOT_HELD,

    STATUS_CANNOT_IMPERSONATE, ERROR_CANNOT_IMPERSONATE,

    STATUS_LOGON_FAILURE, ERROR_LOGON_FAILURE,

    STATUS_ACCOUNT_RESTRICTION, ERROR_ACCOUNT_RESTRICTION,

    STATUS_INVALID_LOGON_HOURS, ERROR_INVALID_LOGON_HOURS,

    STATUS_INVALID_WORKSTATION, ERROR_INVALID_WORKSTATION,

    STATUS_BUFFER_TOO_SMALL, ERROR_INSUFFICIENT_BUFFER,

    STATUS_UNABLE_TO_DECOMMIT_VM, ERROR_INVALID_ADDRESS,

    STATUS_DISK_CORRUPT_ERROR, ERROR_DISK_CORRUPT,
    STATUS_FT_MISSING_MEMBER, ERROR_IO_DEVICE,
    STATUS_FT_ORPHANING, ERROR_IO_DEVICE,

    STATUS_VARIABLE_NOT_FOUND, ERROR_ENVVAR_NOT_FOUND,

    STATUS_OBJECT_NAME_INVALID, ERROR_INVALID_NAME,

    STATUS_OBJECT_NAME_NOT_FOUND, ERROR_FILE_NOT_FOUND,

    STATUS_OBJECT_NAME_COLLISION, ERROR_ALREADY_EXISTS,

    STATUS_OBJECT_PATH_INVALID, ERROR_BAD_PATHNAME,

    STATUS_OBJECT_PATH_NOT_FOUND, ERROR_PATH_NOT_FOUND,
    STATUS_DFS_EXIT_PATH_FOUND, ERROR_PATH_NOT_FOUND,

    STATUS_OBJECT_PATH_SYNTAX_BAD, ERROR_BAD_PATHNAME,

    STATUS_NAME_TOO_LONG, ERROR_FILENAME_EXCED_RANGE,

    STATUS_DATA_OVERRUN, ERROR_IO_DEVICE,
    STATUS_DATA_LATE_ERROR, ERROR_IO_DEVICE,
    STATUS_DATA_ERROR, ERROR_CRC,

    STATUS_CRC_ERROR, ERROR_CRC,

    STATUS_SHARING_VIOLATION, ERROR_SHARING_VIOLATION,

    STATUS_QUOTA_EXCEEDED, ERROR_NOT_ENOUGH_QUOTA,

    STATUS_MUTANT_NOT_OWNED, ERROR_NOT_OWNER,

    STATUS_SEMAPHORE_LIMIT_EXCEEDED, ERROR_TOO_MANY_POSTS,

    STATUS_DISK_FULL, ERROR_DISK_FULL,

    STATUS_LOCK_NOT_GRANTED, ERROR_LOCK_VIOLATION,

    STATUS_FILE_LOCK_CONFLICT, ERROR_LOCK_VIOLATION,  // FIX, FIX - is this right?

    STATUS_NOT_A_DIRECTORY, ERROR_DIRECTORY,          // FIX, FIX - is this right?

    STATUS_UNKNOWN_REVISION, ERROR_UNKNOWN_REVISION,

    STATUS_REVISION_MISMATCH, ERROR_REVISION_MISMATCH,

    STATUS_INVALID_OWNER, ERROR_INVALID_OWNER,

    STATUS_INVALID_PRIMARY_GROUP, ERROR_INVALID_PRIMARY_GROUP,

    STATUS_NO_IMPERSONATION_TOKEN, ERROR_NO_IMPERSONATION_TOKEN,

    STATUS_CANT_DISABLE_MANDATORY, ERROR_CANT_DISABLE_MANDATORY,

    STATUS_NO_LOGON_SERVERS, ERROR_NO_LOGON_SERVERS,
    STATUS_DOMAIN_CONTROLLER_NOT_FOUND, ERROR_DOMAIN_CONTROLLER_NOT_FOUND,

    STATUS_NO_SUCH_LOGON_SESSION, ERROR_NO_SUCH_LOGON_SESSION,

    STATUS_INVALID_ACCOUNT_NAME, ERROR_INVALID_ACCOUNT_NAME,

    STATUS_USER_EXISTS, ERROR_USER_EXISTS,

    STATUS_NO_SUCH_USER, ERROR_NO_SUCH_USER,

    STATUS_GROUP_EXISTS, ERROR_GROUP_EXISTS,

    STATUS_NO_SUCH_GROUP, ERROR_NO_SUCH_GROUP,

    STATUS_SPECIAL_GROUP, ERROR_SPECIAL_GROUP,

    STATUS_MEMBER_IN_GROUP, ERROR_MEMBER_IN_GROUP,

    STATUS_MEMBER_NOT_IN_GROUP, ERROR_MEMBER_NOT_IN_GROUP,

    STATUS_LAST_ADMIN, ERROR_LAST_ADMIN,

    STATUS_WRONG_PASSWORD, ERROR_INVALID_PASSWORD,
    STATUS_WRONG_PASSWORD_CORE, ERROR_INVALID_PASSWORD,

    STATUS_ILL_FORMED_PASSWORD, ERROR_ILL_FORMED_PASSWORD,

    STATUS_PASSWORD_RESTRICTION, ERROR_PASSWORD_RESTRICTION,

    STATUS_PASSWORD_EXPIRED, ERROR_PASSWORD_EXPIRED,
    STATUS_PASSWORD_MUST_CHANGE, ERROR_PASSWORD_MUST_CHANGE,

    STATUS_ACCOUNT_DISABLED, ERROR_ACCOUNT_DISABLED,
    STATUS_ACCOUNT_LOCKED_OUT, ERROR_ACCOUNT_LOCKED_OUT,

    STATUS_NONE_MAPPED, ERROR_NONE_MAPPED,

    STATUS_TOO_MANY_LUIDS_REQUESTED, ERROR_TOO_MANY_LUIDS_REQUESTED,

    STATUS_LUIDS_EXHAUSTED, ERROR_LUIDS_EXHAUSTED,

    STATUS_INVALID_SUB_AUTHORITY, ERROR_INVALID_SUB_AUTHORITY,

    STATUS_INVALID_ACL, ERROR_INVALID_ACL,

    STATUS_INVALID_SID, ERROR_INVALID_SID,

    STATUS_INVALID_SECURITY_DESCR, ERROR_INVALID_SECURITY_DESCR,

    STATUS_PROCEDURE_NOT_FOUND, ERROR_PROC_NOT_FOUND,

    STATUS_BAD_INITIAL_PC, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_FILE_FOR_SECTION, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_FORMAT, ERROR_BAD_EXE_FORMAT,
    STATUS_IMAGE_MP_UP_MISMATCH, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_NOT_MZ, ERROR_BAD_EXE_FORMAT,
    STATUS_IMAGE_CHECKSUM_MISMATCH, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_PROTECT, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_LE_FORMAT, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_NE_FORMAT, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_WIN_16, ERROR_BAD_EXE_FORMAT,

    STATUS_NO_TOKEN, ERROR_NO_TOKEN,

    STATUS_RANGE_NOT_LOCKED, ERROR_NOT_LOCKED,

    STATUS_SERVER_DISABLED, ERROR_SERVER_DISABLED,

    STATUS_SERVER_NOT_DISABLED, ERROR_SERVER_NOT_DISABLED,

    STATUS_INVALID_ID_AUTHORITY, ERROR_INVALID_ID_AUTHORITY,

    STATUS_ALLOTTED_SPACE_EXCEEDED, ERROR_ALLOTTED_SPACE_EXCEEDED,

    STATUS_TOO_MANY_PAGING_FILES, ERROR_NOT_ENOUGH_MEMORY,
    STATUS_INSUFFICIENT_RESOURCES, ERROR_NO_SYSTEM_RESOURCES,

    STATUS_INSUFF_SERVER_RESOURCES, ERROR_NOT_ENOUGH_SERVER_MEMORY,

    STATUS_FILE_INVALID, ERROR_FILE_INVALID,
    STATUS_MAPPED_FILE_SIZE_ZERO, ERROR_FILE_INVALID,

    STATUS_DEVICE_PAPER_EMPTY, ERROR_OUT_OF_PAPER,

    STATUS_DEVICE_POWERED_OFF, ERROR_NOT_READY,
    STATUS_DEVICE_OFF_LINE, ERROR_NOT_READY,

    STATUS_DEVICE_DATA_ERROR, ERROR_CRC,

    STATUS_DEVICE_NOT_READY, ERROR_NOT_READY,
    STATUS_DEVICE_POWER_FAILURE, ERROR_NOT_READY,

    STATUS_DEVICE_BUSY, ERROR_BUSY,                   // FIX, FIX - is there a better choice?

    STATUS_FREE_VM_NOT_AT_BASE, ERROR_INVALID_ADDRESS,
    STATUS_MEMORY_NOT_ALLOCATED, ERROR_INVALID_ADDRESS,

    STATUS_NOT_SAME_DEVICE, ERROR_NOT_SAME_DEVICE,

    STATUS_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,

    STATUS_REMOTE_NOT_LISTENING, ERROR_REM_NOT_LIST,

    STATUS_DUPLICATE_NAME, ERROR_DUP_NAME,

    STATUS_BAD_NETWORK_PATH, ERROR_BAD_NETPATH,

    STATUS_NETWORK_BUSY, ERROR_NETWORK_BUSY,

    STATUS_DEVICE_DOES_NOT_EXIST, ERROR_DEV_NOT_EXIST,

    STATUS_TOO_MANY_COMMANDS, ERROR_TOO_MANY_CMDS,

    STATUS_ADAPTER_HARDWARE_ERROR, ERROR_ADAP_HDW_ERR,

    STATUS_REDIRECTOR_NOT_STARTED, ERROR_PATH_NOT_FOUND,

    STATUS_INVALID_EA_NAME, ERROR_INVALID_EA_NAME,

    STATUS_EA_LIST_INCONSISTENT, ERROR_EA_LIST_INCONSISTENT,
    STATUS_EA_TOO_LARGE, ERROR_EA_LIST_INCONSISTENT,
    STATUS_INVALID_EA_FLAG, ERROR_EA_LIST_INCONSISTENT,
    STATUS_EAS_NOT_SUPPORTED, ERROR_EAS_NOT_SUPPORTED,

    STATUS_FILE_CORRUPT_ERROR, ERROR_FILE_CORRUPT,
    STATUS_EA_CORRUPT_ERROR, ERROR_FILE_CORRUPT,
    STATUS_NONEXISTENT_EA_ENTRY, ERROR_FILE_CORRUPT,
    STATUS_NO_EAS_ON_FILE, ERROR_FILE_CORRUPT,

    STATUS_INVALID_NETWORK_RESPONSE, ERROR_BAD_NET_RESP,

    STATUS_USER_SESSION_DELETED, ERROR_UNEXP_NET_ERR,
    STATUS_UNEXPECTED_NETWORK_ERROR, ERROR_UNEXP_NET_ERR,

    STATUS_USER_SESSION_DELETED, ERROR_UNEXP_NET_ERR,

    STATUS_BAD_REMOTE_ADAPTER, ERROR_BAD_REM_ADAP,

    STATUS_PRINT_QUEUE_FULL, ERROR_PRINTQ_FULL,

    STATUS_NO_SPOOL_SPACE, ERROR_NO_SPOOL_SPACE,

    STATUS_PRINT_CANCELLED, ERROR_PRINT_CANCELLED,

    STATUS_NETWORK_NAME_DELETED, ERROR_NETNAME_DELETED,

    STATUS_NETWORK_ACCESS_DENIED, ERROR_NETWORK_ACCESS_DENIED,

    STATUS_BAD_DEVICE_TYPE, ERROR_BAD_DEV_TYPE,

    STATUS_BAD_NETWORK_NAME, ERROR_BAD_NET_NAME,

    STATUS_TOO_MANY_NAMES, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_GUIDS_REQUESTED, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_ADDRESSES, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_NODES, ERROR_TOO_MANY_NAMES,

    STATUS_TOO_MANY_SESSIONS, ERROR_TOO_MANY_SESS,

    STATUS_SHARING_PAUSED, ERROR_SHARING_PAUSED,

    STATUS_REQUEST_NOT_ACCEPTED, ERROR_REQ_NOT_ACCEP,

    STATUS_REDIRECTOR_PAUSED, ERROR_REDIR_PAUSED,

    STATUS_NET_WRITE_FAULT, ERROR_NET_WRITE_FAULT,

    STATUS_VIRTUAL_CIRCUIT_CLOSED, ERROR_VC_DISCONNECTED,

    STATUS_INVALID_PIPE_STATE, ERROR_BAD_PIPE,
    STATUS_INVALID_READ_MODE, ERROR_BAD_PIPE,

    STATUS_PIPE_CLOSING, ERROR_NO_DATA,
    STATUS_PIPE_EMPTY, ERROR_NO_DATA,

    STATUS_PIPE_CONNECTED, ERROR_PIPE_CONNECTED,

    STATUS_PIPE_DISCONNECTED, ERROR_PIPE_NOT_CONNECTED,

    STATUS_PIPE_LISTENING, ERROR_PIPE_LISTENING,

    STATUS_PIPE_NOT_AVAILABLE, ERROR_PIPE_BUSY,
    STATUS_INSTANCE_NOT_AVAILABLE, ERROR_PIPE_BUSY,
    STATUS_PIPE_BUSY, ERROR_PIPE_BUSY,

    STATUS_PIPE_BROKEN, ERROR_BROKEN_PIPE,

    STATUS_DIRECTORY_NOT_EMPTY, ERROR_DIR_NOT_EMPTY,

    STATUS_TOO_MANY_OPENED_FILES, ERROR_TOO_MANY_OPEN_FILES,

    STATUS_IO_TIMEOUT, ERROR_SEM_TIMEOUT,

    STATUS_CANCELLED, ERROR_OPERATION_ABORTED,

    STATUS_UNRECOGNIZED_MEDIA, ERROR_UNRECOGNIZED_MEDIA,

    STATUS_INVALID_LEVEL, ERROR_INVALID_LEVEL,

    STATUS_UNRECOGNIZED_VOLUME, ERROR_UNRECOGNIZED_VOLUME,

    STATUS_MEDIA_WRITE_PROTECTED, ERROR_WRITE_PROTECT,
    STATUS_TOO_LATE, ERROR_WRITE_PROTECT,

    STATUS_SUCCESS, NO_ERROR,

    STATUS_FULLSCREEN_MODE, ERROR_FULLSCREEN_MODE,

    STATUS_END_OF_MEDIA, ERROR_END_OF_MEDIA,

    STATUS_EOM_OVERFLOW, ERROR_EOM_OVERFLOW,

    STATUS_BEGINNING_OF_MEDIA, ERROR_BEGINNING_OF_MEDIA,

    STATUS_MEDIA_CHANGED, ERROR_MEDIA_CHANGED,

    STATUS_BUS_RESET, ERROR_BUS_RESET,

    STATUS_FILEMARK_DETECTED, ERROR_FILEMARK_DETECTED,

    STATUS_SETMARK_DETECTED, ERROR_SETMARK_DETECTED,

    STATUS_NO_DATA_DETECTED, ERROR_NO_DATA_DETECTED,

    STATUS_PARTITION_FAILURE, ERROR_PARTITION_FAILURE,

    STATUS_INVALID_BLOCK_LENGTH, ERROR_INVALID_BLOCK_LENGTH,

    STATUS_DEVICE_NOT_PARTITIONED, ERROR_DEVICE_NOT_PARTITIONED,

    STATUS_UNABLE_TO_LOCK_MEDIA, ERROR_UNABLE_TO_LOCK_MEDIA,

    STATUS_UNABLE_TO_UNLOAD_MEDIA, ERROR_UNABLE_TO_UNLOAD_MEDIA,

    STATUS_UNMAPPABLE_CHARACTER, ERROR_NO_UNICODE_TRANSLATION,

    STATUS_NOT_ALL_ASSIGNED, ERROR_NOT_ALL_ASSIGNED,

    STATUS_SOME_NOT_MAPPED, ERROR_SOME_NOT_MAPPED,

    STATUS_NO_QUOTAS_FOR_ACCOUNT, ERROR_NO_QUOTAS_FOR_ACCOUNT,

    STATUS_LOCAL_USER_SESSION_KEY, ERROR_LOCAL_USER_SESSION_KEY,

    STATUS_NULL_LM_PASSWORD, ERROR_NULL_LM_PASSWORD,

    STATUS_BAD_INHERITANCE_ACL, ERROR_BAD_INHERITANCE_ACL,

    STATUS_INVALID_GROUP_ATTRIBUTES, ERROR_INVALID_GROUP_ATTRIBUTES,

    STATUS_BAD_IMPERSONATION_LEVEL, ERROR_BAD_IMPERSONATION_LEVEL,

    STATUS_CANT_OPEN_ANONYMOUS, ERROR_CANT_OPEN_ANONYMOUS,

    STATUS_BAD_VALIDATION_CLASS, ERROR_BAD_VALIDATION_CLASS,

    STATUS_BAD_TOKEN_TYPE, ERROR_BAD_TOKEN_TYPE,

    STATUS_NO_SECURITY_ON_OBJECT, ERROR_NO_SECURITY_ON_OBJECT,

    STATUS_CANT_ACCESS_DOMAIN_INFO, ERROR_CANT_ACCESS_DOMAIN_INFO,

    STATUS_INVALID_SERVER_STATE, ERROR_INVALID_SERVER_STATE,

    STATUS_INVALID_DOMAIN_STATE, ERROR_INVALID_DOMAIN_STATE,

    STATUS_INVALID_DOMAIN_ROLE, ERROR_INVALID_DOMAIN_ROLE,

    STATUS_NO_SUCH_DOMAIN, ERROR_NO_SUCH_DOMAIN,

    STATUS_DOMAIN_EXISTS, ERROR_DOMAIN_EXISTS,

    STATUS_DOMAIN_LIMIT_EXCEEDED, ERROR_DOMAIN_LIMIT_EXCEEDED,

    STATUS_INTERNAL_DB_CORRUPTION, ERROR_INTERNAL_DB_CORRUPTION,

    STATUS_INTERNAL_ERROR, ERROR_INTERNAL_ERROR,

    STATUS_GENERIC_NOT_MAPPED, ERROR_GENERIC_NOT_MAPPED,

    STATUS_BAD_DESCRIPTOR_FORMAT, ERROR_BAD_DESCRIPTOR_FORMAT,

    STATUS_NOT_LOGON_PROCESS, ERROR_NOT_LOGON_PROCESS,

    STATUS_LOGON_SESSION_EXISTS, ERROR_LOGON_SESSION_EXISTS,

    STATUS_NO_SUCH_PACKAGE, ERROR_NO_SUCH_PACKAGE,

    STATUS_BAD_LOGON_SESSION_STATE, ERROR_BAD_LOGON_SESSION_STATE,

    STATUS_LOGON_SESSION_COLLISION, ERROR_LOGON_SESSION_COLLISION,

    STATUS_INVALID_LOGON_TYPE, ERROR_INVALID_LOGON_TYPE,

    STATUS_RXACT_INVALID_STATE, ERROR_RXACT_INVALID_STATE,

    STATUS_RXACT_COMMIT_FAILURE, ERROR_RXACT_COMMIT_FAILURE,

    STATUS_SPECIAL_ACCOUNT, ERROR_SPECIAL_ACCOUNT,

    STATUS_SPECIAL_USER, ERROR_SPECIAL_USER,

    STATUS_MEMBERS_PRIMARY_GROUP, ERROR_MEMBERS_PRIMARY_GROUP,

    STATUS_TOKEN_ALREADY_IN_USE, ERROR_TOKEN_ALREADY_IN_USE,

    STATUS_NO_SUCH_ALIAS, ERROR_NO_SUCH_ALIAS,

    STATUS_MEMBER_NOT_IN_ALIAS, ERROR_MEMBER_NOT_IN_ALIAS,

    STATUS_MEMBER_IN_ALIAS, ERROR_MEMBER_IN_ALIAS,

    STATUS_ALIAS_EXISTS, ERROR_ALIAS_EXISTS,

    STATUS_LOGON_NOT_GRANTED, ERROR_LOGON_NOT_GRANTED,

    STATUS_TOO_MANY_SECRETS, ERROR_TOO_MANY_SECRETS,

    STATUS_SECRET_TOO_LONG, ERROR_SECRET_TOO_LONG,

    STATUS_INTERNAL_DB_ERROR, ERROR_INTERNAL_DB_ERROR,

    STATUS_TOO_MANY_CONTEXT_IDS, ERROR_TOO_MANY_CONTEXT_IDS,

    STATUS_LOGON_TYPE_NOT_GRANTED, ERROR_LOGON_TYPE_NOT_GRANTED,

    STATUS_NT_CROSS_ENCRYPTION_REQUIRED, ERROR_NT_CROSS_ENCRYPTION_REQUIRED,

    STATUS_NO_SUCH_MEMBER, ERROR_NO_SUCH_MEMBER,

    STATUS_INVALID_MEMBER, ERROR_INVALID_MEMBER,

    STATUS_TOO_MANY_SIDS, ERROR_TOO_MANY_SIDS,

    STATUS_LM_CROSS_ENCRYPTION_REQUIRED, ERROR_LM_CROSS_ENCRYPTION_REQUIRED,

    STATUS_MESSAGE_NOT_FOUND, ERROR_MR_MID_NOT_FOUND,

    STATUS_LOCAL_DISCONNECT, ERROR_NETNAME_DELETED,
    STATUS_REMOTE_DISCONNECT, ERROR_NETNAME_DELETED,

    STATUS_REMOTE_RESOURCES, ERROR_REM_NOT_LIST,

    STATUS_LINK_FAILED, ERROR_UNEXP_NET_ERR,
    STATUS_LINK_TIMEOUT, ERROR_UNEXP_NET_ERR,

    STATUS_INVALID_CONNECTION, ERROR_UNEXP_NET_ERR,
    STATUS_INVALID_ADDRESS, ERROR_UNEXP_NET_ERR,

    STATUS_IO_DEVICE_ERROR, ERROR_IO_DEVICE,
    STATUS_DEVICE_PROTOCOL_ERROR, ERROR_IO_DEVICE,
    STATUS_DRIVER_INTERNAL_ERROR, ERROR_IO_DEVICE,

    STATUS_INVALID_DEVICE_STATE, ERROR_BAD_COMMAND,

    STATUS_DEVICE_CONFIGURATION_ERROR, ERROR_INVALID_PARAMETER,

    STATUS_INVALID_USER_BUFFER, ERROR_INVALID_USER_BUFFER,

    STATUS_SERIAL_NO_DEVICE_INITED, ERROR_SERIAL_NO_DEVICE,

    STATUS_SHARED_IRQ_BUSY, ERROR_IRQ_BUSY,

    STATUS_SERIAL_MORE_WRITES, ERROR_MORE_WRITES,

    STATUS_SERIAL_COUNTER_TIMEOUT, ERROR_COUNTER_TIMEOUT,

    STATUS_FLOPPY_ID_MARK_NOT_FOUND, ERROR_FLOPPY_ID_MARK_NOT_FOUND,

    STATUS_FLOPPY_WRONG_CYLINDER, ERROR_FLOPPY_WRONG_CYLINDER,

    STATUS_FLOPPY_UNKNOWN_ERROR, ERROR_FLOPPY_UNKNOWN_ERROR,

    STATUS_FLOPPY_BAD_REGISTERS, ERROR_FLOPPY_BAD_REGISTERS,

    STATUS_DISK_RECALIBRATE_FAILED, ERROR_DISK_RECALIBRATE_FAILED,

    STATUS_DISK_OPERATION_FAILED, ERROR_DISK_OPERATION_FAILED,

    STATUS_DISK_RESET_FAILED, ERROR_DISK_RESET_FAILED,

    STATUS_EVENTLOG_FILE_CORRUPT, ERROR_EVENTLOG_FILE_CORRUPT,

    STATUS_EVENTLOG_CANT_START, ERROR_EVENTLOG_CANT_START,

    STATUS_NETLOGON_NOT_STARTED, ERROR_NETLOGON_NOT_STARTED,

    STATUS_ACCOUNT_EXPIRED, ERROR_ACCOUNT_EXPIRED,

    STATUS_NETWORK_CREDENTIAL_CONFLICT, ERROR_SESSION_CREDENTIAL_CONFLICT,

    STATUS_REMOTE_SESSION_LIMIT, ERROR_REMOTE_SESSION_LIMIT_EXCEEDED,

    STATUS_INVALID_BUFFER_SIZE, ERROR_INVALID_USER_BUFFER,

    STATUS_INVALID_ADDRESS_COMPONENT, ERROR_INVALID_NETNAME,
    STATUS_INVALID_ADDRESS_WILDCARD, ERROR_INVALID_NETNAME,

    STATUS_ADDRESS_ALREADY_EXISTS, ERROR_DUP_NAME,

    STATUS_ADDRESS_CLOSED, ERROR_NETNAME_DELETED,
    STATUS_CONNECTION_DISCONNECTED, ERROR_NETNAME_DELETED,

    STATUS_CONNECTION_RESET, ERROR_NETNAME_DELETED,

    STATUS_TRANSACTION_ABORTED, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_TIMED_OUT, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_NO_RELEASE, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_NO_MATCH, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_RESPONDED, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_INVALID_ID, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_INVALID_TYPE, ERROR_UNEXP_NET_ERR,

    STATUS_NOT_SERVER_SESSION, ERROR_NOT_SUPPORTED,
    STATUS_NOT_CLIENT_SESSION, ERROR_NOT_SUPPORTED,

    STATUS_USER_MAPPED_FILE, ERROR_USER_MAPPED_FILE,

    STATUS_PLUGPLAY_NO_DEVICE, ERROR_SERVICE_DISABLED,

    STATUS_NO_TRUST_LSA_SECRET, ERROR_NO_TRUST_LSA_SECRET,

    STATUS_NO_TRUST_SAM_ACCOUNT, ERROR_NO_TRUST_SAM_ACCOUNT,

    STATUS_TRUSTED_DOMAIN_FAILURE, ERROR_TRUSTED_DOMAIN_FAILURE,

    STATUS_TRUSTED_RELATIONSHIP_FAILURE, ERROR_TRUSTED_RELATIONSHIP_FAILURE,

    STATUS_TRUST_FAILURE, ERROR_TRUST_FAILURE,

    STATUS_LOG_FILE_FULL, ERROR_LOG_FILE_FULL,

    STATUS_EVENTLOG_FILE_CHANGED, ERROR_EVENTLOG_FILE_CHANGED,

    STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT, ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT,

    STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT, ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT,

    STATUS_NOLOGON_SERVER_TRUST_ACCOUNT, ERROR_NOLOGON_SERVER_TRUST_ACCOUNT,

    STATUS_DOMAIN_TRUST_INCONSISTENT, ERROR_DOMAIN_TRUST_INCONSISTENT,

    STATUS_NO_USER_SESSION_KEY, ERROR_NO_USER_SESSION_KEY,

    STATUS_POSSIBLE_DEADLOCK, ERROR_POSSIBLE_DEADLOCK,

    STATUS_IMAGE_ALREADY_LOADED, ERROR_SERVICE_ALREADY_RUNNING,

    STATUS_NO_BROWSER_SERVERS_FOUND, ERROR_NO_BROWSER_SERVERS_FOUND,

    STATUS_MAPPED_ALIGNMENT, ERROR_MAPPED_ALIGNMENT,

    STATUS_CONNECTION_IN_USE, ERROR_DEVICE_IN_USE,

    STATUS_VERIFY_REQUIRED, ERROR_MEDIA_CHANGED,

    STATUS_ALREADY_DISCONNECTED, ERROR_ACTIVE_CONNECTIONS,

    STATUS_CONNECTION_REFUSED, ERROR_CONNECTION_REFUSED,

    STATUS_GRACEFUL_DISCONNECT, ERROR_GRACEFUL_DISCONNECT,

    STATUS_ADDRESS_ALREADY_ASSOCIATED, ERROR_ADDRESS_ALREADY_ASSOCIATED,

    STATUS_ADDRESS_NOT_ASSOCIATED, ERROR_ADDRESS_NOT_ASSOCIATED,

    STATUS_CONNECTION_INVALID, ERROR_CONNECTION_INVALID,

    STATUS_CONNECTION_ACTIVE, ERROR_CONNECTION_ACTIVE,

    STATUS_NETWORK_UNREACHABLE, ERROR_NETWORK_UNREACHABLE,

    STATUS_HOST_UNREACHABLE, ERROR_HOST_UNREACHABLE,

    STATUS_PROTOCOL_UNREACHABLE, ERROR_PROTOCOL_UNREACHABLE,

    STATUS_PORT_UNREACHABLE, ERROR_PORT_UNREACHABLE,

    STATUS_REQUEST_ABORTED, ERROR_REQUEST_ABORTED,

    STATUS_CONNECTION_ABORTED, ERROR_CONNECTION_ABORTED,

    STATUS_CONNECTION_COUNT_LIMIT, ERROR_CONNECTION_COUNT_LIMIT,

    STATUS_PATH_NOT_COVERED, ERROR_HOST_UNREACHABLE,

    STATUS_LOGIN_TIME_RESTRICTION, ERROR_LOGIN_TIME_RESTRICTION,
    STATUS_LOGIN_WKSTA_RESTRICTION, ERROR_LOGIN_WKSTA_RESTRICTION,
    STATUS_LICENSE_QUOTA_EXCEEDED, ERROR_LICENSE_QUOTA_EXCEEDED,

    STATUS_RESOURCE_NOT_OWNED, ERROR_NOT_OWNER,

    STATUS_DUPLICATE_OBJECTID, STATUS_DUPLICATE_OBJECTID,
    STATUS_OBJECTID_EXISTS, STATUS_OBJECTID_EXISTS,
    0xffffffff, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\smclib\vxd\smcvxd.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    smcvxd.h

Abstract:

    Operation system data definitions for the smart card library

Environment:

    Windows9x VxD

Notes:

Revision History:

    - Created June 1997 by Klaus Schutz 

--*/                                         

#ifdef SMCLIB_HEADER

#define WANTVXDWRAPS

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>
#include <basedef.h>
#include <vmm.h>
#include <debug.h>
#include <vwin32.h>
#include <winerror.h>
#include <vxdwraps.h>

#pragma VxD_LOCKED_CODE_SEG
#pragma VxD_LOCKED_DATA_SEG

#endif

typedef struct _SMARTCARD_EXTENSION *PSMARTCARD_EXTENSION;

typedef struct _OS_DEP_DATA {

	//
	// Pointer to the smartcard extension
	//
	PSMARTCARD_EXTENSION SmartcardExtension;

	//
	// Current DiocParams to be processed
	//
	PDIOCPARAMETERS CurrentDiocParams;

    //
    // These overlapped data are used for all pending operations
    //
    OVERLAPPED *CurrentOverlappedData;

    //
    // These overlapped data are used for card tracking completion
    //
    OVERLAPPED *NotificationOverlappedData;

    //
    // This is used to synchronize access to the driver
    //
    PVMMMUTEX Mutex;

} OS_DEP_DATA, *POS_DEP_DATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\stcusb\common.h ===
/*++

Copyright (c) 1999 SCM Microsystems, Inc.

Module Name:

    common.h

Abstract:

   Constants, structures, macro etc.. for STC USB WDM


Revision History:

   PP       01/20/1999  Initial Version

--*/


#if !defined( __COMMON_H__ )
#define __COMMON_H__

#include <ntstatus.h>
#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <usb100.h>
#include <DEVIOCTL.H>

#define DRIVER_NAME "STCUSB"

#include "SMCLIB.h"
#include "WINSMCRD.h"

//
// Constants -----------------------------------------------------------------
//

#define SMARTCARD_POOL_TAG '4SCS'

#define STCUSB_VENDOR_NAME             "SCM Microsystems"
#define STCUSB_PRODUCT_NAME               "STCUSB"
#define MAX_READ_REGISTER_BUFFER_SIZE     18

#define STCUSB_MAX_DEVICE              16
#define USB_WRITE_RETRIES              2

#define IOCTL_WRITE_STC_REGISTER       SCARD_CTL_CODE(0x800)
#define IOCTL_READ_STC_REGISTER           SCARD_CTL_CODE(0x801)
#define IOCTL_WRITE_STC_DATA           SCARD_CTL_CODE(0x802)
#define IOCTL_READ_STC_DATA               SCARD_CTL_CODE(0x803)

#define POLLING_PERIOD                 500

#define CLA_IDX                        0
#define INS_IDX                        1
#define P1_IDX                      2
#define P2_IDX                      3
#define P3_IDX                      4

#define ISO_OUT                        TRUE
#define ISO_IN                      !ISO_OUT


#define  NAD_IDX                       0x00
#define PCB_IDX                        0x01
#define LEN_IDX                        0x02
#define DATA_IDX                    0x03
#define PROLOGUE_LEN                0x03
#define EPILOGUE_LEN                0x01

#define OSC                         16000
#define FREQ                        3580
#define CYC_TO_MS( cyc )               ((ULONG)( cyc / FREQ ))

// register addresses
#define ADR_ETULENGTH15                0x00
#define ADR_ETULENGTH7                 0x01
#define ADR_CGT8                    0x02
#define ADR_CGT7                    0x03
#define ADR_CWT31                   0x04
#define ADR_CWT23                   0x05
#define ADR_CWT15                   0x06
#define ADR_CWT7                    0x07
#define  ADR_BGT8                   0x08
#define ADR_BGT7                    0x09
#define ADR_BWT31                   0x0A
#define ADR_BWT23                   0x0B
#define ADR_BWT15                   0x0C
#define ADR_BWT7                    0x0D
#define ADR_TCON                    0x0E
#define ADR_UART_CONTROL               0x0F
#define ADR_FIFO_CONFIG                0x10
#define ADR_INT_CONTROL                0x11
#define ADR_INT_STATUS                 0x12
#define ADR_DATA                    0x13
#define ADR_IO_CONFIG                  0x14
#define ADR_SC_CONTROL                 0x15
#define ADR_CLOCK_CONTROL              0x16


// clock control register
#define M_CKE                       0x01
#define M_OEN                       0x02

// ETU length register
#define M_ETU_RST                   0x80
#define M_DIV                       0x30
#define M_DIV1                      0x20
#define M_DIV0                      0x10
#define M_ETUH                      0x0F

#define M_ETUL                      0xFF

// CGT length register
#define M_CGTH                      0x01
#define M_CGTL                      0XFF

// BGT length register
#define M_BGTH                      0x01
#define M_BGTL                      0xFF

// CWT register
#define M_CWT4                      0xFF
#define M_CWT3                      0xFF
#define M_CWT2                      0xFF
#define M_CWT1                      0xFF

// TCON register
#define M_MGT                       0x80
#define M_MWT                       0x40
#define M_WTR                       0x04
#define M_GT                        0x02
#define M_WT                        0x01

// UART control register
#define M_UEN                       0x40
#define M_UART_RST                     0x20
#define M_CONV                      0x10
#define  M_TS                       0x08
#define  M_PE                       0x04
#define  M_R                           0x03

// FIFO config register
#define M_RFP                       0x80
#define M_LD                        0x0F

// INT control register
#define  M_SSL                      0x20
#define M_DRM                       0x10
#define M_DSM                       0x08
#define M_WTE                       0x04
#define M_SIM                       0x02
#define M_MEM                       0x01
#define M_DRM_MEM                   0x11

// INT status register
#define M_FNE                       0x80
#define M_FE                        0x40
#define M_OE                        0x20
#define M_DR                        0x10
#define M_TRE                       0x08
#define M_WTOVF                        0x04
#define M_SENSE                        0x02
#define M_MOV                       0x01

// SMART card interface
#define M_ALT1                      0x20
#define M_ALT2                      0x10
#define M_ALT0                      0x08
#define M_SDE                       0x04
#define M_SL                        0x02
#define M_SD                        0x01

// SMART card control register
#define M_IO                        0x80
#define M_VCE                       0x40
#define M_SC_RST                    0x20
#define M_SCE                       0x10
#define M_SCK                       0x08
#define M_C8                        0x04
#define M_C4                        0x02
#define M_VPE                       0x01


// Nad
#define HOST_TO_STC1                0x12
#define HOST_TO_STC2                0x52
#define HOST_TO_ICC1                0x02
#define HOST_TO_ICC2                0x42
#define STC1_TO_HOST                0x21
#define STC2_TO_HOST                0x25
#define ICC1_TO_HOST                0x20
#define ICC2_TO_HOST                0x24

// PCB
#define PCB                         0x00


#define CLA_READ_REGISTER              0x00
#define INS_READ_REGISTER              0xB0

#define CLA_WRITE_REGISTER             0x00
#define INS_WRITE_REGISTER             0xD0

#define CLA_READ_FIRMWARE_REVISION        0x00
#define INS_READ_FIRMWARE_REVISION        0xB1

#define PCB_DEFAULT                    0x00
#define TLV_BUFFER_SIZE                0x20
#define ATR_SIZE                    0x40  // TS + 32 + SW + PROLOGUE + EPILOGUE...

#define MAX_T1_BLOCK_SIZE              270

// ATR interface byte coding in TS
#define TAx                         0x01
#define TBx                         0x02
#define TCx                         0x04
#define TDx                         0x08


#define FREQ_DIV     1  // 3,58 MHz XTAL -> SC Clock = 3.58MHz
//#define FREQ_DIV   0x08  /* 30MHz XTAL -> SC Clock = 3.75MHz */

#define PROTOCOL_TO                    0
#define PROTOCOL_T1                    1
#define PROTOCOL_T14                14
#define PROTOCOL_T15                15

#define STC_READ_TIMEOUT               1000

//  max. of communication errors while polling the device
#define ERROR_COUNTER_TRESHOLD     5
//
// Macros --------------------------------------------------------------------
//
#define SysCompareMemory( p1, p2, Len )         ( RtlCompareMemory( p1,p2, Len ) != Len )
#define SysCopyMemory( pDest, pSrc, Len )    RtlCopyMemory( pDest, pSrc, Len )
#define SysFillMemory( pDest, Value, Len )      RtlFillMemory( pDest, Len, Value )


//
// Structures ----------------------------------------------------------------
//
typedef struct _DEVICE_EXTENSION
{
   // The PDO that we are attached to
    PDEVICE_OBJECT AttachedPDO;

    // Our PnP device name
   UNICODE_STRING DeviceName;

    // Current number of io-requests
    LONG IoCount;

    // Used to access IoCount;
    KSPIN_LOCK SpinLock;

     // Used to signal that the device has been removed
    //KEVENT ReaderRemoved;

    // Used to signal that the reader is able to process reqeusts
    KEVENT ReaderStarted;

    // Used to signal the the reader has been closed
    LONG ReaderOpen;

    // Used to synchonize the polling thread
    KMUTEX   hMutex;

    // Used to keep track of the current power state the reader is in
    LONG PowerState;

   // configuration handle for the configuration the device is currently in use
    USBD_CONFIGURATION_HANDLE ConfigurationHandle;

    // ptr to the USB device descriptor for this device
   PUSB_DEVICE_DESCRIPTOR DeviceDescriptor;

    // we support up to one interface
   PUSBD_INTERFACE_INFORMATION Interface;

   // poll thread relevant data
   KEVENT       FinishPollThread;
   KEVENT       PollThreadStopped;
   PIO_WORKITEM PollWorkItem;

   SMARTCARD_EXTENSION  SmartcardExtension;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


typedef enum _READER_POWER_STATE {
    PowerReaderUnspecified = 0,
    PowerReaderWorking,
    PowerReaderOff
} READER_POWER_STATE, *PREADER_POWER_STATE;

typedef struct _READER_EXTENSION {

   UCHAR Device;

   // Software revision ID of the firmware.
   UCHAR FirmwareMajor, FirmwareMinor;

    BOOLEAN CardPresent;

    // Current reader power state.
    READER_POWER_STATE ReaderPowerState;

   // read timeout in ms
   ULONG       ReadTimeout;

   PDEVICE_OBJECT DeviceObject;

   UCHAR ucReadBuffer[MIN_BUFFER_SIZE];

   ULONG ulReadBufferLen;

   // counter for communication errors while polling the reader
   ULONG ErrorCounter;
} READER_EXTENSION, *PREADER_EXTENSION;

#define SIZEOF_READER_EXTENSION     ( sizeof( READER_EXTENSION ))

typedef struct _STC_REGISTER
{
   UCHAR Register;
   UCHAR Size;
   ULONG Value;

} STC_REGISTER, *PSTC_REGISTER;

//
// wrapper ------------------------------------------------------------------
//


#define IFReadSTCRegister  UsbReadSTCRegister
#define IFReadSTCData      UsbReadSTCData
#define IFWriteSTCRegister UsbWriteSTCRegister
#define IFWriteSTCData     UsbWriteSTCData

#endif   // __COMMON_H__

// ------------------------------- END OF FILE -------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\stcusb\makefile.inc ===
stcusblg.h stcusblg.rc msg00001.bin: stcusblg.mc
    mc stcusblg.mc

stcusblg.rc: msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\stcusb\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by stcusb.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\stcusb\stccb.h ===
/*++

Copyright (c) 1998 SCM Microsystems, Inc.

Module Name:

    stccb.h

Abstract:

	Constants & access function prototypes for callback functions


Revision History:

	PP			12/18/1998	Initial Version

--*/
#if !defined( __STC_CB_H__ )
#define __STC_CB_H__

//
//	Prototypes ----------------------------------------------------------------
//


NTSTATUS
CBCardPower(
	PSMARTCARD_EXTENSION SmartcardExtension);

NTSTATUS
CBSetProtocol(		
	PSMARTCARD_EXTENSION SmartcardExtension);

NTSTATUS
CBTransmit(
	PSMARTCARD_EXTENSION SmartcardExtension);

NTSTATUS
CBCardTracking(
	PSMARTCARD_EXTENSION SmartcardExtension);

NTSTATUS
CBUpdateCardState(
	PSMARTCARD_EXTENSION SmartcardExtension);

NTSTATUS
CBGenericIOCTL(
	PSMARTCARD_EXTENSION SmartcardExtension);

//
//	LOCAL PROTOTYPES (not part of the callback handler interface )
//
NTSTATUS
CBT0Transmit(		
	PSMARTCARD_EXTENSION SmartcardExtension);

NTSTATUS
CBT1Transmit(
	PSMARTCARD_EXTENSION SmartcardExtension);

NTSTATUS
CBRawTransmit(		
	PSMARTCARD_EXTENSION SmartcardExtension);

NTSTATUS
CBSynchronizeSTC(
	PSMARTCARD_EXTENSION SmartcardExtension );


#endif // __STC_CB_H__

//	------------------------------- END OF FILE -------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\stcusb\stccb.c ===
/*++

Copyright (c) 1998 SCM Microsystems, Inc.

Module Name:

   StcCb.c

Abstract:

   Declaration of callback functions - WDM Version


Revision History:


   PP 1.01     01/19/1998
   PP 1.00     12/18/1998     Initial Version

--*/


// Include

#include "common.h"
#include "stccmd.h"
#include "stccb.h"
#include "stcusbnt.h"
#include "usbcom.h"

NTSTATUS
CBCardPower(
   PSMARTCARD_EXTENSION SmartcardExtension)
/*++

CBCardPower:
   callback handler for SMCLIB RDF_CARD_POWER

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_SUCCESS
   STATUS_NO_MEDIA
   STATUS_TIMEOUT
   STATUS_BUFFER_TOO_SMALL

--*/
{
   NTSTATUS       NTStatus = STATUS_SUCCESS;
   UCHAR          ATRBuffer[ ATR_SIZE ];
   ULONG          Command,
                  ATRLength;
   PREADER_EXTENSION ReaderExtension;

   SmartcardDebug( DEBUG_TRACE, ("%s!CBCardPower Enter\n",DRIVER_NAME ));

   ReaderExtension = SmartcardExtension->ReaderExtension;


   // discard old ATR
   SysFillMemory( SmartcardExtension->CardCapabilities.ATR.Buffer, 0x00, 0x40 );

   SmartcardExtension->CardCapabilities.ATR.Length = 0;
   SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;

   Command = SmartcardExtension->MinorIoControlCode;

   switch ( Command )
   {
      case SCARD_WARM_RESET:

         // if the card was not powerd, fall through to cold reset
         if( SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_SWALLOWED )
         {
            // reset the card
            ATRLength = ATR_SIZE;
            NTStatus = STCReset(
               ReaderExtension,
               0,             // not used: ReaderExtension->Device,
               TRUE,          // warm reset
               ATRBuffer,
               &ATRLength);

            break;
         }
         // warm reset not possible because card was not powerd

      case SCARD_COLD_RESET:
         // reset the card
         ATRLength = ATR_SIZE;
         NTStatus = STCReset(
            ReaderExtension,
            0,                // not used: ReaderExtension->Device,
            FALSE,               // cold reset
            ATRBuffer,
            &ATRLength);
         break;

      case SCARD_POWER_DOWN:

         // discard old card status
         ATRLength = 0;
         NTStatus = STCPowerOff( ReaderExtension );

         if(NTStatus == STATUS_SUCCESS)
         {
            SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_PRESENT;
         }
         break;
   }

   // finish the request
   if( NTStatus == STATUS_SUCCESS )
   {

      // update all neccessary data if an ATR was received
      if( ATRLength >= 2 )
      {
         // copy ATR to user buffer
         if( ATRLength <= SmartcardExtension->IoRequest.ReplyBufferLength )
         {
            SysCopyMemory(
               SmartcardExtension->IoRequest.ReplyBuffer,
               ATRBuffer,
               ATRLength);
            *SmartcardExtension->IoRequest.Information = ATRLength;
         }
         else
         {
            NTStatus = STATUS_BUFFER_TOO_SMALL;
         }

         // copy ATR to card capability buffer
         if( ATRLength <= MAXIMUM_ATR_LENGTH )
         {
            SysCopyMemory(
               SmartcardExtension->CardCapabilities.ATR.Buffer,
               ATRBuffer,
               ATRLength);

            SmartcardExtension->CardCapabilities.ATR.Length = ( UCHAR )ATRLength;

            // let the lib update the card capabilities
            NTStatus = SmartcardUpdateCardCapabilities( SmartcardExtension );

         }
         else
         {
            NTStatus = STATUS_BUFFER_TOO_SMALL;
         }
         if( NTStatus == STATUS_SUCCESS )
         {
            // set the stc registers
            CBSynchronizeSTC( SmartcardExtension );

            // set read timeout
            if( SmartcardExtension->CardCapabilities.Protocol.Selected == SCARD_PROTOCOL_T1 )
            {
               ReaderExtension->ReadTimeout =
                  (ULONG) (SmartcardExtension->CardCapabilities.T1.BWT  / 1000);

            }
            else
            {
               ReaderExtension->ReadTimeout =
                  (ULONG) (SmartcardExtension->CardCapabilities.T0.WT / 1000);
               if(ReaderExtension->ReadTimeout < 50)
               {
                  ReaderExtension->ReadTimeout = 50; //  50 ms minimum timeout
               }
            }
         }
      }
   }


   SmartcardDebug( DEBUG_TRACE,( "%s!CBCardPower Exit: %X\n", DRIVER_NAME,NTStatus ));
   return( NTStatus );
}

NTSTATUS
CBSetProtocol(
   PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

CBSetProtocol:
   callback handler for SMCLIB RDF_SET_PROTOCOL

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_SUCCESS
   STATUS_NO_MEDIA
   STATUS_TIMEOUT
   STATUS_BUFFER_TOO_SMALL
   STATUS_INVALID_DEVICE_STATE
   STATUS_INVALID_DEVICE_REQUEST

--*/
{
   NTSTATUS       NTStatus = STATUS_PENDING;
   UCHAR          PTSRequest[5],
                  PTSReply[5];
   ULONG          NewProtocol;
   PREADER_EXTENSION ReaderExtension;

   SmartcardDebug( DEBUG_TRACE, ("%s!CBSetProtocol Enter\n",DRIVER_NAME ));

   ReaderExtension = SmartcardExtension->ReaderExtension;
   NewProtocol    = SmartcardExtension->MinorIoControlCode;

   // check if the card is already in specific state
   if( ( SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC )  &&
      ( SmartcardExtension->CardCapabilities.Protocol.Selected & NewProtocol ))
   {
      NTStatus = STATUS_SUCCESS;
   }

   // protocol supported?
   if( !( SmartcardExtension->CardCapabilities.Protocol.Supported & NewProtocol ) ||
      !( SmartcardExtension->ReaderCapabilities.SupportedProtocols & NewProtocol ))
   {
      NTStatus = STATUS_INVALID_DEVICE_REQUEST;
   }

   // send PTS
   while( NTStatus == STATUS_PENDING )
   {
      // set initial character of PTS
      PTSRequest[0] = 0xFF;

      // set the format character
      if(( NewProtocol & SCARD_PROTOCOL_T1 )&&
         (SmartcardExtension->CardCapabilities.Protocol.Supported & SCARD_PROTOCOL_T1 ))
      {
         PTSRequest[1] = 0x11;
         SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T1;
      }
      else
      {
         PTSRequest[1] = 0x10;
         SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T0;
      }

      // PTS1 codes Fl and Dl
      PTSRequest[2] =
         SmartcardExtension->CardCapabilities.PtsData.Fl << 4 |
         SmartcardExtension->CardCapabilities.PtsData.Dl;

      // check character
      PTSRequest[3] = PTSRequest[0] ^ PTSRequest[1] ^ PTSRequest[2];

      // write PTSRequest
      NTStatus = IFWriteSTCData( ReaderExtension, PTSRequest, 4 );

      // get response
      if( NTStatus == STATUS_SUCCESS )
      {
         NTStatus = IFReadSTCData( ReaderExtension, PTSReply, 4 );

         if(( NTStatus == STATUS_SUCCESS ) && !SysCompareMemory( PTSRequest, PTSReply, 4))
         {
            // set the stc registers
            SmartcardExtension->CardCapabilities.Dl =
               SmartcardExtension->CardCapabilities.PtsData.Dl;
            SmartcardExtension->CardCapabilities.Fl =
               SmartcardExtension->CardCapabilities.PtsData.Fl;

            CBSynchronizeSTC( SmartcardExtension );

            // the card replied correctly to the PTS-request
            break;
         }
      }

      //
      // The card did either NOT reply or it replied incorrectly
      // so try default values
      //
      if( SmartcardExtension->CardCapabilities.PtsData.Type != PTS_TYPE_DEFAULT )
      {
         SmartcardExtension->CardCapabilities.PtsData.Type  = PTS_TYPE_DEFAULT;
         SmartcardExtension->MinorIoControlCode          = SCARD_COLD_RESET;
         NTStatus = CBCardPower( SmartcardExtension );

         if( NTStatus == STATUS_SUCCESS )
         {
            NTStatus = STATUS_PENDING;
         }
         else
         {
            NTStatus = STATUS_DEVICE_PROTOCOL_ERROR;
         }
      }
   }

   if( NTStatus == STATUS_TIMEOUT )
   {
      NTStatus = STATUS_IO_TIMEOUT;
   }

   if( NTStatus == STATUS_SUCCESS )
   {
      // card replied correctly to the PTS request
      if( SmartcardExtension->CardCapabilities.Protocol.Selected & SCARD_PROTOCOL_T1 )
      {
         ReaderExtension->ReadTimeout = SmartcardExtension->CardCapabilities.T1.BWT / 1000;
      }
      else
      {
         ULONG ClockRateFactor =
            SmartcardExtension->CardCapabilities.ClockRateConversion[SmartcardExtension->CardCapabilities.PtsData.Fl].F;

         // check for RFU value, and replace by default value
         if( !ClockRateFactor )
            ClockRateFactor = 372;

         ReaderExtension->ReadTimeout = 960 
            * SmartcardExtension->CardCapabilities.T0.WI 
            * ClockRateFactor
            / SmartcardExtension->CardCapabilities.PtsData.CLKFrequency;

         // We need to have a minimum timeout anyway
         if(ReaderExtension->ReadTimeout <50)
         {
            ReaderExtension->ReadTimeout =50; // 50 ms minimum timeout
         }
      }

      // indicate that the card is in specific mode
      SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;

      // return the selected protocol to the caller
      *(PULONG) SmartcardExtension->IoRequest.ReplyBuffer = SmartcardExtension->CardCapabilities.Protocol.Selected;
      *SmartcardExtension->IoRequest.Information = sizeof(SmartcardExtension->CardCapabilities.Protocol.Selected);
   }
   else
   {
      SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
      *(PULONG) SmartcardExtension->IoRequest.ReplyBuffer = 0;
      *SmartcardExtension->IoRequest.Information = 0;
   }

   SmartcardDebug( DEBUG_TRACE, ("%d!CBSetProtocol: Exit %X\n",DRIVER_NAME, NTStatus ));

   return( NTStatus );
}
NTSTATUS
CBGenericIOCTL(
   PSMARTCARD_EXTENSION SmartcardExtension)
/*++

Description:
   Performs generic callbacks to the reader

Arguments:
   SmartcardExtension   context of the call

Return Value:
   STATUS_SUCCESS

--*/
{
   NTSTATUS          NTStatus;
   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!CBGenericIOCTL: Enter\n",
      DRIVER_NAME));

   //
   // get pointer to current IRP stack location
   //
   //
   // assume error
   //
   NTStatus = STATUS_INVALID_DEVICE_REQUEST;


   //
   // dispatch IOCTL
   //
   switch( SmartcardExtension->MajorIoControlCode )
   {



      case IOCTL_WRITE_STC_REGISTER:


         NTStatus = IFWriteSTCRegister(
            SmartcardExtension->ReaderExtension,
            *(SmartcardExtension->IoRequest.RequestBuffer),             // Address
            (ULONG)(*(SmartcardExtension->IoRequest.RequestBuffer + 1)),   // Size
            SmartcardExtension->IoRequest.RequestBuffer + 2);           // Data

         *SmartcardExtension->IoRequest.Information = 1;
         if(NTStatus == STATUS_SUCCESS)
         {
            *(SmartcardExtension->IoRequest.ReplyBuffer) = 0;
         }
         else
         {
            *(SmartcardExtension->IoRequest.ReplyBuffer) = 1;
         }

         break;

      case IOCTL_READ_STC_REGISTER:

         NTStatus = IFReadSTCRegister(
            SmartcardExtension->ReaderExtension,
            *(SmartcardExtension->IoRequest.RequestBuffer),             // Address
            (ULONG)(*(SmartcardExtension->IoRequest.RequestBuffer + 1)),   // Size
            SmartcardExtension->IoRequest.ReplyBuffer);                 // Data

         if(NTStatus ==STATUS_SUCCESS)
         {
            *SmartcardExtension->IoRequest.Information =
               (ULONG)(*(SmartcardExtension->IoRequest.RequestBuffer + 1));
         }
         else
         {
            SmartcardExtension->IoRequest.Information = 0;
         }

         break;



      case IOCTL_WRITE_STC_DATA:


         NTStatus = IFWriteSTCData(
            SmartcardExtension->ReaderExtension,
            SmartcardExtension->IoRequest.RequestBuffer + 1,            // Data
            (ULONG)(*(SmartcardExtension->IoRequest.RequestBuffer)));      // Size

         *SmartcardExtension->IoRequest.Information = 1;
         if(NTStatus == STATUS_SUCCESS)
         {
            *(SmartcardExtension->IoRequest.ReplyBuffer) = 0;
         }
         else
         {
            *(SmartcardExtension->IoRequest.ReplyBuffer) = 1;
         }

         break;

      case IOCTL_READ_STC_DATA:

         NTStatus = IFReadSTCData(
            SmartcardExtension->ReaderExtension,
            SmartcardExtension->IoRequest.ReplyBuffer,                  // Data
            (ULONG)(*(SmartcardExtension->IoRequest.RequestBuffer)));      // Size

         if(NTStatus ==STATUS_SUCCESS)
         {
            *SmartcardExtension->IoRequest.Information =
               (ULONG)(*(SmartcardExtension->IoRequest.RequestBuffer));
         }
         else
         {
            SmartcardExtension->IoRequest.Information = 0;
         }

         break;

      default:
         break;
   }


   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!CBGenericIOCTL: Exit\n",
      DRIVER_NAME));

   return( NTStatus );
}



NTSTATUS
CBTransmit(
   PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

CBTransmit:
   callback handler for SMCLIB RDF_TRANSMIT

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_SUCCESS
   STATUS_NO_MEDIA
   STATUS_TIMEOUT
   STATUS_INVALID_DEVICE_REQUEST

--*/
{
   NTSTATUS  NTStatus = STATUS_SUCCESS;

   SmartcardDebug( DEBUG_TRACE, ("%s!CBTransmit Enter\n",DRIVER_NAME ));

   // dispatch on the selected protocol
   switch( SmartcardExtension->CardCapabilities.Protocol.Selected )
   {
      case SCARD_PROTOCOL_T0:
         NTStatus = CBT0Transmit( SmartcardExtension );
         break;

      case SCARD_PROTOCOL_T1:
         NTStatus = CBT1Transmit( SmartcardExtension );
         break;

      case SCARD_PROTOCOL_RAW:
         NTStatus = CBRawTransmit( SmartcardExtension );
         break;

      default:
         NTStatus = STATUS_INVALID_DEVICE_REQUEST;
         break;
   }

   SmartcardDebug( DEBUG_TRACE, ("%s!CBTransmit Exit: %X\n",DRIVER_NAME, NTStatus ));

   return( NTStatus );
}



NTSTATUS
T0_ExchangeData(
   PREADER_EXTENSION ReaderExtension,
   PUCHAR            pRequest,
   ULONG          RequestLen,
   PUCHAR            pReply,
   PULONG            pReplyLen)
/*++

Routine Description:
   T=0 management

Arguments:
   ReaderExtension   Context of the call
   pRequest    Request buffer
   RequestLen     Request buffer length
   pReply         Reply buffer
   pReplyLen      Reply buffer length


Return Value:
   STATUS_SUCCESS
   Status returned by IFReadSTCData or IFWriteSTCData

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   BOOLEAN     Direction;
   UCHAR    Ins,
            Pcb = 0;
   ULONG    Len,
            DataIdx;

   // get direction
   Ins = pRequest[ INS_IDX ] & 0xFE;
   Len   = pRequest[ P3_IDX ];

   if( RequestLen == 5 )
   {
      Direction   = ISO_OUT;
      DataIdx     = 0;
      // For an ISO OUT command Len=0 means that the host expect an
      // 256 byte answer
      if( !Len )
      {
         Len = 0x100;
      }
      // Add 2 for SW1 SW2
      Len+=2;
   }
   else
   {
      Direction   = ISO_IN;
      DataIdx     = 5;
   }

   // send header CLASS,INS,P1,P2,P3
   NTStatus = IFWriteSTCData( ReaderExtension, pRequest, 5 );

   if( NTStatus == STATUS_SUCCESS )
   {
      NTStatus = STATUS_MORE_PROCESSING_REQUIRED;
   }

   while( NTStatus == STATUS_MORE_PROCESSING_REQUIRED )
   {
      // PCB reading
      NTStatus = IFReadSTCData( ReaderExtension, &Pcb, 1 );

      if( NTStatus == STATUS_SUCCESS )
      {
         if( Pcb == 0x60 )
         {
            // null byte?
            NTStatus = STATUS_MORE_PROCESSING_REQUIRED;
            continue;
         }
         else if( ( Pcb & 0xFE ) == Ins )
         {
            // transfer all
            if( Direction == ISO_IN )
            {
               // write remaining data
               NTStatus = IFWriteSTCData( ReaderExtension, pRequest + DataIdx, Len );
               if( NTStatus == STATUS_SUCCESS )
               {
                  // if all data successful written the status word is expected
                  NTStatus = STATUS_MORE_PROCESSING_REQUIRED;
                  Direction   = ISO_OUT;
                  DataIdx     = 0;
                  Len         = 2;
               }
            }
            else
            {
               // read remaining data
               NTStatus = IFReadSTCData( ReaderExtension, pReply + DataIdx, Len );

               DataIdx += Len;
            }
         }
         else if( (( Pcb & 0xFE ) ^ Ins ) == 0xFE )
         {
            // transfer next
            if( Direction == ISO_IN )
            {
               // write next

               NTStatus = IFWriteSTCData( ReaderExtension, pRequest + DataIdx, 1 );

               if( NTStatus == STATUS_SUCCESS )
               {
                  DataIdx++;

                  // if all data successful written the status word is expected
                  if( --Len == 0 )
                  {
                     Direction   = ISO_OUT;
                     DataIdx     = 0;
                     Len         = 2;
                  }
                  NTStatus = STATUS_MORE_PROCESSING_REQUIRED;
               }
            }
            else
            {
               // read next
               NTStatus = IFReadSTCData( ReaderExtension, pReply + DataIdx, 1 );


               if( NTStatus == STATUS_SUCCESS )
               {
                  NTStatus = STATUS_MORE_PROCESSING_REQUIRED;
                  Len--;
                  DataIdx++;
               }
            }
         }
         else if( (( Pcb & 0x60 ) == 0x60 ) || (( Pcb & 0x90 ) == 0x90 ) )
         {
            if( Direction == ISO_IN )
            {
               Direction   = ISO_OUT;
               DataIdx     = 0;
            }

            // SW1
            *pReply  = Pcb;

            // read SW2 and leave

            NTStatus = IFReadSTCData( ReaderExtension, &Pcb, 1 );

            *(pReply + 1)  = Pcb;
            DataIdx        += 2;
         }
         else
         {
            NTStatus = STATUS_UNSUCCESSFUL;
         }
      }
   }

   if(( NTStatus == STATUS_SUCCESS ) && ( pReplyLen != NULL ))
   {
      *pReplyLen = DataIdx;
   }

   return( NTStatus );
}


NTSTATUS
CBT0Transmit(
   PSMARTCARD_EXTENSION SmartcardExtension)
/*++

CBT0Transmit:
   finishes the callback RDF_TRANSMIT for the T0 protocol

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_SUCCESS
   STATUS_NO_MEDIA
   STATUS_TIMEOUT
   STATUS_INVALID_DEVICE_REQUEST

--*/
{
    NTSTATUS            NTStatus = STATUS_SUCCESS;

   SmartcardDebug( DEBUG_TRACE, ("%s!CBT0Transmit Enter\n",DRIVER_NAME ));

   SmartcardExtension->SmartcardRequest.BufferLength = 0;

   // let the lib setup the T=1 APDU & check for errors
   NTStatus = SmartcardT0Request( SmartcardExtension );

   if( NTStatus == STATUS_SUCCESS )
   {
      NTStatus = T0_ExchangeData(
         SmartcardExtension->ReaderExtension,
         SmartcardExtension->SmartcardRequest.Buffer,
         SmartcardExtension->SmartcardRequest.BufferLength,
         SmartcardExtension->SmartcardReply.Buffer,
         &SmartcardExtension->SmartcardReply.BufferLength);

      if( NTStatus == STATUS_SUCCESS )
      {
         // let the lib evaluate the result & tansfer the data
         NTStatus = SmartcardT0Reply( SmartcardExtension );
      }
   }

   SmartcardDebug( DEBUG_TRACE,("%s!CBT0Transmit Exit: %X\n",DRIVER_NAME, NTStatus ));

    return( NTStatus );
}





NTSTATUS
CBT1Transmit(
   PSMARTCARD_EXTENSION SmartcardExtension)
/*++

CBT1Transmit:
   finishes the callback RDF_TRANSMIT for the T1 protocol

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_SUCCESS
   STATUS_NO_MEDIA
   STATUS_TIMEOUT
   STATUS_INVALID_DEVICE_REQUEST

--*/
{
    NTSTATUS   NTStatus = STATUS_SUCCESS;

   SmartcardDebug( DEBUG_TRACE, ("%s!CBT1Transmit Enter\n",DRIVER_NAME ));

   // smclib workaround
   *(PULONG)&SmartcardExtension->IoRequest.ReplyBuffer[0] = 0x02;
   *(PULONG)&SmartcardExtension->IoRequest.ReplyBuffer[4] = sizeof( SCARD_IO_REQUEST );

   // use the lib support to construct the T=1 packets
   do {
      // no header for the T=1 protocol
      SmartcardExtension->SmartcardRequest.BufferLength = 0;

      SmartcardExtension->T1.NAD = 0;

      // let the lib setup the T=1 APDU & check for errors
      NTStatus = SmartcardT1Request( SmartcardExtension );
      if( NTStatus == STATUS_SUCCESS )
      {
         // send command (don't calculate LRC because CRC may be used!)
         NTStatus = IFWriteSTCData(
            SmartcardExtension->ReaderExtension,
            SmartcardExtension->SmartcardRequest.Buffer,
            SmartcardExtension->SmartcardRequest.BufferLength);

         // extend read timeout if the card issued a WTX request
         if (SmartcardExtension->T1.Wtx)
         {
            SmartcardExtension->ReaderExtension->ReadTimeout = 
               ( SmartcardExtension->T1.Wtx * 
               SmartcardExtension->CardCapabilities.T1.BWT + 999L )/
               1000L;
         }
         else
         {
            // restore timeout
            SmartcardExtension->ReaderExtension->ReadTimeout = 
               (ULONG) (SmartcardExtension->CardCapabilities.T1.BWT  / 1000);
         }

         // get response
         SmartcardExtension->SmartcardReply.BufferLength = 0;

         if( NTStatus == STATUS_SUCCESS )
         {
            NTStatus = IFReadSTCData(
               SmartcardExtension->ReaderExtension,
               SmartcardExtension->SmartcardReply.Buffer,
               3);

            if( NTStatus == STATUS_SUCCESS )
            {
               ULONG Length;

               Length = (ULONG)SmartcardExtension->SmartcardReply.Buffer[ LEN_IDX ] + 1;

               if( Length + 3 < MIN_BUFFER_SIZE )
               {
                  NTStatus = IFReadSTCData(
                     SmartcardExtension->ReaderExtension,
                     &SmartcardExtension->SmartcardReply.Buffer[ DATA_IDX ],
                     Length);

                  SmartcardExtension->SmartcardReply.BufferLength = Length + 3;
               }
               else
               {
                  NTStatus = STATUS_BUFFER_TOO_SMALL;
               }
            }
            //
            // if STCRead detects an LRC error, ignore it (maybe CRC used). Timeouts will
            // be detected by the lib if len=0
            //
            if(( NTStatus == STATUS_CRC_ERROR ) || ( NTStatus == STATUS_IO_TIMEOUT ))
            {
               NTStatus = STATUS_SUCCESS;
            }

            if( NTStatus == STATUS_SUCCESS )
            {
               // let the lib evaluate the result & setup the next APDU
               NTStatus = SmartcardT1Reply( SmartcardExtension );
            }
         }
      }

   // continue if the lib wants to send the next packet
   } while( NTStatus == STATUS_MORE_PROCESSING_REQUIRED );

   if( NTStatus == STATUS_IO_TIMEOUT )
   {
      NTStatus = STATUS_DEVICE_PROTOCOL_ERROR;
   }

   SmartcardDebug( DEBUG_TRACE,( "%s!CBT1Transmit Exit: %X\n",DRIVER_NAME, NTStatus ));

   return ( NTStatus );
}

NTSTATUS
CBRawTransmit(
   PSMARTCARD_EXTENSION SmartcardExtension)
/*++

CBRawTransmit:
   finishes the callback RDF_TRANSMIT for the RAW protocol

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_UNSUCCESSFUL

--*/
{
    NTSTATUS         NTStatus = STATUS_UNSUCCESSFUL;

   SmartcardDebug( DEBUG_TRACE, ("%s!CBRawTransmit Exit: %X\n",DRIVER_NAME, NTStatus ));
   return ( NTStatus );
}


NTSTATUS
CBCardTracking(
   PSMARTCARD_EXTENSION SmartcardExtension)
/*++

CBCardTracking:
   callback handler for SMCLIB RDF_CARD_TRACKING. the requested event was
   validated by the smclib (i.e. a card removal request will only be passed
   if a card is present).
   for a win95 build STATUS_PENDING will be returned without any other action.
   for NT the cancel routine for the irp will be set to the drivers cancel
   routine.

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_PENDING

--*/
{
   KIRQL CurrentIrql;

   SmartcardDebug(
      DEBUG_TRACE,
      ("%s!CBCardTracking Enter\n",
      DRIVER_NAME));

   // set cancel routine
   IoAcquireCancelSpinLock( &CurrentIrql );

   IoSetCancelRoutine(
      SmartcardExtension->OsData->NotificationIrp,
      StcUsbCancel);

   IoReleaseCancelSpinLock( CurrentIrql );

   SmartcardDebug(
      DEBUG_TRACE,
      ("%s!CBCardTracking Exit\n",
      DRIVER_NAME));

   return( STATUS_PENDING );

}


NTSTATUS
CBUpdateCardState(
   PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

CBUpdateCardState:
   updates the variable CurrentState in SmartcardExtension

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_SUCCESS

--*/
{
   NTSTATUS status = STATUS_SUCCESS;
   UCHAR    cardStatus = 0;
   KIRQL    irql;
   BOOLEAN     stateChanged = FALSE;
   ULONG    oldState;

   // read card state
   status = IFReadSTCRegister(
      SmartcardExtension->ReaderExtension,
      ADR_IO_CONFIG,
      1,
      &cardStatus
      );

   oldState = SmartcardExtension->ReaderCapabilities.CurrentState;

   switch(status)
   {
      case STATUS_NO_MEDIA:
         SmartcardExtension->ReaderExtension->ErrorCounter = 0;
         SmartcardExtension->ReaderCapabilities.CurrentState =
            SCARD_ABSENT;
         break;

      case STATUS_MEDIA_CHANGED:
         SmartcardExtension->ReaderExtension->ErrorCounter = 0;
         SmartcardExtension->ReaderCapabilities.CurrentState =
            SCARD_PRESENT;
         break;

      case STATUS_SUCCESS:
         SmartcardExtension->ReaderExtension->ErrorCounter = 0;
         cardStatus &= M_SD;
         if( cardStatus == 0 )
         {
            SmartcardExtension->ReaderCapabilities.CurrentState =
               SCARD_ABSENT;
         }
         else if( SmartcardExtension->ReaderCapabilities.CurrentState <=
            SCARD_ABSENT )
         {
            SmartcardExtension->ReaderCapabilities.CurrentState =
               SCARD_PRESENT;
         }
         break;

      default:
         if( ++SmartcardExtension->ReaderExtension->ErrorCounter < ERROR_COUNTER_TRESHOLD )
         {
             // a unknown status was reported from the reader, so use the previous state
             SmartcardExtension->ReaderCapabilities.CurrentState = oldState;
         }
         else
         {
              SmartcardLogError(
                 SmartcardExtension->OsData->DeviceObject,
                 STATUS_DEVICE_DATA_ERROR,
                 NULL,
                 0);

             // a report of SCARD_UNKNOWN will force the resource manager to 
             // disconnect the reader
             SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_UNKNOWN;
         }
         break;
   }
   //
   // we need to update the card state if there was a card before hibernate
   // stand / by or when the current state has changed.
   //
   if (SmartcardExtension->ReaderExtension->CardPresent ||
      oldState <= SCARD_ABSENT &&
      SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT ||
      oldState > SCARD_ABSENT &&
      SmartcardExtension->ReaderCapabilities.CurrentState <= SCARD_ABSENT) {

        stateChanged = TRUE;
      SmartcardExtension->ReaderExtension->CardPresent = FALSE;
    }

   KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock, &irql);
   if(stateChanged && SmartcardExtension->OsData->NotificationIrp != NULL)
   {
      KIRQL CurrentIrql;
      PIRP pIrp;

      IoAcquireCancelSpinLock( &CurrentIrql );
      IoSetCancelRoutine( SmartcardExtension->OsData->NotificationIrp, NULL );
      IoReleaseCancelSpinLock( CurrentIrql );

      SmartcardExtension->OsData->NotificationIrp->IoStatus.Status =
            STATUS_SUCCESS;
      SmartcardExtension->OsData->NotificationIrp->IoStatus.Information = 0;

      SmartcardDebug(
         DEBUG_DRIVER,
         ("%s!CBUpdateCardState: Completing notification irp %lx\n",
         DRIVER_NAME,
         SmartcardExtension->OsData->NotificationIrp));

      pIrp = SmartcardExtension->OsData->NotificationIrp;
      SmartcardExtension->OsData->NotificationIrp = NULL;

     KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock, irql);

      IoCompleteRequest(pIrp, IO_NO_INCREMENT);

   } else {
     KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock, irql);
   }

   return status;
}

NTSTATUS
CBSynchronizeSTC(
   PSMARTCARD_EXTENSION SmartcardExtension )
/*++

CBSynchronizeSTC:
   updates the card dependend data of the stc (wait times, ETU...)

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_SUCCESS

--*/

{
   NTSTATUS          NTStatus = STATUS_SUCCESS;
   PREADER_EXTENSION    ReaderExtension;
   ULONG             CWT,
                     BWT,
                     CGT,
                     ETU;
   UCHAR             Dl,
                     Fl,
                     N;

   PCLOCK_RATE_CONVERSION  ClockRateConversion;
   PBIT_RATE_ADJUSTMENT BitRateAdjustment;

   ReaderExtension      = SmartcardExtension->ReaderExtension;
   ClockRateConversion  = SmartcardExtension->CardCapabilities.ClockRateConversion;
   BitRateAdjustment = SmartcardExtension->CardCapabilities.BitRateAdjustment;

   // cycle length
   Dl = SmartcardExtension->CardCapabilities.Dl;
   Fl = SmartcardExtension->CardCapabilities.Fl;

   ETU = ClockRateConversion[Fl & 0x0F].F;

   ETU /= BitRateAdjustment[ Dl & 0x0F ].DNumerator;
   ETU *= BitRateAdjustment[ Dl & 0x0F ].DDivisor;

   // ETU += (ETU % 2 == 0) ? 0 : 1;

   // a extra guard time of 0xFF means minimum delay in both directions
   N = SmartcardExtension->CardCapabilities.N;
   if( N == 0xFF )
   {
      N = 0;
   }

   // set character waiting & guard time
   switch ( SmartcardExtension->CardCapabilities.Protocol.Selected )
   {
      case SCARD_PROTOCOL_T0:
         CWT = 960 * SmartcardExtension->CardCapabilities.T0.WI;
         CGT = 14 + N;  // 13 + N;     cryptoflex error
         break;

      case SCARD_PROTOCOL_T1:
         CWT = 11 + ( 0x01 << SmartcardExtension->CardCapabilities.T1.CWI );
         BWT = 11 + ( 0x01 << SmartcardExtension->CardCapabilities.T1.BWI ) * 960;
         CGT = 15 + N ;//13 + N; // 12 + N;     sicrypt error

         NTStatus = STCSetBWT( ReaderExtension, BWT * ETU );

         break;

      default:
         // restore default CGT
         CGT=13;
         STCSetCGT( ReaderExtension, CGT);
         NTStatus = STATUS_UNSUCCESSFUL;
         break;
   }

   if(( NTStatus == STATUS_SUCCESS ) && ETU )
   {
      NTStatus = STCSetETU( ReaderExtension, ETU );

      if( NTStatus == STATUS_SUCCESS )
      {
         NTStatus = STCSetCGT( ReaderExtension, CGT );

         if( NTStatus == STATUS_SUCCESS )
         {
            NTStatus = STCSetCWT( ReaderExtension, CWT * ETU );
         }
      }
   }
   return( NTStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\stcusb\stccmd.c ===
/*++

Copyright (c) 1997 SCM Microsystems, Inc.

Module Name:

    StcCmd.c

Abstract:

   Basic command functions for STC smartcard reader


Environment:



Revision History:

   PP       01.19.1999  1.01  Modification for PC/SC
   YL                1.00  Initial Version

--*/

#include "common.h"
#include "StcCmd.h"
#include "usbcom.h"
#include "stcusbnt.h"


const STC_REGISTER STCInitialize[] =
{
   { ADR_SC_CONTROL,    0x01, 0x00     },    // reset
   { ADR_CLOCK_CONTROL, 0x01, 0x01     },
   { ADR_CLOCK_CONTROL, 0x01, 0x03     },
   { ADR_UART_CONTROL,     0x01, 0x27     },
   { ADR_UART_CONTROL,     0x01, 0x4F     },
   { ADR_IO_CONFIG,     0x01, 0x02     },    // 0x10 eva board
   { ADR_FIFO_CONFIG,      0x01, 0x81     },
   { ADR_INT_CONTROL,      0x01, 0x11     },
   { 0x0E,              0x01, 0xC0     },
   { 0x00,              0x00, 0x00     },
};

const STC_REGISTER STCClose[] =
{
   { ADR_INT_CONTROL,      0x01, 0x00     },
   { ADR_SC_CONTROL,    0x01, 0x00     },    // reset
   { ADR_UART_CONTROL,     0x01, 0x40     },
   { ADR_CLOCK_CONTROL, 0x01, 0x01     },
   { ADR_CLOCK_CONTROL, 0x01, 0x00     },
   { 0x00,              0x00, 0x00     },
};





NTSTATUS
STCResetInterface(
   PREADER_EXTENSION ReaderExtension)
/*++
Description:

Arguments:
   ReaderExtension      context of call

Return Value:

--*/
{
   NTSTATUS NtStatus = STATUS_SUCCESS;
   DWORD dwETU;

   dwETU = 0x7401 | 0x0080;
   NtStatus=IFWriteSTCRegister(
      ReaderExtension,
      ADR_ETULENGTH15,
      2,
      (UCHAR *)&dwETU);

   return(NtStatus);
}

NTSTATUS
STCReset(
   PREADER_EXTENSION ReaderExtension,
   UCHAR          Device,
   BOOLEAN           WarmReset,
   PUCHAR            pATR,
   PULONG            pATRLength)
/*++
Description:
   performs a reset of ICC

Arguments:
   ReaderExtension      context of call
   Device            device requested
   WarmReset         kind of ICC reset
   pATR           ptr to ATR buffer, NULL if no ATR required
   pATRLength        size of ATR buffer / length of ATR

Return Value:
   STATUS_SUCCESS
   STATUS_NO_MEDIA
   STATUS_UNRECOGNIZED_MEDIA
   error values from IFRead / IFWrite

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;

   // set UART to autolearn mode
   NTStatus = STCInitUART( ReaderExtension, TRUE );


   if( NTStatus == STATUS_SUCCESS)
   {
      //
      // set default frequency for ATR
      //
      NTStatus = STCSetFDIV( ReaderExtension, FREQ_DIV );

      if( NTStatus == STATUS_SUCCESS && ( !WarmReset ))
      {
         //
         // deactivate contacts
         //
         NTStatus = STCPowerOff( ReaderExtension );
      }

      //
      // set power to card
      //
      if( NTStatus == STATUS_SUCCESS)
      {
         NTStatus = STCPowerOn( ReaderExtension );

         if( NTStatus == STATUS_SUCCESS)
         {
            NTStatus = STCReadATR( ReaderExtension, pATR, pATRLength );
         }
      }
   }

   if( NTStatus != STATUS_SUCCESS )
   {
      STCPowerOff( ReaderExtension );
   }
   return( NTStatus );
}

NTSTATUS
STCReadATR(
   PREADER_EXTENSION ReaderExtension,
   PUCHAR            pATR,
   PULONG            pATRLen)
/*++
Description:
   Read and analize the ATR

Arguments:
   ReaderExtension      context of call
   pATR           ptr to ATR buffer,
   pATRLen           size of ATR buffer / length of ATR

Return Value:

--*/

{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR    T0_Yx,
            T0_K,          // number of historical bytes
            Protocol;
   ULONG    ATRLen;
   //
   // set read timeout for ATR
   //
   ReaderExtension->ReadTimeout = 250; // only 250ms for this firs ATR
   //
   // read TS if active low reset
   //
   NTStatus = IFReadSTCData( ReaderExtension, pATR, 1 );

   if( NTStatus == STATUS_IO_TIMEOUT )
   {
      ReaderExtension->ReadTimeout = 2500;
      NTStatus = STCSetRST( ReaderExtension, TRUE );

      if( NTStatus == STATUS_SUCCESS )
      {
         NTStatus = IFReadSTCData( ReaderExtension, pATR, 1 );
      }
   }


   Protocol = PROTOCOL_TO;
   ATRLen      = 1;

   if( NTStatus == STATUS_SUCCESS )
   {
      // T0
      NTStatus = IFReadSTCData( ReaderExtension, pATR + ATRLen, 1 );
      ATRLen++;

      /* Convention management */
      if ( pATR[0] == 0x03 )     /* Direct convention */
      {
         pATR[0] = 0x3F;
      }

      if ( ( pATR[0] != 0x3F ) && ( pATR[0] != 0x3B ) )
      {
         NTStatus = STATUS_DATA_ERROR;
      }

      if( NTStatus == STATUS_SUCCESS )
      {
         ULONG Request;

         // number of historical bytes
         T0_K = (UCHAR) ( pATR[ATRLen-1] & 0x0F );

         // coding of TA, TB, TC, TD
         T0_Yx = (UCHAR) ( pATR[ATRLen-1] & 0xF0 ) >> 4;

         while(( NTStatus == STATUS_SUCCESS ) && T0_Yx )
         {
            UCHAR Mask;

            // evaluate presence of TA, TB, TC, TD
            Mask  = T0_Yx;
            Request  = 0;
            while( Mask )
            {
               if( Mask & 1 )
               {
                  Request++;
               }
               Mask >>= 1;
            }
            NTStatus = IFReadSTCData( ReaderExtension, pATR + ATRLen, Request );
            ATRLen += Request;

            if( T0_Yx & TDx )
            {
               // high nibble of TD codes the next set of TA, TB, TC, TD
               T0_Yx = ( pATR[ATRLen-1] & 0xF0 ) >> 4;
               // low nibble of TD codes the protocol
               Protocol = pATR[ATRLen-1] & 0x0F;
            }
            else
            {
               break;
            }
         }

         if( NTStatus == STATUS_SUCCESS )
         {
            // historical bytes
            NTStatus = IFReadSTCData( ReaderExtension, pATR + ATRLen, T0_K );

            // check sum
            if( NTStatus == STATUS_SUCCESS )
            {
               ATRLen += T0_K;

               if( Protocol >= PROTOCOL_T1 )
               {
                  NTStatus = IFReadSTCData( ReaderExtension, pATR + ATRLen, 1 );
                  if( NTStatus == STATUS_SUCCESS )
                  {
                     ATRLen++;
                  }
                  else if( NTStatus == STATUS_IO_TIMEOUT )
                  {
                     // some cards don't support the TCK
                     NTStatus = STATUS_SUCCESS;
                  }
               }
            }
         }
      }
   }

   if( NTStatus == STATUS_IO_TIMEOUT )
   {
      NTStatus = STATUS_UNRECOGNIZED_MEDIA;
   }

   if(( NTStatus == STATUS_SUCCESS ) && ( pATRLen != NULL ))
   {
      *pATRLen = ATRLen;
   }
   return( NTStatus );
}


NTSTATUS
STCPowerOff(
   PREADER_EXTENSION ReaderExtension )
/*++
Description:
   Deactivates the requested device

Arguments:
   ReaderExtension      context of call

Return Value:
   STATUS_SUCCESS
   error values from IFRead / IFWrite

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR    SCCtrl;

   // clear SIM
   SCCtrl=0x11;
   NTStatus=IFWriteSTCRegister(
      ReaderExtension,
      ADR_INT_CONTROL,
      1,
      &SCCtrl);

   SCCtrl = 0x00;
   NTStatus = IFWriteSTCRegister( ReaderExtension, ADR_SC_CONTROL, 1, &SCCtrl );

   return( NTStatus );
}

NTSTATUS
STCPowerOn(
   PREADER_EXTENSION ReaderExtension )
/*++
Description:
   Deactivates the requested device

Arguments:
   ReaderExtension      context of call

Return Value:
   STATUS_SUCCESS
   error values from IFRead / IFWrite

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR    SCCtrl,Byte;

   Byte = 0x02;
   NTStatus = IFWriteSTCRegister(
      ReaderExtension,
      ADR_IO_CONFIG,
      1,
      &Byte
      );

   SCCtrl = 0x40;       // vcc
   NTStatus = IFWriteSTCRegister( ReaderExtension, ADR_SC_CONTROL, 1, &SCCtrl );

   if( NTStatus == STATUS_SUCCESS )
   {
      SCCtrl = 0x41;    // vpp
      NTStatus = IFWriteSTCRegister(
         ReaderExtension,
         ADR_SC_CONTROL,
         1,
         &SCCtrl
         );


      // set SIM
      SCCtrl = 0x13;
      NTStatus=IFWriteSTCRegister(
         ReaderExtension,
         ADR_INT_CONTROL,
         1,
         &SCCtrl);

      if( NTStatus == STATUS_SUCCESS )
      {
         SCCtrl = 0xD1; //  vcc, clk, io
         NTStatus = IFWriteSTCRegister(
            ReaderExtension,
            ADR_SC_CONTROL,
            1,
            &SCCtrl
            );
      }
   }
   return( NTStatus );
}


NTSTATUS
STCSetRST(
   PREADER_EXTENSION ReaderExtension,
   BOOLEAN           On)
/*++
Description:

Arguments:
   ReaderExtension      context of call

Return Value:
   STATUS_SUCCESS
   error values from IFRead / IFWrite

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR    SCCtrl = 0;

   NTStatus = IFReadSTCRegister( ReaderExtension, ADR_SC_CONTROL, 1,&SCCtrl );
   if( NTStatus == STATUS_SUCCESS )
   {
      if( On )
      {
         SCCtrl |= 0x20;
      }
      else
      {
         SCCtrl &= ~0x20;
      }

      NTStatus = IFWriteSTCRegister(
         ReaderExtension,
         ADR_SC_CONTROL,
         1,
         &SCCtrl
         );
   }
   return(NTStatus);
}


NTSTATUS
STCConfigureSTC(
   PREADER_EXTENSION ReaderExtension,
   PSTC_REGISTER     pConfiguration
   )
{
   NTSTATUS       NTStatus = STATUS_SUCCESS;
   UCHAR          Value;

   do
   {
      if( pConfiguration->Register == ADR_INT_CONTROL )
      {
         // Read interrupt status register to acknoledge wrong states
         NTStatus = IFReadSTCRegister(
            ReaderExtension,
            ADR_INT_STATUS,
            1,
            &Value
            );
      }

      Value = (UCHAR) pConfiguration->Value;
      NTStatus = IFWriteSTCRegister(
         ReaderExtension,
         pConfiguration->Register,
         pConfiguration->Size,
         (PUCHAR)&pConfiguration->Value
         );

      if (NTStatus == STATUS_NO_MEDIA)
      {
         // ignore that no card is in the reader
         NTStatus = STATUS_SUCCESS;
      }

      // delay to stabilize the oscilator clock:
      if( pConfiguration->Register == ADR_CLOCK_CONTROL )
      {
         SysDelay( 100 );
      }
      pConfiguration++;

   } while(NTStatus == STATUS_SUCCESS && pConfiguration->Size);

   return NTStatus;
}


NTSTATUS
STCSetETU(
   PREADER_EXTENSION ReaderExtension,
   ULONG          NewETU)
/*++
Description:

Arguments:
   ReaderExtension      context of call

Return Value:
   STATUS_SUCCESS
   error values from IFRead / IFWrite

--*/
{
   NTSTATUS NTStatus = STATUS_DATA_ERROR;
   UCHAR    ETU[2];

   SmartcardDebug(
      DEBUG_TRACE,
      ("%s!STCSetETU   %d\n",
      DRIVER_NAME,
      NewETU));

   if( NewETU < 0x0FFF )
   {
      NTStatus = IFReadSTCRegister(
         ReaderExtension,
         ADR_ETULENGTH15,
         2,
         ETU);

      if( NTStatus == STATUS_SUCCESS )
      {
         //
         // save all RFU bits
         //
         ETU[1]   = (UCHAR) NewETU;
         ETU[0]   = (UCHAR)(( ETU[0] & 0xF0 ) | ( NewETU >> 8 ));

         NTStatus = IFWriteSTCRegister(
            ReaderExtension,
            ADR_ETULENGTH15,
            2,
            ETU);
      }
   }
   return(NTStatus);
}

NTSTATUS
STCSetCGT(
   PREADER_EXTENSION ReaderExtension,
   ULONG          NewCGT)
/*++
Description:

Arguments:
   ReaderExtension      context of call

Return Value:
   STATUS_SUCCESS
   error values from IFRead / IFWrite

--*/

{
   NTSTATUS NTStatus = STATUS_DATA_ERROR;
   UCHAR    CGT[2];

   SmartcardDebug(
      DEBUG_TRACE,
      ("%s!STCSetCGT   %d\n",
      DRIVER_NAME,
      NewCGT));

   if( NewCGT < 0x01FF )
   {
      NTStatus = IFReadSTCRegister(
         ReaderExtension,
         ADR_CGT8,
         2,
         CGT);

      if( NTStatus == STATUS_SUCCESS )
      {
         //
         // save all RFU bits
         //
         CGT[1] = ( UCHAR )NewCGT;
         CGT[0] = (UCHAR)(( CGT[0] & 0xFE ) | ( NewCGT >> 8 ));

         NTStatus = IFWriteSTCRegister(
            ReaderExtension,
            ADR_CGT8,
            2,
            CGT);
      }
   }
   return(NTStatus);
}

NTSTATUS
STCSetCWT(
   PREADER_EXTENSION ReaderExtension,
   ULONG          NewCWT)
/*++
Description:

Arguments:
   ReaderExtension      context of call

Return Value:
   STATUS_SUCCESS
   error values from IFRead / IFWrite

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR    CWT[4];


   SmartcardDebug(
      DEBUG_TRACE,
      ("%s!STCSetCWT   %d\n",
      DRIVER_NAME,
      NewCWT));
   // little indians...
   CWT[0] = (( PUCHAR )&NewCWT )[3];
   CWT[1] = (( PUCHAR )&NewCWT )[2];
   CWT[2] = (( PUCHAR )&NewCWT )[1];
   CWT[3] = (( PUCHAR )&NewCWT )[0];

   NTStatus = IFWriteSTCRegister(
      ReaderExtension,
      ADR_CWT31,
      4,
      CWT );
   return(NTStatus);
}

NTSTATUS
STCSetBWT(
   PREADER_EXTENSION ReaderExtension,
   ULONG          NewBWT)
/*++
Description:

Arguments:
   ReaderExtension      context of call

Return Value:
   STATUS_SUCCESS
   error values from IFRead / IFWrite

--*/
{
   NTSTATUS    NTStatus = STATUS_SUCCESS;
   UCHAR    BWT[4];

   SmartcardDebug(
      DEBUG_TRACE,
      ("%s!STCSetBWT   %d\n",
      DRIVER_NAME,
      NewBWT));

   // little indians...
   BWT[0] = (( PUCHAR )&NewBWT )[3];
   BWT[1] = (( PUCHAR )&NewBWT )[2];
   BWT[2] = (( PUCHAR )&NewBWT )[1];
   BWT[3] = (( PUCHAR )&NewBWT )[0];

   NTStatus = IFWriteSTCRegister(
      ReaderExtension,
      ADR_BWT31,
      4,
      BWT );

   return(NTStatus);
}


NTSTATUS
STCSetFDIV(
   PREADER_EXTENSION ReaderExtension,
   ULONG          Factor)
/*++
Description:

Arguments:
   ReaderExtension      context of call

Return Value:
   STATUS_SUCCESS
   error values from IFRead / IFWrite

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR    DIV = 0;

   NTStatus = IFReadSTCRegister(
      ReaderExtension,
      ADR_ETULENGTH15,
      1,
      &DIV );

   if( NTStatus == STATUS_SUCCESS )
   {
      switch( Factor )
      {
         case 1:
            DIV &= ~M_DIV0;
            DIV &= ~M_DIV1;
            break;

         case 2:
            DIV |= M_DIV0;
            DIV &= ~M_DIV1;
            break;

         case 4   :
            DIV &= ~M_DIV0;
            DIV |= M_DIV1;
            break;

         case 8   :
            DIV |= M_DIV0;
            DIV |= M_DIV1;
            break;

         default :
            NTStatus = STATUS_DATA_ERROR;
      }
      if( NTStatus == STATUS_SUCCESS )
      {
         NTStatus = IFWriteSTCRegister(
            ReaderExtension,
            ADR_ETULENGTH15,
            1,
            &DIV );
      }
   }
   return(NTStatus);
}

NTSTATUS
STCInitUART(
   PREADER_EXTENSION ReaderExtension,
   BOOLEAN           AutoLearn)
/*++
Description:

Arguments:
   ReaderExtension      context of call

Return Value:
   STATUS_SUCCESS
   error values from IFRead / IFWrite

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR    Value;

   Value = AutoLearn ? 0x6F : 0x66;

   NTStatus = IFWriteSTCRegister(
      ReaderExtension,
      ADR_UART_CONTROL,
      1,
      &Value );

   return( NTStatus );
}

//---------------------------------------- END OF FILE ----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\stcusb\stcusbnt.h ===
/*++

Copyright (c) 1998 SCM Microsystems, Inc.

Module Name:

    stcusbNT.h

Abstract:

    Driver header - WDM Version

Author:


Revision History:

    PP  1.00        12/18/1998      Initial Version

--*/

#if !defined ( __STCUSB_WDM_H__ )
#define __STCUSB_WDM_H__

//
//  Prototypes ----------------------------------------------------------------
//

        
NTSTATUS
DriverEntry(
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath);

NTSTATUS
StcUsbPnP(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp);

NTSTATUS
StcUsbPower(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp);


NTSTATUS
StcUsbCreateDevice(
    IN  PDRIVER_OBJECT DriverObject,
    OUT PDEVICE_OBJECT *DeviceObject);

NTSTATUS 
StcUsbStartDevice(
    PDEVICE_OBJECT DeviceObject);

VOID
StcUsbStopDevice( 
    PDEVICE_OBJECT DeviceObject);

NTSTATUS
StcUsbAddDevice(
    IN PDRIVER_OBJECT DriverObject, 
    IN PDEVICE_OBJECT PhysicalDeviceObject);

VOID
StcUsbUnloadDevice( 
    PDEVICE_OBJECT DeviceObject);

VOID
StcUsbUnloadDriver( 
    PDRIVER_OBJECT DriverObject);

NTSTATUS
StcUsbCleanup(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp);

NTSTATUS
StcUsbSystemControl(
   PDEVICE_OBJECT DeviceObject,
   PIRP Irp);

NTSTATUS
StcUsbDeviceIoControl(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp);

NTSTATUS 
StcUsbCreateClose(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp);

NTSTATUS
StcUsbCancel(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp);

NTSTATUS
StcUsbGenericIOCTL(
    PSMARTCARD_EXTENSION SmartcardExtension);

NTSTATUS
StcUsbStartPollThread( PDEVICE_EXTENSION DeviceExtension );

VOID
StcUsbStopPollThread( PDEVICE_EXTENSION DeviceExtension );

void SysDelay( ULONG Timeout );



#endif  // __STCUSB_WDM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\stcusb\stccmd.h ===
/*++

Copyright (c) 1998 SCM Microsystems, Inc.

Module Name:

    stccmd.h

Abstract:

	function prototypes for stc commands


Revision History:

	PP			12/18/1998	Initial Version

--*/

#if !defined( __STC_CMD_H__ )
#define __STC_CMD_H__
//
//
//	Prototypes ----------------------------------------------------------------
//

NTSTATUS 
STCResetInterface(
	PREADER_EXTENSION	ReaderExtension);

NTSTATUS
STCReset( 
	PREADER_EXTENSION	ReaderExtension,
	UCHAR				Device,
	BOOLEAN				WarmReset,
	PUCHAR				pATR,
	PULONG				pATRLength);

NTSTATUS 
STCReadATR(
	PREADER_EXTENSION	ReaderExtension, 
	PUCHAR				pATR, 
	PULONG				pATRLength);

NTSTATUS
STCPowerOff(
	PREADER_EXTENSION	ReaderExtension);

NTSTATUS
STCPowerOn(
	PREADER_EXTENSION	ReaderExtension);

NTSTATUS
STCSetRST(
	PREADER_EXTENSION	ReaderExtension,
	BOOLEAN				On);
NTSTATUS
STCConfigureSTC( 	
	PREADER_EXTENSION	ReaderExtension,
	PSTC_REGISTER		pConfiguration
	);

NTSTATUS
STCSetETU(
	PREADER_EXTENSION	ReaderExtension,
	ULONG				NewETU);

NTSTATUS
STCSetCGT(
	PREADER_EXTENSION	ReaderExtension,
	ULONG				NewCGT);

NTSTATUS
STCSetCWT(
	PREADER_EXTENSION	ReaderExtension,
	ULONG				NewCWT);

NTSTATUS
STCSetBWT(
	PREADER_EXTENSION	ReaderExtension,
	ULONG				NewBWT);

NTSTATUS 
STCShortCircuitTest(
	PREADER_EXTENSION	ReaderExtension,
	BOOLEAN				*Detected);

NTSTATUS
STCSetFDIV(
	PREADER_EXTENSION	ReaderExtension,
	ULONG				Factor);

NTSTATUS 
STCInitUART(
	PREADER_EXTENSION	ReaderExtension,
	BOOLEAN				AutoLearn);



#endif	//	!__STC_CMD_H__


//---------------------------------------- END OF FILE ----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\stcusb\stcusbnt.c ===
/*++

Copyright (c) 1998 SCM Microsystems, Inc.

Module Name:

   StcUsbNT.c

Abstract:

   Main Driver Module - WDM Version


Revision History:


   PP 1.01     01/19/1998     Initial Version
   PP 1.00     12/18/1998     Initial Version

--*/

#include <ntstatus.h>
#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <usb100.h>

#include <common.h>
#include <stcCmd.h>
#include <stcCB.h>
#include <stcusblg.h>
#include <usbcom.h>
#include <stcusbnt.h>


#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGEABLE, StcUsbAddDevice)
#pragma alloc_text(PAGEABLE, StcUsbCreateDevice)
#pragma alloc_text(PAGEABLE, StcUsbStartDevice)
#pragma alloc_text(PAGEABLE, StcUsbUnloadDriver)
#pragma alloc_text(PAGEABLE, StcUsbCreateClose)

extern const STC_REGISTER STCInitialize[];
extern const STC_REGISTER STCClose[];

NTSTATUS
DriverEntry(
   PDRIVER_OBJECT DriverObject,
   PUNICODE_STRING   RegistryPath )
/*++

DriverEntry:
   entry function of the driver. setup the callbacks for the OS and try to
   initialize a device object for every device in the system

Arguments:
   DriverObject   context of the driver
   RegistryPath   path to the registry entry for the driver

Return Value:
   STATUS_SUCCESS
   STATUS_UNSUCCESSFUL

--*/
{
//  SmartcardSetDebugLevel( DEBUG_DRIVER | DEBUG_TRACE );
   SmartcardDebug(
        DEBUG_DRIVER,
       ("------------------------------------------------------------------\n" )
       );

   SmartcardDebug(
        DEBUG_DRIVER,
       ("%s!DriverEntry: Enter - %s %s\n",
        DRIVER_NAME,
        __DATE__,
        __TIME__));

   SmartcardDebug(
        DEBUG_DRIVER,
       ("------------------------------------------------------------------\n" )
       );

   // tell the system our entry points
   DriverObject->MajorFunction[IRP_MJ_CREATE] =       StcUsbCreateClose;
   DriverObject->MajorFunction[IRP_MJ_CLOSE] =           StcUsbCreateClose;
   DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] =  StcUsbDeviceIoControl;
   DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] =  StcUsbSystemControl;
   DriverObject->MajorFunction[IRP_MJ_CLEANUP]  =        StcUsbCleanup;
   DriverObject->MajorFunction[IRP_MJ_PNP]   =           StcUsbPnP;
    DriverObject->MajorFunction[IRP_MJ_POWER] =          StcUsbPower;

   DriverObject->DriverExtension->AddDevice =            StcUsbAddDevice;
   DriverObject->DriverUnload =                    StcUsbUnloadDriver;

   SmartcardDebug(
      DEBUG_TRACE,
      ("%s!DriverEntry: Exit\n",
      DRIVER_NAME));

   return STATUS_SUCCESS;;
}

NTSTATUS
StcUsbAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject)
/*++

Routine Description:
   creates a new device object for the driver, allocates & initializes all
   neccessary structures (i.e. SmartcardExtension & ReaderExtension).

Arguments:
   DriverObject   context of call
   DeviceObject   ptr to the created device object

Return Value:
   STATUS_SUCCESS
   STATUS_INSUFFICIENT_RESOURCES
   status returned by smclib.sys

--*/
{
   NTSTATUS status;
   UNICODE_STRING DriverID;
   PDEVICE_OBJECT DeviceObject = NULL;
   PDEVICE_EXTENSION DeviceExtension = NULL;
   PREADER_EXTENSION ReaderExtension = NULL;
    PSMARTCARD_EXTENSION SmartcardExtension = NULL;
   UNICODE_STRING vendorNameU, ifdTypeU;
   ANSI_STRING vendorNameA, ifdTypeA;
   HANDLE regKey = NULL;

   // this is a list of our supported data rates

    static ULONG dataRatesSupported[] = { 9600, 19200, 38400, 55800, 115200 };

   PAGED_CODE();

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!StcUsbAddDevice: Enter\n",
      DRIVER_NAME));
    try
   {
       ULONG deviceInstance;
      RTL_QUERY_REGISTRY_TABLE parameters[3];
      RtlZeroMemory(parameters, sizeof(parameters));
      RtlZeroMemory(&vendorNameU, sizeof(vendorNameU));
      RtlZeroMemory(&ifdTypeU, sizeof(ifdTypeU));
      RtlZeroMemory(&vendorNameA, sizeof(vendorNameA));
      RtlZeroMemory(&ifdTypeA, sizeof(ifdTypeA));

       // Create the device object
       status = IoCreateDevice(
          DriverObject,
          sizeof(DEVICE_EXTENSION),
            NULL,
          FILE_DEVICE_SMARTCARD,
          0,
          TRUE,
          &DeviceObject);

        if (status != STATUS_SUCCESS)
      {
         SmartcardLogError(
            DriverObject,
            STCUSB_INSUFFICIENT_RESOURCES,
            NULL,
            0);

            __leave;
        }

       //   set up the device extension.
       DeviceExtension = DeviceObject->DeviceExtension;
        SmartcardExtension = &DeviceExtension->SmartcardExtension;
      SmartcardExtension->VendorAttr.UnitNo = MAXULONG;

      for (deviceInstance = 0; deviceInstance < MAXULONG; deviceInstance++) {

         PDEVICE_OBJECT devObj;

         for (devObj = DeviceObject;
             devObj != NULL;
             devObj = devObj->NextDevice) {

             PDEVICE_EXTENSION devExt = devObj->DeviceExtension;
             PSMARTCARD_EXTENSION smcExt = &devExt->SmartcardExtension;

             if (deviceInstance == smcExt->VendorAttr.UnitNo) {

                break;
             }
         }
         if (devObj == NULL) {

            SmartcardExtension->VendorAttr.UnitNo = deviceInstance;
             SmartcardExtension->ReaderCapabilities.Channel = deviceInstance;
            break;
         }
      }

      // Used to synchonize the smartcard detection polling
      // with the the IO Control routine
      KeInitializeMutex(
         &DeviceExtension->hMutex,
         1);

      // Used for stop / start notification
        KeInitializeEvent(
            &DeviceExtension->ReaderStarted,
            NotificationEvent,
            FALSE);

      // Used to control the poll thread
      KeInitializeEvent(
          &DeviceExtension->FinishPollThread,
          NotificationEvent,
          FALSE
          );

      KeInitializeEvent(
          &DeviceExtension->PollThreadStopped,
          NotificationEvent,
          FALSE
          );

      DeviceExtension->PollWorkItem = IoAllocateWorkItem( DeviceObject );
      if( DeviceExtension->PollWorkItem == NULL )
      {
         status = STATUS_INSUFFICIENT_RESOURCES;
         __leave;
      }

      //   allocate the reader extension
       ReaderExtension = ExAllocatePool(
          NonPagedPool,
          sizeof( READER_EXTENSION ));

       if( ReaderExtension == NULL )
      {
         SmartcardLogError(
            DriverObject,
            STCUSB_INSUFFICIENT_RESOURCES,
            NULL,
            0);

            status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
        }

       RtlZeroMemory( ReaderExtension, sizeof( READER_EXTENSION ));

       SmartcardExtension->ReaderExtension = ReaderExtension;
      SmartcardExtension->ReaderExtension->DeviceObject = DeviceObject;

       //   setup smartcard extension - callback's
       SmartcardExtension->ReaderFunction[RDF_CARD_POWER] = CBCardPower;
       SmartcardExtension->ReaderFunction[RDF_TRANSMIT] =      CBTransmit;
       SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING] = CBCardTracking;
       SmartcardExtension->ReaderFunction[RDF_SET_PROTOCOL] =  CBSetProtocol;

       //   setup smartcard extension - vendor attribute
       RtlCopyMemory(
          SmartcardExtension->VendorAttr.VendorName.Buffer,
          STCUSB_VENDOR_NAME,
          sizeof( STCUSB_VENDOR_NAME ));

       SmartcardExtension->VendorAttr.VendorName.Length =
            sizeof( STCUSB_VENDOR_NAME );

       RtlCopyMemory(
          SmartcardExtension->VendorAttr.IfdType.Buffer,
          STCUSB_PRODUCT_NAME,
          sizeof( STCUSB_PRODUCT_NAME ));
       SmartcardExtension->VendorAttr.IfdType.Length =
          sizeof( STCUSB_PRODUCT_NAME );

       SmartcardExtension->VendorAttr.IfdVersion.BuildNumber = 0;

       //   store firmware revision in ifd version
       SmartcardExtension->VendorAttr.IfdVersion.VersionMajor =
          ReaderExtension->FirmwareMajor;
       SmartcardExtension->VendorAttr.IfdVersion.VersionMinor =
          ReaderExtension->FirmwareMinor;
       SmartcardExtension->VendorAttr.IfdSerialNo.Length = 0;

       //   setup smartcard extension - reader capabilities
       SmartcardExtension->ReaderCapabilities.SupportedProtocols =
          SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;
       SmartcardExtension->ReaderCapabilities.ReaderType =
          SCARD_READER_TYPE_USB;
       SmartcardExtension->ReaderCapabilities.MechProperties = 0;

      // Clk frequency in KHz encoded as little endian integer
      SmartcardExtension->ReaderCapabilities.CLKFrequency.Default = 3571;
      SmartcardExtension->ReaderCapabilities.CLKFrequency.Max = 3571;

      SmartcardExtension->ReaderCapabilities.DataRate.Default =
      SmartcardExtension->ReaderCapabilities.DataRate.Max = dataRatesSupported[0];


      // reader could support higher data rates
      SmartcardExtension->ReaderCapabilities.DataRatesSupported.List =
         dataRatesSupported;
      SmartcardExtension->ReaderCapabilities.DataRatesSupported.Entries =
         sizeof(dataRatesSupported) / sizeof(dataRatesSupported[0]);

       //   enter correct version of the lib
       SmartcardExtension->Version = SMCLIB_VERSION;
       SmartcardExtension->SmartcardRequest.BufferSize   = MIN_BUFFER_SIZE;
       SmartcardExtension->SmartcardReply.BufferSize  = MIN_BUFFER_SIZE;

       SmartcardExtension->ReaderCapabilities.MaxIFSD    = 128; // 254 does not work. SCM should figure out why.

        SmartcardExtension->ReaderExtension->ReaderPowerState =
            PowerReaderWorking;

       status = SmartcardInitialize(SmartcardExtension);

        if (status != STATUS_SUCCESS)
      {
         SmartcardLogError(
            DriverObject,
            STCUSB_INSUFFICIENT_RESOURCES,
            NULL,
            0);

            __leave;
        }

      // tell the lib our device object
      SmartcardExtension->OsData->DeviceObject = DeviceObject;

      DeviceExtension->AttachedPDO = IoAttachDeviceToDeviceStack(
            DeviceObject,
            PhysicalDeviceObject);

        ASSERT(DeviceExtension->AttachedPDO != NULL);

        if (DeviceExtension->AttachedPDO == NULL)
      {
            status = STATUS_UNSUCCESSFUL;
            __leave;
        }

      // register our new device
      status = IoRegisterDeviceInterface(
         PhysicalDeviceObject,
         &SmartCardReaderGuid,
         NULL,
         &DeviceExtension->DeviceName);

      ASSERT(status == STATUS_SUCCESS);

      DeviceObject->Flags |= DO_BUFFERED_IO;
      DeviceObject->Flags |= DO_POWER_PAGABLE;
      DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
      //
      // try to read the reader name from the registry
      // if that does not work, we will use the default
      // (hardcoded) name
      //
      if (IoOpenDeviceRegistryKey(
         PhysicalDeviceObject,
         PLUGPLAY_REGKEY_DEVICE,
         KEY_READ,
         &regKey
         ) != STATUS_SUCCESS) {

         __leave;
      }

      parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
      parameters[0].Name = L"VendorName";
      parameters[0].EntryContext = &vendorNameU;
      parameters[0].DefaultType = REG_SZ;
      parameters[0].DefaultData = &vendorNameU;
      parameters[0].DefaultLength = 0;

      parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
      parameters[1].Name = L"IfdType";
      parameters[1].EntryContext = &ifdTypeU;
      parameters[1].DefaultType = REG_SZ;
      parameters[1].DefaultData = &ifdTypeU;
      parameters[1].DefaultLength = 0;

      if (RtlQueryRegistryValues(
          RTL_REGISTRY_HANDLE,
          (PWSTR) regKey,
          parameters,
          NULL,
          NULL
          ) != STATUS_SUCCESS) {

         __leave;
      }

      if (RtlUnicodeStringToAnsiString(
         &vendorNameA,
         &vendorNameU,
         TRUE
         ) != STATUS_SUCCESS) {

         __leave;
      }

      if (RtlUnicodeStringToAnsiString(
         &ifdTypeA,
         &ifdTypeU,
         TRUE
         ) != STATUS_SUCCESS) {

         __leave;
      }

      if (vendorNameA.Length == 0 ||
         vendorNameA.Length > MAXIMUM_ATTR_STRING_LENGTH ||
         ifdTypeA.Length == 0 ||
         ifdTypeA.Length > MAXIMUM_ATTR_STRING_LENGTH) {

         __leave;
      }

      RtlCopyMemory(
         SmartcardExtension->VendorAttr.VendorName.Buffer,
         vendorNameA.Buffer,
         vendorNameA.Length
         );
      SmartcardExtension->VendorAttr.VendorName.Length =
         vendorNameA.Length;
      RtlCopyMemory(
         SmartcardExtension->VendorAttr.IfdType.Buffer,
         ifdTypeA.Buffer,
         ifdTypeA.Length
         );
      SmartcardExtension->VendorAttr.IfdType.Length =
         ifdTypeA.Length;
    }
    __finally
   {
      if (vendorNameU.Buffer) {

         RtlFreeUnicodeString(&vendorNameU);
      }

      if (ifdTypeU.Buffer) {

         RtlFreeUnicodeString(&ifdTypeU);
      }

      if (vendorNameA.Buffer) {

         RtlFreeAnsiString(&vendorNameA);
      }

      if (ifdTypeA.Buffer) {

         RtlFreeAnsiString(&ifdTypeA);
      }

      if (regKey != NULL) {

         ZwClose(regKey);
      }

        if (status != STATUS_SUCCESS)
      {
            StcUsbUnloadDevice(DeviceObject);
        }

       SmartcardDebug(
          DEBUG_TRACE,
          ( "%s!StcUsbAddDevice: Exit %x\n",
         DRIVER_NAME,
          status ));
    }
    return status;
}


NTSTATUS
StcUsbStartDevice(
   PDEVICE_OBJECT DeviceObject
   )
/*++

Routine Description:
   get the actual configuration from the USB communication layer
   and initializes the reader hardware

Arguments:
   DeviceObject         context of call

Return Value:
   STATUS_SUCCESS
   status returned by LowLevel routines

--*/
{
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension = &DeviceExtension->SmartcardExtension;
    PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;
    NTSTATUS NtStatus = STATUS_NO_MEMORY;

    PURB pUrb = NULL;

   SmartcardDebug(
      DEBUG_TRACE,
      ("%s!StcUsbStartDevice: Enter\n",
      DRIVER_NAME));

   __try {

      // Initialize the USB interface
      pUrb = ExAllocatePool(
         NonPagedPool,
         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST)
         );

      if(pUrb == NULL)
      {
         __leave;

      }

      DeviceExtension->DeviceDescriptor = ExAllocatePool(
         NonPagedPool,
         sizeof(USB_DEVICE_DESCRIPTOR)
         );

      if(DeviceExtension->DeviceDescriptor == NULL)
      {
         __leave;
      }

      UsbBuildGetDescriptorRequest(
         pUrb,
         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
         USB_DEVICE_DESCRIPTOR_TYPE,
         0,
         0,
         DeviceExtension->DeviceDescriptor,
         NULL,
         sizeof(USB_DEVICE_DESCRIPTOR),
         NULL
         );

      // Send the urb to the USB driver
      NtStatus = UsbCallUSBD(DeviceObject, pUrb);

      if(NtStatus != STATUS_SUCCESS)
      {
         __leave;
      }

      UsbConfigureDevice(DeviceObject);

      ReaderExtension->ulReadBufferLen = 0;

      // setup the STC registers
      NtStatus = STCConfigureSTC(
            SmartcardExtension->ReaderExtension,
            ( PSTC_REGISTER ) STCInitialize
            );

        if (NtStatus != STATUS_SUCCESS)
      {
          SmartcardLogError(
             DeviceObject,
             STCUSB_CANT_INITIALIZE_READER,
             NULL,
             0);

            __leave;
        }

      UsbGetFirmwareRevision(SmartcardExtension->ReaderExtension);
       //   store firmware revision in ifd version
       SmartcardExtension->VendorAttr.IfdVersion.VersionMajor =
          ReaderExtension->FirmwareMajor;
       SmartcardExtension->VendorAttr.IfdVersion.VersionMinor =
          ReaderExtension->FirmwareMinor;

      // CBUpdateCardState(SmartcardExtension );

       // start polling the device for card movement detection
       StcUsbStartPollThread( DeviceExtension );

        NtStatus = IoSetDeviceInterfaceState(
         &DeviceExtension->DeviceName,
         TRUE
         );

      if (NtStatus == STATUS_OBJECT_NAME_EXISTS)
      {
         // We tried to re-enable the device which is ok
         // This can happen after a stop - start sequence
         NtStatus = STATUS_SUCCESS;
      }

        // signal that the reader has been started
        KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);

      ASSERT(NtStatus == STATUS_SUCCESS);
    }
    finally
   {
      if (pUrb != NULL)
      {
         ExFreePool(pUrb);
      }

        if (NtStatus != STATUS_SUCCESS)
        {
            StcUsbStopDevice(DeviceObject);
        }

        SmartcardDebug(
           DEBUG_TRACE,
           ( "%s!StcUsbStartDevice: Exit %x\n",
         DRIVER_NAME,
           NtStatus ));
    }
    return NtStatus;
}



VOID
StcUsbStopDevice(
   PDEVICE_OBJECT DeviceObject)
/*++

Routine Description:
    Finishes card tracking requests and closes the connection to the
    Usb port.

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS status;
   LARGE_INTEGER delayPeriod;

    if (DeviceObject == NULL)
   {
        return;
    }

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!StcUsbStopDevice: Enter\n",
      DRIVER_NAME));

    DeviceExtension = DeviceObject->DeviceExtension;

    KeClearEvent(&DeviceExtension->ReaderStarted);

   // stop polling the reader
   StcUsbStopPollThread( DeviceExtension );

   if (DeviceExtension->DeviceDescriptor)
   {
      ExFreePool(DeviceExtension->DeviceDescriptor);
      DeviceExtension->DeviceDescriptor = NULL;
   }

   if (DeviceExtension->Interface)
   {
      ExFreePool(DeviceExtension->Interface);
      DeviceExtension->Interface = NULL;
   }

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!StcUsbStopDevice: Exit\n",
      DRIVER_NAME));
}

NTSTATUS
StcUsbSystemControl(
   PDEVICE_OBJECT DeviceObject,
   PIRP        Irp
   )
{
   PDEVICE_EXTENSION DeviceExtension; 
   NTSTATUS status = STATUS_SUCCESS;

   DeviceExtension      = DeviceObject->DeviceExtension;

   IoSkipCurrentIrpStackLocation(Irp);
   status = IoCallDriver(DeviceExtension->AttachedPDO, Irp);
      
   return status;

}

NTSTATUS
StcUsbDeviceIoControl(
   PDEVICE_OBJECT DeviceObject,
   PIRP        Irp)
/*++

StcUsbDeviceIoControl:
   all IRP's requiring IO are queued to the StartIo routine, other requests
   are served immediately

--*/
{
   PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    KIRQL irql;
    LARGE_INTEGER timeout;
    PSMARTCARD_EXTENSION SmartcardExtension = &deviceExtension->SmartcardExtension;
   PREADER_EXTENSION ReaderExtension= SmartcardExtension->ReaderExtension;


    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    if (deviceExtension->IoCount < 0)
   {
        KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
        status = KeWaitForSingleObject(
            &deviceExtension->ReaderStarted,
            Executive,
            KernelMode,
            FALSE,
            NULL);

        KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    }
    ASSERT(deviceExtension->IoCount >= 0);
    deviceExtension->IoCount++;
    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

    status = SmartcardAcquireRemoveLock(&deviceExtension->SmartcardExtension);

    if (status != STATUS_SUCCESS)
   {

        // the device has been removed. Fail the call
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_REMOVED;
    }

    KeWaitForMutexObject(
        &deviceExtension->hMutex,
        Executive,
        KernelMode,
        FALSE,
      NULL);

   status = SmartcardDeviceControl(
      &(deviceExtension->SmartcardExtension),
      Irp);

    KeReleaseMutex(
      &deviceExtension->hMutex,
      FALSE);

    SmartcardReleaseRemoveLock(&deviceExtension->SmartcardExtension);

    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    deviceExtension->IoCount--;
    ASSERT(deviceExtension->IoCount >= 0);
    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

    return status;
}
NTSTATUS
StcUsbCallComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event)
/*++

Routine Description:
   Completion routine for an Irp sent to the Usb driver. The event will
   be set to notify that the Usb driver is done. The routine will not
   'complete' the Irp, so the caller of CallUsbDriver can continue.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);

    if (Irp->Cancel)
   {
        Irp->IoStatus.Status = STATUS_CANCELLED;
    }

    KeSetEvent (Event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
StcUsbCallUsbDriver(
    IN PDEVICE_OBJECT AttachedPDO,
    IN PIRP Irp)

/*++

Routine Description:
   Send an Irp to the Usb driver.

--*/
{
   NTSTATUS NtStatus = STATUS_SUCCESS;
    KEVENT Event;

    // Copy our stack location to the next.
    IoCopyCurrentIrpStackLocationToNext(Irp);

   //
   // initialize an event for process synchronization. the event is passed
   // to our completion routine and will be set if the pcmcia driver is done
   //
    KeInitializeEvent(
        &Event,
        NotificationEvent,
        FALSE);

    // Our IoCompletionRoutine sets only our event
    IoSetCompletionRoutine (
        Irp,
        StcUsbCallComplete,
        &Event,
        TRUE,
        TRUE,
        TRUE);

    if (IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_POWER)
   {
      NtStatus = PoCallDriver(AttachedPDO, Irp);
    }
   else
   {
      NtStatus = IoCallDriver(AttachedPDO, Irp);
    }

   // Wait until the usb driver has processed the Irp
    if (NtStatus == STATUS_PENDING)
   {
        NtStatus = KeWaitForSingleObject(
            &Event,
            Executive,
            KernelMode,
            FALSE,
            NULL);

      if (NtStatus == STATUS_SUCCESS)
      {
         NtStatus = Irp->IoStatus.Status;
      }
   }

   return(NtStatus);
}




NTSTATUS
StcUsbPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp)
/*++

Routine Description:
   driver callback for pnp manager
   All other requests will be passed to the usb driver to ensure correct processing.

--*/
{

   NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension = &DeviceExtension->SmartcardExtension;
   PIO_STACK_LOCATION IrpStack;
    PDEVICE_OBJECT AttachedPDO;
    BOOLEAN deviceRemoved = FALSE;
    KIRQL irql;

    PAGED_CODE();

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!StcUsbPnP: Enter\n",
      DRIVER_NAME));

    status = SmartcardAcquireRemoveLock(SmartcardExtension);

    if (status != STATUS_SUCCESS)
   {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    AttachedPDO = DeviceExtension->AttachedPDO;

//   Irp->IoStatus.Information = 0;
   IrpStack = IoGetCurrentIrpStackLocation(Irp);

    // Now look what the PnP manager wants...
   switch(IrpStack->MinorFunction)
   {
      case IRP_MN_START_DEVICE:

            // Now we should connect to our resources (Irql, Io etc.)
         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!StcUsbPnP: IRP_MN_START_DEVICE\n",
            DRIVER_NAME));

            // We have to call the underlying driver first
            status = StcUsbCallUsbDriver(AttachedPDO, Irp);
            
            if (NT_SUCCESS(status))
         {
                status = StcUsbStartDevice(DeviceObject);

         }
         break;

        case IRP_MN_QUERY_STOP_DEVICE:

         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!StcUsbPnP: IRP_MN_QUERY_STOP_DEVICE\n",
            DRIVER_NAME));
            KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);
            if (DeviceExtension->IoCount > 0)
         {
                // we refuse to stop if we have pending io
                KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);
                status = STATUS_DEVICE_BUSY;

            }
         else
         {
             // stop processing requests
                DeviceExtension->IoCount = -1;
                KeClearEvent(&DeviceExtension->ReaderStarted);
                KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);
                status = StcUsbCallUsbDriver(AttachedPDO, Irp);
            }
         break;

        case IRP_MN_CANCEL_STOP_DEVICE:

         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!StcUsbPnP: IRP_MN_CANCEL_STOP_DEVICE\n",
            DRIVER_NAME));

            status = StcUsbCallUsbDriver(AttachedPDO, Irp);

            // we can continue to process requests
            DeviceExtension->IoCount = 0;
            KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);
         break;

      case IRP_MN_STOP_DEVICE:

         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!StcUsbPnP: IRP_MN_STOP_DEVICE\n",
            DRIVER_NAME));

            StcUsbStopDevice(DeviceObject);
            status = StcUsbCallUsbDriver(AttachedPDO, Irp);
         break;

      case IRP_MN_QUERY_REMOVE_DEVICE:

            // Remove our device
         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!StcUsbPnP: IRP_MN_QUERY_REMOVE_DEVICE\n",
            DRIVER_NAME));

         // disable the reader
         status = IoSetDeviceInterfaceState(
            &DeviceExtension->DeviceName,
            FALSE);
         ASSERT(status == STATUS_SUCCESS);

         if (status != STATUS_SUCCESS)
         {
            break;
         }

         // check if the reader has been opened
            if (DeviceExtension->ReaderOpen)
         {
            // someone is connected, enable the reader and fail the call
            IoSetDeviceInterfaceState(
               &DeviceExtension->DeviceName,
               TRUE);
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            // pass the call to the next driver in the stack
            status = StcUsbCallUsbDriver(AttachedPDO, Irp);
         break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:

            // Removal of device has been cancelled
         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!StcUsbPnP: IRP_MN_CANCEL_REMOVE_DEVICE\n",
            DRIVER_NAME));

            // pass the call to the next driver in the stack
            status = StcUsbCallUsbDriver(AttachedPDO, Irp);

            if (status == STATUS_SUCCESS)
         {
            status = IoSetDeviceInterfaceState(
               &DeviceExtension->DeviceName,
               TRUE);
            }
         break;

      case IRP_MN_REMOVE_DEVICE:

            // Remove our device
         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!StcUsbPnP: IRP_MN_REMOVE_DEVICE\n",
            DRIVER_NAME));

            StcUsbStopDevice(DeviceObject);
            StcUsbUnloadDevice(DeviceObject);

            status = StcUsbCallUsbDriver(AttachedPDO, Irp);
            deviceRemoved = TRUE;
         break;

      default:
         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!StcUsbPnP: IRP_MN_...%lx\n",
                DRIVER_NAME,
                IrpStack->MinorFunction));
            // This is an Irp that is only useful for underlying drivers
            status = StcUsbCallUsbDriver(AttachedPDO, Irp);
         break;
   }

   Irp->IoStatus.Status = status;

    IoCompleteRequest(
        Irp,
        IO_NO_INCREMENT);

    if (deviceRemoved == FALSE)
   {
        SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);
    }

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!StcUsbPnP: Exit %x\n",
      DRIVER_NAME,
        status));

    return status;
}

VOID
StcUsbSystemPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:
    This function is called when the underlying stacks
    completed the power transition.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (MinorFunction);
    UNREFERENCED_PARAMETER (PowerState);
    UNREFERENCED_PARAMETER (IoStatus);

    KeSetEvent(Event, 0, FALSE);
}

NTSTATUS
StcUsbDevicePowerCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMARTCARD_EXTENSION SmartcardExtension)
/*++

Routine Description:
    This routine is called after the underlying stack powered
    UP the Usb port, so it can be used again.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    NTSTATUS status;
    UCHAR state;
    BOOLEAN CardPresent;

   //
   // setup the STC registers
   //
   status = STCConfigureSTC(
        SmartcardExtension->ReaderExtension,
        ( PSTC_REGISTER ) STCInitialize
        );

    // get the current state of the card
    CBUpdateCardState(SmartcardExtension);

    // save the current power state of the reader
    SmartcardExtension->ReaderExtension->ReaderPowerState =
        PowerReaderWorking;

    SmartcardReleaseRemoveLock(SmartcardExtension);

    // inform the power manager of our state.
    PoSetPowerState (
        DeviceObject,
        DevicePowerState,
        irpStack->Parameters.Power.State);

    PoStartNextPowerIrp(Irp);

    // restart the polling thread
    StcUsbStartPollThread( deviceExtension );

    return STATUS_SUCCESS;
}

typedef enum _ACTION {

    Undefined = 0,
    SkipRequest,
    WaitForCompletion,
    CompleteRequest,
    MarkPending

} ACTION;

NTSTATUS
StcUsbPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp)
/*++

Routine Description:
    The power dispatch routine.
    This driver is the power policy owner of the device stack,
    because this driver knows about the connected reader.
    Therefor this driver will translate system power states
    to device power states.

Arguments:
   DeviceObject - pointer to a device object.
   Irp - pointer to an I/O Request Packet.

Return Value:
      NT status code

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    ACTION action;
    POWER_STATE powerState;
   KEVENT event;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!StcUsbPower: Enter\n",
      DRIVER_NAME));

    status = SmartcardAcquireRemoveLock(smartcardExtension);


    if (!NT_SUCCESS(status))
   {
        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

   switch (irpStack->Parameters.Power.Type) {
   case DevicePowerState:
      if (irpStack->MinorFunction == IRP_MN_SET_POWER) {

         switch (irpStack->Parameters.Power.State.DeviceState) {

         case PowerDeviceD0:
            // Turn on the reader
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!StcUsbPower: PowerDevice D0\n",
                           DRIVER_NAME));

            //
            // First, we send down the request to the bus, in order
            // to power on the port. When the request completes,
            // we turn on the reader
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine (
                                   Irp,
                                   StcUsbDevicePowerCompletion,
                                   smartcardExtension,
                                   TRUE,
                                   TRUE,
                                   TRUE);
            action = WaitForCompletion;
            break;

         case PowerDeviceD3:
            // Turn off the reader
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!StcUsbPower: PowerDevice D3\n",
                           DRIVER_NAME));

            KeClearEvent(&deviceExtension->ReaderStarted);

            StcUsbStopPollThread( deviceExtension );

            PoSetPowerState (
                            DeviceObject,
                            DevicePowerState,
                            irpStack->Parameters.Power.State);

            // save the current card state
            smartcardExtension->ReaderExtension->CardPresent =
            smartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT;

            // power down the card
            if (smartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT ) {
               smartcardExtension->MinorIoControlCode = SCARD_POWER_DOWN;
               status = CBCardPower(smartcardExtension);
               //
               // This will trigger the card monitor, since we do not really
               // know if the user will remove / re-insert a card while the
               // system is asleep
               //
            }
            status = STCConfigureSTC(
                                    smartcardExtension->ReaderExtension,
                                    ( PSTC_REGISTER ) STCClose
                                    );

            // save the current power state of the reader
            smartcardExtension->ReaderExtension->ReaderPowerState =
            PowerReaderOff;

            action = SkipRequest;
            break;

         default:
            action = SkipRequest;
            break;
         }
      } else {

         action = SkipRequest;
      }
      break;

   case SystemPowerState: {
         //
         // The system wants to change the power state.
         // We need to translate the system power state to
         // a corresponding device power state.
         //

         POWER_STATE_TYPE powerType = DevicePowerState;
         KIRQL irql;

         ASSERT(smartcardExtension->ReaderExtension->ReaderPowerState !=
                PowerReaderUnspecified);

         switch (irpStack->MinorFunction) {

         case IRP_MN_QUERY_POWER:

            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!StcUsbPower: Query Power\n",
                           DRIVER_NAME));

            //
            // By default we succeed and pass down
            //

            action = SkipRequest;
            Irp->IoStatus.Status = STATUS_SUCCESS;

            switch (irpStack->Parameters.Power.State.SystemState) {

            case PowerSystemMaximum:
            case PowerSystemWorking:
               break;
            
            case PowerSystemSleeping1:
            case PowerSystemSleeping2:
            case PowerSystemSleeping3:
            case PowerSystemHibernate:
            case PowerSystemShutdown:
               KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
               if (deviceExtension->IoCount == 0) {

                  // Block any further ioctls
//                  KeClearEvent(&deviceExtension->ReaderStarted);

               } else {

                  // can't go to sleep mode since the reader is busy.
                  status = STATUS_DEVICE_BUSY;
                  action = CompleteRequest;
               }
               KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
               break;
            }
            break;

         case IRP_MN_SET_POWER:

            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!StcUsbPower: PowerSystem S%d\n",
                           DRIVER_NAME,
                           irpStack->Parameters.Power.State.SystemState - 1));

            switch (irpStack->Parameters.Power.State.SystemState) {

            case PowerSystemMaximum:
            case PowerSystemWorking:

               if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                   PowerReaderWorking) {

                  // We're already in the right state
                  KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);
                  action = SkipRequest;
                  break;
               }

               powerState.DeviceState = PowerDeviceD0;
               action = MarkPending;
               break;

            case PowerSystemSleeping1:
            case PowerSystemSleeping2:
            case PowerSystemSleeping3:
            case PowerSystemHibernate:
            case PowerSystemShutdown:

               if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                   PowerReaderOff) {
                  // We're already in the right state
                  action = SkipRequest;
                  break;
               }

               powerState.DeviceState = PowerDeviceD3;

               // first, inform the power manager of our new state.
               PoSetPowerState (
                               DeviceObject,
                               SystemPowerState,
                               powerState);

               action = MarkPending;
               break;

            default:
               action = SkipRequest;
               break;
            }
            break;
         default:
            action = SkipRequest;
            break;
         }
      }
      break;

   default:
      action = SkipRequest;
      break;
   }

    switch (action)
   {
        case CompleteRequest:
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;

            SmartcardReleaseRemoveLock(smartcardExtension);
            PoStartNextPowerIrp(Irp);
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
         break;

        case MarkPending:
         // initialize the event we need in the completion function
         KeInitializeEvent(
            &event,
            NotificationEvent,
            FALSE
            );
         // request the device power irp
         status = PoRequestPowerIrp (
            DeviceObject,
            IRP_MN_SET_POWER,
            powerState,
            StcUsbSystemPowerCompletion,
            &event,
            NULL
            );


         if (status == STATUS_PENDING) {

            // wait until the device power irp completed
            status = KeWaitForSingleObject(
               &event,
               Executive,
               KernelMode,
               FALSE,
               NULL
               );

            SmartcardReleaseRemoveLock(smartcardExtension);

            if (powerState.SystemState == PowerSystemWorking) {

               PoSetPowerState (
                  DeviceObject,
                  SystemPowerState,
                  powerState
                  );
            }

            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(deviceExtension->AttachedPDO, Irp);

         } else {

            SmartcardReleaseRemoveLock(smartcardExtension);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
         }
         break;

        case SkipRequest:
            SmartcardReleaseRemoveLock(smartcardExtension);
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(deviceExtension->AttachedPDO, Irp);
         break;

        case WaitForCompletion:
            status = PoCallDriver(deviceExtension->AttachedPDO, Irp);
         break;

        default:
            break;
    }
    return status;
}

NTSTATUS
StcUsbCreateClose(
   PDEVICE_OBJECT DeviceObject,
   PIRP        Irp
   )
/*++

Routine Description:

    This routine is called by the I/O system when the device is opened or closed.

Arguments:
   DeviceObject   context of device
   Irp            context of call

Return Value:
   STATUS_SUCCESS
   STATUS_DEVICE_BUSY

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!StcCreateClose: Enter\n",
      DRIVER_NAME));

   __try {

      if (irpStack->MajorFunction == IRP_MJ_CREATE) {

         status = SmartcardAcquireRemoveLockWithTag(
            &deviceExtension->SmartcardExtension,
            'lCrC'
            );

         if (status != STATUS_SUCCESS) {

            status = STATUS_DEVICE_REMOVED;
            __leave;
         }

         // test if the device has been opened already
         if (InterlockedCompareExchange(
            &deviceExtension->ReaderOpen,
            TRUE,
            FALSE) == FALSE) {

            SmartcardDebug(
               DEBUG_DRIVER,
               ("%s!StcCreateClose: Open\n",
               DRIVER_NAME)
               );

         } else {

            // the device is already in use
            status = STATUS_UNSUCCESSFUL;

            // release the lock
            SmartcardReleaseRemoveLockWithTag(
               &deviceExtension->SmartcardExtension,
               'lCrC'
               );
         }

      } else {

         SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!StcCreateClose: Close\n",
            DRIVER_NAME)
            );

         SmartcardReleaseRemoveLockWithTag(
            &deviceExtension->SmartcardExtension,
            'lCrC'
            );

         deviceExtension->ReaderOpen = FALSE;
      }
   }
   __finally {

      Irp->IoStatus.Status = status;
      Irp->IoStatus.Information = 0;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
   }

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!StcCreateClose: Exit (%lx)\n",
      DRIVER_NAME,
      status));

   return status;
}


NTSTATUS
StcUsbCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system
    when the irp should be cancelled

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_CANCELLED

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!StcUsbCancel: Enter\n",
        DRIVER_NAME));

    ASSERT(Irp == smartcardExtension->OsData->NotificationIrp);

   Irp->IoStatus.Information  = 0;
   Irp->IoStatus.Status    = STATUS_CANCELLED;

   smartcardExtension->OsData->NotificationIrp = NULL;

    IoReleaseCancelSpinLock(
        Irp->CancelIrql);

   IoCompleteRequest(
      Irp,
      IO_NO_INCREMENT);

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!StcUsbCancel: Exit\n",
        DRIVER_NAME));

    return STATUS_CANCELLED;
}

NTSTATUS
StcUsbCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system when the calling thread terminates

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_CANCELLED

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
   NTSTATUS status = STATUS_SUCCESS;
    KIRQL CancelIrql;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!StcUsbCleanup: Enter\n",
        DRIVER_NAME));

   IoAcquireCancelSpinLock(&CancelIrql);

   // cancel pending notification irps
   if( smartcardExtension->OsData->NotificationIrp )
   {
        // reset the cancel function so that it won't be called anymore
        IoSetCancelRoutine(
            smartcardExtension->OsData->NotificationIrp,
            NULL
            );

        smartcardExtension->OsData->NotificationIrp->CancelIrql =
            CancelIrql;

        StcUsbCancel(
            DeviceObject,
            smartcardExtension->OsData->NotificationIrp);

   } else {

        IoReleaseCancelSpinLock(CancelIrql);
    }

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!StcUsbCleanup: Completing IRP %lx\n",
        DRIVER_NAME,
        Irp));

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

   IoCompleteRequest(
      Irp,
      IO_NO_INCREMENT);

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!StcUsbCleanup: Exit\n",
        DRIVER_NAME));

    return STATUS_SUCCESS;
}


VOID
StcUsbUnloadDevice(
   PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:
   close connections to smclib.sys and the usb driver, delete symbolic
   link and mark the slot as unused.


Arguments:
   DeviceObject   device to unload

Return Value:
   void

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;
    NTSTATUS status;

    if (DeviceObject == NULL)
   {
        return;
    }

   DeviceExtension= DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!StcUsbUnloadDevice: Enter\n",
      DRIVER_NAME));

    KeWaitForMutexObject(
        &DeviceExtension->hMutex,
        Executive,
        KernelMode,
        FALSE,
      NULL);

   KeReleaseMutex(
      &DeviceExtension->hMutex,
      FALSE);

   // free polling resources
   if( DeviceExtension->PollWorkItem == NULL )
   {
      IoFreeWorkItem( DeviceExtension->PollWorkItem );
   }


   // disable our device so no one can open it
   IoSetDeviceInterfaceState(
      &DeviceExtension->DeviceName,
      FALSE);

   // report to the lib that the device will be unloaded
   if(SmartcardExtension->OsData != NULL)
   {
      ASSERT(SmartcardExtension->OsData->NotificationIrp == NULL);
      SmartcardReleaseRemoveLockAndWait(SmartcardExtension);
   }

   // delete the symbolic link
   if( DeviceExtension->DeviceName.Buffer != NULL )
   {
      RtlFreeUnicodeString(&DeviceExtension->DeviceName);
      DeviceExtension->DeviceName.Buffer = NULL;
   }

   if( SmartcardExtension->OsData != NULL )
   {
      SmartcardExit( SmartcardExtension );
   }

    if (DeviceExtension->SmartcardExtension.ReaderExtension != NULL)
   {
        ExFreePool(DeviceExtension->SmartcardExtension.ReaderExtension);
        DeviceExtension->SmartcardExtension.ReaderExtension = NULL;
    }

    // Detach from the usb driver
    if (DeviceExtension->AttachedPDO)
   {
      IoDetachDevice(DeviceExtension->AttachedPDO);
        DeviceExtension->AttachedPDO = NULL;
    }

   // delete the device object
   IoDeleteDevice(DeviceObject);

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!StcUsbUnloadDevice: Exit\n",
      DRIVER_NAME));
}

VOID
StcUsbUnloadDriver(
   PDRIVER_OBJECT DriverObject)
/*++

Description:
   unloads all devices for a given driver object

Arguments:
   DriverObject   context of driver

--*/
{
   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!StcUsbUnloadDriver\n",
      DRIVER_NAME));
}

void
SysDelay(
   ULONG Timeout
   )
/*++

SysDelay:
   performs a required delay.

Arguments:
   Timeout     delay in milli seconds

Return Value:
   void

--*/
{
   LARGE_INTEGER  SysTimeout;

   SysTimeout.QuadPart = (LONGLONG)-10 * 1000 * Timeout;

   // KeDelayExecutionThread: counted in 100 ns
   KeDelayExecutionThread( KernelMode, FALSE, &SysTimeout );
}


VOID 
StcUsbCardDetectionThread(
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_EXTENSION DeviceExtension)
/*++

StcUsbCardDetectionThread:
    create the card detection thread
Arguments:
    SmartcardExtension  context of call

Return Value:
    -

--*/
{
   NTSTATUS                NTStatus = STATUS_SUCCESS;
   PSMARTCARD_EXTENSION    SmartcardExtension  = &DeviceExtension->SmartcardExtension;
   LARGE_INTEGER           Timeout;

   SmartcardDebug( 
      DEBUG_TRACE, 
      ("%s!StcUsbCardDetectionThread\n",
      DRIVER_NAME));

   __try
   {
      NTStatus = SmartcardAcquireRemoveLock(SmartcardExtension);

      if( NTStatus == STATUS_DELETE_PENDING )
         __leave;

      // wait for the mutex shared with the deviceiocontrol routine
      NTStatus = KeWaitForMutexObject(
         &DeviceExtension->hMutex,
         Executive,
         KernelMode,
         FALSE,
         NULL);
        
      if( NTStatus != STATUS_SUCCESS )
         __leave;

      CBUpdateCardState(SmartcardExtension);

      KeReleaseMutex( &DeviceExtension->hMutex, FALSE );

      SmartcardReleaseRemoveLock(SmartcardExtension);

      Timeout.QuadPart = -10000 * POLLING_PERIOD; 

      NTStatus = KeWaitForSingleObject(         
         &DeviceExtension->FinishPollThread,
         Executive,
         KernelMode,
         FALSE,
         &Timeout
         );

      // thread stopped?
      if( NTStatus == STATUS_SUCCESS )
         __leave;

      // queue the work item again
      IoQueueWorkItem(
         DeviceExtension->PollWorkItem,
         StcUsbCardDetectionThread,
         DelayedWorkQueue,
         DeviceExtension
         );
    }
    __finally
    {
        if( NTStatus != STATUS_TIMEOUT )
        {
            SmartcardDebug( 
                DEBUG_TRACE, 
                ("%s!StcUsbCardDetectionThread Terminate polling thread\n",
                DRIVER_NAME));

            KeSetEvent( &DeviceExtension->PollThreadStopped, 0, FALSE);
        }
    }
    return;
}



NTSTATUS
StcUsbStartPollThread( PDEVICE_EXTENSION DeviceExtension )
{
   NTSTATUS    NTStatus = STATUS_SUCCESS;

   KeClearEvent( &DeviceExtension->FinishPollThread );
   KeClearEvent( &DeviceExtension->PollThreadStopped );

   // queue the work item again
   IoQueueWorkItem(
      DeviceExtension->PollWorkItem,
      StcUsbCardDetectionThread,
      DelayedWorkQueue,
      DeviceExtension
      );

   return( NTStatus );
}


VOID
StcUsbStopPollThread( PDEVICE_EXTENSION DeviceExtension )
{
   NTSTATUS    NTStatus = STATUS_SUCCESS;

   if( DeviceExtension->PollWorkItem )
   {
      //  notify the card detection thread to finish. This will kick the thread out of the wait
      KeSetEvent( &DeviceExtension->FinishPollThread, 0, FALSE );
      KeWaitForSingleObject(
          &DeviceExtension->PollThreadStopped,
          Executive,
          KernelMode,
          FALSE,
          0
          );
   }
   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\stcusb\usbcom.c ===
/*++

Copyright (c) 1997 SCM Microsystems, Inc.

Module Name:

    usbcom.c

Abstract:

   Hardware access functions for USB smartcard reader


Environment:

      WDM

Revision History:

   PP       01/19/1999  1.01
   PP       12/18/1998  1.00  Initial Version


--*/


#include "common.h"
#include "stcCmd.h"
#include "usbcom.h"
#include "stcusbnt.h"

#pragma optimize( "", off )



NTSTATUS STCtoNT(
   UCHAR ucData[])
/*++

Routine Description:
   Error code translation routine

Arguments:
   ucData   Error code returned by the STC

Return Value:
   Corresponding NT error code

--*/
{
   USHORT usCode = ucData[0]*0x100 +ucData[1];
   NTSTATUS NtStatus;


   switch (usCode)
   {
      case 0x9000:
         NtStatus = STATUS_SUCCESS;
         break;
      case 0x5800:
         NtStatus = STATUS_UNSUCCESSFUL;
         break;
      case 0x2000:
         NtStatus = STATUS_UNSUCCESSFUL;
         break;
      case 0x4000:
         NtStatus = STATUS_UNSUCCESSFUL;
         break;
      case 0x64A1:
         NtStatus = STATUS_NO_MEDIA;
         break;
      case 0x64A0:
         NtStatus = STATUS_MEDIA_CHANGED;
         break;
      case 0x6203:
         NtStatus = STATUS_UNSUCCESSFUL;
         break;
      case 0x6300:
         NtStatus = STATUS_UNSUCCESSFUL;
         break;
      case 0x6500:
         NtStatus = STATUS_UNSUCCESSFUL;
         break;
      case 0x6A00:
         NtStatus = STATUS_UNSUCCESSFUL;
         break;
      case 0x6A80:
         NtStatus = STATUS_UNSUCCESSFUL;
         break;
      default:
         NtStatus = STATUS_UNSUCCESSFUL;
         break;
   }
   return(NtStatus);
}


//******************************************************************************
//
// UsbSyncCompletionRoutine()
//
// Completion routine used by UsbCallUSBD.
//
// Signals an Irp completion event and then returns MORE_PROCESSING_REQUIRED
// to stop further completion of the Irp.
//
// If the Irp is one we allocated ourself, DeviceObject is NULL.
//
//******************************************************************************

NTSTATUS
UsbSyncCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PKEVENT kevent;

    kevent = (PKEVENT)Context;

    KeSetEvent(kevent,
               IO_NO_INCREMENT,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

//******************************************************************************
//
// UsbCallUSBD()
//
// Synchronously sends a URB down the device stack.  Blocks until the request
// completes normally or until the request is timed out and cancelled.
//
// Must be called at IRQL PASSIVE_LEVEL
//
//******************************************************************************

NTSTATUS
UsbCallUSBD (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PURB             Urb
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    KEVENT              localevent;
    PIRP                irp;
    PIO_STACK_LOCATION  nextStack;
    NTSTATUS            ntStatus;

    deviceExtension = DeviceObject->DeviceExtension;

    // Initialize the event we'll wait on
    //
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

    // Allocate the Irp
    //
    irp = IoAllocateIrp(deviceExtension->AttachedPDO->StackSize,
                        FALSE);

    if (irp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Set the Irp parameters
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_SUBMIT_URB;

    nextStack->Parameters.Others.Argument1 = Urb;

    // Set the completion routine, which will signal the event
    //
    IoSetCompletionRoutine(irp,
                           UsbSyncCompletionRoutine,
                           &localevent,
                           TRUE,    // InvokeOnSuccess
                           TRUE,    // InvokeOnError
                           TRUE);   // InvokeOnCancel

    // Pass the Irp & Urb down the stack
    //
    ntStatus = IoCallDriver(deviceExtension->AttachedPDO,
                            irp);

    // If the request is pending, block until it completes
    //
    if (ntStatus == STATUS_PENDING)
    {
        LARGE_INTEGER timeout;

        // We used to wait for 1 second, but that made this timeout longer
        // than the polling period of 500ms.  So, if this read failed (e.g.,
        // because of device or USB failure) and timeout, two more worker items
        // would get queued and eventually hundreds of working items would be
        // backed up.  By reducing this timeout we have a good chance that this
        // will finish before the next item is queued.  450ms seems a good value.
        //
        timeout.QuadPart = -4500000; // 450ms

        ntStatus = KeWaitForSingleObject(&localevent,
                                         Executive,
                                         KernelMode,
                                         FALSE,
                                         &timeout);

        if (ntStatus == STATUS_TIMEOUT)
        {
            ntStatus = STATUS_IO_TIMEOUT;

            // Cancel the Irp we just sent.
            //
            IoCancelIrp(irp);

            // And wait until the cancel completes
            //
            KeWaitForSingleObject(&localevent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
        else
        {
            ntStatus = irp->IoStatus.Status;
        }
    }

    // Done with the Irp, now free it.
    //
    IoFreeIrp(irp);

    // If the request was not sucessful, delay for 1 second.  (Why?)
    //
    if (ntStatus != STATUS_SUCCESS)
    {
        SysDelay(1000);
    }

    return ntStatus;
}

NTSTATUS
UsbSelectInterfaces(
   IN PDEVICE_OBJECT DeviceObject,
   IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor)
/*++

Routine Description:
    Initializes an USB reader with (possibly) multiple interfaces;
   This driver only supports one interface (with multiple endpoints).


Arguments:
    DeviceObject - pointer to the device object for this instance of the device.

    ConfigurationDescriptor - pointer to the USB configuration
                    descriptor containing the interface and endpoint
                    descriptors.


Return Value:

    NT status code

--*/
{
   PDEVICE_EXTENSION DeviceExtension= DeviceObject->DeviceExtension;
   NTSTATUS NtStatus;
   PURB pUrb = NULL;
   USHORT usSize;
   ULONG  ulNumberOfInterfaces, i;
   UCHAR ucNumberOfPipes, ucAlternateSetting, ucMyInterfaceNumber;
   PUSB_INTERFACE_DESCRIPTOR InterfaceDescriptor;
   PUSBD_INTERFACE_INFORMATION InterfaceObject;

    // This driver only supports one interface, we must parse
    // the configuration descriptor for the interface
    // and remember the pipes.
    //

    pUrb = USBD_CreateConfigurationRequest(ConfigurationDescriptor, &usSize);

   if (pUrb)
   {
      //
      // USBD_ParseConfigurationDescriptorEx searches a given configuration
      // descriptor and returns a pointer to an interface that matches the
      //  given search criteria. We only support one interface on this device
      //
        InterfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
         ConfigurationDescriptor,
         ConfigurationDescriptor, //search from start of config  descriptro
         -1,   // interface number not a criteria; we only support one interface
         -1,   // not interested in alternate setting here either
         -1,   // interface class not a criteria
         -1,   // interface subclass not a criteria
         -1);  // interface protocol not a criteria

      ASSERT( InterfaceDescriptor != NULL );

      InterfaceObject = &pUrb->UrbSelectConfiguration.Interface;

      for (i = 0; i < InterfaceObject->NumberOfPipes; i++)
      {
         InterfaceObject->Pipes[i].PipeFlags = 0;
        }

        UsbBuildSelectConfigurationRequest(
         pUrb,
         usSize,
         ConfigurationDescriptor);

      NtStatus = UsbCallUSBD(DeviceObject, pUrb);
    }
   else
   {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if(NtStatus == STATUS_SUCCESS)
   {

      // Save the configuration handle for this device
        DeviceExtension->ConfigurationHandle =
            pUrb->UrbSelectConfiguration.ConfigurationHandle;

      ASSERT(DeviceExtension->Interface == NULL);

        DeviceExtension->Interface = ExAllocatePool(
         NonPagedPool,
            InterfaceObject->Length
         );

        if (DeviceExtension->Interface)
      {
            // save a copy of the interface information returned
            RtlCopyMemory(
            DeviceExtension->Interface,
            InterfaceObject,
            InterfaceObject->Length);
      }
      else
      {
         NtStatus = STATUS_NO_MEMORY;
      }
    }

    if (pUrb)
   {
        ExFreePool(pUrb);
    }

    return NtStatus;
}

NTSTATUS
UsbConfigureDevice(
   IN PDEVICE_OBJECT DeviceObject)
/*++

Routine Description:
    Initializes a given instance of the device on the USB and
   selects and saves the configuration.

Arguments:

   DeviceObject - pointer to the physical device object for this instance of the device.


Return Value:

    NT status code


--*/
{
   PDEVICE_EXTENSION DeviceExtension= DeviceObject->DeviceExtension;
   NTSTATUS NtStatus;
   PURB pUrb = NULL;
   ULONG ulSize;
   PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor = NULL;

   __try {

      pUrb = ExAllocatePool(
         NonPagedPool,
         sizeof( struct _URB_CONTROL_DESCRIPTOR_REQUEST )
         );

      if( pUrb == NULL)
      {
         NtStatus = STATUS_NO_MEMORY;
         __leave;
      }

      // When USB_CONFIGURATION_DESCRIPTOR_TYPE is specified for DescriptorType
      // in a call to UsbBuildGetDescriptorRequest(),
      // all interface, endpoint, class-specific, and vendor-specific descriptors
      // for the configuration also are retrieved.
      // The caller must allocate a buffer large enough to hold all of this
      // information or the data is truncated without error.
      // Therefore the 'siz' set below is just a 'good guess', and we may have to retry
        ulSize = sizeof( USB_CONFIGURATION_DESCRIPTOR ) + 16;

       // We will break out of this 'retry loop' when UsbBuildGetDescriptorRequest()
      // has a big enough deviceExtension->UsbConfigurationDescriptor buffer not to truncate
      while( 1 )
      {
         ConfigurationDescriptor = ExAllocatePool( NonPagedPool, ulSize );

         if(ConfigurationDescriptor == NULL)
         {
            NtStatus = STATUS_NO_MEMORY;
            __leave;
         }

         UsbBuildGetDescriptorRequest(
            pUrb,
            sizeof( struct _URB_CONTROL_DESCRIPTOR_REQUEST ),
            USB_CONFIGURATION_DESCRIPTOR_TYPE,
            0,
            0,
            ConfigurationDescriptor,
            NULL,
            ulSize,
            NULL );

         NtStatus = UsbCallUSBD( DeviceObject, pUrb );

         // if we got some data see if it was enough.
         // NOTE: we may get an error in URB because of buffer overrun
         if (pUrb->UrbControlDescriptorRequest.TransferBufferLength == 0 ||
            ConfigurationDescriptor->wTotalLength <= ulSize)
         {
            break;
         }

         ulSize = ConfigurationDescriptor->wTotalLength;
         ExFreePool(ConfigurationDescriptor);
         ConfigurationDescriptor = NULL;
      }

      //
      // We have the configuration descriptor for the configuration we want.
      // Now we issue the select configuration command to get
      // the  pipes associated with this configuration.
      //
      if(NT_SUCCESS(NtStatus))
      {
          NtStatus = UsbSelectInterfaces(
             DeviceObject,
             ConfigurationDescriptor);
      }
   }
   __finally {

      if( pUrb )
      {
         ExFreePool( pUrb );
      }
      if( ConfigurationDescriptor )
      {
         ExFreePool( ConfigurationDescriptor );
      }
   }

   return NtStatus;
}

NTSTATUS
UsbWriteSTCData(
   PREADER_EXTENSION ReaderExtension,
   PUCHAR            pucData,
   ULONG          ulSize)

/*++

Routine Description:
   Write data in the STC

Arguments:
   ReaderExtension   Context of the call
   APDU        Buffer to write
   ulAPDULen      Length of the buffer to write
Return Value:

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   PUCHAR pucCmd;
   UCHAR ucResponse[3];
   BOOLEAN resend = TRUE;
   LONG Len;
   ULONG Index;
   LONG refLen = (LONG) ulSize;
   ULONG Retries;

   pucCmd = ExAllocatePool( NonPagedPool, MIN_BUFFER_SIZE);

   if(pucCmd == NULL)
   {
      return STATUS_NO_MEMORY;
   }

   ReaderExtension->ulReadBufferLen = 0;

   // Build the write data command
   Len = refLen;
   Index = 0;

   while (resend == TRUE)
   {
      if(Len > 62)
      {
         Len = 62;
         resend = TRUE;
      }
      else
      {
         resend = FALSE;
      }

      *pucCmd = 0xA0;
      *(pucCmd+1) = (UCHAR) Len;
      memcpy( pucCmd + 2, pucData+Index, Len );

	  Retries = USB_WRITE_RETRIES;
	  do
	  {
         // Send the Write data command
         NTStatus = UsbWrite( ReaderExtension, pucCmd, 2 + Len);
         if (NTStatus != STATUS_SUCCESS)
		 {
            SmartcardDebug(
               DEBUG_DRIVER,
               ("%s!UsbWriteSTCData: write error %X \n",
               DRIVER_NAME,
               NTStatus)
               );
            break;
		 }
         // Read the response
         NTStatus = UsbRead( ReaderExtension, ucResponse, 3);
         if (NTStatus != STATUS_SUCCESS)
		 {
            SmartcardDebug(
               DEBUG_DRIVER,
               ("%s!UsbWriteSTCData: read error %X \n",
               DRIVER_NAME,
               NTStatus)
               );
            break;
		 }
         else
		 {
             // Test if what we read is really a response to a write
            if(ucResponse[0] != 0xA0)
			{
               NTStatus = STCtoNT(ucResponse);
			}
		 }
	  } while(( NTStatus != STATUS_SUCCESS ) && --Retries );

	  if( NTStatus != STATUS_SUCCESS )
		  break;

      Index += 62;
      Len = refLen - 62;
      refLen = refLen - 62;
   }

   ExFreePool( pucCmd );
   return STATUS_SUCCESS;
}

NTSTATUS
UsbReadSTCData(
   PREADER_EXTENSION    ReaderExtension,
   PUCHAR               pucData,
   ULONG             ulDataLen)

/*++

Routine Description:
   Read data from the STC

Arguments:
   ReaderExtension   Context of the call
   ulAPDULen      Length of the buffer to write
   pucData        Output Buffer


Return Value:

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR       ucCmd[1];
   PUCHAR      pucResponse;
   int i;
   ULONG ulLenExpected = ulDataLen;
   ULONG Index=0;
   BOOLEAN  SendReadCommand = TRUE;
   LARGE_INTEGER  Begin;
   LARGE_INTEGER  End;

   pucResponse  = ExAllocatePool( NonPagedPool, MIN_BUFFER_SIZE);
   if(pucResponse == NULL)
   {
      return STATUS_NO_MEMORY;
   }

   KeQuerySystemTime( &Begin );
   End = Begin;
   End.QuadPart = End.QuadPart + (LONGLONG)10 * 1000 * ReaderExtension->ReadTimeout;

   // First let see if we have not already read the data that
   // we need
   if(ReaderExtension->ulReadBufferLen != 0)
   {
      if(ReaderExtension->ulReadBufferLen >= ulLenExpected)
      {
         // all the data that we need are available
         memcpy(pucData,ReaderExtension->ucReadBuffer,ulLenExpected);
         ReaderExtension->ulReadBufferLen = ReaderExtension->ulReadBufferLen - ulLenExpected;
         if(ReaderExtension->ulReadBufferLen != 0)
         {
            memcpy(
               ReaderExtension->ucReadBuffer,
               ReaderExtension->ucReadBuffer+ulLenExpected,
               ReaderExtension->ulReadBufferLen);
         }
         SendReadCommand = FALSE;
      }
      else
      {
         // all the data that we need are not available
         memcpy(pucData,ReaderExtension->ucReadBuffer,ReaderExtension->ulReadBufferLen);
         ulLenExpected = ulLenExpected - ReaderExtension->ulReadBufferLen;
         Index = ReaderExtension->ulReadBufferLen;
         ReaderExtension->ulReadBufferLen = 0;
         SendReadCommand = TRUE;
      }
   }
   while( SendReadCommand == TRUE)
   {
      // Build the Read Register command
      ucCmd[0] = 0xE0;

      NTStatus = UsbWrite( ReaderExtension, ucCmd, 1);
      if (NTStatus != STATUS_SUCCESS)
      {
         SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!UsbReadSTCData: write error %X \n",
            DRIVER_NAME,
            NTStatus)
            );
         break;
      }

      NTStatus = UsbRead( ReaderExtension, pucResponse, 64);
      if (NTStatus != STATUS_SUCCESS)
      {
         SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!UsbReadSTCData: read error %X \n",
            DRIVER_NAME,
            NTStatus)
            );
         break;
      }
      // Test if what we read is really a READ DATA frame
      if(*pucResponse != 0xE0)
      {
         if(*pucResponse == 0x64 && *(pucResponse + 1) == 0xA0)
         {
            NTStatus = STATUS_NO_MEDIA;
         }
         else
         {
            NTStatus = STCtoNT(pucResponse);
         }
         break;
      }
      // If there is no data available
      if (*(pucResponse + 1) == 0)
      {
         KeQuerySystemTime( &Begin );
         if(RtlLargeIntegerGreaterThan(End, Begin))
         {
            SendReadCommand = TRUE;
         }
         else
         {
            ReaderExtension->ulReadBufferLen = 0;
            SmartcardDebug(
               DEBUG_DRIVER,
               ("%s!UsbReadSTCData: Timeout %X \n",
               DRIVER_NAME,
               STATUS_IO_TIMEOUT));
            NTStatus =STATUS_IO_TIMEOUT;
            break;
         }
      }
      if ((ULONG) *(pucResponse+1) < ulLenExpected)
      {
         memcpy(pucData+Index,pucResponse+2,(ULONG) *(pucResponse+1));
         Index = Index + (ULONG) *(pucResponse+1);
         ulLenExpected = ulLenExpected - (ULONG) *(pucResponse+1);
         SendReadCommand = TRUE;
      }
      else
      {
         SendReadCommand = FALSE;
         memcpy(pucData+Index,pucResponse+2,ulLenExpected);

         if((ULONG) *(pucResponse+1) > ulLenExpected)
         {
            memcpy(
               ReaderExtension->ucReadBuffer,
               pucResponse+ulLenExpected+2,
               (ULONG) *(pucResponse+1) - ulLenExpected);

            ReaderExtension->ulReadBufferLen =
               (ULONG) *(pucResponse+1) - ulLenExpected;
         }
         else
         {
            ReaderExtension->ulReadBufferLen = 0;
         }
      }
   }

   ExFreePool( pucResponse );
   return NTStatus;
}

NTSTATUS
UsbWriteSTCRegister(
   PREADER_EXTENSION ReaderExtension,
   UCHAR          ucAddress,
   ULONG          ulSize,
   PUCHAR            pucValue)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   PUCHAR pucCmd;
   UCHAR ucResponse[2];

   if(ulSize > 16)
   {
      return STATUS_UNSUCCESSFUL;
   }

   pucCmd = ExAllocatePool( NonPagedPool, MAX_READ_REGISTER_BUFFER_SIZE);
   if(pucCmd == NULL)
   {
      return STATUS_NO_MEMORY;
   }
   ReaderExtension->ulReadBufferLen = 0;

   // Build the write register command
   *pucCmd = 0x80 | ucAddress;
   *(pucCmd+1) = (UCHAR) ulSize;
   memcpy( pucCmd + 2, pucValue, ulSize );

   // Send the Write Register command
   NTStatus = UsbWrite( ReaderExtension, pucCmd, 2 + ulSize);
   if (NTStatus == STATUS_SUCCESS)
   {
      // Read the acknowledge
      NTStatus = UsbRead( ReaderExtension, ucResponse, 2);
      if (NTStatus == STATUS_SUCCESS)
      {
         NTStatus = STCtoNT(ucResponse);
      }
   }

   ExFreePool( pucCmd );
   return NTStatus;
}

NTSTATUS
UsbReadSTCRegister(
   PREADER_EXTENSION ReaderExtension,
   UCHAR          ucAddress,
   ULONG          ulSize,
   PUCHAR            pucValue)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR       ucCmd[2];
   PUCHAR      pucResponse;

   if(ulSize > 16)
   {
      return STATUS_UNSUCCESSFUL;
   }

   pucResponse = ExAllocatePool(
      NonPagedPool,
      MAX_READ_REGISTER_BUFFER_SIZE
      );

   if(pucResponse == NULL)
   {
      return STATUS_NO_MEMORY;
   }

   // Build the Read Register command
   ucCmd[0] = 0xC0 | ucAddress;
   ucCmd[1] = (UCHAR) ulSize;

   // Send the Read Register command
   NTStatus = UsbWrite( ReaderExtension, ucCmd, 2);
   if (NTStatus == STATUS_SUCCESS)
   {
      // Read the response from the reader
      NTStatus = UsbRead(
         ReaderExtension,
         pucResponse,
         6
         );

      if (NTStatus == STATUS_SUCCESS)
      {
         // Test if what we read is really a READ frame
         if(*pucResponse == 0x21)
         {
            if(*(pucResponse + 1) > 16)
            {
               NTStatus = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
               memcpy(
                  pucValue,
                  pucResponse + 2,
                  (ULONG) *(pucResponse + 1)
                  );
            }
         }
         else
         {
            NTStatus = STCtoNT(pucResponse);
         }
      }
   }

   ExFreePool( pucResponse );
   return NTStatus;
}

NTSTATUS
UsbGetFirmwareRevision(
   PREADER_EXTENSION ReaderExtension)
/*++
Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR       ucCmd[1];
   UCHAR    ucResponse[4];

   ucCmd[0] = 0xE1;
   NTStatus = UsbWrite( ReaderExtension, ucCmd, 2 );

   if( NTStatus == STATUS_SUCCESS )
   {
      ReaderExtension->ReadTimeout = 1000;
      NTStatus = UsbRead( ReaderExtension, ucResponse, 4 );

      if( NTStatus == STATUS_SUCCESS )
      {
         ReaderExtension->FirmwareMajor = ucResponse[ 2 ];
         ReaderExtension->FirmwareMinor = ucResponse[ 3 ];
      }
   }
   return NTStatus ;
}


NTSTATUS
UsbRead(
   PREADER_EXTENSION ReaderExtension,
   PUCHAR            pData,
   ULONG          DataLen  )
/*++
Description:
   Read data on the USB bus

Arguments:
   ReaderExtension   context of call
   pData       ptr to data buffer
   DataLen        length of data buffer
   pNBytes        number of bytes returned

Return Value:
   STATUS_SUCCESS
   STATUS_BUFFER_TOO_SMALL
   STATUS_UNSUCCESSFUL

--*/
{
   NTSTATUS NtStatus = STATUS_SUCCESS;
   PURB pUrb;
   USBD_INTERFACE_INFORMATION* pInterfaceInfo;
   USBD_PIPE_INFORMATION* pPipeInfo;
   PDEVICE_OBJECT DeviceObject = ReaderExtension->DeviceObject;
   PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
   ULONG ulSize;

   pInterfaceInfo = DeviceExtension->Interface;

   ASSERT(pInterfaceInfo != NULL);

   if (pInterfaceInfo == NULL) {

      // The device has likely been disconnected during hibernate / stand by
      return STATUS_DEVICE_NOT_CONNECTED;
   }

   // Read pipe number is 0 on this device
   pPipeInfo = &( pInterfaceInfo->Pipes[ 0 ] );

   ulSize = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
   pUrb = ExAllocatePool( NonPagedPool, ulSize );

   if(pUrb == NULL)
   {
      return STATUS_NO_MEMORY;
   }
   else
   {
      UsbBuildInterruptOrBulkTransferRequest(
         pUrb,
         (USHORT)ulSize,
         pPipeInfo->PipeHandle,
         pData,
         NULL,
         DataLen,
         USBD_SHORT_TRANSFER_OK,
         NULL
         );

      NtStatus = UsbCallUSBD( DeviceObject, pUrb );
      ExFreePool( pUrb );
   }

   return NtStatus;
}

NTSTATUS
UsbWrite(
   PREADER_EXTENSION ReaderExtension,
   PUCHAR            pData,
   ULONG          DataLen)
/*++
Description:
   Write data on the usb port

Arguments:
   ReaderExtension   context of call
   pData          ptr to data buffer
   DataLen           length of data buffer (exclusive LRC!)

Return Value:
   return value of

--*/
{
   NTSTATUS NtStatus = STATUS_SUCCESS;
   PURB pUrb;
   USBD_INTERFACE_INFORMATION* pInterfaceInfo;
   USBD_PIPE_INFORMATION* pPipeInfo;
   PDEVICE_OBJECT DeviceObject = ReaderExtension->DeviceObject;
   PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
   ULONG ulSize;

   pInterfaceInfo = DeviceExtension->Interface;

   ASSERT(pInterfaceInfo != NULL);

   if (pInterfaceInfo == NULL) {

      // The device has likely been disconnected during hibernate / stand by
      return STATUS_DEVICE_NOT_CONNECTED;
   }

   // Write pipe number is 1 on this device
   pPipeInfo = &( pInterfaceInfo->Pipes[ 1 ] );

   ulSize = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
   pUrb = ExAllocatePool( NonPagedPool, ulSize );
   if(pUrb == NULL)
   {
      NtStatus = STATUS_NO_MEMORY;
   }
   else
   {
      UsbBuildInterruptOrBulkTransferRequest(
         pUrb,
         (USHORT)ulSize,
         pPipeInfo->PipeHandle,
         pData,
         NULL,
         DataLen,
         USBD_SHORT_TRANSFER_OK,
         NULL );

      NtStatus = UsbCallUSBD( DeviceObject, pUrb );
      ExFreePool( pUrb );
   }
   return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\stcusb\usbcom.h ===
/*++

Copyright (c) 1998 SCM Microsystems, Inc.

Module Name:

    UsbCom.h

Abstract:

	Constants & access function prototypes for USB  smartcard reader


Revision History:

	PP			12/18/1998	Initial Version

--*/

#if !defined( __USB_COM_H__ )
#define __USB_COM_H__

//
//	Prototypes for access functions -------------------------------------------
//
NTSTATUS
UsbResetDevice(
    IN PDEVICE_OBJECT DeviceObject
    );
NTSTATUS 
UsbCallUSBD( 
	IN PDEVICE_OBJECT DeviceObject, 
	IN PURB pUrb);

NTSTATUS 
UsbConfigureDevice( 
	IN PDEVICE_OBJECT DeviceObject);


NTSTATUS
UsbWriteSTCData(
	PREADER_EXTENSION	ReaderExtension,
	PUCHAR				pucData,
	ULONG				ulSize);

NTSTATUS
UsbReadSTCData(
	PREADER_EXTENSION	ReaderExtension,
	PUCHAR				pucData,
	ULONG				ulDataLen);

NTSTATUS
UsbWriteSTCRegister(
	PREADER_EXTENSION	ReaderExtension,
	UCHAR				ucAddress,
	ULONG				ulSize,
	PUCHAR				pucValue);

NTSTATUS
UsbReadSTCRegister(
	PREADER_EXTENSION	ReaderExtension,
	UCHAR				ucAddress,
	ULONG				ulSize,
	PUCHAR				pucValue);

NTSTATUS
UsbGetFirmwareRevision(
	PREADER_EXTENSION	ReaderExtension);

NTSTATUS
UsbRead( 
	PREADER_EXTENSION	ReaderExtension,
	PUCHAR				pData,
	ULONG				DataLen);

NTSTATUS
UsbWrite( 
	PREADER_EXTENSION	ReaderExtension,
	PUCHAR				pData,
	ULONG				DataLen);

NTSTATUS
UsbSend( 
	PREADER_EXTENSION	ReaderExtension,
	PUCHAR				pDataIn,
	ULONG				DataLenIn,
	PUCHAR				pDataOut,
	ULONG				DataLenOut);


#endif	//	__USB_COM_H__

//	------------------------------- END OF FILE -------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\addfilter\addfilter.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    addfilter.c

Abstract:

    This command line utility adds and removes upper filter drivers
    for a given drive or volume

Author:

    Benjamin Strautin (t-bensta)

Environment:

    User mode only

Notes:

    - the filter is not checked for validity before it is added to the driver
      stack; if an invalid filter is added, the device may no longer be
      accessible.
    - all code works irrespective of character set (ANSI, Unicode, ...)

Revision History:

    05-24-99 : created

--*/

#include <windows.h>
#include <stdio.h>
#include <malloc.h>

// defines GUID
#include <initguid.h>

// the SetupDiXXX api (from the DDK)
#include <setupapi.h>

// defines guids for device classes (DiskClassGuid, etc)
#include <devioctl.h>
#include <ntddstor.h>

// for all of the _t stuff (to allow compiling for both Unicode/Ansi)
#include <tchar.h>


#if DBG
#include <assert.h>
#define ASSERT(condition) assert(condition)
#else
#define ASSERT(condition)
#endif

BOOLEAN
AddFilterDriver(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR Filter,
    IN BOOLEAN UpperFilter
    );

BOOLEAN
RemoveFilterDriver(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR Filter,
    IN BOOLEAN UpperFilter
    );

void
PrintFilters(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOLEAN UpperFilters
    );

LPTSTR
GetFilters(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOLEAN UpperFilters
    );

void PrintDeviceName(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );

BOOLEAN
DeviceNameMatches(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR DeviceName
    );

PBYTE
GetDeviceRegistryProperty(
    IN  HDEVINFO DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD Property,
    OUT PDWORD PropertyRegDataType
    );

BOOLEAN
RestartDevice(
    IN HDEVINFO DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    );

BOOLEAN
PrependSzToMultiSz(
    IN     LPTSTR  SzToPrepend,
    IN OUT LPTSTR *MultiSz
    );

size_t
MultiSzLength(
    IN LPTSTR MultiSz
    );

size_t
MultiSzSearchAndDeleteCaseInsensitive(
    IN  LPTSTR  FindThis,
    IN  LPTSTR  FindWithin,
    OUT size_t  *NewStringLength
    );

void
PrintUsage();

// To add/remove filter drivers:
// - use SetupDiGetClassDevs to get a list of devices of the given interface
//   class
// - use SetupDiEnumDeviceInfo to enumerate the items in that list and
//   obtain a SP_DEVINFO_DATA
// - use SetupDiGetDeviceRegistryProperty to get the list of filter drivers
// - add/remove items in the filter list
// - use SetupDiSetDeviceRegistryProperty to put the list back in place
// To restart the device:
// - use SetupDiCallClassInstaller with DIF_PROPERTYCHANGE and DICS_STOP to
//   stop the device
// - use SetupDiCallClassInstaller with DIF_PROPERTYCHANGE and DICS_START to
//   restart the device

int __cdecl _tmain(int argc, _TCHAR ** argv, _TCHAR ** envp)
{
    // these two constants are used to help enumerate through the list of all
    // disks and volumes on the system. Adding another GUID should "just work"
    static const GUID * deviceGuids[] = {
        &DiskClassGuid,
        &VolumeClassGuid,
        &CdRomClassGuid
    };
    static const int numdeviceGuids = sizeof(deviceGuids) / sizeof(LPGUID);

    // structs needed to contain information about devices
    HDEVINFO                 devInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA          devInfoData;

    // indices for stepping through devices, and device interface guids
    int argIndex;
    int devGuidIndex;
    int deviceIndex;

    // variables used to deal with the command-line options of this program
    BOOLEAN listDevices   = FALSE;
    BOOLEAN upperFilter   = TRUE;

    LPTSTR deviceName     = NULL;
    LPTSTR filterToAdd    = NULL;
    LPTSTR filterToRemove = NULL;

    BOOLEAN keepGoing   = TRUE;
    BOOLEAN needReboot  = FALSE;
    BOOLEAN deviceMatch = FALSE;

    ////////////////////////////////////////////////
    // parse arguments; nothing too exciting here //
    ////////////////////////////////////////////////

    if( argc < 2 || _tcscmp(argv[1], _T("/?")) == 0 )
    {
        PrintUsage();
        return (0);
    }

    argIndex=1;

    for (argIndex = 1; argIndex < argc; argIndex++) {

        if( _tcscmp(argv[argIndex], _T("/listdevices")) == 0 ) {
            
            listDevices = TRUE;
        
        } else if( _tcscmp(argv[argIndex], _T("/lower")) == 0 ) {

            upperFilter = FALSE;
            printf("Using Lower Filters\n");

        } else if( _tcscmp(argv[argIndex], _T("/device")) == 0 ) {
            
            argIndex++;
            
            if( argIndex < argc ) {
                deviceName = argv[argIndex];
            } else {
                PrintUsage();
                return (0);
            }

        } else if( _tcscmp(argv[argIndex], _T("/add")) == 0 ) {

            argIndex++;
            
            if( argIndex<argc ) {
                filterToAdd = argv[argIndex];
            } else {
                PrintUsage();
                return (0);
            }
        
        } else if( _tcscmp(argv[argIndex], _T("/remove")) == 0 ) {
            
            argIndex++;
            if( argIndex<argc ) {
                filterToRemove = argv[argIndex];
            } else {
                PrintUsage();
                return (0);
            }

        } else {
            PrintUsage();
            return (0);
        }

    }

    //////////////////////////////////////////////////////
    // done parsing arguments, move onto the good stuff //
    //////////////////////////////////////////////////////

    // This outer loop steps through the array of device guid pointers that is
    // defined above main(). It was just the easiest way to deal with both
    // Disks and Volumes (and it is easy to add other types of devices)
    
    for(devGuidIndex = 0; devGuidIndex<numdeviceGuids; devGuidIndex++) {
        
        // get a list of devices which support the given interface
        devInfo = SetupDiGetClassDevs( deviceGuids[devGuidIndex],
                                       NULL,
                                       NULL,
                                       DIGCF_PROFILE |
                                       DIGCF_DEVICEINTERFACE |
                                       DIGCF_PRESENT );

        if( devInfo == INVALID_HANDLE_VALUE ) {
            printf("got INVALID_HANDLE_VALUE!\n");
            return (1);
        }

        // as per DDK docs on SetupDiEnumDeviceInfo
        devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        // step through the list of devices for this handle
        // get device info at index deviceIndex, the function returns FALSE
        // when there is no device at the given index.
        for( deviceIndex=0;
             SetupDiEnumDeviceInfo( devInfo, deviceIndex, &devInfoData );
             deviceIndex++ ) {
            
            // setting this variable to FALSE will cause all of the if
            // statements to fall through, cutting off processing for this
            // device.
            keepGoing = TRUE;

            // if a device name was specified, and it doesn't match this one,
            // stop. If there is a match (or no name was specified), mark that
            // there was a match.
            if( deviceName != NULL &&
                !DeviceNameMatches( devInfo, &devInfoData, deviceName )
                ) {
                
                keepGoing = FALSE;

            } else {
                
                deviceMatch = TRUE;

            }

            // print the device name
            if( keepGoing && listDevices ) {
                
                PrintDeviceName( devInfo, &devInfoData );

            }

            // print the drivers, if we are not adding or removing one
            if( keepGoing && filterToAdd == NULL && filterToRemove == NULL ) {
                
                PrintFilters( devInfo, &devInfoData, upperFilter );

            }

            // add the filter, then try to restart the device
            if( keepGoing && filterToAdd != NULL ) {
                
                if( !AddFilterDriver(devInfo,
                                     &devInfoData,
                                     filterToAdd,
                                     upperFilter)) {
                    
                    printf("Unable to add filter!\n");
                
                } else {
                    
                    if( !RestartDevice( devInfo, &devInfoData) ) {
                        needReboot = TRUE;
                    }

                }
            }

            // remove the filter, then try to restart the device
            if( keepGoing && filterToRemove != NULL ) {
                
                if( !RemoveFilterDriver(devInfo,
                                        &devInfoData,
                                        filterToRemove,
                                        upperFilter)) {

                    printf("Unable to remove filter!\n");

                } else {

                    if( !RestartDevice( devInfo, &devInfoData) ) {
                        needReboot = TRUE;
                    }

                }

            }

            if( listDevices )
            {
                printf("\n");
            }

            // end of main processing loop
        }

        // clean up the device list
        if( devInfo != INVALID_HANDLE_VALUE ) {
            
            if( !SetupDiDestroyDeviceInfoList( devInfo ) ) {
                printf("unable to delete device info list! error: %u\n",
                       GetLastError());
            }

        }

    } // loop for each GUID index

    if( !deviceMatch ) {
        
        printf("No devices matched that name\n");
    
    } else {
        
        if( needReboot ) {
            
            printf("One or more devices could not be restarted. The machine "
                   "must be restarted\n"
                   "in order for settings to take effect\n");
        
        } else {
            
            printf("Everything has completed normally.\n");

        }

    }

    return (0);
}


/*
 * add the given filter driver to the list of upper filter drivers for the
 * device.
 *
 * After the call, the device must be restarted in order for the new setting to
 * take effect. This can be accomplished with a call to RestartDevice(), or by
 * rebooting the machine.
 *
 * returns TRUE if successful, FALSE otherwise
 *
 * note: The filter is prepended to the list of drivers, which will put it at
 * the bottom of the filter driver stack
 *
 * parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 *   Filter         - the filter to add
 */
BOOLEAN
AddFilterDriver(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR Filter,
    IN BOOLEAN UpperFilter
    )
{
    size_t length = 0; // character length
    size_t size   = 0; // buffer size
    LPTSTR buffer = GetFilters( DeviceInfoSet, DeviceInfoData, UpperFilter );

    ASSERT(DeviceInfoData != NULL);
    ASSERT(Filter != NULL);

    if( buffer == NULL )
    {
        // if there is no such value in the registry, then there are no upper
        // filter drivers loaded, and we can just put one there

        // make room for the string, string null terminator, and multisz null
        // terminator
        length = _tcslen(Filter)+1;
        size   = (length+1)*sizeof(_TCHAR);
        buffer = malloc( size );
        if( buffer == NULL )
        {
            printf("in AddUpperFilterDriver(): unable to allocate memory!\n");
            return (FALSE);
        }
        memset(buffer, 0, size);

        // copy the string into the new buffer
        
        memcpy(buffer, Filter, length*sizeof(_TCHAR));

    }
    else
    {
        LPTSTR buffer2;
        // remove all instances of filter from driver list
        MultiSzSearchAndDeleteCaseInsensitive( Filter, buffer, &length );
        
        // allocate a buffer large enough to add the new filter
        // MultiSzLength already includes length of terminating NULL
        
        // determing the new length of the string
        length = MultiSzLength(buffer) + _tcslen(Filter) + 1;
        size   = length*sizeof(_TCHAR);
        
        buffer2 = malloc( size );
        if (buffer2 == NULL) {
            printf("Out of memory adding filter\n");
            return (0);
        }
        memset(buffer2, 0, size);
        
        // swap the buffers out
        memcpy(buffer2, buffer, MultiSzLength(buffer)*sizeof(_TCHAR));      
        free(buffer);
        buffer = buffer2;
        
        // add the driver to the driver list
        PrependSzToMultiSz(Filter, &buffer);
    
    }

    // set the new list of filters in place
    if( !SetupDiSetDeviceRegistryProperty( DeviceInfoSet,
                                           DeviceInfoData,
                                           (UpperFilter ? SPDRP_UPPERFILTERS : SPDRP_LOWERFILTERS),
                                           (PBYTE)buffer,
                                           (MultiSzLength(buffer)*sizeof(_TCHAR)) )
        )
    {
        printf("in AddUpperFilterDriver(): "
               "couldn't set registry value! error: %u\n", GetLastError());
        free( buffer );
        return (FALSE);
    }

    // no need for buffer anymore
    free( buffer );

    return (TRUE);
}


/*
 * remove all instances of the given filter driver from the list of upper
 * filter drivers for the device.
 *
 * After the call, the device must be restarted in order for the new setting to
 * take effect. This can be accomplished with a call to RestartDevice(), or by
 * rebooting the machine.
 *
 * returns TRUE if successful, FALSE otherwise
 *
 * parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 *   Filter - the filter to remove
 */
BOOLEAN
RemoveFilterDriver(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR Filter,
    IN BOOLEAN UpperFilter
    )
{
    size_t length  = 0;
    size_t size    = 0;
    LPTSTR buffer  = GetFilters( DeviceInfoSet, DeviceInfoData, UpperFilter );
    BOOL   success = FALSE;

    ASSERT(DeviceInfoData != NULL);
    ASSERT(Filter != NULL);

    if( buffer == NULL )
    {
        // if there is no such value in the registry, then there are no upper
        // filter drivers loaded, and we are done
        return (TRUE);
    }
    else
    {
        // remove all instances of filter from driver list
        MultiSzSearchAndDeleteCaseInsensitive( Filter, buffer, &length );
    }

    length = MultiSzLength(buffer);

    ASSERT ( length > 0 );

    if( length == 1 )
    {
        // if the length of the list is 1, the return value from
        // MultiSzLength() was just accounting for the trailing '\0', so we can
        // delete the registry key, by setting it to NULL.
        success = SetupDiSetDeviceRegistryProperty( DeviceInfoSet,
                                                    DeviceInfoData,
                                                    (UpperFilter ? SPDRP_UPPERFILTERS : SPDRP_LOWERFILTERS),
                                                    NULL,
                                                    0 );
    }
    else
    {
        // set the new list of drivers into the registry
        size = length*sizeof(_TCHAR);
        success = SetupDiSetDeviceRegistryProperty( DeviceInfoSet,
                                                    DeviceInfoData,
                                                    (UpperFilter ? SPDRP_UPPERFILTERS : SPDRP_LOWERFILTERS),
                                                    (PBYTE)buffer,
                                                    size );
    }

    // no need for buffer anymore
    free( buffer );

    if( !success )
    {
        printf("in RemoveUpperFilterDriver(): "
               "couldn't set registry value! error: %i\n", GetLastError());
        return (FALSE);
    }

    return (TRUE);
}

/*
 * print the list of upper filters for the given device
 *
 * parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 */
void
PrintFilters(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOLEAN UpperFilters
    )
{
    // get the list of filters
    LPTSTR buffer = GetFilters( DeviceInfoSet, DeviceInfoData, UpperFilters );
    size_t filterPosition;

    if( buffer == NULL )
    {
        // if there is no such value in the registry, then there are no upper
        // filter drivers loaded
        printf("There are no upper filter drivers loaded for this device.\n");
    }
    else
    {
        // go through the multisz and print out each driver
        filterPosition=0;
        while( *buffer != _T('\0') )
        {
            _tprintf(_T("%i: %s\n"), filterPosition, buffer);
            buffer += _tcslen(buffer)+1;
            filterPosition++;
        }

        // no need for buffer anymore
        free( buffer );
    }

    return;
}

/*
 * print the device name
 *
 * parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 */
void PrintDeviceName(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
{
    DWORD  regDataType;
    LPTSTR deviceName =
        (LPTSTR) GetDeviceRegistryProperty( DeviceInfoSet,
                                            DeviceInfoData,
                                            SPDRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                            &regDataType );

    if( deviceName != NULL )
    {
        // just to make sure we are getting the expected type of buffer
        if( regDataType != REG_SZ )
        {
            printf("in PrintDeviceName(): registry key is not an SZ!\n");
        }
        else
        {
            // if the device name starts with \Device, cut that off (all
            // devices will start with it, so it is redundant)

            if( _tcsncmp(deviceName, _T("\\Device"), 7) == 0 )
            {
                memmove(deviceName,
                        deviceName+7,
                        (_tcslen(deviceName)-6)*sizeof(_TCHAR) );
            }

            _tprintf(_T("%s\n"), deviceName);
        }
        free( deviceName );
    }
    else
    {
        printf("in PrintDeviceName(): registry key is NULL! error: %u\n",
               GetLastError());
    }

    return;
}

/*
 * Returns a buffer containing the list of upper filters for the device. (NULL
 * is returned if there is no buffer, or an error occurs)
 * The buffer must be freed by the caller.
 *
 * parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 */
LPTSTR
GetFilters(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOLEAN UpperFilters
    )
{
    DWORD  regDataType;
    LPTSTR buffer = (LPTSTR) GetDeviceRegistryProperty( DeviceInfoSet,
                                                        DeviceInfoData,
                                                        (UpperFilters ? SPDRP_UPPERFILTERS : SPDRP_LOWERFILTERS),
                                                        &regDataType );

    // just to make sure we are getting the expected type of buffer
    if( buffer != NULL && regDataType != REG_MULTI_SZ )
    {
        printf("in GetUpperFilters(): "
               "registry key is not a MULTI_SZ!\n");
        free( buffer );
        return (NULL);
    }

    return (buffer);
}

/*
 * return true if DeviceName matches the name of the device specified by
 * DeviceInfoData
 *
 * parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 *   DeviceName     - the name to try to match
 */
BOOLEAN
DeviceNameMatches(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR DeviceName
    )
{
    BOOLEAN matching = FALSE;
    DWORD   regDataType;

    // get the device name
    LPTSTR  deviceName =
        (LPTSTR) GetDeviceRegistryProperty( DeviceInfoSet,
                                            DeviceInfoData,
                                            SPDRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                            &regDataType );

    if( deviceName != NULL )
    {
        // just to make sure we are getting the expected type of buffer
        if( regDataType != REG_SZ )
        {
            printf("in DeviceNameMatches(): registry key is not an SZ!\n");
            matching = FALSE;
        }
        else
        {
            // if the device name starts with \Device, cut that off (all
            // devices will start with it, so it is redundant)

            if( _tcsncmp(deviceName, _T("\\Device"), 7) == 0 )
            {
                memmove(deviceName,
                        deviceName+7,
                        (_tcslen(deviceName)-6)*sizeof(_TCHAR) );
            }

            // do the strings match?
            matching = (_tcscmp(deviceName, DeviceName) == 0);
        }
        free( deviceName );
    }
    else
    {
        printf("in DeviceNameMatches(): registry key is NULL!\n");
        matching = FALSE;
    }

    return (matching);
}

/*
 * A wrapper around SetupDiGetDeviceRegistryProperty, so that I don't have to
 * deal with memory allocation anywhere else
 *
 * parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 *   Property       - which property to get (SPDRP_XXX)
 *   PropertyRegDataType - the type of registry property
 */
PBYTE
GetDeviceRegistryProperty(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD Property,
    OUT PDWORD PropertyRegDataType
    )
{
    DWORD length = 0;
    PBYTE buffer = NULL;

    // get the required length of the buffer
    if( SetupDiGetDeviceRegistryProperty( DeviceInfoSet,
                                          DeviceInfoData,
                                          Property,
                                          NULL,   // registry data type
                                          NULL,   // buffer
                                          0,      // buffer size
                                          &length // required size
        ) )
    {
        // we should not be successful at this point, so this call succeeding
        // is an error condition
        printf("in GetDeviceRegistryProperty(): "
               "call SetupDiGetDeviceRegistryProperty did not fail\n",
               GetLastError());
        return (NULL);
    }

    if( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
    {
        // this means there are no upper filter drivers loaded, so we can just
        // return.
        return (NULL);
    }

    // since we don't have a buffer yet, it is "insufficient"; we allocate
    // one and try again.
    buffer = malloc( length );
    if( buffer == NULL )
    {
        printf("in GetDeviceRegistryProperty(): "
               "unable to allocate memory!\n");
        return (NULL);
    }
    if( !SetupDiGetDeviceRegistryProperty( DeviceInfoSet,
                                           DeviceInfoData,
                                           Property,
                                           PropertyRegDataType,
                                           buffer,
                                           length,
                                           NULL // required size
        ) )
    {
        printf("in GetDeviceRegistryProperty(): "
               "couldn't get registry property! error: %i\n",
               GetLastError());
        free( buffer );
        return (NULL);
    }

    // ok, we are finally done, and can return the buffer
    return (buffer);
}


/*
 * restarts the given device
 *
 * call CM_Query_And_Remove_Subtree (to unload the driver)
 * call CM_Reenumerate_DevNode on the _parent_ (to reload the driver)
 *
 * parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 */
BOOLEAN
RestartDevice(
    IN HDEVINFO DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    )
{
    SP_PROPCHANGE_PARAMS params;
    SP_DEVINSTALL_PARAMS installParams;

    // for future compatibility; this will zero out the entire struct, rather
    // than just the fields which exist now
    memset(&params, 0, sizeof(SP_PROPCHANGE_PARAMS));

    // initialize the SP_CLASSINSTALL_HEADER struct at the beginning of the
    // SP_PROPCHANGE_PARAMS struct, so that SetupDiSetClassInstallParams will
    // work
    params.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    params.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;

    // initialize SP_PROPCHANGE_PARAMS such that the device will be stopped.
    params.StateChange = DICS_STOP;
    params.Scope       = DICS_FLAG_CONFIGSPECIFIC;
    params.HwProfile   = 0; // current profile

    // prepare for the call to SetupDiCallClassInstaller (to stop the device)
    if( !SetupDiSetClassInstallParams( DeviceInfoSet,
                                       DeviceInfoData,
                                       (PSP_CLASSINSTALL_HEADER) &params,
                                       sizeof(SP_PROPCHANGE_PARAMS)
        ) )
    {
        printf("in RestartDevice(): couldn't set the install parameters!");
        printf(" error: %u\n", GetLastError());
        return (FALSE);
    }

    // stop the device
    if( !SetupDiCallClassInstaller( DIF_PROPERTYCHANGE,
                                    DeviceInfoSet,
                                    DeviceInfoData )
        )
    {
        printf("in RestartDevice(): call to class installer (STOP) failed!");
        printf(" error: %u\n", GetLastError() );
        return (FALSE);
    }

    // restarting the device
    params.StateChange = DICS_START;

    // prepare for the call to SetupDiCallClassInstaller (to stop the device)
    if( !SetupDiSetClassInstallParams( DeviceInfoSet,
                                       DeviceInfoData,
                                       (PSP_CLASSINSTALL_HEADER) &params,
                                       sizeof(SP_PROPCHANGE_PARAMS)
        ) )
    {
        printf("in RestartDevice(): couldn't set the install parameters!");
        printf(" error: %u\n", GetLastError());
        return (FALSE);
    }

    // restart the device
    if( !SetupDiCallClassInstaller( DIF_PROPERTYCHANGE,
                                    DeviceInfoSet,
                                    DeviceInfoData )
        )
    {
        printf("in RestartDevice(): call to class installer (START) failed!");
        printf(" error: %u\n", GetLastError());
        return (FALSE);
    }

    installParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    // same as above, the call will succeed, but we still need to check status
    if( !SetupDiGetDeviceInstallParams( DeviceInfoSet,
                                        DeviceInfoData,
                                        &installParams )
        )
    {
        printf("in RestartDevice(): couldn't get the device install params!");
        printf(" error: %u\n", GetLastError() );
        return (FALSE);
    }

    // to see if the machine needs to be rebooted
    if( installParams.Flags & DI_NEEDREBOOT )
    {
        return (FALSE);
    }

    // if we get this far, then the device has been stopped and restarted
    return (TRUE);
}


/*
 * prepend the given string to a MultiSz
 *
 * returns true if successful, false if not (will only fail in memory
 * allocation)
 *
 * note: This WILL allocate and free memory, so don't keep pointers to the
 * MultiSz passed in.
 *
 * parameters:
 *   SzToPrepend - string to prepend
 *   MultiSz     - pointer to a MultiSz which will be prepended-to
 */
BOOLEAN
PrependSzToMultiSz(
    IN     LPTSTR  SzToPrepend,
    IN OUT LPTSTR *MultiSz
    )
{
    size_t szLen;
    size_t multiSzLen;
    LPTSTR newMultiSz = NULL;

    ASSERT(SzToPrepend != NULL);
    ASSERT(MultiSz != NULL);

    // get the size, in bytes, of the two buffers
    szLen = (_tcslen(SzToPrepend)+1)*sizeof(_TCHAR);
    multiSzLen = MultiSzLength(*MultiSz)*sizeof(_TCHAR);
    newMultiSz = (LPTSTR)malloc( szLen+multiSzLen );

    if( newMultiSz == NULL )
    {
        return (FALSE);
    }

    // recopy the old MultiSz into proper position into the new buffer.
    // the (char*) cast is necessary, because newMultiSz may be a wchar*, and
    // szLen is in bytes.

    memcpy( ((char*)newMultiSz) + szLen, *MultiSz, multiSzLen );

    // copy in the new string
    _tcscpy( newMultiSz, SzToPrepend );

    free( *MultiSz );
    *MultiSz = newMultiSz;

    return (TRUE);
}


/*
 * returns the length (in characters) of the buffer required to hold this
 * MultiSz, INCLUDING the trailing null.
 *
 * example: MultiSzLength("foo\0bar\0") returns 9
 *
 * note: since MultiSz cannot be null, a number >= 1 will always be returned
 *
 * parameters:
 *   MultiSz - the MultiSz to get the length of
 */
size_t
MultiSzLength(
    IN LPTSTR MultiSz
    )
{
    size_t len = 0;
    size_t totalLen = 0;

    ASSERT( MultiSz != NULL );

    // search for trailing null character
    while( *MultiSz != _T('\0') )
    {
        len = _tcslen(MultiSz)+1;
        MultiSz += len;
        totalLen += len;
    }

    // add one for the trailing null character
    return (totalLen+1);
}


/*
 * Deletes all instances of a string from within a multi-sz.
 *
 * parameters:
 *   FindThis        - the string to find and remove
 *   FindWithin      - the string having the instances removed
 *   NewStringLength - the new string length
 */
size_t
MultiSzSearchAndDeleteCaseInsensitive(
    IN  LPTSTR FindThis,
    IN  LPTSTR FindWithin,
    OUT size_t *NewLength
    )
{
    LPTSTR search;
    size_t currentOffset;
    DWORD  instancesDeleted;
    size_t searchLen;

    ASSERT(FindThis != NULL);
    ASSERT(FindWithin != NULL);
    ASSERT(NewLength != NULL);

    currentOffset = 0;
    instancesDeleted = 0;
    search = FindWithin;

    *NewLength = MultiSzLength(FindWithin);

    // loop while the multisz null terminator is not found
    while ( *search != _T('\0') )
    {
        // length of string + null char; used in more than a couple places
        searchLen = _tcslen(search) + 1;

        // if this string matches the current one in the multisz...
        if( _tcsicmp(search, FindThis) == 0 )
        {
            // they match, shift the contents of the multisz, to overwrite the
            // string (and terminating null), and update the length
            instancesDeleted++;
            *NewLength -= searchLen;
            memmove( search,
                     search + searchLen,
                     (*NewLength - currentOffset) * sizeof(TCHAR) );
        }
        else
        {
            // they don't mactch, so move pointers, increment counters
            currentOffset += searchLen;
            search        += searchLen;
        }
    }

    return (instancesDeleted);
}


/*
 * print usage
 */
void PrintUsage()
{
    printf("usage:\n\n"
           "addfilter"
           " [/listdevices]"
           " [/device device_name]"
           " [/add filter]"
           " [/remove filter]"
           " [/lower]"
           "\n\n");
    printf("If device_name is not supplied, settings will apply "
           "to all devices.\n");
    printf("If there is no /add or /remove argument, a list of currently"
           " installed drivers\n"
           "will be printed.\n");
    printf("The default is to process upper filters.  Use the /lower switch"
           " to process lower filters instead.\n");
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\cdaudio\cdaudio.h ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

--*/

#if DBG

//
// CdAudio debug level global variable
//

ULONG CdAudioDebug = 0;

//
// Remap CdDump to local routine
//

#define CdDump(X)  CdAudioDebugPrint X

VOID
CdAudioDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#else

#define CdDump(X)

#endif // DBG

#define CDAUDIO_NOT_ACTIVE   0
#define CDAUDIO_ATAPI        1
#define CDAUDIO_CDS535       2
#define CDAUDIO_CDS435       3
#define CDAUDIO_DENON        4
#define CDAUDIO_FUJITSU      5
#define CDAUDIO_HITACHI      6
#define CDAUDIO_HPCDR        7
#define CDAUDIO_NEC          8
#define CDAUDIO_PIONEER      9
#define CDAUDIO_PIONEER624  10
#define CDAUDIO_MAX_ACTIVE  10
//
// Registry values...
//
#define CDAUDIO_SEARCH_ACTIVE    0xFF
#define CDAUDIO_ACTIVE_KEY_NAME  (L"MapType")

#define CDAUDIO_NOT_PAUSED   0
#define CDAUDIO_PAUSED       1

//
// Device Extension
//

typedef struct _CD_DEVICE_EXTENSION {

    //
    // Target Device Object
    //

    PDEVICE_OBJECT TargetDeviceObject;

    //
    // Physical Device Object
    //
    PDEVICE_OBJECT TargetPdo;

    //
    // Back pointer to device object
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // paging path count
    //

    ULONG  PagingPathCount;
    KEVENT PagingPathCountEvent;

    //
    // A timer, DPC, and simple
    // synchronization to assert
    // on if non-serialized.
    //
    PRKDPC Dpc;
    PKTIMER Timer;
    LONG Sync;

    //
    // CdAudio active for this drive
    //

    UCHAR Active;

    //
    // For drives that don't support
    // PAUSE/RESUME (Denon), a flag
    // to signify when the drive is
    // paused.
    //

    UCHAR Paused;

    //
    // For drives that don't support
    // PAUSE/RESUME (Denon), this is the
    // current position on the disc when
    // a pause was last executed.  This is
    // stored in either BCD or binary,
    // depending on the drive.
    //

    UCHAR PausedM;
    UCHAR PausedS;
    UCHAR PausedF;

    //
    // For drives that don't support
    // PAUSE/RESUME (Denon), this is the
    // last "ending" position on the disc when
    // a play was last executed.  This is
    // stored in BCD or binary, depending on
    // the drive.
    //

    UCHAR LastEndM;
    UCHAR LastEndS;
    UCHAR LastEndF;

    //
    // Indicates the CD is currently playing music.
    //

    BOOLEAN PlayActive;

} CD_DEVICE_EXTENSION, *PCD_DEVICE_EXTENSION;

#define AUDIO_TIMEOUT 10
#define CD_DEVICE_EXTENSION_SIZE sizeof(CD_DEVICE_EXTENSION)
#define MAXIMUM_RETRIES 4

//
// Convert BCD character to decimal equivalent
//

#define BCD_TO_DEC(x) ((((x & 0xF0)>>4)*10) + (x & 0x0F))
#define DEC_TO_BCD(x) (((x / 10) << 4) + (x % 10))

//
// Defines for NEC CDR cdrom drives
//

#define NEC_READ_TOC_CODE           0xDE
#define NEC_AUDIO_TRACK_SEARCH_CODE 0xD8
#define NEC_PLAY_AUDIO_CODE         0xD9
#define NEC_STILL_CODE              0xDA
#define NEC_EJECT_CODE              0xDC
#define NEC_READ_SUB_Q_CHANNEL_CODE 0xDD
#define NEC_Q_CHANNEL_TRANSFER_SIZE 10

#define NEC_ENTER_PLAY_MODE         0x01
#define NEC_TYPE_LOGICAL            0x00
#define NEC_TYPE_ATIME              0x40
#define NEC_TYPE_TRACK_NUMBER       0x80
#define NEC_TYPE_NO_CHANGE          0xC0
#define NEC_PLAY_STEREO             0x03
#define NEC_TRANSFER_WHOLE_TOC      0x03
#define NEC_TOC_TYPE_DISK           0xA0
#define NEC_TOC_TYPE_SESSION        0xB0

//
// The NEC cdrom TOC size is:
//  2  bytes for size
//  10 bytes first track data
//  10 bytes last track data
//  10 bytes total disk data
//  10 bytes per track 99 track maximum.
//

#define NEC_CDROM_TOC_SIZE          1022

//
// NEC SENSE CODES
//

#define NEC_SCSI_ERROR_NO_DISC              0x0B
#define NEC_SCSI_ERROR_ILLEGAL_DISC         0x0C
#define NEC_SCSI_ERROR_TRAY_OPEN            0x0D
#define NEC_SCSI_ERROR_SEEK_ERROR           0x15
#define NEC_SCSI_ERROR_MUSIC_AREA           0x1D
#define NEC_SCSI_ERROR_DATA_AREA            0x1C
#define NEC_SCSI_ERROR_PARITY_ERROR         0x30
#define NEC_SCSI_ERROR_INVALID_COMMAND      0x20
#define NEC_SCSI_ERROR_INVALID_ADDRESS      0x21
#define NEC_SCSI_ERROR_INVALID_PARAMETER    0x22
#define NEC_SCSI_ERROR_INVALID_CMD_SEQUENCE 0x24
#define NEC_SCSI_ERROR_END_OF_VOLUME        0x25
#define NEC_SCSI_ERROR_MEDIA_CHANGED        0x28
#define NEC_SCSI_ERROR_DEVICE_RESET         0x29

//
// NEC 10-byte cdb definitions.
//

typedef union _NEC_CDB {

    //
    // NEC Read TOC CDB
    //

    struct _NEC_READ_TOC {
        UCHAR OperationCode;
        UCHAR Type : 2;
        UCHAR Reserved1 : 6;
        UCHAR TrackNumber;
        UCHAR Reserved2[6];
        UCHAR Control;
    } NEC_READ_TOC, *PNEC_READ_TOC;

    //
    // NEC Play CDB
    //

    struct _NEC_PLAY_AUDIO {
        UCHAR OperationCode;
        UCHAR PlayMode : 3;
        UCHAR Reserved1 : 5;
        UCHAR Minute;
        UCHAR Second;
        UCHAR Frame;
        UCHAR Reserved2[4];
        UCHAR Control;
    } NEC_PLAY_AUDIO, *PNEC_PLAY_AUDIO;

    //
    // NEC Seek Audio
    //

    struct _NEC_SEEK_AUDIO {
        UCHAR OperationCode;
        UCHAR Play : 1;
        UCHAR Reserved1 : 7;
        UCHAR Minute;
        UCHAR Second;
        UCHAR Frame;
        UCHAR Reserved2[4];
        UCHAR Control;
    } NEC_SEEK_AUDIO, *PNEC_SEEK_AUDIO;

    //
    // NEC Pause Audio
    //

    struct _NEC_PAUSE_AUDIO {
        UCHAR OperationCode;
        UCHAR Reserved1[8];
        UCHAR Control;
    } NEC_PAUSE_AUDIO, *PNEC_PAUSE_AUDIO;

    //
    // NEC Read Q Channel
    //

    struct _NEC_READ_Q_CHANNEL {
        UCHAR OperationCode;
        UCHAR TransferSize : 5;
        UCHAR Reserved1 : 3;
        UCHAR Reserved2[7];
        UCHAR Control;
    } NEC_READ_Q_CHANNEL, *PNEC_READ_Q_CHANNEL;

    //
    // NEC Eject Disc
    //

    struct _NEC_EJECT {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 7;
        UCHAR Reserved2[7];
        UCHAR Control;
    } NEC_EJECT, *PNEC_EJECT;

} NEC_CDB, *PNEC_CDB;

//
// Defines for PIONEER DRM-600
//

#define PIONEER_REZERO_UNIT_CODE        0x01
#define PIONEER_EJECT_CODE              0xC0
#define PIONEER_READ_TOC_CODE           0xC1
#define PIONEER_READ_SUB_Q_CHANNEL_CODE 0xC2
#define PIONEER_Q_CHANNEL_TRANSFER_SIZE        9
#define PIONEER_AUDIO_STATUS_TRANSFER_SIZE     6
#define PIONEER_AUDIO_TRACK_SEARCH_CODE 0xC8
#define PIONEER_PLAY_AUDIO_CODE         0xC9
#define PIONEER_PAUSE_CODE              0xCA
#define PIONEER_AUDIO_STATUS_CODE       0xCC
#define PIONEER_READ_STATUS_CODE        0xE0


#define PIONEER_READ_FIRST_AND_LAST     0x00
#define PIONEER_READ_TRACK_INFO         0x02
#define PIONEER_READ_LEAD_OUT_INFO      0x01
#define PIONEER_TRANSFER_SIZE           0x04
#define PIONEER_TYPE_ATIME              0x01
#define PIONEER_STOP_ADDRESS            0x10

//
// Page codes for the READ_STATUS command.
//

#define PIONEER_PC_DRIVE_STATUS            0x01
#define PIONEER_PC_AUDIO_STATUS            0x02

typedef struct _PIONEER_DRIVE_STATUS_BUFFER {
    UCHAR PageCode : 6;
    UCHAR Reserved : 2;
    UCHAR PageLengthMsb;
    UCHAR PageLengthLsb;
    UCHAR DriveStatusLsb;
    UCHAR DriveStatusMsb;
} PIONEER_DRIVE_STATUS_BUFFER, *PPIONEER_DRIVE_STATUS_BUFFER;

#define PIONEER_DISC_PRESENT 0x08

//
// Pioneer cdb definitions.
//

typedef union _PIONEER_CDB {


    //
    // Pioneer Start/Stop Unit
    //

    struct _PNR_START_STOP {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 4;
        UCHAR Lun : 3;
        UCHAR Reserved2 : 7;
        UCHAR PCF : 1;
        UCHAR Reserved3;
        UCHAR Start : 1;
        UCHAR Eject : 1;
        UCHAR Reserved4 : 6;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved5 : 4;
        UCHAR Vendor : 2;
    } PNR_START_STOP, *PPNR_START_STOP;

    //
    // Pioneer Read TOC CDB
    //

    struct _PNR_READ_TOC {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[3];
        UCHAR TrackNumber;
        UCHAR Reserved3;
        UCHAR AssignedLength[2];
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved4 : 4;
        UCHAR Type : 2;
    } PNR_READ_TOC, *PPNR_READ_TOC;

    //
    // Pioneer Play CDB
    //

    struct _PNR_PLAY_AUDIO {
        UCHAR OperationCode;
        UCHAR PlayMode : 4;
        UCHAR StopAddr : 1;
        UCHAR Lun : 3;
        UCHAR Reserved1;
        UCHAR Minute;
        UCHAR Second;
        UCHAR Frame;
        UCHAR Reserved2[3];
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved3 : 4;
        UCHAR Type : 2;
    } PNR_PLAY_AUDIO, *PPNR_PLAY_AUDIO;

    //
    // Pioneer Seek Audio
    //

    struct _PNR_SEEK_AUDIO {
        UCHAR OperationCode;
        UCHAR PlayMode : 4;
        UCHAR PlayBack : 1;
        UCHAR Lun : 3;
        UCHAR Reserved1;
        UCHAR Minute;
        UCHAR Second;
        UCHAR Frame;
        UCHAR Reserved2[3];
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved3 : 4;
        UCHAR Type : 2;
    } PNR_SEEK_AUDIO, *PPNR_SEEK_AUDIO;

    //
    // Pioneer Pause Audio
    //

    struct _PNR_PAUSE_AUDIO {
        UCHAR OperationCode;
        UCHAR Reserved1 : 4;
        UCHAR Pause : 1;
        UCHAR Lun : 3;
        UCHAR Reserved2[7];
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved3 : 4;
        UCHAR Reserved4 : 2;
    } PNR_PAUSE_AUDIO, *PPNR_PAUSE_AUDIO;

    //
    // Pioneer Audio Status
    //

    struct _PNR_AUDIO_STATUS {
        UCHAR OperationCode;
        UCHAR Reserved1 : 4;
        UCHAR Reserved2 : 1;
        UCHAR Lun : 3;
        UCHAR Reserved3[6];
        UCHAR AssignedLength;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved4 : 4;
        UCHAR Reserved5 : 2;
    } PNR_AUDIO_STATUS, *PPNR_AUDIO_STATUS;

    //
    // Pioneer Read Q Channel
    //

    struct _PNR_READ_Q_CHANNEL {
        UCHAR OperationCode;
        UCHAR Reserved1 : 4;
        UCHAR Reserved2 : 1;
        UCHAR Lun : 3;
        UCHAR Reserved3[6];
        UCHAR AssignedLength;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved4 : 4;
        UCHAR Reserved5 : 2;
    } PNR_READ_Q_CHANNEL, *PPNR_READ_Q_CHANNEL;

    //
    // Pioneer Eject Disc
    //

    struct _PNR_EJECT {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 4;
        UCHAR Lun : 3;
        UCHAR Reserved2[7];
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved4 : 4;
        UCHAR Reserved5 : 2;
    } PNR_EJECT, *PPNR_EJECT;

    struct _PNR_READ_STATUS {
        UCHAR OperationCode;
        UCHAR Reserved1 : 4;
        UCHAR Lun : 3;
        UCHAR PageCode : 5;
        UCHAR PCField : 1;
        UCHAR Reserved2[5];
        UCHAR AllocationLengthMsb;
        UCHAR AllocationLengthLsb;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved3 : 4;
        UCHAR Reserved4 : 2;
    } PNR_READ_STATUS, *PPNR_READ_STATUS;

} PNR_CDB, *PPNR_CDB;


//
// Defines for DENON DRD-253
//

#define DENON_READ_TOC_CODE             0xE9
#define DENON_EJECT_CODE                0xE6
#define DENON_PLAY_AUDIO_EXTENDED_CODE  0x22
#define DENON_STOP_AUDIO_CODE           0xE7
#define DENON_READ_SUB_Q_CHANNEL_CODE   0xEB

//
// Defines for HITACHI 1750s
//

#define HITACHI_READ_TOC_CODE              0xE8
#define HITACHI_EJECT_CODE                 0xE4
#define HITACHI_PLAY_AUDIO_MSF_CODE        0xE0
#define HITACHI_PAUSE_AUDIO_CODE           0xE1
#define HITACHI_READ_SUB_Q_CHANNEL_CODE    0xE5

//
// 12 byte cdbs for Hitachi and Atapi
//


typedef union _HITACHICDB {

    //
    // Disc Information
    //

    struct _READ_DISC_INFO {

        UCHAR   OperationCode;
        UCHAR   Reserved : 5;
        UCHAR   LogicalUnitNumber : 3;
        UCHAR   Reserved1[7];
        UCHAR   AllocationLength[2];
        UCHAR   Link : 1;
        UCHAR   Flag : 1;
        UCHAR   Reserved2 : 4;
        UCHAR   VendorUniqueBits : 2;

    } READ_DISC_INFO, *PREAD_DISC_INFO;

    //
    // Play Audio
    //

    struct {

        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR Right : 1;
        UCHAR Left : 1;
        UCHAR Reserved : 2;
        UCHAR Lun : 3;
        UCHAR StartingM;
        UCHAR StartingS;
        UCHAR StartingF;
        UCHAR Reserved1[2];
        UCHAR EndingM;
        UCHAR EndingS;
        UCHAR EndingF;
        UCHAR Reserved2;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved3 : 4;
        UCHAR VendorUniqueBits : 2;

    } PLAY_AUDIO, *PPLAY_AUDIO;

    //
    // Pause Audio
    //

    struct _PAUSE {

        UCHAR OperationCode;
        UCHAR Reserved : 5;
        UCHAR Lun : 3;
        UCHAR Reserved1[9];
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved2 : 4;
        UCHAR VendorUnqiueBits : 2;

    } PAUSE_AUDIO, *PPAUSE_AUDIO;

    //
    // Eject media
    //

    struct _EJECT {

        UCHAR OperationCode;
        UCHAR Reserved : 5;
        UCHAR Lun : 3;
        UCHAR Reserved1[8];
        UCHAR Eject : 1;
        UCHAR Mode : 1;
        UCHAR Reserved2 : 6;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved3 : 4;
        UCHAR VendorUnqiueBits : 2;

    } EJECT, *PEJECT;

    //
    // Audio Status
    //

    struct _AUDIO_STATUS {

        UCHAR OperationCode;
        UCHAR Reserved : 5;
        UCHAR Lun : 3;
        UCHAR Reserved1[9];
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved2 : 4;
        UCHAR VendorUnqiueBits : 2;

    } AUDIO_STATUS, *PAUDIO_STATUS;

    //
    // Stop play
    //

    struct _STOP_PLAY {
        UCHAR OperationCode;
        UCHAR Reserved[11];
    } STOP_PLAY, *PSTOP_PLAY;

} HITACHICDB, *PHITACHICDB;

//
// Defines for Chinon CDS-535 CDROM Drive
//

#define CDS535_READ_TOC_CODE           0x43
#define CDS535_EJECT_CODE              0xC0
#define CDS535_READ_SUB_Q_CHANNEL_CODE 0x42
#define CDS535_STOP_AUDIO              0xC6
#define CDS535_GET_LAST_SESSION        0x26

//
// Defines for Chinon CDS-435 CDROM Drive
//

#define CDS435_READ_TOC_CODE            0x43
#define CDS435_EJECT_CODE               0xC0
#define CDS435_STOP_AUDIO_CODE          0xC6
#define CDS435_PLAY_AUDIO_EXTENDED_CODE 0x47
#define CDS435_READ_SUB_Q_CHANNEL_CODE  0x42

//
// Define for Fujitsu CDROM device.
//

#define FUJITSU_READ_TOC_CODE           0xE3


//
// Algebraically equal to:
//      75*60*Minutes +
//      75*Seconds    +
//      Frames        - 150
//
#define MSF_TO_LBA(Minutes,Seconds,Frames) \
    (ULONG)(75 * ((60 * (Minutes)) + (Seconds)) + (Frames) - 150)


#define LBA_TO_MSF(Lba,Minutes,Seconds,Frames)               \
{                                                            \
    (Minutes) = (UCHAR)( (Lba) / (60 * 75)      );           \
    (Seconds) = (UCHAR)(((Lba) % (60 * 75)) / 75);           \
    (Frames)  = (UCHAR)(((Lba) % (60 * 75)) % 75);           \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\cdaudio\cdaudio.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    audio.c

Abstract:

    This driver filters scsi-2 cdrom audio commands for non-scsi-2
    compliant cdrom drives.  At initialization, the driver scans the
    scsi bus for a recognized non-scsi-2 cdrom drive, and if one is
    found attached, installs itself to intercept IO_DEVICE_CONTROL
    requests for this drive.

Environment:

    kernel mode only

Notes:

Revision History:


--*/

#include "ntddk.h"
#include "ntddscsi.h"
#include "ntddcdrm.h"
#include "stdio.h"
#include "scsi.h"
#include "cdaudio.h"

#ifdef POOL_TAGGING
    #ifdef ExAllocatePool
        #undef ExAllocatePool
    #endif
    #define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,' AdC')
#endif



//
// Function declarations
//

NTSTATUS
    DriverEntry (
                IN PDRIVER_OBJECT DriverObject,
                IN PUNICODE_STRING RegistryPath
                );

NTSTATUS
    CdAudioCreate(
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP Irp
                 );

NTSTATUS
    CdAudioReadWrite(
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp
                    );

NTSTATUS
    CdAudioDeviceControl(
                        IN PDEVICE_OBJECT DeviceObject,
                        IN PIRP Irp
                        );

NTSTATUS
    CdAudioSendToNextDriver(
                           IN PDEVICE_OBJECT DeviceObject,
                           IN PIRP Irp
                           );

BOOLEAN
    CdAudioIsPlayActive(
                       IN PDEVICE_OBJECT DeviceObject
                       );

BOOLEAN
    NecSupportNeeded(
                    PUCHAR InquiryData
                    );

NTSTATUS
    CdAudioNECDeviceControl(
                           IN PDEVICE_OBJECT DeviceObject,
                           IN PIRP Irp
                           );

NTSTATUS
    CdAudioPioneerDeviceControl(
                               IN PDEVICE_OBJECT DeviceObject,
                               IN PIRP Irp
                               );

NTSTATUS
    CdAudioDenonDeviceControl(
                             IN PDEVICE_OBJECT DeviceObject,
                             IN PIRP Irp
                             );

NTSTATUS
    CdAudioHitachiSendPauseCommand(
                                  IN PDEVICE_OBJECT DeviceObject
                                  );

NTSTATUS
    CdAudioHitachiDeviceControl(
                               IN PDEVICE_OBJECT DeviceObject,
                               IN PIRP Irp
                               );

NTSTATUS
    CdAudio535DeviceControl(
                           IN PDEVICE_OBJECT DeviceObject,
                           IN PIRP Irp
                           );


NTSTATUS
    CdAudio435DeviceControl(
                           IN PDEVICE_OBJECT DeviceObject,
                           IN PIRP Irp
                           );


NTSTATUS
    CdAudioPan533DeviceControl(
                              IN PDEVICE_OBJECT DeviceObject,
                              IN PIRP Irp
                              );

NTSTATUS
    CdAudioAtapiDeviceControl(
                             IN PDEVICE_OBJECT DeviceObject,
                             IN PIRP Irp
                             );

NTSTATUS
    CdAudioLionOpticsDeviceControl(
                                  IN PDEVICE_OBJECT DeviceObject,
                                  IN PIRP Irp
                                  );

NTSTATUS
    CdAudioHPCdrDeviceControl(
                             PDEVICE_OBJECT DeviceObject,
                             PIRP Irp
                             );

VOID
    HpCdrProcessLastSession(
                           IN PCDROM_TOC Toc
                           );

NTSTATUS
    HPCdrCompletion(
                   IN PDEVICE_OBJECT DeviceObject,
                   IN PIRP Irp,
                   IN PVOID Context
                   );

NTSTATUS
    CdAudioPower(
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP Irp
                 );

NTSTATUS
    CdAudioForwardIrpSynchronous(
                                 IN PDEVICE_OBJECT DeviceObject,
                                 IN PIRP Irp
                                 );

VOID CdAudioUnload(
                  IN PDRIVER_OBJECT DriverObject
                  );

//
// Define the sections that allow for discarding (i.e. paging) some of
// the code.  NEC is put into one section, all others go into another
// section.  This way unless there are both NEC and one of the other
// device brands, some amount of code is freed.
//

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGECDNC, CdAudioNECDeviceControl)
#pragma alloc_text(PAGECDOT, CdAudioHitachiSendPauseCommand)
#pragma alloc_text(PAGECDOT, CdAudioHitachiDeviceControl)
#pragma alloc_text(PAGECDOT, CdAudioDenonDeviceControl)
#pragma alloc_text(PAGECDNC, CdAudio435DeviceControl)
#pragma alloc_text(PAGECDNC, CdAudio535DeviceControl)
#pragma alloc_text(PAGECDOT, CdAudioPioneerDeviceControl)
#pragma alloc_text(PAGECDNC, CdAudioPan533DeviceControl)
#pragma alloc_text(PAGECDOT, CdAudioAtapiDeviceControl)
#pragma alloc_text(PAGECDOT, CdAudioLionOpticsDeviceControl)
#pragma alloc_text(PAGECDOT, CdAudioHPCdrDeviceControl)
#pragma alloc_text(PAGECDOT, HpCdrProcessLastSession)
#pragma alloc_text(PAGECDOT, HPCdrCompletion)


NTSTATUS
    SendSrbSynchronous(
                      IN  PCD_DEVICE_EXTENSION    Extension,
                      IN  PSCSI_PASS_THROUGH      Srb,
                      IN  PVOID                   Buffer,
                      IN  ULONG                   BufferLength
                      )

/*++

Routine Description:

    This routine sends the given SRB synchronously to the CDROM class driver.

Arguments:

    Extension       - Supplies the device extension.

    Srb             - Supplies the SRB.

    Buffer          - Supplies the return buffer.

    BufferLength    - Supplies the buffer length.

Return Value:

    NTSTATUS

--*/

{
    ULONG           ioctl;
    KEVENT          event;
    PIRP            irp = NULL;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS        status;

    Srb->Length = sizeof(SCSI_PASS_THROUGH);
    Srb->SenseInfoLength = 0;
    Srb->SenseInfoOffset = 0;

    if (Buffer) {
        Srb->DataIn = SCSI_IOCTL_DATA_IN;
        Srb->DataTransferLength = BufferLength;
        Srb->DataBufferOffset = (ULONG_PTR) Buffer;
        ioctl = IOCTL_SCSI_PASS_THROUGH_DIRECT;
    } else {
        Srb->DataIn = SCSI_IOCTL_DATA_OUT;
        Srb->DataTransferLength = 0;
        Srb->DataBufferOffset = 0;
        ioctl = IOCTL_SCSI_PASS_THROUGH;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(ioctl, Extension->TargetDeviceObject,
                                        Srb, sizeof(SCSI_PASS_THROUGH),
                                        Srb, sizeof(SCSI_PASS_THROUGH),
                                        FALSE, &event, &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(Extension->TargetDeviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    return status;
}

NTSTATUS
    CdAudioAddDevice(
                    IN PDRIVER_OBJECT DriverObject,
                    IN PDEVICE_OBJECT PhysicalDeviceObject
                    )

/*++

Routine Description:

    This routine creates and initializes a new FDO for the corresponding
    PDO.  It may perform property queries on the FDO but cannot do any
    media access operations.

Arguments:

    DriverObject - CDROM class driver object.

    Pdo - the physical device object we are being added to

Return Value:

    status

--*/

{
    NTSTATUS                    status;
    PDEVICE_OBJECT              deviceObject;
    PCD_DEVICE_EXTENSION        extension;
    ULONG                       regActive = CDAUDIO_SEARCH_ACTIVE;

    //
    // Use registry to potentially not load onto stack
    //

    {
        HANDLE                      deviceParameterHandle;
        RTL_QUERY_REGISTRY_TABLE    queryTable[2];

        //
        // See if key exists and is readable.
        //

        status = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                         PLUGPLAY_REGKEY_DRIVER,
                                         KEY_READ,
                                         &deviceParameterHandle);

        if (!NT_SUCCESS(status)) {

            //
            // Pnp keys should always exist and be system-readable
            //

            CdDump((0, "AddDevice !! Registry key DNE?! %lx\n", status));

            ASSERT(FALSE);

            regActive = CDAUDIO_SEARCH_ACTIVE;
            goto AddDeviceEndRegistry;
        }

        //
        // Zero out the memory
        //

        RtlZeroMemory(&queryTable, sizeof(queryTable));

        //
        // Setup the structure for the read call
        //

        queryTable->Flags         =
            RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
        queryTable->Name          = CDAUDIO_ACTIVE_KEY_NAME;
        queryTable->EntryContext  = &regActive;
        queryTable->DefaultType   = REG_DWORD;
        queryTable->DefaultData   = NULL;
        queryTable->DefaultLength = 0;

        //
        // Get the value in regActive (using queryTable)
        //

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        (PWSTR)deviceParameterHandle,
                                        queryTable,
                                        NULL,
                                        NULL);

        //
        // Check for failure...
        //

        if (!NT_SUCCESS(status)) {

            //
            // This is normal, as the key does not exist the first
            // time the system loads the driver for the device.
            //

            CdDump(( 2,
                     "AddDevice !! Read value, status %lx\n",
                     status));
            regActive = CDAUDIO_SEARCH_ACTIVE;

        } else if (regActive > CDAUDIO_MAX_ACTIVE) {

            //
            // The registry value has either been corrupted, or manually
            // set to CDAUDIO_SEARCH_ACTIVE.  Either way, the driver will
            // search for drive type later.
            //

            CdDump(( 2,
                     "AddDevice !! Need to search, value %x\n",
                     regActive));
            regActive = CDAUDIO_SEARCH_ACTIVE;

        } else {

            //
            // We read a valid value, which will override the mapping type.
            //

            CdDump(( 2,
                     "AddDevice => Read value %x\n",
                     regActive));

        }

        //
        // close the handle
        //

        ZwClose(deviceParameterHandle);

    } // Finished registry handling

    AddDeviceEndRegistry:

    //
    // We forcibly set to within these bounds above
    //

    if (( regActive >  CDAUDIO_MAX_ACTIVE ) &&
        ( regActive != CDAUDIO_SEARCH_ACTIVE )) {
        CdDump((0,
                "AddDevice => Invalid registry value for "
                "maptype %x, resetting\n",
                regActive
                ));
        regActive = CDAUDIO_SEARCH_ACTIVE;
    }



    CdDump((1,
            "AddDevice => Active == %x\n",
            regActive));

    //
    // The system will remove us from memory if we don't call IoCreateDevice
    //

    if (regActive == CDAUDIO_NOT_ACTIVE) {
        CdDump((2,
                "AddDevice => Not attaching for pdo %p\n",
                PhysicalDeviceObject
                ));
        return STATUS_SUCCESS;
    }

    //
    // Map support section into non-paged pool
    //

    switch (regActive) {

    case CDAUDIO_NEC:
        MmLockPagableCodeSection((PVOID)CdAudioNECDeviceControl);
        break;

    case CDAUDIO_PIONEER:
    case CDAUDIO_PIONEER624:
        MmLockPagableCodeSection((PVOID)CdAudioPioneerDeviceControl);
        break;

    case CDAUDIO_DENON:
        MmLockPagableCodeSection((PVOID)CdAudioDenonDeviceControl);
        break;

    case CDAUDIO_HITACHI:
    case CDAUDIO_FUJITSU:
        MmLockPagableCodeSection((PVOID)CdAudioHitachiDeviceControl);
        break;

    case CDAUDIO_CDS535:
        MmLockPagableCodeSection((PVOID)CdAudio535DeviceControl);
        break;

    case CDAUDIO_CDS435:
        MmLockPagableCodeSection((PVOID)CdAudio435DeviceControl);
        break;

    case CDAUDIO_ATAPI:
        MmLockPagableCodeSection((PVOID)CdAudioAtapiDeviceControl);
        break;

    case CDAUDIO_HPCDR:
        MmLockPagableCodeSection((PVOID)CdAudioHPCdrDeviceControl);
        break;

    case CDAUDIO_SEARCH_ACTIVE:
    default:
        break;
    }

    //
    // Create the devObj so we are used
    //

    status = IoCreateDevice(DriverObject,
                            sizeof(CD_DEVICE_EXTENSION),
                            NULL,
                            PhysicalDeviceObject->DeviceType,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &deviceObject);

    if (!NT_SUCCESS(status)) {

        CdDump(( 0,
                 "AddDevice !! Unable to create device %lx\n",
                 status
                 ));

        // LOGLOG

        return status;
    }

    //
    // Set device object flags, device extension
    //

    deviceObject->Flags |= DO_DIRECT_IO;

    if (deviceObject->Flags & DO_POWER_INRUSH) {
        CdDump((0,
                "AddDevice ?? DO_POWER_INRUSH set for DO %p\n",
                deviceObject
                ));
    } else {
        deviceObject->Flags |= DO_POWER_PAGABLE;
    }


    extension = deviceObject->DeviceExtension;
    RtlZeroMemory(extension, sizeof(CD_DEVICE_EXTENSION));

    //
    // Useful to have next lower driver
    //

    extension->TargetDeviceObject =
        IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

    if (!extension->TargetDeviceObject) {

        CdDump(( 0,
                 "AddDevice !! Unable to attach to device stack %lx\n",
                 STATUS_NO_SUCH_DEVICE
                 ));

        // LOGLOG

        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }

    KeInitializeEvent(&extension->PagingPathCountEvent, SynchronizationEvent, TRUE);

    //
    // Must set Active flag, Pdo
    //

    extension->Active       = (UCHAR)regActive;
    extension->DeviceObject = deviceObject;
    extension->TargetPdo    = PhysicalDeviceObject;

    //
    // No longer initializing
    //

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return STATUS_SUCCESS;
}

NTSTATUS
    CdAudioSignalCompletion(
                           IN PDEVICE_OBJECT DeviceObject,
                           IN PIRP Irp,
                           IN PKEVENT Event
                           )

/*++

Routine Description:

    This completion routine will signal the event given as context and then
    return STATUS_MORE_PROCESSING_REQUIRED to stop event completion.  It is
    the responsibility of the routine waiting on the event to complete the
    request and free the event.

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp

    Event - a pointer to the event to signal

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
    CdAudioStartDevice(
                      IN  PDEVICE_OBJECT  DeviceObject,
                      IN  PIRP            Irp
                      )

/*++

Routine Description:

    Dispatch for START DEVICE.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PCD_DEVICE_EXTENSION     deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS                 status;
    KEVENT                   event;

#if DBG
    UCHAR string[17];
#endif

    CdDump((2, "StartDevice => Entering.\n"));

    status = CdAudioForwardIrpSynchronous(DeviceObject, Irp);

    if (!NT_SUCCESS(status)) {

        // LOGLOG - Should put some message into the system log

        return status;
    }

    ///
    /// From this point forward, not matter what occurs, we should
    /// return STATUS_SUCCESS.  The rest of the code is non-critical,
    /// and the worst occurance is that audio will not play on a CDROM.
    ///

    CdDump((2, "StartDevice => Starting\n"));

    //
    // Initialize device extension data
    //

    deviceExtension->Paused = CDAUDIO_NOT_PAUSED;
    deviceExtension->PausedM  = 0;
    deviceExtension->PausedS  = 0;
    deviceExtension->PausedF  = 0;
    deviceExtension->LastEndM = 0;
    deviceExtension->LastEndS = 0;
    deviceExtension->LastEndF = 0;

    //
    // deviceExtension->Active possibly set from registry in AddDevice
    //

    ASSERT(deviceExtension->Active > 0);
    ASSERT((deviceExtension->Active <= CDAUDIO_MAX_ACTIVE) ||
           (deviceExtension->Active == CDAUDIO_SEARCH_ACTIVE));

    //
    // Search for the type of translation via the inquiry data
    // if registry value DNE or says to.  Otherwise, use the
    // registry value (gotten in CdAudioAddDevice) as the Active Value
    //

    if (deviceExtension->Active == (UCHAR)CDAUDIO_SEARCH_ACTIVE) {

        SCSI_PASS_THROUGH        srb;
        PCDB                     cdb = (PCDB) srb.Cdb;
        PUCHAR                   inquiryDataPtr = NULL;
        UCHAR                    attempt = 0;

        CdDump(( 1,
                 "StartDevice => Searching for map type via InquiryData\n"
                 ));

        //
        // Allocate buffer for returned inquiry data
        //

        inquiryDataPtr = (PUCHAR)ExAllocatePool( NonPagedPoolCacheAligned,
                                                 INQUIRYDATABUFFERSIZE
                                               );
        if (!inquiryDataPtr) {
            CdDump(( 0,
                     "StartDevice !! Insufficient resources for inquiry data\n"
                     ));
            deviceExtension->Active = CDAUDIO_NOT_ACTIVE;
            // LOGLOG
            return STATUS_SUCCESS;
        }

        //
        // Force it into the loop
        //
        status = STATUS_UNSUCCESSFUL;

        CdDump(( 4,
                 "StartDevice => Inquiry Data at %p\n",
                 inquiryDataPtr
                 ));

        //
        // Try to get inquiry data a few times
        //
        while (
               !(NT_SUCCESS(status)) &&
               (attempt++ < MAXIMUM_RETRIES)
               ) {
            CdDump(( 1,
                     "StartDevice => Inquiry attempt %d\n",
                     attempt
                     ));

            //
            // Zero SRB (including cdb)
            //

            RtlZeroMemory( &srb, sizeof(SCSI_PASS_THROUGH) );

            //
            // Just for safety, zero the inquiryDataPtr
            //

            RtlZeroMemory( inquiryDataPtr, INQUIRYDATABUFFERSIZE );

            //
            // Fill in CDB for INQUIRY to CDROM
            //

            cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;
            cdb->CDB6INQUIRY.AllocationLength = INQUIRYDATABUFFERSIZE;


            //
            // Inquiry length is 6, with timeout
            //

            srb.CdbLength = 6;
            srb.TimeOutValue = AUDIO_TIMEOUT;

            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         inquiryDataPtr,
                                         INQUIRYDATABUFFERSIZE
                                       );
            CdDump(( 2,
                     "StartDevice => Inquiry status for attempt %d is %lx\n",
                     attempt,
                     status
                     ));
        }

        //
        // So if it failed a bunch of times....
        //
        if (!NT_SUCCESS(status)) {

            CdDump(( 1, "StartDevice !! Inquiry failed! %lx\n", status ));
            ExFreePool( inquiryDataPtr );

            // LOGLOG

            //
            // Do not translate any commands if we cannot determine
            // the drive type.  Better to lose audio than to lose
            // data functionality.
            //

            deviceExtension->Active = CDAUDIO_NOT_ACTIVE;
            return STATUS_SUCCESS;
        }

#if DBG
        RtlZeroMemory( string, 17 );
        RtlCopyMemory( string, &(inquiryDataPtr[8]), 8 );
        CdDump((2, "StartDevice => Vendor '%s'\n", string));
        RtlZeroMemory( string, 17 );
        RtlCopyMemory( string, &(inquiryDataPtr[16]), 16 );
        CdDump((2, "StartDevice => Drive '%s'\n", string));
#endif


        //
        // Conduct a search by the inquiry data
        //

        {
            //
            // Set the default value to NONE (not SEARCH_ACTIVE)
            //

            deviceExtension->Active = CDAUDIO_NOT_ACTIVE;

            //
            // Check for NEC drive
            //

            if ( RtlEqualMemory( &(inquiryDataPtr[8]), "NEC     ", 8 )) {
                if (NecSupportNeeded(inquiryDataPtr)) {
                    MmLockPagableCodeSection((PVOID)CdAudioNECDeviceControl);
                    deviceExtension->Active = CDAUDIO_NEC;
                }
            }

            //
            // Check for PIONEER DRM-600 and DRM-600x drives
            //

            if ( (RtlEqualMemory( &(inquiryDataPtr[8]), "PIONEER ", 8 )) &&
                 (RtlEqualMemory( &(inquiryDataPtr[16]), "CD-ROM DRM-600", 15 ))
                 ) {
                MmLockPagableCodeSection((PVOID)CdAudioPioneerDeviceControl);
                deviceExtension->Active = CDAUDIO_PIONEER;
            }

            //
            // Check for DENON drive
            //

            if ((inquiryDataPtr[8] =='D') &&
                (inquiryDataPtr[9] =='E') &&
                (inquiryDataPtr[10]=='N') &&
                (inquiryDataPtr[16]=='D') &&
                (inquiryDataPtr[17]=='R') &&
                (inquiryDataPtr[18]=='D') &&
                (inquiryDataPtr[20]=='2') &&
                (inquiryDataPtr[21]=='5') &&
                (inquiryDataPtr[22]=='X')) {
                MmLockPagableCodeSection((PVOID)CdAudioDenonDeviceControl);
                deviceExtension->Active = CDAUDIO_DENON;
            }

            if ( RtlEqualMemory( &(inquiryDataPtr[8]), "CHINON", 6 )) {

                //
                // Check for Chinon CDS-535
                //

                if ((inquiryDataPtr[27]=='5') &&
                    (inquiryDataPtr[28]=='3') &&
                    (inquiryDataPtr[29]=='5') &&
                    (inquiryDataPtr[32]=='Q')
                    ) {
                    MmLockPagableCodeSection((PVOID)CdAudio535DeviceControl);
                    deviceExtension->Active = CDAUDIO_CDS535;
                }

                //
                // Check for Chinon CDS-435 or CDS-431
                //  (willing to handle versions M/N, S/U, and H)
                //

                if ((inquiryDataPtr[27]=='4') &&
                    (inquiryDataPtr[28]=='3') &&
                    ((inquiryDataPtr[29]=='5') ||
                     (inquiryDataPtr[29]=='1')
                     )                        &&
                    ((inquiryDataPtr[32]=='M') ||
                     (inquiryDataPtr[32]=='N') ||
                     (inquiryDataPtr[32]=='S') ||
                     (inquiryDataPtr[32]=='U') ||
                     (inquiryDataPtr[32]=='H')
                     )
                    ) {
                    MmLockPagableCodeSection((PVOID)CdAudio435DeviceControl);
                    deviceExtension->Active = CDAUDIO_CDS435;
                }

                //
                // End of the Chinon drives
                //
            }


            //
            // Check for HITACHI drives
            //

            if ( (RtlEqualMemory( &(inquiryDataPtr[8]), "HITACHI ", 8 )) &&
                 ( (RtlEqualMemory( &(inquiryDataPtr[16]), "CDR-3650/1650S  ", 16 )) ||
                   (RtlEqualMemory( &(inquiryDataPtr[16]), "CDR-1750S       ", 16 ))
                   )
                 ) {
                MmLockPagableCodeSection((PVOID)CdAudioHitachiDeviceControl);
                deviceExtension->Active = CDAUDIO_HITACHI;
            }

            //
            // Check for Atapi drives that require support.
            //

            if ( ((RtlEqualMemory( &(inquiryDataPtr[8]),  "WEARNES ", 8 )) &&
                  (RtlEqualMemory( &(inquiryDataPtr[16]), "RUB",      3 ))
                  ) ||
                 ((RtlEqualMemory( &(inquiryDataPtr[8]),  "OTI     ", 8)) &&
                  (RtlEqualMemory( &(inquiryDataPtr[16]), "DOLPHIN ", 8))
                  )
                 ) {
                MmLockPagableCodeSection((PVOID)CdAudioAtapiDeviceControl);
                deviceExtension->Active = CDAUDIO_ATAPI;
                inquiryDataPtr[25] = (UCHAR)0;
            }

            //
            // Check for FUJITSU drives
            //

            if (RtlEqualMemory( &(inquiryDataPtr[8]), "FUJITSU ", 8 )) {

                //
                // It's a Fujitsu drive...is it one we want to
                // handle...?

                if ((inquiryDataPtr[16]=='C') &&
                    (inquiryDataPtr[17]=='D') &&
                    (inquiryDataPtr[18]=='R') &&
                    (inquiryDataPtr[20]=='3') &&
                    (inquiryDataPtr[21]=='6') &&
                    (inquiryDataPtr[22]=='5') &&
                    (inquiryDataPtr[23]=='0')) {

                    //
                    // Yes, we want to handle this as HITACHI compatible drive
                    //
                    MmLockPagableCodeSection((PVOID)CdAudioHitachiDeviceControl);
                    deviceExtension->Active = CDAUDIO_HITACHI;
                    inquiryDataPtr[25] = (UCHAR)0;

                } else if ((inquiryDataPtr[16]=='F') &&
                           (inquiryDataPtr[17]=='M') &&
                           (inquiryDataPtr[18]=='C') &&
                           (inquiryDataPtr[21]=='1') &&
                           (inquiryDataPtr[22]=='0') &&
                           ((inquiryDataPtr[23]=='1') ||
                            (inquiryDataPtr[23]=='2')) ) {

                    //
                    // Yes, we want to handle this as FUJITSU drive
                    //
                    MmLockPagableCodeSection((PVOID)CdAudioHitachiDeviceControl);
                    deviceExtension->Active = CDAUDIO_FUJITSU;
                    inquiryDataPtr[25] = (UCHAR)0;
                }

            }

            //
            // Check for HP CDR
            //

            if ((RtlEqualMemory( &(inquiryDataPtr[8]),  "HP      ",     8 )) &&
                (RtlEqualMemory( &(inquiryDataPtr[16]), "C4324/C4325", 11 ))
                ) {
                MmLockPagableCodeSection((PVOID)CdAudioHPCdrDeviceControl);
                deviceExtension->Active = CDAUDIO_HPCDR;
            }

        }

        ExFreePool( inquiryDataPtr );
    }

    CdDump((2,
            "StartDevice => Active is set to %x\n",
            deviceExtension->Active));

    //
    // Store the value in the registry so the inquiry data does
    // not have to be read and searched.
    //
    {
        HANDLE                   deviceParameterHandle;
        ULONG                    keyValue = (ULONG)deviceExtension->Active;

        //
        // Open a handle to the key
        //

        status = IoOpenDeviceRegistryKey(deviceExtension->TargetPdo,
                                         PLUGPLAY_REGKEY_DRIVER,
                                         KEY_WRITE,
                                         &deviceParameterHandle);
        if (!NT_SUCCESS(status)) {
            CdDump(( 0,
                     "StartDevice !! Failed to open registry %lx\n",
                     status
                     ));

            // LOGLOG

            //
            // Handle not open, so just
            //

            return STATUS_SUCCESS;
        }

        //
        // Write the value
        //

        status = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                       (PWSTR) deviceParameterHandle,
                                       CDAUDIO_ACTIVE_KEY_NAME,
                                       REG_DWORD,
                                       &keyValue,
                                       sizeof(keyValue));

        if (!NT_SUCCESS(status)) {

            //
            // This is a non-fatal error, so just write to debugger?
            //

            CdDump(( 0,
                     "StartDevice !! Failed to write registry %lx\n",
                     status
                     ));
            // LOGLOG

            //
            // But fall through to close the handle to the registry
            //

        }

        //
        // Don't forget to close what we open...
        //

        ZwClose(deviceParameterHandle);
        CdDump(( 2,
                 "StartDevice => Wrote value %x successfully\n",
                 deviceExtension->Active
                 ));

    }

    return STATUS_SUCCESS;

}

NTSTATUS
    CdAudioPnp(
              IN  PDEVICE_OBJECT  DeviceObject,
              IN  PIRP            Irp
              )

/*++

Routine Description:

    Dispatch for PNP

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp  = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status = STATUS_NOT_SUPPORTED;

    switch (irpSp->MinorFunction) {

    case IRP_MN_START_DEVICE: {
        status = CdAudioStartDevice(DeviceObject, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    case IRP_MN_DEVICE_USAGE_NOTIFICATION: {
        ULONG count;
        BOOLEAN setPagable;
        PCD_DEVICE_EXTENSION deviceExtension;


        if (irpSp->Parameters.UsageNotification.Type != DeviceUsageTypePaging) {
            return CdAudioSendToNextDriver(DeviceObject, Irp);
        }

        deviceExtension = DeviceObject->DeviceExtension;

        //
        // wait on the paging path event
        //

        status = KeWaitForSingleObject(&deviceExtension->PagingPathCountEvent,
                                       Executive, KernelMode,
                                       FALSE, NULL);

        //
        // if removing last paging device, need to clear DO_POWER_PAGABLE
        // bit here, and possible re-set it below on failure.
        //

        setPagable = FALSE;
        if (!irpSp->Parameters.UsageNotification.InPath &&
            deviceExtension->PagingPathCount == 1 ) {

            //
            // removing the last paging file
            // must have DO_POWER_PAGABLE bits set
            //

            if (DeviceObject->Flags & DO_POWER_INRUSH) {
                CdDump((2, "Pnp: Last paging file removed "
                        "but DO_POWER_INRUSH set, so not setting PAGABLE bit "
                        "for DO %p\n", DeviceObject));
            } else {
                CdDump((2, "Pnp: Setting  PAGABLE bit "
                        "for DO %p\n", DeviceObject));
                DeviceObject->Flags |= DO_POWER_PAGABLE;
                setPagable = TRUE;
            }

        }

        //
        // send the irp synchronously
        //

        status = CdAudioForwardIrpSynchronous(DeviceObject, Irp);

        //
        // now deal with the failure and success cases.
        // note that we are not allowed to fail the irp
        // once it is sent to the lower drivers.
        //

        if (NT_SUCCESS(status)) {

            IoAdjustPagingPathCount(
                &deviceExtension->PagingPathCount,
                irpSp->Parameters.UsageNotification.InPath);

            if (irpSp->Parameters.UsageNotification.InPath) {

                if (deviceExtension->PagingPathCount == 1) {
                    CdDump((2, "Pnp: Clearing PAGABLE bit "
                            "for DO %p\n", DeviceObject));
                    DeviceObject->Flags &= ~DO_POWER_PAGABLE;
                }

            } // end InPath if/else

        } else {

            //
            // cleanup the changes done above
            //

            if (setPagable == TRUE) {
                CdDump((2, "Pnp: Un-setting pagable bit for DO %p\n", DeviceObject));
                DeviceObject->Flags &= ~DO_POWER_PAGABLE;
                setPagable = FALSE;
            }

        }

        //
        // set the event so the next one can occur.
        //

        KeSetEvent(&deviceExtension->PagingPathCountEvent,
                   IO_NO_INCREMENT, FALSE);

        //
        // and complete the irp
        //
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
        break;
    }



    default:
        return CdAudioSendToNextDriver(DeviceObject, Irp);
    }

}


NTSTATUS
    DriverEntry(
               IN PDRIVER_OBJECT DriverObject,
               IN PUNICODE_STRING RegistryPath
               )

/*++

Routine Description:

    Initialize CdAudio driver.
    This is the system initialization entry point
    when the driver is linked into the kernel.

Arguments:

    DriverObject

Return Value:

    NTSTATUS

--*/

{
    ULONG i;

    //
    // Send everything down unless specifically handled.
    //
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = CdAudioSendToNextDriver;
    }

    DriverObject->MajorFunction[IRP_MJ_READ]           = CdAudioReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE]          = CdAudioReadWrite;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = CdAudioDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = CdAudioPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = CdAudioPower;
    DriverObject->DriverExtension->AddDevice           = CdAudioAddDevice;
    DriverObject->DriverUnload                         = CdAudioUnload;

    return STATUS_SUCCESS;
}

#define NEC_CDAUDIO_SUPPORT_DRIVES 12

BOOLEAN
    NecSupportNeeded(
                    PUCHAR InquiryData
                    )

/*++

Routine Description:

    This routine determines whether the NEC drive in question
    needs assistance from this driver.

Arguments:

    InquiryData - Pointer to the inquiry data buffer.

Return Value:

    TRUE - if support is needed.

--*/

{
    PINQUIRYDATA inquiryData = (PINQUIRYDATA)InquiryData;
    ULONG  i;
    PUCHAR badDriveList[NEC_CDAUDIO_SUPPORT_DRIVES] = {
        "CD-ROM DRIVE:80 ",   // must be 16 byte long
        "CD-ROM DRIVE:82 ",
        "CD-ROM DRIVE:83 ",
        "CD-ROM DRIVE:84 ",
        "CD-ROM DRIVE:841",
        "CD-ROM DRIVE:38 ",
        "CD-ROM DRIVE 4 M",
        "CD-ROM DRIVE:500",
        "CD-ROM DRIVE:400",
        "CD-ROM DRIVE:401",
        "CD-ROM DRIVE:501",
        "CD-ROM DRIVE:900"};


    for (i = 0; i < NEC_CDAUDIO_SUPPORT_DRIVES; i++) {
        if (RtlCompareMemory(inquiryData->ProductId, badDriveList[i], 16)==16) {
            return TRUE;
        }
    }

    return FALSE;
}


NTSTATUS
    CdAudioReadWrite(
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp
                    )

/*++

Routine Description:

    This is the driver entry point for read and write requests
    to the cdrom.  Since we only want to trap device control requests,
    we will just pass these requests on to the original driver.

Arguments:

    DeviceObject - pointer to device object for disk partition
    Irp - NT IO Request Packet

Return Value:

    NTSTATUS - status of request

--*/

{
    PCD_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    //
    // If the cd is playing music then reject this request.
    //

    if (deviceExtension->PlayActive) {
        Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_BUSY;
    }

    //
    // simply return status of driver below us...
    //

    return CdAudioSendToNextDriver(DeviceObject, Irp);

}


NTSTATUS
    CdAudioDeviceControl(
                        PDEVICE_OBJECT DeviceObject,
                        PIRP Irp
                        )

/*++

Routine Description:

    This routine is called by the I/O subsystem for device controls.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PCD_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    switch ( deviceExtension->Active ) {

    case CDAUDIO_SEARCH_ACTIVE:

        //
        // This occurs while we have not finished StartDevice()
        //

        status = CdAudioSendToNextDriver( DeviceObject, Irp );
        break;

    case CDAUDIO_NOT_ACTIVE:
        CdDump(( 3,
                 "DeviceControl => NOT ACTIVE for this drive.\n"
               ));
        status = CdAudioSendToNextDriver( DeviceObject, Irp );
        break;

    case CDAUDIO_NEC:
        status = CdAudioNECDeviceControl( DeviceObject, Irp );
        break;

    case CDAUDIO_PIONEER:
    case CDAUDIO_PIONEER624:
        status = CdAudioPioneerDeviceControl( DeviceObject, Irp );
        break;

    case CDAUDIO_DENON:
        status = CdAudioDenonDeviceControl( DeviceObject, Irp );
        break;

    case CDAUDIO_FUJITSU:
    case CDAUDIO_HITACHI:
        status = CdAudioHitachiDeviceControl( DeviceObject, Irp );
        break;

    case CDAUDIO_CDS535:
        status = CdAudio535DeviceControl( DeviceObject, Irp );
        break;

    case CDAUDIO_CDS435:
        status = CdAudio435DeviceControl( DeviceObject, Irp );
        break;

    case CDAUDIO_ATAPI:
        status = CdAudioAtapiDeviceControl( DeviceObject, Irp );
        break;

    case CDAUDIO_HPCDR:
        status = CdAudioHPCdrDeviceControl( DeviceObject, Irp );
        break;

    default:

        // LOGLOG

        CdDump(( 0,
                 "DeviceControl !! Active==UNKNOWN %x\n",
                 deviceExtension->Active
               ));
        ASSERT(FALSE);
        deviceExtension->Active = CDAUDIO_NOT_ACTIVE;
        status = CdAudioSendToNextDriver( DeviceObject, Irp );
    }

    return status;

}



NTSTATUS
    CdAudioSendToNextDriver(
                           PDEVICE_OBJECT DeviceObject,
                           PIRP Irp
                           )

/*++

Routine Description:

    This routine is sends the Irp to the next driver in line
    when the Irp is not processed by this driver.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PCD_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);
}


BOOLEAN
    CdAudioIsPlayActive(
                       IN PDEVICE_OBJECT DeviceObject
                       )

/*++

Routine Description:

    This routine determines if the cd is currently playing music.

Arguments:

    DeviceObject - Device object to test.

Return Value:

    TRUE if the device is playing music.

--*/
{
    PCD_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PIRP irp;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    NTSTATUS status;
    PSUB_Q_CURRENT_POSITION currentBuffer;
    BOOLEAN returnValue;

    if (!deviceExtension->PlayActive) {
        return(FALSE);
    }

    currentBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                   sizeof(SUB_Q_CURRENT_POSITION));

    if (currentBuffer == NULL) {
        return(FALSE);
    }

    ((PCDROM_SUB_Q_DATA_FORMAT) currentBuffer)->Format =
        IOCTL_CDROM_CURRENT_POSITION;
    ((PCDROM_SUB_Q_DATA_FORMAT) currentBuffer)->Track = 0;

    //
    // Create notification event object to be used to signal the
    // request completion.
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Build the synchronous request  to be sent to the port driver
    // to perform the request.
    //

    irp = IoBuildDeviceIoControlRequest(IOCTL_CDROM_READ_Q_CHANNEL,
                                        deviceExtension->DeviceObject,
                                        currentBuffer,
                                        sizeof(CDROM_SUB_Q_DATA_FORMAT),
                                        currentBuffer,
                                        sizeof(SUB_Q_CURRENT_POSITION),
                                        FALSE,
                                        &event,
                                        &ioStatus);

    if (irp == NULL) {
        ExFreePool(currentBuffer);
        return FALSE;
    }

    //
    // Pass request to port driver and wait for request to complete.
    //

    status = IoCallDriver(deviceExtension->DeviceObject, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        ExFreePool(currentBuffer);
        return FALSE;
    }

    if (currentBuffer->Header.AudioStatus == AUDIO_STATUS_IN_PROGRESS) {

        returnValue = TRUE;
    } else {
        returnValue = FALSE;
        deviceExtension->PlayActive = FALSE;
    }

    ExFreePool(currentBuffer);

    return(returnValue);


}


NTSTATUS
    CdAudioNECDeviceControl(
                           PDEVICE_OBJECT DeviceObject,
                           PIRP Irp
                           )

/*++

Routine Description:

    This routine is called by CdAudioDeviceControl to handle
    audio IOCTLs sent to NEC cdrom drives.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PCD_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCDROM_TOC         cdaudioDataOut  = Irp->AssociatedIrp.SystemBuffer;
    SCSI_PASS_THROUGH  srb;
    PNEC_CDB           cdb = (PNEC_CDB)srb.Cdb;
    NTSTATUS           status;
    ULONG              i,bytesTransfered;
    PUCHAR             Toc;
    ULONG              retryCount = 0;
    ULONG              address;
    LARGE_INTEGER delay;


    NECRestart:

    //
    // Clear out cdb
    //

    RtlZeroMemory( cdb, MAXIMUM_CDB_SIZE );

    //
    // What IOCTL do we need to execute?
    //

    switch (currentIrpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_CDROM_GET_LAST_SESSION:

        CdDump(( 2,
                 "NECDeviceControl => IOCTL_CDROM_GET_LAST_SESSION recv'd.\n"
               ));

        //
        // Ensure we have a large enough buffer?
        //

        if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
            (ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[1])) {
            status = STATUS_BUFFER_TOO_SMALL;
            // we have transferred zero bytes
            Irp->IoStatus.Information = 0;
            break;

        }


        //
        // If the cd is playing music then reject this request.
        //

        if (CdAudioIsPlayActive(DeviceObject)) {
            Irp->IoStatus.Information = 0;
            status = STATUS_DEVICE_BUSY;
            break;

        }

        //
        // Allocate storage to hold TOC from disc
        //

        Toc = (PUCHAR)ExAllocatePool( NonPagedPoolCacheAligned,
                                      NEC_CDROM_TOC_SIZE
                                    );

        if ( Toc == NULL ) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Information = 0;
            goto SetStatusAndReturn;

        }

        //
        // Set up defaults
        //

        RtlZeroMemory( Toc, NEC_CDROM_TOC_SIZE );
        srb.CdbLength = 10;

        //
        // Fill in CDB
        //

        cdb->NEC_READ_TOC.OperationCode = NEC_READ_TOC_CODE;
        cdb->NEC_READ_TOC.Type          = NEC_TRANSFER_WHOLE_TOC;
        cdb->NEC_READ_TOC.TrackNumber   = NEC_TOC_TYPE_SESSION;
        srb.TimeOutValue      = AUDIO_TIMEOUT;

        status = SendSrbSynchronous(
                                   deviceExtension,
                                   &srb,
                                   Toc,
                                   NEC_CDROM_TOC_SIZE
                                   );

        if (!NT_SUCCESS(status) && (status!=STATUS_DATA_OVERRUN)) {

            CdDump(( 1,
                     "NECDeviceControl => READ_TOC error, status %lx\n",
                     status ));

            ExFreePool( Toc );
            Irp->IoStatus.Information = 0;
            goto SetStatusAndReturn;

        } else {

            status = STATUS_SUCCESS;
        }

        //
        // Translate data into our format.
        //

        bytesTransfered = FIELD_OFFSET(CDROM_TOC, TrackData[1]);
        Irp->IoStatus.Information = bytesTransfered;

        RtlZeroMemory(cdaudioDataOut, bytesTransfered);

        cdaudioDataOut->Length[0]  = (UCHAR)((bytesTransfered - 2) >> 8);
        cdaudioDataOut->Length[1]  = (UCHAR)((bytesTransfered - 2) & 0xFF);

        //
        // Determine if this is a multisession cd.
        //

        if (*((ULONG UNALIGNED *) &Toc[14]) == 0) {

            //
            // This is a single session disk.  Just return.
            //

            ExFreePool(Toc);
            break;
        }

        //
        // Fake the session information.
        //

        cdaudioDataOut->FirstTrack = 1;
        cdaudioDataOut->LastTrack  = 2;

        CdDump(( 4,
                 "NECDeviceControl => Tracks %d - %d, (%x bytes)\n",
                 cdaudioDataOut->FirstTrack,
                 cdaudioDataOut->LastTrack,
                 bytesTransfered
               ));


        //
        // Grab Information for the last session.
        //

        cdaudioDataOut->TrackData[0].Reserved = 0;
        cdaudioDataOut->TrackData[0].Control =
            ((Toc[2] & 0x0F) << 4) | (Toc[2] >> 4);
        cdaudioDataOut->TrackData[0].TrackNumber = 1;

        cdaudioDataOut->TrackData[0].Reserved1 = 0;

        //
        // Convert the minutes, seconds and frames to an absolute block
        // address.  The formula comes from NEC.
        //

        address = (BCD_TO_DEC(Toc[15]) * 60 + BCD_TO_DEC(Toc[16])) * 75
            + BCD_TO_DEC(Toc[17]);

        //
        // Put the address in big-endian in the the user's TOC.
        //

        cdaudioDataOut->TrackData[0].Address[0] = (UCHAR) (address >> 24);
        cdaudioDataOut->TrackData[0].Address[1] = (UCHAR) (address >> 16);
        cdaudioDataOut->TrackData[0].Address[2] = (UCHAR) (address >> 8);
        cdaudioDataOut->TrackData[0].Address[3] = (UCHAR) address;

        //
        // Free storage now that we've stored it elsewhere
        //

        ExFreePool( Toc );
        break;

    case IOCTL_CDROM_READ_TOC:

        CdDump(( 2,
                 "NECDeviceControl => IOCTL_CDROM_READ_TOC recv'd.\n"
               ));

        //
        // If the cd is playing music then reject this request.
        //

        if (CdAudioIsPlayActive(DeviceObject)) {
            status = STATUS_DEVICE_BUSY;
            Irp->IoStatus.Information = 0;
            break;
        }

        //
        // Must have allocated at least enough buffer space
        // to store how many tracks are on the disc
        //

        if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
            ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[0]))
            ) {
            status = STATUS_BUFFER_TOO_SMALL;
            // we have transferred zero bytes
            Irp->IoStatus.Information = 0;
            break;
        }

        //
        // Allocate storage to hold TOC from disc
        //

        Toc = (PUCHAR)ExAllocatePool( NonPagedPoolCacheAligned,
                                      NEC_CDROM_TOC_SIZE
                                    );

        if ( Toc == NULL ) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Information = 0;
            goto SetStatusAndReturn;

        }

        CdDump(( 4,
                 "NECDeviceControl => Toc = %p  cdaudioDataOut = %p\n",
                 Toc, cdaudioDataOut
               ));

        //
        // Set up defaults
        //

        RtlZeroMemory( Toc, NEC_CDROM_TOC_SIZE );
        srb.CdbLength = 10;

        //
        // Fill in CDB
        //

        cdb->NEC_READ_TOC.OperationCode = NEC_READ_TOC_CODE;
        cdb->NEC_READ_TOC.Type          = NEC_TRANSFER_WHOLE_TOC;
        srb.TimeOutValue      = AUDIO_TIMEOUT;
        status = SendSrbSynchronous(
                                   deviceExtension,
                                   &srb,
                                   Toc,
                                   NEC_CDROM_TOC_SIZE
                                   );

        if (!NT_SUCCESS(status) && (status!=STATUS_DATA_OVERRUN)) {

            CdDump(( 1,
                     "NECDeviceControl => READ_TOC error (%lx)\n",
                     status ));


            if (status != STATUS_DATA_OVERRUN) {

                CdDump(( 1, "NECDeviceControl => SRB ERROR (%lx)\n",
                         status ));
                Irp->IoStatus.Information = 0;
                ExFreePool( Toc );
                goto SetStatusAndReturn;
            }

        } else {

            status = STATUS_SUCCESS;
        }

        //
        // Translate data into our format.
        //

        bytesTransfered =
            currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength >
            sizeof(CDROM_TOC) ?
            sizeof(CDROM_TOC) :
            currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

        cdaudioDataOut->FirstTrack = BCD_TO_DEC(Toc[9]);
        cdaudioDataOut->LastTrack  = BCD_TO_DEC(Toc[19]);

        CdDump(( 4,
                 "NECDeviceControl => Tracks %d - %d, (%x bytes)\n",
                 cdaudioDataOut->FirstTrack,
                 cdaudioDataOut->LastTrack,
                 bytesTransfered
               ));

        //
        // Return only N number of tracks, where N is the number of
        // full tracks of info we can stuff into the user buffer
        // if tracks from 1 to 2, that means there are two tracks,
        // so let i go from 0 to 1 (two tracks of info)
        //
        {
            //
            // tracksToReturn == Number of real track info to return
            // tracksInBuffer == How many fit into the user-supplied buffer
            // tracksOnCd     == Number of tracks on the CD (not including lead-out)
            //

            ULONG tracksToReturn;
            ULONG tracksOnCd;
            ULONG tracksInBuffer;
            ULONG dataLength;
            tracksOnCd = (cdaudioDataOut->LastTrack - cdaudioDataOut->FirstTrack) + 1;

            dataLength = ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[tracksOnCd])) - 2;
            cdaudioDataOut->Length[0]  = (UCHAR)(dataLength >> 8);
            cdaudioDataOut->Length[1]  = (UCHAR)(dataLength & 0xFF);


            tracksInBuffer = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength -
                             ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[0]));
            tracksInBuffer /= sizeof(TRACK_DATA);

            // take the lesser of the two
            tracksToReturn = (tracksInBuffer < tracksOnCd) ?
                             tracksInBuffer :
                             tracksOnCd;

            for( i=0; i < tracksToReturn; i++ ) {

                //
                // Grab Information for each track
                //

                cdaudioDataOut->TrackData[i].Reserved = 0;
                cdaudioDataOut->TrackData[i].Control =
                    ((Toc[(i*10)+32] & 0x0F) << 4) | (Toc[(i*10)+32] >> 4);
                cdaudioDataOut->TrackData[i].TrackNumber =
                    (UCHAR)(i + cdaudioDataOut->FirstTrack);

                cdaudioDataOut->TrackData[i].Reserved1  = 0;
                cdaudioDataOut->TrackData[i].Address[0] = 0;
                cdaudioDataOut->TrackData[i].Address[1] =
                    BCD_TO_DEC((Toc[(i*10)+39]));
                cdaudioDataOut->TrackData[i].Address[2] =
                    BCD_TO_DEC((Toc[(i*10)+40]));
                cdaudioDataOut->TrackData[i].Address[3] =
                    BCD_TO_DEC((Toc[(i*10)+41]));

                CdDump(( 4,
                            "CdAudioNecDeviceControl: Track %d  %d:%d:%d\n",
                            cdaudioDataOut->TrackData[i].TrackNumber,
                            cdaudioDataOut->TrackData[i].Address[1],
                            cdaudioDataOut->TrackData[i].Address[2],
                            cdaudioDataOut->TrackData[i].Address[3]
                        ));
            }

            //
            // Fake "lead out track" info
            // Only if all tracks have been copied...
            //

            if ( tracksInBuffer > tracksOnCd ) {
                cdaudioDataOut->TrackData[i].Reserved    = 0;
                cdaudioDataOut->TrackData[i].Control     = 0x10;
                cdaudioDataOut->TrackData[i].TrackNumber = 0xaa;
                cdaudioDataOut->TrackData[i].Reserved1   = 0;
                cdaudioDataOut->TrackData[i].Address[0]  = 0;
                cdaudioDataOut->TrackData[i].Address[1]  = BCD_TO_DEC(Toc[29]);
                cdaudioDataOut->TrackData[i].Address[2]  = BCD_TO_DEC(Toc[30]);
                cdaudioDataOut->TrackData[i].Address[3]  = BCD_TO_DEC(Toc[31]);

                CdDump(( 4,
                         "NECDeviceControl => Track %d  %d:%d:%d\n",
                         cdaudioDataOut->TrackData[i].TrackNumber,
                         cdaudioDataOut->TrackData[i].Address[1],
                         cdaudioDataOut->TrackData[i].Address[2],
                         cdaudioDataOut->TrackData[i].Address[3]
                       ));
                i++;
            }

            Irp->IoStatus.Information  = ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[i]));

        }


        //
        // Free storage now that we've stored it elsewhere
        //

        ExFreePool( Toc );
        break;

    case IOCTL_CDROM_STOP_AUDIO:

        deviceExtension->PlayActive = FALSE;

        //
        // Same as scsi-2 spec, so just send to default driver
        //

        return CdAudioSendToNextDriver( DeviceObject, Irp );
        break;

    case IOCTL_CDROM_PLAY_AUDIO_MSF:
        {

            PCDROM_PLAY_AUDIO_MSF inputBuffer = Irp->AssociatedIrp.SystemBuffer;

            CdDump(( 3,
                     "NECDeviceControl => IOCTL_CDROM_PLAY_AUDIO_MSF recv'd.\n"
                   ));

            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CDROM_PLAY_AUDIO_MSF)
                ) {
                status = STATUS_INFO_LENGTH_MISMATCH;
                Irp->IoStatus.Information = 0;
                break;
            }


            //
            // First, seek to Starting MSF and enter play mode.
            //

            srb.CdbLength                     = 10;
            srb.TimeOutValue                  = AUDIO_TIMEOUT;
            cdb->NEC_PLAY_AUDIO.OperationCode = NEC_AUDIO_TRACK_SEARCH_CODE;
            cdb->NEC_PLAY_AUDIO.PlayMode      = NEC_ENTER_PLAY_MODE;
            cdb->NEC_PLAY_AUDIO.Minute        = DEC_TO_BCD(inputBuffer->StartingM);
            cdb->NEC_PLAY_AUDIO.Second        = DEC_TO_BCD(inputBuffer->StartingS);
            cdb->NEC_PLAY_AUDIO.Frame         = DEC_TO_BCD(inputBuffer->StartingF);
            cdb->NEC_PLAY_AUDIO.Control       = NEC_TYPE_ATIME;

            CdDump(( 3,
                     "NECDeviceControl => play start MSF is BCD(%x:%x:%x)\n",
                     cdb->NEC_PLAY_AUDIO.Minute,
                     cdb->NEC_PLAY_AUDIO.Second,
                     cdb->NEC_PLAY_AUDIO.Frame
                   ));


            status = SendSrbSynchronous(deviceExtension,
                                        &srb,
                                        NULL,
                                        0
                                       );
            if (NT_SUCCESS(status)) {

                //
                // Indicate the play actition is active.
                //

                deviceExtension->PlayActive = TRUE;

                //
                // Now, set the termination point for the play operation
                //

                RtlZeroMemory( cdb, MAXIMUM_CDB_SIZE );
                cdb->NEC_PLAY_AUDIO.OperationCode = NEC_PLAY_AUDIO_CODE;
                cdb->NEC_PLAY_AUDIO.PlayMode      = NEC_PLAY_STEREO;
                cdb->NEC_PLAY_AUDIO.Minute        = DEC_TO_BCD(inputBuffer->EndingM);
                cdb->NEC_PLAY_AUDIO.Second        = DEC_TO_BCD(inputBuffer->EndingS);
                cdb->NEC_PLAY_AUDIO.Frame         = DEC_TO_BCD(inputBuffer->EndingF);
                cdb->NEC_PLAY_AUDIO.Control       = NEC_TYPE_ATIME;

                CdDump(( 3,
                         "NECDeviceControl => play end MSF is BCD(%x:%x:%x)\n",
                         cdb->NEC_PLAY_AUDIO.Minute,
                         cdb->NEC_PLAY_AUDIO.Second,
                         cdb->NEC_PLAY_AUDIO.Frame
                       ));

                status = SendSrbSynchronous(
                                           deviceExtension,
                                           &srb,
                                           NULL,
                                           0
                                           );


            }
        }
        break;

    case IOCTL_CDROM_SEEK_AUDIO_MSF:
        {

            PCDROM_SEEK_AUDIO_MSF inputBuffer = Irp->AssociatedIrp.SystemBuffer;

            CdDump(( 3,
                     "NECDeviceControl => IOCTL_CDROM_SEEK_AUDIO_MSF recv'd.\n"
                   ));

            //
            // Must have allocated at least enough buffer space
            // to store how many tracks are on the disc
            //

            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CDROM_SEEK_AUDIO_MSF)
                ) {
                status = STATUS_INFO_LENGTH_MISMATCH;
                Irp->IoStatus.Information = 0;
                break;
            }


            //
            // seek to MSF and enter pause (still) mode.
            //

            srb.CdbLength                 = 10;
            srb.TimeOutValue              = AUDIO_TIMEOUT;
            cdb->NEC_SEEK_AUDIO.OperationCode = NEC_AUDIO_TRACK_SEARCH_CODE;
            cdb->NEC_SEEK_AUDIO.Minute        = DEC_TO_BCD(inputBuffer->M);
            cdb->NEC_SEEK_AUDIO.Second        = DEC_TO_BCD(inputBuffer->S);
            cdb->NEC_SEEK_AUDIO.Frame         = DEC_TO_BCD(inputBuffer->F);
            cdb->NEC_SEEK_AUDIO.Control       = NEC_TYPE_ATIME;
            CdDump(( 4,
                     "NECDeviceControl => seek MSF is %d:%d:%d\n",
                     cdb->NEC_SEEK_AUDIO.Minute,
                     cdb->NEC_SEEK_AUDIO.Second,
                     cdb->NEC_SEEK_AUDIO.Frame
                   ));

            status = SendSrbSynchronous(
                                       deviceExtension,
                                       &srb,
                                       NULL,
                                       0
                                       );

        }
        break;

    case IOCTL_CDROM_PAUSE_AUDIO:

        CdDump(( 3,
                 "NECDeviceControl => IOCTL_CDROM_PAUSE_AUDIO recv'd.\n"
               ));

        deviceExtension->PlayActive = FALSE;

        //
        // Enter pause (still ) mode
        //

        srb.CdbLength                  = 10;
        srb.TimeOutValue               = AUDIO_TIMEOUT;
        cdb->NEC_PAUSE_AUDIO.OperationCode = NEC_STILL_CODE;
        status = SendSrbSynchronous(
                                   deviceExtension,
                                   &srb,
                                   NULL,
                                   0
                                   );

        break;

    case IOCTL_CDROM_RESUME_AUDIO:

        CdDump(( 3,
                 "NECDeviceControl => IOCTL_CDROM_RESUME_AUDIO recv'd.\n"
               ));

        //
        // Resume play
        //

        srb.CdbLength                 = 10;
        srb.TimeOutValue              = AUDIO_TIMEOUT;
        cdb->NEC_PLAY_AUDIO.OperationCode = NEC_PLAY_AUDIO_CODE;
        cdb->NEC_PLAY_AUDIO.PlayMode      = NEC_PLAY_STEREO;
        cdb->NEC_PLAY_AUDIO.Control       = NEC_TYPE_NO_CHANGE;
        status = SendSrbSynchronous(
                                   deviceExtension,
                                   &srb,
                                   NULL,
                                   0
                                   );
        break;

    case IOCTL_CDROM_READ_Q_CHANNEL:
        {

            PSUB_Q_CURRENT_POSITION userPtr =
                Irp->AssociatedIrp.SystemBuffer;
            PUCHAR SubQPtr =
                ExAllocatePool( NonPagedPoolCacheAligned,
                                NEC_Q_CHANNEL_TRANSFER_SIZE
                              );

            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SUB_Q_CURRENT_POSITION)
                ) {
                status = STATUS_BUFFER_TOO_SMALL;
                // we have transferred zero bytes
                Irp->IoStatus.Information = 0;
                if (SubQPtr) ExFreePool(SubQPtr);
                break;
            }


            CdDump(( 5,
                     "NECDeviceControl => IOCTL_CDROM_READ_Q_CHANNEL recv'd.\n"
                   ));

            if (SubQPtr==NULL) {

                CdDump(( 1,
                         "NECDeviceControl !! READ_Q_CHANNEL, SubQPtr==NULL!\n"
                       ));

                status = STATUS_INSUFFICIENT_RESOURCES;
                Irp->IoStatus.Information = 0;
                goto SetStatusAndReturn;

            }

            RtlZeroMemory( SubQPtr, NEC_Q_CHANNEL_TRANSFER_SIZE );

            if ( ((PCDROM_SUB_Q_DATA_FORMAT)userPtr)->Format!=
                 IOCTL_CDROM_CURRENT_POSITION) {

                CdDump((1,
                    "NECDeviceControl !! READ_Q_CHANNEL, illegal Format (%d)\n",
                    ((PCDROM_SUB_Q_DATA_FORMAT)userPtr)->Format
                    ));

                ExFreePool( SubQPtr );
                status = STATUS_UNSUCCESSFUL;
                Irp->IoStatus.Information = 0;
                goto SetStatusAndReturn;
            }

            NECSeek:

            //
            // Set up to read Q Channel
            //

            srb.CdbLength                     = 10;
            srb.TimeOutValue                  = AUDIO_TIMEOUT;
            cdb->NEC_READ_Q_CHANNEL.OperationCode = NEC_READ_SUB_Q_CHANNEL_CODE;
            // Transfer Length
            cdb->NEC_READ_Q_CHANNEL.TransferSize  = NEC_Q_CHANNEL_TRANSFER_SIZE;
            CdDump(( 4, "NECDeviceControl => cdb = %p  srb = %p  SubQPtr = %p\n",
                     cdb,
                     &srb,
                     SubQPtr
                   ));
            status = SendSrbSynchronous(
                                       deviceExtension,
                                       &srb,
                                       SubQPtr,
                                       NEC_Q_CHANNEL_TRANSFER_SIZE
                                       );
            CdDump(( 4, "NECDeviceControl => READ_Q_CHANNEL, status is %lx\n",
                     status
                   ));

            if ((NT_SUCCESS(status)) || (status==STATUS_DATA_OVERRUN)) {

                userPtr->Header.Reserved = 0;
                if (SubQPtr[0]==0x00)
                    userPtr->Header.AudioStatus = AUDIO_STATUS_IN_PROGRESS;
                else if (SubQPtr[0]==0x01) {

                    userPtr->Header.AudioStatus = AUDIO_STATUS_PAUSED;
                    deviceExtension->PlayActive = FALSE;
                } else if (SubQPtr[0]==0x02) {
                    userPtr->Header.AudioStatus = AUDIO_STATUS_PAUSED;
                    deviceExtension->PlayActive = FALSE;
                } else if (SubQPtr[0]==0x03) {

                    userPtr->Header.AudioStatus = AUDIO_STATUS_PLAY_COMPLETE;
                    deviceExtension->PlayActive = FALSE;

                } else {
                    deviceExtension->PlayActive = FALSE;

                }

                userPtr->Header.DataLength[0] = 0;
                userPtr->Header.DataLength[0] = 12;

                userPtr->FormatCode = 0x01;
                userPtr->Control = SubQPtr[1] & 0x0F;
                userPtr->ADR     = 0;
                userPtr->TrackNumber = BCD_TO_DEC(SubQPtr[2]);
                userPtr->IndexNumber = BCD_TO_DEC(SubQPtr[3]);
                userPtr->AbsoluteAddress[0] = 0;
                userPtr->AbsoluteAddress[1] = BCD_TO_DEC((SubQPtr[7]));
                userPtr->AbsoluteAddress[2] = BCD_TO_DEC((SubQPtr[8]));
                userPtr->AbsoluteAddress[3] = BCD_TO_DEC((SubQPtr[9]));
                userPtr->TrackRelativeAddress[0] = 0;
                userPtr->TrackRelativeAddress[1] = BCD_TO_DEC((SubQPtr[4]));
                userPtr->TrackRelativeAddress[2] = BCD_TO_DEC((SubQPtr[5]));
                userPtr->TrackRelativeAddress[3] = BCD_TO_DEC((SubQPtr[6]));
                Irp->IoStatus.Information = sizeof(SUB_Q_CURRENT_POSITION);
                CdDump(( 5,
                         "NECDeviceControl => <SubQPtr> Status = 0x%lx, [%x %x:%x]  (%x:%x:%x)\n",
                         SubQPtr[0],
                         SubQPtr[2],
                         SubQPtr[4],
                         SubQPtr[5],
                         SubQPtr[7],
                         SubQPtr[8],
                         SubQPtr[9]
                       ));
                CdDump(( 5,
                         "NECDeviceControl => <userPtr> Status = 0x%lx, [%d %d:%d]  (%d:%d:%d)\n",
                         userPtr->Header.AudioStatus,
                         userPtr->TrackNumber,
                         userPtr->TrackRelativeAddress[1],
                         userPtr->TrackRelativeAddress[2],
                         userPtr->AbsoluteAddress[1],
                         userPtr->AbsoluteAddress[2],
                         userPtr->AbsoluteAddress[3]
                       ));

                //
                // Sometimes the NEC will return a bogus value for track number.
                // if this occurs just retry.
                //

                if (userPtr->TrackNumber > MAXIMUM_NUMBER_TRACKS) {

                    //
                    // Delay for .5 seconds.
                    //

                    delay.QuadPart = - 10 * (LONGLONG)1000 * 100 * 5;

                    //
                    // Stall for a while to let the controller spinup.
                    //

                    KeDelayExecutionThread(KernelMode,
                                           FALSE,
                                           &delay);

                    if (retryCount++ < MAXIMUM_RETRIES) {
                        goto NECSeek;
                    } else {
                        Irp->IoStatus.Information = 0;
                        status = STATUS_DEVICE_PROTOCOL_ERROR;
                    }

                } else {
                    status = STATUS_SUCCESS;
                }

            } else {

                RtlZeroMemory( userPtr, sizeof(SUB_Q_CURRENT_POSITION) );
                Irp->IoStatus.Information = 0;
                CdDump((1,
                        "NECDeviceControl => READ_Q_CHANNEL failed %lx)\n",
                        status
                       ));

            }

            ExFreePool( SubQPtr );

        }
        break;

    case IOCTL_CDROM_EJECT_MEDIA:

        CdDump(( 3,
                 "NECDeviceControl => IOCTL_CDROM_EJECT_MEDIA recv'd.\n"
               ));

        deviceExtension->PlayActive = FALSE;

        //
        // Set up to read Q Channel
        //

        srb.CdbLength            = 10;
        srb.TimeOutValue         = AUDIO_TIMEOUT;
        cdb->NEC_EJECT.OperationCode = NEC_EJECT_CODE;
        status = SendSrbSynchronous(
                                   deviceExtension,
                                   &srb,
                                   NULL,
                                   0
                                   );
        Irp->IoStatus.Information = 0;
        CdDump(( 3,
                 "NECDeviceControl => invalidating cached TOC!\n"
               ));
        break;

    case IOCTL_CDROM_GET_CONTROL:
    case IOCTL_CDROM_GET_VOLUME:
    case IOCTL_CDROM_SET_VOLUME:

        CdDump(( 3, "NECDeviceControl => Not Supported yet.\n" ));
        Irp->IoStatus.Information = 0;
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    case IOCTL_CDROM_CHECK_VERIFY:

        //
        // Update the play active flag.
        //

        CdAudioIsPlayActive(DeviceObject);

        //
        // Fall through and pass the request to the next driver.
        //

    default:

        CdDump(( 10,
                 "NECDeviceControl => Unsupported device IOCTL (%x)\n",
                 currentIrpStack->Parameters.DeviceIoControl.IoControlCode
               ));
        return CdAudioSendToNextDriver( DeviceObject, Irp );
        break;

    } // end switch( IOCTL )

    SetStatusAndReturn:

    //
    // set status code and return
    //

    if (status == STATUS_VERIFY_REQUIRED) {


        //
        // If the status is verified required and the this request
        // should bypass verify required then retry the request.
        //

        if (currentIrpStack->Flags & SL_OVERRIDE_VERIFY_VOLUME) {

            status = STATUS_IO_DEVICE_ERROR;
            goto NECRestart;

        }

        IoSetHardErrorOrVerifyDevice( Irp,
                                      deviceExtension->TargetDeviceObject
                                    );

        Irp->IoStatus.Information = 0;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;

}


NTSTATUS
    CdAudioPioneerDeviceControl(
                               PDEVICE_OBJECT DeviceObject,
                               PIRP Irp
                               )

/*++

Routine Description:

    This routine is called by CdAudioDeviceControl to handle
    audio IOCTLs sent to PIONEER DRM-6xx cdrom drives.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PCD_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCDROM_TOC         cdaudioDataOut  = Irp->AssociatedIrp.SystemBuffer;
    SCSI_PASS_THROUGH  srb;
    PPNR_CDB           cdb = (PPNR_CDB)srb.Cdb;
    PCDB               scsiCdb = (PCDB) srb.Cdb;
    NTSTATUS           status;
    ULONG              i,retry;
    PUCHAR             Toc;

    PioneerRestart:

    //
    // Clear out cdb
    //

    RtlZeroMemory( cdb, MAXIMUM_CDB_SIZE );

    //
    // What IOCTL do we need to execute?
    //

    switch (currentIrpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_CDROM_READ_TOC: {
            CdDump(( 3,
                     "PioneerDeviceControl => IOCTL_CDROM_READ_TOC recv'd.\n"
                   ));

            //
            // Must have allocated at least enough buffer space
            // to store how many tracks are on the disc
            //

            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[0]))
                ) {
                status = STATUS_BUFFER_TOO_SMALL;
                // we have transferred zero bytes
                Irp->IoStatus.Information = 0;
                break;
            }

            //
            // If the cd is playing music then reject this request.
            //

            if (CdAudioIsPlayActive(DeviceObject)) {
                status = STATUS_DEVICE_BUSY;
                Irp->IoStatus.Information = 0;
                break;
            }

            //
            // Allocate storage to hold TOC from disc
            //

            Toc = (PUCHAR)ExAllocatePool( NonPagedPoolCacheAligned,
                                          CDROM_TOC_SIZE
                                        );

            if (Toc==NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                Irp->IoStatus.Information = 0;
                goto SetStatusAndReturn;

            }

            RtlZeroMemory( Toc, CDROM_TOC_SIZE );

            //
            // mount this disc (via START/STOP unit), which is
            // necessary since we don't know which is the
            // currently loaded disc.
            //

            if (deviceExtension->Active == CDAUDIO_PIONEER) {
                cdb->PNR_START_STOP.Immediate     = 1;
            } else {
                cdb->PNR_START_STOP.Immediate     = 0;
            }

            cdb->PNR_START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
            cdb->PNR_START_STOP.Start         = 1;
            srb.CdbLength = 6;
            srb.TimeOutValue = AUDIO_TIMEOUT;
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         NULL,
                                         0
                                       );

            if (!NT_SUCCESS(status)) {
                CdDump(( 1,
                         "PioneerDeviceControl => Start Unit failed (%lx)\n",
                         status));

                ExFreePool( Toc );
                Irp->IoStatus.Information = 0;
                goto SetStatusAndReturn;
            }

            //
            // Get first and last tracks
            //

            RtlZeroMemory( cdb, MAXIMUM_CDB_SIZE );
            srb.CdbLength = 10;
            cdb->PNR_READ_TOC.OperationCode     = PIONEER_READ_TOC_CODE;
            cdb->PNR_READ_TOC.AssignedLength[1] = PIONEER_TRANSFER_SIZE;
            cdb->PNR_READ_TOC.Type              = PIONEER_READ_FIRST_AND_LAST;
            srb.TimeOutValue                    = AUDIO_TIMEOUT;
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         Toc,
                                         PIONEER_TRANSFER_SIZE
                                       );

            if (!NT_SUCCESS(status)) {

                CdDump(( 1,
                         "PioneerDeviceControl => ReadTOC, First/Last Tracks failed (%lx)\n",
                         status ));
                ExFreePool( Toc );
                Irp->IoStatus.Information = 0;
                goto SetStatusAndReturn;

            }

            cdaudioDataOut->FirstTrack = BCD_TO_DEC(Toc[0]);
            cdaudioDataOut->LastTrack  = BCD_TO_DEC(Toc[1]);

            //
            // Return only N number of tracks, where N is the number of
            // full tracks of info we can stuff into the user buffer
            // if tracks from 1 to 2, that means there are two tracks,
            // so let i go from 0 to 1 (two tracks of info)
            //
            {
                //
                // tracksToReturn == Number of real track info to return
                // tracksInBuffer == How many fit into the user-supplied buffer
                // tracksOnCd     == Number of tracks on the CD (not including lead-out)
                //

                ULONG tracksToReturn;
                ULONG tracksOnCd;
                ULONG tracksInBuffer;
                ULONG dataLength;
                tracksOnCd = (cdaudioDataOut->LastTrack - cdaudioDataOut->FirstTrack) + 1;

                //
                // set the number of tracks correctly
                //

                dataLength = ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[tracksOnCd])) - 2;
                cdaudioDataOut->Length[0]  = (UCHAR)(dataLength >> 8);
                cdaudioDataOut->Length[1]  = (UCHAR)(dataLength & 0xFF);


                tracksInBuffer = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength -
                                 ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[0]));
                tracksInBuffer /= sizeof(TRACK_DATA);

                // take the lesser of the two
                tracksToReturn = (tracksInBuffer < tracksOnCd) ?
                                 tracksInBuffer :
                                 tracksOnCd;

                for( i=0; i < tracksToReturn; i++ ) {

                    //
                    // Grab Information for each track
                    //

                    RtlZeroMemory( cdb, MAXIMUM_CDB_SIZE );
                    cdb->PNR_READ_TOC.OperationCode     = PIONEER_READ_TOC_CODE;
                    // track
                    cdb->PNR_READ_TOC.TrackNumber       =
                        (UCHAR)(DEC_TO_BCD((i+cdaudioDataOut->FirstTrack)));
                    cdb->PNR_READ_TOC.AssignedLength[1] = PIONEER_TRANSFER_SIZE;
                    cdb->PNR_READ_TOC.Type              = PIONEER_READ_TRACK_INFO;
                    srb.TimeOutValue                    = AUDIO_TIMEOUT;
                    status = SendSrbSynchronous( deviceExtension,
                                                 &srb,
                                                 Toc,
                                                 PIONEER_TRANSFER_SIZE
                                               );

                    if (!NT_SUCCESS(status)) {

                        CdDump(( 1,
                                 "PioneerDeviceControl => ReadTOC, Track #%d, failed (%lx)\n",
                                 i+cdaudioDataOut->FirstTrack,
                                 status ));
                        ExFreePool( Toc );
                        Irp->IoStatus.Information = 0;
                        goto SetStatusAndReturn;

                    }

                    cdaudioDataOut->TrackData[i].Reserved = 0;
                    cdaudioDataOut->TrackData[i].Control  = Toc[0];
                    cdaudioDataOut->TrackData[i].TrackNumber =
                        (UCHAR)((i + cdaudioDataOut->FirstTrack));
                    cdaudioDataOut->TrackData[i].Reserved1 = 0;
                    cdaudioDataOut->TrackData[i].Address[0]=0;
                    cdaudioDataOut->TrackData[i].Address[1]=BCD_TO_DEC(Toc[1]);
                    cdaudioDataOut->TrackData[i].Address[2]=BCD_TO_DEC(Toc[2]);
                    cdaudioDataOut->TrackData[i].Address[3]=BCD_TO_DEC(Toc[3]);

                    CdDump(( 4,
                                "CdAudioPioneerDeviceControl: Track %d  %d:%d:%d\n",
                                cdaudioDataOut->TrackData[i].TrackNumber,
                                cdaudioDataOut->TrackData[i].Address[1],
                                cdaudioDataOut->TrackData[i].Address[2],
                                cdaudioDataOut->TrackData[i].Address[3]
                            ));
                }

                //
                // Fake "lead out track" info
                // Only if all tracks have been copied...
                //

                if ( tracksInBuffer > tracksOnCd ) {
                    RtlZeroMemory( cdb, MAXIMUM_CDB_SIZE );
                    cdb->PNR_READ_TOC.OperationCode     = PIONEER_READ_TOC_CODE;
                    cdb->PNR_READ_TOC.AssignedLength[1] = PIONEER_TRANSFER_SIZE;
                    cdb->PNR_READ_TOC.Type              = PIONEER_READ_LEAD_OUT_INFO;
                    srb.TimeOutValue                    = AUDIO_TIMEOUT;
                    status = SendSrbSynchronous( deviceExtension,
                                                 &srb,
                                                 Toc,
                                                 PIONEER_TRANSFER_SIZE
                                               );

                    if (!NT_SUCCESS(status)) {

                        CdDump(( 1,
                                 "PioneerDeviceControl => ReadTOC, read LeadOutTrack failed (%lx)\n",
                                 status ));
                        ExFreePool( Toc );
                        Irp->IoStatus.Information = 0;
                        goto SetStatusAndReturn;

                    }

                    cdaudioDataOut->TrackData[i].Reserved    = 0;
                    cdaudioDataOut->TrackData[i].Control     = 0x10;
                    cdaudioDataOut->TrackData[i].TrackNumber = 0xaa;
                    cdaudioDataOut->TrackData[i].Reserved1   = 0;
                    cdaudioDataOut->TrackData[i].Address[0]  = 0;
                    cdaudioDataOut->TrackData[i].Address[1]  = BCD_TO_DEC(Toc[0]);
                    cdaudioDataOut->TrackData[i].Address[2]  = BCD_TO_DEC(Toc[1]);
                    cdaudioDataOut->TrackData[i].Address[3]  = BCD_TO_DEC(Toc[2]);

                    CdDump(( 4,
                                "CdAudioPioneerDeviceControl: Track %d  %d:%d:%d\n",
                                cdaudioDataOut->TrackData[i].TrackNumber,
                                cdaudioDataOut->TrackData[i].Address[1],
                                cdaudioDataOut->TrackData[i].Address[2],
                                cdaudioDataOut->TrackData[i].Address[3]
                            ));

                    i++;
                }

                //
                // Set size of information transfered to
                // max size possible for CDROM Table of Contents
                //

                Irp->IoStatus.Information  = ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[i]));

            }

            ExFreePool( Toc );

        }
        break;

    case IOCTL_CDROM_STOP_AUDIO: {
            CdDump((3,
                    "PioneerDeviceControl => IOCTL_CDROM_STOP_AUDIO recv'd.\n"
                   ));


            deviceExtension->PlayActive = FALSE;

            //
            // Same as scsi-2 spec, so just send to default driver
            //

            return CdAudioSendToNextDriver( DeviceObject, Irp );
        }
        break;


    case IOCTL_CDROM_PLAY_AUDIO_MSF: {

            PCDROM_PLAY_AUDIO_MSF inputBuffer =
                Irp->AssociatedIrp.SystemBuffer;

            CdDump(( 3,
                     "PioneerDeviceControl => IOCTL_CDROM_PLAY_AUDIO_MSF recv'd.\n"
                     ));
            Irp->IoStatus.Information = 0;

            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CDROM_PLAY_AUDIO_MSF)
                ) {
                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }


            //
            // First, set play END point for the play operation
            //

            retry = 5;
            do {

                srb.CdbLength                     = 10;
                srb.TimeOutValue                  = AUDIO_TIMEOUT;
                cdb->PNR_SEEK_AUDIO.OperationCode =
                    PIONEER_AUDIO_TRACK_SEARCH_CODE;
                cdb->PNR_SEEK_AUDIO.Minute        =
                    DEC_TO_BCD(inputBuffer->StartingM);
                cdb->PNR_SEEK_AUDIO.Second        =
                    DEC_TO_BCD(inputBuffer->StartingS);
                cdb->PNR_SEEK_AUDIO.Frame         =
                    DEC_TO_BCD(inputBuffer->StartingF);
                cdb->PNR_SEEK_AUDIO.Type          = PIONEER_TYPE_ATIME;
                status = SendSrbSynchronous( deviceExtension,
                                             &srb,
                                             NULL,
                                             0
                                           );

            } while ( !NT_SUCCESS(status) && ((retry--)>0) );

            if (NT_SUCCESS(status)) {

                //
                // Now, set play start position and start playing.
                //

                RtlZeroMemory( cdb, MAXIMUM_CDB_SIZE );
                retry = 5;
                do {
                    srb.CdbLength = 10;
                    srb.TimeOutValue = AUDIO_TIMEOUT;
                    cdb->PNR_PLAY_AUDIO.OperationCode = PIONEER_PLAY_AUDIO_CODE;
                    cdb->PNR_PLAY_AUDIO.StopAddr      = 1;
                    cdb->PNR_PLAY_AUDIO.Minute        =
                        DEC_TO_BCD(inputBuffer->EndingM);
                    cdb->PNR_PLAY_AUDIO.Second        =
                        DEC_TO_BCD(inputBuffer->EndingS);
                    cdb->PNR_PLAY_AUDIO.Frame         =
                        DEC_TO_BCD(inputBuffer->EndingF);
                    cdb->PNR_PLAY_AUDIO.Type          =
                        PIONEER_TYPE_ATIME;
                    status = SendSrbSynchronous( deviceExtension,
                                                 &srb,
                                                 NULL,
                                                 0
                                               );
                } while ( !NT_SUCCESS(status) && ((retry--)>0) );

                if (NT_SUCCESS(status)) {

                    //
                    // Indicate the play actition is active.
                    //

                    deviceExtension->PlayActive = TRUE;


                }

#if DBG
                if (!NT_SUCCESS(status)) {
                    CdDump(( 1,
                             "PioneerDeviceControl => PLAY_AUDIO_MSF(stop) failed %lx\n",
                             status
                           ));

                    CdDump(( 3,
                             "PioneerDeviceControl => cdb = %p, srb = %p\n",
                             cdb, &srb
                           ));

                    if (CdAudioDebug>2)
                        DbgBreakPoint();
                }
#endif
            }
#if DBG
            else {

                CdDump(( 1,
                         "PioneerDeviceControl => PLAY_AUDIO_MSF(start) failed %lx\n",
                         status
                       ));
                CdDump(( 3,
                         "PioneerDeviceControl => cdb = %p, srb = %p\n",
                         cdb, &srb
                       ));

                if (CdAudioDebug>2)
                    DbgBreakPoint();


            }
#endif
        }
        break;

    case IOCTL_CDROM_SEEK_AUDIO_MSF: {

            PCDROM_SEEK_AUDIO_MSF inputBuffer = Irp->AssociatedIrp.SystemBuffer;

            CdDump(( 1,
                     "PioneerDeviceControl => IOCTL_CDROM_SEEK_AUDIO_MSF recv'd.\n"
                   ));
            Irp->IoStatus.Information = 0;

            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CDROM_SEEK_AUDIO_MSF)
                ) {
                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            retry = 5;
            do {

                //
                // seek to MSF and enter pause (still) mode.
                //

                srb.CdbLength                     = 10;
                srb.TimeOutValue                  = AUDIO_TIMEOUT;
                cdb->PNR_SEEK_AUDIO.OperationCode = PIONEER_AUDIO_TRACK_SEARCH_CODE;
                cdb->PNR_SEEK_AUDIO.Minute        = DEC_TO_BCD(inputBuffer->M);
                cdb->PNR_SEEK_AUDIO.Second        = DEC_TO_BCD(inputBuffer->S);
                cdb->PNR_SEEK_AUDIO.Frame         = DEC_TO_BCD(inputBuffer->F);
                cdb->PNR_SEEK_AUDIO.Type          = PIONEER_TYPE_ATIME;
                CdDump(( 3,
                         "PioneerDeviceControl => Seek to MSF %d:%d:%d, BCD(%x:%x:%x)\n",
                         inputBuffer->M,
                         inputBuffer->S,
                         inputBuffer->F,
                         cdb->PNR_SEEK_AUDIO.Minute,
                         cdb->PNR_SEEK_AUDIO.Second,
                         cdb->PNR_SEEK_AUDIO.Frame
                       ));
                CdDump(( 3,
                         "PioneerDeviceControl => Seek to MSF, cdb is %p, srb is %p\n",
                         cdb,
                         &srb
                       ));
#if DBG
                if (CdAudioDebug>2) {

                    DbgBreakPoint();

                }
#endif
                status = SendSrbSynchronous( deviceExtension,
                                             &srb,
                                             NULL,
                                             0
                                           );

            } while ( !NT_SUCCESS(status) && ((retry--)>0) );
#if DBG
            if (!NT_SUCCESS(status)) {

                CdDump((1,
                        "PioneerDeviceControl => Seek to MSF failed %lx\n",
                        status
                       ));

                if (CdAudioDebug>5) {

                    DbgBreakPoint();

                }
            }
#endif
        }
        break;

    case IOCTL_CDROM_PAUSE_AUDIO: {

            CdDump(( 3,
                     "PioneerDeviceControl => IOCTL_CDROM_PAUSE_AUDIO recv'd.\n"
                   ));

            Irp->IoStatus.Information = 0;
            deviceExtension->PlayActive = FALSE;

            //
            // Enter pause (still ) mode
            //

            srb.CdbLength                      = 10;
            srb.TimeOutValue                   = AUDIO_TIMEOUT;
            cdb->PNR_PAUSE_AUDIO.OperationCode = PIONEER_PAUSE_CODE;
            cdb->PNR_PAUSE_AUDIO.Pause         = 1;
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         NULL,
                                         0
                                       );
        }
        break;

    case IOCTL_CDROM_RESUME_AUDIO: {

            CdDump(( 3,
                     "PioneerDeviceControl => IOCTL_CDROM_RESUME_AUDIO recv'd.\n"
                   ));

            Irp->IoStatus.Information = 0;

            //
            // Resume Play
            //

            srb.CdbLength                      = 10;
            srb.TimeOutValue                   = AUDIO_TIMEOUT;
            cdb->PNR_PAUSE_AUDIO.OperationCode = PIONEER_PAUSE_CODE;
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         NULL,
                                         0
                                       );
        }
        break;

    case IOCTL_CDROM_READ_Q_CHANNEL: {
            PSUB_Q_CURRENT_POSITION userPtr =
                Irp->AssociatedIrp.SystemBuffer;
            PUCHAR SubQPtr =
                ExAllocatePool( NonPagedPoolCacheAligned,
                                PIONEER_Q_CHANNEL_TRANSFER_SIZE
                              );

            CdDump(( 5,
                     "PioneerDeviceControl => IOCTL_CDROM_READ_Q_CHANNEL recv'd.\n"
                   ));

            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SUB_Q_CURRENT_POSITION)
                ) {
                status = STATUS_BUFFER_TOO_SMALL;
                // we have transferred zero bytes
                Irp->IoStatus.Information = 0;
                if (SubQPtr) ExFreePool(SubQPtr);
                break;
            }

            if (SubQPtr==NULL) {

                CdDump(( 1,
                         "PioneerDeviceControl => READ_Q_CHANNEL, SubQPtr==NULL!\n"
                       ));

                RtlZeroMemory( userPtr, sizeof(SUB_Q_CURRENT_POSITION) );
                status = STATUS_INSUFFICIENT_RESOURCES;
                Irp->IoStatus.Information = 0;
                goto SetStatusAndReturn;

            }

            if ( ((PCDROM_SUB_Q_DATA_FORMAT)userPtr)->Format!=
                 IOCTL_CDROM_CURRENT_POSITION) {

                CdDump(( 1,
                         "PioneerDeviceControl => READ_Q_CHANNEL, Illegal Format (%d)!\n",
                         ((PCDROM_SUB_Q_DATA_FORMAT)userPtr)->Format
                       ));

                ExFreePool( SubQPtr );
                RtlZeroMemory( userPtr, sizeof(SUB_Q_CURRENT_POSITION) );
                Irp->IoStatus.Information = 0;
                status = STATUS_INVALID_DEVICE_REQUEST;
                goto SetStatusAndReturn;
            }

            //
            // Read audio play status
            //

            retry = 5;
            do {
                srb.CdbLength = 10;
                srb.TimeOutValue = AUDIO_TIMEOUT;
                cdb->PNR_AUDIO_STATUS.OperationCode  =
                    PIONEER_AUDIO_STATUS_CODE;
                cdb->PNR_AUDIO_STATUS.AssignedLength =
                    PIONEER_AUDIO_STATUS_TRANSFER_SIZE;  // Transfer Length
                status = SendSrbSynchronous( deviceExtension,
                                             &srb,
                                             SubQPtr,
                                             6
                                           );
            } while ( !NT_SUCCESS(status) &&
                      ((retry--)>0) &&
                      status != STATUS_DEVICE_NOT_READY
                    );

            if (NT_SUCCESS(status)) {

                userPtr->Header.Reserved = 0;
                if (SubQPtr[0]==0x00)
                    userPtr->Header.AudioStatus = AUDIO_STATUS_IN_PROGRESS;
                else if (SubQPtr[0]==0x01) {
                    deviceExtension->PlayActive = FALSE;
                    userPtr->Header.AudioStatus = AUDIO_STATUS_PAUSED;
                } else if (SubQPtr[0]==0x02) {
                    deviceExtension->PlayActive = FALSE;
                    userPtr->Header.AudioStatus = AUDIO_STATUS_PAUSED;
                } else if (SubQPtr[0]==0x03) {

                    userPtr->Header.AudioStatus = AUDIO_STATUS_PLAY_COMPLETE;
                    deviceExtension->PlayActive = FALSE;

                } else {
                    deviceExtension->PlayActive = FALSE;

                }

            } else {

                CdDump(( 1,
                         "PioneerDeviceControl => read status code (Q) failed (%lx)\n",
                         status
                       ));

                ExFreePool( SubQPtr );
                Irp->IoStatus.Information = 0;
                goto SetStatusAndReturn;

            }

            //
            // Set up to read current position from Q Channel
            //

            RtlZeroMemory( cdb, MAXIMUM_CDB_SIZE );
            retry =  5;
            do {
                srb.CdbLength = 10;
                srb.TimeOutValue = AUDIO_TIMEOUT;
                cdb->PNR_READ_Q_CHANNEL.OperationCode  =
                    PIONEER_READ_SUB_Q_CHANNEL_CODE;
                cdb->PNR_READ_Q_CHANNEL.AssignedLength =
                    PIONEER_Q_CHANNEL_TRANSFER_SIZE;  // Transfer Length
                status = SendSrbSynchronous( deviceExtension,
                                             &srb,
                                             SubQPtr,
                                             PIONEER_Q_CHANNEL_TRANSFER_SIZE
                                           );

            } while ( !NT_SUCCESS(status) && ((retry--)>0) );

            if (NT_SUCCESS(status)) {

                userPtr->Header.DataLength[0] = 0;
                userPtr->Header.DataLength[0] = 12;

                userPtr->FormatCode = 0x01;
                userPtr->Control = SubQPtr[0] & 0x0F;
                userPtr->ADR     = 0;
                userPtr->TrackNumber = BCD_TO_DEC(SubQPtr[1]);
                userPtr->IndexNumber = BCD_TO_DEC(SubQPtr[2]);
                userPtr->AbsoluteAddress[0] = 0;
                userPtr->AbsoluteAddress[1] = BCD_TO_DEC((SubQPtr[6]));
                userPtr->AbsoluteAddress[2] = BCD_TO_DEC((SubQPtr[7]));
                userPtr->AbsoluteAddress[3] = BCD_TO_DEC((SubQPtr[8]));
                userPtr->TrackRelativeAddress[0] = 0;
                userPtr->TrackRelativeAddress[1] = BCD_TO_DEC((SubQPtr[3]));
                userPtr->TrackRelativeAddress[2] = BCD_TO_DEC((SubQPtr[4]));
                userPtr->TrackRelativeAddress[3] = BCD_TO_DEC((SubQPtr[5]));
                Irp->IoStatus.Information = sizeof(SUB_Q_CURRENT_POSITION);

            } else {

                Irp->IoStatus.Information = 0;
                CdDump(( 1,
                         "PioneerDeviceControl => read q channel failed (%lx)\n",
                         status
                       ));

            }

            ExFreePool( SubQPtr );
        }
        break;

    case IOCTL_CDROM_EJECT_MEDIA: {

            CdDump(( 3, "PioneerDeviceControl => "
                     "IOCTL_CDROM_EJECT_MEDIA recv'd. "));
            Irp->IoStatus.Information = 0;

            deviceExtension->PlayActive = FALSE;

            //
            // Build cdb to eject cartridge
            //

            if (deviceExtension->Active == CDAUDIO_PIONEER) {
                srb.CdbLength            = 10;
                srb.TimeOutValue         = AUDIO_TIMEOUT;
                cdb->PNR_EJECT.OperationCode = PIONEER_EJECT_CODE;
                cdb->PNR_EJECT.Immediate     = 1;
            } else {
                srb.CdbLength = 6;

                scsiCdb->START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
                scsiCdb->START_STOP.LoadEject = 1;
                scsiCdb->START_STOP.Start = 0;
            }


            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         NULL,
                                         0
                                       );
            CdDump(( 1, "PioneerDeviceControl => "
                     "IOCTL_CDROM_EJECT_MEDIA returned %lx.\n",
                     status
                   ));
        }
        break;

    case IOCTL_CDROM_GET_CONTROL:
    case IOCTL_CDROM_GET_VOLUME:
    case IOCTL_CDROM_SET_VOLUME:

        CdDump(( 3, "PioneerDeviceControl => Not Supported yet.\n" ));
        Irp->IoStatus.Information = 0;
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    case IOCTL_CDROM_CHECK_VERIFY:

        //
        // Update the play active flag.
        //

        CdAudioIsPlayActive(DeviceObject);

    default:

        CdDump((10,"PioneerDeviceControl => Unsupported device IOCTL\n"));
        return CdAudioSendToNextDriver( DeviceObject, Irp );
        break;



    } // end switch( IOCTL )

    SetStatusAndReturn:
    //
    // set status code and return
    //

    if (status == STATUS_VERIFY_REQUIRED) {

        //
        // If the status is verified required and the this request
        // should bypass verify required then retry the request.
        //

        if (currentIrpStack->Flags & SL_OVERRIDE_VERIFY_VOLUME) {

            status = STATUS_IO_DEVICE_ERROR;
            goto PioneerRestart;

        }


        IoSetHardErrorOrVerifyDevice( Irp,
                                      deviceExtension->TargetDeviceObject
                                    );

        Irp->IoStatus.Information = 0;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;

}


NTSTATUS
    CdAudioDenonDeviceControl(
                             PDEVICE_OBJECT DeviceObject,
                             PIRP Irp
                             )

/*++

Routine Description:

    This routine is called by CdAudioDeviceControl to handle
    audio IOCTLs sent to DENON DRD-253 cdrom drive.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PCD_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCDROM_TOC         cdaudioDataOut  = Irp->AssociatedIrp.SystemBuffer;
    SCSI_PASS_THROUGH  srb;
    PCDB               cdb = (PCDB)srb.Cdb;
    NTSTATUS           status;
    ULONG              i,bytesTransfered;
    PUCHAR             Toc;

    DenonRestart:

    //
    // Clear out cdb
    //

    RtlZeroMemory( cdb, MAXIMUM_CDB_SIZE );

    //
    // What IOCTL do we need to execute?
    //

    switch (currentIrpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_CDROM_GET_LAST_SESSION:

        //
        // Multiple sessions are not supported.
        //

        status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;
        break;

    case IOCTL_CDROM_READ_TOC:
        CdDump(( 3,
                 "DenonDeviceControl => IOCTL_CDROM_READ_TOC recv'd.\n"
               ));

        //
        // Must have allocated at least enough buffer space
        // to store how many tracks are on the disc
        //

        if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
            ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[0]))
            ) {
            status = STATUS_BUFFER_TOO_SMALL;
            // we have transferred zero bytes
            Irp->IoStatus.Information = 0;
            break;
        }

        //
        // If the cd is playing music then reject this request.
        //

        if (CdAudioIsPlayActive(DeviceObject)) {
            status = STATUS_DEVICE_BUSY;
            Irp->IoStatus.Information = 0;
            break;
        }


        //
        // Allocate storage to hold TOC from disc
        //

        Toc = (PUCHAR)ExAllocatePool( NonPagedPoolCacheAligned,
                                      CDROM_TOC_SIZE
                                    );

        if (Toc==NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Information = 0;
            goto SetStatusAndReturn;

        }

        //
        // Set up defaults
        //

        RtlZeroMemory( Toc, CDROM_TOC_SIZE );

        //
        // Fill in cdb for this operation
        //

        cdb->CDB6GENERIC.OperationCode = DENON_READ_TOC_CODE;
        srb.TimeOutValue               = AUDIO_TIMEOUT;
        srb.CdbLength                  = 6;
        status = SendSrbSynchronous( deviceExtension,
                                     &srb,
                                     Toc,
                                     CDROM_TOC_SIZE
                                   );

        if (!NT_SUCCESS(status) && (status!=STATUS_DATA_OVERRUN)) {

            CdDump(( 1,
                     "DenonDeviceControl => READ_TOC error (%lx)\n",
                     status ));

            if (status != STATUS_DATA_OVERRUN) {

                CdDump(( 1, "DenonDeviceControl => SRB ERROR (%lx)\n",
                         status ));
                ExFreePool( Toc );
                Irp->IoStatus.Information = 0;
                goto SetStatusAndReturn;
            }

        }

        //
        // Set the status to success since data under runs are not an error.
        //

        status = STATUS_SUCCESS;

        //
        // Since the Denon manual didn't define the format of
        // the buffer returned from this call, here it is:
        //
        // Byte  Data (4 byte "packets")
        //
        //  00   a0 FT 00 00 (FT       == BCD of first track number on disc)
        //  04   a1 LT 00 00 (LT       == BCD of last  track number on disc)
        //  08   a2 MM SS FF (MM SS FF == BCD of total disc time, in MSF)
        //
        //  For each track on disc:
        //
        //  0C   XX   MM SS FF (MM SS FF == BCD MSF start position of track XX)
        //  0C+4 XX+1 MM SS FF (MM SS FF == BCD MSF start position of track XX+1)
        //
        //  etc., for each track
        //

        //
        // Translate data into our format
        //

        bytesTransfered =
            currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength >
            srb.DataTransferLength ?
            srb.DataTransferLength :
            currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

        cdaudioDataOut->FirstTrack = BCD_TO_DEC(Toc[1]);
        cdaudioDataOut->LastTrack  = BCD_TO_DEC(Toc[5]);

        //
        // Return only N number of tracks, where N is the number of
        // full tracks of info we can stuff into the user buffer
        // if tracks from 1 to 2, that means there are two tracks,
        // so let i go from 0 to 1 (two tracks of info)
        //
        {
            //
            // tracksToReturn == Number of real track info to return
            // tracksInBuffer == How many fit into the user-supplied buffer
            // tracksOnCd     == Number of tracks on the CD (not including lead-out)
            //

            ULONG tracksToReturn;
            ULONG tracksOnCd;
            ULONG tracksInBuffer;
            ULONG dataLength;
            tracksOnCd = (cdaudioDataOut->LastTrack - cdaudioDataOut->FirstTrack) + 1;

            //
            // set the length of the data per SCSI2 spec
            //

            dataLength = ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[tracksOnCd])) - 2;
            cdaudioDataOut->Length[0]  = (UCHAR)(dataLength >> 8);
            cdaudioDataOut->Length[1]  = (UCHAR)(dataLength &  0xFF);

            tracksInBuffer = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength -
                             ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[0]));
            tracksInBuffer /= sizeof(TRACK_DATA);

            // take the lesser of the two
            tracksToReturn = (tracksInBuffer < tracksOnCd) ?
                             tracksInBuffer :
                             tracksOnCd;

            for( i=0; i < tracksToReturn; i++ ) {

                //
                // Grab Information for each track
                //

                cdaudioDataOut->TrackData[i].Reserved = 0;
                cdaudioDataOut->TrackData[i].Control  = Toc[(i*4)+12];
                cdaudioDataOut->TrackData[i].TrackNumber =
                    (UCHAR)((i + cdaudioDataOut->FirstTrack));

                cdaudioDataOut->TrackData[i].Reserved1  = 0;
                cdaudioDataOut->TrackData[i].Address[0] = 0;
                cdaudioDataOut->TrackData[i].Address[1] =
                    BCD_TO_DEC((Toc[(i*4)+13]));
                cdaudioDataOut->TrackData[i].Address[2] =
                    BCD_TO_DEC((Toc[(i*4)+14]));
                cdaudioDataOut->TrackData[i].Address[3] =
                    BCD_TO_DEC((Toc[(i*4)+15]));

                CdDump(( 4,
                            "CdAudioDenonDeviceControl: Track %d  %d:%d:%d\n",
                            cdaudioDataOut->TrackData[i].TrackNumber,
                            cdaudioDataOut->TrackData[i].Address[1],
                            cdaudioDataOut->TrackData[i].Address[2],
                            cdaudioDataOut->TrackData[i].Address[3]
                        ));
            }

            //
            // Fake "lead out track" info
            // Only if all tracks have been copied...
            //

            if ( tracksInBuffer > tracksOnCd ) {
                cdaudioDataOut->TrackData[i].Reserved    = 0;
                cdaudioDataOut->TrackData[i].Control     = 0;
                cdaudioDataOut->TrackData[i].TrackNumber = 0xaa;
                cdaudioDataOut->TrackData[i].Reserved1   = 0;
                cdaudioDataOut->TrackData[i].Address[0]  = 0;
                cdaudioDataOut->TrackData[i].Address[1]  = BCD_TO_DEC(Toc[9]);
                cdaudioDataOut->TrackData[i].Address[2]  = BCD_TO_DEC(Toc[10]);
                cdaudioDataOut->TrackData[i].Address[3]  = BCD_TO_DEC(Toc[11]);
                CdDump(( 4,
                            "CdAudioDenonDeviceControl: Track %d  %d:%d:%d\n",
                            cdaudioDataOut->TrackData[i].TrackNumber,
                            cdaudioDataOut->TrackData[i].Address[1],
                            cdaudioDataOut->TrackData[i].Address[2],
                            cdaudioDataOut->TrackData[i].Address[3]
                        ));
                i++;
            }
            Irp->IoStatus.Information = ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[i]));

        }

        //
        // Clear out deviceExtension data
        //

        deviceExtension->Paused = CDAUDIO_NOT_PAUSED;
        deviceExtension->PausedM = 0;
        deviceExtension->PausedS = 0;
        deviceExtension->PausedF = 0;
        deviceExtension->LastEndM = 0;
        deviceExtension->LastEndS = 0;
        deviceExtension->LastEndF = 0;

        //
        // Free storage now that we've stored it elsewhere
        //

        ExFreePool( Toc );
        break;

    case IOCTL_CDROM_PLAY_AUDIO_MSF:
    case IOCTL_CDROM_STOP_AUDIO:
        {

            PCDROM_PLAY_AUDIO_MSF inputBuffer =
                Irp->AssociatedIrp.SystemBuffer;

            Irp->IoStatus.Information = 0;

            deviceExtension->PlayActive = FALSE;

            srb.CdbLength                  = 6;
            srb.TimeOutValue               = AUDIO_TIMEOUT;
            cdb->CDB6GENERIC.OperationCode = DENON_STOP_AUDIO_CODE;
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         NULL,
                                         0
                                       );

            if (NT_SUCCESS(status)) {

                deviceExtension->Paused = CDAUDIO_NOT_PAUSED;
                deviceExtension->PausedM = 0;
                deviceExtension->PausedS = 0;
                deviceExtension->PausedF = 0;
                deviceExtension->LastEndM = 0;
                deviceExtension->LastEndS = 0;
                deviceExtension->LastEndF = 0;

            } else {

                CdDump(( 3,
                         "DenonDeviceControl => STOP failed (%lx)\n",
                         status ));

            }


            if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_CDROM_STOP_AUDIO
               ) {

                CdDump((3,
                        "DenonDeviceControl => IOCTL_CDROM_STOP_AUDIO recv'd.\n"
                       ));

                goto SetStatusAndReturn;

            }

            CdDump((3,
                    "DenonDeviceControl => IOCTL_CDROM_PLAY_AUDIO_MSF recv'd.\n"
                   ));

            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CDROM_PLAY_AUDIO_MSF)
                ) {
                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            //
            // Fill in cdb for this operation
            //

            srb.CdbLength                = 10;
            srb.TimeOutValue             = AUDIO_TIMEOUT;
            cdb->CDB10.OperationCode     = DENON_PLAY_AUDIO_EXTENDED_CODE;
            cdb->CDB10.LogicalBlockByte0 = DEC_TO_BCD(inputBuffer->StartingM);
            cdb->CDB10.LogicalBlockByte1 = DEC_TO_BCD(inputBuffer->StartingS);
            cdb->CDB10.LogicalBlockByte2 = DEC_TO_BCD(inputBuffer->StartingF);
            cdb->CDB10.LogicalBlockByte3 = DEC_TO_BCD(inputBuffer->EndingM);
            cdb->CDB10.Reserved2         = DEC_TO_BCD(inputBuffer->EndingS);
            cdb->CDB10.TransferBlocksMsb = DEC_TO_BCD(inputBuffer->EndingF);
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         NULL,
                                         0
                                       );

            if (NT_SUCCESS(status)) {

                //
                // Indicate the play actition is active.
                //

                deviceExtension->PlayActive = TRUE;
                deviceExtension->Paused = CDAUDIO_NOT_PAUSED;

                //
                // Set last play ending address for next pause command
                //

                deviceExtension->LastEndM = DEC_TO_BCD(inputBuffer->EndingM);
                deviceExtension->LastEndS = DEC_TO_BCD(inputBuffer->EndingS);
                deviceExtension->LastEndF = DEC_TO_BCD(inputBuffer->EndingF);
                CdDump(( 3,
                         "DenonDeviceControl => PLAY  ==> BcdLastEnd set to (%x %x %x)\n",
                         deviceExtension->LastEndM,
                         deviceExtension->LastEndS,
                         deviceExtension->LastEndF ));

            } else {

                CdDump(( 3,
                         "DenonDeviceControl => PLAY failed (%lx)\n",
                         status ));

                //
                // The Denon drive returns STATUS_INVALD_DEVICE_REQUEST
                // when we ask to play an invalid address, so we need
                // to map to STATUS_NONEXISTENT_SECTOR in order to be
                // consistent with the other drives.
                //

                if (status==STATUS_INVALID_DEVICE_REQUEST) {

                    status = STATUS_NONEXISTENT_SECTOR;
                }

            }
        }
        break;

    case IOCTL_CDROM_SEEK_AUDIO_MSF:
        {

            PCDROM_SEEK_AUDIO_MSF inputBuffer = Irp->AssociatedIrp.SystemBuffer;

            Irp->IoStatus.Information = 0;

            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CDROM_SEEK_AUDIO_MSF)
                ) {
                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }


            CdDump(( 3,
                    "DenonDeviceControl => IOCTL_CDROM_SEEK_AUDIO_MSF recv'd.\n"
                   ));

            //
            // Fill in cdb for this operation
            //

            srb.CdbLength                = 10;
            srb.TimeOutValue             = AUDIO_TIMEOUT;
            cdb->CDB10.OperationCode     = DENON_PLAY_AUDIO_EXTENDED_CODE;
            cdb->CDB10.LogicalBlockByte0 = DEC_TO_BCD(inputBuffer->M);
            cdb->CDB10.LogicalBlockByte1 = DEC_TO_BCD(inputBuffer->S);
            cdb->CDB10.LogicalBlockByte2 = DEC_TO_BCD(inputBuffer->F);
            cdb->CDB10.LogicalBlockByte3 = DEC_TO_BCD(inputBuffer->M);
            cdb->CDB10.Reserved2         = DEC_TO_BCD(inputBuffer->S);
            cdb->CDB10.TransferBlocksMsb = DEC_TO_BCD(inputBuffer->F);
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         NULL,
                                         0
                                       );

            if (NT_SUCCESS(status)) {

                deviceExtension->Paused = CDAUDIO_PAUSED;
                deviceExtension->PausedM = DEC_TO_BCD(inputBuffer->M);
                deviceExtension->PausedS = DEC_TO_BCD(inputBuffer->S);
                deviceExtension->PausedF = DEC_TO_BCD(inputBuffer->F);
                deviceExtension->LastEndM = DEC_TO_BCD(inputBuffer->M);
                deviceExtension->LastEndS = DEC_TO_BCD(inputBuffer->S);
                deviceExtension->LastEndF = DEC_TO_BCD(inputBuffer->F);
                CdDump(( 3,
                         "DenonDeviceControl => SEEK, Paused (%x %x %x) LastEnd (%x %x %x)\n",
                         deviceExtension->PausedM,
                         deviceExtension->PausedS,
                         deviceExtension->PausedF,
                         deviceExtension->LastEndM,
                         deviceExtension->LastEndS,
                         deviceExtension->LastEndF ));

            } else {

                CdDump(( 3,
                         "DenonDeviceControl => SEEK failed (%lx)\n",
                         status ));

                //
                // The Denon drive returns STATUS_INVALD_DEVICE_REQUEST
                // when we ask to play an invalid address, so we need
                // to map to STATUS_NONEXISTENT_SECTOR in order to be
                // consistent with the other drives.
                //

                if (status==STATUS_INVALID_DEVICE_REQUEST) {

                    status = STATUS_NONEXISTENT_SECTOR;
                }

            }
        }
        break;

    case IOCTL_CDROM_PAUSE_AUDIO:
        {
            PUCHAR SubQPtr =
                ExAllocatePool( NonPagedPoolCacheAligned,
                                10
                              );

            Irp->IoStatus.Information = 0;

            CdDump(( 3,
                     "DenonDeviceControl => IOCTL_CDROM_PAUSE_AUDIO recv'd.\n"
                   ));

            deviceExtension->PlayActive = FALSE;

            if (SubQPtr==NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto SetStatusAndReturn;

            }

            //
            // Enter pause (still ) mode
            //

            if (deviceExtension->Paused==CDAUDIO_PAUSED) {

                CdDump(( 3,
                         "DenonDeviceControl => PAUSE: Already Paused!\n"
                       ));

                ExFreePool( SubQPtr );
                status = STATUS_SUCCESS;
                goto SetStatusAndReturn;

            }

            //
            // Since the Denon doesn't have a pause mode,
            // we'll just record the current position and
            // stop the drive.
            //

            srb.CdbLength                  = 6;
            srb.TimeOutValue               = AUDIO_TIMEOUT;
            cdb->CDB6GENERIC.OperationCode = DENON_READ_SUB_Q_CHANNEL_CODE;
            cdb->CDB6GENERIC.CommandUniqueBytes[2] = 10; // Transfer Length
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         SubQPtr,
                                         10
                                       );
            if (!NT_SUCCESS(status)) {

                CdDump(( 1,
                         "DenonDeviceControl => Pause, Read Q Channel failed (%lx)\n",
                         status ));
                ExFreePool( SubQPtr );
                goto SetStatusAndReturn;
            }

            deviceExtension->PausedM = SubQPtr[7];
            deviceExtension->PausedS = SubQPtr[8];
            deviceExtension->PausedF = SubQPtr[9];

            RtlZeroMemory( cdb, MAXIMUM_CDB_SIZE );
            srb.CdbLength                  = 6;
            srb.TimeOutValue               = AUDIO_TIMEOUT;
            cdb->CDB6GENERIC.OperationCode = DENON_STOP_AUDIO_CODE;
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         NULL,
                                         0
                                       );
            if (!NT_SUCCESS(status)) {

                CdDump(( 1,
                         "DenonDeviceControl => PAUSE, StopAudio failed! (%lx)\n",
                         status ));
                ExFreePool( SubQPtr );
                goto SetStatusAndReturn;
            }

            deviceExtension->Paused = CDAUDIO_PAUSED;
            deviceExtension->PausedM = SubQPtr[7];
            deviceExtension->PausedS = SubQPtr[8];
            deviceExtension->PausedF = SubQPtr[9];

            CdDump((3,
                    "DenonDeviceControl => PAUSE ==> Paused  set to (%x %x %x)\n",
                    deviceExtension->PausedM,
                    deviceExtension->PausedS,
                    deviceExtension->PausedF ));

            ExFreePool( SubQPtr );
        }
        break;

    case IOCTL_CDROM_RESUME_AUDIO:

        //
        // Resume cdrom
        //

        CdDump(( 3,
                 "DenonDeviceControl => IOCTL_CDROM_RESUME_AUDIO recv'd.\n"
               ));

        Irp->IoStatus.Information = 0;

        //
        // Since the Denon doesn't have a resume IOCTL,
        // we'll just start playing (if paused) from the
        // last recored paused position to the last recorded
        // "end of play" position.
        //

        if (deviceExtension->Paused==CDAUDIO_NOT_PAUSED) {

            status = STATUS_UNSUCCESSFUL;
            goto SetStatusAndReturn;

        }



        //
        // Fill in cdb for this operation
        //

        srb.CdbLength                = 10;
        srb.TimeOutValue             = AUDIO_TIMEOUT;
        cdb->CDB10.OperationCode     = DENON_PLAY_AUDIO_EXTENDED_CODE;
        cdb->CDB10.LogicalBlockByte0 = deviceExtension->PausedM;
        cdb->CDB10.LogicalBlockByte1 = deviceExtension->PausedS;
        cdb->CDB10.LogicalBlockByte2 = deviceExtension->PausedF;
        cdb->CDB10.LogicalBlockByte3 = deviceExtension->LastEndM;
        cdb->CDB10.Reserved2         = deviceExtension->LastEndS;
        cdb->CDB10.TransferBlocksMsb = deviceExtension->LastEndF;
        status = SendSrbSynchronous( deviceExtension,
                                     &srb,
                                     NULL,
                                     0
                                   );

        if (NT_SUCCESS(status)) {

            deviceExtension->Paused = CDAUDIO_NOT_PAUSED;

        } else {

            CdDump(( 1,
                     "DenonDeviceControl => RESUME (%x %x %x) - (%x %x %x) failed (%lx)\n",
                     deviceExtension->PausedM,
                     deviceExtension->PausedS,
                     deviceExtension->PausedF,
                     deviceExtension->LastEndM,
                     deviceExtension->LastEndS,
                     deviceExtension->LastEndF,
                     status ));

        }
        break;

    case IOCTL_CDROM_READ_Q_CHANNEL:
        {
            PSUB_Q_CURRENT_POSITION userPtr =
                Irp->AssociatedIrp.SystemBuffer;
            PUCHAR SubQPtr =
                ExAllocatePool( NonPagedPoolCacheAligned,
                                sizeof(SUB_Q_CHANNEL_DATA)
                              );

            CdDump(( 5,
                     "DenonDeviceControl => IOCTL_CDROM_READ_Q_CHANNEL recv'd.\n"
                   ));

            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SUB_Q_CURRENT_POSITION)
                ) {
                status = STATUS_BUFFER_TOO_SMALL;
                // we have transferred zero bytes
                Irp->IoStatus.Information = 0;
                if (SubQPtr) ExFreePool(SubQPtr);
                break;
            }


            if (SubQPtr==NULL) {

                CdDump(( 1,
                         "DenonDeviceControl => READ_Q_CHANNEL, SubQPtr==NULL!\n"
                       ));

                RtlZeroMemory( userPtr, sizeof(SUB_Q_CURRENT_POSITION) );
                status = STATUS_INSUFFICIENT_RESOURCES;
                Irp->IoStatus.Information = 0;
                goto SetStatusAndReturn;

            }

            if ( ((PCDROM_SUB_Q_DATA_FORMAT)userPtr)->Format!=
                 IOCTL_CDROM_CURRENT_POSITION) {

                CdDump(( 1,
                         "DenonDeviceControl => READ_Q_CHANNEL, illegal Format (%d)\n",
                         ((PCDROM_SUB_Q_DATA_FORMAT)userPtr)->Format
                       ));

                ExFreePool( SubQPtr );
                RtlZeroMemory( userPtr, sizeof(SUB_Q_CURRENT_POSITION) );
                status = STATUS_UNSUCCESSFUL;
                Irp->IoStatus.Information = 0;
                goto SetStatusAndReturn;
            }

            //
            // Read audio play status
            //

            srb.CdbLength            = 6;
            srb.TimeOutValue         = AUDIO_TIMEOUT;
            cdb->CDB6GENERIC.OperationCode = DENON_READ_SUB_Q_CHANNEL_CODE;
            cdb->CDB6GENERIC.CommandUniqueBytes[2] = 10; // Transfer Length
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         SubQPtr,
                                         10
                                       );
            if (NT_SUCCESS(status)) {

                userPtr->Header.Reserved = 0;

                if (deviceExtension->Paused==CDAUDIO_PAUSED) {

                    deviceExtension->PlayActive = FALSE;
                    userPtr->Header.AudioStatus = AUDIO_STATUS_PAUSED;

                } else {

                    if (SubQPtr[0]==0x01)
                        userPtr->Header.AudioStatus = AUDIO_STATUS_IN_PROGRESS;
                    else if (SubQPtr[0]==0x00) {
                        userPtr->Header.AudioStatus =
                            AUDIO_STATUS_PLAY_COMPLETE;
                        deviceExtension->PlayActive = FALSE;

                    } else {
                        deviceExtension->PlayActive = FALSE;
                    }

                }

                userPtr->Header.DataLength[0] = 0;
                userPtr->Header.DataLength[0] = 12;

                userPtr->FormatCode = 0x01;
                userPtr->Control = SubQPtr[1];
                userPtr->ADR     = 0;
                userPtr->TrackNumber = BCD_TO_DEC(SubQPtr[2]);
                userPtr->IndexNumber = BCD_TO_DEC(SubQPtr[3]);
                userPtr->AbsoluteAddress[0] = 0;
                userPtr->AbsoluteAddress[1] = BCD_TO_DEC((SubQPtr[7]));
                userPtr->AbsoluteAddress[2] = BCD_TO_DEC((SubQPtr[8]));
                userPtr->AbsoluteAddress[3] = BCD_TO_DEC((SubQPtr[9]));
                userPtr->TrackRelativeAddress[0] = 0;
                userPtr->TrackRelativeAddress[1] = BCD_TO_DEC((SubQPtr[4]));
                userPtr->TrackRelativeAddress[2] = BCD_TO_DEC((SubQPtr[5]));
                userPtr->TrackRelativeAddress[3] = BCD_TO_DEC((SubQPtr[6]));
                Irp->IoStatus.Information = sizeof(SUB_Q_CURRENT_POSITION);

            } else {
                CdDump(( 1,
                         "DenonDeviceControl => READ_Q_CHANNEL failed (%lx)\n",
                         status
                       ));
                Irp->IoStatus.Information = 0;

            }

            ExFreePool( SubQPtr );
        }
        break;

    case IOCTL_CDROM_EJECT_MEDIA:

        //
        // Build cdb to eject cartridge
        //
        Irp->IoStatus.Information = 0;

        CdDump(( 3,
                 "DenonDeviceControl => IOCTL_CDROM_EJECT_MEDIA recv'd.\n"
               ));

        deviceExtension->PlayActive = FALSE;

        srb.CdbLength                  = 6;
        srb.TimeOutValue               = AUDIO_TIMEOUT;
        cdb->CDB6GENERIC.OperationCode = DENON_EJECT_CODE;
        status = SendSrbSynchronous( deviceExtension,
                                     &srb,
                                     NULL,
                                     0
                                   );
        break;

    case IOCTL_CDROM_GET_CONTROL:
    case IOCTL_CDROM_GET_VOLUME:
    case IOCTL_CDROM_SET_VOLUME:
        CdDump(( 3, "DenonDeviceControl => Not Supported yet.\n" ));
        Irp->IoStatus.Information = 0;
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    case IOCTL_CDROM_CHECK_VERIFY:

        //
        // Update the play active flag.
        //

        CdAudioIsPlayActive(DeviceObject);

    default:

        CdDump((10,"DenonDeviceControl => Unsupported device IOCTL\n"));
        return CdAudioSendToNextDriver( DeviceObject, Irp );
        break;

    } // end switch( IOCTL )

    SetStatusAndReturn:
    //
    // set status code and return
    //

    if (status == STATUS_VERIFY_REQUIRED) {

        //
        // If the status is verified required and the this request
        // should bypass verify required then retry the request.
        //

        if (currentIrpStack->Flags & SL_OVERRIDE_VERIFY_VOLUME) {

            status = STATUS_IO_DEVICE_ERROR;
            goto DenonRestart;

        }


        IoSetHardErrorOrVerifyDevice( Irp,
                                      deviceExtension->TargetDeviceObject
                                    );

        Irp->IoStatus.Information = 0;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;

}

NTSTATUS
    CdAudioHitachiSendPauseCommand(
                                  IN PDEVICE_OBJECT DeviceObject
                                  )

/*++

Routine Description:

    This routine sends a PAUSE cdb to the Hitachi drive.  The Hitachi
    drive returns a "busy" condition whenever a play audio command is in
    progress...so we need to bump the drive out of audio play to issue
    a new command.  This routine is in place for this purpose.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PCD_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    SCSI_PASS_THROUGH  srb;
    PHITACHICDB        cdb = (PHITACHICDB)srb.Cdb;
    NTSTATUS           status;
    PUCHAR             PausePos;

    //
    // Allocate buffer for pause data
    //

    PausePos = (PUCHAR)ExAllocatePool( NonPagedPoolCacheAligned, 3 );

    if (PausePos==NULL) {

        return(STATUS_INSUFFICIENT_RESOURCES);

    }

    RtlZeroMemory( PausePos, 3 );

    //
    // Clear out cdb
    //

    RtlZeroMemory( cdb, MAXIMUM_CDB_SIZE );

    //
    // Clear audio play command so that next command will be issued
    //

    srb.CdbLength    = 12;
    srb.TimeOutValue = AUDIO_TIMEOUT;
    cdb->PAUSE_AUDIO.OperationCode = HITACHI_PAUSE_AUDIO_CODE;
    status = SendSrbSynchronous( deviceExtension,
                                 &srb,
                                 PausePos,
                                 3
                               );

    ExFreePool( PausePos );

    return status;
}

NTSTATUS
    CdAudioHitachiDeviceControl(
                               IN PDEVICE_OBJECT DeviceObject,
                               IN PIRP Irp
                               )

/*++

Routine Description:

    This routine is called by CdAudioDeviceControl to handle
    audio IOCTLs sent to Hitachi cdrom drives.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PCD_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCDROM_TOC         cdaudioDataOut  = Irp->AssociatedIrp.SystemBuffer;
    SCSI_PASS_THROUGH  srb;
    PHITACHICDB        cdb = (PHITACHICDB)srb.Cdb;
    NTSTATUS           status;
    ULONG              i,bytesTransfered;
    PUCHAR             Toc;

    HitachiRestart:

    //
    // Clear out cdb
    //

    RtlZeroMemory( cdb, MAXIMUM_CDB_SIZE );

    //
    // What IOCTL do we need to execute?
    //

    switch (currentIrpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_CDROM_READ_TOC:
        CdDump(( 3,
                 "HitachiDeviceControl => IOCTL_CDROM_READ_TOC recv'd.\n"
               ));

        //
        // Must have allocated at least enough buffer space
        // to store how many tracks are on the disc
        //

        if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
            ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[0]))
            ) {
            status = STATUS_BUFFER_TOO_SMALL;
            // we have transferred zero bytes
            Irp->IoStatus.Information = 0;
            break;
        }

        //
        // If the cd is playing music then reject this request.
        //

        if (CdAudioIsPlayActive(DeviceObject)) {
            status = STATUS_DEVICE_BUSY;
            Irp->IoStatus.Information = 0;
            break;
        }

        //
        // Allocate storage to hold TOC from disc
        //

        Toc = (PUCHAR)ExAllocatePool( NonPagedPoolCacheAligned,
                                      CDROM_TOC_SIZE
                                    );

        if (Toc==NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Information = 0;
            goto SetStatusAndReturn;

        }

        //
        // Set up defaults
        //

        RtlZeroMemory( Toc, CDROM_TOC_SIZE );
        srb.CdbLength = 12;

        //
        // Fill in CDB
        //

        if (deviceExtension->Active == CDAUDIO_FUJITSU) {
            cdb->READ_DISC_INFO.OperationCode = FUJITSU_READ_TOC_CODE;
        } else {
            cdb->READ_DISC_INFO.OperationCode = HITACHI_READ_TOC_CODE;
        }
        cdb->READ_DISC_INFO.AllocationLength[0] = CDROM_TOC_SIZE >> 8;
        cdb->READ_DISC_INFO.AllocationLength[1] = CDROM_TOC_SIZE & 0xFF;
        srb.TimeOutValue                        = AUDIO_TIMEOUT;
        status = SendSrbSynchronous( deviceExtension,
                                     &srb,
                                     Toc,
                                     CDROM_TOC_SIZE
                                   );

        if (!NT_SUCCESS(status) && (status!=STATUS_DATA_OVERRUN)) {

            CdDump(( 1,
                     "HitachiDeviceControl => READ_TOC error (%lx)\n",
                     status ));


            if (status != STATUS_DATA_OVERRUN) {

                CdDump(( 1, "HitachiDeviceControl => SRB ERROR (%lx)\n",
                         status ));
                ExFreePool( Toc );
                Irp->IoStatus.Information = 0;
                goto SetStatusAndReturn;
            }

        } else

            status = STATUS_SUCCESS;

        //
        // added for cdrom101 and 102 to correspondence
        //

        if ( deviceExtension->Active == CDAUDIO_HITACHI ) {

            //
            // Translate data into our format
            //

            bytesTransfered =
                currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength >
                sizeof(CDROM_TOC) ?
                sizeof(CDROM_TOC) :
                currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

            cdaudioDataOut->FirstTrack = Toc[2];
            cdaudioDataOut->LastTrack  = Toc[3];

            //
            // Return only N number of tracks, where N is the number of
            // full tracks of info we can stuff into the user buffer
            // if tracks from 1 to 2, that means there are two tracks,
            // so let i go from 0 to 1 (two tracks of info)
            //
            {
                //
                // tracksToReturn == Number of real track info to return
                // tracksInBuffer == How many fit into the user-supplied buffer
                // tracksOnCd     == Number of tracks on the CD (not including lead-out)
                //

                ULONG tracksToReturn;
                ULONG tracksOnCd;
                ULONG tracksInBuffer;
                ULONG dataLength;
                tracksOnCd = (cdaudioDataOut->LastTrack - cdaudioDataOut->FirstTrack) + 1;


                dataLength = ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[tracksOnCd])) - 2;
                cdaudioDataOut->Length[0]  = (UCHAR)(dataLength >> 8);
                cdaudioDataOut->Length[1]  = (UCHAR)(dataLength & 0xFF);

                tracksInBuffer = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength -
                                 ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[0]));
                tracksInBuffer /= sizeof(TRACK_DATA);

                // take the lesser of the two
                tracksToReturn = (tracksInBuffer < tracksOnCd) ?
                                 tracksInBuffer :
                                 tracksOnCd;
                for( i=0; i < tracksToReturn; i++ ) {

                    //
                    // Grab Information for each track
                    //

                    cdaudioDataOut->TrackData[i].Reserved    = 0;
                    cdaudioDataOut->TrackData[i].Control     =
                        ((Toc[(i*4)+8] & 0x0F) << 4) | (Toc[(i*4)+8] >> 4);
                    cdaudioDataOut->TrackData[i].TrackNumber =
                        (UCHAR)((i + cdaudioDataOut->FirstTrack));

                    cdaudioDataOut->TrackData[i].Reserved1 =  0;
                    cdaudioDataOut->TrackData[i].Address[0] = 0;
                    cdaudioDataOut->TrackData[i].Address[1] = Toc[(i*4)+9];
                    cdaudioDataOut->TrackData[i].Address[2] = Toc[(i*4)+10];
                    cdaudioDataOut->TrackData[i].Address[3] = Toc[(i*4)+11];

                    CdDump(( 4,
                                "CdAudioHitachiDeviceControl: Track %d  %d:%d:%d\n",
                                cdaudioDataOut->TrackData[i].TrackNumber,
                                cdaudioDataOut->TrackData[i].Address[1],
                                cdaudioDataOut->TrackData[i].Address[2],
                                cdaudioDataOut->TrackData[i].Address[3]
                            ));
                }

                //
                // Fake "lead out track" info
                // Only if all tracks have been copied...
                //

                if ( tracksInBuffer > tracksOnCd ) {
                    cdaudioDataOut->TrackData[i].Reserved    = 0;
                    cdaudioDataOut->TrackData[i].Control     = 0x10;
                    cdaudioDataOut->TrackData[i].TrackNumber = 0xaa;
                    cdaudioDataOut->TrackData[i].Reserved1   = 0;
                    cdaudioDataOut->TrackData[i].Address[0]  = 0;
                    cdaudioDataOut->TrackData[i].Address[1]  = Toc[5];
                    cdaudioDataOut->TrackData[i].Address[2]  = Toc[6];
                    cdaudioDataOut->TrackData[i].Address[3]  = Toc[7];
                    CdDump(( 4,
                                "CdAudioHitachiDeviceControl: Track %d  %d:%d:%d\n",
                                cdaudioDataOut->TrackData[i].TrackNumber,
                                cdaudioDataOut->TrackData[i].Address[1],
                                cdaudioDataOut->TrackData[i].Address[2],
                                cdaudioDataOut->TrackData[i].Address[3]
                            ));
                    i++;
                }

                Irp->IoStatus.Information = ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[i]));

            }

            //
            // Clear out device extension data
            //

            deviceExtension->Paused = CDAUDIO_NOT_PAUSED;
            deviceExtension->PausedM = 0;
            deviceExtension->PausedS = 0;
            deviceExtension->PausedF = 0;
            deviceExtension->LastEndM = 0;
            deviceExtension->LastEndS = 0;
            deviceExtension->LastEndF = 0;
        } else {

            //
            // added for cdrom101 and 102 to correspondence
            //

            bytesTransfered =
                currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength >
                sizeof(CDROM_TOC) ?
                sizeof(CDROM_TOC) :
                currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

            cdaudioDataOut->FirstTrack = Toc[1];
            cdaudioDataOut->LastTrack  = Toc[2];

            //
            // Return only N number of tracks, where N is the number of
            // full tracks of info we can stuff into the user buffer
            // if tracks from 1 to 2, that means there are two tracks,
            // so let i go from 0 to 1 (two tracks of info)
            //
            {
                //
                // tracksToReturn == Number of real track info to return
                // tracksInBuffer == How many fit into the user-supplied buffer
                // tracksOnCd     == Number of tracks on the CD (not including lead-out)
                //

                ULONG tracksToReturn;
                ULONG tracksOnCd;
                ULONG tracksInBuffer;
                ULONG dataLength;

                tracksOnCd = (cdaudioDataOut->LastTrack - cdaudioDataOut->FirstTrack) + 1;

                dataLength = ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[tracksOnCd])) - 2;
                cdaudioDataOut->Length[0]  = (UCHAR)(dataLength >> 8);
                cdaudioDataOut->Length[1]  = (UCHAR)(dataLength & 0xFF);

                tracksInBuffer = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength -
                                 ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[0]));
                tracksInBuffer /= sizeof(TRACK_DATA);

                // take the lesser of the two
                tracksToReturn = (tracksInBuffer < tracksOnCd) ?
                                 tracksInBuffer :
                                 tracksOnCd;

                for( i=0; i < tracksToReturn; i++ ) {

                    //
                    // Grab Information for each track
                    //

                    cdaudioDataOut->TrackData[i].Reserved    = 0;
                    if (Toc[(i*3)+6] & 0x80)
                        cdaudioDataOut->TrackData[i].Control = 0x04;
                    else
                        cdaudioDataOut->TrackData[i].Control = 0;
                    cdaudioDataOut->TrackData[i].Adr         = 0;
                    cdaudioDataOut->TrackData[i].TrackNumber =
                        (UCHAR)((i + cdaudioDataOut->FirstTrack));

                    cdaudioDataOut->TrackData[i].Reserved1   =  0;
                    cdaudioDataOut->TrackData[i].Address[0]  = 0;
                    cdaudioDataOut->TrackData[i].Address[1]  = Toc[(i*3)+6] & 0x7f;
                    cdaudioDataOut->TrackData[i].Address[2]  = Toc[(i*3)+7];
                    cdaudioDataOut->TrackData[i].Address[3]  = Toc[(i*3)+8];

                    CdDump(( 4,
                                "CdAudioHitachiDeviceControl: Track %d  %d:%d:%d\n",
                                cdaudioDataOut->TrackData[i].TrackNumber,
                                cdaudioDataOut->TrackData[i].Address[1],
                                cdaudioDataOut->TrackData[i].Address[2],
                                cdaudioDataOut->TrackData[i].Address[3]
                            ));
                }

                //
                // Fake "lead out track" info
                // Only if all tracks have been copied...
                //

                if ( tracksInBuffer > tracksOnCd ) {
                    cdaudioDataOut->TrackData[i].Reserved    = 0;
                    cdaudioDataOut->TrackData[i].Control     = 0x10;
                    cdaudioDataOut->TrackData[i].TrackNumber = 0xaa;
                    cdaudioDataOut->TrackData[i].Reserved1   = 0;
                    cdaudioDataOut->TrackData[i].Address[0]  = 0;
                    cdaudioDataOut->TrackData[i].Address[1]  = Toc[3];
                    cdaudioDataOut->TrackData[i].Address[2]  = Toc[4];
                    cdaudioDataOut->TrackData[i].Address[3]  = Toc[5];
                    CdDump(( 4,
                                "CdAudioHitachiDeviceControl: Track %d  %d:%d:%d\n",
                                cdaudioDataOut->TrackData[i].TrackNumber,
                                cdaudioDataOut->TrackData[i].Address[1],
                                cdaudioDataOut->TrackData[i].Address[2],
                                cdaudioDataOut->TrackData[i].Address[3]
                            ));
                    i++;
                }

                Irp->IoStatus.Information = ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[i]));
            }
        }

        //
        // Free storage now that we've stored it elsewhere
        //

        ExFreePool( Toc );
        break;

    case IOCTL_CDROM_STOP_AUDIO:

        deviceExtension->PlayActive = FALSE;
        Irp->IoStatus.Information = 0;

        //
        // Kill any current play operation
        //

        CdAudioHitachiSendPauseCommand( DeviceObject );

        //
        // Same as scsi-2 spec, so just send to default driver
        //

        deviceExtension->Paused = CDAUDIO_NOT_PAUSED;
        deviceExtension->PausedM = 0;
        deviceExtension->PausedS = 0;
        deviceExtension->PausedF = 0;
        deviceExtension->LastEndM = 0;
        deviceExtension->LastEndS = 0;
        deviceExtension->LastEndF = 0;

        return CdAudioSendToNextDriver( DeviceObject, Irp );
        break;

    case IOCTL_CDROM_PLAY_AUDIO_MSF:
        {
            PCDROM_PLAY_AUDIO_MSF inputBuffer =
                Irp->AssociatedIrp.SystemBuffer;

            Irp->IoStatus.Information = 0;

            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CDROM_PLAY_AUDIO_MSF)
                ) {
                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            CdDump(( 3,
                     "HitachiDeviceControl => IOCTL_CDROM_PLAY_AUDIO_MSF recv'd.\n"
                   ));

            //
            // Kill any current play operation
            //

            CdAudioHitachiSendPauseCommand( DeviceObject );

            //
            // Fill in CDB for PLAY operation
            //

            srb.CdbLength                 = 12;
            srb.TimeOutValue              = AUDIO_TIMEOUT;
            cdb->PLAY_AUDIO.OperationCode = HITACHI_PLAY_AUDIO_MSF_CODE;
            cdb->PLAY_AUDIO.Immediate     = 1;
            cdb->PLAY_AUDIO.StartingM     = inputBuffer->StartingM;
            cdb->PLAY_AUDIO.StartingS     = inputBuffer->StartingS;
            cdb->PLAY_AUDIO.StartingF     = inputBuffer->StartingF;
            cdb->PLAY_AUDIO.EndingM       = inputBuffer->EndingM;
            cdb->PLAY_AUDIO.EndingS       = inputBuffer->EndingS;
            cdb->PLAY_AUDIO.EndingF       = inputBuffer->EndingF;
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         NULL,
                                         0
                                       );

            if (NT_SUCCESS(status)) {

                //
                // Indicate the play actition is active.
                //

                deviceExtension->PlayActive = TRUE;

                deviceExtension->Paused = CDAUDIO_NOT_PAUSED;


                //
                // Set last play ending address for next pause command
                //

                deviceExtension->PausedM  = inputBuffer->StartingM;
                deviceExtension->PausedS  = inputBuffer->StartingS;
                deviceExtension->PausedF  = inputBuffer->StartingF;
                deviceExtension->LastEndM = inputBuffer->EndingM;
                deviceExtension->LastEndS = inputBuffer->EndingS;
                deviceExtension->LastEndF = inputBuffer->EndingF;

            } else {

                CdDump(( 3,
                         "HitachiDeviceControl => PLAY failed (%lx)\n",
                         status ));
            }

        }
        break;

    case IOCTL_CDROM_SEEK_AUDIO_MSF:
        {

            PCDROM_SEEK_AUDIO_MSF inputBuffer = Irp->AssociatedIrp.SystemBuffer;

            Irp->IoStatus.Information = 0;

            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CDROM_SEEK_AUDIO_MSF)
                ) {
                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }


            CdDump(( 3,
                     "HitachiDeviceControl => IOCTL_CDROM_SEEK_AUDIO_MSF recv'd.\n"
                   ));

            //
            // Kill any current play operation
            //

            CdAudioHitachiSendPauseCommand( DeviceObject );

            //
            // seek to MSF and enter pause (still) mode.
            //

            //
            // Fill in CDB for PLAY operation
            //

            srb.CdbLength                 = 12;
            srb.TimeOutValue              = AUDIO_TIMEOUT;
            cdb->PLAY_AUDIO.OperationCode = HITACHI_PLAY_AUDIO_MSF_CODE;
            cdb->PLAY_AUDIO.Immediate     = 1;
            cdb->PLAY_AUDIO.StartingM     = inputBuffer->M;
            cdb->PLAY_AUDIO.StartingS     = inputBuffer->S;
            cdb->PLAY_AUDIO.StartingF     = inputBuffer->F;
            cdb->PLAY_AUDIO.EndingM       = inputBuffer->M;
            cdb->PLAY_AUDIO.EndingS       = inputBuffer->S;
            cdb->PLAY_AUDIO.EndingF       = inputBuffer->F;

            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         NULL,
                                         0
                                       );
            if (NT_SUCCESS(status)) {

                deviceExtension->PausedM = inputBuffer->M;
                deviceExtension->PausedS = inputBuffer->S;
                deviceExtension->PausedF = inputBuffer->F;
                deviceExtension->LastEndM = inputBuffer->M;
                deviceExtension->LastEndS = inputBuffer->S;
                deviceExtension->LastEndF = inputBuffer->F;

            } else {

                CdDump(( 3,
                         "HitachiDeviceControl => SEEK failed (%lx)\n",
                         status ));
            }

        }
        break;

    case IOCTL_CDROM_PAUSE_AUDIO:
        {

            PUCHAR PausePos = ExAllocatePool( NonPagedPoolCacheAligned, 3 );

            Irp->IoStatus.Information = 0;

            if (PausePos==NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto SetStatusAndReturn;

            }

            deviceExtension->PlayActive = FALSE;

            RtlZeroMemory( PausePos, 3 );

            CdDump(( 3,
                     "HitachiDeviceControl => IOCTL_CDROM_PAUSE_AUDIO recv'd.\n"
                   ));

            //
            // Enter pause (still ) mode
            //

            srb.CdbLength    = 12;
            srb.TimeOutValue = AUDIO_TIMEOUT;
            cdb->PAUSE_AUDIO.OperationCode = HITACHI_PAUSE_AUDIO_CODE;
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         PausePos,
                                         3
                                       );

            deviceExtension->Paused = CDAUDIO_PAUSED;
            deviceExtension->PausedM = PausePos[0];
            deviceExtension->PausedS = PausePos[1];
            deviceExtension->PausedF = PausePos[2];

            ExFreePool( PausePos );
        }
        break;

    case IOCTL_CDROM_RESUME_AUDIO:

        CdDump(( 3,
                 "HitachiDeviceControl => IOCTL_CDROM_RESUME_AUDIO recv'd.\n"
               ));

        Irp->IoStatus.Information = 0;

        //
        // Kill any current play operation
        //

        CdAudioHitachiSendPauseCommand( DeviceObject );

        //
        // Resume play
        //

        //
        // Fill in CDB for PLAY operation
        //

        srb.CdbLength    = 12;
        srb.TimeOutValue = AUDIO_TIMEOUT;
        cdb->PLAY_AUDIO.OperationCode = HITACHI_PLAY_AUDIO_MSF_CODE;
        cdb->PLAY_AUDIO.Immediate     = 1;
        cdb->PLAY_AUDIO.StartingM     = deviceExtension->PausedM;
        cdb->PLAY_AUDIO.StartingS     = deviceExtension->PausedS;
        cdb->PLAY_AUDIO.StartingF     = deviceExtension->PausedF;
        cdb->PLAY_AUDIO.EndingM       = deviceExtension->LastEndM;
        cdb->PLAY_AUDIO.EndingS       = deviceExtension->LastEndS;
        cdb->PLAY_AUDIO.EndingF       = deviceExtension->LastEndF;
        status = SendSrbSynchronous( deviceExtension,
                                     &srb,
                                     NULL,
                                     0
                                   );

        if (NT_SUCCESS(status)) {

            deviceExtension->Paused = CDAUDIO_NOT_PAUSED;

        }

        break;

    case IOCTL_CDROM_READ_Q_CHANNEL:
        {

            PSUB_Q_CURRENT_POSITION userPtr =
                Irp->AssociatedIrp.SystemBuffer;
            PUCHAR SubQPtr =
                ExAllocatePool( NonPagedPoolCacheAligned,
                                sizeof(SUB_Q_CHANNEL_DATA)
                              );

            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SUB_Q_CURRENT_POSITION)
                ) {
                status = STATUS_BUFFER_TOO_SMALL;
                // we have transferred zero bytes
                Irp->IoStatus.Information = 0;
                if (SubQPtr) ExFreePool(SubQPtr);
                break;
            }

            CdDump(( 5,
                     "HitachiDeviceControl => IOCTL_CDROM_READ_Q_CHANNEL recv'd.\n"
                   ));

            if (SubQPtr==NULL) {

                CdDump(( 1,
                         "HitachiDeviceControl => READ_Q_CHANNEL, SubQPtr==NULL!\n"
                       ));

                status = STATUS_INSUFFICIENT_RESOURCES;
                Irp->IoStatus.Information = 0;
                goto SetStatusAndReturn;

            }

            if ( ((PCDROM_SUB_Q_DATA_FORMAT)userPtr)->Format!=
                 IOCTL_CDROM_CURRENT_POSITION) {

                CdDump(( 1,
                         "HitachiDeviceControl => READ_Q_CHANNEL, illegal Format (%d)\n",
                         ((PCDROM_SUB_Q_DATA_FORMAT)userPtr)->Format
                       ));

                ExFreePool( SubQPtr );
                status = STATUS_UNSUCCESSFUL;
                Irp->IoStatus.Information = 0;
                goto SetStatusAndReturn;
            }

            //
            // Set up to read Q Channel
            //

            srb.CdbLength            = 12;
            srb.TimeOutValue         = AUDIO_TIMEOUT;
            cdb->AUDIO_STATUS.OperationCode = HITACHI_READ_SUB_Q_CHANNEL_CODE;

            Retry:
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         SubQPtr,
                                         sizeof(SUB_Q_CHANNEL_DATA)
                                       );
            if ((NT_SUCCESS(status)) || (status==STATUS_DATA_OVERRUN)) {

                //
                // While playing one track of Japanese music CDs on "CD player",
                // track number is incremented unexpectedly.
                // Some of SubQ data in Japanese music cd does not contain current position
                // information. This is distinguished by lower 4 bits of SubQPtr[1]. If this
                // data is needless, retry READ_SUB_Q_CHANNEL_CODE command until required
                // information will be got.
                //

                if ((SubQPtr[1] & 0x0F) != 1)
                    goto Retry;

                userPtr->Header.Reserved = 0;
                if (deviceExtension->Paused == CDAUDIO_PAUSED) {

                    deviceExtension->PlayActive = FALSE;
                    userPtr->Header.AudioStatus = AUDIO_STATUS_PAUSED;
                } else {
                    if (SubQPtr[0]==0x01)
                        userPtr->Header.AudioStatus = AUDIO_STATUS_IN_PROGRESS;
                    else if (SubQPtr[0]==0x00) {
                        userPtr->Header.AudioStatus = AUDIO_STATUS_PLAY_COMPLETE;
                        deviceExtension->PlayActive = FALSE;

                    } else {
                        deviceExtension->PlayActive = FALSE;
                    }
                }
                userPtr->Header.DataLength[0] = 0;
                userPtr->Header.DataLength[0] = 12;

                userPtr->FormatCode = 0x01;
                userPtr->Control = ((SubQPtr[1] & 0xF0) >> 4);
                userPtr->ADR     = SubQPtr[1] & 0x0F;
                userPtr->TrackNumber = SubQPtr[2];
                userPtr->IndexNumber = SubQPtr[3];
                userPtr->AbsoluteAddress[0] = 0;
                userPtr->AbsoluteAddress[1] = SubQPtr[8];
                userPtr->AbsoluteAddress[2] = SubQPtr[9];
                userPtr->AbsoluteAddress[3] = SubQPtr[10];
                userPtr->TrackRelativeAddress[0] = 0;
                userPtr->TrackRelativeAddress[1] = SubQPtr[4];
                userPtr->TrackRelativeAddress[2] = SubQPtr[5];
                userPtr->TrackRelativeAddress[3] = SubQPtr[6];
                Irp->IoStatus.Information = sizeof(SUB_Q_CURRENT_POSITION);
                status = STATUS_SUCCESS;

            } else {

                Irp->IoStatus.Information = 0;
                CdDump(( 1,
                         "HitachiDeviceControl => READ_Q_CHANNEL failed (%lx)\n",
                         status
                       ));

            }

            ExFreePool( SubQPtr );

        }
        break;

    case IOCTL_CDROM_EJECT_MEDIA:
        {

            PUCHAR EjectStatus = ExAllocatePool( NonPagedPoolCacheAligned, 1 );

            Irp->IoStatus.Information = 0;

            if (EjectStatus==NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto SetStatusAndReturn;

            }

            deviceExtension->PlayActive = FALSE;

            CdDump(( 3,
                     "HitachiDeviceControl => IOCTL_CDROM_EJECT_MEDIA recv'd.\n"
                   ));

            //
            // Set up to EJECT disc
            //

            srb.CdbLength            = 12;
            srb.TimeOutValue         = AUDIO_TIMEOUT;
            cdb->EJECT.OperationCode = HITACHI_EJECT_CODE;
            cdb->EJECT.Eject         = 1;  // Set Eject flag
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         EjectStatus,
                                         1
                                       );
            if (NT_SUCCESS(status)) {

                deviceExtension->Paused = CDAUDIO_NOT_PAUSED;
                deviceExtension->PausedM = 0;
                deviceExtension->PausedS = 0;
                deviceExtension->PausedF = 0;
                deviceExtension->LastEndM = 0;
                deviceExtension->LastEndS = 0;
                deviceExtension->LastEndF = 0;

            }

            ExFreePool( EjectStatus );
        }
        break;

    case IOCTL_CDROM_GET_CONTROL:
    case IOCTL_CDROM_GET_VOLUME:
    case IOCTL_CDROM_SET_VOLUME:

        CdDump(( 3, "CdAudioHitachieviceControl: Not Supported yet.\n" ));
        Irp->IoStatus.Information = 0;
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    case IOCTL_CDROM_CHECK_VERIFY:

        //
        // Update the play active flag.
        //

        CdAudioIsPlayActive(DeviceObject);

    default:

        CdDump((10,"HitachiDeviceControl => Unsupported device IOCTL\n"));
        return CdAudioSendToNextDriver( DeviceObject, Irp );
        break;

    } // end switch( IOCTL )

    SetStatusAndReturn:

    //
    // set status code and return
    //

    if (status == STATUS_VERIFY_REQUIRED) {

        //
        // If the status is verified required and the this request
        // should bypass verify required then retry the request.
        //

        if (currentIrpStack->Flags & SL_OVERRIDE_VERIFY_VOLUME) {

            status = STATUS_IO_DEVICE_ERROR;
            goto HitachiRestart;

        }


        IoSetHardErrorOrVerifyDevice( Irp,
                                      deviceExtension->TargetDeviceObject
                                    );

        Irp->IoStatus.Information = 0;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;

}

NTSTATUS
    CdAudio535DeviceControl(
                           PDEVICE_OBJECT DeviceObject,
                           PIRP Irp
                           )

/*++

Routine Description:

    This routine is called by CdAudioDeviceControl to handle
    audio IOCTLs sent to Chinon CDS-535 cdrom drive.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PCD_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCDROM_TOC         cdaudioDataOut  = Irp->AssociatedIrp.SystemBuffer;
    SCSI_PASS_THROUGH  srb;
    PREAD_CAPACITY_DATA lastSession;
    PCDB               cdb = (PCDB)srb.Cdb;
    NTSTATUS           status;
    ULONG              i,bytesTransfered;
    PUCHAR             Toc;
    ULONG              destblock;


    //
    // Clear out cdb
    //

    RtlZeroMemory( cdb, MAXIMUM_CDB_SIZE );

    //
    // What IOCTL do we need to execute?
    //

    switch (currentIrpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_CDROM_GET_LAST_SESSION:

        //
        // If the cd is playing music then reject this request.
        //

        if (CdAudioIsPlayActive(DeviceObject)) {
            status = STATUS_DEVICE_BUSY;
            Irp->IoStatus.Information = 0;
            break;
        }

        if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
            (ULONG)(FIELD_OFFSET(CDROM_TOC, TrackData[1]))) {
            status = STATUS_BUFFER_TOO_SMALL;
            // we have transferred zero bytes
            Irp->IoStatus.Information = 0;
            break;

        }

        // Allocate storage to hold lastSession from disc
        //

        lastSession = ExAllocatePool( NonPagedPoolCacheAligned,
                                      sizeof(READ_CAPACITY_DATA)
                                    );

        if (lastSession==NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Information = 0;
            goto SetStatusAndReturn;

        }

        //
        // Set up defaults
        //

        RtlZeroMemory( lastSession, sizeof(READ_CAPACITY_DATA));
        srb.CdbLength = 10;

        //
        // Fill in CDB
        //

        cdb->CDB10.OperationCode = CDS535_GET_LAST_SESSION;
        srb.TimeOutValue      = AUDIO_TIMEOUT;
        status = SendSrbSynchronous( deviceExtension,
                                     &srb,
                                     lastSession,
                                     sizeof(READ_CAPACITY_DATA)
                                   );

        if (!NT_SUCCESS(status)) {

            CdDump(( 1,
                     "535DeviceControl => READ_TOC error (%lx)\n",
                     status ));


            ExFreePool( lastSession );
            Irp->IoStatus.Information = 0;
            goto SetStatusAndReturn;

        } else {

            status = STATUS_SUCCESS;
        }

        //
        // Translate data into our format.
        //

        bytesTransfered = FIELD_OFFSET(CDROM_TOC, TrackData[1]);
        Irp->IoStatus.Information = bytesTransfered;

        RtlZeroMemory(cdaudioDataOut, bytesTransfered);

        cdaudioDataOut->Length[0]  = (UCHAR)((bytesTransfered-2) >> 8);
        cdaudioDataOut->Length[1]  = (UCHAR)((bytesTransfered-2) & 0xFF);

        //
        // Determine if this is a multisession cd.
        //

        if (lastSession->LogicalBlockAddress == 0) {

            //
            // This is a single session disk.  Just return.
            //

            ExFreePool(lastSession);
            break;
        }

        //
        // Fake the session information.
        //

        cdaudioDataOut->FirstTrack = 1;
        cdaudioDataOut->LastTrack  = 2;

        CdDump(( 4,
                 "535DeviceControl => Tracks %d - %d, (%x bytes)\n",
                 cdaudioDataOut->FirstTrack,
                 cdaudioDataOut->LastTrack,
                 bytesTransfered
               ));


        //
        // Grab Information for the last session.
        //

        *((ULONG *)&cdaudioDataOut->TrackData[0].Address[0]) =
            lastSession->LogicalBlockAddress;

        //
        // Free storage now that we've stored it elsewhere
        //

        ExFreePool( lastSession );
        break;

    case IOCTL_CDROM_READ_TOC:
        CdDump(( 3,
                 "535DeviceControl => IOCTL_CDROM_READ_TOC recv'd.\n"
               ));

        //
        // Must have allocated at least enough buffer space
        // to store how many tracks are on the disc
        //

        if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
            ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[0]))
            ) {
            status = STATUS_BUFFER_TOO_SMALL;
            // we have transferred zero bytes
            Irp->IoStatus.Information = 0;
            break;
        }

        //
        // If the cd is playing music then reject this request.
        //

        if (CdAudioIsPlayActive(DeviceObject)) {
            status = STATUS_DEVICE_BUSY;
            Irp->IoStatus.Information = 0;
            break;
        }

        //
        // Allocate storage to hold TOC from disc
        //

        Toc = (PUCHAR)ExAllocatePool( NonPagedPoolCacheAligned,
                                      CDROM_TOC_SIZE
                                    );

        if (Toc==NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Information = 0;
            goto SetStatusAndReturn;

        }

        //
        // Set up defaults
        //

        RtlZeroMemory( Toc, CDROM_TOC_SIZE );

        //
        // Fill in cdb for this operation
        //

        cdb->CDB10.OperationCode = CDS535_READ_TOC_CODE;
        cdb->CDB10.Reserved1 = 1;       // MSF mode
        cdb->CDB10.TransferBlocksMsb = (CDROM_TOC_SIZE >> 8);
        cdb->CDB10.TransferBlocksLsb = (CDROM_TOC_SIZE & 0xFF);
        srb.TimeOutValue               = AUDIO_TIMEOUT;
        srb.CdbLength                  = 10;
        status = SendSrbSynchronous( deviceExtension,
                                     &srb,
                                     Toc,
                                     CDROM_TOC_SIZE
                                   );

        if (!NT_SUCCESS(status) && (status!=STATUS_DATA_OVERRUN)) {

            CdDump(( 1,
                     "535DeviceControl => READ_TOC error (%lx)\n",
                     status ));

            if (status != STATUS_DATA_OVERRUN) {

                CdDump(( 1, "535DeviceControl => SRB ERROR (%lx)\n",
                         status ));
                ExFreePool( Toc );
                Irp->IoStatus.Information = 0;
                goto SetStatusAndReturn;
            }

        } else {

            status = STATUS_SUCCESS;
        }

        //
        // Translate data into SCSI-II format
        //   (track numbers, except 0xAA, must be converted from BCD)

        bytesTransfered =
            currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength >
            sizeof(CDROM_TOC) ?
            sizeof(CDROM_TOC) :
            currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

        cdaudioDataOut->Length[0]  = Toc[0];
        cdaudioDataOut->Length[1]  = Toc[1];
        cdaudioDataOut->FirstTrack = BCD_TO_DEC(Toc[2]);
        cdaudioDataOut->LastTrack  = BCD_TO_DEC(Toc[3]);


        //
        // Return only N number of tracks, where N is the number of
        // full tracks of info we can stuff into the user buffer
        // if tracks from 1 to 2, that means there are two tracks,
        // so let i go from 0 to 1 (two tracks of info)
        //
        {
            //
            // tracksToReturn == Number of real track info to return
            // tracksInBuffer == How many fit into the user-supplied buffer
            // tracksOnCd     == Number of tracks on the CD (not including lead-out)
            //

            ULONG tracksToReturn;
            ULONG tracksOnCd;
            ULONG tracksInBuffer;
            tracksOnCd = (cdaudioDataOut->LastTrack - cdaudioDataOut->FirstTrack) + 1;
            tracksInBuffer = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength -
                             ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[0]));
            tracksInBuffer /= sizeof(TRACK_DATA);

            // take the lesser of the two
            tracksToReturn = (tracksInBuffer < tracksOnCd) ?
                             tracksInBuffer :
                             tracksOnCd;

            for( i=0; i < tracksToReturn; i++ ) {

                //
                // Grab Information for each track
                //

                cdaudioDataOut->TrackData[i].Reserved    = 0;
                cdaudioDataOut->TrackData[i].Control     = Toc[(i*8)+4+1];
                cdaudioDataOut->TrackData[i].TrackNumber =
                    BCD_TO_DEC(Toc[(i*8)+4+2]);
                cdaudioDataOut->TrackData[i].Reserved1   = 0;
                cdaudioDataOut->TrackData[i].Address[0]  = 0;
                cdaudioDataOut->TrackData[i].Address[1]  = Toc[(i*8)+4+5];
                cdaudioDataOut->TrackData[i].Address[2]  = Toc[(i*8)+4+6];
                cdaudioDataOut->TrackData[i].Address[3]  = Toc[(i*8)+4+7];
                CdDump(( 4,
                            "CdAudio535DeviceControl: Track %d  %d:%d:%d\n",
                            cdaudioDataOut->TrackData[i].TrackNumber,
                            cdaudioDataOut->TrackData[i].Address[1],
                            cdaudioDataOut->TrackData[i].Address[2],
                            cdaudioDataOut->TrackData[i].Address[3]
                        ));
            }

            //
            // Fake "lead out track" info
            // Only if all tracks have been copied...
            //

            if ( tracksInBuffer > tracksOnCd ) {
                cdaudioDataOut->TrackData[i].Reserved    = 0;
                cdaudioDataOut->TrackData[i].Control     = Toc[(i*8)+4+1];
                cdaudioDataOut->TrackData[i].TrackNumber = Toc[(i*8)+4+2]; // leave as 0xAA
                cdaudioDataOut->TrackData[i].Reserved1   = 0;
                cdaudioDataOut->TrackData[i].Address[0]  = 0;
                cdaudioDataOut->TrackData[i].Address[1]  = Toc[(i*8)+4+5];
                cdaudioDataOut->TrackData[i].Address[2]  = Toc[(i*8)+4+6];
                cdaudioDataOut->TrackData[i].Address[3]  = Toc[(i*8)+4+7];
                CdDump(( 4,
                            "CdAudio535DeviceControl: Track %d  %d:%d:%d\n",
                            cdaudioDataOut->TrackData[i].TrackNumber,
                            cdaudioDataOut->TrackData[i].Address[1],
                            cdaudioDataOut->TrackData[i].Address[2],
                            cdaudioDataOut->TrackData[i].Address[3]
                        ));
                i++;
            }

            Irp->IoStatus.Information  = ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[i]));

        }

        //
        // Free storage now that we've stored it elsewhere
        //

        ExFreePool( Toc );
        break;

    case IOCTL_CDROM_READ_Q_CHANNEL:
        {
            PSUB_Q_CURRENT_POSITION userPtr =
                Irp->AssociatedIrp.SystemBuffer;
            PUCHAR SubQPtr =
                ExAllocatePool( NonPagedPoolCacheAligned,
                                sizeof(SUB_Q_CURRENT_POSITION)
                              );

            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SUB_Q_CURRENT_POSITION)
                ) {
                status = STATUS_BUFFER_TOO_SMALL;
                // we have transferred zero bytes
                Irp->IoStatus.Information = 0;
                if (SubQPtr) ExFreePool(SubQPtr);
                break;
            }


            CdDump(( 5,
                     "535DeviceControl => IOCTL_CDROM_READ_Q_CHANNEL recv'd.\n"
                   ));

            if (SubQPtr==NULL) {

                CdDump(( 1,
                         "535DeviceControl => READ_Q_CHANNEL, SubQPtr==NULL!\n"
                       ));

                RtlZeroMemory( userPtr, sizeof(SUB_Q_CURRENT_POSITION) );
                status = STATUS_INSUFFICIENT_RESOURCES;
                Irp->IoStatus.Information = 0;
                goto SetStatusAndReturn;

            }

            if ( ((PCDROM_SUB_Q_DATA_FORMAT)userPtr)->Format!=
                 IOCTL_CDROM_CURRENT_POSITION) {

                CdDump(( 1,
                         "535DeviceControl => READ_Q_CHANNEL, illegal Format (%d)\n",
                         ((PCDROM_SUB_Q_DATA_FORMAT)userPtr)->Format
                       ));

                ExFreePool( SubQPtr );
                RtlZeroMemory( userPtr, sizeof(SUB_Q_CURRENT_POSITION) );
                status = STATUS_UNSUCCESSFUL;
                Irp->IoStatus.Information = 0;
                goto SetStatusAndReturn;
            }

            //
            // Get Current Position
            //

            srb.CdbLength            = 10;
            srb.TimeOutValue         = AUDIO_TIMEOUT;
            cdb->SUBCHANNEL.OperationCode = CDS535_READ_SUB_Q_CHANNEL_CODE;
            cdb->SUBCHANNEL.Msf = 1;
            cdb->SUBCHANNEL.SubQ = 1;
            cdb->SUBCHANNEL.Format = 1;
            cdb->SUBCHANNEL.AllocationLength[1] = sizeof(SUB_Q_CURRENT_POSITION);
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         SubQPtr,
                                         sizeof(SUB_Q_CURRENT_POSITION)
                                       );

            //
            // Copy current position, converting track and index from BCD
            //

            if (NT_SUCCESS(status)) {
                if (SubQPtr[1] == 0x11) deviceExtension->PlayActive = TRUE;
                else deviceExtension->PlayActive = FALSE;

                userPtr->Header.Reserved = 0;
                userPtr->Header.AudioStatus = SubQPtr[1];
                userPtr->Header.DataLength[0] = 0;
                userPtr->Header.DataLength[1] = 12;
                userPtr->FormatCode = 0x01;
                userPtr->Control = SubQPtr[5];
                userPtr->ADR     = 0;
                userPtr->TrackNumber = BCD_TO_DEC(SubQPtr[6]);
                userPtr->IndexNumber = BCD_TO_DEC(SubQPtr[7]);
                userPtr->AbsoluteAddress[0] = 0;
                userPtr->AbsoluteAddress[1] = SubQPtr[9];
                userPtr->AbsoluteAddress[2] = SubQPtr[10];
                userPtr->AbsoluteAddress[3] = SubQPtr[11];
                userPtr->TrackRelativeAddress[0] = 0;
                userPtr->TrackRelativeAddress[1] = SubQPtr[13];
                userPtr->TrackRelativeAddress[2] = SubQPtr[14];
                userPtr->TrackRelativeAddress[3] = SubQPtr[15];
                Irp->IoStatus.Information = sizeof(SUB_Q_CURRENT_POSITION);
            } else {
                Irp->IoStatus.Information = 0;
                CdDump(( 1,
                         "535DeviceControl => READ_Q_CHANNEL failed (%lx)\n",
                         status
                       ));
            }

            ExFreePool( SubQPtr );
        }
        break;

    case IOCTL_CDROM_PLAY_AUDIO_MSF:
        {
            PCDROM_PLAY_AUDIO_MSF inputBuffer = Irp->AssociatedIrp.SystemBuffer;

            Irp->IoStatus.Information = 0;

            //
            // Play Audio MSF
            //

            CdDump((2,"535DeviceControl: Play audio MSF\n"));

            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CDROM_PLAY_AUDIO_MSF)
                ) {
                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            if (inputBuffer->StartingM == inputBuffer->EndingM &&
                inputBuffer->StartingS == inputBuffer->EndingS &&
                inputBuffer->StartingF == inputBuffer->EndingF) {

                cdb->PAUSE_RESUME.OperationCode = SCSIOP_PAUSE_RESUME;
                cdb->PAUSE_RESUME.Action = CDB_AUDIO_PAUSE;

            } else {
                cdb->PLAY_AUDIO_MSF.OperationCode = SCSIOP_PLAY_AUDIO_MSF;

                cdb->PLAY_AUDIO_MSF.StartingM = inputBuffer->StartingM;
                cdb->PLAY_AUDIO_MSF.StartingS = inputBuffer->StartingS;
                cdb->PLAY_AUDIO_MSF.StartingF = inputBuffer->StartingF;

                cdb->PLAY_AUDIO_MSF.EndingM = inputBuffer->EndingM;
                cdb->PLAY_AUDIO_MSF.EndingS = inputBuffer->EndingS;
                cdb->PLAY_AUDIO_MSF.EndingF = inputBuffer->EndingF;

            }

            srb.CdbLength = 10;

            //
            // Set timeout value.
            //

            srb.TimeOutValue             = AUDIO_TIMEOUT;

            status = SendSrbSynchronous(deviceExtension,
                                        &srb,
                                        NULL,
                                        0);

            if (NT_SUCCESS(status) &&
                cdb->PLAY_AUDIO_MSF.OperationCode == SCSIOP_PLAY_AUDIO_MSF) {
                deviceExtension->PlayActive = TRUE;
            }
        }

        break;

    case IOCTL_CDROM_SEEK_AUDIO_MSF:
        {

            PCDROM_SEEK_AUDIO_MSF inputBuffer = Irp->AssociatedIrp.SystemBuffer;

            CdDump(( 3,
                     "535DeviceControl => IOCTL_CDROM_SEEK_AUDIO_MSF recv'd.\n"
                   ));
            Irp->IoStatus.Information = 0;

            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CDROM_SEEK_AUDIO_MSF)
                ) {
                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }


            //
            // Use the data seek command to move the pickup
            // NOTE: This blithely assumes logical block size == 2048 bytes.
            //

            destblock = ((((ULONG)(inputBuffer->M) * 60)
                          + (ULONG)(inputBuffer->S)) * 75)
                        + (ULONG)(inputBuffer->F)
                        - 150;

            srb.CdbLength                = 10;
            srb.TimeOutValue             = AUDIO_TIMEOUT;
            cdb->SEEK.OperationCode      = SCSIOP_SEEK;
            cdb->SEEK.LogicalBlockAddress[0] = (UCHAR)(destblock >> 24) & 0xFF;
            cdb->SEEK.LogicalBlockAddress[1] = (UCHAR)(destblock >> 16) & 0xFF;
            cdb->SEEK.LogicalBlockAddress[2] = (UCHAR)(destblock >>  8) & 0xFF;
            cdb->SEEK.LogicalBlockAddress[3] = (UCHAR)(destblock & 0xFF);
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         NULL,
                                         0
                                       );

            if (!NT_SUCCESS(status)) {

                CdDump(( 3,
                         "535DeviceControl => SEEK failed (%lx)\n",
                         status ));

            }
        }
        break;

    case IOCTL_CDROM_EJECT_MEDIA:

        //
        // Build cdb to eject cartridge
        //

        CdDump(( 3,
                 "535DeviceControl => IOCTL_CDROM_EJECT_MEDIA recv'd.\n"
               ));
        Irp->IoStatus.Information = 0;

        deviceExtension->PlayActive = FALSE;

        srb.CdbLength                  = 10;
        srb.TimeOutValue               = AUDIO_TIMEOUT;
        cdb->CDB10.OperationCode = CDS535_EJECT_CODE;
        status = SendSrbSynchronous( deviceExtension,
                                     &srb,
                                     NULL,
                                     0
                                   );
        break;

    case IOCTL_CDROM_GET_CONTROL:
    case IOCTL_CDROM_GET_VOLUME:
    case IOCTL_CDROM_SET_VOLUME:
        CdDump(( 3, "535DeviceControl => Not Supported yet.\n" ));
        Irp->IoStatus.Information = 0;
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    case IOCTL_CDROM_CHECK_VERIFY:

        //
        // Update the play active flag.
        //

        CdAudioIsPlayActive(DeviceObject);

    default:

        CdDump((10,"535DeviceControl => Unsupported device IOCTL\n"));
        return CdAudioSendToNextDriver( DeviceObject, Irp );
        break;

    } // end switch( IOCTL )

    SetStatusAndReturn:
    //
    // set status code and return
    //

    if (status == STATUS_VERIFY_REQUIRED) {

        IoSetHardErrorOrVerifyDevice( Irp,
                                      deviceExtension->TargetDeviceObject
                                    );

        Irp->IoStatus.Information = 0;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;

}


NTSTATUS
    CdAudio435DeviceControl(
                           PDEVICE_OBJECT DeviceObject,
                           PIRP Irp
                           )

/*++

Routine Description:

    This routine is called by CdAudioDeviceControl to handle
    audio IOCTLs sent to Chinon CDS-435 cdrom drive.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PCD_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCDROM_TOC         cdaudioDataOut  = Irp->AssociatedIrp.SystemBuffer;
    SCSI_PASS_THROUGH  srb;
    PCDB               cdb = (PCDB)srb.Cdb;
    NTSTATUS           status;
    ULONG              i,bytesTransfered;
    PUCHAR             Toc;

    //
    // Clear out cdb
    //

    RtlZeroMemory( cdb, MAXIMUM_CDB_SIZE );

    //
    // What IOCTL do we need to execute?
    //

    switch (currentIrpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_CDROM_READ_TOC:
        CdDump(( 3,
                 "435DeviceControl => IOCTL_CDROM_READ_TOC recv'd.\n"
               ));

        //
        // Must have allocated at least enough buffer space
        // to store how many tracks are on the disc
        //

        if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
            ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[0]))
            ) {
            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = 0;
            break;
        }


        //
        // If the cd is playing music then reject this request.
        //

        if (CdAudioIsPlayActive(DeviceObject)) {
            status = STATUS_DEVICE_BUSY;
            Irp->IoStatus.Information = 0;
            break;
        }

        //
        // Allocate storage to hold TOC from disc
        //

        Toc = (PUCHAR)ExAllocatePool( NonPagedPoolCacheAligned,
                                      CDROM_TOC_SIZE
                                    );

        if (Toc==NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Information = 0;
            goto SetStatusAndReturn;

        }

        //
        // Set up defaults
        //

        RtlZeroMemory( Toc, CDROM_TOC_SIZE );

        //
        // Fill in cdb for this operation
        //

        cdb->READ_TOC.OperationCode = CDS435_READ_TOC_CODE;
        cdb->READ_TOC.Msf = 1;
        cdb->READ_TOC.AllocationLength[0] = (CDROM_TOC_SIZE >> 8);
        cdb->READ_TOC.AllocationLength[1] = (CDROM_TOC_SIZE & 0xFF);
        srb.TimeOutValue                  = AUDIO_TIMEOUT;
        srb.CdbLength                     = 10;
        status = SendSrbSynchronous( deviceExtension,
                                     &srb,
                                     Toc,
                                     CDROM_TOC_SIZE
                                   );

        if (!NT_SUCCESS(status) && (status!=STATUS_DATA_OVERRUN)) {

            CdDump(( 1,
                     "435DeviceControl => READ_TOC error (%lx)\n",
                     status ));

            if (status != STATUS_DATA_OVERRUN) {

                CdDump(( 1, "435DeviceControl => SRB ERROR (%lx)\n",
                         status ));
                ExFreePool( Toc );
                Irp->IoStatus.Information = 0;
                goto SetStatusAndReturn;
            }

        } else {

            status = STATUS_SUCCESS;
        }

        //
        // Translate data into SCSI-II format
        //   (track numbers, except 0xAA, must be converted from BCD)

        bytesTransfered =
            currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength >
            sizeof(CDROM_TOC) ?
            sizeof(CDROM_TOC) :
            currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

        cdaudioDataOut->Length[0]  = Toc[0];
        cdaudioDataOut->Length[1]  = Toc[1];
        cdaudioDataOut->FirstTrack = BCD_TO_DEC(Toc[2]);
        cdaudioDataOut->LastTrack  = BCD_TO_DEC(Toc[3]);

        //
        // Return only N number of tracks, where N is the number of
        // full tracks of info we can stuff into the user buffer
        // if tracks from 1 to 2, that means there are two tracks,
        // so let i go from 0 to 1 (two tracks of info)
        //
        {
            //
            // tracksToReturn == Number of real track info to return
            // tracksInBuffer == How many fit into the user-supplied buffer
            // tracksOnCd     == Number of tracks on the CD (not including lead-out)
            //

            ULONG tracksToReturn;
            ULONG tracksOnCd;
            ULONG tracksInBuffer;
            tracksOnCd = (cdaudioDataOut->LastTrack - cdaudioDataOut->FirstTrack) + 1;
            tracksInBuffer = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength -
                             ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[0]));
            tracksInBuffer /= sizeof(TRACK_DATA);

            // take the lesser of the two
            tracksToReturn = (tracksInBuffer < tracksOnCd) ?
                             tracksInBuffer :
                             tracksOnCd;

            for( i=0; i < tracksToReturn; i++ ) {

                //
                // Grab Information for each track
                //
                cdaudioDataOut->TrackData[i].Reserved    = 0;
                cdaudioDataOut->TrackData[i].Control     = Toc[(i*8)+4+1];
                cdaudioDataOut->TrackData[i].TrackNumber =
                    BCD_TO_DEC(Toc[(i*8)+4+2]);
                cdaudioDataOut->TrackData[i].Reserved1   = 0;
                cdaudioDataOut->TrackData[i].Address[0]  = 0;
                cdaudioDataOut->TrackData[i].Address[1]  = Toc[(i*8)+4+5];
                cdaudioDataOut->TrackData[i].Address[2]  = Toc[(i*8)+4+6];
                cdaudioDataOut->TrackData[i].Address[3]  = Toc[(i*8)+4+7];

                CdDump(( 4,
                            "CdAudio435DeviceControl: Track %d  %d:%d:%d\n",
                            cdaudioDataOut->TrackData[i].TrackNumber,
                            cdaudioDataOut->TrackData[i].Address[1],
                            cdaudioDataOut->TrackData[i].Address[2],
                            cdaudioDataOut->TrackData[i].Address[3]
                        ));
            }

            //
            // Fake "lead out track" info
            // Only if all tracks have been copied...
            //

            if ( tracksInBuffer > tracksOnCd ) {
                cdaudioDataOut->TrackData[i].Reserved    = 0;
                cdaudioDataOut->TrackData[i].Control     = Toc[(i*8)+4+1];
                cdaudioDataOut->TrackData[i].TrackNumber = Toc[(i*8)+4+2]; // leave as 0xAA
                cdaudioDataOut->TrackData[i].Reserved1   = 0;
                cdaudioDataOut->TrackData[i].Address[0]  = 0;
                cdaudioDataOut->TrackData[i].Address[1]  = Toc[(i*8)+4+5];
                cdaudioDataOut->TrackData[i].Address[2]  = Toc[(i*8)+4+6];
                cdaudioDataOut->TrackData[i].Address[3]  = Toc[(i*8)+4+7];
                CdDump(( 4,
                            "CdAudio435DeviceControl: Track %d  %d:%d:%d\n",
                            cdaudioDataOut->TrackData[i].TrackNumber,
                            cdaudioDataOut->TrackData[i].Address[1],
                            cdaudioDataOut->TrackData[i].Address[2],
                            cdaudioDataOut->TrackData[i].Address[3]
                        ));
                i++;
            }

            Irp->IoStatus.Information = ((ULONG)FIELD_OFFSET(CDROM_TOC, TrackData[i]));

        }

        //
        // Clear out deviceExtension data
        //

        deviceExtension->Paused = CDAUDIO_NOT_PAUSED;
        deviceExtension->PausedM = 0;
        deviceExtension->PausedS = 0;
        deviceExtension->PausedF = 0;
        deviceExtension->LastEndM = 0;
        deviceExtension->LastEndS = 0;
        deviceExtension->LastEndF = 0;

        //
        // Free storage now that we've stored it elsewhere
        //

        ExFreePool( Toc );
        break;

    case IOCTL_CDROM_PLAY_AUDIO_MSF:
    case IOCTL_CDROM_STOP_AUDIO:
        {

            PCDROM_PLAY_AUDIO_MSF inputBuffer =
                Irp->AssociatedIrp.SystemBuffer;

            Irp->IoStatus.Information = 0;

            srb.CdbLength                  = 10;
            srb.TimeOutValue               = AUDIO_TIMEOUT;
            cdb->CDB10.OperationCode = CDS435_STOP_AUDIO_CODE;
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         NULL,
                                         0
                                       );

            if (NT_SUCCESS(status)) {

                deviceExtension->PlayActive = FALSE;

                deviceExtension->Paused = CDAUDIO_NOT_PAUSED;
                deviceExtension->PausedM = 0;
                deviceExtension->PausedS = 0;
                deviceExtension->PausedF = 0;
                deviceExtension->LastEndM = 0;
                deviceExtension->LastEndS = 0;
                deviceExtension->LastEndF = 0;

            } else {

                CdDump(( 3,
                         "435DeviceControl => STOP failed (%lx)\n",
                         status ));

            }


            if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_CDROM_STOP_AUDIO
               ) {

                CdDump(( 3,
                         "435DeviceControl => IOCTL_CDROM_STOP_AUDIO recv'd.\n"
                       ));

                goto SetStatusAndReturn;

            }

            CdDump(( 3,
                     "435DeviceControl => IOCTL_CDROM_PLAY_AUDIO_MSF recv'd.\n"
                   ));

            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CDROM_PLAY_AUDIO_MSF)
                ) {
                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            //
            // Fill in cdb for this operation
            //

            srb.CdbLength                = 10;
            srb.TimeOutValue             = AUDIO_TIMEOUT;
            cdb->PLAY_AUDIO_MSF.OperationCode =
                CDS435_PLAY_AUDIO_EXTENDED_CODE;
            cdb->PLAY_AUDIO_MSF.StartingM = inputBuffer->StartingM;
            cdb->PLAY_AUDIO_MSF.StartingS = inputBuffer->StartingS;
            cdb->PLAY_AUDIO_MSF.StartingF = inputBuffer->StartingF;
            cdb->PLAY_AUDIO_MSF.EndingM   = inputBuffer->EndingM;
            cdb->PLAY_AUDIO_MSF.EndingS   = inputBuffer->EndingS;
            cdb->PLAY_AUDIO_MSF.EndingF   = inputBuffer->EndingF;
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         NULL,
                                         0
                                       );

            if (NT_SUCCESS(status)) {

                deviceExtension->PlayActive = TRUE;

                deviceExtension->Paused = CDAUDIO_NOT_PAUSED;

                //
                // Set last play ending address for next pause command
                //

                deviceExtension->LastEndM = inputBuffer->EndingM;
                deviceExtension->LastEndS = inputBuffer->EndingS;
                deviceExtension->LastEndF = inputBuffer->EndingF;
                CdDump(( 3,
                         "435DeviceControl => PLAY  ==> BcdLastEnd set to (%x %x %x)\n",
                         deviceExtension->LastEndM,
                         deviceExtension->LastEndS,
                         deviceExtension->LastEndF ));

            } else {

                CdDump(( 3,
                         "435DeviceControl => PLAY failed (%lx)\n",
                         status ));

            }
        }
        break;

    case IOCTL_CDROM_SEEK_AUDIO_MSF:
        {

            PCDROM_SEEK_AUDIO_MSF inputBuffer = Irp->AssociatedIrp.SystemBuffer;

            Irp->IoStatus.Information = 0;

            CdDump(( 3,
                     "435DeviceControl => IOCTL_CDROM_SEEK_AUDIO_MSF recv'd.\n"
                   ));

            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CDROM_SEEK_AUDIO_MSF)
                ) {
                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            //
            // Fill in cdb for this operation
            //

            srb.CdbLength                = 10;
            srb.TimeOutValue             = AUDIO_TIMEOUT;
            cdb->CDB10.OperationCode     = CDS435_PLAY_AUDIO_EXTENDED_CODE;
            cdb->PLAY_AUDIO_MSF.StartingM = inputBuffer->M;
            cdb->PLAY_AUDIO_MSF.StartingS = inputBuffer->S;
            cdb->PLAY_AUDIO_MSF.StartingF = inputBuffer->F;
            cdb->PLAY_AUDIO_MSF.EndingM   = inputBuffer->M;
            cdb->PLAY_AUDIO_MSF.EndingS   = inputBuffer->S;
            cdb->PLAY_AUDIO_MSF.EndingF   = inputBuffer->F;
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         NULL,
                                         0
                                       );

            if (NT_SUCCESS(status)) {

                deviceExtension->Paused = CDAUDIO_PAUSED;
                deviceExtension->PausedM = inputBuffer->M;
                deviceExtension->PausedS = inputBuffer->S;
                deviceExtension->PausedF = inputBuffer->F;
                deviceExtension->LastEndM = inputBuffer->M;
                deviceExtension->LastEndS = inputBuffer->S;
                deviceExtension->LastEndF = inputBuffer->F;
                CdDump(( 3,
                         "435DeviceControl => SEEK, Paused (%x %x %x) LastEnd (%x %x %x)\n",
                         deviceExtension->PausedM,
                         deviceExtension->PausedS,
                         deviceExtension->PausedF,
                         deviceExtension->LastEndM,
                         deviceExtension->LastEndS,
                         deviceExtension->LastEndF ));

            } else {

                CdDump(( 3,
                         "435DeviceControl => SEEK failed (%lx)\n",
                         status ));

                //
                // The CDS-435 drive returns STATUS_INVALID_DEVICE_REQUEST
                // when we ask to play an invalid address, so we need
                // to map to STATUS_NONEXISTENT_SECTOR in order to be
                // consistent with the other drives.
                //

                if (status==STATUS_INVALID_DEVICE_REQUEST) {

                    status = STATUS_NONEXISTENT_SECTOR;
                }

            }
        }
        break;

    case IOCTL_CDROM_PAUSE_AUDIO:
        {
            PUCHAR SubQPtr =
                ExAllocatePool( NonPagedPoolCacheAligned,
                                sizeof(SUB_Q_CHANNEL_DATA)
                              );

            Irp->IoStatus.Information = 0;

            CdDump(( 3,
                     "435DeviceControl => IOCTL_CDROM_PAUSE_AUDIO recv'd.\n"
                   ));

            if (SubQPtr==NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto SetStatusAndReturn;

            }

            //
            // Enter pause (still ) mode
            //

            if (deviceExtension->Paused==CDAUDIO_PAUSED) {

                CdDump(( 3,
                         "435DeviceControl => PAUSE: Already Paused!\n"
                       ));

                ExFreePool( SubQPtr );
                status = STATUS_SUCCESS;
                goto SetStatusAndReturn;

            }

            //
            // Since the CDS-435 doesn't have a pause mode,
            // we'll just record the current position and
            // stop the drive.
            //

            srb.CdbLength            = 10;
            srb.TimeOutValue         = AUDIO_TIMEOUT;
            cdb->SUBCHANNEL.OperationCode = CDS435_READ_SUB_Q_CHANNEL_CODE;
            cdb->SUBCHANNEL.Msf = 1;
            cdb->SUBCHANNEL.SubQ = 1;
            cdb->SUBCHANNEL.AllocationLength[1] = sizeof(SUB_Q_CHANNEL_DATA);
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         SubQPtr,
                                         sizeof(SUB_Q_CHANNEL_DATA)
                                       );
            if (!NT_SUCCESS(status)) {

                CdDump(( 1,
                         "435DeviceControl => Pause, Read Q Channel failed (%lx)\n",
                         status ));
                ExFreePool( SubQPtr );
                goto SetStatusAndReturn;
            }

            deviceExtension->PausedM = SubQPtr[9];
            deviceExtension->PausedS = SubQPtr[10];
            deviceExtension->PausedF = SubQPtr[11];

            //
            // now stop audio
            //
            RtlZeroMemory( cdb, MAXIMUM_CDB_SIZE );
            srb.CdbLength                  = 10;
            srb.TimeOutValue               = AUDIO_TIMEOUT;
            cdb->CDB10.OperationCode = CDS435_STOP_AUDIO_CODE;
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         NULL,
                                         0
                                       );
            if (!NT_SUCCESS(status)) {

                CdDump(( 1,
                         "435DeviceControl => PAUSE, StopAudio failed! (%lx)\n",
                         status ));
                ExFreePool( SubQPtr );
                goto SetStatusAndReturn;
            }

            deviceExtension->PlayActive = FALSE;

            deviceExtension->Paused = CDAUDIO_PAUSED;
            deviceExtension->PausedM = SubQPtr[9];
            deviceExtension->PausedS = SubQPtr[10];
            deviceExtension->PausedF = SubQPtr[11];

            CdDump((3,
                    "435DeviceControl => PAUSE ==> Paused  set to (%x %x %x)\n",
                    deviceExtension->PausedM,
                    deviceExtension->PausedS,
                    deviceExtension->PausedF ));

            ExFreePool( SubQPtr );
        }
        break;

    case IOCTL_CDROM_RESUME_AUDIO:

        //
        // Resume cdrom
        //

        CdDump(( 3,
                 "435DeviceControl => IOCTL_CDROM_RESUME_AUDIO recv'd.\n"
               ));

        Irp->IoStatus.Information = 0;

        //
        // Since the CDS-435 doesn't have a resume IOCTL,
        // we'll just start playing (if paused) from the
        // last recored paused position to the last recorded
        // "end of play" position.
        //

        if (deviceExtension->Paused==CDAUDIO_NOT_PAUSED) {
            status = STATUS_UNSUCCESSFUL;
            goto SetStatusAndReturn;

        }

        //
        // Fill in cdb for this operation
        //

        srb.CdbLength                = 10;
        srb.TimeOutValue             = AUDIO_TIMEOUT;
        cdb->PLAY_AUDIO_MSF.OperationCode     = CDS435_PLAY_AUDIO_EXTENDED_CODE;
        cdb->PLAY_AUDIO_MSF.StartingM = deviceExtension->PausedM;
        cdb->PLAY_AUDIO_MSF.StartingS = deviceExtension->PausedS;
        cdb->PLAY_AUDIO_MSF.StartingF = deviceExtension->PausedF;
        cdb->PLAY_AUDIO_MSF.EndingM   = deviceExtension->LastEndM;
        cdb->PLAY_AUDIO_MSF.EndingS   = deviceExtension->LastEndS;
        cdb->PLAY_AUDIO_MSF.EndingF   = deviceExtension->LastEndF;
        status = SendSrbSynchronous( deviceExtension,
                                     &srb,
                                     NULL,
                                     0
                                   );

        if (NT_SUCCESS(status)) {

            deviceExtension->PlayActive = TRUE;

            deviceExtension->Paused = CDAUDIO_NOT_PAUSED;

        } else {

            CdDump(( 1,
                     "435DeviceControl => RESUME (%x %x %x) - (%x %x %x) failed (%lx)\n",
                     deviceExtension->PausedM,
                     deviceExtension->PausedS,
                     deviceExtension->PausedF,
                     deviceExtension->LastEndM,
                     deviceExtension->LastEndS,
                     deviceExtension->LastEndF,
                     status ));

        }
        break;

    case IOCTL_CDROM_READ_Q_CHANNEL:
        {
            PSUB_Q_CURRENT_POSITION userPtr =
                Irp->AssociatedIrp.SystemBuffer;
            PUCHAR SubQPtr =
                ExAllocatePool( NonPagedPoolCacheAligned,
                                sizeof(SUB_Q_CHANNEL_DATA)
                              );

            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SUB_Q_CURRENT_POSITION)
                ) {
                status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Information = 0;
                if (SubQPtr) ExFreePool(SubQPtr);
                break;
            }


            CdDump(( 5,
                     "435DeviceControl => IOCTL_CDROM_READ_Q_CHANNEL recv'd.\n"
                   ));

            if (SubQPtr==NULL) {

                CdDump(( 1,
                         "435DeviceControl => READ_Q_CHANNEL, SubQPtr==NULL!\n"
                       ));

                RtlZeroMemory( userPtr, sizeof(SUB_Q_CURRENT_POSITION) );
                status = STATUS_INSUFFICIENT_RESOURCES;
                Irp->IoStatus.Information = 0;
                goto SetStatusAndReturn;

            }

            if ( ((PCDROM_SUB_Q_DATA_FORMAT)userPtr)->Format!=
                 IOCTL_CDROM_CURRENT_POSITION) {

                CdDump(( 1,
                         "435DeviceControl => READ_Q_CHANNEL, illegal Format (%d)\n",
                         ((PCDROM_SUB_Q_DATA_FORMAT)userPtr)->Format
                       ));

                ExFreePool( SubQPtr );
                RtlZeroMemory( userPtr, sizeof(SUB_Q_CURRENT_POSITION) );
                status = STATUS_UNSUCCESSFUL;
                Irp->IoStatus.Information = 0;
                goto SetStatusAndReturn;
            }

            //
            // Read audio play status
            //

            srb.CdbLength            = 10;
            srb.TimeOutValue         = AUDIO_TIMEOUT;
            cdb->SUBCHANNEL.OperationCode = CDS435_READ_SUB_Q_CHANNEL_CODE;
            cdb->SUBCHANNEL.Msf = 1;
            cdb->SUBCHANNEL.SubQ = 1;
            cdb->SUBCHANNEL.AllocationLength[1] = sizeof(SUB_Q_CHANNEL_DATA);
            status = SendSrbSynchronous( deviceExtension,
                                         &srb,
                                         SubQPtr,
                                         sizeof(SUB_Q_CHANNEL_DATA)
                                       );
            if (NT_SUCCESS(status)) {

                userPtr->Header.Reserved = 0;

                if (deviceExtension->Paused==CDAUDIO_PAUSED) {

                    deviceExtension->PlayActive = FALSE;
                    userPtr->Header.AudioStatus = AUDIO_STATUS_PAUSED;

                } else {

                    if (SubQPtr[1] == 0x11) {

                        deviceExtension->PlayActive = TRUE;
                        userPtr->Header.AudioStatus = AUDIO_STATUS_IN_PROGRESS;

                    } else {

                        deviceExtension->PlayActive = FALSE;
                        userPtr->Header.AudioStatus = AUDIO_STATUS_PLAY_COMPLETE;

                    }
                }

                userPtr->Header.DataLength[0] = 0;
                userPtr->Header.DataLength[1] = 12;

                userPtr->FormatCode = 0x01;
                userPtr->Control = SubQPtr[5];
                userPtr->ADR     = 0;
                userPtr->TrackNumber = BCD_TO_DEC(SubQPtr[6]);
                userPtr->IndexNumber = BCD_TO_DEC(SubQPtr[7]);
                userPtr->AbsoluteAddress[0] = 0;
                userPtr->AbsoluteAddress[1] = SubQPtr[9];
                userPtr->AbsoluteAddress[2] = SubQPtr[10];
                userPtr->AbsoluteAddress[3] = SubQPtr[11];
                userPtr->TrackRelativeAddress[0] = 0;
                userPtr->TrackRelativeAddress[1] = SubQPtr[13];
                userPtr->TrackRelativeAddress[2] = SubQPtr[14];
                userPtr->TrackRelativeAddress[3] = SubQPtr[15];
                Irp->IoStatus.Information = sizeof(SUB_Q_CURRENT_POSITION);

            } else {

                Irp->IoStatus.Information = 0;
                CdDump(( 1,
                         "435DeviceControl => READ_Q_CHANNEL failed (%lx)\n",
                         status
                       ));


            }

            ExFreePool( SubQPtr );
        }
        break;

    case IOCTL_CDROM_EJECT_MEDIA:

        //
        // Build cdb to eject cartridge
        //

        CdDump(( 3,
                 "435DeviceControl => IOCTL_CDROM_EJECT_MEDIA recv'd.\n"
               ));

        Irp->IoStatus.Information = 0;

        srb.CdbLength                  = 10;
        srb.TimeOutValue               = AUDIO_TIMEOUT;
        cdb->CDB10.OperationCode = CDS435_EJECT_CODE;
        status = SendSrbSynchronous( deviceExtension,
                                     &srb,
                                     NULL,
                                     0
                                   );

        deviceExtension->Paused = CDAUDIO_NOT_PAUSED;
        deviceExtension->PausedM = 0;
        deviceExtension->PausedS = 0;
        deviceExtension->PausedF = 0;
        deviceExtension->LastEndM = 0;
        deviceExtension->LastEndS = 0;
        deviceExtension->LastEndF = 0;

        break;

    case IOCTL_CDROM_GET_CONTROL:
    case IOCTL_CDROM_GET_VOLUME:
    case IOCTL_CDROM_SET_VOLUME:
        CdDump(( 3, "435DeviceControl => Not Supported yet.\n" ));
        Irp->IoStatus.Information = 0;
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    case IOCTL_CDROM_CHECK_VERIFY:

        CdDump(( 3, "435DeviceControl => IOCTL_CDROM_CHECK_VERIFY recv'd.\n"
               ));


        //
        // Update the play active flag.
        //


        if (CdAudioIsPlayActive(DeviceObject) == TRUE) {
            deviceExtension->PlayActive = TRUE;
            status = STATUS_SUCCESS;     // media must be in place if audio
            Irp->IoStatus.Information = 0; //  is playing
            goto SetStatusAndReturn;
        } else {
            deviceExtension->PlayActive = FALSE;
            return CdAudioSendToNextDriver( DeviceObject, Irp );
        }
        break;

    default:

        CdDump((10,"435DeviceControl => Unsupported device IOCTL\n"));
        return CdAudioSendToNextDriver( DeviceObject, Irp );
        break;

    } // end switch( IOCTL )

    SetStatusAndReturn:
    //
    // set status code and return
    //

    if (status == STATUS_VERIFY_REQUIRED) {

        IoSetHardErrorOrVerifyDevice( Irp,
                                      deviceExtension->TargetDeviceObject
                                    );

        Irp->IoStatus.Information = 0;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;

}


NTSTATUS
    CdAudioAtapiDeviceControl(
                             IN PDEVICE_OBJECT DeviceObject,
                             IN PIRP Irp
                             )

{

    NTSTATUS             status;
    PCD_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION   currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    SCSI_PASS_THROUGH    srb;
    PHITACHICDB          cdb = (PHITACHICDB)srb.Cdb;

    CdDump ((3,"AtapiDeviceControl => IoControl %x.\n",
             currentIrpStack->Parameters.DeviceIoControl.IoControlCode));

    //
    // The Atapi devices supported only need remapping of IOCTL_CDROM_STOP_AUDIO
    //

    if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode ==
        IOCTL_CDROM_STOP_AUDIO
        ) {

        Irp->IoStatus.Information = 0;

        deviceExtension->PlayActive = FALSE;

        //
        // Zero and fill in new Srb
        //

        RtlZeroMemory(&srb, sizeof(SCSI_PASS_THROUGH));

        //
        // Issue the Atapi STOP_PLAY command.
        //

        cdb->STOP_PLAY.OperationCode = 0x4E;

        srb.CdbLength = 12;

        //
        // Set timeout value.
        //

        srb.TimeOutValue = AUDIO_TIMEOUT;

        status = SendSrbSynchronous(deviceExtension,
                                    &srb,
                                    NULL,
                                    0);

        if (!NT_SUCCESS(status)) {

            CdDump(( 1,
                     "AtapiDeviceControl => STOP_AUDIO error (%lx)\n",
                     status ));

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;

        }

    } else {

        return CdAudioSendToNextDriver( DeviceObject, Irp );

    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;

}

VOID
    HpCdrProcessLastSession(
                           IN PCDROM_TOC Toc
                           )

/*++

Routine Description:

    This routine fixes up the multi session table of contents when the
    session data is returned for HP CDR 4020i drives.

Arguments:

    Toc - the table of contents buffer returned from the drive.

Return Value:

    None

--*/

{
    ULONG index;
    PUCHAR cp;

    index = Toc->FirstTrack;

    if (index) {
        index--;

        //
        // Fix up the TOC information from the HP method to how it is
        // interpreted by the file systems.
        //

        Toc->FirstTrack = Toc->TrackData[0].Reserved;
        Toc->LastTrack = Toc->TrackData[index].Reserved;
        Toc->TrackData[0] = Toc->TrackData[index];
    } else {
        Toc->FirstTrack = Toc->LastTrack = 0;
    }

    CdDump((2, "HP TOC data for last session\n"));
    for (cp = (PUCHAR) Toc, index = 0; index < 12; index++, cp++) {
        CdDump((2, "%2x ", *cp));
    }
    CdDump((2, "\n"));
}


NTSTATUS
    HPCdrCompletion(
                   IN PDEVICE_OBJECT DeviceObject,
                   IN PIRP Irp,
                   IN PVOID Context
                   )

/*++

Routine Description:

    This routine is called when the I/O request has completed.

Arguments:

    DeviceObject - SimBad device object.
    Irp          - Completed request.
    Context      - not used.  Set up to also be a pointer to the DeviceObject.

Return Value:

    NTSTATUS

--*/

{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(DeviceObject);

    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );

    }

    if (NT_SUCCESS(Irp->IoStatus.Status)) {
        HpCdrProcessLastSession((PCDROM_TOC)Irp->AssociatedIrp.SystemBuffer);
    }
    return Irp->IoStatus.Status;
}


NTSTATUS
    CdAudioHPCdrDeviceControl(
                             PDEVICE_OBJECT DeviceObject,
                             PIRP Irp
                             )

/*++

Routine Description:

    This routine is called by CdAudioDeviceControl to handle
    audio IOCTLs sent to the HPCdr device - this specifically handles
    session data for multi session support.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION   currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION   nextIrpStack    = IoGetNextIrpStackLocation(Irp);
    PCD_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    //
    // Is this a GET_LAST_SESSION request
    //

    if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode ==
        IOCTL_CDROM_GET_LAST_SESSION
        ) {

        //
        // Copy stack parameters to next stack.
        //

        IoCopyCurrentIrpStackLocationToNext( Irp );

        //
        // Set IRP so IoComplete calls our completion routine.
        //

        IoSetCompletionRoutine(Irp,
                               HPCdrCompletion,
                               deviceExtension,
                               TRUE,
                               TRUE,
                               TRUE);

        //
        // Send this to next driver layer and process on completion.
        //

        return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

    } else {

        return CdAudioSendToNextDriver( DeviceObject, Irp );

    }

    //
    // Cannot get here
    //

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
CdAudioForwardIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sends the Irp to the next driver in line
    when the Irp needs to be processed by the lower drivers
    prior to being processed by this one.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PCD_DEVICE_EXTENSION deviceExtension;
    KEVENT event;
    NTSTATUS status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    deviceExtension = (PCD_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    //
    // copy the irpstack for the next device
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // set a completion routine
    //

    IoSetCompletionRoutine(Irp, CdAudioSignalCompletion,
                            &event, TRUE, TRUE, TRUE);

    //
    // call the next lower device
    //

    status = IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

    //
    // wait for the actual completion
    //

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;

} // end DiskPerfForwardIrpSynchronous()


VOID CdAudioUnload(
                  IN PDRIVER_OBJECT DriverObject
                  )

/*++

Routine Description:

    This routine is called when the control panel "Unloads"
    the CDROM device.

Arguments:

    DeviceObject

Return Value:

    void

--*/

{
    CdDump((1,
            "Unload => Unloading for DeviceObject %p\n",
            DriverObject->DeviceObject
            ));
    ASSERT(!DriverObject->DeviceObject);
    return;
}

NTSTATUS
    CdAudioPower(
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP Irp
                 )
{
    PCD_DEVICE_EXTENSION deviceExtension;

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);

    deviceExtension = (PCD_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    return PoCallDriver(deviceExtension->TargetDeviceObject, Irp);
}


#if DBG

    #include "stdarg.h"
    #define DBGHDR   "[cdaudio] "

VOID
    CdAudioDebugPrint(
                     ULONG DebugPrintLevel,
                     PCCHAR DebugMessage,
                     ...
                     )

/*++

Routine Description:

    Debug print for CdAudio driver

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;
    va_start( ap, DebugMessage );

    if (DebugPrintLevel <= CdAudioDebug) {

        char buffer[128];
        DbgPrint(DBGHDR);
        vsprintf(buffer, DebugMessage, ap);
        DbgPrint(buffer);
    }

    va_end(ap);

}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\cdrom\data.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:


Abstract:


Environment:


Notes:

Revision History:

--*/

#include "ntddk.h"
#include "classpnp.h"
#include "trace.h"

#include "data.tmh"


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

/*

#define CDROM_HACK_DEC_RRD                 (0x00000001)
#define CDROM_HACK_FUJITSU_FMCD_10x        (0x00000002)
#define CDROM_HACK_HITACHI_1750            (0x00000004)
#define CDROM_HACK_HITACHI_GD_2000         (0x00000008)
#define CDROM_HACK_TOSHIBA_SD_W1101        (0x00000010)
#define CDROM_HACK_TOSHIBA_XM_3xx          (0x00000020)
#define CDROM_HACK_NEC_CDDA                (0x00000040)
#define CDROM_HACK_PLEXTOR_CDDA            (0x00000080)
#define CDROM_HACK_BAD_GET_CONFIG_SUPPORT  (0x00000100)
#define CDROM_HACK_FORCE_READ_CD_DETECTION (0x00000200)
#define CDROM_HACK_READ_CD_SUPPORTED       (0x00000400)

*/

CLASSPNP_SCAN_FOR_SPECIAL_INFO CdromHackItems[] = {
    // digital put out drives using 512 byte block sizes,
    // and needed us to send a mode page to set the sector
    // size back to 2048.
    { "DEC"     , "RRD"                            , NULL,   0x0001 },
    // these fujitsu drives take longer than ten seconds to
    // timeout commands when audio discs are placed in them
    { "FUJITSU" , "FMCD-101"                       , NULL,   0x0002 },
    { "FUJITSU" , "FMCD-102"                       , NULL,   0x0002 },
    // these hitachi drives don't work properly in PIO mode
    { "HITACHI ", "CDR-1750S"                      , NULL,   0x0004 },
    { "HITACHI ", "CDR-3650/1650S"                 , NULL,   0x0004 },
    // this particular gem doesn't automatcially spin up
    // on some media access commands.
    { ""        , "HITACHI GD-2000"                , NULL,   0x0008 },
    { ""        , "HITACHI DVD-ROM GD-2000"        , NULL,   0x0008 },
    // this particular drive doesn't support DVD playback.
    // just print an error message in CHK builds.
    { "TOSHIBA ", "SD-W1101 DVD-RAM"               , NULL,   0x0010 },
    // not sure what this device's issue was.  seems to
    // require mode selects at various times.
    { "TOSHIBA ", "CD-ROM XM-3"                    , NULL,   0x0020 },
    // NEC defined a "READ_CD" type command before there was
    // a standard, so fall back on this as an option.
    { "NEC"     , ""                               , NULL,   0x0040 },
    // plextor defined a "READ_CD" type command before there was
    // a standard, so fall back on this as an option.
    { "PLEXTOR ", ""                               , NULL,   0x0080 },
    // this drive times out and sometimes disappears from the bus
    // when send GET_CONFIGURATION commands.  don't send them.
    { ""        , "LG DVD-ROM DRD-840B"            , NULL,   0x0100 },
    { ""        , "SAMSUNG DVD-ROM SD-608"         , NULL,   0x0300 },
    // these drives should have supported READ_CD, but at least
    // some firmware revisions did not.  force READ_CD detection.
    { ""        , "SAMSUNG DVD-ROM SD-"            , NULL,   0x2000 },
    // the mitsumi drive below doesn't follow the block-only spec,
    // and we end up hanging when sending it commands it doesn't
    // understand.  this causes complications later, also.
    { "MITSUMI ", "CR-4802TE       "               , NULL,   0x0100 },
    // some drives return various funky errors (such as 3/2/0 NO_SEEK_COMPLETE)
    // during the detection of READ_CD support, resulting in iffy detection.
    // since they probably don't support mode switching, which is really old
    // legacy stuff anyways, the ability to read digitally is lost when
    // these drives return unexpected error codes.  note: MMC compliant drives
    // are presumed to support READ_CD, as are DVD drives, and anything
    // connected to a bus type other than IDE or SCSI, and therefore don't
    // need to be here.
    { "YAMAHA  ", "CRW8424S        "               , NULL,   0x0400 },
    // and finally, a place to finish the list. :)
    { NULL      , NULL                             , NULL,   0x0000 }
};

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\cdrom\cdrom.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    cdromp.h

Abstract:

    Private header file for cdrom.sys.  This contains private
    structure and function declarations as well as constant
    values which do not need to be exported.

Author:

Environment:

    kernel mode only

Notes:


Revision History:

--*/

#ifndef __CDROMP_H__
#define __CDROMP_H__

#include "ntddmmc.h"
#include "trace.h"

extern CLASSPNP_SCAN_FOR_SPECIAL_INFO CdromHackItems[];

typedef enum {
    CdromDebugError     = 0,  // always printed
    CdromDebugWarning   = 1,  // set bit 0x00000001 in nt!kd_cdrom_mask
    CdromDebugTrace     = 2,  // set bit 0x00000002 in nt!kd_cdrom_mask
    CdromDebugInfo      = 3,  // set bit 0x00000004 in nt!kd_cdrom_mask
#if 0
    CdromDebug          = z,  // set bit 0x00000000 in nt!kd_cdrom_mask
    CdromDebug          = z,  // set bit 0x00000000 in nt!kd_cdrom_mask
    CdromDebug          = z,  // set bit 0x00000000 in nt!kd_cdrom_mask
    CdromDebug          = z,  // set bit 0x00000000 in nt!kd_cdrom_mask
#endif 0
    CdromDebugFeatures  = 32  // set bit 0x80000000 in nt!kd_cdrom_mask
};

#define CDROM_GET_CONFIGURATION_TIMEOUT    (0x4)

#define CDROM_HACK_DEC_RRD                 (0x00000001)
#define CDROM_HACK_FUJITSU_FMCD_10x        (0x00000002)
#define CDROM_HACK_HITACHI_1750            (0x00000004)
#define CDROM_HACK_HITACHI_GD_2000         (0x00000008)
#define CDROM_HACK_TOSHIBA_SD_W1101        (0x00000010)
#define CDROM_HACK_TOSHIBA_XM_3xx          (0x00000020)
#define CDROM_HACK_NEC_CDDA                (0x00000040)
#define CDROM_HACK_PLEXTOR_CDDA            (0x00000080)
#define CDROM_HACK_BAD_GET_CONFIG_SUPPORT  (0x00000100)
#define CDROM_HACK_FORCE_READ_CD_DETECTION (0x00000200)
#define CDROM_HACK_READ_CD_SUPPORTED       (0x00000400)
#define CDROM_HACK_LOCKED_PAGES            (0x80000000) // not a valid flag to save
                                     
#define CDROM_HACK_VALID_FLAGS             (0x000007ff)
#define CDROM_HACK_INVALID_FLAGS           (~CDROM_HACK_VALID_FLAGS)


typedef struct _XA_CONTEXT {

    //
    // Pointer to the device object.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // Pointer to the original request when
    // a mode select must be sent.
    //

    PIRP OriginalRequest;

    //
    // Pointer to the mode select srb.
    //

    PSCSI_REQUEST_BLOCK Srb;
} XA_CONTEXT, *PXA_CONTEXT;

typedef struct _ERROR_RECOVERY_DATA {
    MODE_PARAMETER_HEADER   Header;
    MODE_PARAMETER_BLOCK BlockDescriptor;
    MODE_READ_RECOVERY_PAGE ReadRecoveryPage;
} ERROR_RECOVERY_DATA, *PERROR_RECOVERY_DATA;

typedef struct _ERROR_RECOVERY_DATA10 {
    MODE_PARAMETER_HEADER10 Header10;
    MODE_PARAMETER_BLOCK BlockDescriptor10;
    MODE_READ_RECOVERY_PAGE ReadRecoveryPage10;
} ERROR_RECOVERY_DATA10, *PERROR_RECOVERY_DATA10;

//
// CdRom specific addition to device extension.
//

typedef struct _CDROM_DRIVER_EXTENSION {
    ULONG InterlockedCdRomCounter;
    PVOID Reserved[3];
} CDROM_DRIVER_EXTENSION, *PCDROM_DRIVER_EXTENSION;

#define CdromMmcUpdateComplete 0
#define CdromMmcUpdateRequired 1
#define CdromMmcUpdateStarted  2

typedef struct _CDROM_MMC_EXTENSION {

    ULONG        IsMmc;        // allow quick checks
    ULONG        WriteAllowed;
           
    LONG         UpdateState;
    
    LIST_ENTRY DelayedIrpsList;  
    ULONG NumDelayedIrps;
    KSPIN_LOCK   DelayedIrpsLock;  
    
    PIO_WORKITEM              CapabilitiesWorkItem;
    PIRP                      CapabilitiesIrp;
    PMDL                      CapabilitiesMdl;
    PGET_CONFIGURATION_HEADER CapabilitiesBuffer;
    ULONG                     CapabilitiesBufferSize;
    KEVENT                    CapabilitiesEvent;
    SCSI_REQUEST_BLOCK        CapabilitiesSrb;

} CDROM_MMC_EXTENSION, *PCDROM_MMC_EXTENSION;


#define CDROM_DRIVER_EXTENSION_ID CdRomAddDevice

typedef struct _CDROM_DATA {

    //
    // Pointer to the cdrom driver extension
    //

    PCDROM_DRIVER_EXTENSION DriverExtension;


    //
    // These bits allow detection of when to requery the
    // drive's capabilities.
    //

    CDROM_MMC_EXTENSION Mmc;

    //
    // hack flags for ScanForSpecial routines
    //

    ULONG_PTR HackFlags;

    //
    // the error handling routines need to be per-device,
    // not per-driver....
    //

    PCLASS_ERROR ErrorHandler;

    //
    // Indicates whether an audio play operation
    // is currently being performed.
    // Only thing this does is prevent reads and
    // toc requests while playing audio.
    //

    BOOLEAN PlayActive;

    //
    // Indicates whether the blocksize used for user data
    // is 2048 or 2352.
    //

    BOOLEAN RawAccess;

    //
    // Indicates that this is a DEC RRD cdrom.
    // This drive requires software to fix responses
    // from the faulty firmware
    //

    BOOLEAN IsDecRrd;

    //
    // This points to an irp which needs to be delayed for a bit before a
    // retry can be attempted.  The interval counter is set by the deferring
    // routine and will be decremented to zero in the tick handler.  Once
    // the counter goes to zero the irp will be issued again.
    // DelayedRetryResend controls whether the irp is resent to the lower
    // driver (TRUE) or reissued into the startio routine (FALSE)
    //

    BOOLEAN DelayedRetryResend;

    PIRP DelayedRetryIrp;

    ULONG DelayedRetryInterval;

    KSPIN_LOCK DelayedRetrySpinLock;

    //
    // indicate we need to pick a default dvd region
    // for the user if we can
    //

    ULONG PickDvdRegion;

    //
    // The interface strings registered for this device.
    //

    UNICODE_STRING CdromInterfaceString;
    UNICODE_STRING VolumeInterfaceString;

    //
    // The well known name link for this device.
    //

    UNICODE_STRING WellKnownName;

    //
    // Indicates whether 6 or 10 bytes mode sense/select
    // should be used
    //

    ULONG XAFlags;

    //
    // keep track of what type of DVD device we are
    //

    BOOLEAN DvdRpc0Device;
    BOOLEAN DvdRpc0LicenseFailure;
    UCHAR   Rpc0SystemRegion;           // bitmask, one means prevent play
    UCHAR   Rpc0SystemRegionResetCount;

    ULONG   Rpc0RetryRegistryCallback;   // one until initial region choosen

    KMUTEX  Rpc0RegionMutex;

    //
    // Storage for the error recovery page. This is used
    // as an easy method to switch block sizes.
    //
    // NOTE - doubly unnamed structs just aren't very clean looking code - this
    // should get cleaned up at some point in the future.
    //

    union {
        ERROR_RECOVERY_DATA;
        ERROR_RECOVERY_DATA10;
    };

} CDROM_DATA, *PCDROM_DATA;

#define DEVICE_EXTENSION_SIZE sizeof(FUNCTIONAL_DEVICE_EXTENSION) + sizeof(CDROM_DATA)
#define SCSI_CDROM_TIMEOUT          10
#define SCSI_CHANGER_BONUS_TIMEOUT  10
#define HITACHI_MODE_DATA_SIZE      12
#define MODE_DATA_SIZE              64
#define RAW_SECTOR_SIZE           2352
#define COOKED_SECTOR_SIZE        2048
#define CDROM_SRB_LIST_SIZE          4

#define PLAY_ACTIVE(x) (((PCDROM_DATA)(x->CommonExtension.DriverData))->PlayActive)

#define MSF_TO_LBA(Minutes,Seconds,Frames) \
                (ULONG)((60 * 75 * (Minutes)) + (75 * (Seconds)) + ((Frames) - 150))

#define LBA_TO_MSF(Lba,Minutes,Seconds,Frames)               \
{                                                            \
    (Minutes) = (UCHAR)(Lba  / (60 * 75));                   \
    (Seconds) = (UCHAR)((Lba % (60 * 75)) / 75);             \
    (Frames)  = (UCHAR)((Lba % (60 * 75)) % 75);             \
}

#define DEC_TO_BCD(x) (((x / 10) << 4) + (x % 10))

//
// Define flags for XA, CDDA, and Mode Select/Sense
//

#define XA_USE_6_BYTE             0x01
#define XA_USE_10_BYTE            0x02

#define XA_NOT_SUPPORTED          0x10
#define XA_USE_READ_CD            0x20
#define XA_PLEXTOR_CDDA           0x40
#define XA_NEC_CDDA               0x80

//
// Sector types for READ_CD
//

#define ANY_SECTOR                0
#define CD_DA_SECTOR              1
#define YELLOW_MODE1_SECTOR       2
#define YELLOW_MODE2_SECTOR       3
#define FORM2_MODE1_SECTOR        4
#define FORM2_MODE2_SECTOR        5

#define MAX_COPY_PROTECT_AGID     4

#ifdef ExAllocatePool
#undef ExAllocatePool
#define ExAllocatePool #assert(FALSE)
#endif

#define CDROM_TAG_GET_CONFIG    'cCcS'  // "ScCc" - ioctl GET_CONFIGURATION
#define CDROM_TAG_DC_EVENT      'ECcS'  // "ScCE" - device control synch event
#define CDROM_TAG_FEATURE       'FCcS'  // "ScCF" - allocated by CdRomGetConfiguration(), free'd by caller
#define CDROM_TAG_DISK_GEOM     'GCcS'  // "ScCG" - disk geometry buffer
#define CDROM_TAG_HITACHI_ERROR 'HCcS'  // "ScCH" - hitachi error buffer
#define CDROM_TAG_SENSE_INFO    'ICcS'  // "ScCI" - sense info buffers
#define CDROM_TAG_POWER_IRP     'iCcS'  // "ScCi" - irp for power request
#define CDROM_TAG_SRB           'SCcS'  // "ScCS" - srb allocation
#define CDROM_TAG_STRINGS       'sCcS'  // "ScCs" - assorted string data
#define CDROM_TAG_MODE_DATA     'MCcS'  // "ScCM" - mode data buffer
#define CDROM_TAG_READ_CAP      'PCcS'  // "ScCP" - read capacity buffer
#define CDROM_TAG_PLAY_ACTIVE   'pCcS'  // "ScCp" - play active checks
#define CDROM_TAG_SUB_Q         'QCcS'  // "ScCQ" - read sub q buffer
#define CDROM_TAG_RAW           'RCcS'  // "ScCR" - raw mode read buffer
#define CDROM_TAG_TOC           'TCcS'  // "ScCT" - read toc buffer
#define CDROM_TAG_TOSHIBA_ERROR 'tCcS'  // "ScCt" - toshiba error buffer
#define CDROM_TAG_DEC_ERROR     'dCcS'  // "ScCt" - DEC error buffer
#define CDROM_TAG_UPDATE_CAP    'UCcS'  // "ScCU" - update capacity path
#define CDROM_TAG_VOLUME        'VCcS'  // "ScCV" - volume control buffer
#define CDROM_TAG_VOLUME_INT    'vCcS'  // "ScCv" - volume control buffer

#define DVD_TAG_READ_STRUCTURE  'SVcS'  // "ScVS" - used for dvd structure reads
#define DVD_TAG_READ_KEY        'kVcS'  // "ScVk" - read buffer for dvd key
#define DVD_TAG_SEND_KEY        'KVcS'  // "ScVK" - write buffer for dvd key
#define DVD_TAG_RPC2_CHECK      'sVcS'  // "ScVs" - read buffer for dvd/rpc2 check
#define DVD_TAG_DVD_REGION      'tVcS'  // "ScVt" - read buffer for rpc2 check
#define DVD_TAG_SECURITY        'XVcS' // "ScVX" - security descriptor


#define CDROM_SUBKEY_NAME        (L"CdRom")  // store new settings here
#define CDROM_READ_CD_NAME       (L"ReadCD") // READ_CD support previously detected
#define CDROM_NON_MMC_DRIVE_NAME (L"NonMmc") // MMC commands hang
//
// DVD Registry Value Names for RPC0 Device
//
#define DVD_DEFAULT_REGION       (L"DefaultDvdRegion")    // this is init. by the dvd class installer
#define DVD_CURRENT_REGION       (L"DvdR")
#define DVD_REGION_RESET_COUNT   (L"DvdRCnt")
#define DVD_MAX_REGION_RESET_COUNT  2
#define DVD_MAX_REGION              8



#define BAIL_OUT(Irp) \
    DebugPrint((2, "Cdrom: [%p] Bailing with status " \
                " %lx at line %x file %s\n",          \
                (Irp), (Irp)->IoStatus.Status,        \
                __LINE__, __FILE__))


/*++

Routine Description:

    This routine grabs an extra remove lock using a local variable
    for a unique tag.  It then completes the irp in question, and
    the just-acquired removelock guarantees that it is still safe
    to call IoStartNextPacket().  When that finishes, we release
    the newly acquired RemoveLock and return.

Arguments:

    DeviceObject - the device object for the StartIo queue
    Irp - the request we are completing

Return Value:

    None

Notes:

    This is implemented as an inline function to allow the compiler
    to optimize this as either a function call or as actual inline code.
    
    This routine will not work with IoXxxRemoveLock() calls, as the
    behavior is different.  ClassXxxRemoveLock() calls succeed until
    the remove has completed, while IoXxxRemoveLock() calls fail as
    soon as the call to IoReleaseRemoveLockAndWait() has been called.
    The Class version allows this routine to work in a safe manner.
    
    replaces the following two lines:
        IoStartNextPacket(DeviceObject, FALSE);
        ClassReleaseRemoveLock(DeviceObject, Irp);
    and raises irql as needed to call IoStartNextPacket()

--*/
__inline
VOID
CdRomCompleteIrpAndStartNextPacketSafely(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    UCHAR uniqueAddress;
    KIRQL oldIrql = KeGetCurrentIrql();
    
    ClassAcquireRemoveLock(DeviceObject, (PIRP)&uniqueAddress);
    ClassReleaseRemoveLock(DeviceObject, Irp);
    ClassCompleteRequest(DeviceObject, Irp, IO_CD_ROM_INCREMENT);
    
    if (oldIrql > DISPATCH_LEVEL) {
        ASSERT(!"Cannot call IoStartNextPacket at raised IRQL!");
    } else if (oldIrql < DISPATCH_LEVEL) {
        KeRaiseIrqlToDpcLevel();
    } else { //  (oldIrql == DISPATCH_LEVEL)
        NOTHING;
    }

    IoStartNextPacket(DeviceObject, FALSE);
    
    if (oldIrql > DISPATCH_LEVEL) {
        ASSERT(!"Cannot call IoStartNextPacket at raised IRQL!");
    } else if (oldIrql < DISPATCH_LEVEL) {
        KeLowerIrql(oldIrql);
    } else { //  (oldIrql == DISPATCH_LEVEL)
        NOTHING;
    }

    ClassReleaseRemoveLock(DeviceObject, (PIRP)&uniqueAddress);


    return;
}

VOID
CdRomDeviceControlDvdReadStructure(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP OriginalIrp,
    IN PIRP NewIrp,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
CdRomDeviceControlDvdEndSession(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP OriginalIrp,
    IN PIRP NewIrp,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
CdRomDeviceControlDvdStartSessionReadKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP OriginalIrp,
    IN PIRP NewIrp,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
CdRomDeviceControlDvdSendKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP OriginalIrp,
    IN PIRP NewIrp,
    IN PSCSI_REQUEST_BLOCK Srb
    );



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
CdRomUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
CdRomAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
CdRomOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
CdRomReadWriteVerification(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
CdRomSwitchMode(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN PIRP  OriginalRequest
    );

NTSTATUS
CdRomDeviceControlDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
CdRomDeviceControlCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
CdRomSetVolumeIntermediateCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
CdRomSwitchModeCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
CdRomXACompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
CdRomClassIoctlCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
CdRomStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
CdRomTickHandler(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
CdRomUpdateCapacity(
    IN PFUNCTIONAL_DEVICE_EXTENSION DeviceExtension,
    IN PIRP IrpToComplete,
    IN OPTIONAL PKEVENT IoctlEvent
    );

NTSTATUS
CdRomCreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );

VOID
ScanForSpecialHandler(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    ULONG_PTR HackFlags
    );

VOID
ScanForSpecial(
    PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
CdRomIsPlayActive(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
CdRomErrorHandler(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    );

VOID
HitachiProcessErrorGD2000(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    );

VOID
HitachiProcessError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    );

VOID
ToshibaProcessError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    );

NTSTATUS
ToshibaProcessErrorCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

VOID
CdRomCreateNamedEvent(
    IN PFUNCTIONAL_DEVICE_EXTENSION DeviceExtension,
    IN ULONG DeviceNumber
    );

NTSTATUS
CdRomInitDevice(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
CdRomStartDevice(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
CdRomStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );

NTSTATUS
CdRomRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );

NTSTATUS
CdRomDvdEndAllSessionsCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
CdRomDvdReadDiskKeyCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

DEVICE_TYPE
CdRomGetDeviceType(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
CdRomCreateWellKnownName(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
CdRomDeleteWellKnownName(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
CdRomGetDeviceParameter (
    IN     PDEVICE_OBJECT      DeviceObject,
    IN     PWSTR               ParameterName,
    IN OUT PULONG              ParameterValue
    );

NTSTATUS
CdRomSetDeviceParameter (
    IN PDEVICE_OBJECT DeviceObject,
    IN PWSTR          ParameterName,
    IN ULONG          ParameterValue
    );

VOID
CdRomPickDvdRegion (
    IN PDEVICE_OBJECT Fdo
);

NTSTATUS
CdRomRetryRequest(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PIRP Irp,
    IN ULONG Delay,
    IN BOOLEAN ResendIrp
    );

NTSTATUS
CdRomRerunRequest(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN OPTIONAL PIRP Irp,
    IN BOOLEAN ResendIrp
    );

NTSTATUS
CdRomGetRpc0Settings(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
CdRomSetRpc0Settings(
    IN PDEVICE_OBJECT Fdo,
    IN UCHAR NewRegion
    );

NTSTATUS
CdRomShutdownFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

////////////////////////////////////////////////////////////////////////////////

VOID
CdRomIsDeviceMmcDevice(
    IN PDEVICE_OBJECT Fdo,
    OUT PBOOLEAN IsMmc
    );

NTSTATUS
CdRomMmcErrorHandler(
    IN PDEVICE_OBJECT Fdo,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT PNTSTATUS Status,
    OUT PBOOLEAN Retry
    );

PVOID
CdRomFindFeaturePage(
    IN PGET_CONFIGURATION_HEADER FeatureBuffer,
    IN ULONG Length,
    IN FEATURE_NUMBER Feature
    );

NTSTATUS
CdRomGetConfiguration(
    IN PDEVICE_OBJECT Fdo,
    OUT PGET_CONFIGURATION_HEADER *Buffer,
    OUT PULONG BytesReturned,
    IN FEATURE_NUMBER StartingFeature,
    IN ULONG RequestedType
    );

VOID
CdRomUpdateMmcDriveCapabilities(
    IN PDEVICE_OBJECT Fdo,
    IN PVOID Context // RESERVED == NULL
    );

VOID
CdRomFindProfileInProfiles(
    IN PFEATURE_DATA_PROFILE_LIST ProfileHeader,
    IN FEATURE_PROFILE_TYPE ProfileToFind,
    OUT PBOOLEAN Exists
    );

NTSTATUS
CdRomAllocateMmcResources(
    IN PDEVICE_OBJECT Fdo
    );

VOID
CdRomDeAllocateMmcResources(
    IN PDEVICE_OBJECT Fdo
    );

VOID
CdromFakePartitionInfo(
    IN PCOMMON_DEVICE_EXTENSION CommonExtension,
    IN PIRP Irp
    );

VOID
CdRomInterpretReadCapacity(
    IN PDEVICE_OBJECT Fdo,
    IN PREAD_CAPACITY_DATA ReadCapacityBuffer
    );

NTSTATUS
CdRomShutdownFlushCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
CdRompFlushDelayedList(
    IN PDEVICE_OBJECT Fdo,
    IN PCDROM_MMC_EXTENSION MmcData,
    IN NTSTATUS Status,
    IN BOOLEAN CalledFromWorkItem
    );

#endif // __CDROMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\cdrom\cdrom.c ===
/*--

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    cdrom.c

Abstract:

    The CDROM class driver tranlates IRPs to SRBs with embedded CDBs
    and sends them to its devices through the port driver.

Environment:

    kernel mode only

Notes:

    SCSI Tape, CDRom and Disk class drivers share common routines
    that can be found in the CLASS directory (..\ntos\dd\class).

Revision History:

--*/

#include "stddef.h"
#include "string.h"

#include "ntddk.h"

#include "ntddcdvd.h"
#include "classpnp.h"

#include "initguid.h"
#include "ntddstor.h"
#include "cdrom.h"

#include "cdrom.tmh"


#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, CdRomUnload)
#pragma alloc_text(PAGE, CdRomAddDevice)
#pragma alloc_text(PAGE, CdRomCreateDeviceObject)
#pragma alloc_text(PAGE, CdRomStartDevice)
#pragma alloc_text(PAGE, ScanForSpecial)
#pragma alloc_text(PAGE, ScanForSpecialHandler)
#pragma alloc_text(PAGE, CdRomRemoveDevice)
#pragma alloc_text(PAGE, CdRomGetDeviceType)
#pragma alloc_text(PAGE, CdRomReadWriteVerification)
#pragma alloc_text(PAGE, CdRomGetDeviceParameter)
#pragma alloc_text(PAGE, CdRomSetDeviceParameter)
#pragma alloc_text(PAGE, CdRomPickDvdRegion)
#pragma alloc_text(PAGE, CdRomIsPlayActive)

#pragma alloc_text(PAGEHITA, HitachiProcessError)
#pragma alloc_text(PAGEHIT2, HitachiProcessErrorGD2000)

#pragma alloc_text(PAGETOSH, ToshibaProcessErrorCompletion)
#pragma alloc_text(PAGETOSH, ToshibaProcessError)

#endif

#define IS_WRITE_REQUEST(irpStack)                                             \
 (irpStack->MajorFunction == IRP_MJ_WRITE)
 
#define IS_READ_WRITE_REQUEST(irpStack)                                        \
((irpStack->MajorFunction == IRP_MJ_READ)  ||                                  \
 (irpStack->MajorFunction == IRP_MJ_WRITE) ||                                  \
 ((irpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL) &&                        \
  (irpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_CDROM_RAW_READ)))




NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the cdrom class driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the name of the services node for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    CLASS_INIT_DATA InitializationData;
    PCDROM_DRIVER_EXTENSION driverExtension;
    NTSTATUS status;
    
    PAGED_CODE();
    
    WPP_INIT_TRACING(DriverObject, RegistryPath);

    TraceLog((CdromDebugTrace,
                "CDROM.SYS DriverObject %p loading\n", DriverObject));
    
    status = IoAllocateDriverObjectExtension(DriverObject,
                                             CDROM_DRIVER_EXTENSION_ID,
                                             sizeof(CDROM_DRIVER_EXTENSION),
                                             &driverExtension);    

    if (!NT_SUCCESS(status)) {
        TraceLog((CdromDebugWarning,
                    "DriverEntry !! no DriverObjectExtension %x\n", status));
        return status;
    }

    //
    // always zero the memory, since we are now reloading the driver.
    //

    RtlZeroMemory(driverExtension, sizeof(CDROM_DRIVER_EXTENSION));

    //
    // Zero InitData
    //

    RtlZeroMemory (&InitializationData, sizeof(CLASS_INIT_DATA));

    //
    // Set sizes
    //

    InitializationData.InitializationDataSize = sizeof(CLASS_INIT_DATA);

    InitializationData.FdoData.DeviceExtensionSize = DEVICE_EXTENSION_SIZE;

    InitializationData.FdoData.DeviceType = FILE_DEVICE_CD_ROM;
    InitializationData.FdoData.DeviceCharacteristics =
        FILE_REMOVABLE_MEDIA | FILE_DEVICE_SECURE_OPEN;

    //
    // Set entry points
    //

    InitializationData.FdoData.ClassError = CdRomErrorHandler;
    InitializationData.FdoData.ClassInitDevice = CdRomInitDevice;
    InitializationData.FdoData.ClassStartDevice = CdRomStartDevice;
    InitializationData.FdoData.ClassStopDevice = CdRomStopDevice;
    InitializationData.FdoData.ClassRemoveDevice = CdRomRemoveDevice;

    InitializationData.FdoData.ClassReadWriteVerification = CdRomReadWriteVerification;
    InitializationData.FdoData.ClassDeviceControl = CdRomDeviceControlDispatch;

    InitializationData.FdoData.ClassPowerDevice = ClassSpinDownPowerHandler;
    InitializationData.FdoData.ClassShutdownFlush = CdRomShutdownFlush;
    InitializationData.FdoData.ClassCreateClose = NULL;

    InitializationData.ClassStartIo = CdRomStartIo;
    InitializationData.ClassAddDevice = CdRomAddDevice;

    InitializationData.ClassTick = CdRomTickHandler;
    InitializationData.ClassUnload = CdRomUnload;

    //
    // Call the class init routine
    //

    return ClassInitialize( DriverObject, RegistryPath, &InitializationData);

} // end DriverEntry()


VOID
CdRomUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    PAGED_CODE();
    UNREFERENCED_PARAMETER(DriverObject);
    TraceLog((CdromDebugTrace,
                "CDROM.SYS DriverObject %p unloading\n", DriverObject));
    WPP_CLEANUP(DriverObject);
    return;
} // end CdRomUnload()


NTSTATUS
CdRomAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates and initializes a new FDO for the corresponding
    PDO.  It may perform property queries on the FDO but cannot do any
    media access operations.

Arguments:

    DriverObject - CDROM class driver object.

    Pdo - the physical device object we are being added to

Return Value:

    status

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    //
    // Get the address of the count of the number of cdroms already initialized.
    //

    status = CdRomCreateDeviceObject(DriverObject,
                                     PhysicalDeviceObject);

    //
    // Note: this always increments driver extension counter
    //       it will eventually wrap, and fail additions
    //       if an existing cdrom has the given number.
    //       so unlikely that we won't even bother considering
    //       this case, since the cure is quite likely worse
    //       than the symptoms.
    //

    if(NT_SUCCESS(status)) {

        //
        // keep track of the total number of active cdroms in IoGet(),
        // as some programs use this to determine when they have found
        // all the cdroms in the system.
        //

        TraceLog((CdromDebugTrace, "CDROM.SYS Add succeeded\n"));
        IoGetConfigurationInformation()->CdRomCount++;

    } else {

        TraceLog((CdromDebugWarning,
                    "CDROM.SYS Add failed! %x\n", status));

    }

    return status;
}


NTSTATUS
CdRomCreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates an object for the device and then calls the
    SCSI port driver for media capacity and sector size.

Arguments:

    DriverObject - Pointer to driver object created by system.
    PortDeviceObject - to connect to SCSI port driver.
    DeviceCount - Number of previously installed CDROMs.
    PortCapabilities - Pointer to structure returned by SCSI port
        driver describing adapter capabilites (and limitations).
    LunInfo - Pointer to configuration information for this device.

Return Value:

    NTSTATUS

--*/
{
    UCHAR ntNameBuffer[64];
    STRING ntNameString;
    NTSTATUS status;

    PDEVICE_OBJECT lowerDevice = NULL;
    PDEVICE_OBJECT deviceObject = NULL;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = NULL;
    PCDROM_DATA cdData = NULL;
    PCDROM_DRIVER_EXTENSION driverExtension = NULL;
    ULONG deviceNumber;

    CCHAR                   dosNameBuffer[64];
    CCHAR                   deviceNameBuffer[64];
    STRING                  deviceNameString;
    STRING                  dosString;
    UNICODE_STRING          dosUnicodeString;
    UNICODE_STRING          unicodeString;

    PAGED_CODE();

    //
    // Claim the device. Note that any errors after this
    // will goto the generic handler, where the device will
    // be released.
    //

    lowerDevice = IoGetAttachedDeviceReference(PhysicalDeviceObject);

    status = ClassClaimDevice(lowerDevice, FALSE);

    if(!NT_SUCCESS(status)) {

        //
        // Someone already had this device - we're in trouble
        //

        ObDereferenceObject(lowerDevice);
        return status;
    }

    //
    // Create device object for this device by first getting a unique name
    // for the device and then creating it.
    //

    driverExtension = IoGetDriverObjectExtension(DriverObject,
                                                 CDROM_DRIVER_EXTENSION_ID);
    ASSERT(driverExtension != NULL);

    //
    // InterlockedCdRomCounter is biased by 1.
    //

    deviceNumber = InterlockedIncrement(&driverExtension->InterlockedCdRomCounter) - 1;
    sprintf(ntNameBuffer, "\\Device\\CdRom%d", deviceNumber);


    status = ClassCreateDeviceObject(DriverObject,
                                     ntNameBuffer,
                                     PhysicalDeviceObject,
                                     TRUE,
                                     &deviceObject);

    if (!NT_SUCCESS(status)) {
        TraceLog((CdromDebugWarning,
                    "CreateCdRomDeviceObjects: Can not create device %s\n",
                    ntNameBuffer));

        goto CreateCdRomDeviceObjectExit;
    }

    //
    // Indicate that IRPs should include MDLs.
    //

    SET_FLAG(deviceObject->Flags, DO_DIRECT_IO);

    fdoExtension = deviceObject->DeviceExtension;

    //
    // Back pointer to device object.
    //

    fdoExtension->CommonExtension.DeviceObject = deviceObject;

    //
    // This is the physical device.
    //

    fdoExtension->CommonExtension.PartitionZeroExtension = fdoExtension;

    //
    // Initialize lock count to zero. The lock count is used to
    // disable the ejection mechanism when media is mounted.
    //

    fdoExtension->LockCount = 0;

    //
    // Save system cdrom number
    //

    fdoExtension->DeviceNumber = deviceNumber;

    //
    // Set the alignment requirements for the device based on the
    // host adapter requirements
    //

    if (lowerDevice->AlignmentRequirement > deviceObject->AlignmentRequirement) {
        deviceObject->AlignmentRequirement = lowerDevice->AlignmentRequirement;
    }

    //
    // Save the device descriptors
    //

    fdoExtension->AdapterDescriptor = NULL;

    fdoExtension->DeviceDescriptor = NULL;

    //
    // Clear the SrbFlags and disable synchronous transfers
    //

    fdoExtension->SrbFlags = SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Finally, attach to the PDO
    //

    fdoExtension->LowerPdo = PhysicalDeviceObject;

    fdoExtension->CommonExtension.LowerDeviceObject =
        IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

    if(fdoExtension->CommonExtension.LowerDeviceObject == NULL) {

        //
        // Uh - oh, we couldn't attach
        // cleanup and return
        //

        status = STATUS_UNSUCCESSFUL;
        goto CreateCdRomDeviceObjectExit;
    }

    //
    // CdRom uses an extra stack location for synchronizing it's start io
    // routine
    //

    deviceObject->StackSize++;

    //
    // cdData is used a few times below
    //

    cdData = fdoExtension->CommonExtension.DriverData;

    //
    // For NTMS to be able to easily determine drives-drv. letter matches.
    //

    status = CdRomCreateWellKnownName( deviceObject );

    if (!NT_SUCCESS(status)) {
        TraceLog((CdromDebugWarning,
                    "CdromCreateDeviceObjects: unable to create symbolic "
                    "link for device %wZ\n", &fdoExtension->CommonExtension.DeviceName));
        TraceLog((CdromDebugWarning,
                    "CdromCreateDeviceObjects: (non-fatal error)\n"));
    }

    ClassUpdateInformationInRegistry(deviceObject, "CdRom",
                                     fdoExtension->DeviceNumber, NULL, 0);

    //
    // from above IoGetAttachedDeviceReference
    //

    ObDereferenceObject(lowerDevice);

    //
    // need to init timerlist here in case a remove occurs
    // without a start, since we check the list is empty on remove.
    //

    cdData->DelayedRetryIrp = NULL;
    cdData->DelayedRetryInterval = 0;

    //
    // need this to be initialized for RPC Phase 1 drives (rpc0)
    //

    KeInitializeMutex(&cdData->Rpc0RegionMutex, 0);
    
    //
    // The device is initialized properly - mark it as such.
    //

    CLEAR_FLAG(deviceObject->Flags, DO_DEVICE_INITIALIZING);

    return(STATUS_SUCCESS);

CreateCdRomDeviceObjectExit:

    //
    // Release the device since an error occured.
    //

    // ClassClaimDevice(PortDeviceObject,
    //                      LunInfo,
    //                      TRUE,
    //                      NULL);

    //
    // from above IoGetAttachedDeviceReference
    //

    ObDereferenceObject(lowerDevice);

    if (deviceObject != NULL) {
        IoDeleteDevice(deviceObject);
    }

    return status;

} // end CreateCdRomDeviceObject()


NTSTATUS
CdRomInitDevice(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine will complete the cd-rom initialization.  This includes
    allocating sense info buffers and srb s-lists, reading drive capacity
    and setting up Media Change Notification (autorun).

    This routine will not clean up allocate resources if it fails - that
    is left for device stop/removal

Arguments:

    Fdo - a pointer to the functional device object for this device

Return Value:

    status

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PCLASS_DRIVER_EXTENSION driverExtension = ClassGetDriverExtension(
                                                Fdo->DriverObject);

    PVOID senseData = NULL;

    ULONG timeOut;
    PCDROM_DATA cddata;

    BOOLEAN changerDevice;
    BOOLEAN isMmcDevice = FALSE;

    ULONG bps;
    ULONG lastBit;


    NTSTATUS status;

    PAGED_CODE();

    //
    // Build the lookaside list for srb's for the physical disk.  Should only
    // need a couple.
    //

    ClassInitializeSrbLookasideList(&(fdoExtension->CommonExtension),
                                    CDROM_SRB_LIST_SIZE);

    //
    // Allocate request sense buffer.
    //

    senseData = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                      SENSE_BUFFER_SIZE,
                                      CDROM_TAG_SENSE_INFO);

    if (senseData == NULL) {

        //
        // The buffer cannot be allocated.
        //

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto CdRomInitDeviceExit;
    }

    //
    // Set the sense data pointer in the device extension.
    //

    fdoExtension->SenseData = senseData;

    //
    // CDROMs are not partitionable so starting offset is 0.
    //

    commonExtension->StartingOffset.LowPart = 0;
    commonExtension->StartingOffset.HighPart = 0;

    //
    // Set timeout value in seconds.
    //

    timeOut = ClassQueryTimeOutRegistryValue(Fdo);
    if (timeOut) {
        fdoExtension->TimeOutValue = timeOut;
    } else {
        fdoExtension->TimeOutValue = SCSI_CDROM_TIMEOUT;
    }

    cddata = (PCDROM_DATA)(commonExtension->DriverData);

    //
    // Set up media change support defaults.
    //

    KeInitializeSpinLock(&cddata->DelayedRetrySpinLock);

    cddata->DelayedRetryIrp = NULL;
    cddata->DelayedRetryInterval = 0;
    cddata->Mmc.WriteAllowed = FALSE;

    //
    // Scan for  controllers that require special processing.
    //

    ScanForSpecial(Fdo);

    //
    // Determine if the drive is MMC-Capable
    //

    CdRomIsDeviceMmcDevice(Fdo, &isMmcDevice);

    if (!isMmcDevice) {

        SET_FLAG(Fdo->Characteristics, FILE_READ_ONLY_DEVICE);
    
    } else {
        
        //
        // the drive supports at least a subset of MMC commands
        // (and therefore supports READ_CD, etc...)
        //

        cddata->Mmc.IsMmc = TRUE;
        
        //
        // allocate a buffer for all the capabilities and such
        //

        status = CdRomAllocateMmcResources(Fdo);
        if (!NT_SUCCESS(status)) {
            goto CdRomInitDeviceExit;
        }
        

#if 0
        //
        // determine all the various media types from the profiles feature
        //
        {
            PFEATURE_DATA_PROFILE_LIST profileHeader;
            ULONG mediaTypes = 0;
            ULONG i;

            KdPrintEx((DPFLTR_CDROM_ID, CdromDebugError,
                       "Checking all profiles for media types supported.\n"
                       ));

            profileHeader = CdRomFindFeaturePage(cddata->Mmc.CapabilitiesBuffer,
                                                 cddata->Mmc.CapabilitiesBufferSize,
                                                 FeatureProfileList);
            if (profileHeader == NULL) {

                //
                // if profiles don't exist, there is something seriously
                // wrong with this command -- it's either not a cdrom or
                // one that hasn't implemented the spec correctly.  exit
                // now while we have the chance to do so safely.
                //
                KdPrintEx((DPFLTR_CDROM_ID, CdromDebugError,
                           "CdromDevice supports GET_CONFIGURATION, but "
                           "doesn't provide profiles for PDO %p!\n",
                           fdoExtension->LowerPdo));
                status = STATUS_DEVICE_CONFIGURATION_ERROR;
                goto CdRomInitDeviceExit;

            }

            for (i = 0; i < MAX_CDROM_MEDIA_TYPES; i++) {
                
                BOOLEAN profileFound;
                CdRomFindProfileInProfiles(profileHeader,
                                           MediaProfileMatch[i].Profile,
                                           &profileFound);
                if (profileFound) {
                    
                    KdPrintEx((DPFLTR_CDROM_ID, CdromDebugError,
                               "CdromInit -> Found Profile %x => Media %x "
                               "(%x total)\n",
                               MediaProfileMatch[i].Profile,
                               MediaProfileMatch[i].Media,
                               mediaTypes + 1
                               ));
                    
                    cddata->Mmc.MediaProfileMatches[mediaTypes] =
                        MediaProfileMatch[i];
                    mediaTypes++;
                
                }

            }

            if (mediaTypes == 0) {

                //
                // if profiles don't exist, there is something seriously
                // wrong with this command -- it's either not a cdrom or
                // one that hasn't implemented the spec correctly.  exit
                // now while we have the chance to do so safely.
                //
                KdPrintEx((DPFLTR_CDROM_ID, CdromDebugError,
                           "CdromDevice supports GET_CONFIGURATION, but "
                           "doesn't support any of the standard profiles "
                           "for PDO %p!\n", fdoExtension->LowerPdo));
                status = STATUS_DEVICE_CONFIGURATION_ERROR;
                goto CdRomInitDeviceExit;
            
            }

            cddata->Mmc.MediaTypes = mediaTypes;


        }
#endif // media checks, and all failure paths due to bad firmware.

        //
        // if the drive supports target defect management and sector-addressable
        // writes, then we should allow writes to the media.
        //

        if (CdRomFindFeaturePage(cddata->Mmc.CapabilitiesBuffer,
                                 cddata->Mmc.CapabilitiesBufferSize,
                                 FeatureDefectManagement) &&
            CdRomFindFeaturePage(cddata->Mmc.CapabilitiesBuffer,
                                 cddata->Mmc.CapabilitiesBufferSize,
                                 FeatureRandomWritable)) {

            //
            // the drive is target defect managed, and supports random writes
            // on sector-aligment.  allow writes to occur by setting the error
            // handler to point to a private media change detection handler.
            //

            KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                       "Found a WRITE capable device: %p\n", Fdo));
            
            //
            // the write specific pages have been found -- 
            // set the error handler and set it to require an update!
            //

            cddata->Mmc.UpdateState = CdromMmcUpdateRequired;
            cddata->ErrorHandler = CdRomMmcErrorHandler;

        }

        //
        // ISSUE-2000/4/4-henrygab - mmc-compliant compliant drives should
        //                           be initialized based upon reported
        //                           capabilities, such as CSS, Analogue Audio,
        //                           READ_CD capabilities, and (possibly) even
        //                           drive capacity information.
        //
        
        TraceLog((CdromDebugWarning,
                  "Defaulting to READ_CD because device %p is MMC compliant\n",
                  Fdo));
        SET_FLAG(fdoExtension->DeviceFlags, DEV_SAFE_START_UNIT);
        SET_FLAG(cddata->XAFlags, XA_USE_READ_CD);

    }


    //
    // Set the default geometry for the cdrom to match what NT 4 used.
    // Classpnp will use these values to compute the cylinder count rather
    // than using it's NT 5.0 defaults.
    //

    fdoExtension->DiskGeometry.TracksPerCylinder = 0x40;
    fdoExtension->DiskGeometry.SectorsPerTrack = 0x20;

    //
    // Do READ CAPACITY. This SCSI command returns the last sector address
    // on the device and the bytes per sector. These are used to calculate
    // the drive capacity in bytes.
    //
    // NOTE: This should be change to send the Srb synchronously, then
    // call CdRomInterpretReadCapacity() to properly setup the defaults.
    //

    status = ClassReadDriveCapacity(Fdo);

    bps = fdoExtension->DiskGeometry.BytesPerSector;

    if (!NT_SUCCESS(status) || !bps) {

        TraceLog((CdromDebugWarning,
                    "CdRomStartDevice: Can't read capacity for device %wZ\n",
                    &(fdoExtension->CommonExtension.DeviceName)));

        //
        // Set disk geometry to default values (per ISO 9660).
        //

        bps = 2048;
        fdoExtension->SectorShift = 11;
        commonExtension->PartitionLength.QuadPart = (LONGLONG)(0x7fffffff);

    } else {

        //
        // Insure that bytes per sector is a power of 2
        // This corrects a problem with the HP 4020i CDR where it
        // returns an incorrect number for bytes per sector.
        //

        lastBit = (ULONG) -1;
        while (bps) {
            lastBit++;
            bps = bps >> 1;
        }

        bps = 1 << lastBit;
    }
    fdoExtension->DiskGeometry.BytesPerSector = bps;
    TraceLog((CdromDebugTrace, "CdRomInitDevice: Calc'd bps = %x\n", bps));


    ClassInitializeMediaChangeDetection(fdoExtension, "CdRom");


    //
    // test for audio read capabilities
    //

    TraceLog((CdromDebugWarning,
              "Detecting XA_READ capabilities\n"));

    if (CdRomGetDeviceType(Fdo) == FILE_DEVICE_DVD) {

        TraceLog((CdromDebugWarning,
                    "CdRomInitDevice: DVD Devices require START_UNIT\n"));


        //
        // all DVD devices must support the READ_CD command
        //

        TraceLog((CdromDebugWarning,
                    "CdRomDetermineRawReadCapabilities: DVD devices "
                    "support READ_CD command for FDO %p\n", Fdo));
        SET_FLAG(fdoExtension->DeviceFlags, DEV_SAFE_START_UNIT);
        SET_FLAG(cddata->XAFlags, XA_USE_READ_CD);


        status = STATUS_SUCCESS;

    } else if ((fdoExtension->DeviceDescriptor->BusType != BusTypeScsi)  &&
               (fdoExtension->DeviceDescriptor->BusType != BusTypeAta)   &&
               (fdoExtension->DeviceDescriptor->BusType != BusTypeAtapi) &&
               (fdoExtension->DeviceDescriptor->BusType != BusTypeUnknown)
               ) {

        //
        // devices on the newer busses must support READ_CD command
        //

        TraceLog((CdromDebugWarning,
                  "CdRomDetermineRawReadCapabilities: Devices for newer "
                  "busses must support READ_CD command for FDO %p, Bus %x\n",
                  Fdo, fdoExtension->DeviceDescriptor->BusType));
        SET_FLAG(fdoExtension->DeviceFlags, DEV_SAFE_START_UNIT);
        SET_FLAG(cddata->XAFlags, XA_USE_READ_CD);

    }

    //
    // now clear all our READ_CD flags if the drive should have supported
    // it, but we are not sure it actually does.  we still won't query
    // the drive more than one time if it supports the command.
    //

    if (TEST_FLAG(cddata->HackFlags, CDROM_HACK_FORCE_READ_CD_DETECTION)) {

        TraceLog((CdromDebugWarning,
                  "Forcing detection of READ_CD for FDO %p because "
                  "testing showed some firmware did not properly support it\n",
                  Fdo));
        CLEAR_FLAG(cddata->XAFlags, XA_USE_READ_CD);

    }


    //
    // read our READ_CD support in the registry if it was seeded.
    //
    {
        ULONG readCdSupported = 0;
        
        ClassGetDeviceParameter(fdoExtension,
                                CDROM_SUBKEY_NAME,
                                CDROM_READ_CD_NAME,
                                &readCdSupported
                                );
        
        if (readCdSupported != 0) {
            
            TraceLog((CdromDebugWarning,
                      "Defaulting to READ_CD because previously detected "
                      "that the device supports it for Fdo %p.\n",
                      Fdo
                      ));
            SET_FLAG(cddata->XAFlags, XA_USE_READ_CD);

        }

    }


    //
    // backwards-compatible hackish attempt to determine if the drive
    // supports any method of reading digital audio from the disc.
    //

    if (!TEST_FLAG(cddata->XAFlags, XA_USE_READ_CD)) {

        SCSI_REQUEST_BLOCK srb;
        PCDB cdb;
        ULONG length;
        PUCHAR buffer = NULL;
        ULONG count;

        //
        // ISSUE-2000/07/05-henrygab - use the mode page to determine
        //          READ_CD support, then fall back on the below
        //          (unreliable?) hack.
        //

        //
        // Build the MODE SENSE CDB. The data returned will be kept in the
        // device extension and used to set block size.
        //

        length = max(sizeof(ERROR_RECOVERY_DATA),sizeof(ERROR_RECOVERY_DATA10));

        buffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                       length,
                                       CDROM_TAG_MODE_DATA);

        if (!buffer) {
            TraceLog((CdromDebugWarning,
                        "CdRomDetermineRawReadCapabilities: cannot allocate "
                        "buffer, so leaving for FDO %p\n", Fdo));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto CdRomInitDeviceExit;
        }

        for (count = 0; count < 2; count++) {

            if (count == 0) {
                length = sizeof(ERROR_RECOVERY_DATA);
            } else {
                length = sizeof(ERROR_RECOVERY_DATA10);
            }

            RtlZeroMemory(buffer, length);
            RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));
            cdb = (PCDB)srb.Cdb;

            srb.TimeOutValue = fdoExtension->TimeOutValue;

            if (count == 0) {
                srb.CdbLength = 6;
                cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
                cdb->MODE_SENSE.PageCode = 0x1;
                // note: not setting DBD in order to get the block descriptor!
                cdb->MODE_SENSE.AllocationLength = (UCHAR)length;
            } else {
                srb.CdbLength = 10;
                cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
                cdb->MODE_SENSE10.PageCode = 0x1;
                // note: not setting DBD in order to get the block descriptor!
                cdb->MODE_SENSE10.AllocationLength[0] = (UCHAR)(length >> 8);
                cdb->MODE_SENSE10.AllocationLength[1] = (UCHAR)(length & 0xFF);
            }

            status = ClassSendSrbSynchronous(Fdo,
                                             &srb,
                                             buffer,
                                             length,
                                             FALSE);


            if (NT_SUCCESS(status) || (status == STATUS_DATA_OVERRUN)) {

                //
                // STATUS_DATA_OVERRUN means it's a newer drive with more info
                // to tell us, so it's probably able to support READ_CD
                //

                RtlZeroMemory(cdb, CDB12GENERIC_LENGTH);

                srb.CdbLength = 12;
                cdb->READ_CD.OperationCode = SCSIOP_READ_CD;

                status = ClassSendSrbSynchronous(Fdo,
                                                 &srb,
                                                 NULL,
                                                 0,
                                                 FALSE);

                if (NT_SUCCESS(status) ||
                    (status == STATUS_NO_MEDIA_IN_DEVICE) ||
                    (status == STATUS_NONEXISTENT_SECTOR) ||
                    (status == STATUS_UNRECOGNIZED_MEDIA)
                    ) {

                    //
                    // READ_CD works
                    //

                    TraceLog((CdromDebugWarning,
                              "CdRomDetermineRawReadCapabilities: Using "
                              "READ_CD for FDO %p due to status %x\n",
                              Fdo,
                              status));
                    SET_FLAG(cddata->XAFlags, XA_USE_READ_CD);
                    
                    //
                    // ignore errors in saving this info
                    //
                    
                    ClassSetDeviceParameter(fdoExtension,
                                            CDROM_SUBKEY_NAME,
                                            CDROM_READ_CD_NAME,
                                            1
                                            );
                                            

                    break; // out of the for loop

                }

                TraceLog((CdromDebugWarning,
                            "CdRomDetermineRawReadCapabilities: Using "
                            "%s-byte mode switching for FDO %p due to status "
                            "%x returned for READ_CD\n",
                            ((count == 0) ? "6" : "10"), Fdo, status));

                if (count == 0) {
                    SET_FLAG(cddata->XAFlags, XA_USE_6_BYTE);
                    RtlCopyMemory(&cddata->Header,
                                  buffer,
                                  sizeof(ERROR_RECOVERY_DATA));
                    cddata->Header.ModeDataLength = 0;
                } else {
                    SET_FLAG(cddata->XAFlags, XA_USE_10_BYTE);
                    RtlCopyMemory(&cddata->Header10,
                                  buffer,
                                  sizeof(ERROR_RECOVERY_DATA10));
                    cddata->Header10.ModeDataLength[0] = 0;
                    cddata->Header10.ModeDataLength[1] = 0;
                }
                break;  // out of for loop

            }
            TraceLog((CdromDebugWarning,
                      "FDO %p failed %x byte mode sense, status %x\n",
                      Fdo,
                      ((count == 0) ? 6 : 10),
                      status
                      ));

            //
            // mode sense failed
            //

        } // end of for loop to try 6 and 10-byte mode sense

        if (count == 2) {

            //
            // nothing worked.  we probably cannot support digital
            // audio extraction from this drive
            //

            TraceLog((CdromDebugWarning,
                        "CdRomDetermineRawReadCapabilities: FDO %p "
                        "cannot support READ_CD\n", Fdo));
            CLEAR_FLAG(cddata->XAFlags, XA_PLEXTOR_CDDA);
            CLEAR_FLAG(cddata->XAFlags, XA_NEC_CDDA);
            SET_FLAG(cddata->XAFlags, XA_NOT_SUPPORTED);

        } // end of count == 2

        //
        // free our resources
        //

        ExFreePool(buffer);

        //
        // set a successful status
        // (in case someone later checks this)
        //

        status = STATUS_SUCCESS;

    }

    //
    // Register interfaces for this device.
    //

    {
        UNICODE_STRING interfaceName;

        RtlInitUnicodeString(&interfaceName, NULL);

        status = IoRegisterDeviceInterface(fdoExtension->LowerPdo,
                                           (LPGUID) &CdRomClassGuid,
                                           NULL,
                                           &interfaceName);

        if(NT_SUCCESS(status)) {

            cddata->CdromInterfaceString = interfaceName;

            status = IoSetDeviceInterfaceState(
                        &interfaceName,
                        TRUE);

            if(!NT_SUCCESS(status)) {

                TraceLog((CdromDebugWarning,
                            "CdromInitDevice: Unable to register cdrom "
                            "DCA for fdo %p [%lx]\n",
                            Fdo, status));
            }
        }
    }

    return(STATUS_SUCCESS);

CdRomInitDeviceExit:

    CdRomDeAllocateMmcResources(Fdo);    
    RtlZeroMemory(&(cddata->Mmc), sizeof(CDROM_MMC_EXTENSION));
    
    return status;

}


NTSTATUS
CdRomStartDevice(
    IN PDEVICE_OBJECT Fdo
    )
/*++

Routine Description:

    This routine starts the timer for the cdrom

Arguments:

    Fdo - a pointer to the functional device object for this device

Return Value:

    status

--*/

{
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PCDROM_DATA cddata = (PCDROM_DATA)(commonExtension->DriverData);
    PDVD_COPY_PROTECT_KEY copyProtectKey;
    PDVD_RPC_KEY rpcKey;
    IO_STATUS_BLOCK ioStatus;
    ULONG bufferLen;

    // CdRomCreateWellKnownName(Fdo);

    //
    // if we have a DVD-ROM
    //    if we have a rpc0 device
    //        fake a rpc2 device
    //    if device does not have a dvd region set
    //        select a dvd region for the user
    //
    
    cddata->DvdRpc0Device = FALSE;

    //
    // since StartIo() will call IoStartNextPacket() on error, allowing
    // StartIo() to be non-recursive prevents stack overflow bugchecks in
    // severe error cases (such as fault-injection in the verifier).
    //
    // the only difference is that the thread context may be different
    // in StartIo() than in the caller of IoStartNextPacket().
    //

    IoSetStartIoAttributes(Fdo, TRUE, TRUE);

    //
    // check to see if we have a DVD device
    //

    if (CdRomGetDeviceType(Fdo) != FILE_DEVICE_DVD) {
        return STATUS_SUCCESS;
    }

    //
    // we got a DVD drive.
    // now, figure out if we have a RPC0 device
    //

    bufferLen = DVD_RPC_KEY_LENGTH;
    copyProtectKey =
        (PDVD_COPY_PROTECT_KEY)ExAllocatePoolWithTag(PagedPool,
                                                     bufferLen,
                                                     DVD_TAG_RPC2_CHECK);

    if (copyProtectKey == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // get the device region
    //
    RtlZeroMemory (copyProtectKey, bufferLen);
    copyProtectKey->KeyLength = DVD_RPC_KEY_LENGTH;
    copyProtectKey->KeyType = DvdGetRpcKey;

    //
    // Build a request for READ_KEY
    //
    ClassSendDeviceIoControlSynchronous(
        IOCTL_DVD_READ_KEY,
        Fdo,
        copyProtectKey,
        DVD_RPC_KEY_LENGTH,
        DVD_RPC_KEY_LENGTH,
        FALSE,
        &ioStatus
        );

    if (!NT_SUCCESS(ioStatus.Status)) {

        //
        // we have a rpc0 device
        //
        // NOTE: THIS MODIFIES THE BEHAVIOR OF THE IOCTL
        //

        cddata->DvdRpc0Device = TRUE;

        TraceLog((CdromDebugWarning,
                    "CdromStartDevice (%p): RPC Phase 1 drive detected\n",
                    Fdo));

        //
        // note: we could force this chosen now, but it's better to reduce
        // the number of code paths that could be taken.  always delay to
        // increase the percentage code coverage.
        //

        TraceLog((CdromDebugWarning,
                  "CdromStartDevice (%p): Delay DVD Region Selection\n",
                  Fdo));

        cddata->Rpc0SystemRegion           = 0xff;
        cddata->Rpc0SystemRegionResetCount = DVD_MAX_REGION_RESET_COUNT;
        cddata->PickDvdRegion              = 1;
        cddata->Rpc0RetryRegistryCallback  = 1;
        ExFreePool(copyProtectKey);
        return STATUS_SUCCESS;

    } else {

        rpcKey = (PDVD_RPC_KEY) copyProtectKey->KeyData;

        //
        // TypeCode of zero means that no region has been set.
        //

        if (rpcKey->TypeCode == 0) {
            TraceLog((CdromDebugWarning,
                        "CdromStartDevice (%p): must choose DVD region\n",
                        Fdo));
            cddata->PickDvdRegion = 1;
            CdRomPickDvdRegion(Fdo);
        }
    }

    ExFreePool (copyProtectKey);

    return STATUS_SUCCESS;
}


NTSTATUS
CdRomStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )
{
    return STATUS_SUCCESS;
}


VOID
CdRomStartIo(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    )
{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;

    PIO_STACK_LOCATION  currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION  nextIrpStack = IoGetNextIrpStackLocation(Irp);
    PIO_STACK_LOCATION  irpStack;

    PIRP                irp2 = NULL;

    ULONG               transferPages;
    ULONG               transferByteCount = currentIrpStack->Parameters.Read.Length;
    LARGE_INTEGER       startingOffset = currentIrpStack->Parameters.Read.ByteOffset;
    PCDROM_DATA         cdData;
    PSCSI_REQUEST_BLOCK srb = NULL;
    PCDB                cdb;
    PUCHAR              senseBuffer = NULL;
    PVOID               dataBuffer;
    NTSTATUS            status;
    BOOLEAN             use6Byte;
    KIRQL oldIrql;

    //
    // Mark IRP with status pending.
    //

    IoMarkIrpPending(Irp);

    cdData = (PCDROM_DATA)(fdoExtension->CommonExtension.DriverData);
    use6Byte = TEST_FLAG(cdData->XAFlags, XA_USE_6_BYTE);

    //
    // if this test is true, then we will exit the routine within this
    // code block, queueing the irp for later completion.
    //

    if ((cdData->Mmc.IsMmc) &&
        (cdData->Mmc.UpdateState != CdromMmcUpdateComplete)
        ) {

        ULONG queueDepth;
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdRomStartIo: [%p] Device needs to update capabilities\n",
                   Irp));
        ASSERT(cdData->Mmc.IsMmc);
        ASSERT(cdData->Mmc.CapabilitiesIrp != NULL);
        ASSERT(cdData->Mmc.CapabilitiesIrp != Irp);

        //
        // NOTE - REF #0002
        //
        // the state was either UpdateRequired (which means we will
        // have to start the work item) or UpdateStarted (which means
        // we have already started the work item at least once -- may
        // transparently change to UpdateComplete).
        //
        // if it's update required, we just queue it, change to UpdateStarted,
        // start the workitem, and start the next packet.
        //
        // else, we must queue the item and check the queue depth.  if the
        // queue depth is equal to 1, that means the worker item from the
        // previous attempt has already de-queued the items, so we should
        // call this routine again (retry) as an optimization rather than
        // re-add it this irp to the queue.  since this is tail recursion,
        // it won't take much/any stack to do this.
        //
        // NOTE: This presumes the following items are true:
        //
        // we only add to the list from CdRomStartIo(), which is serialized.
        // we only set to UpdateStarted from CdRomStartIo(), and only if
        //    the state was UpdateRequired.
        // we only set to UpdateRequired from CdRomMmcErrorHandler(), and
        //    only if the state was UpdateComplete.
        // we only set to UpdateComplete from the workitem, and assert the
        //    state was UpdateStarted.
        // we flush the entire queue in one atomic operation in the workitem,
        //    except in the special case described above when we dequeue
        //    the request immediately.
        //
        // order of operations is vitally important: queue, then test the depth
        // this will prevent lost irps.
        //

        KeAcquireSpinLock(&cdData->Mmc.DelayedIrpsLock, &oldIrql);
        InsertTailList(&cdData->Mmc.DelayedIrpsList, &Irp->Tail.Overlay.ListEntry);
        queueDepth = ++cdData->Mmc.NumDelayedIrps;
        KeReleaseSpinLock(&cdData->Mmc.DelayedIrpsLock, oldIrql);
        
        if (queueDepth == 1) {

            if (cdData->Mmc.UpdateState == CdromMmcUpdateRequired) {
                LONG oldState;
                
                //
                // should free any old partition list info that
                // we've previously saved away and then start the WorkItem
                //

                oldState = InterlockedExchange(&cdData->Mmc.UpdateState,
                                               CdromMmcUpdateStarted);
                ASSERT(oldState == CdromMmcUpdateRequired);

                IoQueueWorkItem(cdData->Mmc.CapabilitiesWorkItem,
                                CdRomUpdateMmcDriveCapabilities,
                                DelayedWorkQueue,
                                NULL);

            } else {
                
                //
                // they *just* finished updating, so we should flush the list
                // back onto the StartIo queue and start the next packet.
                //

                CdRompFlushDelayedList(Fdo, &(cdData->Mmc), STATUS_SUCCESS, FALSE);

            }

        }
            
        //
        // start the next packet so we don't deadlock....
        //

        IoStartNextPacket(Fdo, FALSE);
        return;
    
    }

    //
    // If the flag is set in the device object
    // force a verify for READ, WRITE and RAW_READ requests
    // Note that ioctls are passed through....
    //

    if (TEST_FLAG(Fdo->Flags, DO_VERIFY_VOLUME) &&
        IS_READ_WRITE_REQUEST(currentIrpStack)) {
        
        TraceLog((CdromDebugTrace,
                    "CdRomStartIo: [%p] Volume needs verified\n", Irp));
        
        if (!(currentIrpStack->Flags & SL_OVERRIDE_VERIFY_VOLUME)) {

            if (Irp->Tail.Overlay.Thread) {
                IoSetHardErrorOrVerifyDevice(Irp, Fdo);
            }

            Irp->IoStatus.Status = STATUS_VERIFY_REQUIRED;

            TraceLog((CdromDebugTrace,
                        "CdRomStartIo: [%p] Calling UpdateCapcity - "
                        "ioctl event = %p\n",
                        Irp,
                        nextIrpStack->Parameters.Others.Argument1
                      ));

            //
            // our device control dispatch routine stores an event in the next
            // stack location to signal when startio has completed.  We need to
            // pass this in so that the update capacity completion routine can
            // set it rather than completing the Irp.
            //

            status = CdRomUpdateCapacity(fdoExtension,
                                         Irp,
                                         nextIrpStack->Parameters.Others.Argument1
                                         );

            TraceLog((CdromDebugTrace,
                        "CdRomStartIo: [%p] UpdateCapacity returned %lx\n",
                        Irp, status));
            return;
        }
    }

    //
    // fail writes if they are not allowed...
    //

    if ((currentIrpStack->MajorFunction == IRP_MJ_WRITE) &&
        !(cdData->Mmc.WriteAllowed)) {

        TraceLog((CdromDebugError,
                    "CdRomStartIo: [%p] Device %p failing write request\n",
                    Irp, Fdo));

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        BAIL_OUT(Irp);
        CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
        return;
    }

    if (currentIrpStack->MajorFunction == IRP_MJ_READ ||
        currentIrpStack->MajorFunction == IRP_MJ_WRITE ) {

        ULONG maximumTransferLength = fdoExtension->AdapterDescriptor->MaximumTransferLength;

        //
        // Add partition byte offset to make starting byte relative to
        // beginning of disk.
        //

        currentIrpStack->Parameters.Read.ByteOffset.QuadPart +=
            (fdoExtension->CommonExtension.StartingOffset.QuadPart);

        //
        // Calculate number of pages in this transfer.
        //

        transferPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(MmGetMdlVirtualAddress(Irp->MdlAddress),
                                                       currentIrpStack->Parameters.Read.Length);

        //
        // Check if request length is greater than the maximum number of
        // bytes that the hardware can transfer.
        //

        if (cdData->RawAccess) {

            //
            // a writable device must be MMC compliant, which supports
            // READ_CD commands.
            //

            ASSERT(currentIrpStack->MajorFunction != IRP_MJ_WRITE);

            ASSERT(!TEST_FLAG(cdData->XAFlags, XA_USE_READ_CD));

            //
            // Fire off a mode select to switch back to cooked sectors.
            //

            irp2 = IoAllocateIrp((CCHAR)(Fdo->StackSize+1), FALSE);

            if (!irp2) {
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            srb = ExAllocatePoolWithTag(NonPagedPool,
                                        sizeof(SCSI_REQUEST_BLOCK),
                                        CDROM_TAG_SRB);
            if (!srb) {
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

            cdb = (PCDB)srb->Cdb;

            //
            // Allocate sense buffer.
            //

            senseBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                                SENSE_BUFFER_SIZE,
                                                CDROM_TAG_SENSE_INFO);

            if (!senseBuffer) {
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            //
            // Set up the irp.
            //

            IoSetNextIrpStackLocation(irp2);
            irp2->IoStatus.Status = STATUS_SUCCESS;
            irp2->IoStatus.Information = 0;
            irp2->Flags = 0;
            irp2->UserBuffer = NULL;

            //
            // Save the device object and irp in a private stack location.
            //

            irpStack = IoGetCurrentIrpStackLocation(irp2);
            irpStack->DeviceObject = Fdo;
            irpStack->Parameters.Others.Argument2 = (PVOID) Irp;

            //
            // The retry count will be in the real Irp, as the retry logic will
            // recreate our private irp.
            //

            if (!(nextIrpStack->Parameters.Others.Argument1)) {

                //
                // Only jam this in if it doesn't exist. The completion routines can
                // call StartIo directly in the case of retries and resetting it will
                // cause infinite loops.
                //

                nextIrpStack->Parameters.Others.Argument1 = (PVOID) MAXIMUM_RETRIES;
            }

            //
            // Construct the IRP stack for the lower level driver.
            //

            irpStack = IoGetNextIrpStackLocation(irp2);
            irpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            irpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_SCSI_EXECUTE_IN;
            irpStack->Parameters.Scsi.Srb = srb;

            srb->Length = SCSI_REQUEST_BLOCK_SIZE;
            srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
            srb->SrbStatus = srb->ScsiStatus = 0;
            srb->NextSrb = 0;
            srb->OriginalRequest = irp2;
            srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;
            srb->SenseInfoBuffer = senseBuffer;

            transferByteCount = (use6Byte) ? sizeof(ERROR_RECOVERY_DATA) : sizeof(ERROR_RECOVERY_DATA10);

            dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                               transferByteCount,
                                               CDROM_TAG_RAW);

            if (!dataBuffer) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;

            }

            irp2->MdlAddress = IoAllocateMdl(dataBuffer,
                                            transferByteCount,
                                            FALSE,
                                            FALSE,
                                            (PIRP) NULL);

            if (!irp2->MdlAddress) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                ExFreePool(dataBuffer);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            //
            // Prepare the MDL
            //

            MmBuildMdlForNonPagedPool(irp2->MdlAddress);

            srb->DataBuffer = dataBuffer;

            //
            // Set the new block size in the descriptor.
            //

            if (use6Byte) {
                cdData->BlockDescriptor.BlockLength[0] = (UCHAR)(COOKED_SECTOR_SIZE >> 16) & 0xFF;
                cdData->BlockDescriptor.BlockLength[1] = (UCHAR)(COOKED_SECTOR_SIZE >>  8) & 0xFF;
                cdData->BlockDescriptor.BlockLength[2] = (UCHAR)(COOKED_SECTOR_SIZE & 0xFF);
            } else {
                cdData->BlockDescriptor10.BlockLength[0] = (UCHAR)(COOKED_SECTOR_SIZE >> 16) & 0xFF;
                cdData->BlockDescriptor10.BlockLength[1] = (UCHAR)(COOKED_SECTOR_SIZE >>  8) & 0xFF;
                cdData->BlockDescriptor10.BlockLength[2] = (UCHAR)(COOKED_SECTOR_SIZE & 0xFF);
            }

            //
            // Move error page into dataBuffer.
            //

            RtlCopyMemory(srb->DataBuffer, &cdData->Header, transferByteCount);

            //
            // Build and send a mode select to switch into raw mode.
            //

            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_OUT);
            srb->DataTransferLength = transferByteCount;
            srb->TimeOutValue = fdoExtension->TimeOutValue * 2;

            if (use6Byte) {
                srb->CdbLength = 6;
                cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
                cdb->MODE_SELECT.PFBit = 1;
                cdb->MODE_SELECT.ParameterListLength = (UCHAR)transferByteCount;
            } else {
                srb->CdbLength = 10;
                cdb->MODE_SELECT10.OperationCode = SCSIOP_MODE_SELECT10;
                cdb->MODE_SELECT10.PFBit = 1;
                cdb->MODE_SELECT10.ParameterListLength[0] = (UCHAR)(transferByteCount >> 8);
                cdb->MODE_SELECT10.ParameterListLength[1] = (UCHAR)(transferByteCount & 0xFF);
            }

            //
            // Update completion routine.
            //

            IoSetCompletionRoutine(irp2,
                                   CdRomSwitchModeCompletion,
                                   srb,
                                   TRUE,
                                   TRUE,
                                   TRUE);

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }


        //
        // Request needs to be split. Completion of each portion of the
        // request will fire off the next portion. The final request will
        // signal Io to send a new request.
        //

        transferPages =
            fdoExtension->AdapterDescriptor->MaximumPhysicalPages - 1;

        if(maximumTransferLength > (transferPages << PAGE_SHIFT)) {
            maximumTransferLength = transferPages << PAGE_SHIFT;
        }

        //
        // Check that the maximum transfer size is not zero
        //

        if(maximumTransferLength == 0) {
            maximumTransferLength = PAGE_SIZE;
        }

        ClassSplitRequest(Fdo, Irp, maximumTransferLength);
        return;

    } else if (currentIrpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL) {

        //
        // Allocate an irp, srb and associated structures.
        //

        irp2 = IoAllocateIrp((CCHAR)(Fdo->StackSize+1),
                              FALSE);

        if (!irp2) {
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

            BAIL_OUT(Irp);
            CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
            return;
        }

        srb = ExAllocatePoolWithTag(NonPagedPool,
                                    sizeof(SCSI_REQUEST_BLOCK),
                                    CDROM_TAG_SRB);
        if (!srb) {
            IoFreeIrp(irp2);
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

            BAIL_OUT(Irp);
            CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
            return;
        }

        RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

        cdb = (PCDB)srb->Cdb;

        //
        // Allocate sense buffer.
        //

        senseBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                            SENSE_BUFFER_SIZE,
                                            CDROM_TAG_SENSE_INFO);

        if (!senseBuffer) {
            ExFreePool(srb);
            IoFreeIrp(irp2);
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

            BAIL_OUT(Irp);
            CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
            return;
        }

        RtlZeroMemory(senseBuffer, SENSE_BUFFER_SIZE);

        //
        // Set up the irp.
        //

        IoSetNextIrpStackLocation(irp2);
        irp2->IoStatus.Status = STATUS_SUCCESS;
        irp2->IoStatus.Information = 0;
        irp2->Flags = 0;
        irp2->UserBuffer = NULL;

        //
        // Save the device object and irp in a private stack location.
        //

        irpStack = IoGetCurrentIrpStackLocation(irp2);
        irpStack->DeviceObject = Fdo;
        irpStack->Parameters.Others.Argument2 = (PVOID) Irp;

        //
        // The retry count will be in the real Irp, as the retry logic will
        // recreate our private irp.
        //

        if (!(nextIrpStack->Parameters.Others.Argument1)) {

            //
            // Only jam this in if it doesn't exist. The completion routines can
            // call StartIo directly in the case of retries and resetting it will
            // cause infinite loops.
            //

            nextIrpStack->Parameters.Others.Argument1 = (PVOID) MAXIMUM_RETRIES;
        }

        //
        // keep track of the new irp as Argument3
        //

        nextIrpStack->Parameters.Others.Argument3 = irp2;


        //
        // Construct the IRP stack for the lower level driver.
        //

        irpStack = IoGetNextIrpStackLocation(irp2);
        irpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_SCSI_EXECUTE_IN;
        irpStack->Parameters.Scsi.Srb = srb;

        IoSetCompletionRoutine(irp2,
                               CdRomDeviceControlCompletion,
                               srb,
                               TRUE,
                               TRUE,
                               TRUE);
        //
        // Setup those fields that are generic to all requests.
        //

        srb->Length = SCSI_REQUEST_BLOCK_SIZE;
        srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
        srb->SrbStatus = srb->ScsiStatus = 0;
        srb->NextSrb = 0;
        srb->OriginalRequest = irp2;
        srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;
        srb->SenseInfoBuffer = senseBuffer;

        switch (currentIrpStack->Parameters.DeviceIoControl.IoControlCode) {


        case IOCTL_CDROM_RAW_READ: {

            //
            // Determine whether the drive is currently in raw or cooked mode,
            // and which command to use to read the data.
            //

            if (!TEST_FLAG(cdData->XAFlags, XA_USE_READ_CD)) {

                PRAW_READ_INFO rawReadInfo =
                                   (PRAW_READ_INFO)currentIrpStack->Parameters.DeviceIoControl.Type3InputBuffer;
                ULONG          maximumTransferLength;
                ULONG          transferPages;

                if (cdData->RawAccess) {

                    ULONG  startingSector;
                    UCHAR  min, sec, frame;

                    //
                    // Free the recently allocated irp, as we don't need it.
                    //

                    IoFreeIrp(irp2);

                    cdb = (PCDB)srb->Cdb;
                    RtlZeroMemory(cdb, CDB12GENERIC_LENGTH);

                    //
                    // Calculate starting offset.
                    //

                    startingSector = (ULONG)(rawReadInfo->DiskOffset.QuadPart >> fdoExtension->SectorShift);
                    transferByteCount  = rawReadInfo->SectorCount * RAW_SECTOR_SIZE;
                    maximumTransferLength = fdoExtension->AdapterDescriptor->MaximumTransferLength;
                    transferPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(MmGetMdlVirtualAddress(Irp->MdlAddress),
                                                                   transferByteCount);

                    //
                    // Determine if request is within limits imposed by miniport.
                    //
                    if (transferByteCount > maximumTransferLength ||
                        transferPages > fdoExtension->AdapterDescriptor->MaximumPhysicalPages) {

                        //
                        // The claim is that this won't happen, and is backed up by
                        // ActiveMovie usage, which does unbuffered XA reads of 0x18000, yet
                        // we get only 4 sector requests.
                        //

                        ExFreePool(senseBuffer);
                        ExFreePool(srb);

                        Irp->IoStatus.Information = 0;
                        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

                        BAIL_OUT(Irp);
                        CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                        return;

                    }

                    srb->OriginalRequest = Irp;
                    srb->SrbFlags = fdoExtension->SrbFlags;
                    SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
                    SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
                    srb->DataTransferLength = transferByteCount;
                    srb->TimeOutValue = fdoExtension->TimeOutValue;
                    srb->CdbLength = 10;
                    srb->DataBuffer = MmGetMdlVirtualAddress(Irp->MdlAddress);

                    if (rawReadInfo->TrackMode == CDDA) {
                        if (TEST_FLAG(cdData->XAFlags, XA_PLEXTOR_CDDA)) {

                            srb->CdbLength = 12;

                            cdb->PLXTR_READ_CDDA.LogicalBlockByte3  = (UCHAR) (startingSector & 0xFF);
                            cdb->PLXTR_READ_CDDA.LogicalBlockByte2  = (UCHAR) ((startingSector >>  8) & 0xFF);
                            cdb->PLXTR_READ_CDDA.LogicalBlockByte1  = (UCHAR) ((startingSector >> 16) & 0xFF);
                            cdb->PLXTR_READ_CDDA.LogicalBlockByte0  = (UCHAR) ((startingSector >> 24) & 0xFF);

                            cdb->PLXTR_READ_CDDA.TransferBlockByte3 = (UCHAR) (rawReadInfo->SectorCount & 0xFF);
                            cdb->PLXTR_READ_CDDA.TransferBlockByte2 = (UCHAR) (rawReadInfo->SectorCount >> 8);
                            cdb->PLXTR_READ_CDDA.TransferBlockByte1 = 0;
                            cdb->PLXTR_READ_CDDA.TransferBlockByte0 = 0;

                            cdb->PLXTR_READ_CDDA.SubCode = 0;
                            cdb->PLXTR_READ_CDDA.OperationCode = 0xD8;

                        } else if (TEST_FLAG(cdData->XAFlags, XA_NEC_CDDA)) {

                            cdb->NEC_READ_CDDA.LogicalBlockByte3  = (UCHAR) (startingSector & 0xFF);
                            cdb->NEC_READ_CDDA.LogicalBlockByte2  = (UCHAR) ((startingSector >>  8) & 0xFF);
                            cdb->NEC_READ_CDDA.LogicalBlockByte1  = (UCHAR) ((startingSector >> 16) & 0xFF);
                            cdb->NEC_READ_CDDA.LogicalBlockByte0  = (UCHAR) ((startingSector >> 24) & 0xFF);

                            cdb->NEC_READ_CDDA.TransferBlockByte1 = (UCHAR) (rawReadInfo->SectorCount & 0xFF);
                            cdb->NEC_READ_CDDA.TransferBlockByte0 = (UCHAR) (rawReadInfo->SectorCount >> 8);

                            cdb->NEC_READ_CDDA.OperationCode = 0xD4;
                        }
                    } else {

                        cdb->CDB10.TransferBlocksMsb  = (UCHAR) (rawReadInfo->SectorCount >> 8);
                        cdb->CDB10.TransferBlocksLsb  = (UCHAR) (rawReadInfo->SectorCount & 0xFF);

                        cdb->CDB10.LogicalBlockByte3  = (UCHAR) (startingSector & 0xFF);
                        cdb->CDB10.LogicalBlockByte2  = (UCHAR) ((startingSector >>  8) & 0xFF);
                        cdb->CDB10.LogicalBlockByte1  = (UCHAR) ((startingSector >> 16) & 0xFF);
                        cdb->CDB10.LogicalBlockByte0  = (UCHAR) ((startingSector >> 24) & 0xFF);

                        cdb->CDB10.OperationCode = SCSIOP_READ;
                    }

                    srb->SrbStatus = srb->ScsiStatus = 0;

                    nextIrpStack->MajorFunction = IRP_MJ_SCSI;
                    nextIrpStack->Parameters.Scsi.Srb = srb;

                    // HACKHACK - REF #0001

                    //
                    // Set up IoCompletion routine address.
                    //

                    IoSetCompletionRoutine(Irp,
                                           CdRomXACompletion,
                                           srb,
                                           TRUE,
                                           TRUE,
                                           TRUE);

                    IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, Irp);
                    return;

                } else {

                    transferByteCount = (use6Byte) ? sizeof(ERROR_RECOVERY_DATA) : sizeof(ERROR_RECOVERY_DATA10);
                    dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                                       transferByteCount,
                                                       CDROM_TAG_RAW );
                    if (!dataBuffer) {
                        ExFreePool(senseBuffer);
                        ExFreePool(srb);
                        IoFreeIrp(irp2);
                        Irp->IoStatus.Information = 0;
                        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                        BAIL_OUT(Irp);
                        CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                        return;

                    }

                    irp2->MdlAddress = IoAllocateMdl(dataBuffer,
                                                    transferByteCount,
                                                    FALSE,
                                                    FALSE,
                                                    (PIRP) NULL);

                    if (!irp2->MdlAddress) {
                        ExFreePool(senseBuffer);
                        ExFreePool(srb);
                        ExFreePool(dataBuffer);
                        IoFreeIrp(irp2);
                        Irp->IoStatus.Information = 0;
                        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                        BAIL_OUT(Irp);
                        CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                        return;
                    }

                    //
                    // Prepare the MDL
                    //

                    MmBuildMdlForNonPagedPool(irp2->MdlAddress);

                    srb->DataBuffer = dataBuffer;

                    //
                    // Set the new block size in the descriptor.
                    // This will set the block read size to RAW_SECTOR_SIZE
                    // TODO: Set density code, based on operation
                    //

                    if (use6Byte) {
                        cdData->BlockDescriptor.BlockLength[0] = (UCHAR)(RAW_SECTOR_SIZE >> 16) & 0xFF;
                        cdData->BlockDescriptor.BlockLength[1] = (UCHAR)(RAW_SECTOR_SIZE >>  8) & 0xFF;
                        cdData->BlockDescriptor.BlockLength[2] = (UCHAR)(RAW_SECTOR_SIZE & 0xFF);
                        cdData->BlockDescriptor.DensityCode = 0;
                    } else {
                        cdData->BlockDescriptor10.BlockLength[0] = (UCHAR)(RAW_SECTOR_SIZE >> 16) & 0xFF;
                        cdData->BlockDescriptor10.BlockLength[1] = (UCHAR)(RAW_SECTOR_SIZE >>  8) & 0xFF;
                        cdData->BlockDescriptor10.BlockLength[2] = (UCHAR)(RAW_SECTOR_SIZE & 0xFF);
                        cdData->BlockDescriptor10.DensityCode = 0;
                    }

                    //
                    // Move error page into dataBuffer.
                    //

                    RtlCopyMemory(srb->DataBuffer, &cdData->Header, transferByteCount);


                    //
                    // Build and send a mode select to switch into raw mode.
                    //

                    srb->SrbFlags = fdoExtension->SrbFlags;
                    SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
                    SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_OUT);
                    srb->DataTransferLength = transferByteCount;
                    srb->TimeOutValue = fdoExtension->TimeOutValue * 2;

                    if (use6Byte) {
                        srb->CdbLength = 6;
                        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
                        cdb->MODE_SELECT.PFBit = 1;
                        cdb->MODE_SELECT.ParameterListLength = (UCHAR)transferByteCount;
                    } else {

                        srb->CdbLength = 10;
                        cdb->MODE_SELECT10.OperationCode = SCSIOP_MODE_SELECT10;
                        cdb->MODE_SELECT10.PFBit = 1;
                        cdb->MODE_SELECT10.ParameterListLength[0] = (UCHAR)(transferByteCount >> 8);
                        cdb->MODE_SELECT10.ParameterListLength[1] = (UCHAR)(transferByteCount & 0xFF);
                    }

                    //
                    // Update completion routine.
                    //

                    IoSetCompletionRoutine(irp2,
                                           CdRomSwitchModeCompletion,
                                           srb,
                                           TRUE,
                                           TRUE,
                                           TRUE);

                }

            } else {

                PRAW_READ_INFO rawReadInfo =
                                   (PRAW_READ_INFO)currentIrpStack->Parameters.DeviceIoControl.Type3InputBuffer;
                ULONG  startingSector;

                //
                // Free the recently allocated irp, as we don't need it.
                //

                IoFreeIrp(irp2);

                cdb = (PCDB)srb->Cdb;
                RtlZeroMemory(cdb, CDB12GENERIC_LENGTH);


                //
                // Calculate starting offset.
                //

                startingSector = (ULONG)(rawReadInfo->DiskOffset.QuadPart >> fdoExtension->SectorShift);
                transferByteCount  = rawReadInfo->SectorCount * RAW_SECTOR_SIZE;

                srb->OriginalRequest = Irp;
                srb->SrbFlags = fdoExtension->SrbFlags;
                SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
                SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
                srb->DataTransferLength = transferByteCount;
                srb->TimeOutValue = fdoExtension->TimeOutValue;
                srb->DataBuffer = MmGetMdlVirtualAddress(Irp->MdlAddress);
                srb->CdbLength = 12;
                srb->SrbStatus = srb->ScsiStatus = 0;

                //
                // Fill in CDB fields.
                //

                cdb = (PCDB)srb->Cdb;


                cdb->READ_CD.TransferBlocks[2]  = (UCHAR) (rawReadInfo->SectorCount & 0xFF);
                cdb->READ_CD.TransferBlocks[1]  = (UCHAR) (rawReadInfo->SectorCount >> 8 );
                cdb->READ_CD.TransferBlocks[0]  = (UCHAR) (rawReadInfo->SectorCount >> 16);


                cdb->READ_CD.StartingLBA[3]  = (UCHAR) (startingSector & 0xFF);
                cdb->READ_CD.StartingLBA[2]  = (UCHAR) ((startingSector >>  8));
                cdb->READ_CD.StartingLBA[1]  = (UCHAR) ((startingSector >> 16));
                cdb->READ_CD.StartingLBA[0]  = (UCHAR) ((startingSector >> 24));

                //
                // Setup cdb depending upon the sector type we want.
                //

                switch (rawReadInfo->TrackMode) {
                case CDDA:

                    cdb->READ_CD.ExpectedSectorType = CD_DA_SECTOR;
                    cdb->READ_CD.IncludeUserData = 1;
                    cdb->READ_CD.HeaderCode = 3;
                    cdb->READ_CD.IncludeSyncData = 1;
                    break;

                case YellowMode2:

                    cdb->READ_CD.ExpectedSectorType = YELLOW_MODE2_SECTOR;
                    cdb->READ_CD.IncludeUserData = 1;
                    cdb->READ_CD.HeaderCode = 1;
                    cdb->READ_CD.IncludeSyncData = 1;
                    break;

                case XAForm2:

                    cdb->READ_CD.ExpectedSectorType = FORM2_MODE2_SECTOR;
                    cdb->READ_CD.IncludeUserData = 1;
                    cdb->READ_CD.HeaderCode = 3;
                    cdb->READ_CD.IncludeSyncData = 1;
                    break;

                default:
                    ExFreePool(senseBuffer);
                    ExFreePool(srb);
                    Irp->IoStatus.Information = 0;
                    Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

                    BAIL_OUT(Irp);
                    CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                    return;
                }

                cdb->READ_CD.OperationCode = SCSIOP_READ_CD;

                nextIrpStack->MajorFunction = IRP_MJ_SCSI;
                nextIrpStack->Parameters.Scsi.Srb = srb;

                // HACKHACK - REF #0001

                //
                // Set up IoCompletion routine address.
                //

                IoSetCompletionRoutine(Irp,
                                       CdRomXACompletion,
                                       srb,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, Irp);
                return;

            }

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }

        //
        // the _EX version does the same thing on the front end
        //

        case IOCTL_DISK_GET_LENGTH_INFO:
        case IOCTL_DISK_GET_DRIVE_GEOMETRY_EX:
        case IOCTL_DISK_GET_DRIVE_GEOMETRY:
        case IOCTL_CDROM_GET_DRIVE_GEOMETRY_EX:
        case IOCTL_CDROM_GET_DRIVE_GEOMETRY: {

            //
            // Issue ReadCapacity to update device extension
            // with information for current media.
            //

            TraceLog((CdromDebugError,
                        "CdRomStartIo: Get drive geometry/length "
                        "info (%p)\n", Irp));

            //
            // setup remaining srb and cdb parameters.
            //

            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
            srb->DataTransferLength = sizeof(READ_CAPACITY_DATA);
            srb->CdbLength = 10;
            srb->TimeOutValue = fdoExtension->TimeOutValue;

            dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                               sizeof(READ_CAPACITY_DATA),
                                               CDROM_TAG_READ_CAP);
            if (!dataBuffer) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;

            }

            irp2->MdlAddress = IoAllocateMdl(dataBuffer,
                                            sizeof(READ_CAPACITY_DATA),
                                            FALSE,
                                            FALSE,
                                            (PIRP) NULL);

            if (!irp2->MdlAddress) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                ExFreePool(dataBuffer);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            //
            // Prepare the MDL
            //

            MmBuildMdlForNonPagedPool(irp2->MdlAddress);

            srb->DataBuffer = dataBuffer;
            cdb->CDB10.OperationCode = SCSIOP_READ_CAPACITY;

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }

        case IOCTL_CDROM_GET_CONFIGURATION: {

            PGET_CONFIGURATION_IOCTL_INPUT inputBuffer;
            
            TraceLog((CdromDebugError,
                        "CdRomStartIo: Get configuration (%p)\n", Irp));

            if (!cdData->Mmc.IsMmc) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            transferByteCount = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
            
            dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                               transferByteCount,
                                               CDROM_TAG_GET_CONFIG);
            if (!dataBuffer) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            irp2->MdlAddress = IoAllocateMdl(dataBuffer,
                                             transferByteCount,
                                             FALSE,
                                             FALSE,
                                             (PIRP) NULL);
            if (!irp2->MdlAddress) {
                ExFreePool(dataBuffer);
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            MmBuildMdlForNonPagedPool(irp2->MdlAddress);
            
            //
            // setup remaining srb and cdb parameters
            //

            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
            srb->DataTransferLength = transferByteCount;
            srb->CdbLength = 10;
            srb->TimeOutValue = fdoExtension->TimeOutValue;
            srb->DataBuffer = dataBuffer;
            
            cdb->GET_CONFIGURATION.OperationCode = SCSIOP_GET_CONFIGURATION;
            cdb->GET_CONFIGURATION.AllocationLength[0] = (UCHAR)(transferByteCount >> 8);
            cdb->GET_CONFIGURATION.AllocationLength[1] = (UCHAR)(transferByteCount & 0xff);

            inputBuffer = (PGET_CONFIGURATION_IOCTL_INPUT)Irp->AssociatedIrp.SystemBuffer;
            cdb->GET_CONFIGURATION.StartingFeature[0] = (UCHAR)(inputBuffer->Feature >> 8);
            cdb->GET_CONFIGURATION.StartingFeature[1] = (UCHAR)(inputBuffer->Feature & 0xff);
            cdb->GET_CONFIGURATION.RequestType        = (UCHAR)(inputBuffer->RequestType);
            
            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }

        case IOCTL_DISK_VERIFY: {
            
            PVERIFY_INFORMATION verifyInfo = Irp->AssociatedIrp.SystemBuffer;
            LARGE_INTEGER byteOffset;
            ULONG         sectorOffset;
            USHORT        sectorCount;

            if (!cdData->Mmc.WriteAllowed) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_MEDIA_WRITE_PROTECTED;
                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }
            //
            // Verify sectors
            //

            srb->CdbLength = 10;

            cdb->CDB10.OperationCode = SCSIOP_VERIFY;

            //
            // Add disk offset to starting sector.
            //

            byteOffset.QuadPart = commonExtension->StartingOffset.QuadPart +
                                  verifyInfo->StartingOffset.QuadPart;

            //
            // Convert byte offset to sector offset.
            //

            sectorOffset = (ULONG)(byteOffset.QuadPart >> fdoExtension->SectorShift);

            //
            // Convert ULONG byte count to USHORT sector count.
            //

            sectorCount = (USHORT)(verifyInfo->Length >> fdoExtension->SectorShift);

            //
            // Move little endian values into CDB in big endian format.
            //

            cdb->CDB10.LogicalBlockByte0 = ((PFOUR_BYTE)&sectorOffset)->Byte3;
            cdb->CDB10.LogicalBlockByte1 = ((PFOUR_BYTE)&sectorOffset)->Byte2;
            cdb->CDB10.LogicalBlockByte2 = ((PFOUR_BYTE)&sectorOffset)->Byte1;
            cdb->CDB10.LogicalBlockByte3 = ((PFOUR_BYTE)&sectorOffset)->Byte0;

            cdb->CDB10.TransferBlocksMsb = ((PFOUR_BYTE)&sectorCount)->Byte1;
            cdb->CDB10.TransferBlocksLsb = ((PFOUR_BYTE)&sectorCount)->Byte0;

            //
            // The verify command is used by the NT FORMAT utility and
            // requests are sent down for 5% of the volume size. The
            // request timeout value is calculated based on the number of
            // sectors verified.
            //

            srb->TimeOutValue = ((sectorCount + 0x7F) >> 7) *
                                fdoExtension->TimeOutValue;

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }

        case IOCTL_STORAGE_CHECK_VERIFY:
        case IOCTL_DISK_CHECK_VERIFY:
        case IOCTL_CDROM_CHECK_VERIFY: {

            //
            // Since a test unit ready is about to be performed, reset the
            // timer value to decrease the opportunities for it to race with
            // this code.
            //

            ClassResetMediaChangeTimer(fdoExtension);

            //
            // Set up the SRB/CDB
            //

            srb->CdbLength = 6;
            cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
            srb->TimeOutValue = fdoExtension->TimeOutValue * 2;
            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_DATA_TRANSFER);


            TraceLog((CdromDebugTrace,
                        "CdRomStartIo: [%p] Sending CHECK_VERIFY irp %p\n",
                        Irp, irp2));
            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }

        case IOCTL_DVD_READ_STRUCTURE: {

            CdRomDeviceControlDvdReadStructure(Fdo, Irp, irp2, srb);
            return;

        }

        case IOCTL_DVD_END_SESSION: {
            CdRomDeviceControlDvdEndSession(Fdo, Irp, irp2, srb);
            return;
        }

        case IOCTL_DVD_START_SESSION:
        case IOCTL_DVD_READ_KEY: {

            CdRomDeviceControlDvdStartSessionReadKey(Fdo, Irp, irp2, srb);
            return;

        }


        case IOCTL_DVD_SEND_KEY:
        case IOCTL_DVD_SEND_KEY2: {

            CdRomDeviceControlDvdSendKey (Fdo, Irp, irp2, srb);
            return;


        }

        case IOCTL_CDROM_READ_TOC_EX: {
            
            PCDROM_READ_TOC_EX inputBuffer = Irp->AssociatedIrp.SystemBuffer;

            transferByteCount = currentIrpStack->Parameters.Read.Length;

            dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                               transferByteCount,
                                               CDROM_TAG_TOC);
            if (!dataBuffer) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;

            }

            irp2->MdlAddress = IoAllocateMdl(dataBuffer,
                                            transferByteCount,
                                            FALSE,
                                            FALSE,
                                            (PIRP) NULL);

            if (!irp2->MdlAddress) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                ExFreePool(dataBuffer);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            //
            // setup the request per user request
            // do validity checking in devctl dispatch, not here
            //

            cdb->READ_TOC.OperationCode = SCSIOP_READ_TOC;
            cdb->READ_TOC.Msf = inputBuffer->Msf;
            cdb->READ_TOC.Format2 = inputBuffer->Format;
            cdb->READ_TOC.StartingTrack = inputBuffer->SessionTrack;
            cdb->READ_TOC.AllocationLength[0] = (UCHAR)(transferByteCount >> 8);
            cdb->READ_TOC.AllocationLength[1] = (UCHAR)(transferByteCount & 0xff);

            //
            // Prepare the MDL
            //

            MmBuildMdlForNonPagedPool(irp2->MdlAddress);

            //
            // do the standard stuff....
            //

            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
            srb->DataTransferLength = transferByteCount;
            srb->CdbLength = 10;
            srb->TimeOutValue = fdoExtension->TimeOutValue;
            srb->DataBuffer = dataBuffer;

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }

        case IOCTL_CDROM_GET_LAST_SESSION:
        case IOCTL_CDROM_READ_TOC: {

            if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == 
                IOCTL_CDROM_GET_LAST_SESSION) {

                //
                // Set format to return first and last session numbers.
                //

                cdb->READ_TOC.Format = CDROM_READ_TOC_EX_FORMAT_SESSION;

            } else {

                //
                // Use MSF addressing
                //

                cdb->READ_TOC.Msf = 1;

            }


            transferByteCount =
                currentIrpStack->Parameters.Read.Length >
                    sizeof(CDROM_TOC) ? sizeof(CDROM_TOC):
                    currentIrpStack->Parameters.Read.Length;

            //
            // Set size of TOC structure.
            //

            cdb->READ_TOC.AllocationLength[0] = (UCHAR) (transferByteCount >> 8);
            cdb->READ_TOC.AllocationLength[1] = (UCHAR) (transferByteCount & 0xFF);

            //
            // setup remaining srb and cdb parameters.
            //

            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
            srb->DataTransferLength = transferByteCount;
            srb->CdbLength = 10;
            srb->TimeOutValue = fdoExtension->TimeOutValue;

            dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                               transferByteCount,
                                               CDROM_TAG_TOC);
            if (!dataBuffer) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;

            }

            irp2->MdlAddress = IoAllocateMdl(dataBuffer,
                                            transferByteCount,
                                            FALSE,
                                            FALSE,
                                            (PIRP) NULL);

            if (!irp2->MdlAddress) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                ExFreePool(dataBuffer);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            //
            // Prepare the MDL
            //
            
            MmBuildMdlForNonPagedPool(irp2->MdlAddress);

            srb->DataBuffer = dataBuffer;
            cdb->READ_TOC.OperationCode = SCSIOP_READ_TOC;

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;

        }

        case IOCTL_CDROM_PLAY_AUDIO_MSF: {

            PCDROM_PLAY_AUDIO_MSF inputBuffer = Irp->AssociatedIrp.SystemBuffer;

            //
            // Set up the SRB/CDB
            //

            srb->CdbLength = 10;
            cdb->PLAY_AUDIO_MSF.OperationCode = SCSIOP_PLAY_AUDIO_MSF;

            cdb->PLAY_AUDIO_MSF.StartingM = inputBuffer->StartingM;
            cdb->PLAY_AUDIO_MSF.StartingS = inputBuffer->StartingS;
            cdb->PLAY_AUDIO_MSF.StartingF = inputBuffer->StartingF;

            cdb->PLAY_AUDIO_MSF.EndingM = inputBuffer->EndingM;
            cdb->PLAY_AUDIO_MSF.EndingS = inputBuffer->EndingS;
            cdb->PLAY_AUDIO_MSF.EndingF = inputBuffer->EndingF;

            srb->TimeOutValue = fdoExtension->TimeOutValue;
            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_DATA_TRANSFER);

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;

        }

        case IOCTL_CDROM_READ_Q_CHANNEL: {

            PSUB_Q_CHANNEL_DATA userChannelData =
                             Irp->AssociatedIrp.SystemBuffer;
            PCDROM_SUB_Q_DATA_FORMAT inputBuffer =
                             Irp->AssociatedIrp.SystemBuffer;

            //
            // Allocate buffer for subq channel information.
            //

            dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                               sizeof(SUB_Q_CHANNEL_DATA),
                                               CDROM_TAG_SUB_Q);

            if (!dataBuffer) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;

            }

            irp2->MdlAddress = IoAllocateMdl(dataBuffer,
                                             sizeof(SUB_Q_CHANNEL_DATA),
                                             FALSE,
                                             FALSE,
                                             (PIRP) NULL);

            if (!irp2->MdlAddress) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                ExFreePool(dataBuffer);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            //
            // Prepare the MDL
            //

            MmBuildMdlForNonPagedPool(irp2->MdlAddress);

            srb->DataBuffer = dataBuffer;

            //
            // Always logical unit 0, but only use MSF addressing
            // for IOCTL_CDROM_CURRENT_POSITION
            //

            if (inputBuffer->Format==IOCTL_CDROM_CURRENT_POSITION)
                cdb->SUBCHANNEL.Msf = CDB_USE_MSF;

            //
            // Return subchannel data
            //

            cdb->SUBCHANNEL.SubQ = CDB_SUBCHANNEL_BLOCK;

            //
            // Specify format of informatin to return
            //

            cdb->SUBCHANNEL.Format = inputBuffer->Format;

            //
            // Specify which track to access (only used by Track ISRC reads)
            //

            if (inputBuffer->Format==IOCTL_CDROM_TRACK_ISRC) {
                cdb->SUBCHANNEL.TrackNumber = inputBuffer->Track;
            }

            //
            // Set size of channel data -- however, this is dependent on
            // what information we are requesting (which Format)
            //

            switch( inputBuffer->Format ) {

                case IOCTL_CDROM_CURRENT_POSITION:
                    transferByteCount = sizeof(SUB_Q_CURRENT_POSITION);
                    break;

                case IOCTL_CDROM_MEDIA_CATALOG:
                    transferByteCount = sizeof(SUB_Q_MEDIA_CATALOG_NUMBER);
                    break;

                case IOCTL_CDROM_TRACK_ISRC:
                    transferByteCount = sizeof(SUB_Q_TRACK_ISRC);
                    break;
            }

            cdb->SUBCHANNEL.AllocationLength[0] = (UCHAR) (transferByteCount >> 8);
            cdb->SUBCHANNEL.AllocationLength[1] = (UCHAR) (transferByteCount &  0xFF);
            cdb->SUBCHANNEL.OperationCode = SCSIOP_READ_SUB_CHANNEL;
            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
            srb->DataTransferLength = transferByteCount;
            srb->CdbLength = 10;
            srb->TimeOutValue = fdoExtension->TimeOutValue;

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;

        }

        case IOCTL_CDROM_PAUSE_AUDIO: {

            cdb->PAUSE_RESUME.OperationCode = SCSIOP_PAUSE_RESUME;
            cdb->PAUSE_RESUME.Action = CDB_AUDIO_PAUSE;

            srb->CdbLength = 10;
            srb->TimeOutValue = fdoExtension->TimeOutValue;
            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_DATA_TRANSFER);

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }

        case IOCTL_CDROM_RESUME_AUDIO: {

            cdb->PAUSE_RESUME.OperationCode = SCSIOP_PAUSE_RESUME;
            cdb->PAUSE_RESUME.Action = CDB_AUDIO_RESUME;

            srb->CdbLength = 10;
            srb->TimeOutValue = fdoExtension->TimeOutValue;
            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_DATA_TRANSFER);

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }

        case IOCTL_CDROM_SEEK_AUDIO_MSF: {

            PCDROM_SEEK_AUDIO_MSF inputBuffer = Irp->AssociatedIrp.SystemBuffer;
            ULONG                 logicalBlockAddress;

            logicalBlockAddress = MSF_TO_LBA(inputBuffer->M, inputBuffer->S, inputBuffer->F);

            cdb->SEEK.OperationCode      = SCSIOP_SEEK;
            cdb->SEEK.LogicalBlockAddress[0] = ((PFOUR_BYTE)&logicalBlockAddress)->Byte3;
            cdb->SEEK.LogicalBlockAddress[1] = ((PFOUR_BYTE)&logicalBlockAddress)->Byte2;
            cdb->SEEK.LogicalBlockAddress[2] = ((PFOUR_BYTE)&logicalBlockAddress)->Byte1;
            cdb->SEEK.LogicalBlockAddress[3] = ((PFOUR_BYTE)&logicalBlockAddress)->Byte0;

            srb->CdbLength = 10;
            srb->TimeOutValue = fdoExtension->TimeOutValue;
            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_DATA_TRANSFER);

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;

        }

        case IOCTL_CDROM_STOP_AUDIO: {

            cdb->START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
            cdb->START_STOP.Immediate = 1;
            cdb->START_STOP.Start = 0;
            cdb->START_STOP.LoadEject = 0;

            srb->CdbLength = 6;
            srb->TimeOutValue = fdoExtension->TimeOutValue;

            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_DATA_TRANSFER);

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }

        case IOCTL_CDROM_GET_CONTROL: {

            PAUDIO_OUTPUT audioOutput;
            PCDROM_AUDIO_CONTROL audioControl = Irp->AssociatedIrp.SystemBuffer;

            //
            // Allocate buffer for volume control information.
            //

            dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                               MODE_DATA_SIZE,
                                               CDROM_TAG_VOLUME);

            if (!dataBuffer) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;

            }

            irp2->MdlAddress = IoAllocateMdl(dataBuffer,
                                            MODE_DATA_SIZE,
                                            FALSE,
                                            FALSE,
                                            (PIRP) NULL);

            if (!irp2->MdlAddress) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                ExFreePool(dataBuffer);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            //
            // Prepare the MDL
            //

            MmBuildMdlForNonPagedPool(irp2->MdlAddress);
            srb->DataBuffer = dataBuffer;

            RtlZeroMemory(dataBuffer, MODE_DATA_SIZE);

            //
            // Setup for either 6 or 10 byte CDBs.
            //

            if (use6Byte) {

                cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
                cdb->MODE_SENSE.PageCode = CDROM_AUDIO_CONTROL_PAGE;
                cdb->MODE_SENSE.AllocationLength = MODE_DATA_SIZE;

                //
                // Disable block descriptors.
                //

                cdb->MODE_SENSE.Dbd = TRUE;

                srb->CdbLength = 6;
            } else {

                cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
                cdb->MODE_SENSE10.PageCode = CDROM_AUDIO_CONTROL_PAGE;
                cdb->MODE_SENSE10.AllocationLength[0] = (UCHAR)(MODE_DATA_SIZE >> 8);
                cdb->MODE_SENSE10.AllocationLength[1] = (UCHAR)(MODE_DATA_SIZE & 0xFF);

                //
                // Disable block descriptors.
                //

                cdb->MODE_SENSE10.Dbd = TRUE;

                srb->CdbLength = 10;
            }

            srb->TimeOutValue = fdoExtension->TimeOutValue;
            srb->DataTransferLength = MODE_DATA_SIZE;
            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;

        }

        case IOCTL_CDROM_GET_VOLUME:
        case IOCTL_CDROM_SET_VOLUME: {

            dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                        MODE_DATA_SIZE,
                                        CDROM_TAG_VOLUME);

            if (!dataBuffer) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            irp2->MdlAddress = IoAllocateMdl(dataBuffer,
                                            MODE_DATA_SIZE,
                                            FALSE,
                                            FALSE,
                                            (PIRP) NULL);

            if (!irp2->MdlAddress) {
                ExFreePool(senseBuffer);
                ExFreePool(srb);
                ExFreePool(dataBuffer);
                IoFreeIrp(irp2);
                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                BAIL_OUT(Irp);
                CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
                return;
            }

            //
            // Prepare the MDL
            //

            MmBuildMdlForNonPagedPool(irp2->MdlAddress);
            srb->DataBuffer = dataBuffer;

            RtlZeroMemory(dataBuffer, MODE_DATA_SIZE);


            if (use6Byte) {
                
                cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
                cdb->MODE_SENSE.PageCode = CDROM_AUDIO_CONTROL_PAGE;
                cdb->MODE_SENSE.AllocationLength = MODE_DATA_SIZE;

                srb->CdbLength = 6;

            } else {

                cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
                cdb->MODE_SENSE10.PageCode = CDROM_AUDIO_CONTROL_PAGE;
                cdb->MODE_SENSE10.AllocationLength[0] = (UCHAR)(MODE_DATA_SIZE >> 8);
                cdb->MODE_SENSE10.AllocationLength[1] = (UCHAR)(MODE_DATA_SIZE & 0xFF);

                srb->CdbLength = 10;
            }

            srb->TimeOutValue = fdoExtension->TimeOutValue;
            srb->DataTransferLength = MODE_DATA_SIZE;
            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);

            if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_CDROM_SET_VOLUME) {

                //
                // Setup a different completion routine as the mode sense data is needed in order
                // to send the mode select.
                //

                IoSetCompletionRoutine(irp2,
                                       CdRomSetVolumeIntermediateCompletion,
                                       srb,
                                       TRUE,
                                       TRUE,
                                       TRUE);

            }

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;

        }

        case IOCTL_STORAGE_SET_READ_AHEAD: {

            PSTORAGE_SET_READ_AHEAD readAhead = Irp->AssociatedIrp.SystemBuffer;

            ULONG blockAddress;
            PFOUR_BYTE fourByte = (PFOUR_BYTE) &blockAddress;

            //
            // setup the SRB for a set readahead command
            //

            cdb->SET_READ_AHEAD.OperationCode = SCSIOP_SET_READ_AHEAD;

            blockAddress = (ULONG) (readAhead->TriggerAddress.QuadPart >>
                                    fdoExtension->SectorShift);

            cdb->SET_READ_AHEAD.TriggerLBA[0] = fourByte->Byte3;
            cdb->SET_READ_AHEAD.TriggerLBA[1] = fourByte->Byte2;
            cdb->SET_READ_AHEAD.TriggerLBA[2] = fourByte->Byte1;
            cdb->SET_READ_AHEAD.TriggerLBA[3] = fourByte->Byte0;

            blockAddress = (ULONG) (readAhead->TargetAddress.QuadPart >>
                                    fdoExtension->SectorShift);

            cdb->SET_READ_AHEAD.ReadAheadLBA[0] = fourByte->Byte3;
            cdb->SET_READ_AHEAD.ReadAheadLBA[1] = fourByte->Byte2;
            cdb->SET_READ_AHEAD.ReadAheadLBA[2] = fourByte->Byte1;
            cdb->SET_READ_AHEAD.ReadAheadLBA[3] = fourByte->Byte0;

            srb->CdbLength = 12;
            srb->TimeOutValue = fdoExtension->TimeOutValue;

            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_DATA_TRANSFER);

            IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp2);
            return;
        }

        case IOCTL_DISK_GET_DRIVE_LAYOUT:
        case IOCTL_DISK_GET_DRIVE_LAYOUT_EX:
        case IOCTL_DISK_GET_PARTITION_INFO:
        case IOCTL_DISK_GET_PARTITION_INFO_EX: {

            ASSERT(irp2);
            ASSERT(senseBuffer);
            ASSERT(srb);

            ExFreePool(srb);
            ExFreePool(senseBuffer);
            IoFreeIrp(irp2);

            //
            // NOTE: should probably update the media's capacity first...
            //
            
            CdromFakePartitionInfo(commonExtension, Irp);
            return;
        }

        case IOCTL_DISK_IS_WRITABLE: {
            
            TraceLog((CdromDebugWarning,
                        "CdRomStartIo: DiskIsWritable (%p) - returning %s\n",
                        Irp, (cdData->Mmc.WriteAllowed ? "TRUE" : "false")));
            
            ASSERT(irp2);
            ASSERT(senseBuffer);
            ASSERT(srb);

            ExFreePool(srb);
            ExFreePool(senseBuffer);
            IoFreeIrp(irp2);

            Irp->IoStatus.Information = 0;
            if (cdData->Mmc.WriteAllowed) {
                Irp->IoStatus.Status = STATUS_SUCCESS;
            } else {
                Irp->IoStatus.Status = STATUS_MEDIA_WRITE_PROTECTED;
            }
            CdRomCompleteIrpAndStartNextPacketSafely(Fdo, Irp);
            return;
        }

        default: {

            UCHAR uniqueAddress;

            //
            // Just complete the request - CdRomClassIoctlCompletion will take
            // care of it for us 
            //
            // NOTE: THIS IS A SYNCHRONIZATION METHOD!!!
            //

            //
            // Acquire a new copy of the lock so that ClassCompleteRequest
            // doesn't get confused when we complete the other request while
            // holding the lock.
            //

            //
            // NOTE: CdRomDeviceControlDispatch/CdRomDeviceControlCompletion
            //       wait for the event and eventually calls
            //       IoStartNextPacket()
            //

            ASSERT(irp2);
            ASSERT(senseBuffer);
            ASSERT(srb);

            ExFreePool(srb);
            ExFreePool(senseBuffer);
            IoFreeIrp(irp2);



            ClassAcquireRemoveLock(Fdo, (PIRP)&uniqueAddress);
            ClassReleaseRemoveLock(Fdo, Irp);
            ClassCompleteRequest(Fdo, Irp, IO_NO_INCREMENT);
            ClassReleaseRemoveLock(Fdo, (PIRP)&uniqueAddress);
            return;
        }

        } // end switch()
    } else if (currentIrpStack->MajorFunction == IRP_MJ_SHUTDOWN ||
               currentIrpStack->MajorFunction == IRP_MJ_FLUSH_BUFFERS) {

        currentIrpStack->Parameters.Others.Argument1 = 0;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        CdRomShutdownFlushCompletion(Fdo, NULL, Irp);
        return;

    }

    //
    // If a read or an unhandled IRP_MJ_XX, end up here. The unhandled IRP_MJ's
    // are expected and composed of AutoRun Irps, at present.
    //

    IoCallDriver(commonExtension->LowerDeviceObject, Irp);
    return;
}


NTSTATUS
CdRomReadWriteVerification(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the entry called by the I/O system for read requests.
    It builds the SRB and sends it to the port driver.

Arguments:

    DeviceObject - the system object for the device.
    Irp - IRP involved.

Return Value:

    NT Status

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION  currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG               transferByteCount = currentIrpStack->Parameters.Read.Length;
    LARGE_INTEGER       startingOffset = currentIrpStack->Parameters.Read.ByteOffset;

    PCDROM_DATA         cdData = (PCDROM_DATA)(commonExtension->DriverData);

    SCSI_REQUEST_BLOCK  srb;
    PCDB                cdb = (PCDB)srb.Cdb;
    NTSTATUS            status;

    PAGED_CODE();

    //
    // note: we are no longer failing write commands immediately
    //       they are now failed in StartIo based upon media ability
    //

    //
    // If the cd is playing music then reject this request.
    //

    if (PLAY_ACTIVE(fdoExtension)) {
        Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
        return STATUS_DEVICE_BUSY;
    }

    //
    // Verify parameters of this request.
    // Check that ending sector is on disc and
    // that number of bytes to transfer is a multiple of
    // the sector size.
    //

    startingOffset.QuadPart = currentIrpStack->Parameters.Read.ByteOffset.QuadPart +
                              transferByteCount;

    if (!fdoExtension->DiskGeometry.BytesPerSector) {
        fdoExtension->DiskGeometry.BytesPerSector = 2048;
    }

    if ((startingOffset.QuadPart > commonExtension->PartitionLength.QuadPart) ||
        (transferByteCount & fdoExtension->DiskGeometry.BytesPerSector - 1)) {

        //
        // Fail request with status of invalid parameters.
        //

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

        return STATUS_INVALID_PARAMETER;
    }


    return STATUS_SUCCESS;

} // end CdRomReadWriteVerification()


NTSTATUS
CdRomSwitchModeCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation(Irp);
    PCDROM_DATA         cdData = (PCDROM_DATA)(commonExtension->DriverData);
    BOOLEAN             use6Byte = TEST_FLAG(cdData->XAFlags, XA_USE_6_BYTE);
    PIO_STACK_LOCATION  realIrpStack;
    PIO_STACK_LOCATION  realIrpNextStack;
    PSCSI_REQUEST_BLOCK srb     = Context;
    PIRP                realIrp = NULL;
    NTSTATUS            status;
    BOOLEAN             retry;

    //
    // Extract the 'real' irp from the irpstack.
    //

    realIrp = (PIRP) irpStack->Parameters.Others.Argument2;
    realIrpStack = IoGetCurrentIrpStackLocation(realIrp);
    realIrpNextStack = IoGetNextIrpStackLocation(realIrp);

    //
    // Check SRB status for success of completing request.
    //

    if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        ULONG retryInterval;

        TraceLog((CdromDebugTrace,
                    "CdRomSetVolumeIntermediateCompletion: Irp %p, Srb %p, Real Irp %p\n",
                    Irp,
                    srb,
                    realIrp));

        //
        // Release the queue if it is frozen.
        //

        if (srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {
            ClassReleaseQueue(DeviceObject);
        }


        retry = ClassInterpretSenseInfo(DeviceObject,
                                        srb,
                                        irpStack->MajorFunction,
                                        irpStack->Parameters.DeviceIoControl.IoControlCode,
                                        MAXIMUM_RETRIES - ((ULONG)(ULONG_PTR)realIrpNextStack->Parameters.Others.Argument1),
                                        &status,
                                        &retryInterval);

        //
        // If the status is verified required and the this request
        // should bypass verify required then retry the request.
        //

        if (realIrpStack->Flags & SL_OVERRIDE_VERIFY_VOLUME &&
            status == STATUS_VERIFY_REQUIRED) {

            status = STATUS_IO_DEVICE_ERROR;
            retry = TRUE;
        }

        if (retry && ((ULONG)(ULONG_PTR)realIrpNextStack->Parameters.Others.Argument1)--) {

            if (((ULONG)(ULONG_PTR)realIrpNextStack->Parameters.Others.Argument1)) {

                //
                // Retry request.
                //

                TraceLog((CdromDebugWarning,
                            "Retry request %p - Calling StartIo\n", Irp));


                ExFreePool(srb->SenseInfoBuffer);
                ExFreePool(srb->DataBuffer);
                ExFreePool(srb);
                if (Irp->MdlAddress) {
                    IoFreeMdl(Irp->MdlAddress);
                }

                IoFreeIrp(Irp);

                //
                // Call StartIo directly since IoStartNextPacket hasn't been called,
                // the serialisation is still intact.
                //

                CdRomRetryRequest(fdoExtension,
                                  realIrp,
                                  retryInterval,
                                  FALSE);

                return STATUS_MORE_PROCESSING_REQUIRED;

            }

            //
            // Exhausted retries. Fall through and complete the request with the appropriate status.
            //
        }
    } else {

        //
        // Set status for successful request.
        //

        status = STATUS_SUCCESS;
        
    }

    if (NT_SUCCESS(status)) {

        ULONG sectorSize, startingSector, transferByteCount;
        PCDB cdb;

        //
        // Update device ext. to show which mode we are currently using.
        //

        sectorSize =  cdData->BlockDescriptor.BlockLength[0] << 16;
        sectorSize |= (cdData->BlockDescriptor.BlockLength[1] << 8);
        sectorSize |= (cdData->BlockDescriptor.BlockLength[2]);

        cdData->RawAccess = (sectorSize == RAW_SECTOR_SIZE) ? TRUE : FALSE;

        //
        // Free the old data buffer, mdl.
        // reuse the SenseInfoBuffer and Srb
        //

        ExFreePool(srb->DataBuffer);
        IoFreeMdl(Irp->MdlAddress);
        IoFreeIrp(Irp);

        //
        // rebuild the srb.
        //

        cdb = (PCDB)srb->Cdb;
        RtlZeroMemory(cdb, CDB12GENERIC_LENGTH);


        if (cdData->RawAccess) {

            PRAW_READ_INFO rawReadInfo =
                               (PRAW_READ_INFO)realIrpStack->Parameters.DeviceIoControl.Type3InputBuffer;

            ULONG maximumTransferLength;
            ULONG transferPages;
            UCHAR min, sec, frame;

            //
            // Calculate starting offset.
            //

            startingSector = (ULONG)(rawReadInfo->DiskOffset.QuadPart >> fdoExtension->SectorShift);
            transferByteCount  = rawReadInfo->SectorCount * RAW_SECTOR_SIZE;
            maximumTransferLength = fdoExtension->AdapterDescriptor->MaximumTransferLength;
            transferPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(MmGetMdlVirtualAddress(realIrp->MdlAddress),
                                                           transferByteCount);

            //
            // Determine if request is within limits imposed by miniport.
            // If the request is larger than the miniport's capabilities, split it.
            //

            if (transferByteCount > maximumTransferLength ||
                transferPages > fdoExtension->AdapterDescriptor->MaximumPhysicalPages) {


                ExFreePool(srb->SenseInfoBuffer);
                ExFreePool(srb);
                realIrp->IoStatus.Information = 0;
                realIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;

                BAIL_OUT(realIrp);
                CdRomCompleteIrpAndStartNextPacketSafely(DeviceObject, realIrp);
                return STATUS_MORE_PROCESSING_REQUIRED;
            }

            srb->OriginalRequest = realIrp;
            srb->SrbFlags = fdoExtension->SrbFlags;
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);

            srb->DataTransferLength = transferByteCount;
            srb->TimeOutValue = fdoExtension->TimeOutValue;
            srb->CdbLength = 10;
            srb->DataBuffer = MmGetMdlVirtualAddress(realIrp->MdlAddress);

            if (rawReadInfo->TrackMode == CDDA) {
                if (TEST_FLAG(cdData->XAFlags, XA_PLEXTOR_CDDA)) {

                    srb->CdbLength = 12;

                    cdb->PLXTR_READ_CDDA.LogicalBlockByte3  = (UCHAR) (startingSector & 0xFF);
                    cdb->PLXTR_READ_CDDA.LogicalBlockByte2  = (UCHAR) ((startingSector >>  8) & 0xFF);
                    cdb->PLXTR_READ_CDDA.LogicalBlockByte1  = (UCHAR) ((startingSector >> 16) & 0xFF);
                    cdb->PLXTR_READ_CDDA.LogicalBlockByte0  = (UCHAR) ((startingSector >> 24) & 0xFF);

                    cdb->PLXTR_READ_CDDA.TransferBlockByte3 = (UCHAR) (rawReadInfo->SectorCount & 0xFF);
                    cdb->PLXTR_READ_CDDA.TransferBlockByte2 = (UCHAR) (rawReadInfo->SectorCount >> 8);
                    cdb->PLXTR_READ_CDDA.TransferBlockByte1 = 0;
                    cdb->PLXTR_READ_CDDA.TransferBlockByte0 = 0;

                    cdb->PLXTR_READ_CDDA.SubCode = 0;
                    cdb->PLXTR_READ_CDDA.OperationCode = 0xD8;

                } else if (TEST_FLAG(cdData->XAFlags, XA_NEC_CDDA)) {

                    cdb->NEC_READ_CDDA.LogicalBlockByte3  = (UCHAR) (startingSector & 0xFF);
                    cdb->NEC_READ_CDDA.LogicalBlockByte2  = (UCHAR) ((startingSector >>  8) & 0xFF);
                    cdb->NEC_READ_CDDA.LogicalBlockByte1  = (UCHAR) ((startingSector >> 16) & 0xFF);
                    cdb->NEC_READ_CDDA.LogicalBlockByte0  = (UCHAR) ((startingSector >> 24) & 0xFF);

                    cdb->NEC_READ_CDDA.TransferBlockByte1 = (UCHAR) (rawReadInfo->SectorCount & 0xFF);
                    cdb->NEC_READ_CDDA.TransferBlockByte0 = (UCHAR) (rawReadInfo->SectorCount >> 8);

                    cdb->NEC_READ_CDDA.OperationCode = 0xD4;
                }
            } else {
                cdb->CDB10.TransferBlocksMsb  = (UCHAR) (rawReadInfo->SectorCount >> 8);
                cdb->CDB10.TransferBlocksLsb  = (UCHAR) (rawReadInfo->SectorCount & 0xFF);

                cdb->CDB10.LogicalBlockByte3  = (UCHAR) (startingSector & 0xFF);
                cdb->CDB10.LogicalBlockByte2  = (UCHAR) ((startingSector >>  8) & 0xFF);
                cdb->CDB10.LogicalBlockByte1  = (UCHAR) ((startingSector >> 16) & 0xFF);
                cdb->CDB10.LogicalBlockByte0  = (UCHAR) ((startingSector >> 24) & 0xFF);

                cdb->CDB10.OperationCode = SCSIOP_READ;
            }

            srb->SrbStatus = srb->ScsiStatus = 0;


            irpStack = IoGetNextIrpStackLocation(realIrp);
            irpStack->MajorFunction = IRP_MJ_SCSI;
            irpStack->Parameters.Scsi.Srb = srb;

            if (!(irpStack->Parameters.Others.Argument1)) {

                //
                // Only jam this in if it doesn't exist. The completion routines can
                // call StartIo directly in the case of retries and resetting it will
                // cause infinite loops.
                //

                irpStack->Parameters.Others.Argument1 = (PVOID) MAXIMUM_RETRIES;
            }

            //
            // Set up IoCompletion routine address.
            //

            IoSetCompletionRoutine(realIrp,
                                   CdRomXACompletion,
                                   srb,
                                   TRUE,
                                   TRUE,
                                   TRUE);
        } else {

            PSTORAGE_ADAPTER_DESCRIPTOR adapterDescriptor;
            ULONG maximumTransferLength;
            ULONG transferPages;

            //
            // a writable device must be MMC compliant, which supports
            // READ_CD commands, so writes and mode switching should
            // never occur on the same device.
            //

            ASSERT(realIrpStack->MajorFunction != IRP_MJ_WRITE);

            //
            // free the SRB and SenseInfoBuffer since they aren't used
            // by either ClassBuildRequest() nor ClassSplitRequest().
            //

            ExFreePool(srb->SenseInfoBuffer);
            ExFreePool(srb);
            
            //
            // Back to cooked sectors. Build and send a normal read.
            // The real work for setting offsets was done in startio.
            //
            
            adapterDescriptor =
                commonExtension->PartitionZeroExtension->AdapterDescriptor;
            maximumTransferLength = adapterDescriptor->MaximumTransferLength;
            transferPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                                MmGetMdlVirtualAddress(realIrp->MdlAddress),
                                realIrpStack->Parameters.Read.Length);

            if ((realIrpStack->Parameters.Read.Length > maximumTransferLength) ||
                (transferPages > adapterDescriptor->MaximumPhysicalPages)) {

                ULONG maxPages = adapterDescriptor->MaximumPhysicalPages;

                if (maxPages != 0) {
                    maxPages --; // to account for page boundaries
                }

                TraceLog((CdromDebugTrace,
                            "CdromSwitchModeCompletion: Request greater than "
                            " maximum\n"));
                TraceLog((CdromDebugTrace,
                            "CdromSwitchModeCompletion: Maximum is %lx\n",
                            maximumTransferLength));
                TraceLog((CdromDebugTrace,
                            "CdromSwitchModeCompletion: Byte count is %lx\n",
                            realIrpStack->Parameters.Read.Length));

                //
                // Check that the maximum transfer length fits within
                // the maximum number of pages the device can handle.
                //
                
                if (maximumTransferLength > maxPages << PAGE_SHIFT) {
                    maximumTransferLength = maxPages << PAGE_SHIFT;
                }

                //
                // Check that maximum transfer size is not zero
                //

                if (maximumTransferLength == 0) {
                    maximumTransferLength = PAGE_SIZE;
                }

                //
                // Request needs to be split. Completion of each portion
                // of the request will fire off the next portion. The final
                // request will signal Io to send a new request.
                //

                ClassSplitRequest(DeviceObject, realIrp, maximumTransferLength);
                return STATUS_MORE_PROCESSING_REQUIRED;

            } else {

                //
                // Build SRB and CDB for this IRP.
                //

                ClassBuildRequest(DeviceObject, realIrp);

            }
        }

        //
        // Call the port driver.
        //

        IoCallDriver(commonExtension->LowerDeviceObject, realIrp);

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    //
    // Update device Extension flags to indicate that XA isn't supported.
    //

    TraceLog((CdromDebugWarning,
                "Device Cannot Support CDDA (but tested positive) "
                "Now Clearing CDDA flags for FDO %p\n", DeviceObject));
    SET_FLAG(cdData->XAFlags, XA_NOT_SUPPORTED);
    CLEAR_FLAG(cdData->XAFlags, XA_PLEXTOR_CDDA);
    CLEAR_FLAG(cdData->XAFlags, XA_NEC_CDDA);

    //
    // Deallocate srb and sense buffer.
    //

    if (srb) {
        if (srb->DataBuffer) {
            ExFreePool(srb->DataBuffer);
        }
        if (srb->SenseInfoBuffer) {
            ExFreePool(srb->SenseInfoBuffer);
        }
        ExFreePool(srb);
    }

    if (Irp->PendingReturned) {
      IoMarkIrpPending(Irp);
    }

    if (realIrp->PendingReturned) {
        IoMarkIrpPending(realIrp);
    }

    if (Irp->MdlAddress) {
        IoFreeMdl(Irp->MdlAddress);
    }

    IoFreeIrp(Irp);

    //
    // Set status in completing IRP.
    //

    realIrp->IoStatus.Status = status;

    //
    // Set the hard error if necessary.
    //

    if (!NT_SUCCESS(status) && IoIsErrorUserInduced(status)) {

        //
        // Store DeviceObject for filesystem, and clear
        // in IoStatus.Information field.
        //

        if (realIrp->Tail.Overlay.Thread) {
            IoSetHardErrorOrVerifyDevice(realIrp, DeviceObject);
        }
        realIrp->IoStatus.Information = 0;
    }

    CdRomCompleteIrpAndStartNextPacketSafely(DeviceObject, realIrp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
ScanForSpecialHandler(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    ULONG_PTR HackFlags
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension;
    PCDROM_DATA cdData;

    PAGED_CODE();

    CLEAR_FLAG(HackFlags, CDROM_HACK_INVALID_FLAGS);
    
    commonExtension = &(FdoExtension->CommonExtension);
    cdData = (PCDROM_DATA)(commonExtension->DriverData);
    cdData->HackFlags = HackFlags;

    return;
}

VOID
ScanForSpecial(
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This function checks to see if an SCSI logical unit requires an special
    initialization or error processing.

Arguments:

    DeviceObject - Supplies the device object to be tested.

    InquiryData - Supplies the inquiry data returned by the device of interest.

    PortCapabilities - Supplies the capabilities of the device object.

Return Value:

    None.

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension;
    PCDROM_DATA cdData;
    
    PAGED_CODE();

    fdoExtension = DeviceObject->DeviceExtension;
    commonExtension = DeviceObject->DeviceExtension;
    cdData = (PCDROM_DATA)(commonExtension->DriverData);

    
    //
    // set our hack flags
    //

    ClassScanForSpecial(fdoExtension, CdromHackItems, ScanForSpecialHandler);

    //
    // All CDRom's can ignore the queue lock failure for power operations
    // and do not require handling the SpinUp case (unknown result of sending
    // a cdrom a START_UNIT command -- may eject disks?)
    //
    // We send the stop command mostly to stop outstanding asynch operations
    // (like audio playback) from running when the system is powered off.
    // Because of this and the unlikely chance that a PLAY command will be
    // sent in the window between the STOP and the time the machine powers down
    // we don't require queue locks.  This is important because without them
    // classpnp's power routines will send the START_STOP_UNIT command to the
    // device whether or not it supports locking (atapi does not support locking
    // and if we requested them we would end up not stopping audio on atapi
    // devices).
    //

    SET_FLAG(fdoExtension->ScanForSpecialFlags, CLASS_SPECIAL_DISABLE_SPIN_UP);
    SET_FLAG(fdoExtension->ScanForSpecialFlags, CLASS_SPECIAL_NO_QUEUE_LOCK);

    if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_HITACHI_1750)
        && ( fdoExtension->AdapterDescriptor->AdapterUsesPio )
        ) {

        //
        // Read-ahead must be disabled in order to get this cdrom drive
        // to work on scsi adapters that use PIO.
        //


        TraceLog((CdromDebugWarning,
                    "CdRom ScanForSpecial:  Found Hitachi CDR-1750S.\n"));

        //
        // Setup an error handler to reinitialize the cd rom after it is reset.
        //

        cdData->ErrorHandler = HitachiProcessError;

        //
        // Lock down the hitachi error processing code.
        //

        MmLockPagableCodeSection(HitachiProcessError);
        SET_FLAG(cdData->HackFlags, CDROM_HACK_LOCKED_PAGES);


    } else if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_TOSHIBA_SD_W1101)) {

        TraceLog((CdromDebugError,
                    "CdRom ScanForSpecial: Found Toshiba SD-W1101 DVD-RAM "
                    "-- This drive will *NOT* support DVD-ROM playback.\n"));

    } else if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_HITACHI_GD_2000)) {

        TraceLog((CdromDebugWarning,
                    "CdRom ScanForSpecial: Found Hitachi GD-2000\n"));

        //
        // Setup an error handler to spin up the drive when it idles out
        // since it seems to like to fail to spin itself back up on its
        // own for a REPORT_KEY command.  It may also lose the AGIDs that
        // it has given, which will result in DVD playback failures.
        // This routine will just do what it can...
        //

        cdData->ErrorHandler = HitachiProcessErrorGD2000;

        //
        // this drive may require START_UNIT commands to spin
        // the drive up when it's spun itself down.
        //

        SET_FLAG(fdoExtension->DeviceFlags, DEV_SAFE_START_UNIT);

        //
        // Lock down the hitachi error processing code.
        //

        MmLockPagableCodeSection(HitachiProcessErrorGD2000);
        SET_FLAG(cdData->HackFlags, CDROM_HACK_LOCKED_PAGES);

    } else if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_FUJITSU_FMCD_10x)) {

        //
        // When Read command is issued to FMCD-101 or FMCD-102 and there is a music
        // cd in it. It takes longer time than SCSI_CDROM_TIMEOUT before returning
        // error status.
        //

        fdoExtension->TimeOutValue = 20;

    } else if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_DEC_RRD)) {

        PMODE_PARM_READ_WRITE_DATA modeParameters;
        SCSI_REQUEST_BLOCK         srb;
        PCDB                       cdb;
        NTSTATUS                   status;


        TraceLog((CdromDebugWarning,
                    "CdRom ScanForSpecial:  Found DEC RRD.\n"));

        cdData->IsDecRrd = TRUE;

        //
        // Setup an error handler to reinitialize the cd rom after it is reset?
        //
        //commonExtension->DevInfo->ClassError = DecRrdProcessError;

        //
        // Found a DEC RRD cd-rom.  These devices do not pass MS HCT
        // multi-media tests because the DEC firmware modifieds the block
        // from the PC-standard 2K to 512.  Change the block transfer size
        // back to the PC-standard 2K by using a mode select command.
        //

        modeParameters = ExAllocatePoolWithTag(NonPagedPool,
                                               sizeof(MODE_PARM_READ_WRITE_DATA),
                                               CDROM_TAG_MODE_DATA
                                               );
        if (modeParameters == NULL) {
            return;
        }

        RtlZeroMemory(modeParameters, sizeof(MODE_PARM_READ_WRITE_DATA));
        RtlZeroMemory(&srb,           sizeof(SCSI_REQUEST_BLOCK));

        //
        // Set the block length to 2K.
        //

        modeParameters->ParameterListHeader.BlockDescriptorLength =
                sizeof(MODE_PARAMETER_BLOCK);

        //
        // Set block length to 2K (0x0800) in Parameter Block.
        //

        modeParameters->ParameterListBlock.BlockLength[0] = 0x00; //MSB
        modeParameters->ParameterListBlock.BlockLength[1] = 0x08;
        modeParameters->ParameterListBlock.BlockLength[2] = 0x00; //LSB

        //
        // Build the mode select CDB.
        //

        srb.CdbLength = 6;
        srb.TimeOutValue = fdoExtension->TimeOutValue;

        cdb = (PCDB)srb.Cdb;
        cdb->MODE_SELECT.PFBit               = 1;
        cdb->MODE_SELECT.OperationCode       = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.ParameterListLength = HITACHI_MODE_DATA_SIZE;

        //
        // Send the request to the device.
        //

        status = ClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         modeParameters,
                                         sizeof(MODE_PARM_READ_WRITE_DATA),
                                         TRUE);

        if (!NT_SUCCESS(status)) {
            TraceLog((CdromDebugWarning,
                        "CdRom ScanForSpecial: Setting DEC RRD to 2K block"
                        "size failed [%x]\n", status));
        }
        ExFreePool(modeParameters);

    } else if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_TOSHIBA_XM_3xx)) {

        SCSI_REQUEST_BLOCK srb;
        PCDB               cdb;
        ULONG              length;
        PUCHAR             buffer;
        NTSTATUS           status;

        //
        // Set the density code and the error handler.
        //

        length = (sizeof(MODE_READ_RECOVERY_PAGE) + MODE_BLOCK_DESC_LENGTH + MODE_HEADER_LENGTH);

        RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

        //
        // Build the MODE SENSE CDB.
        //

        srb.CdbLength = 6;
        cdb = (PCDB)srb.Cdb;

        //
        // Set timeout value from device extension.
        //

        srb.TimeOutValue = fdoExtension->TimeOutValue;

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = 0x1;
        // NOTE: purposely not setting DBD because it is what is needed.
        cdb->MODE_SENSE.AllocationLength = (UCHAR)length;

        buffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                (sizeof(MODE_READ_RECOVERY_PAGE) + MODE_BLOCK_DESC_LENGTH + MODE_HEADER_LENGTH),
                                CDROM_TAG_MODE_DATA);
        if (!buffer) {
            return;
        }

        status = ClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         buffer,
                                         length,
                                         FALSE);

        ((PERROR_RECOVERY_DATA)buffer)->BlockDescriptor.DensityCode = 0x83;
        ((PERROR_RECOVERY_DATA)buffer)->Header.ModeDataLength = 0x0;

        RtlCopyMemory(&cdData->Header, buffer, sizeof(ERROR_RECOVERY_DATA));

        RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

        //
        // Build the MODE SENSE CDB.
        //

        srb.CdbLength = 6;
        cdb = (PCDB)srb.Cdb;

        //
        // Set timeout value from device extension.
        //

        srb.TimeOutValue = fdoExtension->TimeOutValue;

        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = 1;
        cdb->MODE_SELECT.ParameterListLength = (UCHAR)length;

        status = ClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         buffer,
                                         length,
                                         TRUE);

        if (!NT_SUCCESS(status)) {
            TraceLog((CdromDebugWarning,
                        "Cdrom.ScanForSpecial: Setting density code on Toshiba failed [%x]\n",
                        status));
        }

        cdData->ErrorHandler = ToshibaProcessError;

        //
        // Lock down the toshiba error section.
        //

        MmLockPagableCodeSection(ToshibaProcessError);
        SET_FLAG(cdData->HackFlags, CDROM_HACK_LOCKED_PAGES);

        ExFreePool(buffer);

    }

    //
    // Determine special CD-DA requirements.
    //

    if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_READ_CD_SUPPORTED)) {

        SET_FLAG(cdData->XAFlags, XA_USE_READ_CD);

    } else if (!TEST_FLAG(cdData->XAFlags, XA_USE_READ_CD)) {

        if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_PLEXTOR_CDDA)) {
            SET_FLAG(cdData->XAFlags, XA_PLEXTOR_CDDA);
        } else if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_NEC_CDDA)) {
            SET_FLAG(cdData->XAFlags, XA_NEC_CDDA);
        }

    }

    if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_LOCKED_PAGES)) {
        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_ERROR_LEVEL,
                   "Locking pages for error handler\n"));
    }

    
    return;
}


VOID
HitachiProcessErrorGD2000(
    PDEVICE_OBJECT Fdo,
    PSCSI_REQUEST_BLOCK OriginalSrb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )
/*++

Routine Description:

   This routine checks the type of error.  If the error suggests that the
   drive has spun down and cannot reinitialize itself, send a
   START_UNIT or READ to the device.  This will force the drive to spin
   up.  This drive also loses the AGIDs it has granted when it spins down,
   which may result in playback failure the first time around.

Arguments:

    DeviceObject - Supplies a pointer to the device object.

    Srb - Supplies a pointer to the failing Srb.

    Status - return the final status for this command?

    Retry - return if the command should be retried.

Return Value:

    None.

--*/
{
    PSENSE_DATA         senseBuffer = OriginalSrb->SenseInfoBuffer;

    UNREFERENCED_PARAMETER(Status);
    UNREFERENCED_PARAMETER(Retry);

    if (!TEST_FLAG(OriginalSrb->SrbStatus, SRB_STATUS_AUTOSENSE_VALID)) {
        return;
    }

    if (((senseBuffer->SenseKey & 0xf) == SCSI_SENSE_HARDWARE_ERROR) &&
        (senseBuffer->AdditionalSenseCode == 0x44)) {

        PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
        PIRP                irp;
        PIO_STACK_LOCATION  irpStack;
        PCOMPLETION_CONTEXT context;
        PSCSI_REQUEST_BLOCK newSrb;
        PCDB                cdb;

        TraceLog((CdromDebugWarning,
                    "HitachiProcessErrorGD2000 (%p) => Internal Target "
                    "Failure Detected -- spinning up drive\n", Fdo));

        //
        // the request should be retried because the device isn't ready
        //

        *Retry = TRUE;
        *Status = STATUS_DEVICE_NOT_READY;

        //
        // send a START_STOP unit to spin up the drive
        // NOTE: this temporarily violates the StartIo serialization
        //       mechanism, but the completion routine on this will NOT
        //       call StartNextPacket(), so it's a temporary disruption
        //       of the serialization only.
        //

        ClassSendStartUnit(Fdo);

    }

    return;
}


VOID
HitachiProcessError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )
/*++

Routine Description:

   This routine checks the type of error.  If the error indicates CD-ROM the
   CD-ROM needs to be reinitialized then a Mode sense command is sent to the
   device.  This command disables read-ahead for the device.

Arguments:

    DeviceObject - Supplies a pointer to the device object.

    Srb - Supplies a pointer to the failing Srb.

    Status - Not used.

    Retry - Not used.

Return Value:

    None.

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PSENSE_DATA         senseBuffer = Srb->SenseInfoBuffer;
    LARGE_INTEGER       largeInt;
    PUCHAR              modePage;
    PIO_STACK_LOCATION  irpStack;
    PIRP                irp;
    PSCSI_REQUEST_BLOCK srb;
    PCOMPLETION_CONTEXT context;
    PCDB                cdb;
    ULONG_PTR            alignment;

    UNREFERENCED_PARAMETER(Status);
    UNREFERENCED_PARAMETER(Retry);

    largeInt.QuadPart = (LONGLONG) 1;

    //
    // Check the status.  The initialization command only needs to be sent
    // if UNIT ATTENTION is returned.
    //

    if (!(Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID)) {

        //
        // The drive does not require reinitialization.
        //

        return;
    }

    //
    // Found an HITACHI cd-rom that does not work with PIO
    // adapters when read-ahead is enabled.  Read-ahead is disabled by
    // a mode select command.  The mode select page code is zero and the
    // length is 6 bytes.  All of the other bytes should be zero.
    //

    if ((senseBuffer->SenseKey & 0xf) == SCSI_SENSE_UNIT_ATTENTION) {

        TraceLog((CdromDebugWarning,
                    "HitachiProcessError: Reinitializing the CD-ROM.\n"));

        //
        // Send the special mode select command to disable read-ahead
        // on the CD-ROM reader.
        //

        alignment = DeviceObject->AlignmentRequirement ?
            DeviceObject->AlignmentRequirement : 1;

        context = ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(COMPLETION_CONTEXT) +  HITACHI_MODE_DATA_SIZE + (ULONG)alignment,
            CDROM_TAG_HITACHI_ERROR
            );

        if (context == NULL) {

            //
            // If there is not enough memory to fulfill this request,
            // simply return. A subsequent retry will fail and another
            // chance to start the unit.
            //

            return;
        }

        context->DeviceObject = DeviceObject;
        srb = &context->Srb;

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

        //
        // Write length to SRB.
        //

        srb->Length = SCSI_REQUEST_BLOCK_SIZE;

        //
        // Set up SCSI bus address.
        //

        srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
        srb->TimeOutValue = fdoExtension->TimeOutValue;

        //
        // Set the transfer length.
        //

        srb->DataTransferLength = HITACHI_MODE_DATA_SIZE;
        srb->SrbFlags = fdoExtension->SrbFlags;
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_OUT);
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_AUTOSENSE);
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);

        //
        // The data buffer must be aligned.
        //

        srb->DataBuffer = (PVOID) (((ULONG_PTR) (context + 1) + (alignment - 1)) &
            ~(alignment - 1));


        //
        // Build the HITACHI read-ahead mode select CDB.
        //

        srb->CdbLength = 6;
        cdb = (PCDB)srb->Cdb;
        cdb->MODE_SENSE.LogicalUnitNumber = srb->Lun;
        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SENSE.AllocationLength = HITACHI_MODE_DATA_SIZE;

        //
        // Initialize the mode sense data.
        //

        modePage = srb->DataBuffer;

        RtlZeroMemory(modePage, HITACHI_MODE_DATA_SIZE);

        //
        // Set the page length field to 6.
        //

        modePage[5] = 6;

        //
        // Build the asynchronous request to be sent to the port driver.
        //

        irp = IoBuildAsynchronousFsdRequest(IRP_MJ_WRITE,
                                           DeviceObject,
                                           srb->DataBuffer,
                                           srb->DataTransferLength,
                                           &largeInt,
                                           NULL);

        if (irp == NULL) {

            //
            // If there is not enough memory to fulfill this request,
            // simply return. A subsequent retry will fail and another
            // chance to start the unit.
            //

            ExFreePool(context);
            return;
        }

        ClassAcquireRemoveLock(DeviceObject, irp);

        IoSetCompletionRoutine(irp,
                   (PIO_COMPLETION_ROUTINE)ClassAsynchronousCompletion,
                   context,
                   TRUE,
                   TRUE,
                   TRUE);

        irpStack = IoGetNextIrpStackLocation(irp);

        irpStack->MajorFunction = IRP_MJ_SCSI;

        srb->OriginalRequest = irp;

        //
        // Save SRB address in next stack for port driver.
        //

        irpStack->Parameters.Scsi.Srb = (PVOID)srb;

        //
        // Set up IRP Address.
        //

        (VOID)IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp);

    }
}


NTSTATUS
ToshibaProcessErrorCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )

/*++

Routine Description:

    Completion routine for the ClassError routine to handle older Toshiba units
    that require setting the density code.

Arguments:

    DeviceObject - Supplies a pointer to the device object.

    Irp - Pointer to irp created to set the density code.

    Context - Supplies a pointer to the Mode Select Srb.


Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{

    PSCSI_REQUEST_BLOCK srb = Context;

    //
    // Free all of the allocations.
    //

    ClassReleaseRemoveLock(DeviceObject, Irp);

    ExFreePool(srb->DataBuffer);
    ExFreePool(srb);
    IoFreeMdl(Irp->MdlAddress);
    IoFreeIrp(Irp);

    //
    // Indicate the I/O system should stop processing the Irp completion.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
ToshibaProcessError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

   This routine checks the type of error.  If the error indicates a unit attention,
   the density code needs to be set via a Mode select command.

Arguments:

    DeviceObject - Supplies a pointer to the device object.

    Srb - Supplies a pointer to the failing Srb.

    Status - Not used.

    Retry - Not used.

Return Value:

    None.

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PCDROM_DATA         cdData = (PCDROM_DATA)(commonExtension->DriverData);
    PSENSE_DATA         senseBuffer = Srb->SenseInfoBuffer;
    PIO_STACK_LOCATION  irpStack;
    PIRP                irp;
    PSCSI_REQUEST_BLOCK srb;
    ULONG               length;
    PCDB                cdb;
    PUCHAR              dataBuffer;


    if (!(Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID)) {
        return;
    }

    //
    // The Toshiba's require the density code to be set on power up and media changes.
    //

    if ((senseBuffer->SenseKey & 0xf) == SCSI_SENSE_UNIT_ATTENTION) {


        irp = IoAllocateIrp((CCHAR)(DeviceObject->StackSize+1),
                              FALSE);

        if (!irp) {
            return;
        }

        srb = ExAllocatePoolWithTag(NonPagedPool,
                                    sizeof(SCSI_REQUEST_BLOCK),
                                    CDROM_TAG_TOSHIBA_ERROR);
        if (!srb) {
            IoFreeIrp(irp);
            return;
        }


        length = sizeof(ERROR_RECOVERY_DATA);
        dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                           length,
                                           CDROM_TAG_TOSHIBA_ERROR);
        if (!dataBuffer) {
            ExFreePool(srb);
            IoFreeIrp(irp);
            return;
        }

        irp->MdlAddress = IoAllocateMdl(dataBuffer,
                                        length,
                                        FALSE,
                                        FALSE,
                                        (PIRP) NULL);

        if (!irp->MdlAddress) {
            ExFreePool(srb);
            ExFreePool(dataBuffer);
            IoFreeIrp(irp);
            return;
        }

        //
        // Prepare the MDL
        //

        MmBuildMdlForNonPagedPool(irp->MdlAddress);

        RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

        srb->DataBuffer = dataBuffer;
        cdb = (PCDB)srb->Cdb;

        //
        // Set up the irp.
        //

        IoSetNextIrpStackLocation(irp);
        irp->IoStatus.Status = STATUS_SUCCESS;
        irp->IoStatus.Information = 0;
        irp->Flags = 0;
        irp->UserBuffer = NULL;

        //
        // Save the device object and irp in a private stack location.
        //

        irpStack = IoGetCurrentIrpStackLocation(irp);
        irpStack->DeviceObject = DeviceObject;

        //
        // Construct the IRP stack for the lower level driver.
        //

        irpStack = IoGetNextIrpStackLocation(irp);
        irpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_SCSI_EXECUTE_OUT;
        irpStack->Parameters.Scsi.Srb = srb;

        IoSetCompletionRoutine(irp,
                               ToshibaProcessErrorCompletion,
                               srb,
                               TRUE,
                               TRUE,
                               TRUE);

        ClassAcquireRemoveLock(DeviceObject, irp);

        srb->Length = SCSI_REQUEST_BLOCK_SIZE;
        srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
        srb->SrbStatus = srb->ScsiStatus = 0;
        srb->NextSrb = 0;
        srb->OriginalRequest = irp;
        srb->SenseInfoBufferLength = 0;

        //
        // Set the transfer length.
        //

        srb->DataTransferLength = length;
        srb->SrbFlags = fdoExtension->SrbFlags;
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_OUT);
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_AUTOSENSE);
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE);


        srb->CdbLength = 6;
        cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
        cdb->MODE_SELECT.PFBit = 1;
        cdb->MODE_SELECT.ParameterListLength = (UCHAR)length;

        //
        // Copy the Mode page into the databuffer.
        //

        RtlCopyMemory(srb->DataBuffer, &cdData->Header, length);

        //
        // Set the density code.
        //

        ((PERROR_RECOVERY_DATA)srb->DataBuffer)->BlockDescriptor.DensityCode = 0x83;

        IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp);
    }
}


BOOLEAN
CdRomIsPlayActive(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine determines if the cd is currently playing music.

Arguments:

    DeviceObject - Device object to test.

Return Value:

    TRUE if the device is playing music.

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    IO_STATUS_BLOCK ioStatus;
    PSUB_Q_CURRENT_POSITION currentBuffer;

    PAGED_CODE();

    //
    // if we don't think it is playing audio, don't bother checking.
    //

    if (!PLAY_ACTIVE(fdoExtension)) {
        return(FALSE);
    }

    currentBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                          sizeof(SUB_Q_CURRENT_POSITION),
                                          CDROM_TAG_PLAY_ACTIVE);

    if (currentBuffer == NULL) {
        return(FALSE);
    }

    ((PCDROM_SUB_Q_DATA_FORMAT) currentBuffer)->Format = IOCTL_CDROM_CURRENT_POSITION;
    ((PCDROM_SUB_Q_DATA_FORMAT) currentBuffer)->Track = 0;

    //
    // Build the synchronous request to be sent to ourself
    // to perform the request.
    //

    ClassSendDeviceIoControlSynchronous(
        IOCTL_CDROM_READ_Q_CHANNEL,
        DeviceObject,
        currentBuffer,
        sizeof(CDROM_SUB_Q_DATA_FORMAT),
        sizeof(SUB_Q_CURRENT_POSITION),
        FALSE,
        &ioStatus);

    if (!NT_SUCCESS(ioStatus.Status)) {
        ExFreePool(currentBuffer);
        return FALSE;
    }

    //
    // should update the playactive flag here.
    //

    if (currentBuffer->Header.AudioStatus == AUDIO_STATUS_IN_PROGRESS) {
        PLAY_ACTIVE(fdoExtension) = TRUE;
    } else {
        PLAY_ACTIVE(fdoExtension) = FALSE;
    }

    ExFreePool(currentBuffer);

    return(PLAY_ACTIVE(fdoExtension));

}


VOID
CdRomTickHandler(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine handles the once per second timer provided by the
    Io subsystem.  It is used to do delayed retries for cdroms.

Arguments:

    DeviceObject - what to check.

Return Value:

    None.

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    ULONG isRemoved;

    KIRQL             oldIrql;

    PIRP              irp;
    PIRP              heldIrpList;
    PIRP              nextIrp;
    PLIST_ENTRY       listEntry;
    PCDROM_DATA       cddata;
    PIO_STACK_LOCATION irpStack;
    UCHAR             uniqueAddress;

    isRemoved = ClassAcquireRemoveLock(DeviceObject, (PIRP) &uniqueAddress);

    //
    // We stop the timer before deleting the device.  It's safe to keep going
    // if the flag value is REMOVE_PENDING because the removal thread will be
    // blocked trying to stop the timer.
    //

    ASSERT(isRemoved != REMOVE_COMPLETE);

    //
    // This routine is reasonably safe even if the device object has a pending
    // remove

    cddata = commonExtension->DriverData;

    //
    // Since cdrom is completely synchronized there can never be more than one
    // irp delayed for retry at any time.
    //

    KeAcquireSpinLock(&(cddata->DelayedRetrySpinLock), &oldIrql);

    if(cddata->DelayedRetryIrp != NULL) {

        PIRP irp = cddata->DelayedRetryIrp;

        //
        // If we've got a delayed retry at this point then there had beter
        // be an interval for it.
        //

        ASSERT(cddata->DelayedRetryInterval != 0);
        cddata->DelayedRetryInterval--;

        if(isRemoved) {

            //
            // This device is removed - flush the timer queue
            //

            cddata->DelayedRetryIrp = NULL;
            cddata->DelayedRetryInterval = 0;

            KeReleaseSpinLock(&(cddata->DelayedRetrySpinLock), oldIrql);

            ClassReleaseRemoveLock(DeviceObject, irp);
            ClassCompleteRequest(DeviceObject, irp, IO_CD_ROM_INCREMENT);

        } else if (cddata->DelayedRetryInterval == 0) {

            //
            // Submit this IRP to the lower driver.  This IRP does not
            // need to be remembered here.  It will be handled again when
            // it completes.
            //

            cddata->DelayedRetryIrp = NULL;

            KeReleaseSpinLock(&(cddata->DelayedRetrySpinLock), oldIrql);

            TraceLog((CdromDebugWarning,
                        "CdRomTickHandler: Reissuing request %p (thread = %p)\n",
                        irp,
                        irp->Tail.Overlay.Thread));

            //
            // feed this to the appropriate port driver
            //

            CdRomRerunRequest(fdoExtension, irp, cddata->DelayedRetryResend);
        } else {
            KeReleaseSpinLock(&(cddata->DelayedRetrySpinLock), oldIrql);
        }
    } else {
        KeReleaseSpinLock(&(cddata->DelayedRetrySpinLock), oldIrql);
    }

    ClassReleaseRemoveLock(DeviceObject, (PIRP) &uniqueAddress);
}


NTSTATUS
CdRomUpdateGeometryCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )

/*++

Routine Description:

    This routine andles the completion of the test unit ready irps
    used to determine if the media has changed.  If the media has
    changed, this code signals the named event to wake up other
    system services that react to media change (aka AutoPlay).

Arguments:

    DeviceObject - the object for the completion
    Irp - the IRP being completed
    Context - the SRB from the IRP

Return Value:

    NTSTATUS

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension;

    PSCSI_REQUEST_BLOCK srb = (PSCSI_REQUEST_BLOCK) Context;
    PREAD_CAPACITY_DATA readCapacityBuffer;
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status;
    BOOLEAN             retry;
    ULONG               retryCount;
    ULONG               lastSector;
    PIRP                originalIrp;
    PCDROM_DATA         cddata;
    UCHAR               uniqueAddress;

    //
    // Get items saved in the private IRP stack location.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    retryCount = (ULONG)(ULONG_PTR) irpStack->Parameters.Others.Argument1;
    originalIrp = (PIRP) irpStack->Parameters.Others.Argument2;

    if (!DeviceObject) {
        DeviceObject = irpStack->DeviceObject;
    }
    ASSERT(DeviceObject);

    fdoExtension = DeviceObject->DeviceExtension;
    commonExtension = DeviceObject->DeviceExtension;
    cddata = commonExtension->DriverData;
    readCapacityBuffer = srb->DataBuffer;

    if ((NT_SUCCESS(Irp->IoStatus.Status)) && (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_SUCCESS)) {

        CdRomInterpretReadCapacity(DeviceObject, readCapacityBuffer);

    } else {

        ULONG retryInterval;

        TraceLog((CdromDebugWarning,
                    "CdRomUpdateGeometryCompletion: [%p] unsuccessful "
                    "completion of buddy-irp %p (status - %lx)\n",
                    originalIrp, Irp, Irp->IoStatus.Status));

        if (srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {
            ClassReleaseQueue(DeviceObject);
        }

        retry = ClassInterpretSenseInfo(DeviceObject,
                                        srb,
                                        IRP_MJ_SCSI,
                                        0,
                                        retryCount,
                                        &status,
                                        &retryInterval);
        if (retry) {
            retryCount--;
            if ((retryCount) && (commonExtension->IsRemoved == NO_REMOVE)) {
                PCDB cdb;

                TraceLog((CdromDebugWarning,
                            "CdRomUpdateGeometryCompletion: [%p] Retrying "
                            "request %p .. thread is %p\n",
                            originalIrp, Irp, Irp->Tail.Overlay.Thread));

                //
                // set up a one shot timer to get this process started over
                //

                irpStack->Parameters.Others.Argument1 = ULongToPtr( retryCount );
                irpStack->Parameters.Others.Argument2 = (PVOID) originalIrp;
                irpStack->Parameters.Others.Argument3 = (PVOID) 2;

                //
                // Setup the IRP to be submitted again in the timer routine.
                //

                irpStack = IoGetNextIrpStackLocation(Irp);
                irpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                irpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_SCSI_EXECUTE_IN;
                irpStack->Parameters.Scsi.Srb = srb;
                IoSetCompletionRoutine(Irp,
                                       CdRomUpdateGeometryCompletion,
                                       srb,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                //
                // Set up the SRB for read capacity.
                //

                srb->CdbLength = 10;
                srb->TimeOutValue = fdoExtension->TimeOutValue;
                srb->SrbStatus = srb->ScsiStatus = 0;
                srb->NextSrb = 0;
                srb->Length = SCSI_REQUEST_BLOCK_SIZE;
                srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
                srb->SrbFlags = fdoExtension->SrbFlags;
                SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
                SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
                srb->DataTransferLength = sizeof(READ_CAPACITY_DATA);

                //
                // Set up the CDB
                //

                cdb = (PCDB) &srb->Cdb[0];
                cdb->CDB10.OperationCode = SCSIOP_READ_CAPACITY;

                //
                // Requests queued onto this list will be sent to the
                // lower level driver during CdRomTickHandler
                //

                CdRomRetryRequest(fdoExtension, Irp, retryInterval, TRUE);

                return STATUS_MORE_PROCESSING_REQUIRED;
            }

            if (commonExtension->IsRemoved != NO_REMOVE) {

                //
                // We cannot retry the request.  Fail it.
                //

                originalIrp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;

            } else {

                //
                // This has been bounced for a number of times.  Error the
                // original request.
                //

                originalIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                RtlZeroMemory(&(fdoExtension->DiskGeometry),
                              sizeof(DISK_GEOMETRY));
                fdoExtension->DiskGeometry.BytesPerSector = 2048;
                fdoExtension->SectorShift = 11;
                commonExtension->PartitionLength.QuadPart =
                    (LONGLONG)(0x7fffffff);
                fdoExtension->DiskGeometry.MediaType = RemovableMedia;
            }
        } else {

            //
            // Set up reasonable defaults
            //

            RtlZeroMemory(&(fdoExtension->DiskGeometry),
                          sizeof(DISK_GEOMETRY));
            fdoExtension->DiskGeometry.BytesPerSector = 2048;
            fdoExtension->SectorShift = 11;
            commonExtension->PartitionLength.QuadPart = (LONGLONG)(0x7fffffff);
            fdoExtension->DiskGeometry.MediaType = RemovableMedia;
        }
    }

    //
    // Free resources held.
    //

    ExFreePool(srb->SenseInfoBuffer);
    ExFreePool(srb->DataBuffer);
    ExFreePool(srb);
    if (Irp->MdlAddress) {
        IoFreeMdl(Irp->MdlAddress);
    }
    IoFreeIrp(Irp);
    Irp = NULL;

    if (originalIrp->Tail.Overlay.Thread) {

        TraceLog((CdromDebugTrace,
                    "CdRomUpdateGeometryCompletion: [%p] completing "
                    "original IRP\n", originalIrp));

    } else {

        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugError,
                   "CdRomUpdateGeometryCompletion: completing irp %p which has "
                   "no thread\n", originalIrp));

    }
    
    {
        // NOTE: should the original irp be sent down to the device object?
        //       it probably should if the SL_OVERRIDER_VERIFY_VOLUME flag
        //       is set!
        KIRQL oldIrql;
        PIO_STACK_LOCATION realIrpStack;

        realIrpStack = IoGetCurrentIrpStackLocation(originalIrp);
        oldIrql = KeRaiseIrqlToDpcLevel();

        if (TEST_FLAG(realIrpStack->Flags, SL_OVERRIDE_VERIFY_VOLUME)) {
            CdRomStartIo(DeviceObject, originalIrp);
        } else {
            originalIrp->IoStatus.Status = STATUS_VERIFY_REQUIRED;
            originalIrp->IoStatus.Information = 0;
            CdRomCompleteIrpAndStartNextPacketSafely(DeviceObject, originalIrp);
        }
        KeLowerIrql(oldIrql);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
CdRomUpdateCapacity(
    IN PFUNCTIONAL_DEVICE_EXTENSION DeviceExtension,
    IN PIRP IrpToComplete,
    IN OPTIONAL PKEVENT IoctlEvent
    )

/*++

Routine Description:

    This routine updates the capacity of the disk as recorded in the device extension.
    It also completes the IRP given with STATUS_VERIFY_REQUIRED.  This routine is called
    when a media change has occurred and it is necessary to determine the capacity of the
    new media prior to the next access.

Arguments:

    DeviceExtension - the device to update
    IrpToComplete - the request that needs to be completed when done.

Return Value:

    NTSTATUS

--*/

{
    PCOMMON_DEVICE_EXTENSION commonExtension = (PCOMMON_DEVICE_EXTENSION) DeviceExtension;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = (PFUNCTIONAL_DEVICE_EXTENSION) DeviceExtension;

    PCDB                cdb;
    PIRP                irp;
    PSCSI_REQUEST_BLOCK srb;
    PREAD_CAPACITY_DATA capacityBuffer;
    PIO_STACK_LOCATION  irpStack;
    PUCHAR              senseBuffer;
    NTSTATUS            status;

    irp = IoAllocateIrp((CCHAR)(commonExtension->DeviceObject->StackSize+1),
                        FALSE);

    if (irp) {

        srb = ExAllocatePoolWithTag(NonPagedPool,
                                    sizeof(SCSI_REQUEST_BLOCK),
                                    CDROM_TAG_UPDATE_CAP);
        if (srb) {
            capacityBuffer = ExAllocatePoolWithTag(
                                NonPagedPoolCacheAligned,
                                sizeof(READ_CAPACITY_DATA),
                                CDROM_TAG_UPDATE_CAP);

            if (capacityBuffer) {


                senseBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                                    SENSE_BUFFER_SIZE,
                                                    CDROM_TAG_UPDATE_CAP);

                if (senseBuffer) {

                    irp->MdlAddress = IoAllocateMdl(capacityBuffer,
                                                    sizeof(READ_CAPACITY_DATA),
                                                    FALSE,
                                                    FALSE,
                                                    (PIRP) NULL);

                    if (irp->MdlAddress) {

                        //
                        // Have all resources.  Set up the IRP to send for the capacity.
                        //

                        IoSetNextIrpStackLocation(irp);
                        irp->IoStatus.Status = STATUS_SUCCESS;
                        irp->IoStatus.Information = 0;
                        irp->Flags = 0;
                        irp->UserBuffer = NULL;

                        //
                        // Save the device object and retry count in a private stack location.
                        //

                        irpStack = IoGetCurrentIrpStackLocation(irp);
                        irpStack->DeviceObject = commonExtension->DeviceObject;
                        irpStack->Parameters.Others.Argument1 = (PVOID) MAXIMUM_RETRIES;
                        irpStack->Parameters.Others.Argument2 = (PVOID) IrpToComplete;

                        //
                        // Construct the IRP stack for the lower level driver.
                        //

                        irpStack = IoGetNextIrpStackLocation(irp);
                        irpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                        irpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_SCSI_EXECUTE_IN;
                        irpStack->Parameters.Scsi.Srb = srb;
                        IoSetCompletionRoutine(irp,
                                               CdRomUpdateGeometryCompletion,
                                               srb,
                                               TRUE,
                                               TRUE,
                                               TRUE);
                        //
                        // Prepare the MDL
                        //

                        MmBuildMdlForNonPagedPool(irp->MdlAddress);


                        //
                        // Set up the SRB for read capacity.
                        //

                        RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));
                        RtlZeroMemory(senseBuffer, SENSE_BUFFER_SIZE);
                        srb->CdbLength = 10;
                        srb->TimeOutValue = DeviceExtension->TimeOutValue;
                        srb->SrbStatus = srb->ScsiStatus = 0;
                        srb->NextSrb = 0;
                        srb->Length = SCSI_REQUEST_BLOCK_SIZE;
                        srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
                        srb->SrbFlags = DeviceExtension->SrbFlags;
                        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
                        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
                        srb->DataBuffer = capacityBuffer;
                        srb->DataTransferLength = sizeof(READ_CAPACITY_DATA);
                        srb->OriginalRequest = irp;
                        srb->SenseInfoBuffer = senseBuffer;
                        srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

                        //
                        // Set up the CDB
                        //

                        cdb = (PCDB) &srb->Cdb[0];
                        cdb->CDB10.OperationCode = SCSIOP_READ_CAPACITY;

                        //
                        // Set the return value in the IRP that will be completed
                        // upon completion of the read capacity.
                        //

                        IrpToComplete->IoStatus.Status = STATUS_IO_DEVICE_ERROR;
                        IoMarkIrpPending(IrpToComplete);

                        IoCallDriver(commonExtension->LowerDeviceObject, irp);

                        //
                        // status is not checked because the completion routine for this
                        // IRP will always get called and it will free the resources.
                        //

                        return STATUS_PENDING;

                    } else {
                        ExFreePool(senseBuffer);
                        ExFreePool(capacityBuffer);
                        ExFreePool(srb);
                        IoFreeIrp(irp);
                    }
                } else {
                    ExFreePool(capacityBuffer);
                    ExFreePool(srb);
                    IoFreeIrp(irp);
                }
            } else {
                ExFreePool(srb);
                IoFreeIrp(irp);
            }
        } else {
            IoFreeIrp(irp);
        }
    }

    //
    // complete the original irp with a failure.
    // ISSUE-2000/07/05-henrygab - find a way to avoid failure.
    //

    RtlZeroMemory(&(fdoExtension->DiskGeometry),
                  sizeof(DISK_GEOMETRY));
    fdoExtension->DiskGeometry.BytesPerSector = 2048;
    fdoExtension->SectorShift = 11;
    commonExtension->PartitionLength.QuadPart =
        (LONGLONG)(0x7fffffff);
    fdoExtension->DiskGeometry.MediaType = RemovableMedia;

    IrpToComplete->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
    IrpToComplete->IoStatus.Information = 0;

    BAIL_OUT(IrpToComplete);
    CdRomCompleteIrpAndStartNextPacketSafely(commonExtension->DeviceObject,
                                             IrpToComplete);
    return STATUS_INSUFFICIENT_RESOURCES;
}


NTSTATUS
CdRomRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )

/*++

Routine Description:

    This routine is responsible for releasing any resources in use by the
    cdrom driver and shutting down it's timer routine.  This routine is called
    when all outstanding requests have been completed and the device has
    disappeared - no requests may be issued to the lower drivers.

Arguments:

    DeviceObject - the device object being removed

Return Value:

    none - this routine may not fail

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION deviceExtension =
        DeviceObject->DeviceExtension;

    PCDROM_DATA cdData = deviceExtension->CommonExtension.DriverData;

    PAGED_CODE();

    if((Type == IRP_MN_QUERY_REMOVE_DEVICE) ||
       (Type == IRP_MN_CANCEL_REMOVE_DEVICE)) {
        return STATUS_SUCCESS;
    }

    if(cdData->DelayedRetryIrp != NULL) {
        cdData->DelayedRetryInterval = 1;
        CdRomTickHandler(DeviceObject);
    }

    CdRomDeAllocateMmcResources(DeviceObject);

    if (deviceExtension->DeviceDescriptor) {
        ExFreePool(deviceExtension->DeviceDescriptor);
        deviceExtension->DeviceDescriptor = NULL;
    }

    if (deviceExtension->AdapterDescriptor) {
        ExFreePool(deviceExtension->AdapterDescriptor);
        deviceExtension->AdapterDescriptor = NULL;
    }

    if (deviceExtension->SenseData) {
        ExFreePool(deviceExtension->SenseData);
        deviceExtension->SenseData = NULL;
    }

    ClassDeleteSrbLookasideList(&deviceExtension->CommonExtension);

    if(cdData->CdromInterfaceString.Buffer != NULL) {
        IoSetDeviceInterfaceState(
            &(cdData->CdromInterfaceString),
            FALSE);
        RtlFreeUnicodeString(&(cdData->CdromInterfaceString));
        RtlInitUnicodeString(&(cdData->CdromInterfaceString), NULL);
    }

    if(cdData->VolumeInterfaceString.Buffer != NULL) {
        IoSetDeviceInterfaceState(
            &(cdData->VolumeInterfaceString),
            FALSE);
        RtlFreeUnicodeString(&(cdData->VolumeInterfaceString));
        RtlInitUnicodeString(&(cdData->VolumeInterfaceString), NULL);
    }

    CdRomDeleteWellKnownName(DeviceObject);

    ASSERT(cdData->DelayedRetryIrp == NULL);

    if(Type == IRP_MN_REMOVE_DEVICE) {

        if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_LOCKED_PAGES)) {
            
            //
            // unlock locked pages by locking (to get Mm pointer)
            // and then unlocking twice.
            //
            
            PVOID locked;

            if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_HITACHI_1750)) {
                
                locked = MmLockPagableCodeSection(HitachiProcessError);

            } else if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_HITACHI_GD_2000)) {

                locked = MmLockPagableCodeSection(HitachiProcessErrorGD2000);

            } else if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_TOSHIBA_XM_3xx )) {
            
                locked = MmLockPagableCodeSection(ToshibaProcessError);
            
            } else {

                // this is a problem!
                // workaround by locking this twice, once for us and
                // once for the non-existant locker from ScanForSpecial
                ASSERT(!"hack flags show locked section, but none exists?");
                locked = MmLockPagableCodeSection(CdRomRemoveDevice);
                locked = MmLockPagableCodeSection(CdRomRemoveDevice);


            }

            MmUnlockPagableImageSection(locked);
            MmUnlockPagableImageSection(locked);

        }

        //
        // keep the system-wide count accurate, as
        // programs use this info to know when they 
        // have found all the cdroms in a system.
        //

        TraceLog((CdromDebugTrace,
                    "CDROM.SYS Remove device\n"));
        IoGetConfigurationInformation()->CdRomCount--;
    }

    //
    // so long, and thanks for all the fish!
    //

    return STATUS_SUCCESS;
}


DEVICE_TYPE
CdRomGetDeviceType(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine figures out the real device type
    by checking CDVD_CAPABILITIES_PAGE

Arguments:

    DeviceObject -

Return Value:

    FILE_DEVICE_CD_ROM or FILE_DEVICE_DVD


--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    PCDROM_DATA cdromExtension;
    ULONG bufLength;
    SCSI_REQUEST_BLOCK srb;
    PCDB cdb;
    PMODE_PARAMETER_HEADER10 modePageHeader;
    PCDVD_CAPABILITIES_PAGE capPage;
    ULONG capPageOffset;
    DEVICE_TYPE deviceType;
    NTSTATUS status;
    BOOLEAN use6Byte;

    PAGED_CODE();

    //
    // NOTE: don't cache this until understand how it affects GetMediaTypes()
    //

    //
    // default device type
    //

    deviceType = FILE_DEVICE_CD_ROM;

    fdoExtension = DeviceObject->DeviceExtension;

    cdromExtension = fdoExtension->CommonExtension.DriverData;

    use6Byte = TEST_FLAG(cdromExtension->XAFlags, XA_USE_6_BYTE);

    RtlZeroMemory(&srb, sizeof(srb));
    cdb = (PCDB)srb.Cdb;

    //
    // Build the MODE SENSE CDB. The data returned will be kept in the
    // device extension and used to set block size.
    //
    if (use6Byte) {

        bufLength = sizeof(CDVD_CAPABILITIES_PAGE) +
                    sizeof(MODE_PARAMETER_HEADER);

        capPageOffset = sizeof(MODE_PARAMETER_HEADER);

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.Dbd = 1;
        cdb->MODE_SENSE.PageCode = MODE_PAGE_CAPABILITIES;
        cdb->MODE_SENSE.AllocationLength = (UCHAR)bufLength;
        srb.CdbLength = 6;
    } else {

        bufLength = sizeof(CDVD_CAPABILITIES_PAGE) +
                    sizeof(MODE_PARAMETER_HEADER10);

        capPageOffset = sizeof(MODE_PARAMETER_HEADER10);

        cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
        cdb->MODE_SENSE10.Dbd = 1;
        cdb->MODE_SENSE10.PageCode = MODE_PAGE_CAPABILITIES;
        cdb->MODE_SENSE10.AllocationLength[0] = (UCHAR)(bufLength >> 8);
        cdb->MODE_SENSE10.AllocationLength[1] = (UCHAR)(bufLength >> 0);
        srb.CdbLength = 10;
    }

    //
    // Set timeout value from device extension.
    //
    srb.TimeOutValue = fdoExtension->TimeOutValue;

    modePageHeader = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                           bufLength,
                                           CDROM_TAG_MODE_DATA);
    if (modePageHeader) {

        RtlZeroMemory(modePageHeader, bufLength);

        status = ClassSendSrbSynchronous(
                     DeviceObject,
                     &srb,
                     modePageHeader,
                     bufLength,
                     FALSE);

        if (NT_SUCCESS(status) ||
            (status == STATUS_DATA_OVERRUN) ||
            (status == STATUS_BUFFER_OVERFLOW)
            ) {

            capPage = (PCDVD_CAPABILITIES_PAGE) (((PUCHAR) modePageHeader) + capPageOffset);

            if ((capPage->PageCode == MODE_PAGE_CAPABILITIES) &&
                (capPage->DVDROMRead || capPage->DVDRRead ||
                 capPage->DVDRAMRead || capPage->DVDRWrite ||
                 capPage->DVDRAMWrite)) {

                deviceType = FILE_DEVICE_DVD;
            }
        }
        ExFreePool (modePageHeader);
    }

    return deviceType;
}


NTSTATUS
CdRomCreateWellKnownName(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine creates a symbolic link to the cdrom device object
    under \dosdevices.  The number of the cdrom device does not neccessarily
    match between \dosdevices and \device, but usually will be the same.

    Saves the buffer

Arguments:

    DeviceObject -

Return Value:

    NTSTATUS

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PCDROM_DATA cdromData = commonExtension->DriverData;

    UNICODE_STRING unicodeLinkName;
    WCHAR wideLinkName[64];
    PWCHAR savedName;

    LONG cdromNumber = fdoExtension->DeviceNumber;

    NTSTATUS status;

    //
    // if already linked, assert then return
    //

    if (cdromData->WellKnownName.Buffer != NULL) {

        TraceLog((CdromDebugError,
                    "CdRomCreateWellKnownName: link already exists %p\n",
                    cdromData->WellKnownName.Buffer));
        ASSERT(FALSE);
        return STATUS_UNSUCCESSFUL;

    }

    //
    // find an unused CdRomNN to link to
    //

    do {

        swprintf(wideLinkName, L"\\DosDevices\\CdRom%d", cdromNumber);
        RtlInitUnicodeString(&unicodeLinkName, wideLinkName);
        status = IoCreateSymbolicLink(&unicodeLinkName,
                                      &(commonExtension->DeviceName));

        cdromNumber++;

    } while((status == STATUS_OBJECT_NAME_COLLISION) ||
            (status == STATUS_OBJECT_NAME_EXISTS));

    if (!NT_SUCCESS(status)) {

        TraceLog((CdromDebugWarning,
                    "CdRomCreateWellKnownName: Error %lx linking %wZ to "
                    "device %wZ\n",
                    status,
                    &unicodeLinkName,
                    &(commonExtension->DeviceName)));
        return status;

    }

    TraceLog((CdromDebugWarning,
                "CdRomCreateWellKnownName: successfully linked %wZ "
                "to device %wZ\n",
                &unicodeLinkName,
                &(commonExtension->DeviceName)));

    //
    // Save away the symbolic link name in the driver data block.  We need
    // it so we can delete the link when the device is removed.
    //

    savedName = ExAllocatePoolWithTag(PagedPool,
                                      unicodeLinkName.MaximumLength,
                                      CDROM_TAG_STRINGS);

    if (savedName == NULL) {
        IoDeleteSymbolicLink(&unicodeLinkName);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(savedName,
                  unicodeLinkName.Buffer,
                  unicodeLinkName.MaximumLength);

    RtlInitUnicodeString(&(cdromData->WellKnownName), savedName);

    //
    // the name was saved and the link created
    //

    return STATUS_SUCCESS;
}


VOID
CdRomDeleteWellKnownName(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PCDROM_DATA cdromData = commonExtension->DriverData;

    if(cdromData->WellKnownName.Buffer != NULL) {

        IoDeleteSymbolicLink(&(cdromData->WellKnownName));
        ExFreePool(cdromData->WellKnownName.Buffer);
        cdromData->WellKnownName.Buffer = NULL;
        cdromData->WellKnownName.Length = 0;
        cdromData->WellKnownName.MaximumLength = 0;

    }
    return;
}


NTSTATUS
CdRomGetDeviceParameter (
    IN     PDEVICE_OBJECT      Fdo,
    IN     PWSTR               ParameterName,
    IN OUT PULONG              ParameterValue
    )
/*++

Routine Description:

    retrieve a devnode registry parameter

Arguments:

    DeviceObject - Cdrom Device Object

    ParameterName - parameter name to look up

    ParameterValuse - default parameter value

Return Value:

    NT Status

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    NTSTATUS                 status;
    HANDLE                   deviceParameterHandle;
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    ULONG                    defaultParameterValue;

    PAGED_CODE();

    //
    // open the given parameter
    //
    status = IoOpenDeviceRegistryKey(fdoExtension->LowerPdo,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     KEY_READ,
                                     &deviceParameterHandle);

    if(NT_SUCCESS(status)) {

        RtlZeroMemory(queryTable, sizeof(queryTable));

        defaultParameterValue = *ParameterValue;

        queryTable->Flags         = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
        queryTable->Name          = ParameterName;
        queryTable->EntryContext  = ParameterValue;
        queryTable->DefaultType   = REG_NONE;
        queryTable->DefaultData   = NULL;
        queryTable->DefaultLength = 0;

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        (PWSTR) deviceParameterHandle,
                                        queryTable,
                                        NULL,
                                        NULL);
        if (!NT_SUCCESS(status)) {

            *ParameterValue = defaultParameterValue;
        }

        //
        // close what we open
        //
        ZwClose(deviceParameterHandle);
    }

    return status;

} // CdRomGetDeviceParameter


NTSTATUS
CdRomSetDeviceParameter (
    IN PDEVICE_OBJECT Fdo,
    IN PWSTR          ParameterName,
    IN ULONG          ParameterValue
    )
/*++

Routine Description:

    save a devnode registry parameter

Arguments:

    DeviceObject - Cdrom Device Object

    ParameterName - parameter name

    ParameterValuse - parameter value

Return Value:

    NT Status

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    NTSTATUS                 status;
    HANDLE                   deviceParameterHandle;

    PAGED_CODE();

    //
    // open the given parameter
    //
    status = IoOpenDeviceRegistryKey(fdoExtension->LowerPdo,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     KEY_READ | KEY_WRITE,
                                     &deviceParameterHandle);

    if(NT_SUCCESS(status)) {

        status = RtlWriteRegistryValue(
                    RTL_REGISTRY_HANDLE,
                    (PWSTR) deviceParameterHandle,
                    ParameterName,
                    REG_DWORD,
                    &ParameterValue,
                    sizeof (ParameterValue));

        //
        // close what we open
        //
        ZwClose(deviceParameterHandle);
    }

    return status;

} // CdromSetDeviceParameter


VOID
CdRomPickDvdRegion(
    IN PDEVICE_OBJECT Fdo
    )
/*++

Routine Description:

    pick a default dvd region

Arguments:

    DeviceObject - Cdrom Device Object

Return Value:

    NT Status

--*/
{
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PCDROM_DATA cddata = (PCDROM_DATA)(commonExtension->DriverData);

    //
    // these five pointers all point to dvdReadStructure or part of
    // its data, so don't deallocate them more than once!
    //

    PDVD_READ_STRUCTURE dvdReadStructure;
    PDVD_COPY_PROTECT_KEY copyProtectKey;
    PDVD_COPYRIGHT_DESCRIPTOR dvdCopyRight;
    PDVD_RPC_KEY rpcKey;
    PDVD_SET_RPC_KEY dvdRpcKey;

    IO_STATUS_BLOCK ioStatus;
    ULONG bufferLen;
    UCHAR mediaRegion;
    ULONG pickDvdRegion;
    ULONG defaultDvdRegion;
    ULONG dvdRegion;

    PAGED_CODE();

    if ((pickDvdRegion = InterlockedExchange(&cddata->PickDvdRegion, 0)) == 0) {

        //
        // it was non-zero, so either another thread will do this, or
        // we no longer need to pick a region
        //

        return;
    }

    //
    // short-circuit if license agreement violated
    //

    if (cddata->DvdRpc0LicenseFailure) {
        TraceLog((CdromDebugWarning,
                    "DVD License failure.  Refusing to pick a region\n"));
        InterlockedExchange(&cddata->PickDvdRegion, 0);
        return;
    }


    bufferLen = max(
                    max(sizeof(DVD_DESCRIPTOR_HEADER) +
                            sizeof(DVD_COPYRIGHT_DESCRIPTOR),
                        sizeof(DVD_READ_STRUCTURE)
                        ),
                    max(DVD_RPC_KEY_LENGTH,
                        DVD_SET_RPC_KEY_LENGTH
                        ),
                    );

    dvdReadStructure = (PDVD_READ_STRUCTURE)
        ExAllocatePoolWithTag(PagedPool, bufferLen, DVD_TAG_DVD_REGION);

    if (dvdReadStructure == NULL) {
        InterlockedExchange(&cddata->PickDvdRegion, pickDvdRegion);
        return;
    }

    if (cddata->DvdRpc0Device && cddata->Rpc0RetryRegistryCallback) {

        TraceLog((CdromDebugWarning,
                    "CdRomPickDvdRegion (%p): now retrying RPC0 callback\n",
                    Fdo));

        //
        // get the registry settings again
        //

        ioStatus.Status = CdRomGetRpc0Settings(Fdo);

        if (ioStatus.Status == STATUS_LICENSE_VIOLATION) {

            //
            // if this is the returned error, then
            // the routine should have set this!
            //

            ASSERT(cddata->DvdRpc0LicenseFailure);
            cddata->DvdRpc0LicenseFailure = 1;
            TraceLog((CdromDebugWarning,
                        "CdRomPickDvdRegion (%p): "
                        "setting to fail all dvd ioctls due to CSS licensing "
                        "failure.\n", Fdo));

            pickDvdRegion = 0;
            goto getout;

        }

        //
        // get the device region, again
        //

        copyProtectKey = (PDVD_COPY_PROTECT_KEY)dvdReadStructure;
        RtlZeroMemory(copyProtectKey, bufferLen);
        copyProtectKey->KeyLength = DVD_RPC_KEY_LENGTH;
        copyProtectKey->KeyType = DvdGetRpcKey;

        //
        // Build a request for READ_KEY
        //

        ClassSendDeviceIoControlSynchronous(
            IOCTL_DVD_READ_KEY,
            Fdo,
            copyProtectKey,
            DVD_RPC_KEY_LENGTH,
            DVD_RPC_KEY_LENGTH,
            FALSE,
            &ioStatus);

        if (!NT_SUCCESS(ioStatus.Status)) {
            TraceLog((CdromDebugWarning,
                        "CdRomPickDvdRegion: Unable to get "
                        "device RPC data (%x)\n", ioStatus.Status));
            pickDvdRegion = 0;
            goto getout;
        }

        //
        // now that we have gotten the device's RPC data,
        // we have set the device extension to usable data.
        // no need to call back into this section of code again
        //

        cddata->Rpc0RetryRegistryCallback = 0;


        rpcKey = (PDVD_RPC_KEY) copyProtectKey->KeyData;

        //
        // TypeCode of zero means that no region has been set.
        //

        if (rpcKey->TypeCode != 0) {
            TraceLog((CdromDebugWarning,
                        "CdRomPickDvdRegion (%p): DVD Region already "
                        "chosen\n", Fdo));
            pickDvdRegion = 0;
            goto getout;
        }

        TraceLog((CdromDebugWarning,
                    "CdRomPickDvdRegion (%p): must choose initial DVD "
                    " Region\n", Fdo));
    }



    copyProtectKey = (PDVD_COPY_PROTECT_KEY) dvdReadStructure;

    dvdCopyRight = (PDVD_COPYRIGHT_DESCRIPTOR)
        ((PDVD_DESCRIPTOR_HEADER) dvdReadStructure)->Data;

    //
    // get the media region
    //

    RtlZeroMemory (dvdReadStructure, bufferLen);
    dvdReadStructure->Format = DvdCopyrightDescriptor;

    //
    // Build and send a request for READ_KEY
    //

    TraceLog((CdromDebugTrace,
                "CdRomPickDvdRegion (%p): Getting Copyright Descriptor\n",
                Fdo));

    ClassSendDeviceIoControlSynchronous(
        IOCTL_DVD_READ_STRUCTURE,
        Fdo,
        dvdReadStructure,
        sizeof(DVD_READ_STRUCTURE),
        sizeof (DVD_DESCRIPTOR_HEADER) +
        sizeof(DVD_COPYRIGHT_DESCRIPTOR),
        FALSE,
        &ioStatus
        );
    TraceLog((CdromDebugTrace,
                "CdRomPickDvdRegion (%p): Got Copyright Descriptor %x\n",
                Fdo, ioStatus.Status));

    if ((NT_SUCCESS(ioStatus.Status)) &&
        (dvdCopyRight->CopyrightProtectionType == 0x01)
        ) {

        //
        // keep the media region bitmap around
        // a 1 means ok to play
        //

        if (dvdCopyRight->RegionManagementInformation == 0xff) {
            TraceLog((CdromDebugError,
                      "CdRomPickDvdRegion (%p): RegionManagementInformation "
                      "is set to dis-allow playback for all regions.  This is "
                      "most likely a poorly authored disc.  defaulting to all "
                      "region disc for purpose of choosing initial region\n",
                      Fdo));
            dvdCopyRight->RegionManagementInformation = 0;
        }


        mediaRegion = ~dvdCopyRight->RegionManagementInformation;

    } else {

        //
        // could be media, can't set the device region
        //

        if (!cddata->DvdRpc0Device) {

            //
            // can't automatically pick a default region on a rpc2 drive
            // without media, so just exit
            //
            TraceLog((CdromDebugWarning,
                        "CdRomPickDvdRegion (%p): failed to auto-choose "
                        "a region due to status %x getting copyright "
                        "descriptor\n", Fdo, ioStatus.Status));
            goto getout;

        } else {

            //
            // for an RPC0 drive, we can try to pick a region for
            // the drive
            //

            mediaRegion = 0x0;
        }

    }

    //
    // get the device region
    //

    RtlZeroMemory (copyProtectKey, bufferLen);
    copyProtectKey->KeyLength = DVD_RPC_KEY_LENGTH;
    copyProtectKey->KeyType = DvdGetRpcKey;

    //
    // Build and send a request for READ_KEY for RPC key
    //

    TraceLog((CdromDebugTrace,
                "CdRomPickDvdRegion (%p): Getting RpcKey\n",
                Fdo));
    ClassSendDeviceIoControlSynchronous(
        IOCTL_DVD_READ_KEY,
        Fdo,
        copyProtectKey,
        DVD_RPC_KEY_LENGTH,
        DVD_RPC_KEY_LENGTH,
        FALSE,
        &ioStatus
        );
    TraceLog((CdromDebugTrace,
                "CdRomPickDvdRegion (%p): Got RpcKey %x\n",
                Fdo, ioStatus.Status));

    if (!NT_SUCCESS(ioStatus.Status)) {

        TraceLog((CdromDebugWarning,
                    "CdRomPickDvdRegion (%p): failed to get RpcKey from "
                    "a DVD Device\n", Fdo));
        goto getout;

    }

    //
    // so we now have what we can get for the media region and the
    // drive region.  we will not set a region if the drive has one
    // set already (mask is not all 1's), nor will we set a region
    // if there are no more user resets available.
    //

    rpcKey = (PDVD_RPC_KEY) copyProtectKey->KeyData;


    if (rpcKey->RegionMask != 0xff) {
        TraceLog((CdromDebugWarning,
                    "CdRomPickDvdRegion (%p): not picking a region since "
                    "it is already chosen\n", Fdo));
        goto getout;
    }

    if (rpcKey->UserResetsAvailable <= 1) {
        TraceLog((CdromDebugWarning,
                    "CdRomPickDvdRegion (%p): not picking a region since "
                    "only one change remains\n", Fdo));
        goto getout;
    }

    defaultDvdRegion = 0;

    //
    // the proppage dvd class installer sets
    // this key based upon the system locale
    //

    CdRomGetDeviceParameter (
        Fdo,
        DVD_DEFAULT_REGION,
        &defaultDvdRegion
        );

    if (defaultDvdRegion > DVD_MAX_REGION) {

        //
        // the registry has a bogus default
        //

        TraceLog((CdromDebugWarning,
                    "CdRomPickDvdRegion (%p): registry has a bogus default "
                    "region value of %x\n", Fdo, defaultDvdRegion));
        defaultDvdRegion = 0;

    }

    //
    // if defaultDvdRegion == 0, it means no default.
    //

    //
    // we will select the initial dvd region for the user
    //

    if ((defaultDvdRegion != 0) &&
        (mediaRegion &
         (1 << (defaultDvdRegion - 1))
         )
        ) {

        //
        // first choice:
        // the media has region that matches
        // the default dvd region.
        //

        dvdRegion = (1 << (defaultDvdRegion - 1));

        TraceLog((CdromDebugWarning,
                    "CdRomPickDvdRegion (%p): Choice #1: media matches "
                    "drive's default, chose region %x\n", Fdo, dvdRegion));


    } else if (mediaRegion) {

        //
        // second choice:
        // pick the lowest region number
        // from the media
        //

        UCHAR mask;

        mask = 1;
        dvdRegion = 0;
        while (mediaRegion && !dvdRegion) {

            //
            // pick the lowest bit
            //
            dvdRegion = mediaRegion & mask;
            mask <<= 1;
        }

        TraceLog((CdromDebugWarning,
                    "CdRomPickDvdRegion (%p): Choice #2: choosing lowest "
                    "media region %x\n", Fdo, dvdRegion));

    } else if (defaultDvdRegion) {

        //
        // third choice:
        // default dvd region from the dvd class installer
        //

        dvdRegion = (1 << (defaultDvdRegion - 1));
        TraceLog((CdromDebugWarning,
                    "CdRomPickDvdRegion (%p): Choice #3: using default "
                    "region for this install %x\n", Fdo, dvdRegion));

    } else {

        //
        // unable to pick one for the user -- this should rarely
        // happen, since the proppage dvd class installer sets
        // the key based upon the system locale
        //
        TraceLog((CdromDebugWarning,
                    "CdRomPickDvdRegion (%p): Choice #4: failed to choose "
                    "a media region\n", Fdo));
        goto getout;

    }

    //
    // now that we've chosen a region, set the region by sending the
    // appropriate request to the drive
    //

    RtlZeroMemory (copyProtectKey, bufferLen);
    copyProtectKey->KeyLength = DVD_SET_RPC_KEY_LENGTH;
    copyProtectKey->KeyType = DvdSetRpcKey;
    dvdRpcKey = (PDVD_SET_RPC_KEY) copyProtectKey->KeyData;
    dvdRpcKey->PreferredDriveRegionCode = (UCHAR) ~dvdRegion;

    //
    // Build and send request for SEND_KEY
    //
    TraceLog((CdromDebugTrace,
                "CdRomPickDvdRegion (%p): Sending new Rpc Key to region %x\n",
                Fdo, dvdRegion));

    ClassSendDeviceIoControlSynchronous(
        IOCTL_DVD_SEND_KEY2,
        Fdo,
        copyProtectKey,
        DVD_SET_RPC_KEY_LENGTH,
        0,
        FALSE,
        &ioStatus);
    TraceLog((CdromDebugTrace,
                "CdRomPickDvdRegion (%p): Sent new Rpc Key %x\n",
                Fdo, ioStatus.Status));

    if (!NT_SUCCESS(ioStatus.Status)) {
        DebugPrint ((1, "CdRomPickDvdRegion (%p): unable to set dvd initial "
                     " region code (%p)\n", Fdo, ioStatus.Status));
    } else {
        DebugPrint ((1, "CdRomPickDvdRegion (%p): Successfully set dvd "
                     "initial region\n", Fdo));
        pickDvdRegion = 0;
    }

getout:
    if (dvdReadStructure) {
        ExFreePool (dvdReadStructure);
    }

    //
    // update the new PickDvdRegion value
    //

    InterlockedExchange(&cddata->PickDvdRegion, pickDvdRegion);

    return;
}


NTSTATUS
CdRomRetryRequest(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PIRP Irp,
    IN ULONG Delay,
    IN BOOLEAN ResendIrp
    )
{
    PCDROM_DATA cdData;
    KIRQL oldIrql;

    if(Delay == 0) {
        return CdRomRerunRequest(FdoExtension, Irp, ResendIrp);
    }

    cdData = FdoExtension->CommonExtension.DriverData;

    KeAcquireSpinLock(&(cdData->DelayedRetrySpinLock), &oldIrql);

    ASSERT(cdData->DelayedRetryIrp == NULL);
    ASSERT(cdData->DelayedRetryInterval == 0);

    cdData->DelayedRetryIrp = Irp;
    cdData->DelayedRetryInterval = Delay;
    cdData->DelayedRetryResend = ResendIrp;

    KeReleaseSpinLock(&(cdData->DelayedRetrySpinLock), oldIrql);

    return STATUS_PENDING;
}


NTSTATUS
CdRomRerunRequest(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN OPTIONAL PIRP Irp,
    IN BOOLEAN ResendIrp
    )
{
    if(ResendIrp) {
        return IoCallDriver(FdoExtension->CommonExtension.LowerDeviceObject,
                            Irp);
    } else {
        KIRQL oldIrql;

        oldIrql = KeRaiseIrqlToDpcLevel();
        CdRomStartIo(FdoExtension->DeviceObject, Irp);
        KeLowerIrql(oldIrql);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
}


/*++

Routine Description:

    This routine just checks for media change sense/asc/ascq and
    also for other events, such as bus resets.  this is used to
    determine if the device behaviour has changed, to allow for
    read and write operations to be allowed and/or disallowed.

Arguments:

    ISSUE-2000/3/30-henrygab - not fully doc'd

Return Value:

    NTSTATUS

--*/
NTSTATUS
CdRomMmcErrorHandler(
    IN PDEVICE_OBJECT Fdo,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT PNTSTATUS Status,
    OUT PBOOLEAN Retry
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    BOOLEAN queryCapabilities = FALSE;

    if (TEST_FLAG(Srb->SrbStatus, SRB_STATUS_AUTOSENSE_VALID)) {
        
        PCDROM_DATA cddata = (PCDROM_DATA)commonExtension->DriverData;
        PSENSE_DATA senseBuffer = Srb->SenseInfoBuffer;

        //
        // the following sense keys could indicate a change in
        // capabilities.
        //

        //
        // we used to expect this to be serialized, and only hit from our
        // own routine. we now allow some requests to continue during our
        // processing of the capabilities update in order to allow
        // IoReadPartitionTable() to succeed.
        //

        switch (senseBuffer->SenseKey & 0xf) {
        
        case SCSI_SENSE_NOT_READY: {
            if (senseBuffer->AdditionalSenseCode ==
                SCSI_ADSENSE_NO_MEDIA_IN_DEVICE) {
                
                if (cddata->Mmc.WriteAllowed) {
                    KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                               "CdromErrorHandler: media removed, writes will be "
                               "failed until new media detected\n"));
                }

                // NOTE - REF #0002
                cddata->Mmc.WriteAllowed = FALSE;
            } else
            if ((senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_LUN_NOT_READY) &&
                (senseBuffer->AdditionalSenseCodeQualifier ==
                 SCSI_SENSEQ_BECOMING_READY)) {
                KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                           "CdromErrorHandler: media becoming ready, "
                           "SHOULD notify shell of change time by sending "
                           "GESN request immediately!\n"));
            }
            break;
        } // end SCSI_SENSE_NOT_READY

        case SCSI_SENSE_UNIT_ATTENTION: {
            switch (senseBuffer->AdditionalSenseCode) {
            case SCSI_ADSENSE_MEDIUM_CHANGED: {
                
                //
                // always update if the medium may have changed
                //
                
                // NOTE - REF #0002
                cddata->Mmc.WriteAllowed = FALSE;
                InterlockedCompareExchange(&(cddata->Mmc.UpdateState),
                                           CdromMmcUpdateRequired,
                                           CdromMmcUpdateComplete);
    
                KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                           "CdromErrorHandler: media change detected, need to "
                           "update drive capabilities\n"));
                break;

            } // end SCSI_ADSENSE_MEDIUM_CHANGED
            
            case SCSI_ADSENSE_BUS_RESET: {
                
                // NOTE - REF #0002
                cddata->Mmc.WriteAllowed = FALSE;
                InterlockedCompareExchange(&(cddata->Mmc.UpdateState),
                                           CdromMmcUpdateRequired,
                                           CdromMmcUpdateComplete);

                KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                           "CdromErrorHandler: bus reset detected, need to "
                           "update drive capabilities\n"));
                break;

            } // end SCSI_ADSENSE_BUS_RESET

            case SCSI_ADSENSE_OPERATOR_REQUEST: {

                BOOLEAN b = FALSE;
                
                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                case SCSI_SENSEQ_MEDIUM_REMOVAL: {
                                        
                    //
                    // eject notification currently handled by classpnp
                    //

                    KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                               "CdromErrorHandler: Eject requested by user\n"));
                    *Retry = TRUE;
                    *Status = STATUS_DEVICE_BUSY;
                    break;
                }

                case SCSI_SENSEQ_WRITE_PROTECT_DISABLE:
                    b = TRUE;
                case SCSI_SENSEQ_WRITE_PROTECT_ENABLE: {
                    
                    KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                               "CdromErrorHandler: Write protect %s requested "
                               "by user\n",
                               (b ? "disable" : "enable")));
                    *Retry = TRUE;
                    *Status = STATUS_DEVICE_BUSY;
                    // NOTE - REF #0002
                    cddata->Mmc.WriteAllowed = FALSE;
                    InterlockedCompareExchange(&(cddata->Mmc.UpdateState),
                                               CdromMmcUpdateRequired,
                                               CdromMmcUpdateComplete);

                }

                } // end of AdditionalSenseCodeQualifier switch


                break;

            } // end SCSI_ADSENSE_OPERATOR_REQUEST

            default: {
                KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                           "CdromErrorHandler: Unit attention %02x/%02x\n",
                           senseBuffer->AdditionalSenseCode,
                           senseBuffer->AdditionalSenseCodeQualifier));
                break;
            }

            } // end of AdditionSenseCode switch
            break;

        } // end SCSI_SENSE_UNIT_ATTENTION

        case SCSI_SENSE_ILLEGAL_REQUEST: {
            if (senseBuffer->AdditionalSenseCode ==
                SCSI_ADSENSE_WRITE_PROTECT) {
                
                if (cddata->Mmc.WriteAllowed) {
                    KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                               "CdromErrorHandler: media was writable, but "
                               "failed request with WRITE_PROTECT error...\n"));
                }
                // NOTE - REF #0002
                // do not update all the capabilities just because
                // we can't write to the disc.
                cddata->Mmc.WriteAllowed = FALSE;
            }
            break;
        } // end SCSI_SENSE_ILLEGAL_REQUEST

        } // end of SenseKey switch

    } // end of SRB_STATUS_AUTOSENSE_VALID

    return STATUS_SUCCESS;
}

/*++

Routine Description:

    This routine checks for a device-specific error handler
    and calls it if it exists.  This allows multiple drives
    that require their own error handler to co-exist.

--*/
VOID
CdRomErrorHandler(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PCDROM_DATA cddata = (PCDROM_DATA)commonExtension->DriverData;
    PSENSE_DATA sense = Srb->SenseInfoBuffer;

    if ((Srb->SenseInfoBufferLength >=
         RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA,AdditionalSenseCodeQualifier)) &&
        TEST_FLAG(Srb->SrbStatus, SRB_STATUS_AUTOSENSE_VALID)) {

        //
        //  Many non-WHQL certified drives (mostly CD-RW) return
        //  2/4/0 when they have no media instead of the obvious
        //  choice of:
        //
        //      SCSI_SENSE_NOT_READY/SCSI_ADSENSE_NO_MEDIA_IN_DEVICE
        //
        //  These drives should not pass WHQL certification due
        //  to this discrepency.
        //
        //  However, we have to retry on 2/4/0 (Not ready, LUN not ready,
        //  no info) and also 3/2/0 (no seek complete).
        //
        //  These conditions occur when the shell tries to examine an
        //  injected CD (e.g. for autoplay) before the CD is spun up.
        //
        //  The drive should be returning an ASCQ of SCSI_SENSEQ_BECOMING_READY
        //  (0x01) in order to comply with WHQL standards.
        //
        //  The default retry timeout of one second is acceptable to balance
        //  these discrepencies.  don't modify the status, though....
        //

        if (((sense->SenseKey & 0xf) == SCSI_SENSE_NOT_READY) &&
            (sense->AdditionalSenseCode == SCSI_ADSENSE_LUN_NOT_READY) &&
            (sense->AdditionalSenseCodeQualifier == SCSI_SENSEQ_CAUSE_NOT_REPORTABLE)
            ) {

            *Retry = TRUE;

        } else if (((sense->SenseKey & 0xf) == SCSI_SENSE_MEDIUM_ERROR) &&
                   (sense->AdditionalSenseCode == 0x2) &&
                   (sense->AdditionalSenseCodeQualifier == 0x0)
                   ) {

            *Retry = TRUE;

        } else if ((sense->AdditionalSenseCode == 0x57) &&
                   (sense->AdditionalSenseCodeQualifier == 0x00)
                   ) {

            //
            // UNABLE_TO_RECOVER_TABLE_OF_CONTENTS
            // the Matshita CR-585 returns this for all read commands
            // on blank CD-R and CD-RW media, and we need to handle
            // this for READ_CD detection ability.
            //
            
            *Retry = FALSE;
            *Status = STATUS_UNRECOGNIZED_MEDIA;

        }

    }

    //
    // tail recursion in both cases takes no stack
    //

    if (cddata->ErrorHandler) {
        cddata->ErrorHandler(DeviceObject, Srb, Status, Retry);
    }
    return;
}


/*++

Routine Description:

    This routine is called for a shutdown and flush IRPs.
    These are sent by the system before it actually shuts
    down or when the file system does a flush.

Arguments:

    DriverObject - Pointer to device object to being shutdown by system.

    Irp - IRP involved.

Return Value:

    NT Status

--*/
NTSTATUS
CdRomShutdownFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    IoMarkIrpPending(Irp);
    IoStartPacket(DeviceObject, Irp, NULL, NULL);
    return STATUS_PENDING;

}

/*++

Routine Description:

    This routine is called for intermediate work a shutdown or
    flush IRPs would need to do.  We just want to free our resources
    and return STATUS_MORE_PROCESSING_REQUIRED.

Arguments:

    DeviceObject - NULL?

    Irp - IRP to free
    
    Context - NULL

Return Value:

    NT Status

--*/
NTSTATUS
CdRomShutdownFlushCompletion(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP NewIrp,
    IN PIRP OriginalIrp 
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION originalIrpStack;
    ULONG_PTR iteration;
    NTSTATUS status = STATUS_SUCCESS;
    
    ASSERT(OriginalIrp);

    originalIrpStack = IoGetCurrentIrpStackLocation(OriginalIrp);

    //
    // always use a new irp so we can call
    // CdRomCompleteIrpAndStartNextPacketSafely() from this routine.
    //
    
    if (NewIrp != NULL) {
        status = NewIrp->IoStatus.Status;
        IoFreeIrp(NewIrp);
        NewIrp = NULL;
    }

    if (!NT_SUCCESS(status)) {
        BAIL_OUT(OriginalIrp);
        goto SafeExit;
    }
    
    //
    // the current irpstack saves the counter which states
    // what part of the multi-part shutdown or flush we are in.
    //

    iteration = (ULONG_PTR)originalIrpStack->Parameters.Others.Argument1;
    iteration++;
    originalIrpStack->Parameters.Others.Argument1 = (PVOID)iteration;

    switch (iteration) {
    case 2:
        if (originalIrpStack->MajorFunction != IRP_MJ_SHUTDOWN) {
            //
            // then we don't want to send the unlock command
            // the incrementing of the state was done above.
            // return the completion routine's result.
            //
            return CdRomShutdownFlushCompletion(Fdo, NULL, OriginalIrp);
        }
        // else fall through....

    case 1: {
        
        PIRP                newIrp = NULL;
        PSCSI_REQUEST_BLOCK newSrb = NULL;
        PCDB                newCdb = NULL;
        PIO_STACK_LOCATION  newIrpStack = NULL;
        ULONG               isRemoved;

        newIrp = IoAllocateIrp((CCHAR)(Fdo->StackSize+1), FALSE);
        if (newIrp == NULL) {
            BAIL_OUT(OriginalIrp);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto SafeExit;
        }
        newSrb = ExAllocatePoolWithTag(NonPagedPool,
                                        sizeof(SCSI_REQUEST_BLOCK),
                                        CDROM_TAG_SRB);
        if (newSrb == NULL) {
            IoFreeIrp(newIrp);
            BAIL_OUT(OriginalIrp);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto SafeExit;
        }
        
        //
        // ClassIoComplete will free the SRB, but we need a routine
        // that will free the irp.  then just call ClassSendAsync,
        // and don't care about the return value, since the completion
        // routine will be called anyways.
        //

        IoSetNextIrpStackLocation(newIrp);
        newIrpStack = IoGetCurrentIrpStackLocation(newIrp);
        newIrpStack->DeviceObject = Fdo;
        IoSetCompletionRoutine(newIrp,
                               CdRomShutdownFlushCompletion,
                               OriginalIrp,
                               TRUE, TRUE, TRUE);
        IoSetNextIrpStackLocation(newIrp);
        newIrpStack = IoGetCurrentIrpStackLocation(newIrp);
        newIrpStack->DeviceObject = Fdo;

        //
        // setup the request
        //

        RtlZeroMemory(newSrb, sizeof(SCSI_REQUEST_BLOCK));
        newCdb = (PCDB)(newSrb->Cdb);
        
        newSrb->QueueTag = SP_UNTAGGED;
        newSrb->QueueAction = SRB_SIMPLE_TAG_REQUEST;
        newSrb->Function = SRB_FUNCTION_EXECUTE_SCSI;

        //
        // tell classpnp not to call StartNextPacket()
        //

        newSrb->SrbFlags = SRB_FLAGS_DONT_START_NEXT_PACKET;

        if (iteration == 1) {

            //
            // first synchronize the cache
            //
            
            newSrb->TimeOutValue = fdoExtension->TimeOutValue * 4;
            newSrb->CdbLength = 10;
            newCdb->SYNCHRONIZE_CACHE10.OperationCode = SCSIOP_SYNCHRONIZE_CACHE;
            
        } else if (iteration == 2) {

            //
            // then unlock the medium
            //

            ASSERT( originalIrpStack->MajorFunction == IRP_MJ_SHUTDOWN );
            
            newSrb->TimeOutValue = fdoExtension->TimeOutValue;
            newSrb->CdbLength = 6;
            newCdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
            newCdb->MEDIA_REMOVAL.Prevent = FALSE;
            
        }


        isRemoved = ClassAcquireRemoveLock(Fdo, newIrp);
        if (isRemoved) {
            IoFreeIrp(newIrp);
            ExFreePool(newSrb);
            ClassReleaseRemoveLock(Fdo, newIrp);
            BAIL_OUT(OriginalIrp);
            status = STATUS_DEVICE_DOES_NOT_EXIST;
            goto SafeExit;
        }
        ClassSendSrbAsynchronous(Fdo, newSrb, newIrp, NULL, 0, FALSE);
        break;
    }

    case 3: {

        PSCSI_REQUEST_BLOCK srb;
        PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation(OriginalIrp);
        
        //
        // forward this request to the device appropriately,
        // don't use this completion routine anymore...
        //
        
        srb = ExAllocatePoolWithTag(NonPagedPool,
                                    sizeof(SCSI_REQUEST_BLOCK),
                                    CDROM_TAG_SRB);
        if (srb == NULL) {
            BAIL_OUT(OriginalIrp);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto SafeExit;
        }

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
        srb->Length = SCSI_REQUEST_BLOCK_SIZE;
        srb->TimeOutValue = fdoExtension->TimeOutValue * 4;
        srb->QueueTag = SP_UNTAGGED;
        srb->QueueAction = SRB_SIMPLE_TAG_REQUEST;
        srb->SrbFlags = fdoExtension->SrbFlags;
        srb->CdbLength = 0;
        srb->OriginalRequest = OriginalIrp;

        if (originalIrpStack->MajorFunction == IRP_MJ_SHUTDOWN) {
            srb->Function = SRB_FUNCTION_SHUTDOWN;
        } else {
            srb->Function = SRB_FUNCTION_FLUSH;
        }

        //
        // Set up IoCompletion routine address.
        //

        IoSetCompletionRoutine(OriginalIrp,
                               ClassIoComplete,
                               srb,
                               TRUE, TRUE, TRUE);

        //
        // Set the retry count to zero.
        //

        originalIrpStack->Parameters.Others.Argument4 = (PVOID) 0;

        //
        // Get next stack location and set major function code.
        //

        nextIrpStack->MajorFunction = IRP_MJ_SCSI;

        //
        // Set up SRB for execute scsi request.
        // Save SRB address in next stack for port driver.
        //

        nextIrpStack->Parameters.Scsi.Srb = srb;

        //
        // Call the port driver to process the request.
        //

        IoCallDriver(commonExtension->LowerDeviceObject, OriginalIrp);
        
        break;

    }
    default: {
        ASSERT(FALSE);
        break;
    }

    } // end switch
    
    status = STATUS_SUCCESS;

SafeExit:

    if (!NT_SUCCESS(status)) {
        OriginalIrp->IoStatus.Status = status;
        CdRomCompleteIrpAndStartNextPacketSafely(Fdo, OriginalIrp);
    }

    //
    // always return STATUS_MORE_PROCESSING_REQUIRED, so noone else tries
    // to access the new irp that we free'd....
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // end CdromShutdownFlush()


VOID
CdromFakePartitionInfo(
    IN PCOMMON_DEVICE_EXTENSION CommonExtension,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG ioctl = currentIrpStack->Parameters.DeviceIoControl.IoControlCode;
    PVOID systemBuffer = Irp->AssociatedIrp.SystemBuffer;

    ASSERT(systemBuffer);

    if ((ioctl != IOCTL_DISK_GET_DRIVE_LAYOUT) &&
        (ioctl != IOCTL_DISK_GET_DRIVE_LAYOUT_EX) &&
        (ioctl != IOCTL_DISK_GET_PARTITION_INFO) &&
        (ioctl != IOCTL_DISK_GET_PARTITION_INFO_EX)) {
        TraceLog((CdromDebugError,
                    "CdromFakePartitionInfo: unhandled ioctl %x\n", ioctl));
        Irp->IoStatus.Status = STATUS_INTERNAL_ERROR;
        Irp->IoStatus.Information = 0;
        CdRomCompleteIrpAndStartNextPacketSafely(CommonExtension->DeviceObject,
                                                 Irp);
        return;
    }

    //
    // nothing to fail from this point on, so set the size appropriately
    // and set irp's status to success.
    //

    TraceLog((CdromDebugWarning,
                "CdromFakePartitionInfo: incoming ioctl %x\n", ioctl));


    Irp->IoStatus.Status = STATUS_SUCCESS;
    switch (ioctl) {
    case IOCTL_DISK_GET_DRIVE_LAYOUT:
        Irp->IoStatus.Information = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION,
                                                 PartitionEntry[1]);
        RtlZeroMemory(systemBuffer, FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION,
                                                 PartitionEntry[1]));
        break;
    case IOCTL_DISK_GET_DRIVE_LAYOUT_EX:
        Irp->IoStatus.Information = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX,
                                                 PartitionEntry[1]);
        RtlZeroMemory(systemBuffer, FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX,
                                                 PartitionEntry[1]));
        break;
    case IOCTL_DISK_GET_PARTITION_INFO:
        Irp->IoStatus.Information = sizeof(PARTITION_INFORMATION);
        RtlZeroMemory(systemBuffer, sizeof(PARTITION_INFORMATION));
        break;
    case IOCTL_DISK_GET_PARTITION_INFO_EX:
        Irp->IoStatus.Information = sizeof(PARTITION_INFORMATION_EX);
        RtlZeroMemory(systemBuffer, sizeof(PARTITION_INFORMATION_EX));
        break;
    default:
        ASSERT(!"Invalid ioctl should not have reached this point\n");
        break;
    }

    //
    // if we are getting the drive layout, then we need to start by
    // adding some of the non-partition stuff that says we have
    // exactly one partition available.
    //


    if (ioctl == IOCTL_DISK_GET_DRIVE_LAYOUT) {
        
        PDRIVE_LAYOUT_INFORMATION layout;
        layout = (PDRIVE_LAYOUT_INFORMATION)systemBuffer;
        layout->PartitionCount = 1;
        layout->Signature = 1;
        systemBuffer = (PVOID)(layout->PartitionEntry);
        ioctl = IOCTL_DISK_GET_PARTITION_INFO;
        
    } else if (ioctl == IOCTL_DISK_GET_DRIVE_LAYOUT_EX) {

        PDRIVE_LAYOUT_INFORMATION_EX layoutEx;
        layoutEx = (PDRIVE_LAYOUT_INFORMATION_EX)systemBuffer;
        layoutEx->PartitionStyle = PARTITION_STYLE_MBR;
        layoutEx->PartitionCount = 1;
        layoutEx->Mbr.Signature = 1;
        systemBuffer = (PVOID)(layoutEx->PartitionEntry);
        ioctl = IOCTL_DISK_GET_PARTITION_INFO_EX;

    }

    //
    // NOTE: the local var 'ioctl' is now modified to either EX or
    // non-EX version. the local var 'systemBuffer' is now pointing
    // to the partition information structure.
    //

    if (ioctl == IOCTL_DISK_GET_PARTITION_INFO) {

        PPARTITION_INFORMATION partitionInfo;
        partitionInfo = (PPARTITION_INFORMATION)systemBuffer;
        partitionInfo->RewritePartition = FALSE;
        partitionInfo->RecognizedPartition = TRUE;
        partitionInfo->PartitionType = PARTITION_FAT32;
        partitionInfo->BootIndicator = FALSE;
        partitionInfo->HiddenSectors = 0;
        partitionInfo->StartingOffset.QuadPart = 0;
        partitionInfo->PartitionLength = CommonExtension->PartitionLength;
        partitionInfo->PartitionNumber = 0;
    
    } else {

        PPARTITION_INFORMATION_EX partitionInfo;
        partitionInfo = (PPARTITION_INFORMATION_EX)systemBuffer;
        partitionInfo->PartitionStyle = PARTITION_STYLE_MBR;
        partitionInfo->RewritePartition = FALSE;
        partitionInfo->Mbr.RecognizedPartition = TRUE;
        partitionInfo->Mbr.PartitionType = PARTITION_FAT32;
        partitionInfo->Mbr.BootIndicator = FALSE;
        partitionInfo->Mbr.HiddenSectors = 0;
        partitionInfo->StartingOffset.QuadPart = 0;
        partitionInfo->PartitionLength = CommonExtension->PartitionLength;
        partitionInfo->PartitionNumber = 0;
    
    }
    TraceLog((CdromDebugWarning,
                "CdromFakePartitionInfo: finishing ioctl %x\n",
                currentIrpStack->Parameters.DeviceIoControl.IoControlCode));

    //
    // complete the irp
    //

    CdRomCompleteIrpAndStartNextPacketSafely(CommonExtension->DeviceObject,
                                             Irp);
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\cdrom\ioctl.c ===
/*--

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    ioctl.c

Abstract:

    The CDROM class driver tranlates IRPs to SRBs with embedded CDBs
    and sends them to its devices through the port driver.

Environment:

    kernel mode only

Notes:

    SCSI Tape, CDRom and Disk class drivers share common routines
    that can be found in the CLASS directory (..\ntos\dd\class).

Revision History:

--*/

#include "stddef.h"
#include "string.h"

#include "ntddk.h"

#include "ntddcdvd.h"
#include "classpnp.h"

#include "initguid.h"
#include "ntddstor.h"
#include "cdrom.h"

#include "ioctl.tmh"

#if DBG
    PUCHAR READ_DVD_STRUCTURE_FORMAT_STRINGS[DvdMaxDescriptor+1] = {
        "Physical",
        "Copyright",
        "DiskKey",
        "BCA",
        "Manufacturer",
        "Unknown"
    };
#endif // DBG

#define DEFAULT_CDROM_SECTORS_PER_TRACK 32
#define DEFAULT_TRACKS_PER_CYLINDER     64



NTSTATUS
CdRomDeviceControlDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the NT device control handler for CDROMs.

Arguments:

    DeviceObject - for this CDROM

    Irp - IO Request packet

Return Value:

    NTSTATUS

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION  fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextStack;
    PCDROM_DATA        cdData = (PCDROM_DATA)(commonExtension->DriverData);

    BOOLEAN            use6Byte = TEST_FLAG(cdData->XAFlags, XA_USE_6_BYTE);
    SCSI_REQUEST_BLOCK srb;
    PCDB cdb = (PCDB)srb.Cdb;
    PVOID outputBuffer;
    ULONG bytesTransferred = 0;
    NTSTATUS status;
    NTSTATUS status2;
    KIRQL    irql;

    ULONG ioctlCode;
    ULONG baseCode;
    ULONG functionCode;

RetryControl:

    //
    // Zero the SRB on stack.
    //

    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

    Irp->IoStatus.Information = 0;

    //
    // if this is a class driver ioctl then we need to change the base code
    // to IOCTL_CDROM_BASE so that the switch statement can handle it.
    //
    // WARNING - currently the scsi class ioctl function codes are between
    // 0x200 & 0x300.  this routine depends on that fact
    //

    ioctlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;
    baseCode = ioctlCode >> 16;
    functionCode = (ioctlCode & (~0xffffc003)) >> 2;

    TraceLog((CdromDebugTrace,
                "CdRomDeviceControl: Ioctl Code = %lx, Base Code = %lx,"
                " Function Code = %lx\n",
                ioctlCode,
                baseCode,
                functionCode
              ));

    if((functionCode >= 0x200) && (functionCode <= 0x300)) {

        ioctlCode = (ioctlCode & 0x0000ffff) | CTL_CODE(IOCTL_CDROM_BASE, 0, 0, 0);

        TraceLog((CdromDebugTrace,
                    "CdRomDeviceControl: Class Code - new ioctl code is %lx\n",
                    ioctlCode));

        irpStack->Parameters.DeviceIoControl.IoControlCode = ioctlCode;

    }

    switch (ioctlCode) {

    case IOCTL_STORAGE_GET_MEDIA_TYPES_EX: {

        PGET_MEDIA_TYPES  mediaTypes = Irp->AssociatedIrp.SystemBuffer;
        PDEVICE_MEDIA_INFO mediaInfo = &mediaTypes->MediaInfo[0];
        ULONG sizeNeeded;

        sizeNeeded = sizeof(GET_MEDIA_TYPES);
        
        //
        // IsMmc is static...
        //

        if (cdData->Mmc.IsMmc) {
            sizeNeeded += sizeof(DEVICE_MEDIA_INFO) * 1; // return two media types
        }

        //
        // Ensure that buffer is large enough.
        //

        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeNeeded) {

            //
            // Buffer too small.
            //

            Irp->IoStatus.Information = sizeNeeded;
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }
        
        RtlZeroMemory(Irp->AssociatedIrp.SystemBuffer, sizeNeeded);

        //
        // ISSUE-2000/5/11-henrygab - need to update GET_MEDIA_TYPES_EX
        //

        mediaTypes->DeviceType = CdRomGetDeviceType(DeviceObject);

        mediaTypes->MediaInfoCount = 1;
        mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaType = CD_ROM;
        mediaInfo->DeviceSpecific.RemovableDiskInfo.NumberMediaSides = 1;
        mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaCharacteristics = MEDIA_READ_ONLY;
        mediaInfo->DeviceSpecific.RemovableDiskInfo.Cylinders.QuadPart = fdoExtension->DiskGeometry.Cylinders.QuadPart;
        mediaInfo->DeviceSpecific.RemovableDiskInfo.TracksPerCylinder = fdoExtension->DiskGeometry.TracksPerCylinder;
        mediaInfo->DeviceSpecific.RemovableDiskInfo.SectorsPerTrack = fdoExtension->DiskGeometry.SectorsPerTrack;
        mediaInfo->DeviceSpecific.RemovableDiskInfo.BytesPerSector = fdoExtension->DiskGeometry.BytesPerSector;

        if (cdData->Mmc.IsMmc) {
            
            //
            // also report a removable disk
            //
            mediaTypes->MediaInfoCount += 1;
            
            mediaInfo++;
            mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaType = RemovableMedia;
            mediaInfo->DeviceSpecific.RemovableDiskInfo.NumberMediaSides = 1;
            mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaCharacteristics = MEDIA_READ_WRITE;
            mediaInfo->DeviceSpecific.RemovableDiskInfo.Cylinders.QuadPart = fdoExtension->DiskGeometry.Cylinders.QuadPart;
            mediaInfo->DeviceSpecific.RemovableDiskInfo.TracksPerCylinder = fdoExtension->DiskGeometry.TracksPerCylinder;
            mediaInfo->DeviceSpecific.RemovableDiskInfo.SectorsPerTrack = fdoExtension->DiskGeometry.SectorsPerTrack;
            mediaInfo->DeviceSpecific.RemovableDiskInfo.BytesPerSector = fdoExtension->DiskGeometry.BytesPerSector;
            mediaInfo--;
        
        }

        //
        // Status will either be success, if media is present, or no media.
        // It would be optimal to base from density code and medium type, but not all devices
        // have values for these fields.
        //

        //
        // Send a TUR to determine if media is present.
        //

        srb.CdbLength = 6;
        cdb = (PCDB)srb.Cdb;
        cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

        //
        // Set timeout value.
        //

        srb.TimeOutValue = fdoExtension->TimeOutValue;

        status = ClassSendSrbSynchronous(DeviceObject,
                                         &srb,
                                         NULL,
                                         0,
                                         FALSE);


        TraceLog((CdromDebugWarning,
                   "CdRomDeviceControl: GET_MEDIA_TYPES status of TUR - %lx\n",
                   status));

        if (NT_SUCCESS(status)) {

            //
            // set the disk's media as current if we can write to it.
            //

            if (cdData->Mmc.IsMmc && cdData->Mmc.WriteAllowed) {

                mediaInfo++;
                SET_FLAG(mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaCharacteristics,
                         MEDIA_CURRENTLY_MOUNTED);
                mediaInfo--;


            } else {

                SET_FLAG(mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaCharacteristics,
                         MEDIA_CURRENTLY_MOUNTED);

            }

        }

        Irp->IoStatus.Information = sizeNeeded;
        status = STATUS_SUCCESS;
        break;
    }


    case IOCTL_CDROM_RAW_READ: {

        LARGE_INTEGER  startingOffset;
        ULONGLONG      transferBytes;
        ULONGLONG      endOffset;
        ULONGLONG      mdlBytes;
        ULONG          startingSector;
        PRAW_READ_INFO rawReadInfo = (PRAW_READ_INFO)irpStack->Parameters.DeviceIoControl.Type3InputBuffer;

        //
        // Ensure that XA reads are supported.
        //

        if (TEST_FLAG(cdData->XAFlags, XA_NOT_SUPPORTED)) {
            TraceLog((CdromDebugWarning,
                        "CdRomDeviceControl: XA Reads not supported. Flags (%x)\n",
                        cdData->XAFlags));
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        //
        // Check that ending sector is on disc and buffers are there and of
        // correct size.
        //

        if (rawReadInfo == NULL) {
            
            //
            // Called from user space. Save the userbuffer in the 
            // Type3InputBuffer so we can reduce the number of code paths.
            //

            irpStack->Parameters.DeviceIoControl.Type3InputBuffer =
                Irp->AssociatedIrp.SystemBuffer;

            //
            // Called from user space.  Validate the buffers.
            //

            rawReadInfo = (PRAW_READ_INFO)irpStack->Parameters.DeviceIoControl.Type3InputBuffer;

            if (rawReadInfo == NULL) {

                TraceLog((CdromDebugWarning,
                            "CdRomDeviceControl: Invalid I/O parameters for "
                            "XA Read (No extent info\n"));
                status = STATUS_INVALID_PARAMETER;
                break;

            }

            if (irpStack->Parameters.DeviceIoControl.InputBufferLength !=
                sizeof(RAW_READ_INFO)) {

                TraceLog((CdromDebugWarning,
                            "CdRomDeviceControl: Invalid I/O parameters for "
                            "XA Read (Invalid info buffer\n"));
                status = STATUS_INVALID_PARAMETER;
                break;

            }
        }

        //
        // if they don't request any data, just fail the request
        //

        if (rawReadInfo->SectorCount == 0) {

            status = STATUS_INVALID_PARAMETER;
            break;

        }

        startingOffset.QuadPart = rawReadInfo->DiskOffset.QuadPart;
        startingSector = (ULONG)(rawReadInfo->DiskOffset.QuadPart >>
                                 fdoExtension->SectorShift);
        transferBytes = (ULONGLONG)rawReadInfo->SectorCount * RAW_SECTOR_SIZE;
        
        endOffset = (ULONGLONG)rawReadInfo->SectorCount * COOKED_SECTOR_SIZE;
        endOffset += startingOffset.QuadPart;

        //
        // check for overflows....
        //
        
        if (transferBytes < (ULONGLONG)(rawReadInfo->SectorCount)) {
            TraceLog((CdromDebugWarning,
                        "CdRomDeviceControl: Invalid I/O parameters for XA "
                        "Read (TransferBytes Overflow)\n"));
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        if (endOffset < (ULONGLONG)startingOffset.QuadPart) {
            TraceLog((CdromDebugWarning,
                        "CdRomDeviceControl: Invalid I/O parameters for XA "
                        "Read (EndingOffset Overflow)\n"));
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            transferBytes) {
            TraceLog((CdromDebugWarning,
                        "CdRomDeviceControl: Invalid I/O parameters for XA "
                        "Read (Bad buffer size)\n"));
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        if (endOffset > (ULONGLONG)commonExtension->PartitionLength.QuadPart) {
            TraceLog((CdromDebugWarning,
                        "CdRomDeviceControl: Invalid I/O parameters for XA "
                        "Read (Request Out of Bounds)\n"));
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // cannot validate the MdlAddress, since it is not included in any
        // other location per the DDK and file system calls.
        //

        //
        // validate the mdl describes at least the number of bytes
        // requested from us.
        //

        mdlBytes = (ULONGLONG)MmGetMdlByteCount(Irp->MdlAddress);
        if (mdlBytes < transferBytes) {
            TraceLog((CdromDebugWarning,
                        "CdRomDeviceControl: Invalid MDL %s, Irp %p\n",
                        "size (5)", Irp));
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // HACKHACK - REF #0001
        // The retry count will be in this irp's IRP_MN function,
        // as the new irp was freed, and we therefore cannot use
        // this irp's next stack location for this function.
        // This may be a good location to store this info for
        // when we remove RAW_READ (mode switching), as we will
        // no longer have the nextIrpStackLocation to play with
        // when that occurs
        //
        // once XA_READ is removed, then this hack can also be
        // removed.
        //
        irpStack->MinorFunction = MAXIMUM_RETRIES; // HACKHACK - REF #0001

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);

        return STATUS_PENDING;
    }

    case IOCTL_DISK_GET_DRIVE_GEOMETRY_EX:
    case IOCTL_CDROM_GET_DRIVE_GEOMETRY_EX: {
        TraceLog((CdromDebugTrace,
                    "CdRomDeviceControl: Get drive geometryEx\n"));
        if ( irpStack->Parameters.DeviceIoControl.OutputBufferLength <
             FIELD_OFFSET(DISK_GEOMETRY_EX, Data)) {
            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = FIELD_OFFSET(DISK_GEOMETRY_EX, Data);
            break;
        }
        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);
        return STATUS_PENDING;
    }

    case IOCTL_DISK_GET_DRIVE_GEOMETRY:
    case IOCTL_CDROM_GET_DRIVE_GEOMETRY: {

        TraceLog((CdromDebugTrace,
                    "CdRomDeviceControl: Get drive geometry\n"));

        if ( irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof( DISK_GEOMETRY ) ) {

            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = sizeof(DISK_GEOMETRY);
            break;
        }

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);

        return STATUS_PENDING;
    }

    case IOCTL_CDROM_READ_TOC_EX: {

        PCDROM_READ_TOC_EX inputBuffer;
        
        if (CdRomIsPlayActive(DeviceObject)) {
            status = STATUS_DEVICE_BUSY;
            break;
        }

        if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(CDROM_READ_TOC_EX)) {
            status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            MINIMUM_CDROM_READ_TOC_EX_SIZE) {
            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = MINIMUM_CDROM_READ_TOC_EX_SIZE;
            break;
        }

        if (irpStack->Parameters.Read.Length > ((USHORT)-1)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        inputBuffer = Irp->AssociatedIrp.SystemBuffer;

        if ((inputBuffer->Reserved1 != 0) ||
            (inputBuffer->Reserved2 != 0) ||
            (inputBuffer->Reserved3 != 0)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // NOTE: when adding new formats, ensure that first two bytes
        //       specify the amount of additional data available.
        //

        if ((inputBuffer->Format == CDROM_READ_TOC_EX_FORMAT_TOC     ) ||
            (inputBuffer->Format == CDROM_READ_TOC_EX_FORMAT_FULL_TOC) ||
            (inputBuffer->Format == CDROM_READ_TOC_EX_FORMAT_CDTEXT  )) {
            
            // SessionTrack field is used

        } else
        if ((inputBuffer->Format == CDROM_READ_TOC_EX_FORMAT_SESSION) ||
            (inputBuffer->Format == CDROM_READ_TOC_EX_FORMAT_PMA)     ||
            (inputBuffer->Format == CDROM_READ_TOC_EX_FORMAT_ATIP)) {
            
            // SessionTrack field is reserved
            
            if (inputBuffer->SessionTrack != 0) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }
            
        } else {
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);
        return STATUS_PENDING;
    }

    case IOCTL_CDROM_GET_LAST_SESSION: {

        //
        // If the cd is playing music then reject this request.
        //

        if (CdRomIsPlayActive(DeviceObject)) {
            status = STATUS_DEVICE_BUSY;
            break;
        }

        //
        // Make sure the caller is requesting enough data to make this worth
        // our while.
        //

        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(CDROM_TOC_SESSION_DATA)) {

            //
            // they didn't request the entire TOC -- use _EX version
            // for partial transfers and such.
            //

            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = sizeof(CDROM_TOC_SESSION_DATA);
            break;
        }

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);

        return STATUS_PENDING;
    }

    case IOCTL_CDROM_READ_TOC:  {

        //
        // If the cd is playing music then reject this request.
        //

        if (CdRomIsPlayActive(DeviceObject)) {
            status = STATUS_DEVICE_BUSY;
            break;
        }

        //
        // Make sure the caller is requesting enough data to make this worth
        // our while.
        //

        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(CDROM_TOC)) {

            //
            // they didn't request the entire TOC -- use _EX version
            // for partial transfers and such.
            //

            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = sizeof(CDROM_TOC);
            break;
        }

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);

        return STATUS_PENDING;
    }

    case IOCTL_CDROM_PLAY_AUDIO_MSF: {

        //
        // Play Audio MSF
        //

        TraceLog((CdromDebugTrace,
                    "CdRomDeviceControl: Play audio MSF\n"));

        if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(CDROM_PLAY_AUDIO_MSF)) {

            //
            // Indicate unsuccessful status.
            //

            status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);

        return STATUS_PENDING;
    }

    case IOCTL_CDROM_SEEK_AUDIO_MSF: {


        //
        // Seek Audio MSF
        //

        TraceLog((CdromDebugTrace,
                    "CdRomDeviceControl: Seek audio MSF\n"));

        if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(CDROM_SEEK_AUDIO_MSF)) {

            //
            // Indicate unsuccessful status.
            //

            status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }
        
        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);
        return STATUS_PENDING;

    }

    case IOCTL_CDROM_PAUSE_AUDIO: {

        //
        // Pause audio
        //

        TraceLog((CdromDebugTrace,
                    "CdRomDeviceControl: Pause audio\n"));

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);

        return STATUS_PENDING;

        break;
    }

    case IOCTL_CDROM_RESUME_AUDIO: {

        //
        // Resume audio
        //

        TraceLog((CdromDebugTrace,
                    "CdRomDeviceControl: Resume audio\n"));

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);

        return STATUS_PENDING;
    }

    case IOCTL_CDROM_READ_Q_CHANNEL: {

        PCDROM_SUB_Q_DATA_FORMAT inputBuffer =
                         Irp->AssociatedIrp.SystemBuffer;

        if(irpStack->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(CDROM_SUB_Q_DATA_FORMAT)) {

            status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        //
        // check for all valid types of request
        //

        if (inputBuffer->Format != IOCTL_CDROM_CURRENT_POSITION &&
            inputBuffer->Format != IOCTL_CDROM_MEDIA_CATALOG &&
            inputBuffer->Format != IOCTL_CDROM_TRACK_ISRC ) {
            status = STATUS_INVALID_PARAMETER;
            Irp->IoStatus.Information = 0;
            break;
        }

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);

        return STATUS_PENDING;
    }

    case IOCTL_CDROM_GET_CONTROL: {

        TraceLog((CdromDebugTrace,
                    "CdRomDeviceControl: Get audio control\n"));

        //
        // Verify user buffer is large enough for the data.
        //

        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(CDROM_AUDIO_CONTROL)) {

            //
            // Indicate unsuccessful status and no data transferred.
            //

            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = sizeof(CDROM_AUDIO_CONTROL);
            break;

        }

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);

        return STATUS_PENDING;
    }

    case IOCTL_CDROM_GET_VOLUME: {

        TraceLog((CdromDebugTrace,
                    "CdRomDeviceControl: Get volume control\n"));

        //
        // Verify user buffer is large enough for data.
        //

        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(VOLUME_CONTROL)) {

            //
            // Indicate unsuccessful status and no data transferred.
            //

            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = sizeof(VOLUME_CONTROL);
            break;

        }

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);

        return STATUS_PENDING;
    }

    case IOCTL_CDROM_SET_VOLUME: {

        TraceLog((CdromDebugTrace,
                    "CdRomDeviceControl: Set volume control\n"));

        if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(VOLUME_CONTROL)) {

            //
            // Indicate unsuccessful status.
            //

            status = STATUS_INFO_LENGTH_MISMATCH;
            break;

        }

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);

        return STATUS_PENDING;
    }

    case IOCTL_CDROM_STOP_AUDIO: {

        //
        // Stop play.
        //

        TraceLog((CdromDebugTrace,
                    "CdRomDeviceControl: Stop audio\n"));

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);

        return STATUS_PENDING;
    }

    case IOCTL_STORAGE_CHECK_VERIFY:
    case IOCTL_DISK_CHECK_VERIFY:
    case IOCTL_CDROM_CHECK_VERIFY: {

        TraceLog((CdromDebugTrace,
                    "CdRomDeviceControl: [%p] Check Verify\n", Irp));

        if((irpStack->Parameters.DeviceIoControl.OutputBufferLength) &&
           (irpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG))) {

           TraceLog((CdromDebugWarning,
                       "CdRomDeviceControl: Check Verify: media count "
                       "buffer too small\n"));

           status = STATUS_BUFFER_TOO_SMALL;
           Irp->IoStatus.Information = sizeof(ULONG);
           break;
        }

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);

        return STATUS_PENDING;
    }

    case IOCTL_DVD_READ_STRUCTURE: {

        TraceLog((CdromDebugTrace,
                    "DvdDeviceControl: [%p] IOCTL_DVD_READ_STRUCTURE\n", Irp));

        if (cdData->DvdRpc0Device && cdData->DvdRpc0LicenseFailure) {
            TraceLog((CdromDebugWarning,
                        "DvdDeviceControl: License Failure\n"));
            status = STATUS_COPY_PROTECTION_FAILURE;
            break;
        }

        if (cdData->DvdRpc0Device && cdData->Rpc0RetryRegistryCallback) {
            //
            // if currently in-progress, this will just return.
            // prevents looping by doing that interlockedExchange()
            //
            TraceLog((CdromDebugWarning,
                        "DvdDeviceControl: PickRegion() from "
                        "READ_STRUCTURE\n"));
            CdRomPickDvdRegion(DeviceObject);
        }


        if(irpStack->Parameters.DeviceIoControl.InputBufferLength <
           sizeof(DVD_READ_STRUCTURE)) {

            TraceLog((CdromDebugWarning,
                        "DvdDeviceControl - READ_STRUCTURE: input buffer "
                        "length too small (was %d should be %d)\n",
                        irpStack->Parameters.DeviceIoControl.InputBufferLength,
                        sizeof(DVD_READ_STRUCTURE)));
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        if(irpStack->Parameters.DeviceIoControl.OutputBufferLength <
           sizeof(READ_DVD_STRUCTURES_HEADER)) {

            TraceLog((CdromDebugWarning,
                        "DvdDeviceControl - READ_STRUCTURE: output buffer "
                        "cannot hold header information\n"));
            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = sizeof(READ_DVD_STRUCTURES_HEADER);            
            break;
        }

        if(irpStack->Parameters.DeviceIoControl.OutputBufferLength >
           MAXUSHORT) {

            //
            // key length must fit in two bytes
            //
            TraceLog((CdromDebugWarning,
                        "DvdDeviceControl - READ_STRUCTURE: output buffer "
                        "too large\n"));
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);

        return STATUS_PENDING;
    }

    case IOCTL_DVD_START_SESSION: {

        TraceLog((CdromDebugTrace,
                    "DvdDeviceControl: [%p] IOCTL_DVD_START_SESSION\n", Irp));

        if (cdData->DvdRpc0Device && cdData->DvdRpc0LicenseFailure) {
            TraceLog((CdromDebugWarning,
                        "DvdDeviceControl: License Failure\n"));
            status = STATUS_COPY_PROTECTION_FAILURE;
            break;
        }

        if(irpStack->Parameters.DeviceIoControl.OutputBufferLength <
           sizeof(DVD_SESSION_ID)) {

            TraceLog((CdromDebugWarning,
                        "DvdDeviceControl: DVD_START_SESSION - output "
                        "buffer too small\n"));
            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = sizeof(DVD_SESSION_ID);
            break;
        }

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);

        return STATUS_PENDING;
    }

    case IOCTL_DVD_SEND_KEY:
    case IOCTL_DVD_SEND_KEY2: {

        PDVD_COPY_PROTECT_KEY key = Irp->AssociatedIrp.SystemBuffer;
        ULONG keyLength;

        TraceLog((CdromDebugTrace,
                    "DvdDeviceControl: [%p] IOCTL_DVD_SEND_KEY\n", Irp));

        if (cdData->DvdRpc0Device && cdData->DvdRpc0LicenseFailure) {
            TraceLog((CdromDebugWarning,
                        "DvdDeviceControl: License Failure\n"));
            status = STATUS_COPY_PROTECTION_FAILURE;
            break;
        }

        if((irpStack->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(DVD_COPY_PROTECT_KEY)) ||
           (irpStack->Parameters.DeviceIoControl.InputBufferLength !=
            key->KeyLength)) {

            //
            // Key is too small to have a header or the key length doesn't
            // match the input buffer length.  Key must be invalid
            //

            TraceLog((CdromDebugWarning,
                        "DvdDeviceControl: [%p] IOCTL_DVD_SEND_KEY - "
                        "key is too small or does not match KeyLength\n",
                        Irp));
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // allow only certain key type (non-destructive) to go through
        // IOCTL_DVD_SEND_KEY (which only requires READ access to the device
        //
        if (ioctlCode == IOCTL_DVD_SEND_KEY) {

            if ((key->KeyType != DvdChallengeKey) &&
                (key->KeyType != DvdBusKey2) &&
                (key->KeyType != DvdInvalidateAGID)) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }
        }

        if (cdData->DvdRpc0Device) {

            if (key->KeyType == DvdSetRpcKey) {

                PDVD_SET_RPC_KEY rpcKey = (PDVD_SET_RPC_KEY) key->KeyData;

                if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                    DVD_SET_RPC_KEY_LENGTH) {

                    status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                // we have a request to set region code
                // on a RPC0 device which doesn't support
                // region coding.
                //
                // we have to fake it.
                //

                KeWaitForMutexObject(
                    &cdData->Rpc0RegionMutex,
                    UserRequest,
                    KernelMode,
                    FALSE,
                    NULL
                    );

                if (cdData->DvdRpc0Device && cdData->Rpc0RetryRegistryCallback) {
                    //
                    // if currently in-progress, this will just return.
                    // prevents looping by doing that interlockedExchange()
                    //
                    TraceLog((CdromDebugWarning,
                                "DvdDeviceControl: PickRegion() from "
                                "SEND_KEY\n"));
                    CdRomPickDvdRegion(DeviceObject);
                }

                if (cdData->Rpc0SystemRegion == rpcKey->PreferredDriveRegionCode) {

                    //
                    // nothing to change
                    //
                    TraceLog((CdromDebugWarning,
                                "DvdDeviceControl (%p) => not changing "
                                "regions -- requesting current region\n",
                                DeviceObject));
                    status = STATUS_SUCCESS;

                } else if (cdData->Rpc0SystemRegionResetCount == 0) {

                    //
                    // not allowed to change it again
                    //

                    TraceLog((CdromDebugWarning,
                                "DvdDeviceControl (%p) => no more region "
                                "changes are allowed for this device\n",
                                DeviceObject));
                    status = STATUS_CSS_RESETS_EXHAUSTED;

                } else {

                    ULONG i;
                    UCHAR mask;
                    ULONG bufferLen;
                    PDVD_READ_STRUCTURE dvdReadStructure;
                    PDVD_COPYRIGHT_DESCRIPTOR dvdCopyRight;
                    IO_STATUS_BLOCK ioStatus;
                    UCHAR mediaRegionData;

                    mask = ~rpcKey->PreferredDriveRegionCode;

                    if (CountOfSetBitsUChar(mask) != 1) {

                        status = STATUS_INVALID_DEVICE_REQUEST;
                        break;
                    }

                    //
                    // this test will always be TRUE except during initial
                    // automatic selection of the first region.
                    //

                    if (cdData->Rpc0SystemRegion != 0xff) {

                        //
                        // make sure we have a media in the drive with the same
                        // region code if the drive is already has a region set
                        //

                        TraceLog((CdromDebugTrace,
                                    "DvdDeviceControl (%p) => Checking "
                                    "media region\n",
                                    DeviceObject));

                        bufferLen = max(sizeof(DVD_DESCRIPTOR_HEADER) +
                                            sizeof(DVD_COPYRIGHT_DESCRIPTOR),
                                        sizeof(DVD_READ_STRUCTURE)
                                        );

                        dvdReadStructure = (PDVD_READ_STRUCTURE)
                            ExAllocatePoolWithTag(PagedPool,
                                                  bufferLen,
                                                  DVD_TAG_RPC2_CHECK);

                        if (dvdReadStructure == NULL) {
                            status = STATUS_INSUFFICIENT_RESOURCES;
                            KeReleaseMutex(&cdData->Rpc0RegionMutex,FALSE);
                            break;
                        }

                        dvdCopyRight = (PDVD_COPYRIGHT_DESCRIPTOR)
                            ((PDVD_DESCRIPTOR_HEADER) dvdReadStructure)->Data;

                        //
                        // check to see if we have a DVD device
                        //

                        RtlZeroMemory (dvdReadStructure, bufferLen);
                        dvdReadStructure->Format = DvdCopyrightDescriptor;

                        //
                        // Build a request for READ_KEY
                        //
                        ClassSendDeviceIoControlSynchronous(
                            IOCTL_DVD_READ_STRUCTURE,
                            DeviceObject,
                            dvdReadStructure,
                            sizeof(DVD_READ_STRUCTURE),
                            sizeof(DVD_DESCRIPTOR_HEADER) +
                                sizeof(DVD_COPYRIGHT_DESCRIPTOR),
                            FALSE,
                            &ioStatus);

                        //
                        // this is just to prevent bugs from creeping in
                        // if status is not set later in development
                        //

                        status = ioStatus.Status;

                        //
                        // handle errors
                        //

                        if (!NT_SUCCESS(status)) {
                            KeReleaseMutex(&cdData->Rpc0RegionMutex,FALSE);
                            ExFreePool(dvdReadStructure);
                            status = STATUS_INVALID_DEVICE_REQUEST;
                            break;
                        }

                        //
                        // save the mediaRegionData before freeing the
                        // allocated memory
                        //

                        mediaRegionData =
                            dvdCopyRight->RegionManagementInformation;
                        ExFreePool(dvdReadStructure);

                        TraceLog((CdromDebugWarning,
                                    "DvdDeviceControl (%p) => new mask is %x"
                                    " MediaRegionData is %x\n", DeviceObject,
                                    rpcKey->PreferredDriveRegionCode,
                                    mediaRegionData));

                        //
                        // the media region must match the requested region
                        // for RPC0 drives for initial region selection
                        //

                        if (((UCHAR)~(mediaRegionData | rpcKey->PreferredDriveRegionCode)) == 0) {
                            KeReleaseMutex(&cdData->Rpc0RegionMutex,FALSE);
                            status = STATUS_CSS_REGION_MISMATCH;
                            break;
                        }

                    }

                    //
                    // now try to set the region
                    //

                    TraceLog((CdromDebugTrace,
                                "DvdDeviceControl (%p) => Soft-Setting "
                                "region of RPC1 device to %x\n",
                                DeviceObject,
                                rpcKey->PreferredDriveRegionCode
                                ));

                    status = CdRomSetRpc0Settings(DeviceObject,
                                                  rpcKey->PreferredDriveRegionCode);

                    if (!NT_SUCCESS(status)) {
                        TraceLog((CdromDebugWarning,
                                    "DvdDeviceControl (%p) => Could not "
                                    "set region code (%x)\n",
                                    DeviceObject, status
                                    ));
                    } else {

                        TraceLog((CdromDebugTrace,
                                    "DvdDeviceControl (%p) => New region set "
                                    " for RPC1 drive\n", DeviceObject));

                        //
                        // if it worked, our extension is already updated.
                        // release the mutex
                        //

                        DebugPrint ((4, "DvdDeviceControl (%p) => DVD current "
                                     "region bitmap  0x%x\n", DeviceObject,
                                     cdData->Rpc0SystemRegion));
                        DebugPrint ((4, "DvdDeviceControl (%p) => DVD region "
                                     " reset Count     0x%x\n", DeviceObject,
                                     cdData->Rpc0SystemRegionResetCount));
                    }

                }

                KeReleaseMutex(&cdData->Rpc0RegionMutex,FALSE);
                break;
            } // end of key->KeyType == DvdSetRpcKey
        } // end of Rpc0Device hacks

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);
        return STATUS_PENDING;
        break;
    }

    case IOCTL_DVD_READ_KEY: {

        PDVD_COPY_PROTECT_KEY keyParameters = Irp->AssociatedIrp.SystemBuffer;
        ULONG keyLength;

        TraceLog((CdromDebugTrace,
                    "DvdDeviceControl: [%p] IOCTL_DVD_READ_KEY\n", Irp));

        if (cdData->DvdRpc0Device && cdData->DvdRpc0LicenseFailure) {
            TraceLog((CdromDebugWarning,
                        "DvdDeviceControl: License Failure\n"));
            status = STATUS_COPY_PROTECTION_FAILURE;
            break;
        }

        if (cdData->DvdRpc0Device && cdData->Rpc0RetryRegistryCallback) {
            TraceLog((CdromDebugWarning,
                        "DvdDeviceControl: PickRegion() from READ_KEY\n"));
            CdRomPickDvdRegion(DeviceObject);
        }


        if(irpStack->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(DVD_COPY_PROTECT_KEY)) {

            TraceLog((CdromDebugWarning,
                        "DvdDeviceControl: EstablishDriveKey - challenge "
                        "key buffer too small\n"));

            status = STATUS_INVALID_PARAMETER;
            break;

        }


        switch(keyParameters->KeyType) {

            case DvdChallengeKey:
                keyLength = DVD_CHALLENGE_KEY_LENGTH;
                break;

            case DvdBusKey1:
            case DvdBusKey2:

                keyLength = DVD_BUS_KEY_LENGTH;
                break;

            case DvdTitleKey:
                keyLength = DVD_TITLE_KEY_LENGTH;
                break;

            case DvdAsf:
                keyLength = DVD_ASF_LENGTH;
                break;

            case DvdDiskKey:
                keyLength = DVD_DISK_KEY_LENGTH;
                break;

            case DvdGetRpcKey:
                keyLength = DVD_RPC_KEY_LENGTH;
                break;

            default:
                keyLength = sizeof(DVD_COPY_PROTECT_KEY);
                break;
        }

        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            keyLength) {

            TraceLog((CdromDebugWarning,
                        "DvdDeviceControl: EstablishDriveKey - output "
                        "buffer too small\n"));
            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = keyLength;
            break;
        }

        if (keyParameters->KeyType == DvdGetRpcKey) {

            CdRomPickDvdRegion(DeviceObject);
        }

        if ((keyParameters->KeyType == DvdGetRpcKey) &&
            (cdData->DvdRpc0Device)) {

            PDVD_RPC_KEY rpcKey;
            rpcKey = (PDVD_RPC_KEY)keyParameters->KeyData;
            RtlZeroMemory (rpcKey, sizeof (*rpcKey));

            KeWaitForMutexObject(
                &cdData->Rpc0RegionMutex,
                UserRequest,
                KernelMode,
                FALSE,
                NULL
                );

            //
            // make up the data
            //
            rpcKey->UserResetsAvailable = cdData->Rpc0SystemRegionResetCount;
            rpcKey->ManufacturerResetsAvailable = 0;
            if (cdData->Rpc0SystemRegion == 0xff) {
                rpcKey->TypeCode = 0;
            } else {
                rpcKey->TypeCode = 1;
            }
            rpcKey->RegionMask = (UCHAR) cdData->Rpc0SystemRegion;
            rpcKey->RpcScheme = 1;

            KeReleaseMutex(
                &cdData->Rpc0RegionMutex,
                FALSE
                );

            Irp->IoStatus.Information = DVD_RPC_KEY_LENGTH;
            status = STATUS_SUCCESS;
            break;

        } else if (keyParameters->KeyType == DvdDiskKey) {

            PDVD_COPY_PROTECT_KEY keyHeader;
            PDVD_READ_STRUCTURE readStructureRequest;

            //
            // Special case - build a request to get the dvd structure
            // so we can get the disk key.
            //

            //
            // save the key header so we can restore the interesting
            // parts later
            //

            keyHeader = ExAllocatePoolWithTag(NonPagedPool,
                                              sizeof(DVD_COPY_PROTECT_KEY),
                                              DVD_TAG_READ_KEY);

            if(keyHeader == NULL) {

                //
                // Can't save the context so return an error
                //

                TraceLog((CdromDebugWarning,
                            "DvdDeviceControl - READ_KEY: unable to "
                            "allocate context\n"));
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            RtlCopyMemory(keyHeader,
                          Irp->AssociatedIrp.SystemBuffer,
                          sizeof(DVD_COPY_PROTECT_KEY));

            IoCopyCurrentIrpStackLocationToNext(Irp);

            nextStack = IoGetNextIrpStackLocation(Irp);

            nextStack->Parameters.DeviceIoControl.IoControlCode =
                IOCTL_DVD_READ_STRUCTURE;

            readStructureRequest = Irp->AssociatedIrp.SystemBuffer;
            readStructureRequest->Format = DvdDiskKeyDescriptor;
            readStructureRequest->BlockByteOffset.QuadPart = 0;
            readStructureRequest->LayerNumber = 0;
            readStructureRequest->SessionId = keyHeader->SessionId;

            nextStack->Parameters.DeviceIoControl.InputBufferLength =
                sizeof(DVD_READ_STRUCTURE);

            nextStack->Parameters.DeviceIoControl.OutputBufferLength =
                sizeof(READ_DVD_STRUCTURES_HEADER) + sizeof(DVD_DISK_KEY_DESCRIPTOR);

            IoSetCompletionRoutine(Irp,
                                   CdRomDvdReadDiskKeyCompletion,
                                   (PVOID) keyHeader,
                                   TRUE,
                                   TRUE,
                                   TRUE);

            {
                UCHAR uniqueAddress;
                ClassAcquireRemoveLock(DeviceObject, (PIRP)&uniqueAddress);
                ClassReleaseRemoveLock(DeviceObject, Irp);

                IoMarkIrpPending(Irp);
                IoCallDriver(commonExtension->DeviceObject, Irp);
                status = STATUS_PENDING;

                ClassReleaseRemoveLock(DeviceObject, (PIRP)&uniqueAddress);
            }

            return STATUS_PENDING;

        } else {

            IoMarkIrpPending(Irp);
            IoStartPacket(DeviceObject, Irp, NULL, NULL);

        }
        return STATUS_PENDING;
    }

    case IOCTL_DVD_END_SESSION: {

        PDVD_SESSION_ID sessionId = Irp->AssociatedIrp.SystemBuffer;

        TraceLog((CdromDebugTrace,
                    "DvdDeviceControl: [%p] END_SESSION\n", Irp));

        if (cdData->DvdRpc0Device && cdData->DvdRpc0LicenseFailure) {
            TraceLog((CdromDebugWarning,
                        "DvdDeviceControl: License Failure\n"));
            status = STATUS_COPY_PROTECTION_FAILURE;
            break;
        }

        if(irpStack->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(DVD_SESSION_ID)) {

            TraceLog((CdromDebugWarning,
                        "DvdDeviceControl: EndSession - input buffer too "
                        "small\n"));
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        IoMarkIrpPending(Irp);

        if(*sessionId == DVD_END_ALL_SESSIONS) {

            status = CdRomDvdEndAllSessionsCompletion(DeviceObject, Irp, NULL);

            if(status == STATUS_SUCCESS) {

                //
                // Just complete the request - it was never issued to the
                // lower device
                //

                break;

            } else {

                return STATUS_PENDING;

            }
        }

        IoStartPacket(DeviceObject, Irp, NULL, NULL);

        return STATUS_PENDING;
    }

    case IOCTL_DVD_GET_REGION: {

        PDVD_COPY_PROTECT_KEY copyProtectKey;
        ULONG keyLength;
        IO_STATUS_BLOCK ioStatus;
        PDVD_DESCRIPTOR_HEADER dvdHeader;
        PDVD_COPYRIGHT_DESCRIPTOR copyRightDescriptor;
        PDVD_REGION dvdRegion;
        PDVD_READ_STRUCTURE readStructure;
        PDVD_RPC_KEY rpcKey;

        TraceLog((CdromDebugTrace,
                    "DvdDeviceControl: [%p] IOCTL_DVD_GET_REGION\n", Irp));

        if (cdData->DvdRpc0Device && cdData->DvdRpc0LicenseFailure) {
            TraceLog((CdromDebugWarning,
                        "DvdDeviceControl: License Failure\n"));
            status = STATUS_COPY_PROTECTION_FAILURE;
            break;
        }

        if(irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(DVD_REGION)) {

            TraceLog((CdromDebugWarning,
                        "DvdDeviceControl: output buffer DVD_REGION too small\n"));
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // figure out how much data buffer we need
        //

        keyLength = max(sizeof(DVD_DESCRIPTOR_HEADER) +
                            sizeof(DVD_COPYRIGHT_DESCRIPTOR),
                        sizeof(DVD_READ_STRUCTURE)
                        );
        keyLength = max(keyLength,
                        DVD_RPC_KEY_LENGTH
                        );

        //
        // round the size to nearest ULONGLONG -- why?
        //

        keyLength += sizeof(ULONGLONG) - (keyLength & (sizeof(ULONGLONG) - 1));

        readStructure = ExAllocatePoolWithTag(NonPagedPool,
                                              keyLength,
                                              DVD_TAG_READ_KEY);
        if (readStructure == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlZeroMemory (readStructure, keyLength);
        readStructure->Format = DvdCopyrightDescriptor;

        //
        // Build a request for READ_STRUCTURE
        //

        ClassSendDeviceIoControlSynchronous(
            IOCTL_DVD_READ_STRUCTURE,
            DeviceObject,
            readStructure,
            keyLength,
            sizeof(DVD_DESCRIPTOR_HEADER) +
                sizeof(DVD_COPYRIGHT_DESCRIPTOR),
            FALSE,
            &ioStatus);

        status = ioStatus.Status;

        if (!NT_SUCCESS(status)) {
            TraceLog((CdromDebugWarning,
                        "CdRomDvdGetRegion => read structure failed %x\n",
                        status));
            ExFreePool(readStructure);
            break;
        }

        //
        // we got the copyright descriptor, so now get the region if possible
        //

        dvdHeader = (PDVD_DESCRIPTOR_HEADER) readStructure;
        copyRightDescriptor = (PDVD_COPYRIGHT_DESCRIPTOR) dvdHeader->Data;

        //
        // the original irp's systembuffer has a copy of the info that
        // should be passed down in the request
        //

        dvdRegion = Irp->AssociatedIrp.SystemBuffer;

        dvdRegion->CopySystem = copyRightDescriptor->CopyrightProtectionType;
        dvdRegion->RegionData = copyRightDescriptor->RegionManagementInformation;

        //
        // now reuse the buffer to request the copy protection info
        //

        copyProtectKey = (PDVD_COPY_PROTECT_KEY) readStructure;
        RtlZeroMemory (copyProtectKey, DVD_RPC_KEY_LENGTH);
        copyProtectKey->KeyLength = DVD_RPC_KEY_LENGTH;
        copyProtectKey->KeyType = DvdGetRpcKey;

        //
        // send a request for READ_KEY
        //

        ClassSendDeviceIoControlSynchronous(
            IOCTL_DVD_READ_KEY,
            DeviceObject,
            copyProtectKey,
            DVD_RPC_KEY_LENGTH,
            DVD_RPC_KEY_LENGTH,
            FALSE,
            &ioStatus);
        status = ioStatus.Status;

        if (!NT_SUCCESS(status)) {
            TraceLog((CdromDebugWarning,
                        "CdRomDvdGetRegion => read key failed %x\n",
                        status));
            ExFreePool(readStructure);
            break;
        }

        //
        // the request succeeded.  if a supported scheme is returned,
        // then return the information to the caller
        //

        rpcKey = (PDVD_RPC_KEY) copyProtectKey->KeyData;

        if (rpcKey->RpcScheme == 1) {

            if (rpcKey->TypeCode) {

                dvdRegion->SystemRegion = ~rpcKey->RegionMask;
                dvdRegion->ResetCount = rpcKey->UserResetsAvailable;

            } else {

                //
                // the drive has not been set for any region
                //

                dvdRegion->SystemRegion = 0;
                dvdRegion->ResetCount = rpcKey->UserResetsAvailable;
            }
            Irp->IoStatus.Information = sizeof(DVD_REGION);

        } else {

            TraceLog((CdromDebugWarning,
                        "CdRomDvdGetRegion => rpcKey->RpcScheme != 1\n"));
            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        ExFreePool(readStructure);
        break;
    }


    case IOCTL_STORAGE_SET_READ_AHEAD: {

        if(irpStack->Parameters.DeviceIoControl.InputBufferLength <
           sizeof(STORAGE_SET_READ_AHEAD)) {

            TraceLog((CdromDebugWarning,
                        "DvdDeviceControl: SetReadAhead buffer too small\n"));
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);

        return STATUS_PENDING;
    }

    case IOCTL_DISK_IS_WRITABLE: {

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);

        return STATUS_PENDING;

    }

    case IOCTL_DISK_GET_DRIVE_LAYOUT: {

        ULONG size;

        //
        // we always fake zero or one partitions, and one partition
        // structure is included in DRIVE_LAYOUT_INFORMATION
        //
        
        size = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION, PartitionEntry[1]);


        TraceLog((CdromDebugTrace,
                    "CdRomDeviceControl: Get drive layout\n"));
        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength < size) {            
            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = size;
            break;
        }
        
        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);
        return STATUS_PENDING;


    }
    case IOCTL_DISK_GET_DRIVE_LAYOUT_EX: {
        
        ULONG size;

        //
        // we always fake zero or one partitions, and one partition
        // structure is included in DRIVE_LAYOUT_INFORMATION_EX
        //

        size = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry[1]);

        TraceLog((CdromDebugTrace,
                    "CdRomDeviceControl: Get drive layout ex\n"));
        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength < size) {            
            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = size;
            break;
        }

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);
        return STATUS_PENDING;    
    
    }

    
    case IOCTL_DISK_GET_PARTITION_INFO: {

        //
        // Check that the buffer is large enough.
        //

        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(PARTITION_INFORMATION)) {

            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = sizeof(PARTITION_INFORMATION);
            break;
        }
        
        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);
        return STATUS_PENDING;
    
    }
    case IOCTL_DISK_GET_PARTITION_INFO_EX: {

        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(PARTITION_INFORMATION_EX)) {

            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = sizeof(PARTITION_INFORMATION_EX);
            break;
        }

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);
        return STATUS_PENDING;
    }

    case IOCTL_DISK_VERIFY: {

        TraceLog((CdromDebugTrace,
                    "IOCTL_DISK_VERIFY to device %p through irp %p\n",
                    DeviceObject, Irp));

        //
        // Validate buffer length.
        //

        if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(VERIFY_INFORMATION)) {

            status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }
        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);
        return STATUS_PENDING;
    }

    case IOCTL_DISK_GET_LENGTH_INFO: {
        
        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(GET_LENGTH_INFORMATION)) {
            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = sizeof(GET_LENGTH_INFORMATION);
            break;
        }
        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);
        return STATUS_PENDING;
    }

    case IOCTL_CDROM_GET_CONFIGURATION: {

        PGET_CONFIGURATION_IOCTL_INPUT inputBuffer;

        TraceLog((CdromDebugTrace,
                    "IOCTL_CDROM_GET_CONFIGURATION to via irp %p\n", Irp));

        //
        // Validate buffer length.
        //

        if (irpStack->Parameters.DeviceIoControl.InputBufferLength !=
            sizeof(GET_CONFIGURATION_IOCTL_INPUT)) {
            status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }
        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(GET_CONFIGURATION_HEADER)) {
            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = sizeof(GET_CONFIGURATION_HEADER);
            break;
        }
        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength > 0xffff) {
            // output buffer is too large
            status = STATUS_INVALID_BUFFER_SIZE;
            break;
        }

        //
        // also verify the arguments are reasonable.
        //

        inputBuffer = Irp->AssociatedIrp.SystemBuffer;
        if (inputBuffer->Feature > 0xffff) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        if ((inputBuffer->RequestType != SCSI_GET_CONFIGURATION_REQUEST_TYPE_ONE) &&
            (inputBuffer->RequestType != SCSI_GET_CONFIGURATION_REQUEST_TYPE_CURRENT) &&
            (inputBuffer->RequestType != SCSI_GET_CONFIGURATION_REQUEST_TYPE_ALL)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        if (inputBuffer->Reserved[0] || inputBuffer->Reserved[1]) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, NULL, NULL);
        return STATUS_PENDING;

    }

    default: {

        BOOLEAN synchronize = (KeGetCurrentIrql() == PASSIVE_LEVEL);
        PKEVENT deviceControlEvent;

        //
        // If the ioctl has come in at passive level then we will synchronize
        // with our start-io routine when sending the ioctl.  If the ioctl
        // has come in at a higher interrupt level and it was not handled
        // above then it's unlikely to be a request for the class DLL - however
        // we'll still use it's common code to forward the request through.
        //

        if (synchronize) {

            deviceControlEvent = ExAllocatePoolWithTag(NonPagedPool,
                                                       sizeof(KEVENT),
                                                       CDROM_TAG_DC_EVENT);

            if (deviceControlEvent == NULL) {

                //
                // must complete this irp unsuccessful here
                //
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;

            } else {

                PIO_STACK_LOCATION currentStack;

                KeInitializeEvent(deviceControlEvent, NotificationEvent, FALSE);

                currentStack = IoGetCurrentIrpStackLocation(Irp);
                nextStack = IoGetNextIrpStackLocation(Irp);

                //
                // Copy the stack down a notch
                //

                IoCopyCurrentIrpStackLocationToNext(Irp);

                IoSetCompletionRoutine(
                    Irp,
                    CdRomClassIoctlCompletion,
                    deviceControlEvent,
                    TRUE,
                    TRUE,
                    TRUE
                    );

                IoSetNextIrpStackLocation(Irp);

                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = 0;

                //
                // Override volume verifies on this stack location so that we
                // will be forced through the synchronization.  Once this
                // location goes away we get the old value back
                //

                SET_FLAG(nextStack->Flags, SL_OVERRIDE_VERIFY_VOLUME);

                IoStartPacket(DeviceObject, Irp, NULL, NULL);

                //
                // Wait for CdRomClassIoctlCompletion to set the event. This
                // ensures serialization remains intact for these unhandled device
                // controls.
                //

                KeWaitForSingleObject(
                    deviceControlEvent,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL);

                ExFreePool(deviceControlEvent);

                TraceLog((CdromDebugTrace,
                            "CdRomDeviceControl: irp %p synchronized\n", Irp));

                status = Irp->IoStatus.Status;
            }

        } else {
            status = STATUS_SUCCESS;
        }

        //
        // If an error occured then propagate that back up - we are no longer
        // guaranteed synchronization and the upper layers will have to
        // retry.
        //
        // If no error occured, call down to the class driver directly
        // then start up the next request.
        //

        if (NT_SUCCESS(status)) {

            UCHAR uniqueAddress;

            //
            // The class device control routine will release the remove
            // lock for this Irp.  We need to make sure we have one
            // available so that it's safe to call IoStartNextPacket
            //

            if(synchronize) {

                ClassAcquireRemoveLock(DeviceObject, (PIRP)&uniqueAddress);

            }

            status = ClassDeviceControl(DeviceObject, Irp);

            if(synchronize) {
                KeRaiseIrql(DISPATCH_LEVEL, &irql);
                IoStartNextPacket(DeviceObject, FALSE);
                KeLowerIrql(irql);
                ClassReleaseRemoveLock(DeviceObject, (PIRP)&uniqueAddress);
            }
            return status;

        }

        //
        // an error occurred (either STATUS_INSUFFICIENT_RESOURCES from
        // attempting to synchronize or  StartIo() error'd this one
        // out), so we need to finish the irp, which is
        // done at the end of this routine.
        //
        break;

    } // end default case

    } // end switch()

    if (status == STATUS_VERIFY_REQUIRED) {

        //
        // If the status is verified required and this request
        // should bypass verify required then retry the request.
        //

        if (irpStack->Flags & SL_OVERRIDE_VERIFY_VOLUME) {

            status = STATUS_IO_DEVICE_ERROR;
            goto RetryControl;

        }
    }

    if (IoIsErrorUserInduced(status)) {

        if (Irp->Tail.Overlay.Thread) {
            IoSetHardErrorOrVerifyDevice(Irp, DeviceObject);
        }

    }

    //
    // Update IRP with completion status.
    //

    Irp->IoStatus.Status = status;

    //
    // Complete the request.
    //

    ClassReleaseRemoveLock(DeviceObject, Irp);
    ClassCompleteRequest(DeviceObject, Irp, IO_DISK_INCREMENT);
    TraceLog((CdromDebugTrace,
                "CdRomDeviceControl: Status is %lx\n", status));
    return status;

} // end CdRomDeviceControl()


NTSTATUS
CdRomClassIoctlCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine signals the event used by CdRomDeviceControl to synchronize
    class driver (and lower level driver) ioctls with cdrom's startio routine.
    The irp completion is short-circuited so that CdRomDeviceControlDispatch
    can reissue it once it wakes up.

Arguments:

    DeviceObject - the device object
    Irp - the request we are synchronizing
    Context - a PKEVENT that we need to signal

Return Value:

    NTSTATUS

--*/
{
    PKEVENT syncEvent = (PKEVENT) Context;

    TraceLog((CdromDebugTrace,
                "CdRomClassIoctlCompletion: setting event for irp %p\n", Irp));

    //
    // We released the lock when we completed this request.  Reacquire it.
    //

    ClassAcquireRemoveLock(DeviceObject, Irp);

    KeSetEvent(syncEvent, IO_DISK_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
CdRomDeviceControlCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PCDROM_DATA         cdData = (PCDROM_DATA)(commonExtension->DriverData);
    BOOLEAN             use6Byte = TEST_FLAG(cdData->XAFlags, XA_USE_6_BYTE);

    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION  realIrpStack;
    PIO_STACK_LOCATION  realIrpNextStack;

    PSCSI_REQUEST_BLOCK srb     = Context;

    PIRP                realIrp = NULL;

    NTSTATUS            status;
    BOOLEAN             retry;

    //
    // Extract the 'real' irp from the irpstack.
    //

    realIrp = (PIRP) irpStack->Parameters.Others.Argument2;
    realIrpStack = IoGetCurrentIrpStackLocation(realIrp);
    realIrpNextStack = IoGetNextIrpStackLocation(realIrp);

    //
    // check that we've really got the correct irp
    //

    ASSERT(realIrpNextStack->Parameters.Others.Argument3 == Irp);

    //
    // Check SRB status for success of completing request.
    //

    if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        ULONG retryInterval;

        TraceLog((CdromDebugTrace,
                    "CdRomDeviceControlCompletion: Irp %p, Srb %p Real Irp %p Status %lx\n",
                    Irp,
                    srb,
                    realIrp,
                    srb->SrbStatus));

        //
        // Release the queue if it is frozen.
        //

        if (srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {
            TraceLog((CdromDebugTrace,
                        "CdRomDeviceControlCompletion: Releasing Queue\n"));
            ClassReleaseQueue(DeviceObject);
        }


        retry = ClassInterpretSenseInfo(DeviceObject,
                                        srb,
                                        irpStack->MajorFunction,
                                        irpStack->Parameters.DeviceIoControl.IoControlCode,
                                        MAXIMUM_RETRIES - ((ULONG)(ULONG_PTR)realIrpNextStack->Parameters.Others.Argument1),
                                        &status,
                                        &retryInterval);

        TraceLog((CdromDebugTrace,
                    "CdRomDeviceControlCompletion: IRP will %sbe retried\n",
                    (retry ? "" : "not ")));

        //
        // Some of the Device Controls need special cases on non-Success status's.
        //

        if (realIrpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL) {
            if ((realIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_CDROM_GET_LAST_SESSION) ||
                (realIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_CDROM_READ_TOC)         ||
                (realIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_CDROM_READ_TOC_EX)      ||
                (realIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_CDROM_GET_CONTROL)      ||
                (realIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_CDROM_GET_VOLUME)) {

                if (status == STATUS_DATA_OVERRUN) {
                    status = STATUS_SUCCESS;
                    retry = FALSE;
                }
            }

            if (realIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_CDROM_READ_Q_CHANNEL) {
                PLAY_ACTIVE(fdoExtension) = FALSE;
            }
        }

        //
        // If the status is verified required and the this request
        // should bypass verify required then retry the request.
        //

        if (realIrpStack->Flags & SL_OVERRIDE_VERIFY_VOLUME &&
            status == STATUS_VERIFY_REQUIRED) {

            // note: status gets overwritten here
            status = STATUS_IO_DEVICE_ERROR;
            retry = TRUE;

            if (((realIrpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL) ||
                 (realIrpStack->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL)
                ) &&
                ((realIrpStack->Parameters.DeviceIoControl.IoControlCode ==
                  IOCTL_CDROM_CHECK_VERIFY) ||
                 (realIrpStack->Parameters.DeviceIoControl.IoControlCode ==
                  IOCTL_STORAGE_CHECK_VERIFY) ||
                 (realIrpStack->Parameters.DeviceIoControl.IoControlCode ==
                  IOCTL_STORAGE_CHECK_VERIFY2) ||
                 (realIrpStack->Parameters.DeviceIoControl.IoControlCode ==
                  IOCTL_DISK_CHECK_VERIFY)
                )
               ) {

                //
                // Update the geometry information, as the media could have
                // changed. The completion routine for this will complete
                // the real irp and start the next packet.
                //

                if (srb) {
                    if (srb->SenseInfoBuffer) {
                        ExFreePool(srb->SenseInfoBuffer);
                    }
                    if (srb->DataBuffer) {
                        ExFreePool(srb->DataBuffer);
                    }
                    ExFreePool(srb);
                    srb = NULL;
                }

                if (Irp->MdlAddress) {
                    IoFreeMdl(Irp->MdlAddress);
                    Irp->MdlAddress = NULL;
                }

                IoFreeIrp(Irp);
                Irp = NULL;

                status = CdRomUpdateCapacity(fdoExtension, realIrp, NULL);
                TraceLog((CdromDebugTrace,
                            "CdRomDeviceControlCompletion: [%p] "
                            "CdRomUpdateCapacity completed with status %lx\n",
                            realIrp, status));
                
                //
                // needed to update the capacity.
                // the irp's already handed off to CdRomUpdateCapacity().
                // we've already free'd the current irp.
                // nothing left to do in this code path.
                //
                
                return STATUS_MORE_PROCESSING_REQUIRED;

            } // end of ioctls to update capacity

        }

        if (retry && ((ULONG)(ULONG_PTR)realIrpNextStack->Parameters.Others.Argument1)--) {

            if (((ULONG)(ULONG_PTR)realIrpNextStack->Parameters.Others.Argument1)) {

                //
                // Retry request.
                //

                TraceLog((CdromDebugWarning,
                            "Retry request %p - Calling StartIo\n", Irp));


                ExFreePool(srb->SenseInfoBuffer);
                if (srb->DataBuffer) {
                    ExFreePool(srb->DataBuffer);
                }
                ExFreePool(srb);
                if (Irp->MdlAddress) {
                    IoFreeMdl(Irp->MdlAddress);
                }

                realIrpNextStack->Parameters.Others.Argument3 = (PVOID)-1;
                IoFreeIrp(Irp);

                CdRomRetryRequest(fdoExtension, realIrp, retryInterval, FALSE);
                return STATUS_MORE_PROCESSING_REQUIRED;
            }

            //
            // Exhausted retries. Fall through and complete the request with
            // the appropriate status.
            //

        }
    } else {

        //
        // Set status for successful request.
        //

        status = STATUS_SUCCESS;

    }


    if (NT_SUCCESS(status)) {
        
        BOOLEAN b = FALSE;


        switch (realIrpStack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_CDROM_GET_CONFIGURATION: {
            RtlMoveMemory(realIrp->AssociatedIrp.SystemBuffer,
                          srb->DataBuffer,
                          srb->DataTransferLength);
            realIrp->IoStatus.Information = srb->DataTransferLength;
            break;
        }

        case IOCTL_DISK_GET_LENGTH_INFO: {
            
            PGET_LENGTH_INFORMATION lengthInfo;
            
            CdRomInterpretReadCapacity(DeviceObject,
                                       (PREAD_CAPACITY_DATA)srb->DataBuffer);

            lengthInfo = (PGET_LENGTH_INFORMATION)realIrp->AssociatedIrp.SystemBuffer;
            lengthInfo->Length = commonExtension->PartitionLength;
            realIrp->IoStatus.Information = sizeof(GET_LENGTH_INFORMATION);
            status = STATUS_SUCCESS;
            break;
        }

        case IOCTL_DISK_GET_DRIVE_GEOMETRY_EX:
        case IOCTL_CDROM_GET_DRIVE_GEOMETRY_EX: {
            
            PDISK_GEOMETRY_EX geometryEx;
            
            CdRomInterpretReadCapacity(DeviceObject,
                                       (PREAD_CAPACITY_DATA)srb->DataBuffer);

            geometryEx = (PDISK_GEOMETRY_EX)(realIrp->AssociatedIrp.SystemBuffer);
            geometryEx->DiskSize = commonExtension->PartitionLength;
            geometryEx->Geometry = fdoExtension->DiskGeometry;
            realIrp->IoStatus.Information =
                FIELD_OFFSET(DISK_GEOMETRY_EX, Data);
            break;
        }

        case IOCTL_DISK_GET_DRIVE_GEOMETRY:
        case IOCTL_CDROM_GET_DRIVE_GEOMETRY: {

            PDISK_GEOMETRY geometry;
            
            CdRomInterpretReadCapacity(DeviceObject,
                                       (PREAD_CAPACITY_DATA)srb->DataBuffer);

            geometry = (PDISK_GEOMETRY)(realIrp->AssociatedIrp.SystemBuffer);
            *geometry = fdoExtension->DiskGeometry;
            realIrp->IoStatus.Information = sizeof(DISK_GEOMETRY);
            break;
        }

        case IOCTL_DISK_VERIFY: {
            //
            // nothing to do but return the status...
            //
            break;
        }

        case IOCTL_DISK_CHECK_VERIFY:
        case IOCTL_STORAGE_CHECK_VERIFY:
        case IOCTL_CDROM_CHECK_VERIFY: {

            if((realIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_CDROM_CHECK_VERIFY) &&
               (realIrpStack->Parameters.DeviceIoControl.OutputBufferLength)) {

                *((PULONG)realIrp->AssociatedIrp.SystemBuffer) =
                    commonExtension->PartitionZeroExtension->MediaChangeCount;

                realIrp->IoStatus.Information = sizeof(ULONG);
            } else {
                realIrp->IoStatus.Information = 0;
            }

            TraceLog((CdromDebugTrace,
                        "CdRomDeviceControlCompletion: [%p] completing "
                        "CHECK_VERIFY buddy irp %p\n", realIrp, Irp));
            break;
        }

        case IOCTL_CDROM_READ_TOC_EX: {

            if (srb->DataTransferLength < MINIMUM_CDROM_READ_TOC_EX_SIZE) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            //
            // Copy the returned info into the user buffer.
            //

            RtlMoveMemory(realIrp->AssociatedIrp.SystemBuffer,
                          srb->DataBuffer,
                          srb->DataTransferLength);

            //
            // update information field.
            //

            realIrp->IoStatus.Information = srb->DataTransferLength;
            break;
        }


        case IOCTL_CDROM_GET_LAST_SESSION:
        case IOCTL_CDROM_READ_TOC: {

            //
            // Copy the returned info into the user buffer.
            //

            RtlMoveMemory(realIrp->AssociatedIrp.SystemBuffer,
                          srb->DataBuffer,
                          srb->DataTransferLength);

            //
            // update information field.
            //

            realIrp->IoStatus.Information = srb->DataTransferLength;
            break;
        }

        case IOCTL_DVD_READ_STRUCTURE: {

            DVD_STRUCTURE_FORMAT format = ((PDVD_READ_STRUCTURE) realIrp->AssociatedIrp.SystemBuffer)->Format;

            PDVD_DESCRIPTOR_HEADER header = realIrp->AssociatedIrp.SystemBuffer;

            FOUR_BYTE fourByte;
            PTWO_BYTE twoByte;
            UCHAR tmp;

            TraceLog((CdromDebugTrace,
                        "DvdDeviceControlCompletion - IOCTL_DVD_READ_STRUCTURE: completing irp %p (buddy %p)\n",
                        Irp,
                        realIrp));

            TraceLog((CdromDebugTrace,
                        "DvdDCCompletion - READ_STRUCTURE: descriptor format of %d\n", format));

            RtlMoveMemory(header,
                          srb->DataBuffer,
                          srb->DataTransferLength);

            //
            // Cook the data.  There are a number of fields that really
            // should be byte-swapped for the caller.
            //

            TraceLog((CdromDebugInfo,
                      "DvdDCCompletion - READ_STRUCTURE:\n"
                      "\tHeader at %p\n"
                      "\tDvdDCCompletion - READ_STRUCTURE: data at %p\n"
                      "\tDataBuffer was at %p\n"
                      "\tDataTransferLength was %lx\n",
                      header,
                      header->Data,
                      srb->DataBuffer,
                      srb->DataTransferLength));

            //
            // First the fields in the header
            //

            TraceLog((CdromDebugInfo, "READ_STRUCTURE: header->Length %lx -> ",
                           header->Length));
            REVERSE_SHORT(&header->Length);
            TraceLog((CdromDebugInfo, "%lx\n", header->Length));

            //
            // Now the fields in the descriptor
            //

            if(format == DvdPhysicalDescriptor) {

                PDVD_LAYER_DESCRIPTOR layer = (PDVD_LAYER_DESCRIPTOR) &(header->Data[0]);

                TraceLog((CdromDebugInfo, "READ_STRUCTURE: StartingDataSector %lx -> ",
                               layer->StartingDataSector));
                REVERSE_LONG(&(layer->StartingDataSector));
                TraceLog((CdromDebugInfo, "%lx\n", layer->StartingDataSector));

                TraceLog((CdromDebugInfo, "READ_STRUCTURE: EndDataSector %lx -> ",
                               layer->EndDataSector));
                REVERSE_LONG(&(layer->EndDataSector));
                TraceLog((CdromDebugInfo, "%lx\n", layer->EndDataSector));

                TraceLog((CdromDebugInfo, "READ_STRUCTURE: EndLayerZeroSector %lx -> ",
                               layer->EndLayerZeroSector));
                REVERSE_LONG(&(layer->EndLayerZeroSector));
                TraceLog((CdromDebugInfo, "%lx\n", layer->EndLayerZeroSector));
            }

            TraceLog((CdromDebugTrace, "Status is %lx\n", Irp->IoStatus.Status));
            TraceLog((CdromDebugTrace, "DvdDeviceControlCompletion - "
                        "IOCTL_DVD_READ_STRUCTURE: data transfer length of %d\n",
                        srb->DataTransferLength));

            realIrp->IoStatus.Information = srb->DataTransferLength;
            break;
        }

        case IOCTL_DVD_READ_KEY: {

            PDVD_COPY_PROTECT_KEY copyProtectKey = realIrp->AssociatedIrp.SystemBuffer;

            PCDVD_KEY_HEADER keyHeader = srb->DataBuffer;
            ULONG dataLength;

            ULONG transferLength =
                srb->DataTransferLength -
                FIELD_OFFSET(CDVD_KEY_HEADER, Data);

            //
            // Adjust the data length to ignore the two reserved bytes in the
            // header.
            //

            dataLength = (keyHeader->DataLength[0] << 8) +
                         keyHeader->DataLength[1];
            dataLength -= 2;

            //
            // take the minimum of the transferred length and the
            // length as specified in the header.
            //

            if(dataLength < transferLength) {
                transferLength = dataLength;
            }

            TraceLog((CdromDebugTrace,
                        "DvdDeviceControlCompletion: [%p] - READ_KEY with "
                        "transfer length of (%d or %d) bytes\n",
                        Irp,
                        dataLength,
                        srb->DataTransferLength - 2));

            //
            // Copy the key data into the return buffer
            //
            if(copyProtectKey->KeyType == DvdTitleKey) {

                RtlMoveMemory(copyProtectKey->KeyData,
                              keyHeader->Data + 1,
                              transferLength - 1);
                copyProtectKey->KeyData[transferLength - 1] = 0;

                //
                // If this is a title key then we need to copy the CGMS flags
                // as well.
                //
                copyProtectKey->KeyFlags = *(keyHeader->Data);

            } else {

                RtlMoveMemory(copyProtectKey->KeyData,
                              keyHeader->Data,
                              transferLength);
            }

            copyProtectKey->KeyLength = sizeof(DVD_COPY_PROTECT_KEY);
            copyProtectKey->KeyLength += transferLength;

            realIrp->IoStatus.Information = copyProtectKey->KeyLength;
            break;
        }

        case IOCTL_DVD_START_SESSION: {

            PDVD_SESSION_ID sessionId = realIrp->AssociatedIrp.SystemBuffer;

            PCDVD_KEY_HEADER keyHeader = srb->DataBuffer;
            PCDVD_REPORT_AGID_DATA keyData = (PCDVD_REPORT_AGID_DATA) keyHeader->Data;

            *sessionId = keyData->AGID;

            realIrp->IoStatus.Information = sizeof(DVD_SESSION_ID);

            break;
        }

        case IOCTL_DVD_END_SESSION:
        case IOCTL_DVD_SEND_KEY:
        case IOCTL_DVD_SEND_KEY2:

            //
            // nothing to return
            //
            realIrp->IoStatus.Information = 0;
            break;

        case IOCTL_CDROM_PLAY_AUDIO_MSF:

            PLAY_ACTIVE(fdoExtension) = TRUE;

            break;

        case IOCTL_CDROM_READ_Q_CHANNEL: {

            PSUB_Q_CHANNEL_DATA userChannelData = realIrp->AssociatedIrp.SystemBuffer;
            PCDROM_SUB_Q_DATA_FORMAT inputBuffer = realIrp->AssociatedIrp.SystemBuffer;
            PSUB_Q_CHANNEL_DATA subQPtr = srb->DataBuffer;

#if DBG
            switch( inputBuffer->Format ) {

            case IOCTL_CDROM_CURRENT_POSITION:
                TraceLog((CdromDebugTrace,"CdRomDeviceControlCompletion: Audio Status is %u\n", subQPtr->CurrentPosition.Header.AudioStatus ));
                TraceLog((CdromDebugTrace,"CdRomDeviceControlCompletion: ADR = 0x%x\n", subQPtr->CurrentPosition.ADR ));
                TraceLog((CdromDebugTrace,"CdRomDeviceControlCompletion: Control = 0x%x\n", subQPtr->CurrentPosition.Control ));
                TraceLog((CdromDebugTrace,"CdRomDeviceControlCompletion: Track = %u\n", subQPtr->CurrentPosition.TrackNumber ));
                TraceLog((CdromDebugTrace,"CdRomDeviceControlCompletion: Index = %u\n", subQPtr->CurrentPosition.IndexNumber ));
                TraceLog((CdromDebugTrace,"CdRomDeviceControlCompletion: Absolute Address = %x\n", *((PULONG)subQPtr->CurrentPosition.AbsoluteAddress) ));
                TraceLog((CdromDebugTrace,"CdRomDeviceControlCompletion: Relative Address = %x\n", *((PULONG)subQPtr->CurrentPosition.TrackRelativeAddress) ));
                break;

            case IOCTL_CDROM_MEDIA_CATALOG:
                TraceLog((CdromDebugTrace,"CdRomDeviceControlCompletion: Audio Status is %u\n", subQPtr->MediaCatalog.Header.AudioStatus ));
                TraceLog((CdromDebugTrace,"CdRomDeviceControlCompletion: Mcval is %u\n", subQPtr->MediaCatalog.Mcval ));
                break;

            case IOCTL_CDROM_TRACK_ISRC:
                TraceLog((CdromDebugTrace,"CdRomDeviceControlCompletion: Audio Status is %u\n", subQPtr->TrackIsrc.Header.AudioStatus ));
                TraceLog((CdromDebugTrace,"CdRomDeviceControlCompletion: Tcval is %u\n", subQPtr->TrackIsrc.Tcval ));
                break;

            }
#endif

            //
            // Update the play active status.
            //

            if (subQPtr->CurrentPosition.Header.AudioStatus == AUDIO_STATUS_IN_PROGRESS) {

                PLAY_ACTIVE(fdoExtension) = TRUE;

            } else {

                PLAY_ACTIVE(fdoExtension) = FALSE;

            }

            //
            // Check if output buffer is large enough to contain
            // the data.
            //

            if (realIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                srb->DataTransferLength) {

                srb->DataTransferLength =
                    realIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
            }

            //
            // Copy our buffer into users.
            //

            RtlMoveMemory(userChannelData,
                          subQPtr,
                          srb->DataTransferLength);

            realIrp->IoStatus.Information = srb->DataTransferLength;
            break;
        }

        case IOCTL_CDROM_PAUSE_AUDIO:

            PLAY_ACTIVE(fdoExtension) = FALSE;
            realIrp->IoStatus.Information = 0;
            break;

        case IOCTL_CDROM_RESUME_AUDIO:

            realIrp->IoStatus.Information = 0;
            break;

        case IOCTL_CDROM_SEEK_AUDIO_MSF:

            realIrp->IoStatus.Information = 0;
            break;

        case IOCTL_CDROM_STOP_AUDIO:

            PLAY_ACTIVE(fdoExtension) = FALSE;
            realIrp->IoStatus.Information = 0;
            break;

        case IOCTL_CDROM_GET_CONTROL: {

            PCDROM_AUDIO_CONTROL audioControl = srb->DataBuffer;
            PAUDIO_OUTPUT        audioOutput;
            ULONG                bytesTransferred;

            audioOutput = ClassFindModePage((PCHAR)audioControl,
                                            srb->DataTransferLength,
                                            CDROM_AUDIO_CONTROL_PAGE,
                                            use6Byte);
            //
            // Verify the page is as big as expected.
            //

            bytesTransferred = (ULONG)((PCHAR) audioOutput - (PCHAR) audioControl) +
                               sizeof(AUDIO_OUTPUT);

            if (audioOutput != NULL &&
                srb->DataTransferLength >= bytesTransferred) {

                audioControl->LbaFormat = audioOutput->LbaFormat;

                audioControl->LogicalBlocksPerSecond =
                    (audioOutput->LogicalBlocksPerSecond[0] << (UCHAR)8) |
                    audioOutput->LogicalBlocksPerSecond[1];

                realIrp->IoStatus.Information = sizeof(CDROM_AUDIO_CONTROL);

            } else {
                realIrp->IoStatus.Information = 0;
                status = STATUS_INVALID_DEVICE_REQUEST;
            }
            break;
        }

        case IOCTL_CDROM_GET_VOLUME: {

            PAUDIO_OUTPUT audioOutput;
            PVOLUME_CONTROL volumeControl = srb->DataBuffer;
            ULONG i;
            ULONG bytesTransferred;

            audioOutput = ClassFindModePage((PCHAR)volumeControl,
                                                 srb->DataTransferLength,
                                                 CDROM_AUDIO_CONTROL_PAGE,
                                                 use6Byte);

            //
            // Verify the page is as big as expected.
            //

            bytesTransferred = (ULONG)((PCHAR) audioOutput - (PCHAR) volumeControl) +
                               sizeof(AUDIO_OUTPUT);

            if (audioOutput != NULL &&
                srb->DataTransferLength >= bytesTransferred) {

                for (i=0; i<4; i++) {
                    volumeControl->PortVolume[i] =
                        audioOutput->PortOutput[i].Volume;
                }

                //
                // Set bytes transferred in IRP.
                //

                realIrp->IoStatus.Information = sizeof(VOLUME_CONTROL);

            } else {
                realIrp->IoStatus.Information = 0;
                status = STATUS_INVALID_DEVICE_REQUEST;
            }

            break;
        }

        case IOCTL_CDROM_SET_VOLUME:

            realIrp->IoStatus.Information = 0;
            break;

        default:

            ASSERT(FALSE);
            realIrp->IoStatus.Information = 0;
            status = STATUS_INVALID_DEVICE_REQUEST;

        } // end switch()
    }

    //
    // Deallocate srb and sense buffer.
    //

    if (srb) {
        if (srb->DataBuffer) {
            ExFreePool(srb->DataBuffer);
        }
        if (srb->SenseInfoBuffer) {
            ExFreePool(srb->SenseInfoBuffer);
        }
        ExFreePool(srb);
    }

    if (realIrp->PendingReturned) {
        IoMarkIrpPending(realIrp);
    }

    if (Irp->MdlAddress) {
        IoFreeMdl(Irp->MdlAddress);
    }

    IoFreeIrp(Irp);

    //
    // Set status in completing IRP.
    //

    realIrp->IoStatus.Status = status;

    //
    // Set the hard error if necessary.
    //

    if (!NT_SUCCESS(status) && IoIsErrorUserInduced(status)) {

        //
        // Store DeviceObject for filesystem, and clear
        // in IoStatus.Information field.
        //

        TraceLog((CdromDebugWarning,
                    "CdRomDeviceCompletion - Setting Hard Error on realIrp %p\n",
                    realIrp));
        if (realIrp->Tail.Overlay.Thread) {
            IoSetHardErrorOrVerifyDevice(realIrp, DeviceObject);
        }

        realIrp->IoStatus.Information = 0;
    }
    
    //
    // note: must complete the realIrp, as the completed irp (above)
    //       was self-allocated.
    //

    CdRomCompleteIrpAndStartNextPacketSafely(DeviceObject, realIrp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
CdRomSetVolumeIntermediateCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation(Irp);
    PCDROM_DATA         cdData = (PCDROM_DATA)(commonExtension->DriverData);
    BOOLEAN             use6Byte = TEST_FLAG(cdData->XAFlags, XA_USE_6_BYTE);
    PIO_STACK_LOCATION  realIrpStack;
    PIO_STACK_LOCATION  realIrpNextStack;
    PSCSI_REQUEST_BLOCK srb     = Context;
    PIRP                realIrp = NULL;
    NTSTATUS            status;
    BOOLEAN             retry;

    //
    // Extract the 'real' irp from the irpstack.
    //

    realIrp = (PIRP) irpStack->Parameters.Others.Argument2;
    realIrpStack = IoGetCurrentIrpStackLocation(realIrp);
    realIrpNextStack = IoGetNextIrpStackLocation(realIrp);

    //
    // Check SRB status for success of completing request.
    //

    if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        ULONG retryInterval;

        TraceLog((CdromDebugTrace,
                    "CdRomSetVolumeIntermediateCompletion: Irp %p, Srb %p, Real Irp %p\n",
                    Irp,
                    srb,
                    realIrp));

        //
        // Release the queue if it is frozen.
        //

        if (srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {
            ClassReleaseQueue(DeviceObject);
        }


        retry = ClassInterpretSenseInfo(DeviceObject,
                                            srb,
                                            irpStack->MajorFunction,
                                            irpStack->Parameters.DeviceIoControl.IoControlCode,
                                            MAXIMUM_RETRIES - ((ULONG)(ULONG_PTR)realIrpNextStack->Parameters.Others.Argument1),
                                            &status,
                                            &retryInterval);

        if (status == STATUS_DATA_OVERRUN) {
            status = STATUS_SUCCESS;
            retry = FALSE;
        }

        //
        // If the status is verified required and the this request
        // should bypass verify required then retry the request.
        //

        if (realIrpStack->Flags & SL_OVERRIDE_VERIFY_VOLUME &&
            status == STATUS_VERIFY_REQUIRED) {

            status = STATUS_IO_DEVICE_ERROR;
            retry = TRUE;
        }

        if (retry && ((ULONG)(ULONG_PTR)realIrpNextStack->Parameters.Others.Argument1)--) {

            if (((ULONG)(ULONG_PTR)realIrpNextStack->Parameters.Others.Argument1)) {

                //
                // Retry request.
                //

                TraceLog((CdromDebugWarning,
                            "Retry request %p - Calling StartIo\n", Irp));


                ExFreePool(srb->SenseInfoBuffer);
                ExFreePool(srb->DataBuffer);
                ExFreePool(srb);
                if (Irp->MdlAddress) {
                    IoFreeMdl(Irp->MdlAddress);
                }

                IoFreeIrp(Irp);

                CdRomRetryRequest(deviceExtension,
                                  realIrp,
                                  retryInterval,
                                  FALSE);

                return STATUS_MORE_PROCESSING_REQUIRED;

            }

            //
            // Exhausted retries. Fall through and complete the request with the appropriate status.
            //

        }
    } else {

        //
        // Set status for successful request.
        //

        status = STATUS_SUCCESS;
    
    }

    if (NT_SUCCESS(status)) {

        PAUDIO_OUTPUT   audioInput = NULL;
        PAUDIO_OUTPUT   audioOutput;
        PVOLUME_CONTROL volumeControl = realIrp->AssociatedIrp.SystemBuffer;
        ULONG           i,bytesTransferred,headerLength;
        PVOID           dataBuffer;
        PCDB            cdb;

        audioInput = ClassFindModePage((PCHAR)srb->DataBuffer,
                                             srb->DataTransferLength,
                                             CDROM_AUDIO_CONTROL_PAGE,
                                             use6Byte);

        //
        // Check to make sure the mode sense data is valid before we go on
        //

        if(audioInput == NULL) {

            TraceLog((CdromDebugWarning,
                        "Mode Sense Page %d not found\n",
                        CDROM_AUDIO_CONTROL_PAGE));

            realIrp->IoStatus.Information = 0;
            realIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
            goto SafeExit;
        }

        if (use6Byte) {
            headerLength = sizeof(MODE_PARAMETER_HEADER);
        } else {
            headerLength = sizeof(MODE_PARAMETER_HEADER10);
        }

        bytesTransferred = sizeof(AUDIO_OUTPUT) + headerLength;

        //
        // Allocate a new buffer for the mode select.
        //

        dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                    bytesTransferred,
                                    CDROM_TAG_VOLUME_INT);

        if (!dataBuffer) {
            realIrp->IoStatus.Information = 0;
            realIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            goto SafeExit;
        }

        RtlZeroMemory(dataBuffer, bytesTransferred);

        //
        // Rebuild the data buffer to include the user requested values.
        //

        audioOutput = (PAUDIO_OUTPUT) ((PCHAR) dataBuffer + headerLength);

        for (i=0; i<4; i++) {
            audioOutput->PortOutput[i].Volume =
                volumeControl->PortVolume[i];
            audioOutput->PortOutput[i].ChannelSelection =
                audioInput->PortOutput[i].ChannelSelection;
        }

        audioOutput->CodePage = CDROM_AUDIO_CONTROL_PAGE;
        audioOutput->ParameterLength = sizeof(AUDIO_OUTPUT) - 2;
        audioOutput->Immediate = MODE_SELECT_IMMEDIATE;

        //
        // Free the old data buffer, mdl.
        //

        IoFreeMdl(Irp->MdlAddress);
        Irp->MdlAddress = NULL;
        ExFreePool(srb->DataBuffer);

        //
        // set the data buffer to new allocation, so it can be
        // freed in the exit path
        //
        
        srb->DataBuffer = dataBuffer;

        //
        // rebuild the srb.
        //

        cdb = (PCDB)srb->Cdb;
        RtlZeroMemory(cdb, CDB12GENERIC_LENGTH);

        srb->SrbStatus = srb->ScsiStatus = 0;
        srb->SrbFlags = deviceExtension->SrbFlags;
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_OUT);
        srb->DataTransferLength = bytesTransferred;

        if (use6Byte) {

            cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
            cdb->MODE_SELECT.ParameterListLength = (UCHAR) bytesTransferred;
            cdb->MODE_SELECT.PFBit = 1;
            srb->CdbLength = 6;
        } else {

            cdb->MODE_SELECT10.OperationCode = SCSIOP_MODE_SELECT10;
            cdb->MODE_SELECT10.ParameterListLength[0] = (UCHAR) (bytesTransferred >> 8);
            cdb->MODE_SELECT10.ParameterListLength[1] = (UCHAR) (bytesTransferred & 0xFF);
            cdb->MODE_SELECT10.PFBit = 1;
            srb->CdbLength = 10;
        }

        //
        // Prepare the MDL
        //

        Irp->MdlAddress = IoAllocateMdl(dataBuffer,
                                        bytesTransferred,
                                        FALSE,
                                        FALSE,
                                        (PIRP) NULL);

        if (!Irp->MdlAddress) {
            realIrp->IoStatus.Information = 0;
            realIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            goto SafeExit;
        }

        MmBuildMdlForNonPagedPool(Irp->MdlAddress);

        irpStack = IoGetNextIrpStackLocation(Irp);
        irpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_SCSI_EXECUTE_IN;
        irpStack->Parameters.Scsi.Srb = srb;

        //
        // reset the irp completion.
        //

        IoSetCompletionRoutine(Irp,
                               CdRomDeviceControlCompletion,
                               srb,
                               TRUE,
                               TRUE,
                               TRUE);
        //
        // Call the port driver.
        //

        IoCallDriver(commonExtension->LowerDeviceObject, Irp);

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

SafeExit:

    //
    // Deallocate srb and sense buffer.
    //

    if (srb) {
        if (srb->DataBuffer) {
            ExFreePool(srb->DataBuffer);
        }
        if (srb->SenseInfoBuffer) {
            ExFreePool(srb->SenseInfoBuffer);
        }
        ExFreePool(srb);
    }

    if (Irp->PendingReturned) {
      IoMarkIrpPending(Irp);
    }

    if (realIrp->PendingReturned) {
        IoMarkIrpPending(realIrp);
    }

    if (Irp->MdlAddress) {
        IoFreeMdl(Irp->MdlAddress);
    }

    IoFreeIrp(Irp);

    //
    // Set status in completing IRP.
    //

    realIrp->IoStatus.Status = status;

    //
    // Set the hard error if necessary.
    //

    if (!NT_SUCCESS(status) && IoIsErrorUserInduced(status)) {

        //
        // Store DeviceObject for filesystem, and clear
        // in IoStatus.Information field.
        //

        if (realIrp->Tail.Overlay.Thread) {
            IoSetHardErrorOrVerifyDevice(realIrp, DeviceObject);
        }
        realIrp->IoStatus.Information = 0;
    }

    CdRomCompleteIrpAndStartNextPacketSafely(DeviceObject, realIrp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
CdRomDvdEndAllSessionsCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will setup the next stack location to issue an end session
    to the device.  It will increment the session id in the system buffer
    and issue an END_SESSION for that AGID if the AGID is valid.

    When the new AGID is > 3 this routine will complete the request.

Arguments:

    DeviceObject - the device object for this drive

    Irp - the request

    Context - done

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED if there is another AGID to clear
    status otherwise.

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation(Irp);

    PDVD_SESSION_ID sessionId = Irp->AssociatedIrp.SystemBuffer;

    NTSTATUS status;

    if(++(*sessionId) > MAX_COPY_PROTECT_AGID) {

        //
        // We're done here - just return success and let the io system
        // continue to complete it.
        //

        return STATUS_SUCCESS;

    }

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp,
                           CdRomDvdEndAllSessionsCompletion,
                           NULL,
                           TRUE,
                           FALSE,
                           FALSE);

    IoMarkIrpPending(Irp);

    IoCallDriver(fdoExtension->CommonExtension.DeviceObject, Irp);

    //
    // At this point we have to assume the irp may have already been
    // completed.  Ignore the returned status and return.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
CdRomDvdReadDiskKeyCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine handles the completion of a request to obtain the disk
    key from the dvd media.  It will transform the raw 2K of key data into
    a DVD_COPY_PROTECT_KEY structure and copy back the saved key parameters
    from the context pointer before returning.

Arguments:

    DeviceObject -

    Irp -

    Context - a DVD_COPY_PROTECT_KEY pointer which contains the key
              parameters handed down by the caller.

Return Value:

    STATUS_SUCCESS;

--*/

{
    PDVD_COPY_PROTECT_KEY savedKey = Context;

    PREAD_DVD_STRUCTURES_HEADER rawKey = Irp->AssociatedIrp.SystemBuffer;
    PDVD_COPY_PROTECT_KEY outputKey = Irp->AssociatedIrp.SystemBuffer;

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        //
        // Shift the data down to its new position.
        //

        RtlMoveMemory(outputKey->KeyData,
                      rawKey->Data,
                      sizeof(DVD_DISK_KEY_DESCRIPTOR));

        RtlCopyMemory(outputKey,
                      savedKey,
                      sizeof(DVD_COPY_PROTECT_KEY));

        outputKey->KeyLength = DVD_DISK_KEY_LENGTH;

        Irp->IoStatus.Information = DVD_DISK_KEY_LENGTH;

    } else {

        TraceLog((CdromDebugWarning,
                    "DiskKey Failed with status %x, %p (%x) bytes\n",
                    Irp->IoStatus.Status,
                    (PVOID)Irp->IoStatus.Information,
                    ((rawKey->Length[0] << 16) | rawKey->Length[1])
                    ));

    }

    //
    // release the context block
    //

    ExFreePool(Context);

    return STATUS_SUCCESS;
}

NTSTATUS
CdRomXACompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine executes when the port driver has completed a request.
    It looks at the SRB status in the completing SRB and if not success
    it checks for valid request sense buffer information. If valid, the
    info is used to update status with more precise message of type of
    error. This routine deallocates the SRB.

Arguments:

    DeviceObject - Supplies the device object which represents the logical
        unit.

    Irp - Supplies the Irp which has completed.

    Context - Supplies a pointer to the SRB.

Return Value:

    NT status

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = Context;
    PFUNCTIONAL_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    BOOLEAN retry;

    //
    // Check SRB status for success of completing request.
    //

    if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        ULONG retryInterval;

        TraceLog((CdromDebugTrace, "CdromXAComplete: IRP %p  SRB %p  Status %x\n",
                    Irp, srb, srb->SrbStatus));

        //
        // Release the queue if it is frozen.
        //

        if (srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {
            ClassReleaseQueue(DeviceObject);
        }

        retry = ClassInterpretSenseInfo(
            DeviceObject,
            srb,
            irpStack->MajorFunction,
            irpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL ? irpStack->Parameters.DeviceIoControl.IoControlCode : 0,
            MAXIMUM_RETRIES - irpStack->MinorFunction, // HACKHACK - REF #0001
            &status,
            &retryInterval);

        //
        // If the status is verified required and the this request
        // should bypass verify required then retry the request.
        //

        if (irpStack->Flags & SL_OVERRIDE_VERIFY_VOLUME &&
            status == STATUS_VERIFY_REQUIRED) {

            status = STATUS_IO_DEVICE_ERROR;
            retry = TRUE;
        }

        if (retry) {

            if (irpStack->MinorFunction != 0) { // HACKHACK - REF #0001

                irpStack->MinorFunction--;      // HACKHACK - REF #0001

                //
                // Retry request.
                //

                TraceLog((CdromDebugWarning,
                            "CdRomXACompletion: Retry request %p (%x) - "
                            "Calling StartIo\n", Irp, irpStack->MinorFunction));


                ExFreePool(srb->SenseInfoBuffer);
                ExFreePool(srb);

                //
                // Call StartIo directly since IoStartNextPacket hasn't been called,
                // the serialisation is still intact.
                //

                CdRomRetryRequest(deviceExtension,
                                  Irp,
                                  retryInterval,
                                  FALSE);

                return STATUS_MORE_PROCESSING_REQUIRED;

            }

            //
            // Exhausted retries, fall through and complete the request
            // with the appropriate status
            //

            TraceLog((CdromDebugWarning,
                        "CdRomXACompletion: Retries exhausted for irp %p\n",
                        Irp));

        }

    } else {

        //
        // Set status for successful request.
        //

        status = STATUS_SUCCESS;

    } // end if (SRB_STATUS(srb->SrbStatus) ...

    //
    // Return SRB to nonpaged pool.
    //

    ExFreePool(srb->SenseInfoBuffer);
    ExFreePool(srb);

    //
    // Set status in completing IRP.
    //

    Irp->IoStatus.Status = status;    

    //
    // Set the hard error if necessary.
    //

    if (!NT_SUCCESS(status) &&
        IoIsErrorUserInduced(status) &&
        Irp->Tail.Overlay.Thread != NULL ) {

        //
        // Store DeviceObject for filesystem, and clear
        // in IoStatus.Information field.
        //

        IoSetHardErrorOrVerifyDevice(Irp, DeviceObject);
        Irp->IoStatus.Information = 0;
    }

    //
    // If pending has be returned for this irp then mark the current stack as
    // pending.
    //

    if (Irp->PendingReturned) {
      IoMarkIrpPending(Irp);
    }
    
    {
        KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
        IoStartNextPacket(DeviceObject, FALSE);
        KeLowerIrql(oldIrql);
    }
    ClassReleaseRemoveLock(DeviceObject, Irp);
    
    return status;
}


VOID
CdRomDeviceControlDvdReadStructure(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP OriginalIrp,
    IN PIRP NewIrp,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(OriginalIrp);
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCDB cdb = (PCDB)Srb->Cdb;
    PVOID dataBuffer;

    PDVD_READ_STRUCTURE request;
    USHORT dataLength;
    ULONG blockNumber;
    PFOUR_BYTE fourByte;

    dataLength =
        (USHORT)currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    request = OriginalIrp->AssociatedIrp.SystemBuffer;
    blockNumber =
        (ULONG)(request->BlockByteOffset.QuadPart >> fdoExtension->SectorShift);
    fourByte = (PFOUR_BYTE) &blockNumber;

    Srb->CdbLength = 12;
    Srb->TimeOutValue = fdoExtension->TimeOutValue;
    Srb->SrbFlags = fdoExtension->SrbFlags;
    SET_FLAG(Srb->SrbFlags, SRB_FLAGS_DATA_IN);

    cdb->READ_DVD_STRUCTURE.OperationCode = SCSIOP_READ_DVD_STRUCTURE;
    cdb->READ_DVD_STRUCTURE.RMDBlockNumber[0] = fourByte->Byte3;
    cdb->READ_DVD_STRUCTURE.RMDBlockNumber[1] = fourByte->Byte2;
    cdb->READ_DVD_STRUCTURE.RMDBlockNumber[2] = fourByte->Byte1;
    cdb->READ_DVD_STRUCTURE.RMDBlockNumber[3] = fourByte->Byte0;
    cdb->READ_DVD_STRUCTURE.LayerNumber   = request->LayerNumber;
    cdb->READ_DVD_STRUCTURE.Format        = (UCHAR)request->Format;

#if DBG
    {
        if ((UCHAR)request->Format > DvdMaxDescriptor) {
            TraceLog((CdromDebugWarning,
                        "READ_DVD_STRUCTURE format %x = %s (%x bytes)\n",
                        (UCHAR)request->Format,
                        READ_DVD_STRUCTURE_FORMAT_STRINGS[DvdMaxDescriptor],
                        dataLength
                        ));
        } else {
            TraceLog((CdromDebugWarning,
                        "READ_DVD_STRUCTURE format %x = %s (%x bytes)\n",
                        (UCHAR)request->Format,
                        READ_DVD_STRUCTURE_FORMAT_STRINGS[(UCHAR)request->Format],
                        dataLength
                        ));
        }
    }
#endif // DBG

    if (request->Format == DvdDiskKeyDescriptor) {

        cdb->READ_DVD_STRUCTURE.AGID = (UCHAR) request->SessionId;

    }

    cdb->READ_DVD_STRUCTURE.AllocationLength[0] = (UCHAR)(dataLength >> 8);
    cdb->READ_DVD_STRUCTURE.AllocationLength[1] = (UCHAR)(dataLength & 0xff);
    Srb->DataTransferLength = dataLength;



    dataBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                       dataLength,
                                       DVD_TAG_READ_STRUCTURE);

    if (!dataBuffer) {
        ExFreePool(Srb->SenseInfoBuffer);
        ExFreePool(Srb);
        IoFreeIrp(NewIrp);
        OriginalIrp->IoStatus.Information = 0;
        OriginalIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

        BAIL_OUT(OriginalIrp);
        CdRomCompleteIrpAndStartNextPacketSafely(Fdo, OriginalIrp);
        return;
    }
    RtlZeroMemory(dataBuffer, dataLength);

    NewIrp->MdlAddress = IoAllocateMdl(dataBuffer,
                                       currentIrpStack->Parameters.Read.Length,
                                       FALSE,
                                       FALSE,
                                       (PIRP) NULL);

    if (NewIrp->MdlAddress == NULL) {
        ExFreePool(dataBuffer);
        ExFreePool(Srb->SenseInfoBuffer);
        ExFreePool(Srb);
        IoFreeIrp(NewIrp);
        OriginalIrp->IoStatus.Information = 0;
        OriginalIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

        BAIL_OUT(OriginalIrp);
        CdRomCompleteIrpAndStartNextPacketSafely(Fdo, OriginalIrp);
        return;
    }

    //
    // Prepare the MDL
    //

    MmBuildMdlForNonPagedPool(NewIrp->MdlAddress);

    Srb->DataBuffer = dataBuffer;

    IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, NewIrp);

    return;
}


VOID
CdRomDeviceControlDvdEndSession(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP OriginalIrp,
    IN PIRP NewIrp,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(OriginalIrp);
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCDB cdb = (PCDB)Srb->Cdb;

    PDVD_SESSION_ID sessionId = OriginalIrp->AssociatedIrp.SystemBuffer;

    Srb->CdbLength = 12;
    Srb->TimeOutValue = fdoExtension->TimeOutValue;
    Srb->SrbFlags = fdoExtension->SrbFlags;
    SET_FLAG(Srb->SrbFlags, SRB_FLAGS_NO_DATA_TRANSFER);

    cdb->SEND_KEY.OperationCode = SCSIOP_SEND_KEY;
    cdb->SEND_KEY.AGID = (UCHAR) (*sessionId);
    cdb->SEND_KEY.KeyFormat = DVD_INVALIDATE_AGID;

    IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, NewIrp);
    return;

}


VOID
CdRomDeviceControlDvdStartSessionReadKey(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP OriginalIrp,
    IN PIRP NewIrp,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(OriginalIrp);
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCDB cdb = (PCDB)Srb->Cdb;
    NTSTATUS status;

    PDVD_COPY_PROTECT_KEY keyParameters;
    PCDVD_KEY_HEADER keyBuffer = NULL;

    ULONG keyLength;

    ULONG allocationLength;
    PFOUR_BYTE fourByte;

    //
    // Both of these use REPORT_KEY commands.
    // Determine the size of the input buffer
    //

    if(currentIrpStack->Parameters.DeviceIoControl.IoControlCode ==
       IOCTL_DVD_READ_KEY) {

        keyParameters = OriginalIrp->AssociatedIrp.SystemBuffer;

        keyLength = sizeof(CDVD_KEY_HEADER) +
                    (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength -
                     sizeof(DVD_COPY_PROTECT_KEY));
    } else {

        keyParameters = NULL;
        keyLength = sizeof(CDVD_KEY_HEADER) +
                    sizeof(CDVD_REPORT_AGID_DATA);
    }

    TRY {

        keyBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                          keyLength,
                                          DVD_TAG_READ_KEY);

        if(keyBuffer == NULL) {

            TraceLog((CdromDebugWarning,
                        "IOCTL_DVD_READ_KEY - couldn't allocate "
                        "%d byte buffer for key\n",
                        keyLength));
            status = STATUS_INSUFFICIENT_RESOURCES;
            LEAVE;
        }


        NewIrp->MdlAddress = IoAllocateMdl(keyBuffer,
                                           keyLength,
                                           FALSE,
                                           FALSE,
                                           (PIRP) NULL);

        if(NewIrp->MdlAddress == NULL) {

            TraceLog((CdromDebugWarning,
                        "IOCTL_DVD_READ_KEY - couldn't create mdl\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            LEAVE;
        }

        MmBuildMdlForNonPagedPool(NewIrp->MdlAddress);

        Srb->DataBuffer = keyBuffer;
        Srb->CdbLength = 12;

        cdb->REPORT_KEY.OperationCode = SCSIOP_REPORT_KEY;

        allocationLength = keyLength;
        fourByte = (PFOUR_BYTE) &allocationLength;
        cdb->REPORT_KEY.AllocationLength[0] = fourByte->Byte1;
        cdb->REPORT_KEY.AllocationLength[1] = fourByte->Byte0;

        Srb->DataTransferLength = keyLength;

        //
        // set the specific parameters....
        //

        if(currentIrpStack->Parameters.DeviceIoControl.IoControlCode ==
           IOCTL_DVD_READ_KEY) {

            if(keyParameters->KeyType == DvdTitleKey) {

                ULONG logicalBlockAddress;

                logicalBlockAddress = (ULONG)
                    (keyParameters->Parameters.TitleOffset.QuadPart >>
                     fdoExtension->SectorShift);

                fourByte = (PFOUR_BYTE) &(logicalBlockAddress);

                cdb->REPORT_KEY.LogicalBlockAddress[0] = fourByte->Byte3;
                cdb->REPORT_KEY.LogicalBlockAddress[1] = fourByte->Byte2;
                cdb->REPORT_KEY.LogicalBlockAddress[2] = fourByte->Byte1;
                cdb->REPORT_KEY.LogicalBlockAddress[3] = fourByte->Byte0;
            }

            cdb->REPORT_KEY.KeyFormat = (UCHAR)keyParameters->KeyType;
            cdb->REPORT_KEY.AGID = (UCHAR) keyParameters->SessionId;
            TraceLog((CdromDebugWarning,
                        "CdRomDvdReadKey => sending irp %p for irp %p (%s)\n",
                        NewIrp, OriginalIrp, "READ_KEY"));

        } else {

            cdb->REPORT_KEY.KeyFormat = DVD_REPORT_AGID;
            cdb->REPORT_KEY.AGID = 0;
            TraceLog((CdromDebugWarning,
                        "CdRomDvdReadKey => sending irp %p for irp %p (%s)\n",
                        NewIrp, OriginalIrp, "START_SESSION"));
        }

        Srb->TimeOutValue = fdoExtension->TimeOutValue;
        Srb->SrbFlags = fdoExtension->SrbFlags;
        SET_FLAG(Srb->SrbFlags, SRB_FLAGS_DATA_IN);

        IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, NewIrp);

        status = STATUS_SUCCESS;

    } FINALLY {

        if (!NT_SUCCESS(status)) {

            //
            // An error occured during setup - free resources and
            // complete this request.
            //
            if (NewIrp->MdlAddress != NULL) {
                IoFreeMdl(NewIrp->MdlAddress);
            }

            if (keyBuffer != NULL) {
                ExFreePool(keyBuffer);
            }
            ExFreePool(Srb->SenseInfoBuffer);
            ExFreePool(Srb);
            IoFreeIrp(NewIrp);

            OriginalIrp->IoStatus.Information = 0;
            OriginalIrp->IoStatus.Status = status;

            BAIL_OUT(OriginalIrp);
            CdRomCompleteIrpAndStartNextPacketSafely(Fdo, OriginalIrp);

        } // end !NT_SUCCESS
    }
    return;
}


VOID
CdRomDeviceControlDvdSendKey(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP OriginalIrp,
    IN PIRP NewIrp,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(OriginalIrp);
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCDB cdb = (PCDB)Srb->Cdb;

    PDVD_COPY_PROTECT_KEY key;
    PCDVD_KEY_HEADER keyBuffer = NULL;

    NTSTATUS status;
    ULONG keyLength;
    PFOUR_BYTE fourByte;

    key = OriginalIrp->AssociatedIrp.SystemBuffer;
    keyLength = (key->KeyLength - sizeof(DVD_COPY_PROTECT_KEY)) +
                sizeof(CDVD_KEY_HEADER);

    TRY {

        keyBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                          keyLength,
                                          DVD_TAG_SEND_KEY);

        if(keyBuffer == NULL) {

            TraceLog((CdromDebugWarning,
                        "IOCTL_DVD_SEND_KEY - couldn't allocate "
                        "%d byte buffer for key\n",
                        keyLength));
            status = STATUS_INSUFFICIENT_RESOURCES;
            LEAVE;
        }

        RtlZeroMemory(keyBuffer, keyLength);

        //
        // keylength is decremented here by two because the
        // datalength does not include the header, which is two
        // bytes.  keylength is immediately incremented later
        // by the same amount.
        //

        keyLength -= 2;
        fourByte = (PFOUR_BYTE) &keyLength;
        keyBuffer->DataLength[0] = fourByte->Byte1;
        keyBuffer->DataLength[1] = fourByte->Byte0;
        keyLength += 2;

        //
        // copy the user's buffer to our own allocated buffer
        //

        RtlMoveMemory(keyBuffer->Data,
                      key->KeyData,
                      key->KeyLength - sizeof(DVD_COPY_PROTECT_KEY));


        NewIrp->MdlAddress = IoAllocateMdl(keyBuffer,
                                           keyLength,
                                           FALSE,
                                           FALSE,
                                           (PIRP) NULL);

        if(NewIrp->MdlAddress == NULL) {
            TraceLog((CdromDebugWarning,
                        "IOCTL_DVD_SEND_KEY - couldn't create mdl\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            LEAVE;
        }


        MmBuildMdlForNonPagedPool(NewIrp->MdlAddress);

        Srb->CdbLength = 12;
        Srb->DataBuffer = keyBuffer;
        Srb->DataTransferLength = keyLength;

        Srb->TimeOutValue = fdoExtension->TimeOutValue;
        Srb->SrbFlags = fdoExtension->SrbFlags;
        SET_FLAG(Srb->SrbFlags, SRB_FLAGS_DATA_OUT);

        cdb->REPORT_KEY.OperationCode = SCSIOP_SEND_KEY;

        fourByte = (PFOUR_BYTE) &keyLength;

        cdb->SEND_KEY.ParameterListLength[0] = fourByte->Byte1;
        cdb->SEND_KEY.ParameterListLength[1] = fourByte->Byte0;
        cdb->SEND_KEY.KeyFormat = (UCHAR)key->KeyType;
        cdb->SEND_KEY.AGID = (UCHAR) key->SessionId;

        if (key->KeyType == DvdSetRpcKey) {
            TraceLog((CdromDebugWarning,
                        "IOCTL_DVD_SEND_KEY - Setting RPC2 drive region\n"));
        } else {
            TraceLog((CdromDebugWarning,
                        "IOCTL_DVD_SEND_KEY - key type %x\n", key->KeyType));
        }

        IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, NewIrp);

        status = STATUS_SUCCESS;

    } FINALLY {

        if (!NT_SUCCESS(status)) {

            //
            // An error occured during setup - free resources and
            // complete this request.
            //

            if (NewIrp->MdlAddress != NULL) {
                IoFreeMdl(NewIrp->MdlAddress);
            }

            if (keyBuffer != NULL) {
                ExFreePool(keyBuffer);
            }

            ExFreePool(Srb->SenseInfoBuffer);
            ExFreePool(Srb);
            IoFreeIrp(NewIrp);

            OriginalIrp->IoStatus.Information = 0;
            OriginalIrp->IoStatus.Status = status;

            BAIL_OUT(OriginalIrp);
            CdRomCompleteIrpAndStartNextPacketSafely(Fdo, OriginalIrp);

        }
    }

    return;
}


VOID
CdRomInterpretReadCapacity(
    IN PDEVICE_OBJECT Fdo,
    IN PREAD_CAPACITY_DATA ReadCapacityBuffer
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    ULONG               lastSector;
    ULONG               bps;
    ULONG               lastBit;
    ULONG               tmp;

    ASSERT(ReadCapacityBuffer);
    ASSERT(commonExtension->IsFdo);
    
    TraceLog((CdromDebugError,
                "CdRomInterpretReadCapacity: Entering\n"));

    //
    // Swizzle bytes from Read Capacity and translate into
    // the necessary geometry information in the device extension.
    //

    tmp = ReadCapacityBuffer->BytesPerBlock;
    ((PFOUR_BYTE)&bps)->Byte0 = ((PFOUR_BYTE)&tmp)->Byte3;
    ((PFOUR_BYTE)&bps)->Byte1 = ((PFOUR_BYTE)&tmp)->Byte2;
    ((PFOUR_BYTE)&bps)->Byte2 = ((PFOUR_BYTE)&tmp)->Byte1;
    ((PFOUR_BYTE)&bps)->Byte3 = ((PFOUR_BYTE)&tmp)->Byte0;

    //
    // Insure that bps is a power of 2.
    // This corrects a problem with the HP 4020i CDR where it
    // returns an incorrect number for bytes per sector.
    //

    if (!bps) {
        bps = 2048;
    } else {
        lastBit = (ULONG) -1;
        while (bps) {
            lastBit++;
            bps = bps >> 1;
        }
        bps = 1 << lastBit;
    }

    fdoExtension->DiskGeometry.BytesPerSector = bps;

    TraceLog((CdromDebugTrace, "CdRomInterpretReadCapacity: Calculated bps %#x\n",
                fdoExtension->DiskGeometry.BytesPerSector));

    //
    // Copy last sector in reverse byte order.
    //

    tmp = ReadCapacityBuffer->LogicalBlockAddress;
    ((PFOUR_BYTE)&lastSector)->Byte0 = ((PFOUR_BYTE)&tmp)->Byte3;
    ((PFOUR_BYTE)&lastSector)->Byte1 = ((PFOUR_BYTE)&tmp)->Byte2;
    ((PFOUR_BYTE)&lastSector)->Byte2 = ((PFOUR_BYTE)&tmp)->Byte1;
    ((PFOUR_BYTE)&lastSector)->Byte3 = ((PFOUR_BYTE)&tmp)->Byte0;

    //
    // Calculate sector to byte shift.
    //

    WHICH_BIT(bps, fdoExtension->SectorShift);

    TraceLog((CdromDebugTrace,"CdRomInterpretReadCapacity: Sector size is %d\n",
        fdoExtension->DiskGeometry.BytesPerSector));

    TraceLog((CdromDebugTrace,"CdRomInterpretReadCapacity: Number of Sectors is %d\n",
        lastSector + 1));

    //
    // Calculate media capacity in bytes.
    //

    commonExtension->PartitionLength.QuadPart = (LONGLONG)(lastSector + 1);

    //
    // we've defaulted to 32/64 forever.  don't want to change this now...
    //

    fdoExtension->DiskGeometry.TracksPerCylinder = 0x40;
    fdoExtension->DiskGeometry.SectorsPerTrack = 0x20;

    //
    // Calculate number of cylinders.
    //

    fdoExtension->DiskGeometry.Cylinders.QuadPart = (LONGLONG)((lastSector + 1) / (32 * 64));

    commonExtension->PartitionLength.QuadPart =
        (commonExtension->PartitionLength.QuadPart << fdoExtension->SectorShift);


    ASSERT(TEST_FLAG(Fdo->Characteristics, FILE_REMOVABLE_MEDIA));
    
    //
    // This device supports removable media.
    //

    fdoExtension->DiskGeometry.MediaType = RemovableMedia;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\cdrom\trace.h ===
/*

    WPP_DEFINE_CONTROL_GUID specifies the GUID used for this filter.
    *** REPLACE THE GUID WITH YOUR OWN UNIQUE ID ***
    WPP_DEFINE_BIT allows setting debug bit masks to selectively print.
    
    everything else can revert to the default?

*/

#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(Cdrom,(58db8e03,0537,45cb,b29b,597f6cbebbfd), \
        WPP_DEFINE_BIT(CdromDebugError)         /* bit  0 = 0x00000001 */ \
        WPP_DEFINE_BIT(CdromDebugWarning)       /* bit  1 = 0x00000002 */ \
        WPP_DEFINE_BIT(CdromDebugTrace)         /* bit  2 = 0x00000004 */ \
        WPP_DEFINE_BIT(CdromDebugInfo)          /* bit  3 = 0x00000008 */ \
        WPP_DEFINE_BIT(FilterDebugD04)          /* bit  4 = 0x00000010 */ \
        WPP_DEFINE_BIT(FilterDebugD05)          /* bit  5 = 0x00000020 */ \
        WPP_DEFINE_BIT(FilterDebugD06)          /* bit  6 = 0x00000040 */ \
        WPP_DEFINE_BIT(FilterDebugD07)          /* bit  7 = 0x00000080 */ \
        WPP_DEFINE_BIT(FilterDebugD08)          /* bit  8 = 0x00000100 */ \
        WPP_DEFINE_BIT(FilterDebugD09)          /* bit  9 = 0x00000200 */ \
        WPP_DEFINE_BIT(FilterDebugD10)          /* bit 10 = 0x00000400 */ \
        WPP_DEFINE_BIT(FilterDebugD11)          /* bit 11 = 0x00000800 */ \
        WPP_DEFINE_BIT(FilterDebugD12)          /* bit 12 = 0x00001000 */ \
        WPP_DEFINE_BIT(FilterDebugD13)          /* bit 13 = 0x00002000 */ \
        WPP_DEFINE_BIT(FilterDebugD14)          /* bit 14 = 0x00004000 */ \
        WPP_DEFINE_BIT(FilterDebugD15)          /* bit 15 = 0x00008000 */ \
        WPP_DEFINE_BIT(FilterDebugD16)          /* bit 16 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD17)          /* bit 17 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD18)          /* bit 18 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD19)          /* bit 19 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD20)          /* bit 20 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD21)          /* bit 21 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD22)          /* bit 22 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD23)          /* bit 23 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD24)          /* bit 24 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD25)          /* bit 25 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD26)          /* bit 26 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD27)          /* bit 27 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD28)          /* bit 28 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD29)          /* bit 29 = 0x00000000 */ \
        WPP_DEFINE_BIT(CdromSecError)           /* bit 30 = 0x00000000 */ \
        WPP_DEFINE_BIT(CdromSecInfo)            /* bit 31 = 0x00000000 */ \
        )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\cdrom\sec.h ===
/*--

Copyright (C) Microsoft Corporation, 1999

--*/

// @@BEGIN_DDKSPLIT
/*++

Module Name:

    sec.h

Abstract:

    Private header file for cdrom.sys.  This contains info for
    the obscurity features for RPC Phase 0 drives


Author:

Environment:

    kernel mode only

Notes:


Revision History:

--*/
// @@END_DDKSPLIT

#include "ntddk.h"
#include "classpnp.h"
#include "cdrom.h"

// @@BEGIN_DDKSPLIT

#ifndef INVALID_HANDLE_VALUE
    #define INVALID_HANDLE_VALUE ((HANDLE)-1)
#endif

#define SHIPPING_VERSION 0

#if SHIPPING_VERSION

    #define STATIC   static    // make debugging difficult
    #ifdef  DebugPrint
        #undef DebugPrint
    #endif
    #define DebugPrint(x)      // remove all debug prints
    #define HELP_ME()          // remove all debug prints

#else // !SHIPPING_VERSION

    #define STATIC
    #define HELP_ME() DebugPrint((0, "%s %d\n", __FILE__, __LINE__));

#endif // SHIPPING_VERSION / !SHIPPING_VERSION

#define INVALID_HASH                      ((ULONGLONG)0)

//
// the DVD_RANDOMIZER is an array of ULONGs with which the
// Vendor, ProductId, and Revision are multiplied to generate
// nonobvious names.  Technically, these should be primes.
//
// CHANGE THESE TO LARGE PRIME NUMBERS PRIOR TO SHIP
//

#define DVD_RANDOMIZER_SIZE 10
ULONG DVD_RANDOMIZER[ DVD_RANDOMIZER_SIZE ] = {
//    'henry paul and anne marie gabryjelski   '
    'rneh', 'ap y',
    'a lu', 'a dn',
    ' enn', 'iram',
    'ag e', 'jyrb',
    'ksle', '   i'
    };

typedef struct _DVD_REGISTRY_CONTEXT {
    ULONGLONG DriveHash;
    ULONGLONG DpidHash;
    UCHAR RegionMask;
    UCHAR ResetCount;
} DVD_REGISTRY_CONTEXT, *PDVD_REGISTRY_CONTEXT;

// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\changer\cdchgr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cdchgr.h
//
//--------------------------------------------------------------------------


#include <stdarg.h>
#include <stdio.h>
#include <ntddk.h>
#include <scsi.h>
#include "ntddchgr.h"
#include "ntddscsi.h"



#ifdef DebugPrint
#undef DebugPrint
#endif

#if DBG
#define DebugPrint(x) ChgrDebugPrint x
#else
#define DebugPrint(x)
#endif


VOID
ChgrDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );


//
// Default timeout for all requests.
//

#define CDCHGR_TIMEOUT 30

#define MAX_INQUIRY_DATA 252
#define SLOT_STATE_NOT_INITIALIZED 0x80000000

//
// DriveType identifiers
//

#define ATAPI_25 0x0001
#define TORISAN  0x0002
#define ALPS_25  0x0003
#define NEC_SCSI 0x0004
#define PNR_SCSI 0x0005


//
// Device Extension
//

typedef struct _DEVICE_EXTENSION {

    //
    // Back pointer to device object
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // Device Object for the underlying cdrom device.
    //

    PDEVICE_OBJECT CdromTargetDeviceObject;

    //
    // Determination of the device type.
    //

    ULONG DeviceType;

    //
    // Unique data for the DeviceType.
    // ATAPI_25 will be NumberOfSlots
    //

    ULONG NumberOfSlots;

    //
    // Indicates the currently selected platter of Torisan units.
    // Used in TURs (as the device overloads this command).
    //

    ULONG CurrentPlatter;

    //
    // The mechanism type - Cartridge (1) or individually changable media (0).
    //

    ULONG MechType;

    //
    // Ordinal of the underlying target.
    //

    ULONG CdRomDeviceNumber;

    //
    // PagingPathRequirements
    //
    ULONG PagingPathCount;
    KEVENT PagingPathCountEvent;

    //
    // The address of the underlying cdrom device.
    //

    SCSI_ADDRESS ScsiAddress;

    //
    // Indicates whether InterfaceState is currently set.
    //

    ULONG InterfaceStateSet;

    //
    // Symbolic link setup by IoRegisterDeviceInterface.
    // Used for IoSetDeviceState
    //

    UNICODE_STRING InterfaceName;

    //
    // Cached inquiry data.
    //

    INQUIRYDATA InquiryData;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#define DEVICE_EXTENSION_SIZE sizeof(DEVICE_EXTENSION)


typedef struct _PASS_THROUGH_REQUEST {
    SCSI_PASS_THROUGH Srb;
    SENSE_DATA SenseInfoBuffer;
    CHAR DataBuffer[0];
} PASS_THROUGH_REQUEST, *PPASS_THROUGH_REQUEST;

//
// Changer function declarations.
//


NTSTATUS
SendPassThrough(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PPASS_THROUGH_REQUEST ScsiPassThrough
    );

BOOLEAN
ChgrIoctl(
    IN ULONG Code
    );

NTSTATUS
ChgrGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChgrGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChgrGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChgrGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChgrSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChgrGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChgrInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChgrSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChgrExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChgrReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChgrQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChgrMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SendTorisanCheckVerify(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\changer\cdchgr.c ===
/*++
Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    changer.c

Abstract:


Authors:

    Chuck Park (chuckp)

Environment:

    kernel mode only

Notes:


--*/


#include "cdchgr.h"
#include "ntddcdrm.h"

#include "initguid.h"
#include "ntddstor.h"


//
// Function declarations
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
ChangerAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );


NTSTATUS
ChangerPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerSendToNextDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
ChangerCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ChangerUnload(
    IN PDRIVER_OBJECT DriverObject
    );



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Installable driver initialization entry point.

Arguments:

    DriverObject - Supplies the driver object.

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful

--*/

{

    ULONG i;

    DebugPrint((2,
              "Changer: DriverEntry\n"));

    //
    // Set up the device driver entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = ChangerPassThrough;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = ChangerPassThrough;
    DriverObject->MajorFunction[IRP_MJ_READ]           = ChangerPassThrough;
    DriverObject->MajorFunction[IRP_MJ_WRITE]          = ChangerPassThrough;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ChangerDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = ChangerPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = ChangerPower;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = ChangerPassThrough;
    DriverObject->DriverExtension->AddDevice           = ChangerAddDevice;
    DriverObject->DriverUnload                         = ChangerUnload;

    return STATUS_SUCCESS;

} // end DriverEntry()


NTSTATUS
ChangerCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

 This routine serves create commands. It does no more than
 establish the drivers existence by returning status success.

Arguments:

 DeviceObject
 IRP

Return Value:

 NT Status

--*/

{

 Irp->IoStatus.Status = STATUS_SUCCESS;
 IoCompleteRequest(Irp, 0);

 return STATUS_SUCCESS;

}


NTSTATUS
ChangerAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++
Routine Description:

    Creates and initializes a new filter device object FDO for the
    corresponding PDO.  Then it attaches the device object to the device
    stack of the drivers for the device.

Arguments:

    DriverObject - Changer DriverObject.
    PhysicalDeviceObject - Physical Device Object from the underlying driver

Return Value:

    NTSTATUS
--*/

{
    NTSTATUS          status;
    IO_STATUS_BLOCK   ioStatus;
    PDEVICE_OBJECT    filterDeviceObject;
    PDEVICE_EXTENSION deviceExtension;
    UNICODE_STRING    additionalString;

    DebugPrint((2,
              "ChangerAddDevice\n"));

    //
    // Create a filter device object for the underlying cdrom device.
    //

    status = IoCreateDevice(DriverObject,
                            DEVICE_EXTENSION_SIZE,
                            NULL,
                            FILE_DEVICE_CD_ROM,
                            0,
                            FALSE,
                            &filterDeviceObject);

    if (!NT_SUCCESS(status)) {
        DebugPrint((2,
                  "ChangerAddDevice: IoCreateDevice failed %lx\n",
                  status));
        return status;
    }

    filterDeviceObject->Flags |= DO_DIRECT_IO;

    if (filterDeviceObject->Flags & DO_POWER_INRUSH) {
        DebugPrint((1,
                    "ChangerAddDevice: Someone set DO_POWER_INRUSH?\n",
                    status
                    ));
    } else {
        filterDeviceObject->Flags |= DO_POWER_PAGABLE;
    }

    deviceExtension = (PDEVICE_EXTENSION) filterDeviceObject->DeviceExtension;

    RtlZeroMemory(deviceExtension, DEVICE_EXTENSION_SIZE);

    //
    // Attaches the device object to the highest device object in the chain and
    // return the previously highest device object, which is passed to IoCallDriver
    // when pass IRPs down the device stack
    //

    deviceExtension->CdromTargetDeviceObject =
        IoAttachDeviceToDeviceStack(filterDeviceObject, PhysicalDeviceObject);

    if (deviceExtension->CdromTargetDeviceObject == NULL) {

        DebugPrint((2,
                  "ChangerAddDevice: IoAttachDevice failed %lx\n",
                  STATUS_NO_SUCH_DEVICE));

        IoDeleteDevice(filterDeviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Save the filter device object in the device extension
    //

    deviceExtension->DeviceObject = filterDeviceObject;

    //
    // Initialize the event for PagingPathNotifications
    //

    KeInitializeEvent(&deviceExtension->PagingPathCountEvent,
                      SynchronizationEvent, TRUE);

    //
    // Register interfaces for this device.
    //

    RtlInitUnicodeString(&(deviceExtension->InterfaceName), NULL);
    RtlInitUnicodeString(&(additionalString), L"CdChanger");


    status = IoRegisterDeviceInterface(PhysicalDeviceObject,
                                       (LPGUID) &CdChangerClassGuid,
                                       &additionalString,
                                       &(deviceExtension->InterfaceName));

    DebugPrint((1,
               "Changer: IoRegisterDeviceInterface - status %lx",
               status));

    filterDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return STATUS_SUCCESS;

} // end ChangerAddDevice()


NTSTATUS
ChgrCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )

/*++

Routine Description:

    This completion routine sets the event waited on by the start device.

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp

    Event - a pointer to the event to signal

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    KeSetEvent(Event,
               IO_NO_INCREMENT,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
ChangerStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    CCHAR             dosNameBuffer[64];
    CCHAR             deviceNameBuffer[64];
    STRING            deviceNameString;
    STRING            dosString;
    UNICODE_STRING    dosUnicodeString;
    UNICODE_STRING    unicodeString;
    PIRP              irp2;
    IO_STATUS_BLOCK   ioStatus;
    STORAGE_DEVICE_NUMBER   deviceNumber;
    NTSTATUS          status = STATUS_INSUFFICIENT_RESOURCES;
    KEVENT            event;
    PPASS_THROUGH_REQUEST passThrough = NULL;
    PSCSI_PASS_THROUGH srb;
    PCDB               cdb;

    //
    // Get the current changer count.
    //

    //devicesFound = &IoGetConfigurationInformation()->MediumChangerCount;

    //
    // Recreate the deviceName of the underlying cdrom.
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp2 = IoBuildDeviceIoControlRequest(IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                        deviceExtension->CdromTargetDeviceObject,
                                        NULL,
                                        0,
                                        &deviceNumber,
                                        sizeof(STORAGE_DEVICE_NUMBER),
                                        FALSE,
                                        &event,
                                        &ioStatus);
    if (!irp2) {

        DebugPrint((1,
                   "ChangerStartDevice: Insufficient resources for GET_DEVICE_NUMBER request\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto StartDeviceExit;
    }

    status = IoCallDriver(deviceExtension->CdromTargetDeviceObject,irp2);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {

        DebugPrint((1,
                   "ChangerStartDevice: GetDeviceNumber failed %lx\n",
                   status));

        goto StartDeviceExit;
    }

    deviceExtension->CdRomDeviceNumber = deviceNumber.DeviceNumber;

    //
    // Create the the arcname with the same ordinal as the underlying cdrom device.
    //

    sprintf(dosNameBuffer,
            "\\DosDevices\\CdChanger%d",
            deviceExtension->CdRomDeviceNumber);

    RtlInitString(&dosString, dosNameBuffer);

    status = RtlAnsiStringToUnicodeString(&dosUnicodeString,
                                          &dosString,
                                          TRUE);

    if(!NT_SUCCESS(status)) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        dosUnicodeString.Buffer = NULL;
    }

    sprintf(deviceNameBuffer,
            "\\Device\\CdRom%d",
            deviceExtension->CdRomDeviceNumber);

    RtlInitString(&deviceNameString,
                  deviceNameBuffer);

    status = RtlAnsiStringToUnicodeString(&unicodeString,
                                          &deviceNameString,
                                          TRUE);
    if (!NT_SUCCESS(status)) {
       status = STATUS_INSUFFICIENT_RESOURCES;
       unicodeString.Buffer = NULL;
    }

    if (dosUnicodeString.Buffer != NULL && unicodeString.Buffer != NULL) {

        //
        // Link the ChangerName to the Underlying cdrom name.
        //

        IoCreateSymbolicLink(&dosUnicodeString, &unicodeString);

    }

    if (dosUnicodeString.Buffer != NULL) {
        RtlFreeUnicodeString(&dosUnicodeString);
    }

    if (unicodeString.Buffer != NULL ) {
        RtlFreeUnicodeString(&unicodeString);
    }

    if (NT_SUCCESS(status)) {

        ULONG    length;
        ULONG slotCount;

        //
        // Get the inquiry data for the device.
        // The passThrough packet will be re-used throughout.
        // Ensure that the buffer is never larger than MAX_INQUIRY_DATA.
        //

        passThrough = ExAllocatePool(NonPagedPoolCacheAligned, sizeof(PASS_THROUGH_REQUEST) + MAX_INQUIRY_DATA);

        if (!passThrough) {

            DebugPrint((1,
                       "ChangerStartDevice: Insufficient resources for Inquiry request\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto StartDeviceExit;
        }

        srb = &passThrough->Srb;
        RtlZeroMemory(passThrough, sizeof(PASS_THROUGH_REQUEST) + MAX_INQUIRY_DATA);
        cdb = (PCDB)srb->Cdb;

        srb->TimeOutValue = 20;
        srb->CdbLength = CDB6GENERIC_LENGTH;
        srb->DataTransferLength = MAX_INQUIRY_DATA;

        //
        // Set CDB operation code.
        //

        cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

        //
        // Set allocation length to inquiry data buffer size.
        //

        cdb->CDB6INQUIRY.AllocationLength = MAX_INQUIRY_DATA;

        status = SendPassThrough(DeviceObject,
                                 passThrough);



        if (status == STATUS_DATA_OVERRUN) {
            status = STATUS_SUCCESS;
        }

        if (NT_SUCCESS(status)) {

            PINQUIRYDATA inquiryData;
            ULONG inquiryLength;

            //
            // Determine the actual inquiry data length.
            //

            inquiryData = (PINQUIRYDATA)passThrough->DataBuffer;
            inquiryLength = inquiryData->AdditionalLength + FIELD_OFFSET(INQUIRYDATA, Reserved);

            if (inquiryLength > srb->DataTransferLength) {
                inquiryLength = srb->DataTransferLength;
            }

            //
            // Copy to deviceExtension buffer.
            //

            RtlMoveMemory(&deviceExtension->InquiryData,
                          inquiryData,
                          inquiryLength);

            //
            // Assume atapi 2.5, unless it's one of the special drives.
            //

            deviceExtension->DeviceType = ATAPI_25;

            if (RtlCompareMemory(inquiryData->VendorId,"ALPS", 4) == 4) {

                //
                // Nominally supporting the spec. the discChanged bits are ALWAYS set
                // and DiscPresent is set if the cartridge has a tray, not necessarily
                // an actual disc in the tray.
                //

                deviceExtension->DeviceType = ALPS_25;

            } else if ((RtlCompareMemory(inquiryData->VendorId, "TORiSAN CD-ROM CDR-C", 20) == 20) ||
                       (RtlCompareMemory(inquiryData->VendorId, "TORiSAN CD-ROM CDR_C", 20) == 20)) {
                deviceExtension->DeviceType = TORISAN;
                deviceExtension->NumberOfSlots = 3;
                status = STATUS_SUCCESS;
            }
        }

        if (deviceExtension->DeviceType != TORISAN) {

            //
            // Send an unload to ensure that the drive is empty.
            // The spec. specifically states that after HW initialization
            // slot0 is loaded. Good for unaware drivers, but the mech. status
            // will return that slot 0 has media, and a TUR will return that
            // the drive also has media.
            //

            RtlZeroMemory(passThrough, sizeof(PASS_THROUGH_REQUEST));

            /*
            cdb = (PCDB)srb->Cdb;

            srb->CdbLength = CDB12GENERIC_LENGTH;
            srb->TimeOutValue = CDCHGR_TIMEOUT;
            srb->DataTransferLength = 0;

            cdb->LOAD_UNLOAD.OperationCode = SCSIOP_LOAD_UNLOAD_SLOT;
            cdb->LOAD_UNLOAD.Start = 0;
            cdb->LOAD_UNLOAD.LoadEject = 1;

            //
            // Send SCSI command (CDB) to device
            //

            status = SendPassThrough(DeviceObject,
                                      passThrough);

            if (!NT_SUCCESS(status)) {

                //
                // Ignore this error.
                //

                DebugPrint((1,
                           "ChangerPnP - StartDevive: Unload slot0 failed. %lx\n",
                           status));

                status = STATUS_SUCCESS;
            }
            */

            //
            // Now send and build a mech. status request to determine the
            // number of slots that the devices supports.
            //

            length = sizeof(MECHANICAL_STATUS_INFORMATION_HEADER);
            length += (10 * sizeof(SLOT_TABLE_INFORMATION));

            //
            // Build srb and cdb.
            //

            srb = &passThrough->Srb;
            RtlZeroMemory(passThrough, sizeof(PASS_THROUGH_REQUEST) + length);
            cdb = (PCDB)srb->Cdb;

            srb->CdbLength = CDB12GENERIC_LENGTH;
            srb->DataTransferLength = length;
            srb->TimeOutValue = 200;

            cdb->MECH_STATUS.OperationCode = SCSIOP_MECHANISM_STATUS;
            cdb->MECH_STATUS.AllocationLength[0] = (UCHAR)(length >> 8);
            cdb->MECH_STATUS.AllocationLength[1] = (UCHAR)(length & 0xFF);

            status = SendPassThrough(DeviceObject,
                                     passThrough);

            if (status == STATUS_DATA_OVERRUN) {
                status = STATUS_SUCCESS;
            }

            if (NT_SUCCESS(status)) {
                PMECHANICAL_STATUS_INFORMATION_HEADER statusHeader;
                PSLOT_TABLE_INFORMATION slotInfo;
                ULONG currentSlot;

                statusHeader = (PMECHANICAL_STATUS_INFORMATION_HEADER)
                                passThrough->DataBuffer;

                slotCount = statusHeader->NumberAvailableSlots;

                DebugPrint((1,
                           "ChangerPnP - StartDevice: Device has %x slots\n",
                           slotCount));

                deviceExtension->NumberOfSlots = slotCount;
            }
        }

        if (NT_SUCCESS(status)) {

            KeInitializeEvent(&event,NotificationEvent,FALSE);

            //
            // Issue GET_ADDRESS Ioctl to determine path, target, and lun information.
            //

            irp2 = IoBuildDeviceIoControlRequest(IOCTL_SCSI_GET_ADDRESS,
                                                deviceExtension->CdromTargetDeviceObject,
                                                NULL,
                                                0,
                                                &deviceExtension->ScsiAddress,
                                                sizeof(SCSI_ADDRESS),
                                                FALSE,
                                                &event,
                                                &ioStatus);

            if (irp2 != NULL) {
                status = IoCallDriver(deviceExtension->CdromTargetDeviceObject, irp2);

                if (status == STATUS_PENDING) {
                    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
                    status = ioStatus.Status;
                }

                if (NT_SUCCESS(status)) {

                    DebugPrint((1,
                               "GetAddress: Port %x, Path %x, Target %x, Lun %x\n",
                                deviceExtension->ScsiAddress.PortNumber,
                                deviceExtension->ScsiAddress.PathId,
                                deviceExtension->ScsiAddress.TargetId,
                                deviceExtension->ScsiAddress.Lun));


                    if (deviceExtension->DeviceType != TORISAN) {

                        //
                        // Finally send a mode sense capabilities page to find out magazine size, etc.
                        //

                        length = sizeof(MODE_PARAMETER_HEADER10) + sizeof(CDVD_CAPABILITIES_PAGE);
                        RtlZeroMemory(passThrough, sizeof(PASS_THROUGH_REQUEST) + length);

                        srb = &passThrough->Srb;
                        cdb = (PCDB)srb->Cdb;

                        srb->CdbLength = CDB10GENERIC_LENGTH;
                        srb->DataTransferLength = length;
                        srb->TimeOutValue = 20;

                        cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
                        cdb->MODE_SENSE10.PageCode = MODE_PAGE_CAPABILITIES;
                        cdb->MODE_SENSE10.AllocationLength[0] = (UCHAR)(length >> 8);
                        cdb->MODE_SENSE10.AllocationLength[1] = (UCHAR)(length & 0xFF);

                        status = SendPassThrough(DeviceObject,
                                                 passThrough);

                        if (status == STATUS_DATA_OVERRUN) {
                            status = STATUS_SUCCESS;
                        }

                        if (NT_SUCCESS(status)) {
                            PMODE_PARAMETER_HEADER10 modeHeader;
                            PCDVD_CAPABILITIES_PAGE modePage;

                            (ULONG_PTR)modeHeader = (ULONG_PTR)passThrough->DataBuffer;
                            (ULONG_PTR)modePage = (ULONG_PTR)modeHeader;
                            (ULONG_PTR)modePage += sizeof(MODE_PARAMETER_HEADER10);

                            //
                            // Determine whether this device uses a cartridge.
                            //

                            if ( modePage->LoadingMechanismType ==
                                 CDVD_LMT_CHANGER_CARTRIDGE ) {

                                //
                                // Mode data indicates a cartridge.
                                //

                                deviceExtension->MechType = 1;

                            }

                            DebugPrint((1,
                                       "ChangerStartDevice: Cartridge? %x\n",
                                       deviceExtension->MechType));

                            goto StartDeviceExit;

                        } else {

                            goto StartDeviceExit;
                        }
                    } else {

                        //
                        // Torisans have a cartridge, not ind. slots.
                        //

                        deviceExtension->MechType = 1;
                        goto StartDeviceExit;
                    }
                } else {
                    DebugPrint((1,
                               "ChangerStartDevice: GetAddress of Cdrom%x failed. Status %lx\n",
                               deviceExtension->CdRomDeviceNumber,
                               status));

                    goto StartDeviceExit;
                }
            } else {
               status = STATUS_INSUFFICIENT_RESOURCES;
            }

        } else {

            DebugPrint((1,
                       "ChangerPnP - StartDevice: Mechanism status failed %lx.\n",
                       status));

            //
            // Fall through.
            //
        }
    }

StartDeviceExit:

    if (passThrough) {
        ExFreePool(passThrough);
    }

    if (NT_SUCCESS(status)) {
        if (!deviceExtension->InterfaceStateSet) {
            status = IoSetDeviceInterfaceState(&(deviceExtension->InterfaceName),
                                               TRUE);
            deviceExtension->InterfaceStateSet = TRUE;
        }
        Irp->IoStatus.Status = STATUS_SUCCESS;
        return STATUS_SUCCESS;
    } else {
        Irp->IoStatus.Status = status;
        return status;
    }
}


NTSTATUS
ChangerPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch for PNP

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    CCHAR               dosNameBuffer[64];
    STRING              dosString;
    UNICODE_STRING      dosUnicodeString;
    NTSTATUS            status;
    KEVENT              event;

    DebugPrint((2,
               "ChangerPnP\n"));

    switch (irpStack->MinorFunction) {

        case IRP_MN_START_DEVICE: {

            KeInitializeEvent(&event, SynchronizationEvent, FALSE);

            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine( Irp,
                                    ChgrCompletion,
                                    &event,
                                    TRUE,
                                    TRUE,
                                    TRUE);

            status = IoCallDriver(deviceExtension->CdromTargetDeviceObject, Irp);

            KeWaitForSingleObject(&event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            if(!NT_SUCCESS(Irp->IoStatus.Status)) {

                //
                // Cdrom failed to start. Bail now.
                //

                status = Irp->IoStatus.Status;

            } else {

                status = ChangerStartDevice(DeviceObject,
                                            Irp);
            }
            break;
        }

        case IRP_MN_REMOVE_DEVICE: {

            //
            // IoDelete fake dev. obj
            //

            status = IoSetDeviceInterfaceState(&(deviceExtension->InterfaceName),
                                               FALSE);

            deviceExtension->InterfaceStateSet = FALSE;

            RtlFreeUnicodeString(&(deviceExtension->InterfaceName));

            //
            // Poison it.
            //

            RtlInitUnicodeString(&(deviceExtension->InterfaceName), NULL);

            //
            // Delete the symbolic link "CdChangerN".
            //

            sprintf(dosNameBuffer,
                    "\\DosDevices\\CdChanger%d",
                    deviceExtension->CdRomDeviceNumber);

            RtlInitString(&dosString, dosNameBuffer);

            status = RtlAnsiStringToUnicodeString(&dosUnicodeString,
                                                  &dosString,
                                                  TRUE);
            ASSERT(NT_SUCCESS(status));

            if (dosUnicodeString.Buffer != NULL) {
                status = IoDeleteSymbolicLink(&dosUnicodeString);
                RtlFreeUnicodeString(&dosUnicodeString);
            }


            IoDetachDevice(deviceExtension->CdromTargetDeviceObject);

            return ChangerSendToNextDriver(DeviceObject, Irp);
            break;
        }

        case IRP_MN_DEVICE_USAGE_NOTIFICATION: {
            ULONG count;
            BOOLEAN setPagable;

            if (irpStack->Parameters.UsageNotification.Type != DeviceUsageTypePaging) {
                status = ChangerSendToNextDriver(DeviceObject, Irp);
                break; // out of case statement
            }
            //
            // wait on the paging path event
            //

            status = KeWaitForSingleObject(&deviceExtension->PagingPathCountEvent,
                                           Executive, KernelMode,
                                           FALSE, NULL);

            //
            // if removing last paging device, need to set DO_POWER_PAGABLE
            // bit here, and possible re-set it below on failure.
            //

            setPagable = FALSE;
            if (!irpStack->Parameters.UsageNotification.InPath &&
                deviceExtension->PagingPathCount == 1 ) {

                //
                // removing the last paging file.
                // must have DO_POWER_PAGABLE bits set
                //

                if (DeviceObject->Flags & DO_POWER_INRUSH) {
                    DebugPrint((2, "ChangerPnp: last paging file removed "
                                "bug DO_POWER_INRUSH set, so not setting "
                                "DO_POWER_PAGABLE bit for DO %p\n",
                                DeviceObject));
                } else {
                    DebugPrint((2, "ChangerPnp: Setting  PAGABLE "
                                "bit for DO %p\n", DeviceObject));
                    DeviceObject->Flags |= DO_POWER_PAGABLE;
                    setPagable = TRUE;
                }

            }

            //
            // send the irp synchronously
            //

            KeInitializeEvent(&event, SynchronizationEvent, FALSE);
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine( Irp, ChgrCompletion,
                                    &event, TRUE, TRUE, TRUE);
            status = IoCallDriver(deviceExtension->CdromTargetDeviceObject, Irp);
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = Irp->IoStatus.Status;

            //
            // now deal with the failure and success cases.
            // note that we are not allowed to fail the irp
            // once it is sent to the lower drivers.
            //

            if (NT_SUCCESS(status)) {

                IoAdjustPagingPathCount(
                    &deviceExtension->PagingPathCount,
                    irpStack->Parameters.UsageNotification.InPath);

                if (irpStack->Parameters.UsageNotification.InPath) {
                    if (deviceExtension->PagingPathCount == 1) {
                        DebugPrint((2, "ChangerPnp: Clearing PAGABLE bit "
                                    "for DO %p\n", DeviceObject));
                        DeviceObject->Flags &= ~DO_POWER_PAGABLE;
                    }
                }

            } else {

                if (setPagable == TRUE) {
                    DeviceObject->Flags &= ~DO_POWER_PAGABLE;
                    setPagable = FALSE;
                }

            }

            //
            // set the event so the next one can occur.
            //

            KeSetEvent(&deviceExtension->PagingPathCountEvent,
                       IO_NO_INCREMENT, FALSE);
            break;

        }


        default:
            return ChangerSendToNextDriver(DeviceObject, Irp);

    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;

} // end ChangerPnp()


NTSTATUS
ChangerSendToNextDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sends the Irp to the next driver in line
    when the Irp is not processed by this driver.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    DebugPrint((2,
              "ChangerSendToNextDriver\n"));

    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(deviceExtension->CdromTargetDeviceObject, Irp);

} // end ChangerSendToNextDriver()

NTSTATUS
    ChangerPower(
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP Irp
                 )
{
    PDEVICE_EXTENSION deviceExtension;

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    return PoCallDriver(deviceExtension->CdromTargetDeviceObject, Irp);
}


NTSTATUS
ChangerDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine handles the medium changer ioctls, and
    passes down most cdrom ioctls to the target device.

Arguments:

    DeviceObject
    Irp

Return Value:

    Status is returned.

--*/

{
    PDEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;

    DebugPrint((2,
               "ChangerDeviceControl\n"));

    if (ChgrIoctl(irpStack->Parameters.DeviceIoControl.IoControlCode)) {

        switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

            case IOCTL_CHANGER_GET_STATUS:

                DebugPrint((2,
                           "CdChgrDeviceControl: IOCTL_CHANGER_GET_STATUS\n"));

                status = ChgrGetStatus(DeviceObject, Irp);

                break;

            case IOCTL_CHANGER_GET_PARAMETERS:

                DebugPrint((2,
                           "CdChgrDeviceControl: IOCTL_CHANGER_GET_PARAMETERS\n"));

                //
                // Validate buffer length.
                //

                if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(GET_CHANGER_PARAMETERS)) {

                    status = STATUS_INFO_LENGTH_MISMATCH;
                } else {

                    status = ChgrGetParameters(DeviceObject, Irp);

                }

                break;

            case IOCTL_CHANGER_GET_PRODUCT_DATA:

                DebugPrint((2,
                           "CdChgrDeviceControl: IOCTL_CHANGER_GET_PRODUCT_DATA\n"));

                if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(CHANGER_PRODUCT_DATA)) {

                    status = STATUS_INFO_LENGTH_MISMATCH;

                } else {

                    status = ChgrGetProductData(DeviceObject, Irp);
                }

                break;

            case IOCTL_CHANGER_SET_ACCESS:

                DebugPrint((2,
                           "CdChgrDeviceControl: IOCTL_CHANGER_SET_ACCESS\n"));

                if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(CHANGER_SET_ACCESS)) {

                    status = STATUS_INFO_LENGTH_MISMATCH;

                } else if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                           sizeof(CHANGER_SET_ACCESS)) {

                    status = STATUS_INFO_LENGTH_MISMATCH;
                } else {

                    status = ChgrSetAccess(DeviceObject, Irp);
                }

                break;

            case IOCTL_CHANGER_GET_ELEMENT_STATUS:

                DebugPrint((2,
                           "CdChgrDeviceControl: IOCTL_CHANGER_GET_ELEMENT_STATUS\n"));


                if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                    sizeof(CHANGER_READ_ELEMENT_STATUS)) {

                    status = STATUS_INFO_LENGTH_MISMATCH;

                } else {

                    status = ChgrGetElementStatus(DeviceObject, Irp);
                }

                break;

            case IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS:

                DebugPrint((2,
                           "CdChgrDeviceControl: IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS\n"));

                if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                    sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS)) {

                    status = STATUS_INFO_LENGTH_MISMATCH;
                } else {

                    status = ChgrInitializeElementStatus(DeviceObject, Irp);
                }

                break;

            case IOCTL_CHANGER_SET_POSITION:

                DebugPrint((2,
                           "CdChgrDeviceControl: IOCTL_CHANGER_SET_POSITION\n"));


                if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                    sizeof(CHANGER_SET_POSITION)) {

                    status = STATUS_INFO_LENGTH_MISMATCH;
                } else {

                    status = ChgrSetPosition(DeviceObject, Irp);
                }

                break;

            case IOCTL_CHANGER_EXCHANGE_MEDIUM:

                DebugPrint((2,
                           "CdChgrDeviceControl: IOCTL_CHANGER_EXCHANGE_MEDIUM\n"));

                status = ChgrExchangeMedium(DeviceObject, Irp);

                break;

            case IOCTL_CHANGER_MOVE_MEDIUM:

                DebugPrint((2,
                           "CdChgrDeviceControl: IOCTL_CHANGER_MOVE_MEDIUM\n"));


                //if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                //    sizeof(CHANGER_MOVE_MEDIUM)) {

                //    status = STATUS_INFO_LENGTH_MISMATCH;

                //} else

                if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                    sizeof(CHANGER_MOVE_MEDIUM)) {

                    status = STATUS_INFO_LENGTH_MISMATCH;

                } else {

                    status = ChgrMoveMedium(DeviceObject, Irp);
                }

                break;

            case IOCTL_CHANGER_REINITIALIZE_TRANSPORT:

                DebugPrint((2,
                           "CdChgrDeviceControl: IOCTL_CHANGER_REINITIALIZE_TRANSPORT\n"));

                if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                    sizeof(CHANGER_ELEMENT)) {

                    status = STATUS_INFO_LENGTH_MISMATCH;

                } else {

                    status = ChgrReinitializeUnit(DeviceObject, Irp);
                }

                break;

            case IOCTL_CHANGER_QUERY_VOLUME_TAGS:

                DebugPrint((2,
                           "CdChgrDeviceControl: IOCTL_CHANGER_QUERY_VOLUME_TAGS\n"));

                if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                    sizeof(CHANGER_SEND_VOLUME_TAG_INFORMATION)) {

                    status = STATUS_INFO_LENGTH_MISMATCH;

                } else if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                            sizeof(READ_ELEMENT_ADDRESS_INFO)) {

                    status = STATUS_INFO_LENGTH_MISMATCH;

                } else {
                    status = ChgrQueryVolumeTags(DeviceObject, Irp);
                }

                break;

            default:
                DebugPrint((1,
                           "CdChgrDeviceControl: Unhandled IOCTL\n"));

                //
                // Set current stack back one.
                //

                Irp->CurrentLocation++,
                Irp->Tail.Overlay.CurrentStackLocation++;

                //
                // Pass unrecognized device control requests
                // down to next driver layer.
                //

                return IoCallDriver(deviceExtension->CdromTargetDeviceObject, Irp);

        }
    } else {

        if (deviceExtension->DeviceType == TORISAN) {

            ULONG ioctlCode;
            ULONG baseCode;
            ULONG functionCode;

            ioctlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;
            baseCode = ioctlCode >> 16;
            functionCode = (ioctlCode & (~0xffffc003)) >> 2;

            if((functionCode >= 0x200) && (functionCode <= 0x300)) {
                ioctlCode = (ioctlCode & 0x0000ffff) | CTL_CODE(IOCTL_CDROM_BASE, 0, 0, 0);
            }

            if ((ioctlCode == IOCTL_CDROM_CHECK_VERIFY) || (ioctlCode == IOCTL_STORAGE_GET_MEDIA_TYPES_EX)) {

                if (ioctlCode == IOCTL_CDROM_CHECK_VERIFY) {

                    //
                    // The fine torisan drives overload TUR as a method to switch platters. Have to send this down via passthrough with the
                    // appropriate bits set.
                    //

                    status = SendTorisanCheckVerify(DeviceObject, Irp);

                } else if (ioctlCode == IOCTL_STORAGE_GET_MEDIA_TYPES_EX) {


                    PGET_MEDIA_TYPES  mediaTypes = Irp->AssociatedIrp.SystemBuffer;
                    PDEVICE_MEDIA_INFO mediaInfo = &mediaTypes->MediaInfo[0];

                    DebugPrint((1,
                               "ChangerDeviceControl: GET_MEDIA_TYPES\n"));
                    //
                    // Yet another case of having to workaround this design. Media types requires knowing if
                    // media is present. As the cdrom driver will send a TUR, this will always switch to the first
                    // platter. So fake it here.
                    //

                    //
                    // Ensure that buffer is large enough.
                    //

                    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                        sizeof(GET_MEDIA_TYPES)) {

                        //
                        // Buffer too small.
                        //

                        Irp->IoStatus.Information = 0;
                        status = STATUS_INFO_LENGTH_MISMATCH;
                    } else {


                        //
                        // Set the type.
                        //

                        mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaType = CD_ROM;
                        mediaInfo->DeviceSpecific.RemovableDiskInfo.NumberMediaSides = 1;
                        mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaCharacteristics = MEDIA_READ_ONLY;

                        mediaTypes->DeviceType = FILE_DEVICE_CD_ROM;
                        mediaTypes->MediaInfoCount = 1;

                        status = SendTorisanCheckVerify(DeviceObject, Irp);


                        if (NT_SUCCESS(status)) {
                            mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaCharacteristics |= MEDIA_CURRENTLY_MOUNTED;
                        }

                        //todo issue IOCTL_CDROM_GET_DRIVE_GEOMETRY to fill in the geom. information.

                        mediaInfo->DeviceSpecific.RemovableDiskInfo.BytesPerSector = 2048;

                        Irp->IoStatus.Information = sizeof(GET_MEDIA_TYPES);
                        status = STATUS_SUCCESS;
                    }
                }
            } else {

               DebugPrint((1,
                          "CdChgrDeviceControl: Unhandled IOCTL\n"));

               //
               // Set current stack back one.
               //

               Irp->CurrentLocation++,
               Irp->Tail.Overlay.CurrentStackLocation++;

               //
               // Pass unrecognized device control requests
               // down to next driver layer.
               //

               return IoCallDriver(deviceExtension->CdromTargetDeviceObject, Irp);

            }
        } else {

            status = STATUS_SUCCESS;

            if (deviceExtension->CdromTargetDeviceObject->Flags & DO_VERIFY_VOLUME) {

                DebugPrint((1,
                           "ChangerDeviceControl: Volume needs to be verified\n"));

                if (!(irpStack->Flags & SL_OVERRIDE_VERIFY_VOLUME)) {

                    status = STATUS_VERIFY_REQUIRED;
                }
            }

            if (NT_SUCCESS(status)) {

                //
                // Set current stack back one.
                //

                Irp->CurrentLocation++,
                Irp->Tail.Overlay.CurrentStackLocation++;

                //
                // Pass unrecognized device control requests
                // down to next driver layer.
                //

                return IoCallDriver(deviceExtension->CdromTargetDeviceObject, Irp);
            }
        }
    }

    Irp->IoStatus.Status = status;

    if (!NT_SUCCESS(status) && IoIsErrorUserInduced(status)) {

        DebugPrint((1,
                   "Mcd.ChangerDeviceControl: IOCTL %x, status %lx\n",
                    irpStack->Parameters.DeviceIoControl.IoControlCode,
                    status));

        IoSetHardErrorOrVerifyDevice(Irp, DeviceObject);
    }


    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
} // end ChangerDeviceControl()




NTSTATUS
ChangerPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    DebugPrint((2,
              "ChangerPassThrough\n"));

    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(deviceExtension->CdromTargetDeviceObject, Irp);
}


VOID
ChangerUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{

    DebugPrint((1,
              "ChangerUnload\n"));
    return;
}


#if DBG
ULONG ChgrDebugLevel = 0;
UCHAR DebugBuffer[128];
#endif


#if DBG

VOID
ChgrDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all medium changer drivers

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= ChgrDebugLevel) {

        vsprintf(DebugBuffer, DebugMessage, ap);

        DbgPrint(DebugBuffer);
    }

    va_end(ap);

} // end ChgrDebugPrint()

#else

//
// DebugPrint stub
//

VOID
ChgrDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\cdrom\mmc.c ===
/*--

Copyright (C) Microsoft Corporation, 2000

Module Name:

    mmc.c

Abstract:

    This file is used to extend cdrom.sys to detect and use mmc-compatible
    drives' capabilities more wisely.

Environment:

    kernel mode only

Notes:

    SCSI Tape, CDRom and Disk class drivers share common routines
    that can be found in the CLASS directory (..\ntos\dd\class).

Revision History:

--*/

#include "ntddk.h"
#include "classpnp.h"
#include "cdrom.h"
#include "mmc.tmh"



NTSTATUS
CdRomGetConfiguration(
    IN PDEVICE_OBJECT Fdo,
    OUT PGET_CONFIGURATION_HEADER *Buffer,
    OUT PULONG BytesReturned,
    IN FEATURE_NUMBER StartingFeature,
    IN ULONG RequestedType
    );
VOID
CdRompPrintAllFeaturePages(
    IN PGET_CONFIGURATION_HEADER Buffer,
    IN ULONG Usable
    );
NTSTATUS
CdRomUpdateMmcDriveCapabilitiesCompletion(
    IN PDEVICE_OBJECT Unused,
    IN PIRP Irp,
    IN PDEVICE_OBJECT Fdo
    );
VOID
CdRomPrepareUpdateCapabilitiesIrp(
    PDEVICE_OBJECT Fdo
    );

/*++

    NOT DOCUMENTED YET - may be called at up to DISPATCH_LEVEL
    if memory is non-paged
    PRESUMES ALL DATA IS ACCESSIBLE based on FeatureBuffer
    
--*/
VOID
CdRomFindProfileInProfiles(
    IN PFEATURE_DATA_PROFILE_LIST ProfileHeader,
    IN FEATURE_PROFILE_TYPE ProfileToFind,
    OUT PBOOLEAN Found
    )
{
    PFEATURE_DATA_PROFILE_LIST_EX profile;
    ULONG numberOfProfiles;
    ULONG i;
    
    ASSERT((ProfileHeader->Header.AdditionalLength % 4) == 0);

    *Found = FALSE;

    numberOfProfiles = ProfileHeader->Header.AdditionalLength / 4;
    profile = ProfileHeader->Profiles; // zero-sized array
    
    for (i = 0; i < numberOfProfiles; i++) {

        FEATURE_PROFILE_TYPE currentProfile;

        currentProfile =
            (profile->ProfileNumber[0] << 8) |
            (profile->ProfileNumber[1] & 0xff);
        
        if (currentProfile == ProfileToFind) {

            *Found = TRUE;

        }
        
        profile++;
    }
    return;

}


/*++

    NOT DOCUMENTED YET - may be called at up to DISPATCH_LEVEL
    if memory is non-paged
    
--*/
PVOID
CdRomFindFeaturePage(
    IN PGET_CONFIGURATION_HEADER FeatureBuffer,
    IN ULONG Length,
    IN FEATURE_NUMBER Feature
    )
{
    PUCHAR buffer;
    PUCHAR limit;
    
    if (Length < sizeof(GET_CONFIGURATION_HEADER) + sizeof(FEATURE_HEADER)) {
        return NULL;
    }

    //
    // set limit to point to first illegal address
    //

    limit  = (PUCHAR)FeatureBuffer;
    limit += Length;

    //
    // set buffer to point to first page
    //

    buffer = FeatureBuffer->Data;

    //
    // loop through each page until we find the requested one, or
    // until it's not safe to access the entire feature header
    // (if equal, have exactly enough for the feature header)
    //
    while (buffer + sizeof(FEATURE_HEADER) <= limit) {

        PFEATURE_HEADER header = (PFEATURE_HEADER)buffer;
        FEATURE_NUMBER thisFeature;

        thisFeature  =
            (header->FeatureCode[0] << 8) |
            (header->FeatureCode[1]);

        if (thisFeature == Feature) {

            PUCHAR temp;

            //
            // if don't have enough memory to safely access all the feature
            // information, return NULL
            //
            temp = buffer;
            temp += sizeof(FEATURE_HEADER);
            temp += header->AdditionalLength;
            
            if (temp > limit) {

                //
                // this means the transfer was cut-off, an insufficiently
                // small buffer was given, or other arbitrary error.  since
                // it's not safe to view the amount of data (even though
                // the header is safe) in this feature, pretend it wasn't
                // transferred at all...
                //

                KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                           "Feature %x exists, but not safe to access all its "
                           "data.  returning NULL\n", Feature));
                return NULL;
            } else {
                return buffer;
            }
        }

        if (header->AdditionalLength % 4) {
            ASSERT(!"Feature page AdditionalLength field must be integral multiple of 4!\n");
            return NULL;
        }

        buffer += sizeof(FEATURE_HEADER);
        buffer += header->AdditionalLength;
    
    }
    return NULL;
}

/*++

Private so we can later expose to someone wanting to use a preallocated buffer

--*/
NTSTATUS
CdRompGetConfiguration(
    IN PDEVICE_OBJECT Fdo,
    IN PGET_CONFIGURATION_HEADER Buffer,
    IN ULONG BufferSize,
    OUT PULONG ValidBytes,
    IN FEATURE_NUMBER StartingFeature,
    IN ULONG RequestedType
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    PCDROM_DATA cdData;
    SCSI_REQUEST_BLOCK srb;
    PCDB cdb;
    ULONG_PTR returned;
    NTSTATUS status;

    PAGED_CODE();
    ASSERT(Buffer);
    ASSERT(ValidBytes);

    *ValidBytes = 0;
    returned = 0;

    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));
    RtlZeroMemory(Buffer, BufferSize);

    fdoExtension = Fdo->DeviceExtension;
    cdData = (PCDROM_DATA)(fdoExtension->CommonExtension.DriverData);

    if (TEST_FLAG(cdData->HackFlags, CDROM_HACK_BAD_GET_CONFIG_SUPPORT)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    srb.TimeOutValue = CDROM_GET_CONFIGURATION_TIMEOUT;
    srb.CdbLength = 10;

    cdb = (PCDB)srb.Cdb;
    cdb->GET_CONFIGURATION.OperationCode = SCSIOP_GET_CONFIGURATION;
    cdb->GET_CONFIGURATION.RequestType = (UCHAR)RequestedType;
    cdb->GET_CONFIGURATION.StartingFeature[0] = (UCHAR)(StartingFeature >> 8);
    cdb->GET_CONFIGURATION.StartingFeature[1] = (UCHAR)(StartingFeature & 0xff);
    cdb->GET_CONFIGURATION.AllocationLength[0] = (UCHAR)(BufferSize >> 8);
    cdb->GET_CONFIGURATION.AllocationLength[1] = (UCHAR)(BufferSize & 0xff);

    status = ClassSendSrbSynchronous(Fdo,  &srb,  Buffer,
                                     BufferSize, FALSE);
    returned = srb.DataTransferLength;

    KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
               "CdromGetConfiguration: Status was %x\n", status));

    if (NT_SUCCESS(status) || status == STATUS_BUFFER_OVERFLOW) {

        //
        // if returned more than can be stored in a ULONG, return false
        //

        if (returned > (ULONG)(-1)) {
            return STATUS_UNSUCCESSFUL;
        }
        ASSERT(returned <= BufferSize);
        *ValidBytes = (ULONG)returned;
        return STATUS_SUCCESS;

    } else {

        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: failed %x\n", status));
        return status;

    }
    ASSERT(FALSE);
    return STATUS_UNSUCCESSFUL;
}

/*++

    Allocates buffer with configuration info, returns STATUS_SUCCESS
    or an error if one occurred

    NOTE: does not handle case where more than 65000 bytes are returned,
          which requires multiple calls with different starting feature
          numbers.

--*/
NTSTATUS
CdRomGetConfiguration(
    IN PDEVICE_OBJECT Fdo,
    OUT PGET_CONFIGURATION_HEADER *Buffer,
    OUT PULONG BytesReturned,
    IN FEATURE_NUMBER StartingFeature,
    IN ULONG RequestedType
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    GET_CONFIGURATION_HEADER header;  // eight bytes, not a lot
    PGET_CONFIGURATION_HEADER buffer;
    ULONG returned;
    ULONG size;
    ULONG i;
    NTSTATUS status;

    PAGED_CODE();


    fdoExtension = Fdo->DeviceExtension;
    *Buffer = NULL;
    *BytesReturned = 0;

    buffer = NULL;
    returned = 0;

    //
    // send the first request down to just get the header
    //

    status = CdRompGetConfiguration(Fdo, &header, sizeof(header),
                                    &returned, StartingFeature, RequestedType);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // now try again, using information returned to allocate
    // just enough memory
    //

    size = header.DataLength[0] << 24 |
           header.DataLength[1] << 16 |
           header.DataLength[2] <<  8 |
           header.DataLength[3] <<  0 ;


    for (i = 0; i < 4; i++) {

        //
        // the datalength field is the size *following*
        // itself, so adjust accordingly
        //

        size += 4*sizeof(UCHAR);

        //
        // make sure the size is reasonable
        //

        if (size <= sizeof(FEATURE_HEADER)) {
            KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                       "CdromGetConfiguration: drive reports only %x bytes?\n",
                       size));
            return STATUS_UNSUCCESSFUL;
        }

        //
        // allocate the memory
        //

        buffer = (PGET_CONFIGURATION_HEADER)
                 ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                       size,
                                       CDROM_TAG_FEATURE);

        if (buffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // send the first request down to just get the header
        //

        status = CdRompGetConfiguration(Fdo, buffer, size, &returned,
                                        StartingFeature, RequestedType);

        if (!NT_SUCCESS(status)) {
            ExFreePool(buffer);
            return status;
        }

        if (returned > size) {
            ExFreePool(buffer);
            return STATUS_INTERNAL_ERROR;
        }

        returned = buffer->DataLength[0] << 24 |
                   buffer->DataLength[1] << 16 |
                   buffer->DataLength[2] <<  8 |
                   buffer->DataLength[3] <<  0 ;
        returned += 4*sizeof(UCHAR);

        if (returned <= size) {
            *Buffer = buffer;
            *BytesReturned = size;  // amount of 'safe' memory
            return STATUS_SUCCESS;
        }

        //
        // else retry using the new size....
        //

        size = returned;
        ExFreePool(buffer);
        buffer = NULL;
        
    }

    //
    // it failed after a number of attempts, so just fail.
    //

    KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
               "CdRomGetConfiguration: Failed %d attempts to get all feature "
               "information\n", i));
    return STATUS_IO_DEVICE_ERROR;
}

VOID
CdRomIsDeviceMmcDevice(
    IN PDEVICE_OBJECT Fdo,
    OUT PBOOLEAN IsMmc
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PCDROM_DATA cdData = commonExtension->DriverData;
    GET_CONFIGURATION_HEADER localHeader;
    NTSTATUS status;
    ULONG usable;
    ULONG size;
    ULONG previouslyFailed;

    PAGED_CODE();
    ASSERT( commonExtension->IsFdo );

    *IsMmc = FALSE;

    //
    // read the registry in case the drive failed previously,
    // and a timeout is occurring.
    //

    previouslyFailed = FALSE;
    ClassGetDeviceParameter(fdoExtension,
                            CDROM_SUBKEY_NAME,
                            CDROM_NON_MMC_DRIVE_NAME,
                            &previouslyFailed
                            );

    if (previouslyFailed) {
        SET_FLAG(cdData->HackFlags, CDROM_HACK_BAD_GET_CONFIG_SUPPORT);
    }

    //
    // check for the following profiles:
    //
    // ProfileList
    //

    status = CdRompGetConfiguration(Fdo,
                                    &localHeader,
                                    sizeof(localHeader),
                                    &usable,
                                    FeatureProfileList,
                                    SCSI_GET_CONFIGURATION_REQUEST_TYPE_ALL);
    
    if (status == STATUS_INVALID_DEVICE_REQUEST ||
        status == STATUS_NO_MEDIA_IN_DEVICE     ||
        status == STATUS_IO_DEVICE_ERROR        ||
        status == STATUS_IO_TIMEOUT) {
        
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "GetConfiguration Failed (%x), device %p not mmc-compliant\n",
                   status, Fdo
                   ));
        previouslyFailed = TRUE;
        ClassSetDeviceParameter(fdoExtension,
                                CDROM_SUBKEY_NAME,
                                CDROM_NON_MMC_DRIVE_NAME,
                                previouslyFailed
                                );
        return;
    
    } else if (!NT_SUCCESS(status)) {
        
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugError,
                   "GetConfiguration Failed, status %x -- defaulting to -ROM\n",
                   status));
        return;

    } else if (usable < sizeof(GET_CONFIGURATION_HEADER)) {

        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "GetConfiguration Failed, returned only %x bytes!\n", usable));
        previouslyFailed = TRUE;
        ClassSetDeviceParameter(fdoExtension,
                                CDROM_SUBKEY_NAME,
                                CDROM_NON_MMC_DRIVE_NAME,
                                previouslyFailed
                                );
        return;

    }

    size = (localHeader.DataLength[0] << 24) |
           (localHeader.DataLength[1] << 16) |
           (localHeader.DataLength[2] <<  8) |
           (localHeader.DataLength[3] <<  0);

    if(size <= 4) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "GetConfiguration Failed, claims MMC support but doesn't "
                   "correctly return config length!\n"));
        return;
    }
    
    size += 4; // sizeof the datalength fields
    
#if DBG
    {
        PGET_CONFIGURATION_HEADER dbgBuffer;
        NTSTATUS dbgStatus;

        dbgBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                          (SIZE_T)size,
                                          CDROM_TAG_FEATURE);
        if (dbgBuffer != NULL) {
            RtlZeroMemory(dbgBuffer, size);
            
            dbgStatus = CdRompGetConfiguration(Fdo, dbgBuffer, size,
                                               &size, FeatureProfileList,
                                               SCSI_GET_CONFIGURATION_REQUEST_TYPE_ALL);
        
            if (NT_SUCCESS(dbgStatus)) {
                CdRompPrintAllFeaturePages(dbgBuffer, usable);            
            }
            ExFreePool(dbgBuffer);
        }
    }
#endif // DBG
    
    *IsMmc = TRUE;
    return;
}

VOID
CdRompPrintAllFeaturePages(
    IN PGET_CONFIGURATION_HEADER Buffer,
    IN ULONG Usable
    )
{
    PFEATURE_HEADER header;

////////////////////////////////////////////////////////////////////////////////
// items expected to ALWAYS be current
////////////////////////////////////////////////////////////////////////////////
    header = CdRomFindFeaturePage(Buffer, Usable, FeatureProfileList);
    if (header != NULL) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: CurrentProfile %x "
                   "with %x bytes of data at %p\n",
                   Buffer->CurrentProfile[0] << 8 |
                   Buffer->CurrentProfile[1],
                   Usable, Buffer));
    }
    
    header = CdRomFindFeaturePage(Buffer, Usable, FeatureCore);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "CORE Features"
                   ));
    }
    
    header = CdRomFindFeaturePage(Buffer, Usable, FeatureMorphing);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "Morphing"
                   ));
    }
    
    header = CdRomFindFeaturePage(Buffer, Usable, FeatureMultiRead);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "Multi-Read"
                   ));
    }
    header = CdRomFindFeaturePage(Buffer, Usable, FeatureRemovableMedium);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "Removable Medium"
                   ));
    }
    
    header = CdRomFindFeaturePage(Buffer, Usable, FeatureTimeout);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "Timeouts"
                   ));
    }

    header = CdRomFindFeaturePage(Buffer, Usable, FeaturePowerManagement);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "Power Management"
                   ));
    }

    header = CdRomFindFeaturePage(Buffer, Usable, FeatureEmbeddedChanger);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "Embedded Changer"
                   ));
    }

    header = CdRomFindFeaturePage(Buffer, Usable, FeatureLogicalUnitSerialNumber);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "LUN Serial Number"
                   ));
    }


    header = CdRomFindFeaturePage(Buffer, Usable, FeatureMicrocodeUpgrade);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "Microcode Update"
                   ));
    }
        
////////////////////////////////////////////////////////////////////////////////
// items expected not to always be current
////////////////////////////////////////////////////////////////////////////////
    header = CdRomFindFeaturePage(Buffer, Usable, FeatureCDAudioAnalogPlay);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "Analogue CD Audio Operations"
                   ));
    }

    header = CdRomFindFeaturePage(Buffer, Usable, FeatureCdRead);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "reading from CD-ROM/R/RW"
                   ));
    }

    header = CdRomFindFeaturePage(Buffer, Usable, FeatureCdMastering);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "CD Recording (Mastering)"
                   ));
    }

    header = CdRomFindFeaturePage(Buffer, Usable, FeatureCdTrackAtOnce);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "CD Recording (Track At Once)"
                   ));
    }
    
    header = CdRomFindFeaturePage(Buffer, Usable, FeatureDvdCSS);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "DVD CSS"
                   ));
    }

    header = CdRomFindFeaturePage(Buffer, Usable, FeatureDvdRead);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "DVD Structure Reads"
                   ));
    }

    header = CdRomFindFeaturePage(Buffer, Usable, FeatureDvdRecordableWrite);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "DVD Recording (Mastering)"
                   ));
    }

    header = CdRomFindFeaturePage(Buffer, Usable, FeatureDiscControlBlocks);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "DVD Disc Control Blocks"
                   ));
    }

    header = CdRomFindFeaturePage(Buffer, Usable, FeatureFormattable);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "Formatting"
                   ));
    }
    
    header = CdRomFindFeaturePage(Buffer, Usable, FeatureRandomReadable);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "Random Reads"
                   ));
    }
    
    header = CdRomFindFeaturePage(Buffer, Usable, FeatureRandomWritable);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "Random Writes"
                   ));
    }

    header = CdRomFindFeaturePage(Buffer, Usable, FeatureRestrictedOverwrite);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "Restricted Overwrites."
                   ));
    }

    header = CdRomFindFeaturePage(Buffer, Usable, FeatureWriteOnce);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "Write Once Media"
                   ));
    }

    header = CdRomFindFeaturePage(Buffer, Usable, FeatureSectorErasable);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "Sector Erasable Media"
                   ));
    }

    header = CdRomFindFeaturePage(Buffer, Usable, FeatureIncrementalStreamingWritable);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "Incremental Streaming Writing"
                   ));
    }

    header = CdRomFindFeaturePage(Buffer, Usable, FeatureRealTimeStreaming);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "Real-time Streaming Reads"
                   ));
    }
    
    header = CdRomFindFeaturePage(Buffer, Usable, FeatureSMART);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "S.M.A.R.T."
                   ));
    }

    header = CdRomFindFeaturePage(Buffer, Usable, FeatureDefectManagement);
    if (header) {
        KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                   "CdromGetConfiguration: %s %s\n",
                   (header->Current ?
                    "Currently supports" : "Is able to support"),
                   "defect management"
                   ));
    }
    return;
}

NTSTATUS
CdRomUpdateMmcDriveCapabilitiesCompletion(
    IN PDEVICE_OBJECT Unused,
    IN PIRP Irp,
    IN PDEVICE_OBJECT Fdo
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PCDROM_DATA cdData = fdoExtension->CommonExtension.DriverData;
    PCDROM_MMC_EXTENSION mmcData = &(cdData->Mmc);
    PSCSI_REQUEST_BLOCK srb = &(mmcData->CapabilitiesSrb);
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PIRP delayedIrp;
    
    // completion routine should retry as neccessary.
    // when success, clear the flag to allow startio to proceed.
    // else fail original request when retries are exhausted.

    ASSERT(mmcData->CapabilitiesIrp == Irp);

    // for now, if succeeded, just print the new pages.

    if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS) {
        
        //
        // ISSUE-2000/4/20-henrygab - should we try to reallocate if size
        //                            available became larger than what we
        //                            originally allocated?  otherwise, it
        //                            is possible (not probable) that we
        //                            would miss the feature.  can check
        //                            that by finding out what the last
        //                            feature is in the current group.
        //

        BOOLEAN retry;
        ULONG retryInterval;
        
        //
        // Release the queue if it is frozen.
        //

        if (srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {
            ClassReleaseQueue(Fdo);
        }

        retry = ClassInterpretSenseInfo(
                    Fdo,
                    srb,
                    irpStack->MajorFunction,
                    0,
                    MAXIMUM_RETRIES - ((ULONG)(ULONG_PTR)irpStack->Parameters.Others.Argument4),
                    &status,
                    &retryInterval);

        //
        // DATA_OVERRUN is not an error in this case....
        //

        if (status == STATUS_DATA_OVERRUN) {
            status = STATUS_SUCCESS;
        }

        //
        // override verify_volume based on original irp's settings
        //

        if (TEST_FLAG(irpStack->Flags, SL_OVERRIDE_VERIFY_VOLUME) &&
            status == STATUS_VERIFY_REQUIRED) {
            status = STATUS_IO_DEVICE_ERROR;
            retry = TRUE;
        }

        if (retry && ((ULONG)(ULONG_PTR)irpStack->Parameters.Others.Argument4)--) {

            LARGE_INTEGER delay;
            delay.QuadPart = retryInterval;
            delay.QuadPart *= (LONGLONG)1000 * 1000 * 10;
            
            //
            // retry the request
            //

            KdPrintEx((DPFLTR_CDROM_ID, CdromDebugError,
                       "Not using ClassRetryRequest Yet\n"));
            KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                       "Retry update capabilities %p\n", Irp));
            CdRomPrepareUpdateCapabilitiesIrp(Fdo);
            
            CdRomRetryRequest(fdoExtension, Irp, retryInterval, TRUE);

            //
            // ClassRetryRequest(Fdo, Irp, delay);
            //
            
            return STATUS_MORE_PROCESSING_REQUIRED;
        
        }

    } else {
        
        status = STATUS_SUCCESS;

    }

    Irp->IoStatus.Status = status;

    KeSetEvent(&mmcData->CapabilitiesEvent, IO_CD_ROM_INCREMENT, FALSE);


    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
CdRomPrepareUpdateCapabilitiesIrp(
    PDEVICE_OBJECT Fdo
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PCDROM_DATA cdData = fdoExtension->CommonExtension.DriverData;
    PCDROM_MMC_EXTENSION mmcData = &(cdData->Mmc);
    PIO_STACK_LOCATION nextStack;
    PSCSI_REQUEST_BLOCK srb;
    PCDB cdb;
    ULONG bufferSize;
    PIRP irp;
    
    ASSERT(mmcData->UpdateState);
    ASSERT(mmcData->NumDelayedIrps != 0);
    ASSERT(mmcData->CapabilitiesIrp != NULL);
    ASSERT(mmcData->CapabilitiesMdl != NULL);
    ASSERT(mmcData->CapabilitiesBuffer);
    ASSERT(mmcData->CapabilitiesBufferSize != 0);
    ASSERT(fdoExtension->SenseData);
    
    //
    // do *NOT* call IoReuseIrp(), since it would zero out our
    // current irp stack location, which we really don't want
    // to happen.  it would also set the current irp stack location
    // to one greater than currently exists (to give max irp usage),
    // but we don't want that either, since we use the top irp stack.
    //
    // IoReuseIrp(mmcData->CapabilitiesIrp, STATUS_UNSUCCESSFUL);
    //

    irp = mmcData->CapabilitiesIrp;
    srb = &(mmcData->CapabilitiesSrb);
    cdb = (PCDB)(srb->Cdb);
    bufferSize = mmcData->CapabilitiesBufferSize;

    //
    // zero stuff out
    //

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));
    RtlZeroMemory(fdoExtension->SenseData, sizeof(SENSE_DATA));
    RtlZeroMemory(mmcData->CapabilitiesBuffer, bufferSize);
    
    //
    // setup the srb
    //
    
    srb->TimeOutValue = CDROM_GET_CONFIGURATION_TIMEOUT;
    srb->Length = SCSI_REQUEST_BLOCK_SIZE;
    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;
    srb->SenseInfoBuffer = fdoExtension->SenseData;
    srb->DataBuffer = mmcData->CapabilitiesBuffer;
    srb->QueueAction = SRB_SIMPLE_TAG_REQUEST;
    srb->DataTransferLength = mmcData->CapabilitiesBufferSize;
    srb->ScsiStatus = 0;
    srb->SrbStatus = 0;
    srb->NextSrb = NULL;
    srb->OriginalRequest = irp;
    srb->SrbFlags = fdoExtension->SrbFlags;
    srb->CdbLength = 10;
    SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
    SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE);

    //
    // setup the cdb
    //

    cdb->GET_CONFIGURATION.OperationCode = SCSIOP_GET_CONFIGURATION;
    cdb->GET_CONFIGURATION.RequestType = SCSI_GET_CONFIGURATION_REQUEST_TYPE_CURRENT;
    cdb->GET_CONFIGURATION.StartingFeature[0] = 0;
    cdb->GET_CONFIGURATION.StartingFeature[1] = 0;
    cdb->GET_CONFIGURATION.AllocationLength[0] = (UCHAR)(bufferSize >> 8);
    cdb->GET_CONFIGURATION.AllocationLength[1] = (UCHAR)(bufferSize & 0xff);

    //
    // setup the irp
    //

    nextStack = IoGetNextIrpStackLocation(irp);
    nextStack->MajorFunction = IRP_MJ_SCSI;
    nextStack->Parameters.Scsi.Srb = srb;
    irp->MdlAddress = mmcData->CapabilitiesMdl;
    irp->AssociatedIrp.SystemBuffer = mmcData->CapabilitiesBuffer;
    IoSetCompletionRoutine(irp, CdRomUpdateMmcDriveCapabilitiesCompletion, Fdo,
                           TRUE, TRUE, TRUE);

    return;

}

VOID
CdRomUpdateMmcDriveCapabilities(
    IN PDEVICE_OBJECT Fdo,
    IN PVOID Context
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PCDROM_DATA cdData = fdoExtension->CommonExtension.DriverData;
    PCDROM_MMC_EXTENSION mmcData = &(cdData->Mmc);
    PIO_STACK_LOCATION thisStack = IoGetCurrentIrpStackLocation(mmcData->CapabilitiesIrp);
    PSCSI_REQUEST_BLOCK srb = &(mmcData->CapabilitiesSrb);
    NTSTATUS status;


    ASSERT(Context == NULL);

    //
    // NOTE: a remove lock is unneccessary, since the delayed irp
    // will have said lock held for itself, preventing a remove.
    //
    CdRomPrepareUpdateCapabilitiesIrp(Fdo);
    
    ASSERT(thisStack->Parameters.Others.Argument1 == Fdo);
    ASSERT(thisStack->Parameters.Others.Argument2 == mmcData->CapabilitiesBuffer);
    ASSERT(thisStack->Parameters.Others.Argument3 == &(mmcData->CapabilitiesSrb));
    
    mmcData->WriteAllowed = FALSE; // default to read-only

    //
    // set max retries, and also allow volume verify override based on
    // original (delayed) irp
    //
    
    thisStack->Parameters.Others.Argument4 = (PVOID)MAXIMUM_RETRIES;

    //
    // send to self... note that SL_OVERRIDE_VERIFY_VOLUME is not required,
    // as this is IRP_MJ_INTERNAL_DEVICE_CONTROL 
    //

    IoCallDriver(commonExtension->LowerDeviceObject, mmcData->CapabilitiesIrp);

    KeWaitForSingleObject(&mmcData->CapabilitiesEvent,
                          Executive, KernelMode, FALSE, NULL);
    
    status = mmcData->CapabilitiesIrp->IoStatus.Status;
    
    if (!NT_SUCCESS(status)) {

        goto FinishDriveUpdate;
    
    }

    //
    // we've updated the feature set, so update whether or not reads and writes
    // are allowed or not.
    //

    KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
               "CdRomUpdateMmc => Succeeded "
               "--------------------"
               "--------------------\n"));

    /*++
    
    NOTE: It is important to only use srb->DataTransferLength worth
          of data at this point, since the bufferSize is what is
          *available* to use, not what was *actually* used.
    
    --*/

#if DBG
    CdRompPrintAllFeaturePages(mmcData->CapabilitiesBuffer,
                               srb->DataTransferLength);
#endif // DBG

    //
    // update whether or not writes are allowed.  this is currently defined
    // as requiring TargetDefectManagement and RandomWritable features
    //
    {
        PFEATURE_HEADER defectHeader;
        PFEATURE_HEADER writableHeader;

        defectHeader   = CdRomFindFeaturePage(mmcData->CapabilitiesBuffer,
                                              srb->DataTransferLength,
                                              FeatureDefectManagement);
        writableHeader = CdRomFindFeaturePage(mmcData->CapabilitiesBuffer,
                                              srb->DataTransferLength,
                                              FeatureRandomWritable);

        if ((defectHeader != NULL)  && (writableHeader != NULL) &&
            (defectHeader->Current) && (writableHeader->Current)) {

            //
            // this should be the *ONLY* place writes are set to allowed 
            //

            KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                       "CdRomUpdateMmc => Writes *allowed*\n"));
            mmcData->WriteAllowed = TRUE;

        } else {

            if (defectHeader == NULL) {
                KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                           "CdRomUpdateMmc => No writes - %s = %s\n",
                           "defect management", "DNE"));
            } else {
                KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                           "CdRomUpdateMmc => No writes - %s = %s\n",
                           "defect management", "Not Current"));
            }
            if (writableHeader == NULL) {
                KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                           "CdRomUpdateMmc => No writes - %s = %s\n",
                           "sector writable", "DNE"));
            } else {
                KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                           "CdRomUpdateMmc => No writes - %s = %s\n",
                           "sector writable", "Not Current"));
            }
        } // end of feature checking
    } // end of check for writability

    //
    // update the cached partition table information
    //
    // NOTE: THIS WILL CURRENTLY CAUSE A DEADLOCK!
    //
    // ISSUE-2000/06/20-henrygab - partition support not implemented
    //                             IoReadPartitionTable must be done
    //                             at PASSIVE level, requiring a thread
    //                             or worker item or other such method.
    //
#if 0
    status = IoReadPartitionTable(Fdo, 1 << fdoExtension->SectorShift,
                                  TRUE, &mmcData->PartitionList);
    if (!NT_SUCCESS(status)) {

        goto FinishDriveUpdate;

    }
#endif

    status = STATUS_SUCCESS;

FinishDriveUpdate:

    CdRompFlushDelayedList(Fdo, mmcData, status, TRUE);

    return;
}


VOID
CdRompFlushDelayedList(
    IN PDEVICE_OBJECT Fdo,
    IN PCDROM_MMC_EXTENSION MmcData,
    IN NTSTATUS Status,
    IN BOOLEAN CalledFromWorkItem
    )
{
    LIST_ENTRY irpList;
    PLIST_ENTRY listEntry;
    KIRQL oldIrql;

    // NOTE - REF #0002
    //
    // need to set the new state first to prevent deadlocks.
    // this is only done from the workitem, to prevent any
    // edge cases where we'd "lose" the UpdateRequired
    //
    // then, must ignore the state, since it's not guaranteed to
    // be the same any longer.  the only thing left is to handle
    // all the delayed irps by flushing the queue and sending them
    // back onto the StartIo queue for the device.
    //

    if (CalledFromWorkItem) {
        
        LONG oldState;
        LONG newState;

        if (NT_SUCCESS(Status)) {
            newState = CdromMmcUpdateComplete;
        } else {
            newState = CdromMmcUpdateRequired;
        }

        oldState = InterlockedCompareExchange(&MmcData->UpdateState,
                                              newState,
                                              CdromMmcUpdateStarted);
        ASSERT(oldState == CdromMmcUpdateStarted);

    } else {

        //
        // just flushing the queue if not called from the workitem,
        // and we don't want to ever fail the queue in those cases.
        //

        ASSERT(NT_SUCCESS(Status));

    }

    /*
     *  Get all the delayed IRPs into a private list first to avoid an infinite loop 
     *  where irps are added to the DelayedIrpsList while we are siphoning them off.
     */
    InitializeListHead(&irpList);
    KeAcquireSpinLock(&MmcData->DelayedIrpsLock, &oldIrql);
    while (!IsListEmpty(&MmcData->DelayedIrpsList)){
        listEntry = RemoveHeadList(&MmcData->DelayedIrpsList);
        InsertTailList(&irpList, listEntry);
        ASSERT(MmcData->NumDelayedIrps > 0);
        MmcData->NumDelayedIrps--;
    }
    ASSERT(MmcData->NumDelayedIrps == 0);
    KeReleaseSpinLock(&MmcData->DelayedIrpsLock, oldIrql);
    
    // if this assert fires, it means that we have started
    // a workitem when the previous workitem took the delayed
    // irp.  if this happens, then the logic in HACKHACK #0002
    // is either flawed or the rules set within are not being
    // followed.  this would require investigation.
    ASSERT(!IsListEmpty(&irpList));

    //
    // now either succeed or fail all the delayed irps, according
    // to the update status.
    //

    while (!IsListEmpty(&irpList)){
        PIRP irp;
        
        listEntry = RemoveHeadList(&irpList);
        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
        
        irp->Tail.Overlay.DriverContext[0] = 0;
        irp->Tail.Overlay.DriverContext[1] = 0;
        irp->Tail.Overlay.DriverContext[2] = 0;
        irp->Tail.Overlay.DriverContext[3] = 0;

        if (NT_SUCCESS(Status)) {
            
            KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                       "CdRomUpdateMmc => Re-sending delayed irp %p\n",
                       irp));
            IoStartPacket(Fdo, irp, NULL, NULL);

        } else {
            
            KdPrintEx((DPFLTR_CDROM_ID, CdromDebugFeatures,
                       "CdRomUpdateMmc => Failing delayed irp %p with "
                       " status %x\n", irp, Status));
            irp->IoStatus.Information = 0;
            irp->IoStatus.Status = Status;
            ClassReleaseRemoveLock(Fdo, irp);
            IoCompleteRequest(irp, IO_CD_ROM_INCREMENT);

        }

    } // while (list)

    return;

}

VOID
CdRomDeAllocateMmcResources(
    IN PDEVICE_OBJECT Fdo
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PCDROM_DATA cddata = commonExtension->DriverData;
    PCDROM_MMC_EXTENSION mmcData = &cddata->Mmc;
    NTSTATUS status;

    if (mmcData->CapabilitiesWorkItem) {
        IoFreeWorkItem(mmcData->CapabilitiesWorkItem);
        mmcData->CapabilitiesWorkItem = NULL;
    }
    if (mmcData->CapabilitiesIrp) {
        IoFreeIrp(mmcData->CapabilitiesIrp);
        mmcData->CapabilitiesIrp = NULL;
    }
    if (mmcData->CapabilitiesMdl) {
        IoFreeMdl(mmcData->CapabilitiesMdl);
        mmcData->CapabilitiesMdl = NULL;
    }
    if (mmcData->CapabilitiesBuffer) {
        ExFreePool(mmcData->CapabilitiesBuffer);
        mmcData->CapabilitiesBuffer = NULL;
    }
    mmcData->CapabilitiesBuffer = 0;
    mmcData->IsMmc = FALSE;
    mmcData->WriteAllowed = FALSE;
    
    return;
}

NTSTATUS
CdRomAllocateMmcResources(
    IN PDEVICE_OBJECT Fdo
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PCDROM_DATA cddata = commonExtension->DriverData;
    PCDROM_MMC_EXTENSION mmcData = &cddata->Mmc;
    PIO_STACK_LOCATION irpStack;
    NTSTATUS status;

    ASSERT(mmcData->CapabilitiesWorkItem == NULL);
    ASSERT(mmcData->CapabilitiesIrp == NULL);
    ASSERT(mmcData->CapabilitiesMdl == NULL);
    ASSERT(mmcData->CapabilitiesBuffer == NULL);
    ASSERT(mmcData->CapabilitiesBufferSize == 0);

    status = CdRomGetConfiguration(Fdo,
                                   &mmcData->CapabilitiesBuffer,
                                   &mmcData->CapabilitiesBufferSize,
                                   FeatureProfileList,
                                   SCSI_GET_CONFIGURATION_REQUEST_TYPE_ALL);
    if (!NT_SUCCESS(status)) {
        ASSERT(mmcData->CapabilitiesBuffer     == NULL);
        ASSERT(mmcData->CapabilitiesBufferSize == 0);
        return status;
    }
    ASSERT(mmcData->CapabilitiesBuffer     != NULL);
    ASSERT(mmcData->CapabilitiesBufferSize != 0);
    
    mmcData->CapabilitiesMdl = IoAllocateMdl(mmcData->CapabilitiesBuffer,
                                             mmcData->CapabilitiesBufferSize,
                                             FALSE, FALSE, NULL);
    if (mmcData->CapabilitiesMdl == NULL) {
        ExFreePool(mmcData->CapabilitiesBuffer);
        mmcData->CapabilitiesBufferSize = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

        
    mmcData->CapabilitiesIrp = IoAllocateIrp(Fdo->StackSize + 2, FALSE);
    if (mmcData->CapabilitiesIrp == NULL) {
        IoFreeMdl(mmcData->CapabilitiesMdl);
        ExFreePool(mmcData->CapabilitiesBuffer);
        mmcData->CapabilitiesBufferSize = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    mmcData->CapabilitiesWorkItem = IoAllocateWorkItem(Fdo);
    if (mmcData->CapabilitiesWorkItem == NULL) {
        IoFreeIrp(mmcData->CapabilitiesIrp);
        IoFreeMdl(mmcData->CapabilitiesMdl);
        ExFreePool(mmcData->CapabilitiesBuffer);
        mmcData->CapabilitiesBufferSize = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }
            
    //
    // everything has been allocated, so now prepare it all....
    //

    MmBuildMdlForNonPagedPool(mmcData->CapabilitiesMdl);
    InitializeListHead(&mmcData->DelayedIrpsList);
    KeInitializeSpinLock(&mmcData->DelayedIrpsLock);
    mmcData->NumDelayedIrps = 0;

    //
    // use the extra stack for internal bookkeeping
    //
    IoSetNextIrpStackLocation(mmcData->CapabilitiesIrp);
    irpStack = IoGetCurrentIrpStackLocation(mmcData->CapabilitiesIrp);
    irpStack->Parameters.Others.Argument1 = Fdo;
    irpStack->Parameters.Others.Argument2 = mmcData->CapabilitiesBuffer;
    irpStack->Parameters.Others.Argument3 = &(mmcData->CapabilitiesSrb);
    // arg 4 is the retry count

    //
    // set the completion event to FALSE for now
    //

    KeInitializeEvent(&mmcData->CapabilitiesEvent,
                      SynchronizationEvent, FALSE);
    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\cdrom\sec.c ===
/*--

Copyright (C) Microsoft Corporation, 1999

--*/

// @@BEGIN_DDKSPLIT
/*--

Module Name:

    sec.c

Abstract:

    !!! THIS IS SENSITIVE INFORMATION !!!
    THIS CODE MUST NEVER BE INCLUDED IN ANY EXTERNAL DOCUMENTATION

    These functions  MUST  be static to prevent symbols when we ship

Environment:

    kernel mode only

Revision History:

--*/

/*

KEY1 == \Registry\Machine\Software\Microsoft\
DPID == \Registry\Machine\Software\Microsoft\
            Windows NT\CurrentVersion\DigitalProductId [REG_BINARY]

KEY2 == KEY1 + DPID Hash
PHSH == DPID Hash
DHSH == Drive Hash based off vendor, product, revision, and serial no.
UVAL == obfuscated value containing both current region and reset count



Overview:
    KEY1 and DPID must both exist.  furthermore, it is a given that the
    DPID is unique to a machine and changing it is catastrophic.  Based
    upon these presumptions, we use the DPID to create a semi-unique key
    under KEY1 that is based off the DPID (KEY2).  KEY2 will store values
    for each DVD RPC Phase 1 drive.

    It is also a given that both the region AND reset count will change
    each time the key is written.  This allows the obfuscation method to
    rely on either the reset or the region, but does not require both.
    Each byte should rely on one of the above, in order to prevent any
    large sequences of bytes from staying the same between changes.

    Each value under KEY2 will have a one-to-one correlation to a
    specific TYPE of drive (UVAL).  Identical drives will share regions
    and region reset counts.  This is a "better" solution than sharing
    region and reset counts for all devices, which was the only other
    choice.  OEMs must be made aware of this.  This is a good reason to
    install RPC Phase 2 drives into machines.

    The UVAL is read by CdromGetRpc0Settings().  If the read results in
    invalid data, we will mark the device as VIOLATING the license
    agreements.

    The UVAL name is based upon the DHSH as follows:
        Take the DHSH and copy it as legal characters for the registry
        by OR'ing with the value 0x20 (all characters higher than 20
        are legal? -- verify with JVERT).  This also has the benefit of
        being a LOSSY method, but with a FIXED string length.


    The data within UVAL is REG_QWORD.  The data breakdown can be found
    in the functions SecureDvdEncodeSettings() and SecureDvdDecodeSettings()

    NOTE: One main difficulty still exists in determining the difference
    between the above key not existing due to user deletion vs. the above
    key not existing due to first install of this drive.

    OPTIONAL: It is highly preferred to have KEY3 seeded in the system
    hive. This will prevent the casual deletion of the KEY3 tree to reset
    all the region counts to max.  It is unknown if this is simple at
    this time, but allows option 2 (below) to change to deletion, which
    may be a better option.

    OPTIONAL: save another key (UKEY), which, if it exists, means this
    machine should NEVER be allowed to work again.  this will force a
    reinstall, and reduce the effectiveness of a brute-force attack
    to an unmodified driver unless they realize this key is being set.
    this will also allow a method to determine if a user deleted KEY2.
    PSS can know about this magic key.  cdrom should log an EVENTLOG
    saying that the CSS license agreement has been breached.  this key
    should never be set for any error conditions when reading the key.


FunctionalFlow:

    ReadDvdRegionAndResetCount()

    [O] if (SecureDvdLicenseBreachDetected()) {
    [O]     LogLicenseError();
    [O]     return;
    [O] }
        if (!NT_SUCCESS(SecureDvdGetRegKeyHandle(h)) &&
            reason was DNE) {
            LogLicenseError();
            return;
        }
        PHSH = SecureDvdGetProductHash();
        if (PHSH == INVALID_HASH) {
            return;
        }
        DHSH = SecureDvdGetDriveHash();
        if (DHSH == INVALID_HASH) {
            return;
        }

        if (!ReadValue( DriveKey, Data )) {
            INITIALIZE_DRIVE_DATA( Data );
        }

        //
        // data exists, if it's incorrect, LogLicenseError()
        //
        if (!DecodeSettings( QWORD, DHSH, PHSH )) {
            LogLicenseError();
            return;
        }

        // set region & count

        return;


    WriteDvdRegionAndResetCount()

    [O] if (SecureDvdLicenseBreachDetected()) {
    [O]     return FALSE;
    [O] }
        if (!NT_SUCCESS(SecureDvdGetRegKeyHandle(h)) &&
            reason was DNE) {
            return FALSE;
        }
        PHSH = SecureDvdGetProductHash();
        if (PHSH == INVALID_HASH) {
            return FALSE;
        }
        DHSH = SecureDvdGetDriveHash();
        if (DHSH == INVALID_HASH) {
            return FALSE;
        }

        QWORD = EncodeSettings( DHSH, PHSH, Region, Resets );
        if (QWORD == INVALID_HASH) {
            return FALSE;
        }

        if (!WriteValue( DriveKey, Data )) {
            return FALSE;
        }
        return TRUE;

*/
// @@END_DDKSPLIT

#include "sec.h"
#include "sec.tmh"


// @@BEGIN_DDKSPLIT

//
// the digital product id structure is defined
// in \nt\private\windows\setup\pidgen\inc\pidgen.h
// (this was as of 10/06/1999)
//

typedef struct {
    ULONG dwLength;
    SHORT wVersionMajor;
    SHORT wVersionMinor;

    UCHAR szPid2[24];

    ULONG dwKeyIdx;

    UCHAR szSku[16];
    UCHAR  abCdKey[16];

    ULONG dwCloneStatus;
    ULONG dwTime;
    ULONG dwRandom;
    ULONG dwLicenseType;
    ULONG adwLicenseData[2];

    UCHAR szOemId[8];

    ULONG dwBundleId;

    UCHAR aszHardwareIdStatic[8];

    ULONG dwHardwareIdTypeStatic;
    ULONG dwBiosChecksumStatic;
    ULONG dwVolSerStatic;
    ULONG dwTotalRamStatic;
    ULONG dwVideoBiosChecksumStatic;

    UCHAR  aszHardwareIdDynamic[8];

    ULONG dwHardwareIdTypeDynamic;
    ULONG dwBiosChecksumDynamic;
    ULONG dwVolSerDynamic;
    ULONG dwTotalRamDynamic;
    ULONG dwVideoBiosChecksumDynamic;
    ULONG dwCrc32;

} DIGITALPID, *PDIGITALPID;




////////////////////////////////////////////////////////////////////////////////
//
// These functions are not called externally.  Make them static to make
// debugging more difficult in the shipping versions.
//
////////////////////////////////////////////////////////////////////////////////

STATIC
ULONG
RotateULong(
    IN ULONG N,
    IN LONG BitsToRotate
    )
// validated for -64 through +64
{
    if (BitsToRotate < 0) {
        BitsToRotate  = - BitsToRotate;                 // negate
        BitsToRotate %= 8*sizeof(ULONG);                // less than bits
        BitsToRotate  = 8*sizeof(ULONG) - BitsToRotate; // equivalent positive
    } else {
        BitsToRotate %= 8*sizeof(ULONG);                // less than bits
    }

    return ((N <<                      BitsToRotate) |
            (N >> ((8*sizeof(ULONG)) - BitsToRotate)));
}


STATIC
ULONGLONG
RotateULongLong(
    IN ULONGLONG N,
    IN LONG BitsToRotate
    )
// validated for -128 through +128
{
    if (BitsToRotate < 0) {
        BitsToRotate  = - BitsToRotate;
        BitsToRotate %= 8*sizeof(ULONGLONG);
        BitsToRotate  = 8*sizeof(ULONGLONG) - BitsToRotate;
    } else {
        BitsToRotate %= 8*sizeof(ULONGLONG);
    }

    return ((N <<                          BitsToRotate) |
            (N >> ((8*sizeof(ULONGLONG)) - BitsToRotate)));
}


STATIC
BOOLEAN
SecureDvdRegionInvalid(
    IN UCHAR NegativeRegionMask
    )
// validated for all inputs
{
    UCHAR positiveMask = ~NegativeRegionMask;

    if (positiveMask == 0) {
        ASSERT(!"This routine should never be called with the value 0xff");
        return TRUE;
    }

    //
    // region non-zero, drop the lowest bit
    // (this is a cool hack, learned when implementing a fast
    //  way to count the number of set bits in a variable.)
    //

    positiveMask = positiveMask & (positiveMask-1);

    //
    // if still non-zero, had more than one bit set
    //

    if (positiveMask) {
        TraceLog((CdromSecInfo, "DvdInvalidRegion: TRUE for many bits\n"));
        return TRUE;
    }
    return FALSE;
}



STATIC
ULONGLONG
SecureDvdGetDriveHash(
    IN PSTORAGE_DEVICE_DESCRIPTOR Descriptor
    )
// validated for all fields filled
// validated for some fields NULL
// validated for all fields NULL
// validated for some fields invalid (too large?)
// validated for all fields invalid (too large?)
/*
**   returns a ULONGLONG which is the HASH for a given DVD device.
**   NOTE: because this does not check SCSI IDs, identical drives
**         will share the same region and reset counts.
*/
{
    ULONGLONG checkSum = 0;
    ULONG characters = 0;
    LONG i;

    if (Descriptor->VendorIdOffset        > 0x12345678) {
        TraceLog((CdromSecError,
                  "DvdDriveHash: VendorIdOffset is too large (%x)\n",
                  Descriptor->VendorIdOffset));
        Descriptor->VendorIdOffset        = 0;
    }

    if (Descriptor->ProductIdOffset       > 0x12345678) {
        TraceLog((CdromSecError,
                  "DvdDriveHash: ProductIdOffset is too large (%x)\n",
                  Descriptor->ProductIdOffset));
        Descriptor->ProductIdOffset       = 0;
    }

    if (Descriptor->ProductRevisionOffset > 0x12345678) {
        TraceLog((CdromSecError,
                  "DvdDriveHash: ProducetRevisionOffset is too "
                  " large (%x)\n", Descriptor->ProductRevisionOffset));
        Descriptor->ProductRevisionOffset = 0;
    }

    if (Descriptor->SerialNumberOffset    > 0x12345678) {
        TraceLog((CdromSecError,
                  "DvdDriveHash: SerialNumberOffset is too "
                  "large (%x)\n", Descriptor->SerialNumberOffset));
        Descriptor->SerialNumberOffset    = 0;
    }

    if ((!Descriptor->VendorIdOffset       ) &&
        (!Descriptor->ProductIdOffset      ) &&
        (!Descriptor->ProductRevisionOffset) ) {

        TraceLog((CdromSecError, "DvdDriveHash: Invalid Descriptor at %p!\n",
                    Descriptor));
        return INVALID_HASH;

    }

    //
    // take one byte at a time, XOR together
    // should provide a semi-unique hash
    //
    for (i=0;i<4;i++) {

        PUCHAR string = (PUCHAR)Descriptor;
        ULONG offset = 0;

        switch(i) {
            case 0: // vendorId
                TraceLog((CdromSecInfo, "DvdDriveHash: Adding Vendor\n"));
                offset = Descriptor->VendorIdOffset;
                break;
            case 1: // productId
                TraceLog((CdromSecInfo, "DvdDriveHash: Adding Product\n"));
                offset = Descriptor->ProductIdOffset;
                break;
            case 2: // revision
                TraceLog((CdromSecInfo, "DvdDriveHash: Adding Revision\n"));
                offset = Descriptor->ProductRevisionOffset;
                break;
            case 3: // serialNumber
                TraceLog((CdromSecInfo, "DvdDriveHash: Adding SerialNumber\n"));
                offset = Descriptor->SerialNumberOffset;
                break;
            default:
                TraceLog((CdromSecError, "DvdDriveHash: TOO MANY LOOPS!!!\n"));
                offset = 0;
                break;
        }

        //
        // add the string to our checksum
        //

        if (offset != 0) {


            for (string += offset;  *string;  string++) {

                //
                // take each character, multiply it by a "random"
                // value.  rotate the value.
                //

                ULONGLONG temp;

                if (*string == ' ') {
                    // don't include spaces in the character count
                    // nor in the hash
                    continue;
                }

                //
                // dereference the value first!
                //

                temp = (ULONGLONG)(*string);

                //
                // guaranteed no overflow in UCHAR * ULONG in ULONGLONG
                //

                temp *= DVD_RANDOMIZER[ characters%DVD_RANDOMIZER_SIZE ];

                //
                // this rotation is just to spread the values around
                // the 64 bits more evenly
                //

                temp = RotateULongLong(temp, 8*characters);

                //
                // increment number of characters used in checksum
                // (used to verify we have enough characters)
                //

                characters++;

                //
                // XOR it into the checksum
                //

                checkSum ^= temp;

            } // end of string

            if (checkSum == 0) {

                TraceLog((CdromSecInfo, "DvdDriveHash: zero checksum -- using "
                            "random value\n"));
                checkSum ^= DVD_RANDOMIZER[ characters%DVD_RANDOMIZER_SIZE ];
                characters++;

            }

        } // end of non-zero offset

    } // end of four strings (vendor, product, revision, serialNo)


    //
    // we have to use more than four characters
    // for this to be useful
    //
    if (characters <= 4) {
        TraceLog((CdromSecError, "DvdDriveHash: Too few useful characters (%x) "
                    "for unique disk hash\n", characters));
        return INVALID_HASH;
    }

    return checkSum;
}


//
// static, not called externally
//
STATIC
NTSTATUS
SecureDvdEncodeSettings(
    IN  ULONGLONG  DpidHash,
    IN  ULONGLONG  DriveHash,
    OUT PULONGLONG Obfuscated,
    IN  UCHAR      RegionMask,
    IN  UCHAR      ResetCount
    )
// validated for all valid inputs.
// validated for invalid inputs.
{
    LARGE_INTEGER largeInteger;
    ULONGLONG set;
    LONG  i;
    LONG rotate;
    UCHAR temp = 0;

    UCHAR random1;
    UCHAR random2;

    //
    // using the return from KeQueryTickCount() should give
    // semi-random data
    //

    KeQueryTickCount(&largeInteger);
    random2 = 0;
    for (i=0; i < sizeof(ULONGLONG); i++) {
        random2 ^= ((largeInteger.QuadPart >> (8*i)) & 0xff);
    }

    // set temp == sum of all 4-bit values
    // 16 in ULONGLONG, times max value of
    // 15 each is less than MAX_UCHAR
    for (i=0; i < 2*sizeof(ULONGLONG); i++) {

        temp += (UCHAR)( (DpidHash >> (4*i)) & 0xf );

    }

    //
    // validate these settings here
    //

    if (DpidHash == INVALID_HASH) {
        TraceLog((CdromSecError, "DvdEncode: Invalid DigitalProductId Hash\n"));
        goto UserFailure;
    }
    if (DriveHash == INVALID_HASH) {
        TraceLog((CdromSecError, "DvdEncode: Invalid Drive Hash\n"));
        goto UserFailure;
    }

    if (RegionMask == 0xff) {
        TraceLog((CdromSecError, "DvdEncode: Shouldn't attempt to write "
                    "mask of 0xff\n"));
        goto UserFailure;
    }
    if (SecureDvdRegionInvalid(RegionMask)) {
        TraceLog((CdromSecError, "DvdEncode: Invalid region\n"));
        goto LicenseViolation;
    }
    if (ResetCount >= 2) {
        TraceLog((CdromSecError, "DvdEncode: Too many reset counts\n"));
        goto LicenseViolation;
    }

    //
    // using the return from KeQueryTickCount() should give
    // semi-random data
    //

    KeQueryTickCount(&largeInteger);
    random1 = 0;
    for (i=0; i < sizeof(ULONGLONG); i++) {
        random1 ^= ((largeInteger.QuadPart >> (8*i)) & 0xff);
    }

    TraceLog((CdromSecInfo,
              "DvdEncode: Random1 = %x   Random2 = %x\n",
              random1, random2));

    //
    // they must all fit into UCHAR!  they should, since each one is
    // individually a UCHAR, and only bitwise operations are being
    // performed on them.
    //

    //
    // the first cast to UCHAR prevents signed extension.
    // the second cast to ULONGLONG allows high bits preserved by '|'
    //

    set = (ULONGLONG)0;
    for (i=0; i < sizeof(ULONGLONG); i++) {
        set ^= (ULONGLONG)random2 << (8*i);
    }

    set ^= (ULONGLONG)
        ((ULONGLONG)((UCHAR)(random1 ^ temp))                          << 8*7) |
        ((ULONGLONG)((UCHAR)(RegionMask ^ temp))                       << 8*6) |
        ((ULONGLONG)((UCHAR)(ResetCount ^ RegionMask ^ random1))       << 8*5) |
        ((ULONGLONG)((UCHAR)(0))                                       << 8*4) |
        ((ULONGLONG)((UCHAR)(ResetCount ^ temp))                       << 8*3) |
        ((ULONGLONG)((UCHAR)(ResetCount ^ ((DriveHash >> 13) & 0xff))) << 8*2) |
        ((ULONGLONG)((UCHAR)(random1))                                 << 8*1) |
        ((ULONGLONG)((UCHAR)(RegionMask ^ ((DriveHash >> 23) & 0xff))) << 8*0) ;

    TraceLog((CdromSecInfo,
              "DvdEncode: Pre-rotate:  %016I64x    temp = %x\n",
              set, temp));

    //
    // rotate it a semi-random, non-multiple-of-eight bits
    //
    rotate = (LONG)((DpidHash & 0xb) + 1); // {15,14,10,9,7,5,2,1}

    TraceLog((CdromSecInfo,
              "DvdEncode: Rotating %x bits\n", rotate));
    *Obfuscated = RotateULongLong(set, rotate);
    return STATUS_SUCCESS;


UserFailure:
    *Obfuscated = INVALID_HASH;
    return STATUS_UNSUCCESSFUL;

LicenseViolation:
    *Obfuscated = INVALID_HASH;
    return STATUS_LICENSE_VIOLATION;


}


STATIC
NTSTATUS
SecureDvdDecodeSettings(
    IN ULONGLONG DpidHash,
    IN ULONGLONG DriveHash,
    IN ULONGLONG Set,
    OUT PUCHAR RegionMask,
    OUT PUCHAR ResetCount
    )
// validated for many correct inputs, of all region/reset combinations
// validated for many incorrect inputs.
{
    UCHAR random;
    UCHAR region;
    UCHAR resets;
    UCHAR temp = 0;

    LONG i, rotate;

    // set temp == sum of all 4-bit values
    // 16 in ULONGLONG, times max value of
    // 15 each is less than MAX_UCHAR

    for (i=0; i < 2*sizeof(ULONGLONG); i++) {

        temp += (UCHAR)( (DpidHash >> (4*i)) & 0xf );

    }
    rotate = (LONG)((DpidHash & 0xb) + 1); // {15,14,10,9,7,5,2,1}

    Set = RotateULongLong(Set, -rotate);
    TraceLog((CdromSecInfo, "DvdDecode: Post-rotate: %016I64x\n", Set));

    random =  (UCHAR)(Set >> 8*4); // random2

    TraceLog((CdromSecInfo, "DvdDecode: Random2 = %x\n", random));

    for (i = 0; i < sizeof(ULONGLONG); i++) {
        Set ^= (ULONGLONG)random << (8*i);
    }

    //
    // bytes 6,4,3,1 are taken 'as-is'
    // bytes 7,5,2,0 are verified
    //

    region = ((UCHAR)(Set >> 8*6)) ^ temp;
    resets = ((UCHAR)(Set >> 8*3)) ^ temp;
    random = ((UCHAR)(Set >> 8*1)); // make it random1

    TraceLog((CdromSecInfo, "DvdDecode: Random1 = %x  Region = %x  Resets = %x\n",
                random, region, resets));

    // verify the bits

    if (((UCHAR)(Set >> 8*7)) != (random ^ temp)) {
        TraceLog((CdromSecError, "DvdDecode: Invalid Byte 7\n"));
        goto ViolatedLicense;
    }

    random ^= (UCHAR)(Set >> 8*5);
    if (random != (resets ^ region)) {
        TraceLog((CdromSecError, "DvdDecode: Invalid Byte 5\n"));
        goto ViolatedLicense;
    }

    random = (UCHAR)(DriveHash >> 13);
    random ^= (UCHAR)(Set >> 8*2);
    if (random != resets) {
        TraceLog((CdromSecError, "DvdDecode: Invalid Byte 2\n"));
        goto ViolatedLicense;
    }

    random = (UCHAR)(DriveHash >> 23);
    random ^= (UCHAR)(Set >> 8*0);
    if (random != region) {
        TraceLog((CdromSecError, "DvdDecode: Invalid Byte 0\n"));
        goto ViolatedLicense;
    }

    if (SecureDvdRegionInvalid(region)) {
        TraceLog((CdromSecError, "DvdDecode: Region was invalid\n"));
        goto ViolatedLicense;
    }
    if (resets >= 2) {
        TraceLog((CdromSecError, "DvdDecode: Reset count was invalid\n"));
        goto ViolatedLicense;
    }

    TraceLog((CdromSecInfo, "DvdDecode: Successfully validated stored data\n"));

    *RegionMask = region;
    *ResetCount = resets;

    return STATUS_SUCCESS;

ViolatedLicense:

    *RegionMask = 0x00;
    *ResetCount = 0x00;
    return STATUS_LICENSE_VIOLATION;
}


STATIC
NTSTATUS
SecureDvdGetSettingsCallBack(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID UnusedContext,
    IN PDVD_REGISTRY_CONTEXT Context
    )
{
    ULONGLONG hash = 0;
    NTSTATUS status;

    if (ValueType != REG_QWORD) {
        TraceLog((CdromSecError, "DvdGetSettingsCallback: Not REG_BINARY\n"));
        goto ViolatedLicense;
    }

    if (ValueLength != sizeof(ULONGLONG)) {
        TraceLog((CdromSecError, "DvdGetSettingsCallback: DVD Settings data too "
                    "small (%x bytes)\n", ValueLength));
        goto ViolatedLicense;
    }

    hash = *((PULONGLONG)ValueData);

    if (hash == INVALID_HASH) {
        TraceLog((CdromSecError, "DvdGetSettingsCallback: Invalid hash stored?\n"));
        goto ViolatedLicense;
    }

    //
    // validate the data
    // this also sets the values in the context upon success.
    //

    status = SecureDvdDecodeSettings(Context->DpidHash,
                                     Context->DriveHash,
                                     hash,
                                     &Context->RegionMask,
                                     &Context->ResetCount);

    if (status == STATUS_LICENSE_VIOLATION) {

        TraceLog((CdromSecError, "DvdGetSettingsCallback: data was violated!\n"));
        goto ViolatedLicense;

    }

    //
    // the above call to SecureDvdDecodeSettings can only return
    // success or a license violation
    //

    ASSERT(NT_SUCCESS(status));
    return STATUS_SUCCESS;



ViolatedLicense:
    Context->DriveHash = INVALID_HASH;
    Context->DpidHash = INVALID_HASH;
    Context->RegionMask = 0;
    Context->ResetCount = 0;
    return STATUS_LICENSE_VIOLATION;
}


STATIC
NTSTATUS
SecureDvdGetDigitalProductIdCallBack(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PDIGITALPID DigitalPid,  // ValueData
    IN ULONG ValueLength,
    IN PVOID UnusedVariable,
    IN PULONGLONG DpidHash
    )
// validated for non-REG_BINARY
// validated for good data
// validated for short data
{
    NTSTATUS status = STATUS_LICENSE_VIOLATION;
    ULONGLONG hash = 0;

    if (ValueType != REG_BINARY) {
        TraceLog((CdromSecError, "DvdDPIDCallback: Not REG_BINARY\n"));
        *DpidHash = INVALID_HASH;
        return STATUS_LICENSE_VIOLATION;
    }

    if (ValueLength < 4*sizeof(ULONGLONG)) {
        TraceLog((CdromSecError,
                  "DvdDPIDCallback: DPID data too small (%x bytes)\n",
                  ValueLength));
        *DpidHash = INVALID_HASH;
        return STATUS_LICENSE_VIOLATION;
    }

    //
    // apparently, only 13 bytes of the DigitalPID are
    // going to stay static across upgrades.  even these
    // will change if the boot hard drive, video card, or
    // bios signature changes.  nonetheless, this is only
    // supposed to keep the honest people honest. :)
    //

    //
    // 8 bytes to fill == 64 bytes (need to rotate at least 48 bits)
    //

    TraceLog((CdromSecInfo,
              "Bios %08x  Video %08x  VolSer %08x\n",
              DigitalPid->dwBiosChecksumStatic,
              DigitalPid->dwVideoBiosChecksumStatic,
              DigitalPid->dwVolSerStatic));

    hash ^= DigitalPid->dwBiosChecksumStatic;      // 4 bytes // bios signature
    hash = RotateULongLong(hash, 13);              // prime number
    hash ^= DigitalPid->dwVideoBiosChecksumStatic; // 4 bytes // video card
    hash = RotateULongLong(hash, 13);              // prime number
    hash ^= DigitalPid->dwVolSerStatic;            // 4 bytes // hard drive
    hash = RotateULongLong(hash, 13);              // prime number

    *DpidHash = hash;
    return STATUS_SUCCESS;
}


STATIC
NTSTATUS
SecureDvdReturnDPIDHash(
    PULONGLONG DpidHash
    )
{
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    NTSTATUS                 status;

    // cannot be PAGED_CODE() because queryTable cannot be swapped out!

    //
    // query the value
    //

    RtlZeroMemory(&(queryTable[0]), 2 * sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].Name           = L"DigitalProductId";
    queryTable[0].EntryContext   = DpidHash;
    queryTable[0].DefaultType    = 0;
    queryTable[0].DefaultData    = NULL;
    queryTable[0].DefaultLength  = 0;
    queryTable[0].Flags          = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].QueryRoutine   = SecureDvdGetDigitalProductIdCallBack;

    *DpidHash = INVALID_HASH;

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion",
                                    &(queryTable[0]),
                                    NULL,
                                    NULL);

    if (status == STATUS_LICENSE_VIOLATION) {

        TraceLog((CdromSecError,
                  "DvdReturnDPIDHash: Invalid DPID!\n"));

    } else if (!NT_SUCCESS(status)) {

        TraceLog((CdromSecError,
                  "DvdReturnDPIDHash: Cannot get DPID (%x)\n", status));

    } else {

        TraceLog((CdromSecInfo,
                  "DvdReturnDPIDHash: Hash is now %I64x\n",
                  *DpidHash));

    }
    return status;
}


////////////////////////////////////////////////////////////////////////////////
//// Everything past here has not been component tested
////////////////////////////////////////////////////////////////////////////////

#define SECURE_DVD_SET_SECURITY_ON_HANDLE 0

STATIC
NTSTATUS
SecureDvdSetHandleSecurity(
    IN HANDLE Handle
    )
{

#if SECURE_DVD_SET_SECURITY_ON_HANDLE

    PACL                newAcl = NULL;
    ULONG               newAclSize;
    SECURITY_DESCRIPTOR securityDescriptor;
    NTSTATUS            status;
    //
    // from \nt\private\ntos\io\pnpinit.c
    //

    //SeEnableAccessToExports();

    TRY {
        newAclSize = sizeof(ACL);
        newAclSize += sizeof(ACCESS_ALLOWED_ACE);
        newAclSize -= sizeof(ULONG);
        newAclSize += RtlLengthSid(SeExports->SeLocalSystemSid);

        newAcl = ExAllocatePoolWithTag(PagedPool, newAclSize, DVD_TAG_SECURITY);
        if (newAcl == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            LEAVE;
        }


        status = RtlCreateSecurityDescriptor(&securityDescriptor,
                                             SECURITY_DESCRIPTOR_REVISION);
        if (!NT_SUCCESS(status)) {
            ASSERT(!"failed to create a security descriptor?");
            LEAVE;
        }


        status = RtlCreateAcl(newAcl, newAclSize, ACL_REVISION);
        if (!NT_SUCCESS(status)) {
            ASSERT(!"failed to create a new ACL?");
            LEAVE;
        }


        status = RtlAddAccessAllowedAce(newAcl,
                                        ACL_REVISION,
                                        KEY_ALL_ACCESS,
                                        SeExports->SeLocalSystemSid);
        if (!NT_SUCCESS(status)) {
            ASSERT(!"failed to add LocalSystem to ACL");
            LEAVE;
        }


        status = RtlSetDaclSecurityDescriptor(&securityDescriptor,
                                              TRUE,
                                              newAcl,
                                              FALSE);
        if (!NT_SUCCESS(status)) {
            ASSERT(!"failed to set acl in security descriptor?");
            LEAVE;
        }


        status = RtlValidSecurityDescriptor(&securityDescriptor);
        if (!NT_SUCCESS(status)) {
            ASSERT(!"failed to validate security descriptor?");
            LEAVE;
        }


        status = ZwSetSecurityObject(Handle,
                                     // PROTECTED_DACL_SECURITY_INFORMATION,
                                     DACL_SECURITY_INFORMATION,
                                     &securityDescriptor);
        if (!NT_SUCCESS(status)) {
            ASSERT(!"Failed to set security on handle\n");
            LEAVE;
        }


        status = STATUS_SUCCESS;

    } FINALLY {

        if (newAcl != NULL) {
            ExFreePool(newAcl);
            newAcl = NULL;
        }

    }
#endif
    return STATUS_SUCCESS;
}


STATIC
NTSTATUS
SecureDvdGetRegistryHandle(
    IN  ULONGLONG DpidHash,
    OUT PHANDLE Handle
    )
{
    OBJECT_ATTRIBUTES   objectAttributes;
    UNICODE_STRING      hashString;
    NTSTATUS            status;
    LONG                i;
    //
    // using char[] instead of char* allows modification of the
    // string in this routine (a way of obfuscating the string)
    //                 0 ....+.... 1....+.. ..2....+. ...3....+. ...4
    WCHAR string[] = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT";
    WCHAR *hash = &(string[37]);
    PULONGLONG hashAsUlonglong = (PULONGLONG)hash;

    for (i = 0; i < sizeof(ULONGLONG); i++) {

        UCHAR temp;
        temp = (UCHAR)(DpidHash >> (8*i));
        SET_FLAG(temp, 0x20);    // more than 32
        CLEAR_FLAG(temp, 0x80);  // less than 128
        hash[i] = (WCHAR)temp;   // make it a wide char

    }
    hash[i] = UNICODE_NULL;


    RtlInitUnicodeString(&hashString, string);

    RtlZeroMemory(&objectAttributes, sizeof(OBJECT_ATTRIBUTES));


    InitializeObjectAttributes(&objectAttributes,
                               &hashString,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               RTL_REGISTRY_ABSOLUTE, // NULL?
                               NULL  // no security descriptor
                               );

    status = ZwCreateKey(Handle,
                         KEY_ALL_ACCESS,
                         &objectAttributes,
                         0,
                         NULL,  // can be a unicode string....
                         REG_OPTION_NON_VOLATILE,
                         NULL);

    if (!NT_SUCCESS(status)) {
        TraceLog((CdromSecError,
                  "DvdGetRegistryHandle: Failed to create key (%x)\n",
                  status));
        return status;
    }

    status = SecureDvdSetHandleSecurity(*Handle);

    if (!NT_SUCCESS(status)) {
        TraceLog((CdromSecError,
                  "DvdGetRegistryHandle: Failed to set key security (%x)\n",
                  status));
        ZwClose(*Handle);
        *Handle = INVALID_HANDLE_VALUE;
    }

    return status;
}


STATIC
VOID
SecureDvdCreateValueNameFromHash(
    IN ULONGLONG DriveHash,
    OUT PWCHAR   HashString
    )
{
    PUCHAR buffer = (PUCHAR)HashString;
    LONG i;

    RtlZeroMemory(HashString, 17*sizeof(WCHAR));

    sprintf(buffer, "%016I64x", DriveHash);

    // now massage the data to be unicode
    for (i = 15; i >= 0; i--) {
        HashString[i] = buffer[i];
    }
}


STATIC
NTSTATUS
SecureDvdReadOrWriteRegionAndResetCount(
    IN PDEVICE_OBJECT Fdo,
    IN UCHAR   NewRegion,
    IN BOOLEAN ReadingTheValues
    )
//
// NewRegion is ignored if ReadingTheValues is TRUE
//
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PCDROM_DATA cddata;
    NTSTATUS status;

    ULONG keyDisposition;
    DVD_REGISTRY_CONTEXT registryContext;
    HANDLE semiSecureHandle = INVALID_HANDLE_VALUE;

    PAGED_CODE();
    ASSERT(commonExtension->IsFdo);

    cddata = (PCDROM_DATA)(commonExtension->DriverData);

    if (cddata->DvdRpc0LicenseFailure) {
        TraceLog((CdromSecError,
                  "Dvd%sSettings: Already violated licensing\n",
                  (ReadingTheValues ? "Read" : "Write")
                  ));
        goto ViolatedLicense;
    }

    RtlZeroMemory(&registryContext, sizeof(DVD_REGISTRY_CONTEXT));

    //
    // first ensure they didn't violate the CSS agreement
    // by checking for the existance of Mr. Enigma
    //
    {
        HANDLE regHandle;
        OBJECT_ATTRIBUTES objectAttributes;
        UNICODE_STRING mrEnigmaString;

        RtlInitUnicodeString(&mrEnigmaString,
                             L"\\Registry\\Machine\\Software\\Microsoft\\Mr. Enigma");

        RtlZeroMemory(&objectAttributes, sizeof(OBJECT_ATTRIBUTES));
        InitializeObjectAttributes(&objectAttributes,
                                   &mrEnigmaString,
                                   OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                   RTL_REGISTRY_ABSOLUTE, // NULL?
                                   NULL); // no security descriptor

        status = ZwOpenKey(&regHandle, KEY_ALL_ACCESS, &objectAttributes);

        if (!NT_SUCCESS(status)) {
            
            TraceLog((CdromSecError,
                      "Dvd%sSettings: Mr. Enigma doesn't exist.  This will "
                      "fail DVD video playback\n",
                      (ReadingTheValues ? "Read" : "Write")
                      ));
            // red herring   :)
        
        } else {

            ZwClose(regHandle);

        }
    }

    //
    // then, get the DigitalProductIdHash and this DriveHash
    //

    {
        status = SecureDvdReturnDPIDHash(&registryContext.DpidHash);

        // if this fails, we are in serious trouble!
        if (status == STATUS_LICENSE_VIOLATION) {

            TraceLog((CdromSecError,
                      "Dvd%sSettings: License error getting DPIDHash?\n",
                      (ReadingTheValues ? "Read" : "Write")));
            goto ViolatedLicense;

        } else if (!NT_SUCCESS(status)) {

            TraceLog((CdromSecError,
                      "Dvd%sSettings: Couldn't get DPID Hash! (%x)\n",
                      (ReadingTheValues ? "Read" : "Write"), status));
            goto RetryExit;

        }

        if (registryContext.DpidHash == INVALID_HASH) {

            goto ErrorExit;
        }

        registryContext.DriveHash =
            SecureDvdGetDriveHash(fdoExtension->DeviceDescriptor);
        if (registryContext.DriveHash == INVALID_HASH) {
            TraceLog((CdromSecError,
                      "Dvd%sSettings: Couldn't create drive hash(!)\n",
                      (ReadingTheValues ? "Read" : "Write")));
            goto ErrorExit;
        }

    }

    //
    // finally get a handle based upon the DigitalProductIdHash
    // to our "semi-secure" registry key, creating it if neccessary.
    //
    status= SecureDvdGetRegistryHandle(registryContext.DpidHash,
                                       &semiSecureHandle);
    if (!NT_SUCCESS(status)) {
        TraceLog((CdromSecError,
                  "Dvd%sSettings: Could not get semi-secure handle %x\n",
                  (ReadingTheValues ? "Read" : "Write"), status));
        goto ErrorExit;
    }

    //
    // if reading the values, use the semi-secure handle to open a subkey,
    // read its data, close the handle, it.
    //
    //
    if (ReadingTheValues) {

        WCHAR hashString[17]; // 16 + NULL
        RTL_QUERY_REGISTRY_TABLE queryTable[2];

        SecureDvdCreateValueNameFromHash(registryContext.DriveHash, hashString);

        RtlZeroMemory(&queryTable[0], 2*sizeof(RTL_QUERY_REGISTRY_TABLE));

        queryTable[0].DefaultData   = NULL;
        queryTable[0].DefaultLength = 0;
        queryTable[0].DefaultType   = 0;
        queryTable[0].EntryContext  = &registryContext;
        queryTable[0].Flags         = RTL_QUERY_REGISTRY_REQUIRED;
        queryTable[0].Name          = hashString;
        queryTable[0].QueryRoutine  = SecureDvdGetSettingsCallBack;

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        semiSecureHandle,
                                        &queryTable[0],
                                        &registryContext,
                                        NULL);

        if (status == STATUS_LICENSE_VIOLATION) {
            TraceLog((CdromSecError,
                      "Dvd%sSettings: Invalid value in registry!\n",
                      (ReadingTheValues ? "Read" : "Write")));
            goto ViolatedLicense;
        } else if (!NT_SUCCESS(status)) {
            TraceLog((CdromSecError,
                      "Dvd%sSettings: Other non-license error (%x)\n",
                      (ReadingTheValues ? "Read" : "Write"), status));
            goto ErrorExit;
        }

        //
        // set the real values....
        //

        cddata->Rpc0SystemRegion           = registryContext.RegionMask;
        cddata->Rpc0SystemRegionResetCount = registryContext.ResetCount;

        //
        // everything is kosher!
        //

        TraceLog((CdromSecInfo,
                  "Dvd%sSettings: Region %x  Reset %x\n",
                  (ReadingTheValues ? "Read" : "Write"),
                  cddata->Rpc0SystemRegion,
                  cddata->Rpc0SystemRegionResetCount));



    } else { // !ReadingTheValues, iow, writing them....

        //
        // if writing the values, obfuscate them first (which also validates),
        // then use the semi-secure handle to write the subkey
        //

        WCHAR hashString[17]; // 16 + NULL
        ULONGLONG obfuscated;

        //
        // don't munge the device extension until we modify the registry
        // (see below for modification of device extension data)
        //

        registryContext.RegionMask = NewRegion;
        registryContext.ResetCount = cddata->Rpc0SystemRegionResetCount-1;

        //
        // this also validates the settings
        //

        SecureDvdCreateValueNameFromHash(registryContext.DriveHash, hashString);

        status = SecureDvdEncodeSettings(registryContext.DpidHash,
                                         registryContext.DriveHash,
                                         &obfuscated,
                                         registryContext.RegionMask,
                                         registryContext.ResetCount);



        if (status == STATUS_LICENSE_VIOLATION) {

            TraceLog((CdromSecError,
                      "Dvd%sSettings: User may have modified memory! "
                      "%x %x\n", (ReadingTheValues ? "Read" : "Write"),
                      registryContext.RegionMask,
                      registryContext.ResetCount));
            goto ViolatedLicense;

        } else if (!NT_SUCCESS(status)) {

            TraceLog((CdromSecError,
                      "Dvd%sSettings: Couldn't obfuscate data %x %x\n",
                      (ReadingTheValues ? "Read" : "Write"),
                      registryContext.RegionMask,
                      registryContext.ResetCount));
            goto ErrorExit;

        }

        //
        // save them for posterity
        //

        TraceLog((CdromSecInfo,
                  "Dvd%sSettings: Data is %016I64x\n",
                  (ReadingTheValues ? "Read" : "Write"),
                  obfuscated));

        status = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                       semiSecureHandle,
                                       hashString,
                                       REG_QWORD,
                                       &obfuscated,
                                       (ULONG)(sizeof(ULONGLONG))
                                       );
        if (!NT_SUCCESS(status)) {
            TraceLog((CdromSecError,
                      "Dvd%sSettings: Couldn't save %x\n",
                      (ReadingTheValues ? "Read" : "Write"), status));
            goto ErrorExit;
        }

        //
        // make the change in the device extension data also
        //

        cddata->Rpc0SystemRegion = NewRegion;
        cddata->Rpc0SystemRegionResetCount--;

        TraceLog((CdromSecInfo,
                  "Dvd%sSettings: Region %x  Reset %x\n",
                  (ReadingTheValues ? "Read" : "Write"),
                  cddata->Rpc0SystemRegion,
                  cddata->Rpc0SystemRegionResetCount));


    }

    if (semiSecureHandle != INVALID_HANDLE_VALUE) {
        ZwClose(semiSecureHandle);
    }

    return STATUS_SUCCESS;


ViolatedLicense: {
    PIO_ERROR_LOG_PACKET errorLogEntry;

    if (semiSecureHandle != INVALID_HANDLE_VALUE) {
        ZwClose(semiSecureHandle);
    }

    /*
    errorLogEntry = (PIO_ERROR_LOG_ENTRY)
        IoAllocateErrorLogEntry(Fdo,
                                (UCHAR)(sizeof(IO_ERROR_LOG_PACKET)));

    if (errorLogEntry != NULL) {
        errorLogEntry->FinalStatus = STATUS_LICENSE_VIOLATION;
        errorLogEntry->ErrorCode   = STATUS_LICENSE_VIOLATION;
        errorLogEntry->MajorFunctionCode = IRP_MJ_START_DEVICE;
        IoWriteErrorLogEntry(errorLogEntry);
    }
    */

    TraceLog((CdromSecError,
              "Dvd%sSettings: License Violation Detected\n",
              (ReadingTheValues ? "Read" : "Write")));
    cddata->DvdRpc0LicenseFailure = TRUE;   // no playback
    cddata->Rpc0SystemRegion = 0xff;        // no regions
    cddata->Rpc0SystemRegionResetCount = 0; // no resets
    return STATUS_LICENSE_VIOLATION;
}

RetryExit:

    if (ReadingTheValues) {
        cddata->Rpc0RetryRegistryCallback  = 1;
    }

    //
    // fall-through to Error Exit...
    //

ErrorExit:
    TraceLog((CdromSecError,
              "Dvd%sSettings: Non-License Error Detected\n",
              (ReadingTheValues ? "Read" : "Write")));
    //
    // don't modify the device extension on non-license-violation errors
    //
    if (semiSecureHandle != INVALID_HANDLE_VALUE) {
        ZwClose(semiSecureHandle);
    }


    return STATUS_UNSUCCESSFUL;
}


////////////////////////////////////////////////////////////////////////////////
//
// The following functions are externally accessible. They therefore cannot
// be either STATIC nor INLINE
// static to make debugging more difficult in the shipping versions.
//
// These exports return one of only three NTSTATUS values:
//    STATUS_SUCCESS
//    STATUS_UNSUCCESSFUL
//    STATUS_LICENSE_VIOLATION
//
////////////////////////////////////////////////////////////////////////////////

NTSTATUS
CdRomGetRpc0Settings(
    IN PDEVICE_OBJECT Fdo
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PCDROM_DATA cddata = (PCDROM_DATA)(commonExtension->DriverData);
    NTSTATUS status;

    KeWaitForMutexObject(&cddata->Rpc0RegionMutex, UserRequest, KernelMode,
                         FALSE, NULL);
    status = SecureDvdReadOrWriteRegionAndResetCount(Fdo, 0, TRUE);
    KeReleaseMutex(&cddata->Rpc0RegionMutex, FALSE);
    return status;
}


NTSTATUS
CdRomSetRpc0Settings(
    IN PDEVICE_OBJECT Fdo,
    IN UCHAR NewRegion
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PCDROM_DATA cddata = (PCDROM_DATA)(commonExtension->DriverData);
    NTSTATUS status;

    KeWaitForMutexObject(&cddata->Rpc0RegionMutex, UserRequest, KernelMode,
                         FALSE, NULL);
    status = SecureDvdReadOrWriteRegionAndResetCount(Fdo, NewRegion, FALSE);
    KeReleaseMutex(&cddata->Rpc0RegionMutex, FALSE);
    return status;
}


#if 0
// @@END_DDKSPLIT

NTSTATUS
CdRomGetRpc0Settings(
    IN PDEVICE_OBJECT Fdo
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PCDROM_DATA cddata = (PCDROM_DATA)(commonExtension->DriverData);

    cddata->Rpc0SystemRegion = (UCHAR)(~1);        // region one
    cddata->Rpc0SystemRegionResetCount = 0; // no resets

    return STATUS_SUCCESS;
}


NTSTATUS
CdRomSetRpc0Settings(
    IN PDEVICE_OBJECT Fdo,
    IN UCHAR NewRegion
    )
{
    return STATUS_SUCCESS;
}
// @@BEGIN_DDKSPLIT
#endif // 0 -- DDK stub for all the stuff we do...
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\changer\ioctl.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ioctl.c
//
//--------------------------------------------------------------------------

#include "cdchgr.h"


BOOLEAN
InvalidElement(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN CHANGER_ELEMENT Element
    );



BOOLEAN
ChgrIoctl(
    IN ULONG Code
    )
{

    ULONG baseCode;

    baseCode = Code >> 16;
    if (baseCode == IOCTL_CHANGER_BASE) {
        DebugPrint((3,
                   "ChngrIoctl returning TRUE for Base %x, Code %x\n",
                   baseCode,
                   Code));

        return TRUE;
    } else {
        DebugPrint((3,
                   "ChngrIoctl returning FALSE for Base %x, Code %x\n",
                   baseCode,
                   Code));
        return FALSE;
    }
}


NTSTATUS
ChgrGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    PPASS_THROUGH_REQUEST passThrough;
    PSCSI_PASS_THROUGH    srb;
    NTSTATUS              status;
    ULONG                 length;
    PCDB                  cdb;

    //
    // Allocate a request block.
    //

    passThrough = ExAllocatePool(NonPagedPoolCacheAligned, sizeof(PASS_THROUGH_REQUEST));

    if (!passThrough) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    srb = &passThrough->Srb;
    RtlZeroMemory(passThrough, sizeof(PASS_THROUGH_REQUEST));
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;

    //
    // Build TUR.
    //

    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    srb->DataTransferLength = 0;

    if (deviceExtension->DeviceType == TORISAN) {
        DebugPrint((1,
                   "GetStatus: Using CurrentPlatter %x\n",
                   deviceExtension->CurrentPlatter));
        srb->Cdb[7] = (UCHAR)deviceExtension->CurrentPlatter;
        srb->CdbLength = 10;
    }

    //
    // Send the request.
    //

    status = SendPassThrough(DeviceObject,
                             passThrough);

    //
    // Check out the status. As this is fake (taking to the cdrom drive, not to a robotic target),
    // will probably have to make up some stuff.
    //

    if (status == STATUS_NO_MEDIA_IN_DEVICE) {
        status = STATUS_SUCCESS;
    }

    ExFreePool(passThrough);

    if (NT_SUCCESS(status)) {

        if (deviceExtension->DeviceType == ATAPI_25) {

            //
            // Issue mech. status to see if any changed bits are set for those
            // drives that actually support this.
            //

            length = sizeof(MECHANICAL_STATUS_INFORMATION_HEADER);
            length += (deviceExtension->NumberOfSlots) * sizeof(SLOT_TABLE_INFORMATION);

            passThrough = ExAllocatePool(NonPagedPoolCacheAligned, sizeof(PASS_THROUGH_REQUEST) + length);

            if (!passThrough) {

                return STATUS_INSUFFICIENT_RESOURCES;
            }

            srb = &passThrough->Srb;
            RtlZeroMemory(passThrough, sizeof(PASS_THROUGH_REQUEST) + length);
            cdb = (PCDB)srb->Cdb;

            srb->CdbLength = CDB12GENERIC_LENGTH;
            srb->DataTransferLength = length;
            srb->TimeOutValue = 200;

            cdb->MECH_STATUS.OperationCode = SCSIOP_MECHANISM_STATUS;
            cdb->MECH_STATUS.AllocationLength[0] = (UCHAR)(length >> 8);
            cdb->MECH_STATUS.AllocationLength[1] = (UCHAR)(length & 0xFF);

            //
            // Send SCSI command (CDB) to device
            //

            status = SendPassThrough(DeviceObject,
                                     passThrough);

            if (NT_SUCCESS(status)) {

                //
                // Run through slot info, looking for a set changed bit.
                //

                PSLOT_TABLE_INFORMATION slotInfo;
                PMECHANICAL_STATUS_INFORMATION_HEADER statusHeader;
                ULONG slotCount;
                ULONG currentSlot;

                (ULONG_PTR)statusHeader = (ULONG_PTR)passThrough->DataBuffer;
                (ULONG_PTR)slotInfo = (ULONG_PTR)statusHeader;
                (ULONG_PTR)slotInfo += sizeof(MECHANICAL_STATUS_INFORMATION_HEADER);

                slotCount = statusHeader->SlotTableLength[1];
                slotCount |= (statusHeader->SlotTableLength[0] << 8);

                //
                // Total slot information entries.
                //

                slotCount /= sizeof(SLOT_TABLE_INFORMATION);

                //
                // Move the slotInfo pointer to the correct entry.
                //

                for (currentSlot = 0; currentSlot < slotCount; currentSlot++) {

                    if (slotInfo->DiscChanged) {
                        status = STATUS_MEDIA_CHANGED;
                        break;
                    }

                    //
                    // Advance to next slot.
                    //

                    slotInfo += 1;
                }
            }

            ExFreePool(passThrough);
        }
    }

    return status;
}


NTSTATUS
ChgrGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION      currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PGET_CHANGER_PARAMETERS changerParameters;

    changerParameters = Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory(changerParameters, sizeof(GET_CHANGER_PARAMETERS));

    changerParameters->Size = sizeof(GET_CHANGER_PARAMETERS);

    changerParameters->NumberTransportElements = 1;
    changerParameters->NumberStorageElements = (USHORT)deviceExtension->NumberOfSlots;
    changerParameters->NumberIEElements = 0;
    changerParameters->NumberDataTransferElements = 1;
    changerParameters->NumberOfDoors = 0;
    changerParameters->NumberCleanerSlots = 0;

    changerParameters->FirstSlotNumber = 1;
    changerParameters->FirstDriveNumber =  0;
    changerParameters->FirstTransportNumber = 0;
    changerParameters->FirstIEPortNumber = 0;

    if (deviceExtension->MechType == 1) {

        //
        // For example, ALPS, Panasonic, Torisan.
        //

        changerParameters->MagazineSize = (USHORT)deviceExtension->NumberOfSlots;

        changerParameters->Features0 =  (CHANGER_CARTRIDGE_MAGAZINE |
                                         CHANGER_STORAGE_SLOT       |
                                         CHANGER_LOCK_UNLOCK);

    } else {

        //
        // For the NEC.
        //

        changerParameters->MagazineSize = 0;

        changerParameters->Features0 =  (CHANGER_STORAGE_SLOT       |
                                         CHANGER_LOCK_UNLOCK);

    }

    changerParameters->DriveCleanTimeout = 0;

    //
    // Features based on manual, nothing programatic.
    //


    changerParameters->MoveFromSlot  = CHANGER_TO_DRIVE | CHANGER_TO_TRANSPORT;

    Irp->IoStatus.Information = sizeof(GET_CHANGER_PARAMETERS);
    return STATUS_SUCCESS;
}


NTSTATUS
ChgrGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{

    PDEVICE_EXTENSION          deviceExtension = DeviceObject->DeviceExtension;
    PCHANGER_PRODUCT_DATA      productData = Irp->AssociatedIrp.SystemBuffer;

    RtlZeroMemory(productData, sizeof(CHANGER_PRODUCT_DATA));

    //
    // Copy cached inquiry data fields into the system buffer.
    //

    RtlMoveMemory(productData->VendorId, deviceExtension->InquiryData.VendorId, VENDOR_ID_LENGTH);
    RtlMoveMemory(productData->ProductId, deviceExtension->InquiryData.ProductId, PRODUCT_ID_LENGTH);
    RtlMoveMemory(productData->Revision, deviceExtension->InquiryData.ProductRevisionLevel, REVISION_LENGTH);
    RtlMoveMemory(productData->SerialNumber, deviceExtension->InquiryData.VendorSpecific, SERIAL_NUMBER_LENGTH);
    productData->DeviceType = MEDIUM_CHANGER;

    Irp->IoStatus.Information = sizeof(CHANGER_PRODUCT_DATA);
    return STATUS_SUCCESS;
}


NTSTATUS
ChgrSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    PCHANGER_SET_ACCESS setAccess = Irp->AssociatedIrp.SystemBuffer;
    ULONG               controlOperation = setAccess->Control;
    PPASS_THROUGH_REQUEST passThrough;
    PSCSI_PASS_THROUGH    srb;
    NTSTATUS              status;
    PCDB                  cdb;


    if (setAccess->Element.ElementType != ChangerDoor) {

        //
        // No IEPORTs on these devices.
        //

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate a request block.
    //

    passThrough = ExAllocatePool(NonPagedPoolCacheAligned, sizeof(PASS_THROUGH_REQUEST));

    if (!passThrough) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    srb = &passThrough->Srb;
    RtlZeroMemory(passThrough, sizeof(PASS_THROUGH_REQUEST));
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB6GENERIC_LENGTH;
    cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

    srb->DataTransferLength = 0;
    srb->TimeOutValue = 10;

    status = STATUS_SUCCESS;

    if (controlOperation == LOCK_ELEMENT) {

        //
        // Issue prevent media removal command to lock the magazine.
        //

        cdb->MEDIA_REMOVAL.Prevent = 1;

    } else if (controlOperation == UNLOCK_ELEMENT) {

        //
        // Issue allow media removal.
        //

        cdb->MEDIA_REMOVAL.Prevent = 0;

    } else {

        status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {

        //
        // Send the request.
        //

        status = SendPassThrough(DeviceObject,
                                 passThrough);
    }

    ExFreePool(passThrough);
    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CHANGER_SET_ACCESS);
    }

    return status;
}


NTSTATUS
ChgrGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChgrInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{

    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
ChgrSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    //
    // These device don't support this.
    //

    return STATUS_INVALID_DEVICE_REQUEST;

}

NTSTATUS
ChgrExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    //
    // These device don't support this.
    //

    return STATUS_INVALID_DEVICE_REQUEST;

}


NTSTATUS
ChgrReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    //
    // These device don't support this.
    //

    return STATUS_INVALID_DEVICE_REQUEST;

}


NTSTATUS
ChgrQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    //
    // These device don't support this.
    //

    return STATUS_INVALID_DEVICE_REQUEST;

}


NTSTATUS
ChgrMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION    deviceExtension = DeviceObject->DeviceExtension;
    PCHANGER_MOVE_MEDIUM moveMedium = Irp->AssociatedIrp.SystemBuffer;
    USHORT              transport;
    USHORT              source;
    USHORT              destination;
    PPASS_THROUGH_REQUEST passThrough;
    PSCSI_PASS_THROUGH    srb;
    PCDB     cdb;
    NTSTATUS            status;

    //
    // Verify transport, source, and dest. are within range.
    //

    if (InvalidElement(deviceExtension,moveMedium->Transport)) {
        DebugPrint((1,
                   "ChangerMoveMedium: Transport element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    if (InvalidElement(deviceExtension, moveMedium->Source)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Source element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;

    }

    if (InvalidElement(deviceExtension,moveMedium->Destination)) {

        DebugPrint((1,
                   "ChangerMoveMedium: Destination element out of range.\n"));

        return STATUS_ILLEGAL_ELEMENT_ADDRESS;
    }

    //
    // Build srb and cdb.
    //

    passThrough = ExAllocatePool(NonPagedPoolCacheAligned, sizeof(PASS_THROUGH_REQUEST));

    if (!passThrough) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // The torisan units don't really move medium, rather the active disc is changed.
    // To change slots, they've overloaded TUR.
    //

    if (deviceExtension->DeviceType == TORISAN) {

        if (moveMedium->Destination.ElementType == ChangerDrive) {

            srb = &passThrough->Srb;
            RtlZeroMemory(passThrough, sizeof(PASS_THROUGH_REQUEST));
            cdb = (PCDB)srb->Cdb;

            srb->CdbLength = CDB10GENERIC_LENGTH;

            //
            // Build TUR.
            //

            cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

            srb->Cdb[7] = (UCHAR)moveMedium->Source.ElementAddress;
            srb->TimeOutValue = 20;

            srb->DataTransferLength = 0;

            //
            // Send the request.
            //

            status = SendPassThrough(DeviceObject,
                                     passThrough);

            if (status == STATUS_DEVICE_NOT_READY) {

                // TODO send a TUR to verify this.

                DebugPrint((1,
                           "MoveMedium - Claiming success\n"));
                status = STATUS_SUCCESS;
            } else if (status == STATUS_NO_MEDIA_IN_DEVICE) {
                status = STATUS_SOURCE_ELEMENT_EMPTY;
            }

            if (NT_SUCCESS(status)) {

                //
                // Update the current disc indicator.
                //

                deviceExtension->CurrentPlatter = moveMedium->Source.ElementAddress;
                DebugPrint((1,
                           "MoveMedium: Set currentPlatter to %x\n",
                           deviceExtension->CurrentPlatter));

                ExFreePool(passThrough);
                return STATUS_SUCCESS;

            } else {
                DebugPrint((1,
                           "MoveMedium - Status on move %lx\n",
                           status));

                ExFreePool(passThrough);
                return status;
            }


        } else {

            //
            // Claim that is happened.
            //


            ExFreePool(passThrough);
            return STATUS_SUCCESS;
        }
    }

    //
    // If destination is the drive, determine if media is already present.
    // The alps always claims media is there, so don't check.
    //

#if 0
    if (((moveMedium->Destination.ElementType) == ChangerDrive) &&
         (deviceExtension->DeviceType != ALPS_25)) {

        srb = &passThrough->Srb;
        RtlZeroMemory(passThrough, sizeof(PASS_THROUGH_REQUEST));
        cdb = (PCDB)srb->Cdb;

        srb->CdbLength = CDB6GENERIC_LENGTH;

        //
        // Build TUR.
        //

        cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
        srb->TimeOutValue = 20;

        srb->DataTransferLength = 0;

        //
        // Send the request.
        //

        status = SendPassThrough(DeviceObject,
                                 passThrough);

        if (status != STATUS_NO_MEDIA_IN_DEVICE) {

            //
            // Drive has media. Though the device will allow this,
            // error it, as the expected medium changer behaviour is
            // to return element full in this case.
            //

            DebugPrint((1,
                       "ChgrMoveMedium: Drive already has media. TUR Status %lx\n",
                       status));

            ExFreePool(passThrough);
            return STATUS_DESTINATION_ELEMENT_FULL;
        }
    }
#endif

    srb = &passThrough->Srb;
    RtlZeroMemory(passThrough, sizeof(PASS_THROUGH_REQUEST));
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB12GENERIC_LENGTH;
    srb->TimeOutValue = CDCHGR_TIMEOUT;
    srb->DataTransferLength = 0;

    //
    // LOAD_UNLOAD will move a disc from slot to drive,
    // or from drive to slot.
    //

    cdb->LOAD_UNLOAD.OperationCode = SCSIOP_LOAD_UNLOAD_SLOT;
    if (moveMedium->Source.ElementType == ChangerDrive) {

        cdb->LOAD_UNLOAD.Slot = (UCHAR)moveMedium->Destination.ElementAddress;
        cdb->LOAD_UNLOAD.Start = 0;
        cdb->LOAD_UNLOAD.LoadEject = 1;


    } else if (moveMedium->Source.ElementType == ChangerSlot) {

        cdb->LOAD_UNLOAD.Slot = (UCHAR)moveMedium->Source.ElementAddress;
        cdb->LOAD_UNLOAD.Start = 1;
        cdb->LOAD_UNLOAD.LoadEject = 1;
    }

    //
    // Send SCSI command (CDB) to device
    //

    status = SendPassThrough(DeviceObject,
                              passThrough);

    if (NT_SUCCESS(status)) {

        //
        // These devices don't seem to ever generate
        // a unit attention, for media changed, so fake it.
        //

        if (deviceExtension->CdromTargetDeviceObject->Vpb->Flags & VPB_MOUNTED) {

            DebugPrint((1,
                       "Faking DO_VERIFY_VOLUME\n"));

            deviceExtension->CdromTargetDeviceObject->Flags |= DO_VERIFY_VOLUME;
        }

    } else if (status == STATUS_NO_MEDIA_IN_DEVICE) {
        status = STATUS_SOURCE_ELEMENT_EMPTY;
    }

    ExFreePool(passThrough);
    return status;
}


BOOLEAN
InvalidElement(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN CHANGER_ELEMENT Element
    )
{
    if (Element.ElementType == ChangerSlot) {
        if (Element.ElementAddress >= DeviceExtension->NumberOfSlots) {
            DebugPrint((1,
                       "Cdchgr: InvalidElement - type %x, address %x\n",
                       Element.ElementType,
                       Element.ElementAddress));
            return TRUE;
        }
    } else if (Element.ElementType == ChangerDrive) {
        if (Element.ElementAddress != 0) {
            DebugPrint((1,
                       "Cdchgr: InvalidElement - type %x, address %x\n",
                       Element.ElementType,
                       Element.ElementAddress));
            return TRUE;
        }
    } else if (Element.ElementType == ChangerTransport) {
        if (Element.ElementAddress != 0) {
            DebugPrint((1,
                       "Cdchgr: InvalidElement - type %x, address %x\n",
                       Element.ElementType,
                       Element.ElementAddress));
            return TRUE;
        }
    } else {

        DebugPrint((1,
                   "Cdchgr: InvalidElement - type %x, address %x\n",
                   Element.ElementType,
                   Element.ElementAddress));
        return TRUE;
    }

    //
    // Acceptable element/address.
    //

    return FALSE;
}


NTSTATUS
MapSenseInfo(
    IN PSENSE_DATA SenseBuffer
    )

{

    NTSTATUS status = STATUS_SUCCESS;
    UCHAR senseCode = SenseBuffer->SenseKey;
    UCHAR additionalSenseCode = SenseBuffer->AdditionalSenseCode;
    UCHAR additionalSenseCodeQualifier = SenseBuffer->AdditionalSenseCodeQualifier;

    switch (senseCode) {
        case SCSI_SENSE_NO_SENSE:

             if (SenseBuffer->IncorrectLength) {

                status = STATUS_INVALID_BLOCK_LENGTH;

            } else {

                status = STATUS_IO_DEVICE_ERROR;
            }

            break;

        case SCSI_SENSE_RECOVERED_ERROR:

            status = STATUS_SUCCESS;
            break;

        case SCSI_SENSE_NOT_READY:

            status = STATUS_DEVICE_NOT_READY;

            switch (additionalSenseCode) {
                case SCSI_ADSENSE_LUN_NOT_READY:

                    switch (additionalSenseCodeQualifier) {

                        case SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED:

                            status = STATUS_NO_MEDIA_IN_DEVICE;
                            break;
                        case SCSI_SENSEQ_INIT_COMMAND_REQUIRED:
                        case SCSI_SENSEQ_BECOMING_READY:

                            //
                            // Fall through.
                            //
                        default:

                            status = STATUS_DEVICE_NOT_READY;

                    }
                    break;

                case SCSI_ADSENSE_NO_MEDIA_IN_DEVICE:

                    status = STATUS_NO_MEDIA_IN_DEVICE;
                    break;
                default:
                    status = STATUS_DEVICE_NOT_READY;

            }
            break;

        case SCSI_SENSE_MEDIUM_ERROR:

            status = STATUS_DEVICE_DATA_ERROR;
            break;

        case SCSI_SENSE_ILLEGAL_REQUEST:

            switch (additionalSenseCode) {

                case SCSI_ADSENSE_ILLEGAL_BLOCK:
                    status = STATUS_NONEXISTENT_SECTOR;
                    break;

                case SCSI_ADSENSE_INVALID_LUN:
                    status = STATUS_NO_SUCH_DEVICE;
                    break;

                case SCSI_ADSENSE_MUSIC_AREA:
                case SCSI_ADSENSE_DATA_AREA:
                case SCSI_ADSENSE_VOLUME_OVERFLOW:
                case SCSI_ADSENSE_ILLEGAL_COMMAND:
                case SCSI_ADSENSE_INVALID_CDB:
                default:

                    status = STATUS_INVALID_DEVICE_REQUEST;
                    break;
            }
            break;

        case SCSI_SENSE_UNIT_ATTENTION:

            // TODO - check on this.
            DebugPrint((1,
                       "MapSenseInfo: UnitAttention \n"));

            status = STATUS_VERIFY_REQUIRED;
            break;

        case SCSI_SENSE_DATA_PROTECT:

            status = STATUS_MEDIA_WRITE_PROTECTED;
            break;

        case SCSI_SENSE_HARDWARE_ERROR:
        case SCSI_SENSE_ABORTED_COMMAND:

            //
            // Fall through.
            //

        default:

            status = STATUS_IO_DEVICE_ERROR;
            break;
    }

    DebugPrint((1,
               "CdChgr: MapSenseInfo - SK %x, ASC %x, ASCQ %x, Status %lx\n",
               senseCode,
               additionalSenseCode,
               additionalSenseCodeQualifier,
               status));
    return status;
}



NTSTATUS
SendTorisanCheckVerify(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine handles only the check verify commands for the Sanyo changers.

Arguments:

    DeviceObject
    Irp

Return Value:

    Status is returned.

--*/

{
    PDEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PPASS_THROUGH_REQUEST passThrough;
    PSCSI_PASS_THROUGH    srb;
    NTSTATUS              status;
    ULONG                 length;
    PCDB                  cdb;

    //
    // Allocate a request block.
    //

    passThrough = ExAllocatePool(NonPagedPoolCacheAligned, sizeof(PASS_THROUGH_REQUEST));

    if (!passThrough) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    srb = &passThrough->Srb;
    RtlZeroMemory(passThrough, sizeof(PASS_THROUGH_REQUEST));
    cdb = (PCDB)srb->Cdb;

    srb->CdbLength = CDB10GENERIC_LENGTH;

    //
    // Build TUR.
    //

    cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;
    srb->TimeOutValue = 20;

    DebugPrint((1,
               "SendTorisanCheckVerify: Using CurrentPlatter of %x\n",
               deviceExtension->CurrentPlatter));

    srb->Cdb[7] = (UCHAR)deviceExtension->CurrentPlatter;
    srb->DataTransferLength = 0;

    //
    // Send the request.
    //

    status = SendPassThrough(DeviceObject,
                             passThrough);


    ExFreePool(passThrough);
    return status;
}


NTSTATUS
SendPassThrough(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PPASS_THROUGH_REQUEST ScsiPassThrough
    )
/*++

Routine Description:

    This routine fills in most SPT fields, then sends the given SRB synchronously
    to the CDROM class driver.
    DataTransferLength, TimeoutValue are the responsibility of the caller.

Arguments:

    Extension       - Supplies the device extension.

    Srb             - Supplies the SRB.

    Buffer          - Supplies the return buffer.

    BufferLength    - Supplies the buffer length.

Return Value:

    NTSTATUS

--*/


//typedef struct _PASS_THROUGH_REQUEST {
//    SCSI_PASS_THROUGH Srb;
//    SENSE_DATA SenseInfoBuffer;
//    CHAR DataBuffer[0];
//} PASS_THROUGH_REQUEST, *PPASS_THROUGH_REQUEST;


//typedef struct _SCSI_PASS_THROUGH {
//    USHORT Length;
//    UCHAR ScsiStatus;
//    UCHAR PathId;
//    UCHAR TargetId;
//    UCHAR Lun;
//    UCHAR CdbLength;
//    UCHAR SenseInfoLength;
//    UCHAR DataIn;
//    ULONG DataTransferLength;
//    ULONG TimeOutValue;
//    ULONG DataBufferOffset;
//    ULONG SenseInfoOffset;
//    UCHAR Cdb[16];
//}SCSI_PASS_THROUGH, *PSCSI_PASS_THROUGH;

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSCSI_PASS_THROUGH srb = &ScsiPassThrough->Srb;
    KEVENT event;
    PIRP   irp;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;

    srb->Length = sizeof(SCSI_PASS_THROUGH);
    srb->SenseInfoLength = sizeof(SENSE_DATA);
    srb->SenseInfoOffset = FIELD_OFFSET(PASS_THROUGH_REQUEST, SenseInfoBuffer);

    if (srb->DataTransferLength) {

        srb->DataBufferOffset = FIELD_OFFSET(PASS_THROUGH_REQUEST, DataBuffer);
        srb->DataIn = SCSI_IOCTL_DATA_IN;
    } else {

        srb->DataIn = SCSI_IOCTL_DATA_OUT;
        srb->DataBufferOffset = 0;
    }

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_SCSI_PASS_THROUGH,
                                        deviceExtension->CdromTargetDeviceObject,
                                        ScsiPassThrough,
                                        sizeof(PASS_THROUGH_REQUEST) + srb->DataTransferLength,
                                        ScsiPassThrough,
                                        sizeof(PASS_THROUGH_REQUEST) + srb->DataTransferLength,
                                        FALSE,
                                        &event,
                                        &ioStatus);
    if (!irp) {
        DebugPrint((1,
                   "Cdchgr: SendPassThrough NULL irp\n"));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(deviceExtension->CdromTargetDeviceObject,
                          irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    //
    // Check status and map appropriately.
    //

    if (srb->ScsiStatus != SCSISTAT_GOOD) {

        if (srb->ScsiStatus == SCSISTAT_CHECK_CONDITION) {

            status = MapSenseInfo(&ScsiPassThrough->SenseInfoBuffer);
            if (status == STATUS_VERIFY_REQUIRED) {

                if (DeviceObject->Vpb->Flags & VPB_MOUNTED) {

                    DeviceObject->Flags |= DO_VERIFY_VOLUME;
                }
            }
        } else {

            DebugPrint((1,
                       "Cdchgr: Unhandled scsi status %lx\n",
                       srb->ScsiStatus));
            status = STATUS_IO_DEVICE_ERROR;

        }
    }

    DebugPrint((1,
               "Cdchgr: SendSrbPassThrough Status %lx\n",
               status));

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\class\filters\simbad\simbad.c ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    simbad.c

Abstract:

    This driver injects faults by maintaining an array of simulated
    bad blocks and the error code to be returned. Each IO request
    passing through SimBad is tested to see if any of the sectors
    are in the array. If so, the request is failed with the appropriate
    status.

Author:

    Bob Rinne (bobri)
    Mike Glass (mglass)

Environment:

    kernel mode only

Notes:

Revision History:

    22-Jun-94 - venkat   added /b(BugCheck) and /n(RandomWriteDrop) feature
    22-Nov-94 - kpeery   added /t(Resest) feature for restarts
    23-Mar-95 - kpeery   fixed resest feature on arc systems.
    29-Dec-97 - kbarrus  added code: ranges (fail regions on dynamic disks)
    02-Feb-98 - kbarrus  changed memory allocation (wait until request)
    03-Mar-98 - kbarrus  fixed bugcheck/firmware reset behavior
    01-May-98 - kbarrus  use partition0, failing sectors on dynamic disks
    17-Jul-98 - kbarrus  changes: DriverEntry, SimBadInitialize, streamlining
    26-Jul-98 - kbarrus  keep min/max statistics, better sector/range logic
    27-Oct-98 - kbarrus  pnp changes, random write update, debug print update
    11-Jan-99 - kbarrus  device usage notification
    18-Jan-99 - kbarrus  don't page SimBadDeviceControl (acquires spinlock)
    20-Jan-99 - kbarrus  validate buffer lengths, initialize returned buffers,
    14-Mar-99 - kbarrus  303543 
    09-Apr-99 - kbarrus  310247, 310246
    13-Apr-99 - kbarrus  paging path changes
    20-Apr-99 - kbarrus  326977, volume lower filter
    18-May-99 - kbarrus  consistent inputs
    07-Jun-99 - kbarrus  fix add/remove sector and offsets
    24-Sep-99 - kbarrus  fail some ioctl's, look for duplicate ranges
    26-Oct-99 - kbarrus  fix leak
    08-Nov-99 - kbarrus  prefix uninit var
    
--*/

//
// TODO
//
// WMI registration?
//

#include "ntddk.h"
#include "stdarg.h"
#include "stdio.h"
#include "ntdddisk.h"
#include "ntddvol.h"
#include "mountmgr.h"
#include "simbad.h"

//
// internal version number
//

#define SIMBAD_VERSION_A  "v.000105a"
#define SIMBAD_VERSION_W L"v.000105a"

// 
// default sector size
//

#define DEFAULT_SECTOR_SIZE 512

//
// pseudorandom number generator parameters 
// taken from Knuth's Art of Computer Programming
// Volume 2: Seminumerical Algorithms, 3rd edition, p. 185
//

#define MM 2147483647
#define AA 48271
#define QQ 44488
#define RR 3399

#ifdef POOL_TAGGING
   #ifdef ExAllocatePool
      #undef ExAllocatePool
   #endif
   #define ExAllocatePool( a, b ) ExAllocatePoolWithTag( a, b, 'daBS' )
#endif

#if DBG

   //
   // default debug level
   //

   #define DEFAULT_DEBUG_LEVEL 1


   #define DebugPrint( X )  SimBadDebugPrint X

   VOID
      SimBadDebugPrint(
      ULONG DebugPrintLevel,
      ULONG DebugCutoff,
      PCCHAR DebugMessage,
      ...
      );

#else

   #define DebugPrint( X )

#endif // DBG

//
// Pool debugging support - add unique tag to simbad allocations.
//

#ifdef POOL_TAGGING
   #undef ExAllocatePool
   #undef ExAllocatePoolWithQuota
   #define ExAllocatePool( a, b )          ExAllocatePoolWithTag( a, b, 'BmiS' )
   #define ExAllocatePoolWithQuota( a, b ) ExAllocatePoolWithQuotaTag( a, b, 'BmiS' )
#endif

//
// Hal definitions that normal drivers would never call.
//

//
// Define the firmware routine types
//

typedef enum _FIRMWARE_REENTRY
{
   HalHaltRoutine,
   HalPowerDownRoutine,
   HalRestartRoutine,
   HalRebootRoutine,
   HalInteractiveModeRoutine,
   HalMaximumRoutine
} FIRMWARE_REENTRY, * PFIRMWARE_REENTRY;

NTHALAPI VOID HalReturnToFirmware (
   IN FIRMWARE_REENTRY Routine
   );

//
// Device Extension
//

typedef struct _SIMBAD_DEVICE_EXTENSION
{
   //
   // Back pointer to device object
   //

   PDEVICE_OBJECT DeviceObject;

   //
   // Target Device Object
   //

   PDEVICE_OBJECT TargetDeviceObject;

   //
   // Disk number
   //

   ULONG DiskNumber;

   //
   // Partition number
   //

   ULONG PartitionNumber;

   //
   // Volume name
   //

   CHAR * VolumeName;
   
   //
   // Sector Shift Count
   //

   ULONG SectorShift;
   
   //
   // Signature for the device.
   //

   ULONG Signature;
   
   //
   // Simulated bad sector array
   //

   PSIMBAD_SECTORS SimBadSectors;

   //
   // Simulated bad range array
   //

   PSIMBAD_RANGES SimBadRanges;

   //
   // Spinlock to protect queue accesses
   //

   KSPIN_LOCK SpinLock;
   
   //
   // for synchronizing paging path notifications
   //
   
   KEVENT PagingPathCountEvent;

   ULONG  PagingPathCount;

#if DBG

   //
   // min sector referenced
   //

   ULONGLONG SectorMin;

   //
   // max sector referenced
   //

   ULONGLONG SectorMax;

   //
   // Debug print level
   //

   ULONG DebugCutoff;

#endif

} SIMBAD_DEVICE_EXTENSION, * PSIMBAD_DEVICE_EXTENSION;

#define SIMBAD_DEVICE_EXTENSION_SIZE sizeof( SIMBAD_DEVICE_EXTENSION )


//
// Function declarations
//

NTSTATUS DriverEntry (
   IN PDRIVER_OBJECT DriverObject,
   IN PUNICODE_STRING RegistryPath
   );

NTSTATUS SimBadAddDevice(
   IN PDRIVER_OBJECT DriverObject,
   IN PDEVICE_OBJECT PhysicalDeviceObject
   );

void SimBadAllocMemory(
   SIMBAD_SECTORS ** pSectors,
   SIMBAD_RANGES ** pRanges,
   ULONG DebugCutoff
   );

NTSTATUS SimBadCreate(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS SimBadDeviceControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS SimBadDeviceUsage(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS SimBadInit(
   IN PDEVICE_OBJECT DeviceObject
   );

NTSTATUS SimBadIoCompletion(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp,
   IN PVOID Context
   );

NTSTATUS SimBadIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS SimBadPnP(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS SimBadPower(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS SimBadReadWrite(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS SimBadRemoveDevice(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

void SimBadSaveInfo(
   PSIMBAD_SECTORS BadSectors,
   PSIMBAD_RANGES BadRanges
   );

NTSTATUS SimBadSendToNextDriver(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS SimBadSendToNextDriverSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS SimBadShutdownFlush(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS SimBadStartDevice(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

void SimBadUnload(
   IN PDRIVER_OBJECT DriverObject );

ULONG which_bit(
   ULONG data
   );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( PAGE, SimBadAddDevice )
#pragma alloc_text( PAGE, SimBadCreate )
#pragma alloc_text( PAGE, SimBadDeviceUsage )
#pragma alloc_text( PAGE, SimBadInit )
#pragma alloc_text( PAGE, SimBadPnP )
#pragma alloc_text( PAGE, SimBadRemoveDevice )
#pragma alloc_text( PAGE, SimBadShutdownFlush )
#pragma alloc_text( PAGE, SimBadStartDevice )
#pragma alloc_text( PAGE, SimBadUnload )
#endif


NTSTATUS DriverEntry(
   IN PDRIVER_OBJECT DriverObject,
   IN PUNICODE_STRING RegistryPath
   )
{
   ULONG i;

   DebugPrint( ( 0, 0, "SimBad: %s\n", SIMBAD_VERSION_A ) );

   for ( i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++ )
   {
      DriverObject->MajorFunction[ i ] = SimBadSendToNextDriver;
   }

   DriverObject->MajorFunction[ IRP_MJ_CREATE ]         = SimBadCreate;
   DriverObject->MajorFunction[ IRP_MJ_READ ]           = SimBadReadWrite;
   DriverObject->MajorFunction[ IRP_MJ_WRITE ]          = SimBadReadWrite;
   DriverObject->MajorFunction[ IRP_MJ_DEVICE_CONTROL ] = SimBadDeviceControl;
   DriverObject->MajorFunction[ IRP_MJ_SHUTDOWN ]       = SimBadShutdownFlush;
   DriverObject->MajorFunction[ IRP_MJ_FLUSH_BUFFERS ]  = SimBadShutdownFlush;
   DriverObject->MajorFunction[ IRP_MJ_PNP ]            = SimBadPnP;
   DriverObject->MajorFunction[ IRP_MJ_POWER ]          = SimBadPower;
   DriverObject->DriverExtension->AddDevice             = SimBadAddDevice;
   DriverObject->DriverUnload                           = SimBadUnload;

   return STATUS_SUCCESS;

} // end DriverEntry()


NTSTATUS SimBadInit(
   IN PDEVICE_OBJECT DeviceObject
   )
/*
    Simbad keeps an array of bad sectors and an array of bad ranges to
    compare IRP's against.  If simbad isn't enabled, it just passes along 
    the IRP.  If simbad is enabled, it compares the IRP's sector against
    the sector array and range array and fails the request if appropriate.

    Simbad calculates what sectors and/or ranges to fail relative to the
    start of the disk.  Memory allocation for the sector and range array 
    is delayed until needed.  The sector array and range array are 
    allocated as one block of memory, and then subdivided.
*/
{
   NTSTATUS                 status;
   IO_STATUS_BLOCK          ioStatus;
   KEVENT                   event;
   PSIMBAD_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PIRP                     irp;
   STORAGE_DEVICE_NUMBER    number;

   PAGED_CODE();

   KeInitializeSpinLock( &deviceExtension->SpinLock );

   deviceExtension->SimBadSectors = NULL;
   deviceExtension->SimBadRanges = NULL;

   deviceExtension->DiskNumber = -1L;
   deviceExtension->PartitionNumber = -1L;
   deviceExtension->VolumeName = NULL;

#if DBG
   deviceExtension->SectorMin = 0xFFFFFFFFFFFFFFFFL;
   deviceExtension->SectorMax = 0L;
   deviceExtension->DebugCutoff = DEFAULT_DEBUG_LEVEL;
#endif

   //
   // get this info when sectors/ranges are added to a disk
   //

   deviceExtension->Signature = 0L;
   deviceExtension->SectorShift = which_bit( DEFAULT_SECTOR_SIZE );
   
   KeInitializeEvent(
      &event, 
      NotificationEvent, 
      FALSE );

   irp = IoBuildDeviceIoControlRequest(
      IOCTL_STORAGE_GET_DEVICE_NUMBER,
      deviceExtension->TargetDeviceObject,
      NULL,
      0,
      &number,
      sizeof( number ),
      FALSE,
      &event,
      &ioStatus );
   
   if ( !irp ) 
   {
      DebugPrint( ( 0, 0, "SimBad: (init) can't build irp\n" ) );

      return STATUS_INSUFFICIENT_RESOURCES;
   }

   status = IoCallDriver(
      deviceExtension->TargetDeviceObject, 
      irp );

   if ( status == STATUS_PENDING )
   {
      KeWaitForSingleObject(
         &event, 
         Executive, 
         KernelMode, 
         FALSE, 
         NULL );

      status = ioStatus.Status;
   }

   if ( NT_SUCCESS( status ) )
   {
       deviceExtension->DiskNumber = number.DeviceNumber;
       deviceExtension->PartitionNumber = number.PartitionNumber;

       DebugPrint( ( 1, deviceExtension->DebugCutoff,
          "SimBad: (init) \\Device\\Harddisk%lu\\Partition%lu\n",
          deviceExtension->DiskNumber,
          deviceExtension->PartitionNumber ) );
   }
   else
   {
      ULONG iter = 0;
      BOOLEAN done = FALSE;
      ULONG volInfoLen = 0;
      PMOUNTDEV_NAME volName = NULL;
      UNICODE_STRING us;
      ANSI_STRING as;
      
      do
      {
         iter++;

         if ( iter == 1 )
            volInfoLen = sizeof( MOUNTDEV_NAME );
         else
            volInfoLen = sizeof( MOUNTDEV_NAME ) + volName->NameLength;

         if ( volName )
            ExFreePool( volName );

         volName = ExAllocatePool(
            PagedPool,
            volInfoLen );

         if ( !volName )
         {
            DebugPrint( ( 0, 0, "SimBad: (init) ExAllocatePool failed\n" ) );

            status = STATUS_INSUFFICIENT_RESOURCES;

            break;
         }

         KeInitializeEvent(
            &event,
            NotificationEvent,
            FALSE );

         irp = IoBuildDeviceIoControlRequest(
            IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
            deviceExtension->TargetDeviceObject,
            NULL,
            0,
            volName,
            volInfoLen,
            FALSE,
            &event,
            &ioStatus );

         if ( !irp )
         {
            ExFreePool( volName );
            volName = NULL;

            DebugPrint( ( 0, 0, "SimBad: (init) can't build irp\n" ) );

            status = STATUS_INSUFFICIENT_RESOURCES;

            break;
         }

         status = IoCallDriver(
            deviceExtension->TargetDeviceObject,
            irp );

         if ( status == STATUS_PENDING )
         {
             KeWaitForSingleObject(
                &event,
                Executive,
                KernelMode,
                FALSE,
                NULL );

             status = ioStatus.Status;
         }

         if ( iter == 2 || status == STATUS_SUCCESS )
         {
            done = TRUE;
         }
      }
      while ( !done );

      if ( !NT_SUCCESS( status ) )
      {
         if ( volName ) 
            ExFreePool( volName );
         
         DebugPrint( ( 0, 0, 
            "SimBad: (init) IOCTL_MOUNTDEV_QUERY_DEVICE_NAME failed - %x\n", 
            status ) );

         return status;
      }

      us.Length = volName->NameLength;
      us.MaximumLength = volName->NameLength;
      us.Buffer = volName->Name;

      RtlZeroMemory(
         &as,
         sizeof( ANSI_STRING ) );

      status = RtlUnicodeStringToAnsiString(
         &as,
         &us,
         TRUE );

      if ( NT_SUCCESS( status ) )
      {
         deviceExtension->VolumeName = ( CHAR * ) ExAllocatePool(
            NonPagedPool,
            as.Length + 1 );

         if ( deviceExtension->VolumeName )
         {
            RtlZeroMemory(
               deviceExtension->VolumeName,
               as.Length + 1 );
            
            RtlCopyMemory(
               deviceExtension->VolumeName,
               as.Buffer,
               as.Length );
            
            DebugPrint( ( 0, 0, 
               "SimBad: (init) %s\n", 
               deviceExtension->VolumeName ) );
         }
         
         RtlFreeAnsiString( &as );
      }
      else
      {
         DebugPrint( ( 0, 0, 
            "SimBad: (init) RtlUnicodeStringtoAnsiString failed - %x\n", 
            status ) );
      }
      
      ExFreePool( volName );
 
      status = STATUS_SUCCESS;
   }
   
   //
   // WMI registration?
   //

   return status;

} // end SimBadInit()


NTSTATUS SimBadAddDevice(
   IN PDRIVER_OBJECT DriverObject,
   IN PDEVICE_OBJECT PhysicalDeviceObject
   )
{
   NTSTATUS status;
   PDEVICE_OBJECT filterDeviceObject;
   PDEVICE_OBJECT attachedDeviceObject;
   PSIMBAD_DEVICE_EXTENSION deviceExtension;

   PAGED_CODE();

//   DebugPrint( ( 2, 2, "SimBad: (add) add device %x\n" , PhysicalDeviceObject ) );

   attachedDeviceObject = IoGetAttachedDeviceReference( PhysicalDeviceObject );

   status = IoCreateDevice(
      DriverObject,
      sizeof( SIMBAD_DEVICE_EXTENSION ),
      NULL,
      FILE_DEVICE_DISK,
      0,
      FALSE,
      &filterDeviceObject );

   if ( !NT_SUCCESS( status ) )
   {
      DebugPrint( ( 0, 0, "SimBad: (add) IoCreateDevice() failed - %x\n", status ) );

      ObDereferenceObject( attachedDeviceObject );

      return status;
   }

   filterDeviceObject->Flags |= DO_DIRECT_IO;

   if ( attachedDeviceObject )
   {
      if ( attachedDeviceObject->Flags & DO_POWER_PAGABLE )
         filterDeviceObject->Flags |= DO_POWER_PAGABLE;

      if ( attachedDeviceObject->Flags & DO_POWER_INRUSH )
         filterDeviceObject->Flags |= DO_POWER_INRUSH;

      ObDereferenceObject( attachedDeviceObject );
   }
   else
   {
      filterDeviceObject->Flags |= DO_POWER_PAGABLE;
   }

   deviceExtension = filterDeviceObject->DeviceExtension;
   
   RtlZeroMemory( 
      deviceExtension, 
      sizeof( SIMBAD_DEVICE_EXTENSION ) );

   deviceExtension->TargetDeviceObject = IoAttachDeviceToDeviceStack(
      filterDeviceObject,
      PhysicalDeviceObject );

   if ( deviceExtension->TargetDeviceObject == NULL )
   {
      IoDeleteDevice( filterDeviceObject );

      DebugPrint( ( 0, 0, "SimBad: (add) unable to attach filter object\n" ) );

      return STATUS_NO_SUCH_DEVICE;
   }

   deviceExtension->DeviceObject = filterDeviceObject;

   KeInitializeEvent(
      &( deviceExtension->PagingPathCountEvent ),
      NotificationEvent, 
      TRUE );

   filterDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

   return STATUS_SUCCESS;

} // end SimBadAddDevice()


NTSTATUS SimBadReadWrite(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
{
   PSIMBAD_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
   PSIMBAD_SECTORS simBadSectors = NULL;
   PSIMBAD_RANGES simBadRanges = NULL;
   ULONGLONG transferOffset;
   ULONG transferLength;
   ULONG sectorCount;
   ULONGLONG sectorBegin;
   ULONGLONG sectorEnd;
   ULONG i;
   BOOLEAN rangesEnabled;
   BOOLEAN sectorsEnabled;
   BOOLEAN bValid;
   NTSTATUS status;
   KIRQL currentIrql;
   
   if ( deviceExtension )
   {
      simBadSectors = deviceExtension->SimBadSectors;
      simBadRanges = deviceExtension->SimBadRanges;
   }

   //
   // Check if SimBad is enabled.
   //

   sectorsEnabled = ( BOOLEAN ) ( simBadSectors && ( simBadSectors->Flags & SIMBAD_ENABLE ) );
   rangesEnabled = ( BOOLEAN ) ( simBadRanges && ( simBadRanges->Flags & SIMBAD_ENABLE ) );

   if ( sectorsEnabled || rangesEnabled )
   {
      PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation( Irp );
      PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation( Irp );

      //
      // Copy stack parameters to next stack.
      //

      RtlMoveMemory(
         nextIrpStack,
         currentIrpStack,
         sizeof( IO_STACK_LOCATION ) );

      //
      // Calculate various sector and range paramters.
      //

      //
      // Get the offset and length of the read/write from the IRP.
      //

      transferOffset = currentIrpStack->Parameters.Read.ByteOffset.QuadPart;

      transferLength = currentIrpStack->Parameters.Read.Length;

      //
      // Calculate number of sectors in this transfer.
      //

      sectorCount = transferLength >>
         deviceExtension->SectorShift;

      //
      // Calculate beginning sector, an offset from the start of the disk.
      //

      sectorBegin = transferOffset >>
         deviceExtension->SectorShift;

      //
      // Calculate ending sector, an offset from the start of the disk.
      //

      sectorEnd = sectorBegin + sectorCount - 1;

      if ( sectorEnd < sectorBegin )
         DebugPrint( ( 0, deviceExtension->DebugCutoff,
            "Simbad: (rw) 0 sector count??\n" ) );

#if DBG
      if ( sectorBegin < deviceExtension->SectorMin )
         deviceExtension->SectorMin = sectorBegin;

      if ( deviceExtension->SectorMax < sectorEnd )
         deviceExtension->SectorMax = sectorEnd;
#endif
      
      DebugPrint( ( 4, deviceExtension->DebugCutoff,
         "Simbad: (rw) length %x, offset %I64x\n",
         transferLength,
         transferOffset ) );

      if ( sectorsEnabled || rangesEnabled )
         DebugPrint( ( 3, deviceExtension->DebugCutoff,
            "Simbad: (rw) sector: begin %I64x, end %I64x\n",
            sectorBegin,
            sectorEnd ) );

      //
      // Orphan (applies to a range).
      //

      if ( rangesEnabled && ( simBadRanges->Flags & SIMBAD_ORPHAN ) )
      {         
         for ( i = 0; i < simBadRanges->RangeCount; i++ )
         {
            //
            //    (if the r/w begin is in the bad range)
            // or (if the r/w end is in the bad range)
            // or (if the r/w begin is before the bad range and
            //        the r/w end is after the bad range)
            //

            if ( ( simBadRanges->Range[ i ].BlockBegin <= sectorBegin &&
               sectorBegin <= simBadRanges->Range[ i ].BlockEnd ) ||
               ( simBadRanges->Range[ i ].BlockBegin <= sectorEnd &&
               sectorEnd <= simBadRanges->Range[ i ].BlockEnd ) ||
               ( sectorBegin <= simBadRanges->Range[ i ].BlockBegin &&
               simBadRanges->Range[ i ].BlockEnd <= sectorEnd ) )
            {
               KeAcquireSpinLock(
                  &deviceExtension->SpinLock,
                  &currentIrql );
               
               rangesEnabled = ( BOOLEAN ) ( simBadRanges && ( simBadRanges->Flags & SIMBAD_ENABLE ) );

               bValid = ( BOOLEAN ) ( rangesEnabled && 
                  ( simBadRanges->Flags & SIMBAD_ORPHAN ) && 
                  i < simBadRanges->RangeCount );
               
               status = simBadRanges->Range[ i ].Status;               
               
               KeReleaseSpinLock(
                  &deviceExtension->SpinLock,
                  currentIrql );

               if ( bValid )
               {
                  DebugPrint( ( 2, deviceExtension->DebugCutoff,
                     "SimBad: (rw) orphaning - sector %I64x in range\n",
                     sectorBegin ) );

                  Irp->IoStatus.Status = status;
                  Irp->IoStatus.Information = 0;
                  
                  IoCompleteRequest(
                     Irp,
                     IO_NO_INCREMENT );

                  return status;
               }
            } // if (in range)
         } // for (...)
      } // if (simBadRanges...)

      //
      // Random write failure (applies to a range).
      //

      if ( rangesEnabled && ( simBadRanges->Flags & SIMBAD_RANDOM_WRITE_FAIL ) &&
           currentIrpStack->MajorFunction == IRP_MJ_WRITE )
      {
         for ( i = 0; i < simBadRanges->RangeCount; i++ )
         {
            //
            //    (if the r/w begin is in the bad range)
            // or (if the r/w end is in the bad range)
            // or (if the r/w begin is before the bad range and
            //        the r/w end is after the bad range)
            //

            if ( ( simBadRanges->Range[ i ].BlockBegin <= sectorBegin &&
               sectorBegin <= simBadRanges->Range[ i ].BlockEnd ) ||
               ( simBadRanges->Range[ i ].BlockBegin <= sectorEnd &&
               sectorEnd <= simBadRanges->Range[ i ].BlockEnd ) ||
               ( sectorBegin <= simBadRanges->Range[ i ].BlockBegin &&
               simBadRanges->Range[ i ].BlockEnd <= sectorEnd ) )
            {
               KeAcquireSpinLock(
                  &deviceExtension->SpinLock,
                  &currentIrql );
               
               simBadRanges->Seed = AA * ( simBadRanges->Seed % QQ ) - 
                  RR * ( long ) ( simBadRanges->Seed / QQ );

               if ( simBadRanges->Seed < 0 )
                  simBadRanges->Seed += MM;
               
               rangesEnabled = ( BOOLEAN ) ( simBadRanges && ( simBadRanges->Flags & SIMBAD_ENABLE ) );

               bValid = ( BOOLEAN ) ( rangesEnabled && 
                  ( simBadRanges->Flags & SIMBAD_RANDOM_WRITE_FAIL ) &&
                  currentIrpStack->MajorFunction == IRP_MJ_WRITE &&
                  i < simBadRanges->RangeCount && 
                  ( simBadRanges->Seed % simBadRanges->Modulus ) == 0 );
                              
               KeReleaseSpinLock(
                  &deviceExtension->SpinLock,
                  currentIrql );

               if ( bValid )
               {
                  DebugPrint( ( 2, deviceExtension->DebugCutoff,
                     "SimBad: dropping a write, seed %lu\n",
                     simBadRanges->Seed ) );
                                    
                  Irp->IoStatus.Status = STATUS_SUCCESS;

                  IoCompleteRequest(
                     Irp,
                     IO_NO_INCREMENT );

                  return STATUS_SUCCESS;
               }
               else
               {
                  DebugPrint( ( 3, deviceExtension->DebugCutoff,
                     "SimBad: not dropping a write, seed %lu\n",
                     simBadRanges->Seed ) );
               }
            } // if (in range)
         } // for (...)
      } // if (simBadRanges...)

      //
      // Check sector list.
      //

      if ( sectorsEnabled && simBadSectors->SectorCount != 0 )
      {
         ULONG goodLength;
         
         KeAcquireSpinLock(
            &deviceExtension->SpinLock,
            &currentIrql );

         for ( i = 0; i < simBadSectors->SectorCount; i++ )
         {
            if ( ( simBadSectors->Sector[ i ].BlockAddress >= sectorBegin ) &&
               ( simBadSectors->Sector[ i ].BlockAddress <= sectorEnd ) )
            {
               if ( ( ( simBadSectors->Sector[ i ].AccessType & SIMBAD_ACCESS_READ ) &&
                  ( currentIrpStack->MajorFunction == IRP_MJ_READ ) ) ||
                  ( ( simBadSectors->Sector[ i ].AccessType & SIMBAD_ACCESS_WRITE ) &&
                  ( currentIrpStack->MajorFunction == IRP_MJ_WRITE ) ) )
               {
                  //
                  // Calculate the new length up to the bad sector, 
                  // check if this the first bad sector in the request.
                  //
                  
                  goodLength = ( ULONG ) ( simBadSectors->Sector[ i ].BlockAddress - sectorBegin ) <<
                     deviceExtension->SectorShift;

                  if ( goodLength == 0 )
                  {                     
                     status = simBadSectors->Sector[ i ].Status;
                     
                     KeReleaseSpinLock(
                        &deviceExtension->SpinLock,
                        currentIrql );
                     
                     Irp->IoStatus.Status = status;
                     Irp->IoStatus.Information = 0;

                     IoCompleteRequest(
                        Irp,
                        IO_NO_INCREMENT );

                     return status;
                  }
                  else if ( goodLength < nextIrpStack->Parameters.Read.Length )
                  {
                     //
                     // Reduce bytes requested to number before bad sector.
                     //

                     nextIrpStack->Parameters.Read.Length = goodLength;
                  }
               } // if (read/write)
            } // if (in range)
         } // for (...)

         KeReleaseSpinLock(
            &deviceExtension->SpinLock,
            currentIrql );

      } // if (simBadSectors)

      //
      // Check range list.
      //

      if ( rangesEnabled && simBadRanges->RangeCount != 0 )
      {
         ULONG goodLength;

         KeAcquireSpinLock(
            &deviceExtension->SpinLock,
            &currentIrql );

         for ( i = 0; i < simBadRanges->RangeCount; i++ )
         {
            //
            //    (if the r/w begin is in the bad range)
            // or (if the r/w end is in the bad range)
            // or (if the r/w begin is before the bad range and
            //        the r/w end is after the bad range)
            //

            if ( ( simBadRanges->Range[ i ].BlockBegin <= sectorBegin &&
               sectorBegin <= simBadRanges->Range[ i ].BlockEnd ) ||
               ( simBadRanges->Range[ i ].BlockBegin <= sectorEnd &&
               sectorEnd <= simBadRanges->Range[ i ].BlockEnd ) ||
               ( sectorBegin <= simBadRanges->Range[ i ].BlockBegin &&
               simBadRanges->Range[ i ].BlockEnd <= sectorEnd ) )
            {
               if ( ( (simBadRanges->Range[ i ].AccessType & SIMBAD_ACCESS_READ ) &&
                  ( currentIrpStack->MajorFunction == IRP_MJ_READ ) ) ||
                  ( ( simBadRanges->Range[ i ].AccessType & SIMBAD_ACCESS_WRITE ) &&
                  ( currentIrpStack->MajorFunction == IRP_MJ_WRITE ) ) )
               {
                  //
                  // two cases:
                  //
                  // 1.  r/w begin is before the bad range
                  //   fixup next IRP, allow good sectors to complete
                  //
                  // 2.  r/w begin is in the bad range
                  //   complete and return simulated status
                  //

                  if ( sectorBegin <= simBadRanges->Range[ i ].BlockBegin )
                  {
                     //
                     // Calculate the new length up to the bad range.
                     //

                     goodLength = ( ULONG )
                     ( simBadRanges->Range[ i ].BlockBegin - sectorBegin ) <<
                        deviceExtension->SectorShift;

                     if ( goodLength < nextIrpStack->Parameters.Read.Length )
                     {
                        //
                        // Reduce bytes requested to number before bad range.
                        //

                        nextIrpStack->Parameters.Read.Length = goodLength;
                     }
                  }
                  else
                  {
                     status = simBadRanges->Range[ i ].Status;

                     KeReleaseSpinLock(
                        &deviceExtension->SpinLock,
                        currentIrql );

                     Irp->IoStatus.Status = status;
                     Irp->IoStatus.Information = 0;

                     IoCompleteRequest(
                        Irp,
                        IO_NO_INCREMENT );

                     return status;
                  }
               } // if (read/write)
            } // if (in range)
         } // for (...)

         KeReleaseSpinLock(
            &deviceExtension->SpinLock,
            currentIrql );

      } // if (simBadRanges)

      //
      // Set completion routine callback.
      //

      IoSetCompletionRoutine(
         Irp,
         SimBadIoCompletion,
         deviceExtension,
         TRUE,
         TRUE,
         TRUE );
   }
   else
   {
      //
      // Simbad is disabled. Set stack back to hide simbad.
      //

      IoSkipCurrentIrpStackLocation( Irp );
   }

   //
   // Call target driver.
   //

   return IoCallDriver(
      deviceExtension->TargetDeviceObject,
      Irp );

} // end SimBadReadWrite()


NTSTATUS SimBadIoCompletion(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp,
   IN PVOID Context
   )
/*++

Routine Description:

    This routine is called when the I/O request has completed only if
    SimBad is enabled for this partition. The routine checks the I/O request
    to see if a sector involved in the request is to be failed.

Arguments:

    DeviceObject - SimBad device object.
    Irp          - Completed request.
    Context      - not used.  Set up to also be a pointer to the DeviceObject.

Return Value:

    NTSTATUS

--*/
{
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation( Irp );
   PSIMBAD_DEVICE_EXTENSION deviceExtension = ( PSIMBAD_DEVICE_EXTENSION ) Context;
   PSIMBAD_SECTORS simBadSectors = NULL;
   PSIMBAD_RANGES simBadRanges = NULL;
   ULONG sectorCount;
   ULONGLONG sectorBegin;
   ULONGLONG sectorEnd;
   ULONG i;
   BOOLEAN rangesEnabled;
   BOOLEAN sectorsEnabled;
   KIRQL currentIrql;

   if ( deviceExtension )
   {
      simBadSectors = deviceExtension->SimBadSectors;
      simBadRanges = deviceExtension->SimBadRanges;
   }

   //
   // Check if some other error occurred.
   //

   if ( !NT_SUCCESS( Irp->IoStatus.Status ) )
   {
      return Irp->IoStatus.Status;
   }

   //
   // Get current stack.
   //

   irpStack = IoGetCurrentIrpStackLocation( Irp );

   //
   // Check for VERIFY SECTOR IOCTL (Format).
   //

   if ( irpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL )
   {
      PVERIFY_INFORMATION verifyInfo = Irp->AssociatedIrp.SystemBuffer;

      //
      // Get beginning sector and number of sectors from verify parameters.
      // Convert from byte counts to sector counts.
      //

      sectorBegin = verifyInfo->StartingOffset.QuadPart >>
         deviceExtension->SectorShift;

      sectorCount = verifyInfo->Length >>
         deviceExtension->SectorShift;
   }
   else
   {
      //
      // Calculate beginning sector.
      //

      sectorBegin = irpStack->Parameters.Read.ByteOffset.QuadPart >>
         deviceExtension->SectorShift;

      //
      // Calculate number of sectors in this transfer.
      //

      sectorCount = irpStack->Parameters.Read.Length >>
         deviceExtension->SectorShift;
   }

   //
   // Calculate ending sector and range;
   //

   sectorEnd = sectorBegin + sectorCount - 1;

   sectorsEnabled = ( BOOLEAN ) ( simBadSectors && ( simBadSectors->Flags & SIMBAD_ENABLE ) );
   rangesEnabled = ( BOOLEAN ) ( simBadRanges && ( simBadRanges->Flags & SIMBAD_ENABLE ) );

   if ( sectorsEnabled && simBadSectors->SectorCount != 0 )
   {
      DebugPrint( ( 4, deviceExtension->DebugCutoff,
         "SimBad: (io) sector begin %I64x, end %I64x\n",
         sectorBegin,
         sectorEnd ) );

      //
      // Acquire spinlock.
      //

      KeAcquireSpinLock(
         &deviceExtension->SpinLock,
         &currentIrql );

      for ( i = 0; i < simBadSectors->SectorCount; i++ )
      {
         if ( ( simBadSectors->Sector[ i ].BlockAddress >= sectorBegin ) &&
            ( simBadSectors->Sector[ i ].BlockAddress <= sectorEnd ) )
         {
            //
            // Request includes this simulated bad sector.
            //

            BOOLEAN bReadFailure =
               ( simBadSectors->Sector[ i ].AccessType & SIMBAD_ACCESS_READ ) &&
               ( irpStack->MajorFunction == IRP_MJ_READ );

            BOOLEAN bVerifyFailure =
               ( simBadSectors->Sector[ i ].AccessType & SIMBAD_ACCESS_VERIFY ) &&
               ( irpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL );

            BOOLEAN bWriteFailure =
               ( simBadSectors->Sector[ i ].AccessType & SIMBAD_ACCESS_WRITE ) &&
               ( irpStack->MajorFunction == IRP_MJ_WRITE );

            if ( bReadFailure || bVerifyFailure || bWriteFailure )
            {
               if ( bReadFailure )
                  DebugPrint( ( 2, deviceExtension->DebugCutoff,
                     "SimBad: (io) bad read sector %I64x\n",
                     simBadSectors->Sector[ i ].BlockAddress ) );
               else if ( bVerifyFailure )
                  DebugPrint( ( 2, deviceExtension->DebugCutoff,
                     "SimBad: (io) bad verify sector %I64x\n",
                     simBadSectors->Sector[ i ].BlockAddress ) );
               else if ( bWriteFailure )
                  DebugPrint( ( 2, deviceExtension->DebugCutoff,
                     "SimBad: (io) bad write sector %I64x\n",
                     simBadSectors->Sector[ i ].BlockAddress ) );

               //
               // Update the information field to reflect the location
               // of the failure.
               //

               if ( simBadSectors->Sector[ i ].AccessType & SIMBAD_ACCESS_ERROR_ZERO_OFFSET )
               {
                  Irp->IoStatus.Information = 0;
               }

               Irp->IoStatus.Status = simBadSectors->Sector[ i ].Status;

               break;
            }
         } // if (in range)
      } // for(...)

      KeReleaseSpinLock(
         &deviceExtension->SpinLock,
         currentIrql );

   } // if (simBadSectors)

   if ( rangesEnabled && simBadRanges->RangeCount != 0 )
   {
      DebugPrint( ( 4, deviceExtension->DebugCutoff,
         "SimBad: (io) range begin %I64x, end %I64x\n",
         sectorBegin,
         sectorEnd ) );

      //
      // Acquire spinlock.
      //

      KeAcquireSpinLock(
         &deviceExtension->SpinLock,
         &currentIrql );

      for ( i = 0; i < simBadRanges->RangeCount; i++ )
      {
         //
         //    (if the r/w begin is in the bad range)
         // or (if the r/w end is in the bad range)
         // or (if the r/w begin is before the bad range and
         //        the r/w end is after the bad range)
         //

         if ( ( simBadRanges->Range[ i ].BlockBegin <= sectorBegin &&
            sectorBegin <= simBadRanges->Range[ i ].BlockEnd ) ||
            ( simBadRanges->Range[ i ].BlockBegin <= sectorEnd &&
            sectorEnd <= simBadRanges->Range[ i ].BlockEnd ) ||
            ( sectorBegin <= simBadRanges->Range[ i ].BlockBegin &&
            simBadRanges->Range[ i ].BlockEnd <= sectorEnd ) )
         {
            //
            // Request includes this simulated bad range.
            //

            BOOLEAN bReadFailure =
               ( simBadRanges->Range[ i ].AccessType & SIMBAD_ACCESS_READ ) &&
               ( irpStack->MajorFunction == IRP_MJ_READ );

            BOOLEAN bVerifyFailure =
               ( simBadRanges->Range[ i ].AccessType & SIMBAD_ACCESS_VERIFY ) &&
               ( irpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL );

            BOOLEAN bWriteFailure =
               ( simBadRanges->Range[ i ].AccessType & SIMBAD_ACCESS_WRITE ) &&
               ( irpStack->MajorFunction == IRP_MJ_WRITE );

            if ( bReadFailure || bVerifyFailure || bWriteFailure )
            {
               if ( bReadFailure )
                  DebugPrint( ( 2, deviceExtension->DebugCutoff,
                     "SimBad: (io) bad read range %I64x to %I64x\n",
                     simBadRanges->Range[ i ].BlockBegin,
                     simBadRanges->Range[ i ].BlockEnd ) );
               else if ( bVerifyFailure )
                  DebugPrint( ( 2, deviceExtension->DebugCutoff,
                     "SimBad: (io) bad verify range %I64x to %I64x\n",
                     simBadRanges->Range[ i ].BlockBegin,
                     simBadRanges->Range[ i ].BlockEnd ) );
               else if ( bWriteFailure )
                  DebugPrint( ( 2, deviceExtension->DebugCutoff,
                     "SimBad: (io) bad write range %I64x to %I64x\n",
                     simBadRanges->Range[ i ].BlockBegin,
                     simBadRanges->Range[ i ].BlockEnd ) );

               //
               // Update the information field to reflect the location
               // of the failure.
               //

               if ( simBadRanges->Range[ i ].AccessType & SIMBAD_ACCESS_ERROR_ZERO_OFFSET )
               {
                  Irp->IoStatus.Information = 0;
               }

               Irp->IoStatus.Status = simBadRanges->Range[ i ].Status;

               break;
            }
         } // if (in range)
      } // for(...)

      KeReleaseSpinLock(
         &deviceExtension->SpinLock,
         currentIrql );

   } // if (simBadRanges)

   if ( Irp->PendingReturned )
   {
      IoMarkIrpPending(
         Irp );
   }

   return STATUS_SUCCESS;

} // end SimBadIoCompletion()


NTSTATUS SimBadDeviceControl(
   PDEVICE_OBJECT DeviceObject,
   PIRP Irp
   )
{
   PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation( Irp );
   PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation( Irp );
   PSIMBAD_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PSIMBAD_DATA simBadDataIn = NULL;
   PSIMBAD_DATA simBadDataInCopy = NULL;
   PSIMBAD_DATA simBadDataOut = NULL;
   PSIMBAD_SECTORS simBadSectors = NULL;
   PSIMBAD_RANGES simBadRanges = NULL;
   KIRQL currentIrql;
   NTSTATUS status;
   ULONG i;
   ULONG j;

   if ( deviceExtension )
   {
      simBadSectors = deviceExtension->SimBadSectors;
      simBadRanges = deviceExtension->SimBadRanges;
   }

   switch ( currentIrpStack->Parameters.DeviceIoControl.IoControlCode )
   {
   case IOCTL_DISK_SIMBAD:

      if ( deviceExtension->VolumeName )
         DebugPrint( ( 2, deviceExtension->DebugCutoff,
            "SimBad: (rw) %s\n",
            deviceExtension->VolumeName ) );   
      else
         DebugPrint( ( 2, deviceExtension->DebugCutoff,
            "SimBad: (rw) \\Device\\Harddisk%lu\\Partition%lu\n",
            deviceExtension->DiskNumber,
            deviceExtension->PartitionNumber ) );   

      //
      // ensure the buffer sizes are reasonable
      //
      // the input buffer length should always be greater than or equal to sizeof( SIMBAD_DATA )
      //   this is because every simbad request is in the form of a SIMBAD_DATA structure, even if
      //   the request doesn't require any additional data or winds up returning info (!)
      //
      // the output buffer length is either
      //   sizeof( SIMBAD_DATA ) - for SIMBAD_LIST_BAD_SECTORS and SIMBAD_LIST_BAD_RANGES; or
      //   large enough to hold the SIMBAD_VERSION_W string, for SIMBAD_GET_VERSION
      //

      if ( currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof( SIMBAD_DATA ) )
      {
         status = STATUS_INFO_LENGTH_MISMATCH;
         break;
      }

      //
      // input buffer length is large enough, so we can look inside
      //

      simBadDataIn = Irp->AssociatedIrp.SystemBuffer;

      if ( simBadDataIn->Function == SIMBAD_LIST_BAD_SECTORS || 
           simBadDataIn->Function == SIMBAD_LIST_BAD_RANGES ||
           simBadDataIn->Function == SIMBAD_GET_VERSION )
      {
         ULONG minBufferLength;

         if ( simBadDataIn->Function == SIMBAD_GET_VERSION )
            minBufferLength = ( strlen( SIMBAD_VERSION_A ) + 1 ) * sizeof( wchar_t );
         else
            minBufferLength = sizeof( SIMBAD_DATA );

         if ( currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength < minBufferLength )
         {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
         }
      }

      simBadDataOut = Irp->UserBuffer;

      switch ( simBadDataIn->Function )
      {

      case SIMBAD_ADD_SECTORS:

         DebugPrint( ( 2, deviceExtension->DebugCutoff,
            "SimBad: (ioctl) adding sectors\n" ) );

         if ( !simBadSectors )
         {
            SimBadAllocMemory(
               &deviceExtension->SimBadSectors,
               &deviceExtension->SimBadRanges,
#if DBG
               deviceExtension->DebugCutoff );
#else
               0 );
#endif

            simBadSectors = deviceExtension->SimBadSectors;
            simBadRanges = deviceExtension->SimBadRanges;
         }

         simBadDataInCopy = ( PSIMBAD_DATA ) ExAllocatePool( 
            NonPagedPool,
            currentIrpStack->Parameters.DeviceIoControl.InputBufferLength );

         //
         // SIMBAD_ADD_SECTORS expects incoming sectors to be specified as:
         //   partition: sector number
         //   volume: sector number
         //

         if ( simBadSectors && simBadDataInCopy )
         {
            RtlCopyMemory(
               simBadDataInCopy,
               simBadDataIn,
               currentIrpStack->Parameters.DeviceIoControl.InputBufferLength );

            deviceExtension->SectorShift = which_bit( simBadDataInCopy->RangeCount );

            KeAcquireSpinLock(
               &deviceExtension->SpinLock,
               &currentIrql );
            
            //
            // replace existing sector if the block address is equal
            //

            for ( i = 0; i < simBadDataInCopy->SectorCount; i++ )
            {
               for ( j = 0; j < simBadSectors->SectorCount; j++ )
               {
                  if ( i >= MAXIMUM_SIMBAD_SECTORS || j >= MAXIMUM_SIMBAD_SECTORS )
                     break;

                  if ( simBadDataInCopy->Sector[ i ].BlockAddress == simBadSectors->Sector[ j ].BlockAddress )
                  {
                     simBadSectors->Sector[ j ] = simBadDataInCopy->Sector[ i ];
                     
                     DebugPrint( ( 2, deviceExtension->DebugCutoff,
                        "SimBad: (ioctl) sector replace: %I64x\n",
                        simBadSectors->Sector[ j ].BlockAddress ) );

                     simBadDataInCopy->Sector[ i ].BlockAddress = -1;
                  }
               }
            }

            for ( i = 0, j = simBadSectors->SectorCount; i < simBadDataInCopy->SectorCount; i++, j++ )
            {
               if ( i >= MAXIMUM_SIMBAD_SECTORS || j >= MAXIMUM_SIMBAD_SECTORS )
                  break;

               if ( simBadDataInCopy->Sector[ i ].BlockAddress == -1 )
                  continue;

               simBadSectors->Sector[ j ] = simBadDataInCopy->Sector[ i ];
               simBadSectors->SectorCount++;
               
               DebugPrint( ( 2, deviceExtension->DebugCutoff,
                  "SimBad: (ioctl) sector add: %I64x\n",
                  simBadSectors->Sector[ j ].BlockAddress ) );
            } // for (i ...)
            
            //
            // If any sectors added return success.
            //

            if ( i )
               status = STATUS_SUCCESS;
            else
               status = STATUS_UNSUCCESSFUL;

            KeReleaseSpinLock(
               &deviceExtension->SpinLock,
               currentIrql );
         }
         else
         {
            status = STATUS_NO_MEMORY;
         }
         
         if ( simBadDataInCopy )
         {
            ExFreePool( simBadDataInCopy );
            simBadDataInCopy = NULL;
         }

         break;

      case SIMBAD_REMOVE_SECTORS:

         //
         // SIMBAD_REMOVE_SECTORS expects incoming sectors to be specified as:
         //   partition: sector number
         //   volume: sector number
         //

         DebugPrint( ( 2, deviceExtension->DebugCutoff,
            "SimBad: (ioctl) removing sectors\n" ) );

         if ( simBadSectors )
         {
            KeAcquireSpinLock(
               &deviceExtension->SpinLock,
               &currentIrql );

            for ( i = 0; i < simBadDataIn->SectorCount && i < MAXIMUM_SIMBAD_SECTORS; i++ )
            {
               for ( j = 0; j < simBadSectors->SectorCount && j < MAXIMUM_SIMBAD_SECTORS; j++ )
               {
                  if ( simBadSectors->Sector[ j ].BlockAddress == simBadDataIn->Sector[ i ].BlockAddress )
                  {
                     ULONG k;

                     for ( k = j + 1; k < simBadSectors->SectorCount && k < MAXIMUM_SIMBAD_SECTORS; k++ )
                     {
                        simBadSectors->Sector[ k - 1 ] = simBadSectors->Sector[ k ];
                     }

                     simBadSectors->SectorCount--;

                     //
                     // Break out of middle loop.
                     //

                     break;
                  } // if (simBadSectors ...)
               } // for (j= ...)
            } // for (i= ...)
            
            //
            // If all sectors removed return success.
            //

            if ( simBadDataIn->SectorCount == i )
               status = STATUS_UNSUCCESSFUL;
            else
               status = STATUS_SUCCESS;
            
            KeReleaseSpinLock(
               &deviceExtension->SpinLock,
               currentIrql );
         }
         else
         {
            status = STATUS_UNSUCCESSFUL;
         }

         break;

      case SIMBAD_LIST_BAD_SECTORS:

         DebugPrint( ( 2, deviceExtension->DebugCutoff,
            "SimBad: (ioctl) listing sectors\n" ) );
         
         KeAcquireSpinLock(
            &deviceExtension->SpinLock,
            &currentIrql );

         try
         {
            if ( simBadSectors )
            {
               DebugPrint( ( 2, deviceExtension->DebugCutoff,
                  "SimBad: (ioctl) returning %lu sector%s\n",
                  simBadSectors->SectorCount,
                  simBadSectors->SectorCount == 1 ? "" : "s" ) );
                              
               RtlZeroMemory(
                  ( VOID * ) simBadDataOut,
                  sizeof( SIMBAD_DATA ) );
      
               for ( i = 0; i < simBadSectors->SectorCount && i < MAXIMUM_SIMBAD_SECTORS; i++ )
               {
                  DebugPrint( ( 2, deviceExtension->DebugCutoff,
                     "SimBad: (ioctl) sector %I64x status %x access %x\n",
                     simBadSectors->Sector[ i ].BlockAddress,
                     simBadSectors->Sector[ i ].Status,
                     simBadSectors->Sector[ i ].AccessType ) );
      
                     simBadDataOut->Sector[ i ] = simBadSectors->Sector[ i ];
               }
      
               simBadDataOut->SectorCount = simBadSectors->SectorCount;
            }
            else
            {
               simBadDataOut->SectorCount = 0;
            }
   
            simBadDataOut->RangeCount = 0;
   
            status = STATUS_SUCCESS;
         }
         except( EXCEPTION_EXECUTE_HANDLER )
         {
            status = GetExceptionCode();
         }
         
         KeReleaseSpinLock(
            &deviceExtension->SpinLock,
            currentIrql );

         break;

      case SIMBAD_ADD_RANGES:

         DebugPrint( ( 2, deviceExtension->DebugCutoff,
            "SimBad: (ioctl) adding ranges\n" ) );

         if ( !simBadSectors )
         {
            SimBadAllocMemory(
               &deviceExtension->SimBadSectors,
               &deviceExtension->SimBadRanges,
#if DBG
               deviceExtension->DebugCutoff );
#else
               0 );
#endif

            simBadSectors = deviceExtension->SimBadSectors;
            simBadRanges = deviceExtension->SimBadRanges;
         }
         
         simBadDataInCopy = ( PSIMBAD_DATA ) ExAllocatePool( 
            NonPagedPool,
            currentIrpStack->Parameters.DeviceIoControl.InputBufferLength );

         //
         // SIMBAD_ADD_RANGES expects incoming sectors to be specified as:
         //   partition: start offset in sectors, end offset in sectors
         //   volume: start offset in sectors, end offset in sectors
         //

         if ( simBadRanges && simBadDataInCopy )
         {
            RtlCopyMemory(
               simBadDataInCopy,
               simBadDataIn,
               currentIrpStack->Parameters.DeviceIoControl.InputBufferLength );

            deviceExtension->SectorShift = which_bit( simBadDataInCopy->SectorCount );
            
            KeAcquireSpinLock(
               &deviceExtension->SpinLock,
               &currentIrql );

            //
            // replace existing ranges if the begin block and end block are equal
            //

            for ( i = 0; i < simBadDataInCopy->RangeCount; i++ )
            {
               for ( j = 0; j < simBadRanges->RangeCount; j++ )
               {
                  if ( i >= MAXIMUM_SIMBAD_RANGES || j >= MAXIMUM_SIMBAD_RANGES )
                     break;

                  if ( simBadRanges->Range[ j ].BlockBegin == simBadDataInCopy->Range[ i ].BlockBegin &&
                       simBadRanges->Range[ j ].BlockEnd == simBadDataInCopy->Range[ i ].BlockEnd )
                  {
                     simBadRanges->Range[ j ] = simBadDataInCopy->Range[ i ];
                     
                     DebugPrint( ( 2, deviceExtension->DebugCutoff,
                        "SimBad: (ioctl) range replace: sector start %I64x, end %I64x\n",
                        simBadRanges->Range[ j ].BlockBegin,
                        simBadRanges->Range[ j ].BlockEnd ) );

                     simBadDataInCopy->Range[ i ].BlockBegin = 0L;
                     simBadDataInCopy->Range[ i ].BlockEnd = 0L;
                  }
               }
            }
            
            //
            // add new ranges, ignore zero length ranges (replaced ranges are initialized to
            // this to prevent them from being added again)
            //

            for ( i = 0, j = simBadRanges->RangeCount; i < simBadDataInCopy->RangeCount; i++, j++ )
            {
               if ( i >= MAXIMUM_SIMBAD_RANGES || j >= MAXIMUM_SIMBAD_RANGES )
                  break;

               if ( simBadDataInCopy->Range[ i ].BlockBegin == simBadDataInCopy->Range[ i ].BlockEnd )
                  continue;
            
               simBadRanges->Range[ j ] = simBadDataInCopy->Range[ i ];
               simBadRanges->RangeCount++;

               DebugPrint( ( 2, deviceExtension->DebugCutoff,
                  "SimBad: (ioctl) range add: sector start %I64x, end %I64x\n",
                  simBadRanges->Range[ j ].BlockBegin,
                  simBadRanges->Range[ j ].BlockEnd ) );

            } // for (i ...)
            
            //
            // If any ranges added return success.
            //

            if ( i )
               status = STATUS_SUCCESS;
            else
               status = STATUS_UNSUCCESSFUL;
            
            KeReleaseSpinLock(
               &deviceExtension->SpinLock,
               currentIrql );           
         }
         else
         {
            status = STATUS_NO_MEMORY;
         }

         if ( simBadDataInCopy )
         {
            ExFreePool( simBadDataInCopy );
            simBadDataInCopy = NULL;
         }

         break;

      case SIMBAD_REMOVE_RANGES:

         //
         // SIMBAD_ADD_RANGES expects incoming sectors to be specified as:
         //   partition: start offset in sectors, end offset in sectors
         //   volume: start offset in sectors, end offset in sectors
         //

         DebugPrint( ( 2, deviceExtension->DebugCutoff,
            "SimBad: (ioctl) removing ranges\n" ) );

         if ( simBadRanges )
         {
            KeAcquireSpinLock(
               &deviceExtension->SpinLock,
               &currentIrql );
            
            for ( i = 0; i < simBadDataIn->RangeCount && i < MAXIMUM_SIMBAD_RANGES; i++ )
            {
               for ( j = 0; j < simBadRanges->RangeCount && j < MAXIMUM_SIMBAD_RANGES; j++ )
               {
                  //
                  // Look for the specified range.
                  //

                  BOOLEAN startMatch = ( simBadRanges->Range[ j ].BlockBegin == simBadDataIn->Range[ i ].BlockBegin );
                  BOOLEAN endMatch = ( simBadRanges->Range[ j ].BlockEnd == simBadDataIn->Range[ i ].BlockEnd );

                  if ( startMatch && endMatch )
                  {
                     ULONG k;

                     for ( k = j + 1; k < simBadRanges->RangeCount && k < MAXIMUM_SIMBAD_RANGES; k++ )
                     {
                        simBadRanges->Range[ k - 1 ]= simBadRanges->Range[ k ];
                     }

                     simBadRanges->RangeCount--;

                     //
                     // Break out of middle loop.
                     //

                     break;
                  } // if (simBadRanges ...)
               } // for (j= ...)
            } // for (i== ...)
            
            //
            // If all ranges removed return success.
            //

            if ( simBadDataIn->RangeCount == i )
               status = STATUS_UNSUCCESSFUL;
            else
               status = STATUS_SUCCESS;
            
            KeReleaseSpinLock(
               &deviceExtension->SpinLock,
               currentIrql );
         }
         else
         {
            status = STATUS_UNSUCCESSFUL;
         }

         break;

      case SIMBAD_LIST_BAD_RANGES:

         DebugPrint( ( 2, deviceExtension->DebugCutoff,
            "SimBad: (ioctl) listing ranges\n" ) );
         
         KeAcquireSpinLock(
            &deviceExtension->SpinLock,
            &currentIrql );
         
         try
         {
            RtlZeroMemory(
               ( VOID * ) simBadDataOut,
               sizeof( SIMBAD_DATA ) );
   
            if ( simBadRanges )
            {
               DebugPrint( ( 2, deviceExtension->DebugCutoff,
                  "SimBad: (ioctl) returning %lu range%s\n",
                  simBadRanges->RangeCount,
                  simBadRanges->RangeCount == 1 ? "" : "s" ) );               
               
               for ( i = 0; i < simBadRanges->RangeCount && i < MAXIMUM_SIMBAD_RANGES; i++ )
               {
                  DebugPrint( ( 2, deviceExtension->DebugCutoff,
                     "SimBad: (ioctl) begin %I64x end %I64x status %x access %x\n",
                     simBadRanges->Range[ i ].BlockBegin,
                     simBadRanges->Range[ i ].BlockEnd,
                     simBadRanges->Range[ i ].Status,
                     simBadRanges->Range[ i ].AccessType ) );
   
                  simBadDataOut->Range[ i ] = simBadRanges->Range[ i ];
               }
   
               simBadDataOut->RangeCount = simBadRanges->RangeCount;               
            }
            else
            {
               simBadDataOut->RangeCount = 0;
            }
   
            simBadDataOut->SectorCount = 0;
   
            status = STATUS_SUCCESS;
         }
         except( EXCEPTION_EXECUTE_HANDLER )
         {
            status = GetExceptionCode();
         }
         
         KeReleaseSpinLock(
            &deviceExtension->SpinLock,
            currentIrql );
         
         break;

      case SIMBAD_RANDOM_WRITE_FAIL:

         //
         // Fails write randomly
         //

         DebugPrint( ( 2, deviceExtension->DebugCutoff,
            "SimBad: (ioctl) fail random writes\n" ) );

         if ( !simBadSectors )
         {
            SimBadAllocMemory(
               &deviceExtension->SimBadSectors,
               &deviceExtension->SimBadRanges,
#if DBG
               deviceExtension->DebugCutoff );
#else
               0 );
#endif

            simBadSectors = deviceExtension->SimBadSectors;
            simBadRanges = deviceExtension->SimBadRanges;
         }

         if ( simBadRanges )
         {
            KeAcquireSpinLock(
               &deviceExtension->SpinLock,
               &currentIrql );
            
            simBadRanges->Flags |= SIMBAD_RANDOM_WRITE_FAIL;           
            simBadRanges->Seed = simBadDataIn->SectorCount;
            simBadRanges->Modulus = simBadDataIn->RangeCount;

            if ( simBadRanges->Seed == 0 )
               simBadRanges->Seed = SIMBAD_DEFAULT_SEED;

            if ( simBadRanges->Modulus < 2 )
               simBadRanges->Modulus = SIMBAD_DEFAULT_MODULUS;
            
            KeReleaseSpinLock(
               &deviceExtension->SpinLock,
               currentIrql );

            DebugPrint( ( 2, deviceExtension->DebugCutoff,
               "SimBad: (ioctl) seed %lu modulus %lu\n",
               simBadRanges->Seed,
               simBadRanges->Modulus ) );

            status = STATUS_SUCCESS;
         }
         else
         {
            status = STATUS_NO_MEMORY;
         }

         break;

      case SIMBAD_ENABLE:

         //
         // Enable SIMBAD checking in driver.
         //

         DebugPrint( ( 2, deviceExtension->DebugCutoff,
            "SimBad: (ioctl) enable\n" ) );

         KeAcquireSpinLock(
            &deviceExtension->SpinLock,
            &currentIrql );
         
         if ( simBadSectors )
            simBadSectors->Flags |= SIMBAD_ENABLE;

         if ( simBadRanges )
            simBadRanges->Flags |= SIMBAD_ENABLE;

         KeReleaseSpinLock(
            &deviceExtension->SpinLock,
            currentIrql );

         status = STATUS_SUCCESS;

         break;

      case SIMBAD_DISABLE:

         //
         // Disable SIMBAD checking in driver.
         //

         DebugPrint( ( 2, deviceExtension->DebugCutoff,
            "SimBad: (ioctl) disable\n" ) );
         
         KeAcquireSpinLock(
            &deviceExtension->SpinLock,
            &currentIrql );

         if ( simBadSectors )
            simBadSectors->Flags &= ~SIMBAD_ENABLE;

         if ( simBadRanges )
            simBadRanges->Flags &= ~SIMBAD_ENABLE;
         
         KeReleaseSpinLock(
            &deviceExtension->SpinLock,
            currentIrql );

         status = STATUS_SUCCESS;

         break;

      case SIMBAD_CLEAR:

         //
         // Clear bad sector or range list.
         // Also clear the orphaned state.
         //

         DebugPrint( ( 2, deviceExtension->DebugCutoff,
            "SimBad: (ioctl) clear\n" ) );

#if DBG
         DebugPrint( ( 2, deviceExtension->DebugCutoff,
            "SimBad: (ioctl) min %I64x, max %I64x\n",
            deviceExtension->SectorMin,
            deviceExtension->SectorMax ) );

         deviceExtension->SectorMin = 0xFFFFFFFFFFFFFFFFL;
         deviceExtension->SectorMax = 0L;
#endif

         KeAcquireSpinLock(
            &deviceExtension->SpinLock,
            &currentIrql );
         
         if ( simBadSectors )
         {
            simBadSectors->SectorCount = 0;
            simBadSectors->Flags = 0;
         }

         if ( simBadRanges )
         {
            simBadRanges->RangeCount = 0;
            simBadRanges->Flags = 0;
         }
         
         KeReleaseSpinLock(
            &deviceExtension->SpinLock,
            currentIrql );

         status = STATUS_SUCCESS;

         break;

      case SIMBAD_ORPHAN:

         //
         // Orphan device. All accesses to this device will fail.
         //

         DebugPrint( ( 2, deviceExtension->DebugCutoff,
            "SimBad: (ioctl) orphan\n" ) );
         
         KeAcquireSpinLock(
            &deviceExtension->SpinLock,
            &currentIrql );

         if ( simBadRanges )
            simBadRanges->Flags |= SIMBAD_ORPHAN;
         
         KeReleaseSpinLock(
            &deviceExtension->SpinLock,
            currentIrql );

         status = STATUS_SUCCESS;

         break;

      case SIMBAD_BUG_CHECK:

         //
         // Bug check the system
         //

         DebugPrint( ( 2, deviceExtension->DebugCutoff,
            "SimBad: (ioctl) bugcheck\n" ) );

         status = STATUS_SUCCESS;

         KeBugCheckEx( 0xFF, 0xFF, 0xFF, 0xFF, 0xFF );

         break;

      case SIMBAD_FIRMWARE_RESET:

         //
         // Reset the system.
         //

         DebugPrint( ( 2, deviceExtension->DebugCutoff,
            "SimBad: (ioctl) firmware reset\n" ) );

         status = STATUS_SUCCESS;

         HalReturnToFirmware( HalRebootRoutine );

         break;

      case SIMBAD_GET_VERSION:

         //
         // Return internal version number
         //

         DebugPrint( ( 0, 0,
            "SimBad: (ioctl) get version (%s)\n", SIMBAD_VERSION_A ) );

         //
         // size in bytes, includes space for trailing null
         //

         {
            ULONG versionSize = ( strlen( SIMBAD_VERSION_A ) + 1 ) * sizeof( wchar_t );

            try
            {
               RtlZeroMemory(
                  ( VOID * ) simBadDataOut,
                  versionSize );
      
               RtlCopyMemory( 
                  ( VOID * ) simBadDataOut,
                  ( VOID * ) SIMBAD_VERSION_W, 
                  versionSize - sizeof( UNICODE_NULL ) );
               
               status = STATUS_SUCCESS;
            }
            except( EXCEPTION_EXECUTE_HANDLER )
            {
               status = GetExceptionCode();
            }         
         }

         break;

      case SIMBAD_DEBUG_LEVEL:

         //
         // Change the debug level on the fly
         //

         if ( currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof( SIMBAD_DATA ) ) 
         {
            status = STATUS_INFO_LENGTH_MISMATCH;
            break;
         }

#if DBG
         DebugPrint( ( 0, 0,
            "SimBad: (ioctl) debug level %d\n", simBadDataIn->SectorCount ) );

         deviceExtension->DebugCutoff = simBadDataIn->SectorCount;
#endif

         status = STATUS_SUCCESS;

         break;

      default:

         DebugPrint( ( 0, 0,
            "SimBad: (ioctl) unknown simbad function %x\n",
            simBadDataIn->Function ) );

         status = STATUS_INVALID_DEVICE_REQUEST;

         break;

      } // switch (simBadDataIn->Function ...)

      break;

   case IOCTL_DISK_REASSIGN_BLOCKS:
      {
         PREASSIGN_BLOCKS blockList = Irp->AssociatedIrp.SystemBuffer;
         BOOLEAN missedOne;
         BOOLEAN sectorFound;
         KIRQL currentIrql;

         //
         // set this in case we don't touch the IRP at all
         // pass it along with the status is came in as
         //

         status = Irp->IoStatus.Status;

         //
         // The layer above is attempting a sector map.  Check to see
         // if the sectors being fixed are owned by SimBad and if SimBad
         // will allow them to be fixed.
         //

         //
         // Check sector list
         //

         if ( simBadSectors && simBadSectors->SectorCount != 0 )
         {
            //
            // Acquire spinlock.
            //

            KeAcquireSpinLock(
               &deviceExtension->SpinLock,
               &currentIrql );

            sectorFound = FALSE;
            missedOne = FALSE;

            for ( i = 0; i < ( ULONG ) blockList->Count; i++ )
            {
               for ( j = 0; j < simBadSectors->SectorCount; j++ )
               {
                  if ( simBadSectors->Sector[ j ].BlockAddress ==
                     ( ULONGLONG ) blockList->BlockNumber[ i ] )
                  {
                     ULONG k;

                     //
                     // It is a SimBad sector. Check if do not remove flag is set.
                     //

                     if ( simBadSectors->Sector[ j ].AccessType & SIMBAD_ACCESS_FAIL_REASSIGN_SECTOR )
                     {
                        break;
                     }

                     sectorFound = TRUE;

                     //
                     // Remove sectors from driver's array.
                     //

                     for ( k = j + 1; k < simBadSectors->SectorCount; k++ )
                     {
                        //
                        // Shuffle array down to fill hole.
                        //

                        simBadSectors->Sector[ k - 1 ]=simBadSectors->Sector[ k ];
                     }

                     //
                     // Update driver's bad sector count.
                     //

                     simBadSectors->SectorCount--;

                     //
                     // If the accesstype bit is set to indicate that the
                     // physical device drivers should actually map out the
                     // bad sectors, then drop down to the copy stack code.
                     // Note that an assumption is made that there are no
                     // more bad sectors in the list and the bad sector is
                     // gone from SimBad's list (regardless of whether the
                     // lower drivers successfully map out the bad sector).
                     //

                     if ( simBadSectors->Sector[ j ].AccessType & SIMBAD_ACCESS_CAN_REASSIGN_SECTOR )
                     {
                        DebugPrint( ( 2, deviceExtension->DebugCutoff,
                           "SimBad: (ioctl) let physical disk map sector %I64x\n",
                           blockList->BlockNumber[ i ] ) );

                        missedOne = TRUE;
                     }

                     break;
                  } // if (matching sector)
               } // for (j...)

               if ( sectorFound )
               {
                  DebugPrint( ( 2, deviceExtension->DebugCutoff,
                     "SimBad: (ioctl) removing bad sector %I64x\n",
                     blockList->BlockNumber[ i ] ) );

                  status = STATUS_SUCCESS;
               }
               else
               {
                  DebugPrint( ( 2, deviceExtension->DebugCutoff,
                     "SimBad: (ioctl) sector %I64x not found\n",
                     blockList->BlockNumber[ i ] ) );

                  status = STATUS_UNSUCCESSFUL;
               }
            } // for (i...)

            KeReleaseSpinLock(
               &deviceExtension->SpinLock,
               currentIrql );

            //
            // Assume only one sector gets mapped per request.
            // To date this is a safe assumption.
            //

            if ( missedOne )
            {
               //
               // Go to copy down stack.
               //

               goto CopyDown;
            }
         } // if ( simBadSectors && simBadSectors->SectorCount != 0 )

         //
         // Check range list
         //

         if ( simBadRanges && simBadRanges->RangeCount != 0 )
         {
            //
            // Acquire spinlock.
            //

            KeAcquireSpinLock(
               &deviceExtension->SpinLock,
               &currentIrql );

            sectorFound = FALSE;
            missedOne = FALSE;

            for ( i = 0; i < ( ULONG ) blockList->Count; i++ )
            {
               for ( j = 0; j < simBadRanges->RangeCount; j++ )
               {
                  if ( simBadRanges->Range[ j ].BlockBegin <= ( ULONGLONG ) blockList->BlockNumber[ i ] &&
                     simBadRanges->Range[ j ].BlockEnd >= ( ULONGLONG ) blockList->BlockNumber[ i ] )
                  {
                     ULONG k;

                     //
                     // The sector is within a simbad range. Check if do not remove
                     // flag is set.
                     //

                     if ( simBadRanges->Range[ j ].AccessType & SIMBAD_ACCESS_FAIL_REASSIGN_SECTOR )
                     {
                        break;
                     }

                     sectorFound = TRUE;

                     //
                     // NOTE:
                     // what should really happen here is the bad sector should
                     // be removed, and the previous range split into two
                     //

                     if ( simBadRanges->Range[ j ].AccessType & SIMBAD_ACCESS_CAN_REASSIGN_SECTOR )
                     {
                        DebugPrint( ( 2, deviceExtension->DebugCutoff,
                           "SimBad: (ioctl) let physical disk map sector %I64x\n",
                           blockList->BlockNumber[ i ] ) );

                        missedOne = TRUE;
                     }

                     break;
                  } // if (matching range)
               } // for (j...)

               if ( sectorFound )
               {
                  DebugPrint( ( 2, deviceExtension->DebugCutoff,
                     "SimBad: (ioctl) range, removing bad sector %I64x\n",
                     blockList->BlockNumber[ i ] ) );

                  status = STATUS_SUCCESS;
               }
               else
               {
                  DebugPrint( ( 2, deviceExtension->DebugCutoff,
                     "SimBad: (ioctl) range, sector %I64x not found\n",
                     blockList->BlockNumber[ i ] ) );

                  status = STATUS_UNSUCCESSFUL;
               }
            } // for (i...)

            KeReleaseSpinLock(
               &deviceExtension->SpinLock,
               currentIrql );

            //
            // Assume only one sector gets mapped per request.
            // To date this is a safe assumption.
            //

            if ( missedOne )
            {
               //
               // Go to copy down stack.
               //

               goto CopyDown;
            }
         } // ( simBadRanges && simBadRanges->RangeCount != 0 )

         break;
      }

   case IOCTL_DISK_VERIFY:

      //
      // Call ReadWrite routine. It does the right things.
      //

      return SimBadReadWrite(
         DeviceObject,
         Irp );

      //
      // fail the following general storage ioctl's if appropriate
      //

   case IOCTL_DISK_GET_DRIVE_GEOMETRY:
   case IOCTL_DISK_GET_PARTITION_INFO:
   case IOCTL_DISK_SET_PARTITION_INFO:
   case IOCTL_DISK_GET_DRIVE_LAYOUT:
   case IOCTL_DISK_SET_DRIVE_LAYOUT:

      if ( simBadRanges && 
           ( simBadRanges->Flags & SIMBAD_ENABLE ) && 
           ( simBadRanges->Flags & SIMBAD_ORPHAN ) &&
           ( simBadRanges->Range[ 0 ].AccessType & SIMBAD_ACCESS_FAIL_IOCTL ) )
      {
         DebugPrint( ( 2, deviceExtension->DebugCutoff,
            "SimBad: (ioctl) failing (%x/%x)\n", 
            ( currentIrpStack->Parameters.DeviceIoControl.IoControlCode & 0xFFFF ) >> 16,
            ( currentIrpStack->Parameters.DeviceIoControl.IoControlCode & 0x3FFC ) >> 2 ) );

         status = simBadRanges->Range[ 0 ].Status;

         break;
      }

   default:
      
      DebugPrint( ( 3, deviceExtension->DebugCutoff,
         "SimBad: (ioctl) passing (%x/%x)\n", 
         ( currentIrpStack->Parameters.DeviceIoControl.IoControlCode & 0xFFFF ) >> 16,
         ( currentIrpStack->Parameters.DeviceIoControl.IoControlCode & 0x3FFC ) >> 2 ) );

   CopyDown:

      //
      // Copy stack parameters to next stack.
      //

      *nextIrpStack = *currentIrpStack;

      //
      // Set IRP so IoComplete does not call completion routine
      // for this driver.
      //

      IoSetCompletionRoutine(
         Irp,
         NULL,
         deviceExtension,
         FALSE,
         FALSE,
         FALSE );

      //
      // Pass unrecognized device control requests
      // down to next driver layer.
      //

      return IoCallDriver(
         deviceExtension->TargetDeviceObject,
         Irp );
   } // switch

   Irp->IoStatus.Status = status;

   IoCompleteRequest(
      Irp,
      IO_NO_INCREMENT );

   return status;

} // end SimBadDeviceControl()


NTSTATUS SimBadDeviceUsage(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
{
   PIO_STACK_LOCATION irpStack;
   NTSTATUS status;

   PAGED_CODE();

   irpStack = IoGetCurrentIrpStackLocation(Irp);

   if ( irpStack->Parameters.UsageNotification.Type != DeviceUsageTypePaging ) 
   {
       status = SimBadSendToNextDriver( DeviceObject, Irp );
   }
   else
   {
      PSIMBAD_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
      ULONG count;
      BOOLEAN setPagable;

      //
      // wait on the paging path event
      //

      status = KeWaitForSingleObject(
         &deviceExtension->PagingPathCountEvent,
         Executive, 
         KernelMode,
         FALSE, 
         NULL );
   
      //
      // if removing last paging device, need to set DO_POWER_PAGABLE
      // bit here, and possible re-set it below on failure.
      //

      setPagable = FALSE;

      if ( !irpStack->Parameters.UsageNotification.InPath &&
           deviceExtension->PagingPathCount == 1 ) 
      {
         //
         // removing the last paging file
         // must have DO_POWER_PAGABLE bits set
         //
         
         if ( DeviceObject->Flags & DO_POWER_INRUSH ) 
         {
            DebugPrint( ( 2, deviceExtension->DebugCutoff,
               "SimBadDeviceUsage: DO_POWER_INRUSH set, not setting PAGABLE\n" ) );
         } 
         else
         {
            DebugPrint( ( 2, deviceExtension->DebugCutoff,
               "SimBadDeviceUsage: setting PAGABLE\n" ) );

            DeviceObject->Flags |= DO_POWER_PAGABLE;
            setPagable = TRUE;
         }
      }
  
      status = SimBadSendToNextDriverSynchronous( DeviceObject, Irp );
   
      //
      // now deal with the failure and success cases.
      //

      if ( NT_SUCCESS( status ) )
      {
          IoAdjustPagingPathCount(
              &deviceExtension->PagingPathCount,
              irpStack->Parameters.UsageNotification.InPath );

          if ( irpStack->Parameters.UsageNotification.InPath ) 
          {
              if ( deviceExtension->PagingPathCount == 1 ) 
              {
                  DebugPrint( ( 2, deviceExtension->DebugCutoff,
                     "SimBadDeviceUsage: Clearing PAGABLE\n" ) );

                  DeviceObject->Flags &= ~DO_POWER_PAGABLE;
              }
          }
      }
      else
      {
          //
          // cleanup the changes done above
          //

          if ( setPagable == TRUE ) 
          {
              DeviceObject->Flags &= ~DO_POWER_PAGABLE;
              setPagable = FALSE;
          }
      }

      //
      // set the event so the next one can occur.
      //

      KeSetEvent(
         &deviceExtension->PagingPathCountEvent,
         IO_NO_INCREMENT, 
         FALSE );

      IoCompleteRequest( Irp, IO_NO_INCREMENT );   
   }

   return status;

} // end SimBadDeviceUsage()


NTSTATUS SimBadRemoveDevice(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
{
   NTSTATUS                  status;
   PSIMBAD_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
   KEVENT                    event;

   PAGED_CODE();

   DebugPrint( ( 2, deviceExtension->DebugCutoff,
      "SimBad: (pnp remove) device %x\n", 
      DeviceObject ) );

   status = SimBadSendToNextDriverSynchronous( DeviceObject, Irp );

   IoDetachDevice( deviceExtension->TargetDeviceObject );
   IoDeleteDevice( DeviceObject );

   Irp->IoStatus.Status = status;
   IoCompleteRequest( Irp, IO_NO_INCREMENT );

   return status;

} // end SimBadRemoveDevice()


NTSTATUS SimBadStartDevice(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
{
   NTSTATUS                 status;
   PSIMBAD_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   KEVENT                   event;
   ULONG                    flags = FILE_REMOVABLE_MEDIA | 
                                    FILE_READ_ONLY_DEVICE | 
                                    FILE_FLOPPY_DISKETTE;

   PAGED_CODE();
   
   DebugPrint( ( 2, deviceExtension->DebugCutoff,
      "SimBad: (pnp start) device %x\n", 
      DeviceObject ) );
   
   status = SimBadSendToNextDriverSynchronous( DeviceObject, Irp );

   DeviceObject->Characteristics |= 
      ( deviceExtension->TargetDeviceObject->Characteristics & flags );

   SimBadInit( DeviceObject );

   Irp->IoStatus.Status = status;

   IoCompleteRequest( Irp, IO_NO_INCREMENT );

   return status;

} // end SimBadStartDevice()


void SimBadSaveInfo(
   PSIMBAD_SECTORS BadSectors,
   PSIMBAD_RANGES BadRanges
   )
{
} // end SimBadSaveInfo()


void SimBadAllocMemory(
   SIMBAD_SECTORS ** pSectors,
   SIMBAD_RANGES ** pRanges,
   ULONG DebugHurdle
   )
/*++

Routine Description:

    This routine allocates the sector array and range array for each disk, as
    requested while handling a device control request.

Arguments:

    pSectors - pointer to the bad sector array.
    pRanges - pointer to the bad range array.

Return Value:

    None

--*/
{
   DebugPrint( ( 2, DebugHurdle, 
      "SimBad: allocating memory - " ) );

   *pSectors = ExAllocatePool(
      NonPagedPool,
      sizeof( SIMBAD_SECTORS ) + sizeof( SIMBAD_RANGES ) );

   if ( *pSectors )
   {
      RtlZeroMemory(
         *pSectors,
         sizeof( SIMBAD_SECTORS ) + sizeof( SIMBAD_RANGES ) );

      *pRanges =
         ( PSIMBAD_RANGES ) ( ( ( UCHAR * ) *pSectors ) + sizeof( SIMBAD_SECTORS ) );
   }
   else
   {
      *pRanges = NULL;
   }

   DebugPrint( ( 2, DebugHurdle,
      "%s\n",
      *pSectors ? "success" : "failure" ) );

} // end SimBadAllocMemory()


NTSTATUS SimBadCreate(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
{
   PSIMBAD_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

   DebugPrint( ( 3, deviceExtension->DebugCutoff, "SimBad: (create)\n" ) );

   Irp->IoStatus.Status = STATUS_SUCCESS;

   IoCompleteRequest( Irp, IO_NO_INCREMENT );

   return STATUS_SUCCESS;

} // end SimBadCreate()

NTSTATUS SimBadPnP(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
{
   PIO_STACK_LOCATION         irpSp = IoGetCurrentIrpStackLocation( Irp );
   NTSTATUS                   status;
   PSIMBAD_DEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
   
   PAGED_CODE();

   DebugPrint( ( 3, deviceExtension->DebugCutoff, "SimBad: (pnp)\n" ) );

   switch( irpSp->MinorFunction ) 
   {
   case IRP_MN_START_DEVICE:
       status = SimBadStartDevice( DeviceObject, Irp );
       break;

   case IRP_MN_REMOVE_DEVICE:
       status = SimBadRemoveDevice( DeviceObject, Irp );
       break;

   case IRP_MN_DEVICE_USAGE_NOTIFICATION:
      status = SimBadDeviceUsage( DeviceObject, Irp );
      break;

   default:
       return SimBadSendToNextDriver( DeviceObject, Irp );
   }

   return status;

} // end SimBadPnP()


NTSTATUS SimBadPower(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
{
   PSIMBAD_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

   DebugPrint( ( 3, deviceExtension->DebugCutoff, "SimBad: (power)\n" ) );

   PoStartNextPowerIrp( Irp );

   IoSkipCurrentIrpStackLocation( Irp );

   return PoCallDriver( deviceExtension->TargetDeviceObject, Irp );

} // end SimBadPower()

NTSTATUS SimBadShutdownFlush(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
{
   PSIMBAD_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   
   DebugPrint( ( 3, deviceExtension->DebugCutoff, "SimBad: (shutdown/flush)\n" ) );

   IoSkipCurrentIrpStackLocation( Irp );

   return IoCallDriver( 
      deviceExtension->TargetDeviceObject, 
      Irp );

} // end SimBadShutdownFlush()

void SimBadUnload(
   IN PDRIVER_OBJECT DriverObject )
{
   PAGED_CODE();
   
   DebugPrint( ( 2, 2, "SimBad: (unload)\n" ) );

   return;

} // end SimBadUnload()

NTSTATUS SimBadIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
   PKEVENT Event = ( PKEVENT ) Context;

   UNREFERENCED_PARAMETER( DeviceObject );
   UNREFERENCED_PARAMETER( Irp );

   KeSetEvent( Event, IO_NO_INCREMENT, FALSE );

   return STATUS_MORE_PROCESSING_REQUIRED;

} // end SimBadIrpCompletion()


NTSTATUS SimBadSendToNextDriver(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
{
   PSIMBAD_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

   IoSkipCurrentIrpStackLocation( Irp );

   return IoCallDriver( 
      deviceExtension->TargetDeviceObject, 
      Irp );

} // end SimBadSendToNextDriver()

NTSTATUS
SimBadSendToNextDriverSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PSIMBAD_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    KEVENT event;
    NTSTATUS status;

    KeInitializeEvent(
       &event, 
       NotificationEvent, 
       FALSE);
    
    IoCopyCurrentIrpStackLocationToNext( Irp );

    IoSetCompletionRoutine(
       Irp, 
       SimBadIrpCompletion,
       &event, 
       TRUE, 
       TRUE, 
       TRUE );

    status = IoCallDriver(
       deviceExtension->TargetDeviceObject, 
       Irp );

    if ( status == STATUS_PENDING ) 
    {
        KeWaitForSingleObject(
           &event, 
           Executive, 
           KernelMode, 
           FALSE, 
           NULL );

        status = Irp->IoStatus.Status;
    }

    return status;

} // end SimBadSendToNextDriverSynchronous()


ULONG which_bit(
   ULONG data
   )
{
   ULONG i;

   ASSERT( data != 0 );

   for ( i = 0; i < 32; i++ )
   {
      if ( ( 1 << i ) & data )
         return i;
   }

   return 0xfe;

} // end which_bit()

#if DBG

#define BUFFER_SIZE 256

VOID SimBadDebugPrint(
   ULONG DebugPrintLevel,
   ULONG DebugCutoff,
   PCCHAR DebugMessage,
   ...
   )
{
   va_list ap;

   va_start( ap, DebugMessage );

   if ( DebugPrintLevel <= DebugCutoff )
   {
      CHAR buffer[ BUFFER_SIZE ];

      _vsnprintf( buffer, BUFFER_SIZE, DebugMessage, ap );

      DbgPrint( buffer );
   }

   va_end( ap );

} // end SimBadDebugPrint

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\class\filters\simbad\simbad.h ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    simbad.h

Abstract:

    The SIMulated BAD sector utility allows a user to specify
    bad physical sectors through the device control interface.
    The device driver keeps an array of SIMBAD sectors and when
    a request for a transfer includes one of these sectors the
    driver returns the corresponding status and fails the transfer.

Author:

    Mike Glass (mglass) 2-Feb-1992
    Bob Rinne  (bobri)

Revision History:

    09-Apr-92 - bobri    added specific control over errors (read,map,etc).
    12-May-94 - venkat   added code to drop of writes to DISK (CHKDSK testing)
    19-Nov-94 - kpeery   added code to reset the system (restart testing)
    29-Dec-97 - kbarrus  added code: ranges (fail regions on dynamic disks)
    01-May-98 - kbarrus  added partitionOffset field in SIMBAD_DATA, changed max
                         sectors and max ranges
    27-Oct-98 - kbarrus  added modulus, change debug print level
    06-Oct-99 - kbarrus  added ioctl fail flag
--*/

#if _MSC_VER > 1000
#pragma once
#endif

//
// driver name
//

#define SIMBAD_SERVICE_NAME L"Simbad"

//
// These values are selected so that
// sizeof( SIMBAD_SECTORS ) + sizeof( SIMBAD_RANGES ) <= 4096 bytes
//

#define MAXIMUM_SIMBAD_SECTORS 248
#define MAXIMUM_SIMBAD_RANGES  4

//
// psuedo random number generator parameters
//

// default seed should be non-zero
#define SIMBAD_DEFAULT_SEED 5


// default modulus should be > 1
#define SIMBAD_DEFAULT_MODULUS 100

//
// This structure is used by the driver and application to
// specify which sector is BAD and what status the driver
// should return.
//

typedef struct _BAD_SECTOR
{
   ULONGLONG BlockAddress;
   ULONG AccessType;
   NTSTATUS Status;
} BAD_SECTOR, *PBAD_SECTOR;

//
// This structure is used by the driver and application to
// specify a range of sectors that have been marked BAD and
// what status the driver should return.
//

typedef struct _BAD_RANGE
{
   ULONGLONG BlockBegin;
   ULONGLONG BlockEnd;
   ULONG AccessType;
   NTSTATUS Status;
} BAD_RANGE, *PBAD_RANGE;

//
// This structure is maintained by the device driver. It keeps a
// count of how many sectors have been marked BAD and an array of
// the BAD sectors.
//

typedef struct _SIMBAD_SECTORS
{
   ULONG Flags;
   ULONG SectorCount;
   BAD_SECTOR Sector[MAXIMUM_SIMBAD_SECTORS];
} SIMBAD_SECTORS, *PSIMBAD_SECTORS;

//
// This structure is maintained by the device driver. It keeps a
// count of how many ranges have been marked BAD and an array of
// the BAD ranges.
//

typedef struct _SIMBAD_RANGES
{
   ULONG Flags;
    LONG Seed;
   ULONG Modulus;
   ULONG RangeCount;
   BAD_RANGE Range[MAXIMUM_SIMBAD_RANGES];
} SIMBAD_RANGES, *PSIMBAD_RANGES;

//
// This structure is passed from the application to the device
// driver through the device control interface to add and remove
// bad sectors or ranges.
//
// If the function is add or remove sectors or ranges then the Count
// field specifies how many sectors or ranges to add or remove.
//
// If the function is list then the array returns all sectors or
// ranges marked bad.
//
// This facility does not allow mixed adds and removes in a
// single device control call.
//
// NOTE: if a request specifies a number of adds that will exceed
// the array limit (MAXIMUM_SIMBAD_SECTORS or MAXIMUM_SIMBAD_RANGES),
// then sectors or ranges will be added to fill the array and the
// count field will be adjusted to the number of sectors or ranges
// successfully added.
//

typedef struct _SIMBAD_DATA
{
   ULONG Function;
   ULONG SectorCount;
   ULONG RangeCount;
   ULONGLONG Offset;
   BAD_SECTOR Sector[MAXIMUM_SIMBAD_SECTORS];
   BAD_RANGE  Range[MAXIMUM_SIMBAD_RANGES];
} SIMBAD_DATA, *PSIMBAD_DATA;

//
// Simulated Bad Sector Functions
//

//
// When the disable or enable function is specified,
// the rest of the structure is ignored.
// The SimBad function is disabled on driver startup.
// The disable/enable status affects whether completing
// transfers are checks against the bad sector array.
// While the function is disabled, requests to manipulate
// the driver's bad sector array are still allowed
// (ie add sector, remove sector, list bad sectors).
//

#define SIMBAD_DISABLE            0x00000000
#define SIMBAD_ENABLE             0x00000001

//
// These functions are used to set and clear bad sectors or ranges.
//

#define SIMBAD_ADD_SECTORS        0x00000002
#define SIMBAD_REMOVE_SECTORS     0x00000004
#define SIMBAD_LIST_BAD_SECTORS   0x00000008
#define SIMBAD_ADD_RANGES         0x00000010
#define SIMBAD_REMOVE_RANGES      0x00000020
#define SIMBAD_LIST_BAD_RANGES    0x00000040

//
// This function cause all accesses to a driver
// to return failure.
//

#define SIMBAD_ORPHAN             0x00000080

//
// This function clears the internal bad sector list in the driver.
// It also clears the orphan state.
//

#define SIMBAD_CLEAR              0x00000100

//
// Randomly drops of writes to the disk. Used for corrupting the DISK.
// These corrupt disk are used to test CHKDSK.
//

#define SIMBAD_RANDOM_WRITE_FAIL  0x00000200

//
// Bug checks the system.  Used for crash dump
//

#define SIMBAD_BUG_CHECK          0x00000400

//
// Call HalReturnToFirmware() to reset the system.
// Used for restart testing.
//

#define SIMBAD_FIRMWARE_RESET     0x00000800

//
// Return internal version number
//

#define SIMBAD_GET_VERSION        0x00001000

//
// Change debug level (how much prints to the debugger)
//

#define SIMBAD_DEBUG_LEVEL        0x00002000

//
// Simulated Bad Sector Access Codes
//

//
// These are the access codes that will drive when simbad
// returns failures on disks.
//

#define SIMBAD_ACCESS_READ                  0x00000001
#define SIMBAD_ACCESS_WRITE                 0x00000002
#define SIMBAD_ACCESS_VERIFY                0x00000004

//
// Error sector can be mapped via device control.
//

#define SIMBAD_ACCESS_CAN_REASSIGN_SECTOR   0x00000008

//
// When returning an error indicate Irp offset of zero
// (simulates drivers that cannot tell where the error occured within
// an I/O)
//

#define SIMBAD_ACCESS_ERROR_ZERO_OFFSET     0x00000010

//
// Fail calls to reassign bad sector IOCTL.
//

#define SIMBAD_ACCESS_FAIL_REASSIGN_SECTOR  0x00000020

//
// Fail general storage IOCTLs
//

#define SIMBAD_ACCESS_FAIL_IOCTL            0x00000040
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\class\filters\storagefilter\filter_trace.h ===
/*

    WPP_DEFINE_CONTROL_GUID specifies the GUID used for this filter.
    *** REPLACE THE GUID WITH YOUR OWN UNIQUE ID ***
    WPP_DEFINE_BIT allows setting debug bit masks to selectively print.
    
    everything else can revert to the default?

*/

#define WPP_CONTROL_GUIDS \
        WPP_DEFINE_CONTROL_GUID(CtlGuid,(cf31cc96,392f,4823,b356,5aa8eb232cf5),  \
        WPP_DEFINE_BIT(FilterDebugError)         /* 0x00000001 */ \
        WPP_DEFINE_BIT(FilterDebugWarning)       /* 0x00000002 */ \
        WPP_DEFINE_BIT(FilterDebugD03)           /* 0x00000004 */ \
        WPP_DEFINE_BIT(FilterDebugD04)           /* 0x00000008 */ \
        WPP_DEFINE_BIT(FilterDebugFunction)      /* 0x00000010 function entry points */ \
        WPP_DEFINE_BIT(FilterDebugFunction2)     /* 0x00000020 noisy */ \
        WPP_DEFINE_BIT(FilterDebugRemove)        /* 0x00000040 */ \
        WPP_DEFINE_BIT(FilterDebugPnp)           /* 0x00000080 */ \
        WPP_DEFINE_BIT(FilterDebugD09)           /* 0x00000100 */ \
        WPP_DEFINE_BIT(FilterDebugD10)           /* 0x00000200 */ \
        WPP_DEFINE_BIT(FilterDebugD11)           /* 0x00000400 */ \
        WPP_DEFINE_BIT(FilterDebugD12)           /* 0x00000800 */ \
        WPP_DEFINE_BIT(FilterDebugD13)           /* 0x00001000 */ \
        WPP_DEFINE_BIT(FilterDebugD14)           /* 0x00002000 */ \
        WPP_DEFINE_BIT(FilterDebugD15)           /* 0x00004000 */ \
        WPP_DEFINE_BIT(FilterDebugD16)           /* 0x00008000 */ \
        WPP_DEFINE_BIT(FilterDebugD17)           /* 0x00010000 */ \
        WPP_DEFINE_BIT(FilterDebugD18)           /* 0x00020000 */ \
        WPP_DEFINE_BIT(FilterDebugD19)           /* 0x00040000 */ \
        WPP_DEFINE_BIT(FilterDebugD20)           /* 0x00080000 */ \
        WPP_DEFINE_BIT(FilterDebugD21)           /* 0x00100000 */ \
        WPP_DEFINE_BIT(FilterDebugD22)           /* 0x00200000 */ \
        WPP_DEFINE_BIT(FilterDebugD23)           /* 0x00400000 */ \
        WPP_DEFINE_BIT(FilterDebugD24)           /* 0x00800000 */ \
        WPP_DEFINE_BIT(FilterDebugScsiAllow)     /* 0x01000000 */ \
        WPP_DEFINE_BIT(FilterDebugScsiReject)    /* 0x02000000 */ \
        WPP_DEFINE_BIT(FilterDebugPtAllow)       /* 0x04000000 */ \
        WPP_DEFINE_BIT(FilterDebugPtReject)      /* 0x08000000 */ \
        WPP_DEFINE_BIT(FilterDebugBusTrace)      /* 0x01000000 */ \
        WPP_DEFINE_BIT(FilterDebugD30)           /* 0x02000000 */ \
        WPP_DEFINE_BIT(FilterDebugD31)           /* 0x04000000 */ \
        WPP_DEFINE_BIT(FilterDebugD32)           /* 0x08000000 */ \
        )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\class\filters\storagefilter\data.c ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    data.c

Abstract:

    data of allowed commands

Environment:

    kernel mode only

Notes:

Revision History:

--*/
#include "filter.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

/*
--------------------------------------------------------------------------------
Windows 2000 CLASSPNP.SYS (common)
================================================================================

SCSIOP_TEST_UNIT_READY          0x00
SCSIOP_RESERVE_UNIT             0x16
SCSIOP_RELEASE_UNIT             0x17
SCSIOP_MODE_SENSE               0x1A
SCSIOP_START_STOP_UNIT          0x1B
SCSIOP_MEDIUM_REMOVAL           0x1E
SCSIOP_READ_CAPACITY            0x25
SCSIOP_READ                     0x28
SCSIOP_WRITE                    0x2A
--------------------------------------------------------------------------------
*/
BOOLEAN const AllowedCommandsW2kClasspnp[0x100] = {
    1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x00 - 0x0f
    0,0,0,0, 0,0,1,1, 0,0,1,1, 0,0,1,0,   // 0x10 - 0x1f
    0,0,0,0, 0,1,0,0, 1,0,1,0, 0,0,0,0,   // 0x20 - 0x2f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x30 - 0x3f
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x40 - 0x4f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x50 - 0x5f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x60 - 0x6f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x70 - 0x7f
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x80 - 0x8f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x90 - 0x9f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xa0 - 0xaf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xb0 - 0xbf
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xc0 - 0xcf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xd0 - 0xdf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xe0 - 0xef
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0    // 0xf0 - 0xff
};

/*
--------------------------------------------------------------------------------
Windows 2000 CDROM.SYS (Device Type 5)
================================================================================

SCSIOP_TEST_UNIT_READY          0x00
SCSIOP_MODE_SELECT              0x15
SCSIOP_RESERVE_UNIT             0x16
SCSIOP_RELEASE_UNIT             0x17
SCSIOP_MODE_SENSE               0x1A
SCSIOP_START_STOP_UNIT          0x1B
SCSIOP_MEDIUM_REMOVAL           0x1E
SCSIOP_READ_CAPACITY            0x25
SCSIOP_READ                     0x28
SCSIOP_SEEK                     0x2B
SCSIOP_READ_SUB_CHANNEL         0x42
SCSIOP_READ_TOC                 0x43
SCSIOP_PLAY_AUDIO_MSF           0x47
SCSIOP_PAUSE_RESUME             0x4B
SCSIOP_MODE_SELECT10            0x55
SCSIOP_MODE_SENSE10             0x5A
SCSIOP_SEND_KEY                 0xA3
SCSIOP_REPORT_KEY               0xA4
SCSIOP_SET_READ_AHEAD           0xA7
SCSIOP_READ_DVD_STRUCTURE       0xAD
SCSIOP_READ_CD                  0xBE
--------------------------------------------------------------------------------
*/

BOOLEAN const AllowedCommandsW2kCdrom[0x100] = {
    1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x00 - 0x0f
    0,0,0,0, 0,1,1,1, 0,0,1,1, 0,0,1,0,   // 0x10 - 0x1f
    0,0,0,0, 0,1,0,0, 1,0,0,1, 0,0,0,0,   // 0x20 - 0x2f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x30 - 0x3f
    
    0,0,1,1, 0,0,0,1, 0,0,0,1, 0,0,0,0,   // 0x40 - 0x4f
    0,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,0,   // 0x50 - 0x5f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x60 - 0x6f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x70 - 0x7f
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x80 - 0x8f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x90 - 0x9f
    0,0,0,1, 1,0,0,1, 0,0,0,0, 0,1,0,0,   // 0xa0 - 0xaf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,1,0,   // 0xb0 - 0xbf
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xc0 - 0xcf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xd0 - 0xdf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xe0 - 0xef
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0    // 0xf0 - 0xff
};

/*
--------------------------------------------------------------------------------
Windows 2000 DISK.SYS (Device Type 0)
================================================================================

SCSIOP_TEST_UNIT_READY          0x00
SCSIOP_REASSIGN_BLOCKS          0x07
SCSIOP_MODE_SELECT              0x15
SCSIOP_RESERVE_UNIT             0x16
SCSIOP_RELEASE_UNIT             0x17
SCSIOP_MODE_SENSE               0x1A
SCSIOP_START_STOP_UNIT          0x1B
SCSIOP_MEDIUM_REMOVAL           0x1E
SCSIOP_READ_CAPACITY            0x25
SCSIOP_READ                     0x28
SCSIOP_WRITE                    0x2A
SCSIOP_VERIFY                   0x2F
SCSIOP_SYNCHRONIZE_CACHE        0x35
--------------------------------------------------------------------------------
*/

BOOLEAN const AllowedCommandsW2kDisk[0x100] = {
    1,0,0,0, 0,0,0,1, 0,0,0,0, 0,0,0,0,   // 0x00 - 0x0f
    0,0,0,0, 0,1,1,1, 0,0,1,1, 0,0,1,0,   // 0x10 - 0x1f
    0,0,0,0, 0,1,0,0, 1,0,1,0, 0,0,0,1,   // 0x20 - 0x2f
    0,0,0,0, 0,1,0,0, 0,0,0,0, 0,0,0,0,   // 0x30 - 0x3f
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x40 - 0x4f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x50 - 0x5f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x60 - 0x6f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x70 - 0x7f
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x80 - 0x8f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x90 - 0x9f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xa0 - 0xaf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xb0 - 0xbf
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xc0 - 0xcf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xd0 - 0xdf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xe0 - 0xef
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0    // 0xf0 - 0xff
};

/*
--------------------------------------------------------------------------------
Windows 2000 SFLOPPY.SYS (SCSI Floppy)
================================================================================

SCSIOP_TEST_UNIT_READY          0x00
SCSIOP_FORMAT_UNIT              0x04
SCSIOP_MODE_SELECT              0x15
SCSIOP_RESERVE_UNIT             0x16
SCSIOP_RELEASE_UNIT             0x17
SCSIOP_MODE_SENSE               0x1A
SCSIOP_START_STOP_UNIT          0x1B
SCSIOP_MEDIUM_REMOVAL           0x1E
SCSIOP_READ_FORMATTED_CAPACITY  0x23
SCSIOP_READ_CAPACITY            0x25
SCSIOP_READ                     0x28
SCSIOP_WRITE                    0x2A
SCSIOP_VERIFY                   0x2F
--------------------------------------------------------------------------------
*/

BOOLEAN const AllowedCommandsW2kSfloppy[0x100] = {
    1,0,0,0, 1,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x00 - 0x0f
    0,0,0,0, 0,1,1,1, 0,0,1,1, 0,0,1,0,   // 0x10 - 0x1f
    0,0,0,1, 0,1,0,0, 1,0,1,0, 0,0,0,1,   // 0x20 - 0x2f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x30 - 0x3f
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x40 - 0x4f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x50 - 0x5f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x60 - 0x6f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x70 - 0x7f
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x80 - 0x8f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x90 - 0x9f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xa0 - 0xaf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xb0 - 0xbf
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xc0 - 0xcf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xd0 - 0xdf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xe0 - 0xef
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0    // 0xf0 - 0xff
};

/*
--------------------------------------------------------------------------------
My current list of allowed commands:
================================================================================

SCSIOP_TEST_UNIT_READY          0x00
SCSIOP_REQUEST_SENSE            0x03
SCSIOP_FORMAT_UNIT              0x04
SCSIOP_INQUIRY                  0x12
SCSIOP_MODE_SELECT              0x15
SCSIOP_MODE_SENSE               0x1A
SCSIOP_START_STOP_UNIT          0x1B
SCSIOP_MEDIUM_REMOVAL           0x1E
SCSIOP_READ_CAPACITY            0x25
SCSIOP_READ                     0x28
SCSIOP_WRITE                    0x2A
SCSIOP_VERIFY                   0x2F
SCSIOP_SYNCHRONIZE_CACHE        0x35
SCSIOP_READ_TOC                 0x43
SCSIOP_MODE_SELECT10            0x55
SCSIOP_MODE_SENSE10             0x5A
SCSIOP_READ_CD                  0xBE
--------------------------------------------------------------------------------
*/
BOOLEAN const AllowedCommands51Cdrom[0x100] = {
    1,0,0,1, 1,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x00 - 0x0f
    0,0,1,0, 0,1,0,0, 0,0,1,1, 0,0,1,0,   // 0x10 - 0x1f
    0,0,0,0, 0,1,0,0, 1,0,1,0, 0,0,0,1,   // 0x20 - 0x2f
    0,0,0,0, 0,1,0,0, 0,0,0,0, 0,0,0,0,   // 0x30 - 0x3f
    
    0,0,0,1, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x40 - 0x4f
    0,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,0,   // 0x50 - 0x5f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x60 - 0x6f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x70 - 0x7f
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x80 - 0x8f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x90 - 0x9f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xa0 - 0xaf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,1,0,   // 0xb0 - 0xbf
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xc0 - 0xcf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xd0 - 0xdf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xe0 - 0xef
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0    // 0xf0 - 0xff
};

/*
--------------------------------------------------------------------------------
Burning commands:
================================================================================
SCSIOP_READ_DISK_INFORMATION    0x51
SCSIOP_READ_TRACK_INFORMATION   0x52
SCSIOP_RESERVE_TRACK_RZONE      0x53
SCSIOP_SEND_OPC_INFORMATION     0x54  // optimum power calibration
SCSIOP_CLOSE_TRACK_SESSION      0x5B
SCSIOP_READ_BUFFER_CAPACITY     0x5C
SCSIOP_SEND_CUE_SHEET           0x5D
SCSIOP_BLANK                    0xA1
SCSIOP_SET_CD_SPEED             0xBB
--------------------------------------------------------------------------------
*/
BOOLEAN const AllowedCommandsAddBurning[0x100] = {
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x00 - 0x0f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x10 - 0x1f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x20 - 0x2f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x30 - 0x3f
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x40 - 0x4f
    0,1,1,1, 1,0,0,0, 0,0,0,1, 1,1,0,0,   // 0x50 - 0x5f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x60 - 0x6f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x70 - 0x7f
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x80 - 0x8f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x90 - 0x9f
    0,1,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xa0 - 0xaf
    0,0,0,0, 0,0,0,0, 0,0,0,1, 0,0,0,0,   // 0xb0 - 0xbf
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xc0 - 0xcf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xd0 - 0xdf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xe0 - 0xef
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0    // 0xf0 - 0xff
};


/*
--------------------------------------------------------------------------------
Extended CD Support:
================================================================================
SCSIOP_GET_CONFIGURATION        0x46
SCSIOP_GET_EVENT_STATUS         0x4A
--------------------------------------------------------------------------------
*/
BOOLEAN const AllowedCommandsAddExtendedCdrom[0x100] = {
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x00 - 0x0f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x10 - 0x1f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x20 - 0x2f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x30 - 0x3f
    
    0,0,0,0, 0,0,1,0, 0,0,1,0, 0,0,0,0,   // 0x40 - 0x4f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x50 - 0x5f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x60 - 0x6f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x70 - 0x7f
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x80 - 0x8f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x90 - 0x9f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xa0 - 0xaf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xb0 - 0xbf
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xc0 - 0xcf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xd0 - 0xdf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xe0 - 0xef
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0    // 0xf0 - 0xff
};

/*
--------------------------------------------------------------------------------
DVD Support:
================================================================================
SCSIOP_SEND_KEY                 0xA3
SCSIOP_REPORT_KEY               0xA4
SCSIOP_SET_READ_AHEAD           0xA7
SCSIOP_READ_DVD_STRUCTURE       0xAD
SCSIOP_SEND_DVD_STRUCTURE       0xBF
--------------------------------------------------------------------------------
*/
BOOLEAN const AllowedCommandsAddDVDSupport[0x100] = {
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x00 - 0x0f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x10 - 0x1f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x20 - 0x2f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x30 - 0x3f
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x40 - 0x4f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x50 - 0x5f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x60 - 0x6f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x70 - 0x7f
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x80 - 0x8f
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0x90 - 0x9f
    0,0,0,1, 1,0,0,1, 0,0,0,0, 0,1,0,0,   // 0xa0 - 0xaf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,1,   // 0xb0 - 0xbf
    
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xc0 - 0xcf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xd0 - 0xdf
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,   // 0xe0 - 0xef
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0    // 0xf0 - 0xff
};



#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\class\filters\storagefilter\filter.c ===
/*++
Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    filter.c

Abstract:

    This driver is a sample that shows how a storage filter driver could
    be written.  This driver is not optimized for performance, but shows
    proper remove-lock usage and sets a completion routine for all read,
    write, and IOCTL irps.

Environment:

    kernel mode only

Notes:

--*/


#include "filter.h"
#include <classpnp.h>  // SRB_CLASS_FLAGS_PAGING

//
// for any file that has software tracing printouts, you must include a
// header file <filename>.tmh
// this file will be generated by the WPP processing phase
//
#include "filter.tmh"


#if DBG
ULONG Noop = 0;
ULONG DebugLevel = 0; // bitmask!
#endif

ULONG FailEveryNCommands = 0x0000;



//
// Define the sections that allow for discarding (i.e. paging) some of
// the code.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, FilterSyncFilterWithTarget)
#pragma alloc_text (PAGE, FilterAddDevice)
#pragma alloc_text (PAGE, FilterDispatchPnp)
#pragma alloc_text (PAGE, FilterStartDevice)
#pragma alloc_text (PAGE, FilterRemoveDevice)
#pragma alloc_text (PAGE, FilterSetAllowedBitMask)
#pragma alloc_text (PAGE, FilterUnload)
#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O manager to set up the disk
    failure prediction filter driver. The driver object is set up and
    then the Pnp manager calls FilterAddDevice to attach to the boot
    devices.

Arguments:

    DriverObject - The disk performance driver object.

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful

--*/

{

    ULONG               ulIndex;
    PDRIVER_DISPATCH  * dispatch;

    //
    // Enable software tracing by registering using the WPP macro.
    // <unfortunately, this may not allow immediate prints such
    //  as the below KdPrintEx.  need to check.>
    //

    WPP_INIT_TRACING(DriverObject, RegistryPath);

    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "DriverEntry %p %p\n",
               DriverObject,
               RegistryPath
               ));

    //
    // Create dispatch points
    //
    for (ulIndex = 0, dispatch = DriverObject->MajorFunction;
         ulIndex <= IRP_MJ_MAXIMUM_FUNCTION;
         ulIndex++, dispatch++) {

        *dispatch = FilterSendToNextDriver;
    }

    //
    // Set up the device driver entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_SCSI]            = FilterScsi;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = FilterDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = FilterDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER]           = FilterDispatchPower;

    DriverObject->DriverExtension->AddDevice            = FilterAddDevice;
    DriverObject->DriverUnload                          = FilterUnload;

    return(STATUS_SUCCESS);

} // end DriverEntry()

VOID
FilterSyncFilterWithTarget(
    IN PDEVICE_OBJECT FilterDevice,
    IN PDEVICE_OBJECT TargetDevice
    )
{
    ULONG                   propFlags;

    PAGED_CODE();
    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "SyncFilterWithTarget %p %p\n",
               FilterDevice,
               TargetDevice
               ));


    //
    // Propogate all useful flags from target to Filter. MountMgr will look
    // at the Filter object capabilities to figure out if the disk is
    // a removable and perhaps other things.
    //
    
    propFlags = TargetDevice->Flags & FILTER_DEVICE_PROPOGATE_FLAGS;
    SET_FLAG(FilterDevice->Flags, propFlags);

    propFlags = TargetDevice->Characteristics & FILTER_DEVICE_PROPOGATE_CHARACTERISTICS;
    SET_FLAG(FilterDevice->Characteristics, propFlags);

    return;
}

NTSTATUS
FilterAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++
Routine Description:

    Creates and initializes a new filter device object FDO for the
    corresponding PDO.  Then it attaches the device object to the device
    stack of the drivers for the device.

Arguments:

    DriverObject - Filter driver object.
    PhysicalDeviceObject - Physical Device Object from the underlying driver

Return Value:

    NTSTATUS
--*/

{
    NTSTATUS                 status;
    PDEVICE_OBJECT           filterDeviceObject;
    PFILTER_DEVICE_EXTENSION deviceExtension;
    PIRP                     irp;
    ULONG                    registrationFlag = 0;
    PCHAR                    buffer;
    ULONG                    buffersize;

    PAGED_CODE();
    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "AddDevice %p %p\n",
               DriverObject,
               PhysicalDeviceObject
               ));


    //
    // Create a filter device object for this device stack.
    // since we don't handle relative opens, we create the device
    // with the FILE_DEVICE_SECURE_OPEN flag set.
    //

    status = IoCreateDevice(DriverObject,
                            sizeof(FILTER_DEVICE_EXTENSION),
                            NULL,
                            PhysicalDeviceObject->DeviceType,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &filterDeviceObject);

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_STORFILT_ID,
                   FilterDebugWarning,
                   "FilterAddDevice: Cannot create filterDeviceObject\n"));
        return status;
    }

    SET_FLAG(filterDeviceObject->Flags, DO_DIRECT_IO);

    
    deviceExtension = (PFILTER_DEVICE_EXTENSION) filterDeviceObject->DeviceExtension;
    RtlZeroMemory(deviceExtension, sizeof(FILTER_DEVICE_EXTENSION));

    //
    // Attaches the device object to the highest device object in the chain and
    // return the previously highest device object, which is passed to
    // IoCallDriver when pass IRPs down the device stack
    //

    deviceExtension->TargetDeviceObject =
        IoAttachDeviceToDeviceStack(filterDeviceObject, PhysicalDeviceObject);

    if (deviceExtension->TargetDeviceObject == NULL) {
        IoDeleteDevice(filterDeviceObject);
        KdPrintEx((DPFLTR_STORFILT_ID,
                   FilterDebugWarning,
                   "FilterAddDevice: Unable to attach %p to target %p\n",
                   filterDeviceObject,
                   PhysicalDeviceObject
                   ));
        return STATUS_NO_SUCH_DEVICE;

    }

    //
    // NOTE: the bitmap usually requires synchronization.  since the fields
    // are static for this example, we won't require any synchronization
    // to the RTL_BITMAP structure (READ_ONLY).
    //

    RtlInitializeBitMap(&deviceExtension->AllowedCommands,
                        deviceExtension->BitmapBuffer,
                        256);
    RtlClearAllBits(&deviceExtension->AllowedCommands);
    FilterSetAllowedBitMask(deviceExtension);

    //
    // keep a back pointer to the device object
    //
    
    deviceExtension->DeviceObject = filterDeviceObject;

    KeInitializeEvent(&deviceExtension->PagingPathCountEvent,
                      NotificationEvent, TRUE);

    //
    // default to DO_POWER_PAGABLE
    //

    SET_FLAG(filterDeviceObject->Flags,  DO_POWER_PAGABLE);

    //
    // Initialize the remove lock
    //

    IoInitializeRemoveLock(&deviceExtension->RemoveLock,
                           REMLOCK_TAG,
                           REMLOCK_MAXIMUM,
                           REMLOCK_HIGHWATER);

    //
    // we want to fail some commands....
    //

    deviceExtension->FailEvery = FailEveryNCommands;

    //
    // Clear the DO_DEVICE_INITIALIZING flag
    //

    CLEAR_FLAG(filterDeviceObject->Flags, DO_DEVICE_INITIALIZING);

    return STATUS_SUCCESS;

} // end FilterAddDevice()

NTSTATUS
FilterDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch for PNP

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;
    PFILTER_DEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    BOOLEAN lockHeld;
    BOOLEAN irpCompleted;

    PAGED_CODE();

    KdPrintEx((DPFLTR_STORFILT_ID, 
               FilterDebugFunction,
               "DispatchPnp %p %p\n",
               DeviceObject,
               Irp
               ));


    //
    // Acquire the remove lock so that device will not be removed while
    // processing this irp.
    //

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);

    if (!NT_SUCCESS(status)) {

        KdPrintEx((DPFLTR_STORFILT_ID, 
                   FilterDebugRemove,
                   "DispathPnp: Remove lock failed PNP Irp type [%#02x]\n",
                   irpSp->MinorFunction));
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;

    }

    lockHeld = TRUE;
    irpCompleted = FALSE;

    switch(irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE: {

            //
            // Call the Start Routine handler. 
            //
            
            KdPrintEx((DPFLTR_STORFILT_ID, 
                       FilterDebugPnp,
                       "DispatchPnp: Schedule completion for "
                       "START_DEVICE\n"));
            status = FilterStartDevice(DeviceObject, Irp);
            KdPrintEx((DPFLTR_STORFILT_ID, 
                       FilterDebugPnp,
                       "DispatchPnp: START_DEVICE completed "
                       "with status %x\n", status));
            break;

        }

        case IRP_MN_REMOVE_DEVICE: {
            
            //
            // Call the Remove Routine handler. 
            //

            KdPrintEx((DPFLTR_STORFILT_ID,
                       FilterDebugPnp,
                       "DispatchPnp: Schedule completion for "
                       "REMOVE_DEVICE\n"));
            status = FilterRemoveDevice(DeviceObject, Irp);
            KdPrintEx((DPFLTR_STORFILT_ID,
                       FilterDebugPnp,
                       "DispatchPnp: REMOVE_DEVICE completed "
                       "with status %x\n", status));
            
            //
            // Remove locked released by FilterRemoveDevice
            //
            
            lockHeld = FALSE;
            break;

        }
        
        case IRP_MN_DEVICE_USAGE_NOTIFICATION: {

            PIO_STACK_LOCATION irpStack;
            ULONG count;
            BOOLEAN setPagable;

            KdPrintEx((DPFLTR_STORFILT_ID,
                       FilterDebugPnp,
                       "DispatchPnp: Processing DEVICE_USAGE_NOTIFICATION\n"
                       ));
            irpStack = IoGetCurrentIrpStackLocation(Irp);

            if (irpStack->Parameters.UsageNotification.Type != DeviceUsageTypePaging) {
                IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
                lockHeld = FALSE;
                status = FilterSendToNextDriver(DeviceObject, Irp);
                irpCompleted = TRUE;
                break; // out of case statement
            }

            deviceExtension = DeviceObject->DeviceExtension;

            //
            // wait on the paging path event
            //

            status = KeWaitForSingleObject(&deviceExtension->PagingPathCountEvent,
                                           Executive, KernelMode,
                                           FALSE, NULL);

            //
            // if removing last paging device, need to set DO_POWER_PAGABLE
            // bit here, and possible re-set it below on failure.
            //

            setPagable = FALSE;
            if (!irpStack->Parameters.UsageNotification.InPath &&
                deviceExtension->PagingPathCount == 1 ) {

                //
                // removing the last paging file
                // must have DO_POWER_PAGABLE bits set
                //

                if (TEST_FLAG(DeviceObject->Flags, DO_POWER_INRUSH)) {
                    
                    KdPrintEx((DPFLTR_STORFILT_ID,
                               FilterDebugPnp,
                               "DispatchPnp: last paging file "
                               "removed but DO_POWER_INRUSH set, so not "
                               "setting PAGABLE bit for DO %p\n",
                               DeviceObject
                               ));

                } else {
                    
                    KdPrintEx((DPFLTR_STORFILT_ID, 
                               FilterDebugPnp,
                               "DispatchPnp: Setting  PAGABLE "
                               "bit for DO %p\n",
                               DeviceObject
                               ));
                    SET_FLAG(DeviceObject->Flags, DO_POWER_PAGABLE);
                    setPagable = TRUE;

                }

            }

            //
            // send the irp synchronously
            //

            status = FilterForwardIrpSynchronous(DeviceObject, Irp);

            //
            // now deal with the failure and success cases.
            // note that we are not allowed to fail the irp
            // once it is sent to the lower drivers.
            //

            if (NT_SUCCESS(status)) {

                IoAdjustPagingPathCount(
                    &deviceExtension->PagingPathCount,
                    irpStack->Parameters.UsageNotification.InPath);

                if (irpStack->Parameters.UsageNotification.InPath) {
                    if (deviceExtension->PagingPathCount == 1) {

                        //
                        // first paging file addition
                        //

                        KdPrintEx((DPFLTR_STORFILT_ID,
                                   FilterDebugPnp,
                                   "DispatchPnp: Clearing PAGABLE bit "
                                   "for DO %p\n",
                                   DeviceObject));
                        CLEAR_FLAG(DeviceObject->Flags, DO_POWER_PAGABLE);

                    }
                }

            } else {

                //
                // cleanup the changes done above
                //

                if (setPagable == TRUE) {
                    CLEAR_FLAG(DeviceObject->Flags, DO_POWER_PAGABLE);
                    setPagable = FALSE;
                }

            }

            //
            // set the event so the next one can occur.
            //

            KeSetEvent(&deviceExtension->PagingPathCountEvent,
                       IO_NO_INCREMENT, FALSE);
        }

        default: {

            KdPrintEx((DPFLTR_STORFILT_ID,
                       FilterDebugPnp,
                       "DispatchPnp: Forwarding irp\n"));
            //
            // Simply forward all other Irps
            //
            IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            lockHeld = FALSE;
            status = FilterSendToNextDriver(DeviceObject, Irp);
            irpCompleted = TRUE;

        }
    
    } // end switch on IRP_MN_ type


    if (lockHeld) {
        
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    }
    
    if (! irpCompleted) {

        Irp->IoStatus.Status = status;
        KdPrintEx((DPFLTR_STORFILT_ID,
                   FilterDebugPnp,
                   "DispatchPnp: Completing Irp %p with status %x\n",
                   Irp, status));
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

    }
    

    return status;

} // end FilterDispatchPnp()

NTSTATUS
FilterIrpSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Forwarded IRP completion routine. Set an event and return
    STATUS_MORE_PROCESSING_REQUIRED. Irp forwarder will wait on this
    event and then re-complete the irp after cleaning up.

Arguments:

    DeviceObject is the device object of the WMI driver
    Irp is the WMI irp that was just completed
    Context is a PKEVENT that forwarder will wait on

Return Value:

    STATUS_MORE_PORCESSING_REQUIRED

--*/

{
    PKEVENT Event = (PKEVENT) Context;
    
    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction2,
               "SignalCompletion %p %p %p\n",
               DeviceObject,
               Irp,
               Context
               ));

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);

    return(STATUS_MORE_PROCESSING_REQUIRED);

} // end FilterIrpSignalCompletion()

NTSTATUS
FilterStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when a Pnp Start Irp is received.
    It will schedule a completion routine to initialize and register with WMI.

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp


Return Value:

    Status of processing the Start Irp

--*/
{
    PFILTER_DEVICE_EXTENSION   deviceExtension;
    KEVENT              event;
    NTSTATUS            status;

    PAGED_CODE();
    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "StartDevice %p %p\n",
               DeviceObject,
               Irp
               ));

    deviceExtension = (PFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    status = FilterForwardIrpSynchronous(DeviceObject, Irp);

    FilterSyncFilterWithTarget(DeviceObject,
                               deviceExtension->TargetDeviceObject);

    return status;
}

NTSTATUS
FilterRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the device is to be removed.
    It will de-register itself from WMI first, detach itself from the
    stack before deleting itself.

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp


Return Value:

    Status of removing the device

--*/
{
    NTSTATUS            status;
    PFILTER_DEVICE_EXTENSION   deviceExtension;

    PAGED_CODE();
    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "RemoveDevice %p %p\n",
               DeviceObject,
               Irp
               ));


    deviceExtension = (PFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    status = FilterForwardIrpSynchronous(DeviceObject, Irp);

    IoReleaseRemoveLockAndWait(&deviceExtension->RemoveLock, Irp);

    IoDetachDevice(deviceExtension->TargetDeviceObject);
    IoDeleteDevice(DeviceObject);

    return status;
}

NTSTATUS
FilterSendToNextDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sends the Irp to the next driver in line
    when the Irp is not processed by this driver.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFILTER_DEVICE_EXTENSION   deviceExtension;
    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction2,
               "SendToNextDriver %p %p\n",
               DeviceObject,
               Irp
               ));

    IoSkipCurrentIrpStackLocation(Irp);
    deviceExtension = (PFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

} // end FilterSendToNextDriver()

NTSTATUS
FilterDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PFILTER_DEVICE_EXTENSION deviceExtension;
    NTSTATUS status;

    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "DispatchPower %p %p\n",
               DeviceObject,
               Irp
               ));


    deviceExtension = (PFILTER_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    //
    // Acquire the remove lock so that device will not be removed while
    // processing this irp.
    //

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);

    if (!NT_SUCCESS(status)) {

        KdPrintEx((DPFLTR_STORFILT_ID,
                   FilterDebugRemove,
                   "FilterPower: Remove lock failed Power Irp\n"));
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;

    }

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);

    status = PoCallDriver(deviceExtension->TargetDeviceObject, Irp);
    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    return status;

} // end FilterDispatchPower

NTSTATUS
FilterForwardIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sends the Irp to the next driver in line
    when the Irp needs to be processed by the lower drivers
    prior to being processed by this one.
    
    The remove lock must be acquired when calling this routine.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFILTER_DEVICE_EXTENSION   deviceExtension;
    KEVENT event;
    NTSTATUS status;

    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "ForwardIrpSynchronous %p %p\n",
               DeviceObject,
               Irp
               ));

    //
    // NOTE: setting this to be paged code could cause issues since
    //       this driver is in the storage stack.
    //
    // PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    deviceExtension = (PFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // copy the irpstack for the next device
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // set a completion routine
    //

    IoSetCompletionRoutine(Irp, FilterIrpSignalCompletion,
                            &event, TRUE, TRUE, TRUE);

    //
    // call the next lower device
    //

    status = IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

    //
    // wait for the actual completion
    //

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;

} // end FilterForwardIrpSynchronous()

NTSTATUS
FilterDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This device control dispatcher handles only the failure prediction
    device control. All others are passed down to the disk drivers.

Arguments:

    DeviceObject - Context for the activity.
    Irp          - The device control argument block.

Return Value:

    Status is returned.

--*/

{
    PFILTER_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG controlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;
    NTSTATUS status;

    PSENSE_DATA senseData = NULL; // for logging/modification on rejection
    UCHAR senseDataSize = 0;      // for logging/modification on rejection
    PUCHAR scsiStatus = NULL;     // modification on rejection
    PCDB cdb = NULL;              // for logging
    ULONG validCommand = FALSE;   // default to not allowing the cmd



    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "DeviceControl %p %p\n",
               DeviceObject,
               Irp
               ));

    if ((controlCode != IOCTL_SCSI_PASS_THROUGH) &&
        (controlCode != IOCTL_SCSI_PASS_THROUGH_DIRECT)) {
        return FilterSendToNextDriver(DeviceObject, Irp);
    }

    //
    // Acquire the remove lock so that device will not be removed while
    // processing this irp.
    //

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);

    if (!NT_SUCCESS(status)) {
    
        KdPrintEx((DPFLTR_STORFILT_ID,
                   FilterDebugRemove,
                   "FilterDeviceControl: Remove lock failed IOCTL [%x]\n",
                   irpStack->Parameters.DeviceIoControl.IoControlCode));
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if ((controlCode == IOCTL_SCSI_PASS_THROUGH_DIRECT) &&
        (irpStack->MinorFunction != IRP_MN_SCSI_CLASS)) {
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto CompleteWithError;
    }

    //
    // Validiate the user buffer
    // set pointers to the CDB and SENSE_DATA
    //

#if defined (_WIN64)

    if (IoIs32bitProcess(Irp)) {


        //
        // NOTE: the payload (passThrough->DataBuffer) is different for both
        //       these ioctls.  we don't currently care, and hope the compiler
        //       will properly optimize both cases to a single code path.
        //

        if (controlCode == IOCTL_SCSI_PASS_THROUGH) {
            PSCSI_PASS_THROUGH32 passThrough;
            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SCSI_PASS_THROUGH32)) {

                status = STATUS_INVALID_PARAMETER;
                goto CompleteWithError;

            }
            passThrough = Irp->AssociatedIrp.SystemBuffer;
            scsiStatus = &passThrough->ScsiStatus;
            cdb = (PCDB)passThrough->Cdb;
            
            senseData = (PSENSE_DATA)( ((PUCHAR)passThrough) +
                                       passThrough->SenseInfoOffset);
            senseDataSize = passThrough->SenseInfoLength;
            

        } else if (controlCode == IOCTL_SCSI_PASS_THROUGH_DIRECT) {
            PSCSI_PASS_THROUGH_DIRECT32 passThrough;
            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SCSI_PASS_THROUGH_DIRECT32)) {

                status = STATUS_INVALID_PARAMETER;
                goto CompleteWithError;

            }
            passThrough = Irp->AssociatedIrp.SystemBuffer;
            scsiStatus = &passThrough->ScsiStatus;
            cdb = (PCDB)passThrough->Cdb;
            
            senseData = (PSENSE_DATA)( ((PUCHAR)passThrough) +
                                       passThrough->SenseInfoOffset);
            senseDataSize = passThrough->SenseInfoLength;

        }
    
    } else
#endif // defined (_WIN64)

    {
        //
        // NOTE: the payload (passThrough->DataBuffer) is different for both
        //       these ioctls.  we don't currently care, and hope the compiler
        //       will properly optimize both cases to a single code path.
        //

        if (controlCode == IOCTL_SCSI_PASS_THROUGH) {
            PSCSI_PASS_THROUGH passThrough;
            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SCSI_PASS_THROUGH)) {

                status = STATUS_INVALID_PARAMETER;
                goto CompleteWithError;

            }
            passThrough = Irp->AssociatedIrp.SystemBuffer;
            scsiStatus = &passThrough->ScsiStatus;
            cdb = (PCDB)passThrough->Cdb;
            
            senseData = (PSENSE_DATA)( ((PUCHAR)passThrough) +
                                       passThrough->SenseInfoOffset);
            senseDataSize = passThrough->SenseInfoLength;

        } else if (controlCode == IOCTL_SCSI_PASS_THROUGH_DIRECT) {
            PSCSI_PASS_THROUGH_DIRECT passThrough;
            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SCSI_PASS_THROUGH_DIRECT)) {

                status = STATUS_INVALID_PARAMETER;
                goto CompleteWithError;

            }
            passThrough = Irp->AssociatedIrp.SystemBuffer;
            scsiStatus = &passThrough->ScsiStatus;
            cdb = (PCDB)passThrough->Cdb;

            senseData = (PSENSE_DATA)( ((PUCHAR)passThrough) +
                                       passThrough->SenseInfoOffset);
            senseDataSize = passThrough->SenseInfoLength;
        }

    }

    //
    // all required pointers have been set.
    //

    ASSERT(scsiStatus != NULL);
    ASSERT(cdb != NULL);
    ASSERT((senseData != NULL) || (senseDataSize == 0));

    validCommand = FilterIsCmdValid(deviceExtension, cdb->AsByte[0]);

    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugBusTrace,
               "PassThrough: trace"
               "  %02x %02x %02x %02x"
               "  %02x %02x %02x %02x"
               "    %02x %02x %02x %02x"
               "  %02x %02x %02x %02x\n",
               cdb->AsByte[0x0], cdb->AsByte[0x1],
               cdb->AsByte[0x2], cdb->AsByte[0x3],
               cdb->AsByte[0x4], cdb->AsByte[0x5],
               cdb->AsByte[0x6], cdb->AsByte[0x7],
               cdb->AsByte[0x8], cdb->AsByte[0x9],
               cdb->AsByte[0xa], cdb->AsByte[0xb],
               cdb->AsByte[0xc], cdb->AsByte[0xd],
               cdb->AsByte[0xe], cdb->AsByte[0xf]
               ));


    //
    // if the command was not allowed, fake an invalid
    // device request error.
    //

    if (validCommand) {

        KdPrintEx((DPFLTR_STORFILT_ID,
                   FilterDebugPtAllow,
                   "PassThrough: Allowing command 0x%02x\n",
                   cdb->AsByte[0]));
        status = FilterProcessIrp(deviceExtension, Irp);
        return status;

    } else { // (!validCommand)

        KdPrintEx((DPFLTR_STORFILT_ID,
                   FilterDebugPtReject,
                   "PassThrough: Rejecting command 0x%02x\n",
                   cdb->AsByte[0]));

        FilterFakeSenseDataError(
            senseData,
            senseDataSize,
            SCSI_SENSE_ILLEGAL_REQUEST, SCSI_ADSENSE_INVALID_CDB, 0
            );

        *scsiStatus = SCSISTAT_CHECK_CONDITION;
        status = STATUS_SUCCESS;
        goto CompleteWithSuccess;

    }

CompleteWithError:
    
    ASSERT(!NT_SUCCESS(status));

CompleteWithSuccess:

    Irp->IoStatus.Status = status;
    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;

} // end FilterDeviceControl()

NTSTATUS
FilterScsi(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    PFILTER_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;
    PSCSI_REQUEST_BLOCK srb;   
    ULONG validCommand;

    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "Scsi %p %p\n",
               DeviceObject,
               Irp
               ));

    //
    // Acquire the remove lock so that device will not be removed while
    // processing this irp.
    //

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);

    if (!NT_SUCCESS(status)) {

        KdPrintEx((DPFLTR_STORFILT_ID,
                   FilterDebugRemove,
                   "Scsi: Remove lock failed\n"));
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;

    }

    srb = irpStack->Parameters.Scsi.Srb;

    validCommand = FilterIsCmdValid(deviceExtension,
                                    srb->Cdb[0]
                                    );

    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugBusTrace,
               "Scsi: trace %02x %02x %02x %02x  %02x %02x %02x %02x"
               "   %02x %02x %02x %02x  %02x %02x %02x %02x\n",
               srb->Cdb[0x0], srb->Cdb[0x1], srb->Cdb[0x2], srb->Cdb[0x3],
               srb->Cdb[0x4], srb->Cdb[0x5], srb->Cdb[0x6], srb->Cdb[0x7],
               srb->Cdb[0x8], srb->Cdb[0x9], srb->Cdb[0xa], srb->Cdb[0xb],
               srb->Cdb[0xc], srb->Cdb[0xd], srb->Cdb[0xe], srb->Cdb[0xf]
               ));
    
    if (!validCommand) {

        KdPrintEx((DPFLTR_STORFILT_ID,
                   FilterDebugScsiReject,
                   "Scsi: Rejecting command 0x%02x\n",
                   srb->Cdb[0]));

        srb->DataTransferLength = 0;
        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;

        //
        // we don't mark the sense valid above, but if available
        // fill it in anyways to find bugs in that code path.
        //

        FilterFakeSenseDataError(
            srb->SenseInfoBuffer,
            srb->SenseInfoBufferLength,
            SCSI_SENSE_ILLEGAL_REQUEST, SCSI_ADSENSE_INVALID_CDB, 0
            );

        status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Status = status;
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }
    
    
    if (deviceExtension->FailEvery != 0) {
        
        ULONG t = InterlockedIncrement(&deviceExtension->IoCount);

        if ((t%deviceExtension->FailEvery) == 0 &&
            !TEST_FLAG(srb->SrbFlags, SRB_CLASS_FLAGS_PAGING)
            ) {

            KdPrintEx((DPFLTR_STORFILT_ID,
                       FilterDebugScsiAllow,
                       "Scsi: Failing command 0x%02x for PERF testing\n",
                       srb->Cdb[0]));
            RtlZeroMemory(srb->SenseInfoBuffer, srb->SenseInfoBufferLength);
            srb->SrbStatus = SRB_STATUS_COMMAND_TIMEOUT;
            status = STATUS_IO_TIMEOUT;
            Irp->IoStatus.Status = status;
            IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;
        }

    }

    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugScsiAllow,
               "Scsi: Allowing command 0x%02x\n",
               srb->Cdb[0]));

    status = FilterProcessIrp(deviceExtension, Irp);
    return status;

} // end FilterScsi()

NTSTATUS
FilterProcessIrpCompletion(
    IN PDEVICE_OBJECT Unreferenced,
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFILTER_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction2,
               "ProcessIrpCompletion %p %p\n",
               DeviceObject,
               Irp
               ));

    //
    // do any post-processing work here.
    // ie. ioctl processing to print sense buffers or modification of
    //     data returned by device for given commands.
    //

    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    return Irp->IoStatus.Status;
    
} // end FilterProcessIrpCompletion()

NTSTATUS
FilterProcessIrp(
    IN PFILTER_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
{
    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction2,
               "ProcessIrp %p %p\n",
               DeviceExtension,
               Irp
               ));
    
    IoMarkIrpPending(Irp);
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           FilterProcessIrpCompletion,
                           DeviceExtension->DeviceObject,
                           TRUE, TRUE, TRUE);
    IoCallDriver(DeviceExtension->TargetDeviceObject, Irp);
    return STATUS_PENDING;

} // end FilterProcessIrp()

VOID
FilterSetAllowedBitMask(
    IN PFILTER_DEVICE_EXTENSION DeviceExtension
    )
{
    ULONG i;

    PAGED_CODE();
    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "SetAllowedBitMask %p\n",
               DeviceExtension
               ));

    //
    // it is presumed the user can make this more efficient.
    // this method was chosen for clarity and ease of modification.
    //

    RtlClearAllBits(&DeviceExtension->AllowedCommands);

    for (i=0; i < 0x100; i++) {

        if (AllowedCommandsW2kCdrom[i]) {
            RtlSetBit(&DeviceExtension->AllowedCommands, i);
        }
    
    }

    return;
} // end FilterSetAllowedBitMask()

VOID
FilterUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{
    PAGED_CODE();

    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "Unload %p\n",
               DriverObject
               ));

    //
    // WPP_CLEANUP can only occur after all KdPrintEx routines
    // since it deallocates any resources used by that and also
    // deregisters from WMI...
    //

    WPP_CLEANUP(DriverObject);

    return;
}

VOID
FilterFakeSenseDataError(
    IN PSENSE_DATA Sense,
    IN UCHAR SenseLength,
    IN UCHAR SenseKey,
    IN UCHAR Asc,
    IN UCHAR Ascq
    )
{

    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "FakeSenseDataError %p %x\n",
               Sense,
               SenseLength
               ));

    if (SenseLength == 0) {
        return;
    }
    
    RtlZeroMemory(Sense, SenseLength);

    if (SenseLength >= 3) {  // cannot use RTL_CONTAINS_FIELD of a bitfield
        Sense->Valid = 1;
        Sense->SenseKey = SenseKey;
    }
    
    //
    // set the additional sense length appropriately
    //
    
    if (RTL_CONTAINS_FIELD(Sense, SenseLength, AdditionalSenseLength)) {
        
        Sense->AdditionalSenseLength =
            (UCHAR)(SenseLength -
                    RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseLength)
                    );

    }

    //
    // set the additional sense code (if possible) to say the cdb is invalid
    //

    if (RTL_CONTAINS_FIELD(Sense, SenseLength, AdditionalSenseCode)) {
        Sense->AdditionalSenseCode = Asc;
    }

    if (RTL_CONTAINS_FIELD(Sense, SenseLength, AdditionalSenseCodeQualifier)) {
        Sense->AdditionalSenseCodeQualifier = Ascq;
    }
    

    return;

}

BOOLEAN
FilterIsCmdValid(
    IN PFILTER_DEVICE_EXTENSION DeviceExtension,
    IN UCHAR Cmd
    )
{
#if DBG
    if (Noop) {
        return TRUE;
    }
#endif // DBG
    if (RtlCheckBit(&DeviceExtension->AllowedCommands, Cmd)) {
        return TRUE;
    }
    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\class\filters\storagefilter\filter.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 2000

Module Name:

Abstract:

Environment:

Notes:

Revision History:

--*/

#include <ntddk.h>
#include <ntddscsi.h>
#include <scsi.h>
#include "filter_trace.h"

#define DPFLTR_STORFILT_ID 0xffff

extern BOOLEAN const AllowedCommandsW2kClasspnp      [0x100];
extern BOOLEAN const AllowedCommandsW2kCdrom         [0x100];
extern BOOLEAN const AllowedCommandsW2kDisk          [0x100];
extern BOOLEAN const AllowedCommandsW2kSfloppy       [0x100];
extern BOOLEAN const AllowedCommands51Cdrom          [0x100];
extern BOOLEAN const AllowedCommandsAddBurning       [0x100];
extern BOOLEAN const AllowedCommandsAddExtendedCdrom [0x100];
extern BOOLEAN const AllowedCommandsAddDVDSupport    [0x100];


//
// Bit Flag Macros
//

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   (((Flags) & (Bit)) != 0)

//
// Remove lock definitions
//

#define REMLOCK_TAG        'rotS'  // 'Stor' backwards
#define REMLOCK_MAXIMUM        60  // Max minutes system allows lock to be held
#define REMLOCK_HIGHWATER  0x2000  // Max number of irps holding lock at one time

//
// things the driver allocates.
//

#define FILTER_TAG_BITMAP 'BrtS' // unique(?) tag?


//
// Device Extension
//

typedef struct _FILTER_DEVICE_EXTENSION {

    //
    // Back pointer to device object
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // Target Device Object
    //

    PDEVICE_OBJECT TargetDeviceObject;

    //
    // io count for failing requests
    //
    
    ULONG IoCount;
    ULONG FailEvery;

    //
    // must synchronize paging path notifications
    //
    
    KEVENT PagingPathCountEvent;
    ULONG  PagingPathCount;

    //
    // Since we may hold onto irps for an arbitrarily long time
    // we need a remove lock so that our device does not get removed
    // while an irp is being processed.
    
    IO_REMOVE_LOCK RemoveLock;

    //
    // bitmap of allowed commands
    //

    RTL_BITMAP AllowedCommands;
    ULONG      BitmapBuffer[256/(8*sizeof(ULONG))];

} FILTER_DEVICE_EXTENSION, *PFILTER_DEVICE_EXTENSION;

#define FILTER_DEVICE_PROPOGATE_FLAGS            0
#define FILTER_DEVICE_PROPOGATE_CHARACTERISTICS (FILE_REMOVABLE_MEDIA |  \
                                                 FILE_READ_ONLY_DEVICE | \
                                                 FILE_FLOPPY_DISKETTE    \
                                                 )


//
// Function declarations
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
FilterSyncFilterWithTarget(
    IN PDEVICE_OBJECT FilterDevice,
    IN PDEVICE_OBJECT TargetDevice
    );

NTSTATUS
FilterAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
FilterDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FilterIrpSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
FilterStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FilterRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FilterSendToNextDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FilterDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FilterForwardIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FilterDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
FilterScsi(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
FilterProcessIrpCompletion(
    IN PDEVICE_OBJECT Unreferenced,
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
FilterProcessIrp(
    IN PFILTER_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

VOID
FilterSetAllowedBitMask(
    IN PFILTER_DEVICE_EXTENSION DeviceExtension
    );

VOID
FilterUnload(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
FilterFakeSenseDataError(
    IN PSENSE_DATA Sense,
    IN UCHAR SenseLength,
    IN UCHAR SenseKey,
    IN UCHAR Asc,
    IN UCHAR Ascq
    );

BOOLEAN
FilterIsCmdValid(
    IN PFILTER_DEVICE_EXTENSION DeviceExtension,
    IN UCHAR Cmd
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\classpnp\autorun.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    autorun.c

Abstract:

    Code for support of media change detection in the class driver

Environment:

    kernel mode only

Notes:


Revision History:

--*/

#include "classp.h"
#include "debug.h"

#define GESN_TIMEOUT_VALUE (0x4)
#define GESN_BUFFER_SIZE (0x8)
#define MAXIMUM_IMMEDIATE_MCN_RETRIES (0x20)
#define MCN_REG_SUBKEY_NAME                   (L"MediaChangeNotification")
#define MCN_REG_AUTORUN_DISABLE_INSTANCE_NAME (L"AlwaysDisableMCN")
#define MCN_REG_AUTORUN_ENABLE_INSTANCE_NAME  (L"AlwaysEnableMCN")

GUID StoragePredictFailureEventGuid = WMI_STORAGE_PREDICT_FAILURE_EVENT_GUID;

//
// Only send polling irp when device is fully powered up and a
// power down irp is not in progress.
//
// NOTE:   This helps close a window in time where a polling irp could cause
//         a drive to spin up right after it has powered down. The problem is
//         that SCSIPORT, ATAPI and SBP2 will be in the process of powering
//         down (which may take a few seconds), but won't know that. It would
//         then get a polling irp which will be put into its queue since it
//         the disk isn't powered down yet. Once the disk is powered down it
//         will find the polling irp in the queue and then power up the
//         device to do the poll. They do not want to check if the polling
//         irp has the SRB_NO_KEEP_AWAKE flag here since it is in a critical
//         path and would slow down all I/Os. A better way to fix this
//         would be to serialize the polling and power down irps so that
//         only one of them is sent to the device at a time.
//
#define ClasspCanSendPollingIrp(fdoExtension)                           \
               ((fdoExtension->DevicePowerState == PowerDeviceD0) &&  \
                (! fdoExtension->PowerDownInProgress) )

BOOLEAN
ClasspIsMediaChangeDisabledDueToHardwareLimitation(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
ClasspMediaChangeDeviceInstanceOverride(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    OUT PBOOLEAN Enabled
    );

BOOLEAN
ClasspIsMediaChangeDisabledForClass(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PUNICODE_STRING RegistryPath
    );

VOID
ClasspSetMediaChangeStateEx(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN MEDIA_CHANGE_DETECTION_STATE NewState,
    IN BOOLEAN Wait,
    IN BOOLEAN KnownStateChange // can ignore oldstate == unknown
    );

NTSTATUS
ClasspMediaChangeRegistryCallBack(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

VOID
ClasspSendMediaStateIrp(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PMEDIA_CHANGE_DETECTION_INFO Info,
    IN ULONG CountDown
    );

VOID
ClasspFailurePredict(
    IN PDEVICE_OBJECT DeviceObject,
    IN PFAILURE_PREDICTION_INFO Info
    );

NTSTATUS
ClasspInitializePolling(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN BOOLEAN AllowDriveToSleep
    );


#if ALLOC_PRAGMA

#pragma alloc_text(PAGE, ClassInitializeMediaChangeDetection)
#pragma alloc_text(PAGE, ClassEnableMediaChangeDetection)
#pragma alloc_text(PAGE, ClassDisableMediaChangeDetection)
#pragma alloc_text(PAGE, ClassCleanupMediaChangeDetection)
#pragma alloc_text(PAGE, ClasspMediaChangeRegistryCallBack)
#pragma alloc_text(PAGE, ClasspInitializePolling)

#pragma alloc_text(PAGE, ClasspIsMediaChangeDisabledDueToHardwareLimitation)
#pragma alloc_text(PAGE, ClasspMediaChangeDeviceInstanceOverride)
#pragma alloc_text(PAGE, ClasspIsMediaChangeDisabledForClass)

#pragma alloc_text(PAGE, ClassSetFailurePredictionPoll)
#pragma alloc_text(PAGE, ClasspDisableTimer)
#pragma alloc_text(PAGE, ClasspEnableTimer)

#endif

// ISSUE -- make this public?
VOID
ClassSendEjectionNotification(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
{
    //
    // For post-NT5.1 work, need to move EjectSynchronizationEvent
    // to be a MUTEX so we can attempt to grab it here and benefit
    // from deadlock detection.  This will allow checking if the media
    // has been locked by programs before broadcasting these events.
    // (what's the point of broadcasting if the media is not locked?)
    //
    // This would currently only be a slight optimization.  For post-NT5.1,
    // it would allow us to send a single PERSISTENT_PREVENT to MMC devices,
    // thereby cleaning up a lot of the ejection code.  Then, when the
    // ejection request occured, we could see if any locks for the media
    // existed.  if locked, broadcast.  if not, we send the eject irp.
    //
    
    //
    // for now, just always broadcast.  make this a public routine,
    // so class drivers can add special hacks to broadcast this for their
    // non-MMC-compliant devices also from sense codes.
    //

    DBGTRACE(ClassDebugTrace, ("ClassSendEjectionNotification: media EJECT_REQUEST"));    
    ClasspSendNotification(FdoExtension,
                           &GUID_IO_MEDIA_EJECT_REQUEST,
                           0,
                           NULL);
    return;
}


VOID
ClasspSendNotification(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN const GUID * Guid,
    IN ULONG  ExtraDataSize,
    IN PVOID  ExtraData
    )
{
    PTARGET_DEVICE_CUSTOM_NOTIFICATION notification;
    ULONG requiredSize;
        
    requiredSize =
        (sizeof(TARGET_DEVICE_CUSTOM_NOTIFICATION) - sizeof(UCHAR)) +
        ExtraDataSize;

    if (requiredSize > 0x0000ffff) {
        // MAX_USHORT, max total size for these events!
        KdPrintEx((DPFLTR_CLASSPNP_ID, ClassDebugWarning,
                   "Error sending event: size too large! (%x)\n",
                   requiredSize));
        return;
    }
    
    notification = ExAllocatePoolWithTag(NonPagedPool,
                                         requiredSize,
                                         'oNcS');
    
    //
    // if none allocated, exit
    //

    if (notification == NULL) {
        return;
    }

    //
    // Prepare and send the request!
    //
    
    RtlZeroMemory(notification, requiredSize);
    notification->Version = 1;
    notification->Size = (USHORT)(requiredSize);
    notification->FileObject = NULL;
    notification->NameBufferOffset = -1;
    notification->Event = *Guid;
    RtlCopyMemory(notification->CustomDataBuffer, ExtraData, ExtraDataSize);

    IoReportTargetDeviceChangeAsynchronous(FdoExtension->LowerPdo,
                                           notification,
                                           NULL, NULL);
    
    ExFreePool(notification);
    notification = NULL;
    return;
}




/*++////////////////////////////////////////////////////////////////////////////

ClasspInterpretGesnData()

Routine Description:

    This routine will interpret the data returned for a GESN command, and
    (if appropriate) set the media change event, and broadcast the
    appropriate events to user mode for applications who care.

Arguments:

    FdoExtension - the device
    
    DataBuffer - the resulting data from a GESN event.
        requires at least EIGHT valid bytes (header == 4, data == 4)

    ResendImmediately - whether or not to immediately resend the request.
        this should be FALSE if there was no event, FALSE if the reported
        event was of the DEVICE BUSY class, else true.

Return Value:
    
    None
    
Notes:

    DataBuffer must be at least four bytes of valid data (header == 4 bytes),
    and have at least eight bytes of allocated memory (all events == 4 bytes).
    
    The call to StartNextPacket may occur before this routine is completed.
    the operational change notifications are informational in nature, and
    while useful, are not neccessary to ensure proper operation.  For example,
    if the device morphs to no longer supporting WRITE commands, all further
    write commands will fail.  There exists a small timing window wherein
    IOCTL_IS_DISK_WRITABLE may be called and get an incorrect response.  If
    a device supports software write protect, it is expected that the
    application can handle such a case.
    
    NOTE: perhaps setting the updaterequired byte to one should be done here.
    if so, it relies upon the setting of a 32-byte value to be an atomic
    operation.  unfortunately, there is no simple way to notify a class driver
    which wants to know that the device behavior requires updating.
    
    Not ready events may be sent every second.  For example, if we were
    to minimize the number of asynchronous notifications, an application may
    register just after a large busy time was reported.  This would then
    prevent the application from knowing the device was busy until some
    arbitrarily chosen timeout has occurred.  Also, the GESN request would
    have to still occur, since it checks for non-busy events (such as user
    keybutton presses and media change events) as well.  The specification
    states that the lower-numered events get reported first, so busy events,
    while repeating, will only be reported when all other events have been
    cleared from the device.

--*/
VOID
ClasspInterpretGesnData(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PNOTIFICATION_EVENT_STATUS_HEADER Header,
    IN PBOOLEAN ResendImmediately
    )
{
    PMEDIA_CHANGE_DETECTION_INFO info;
    LONG dataLength;
    LONG requiredLength;

    info = FdoExtension->MediaChangeDetectionInfo;

    //
    // note: don't allocate anything in this routine so that we can
    //       always just 'return'.
    //

    *ResendImmediately = FALSE;

    if (Header->NEA) {
        return;
    }
    if (Header->NotificationClass == NOTIFICATION_NO_CLASS_EVENTS) {
        return;
    }

    //
    // HACKHACK - REF #0001
    // This loop is only taken initially, due to the inability to reliably
    // auto-detect drives that report events correctly at boot.  When we
    // detect this behavior during the normal course of running, we will
    // disable the hack, allowing more efficient use of the system.  This
    // should occur "nearly" instantly, as the drive should have multiple
    // events queue'd (ie. power, morphing, media).
    //

    if (info->Gesn.HackEventMask) {

        //
        // all events use the low four bytes of zero to indicate
        // that there was no change in status.
        //

        UCHAR thisEvent = Header->ClassEventData[0] & 0xf;
        UCHAR lowestSetBit;
        UCHAR thisEventBit = (1 << Header->NotificationClass);

        ASSERT(TEST_FLAG(info->Gesn.EventMask, thisEventBit));


        //
        // some bit magic here... this results in the lowest set bit only
        //

        lowestSetBit = info->Gesn.EventMask;
        lowestSetBit &= (info->Gesn.EventMask - 1);
        lowestSetBit ^= (info->Gesn.EventMask);

        if (thisEventBit != lowestSetBit) {
            
            //
            // HACKHACK - REF #0001
            // the first time we ever see an event set that is not the lowest
            // set bit in the request (iow, highest priority), we know that the
            // hack is no longer required, as the device is ignoring "no change"
            // events when a real event is waiting in the other requested queues.
            //

            KdPrintEx((DPFLTR_CLASSPNP_ID, ClassDebugMCN,
                       "Classpnp => GESN::NONE: Compliant drive found, "
                       "removing GESN hack (%x, %x)\n",
                       thisEventBit, info->Gesn.EventMask));
            
            info->Gesn.HackEventMask = FALSE;

        } else if (thisEvent == 0) {
            
            //
            // HACKHACK - REF #0001
            // note: this hack prevents poorly implemented firmware from constantly
            //       returning "No Event".  we do this by cycling through the
            //       supported list of events here.
            //

            SET_FLAG(info->Gesn.NoChangeEventMask, thisEventBit);
            CLEAR_FLAG(info->Gesn.EventMask, thisEventBit);

            //
            // if we have cycled through all supported event types, then
            // we need to reset the events we are asking about. else we
            // want to resend this request immediately in case there was
            // another event pending.
            //

            if (info->Gesn.EventMask == 0) {
                info->Gesn.EventMask         = info->Gesn.NoChangeEventMask;
                info->Gesn.NoChangeEventMask = 0;
            } else {
                *ResendImmediately = TRUE;
            }
            return;
        }

    } // end if (info->Gesn.HackEventMask)

    dataLength =
        (Header->EventDataLength[0] << 8) |
        (Header->EventDataLength[1] & 0xff);
    dataLength -= 2;
    requiredLength = 4; // all events are four bytes

    if (dataLength < requiredLength) {
        KdPrintEx((DPFLTR_CLASSPNP_ID, ClassDebugWarning,
                   "Classpnp => GESN returned only %x bytes data for fdo %p\n",
                   dataLength, FdoExtension->DeviceObject));
        return;
    }
    if (dataLength != requiredLength) {
        KdPrintEx((DPFLTR_CLASSPNP_ID, ClassDebugWarning,
                   "Classpnp => GESN returned too many (%x) bytes data for fdo %p\n",
                   dataLength, FdoExtension->DeviceObject));
        dataLength = 4;
    }

/*
    ClasspSendNotification(FdoExtension,
                           &GUID_IO_GENERIC_GESN_EVENT,
                           sizeof(NOTIFICATION_EVENT_STATUS_HEADER) + dataLength,
                           Header)
*/                           

    switch (Header->NotificationClass) {

    case NOTIFICATION_EXTERNAL_REQUEST_CLASS_EVENTS: { // 0x3
        
        PNOTIFICATION_EXTERNAL_STATUS externalInfo = 
            (PNOTIFICATION_EXTERNAL_STATUS)(Header->ClassEventData);
        DEVICE_EVENT_EXTERNAL_REQUEST externalData;

        //
        // unfortunately, due to time constraints, we will only notify
        // about keys being pressed, and not released.  this makes keys
        // single-function, but simplifies the code significantly.
        //
        
        if (externalInfo->ExternalEvent !=
            NOTIFICATION_EXTERNAL_EVENT_BUTTON_DOWN) {
            break;
        }
        
        *ResendImmediately = TRUE;
        KdPrintEx((DPFLTR_CLASSPNP_ID, ClassDebugMCN,
                   "Classpnp => GESN::EXTERNAL: Event: %x Status %x Req %x\n",
                   externalInfo->ExternalEvent, externalInfo->ExternalStatus,
                   (externalInfo->Request[0] >> 8) | externalInfo->Request[1]
                   ));

        RtlZeroMemory(&externalData, sizeof(DEVICE_EVENT_EXTERNAL_REQUEST));
        externalData.Version = 1;
        externalData.DeviceClass = 0;
        externalData.ButtonStatus = externalInfo->ExternalEvent;
        externalData.Request =
            (externalInfo->Request[0] << 8) |
            (externalInfo->Request[1] & 0xff);
        KeQuerySystemTime(&(externalData.SystemTime));
        externalData.SystemTime.QuadPart *= (LONGLONG)KeQueryTimeIncrement();

        DBGTRACE(ClassDebugTrace, ("ClasspInterpretGesnData: media DEVICE_EXTERNAL_REQUEST"));        
        ClasspSendNotification(FdoExtension,
                               &GUID_IO_DEVICE_EXTERNAL_REQUEST,
                               sizeof(DEVICE_EVENT_EXTERNAL_REQUEST),
                               &externalData);
        return;
    }
    
    case NOTIFICATION_MEDIA_STATUS_CLASS_EVENTS: { // 0x4
        
        PNOTIFICATION_MEDIA_STATUS mediaInfo =
            (PNOTIFICATION_MEDIA_STATUS)(Header->ClassEventData);
        
        if (mediaInfo->MediaEvent == NOTIFICATION_MEDIA_EVENT_NO_CHANGE) {
            break;
        }
        
        *ResendImmediately = TRUE;
        KdPrintEx((DPFLTR_CLASSPNP_ID, ClassDebugMCN,
                   "Classpnp => GESN::MEDIA: Event: %x Status %x\n",
                   mediaInfo->MediaEvent, mediaInfo->MediaStatus));
        
        if ((mediaInfo->MediaEvent == NOTIFICATION_MEDIA_EVENT_NEW_MEDIA) ||
            (mediaInfo->MediaEvent == NOTIFICATION_MEDIA_EVENT_MEDIA_CHANGE)) {


            if (TEST_FLAG(FdoExtension->DeviceObject->Characteristics,
                          FILE_REMOVABLE_MEDIA) &&
                (ClassGetVpb(FdoExtension->DeviceObject) != NULL) &&
                (ClassGetVpb(FdoExtension->DeviceObject)->Flags & VPB_MOUNTED)
                ) {

                SET_FLAG(FdoExtension->DeviceObject->Flags, DO_VERIFY_VOLUME);

            }
            InterlockedIncrement(&FdoExtension->MediaChangeCount);
            ClasspSetMediaChangeStateEx(FdoExtension,
                                        MediaPresent,
                                        FALSE,
                                        TRUE);

        } else if (mediaInfo->MediaEvent == NOTIFICATION_MEDIA_EVENT_MEDIA_REMOVAL) {
            
            ClasspSetMediaChangeStateEx(FdoExtension,
                                        MediaNotPresent,
                                        FALSE,
                                        TRUE);
        
        } else if (mediaInfo->MediaEvent == NOTIFICATION_MEDIA_EVENT_EJECT_REQUEST) {

            KdPrintEx((DPFLTR_CLASSPNP_ID, ClassDebugError,
                       "Classpnp => GESN Ejection request received!\n"));
            ClassSendEjectionNotification(FdoExtension);
        
        }
        break;

    }
    
    case NOTIFICATION_DEVICE_BUSY_CLASS_EVENTS: { // lowest priority events...
        
        PNOTIFICATION_BUSY_STATUS busyInfo =
            (PNOTIFICATION_BUSY_STATUS)(Header->ClassEventData);
        DEVICE_EVENT_BECOMING_READY busyData;
        
        //
        // NOTE: we never actually need to immediately retry for these
        //       events: if one exists, the device is busy, and if not,
        //       we still don't want to retry.
        //

        if (busyInfo->DeviceBusyStatus == NOTIFICATION_BUSY_STATUS_NO_EVENT) {
            break;
        }
        
        //
        // else we want to report the approximated time till it's ready.
        //

        RtlZeroMemory(&busyData, sizeof(DEVICE_EVENT_BECOMING_READY));
        busyData.Version = 1;
        busyData.Reason = busyInfo->DeviceBusyStatus;
        busyData.Estimated100msToReady = (busyInfo->Time[0] << 8) |
                                         (busyInfo->Time[1] & 0xff);
        
        KdPrintEx((DPFLTR_CLASSPNP_ID, ClassDebugMCN,
                   "Classpnp => GESN::BUSY: Event: %x Status %x Time %x\n",
                   busyInfo->DeviceBusyEvent, busyInfo->DeviceBusyStatus,
                   busyData.Estimated100msToReady
                   ));

        DBGTRACE(ClassDebugTrace, ("ClasspInterpretGesnData: media BECOMING_READY"));                
        ClasspSendNotification(FdoExtension,
                               &GUID_IO_DEVICE_BECOMING_READY,
                               sizeof(DEVICE_EVENT_BECOMING_READY),
                               &busyData);
        break;
    }
    
    default: {
        
        break;

    }
    
    } // end switch on notification class    
    return;
}

/*++////////////////////////////////////////////////////////////////////////////

ClasspInternalSetMediaChangeState()

Routine Description:

    This routine will (if appropriate) set the media change event for the
    device.  The event will be set if the media state is changed and
    media change events are enabled.  Otherwise the media state will be
    tracked but the event will not be set.

    This routine will lock out the other media change routines if possible
    but if not a media change notification may be lost after the enable has
    been completed.

Arguments:

    FdoExtension - the device

    MediaPresent - indicates whether the device has media inserted into it
                   (TRUE) or not (FALSE).
 
Return Value:

    none

--*/
VOID
ClasspInternalSetMediaChangeState(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN MEDIA_CHANGE_DETECTION_STATE NewState,
    IN BOOLEAN KnownStateChange // can ignore oldstate == unknown
    )
{
#if DBG
    PUCHAR states[] = {"Unknown", "Present", "Not Present"};
#endif
    MEDIA_CHANGE_DETECTION_STATE oldMediaState;
    PMEDIA_CHANGE_DETECTION_INFO info = FdoExtension->MediaChangeDetectionInfo;
    ULONG data;
    NTSTATUS status;

    ASSERT((NewState >= MediaUnknown) && (NewState <= MediaNotPresent));

    if(info == NULL) {
        return;
    }

    oldMediaState = InterlockedExchange(
        (PLONG)(&info->MediaChangeDetectionState),
        (LONG)NewState);

    if((oldMediaState == MediaUnknown) && (!KnownStateChange)) {

        //
        // The media was in an indeterminate state before - don't notify for
        // this change.
        //

        DebugPrint((ClassDebugMCN,
                    "ClassSetMediaChangeState: State was unknown - this may "
                    "not be a change\n"));
        return;

    } else if(oldMediaState == NewState) {

        //
        // Media is in the same state it was before.
        //

        return;
    }

    if(info->MediaChangeDetectionDisableCount != 0) {

        DBGTRACE(ClassDebugMCN,
                    ("ClassSetMediaChangeState: MCN not enabled, state "
                    "changed from %s to %s\n",
                    states[oldMediaState], states[NewState]));
        return;

    }

    DBGTRACE(ClassDebugMCN,
                ("ClassSetMediaChangeState: State change from %s to %s\n",
                states[oldMediaState], states[NewState]));

    //
    // make the data useful -- it used to always be zero.
    //
    data = FdoExtension->MediaChangeCount;

    if (NewState == MediaPresent) {

        DBGTRACE(ClassDebugTrace, ("ClasspInternalSetMediaChangeState: media ARRIVAL"));
        ClasspSendNotification(FdoExtension,
                               &GUID_IO_MEDIA_ARRIVAL,
                               sizeof(ULONG),
                               &data);

    } 
    else if (NewState == MediaNotPresent) {

        DBGTRACE(ClassDebugTrace, ("ClasspInternalSetMediaChangeState: media REMOVAL"));
        ClasspSendNotification(FdoExtension,
                               &GUID_IO_MEDIA_REMOVAL,
                               sizeof(ULONG),
                               &data);

    } else {

        //
        // Don't notify of changed going to unknown.
        //

        return;
    }
    
    return;
} // end ClasspInternalSetMediaChangeState()

/*++////////////////////////////////////////////////////////////////////////////

ClassSetMediaChangeState()

Routine Description:

    This routine will (if appropriate) set the media change event for the
    device.  The event will be set if the media state is changed and
    media change events are enabled.  Otherwise the media state will be
    tracked but the event will not be set.

    This routine will lock out the other media change routines if possible
    but if not a media change notification may be lost after the enable has
    been completed.

Arguments:

    FdoExtension - the device

    MediaPresent - indicates whether the device has media inserted into it
                   (TRUE) or not (FALSE).

    Wait - indicates whether the function should wait until it can acquire
           the synchronization lock or not.

Return Value:

    none

--*/
VOID
ClasspSetMediaChangeStateEx(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN MEDIA_CHANGE_DETECTION_STATE NewState,
    IN BOOLEAN Wait,
    IN BOOLEAN KnownStateChange // can ignore oldstate == unknown
    )
{
    PMEDIA_CHANGE_DETECTION_INFO info = FdoExtension->MediaChangeDetectionInfo;
    LARGE_INTEGER zero;
    NTSTATUS status;

    DBGTRACE(ClassDebugMCN, ("> ClasspSetMediaChangeStateEx"));

    //
    // Reset SMART status on media removal as the old status may not be
    // valid when there is no media in the device or when new media is
    // inserted.
    //

    if (NewState == MediaNotPresent) {

        FdoExtension->FailurePredicted = FALSE;
        FdoExtension->FailureReason = 0;

    }


    zero.QuadPart = 0;

    if(info == NULL) {
        return;
    }

    status = KeWaitForMutexObject(&info->MediaChangeMutex,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  ((Wait == TRUE) ? NULL : &zero));

    if(status == STATUS_TIMEOUT) {

        //
        // Someone else is in the process of setting the media state
        //

        DBGWARN(("ClasspSetMediaChangeStateEx - timed out waiting for mutex"));
        return;
    }

    //
    // Change the media present state and signal an event, if applicable
    //

    ClasspInternalSetMediaChangeState(FdoExtension, NewState, KnownStateChange);

    KeReleaseMutex(&info->MediaChangeMutex, FALSE);

    DBGTRACE(ClassDebugMCN, ("< ClasspSetMediaChangeStateEx"));

    return;
} // end ClassSetMediaChangeStateEx()
VOID
ClassSetMediaChangeState(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN MEDIA_CHANGE_DETECTION_STATE NewState,
    IN BOOLEAN Wait
    )
{
    ClasspSetMediaChangeStateEx(FdoExtension, NewState, Wait, FALSE);
    return;
}

/*++////////////////////////////////////////////////////////////////////////////

ClasspMediaChangeDetectionCompletion()

Routine Description:

    This routine handles the completion of the test unit ready irps used to
    determine if the media has changed.  If the media has changed, this code
    signals the named event to wake up other system services that react to
    media change (aka AutoPlay).

Arguments:

    DeviceObject - the object for the completion
    Irp - the IRP being completed
    Context - the SRB from the IRP

Return Value:

    NTSTATUS

--*/
NTSTATUS
ClasspMediaChangeDetectionCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PSCSI_REQUEST_BLOCK Srb
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    PCLASS_PRIVATE_FDO_DATA fdoData;
    PMEDIA_CHANGE_DETECTION_INFO info;
    PIO_STACK_LOCATION  nextIrpStack;
    NTSTATUS status;
    BOOLEAN retryImmediately = FALSE;

    //
    // Since the class driver created this request, it's completion routine
    // will not get a valid device object handed in.  Use the one in the
    // irp stack instead
    //

    DeviceObject = IoGetCurrentIrpStackLocation(Irp)->DeviceObject;
    fdoExtension = DeviceObject->DeviceExtension;
    fdoData = fdoExtension->PrivateFdoData;
    info         = fdoExtension->MediaChangeDetectionInfo;

    ASSERT(info->MediaChangeIrp != NULL);
    ASSERT(!TEST_FLAG(Srb->SrbStatus, SRB_STATUS_QUEUE_FROZEN));
    DBGTRACE(ClassDebugMCN, ("> ClasspMediaChangeDetectionCompletion: Device %p completed MCN irp %p.", DeviceObject, Irp));

    /*
     *  HACK for IoMega 2GB Jaz drive:
     *  This drive spins down on its own to preserve the media.  
     *  When spun down, TUR fails with 2/4/0 (SCSI_SENSE_NOT_READY/SCSI_ADSENSE_LUN_NOT_READY/?).
     *  ClassInterpretSenseInfo would then call ClassSendStartUnit to spin the media up, which defeats the
     *  purpose of the spindown.
     *  So in this case, make this into a successful TUR.  
     *  This allows the drive to stay spun down until it is actually accessed again.
     *  (If the media were actually removed, TUR would fail with 2/3a/0 ).
     *  This hack only applies to drives with the CAUSE_NOT_REPORTABLE_HACK bit set; this
     *  is set by disk.sys when HackCauseNotReportableHack is set for the drive in its BadControllers list.
     */
    if ((SRB_STATUS(Srb->SrbStatus) != SRB_STATUS_SUCCESS) &&
        TEST_FLAG(fdoExtension->ScanForSpecialFlags, CLASS_SPECIAL_CAUSE_NOT_REPORTABLE_HACK) &&
        (Srb->SenseInfoBufferLength >= RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseCode))){
        
        PSENSE_DATA senseData = Srb->SenseInfoBuffer;
        
        if ((senseData->SenseKey == SCSI_SENSE_NOT_READY) && 
            (senseData->AdditionalSenseCode == SCSI_ADSENSE_LUN_NOT_READY)){
            Srb->SrbStatus = SRB_STATUS_SUCCESS;
        }
    }       
        

    //
    // use ClassInterpretSenseInfo() to check for media state, and also
    // to call ClassError() with correct parameters.
    //
    status = STATUS_SUCCESS;
    if (SRB_STATUS(Srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        DBGTRACE(ClassDebugMCN, ("ClasspMediaChangeDetectionCompletion - failed - srb status=%s, sense=%s/%s/%s.", DBGGETSRBSTATUSSTR(Srb), DBGGETSENSECODESTR(Srb), DBGGETADSENSECODESTR(Srb), DBGGETADSENSEQUALIFIERSTR(Srb)));

        ClassInterpretSenseInfo(DeviceObject,
                                Srb,
                                IRP_MJ_SCSI,
                                0,
                                0,
                                &status,
                                NULL);

    } 
    else {
        
        fdoData->LoggedTURFailureSinceLastIO = FALSE;
        
        if (!info->Gesn.Supported) {

            DBGTRACE(ClassDebugMCN, ("ClasspMediaChangeDetectionCompletion - succeeded and GESN NOT supported, setting MediaPresent."));
        
            //
            // success != media for GESN case
            //

            ClassSetMediaChangeState(fdoExtension, MediaPresent, FALSE);

        }
        else {
            DBGTRACE(ClassDebugMCN, ("ClasspMediaChangeDetectionCompletion - succeeded (GESN supported)."));
        }
    }
    
    if (info->Gesn.Supported) {

        if (status == STATUS_DATA_OVERRUN) {
            DBGTRACE(ClassDebugMCN, ("ClasspMediaChangeDetectionCompletion - Overrun"));
            status = STATUS_SUCCESS;
        }

        if (!NT_SUCCESS(status)) {            
            DBGTRACE(ClassDebugMCN, ("ClasspMediaChangeDetectionCompletion: GESN failed with status %x", status));
        } else {

            //
            // for GESN, need to interpret the results of the data.
            // this may also require an immediate retry
            //
            
            if (Irp->IoStatus.Information == 8 ) {
                ClasspInterpretGesnData(fdoExtension,
                                        (PVOID)info->Gesn.Buffer,
                                        &retryImmediately);
            }

        } // end of NT_SUCCESS(status)

    } // end of Info->Gesn.Supported

    //
    // free port-allocated sense buffer, if any.
    //

    if (PORT_ALLOCATED_SENSE(fdoExtension, Srb)) {
        FREE_PORT_ALLOCATED_SENSE_BUFFER(fdoExtension, Srb);
    }

    //
    // Remember the IRP and SRB for use the next time.
    //

    ASSERT(IoGetNextIrpStackLocation(Irp));
    IoGetNextIrpStackLocation(Irp)->Parameters.Scsi.Srb = Srb;

    //
    // Reset the MCN timer.
    //

    ClassResetMediaChangeTimer(fdoExtension);

    //
    // run a sanity check to make sure we're not recursing continuously
    //

    if (retryImmediately) {
        
        info->MediaChangeRetryCount++;
        if (info->MediaChangeRetryCount > MAXIMUM_IMMEDIATE_MCN_RETRIES) {
            ASSERT(!"Recursing too often in MCN?");
            info->MediaChangeRetryCount = 0;
            retryImmediately = FALSE;
        }

    } else {
        
        info->MediaChangeRetryCount = 0;

    }


    //
    // release the remove lock....
    //

    {
        UCHAR uniqueValue;
        ClassAcquireRemoveLock(DeviceObject, (PIRP)(&uniqueValue));
        ClassReleaseRemoveLock(DeviceObject, Irp);

        
        //
        // set the irp as not in use
        //
        {
            volatile LONG irpWasInUse;
            irpWasInUse = InterlockedCompareExchange(&info->MediaChangeIrpInUse, 0, 1);
            #if _MSC_FULL_VER != 13009111        // This compiler always takes the wrong path here.
                ASSERT(irpWasInUse);
            #endif
        }

        //
        // now send it again before we release our last remove lock
        //

        if (retryImmediately) {
            ClasspSendMediaStateIrp(fdoExtension, info, 0);
        }
        else {
            DBGTRACE(ClassDebugMCN, ("ClasspMediaChangeDetectionCompletion - not retrying immediately"));
        }
        
        //
        // release the temporary remove lock
        //
        
        ClassReleaseRemoveLock(DeviceObject, (PIRP)(&uniqueValue));
    }

    DBGTRACE(ClassDebugMCN, ("< ClasspMediaChangeDetectionCompletion"));

    return STATUS_MORE_PROCESSING_REQUIRED;
} 

/*++////////////////////////////////////////////////////////////////////////////

ClasspSendTestUnitIrp() - ISSUE-2000/02/20-henrygab - not documented

Routine Description:

    This routine

Arguments:

    DeviceObject - 
    Irp - 

Return Value:


--*/
PIRP
ClasspPrepareMcnIrp(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PMEDIA_CHANGE_DETECTION_INFO Info,
    IN BOOLEAN UseGesn
)
{
    PSCSI_REQUEST_BLOCK srb;
    PIO_STACK_LOCATION irpStack;
    PIO_STACK_LOCATION nextIrpStack;
    NTSTATUS status;
    PCDB cdb;
    PIRP irp;
    PVOID buffer;

    //
    // Setup the IRP to perform a test unit ready.
    //

    irp = Info->MediaChangeIrp;

    ASSERT(irp);

    if (irp == NULL) {
        return NULL;
    }

    //
    // don't keep sending this if the device is being removed.
    //

    status = ClassAcquireRemoveLock(FdoExtension->DeviceObject, irp);
    if (status == REMOVE_COMPLETE) {
        ASSERT(status != REMOVE_COMPLETE);
        return NULL;
    } 
    else if (status == REMOVE_PENDING) {
        ClassReleaseRemoveLock(FdoExtension->DeviceObject, irp);
        return NULL;
    }
    else {
        ASSERT(status == NO_REMOVE);
    }

    irp->IoStatus.Status = STATUS_SUCCESS;
    irp->IoStatus.Information = 0;
    irp->Flags = 0;
    irp->UserBuffer = NULL;

    //
    // If the irp is sent down when the volume needs to be
    // verified, CdRomUpdateGeometryCompletion won't complete
    // it since it's not associated with a thread.  Marking
    // it to override the verify causes it always be sent
    // to the port driver
    //

    irpStack = IoGetCurrentIrpStackLocation(irp);
    irpStack->Flags |= SL_OVERRIDE_VERIFY_VOLUME;

    nextIrpStack = IoGetNextIrpStackLocation(irp);
    nextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextIrpStack->Parameters.Scsi.Srb = &(Info->MediaChangeSrb);

    //
    // Prepare the SRB for execution.
    //

    srb = nextIrpStack->Parameters.Scsi.Srb;
    buffer = srb->SenseInfoBuffer;
    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));
    RtlZeroMemory(buffer, SENSE_BUFFER_SIZE);


    srb->QueueTag = SP_UNTAGGED;
    srb->QueueAction = SRB_SIMPLE_TAG_REQUEST;
    srb->Length = sizeof(SCSI_REQUEST_BLOCK);
    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->SenseInfoBuffer = buffer;
    srb->SrbStatus = 0;
    srb->ScsiStatus = 0;
    srb->OriginalRequest = irp;
    srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;
    
    srb->SrbFlags = FdoExtension->SrbFlags;
    SET_FLAG(srb->SrbFlags, Info->SrbFlags);

    srb->TimeOutValue = FdoExtension->TimeOutValue * 2;
    
    if (srb->TimeOutValue == 0) {

        if (FdoExtension->TimeOutValue == 0) {

            KdPrintEx((DPFLTR_CLASSPNP_ID, DPFLTR_ERROR_LEVEL,
                       "ClassSendTestUnitIrp: FdoExtension->TimeOutValue "
                       "is set to zero?! -- resetting to 10\n"));
            srb->TimeOutValue = 10 * 2;  // reasonable default
        
        } else {
            
            KdPrintEx((DPFLTR_CLASSPNP_ID, DPFLTR_ERROR_LEVEL,
                       "ClassSendTestUnitIrp: Someone set "
                       "srb->TimeOutValue to zero?! -- resetting to %x\n",
                       FdoExtension->TimeOutValue * 2));
            srb->TimeOutValue = FdoExtension->TimeOutValue * 2;

        }

    }
    
    if (!UseGesn) {
        
        srb->CdbLength = 6;
        srb->DataTransferLength = 0;
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_DATA_TRANSFER);
        nextIrpStack->Parameters.DeviceIoControl.IoControlCode =
                IOCTL_SCSI_EXECUTE_NONE;
        srb->DataBuffer = NULL;
        srb->DataTransferLength = 0;
        irp->MdlAddress = NULL;
        
        cdb = (PCDB) &srb->Cdb[0];
        cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

    } else {
        
        ASSERT(Info->Gesn.Buffer);

        srb->TimeOutValue = GESN_TIMEOUT_VALUE; // much shorter timeout for GESN
        
        srb->CdbLength = 10;
        SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
        nextIrpStack->Parameters.DeviceIoControl.IoControlCode =
                IOCTL_SCSI_EXECUTE_IN;
        srb->DataBuffer = Info->Gesn.Buffer;
        srb->DataTransferLength = Info->Gesn.BufferSize;
        irp->MdlAddress = Info->Gesn.Mdl;

        cdb = (PCDB) &srb->Cdb[0];
        cdb->GET_EVENT_STATUS_NOTIFICATION.OperationCode =
            SCSIOP_GET_EVENT_STATUS;
        cdb->GET_EVENT_STATUS_NOTIFICATION.Immediate = 1;
        cdb->GET_EVENT_STATUS_NOTIFICATION.EventListLength[0] =
            (UCHAR)((Info->Gesn.BufferSize) >> 8);
        cdb->GET_EVENT_STATUS_NOTIFICATION.EventListLength[1] =
            (UCHAR)((Info->Gesn.BufferSize) & 0xff);
        cdb->GET_EVENT_STATUS_NOTIFICATION.NotificationClassRequest =
            Info->Gesn.EventMask;

    }

    IoSetCompletionRoutine(irp,
                           ClasspMediaChangeDetectionCompletion,
                           srb,
                           TRUE,
                           TRUE,
                           TRUE);

    return irp;

}

/*++////////////////////////////////////////////////////////////////////////////

ClasspSendMediaStateIrp() - ISSUE-2000/02/20-henrygab - not documented

Routine Description:

    This routine

Arguments:

    DeviceObject - 
    Irp - 

Return Value:

--*/
VOID
ClasspSendMediaStateIrp(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PMEDIA_CHANGE_DETECTION_INFO Info,
    IN ULONG CountDown
    )
{
    BOOLEAN requestPending = FALSE;
    LONG irpInUse;
    LARGE_INTEGER zero;
    NTSTATUS status;

    DBGTRACE(ClassDebugMCN, ("> ClasspSendMediaStateIrp"));

    if (((FdoExtension->CommonExtension.CurrentState != IRP_MN_START_DEVICE) ||
         (FdoExtension->DevicePowerState != PowerDeviceD0)
         ) &&
        (!Info->MediaChangeIrpLost)) {

        //
        // the device may be stopped, powered down, or otherwise queueing io,
        // so should not timeout the autorun irp (yet) -- set to zero ticks.
        // scattered code relies upon this to not prematurely "lose" an
        // autoplay irp that was queued.
        //

        Info->MediaChangeIrpTimeInUse = 0;
    }

    //
    // if the irp is not in use, mark it as such.
    //

    irpInUse = InterlockedCompareExchange(&Info->MediaChangeIrpInUse, 1, 0);

    if (irpInUse) {

        LONG timeInUse;

        timeInUse = InterlockedIncrement(&Info->MediaChangeIrpTimeInUse);

        DebugPrint((ClassDebugMCN, "ClasspSendMediaStateIrp: irp in use for "
                    "%x seconds when synchronizing for MCD\n", timeInUse));

        if (Info->MediaChangeIrpLost == FALSE) {

            if (timeInUse > MEDIA_CHANGE_TIMEOUT_TIME) {

                //
                // currently set to five minutes.  hard to imagine a drive
                // taking that long to spin up.
                //

                DebugPrint((ClassDebugError,
                            "CdRom%d: Media Change Notification has lost "
                            "it's irp and doesn't know where to find it.  "
                            "Leave it alone and it'll come home dragging "
                            "it's stack behind it.\n",
                            FdoExtension->DeviceNumber));
                Info->MediaChangeIrpLost = TRUE;
            }
        }

        DBGTRACE(ClassDebugMCN, ("< ClasspSendMediaStateIrp - irpInUse"));
        return;

    }

    TRY {

        if (Info->MediaChangeDetectionDisableCount != 0) {
            DebugPrint((ClassDebugTrace, "ClassCheckMediaState: device %p has "
                        " detection disabled \n", FdoExtension->DeviceObject));
            LEAVE;
        }

        if (FdoExtension->DevicePowerState != PowerDeviceD0) {

            if (TEST_FLAG(Info->SrbFlags, SRB_FLAGS_NO_KEEP_AWAKE)) {
                DebugPrint((ClassDebugMCN,
                            "ClassCheckMediaState: device %p is powered "
                            "down and flags are set to let it sleep\n",
                            FdoExtension->DeviceObject));
                ClassResetMediaChangeTimer(FdoExtension);
                LEAVE;
            }

            //
            // NOTE: we don't increment the time in use until our power state
            // changes above.  this way, we won't "lose" the autoplay irp.
            // it's up to the lower driver to determine if powering up is a
            // good idea.
            //

            DebugPrint((ClassDebugMCN,
                        "ClassCheckMediaState: device %p needs to powerup "
                        "to handle this io (may take a few extra seconds).\n",
                        FdoExtension->DeviceObject));

        }

        Info->MediaChangeIrpTimeInUse = 0;
        Info->MediaChangeIrpLost = FALSE;

        if (CountDown == 0) {

            PIRP irp;

            DebugPrint((ClassDebugTrace,
                        "ClassCheckMediaState: timer expired\n"));

            if (Info->MediaChangeDetectionDisableCount != 0) {
                DebugPrint((ClassDebugTrace,
                            "ClassCheckMediaState: detection disabled\n"));
                LEAVE;
            }

            //
            // Prepare the IRP for the test unit ready
            //

            irp = ClasspPrepareMcnIrp(FdoExtension,
                                      Info,
                                      Info->Gesn.Supported);

            //
            // Issue the request.
            //

            DebugPrint((ClassDebugTrace,
                        "ClasspSendMediaStateIrp: Device %p getting TUR "
                        " irp %p\n", FdoExtension->DeviceObject, irp));

            if (irp == NULL) {
                LEAVE;
            }


            //
            // note: if we send it to the class dispatch routines, there is
            //       a timing window here (since they grab the remove lock)
            //       where we'd be removed. ELIMINATE the window by grabbing
            //       the lock ourselves above and sending it to the lower
            //       device object directly or to the device's StartIo
            //       routine (which doesn't acquire the lock).
            //
            
            requestPending = TRUE;

            DBGTRACE(ClassDebugMCN, ("  ClasspSendMediaStateIrp - calling IoCallDriver."));
            IoCallDriver(FdoExtension->CommonExtension.LowerDeviceObject, irp);
        }

    } FINALLY {

        if(requestPending == FALSE) {
            irpInUse = InterlockedCompareExchange(&Info->MediaChangeIrpInUse, 0, 1);
            #if _MSC_FULL_VER != 13009111        // This compiler always takes the wrong path here.
                ASSERT(irpInUse);
            #endif
        }

    }

    DBGTRACE(ClassDebugMCN, ("< ClasspSendMediaStateIrp"));
    
    return;
} // end ClasspSendMediaStateIrp()

/*++////////////////////////////////////////////////////////////////////////////

ClassCheckMediaState()

Routine Description:

    This routine is called by the class driver to test for a media change
    condition and/or poll for disk failure prediction.  It should be called
    from the class driver's IO timer routine once per second.

Arguments:

    FdoExtension - the device extension

Return Value:

    none

--*/
VOID
ClassCheckMediaState(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
{
    PMEDIA_CHANGE_DETECTION_INFO info = FdoExtension->MediaChangeDetectionInfo;
    LONG countDown;

    if(info == NULL) {
        DebugPrint((ClassDebugTrace,
                    "ClassCheckMediaState: detection not enabled\n"));
        return;
    }

    //
    // Media change support is active and the IRP is waiting. Decrement the
    // timer.  There is no MP protection on the timer counter.  This code
    // is the only code that will manipulate the timer counter and only one
    // instance of it should be running at any given time.
    //

    countDown = InterlockedDecrement(&(info->MediaChangeCountDown));

    //
    // Try to acquire the media change event.  If we can't do it immediately
    // then bail out and assume the caller will try again later.
    //
    ClasspSendMediaStateIrp(FdoExtension,
                            info,
                            countDown);

    return;
} // end ClassCheckMediaState()

/*++////////////////////////////////////////////////////////////////////////////

ClassResetMediaChangeTimer()

Routine Description:

    Resets the media change count down timer to the default number of seconds.
    
Arguments:

    FdoExtension - the device to reset the timer for

Return Value:

    None

--*/
VOID
ClassResetMediaChangeTimer(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
{
    PMEDIA_CHANGE_DETECTION_INFO info = FdoExtension->MediaChangeDetectionInfo;

    if(info != NULL) {
        InterlockedExchange(&(info->MediaChangeCountDown),
                            MEDIA_CHANGE_DEFAULT_TIME);
    }
    return;
} // end ClassResetMediaChangeTimer()

/*++////////////////////////////////////////////////////////////////////////////

ClasspInitializePolling() - ISSUE-2000/02/20-henrygab - not documented

Routine Description:

    This routine

Arguments:

    DeviceObject - 
    Irp - 

Return Value:

--*/
NTSTATUS
ClasspInitializePolling(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN BOOLEAN AllowDriveToSleep
    )
{
    PDEVICE_OBJECT fdo = FdoExtension->DeviceObject;
    PCLASS_PRIVATE_FDO_DATA fdoData = FdoExtension->PrivateFdoData;

    ULONG size;
    PMEDIA_CHANGE_DETECTION_INFO info;
    PIRP irp;

    PAGED_CODE();

    if (FdoExtension->MediaChangeDetectionInfo != NULL) {
        return STATUS_SUCCESS;
    }

    info = ExAllocatePoolWithTag(NonPagedPool,
                                 sizeof(MEDIA_CHANGE_DETECTION_INFO),
                                 CLASS_TAG_MEDIA_CHANGE_DETECTION);

    if(info != NULL) {
        RtlZeroMemory(info, sizeof(MEDIA_CHANGE_DETECTION_INFO));

        FdoExtension->KernelModeMcnContext.FileObject      = (PVOID)-1;
        FdoExtension->KernelModeMcnContext.DeviceObject    = (PVOID)-1;
        FdoExtension->KernelModeMcnContext.LockCount       = 0;
        FdoExtension->KernelModeMcnContext.McnDisableCount = 0;

        /*
         *  Allocate an IRP to carry the Test-Unit-Ready.
         *  Allocate an extra IRP stack location 
         *  so we can cache our device object in the top location.
         */
        irp = IoAllocateIrp((CCHAR)(fdo->StackSize+1), FALSE);
        
        if (irp != NULL) {

            PVOID buffer;

            buffer = ExAllocatePoolWithTag(
                        NonPagedPoolCacheAligned,
                        SENSE_BUFFER_SIZE,
                        CLASS_TAG_MEDIA_CHANGE_DETECTION);

            if (buffer != NULL) {
                PIO_STACK_LOCATION irpStack;
                PSCSI_REQUEST_BLOCK srb;
                PCDB cdb;

                srb = &(info->MediaChangeSrb);
                info->MediaChangeIrp = irp;
                info->SenseBuffer = buffer;

                /*
                 *  For the driver that creates an IRP, there is no 'current' stack location.
                 *  Step down one IRP stack location so that the extra top one
                 *  becomes our 'current' one.
                 */
                IoSetNextIrpStackLocation(irp);

                /*
                 *  Cache our device object in the extra top IRP stack location
                 *  so we have it in our completion routine.
                 */
                irpStack = IoGetCurrentIrpStackLocation(irp);
                irpStack->DeviceObject = fdo;

                /*
                 *  Now start setting up the next IRP stack location for the call like any driver would.
                 */
                irpStack = IoGetNextIrpStackLocation(irp);
                irpStack->Parameters.Scsi.Srb = srb;
                info->MediaChangeIrp = irp;

                //
                // Initialize the SRB
                //

                RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

                //
                // Initialize and set up the sense information buffer
                //

                RtlZeroMemory(buffer, SENSE_BUFFER_SIZE);
                srb->SenseInfoBuffer = buffer;
                srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

                //
                // Set default values for the media change notification
                // configuration.
                //

                info->MediaChangeCountDown = MEDIA_CHANGE_DEFAULT_TIME;
                info->MediaChangeDetectionDisableCount = 0;

                //
                // Assume that there is initially no media in the device
                // only notify upper layers if there is something there
                //

                info->MediaChangeDetectionState = MediaUnknown;

                info->MediaChangeIrpTimeInUse = 0;
                info->MediaChangeIrpLost = FALSE;

                //
                // setup all extra flags we'll be setting for this irp
                //
                info->SrbFlags = 0;
                if (AllowDriveToSleep) {
                    SET_FLAG(info->SrbFlags, SRB_FLAGS_NO_KEEP_AWAKE);
                }
                SET_FLAG(info->SrbFlags, SRB_CLASS_FLAGS_LOW_PRIORITY);
                SET_FLAG(info->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE);
                SET_FLAG(info->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);

                KeInitializeMutex(&info->MediaChangeMutex, 0x100);

                //
                // It is ok to support media change events on this
                // device.
                //

                FdoExtension->MediaChangeDetectionInfo = info;

                //
                // NOTE: the DeviceType is FILE_DEVICE_CD_ROM even
                //       when the device supports DVD (no need to
                //       check for FILE_DEVICE_DVD, as it's not a
                //       valid check).
                //

                if (FdoExtension->DeviceObject->DeviceType == FILE_DEVICE_CD_ROM){

                    NTSTATUS status;

                    KdPrintEx((DPFLTR_CLASSPNP_ID, ClassDebugMCN,
                               "ClasspInitializePolling: Testing for GESN\n"));
                    status = ClasspInitializeGesn(FdoExtension, info);
                    if (NT_SUCCESS(status)) {
                        KdPrintEx((DPFLTR_CLASSPNP_ID, ClassDebugMCN,
                                   "ClasspInitializePolling: GESN available "
                                   "for %p\n", FdoExtension->DeviceObject));
                        ASSERT(info->Gesn.Supported );
                        ASSERT(info->Gesn.Buffer     != NULL);
                        ASSERT(info->Gesn.BufferSize != 0);
                        ASSERT(info->Gesn.EventMask  != 0);
                        // must return here, for ASSERTs to be valid.
                        return STATUS_SUCCESS;
                    }
                    KdPrintEx((DPFLTR_CLASSPNP_ID, ClassDebugMCN,
                               "ClasspInitializePolling: GESN *NOT* available "
                               "for %p\n", FdoExtension->DeviceObject));
                }
                
                ASSERT(info->Gesn.Supported == 0);
                ASSERT(info->Gesn.Buffer == NULL);
                ASSERT(info->Gesn.BufferSize == 0);
                ASSERT(info->Gesn.EventMask  == 0);
                info->Gesn.Supported = 0; // just in case....
                return STATUS_SUCCESS;
            }

            IoFreeIrp(irp);
        }

        ExFreePool(info);
    }

    //
    // nothing to free here
    //
    return STATUS_INSUFFICIENT_RESOURCES;

} // end ClasspInitializePolling()

NTSTATUS
ClasspInitializeGesn(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PMEDIA_CHANGE_DETECTION_INFO Info
    )
{    
    PNOTIFICATION_EVENT_STATUS_HEADER header;
    CLASS_DETECTION_STATE detectionState = ClassDetectionUnknown;
    PSTORAGE_ADAPTER_DESCRIPTOR adapterDescriptor;
    NTSTATUS status = STATUS_NOT_SUPPORTED;
    PIRP irp;
    KEVENT event;
    BOOLEAN retryImmediately;
    ULONG i;
    ULONG atapiResets;

    
    PAGED_CODE();
    ASSERT(Info == FdoExtension->MediaChangeDetectionInfo);

    //
    // read if we already know the abilities of the device
    //

    ClassGetDeviceParameter(FdoExtension,
                            CLASSP_REG_SUBKEY_NAME,
                            CLASSP_REG_MMC_DETECTION_VALUE_NAME,
                            (PULONG)&detectionState);
    
    if (detectionState == ClassDetectionUnsupported) {
        goto ExitWithError;
    }

    //
    // check if the device has a hack flag saying never to try this.
    //

    if (TEST_FLAG(FdoExtension->PrivateFdoData->HackFlags,
                  FDO_HACK_GESN_IS_BAD)) {
        
        detectionState = ClassDetectionUnsupported;
        ClassSetDeviceParameter(FdoExtension,
                                CLASSP_REG_SUBKEY_NAME,
                                CLASSP_REG_MMC_DETECTION_VALUE_NAME,
                                ClassDetectionSupported);
        goto ExitWithError;

    }


    //
    // else go through the process since we allocate buffers and 
    // get all sorts of device settings.
    //

    if (Info->Gesn.Buffer == NULL) {
        Info->Gesn.Buffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                                  GESN_BUFFER_SIZE,
                                                  '??cS');
    }
    if (Info->Gesn.Buffer == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ExitWithError;
    }
    if (Info->Gesn.Mdl != NULL) {
        IoFreeMdl(Info->Gesn.Mdl);
    }
    Info->Gesn.Mdl = IoAllocateMdl(Info->Gesn.Buffer,
                                   GESN_BUFFER_SIZE,
                                   FALSE, FALSE, NULL);
    if (Info->Gesn.Mdl == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ExitWithError;
    }

    MmBuildMdlForNonPagedPool(Info->Gesn.Mdl);
    Info->Gesn.BufferSize = GESN_BUFFER_SIZE;
    Info->Gesn.EventMask = 0;

    //
    // all items are prepared to use GESN (except the event mask, so don't
    // optimize this part out!).
    //
    // now see if it really works. we have to loop through this because
    // many SAMSUNG (and one COMPAQ) drives timeout when requesting
    // NOT_READY events, even when the IMMEDIATE bit is set. :(
    //
    // using a drive list is cumbersome, so this might fix the problem.
    //

    adapterDescriptor = FdoExtension->AdapterDescriptor;
    atapiResets = 0;
    retryImmediately = TRUE;
    for (i = 0; i < 16 && retryImmediately == TRUE; i++) {
    
        irp = ClasspPrepareMcnIrp(FdoExtension, Info, TRUE);
        if (irp == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ExitWithError;
        }

        ASSERT(TEST_FLAG(Info->MediaChangeSrb.SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE));
    
        //
        // replace the completion routine with a different one this time...
        //
    
        IoSetCompletionRoutine(irp,
                               ClassSignalCompletion,
                               &event,
                               TRUE, TRUE, TRUE);
        KeInitializeEvent(&event, SynchronizationEvent, FALSE);
    
        status = IoCallDriver(FdoExtension->CommonExtension.LowerDeviceObject, irp);
    
        if (status == STATUS_PENDING) {
            status = KeWaitForSingleObject(&event,
                                           Executive,
                                           KernelMode,
                                           FALSE,
                                           NULL);
            ASSERT(NT_SUCCESS(status));
        }
        ClassReleaseRemoveLock(FdoExtension->DeviceObject, irp);
    
        if (SRB_STATUS(Info->MediaChangeSrb.SrbStatus) != SRB_STATUS_SUCCESS) {
            ClassInterpretSenseInfo(FdoExtension->DeviceObject,
                                    &(Info->MediaChangeSrb),
                                    IRP_MJ_SCSI,
                                    0,
                                    0,
                                    &status,
                                    NULL);
        }

        if ((adapterDescriptor->BusType == BusTypeAtapi) &&
            (Info->MediaChangeSrb.SrbStatus == SRB_STATUS_BUS_RESET)
            ) {

            //
            // ATAPI unfortunately returns SRB_STATUS_BUS_RESET instead
            // of SRB_STATUS_TIMEOUT, so we cannot differentiate between
            // the two.  if we get this status four time consecutively,
            // stop trying this command.  it is too late to change ATAPI
            // at this point, so special-case this here. (07/10/2001)
            // NOTE: any value more than 4 may cause the device to be
            //       marked missing.
            //

            atapiResets++;
            if (atapiResets >= 4) {
                status = STATUS_IO_DEVICE_ERROR;
                goto ExitWithError;
            }
        }

        if (status == STATUS_DATA_OVERRUN) {
            status = STATUS_SUCCESS;
        }
    
        if ((status == STATUS_INVALID_DEVICE_REQUEST) ||
            (status == STATUS_TIMEOUT) ||
            (status == STATUS_IO_DEVICE_ERROR) ||
            (status == STATUS_IO_TIMEOUT)
            ) {
    
            //
            // with these error codes, we don't ever want to try this command
            // again on this device, since it reacts poorly.
            //
    
            ClassSetDeviceParameter(FdoExtension,
                                    CLASSP_REG_SUBKEY_NAME,
                                    CLASSP_REG_MMC_DETECTION_VALUE_NAME,
                                    ClassDetectionUnsupported);
            KdPrintEx((DPFLTR_CLASSPNP_ID, ClassDebugWarning,
                       "Classpnp => GESN test failed %x for fdo %p\n",
                       status, FdoExtension->DeviceObject));
            goto ExitWithError;

    
        }
    
        if (!NT_SUCCESS(status)) {

            //
            // this may be other errors that should not disable GESN
            // for all future start_device calls.
            //

            KdPrintEx((DPFLTR_CLASSPNP_ID, ClassDebugWarning,
                       "Classpnp => GESN test failed %x for fdo %p\n",
                       status, FdoExtension->DeviceObject));
            goto ExitWithError;
        }
    
        if (i == 0) {

            //
            // the first time, the request was just retrieving a mask of
            // available bits.  use this to mask future requests.
            //
        
            header = (PNOTIFICATION_EVENT_STATUS_HEADER)(Info->Gesn.Buffer);
            
            KdPrintEx((DPFLTR_CLASSPNP_ID, ClassDebugMCN,
                       "Classpnp => Fdo %p supports event mask %x\n",
                       FdoExtension->DeviceObject, header->SupportedEventClasses));
            
        
            if (TEST_FLAG(header->SupportedEventClasses,
                          NOTIFICATION_MEDIA_STATUS_CLASS_MASK)) {
                KdPrintEx((DPFLTR_CLASSPNP_ID, ClassDebugMCN,
                           "Classpnp => GESN supports MCN\n"));
            }
            if (TEST_FLAG(header->SupportedEventClasses,
                          NOTIFICATION_DEVICE_BUSY_CLASS_MASK)) {
                KdPrintEx((DPFLTR_CLASSPNP_ID, ClassDebugMCN,
                           "Classpnp => GESN supports DeviceBusy\n"));
            }
            Info->Gesn.EventMask = header->SupportedEventClasses;

            //
            // realistically, we are only considering the following events:
            //    EXTERNAL REQUEST - this is being tested for play/stop/etc.
            //    MEDIA STATUS - autorun and ejection requests.
            //    DEVICE BUSY - to allow us to predict when media will be ready.
            // therefore, we should not bother querying for the other,
            // unknown events. clear all but the above flags.
            //
        
            Info->Gesn.EventMask &=
                NOTIFICATION_EXTERNAL_REQUEST_CLASS_MASK |
                NOTIFICATION_MEDIA_STATUS_CLASS_MASK     |
                NOTIFICATION_DEVICE_BUSY_CLASS_MASK      ;
        
        
            //
            // HACKHACK - REF #0001
            // Some devices will *never* report an event if we've also requested
            // that it report lower-priority events.  this is due to a
            // misunderstanding in the specification wherein a "No Change" is
            // interpreted to be a real event.  what should occur is that the
            // device should ignore "No Change" events when multiple event types
            // are requested unless there are no other events waiting.  this
            // greatly reduces the number of requests that the host must send
            // to determine if an event has occurred. Since we must work on all
            // drives, default to enabling the hack until we find evidence of
            // proper firmware.
            //
        
            if (CountOfSetBitsUChar(Info->Gesn.EventMask) == 1) {
                KdPrintEx((DPFLTR_CLASSPNP_ID, ClassDebugMCN,
                           "Classpnp => GESN hack %s for FDO %p\n",
                           "not required", FdoExtension->DeviceObject));
            } else {
                KdPrintEx((DPFLTR_CLASSPNP_ID, ClassDebugMCN,
                           "Classpnp => GESN hack %s for FDO %p\n",
                           "enabled", FdoExtension->DeviceObject));
                Info->Gesn.HackEventMask = 1;
            }

        } else {
            
            //
            // not the first time looping through, so interpret the results.
            //

            ClasspInterpretGesnData(FdoExtension,
                                    (PVOID)Info->Gesn.Buffer,
                                    &retryImmediately);

        }

    } // end loop of GESN requests....

    //
    // we can only use this if it can be relied upon for media changes,
    // since we are (by definition) no longer going to be polling via
    // a TEST_UNIT_READY irp, and drives will not report UNIT ATTENTION
    // for this command (although a filter driver, such as one for burning
    // cd's, might still fake those errors).
    //
    // since we also rely upon NOT_READY events to change the cursor
    // into a "wait" cursor, we can't use GESN without NOT_READY support.
    //
    
    if (TEST_FLAG(Info->Gesn.EventMask,
                  NOTIFICATION_MEDIA_STATUS_CLASS_MASK) &&
        TEST_FLAG(Info->Gesn.EventMask,
                  NOTIFICATION_DEVICE_BUSY_CLASS_MASK)
        ) {
        
        KdPrintEx((DPFLTR_CLASSPNP_ID, ClassDebugMCN,
                   "Classpnp => Enabling GESN support for fdo %p\n",
                   FdoExtension->DeviceObject));
        Info->Gesn.Supported = TRUE;

        ClassSetDeviceParameter(FdoExtension,
                                CLASSP_REG_SUBKEY_NAME,
                                CLASSP_REG_MMC_DETECTION_VALUE_NAME,
                                ClassDetectionSupported);

        return STATUS_SUCCESS;

    }
    
    KdPrintEx((DPFLTR_CLASSPNP_ID, ClassDebugMCN,
               "Classpnp => GESN available but not enabled for fdo %p\n",
               FdoExtension->DeviceObject));
    goto ExitWithError;

    // fall through...

ExitWithError:
    if (Info->Gesn.Mdl) {
        IoFreeMdl(Info->Gesn.Mdl);
        Info->Gesn.Mdl = NULL;
    }
    if (Info->Gesn.Buffer) {
        ExFreePool(Info->Gesn.Buffer);
        Info->Gesn.Buffer = NULL;
    }
    Info->Gesn.Supported  = 0;
    Info->Gesn.EventMask  = 0;
    Info->Gesn.BufferSize = 0;
    return STATUS_NOT_SUPPORTED;

}

/*++////////////////////////////////////////////////////////////////////////////

ClassInitializeTestUnitPolling()

Routine Description:

    This routine will initialize MCN regardless of the settings stored
    in the registry.  This should be used with caution, as some devices
    react badly to constant io. (i.e. never spin down, continuously cycling
    media in changers, ejection of media, etc.)  It is highly suggested to
    use ClassInitializeMediaChangeDetection() instead.

Arguments:

    FdoExtension is the device to poll
    
    AllowDriveToSleep says whether to attempt to allow the drive to sleep
        or not.  This only affects system-known spin down states, so if a 
        drive spins itself down, this has no effect until the system spins
        it down.

Return Value:

--*/
NTSTATUS
ClassInitializeTestUnitPolling(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN BOOLEAN AllowDriveToSleep
    )
{
    return ClasspInitializePolling(FdoExtension, AllowDriveToSleep);
} // end ClassInitializeTestUnitPolling()

/*++////////////////////////////////////////////////////////////////////////////

ClassInitializeMediaChangeDetection()

Routine Description:

    This routine checks to see if it is safe to initialize MCN (the back end
    to autorun) for a given device.  It will then check the device-type wide
    key "Autorun" in the service key (for legacy reasons), and then look in
    the device-specific key to potentially override that setting.
    
    If MCN is to be enabled, all neccessary structures and memory are
    allocated and initialized.
    
    This routine MUST be called only from the ClassInit() callback.

Arguments:

    FdoExtension - the device to initialize MCN for, if appropriate
    
    EventPrefix - unused, legacy argument.  Set to zero.

Return Value:

--*/
VOID
ClassInitializeMediaChangeDetection(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PUCHAR EventPrefix
    )
{
    PDEVICE_OBJECT fdo = FdoExtension->DeviceObject;
    NTSTATUS status;

    PCLASS_DRIVER_EXTENSION driverExtension = ClassGetDriverExtension(
                                                fdo->DriverObject);

    BOOLEAN disabledForBadHardware;
    BOOLEAN disabled;
    BOOLEAN instanceOverride;

    PAGED_CODE();

    //
    // NOTE: This assumes that ClassInitializeMediaChangeDetection is always
    //       called in the context of the ClassInitDevice callback. If called
    //       after then this check will have already been made and the
    //       once a second timer will not have been enabled.
    //

    disabledForBadHardware = ClasspIsMediaChangeDisabledDueToHardwareLimitation(
                                FdoExtension,
                                &(driverExtension->RegistryPath)
                                );

    if (disabledForBadHardware) {
        DebugPrint((ClassDebugMCN,
                    "ClassInitializeMCN: Disabled due to hardware"
                    "limitations for this device"));
        return;
    }

    //
    // autorun should now be enabled by default for all media types.
    //

    disabled = ClasspIsMediaChangeDisabledForClass(
                    FdoExtension,
                    &(driverExtension->RegistryPath)
                    );

    DebugPrint((ClassDebugMCN,
                "ClassInitializeMCN: Class    MCN is %s\n",
                (disabled ? "disabled" : "enabled")));

    status = ClasspMediaChangeDeviceInstanceOverride(
                FdoExtension,
                &instanceOverride);  // default value

    if (!NT_SUCCESS(status)) {
        DebugPrint((ClassDebugMCN,
                    "ClassInitializeMCN: Instance using default\n"));
    } else {
        DebugPrint((ClassDebugMCN,
                    "ClassInitializeMCN: Instance override: %s MCN\n",
                    (instanceOverride ? "Enabling" : "Disabling")));
        disabled = !instanceOverride;
    }

    DebugPrint((ClassDebugMCN,
                "ClassInitializeMCN: Instance MCN is %s\n",
                (disabled ? "disabled" : "enabled")));

    if (disabled) {
        return;
    }
    
    //
    // if the drive is not a CDROM, allow the drive to sleep
    //
    if (FdoExtension->DeviceObject->DeviceType == FILE_DEVICE_CD_ROM) {
        ClasspInitializePolling(FdoExtension, FALSE);
    } else {
        ClasspInitializePolling(FdoExtension, TRUE);
    }

    return;
} // end ClassInitializeMediaChangeDetection()

/*++////////////////////////////////////////////////////////////////////////////

ClasspMediaChangeDeviceInstanceOverride()

Routine Description:

    The user can override the global setting to enable or disable Autorun on a
    specific cdrom device via the control panel.  This routine checks and/or
    sets this value.

Arguments:

    FdoExtension - the device to set/get the value for
    Value        - the value to use in a set
    SetValue     - whether to set the value

Return Value:

    TRUE - Autorun is disabled
    FALSE - Autorun is not disabled (Default)

--*/
NTSTATUS
ClasspMediaChangeDeviceInstanceOverride(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    OUT PBOOLEAN Enabled
    )
{
    HANDLE                   deviceParameterHandle;  // cdrom instance key
    HANDLE                   driverParameterHandle;  // cdrom specific key
    RTL_QUERY_REGISTRY_TABLE queryTable[3];
    OBJECT_ATTRIBUTES        objectAttributes;
    UNICODE_STRING           subkeyName;
    NTSTATUS                 status;
    ULONG                    alwaysEnable;
    ULONG                    alwaysDisable;
    ULONG                    i;


    PAGED_CODE();

    deviceParameterHandle = NULL;
    driverParameterHandle = NULL;
    status = STATUS_UNSUCCESSFUL;
    alwaysEnable = FALSE;
    alwaysDisable = FALSE;

    TRY {

        status = IoOpenDeviceRegistryKey( FdoExtension->LowerPdo,
                                          PLUGPLAY_REGKEY_DEVICE,
                                          KEY_ALL_ACCESS,
                                          &deviceParameterHandle
                                          );
        if (!NT_SUCCESS(status)) {

            //
            // this can occur when a new device is added to the system
            // this is due to cdrom.sys being an 'essential' driver
            //
            DebugPrint((ClassDebugMCN,
                        "ClassMediaChangeDeviceInstanceDisabled: "
                        "Could not open device registry key [%lx]\n", status));
            LEAVE;
        }

        RtlInitUnicodeString(&subkeyName, MCN_REG_SUBKEY_NAME);
        InitializeObjectAttributes(&objectAttributes,
                                   &subkeyName,
                                   OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                   deviceParameterHandle,
                                   (PSECURITY_DESCRIPTOR) NULL);

        status = ZwCreateKey(&driverParameterHandle,
                             KEY_READ,
                             &objectAttributes,
                             0,
                             (PUNICODE_STRING) NULL,
                             REG_OPTION_NON_VOLATILE,
                             NULL);

        if (!NT_SUCCESS(status)) {
            DebugPrint((ClassDebugMCN,
                        "ClassMediaChangeDeviceInstanceDisabled: "
                        "subkey could not be created. %lx\n", status));
            LEAVE;
        }

        //
        // Default to not changing autorun behavior, based upon setting
        // registryValue to zero.
        //

        for (i=0;i<2;i++) {

            RtlZeroMemory(&queryTable[0], sizeof(queryTable));

            queryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
            queryTable[0].DefaultType   = REG_DWORD;
            queryTable[0].DefaultLength = 0;

            if (i==0) {
                queryTable[0].Name          = MCN_REG_AUTORUN_DISABLE_INSTANCE_NAME;
                queryTable[0].EntryContext  = &alwaysDisable;
                queryTable[0].DefaultData   = &alwaysDisable;
            } else {
                queryTable[0].Name          = MCN_REG_AUTORUN_ENABLE_INSTANCE_NAME;
                queryTable[0].EntryContext  = &alwaysEnable;
                queryTable[0].DefaultData   = &alwaysEnable;
            }

            //
            // don't care if it succeeds, since we set defaults above
            //

            RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                   (PWSTR)driverParameterHandle,
                                   queryTable,
                                   NULL,
                                   NULL);
        }

    } FINALLY {

        if (driverParameterHandle) ZwClose(driverParameterHandle);
        if (deviceParameterHandle) ZwClose(deviceParameterHandle);

    }

    if (alwaysEnable && alwaysDisable) {

        DebugPrint((ClassDebugMCN,
                    "ClassMediaChangeDeviceInstanceDisabled: %s selected\n",
                    "Both Enable and Disable set -- DISABLE"));
        ASSERT(NT_SUCCESS(status));
        status = STATUS_SUCCESS;
        *Enabled = FALSE;

    } else if (alwaysDisable) {

        DebugPrint((ClassDebugMCN,
                    "ClassMediaChangeDeviceInstanceDisabled: %s selected\n",
                    "DISABLE"));
        ASSERT(NT_SUCCESS(status));
        status = STATUS_SUCCESS;
        *Enabled = FALSE;

    } else if (alwaysEnable) {

        DebugPrint((ClassDebugMCN,
                    "ClassMediaChangeDeviceInstanceDisabled: %s selected\n",
                    "ENABLE"));
        ASSERT(NT_SUCCESS(status));
        status = STATUS_SUCCESS;
        *Enabled = TRUE;

    } else {

        DebugPrint((ClassDebugMCN,
                    "ClassMediaChangeDeviceInstanceDisabled: %s selected\n",
                    "DEFAULT"));
        status = STATUS_UNSUCCESSFUL;

    }

    return status;

} // end ClasspMediaChangeDeviceInstanceOverride()

/*++////////////////////////////////////////////////////////////////////////////

ClasspIsMediaChangeDisabledDueToHardwareLimitation()

Routine Description:

    The key AutoRunAlwaysDisable contains a MULTI_SZ of hardware IDs for
    which to never enable MediaChangeNotification.

    The user can override the global setting to enable or disable Autorun on a
    specific cdrom device via the control panel.

Arguments:

    FdoExtension -
    RegistryPath - pointer to the unicode string inside
                   ...\CurrentControlSet\Services\Cdrom

Return Value:

    TRUE - no autorun.
    FALSE - Autorun may be enabled

--*/
BOOLEAN
ClasspIsMediaChangeDisabledDueToHardwareLimitation(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PUNICODE_STRING RegistryPath
    )
{
    PSTORAGE_DEVICE_DESCRIPTOR deviceDescriptor = FdoExtension->DeviceDescriptor;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE serviceKey = NULL;
    RTL_QUERY_REGISTRY_TABLE parameters[2];

    UNICODE_STRING deviceUnicodeString;
    ANSI_STRING deviceString;
    ULONG mediaChangeNotificationDisabled = FALSE;

    NTSTATUS status;


    PAGED_CODE();

    //
    // open the service key.
    //

    InitializeObjectAttributes(&objectAttributes,
                               RegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = ZwOpenKey(&serviceKey,
                       KEY_READ,
                       &objectAttributes);

    ASSERT(NT_SUCCESS(status));


    if(!NT_SUCCESS(status)) {

        //
        // always take the safe path.  if we can't open the service key,
        // disable autorun
        //

        return TRUE;

    }

    TRY {
        //
        // Determine if drive is in a list of those requiring
        // autorun to be disabled.  this is stored in a REG_MULTI_SZ
        // named AutoRunAlwaysDisable.  this is required as some autochangers
        // must load the disc to reply to ChkVerify request, causing them
        // to cycle discs continuously.
        //

        PWSTR nullMultiSz;
        PUCHAR vendorId;
        PUCHAR productId;
        PUCHAR revisionId;
        ULONG  length;
        ULONG  offset;

        deviceString.Buffer        = NULL;
        deviceUnicodeString.Buffer = NULL;

        //
        // there may be nothing to check against
        //

        if ((deviceDescriptor->VendorIdOffset == 0) &&
            (deviceDescriptor->ProductIdOffset == 0)) {
            LEAVE;
        }

        length = 0;

        if (deviceDescriptor->VendorIdOffset == 0) {
            vendorId = NULL;
        } else {
            vendorId = (PUCHAR) deviceDescriptor + deviceDescriptor->VendorIdOffset;
            length = strlen(vendorId);
        }

        if ( deviceDescriptor->ProductIdOffset == 0 ) {
            productId = NULL;
        } else {
            productId = (PUCHAR) deviceDescriptor + deviceDescriptor->ProductIdOffset;
            length += strlen(productId);
        }

        if ( deviceDescriptor->ProductRevisionOffset == 0 ) {
            revisionId = NULL;
        } else {
            revisionId = (PUCHAR) deviceDescriptor + deviceDescriptor->ProductRevisionOffset;
            length += strlen(revisionId);
        }

        //
        // allocate a buffer for the string
        //

        deviceString.Length = (USHORT)( length );
        deviceString.MaximumLength = deviceString.Length + 1;
        deviceString.Buffer = (PUCHAR)ExAllocatePoolWithTag( NonPagedPool,
                                                             deviceString.MaximumLength,
                                                             CLASS_TAG_AUTORUN_DISABLE
                                                             );
        if (deviceString.Buffer == NULL) {
            DebugPrint((ClassDebugMCN,
                        "ClassMediaChangeDisabledForHardware: Unable to alloc "
                        "string buffer\n" ));
            LEAVE;
        }

        //
        // copy strings to the buffer
        //
        offset = 0;

        if (vendorId != NULL) {
            RtlCopyMemory(deviceString.Buffer + offset,
                          vendorId,
                          strlen(vendorId));
            offset += strlen(vendorId);
        }

        if ( productId != NULL ) {
            RtlCopyMemory(deviceString.Buffer + offset,
                          productId,
                          strlen(productId));
            offset += strlen(productId);
        }
        if ( revisionId != NULL ) {
            RtlCopyMemory(deviceString.Buffer + offset,
                          revisionId,
                          strlen(revisionId));
            offset += strlen(revisionId);
        }

        ASSERT(offset == deviceString.Length);

        deviceString.Buffer[deviceString.Length] = '\0';  // Null-terminated

        //
        // convert to unicode as registry deals with unicode strings
        //

        status = RtlAnsiStringToUnicodeString( &deviceUnicodeString,
                                               &deviceString,
                                               TRUE
                                               );
        if (!NT_SUCCESS(status)) {
            DebugPrint((ClassDebugMCN,
                        "ClassMediaChangeDisabledForHardware: cannot convert "
                        "to unicode %lx\n", status));
            LEAVE;
        }

        //
        // query the value, setting valueFound to true if found
        //

        RtlZeroMemory(parameters, sizeof(parameters));

        nullMultiSz = L"\0";
        parameters[0].QueryRoutine  = ClasspMediaChangeRegistryCallBack;
        parameters[0].Flags         = RTL_QUERY_REGISTRY_REQUIRED;
        parameters[0].Name          = L"AutoRunAlwaysDisable";
        parameters[0].EntryContext  = &mediaChangeNotificationDisabled;
        parameters[0].DefaultType   = REG_MULTI_SZ;
        parameters[0].DefaultData   = nullMultiSz;
        parameters[0].DefaultLength = 0;

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        serviceKey,
                                        parameters,
                                        &deviceUnicodeString,
                                        NULL);

        if ( !NT_SUCCESS(status) ) {
            LEAVE;
        }

    } FINALLY {

        if (deviceString.Buffer != NULL) {
            ExFreePool( deviceString.Buffer );
        }
        if (deviceUnicodeString.Buffer != NULL) {
            RtlFreeUnicodeString( &deviceUnicodeString );
        }

        ZwClose(serviceKey);
    }

    if (mediaChangeNotificationDisabled) {
        DebugPrint((ClassDebugMCN, "ClassMediaChangeDisabledForHardware: "
                    "Device is on disable list\n"));
        return TRUE;
    }
    return FALSE;

} // end ClasspIsMediaChangeDisabledDueToHardwareLimitation()

/*++////////////////////////////////////////////////////////////////////////////

ClasspIsMediaChangeDisabledForClass()

Routine Description:

    The user must specify that AutoPlay is to run on the platform
    by setting the registry value HKEY_LOCAL_MACHINE\System\CurrentControlSet\
    Services\<SERVICE>\Autorun:REG_DWORD:1.

    The user can override the global setting to enable or disable Autorun on a
    specific cdrom device via the control panel.

Arguments:

    FdoExtension -
    RegistryPath - pointer to the unicode string inside
                   ...\CurrentControlSet\Services\Cdrom

Return Value:

    TRUE - Autorun is disabled for this class
    FALSE - Autorun is enabled for this class

--*/
BOOLEAN
ClasspIsMediaChangeDisabledForClass(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PUNICODE_STRING RegistryPath
    )
{
    PSTORAGE_DEVICE_DESCRIPTOR deviceDescriptor = FdoExtension->DeviceDescriptor;

    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE serviceKey = NULL;
    HANDLE parametersKey = NULL;
    RTL_QUERY_REGISTRY_TABLE parameters[3];

    UNICODE_STRING paramStr;
    UNICODE_STRING deviceUnicodeString;
    ANSI_STRING deviceString;

    //
    //  Default to ENABLING MediaChangeNotification (!)
    //

    ULONG mcnRegistryValue = 1;

    NTSTATUS status;


    PAGED_CODE();

    //
    // open the service key.
    //

    InitializeObjectAttributes(&objectAttributes,
                               RegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = ZwOpenKey(&serviceKey,
                       KEY_READ,
                       &objectAttributes);

    ASSERT(NT_SUCCESS(status));

    if(!NT_SUCCESS(status)) {

        //
        // return the default value, which is the
        // inverse of the registry setting default
        // since this routine asks if it's disabled
        //

        DebugPrint((ClassDebugMCN, "ClassCheckServiceMCN: Defaulting to %s\n",
                    (mcnRegistryValue ? "Enabled" : "Disabled")));
        return (BOOLEAN)(!mcnRegistryValue);

    }

    RtlZeroMemory(parameters, sizeof(parameters));

    //
    // Open the parameters key (if any) beneath the services key.
    //

    RtlInitUnicodeString(&paramStr, L"Parameters");

    InitializeObjectAttributes(&objectAttributes,
                               &paramStr,
                               OBJ_CASE_INSENSITIVE,
                               serviceKey,
                               NULL);

    status = ZwOpenKey(&parametersKey,
                       KEY_READ,
                       &objectAttributes);

    if (!NT_SUCCESS(status)) {
        parametersKey = NULL;
    }



    //
    // Check for the Autorun value.
    //

    parameters[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    parameters[0].Name          = L"Autorun";
    parameters[0].EntryContext  = &mcnRegistryValue;
    parameters[0].DefaultType   = REG_DWORD;
    parameters[0].DefaultData   = &mcnRegistryValue;
    parameters[0].DefaultLength = sizeof(ULONG);

    status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE | RTL_REGISTRY_OPTIONAL,
                                    serviceKey,
                                    parameters,
                                    NULL,
                                    NULL);

    DebugPrint((ClassDebugMCN, "ClassCheckServiceMCN: "
                "<Service>/Autorun flag = %d\n", mcnRegistryValue));

    if(parametersKey != NULL) {

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE | RTL_REGISTRY_OPTIONAL,
                                        parametersKey,
                                        parameters,
                                        NULL,
                                        NULL);
        DebugPrint((ClassDebugMCN, "ClassCheckServiceMCN: "
                    "<Service>/Parameters/Autorun flag = %d\n",
                    mcnRegistryValue));
        ZwClose(parametersKey);

    }
    ZwClose(serviceKey);
    
    DebugPrint((ClassDebugMCN, "ClassCheckServiceMCN: "
                "Autoplay for device %p is %s\n",
                FdoExtension->DeviceObject,
                (mcnRegistryValue ? "on" : "off")
                ));

    //
    // return if it is _disabled_, which is the
    // inverse of the registry setting
    //

    return (BOOLEAN)(!mcnRegistryValue);
} // end ClasspIsMediaChangeDisabledForClass()

/*++////////////////////////////////////////////////////////////////////////////

ClassEnableMediaChangeDetection() ISSUE-2000/02/20-henrygab - why public?
ClassEnableMediaChangeDetection() ISSUE-2000/02/20-henrygab - not documented

Routine Description:

    This routine

Arguments:

    DeviceObject - 
    Irp - 

Return Value:

--*/
VOID
ClassEnableMediaChangeDetection(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
{
    PMEDIA_CHANGE_DETECTION_INFO info = FdoExtension->MediaChangeDetectionInfo;
    LONG oldCount;

    PAGED_CODE();

    if(info == NULL) {
        DebugPrint((ClassDebugMCN,
                    "ClassEnableMediaChangeDetection: not initialized\n"));
        return;
    }

    KeWaitForMutexObject(&info->MediaChangeMutex,
                          UserRequest,
                          KernelMode,
                          FALSE,
                          NULL);

    oldCount = --info->MediaChangeDetectionDisableCount;

    ASSERT(oldCount >= 0);

    DebugPrint((ClassDebugMCN, "ClassEnableMediaChangeDetection: Disable count "
                "reduced to %d - ",
                info->MediaChangeDetectionDisableCount));

    if(oldCount == 0) {

        //
        // We don't know what state the media is in anymore.
        //

        ClasspInternalSetMediaChangeState(FdoExtension,
                                          MediaUnknown,
                                          FALSE
                                          );

        //
        // Reset the MCN timer.
        //

        ClassResetMediaChangeTimer(FdoExtension);

        DebugPrint((ClassDebugMCN, "MCD is enabled\n"));

    } else {

        DebugPrint((ClassDebugMCN, "MCD still disabled\n"));

    }


    //
    // Let something else run.
    //

    KeReleaseMutex(&info->MediaChangeMutex, FALSE);

    return;
} // end ClassEnableMediaChangeDetection()

/*++////////////////////////////////////////////////////////////////////////////

ClassDisableMediaChangeDetection() ISSUE-2000/02/20-henrygab - why public?
ClassDisableMediaChangeDetection() ISSUE-2000/02/20-henrygab - not documented

Routine Description:

    This routine

Arguments:

    DeviceObject - 
    Irp - 

Return Value:

--*/
ULONG BreakOnMcnDisable = FALSE;

VOID
ClassDisableMediaChangeDetection(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
{
    PMEDIA_CHANGE_DETECTION_INFO info = FdoExtension->MediaChangeDetectionInfo;

    PAGED_CODE();

    if(info == NULL) {
        return;
    }

    KeWaitForMutexObject(&info->MediaChangeMutex,
                         UserRequest,
                         KernelMode,
                         FALSE,
                         NULL);

    info->MediaChangeDetectionDisableCount++;

    DebugPrint((ClassDebugMCN, "ClassDisableMediaChangeDetection: "
                "disable count is %d\n",
                info->MediaChangeDetectionDisableCount));

    KeReleaseMutex(&info->MediaChangeMutex, FALSE);

    return;
} // end ClassDisableMediaChangeDetection()

/*++////////////////////////////////////////////////////////////////////////////

ClassCleanupMediaChangeDetection() ISSUE-2000/02/20-henrygab - why public?!

Routine Description:

    This routine will cleanup any resources allocated for MCN.  It is called
    by classpnp during remove device, and therefore is not typically required
    by external drivers.

Arguments:

Return Value:

--*/
VOID
ClassCleanupMediaChangeDetection(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
{
    PMEDIA_CHANGE_DETECTION_INFO info = FdoExtension->MediaChangeDetectionInfo;

    PAGED_CODE()

    if(info == NULL) {
        return;
    }

    FdoExtension->MediaChangeDetectionInfo = NULL;
    
    if (info->Gesn.Buffer) {
        ExFreePool(info->Gesn.Buffer);
    }
    IoFreeIrp(info->MediaChangeIrp);
    ExFreePool(info->SenseBuffer);
    ExFreePool(info);
    return;
} // end ClassCleanupMediaChangeDetection()

/*++////////////////////////////////////////////////////////////////////////////

ClasspMcnControl() - ISSUE-2000/02/20-henrygab - not documented

Routine Description:

    This routine

Arguments:

    DeviceObject - 
    Irp - 

Return Value:

--*/
NTSTATUS
ClasspMcnControl(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension =
        (PCOMMON_DEVICE_EXTENSION) FdoExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PPREVENT_MEDIA_REMOVAL request = Irp->AssociatedIrp.SystemBuffer;

    PFILE_OBJECT fileObject = irpStack->FileObject;
    PFILE_OBJECT_EXTENSION fsContext = NULL;

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Check to make sure we have a file object extension to keep track of this
    // request.  If not we'll fail it before synchronizing.
    //

    TRY {

        if(fileObject != NULL) {
            fsContext = ClasspGetFsContext(commonExtension, fileObject);
        }else if(Irp->RequestorMode == KernelMode) { // && fileObject == NULL
            fsContext = &FdoExtension->KernelModeMcnContext;
        }

        if (fsContext == NULL) {

            //
            // This handle isn't setup correctly.  We can't let the
            // operation go.
            //

            status = STATUS_INVALID_PARAMETER;
            LEAVE;
        }

        if(request->PreventMediaRemoval) {

            //
            // This is a lock command.  Reissue the command in case bus or
            // device was reset and the lock was cleared.
            //

            ClassDisableMediaChangeDetection(FdoExtension);
            InterlockedIncrement(&(fsContext->McnDisableCount));

        } else {

            if(fsContext->McnDisableCount == 0) {
                status = STATUS_INVALID_DEVICE_STATE;
                LEAVE;
            }

            InterlockedDecrement(&(fsContext->McnDisableCount));
            ClassEnableMediaChangeDetection(FdoExtension);
        }

    } FINALLY {

        Irp->IoStatus.Status = status;

        if(Srb) {
            ExFreePool(Srb);
        }

        ClassReleaseRemoveLock(FdoExtension->DeviceObject, Irp);
        ClassCompleteRequest(FdoExtension->DeviceObject,
                             Irp,
                             IO_NO_INCREMENT);
    }
    return status;
} // end ClasspMcnControl(

/*++////////////////////////////////////////////////////////////////////////////

ClasspMediaChangeRegistryCallBack()

Routine Description:

    This callback for a registry SZ or MULTI_SZ is called once for each
    SZ in the value.  It will attempt to match the data with the
    UNICODE_STRING passed in as Context, and modify EntryContext if a
    match is found.  Written for ClasspCheckRegistryForMediaChangeCompletion

Arguments:

    ValueName     - name of the key that was opened
    ValueType     - type of data stored in the value (REG_SZ for this routine)
    ValueData     - data in the registry, in this case a wide string
    ValueLength   - length of the data including the terminating null
    Context       - unicode string to compare against ValueData
    EntryContext  - should be initialized to 0, will be set to 1 if match found

Return Value:

    STATUS_SUCCESS
    EntryContext will be 1 if found

--*/
NTSTATUS
ClasspMediaChangeRegistryCallBack(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    PULONG valueFound;
    PUNICODE_STRING deviceString;
    PWSTR keyValue;

    PAGED_CODE();
    UNREFERENCED_PARAMETER(ValueName);


    //
    // if we have already set the value to true, exit
    //

    valueFound = EntryContext;
    if ((*valueFound) != 0) {
        DebugPrint((ClassDebugMCN, "ClasspMcnRegCB: already set to true\n"));
        return STATUS_SUCCESS;
    }

    if (ValueLength == sizeof(WCHAR)) {
        DebugPrint((ClassDebugError, "ClasspMcnRegCB: NULL string should "
                    "never be passed to registry call-back!\n"));
        return STATUS_SUCCESS;
    }


    //
    // if the data is not a terminated string, exit
    //

    if (ValueType != REG_SZ) {
        return STATUS_SUCCESS;
    }

    deviceString = Context;
    keyValue = ValueData;
    ValueLength -= sizeof(WCHAR); // ignore the null character

    //
    // do not compare more memory than is in deviceString
    //

    if (ValueLength > deviceString->Length) {
        ValueLength = deviceString->Length;
    }

    //
    // if the strings match, disable autorun
    //

    if (RtlCompareMemory(deviceString->Buffer, keyValue, ValueLength) == ValueLength) {
        DebugPrint((ClassDebugMCN, "ClasspRegMcnCB: Match found\n"));
        DebugPrint((ClassDebugMCN, "ClasspRegMcnCB: DeviceString at %p\n",
                    deviceString->Buffer));
        DebugPrint((ClassDebugMCN, "ClasspRegMcnCB: KeyValue at %p\n",
                    keyValue));
        (*valueFound) = TRUE;
    }

    return STATUS_SUCCESS;
} // end ClasspMediaChangeRegistryCallBack()

/*++////////////////////////////////////////////////////////////////////////////

ClasspTimerTick() - ISSUE-2000/02/20-henrygab - not documented

Routine Description:

    This routine

Arguments:

    DeviceObject - 
    Irp - 

Return Value:

--*/
VOID
ClasspTimerTick(
    PDEVICE_OBJECT DeviceObject,
    PVOID Context
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    ULONG isRemoved;

    ASSERT(commonExtension->IsFdo);

    //
    // Do any media change work
    //
    isRemoved = ClassAcquireRemoveLock(DeviceObject, (PIRP)ClasspTimerTick);

    //
    // We stop the timer before deleting the device.  It's safe to keep going
    // if the flag value is REMOVE_PENDING because the removal thread will be
    // blocked trying to stop the timer.
    //

    ASSERT(isRemoved != REMOVE_COMPLETE);

    //
    // This routine is reasonably safe even if the device object has a pending
    // remove

    if(!isRemoved) {

        PFAILURE_PREDICTION_INFO info = fdoExtension->FailurePredictionInfo;

        //
        // Do any media change detection work
        //

        if (fdoExtension->MediaChangeDetectionInfo != NULL) {

            ClassCheckMediaState(fdoExtension);

        }

        //
        // Do any failure prediction work
        //
        if ((info != NULL) && (info->Method != FailurePredictionNone)) {

            ULONG countDown;
            ULONG active;

            if (ClasspCanSendPollingIrp(fdoExtension)) {

                //
                // Synchronization is not required here since the Interlocked
                // locked instruction guarantees atomicity. Other code that
                // resets CountDown uses InterlockedExchange which is also
                // atomic.
                //
                countDown = InterlockedDecrement(&info->CountDown);
                if (countDown == 0) {

                    DebugPrint((4, "ClasspTimerTick: Send FP irp for %p\n",
                                   DeviceObject));

                    if(info->WorkQueueItem == NULL) {

                        info->WorkQueueItem =
                            IoAllocateWorkItem(fdoExtension->DeviceObject);

                        if(info->WorkQueueItem == NULL) {

                            //
                            // Set the countdown to one minute in the future.
                            // we'll try again then in the hopes there's more
                            // free memory.
                            //

                            DebugPrint((1, "ClassTimerTick: Couldn't allocate "
                                           "item - try again in one minute\n"));
                            InterlockedExchange(&info->CountDown, 60);

                        } else {

                            //
                            // Grab the remove lock so that removal will block
                            // until the work item is done.
                            //

                            ClassAcquireRemoveLock(fdoExtension->DeviceObject,
                                                   info->WorkQueueItem);

                            IoQueueWorkItem(info->WorkQueueItem,
                                            ClasspFailurePredict,
                                            DelayedWorkQueue,
                                            info);
                        }

                    } else {

                        DebugPrint((3, "ClasspTimerTick: Failure "
                                       "Prediction work item is "
                                       "already active for device %p\n",
                                    DeviceObject));

                    }
                } // end (countdown == 0)

            } else {
                //
                // If device is sleeping then just rearm polling timer
                DebugPrint((4, "ClassTimerTick, SHHHH!!! device is %p is sleeping\n",
                            DeviceObject));
            }

        } // end failure prediction polling

        //
        // Give driver a chance to do its own specific work
        //

        if (commonExtension->DriverExtension->InitData.ClassTick != NULL) {

            commonExtension->DriverExtension->InitData.ClassTick(DeviceObject);

        } // end device specific tick handler
    } // end check for removed

    ClassReleaseRemoveLock(DeviceObject, (PIRP)ClasspTimerTick);
} // end ClasspTimerTick()

/*++////////////////////////////////////////////////////////////////////////////

ClasspEnableTimer() - ISSUE-2000/02/20-henrygab - not documented

Routine Description:

    This routine

Arguments:

    DeviceObject - 
    Irp - 

Return Value:

--*/
NTSTATUS
ClasspEnableTimer(
    PDEVICE_OBJECT DeviceObject
    )
{
    NTSTATUS status;

    PAGED_CODE();

    if (DeviceObject->Timer == NULL) {

        status = IoInitializeTimer(DeviceObject, ClasspTimerTick, NULL);

    } else {

        status = STATUS_SUCCESS;

    }

    if (NT_SUCCESS(status)) {

        IoStartTimer(DeviceObject);
        DebugPrint((1, "ClasspEnableTimer: Once a second timer enabled "
                    "for device %p\n", DeviceObject));

    }

    DebugPrint((1, "ClasspEnableTimer: Device %p, Status %lx "
                "initializing timer\n", DeviceObject, status));

    return status;

} // end ClasspEnableTimer()

/*++////////////////////////////////////////////////////////////////////////////

ClasspDisableTimer() - ISSUE-2000/02/20-henrygab - not documented

Routine Description:

    This routine

Arguments:

    DeviceObject - 
    Irp - 

Return Value:

--*/
NTSTATUS
ClasspDisableTimer(
    PDEVICE_OBJECT DeviceObject
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PMEDIA_CHANGE_DETECTION_INFO mCDInfo = fdoExtension->MediaChangeDetectionInfo;
    PFAILURE_PREDICTION_INFO fPInfo = fdoExtension->FailurePredictionInfo;
    NTSTATUS status;

    PAGED_CODE();

    if (DeviceObject->Timer != NULL) {

        //
        // we are only going to stop the actual timer in remove device routine.
        // it is the responsibility of the code within the timer routine to
        // check if the device is removed and not processing io for the final
        // call.
        // this keeps the code clean and prevents lots of bugs.
        //


        IoStopTimer(DeviceObject);
        DebugPrint((3, "ClasspDisableTimer: Once a second timer disabled "
                    "for device %p\n", DeviceObject));

    } else {

        DebugPrint((1, "ClasspDisableTimer: Timer never enabled\n"));

    }

    return STATUS_SUCCESS;
} // end ClasspDisableTimer()

/*++////////////////////////////////////////////////////////////////////////////

ClasspFailurePredict() - ISSUE-2000/02/20-henrygab - not documented

Routine Description:

    This routine

Arguments:

    DeviceObject - 
    Irp - 

Return Value:

Note:  this function can be called (via the workitem callback) after the paging device is shut down,
         so it must be PAGE LOCKED.
--*/
VOID
ClasspFailurePredict(
    IN PDEVICE_OBJECT DeviceObject,
    IN PFAILURE_PREDICTION_INFO Info
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PIO_WORKITEM workItem;
    STORAGE_PREDICT_FAILURE checkFailure;
    SCSI_ADDRESS scsiAddress;

    NTSTATUS status;

    ASSERT(Info != NULL);

    DebugPrint((1, "ClasspFailurePredict: Polling for failure\n"));

    //
    // Mark the work item as inactive and reset the countdown timer.  we
    // can't risk freeing the work item until we've released the remove-lock
    // though - if we do it might get resused as a tag before we can release
    // the lock.
    //

    InterlockedExchange(&Info->CountDown, Info->Period);
    workItem = InterlockedExchangePointer(&(Info->WorkQueueItem), NULL);

    if (ClasspCanSendPollingIrp(fdoExtension)) {

        KEVENT event;
        PDEVICE_OBJECT topOfStack;
        PIRP irp = NULL;
        IO_STATUS_BLOCK ioStatus;

        KeInitializeEvent(&event, SynchronizationEvent, FALSE);

        topOfStack = IoGetAttachedDeviceReference(DeviceObject);

        //
        // Send down irp to see if drive is predicting failure
        //

        irp = IoBuildDeviceIoControlRequest(
                        IOCTL_STORAGE_PREDICT_FAILURE,
                        topOfStack,
                        NULL,
                        0,
                        &checkFailure,
                        sizeof(STORAGE_PREDICT_FAILURE),
                        FALSE,
                        &event,
                        &ioStatus);


        if (irp != NULL) {
            status = IoCallDriver(topOfStack, irp);
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
                status = ioStatus.Status;
            }
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (NT_SUCCESS(status) && (checkFailure.PredictFailure)) {

            checkFailure.PredictFailure = 512;

            //
            // Send down irp to get scsi address
            //
            KeInitializeEvent(&event, SynchronizationEvent, FALSE);

            RtlZeroMemory(&scsiAddress, sizeof(SCSI_ADDRESS));
            irp = IoBuildDeviceIoControlRequest(
                IOCTL_SCSI_GET_ADDRESS,
                topOfStack,
                NULL,
                0,
                &scsiAddress,
                sizeof(SCSI_ADDRESS),
                FALSE,
                &event,
                &ioStatus);

            if (irp != NULL) {
                status = IoCallDriver(topOfStack, irp);
                if (status == STATUS_PENDING) {
                    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
                    status = ioStatus.Status;
                }
            }

            ClassNotifyFailurePredicted(fdoExtension,
                                    (PUCHAR)&checkFailure,
                                    sizeof(checkFailure),
                                    (BOOLEAN)(fdoExtension->FailurePredicted == FALSE),
                                    2,
                                    scsiAddress.PathId,
                                    scsiAddress.TargetId,
                                    scsiAddress.Lun);

            fdoExtension->FailurePredicted = TRUE;

        }

        ObDereferenceObject(topOfStack);
    }

    ClassReleaseRemoveLock(DeviceObject, (PIRP) workItem);
    IoFreeWorkItem(workItem);
    return;
} // end ClasspFailurePredict()

/*++////////////////////////////////////////////////////////////////////////////

ClassNotifyFailurePredicted() ISSUE-alanwar-2000/02/20 - not documented

Routine Description:

Arguments:

Return Value:

--*/
VOID
ClassNotifyFailurePredicted(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    PUCHAR Buffer,
    ULONG BufferSize,
    BOOLEAN LogError,
    ULONG UniqueErrorValue,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun
    )
{
    PIO_ERROR_LOG_PACKET logEntry;

    DebugPrint((1, "ClasspFailurePredictPollCompletion: Failure predicted for device %p\n", FdoExtension->DeviceObject));

    //
    // Fire off a WMI event
    //
    ClassWmiFireEvent(FdoExtension->DeviceObject,
                                   &StoragePredictFailureEventGuid,
                                   0,
                                   BufferSize,
                                   Buffer);

    //
    // Log an error into the eventlog
    //

    if (LogError)
    {
        logEntry = IoAllocateErrorLogEntry(
                            FdoExtension->DeviceObject,
                           sizeof(IO_ERROR_LOG_PACKET) + (3 * sizeof(ULONG)));

        if (logEntry != NULL)
        {

            logEntry->FinalStatus     = STATUS_SUCCESS;
            logEntry->ErrorCode       = IO_WRN_FAILURE_PREDICTED;
            logEntry->SequenceNumber  = 0;
            logEntry->MajorFunctionCode = IRP_MJ_DEVICE_CONTROL;
            logEntry->IoControlCode   = IOCTL_STORAGE_PREDICT_FAILURE;
            logEntry->RetryCount      = 0;
            logEntry->UniqueErrorValue = UniqueErrorValue;
            logEntry->DumpDataSize    = 3;

            logEntry->DumpData[0] = PathId;
            logEntry->DumpData[1] = TargetId;
            logEntry->DumpData[2] = Lun;

            //
            // Write the error log packet.
            //

            IoWriteErrorLogEntry(logEntry);
        }
    }
} // end ClassNotifyFailurePredicted()

/*++////////////////////////////////////////////////////////////////////////////

ClassSetFailurePredictionPoll()

Routine Description:

    This routine enables polling for failure prediction, setting the timer
    to fire every N seconds as specified by the PollingPeriod.

Arguments:

    FdoExtension - the device to setup failure prediction for.

    FailurePredictionMethod - specific failure prediction method to use
        if set to FailurePredictionNone, will disable failure detection

    PollingPeriod - if 0 then no change to current polling timer

Return Value:

    NT Status

--*/
NTSTATUS
ClassSetFailurePredictionPoll(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    FAILURE_PREDICTION_METHOD FailurePredictionMethod,
    ULONG PollingPeriod
    )
{
    PFAILURE_PREDICTION_INFO info;
    NTSTATUS status;
    DEVICE_POWER_STATE powerState;

    PAGED_CODE();

    if (FdoExtension->FailurePredictionInfo == NULL) {

        if (FailurePredictionMethod != FailurePredictionNone) {

            info = ExAllocatePoolWithTag(NonPagedPool,
                                         sizeof(FAILURE_PREDICTION_INFO),
                                         CLASS_TAG_FAILURE_PREDICT);

            if (info == NULL) {

                return STATUS_INSUFFICIENT_RESOURCES;

            }

            KeInitializeEvent(&info->Event, SynchronizationEvent, TRUE);

            info->WorkQueueItem = NULL;
            info->Period = DEFAULT_FAILURE_PREDICTION_PERIOD;

        } else {

            //
            // FaultPrediction has not been previously initialized, nor
            // is it being initialized now. No need to do anything.
            //
            return STATUS_SUCCESS;

        }

        FdoExtension->FailurePredictionInfo = info;

    } else {

        info = FdoExtension->FailurePredictionInfo;

    }

    KeWaitForSingleObject(&info->Event,
                          UserRequest,
                          UserMode,
                          FALSE,
                          NULL);


    //
    // Reset polling period and counter. Setup failure detection type
    //

    if (PollingPeriod != 0) {

        InterlockedExchange(&info->Period, PollingPeriod);

    }

    InterlockedExchange(&info->CountDown, info->Period);

    info->Method = FailurePredictionMethod;
    if (FailurePredictionMethod != FailurePredictionNone) {

        status = ClasspEnableTimer(FdoExtension->DeviceObject);

        if (NT_SUCCESS(status)) {
            DebugPrint((3, "ClassEnableFailurePredictPoll: Enabled for "
                        "device %p\n", FdoExtension->DeviceObject));
        }

    } else {

        status = ClasspDisableTimer(FdoExtension->DeviceObject);
        DebugPrint((3, "ClassEnableFailurePredictPoll: Disabled for "
                    "device %p\n", FdoExtension->DeviceObject));
        status = STATUS_SUCCESS;

    }

    KeSetEvent(&info->Event, IO_NO_INCREMENT, FALSE);

    return status;
} // end ClassSetFailurePredictionPoll()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\classpnp\data.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    disk.c

Abstract:

    SCSI disk class driver

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "classp.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

/*
#define FDO_HACK_CANNOT_LOCK_MEDIA (0x00000001)
#define FDO_HACK_GESN_IS_BAD       (0x00000002)
*/

CLASSPNP_SCAN_FOR_SPECIAL_INFO ClassBadItems[] = {
    { ""        , "MITSUMI CD-ROM FX240"           , NULL,   0x02 },
    { ""        , "MITSUMI CD-ROM FX320"           , NULL,   0x02 },
    { ""        , "MITSUMI CD-ROM FX322"           , NULL,   0x02 },
    { ""        , "COMPAQ CRD-8481B"               , NULL,   0x04 },
    { NULL      , NULL                             , NULL,   0x0  }
};


GUID ClassGuidQueryRegInfoEx = GUID_CLASSPNP_QUERY_REGINFOEX;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\classpnp\create.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    class.c

Abstract:

    SCSI class driver routines

Environment:

    kernel mode only

Notes:


Revision History:

--*/

#define CLASS_INIT_GUID 0
#include "classp.h"
#include "debug.h"

ULONG BreakOnClose = 0;

PUCHAR LockTypeStrings[] = {
    "Simple",
    "Secure",
    "Internal"
};


PFILE_OBJECT_EXTENSION
ClasspGetFsContext(
    IN PCOMMON_DEVICE_EXTENSION CommonExtension,
    IN PFILE_OBJECT FileObject
    );

VOID
ClasspCleanupDisableMcn(
    IN PFILE_OBJECT_EXTENSION FsContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ClassCreateClose)
#pragma alloc_text(PAGE, ClasspCreateClose)
#pragma alloc_text(PAGE, ClasspCleanupProtectedLocks)
#pragma alloc_text(PAGE, ClasspEjectionControl)
#pragma alloc_text(PAGE, ClasspCleanupDisableMcn)
#pragma alloc_text(PAGE, ClasspGetFsContext)
#endif

NTSTATUS
ClassCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    SCSI class driver create and close routine.  This is called by the I/O system
    when the device is opened or closed.

Arguments:

    DriverObject - Pointer to driver object created by system.

    Irp - IRP involved.

Return Value:

    Device-specific drivers return value or STATUS_SUCCESS.

--*/

{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    ULONG removeState;
    NTSTATUS status;

    PAGED_CODE();

    //
    // If we're getting a close request then we know the device object hasn't
    // been completely destroyed.  Let the driver cleanup if necessary.
    //

    removeState = ClassAcquireRemoveLock(DeviceObject, Irp);

    //
    // Invoke the device-specific routine, if one exists. Otherwise complete
    // with SUCCESS
    //

    if((removeState == NO_REMOVE) ||
       IS_CLEANUP_REQUEST(IoGetCurrentIrpStackLocation(Irp)->MajorFunction)) {

        status = ClasspCreateClose(DeviceObject, Irp);

        if((NT_SUCCESS(status)) &&
           (commonExtension->DevInfo->ClassCreateClose)) {

            return commonExtension->DevInfo->ClassCreateClose(DeviceObject, Irp);
        }

    } else {
        status = STATUS_DEVICE_DOES_NOT_EXIST;
    }

    Irp->IoStatus.Status = status;
    ClassReleaseRemoveLock(DeviceObject, Irp);
    ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
    return status;
}


NTSTATUS
ClasspCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine will handle create/close operations for a given classpnp
    device if the class driver doesn't supply it's own handler.  If there
    is a file object supplied for our driver (if it's a FO_DIRECT_DEVICE_OPEN
    file object) then it will initialize a file extension on create or destroy
    the extension on a close.

Arguments:

    DeviceObject - the device object being opened or closed.

    Irp - the create/close irp

Return Value:

    status

--*/
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    PFILE_OBJECT fileObject = irpStack->FileObject;

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();


    //
    // ISSUE-2000/3/28-henrygab - if lower stack fails create/close, we end up
    // in an inconsistent state.  re-write to verify all args and allocate all
    // required resources, then pass the irp down, then complete the
    // transaction.  this is because we also cannot forward the irp, then fail
    // it after it has succeeded a lower-level driver.
    //

    if(irpStack->MajorFunction == IRP_MJ_CREATE) {

        PIO_SECURITY_CONTEXT securityContext =
            irpStack->Parameters.Create.SecurityContext;
        DebugPrint((2,
                    "ClasspCREATEClose: create received for device %p\n",
                    DeviceObject));
        DebugPrint((2,
                    "ClasspCREATEClose: desired access %lx\n",
                    securityContext->DesiredAccess));
        DebugPrint((2,
                    "ClasspCREATEClose: file object %lx\n",
                    irpStack->FileObject));

        ASSERT(BreakOnClose == FALSE);

        if(irpStack->FileObject != NULL) {

            PFILE_OBJECT_EXTENSION fsContext;

            //
            // Allocate our own file object extension for this device object.
            //

            status = AllocateDictionaryEntry(
                        &commonExtension->FileObjectDictionary,
                        (ULONGLONG) irpStack->FileObject,
                        sizeof(FILE_OBJECT_EXTENSION),
                        CLASS_TAG_FILE_OBJECT_EXTENSION,
                        &fsContext);

            if(NT_SUCCESS(status)) {

                RtlZeroMemory(fsContext,
                              sizeof(FILE_OBJECT_EXTENSION));

                fsContext->FileObject = irpStack->FileObject;
                fsContext->DeviceObject = DeviceObject;
            } else if (status == STATUS_OBJECT_NAME_COLLISION) {
                status = STATUS_SUCCESS;
            }
        }

    } else {

        DebugPrint((2,
                    "ClasspCreateCLOSE: close received for device %p\n",
                    DeviceObject));
        DebugPrint((2,
                    "ClasspCreateCLOSE: file object %p\n",
                    fileObject));

        if(irpStack->FileObject != NULL) {

            PFILE_OBJECT_EXTENSION fsContext =
                ClasspGetFsContext(commonExtension, irpStack->FileObject);

            DebugPrint((2,
                        "ClasspCreateCLOSE: file extension %p\n",
                        fsContext));

            if(fsContext != NULL) {

                DebugPrint((2,
                            "ClasspCreateCLOSE: extension is ours - "
                            "freeing\n"));
                ASSERT(BreakOnClose == FALSE);

                ClasspCleanupProtectedLocks(fsContext);

                ClasspCleanupDisableMcn(fsContext);

                FreeDictionaryEntry(&(commonExtension->FileObjectDictionary),
                                    fsContext);
            }
        }
    }

    //
    // Notify the lower levels about the create or close operation - give them
    // a chance to cleanup too.
    //

    DebugPrint((2,
                "ClasspCreateClose: %s for devobj %p\n",
                (NT_SUCCESS(status) ? "Success" : "FAILED"),
                DeviceObject));


    if(NT_SUCCESS(status)) {

        KEVENT event;

        //
        // Set up the event to wait on
        //

        KeInitializeEvent(&event, SynchronizationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine( Irp, ClassSignalCompletion, &event,
                                TRUE, TRUE, TRUE);

        status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);

        if(status == STATUS_PENDING) {
            KeWaitForSingleObject(&event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
            status = Irp->IoStatus.Status;
        }

        if (!NT_SUCCESS(status)) {
            DebugPrint((ClassDebugError,
                        "ClasspCreateClose: Lower driver failed, but we "
                        "succeeded.  This is a problem, lock counts will be "
                        "out of sync between levels.\n"));
        }

    }


    return status;
}


VOID
ClasspCleanupProtectedLocks(
    IN PFILE_OBJECT_EXTENSION FsContext
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension =
        FsContext->DeviceObject->DeviceExtension;

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension =
        commonExtension->PartitionZeroExtension;

    ULONG newDeviceLockCount = 1;

    PAGED_CODE();

    DebugPrint((2,
                "ClasspCleanupProtectedLocks called for %p\n",
                FsContext->DeviceObject));
    DebugPrint((2,
                "ClasspCleanupProtectedLocks - FsContext %p is locked "
                "%d times\n", FsContext, FsContext->LockCount));

    ASSERT(BreakOnClose == FALSE);

    //
    // Synchronize with ejection and ejection control requests.
    //

    KeEnterCriticalRegion();
    KeWaitForSingleObject(&(fdoExtension->EjectSynchronizationEvent),
                          UserRequest,
                          UserMode,
                          FALSE,
                          NULL);

    //
    // For each secure lock on this handle decrement the secured lock count
    // for the FDO.  Keep track of the new value.
    //

    if(FsContext->LockCount != 0) {

        do {

            InterlockedDecrement(&FsContext->LockCount);

            newDeviceLockCount =
                InterlockedDecrement(&fdoExtension->ProtectedLockCount);

        } while(FsContext->LockCount != 0);

        //
        // If the new lock count has been dropped to zero then issue a lock
        // command to the device.
        //

        DebugPrint((2,
                    "ClasspCleanupProtectedLocks: FDO secured lock count = %d "
                    "lock count = %d\n",
                    fdoExtension->ProtectedLockCount,
                    fdoExtension->LockCount));

        if((newDeviceLockCount == 0) && (fdoExtension->LockCount == 0)) {

            SCSI_REQUEST_BLOCK srb;
            PCDB cdb;
            NTSTATUS status;

            DebugPrint((2,
                        "ClasspCleanupProtectedLocks: FDO lock count dropped "
                        "to zero\n"));

            RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));
            cdb = (PCDB) &(srb.Cdb);

            srb.CdbLength = 6;

            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;

            //
            // TRUE - prevent media removal.
            // FALSE - allow media removal.
            //

            cdb->MEDIA_REMOVAL.Prevent = FALSE;

            //
            // Set timeout value.
            //

            srb.TimeOutValue = fdoExtension->TimeOutValue;
            status = ClassSendSrbSynchronous(fdoExtension->DeviceObject,
                                             &srb,
                                             NULL,
                                             0,
                                             FALSE);

            DebugPrint((2,
                        "ClasspCleanupProtectedLocks: unlock request to drive "
                        "returned status %lx\n", status));
        }
    }

    KeSetEvent(&fdoExtension->EjectSynchronizationEvent,
               IO_NO_INCREMENT,
               FALSE);
    KeLeaveCriticalRegion();
    return;
}


VOID
ClasspCleanupDisableMcn(
    IN PFILE_OBJECT_EXTENSION FsContext
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension =
        FsContext->DeviceObject->DeviceExtension;

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension =
        commonExtension->PartitionZeroExtension;

    ULONG newCount = 1;

    PAGED_CODE();

    DebugPrint((ClassDebugTrace,
                "ClasspCleanupDisableMcn called for %p\n",
                FsContext->DeviceObject));
    DebugPrint((ClassDebugTrace,
                "ClasspCleanupDisableMcn - FsContext %p is disabled "
                "%d times\n", FsContext, FsContext->McnDisableCount));

    //
    // For each secure lock on this handle decrement the secured lock count
    // for the FDO.  Keep track of the new value.
    //

    while(FsContext->McnDisableCount != 0) {
        FsContext->McnDisableCount--;
        ClassEnableMediaChangeDetection(fdoExtension);
    }

    return;
}


#if 1
/*
 *  BUGBUG REMOVE this old function implementation as soon as the 
 *                  boottime pagefile problems with the new one (below) 
 *                  are resolved.
 */
NTSTATUS
ClasspEjectionControl(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp,
    IN MEDIA_LOCK_TYPE LockType,
    IN BOOLEAN Lock
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension = Fdo->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension =
        (PCOMMON_DEVICE_EXTENSION) FdoExtension;
    
    PFILE_OBJECT_EXTENSION fsContext = NULL;
    NTSTATUS status;
    PSCSI_REQUEST_BLOCK srb = NULL;
    BOOLEAN countChanged = FALSE;

    PAGED_CODE();

    //
    // Interlock with ejection and secure lock cleanup code.  This is a
    // user request so we can allow the stack to get swapped out while we
    // wait for synchronization.
    //

    status = KeWaitForSingleObject(
                &(FdoExtension->EjectSynchronizationEvent),
                UserRequest,
                UserMode,
                FALSE,
                NULL);

    ASSERT(status == STATUS_SUCCESS);

    DebugPrint((2,
                "ClasspEjectionControl: "
                "Received request for %s lock type\n",
                LockTypeStrings[LockType]
                ));

    try {
        PCDB cdb;

        srb = ClasspAllocateSrb(FdoExtension);

        if(srb == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

        cdb = (PCDB) srb->Cdb;

        //
        // Determine if this is a "secured" request.
        //

        if(LockType == SecureMediaLock) {
             
            PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
            PFILE_OBJECT fileObject = irpStack->FileObject;

            //
            // Make sure that the file object we are supplied has a
            // proper FsContext before we try doing a secured lock.
            //

            if(fileObject != NULL) {
                fsContext = ClasspGetFsContext(commonExtension, fileObject);
            }

            if (fsContext == NULL) {

                //
                // This handle isn't setup correctly.  We can't let the
                // operation go.
                //

                status = STATUS_INVALID_PARAMETER;
                leave;
            }
        }

        if(Lock) {

            //
            // This is a lock command.  Reissue the command in case bus or
            // device was reset and the lock was cleared.
            // note: may need to decrement count if actual lock operation
            //       failed....
            //

            switch(LockType) {

                case SimpleMediaLock: {
                    FdoExtension->LockCount++;
                    countChanged = TRUE;
                    break;
                }

                case SecureMediaLock: {
                    fsContext->LockCount++;
                    FdoExtension->ProtectedLockCount++;
                    countChanged = TRUE;
                    break;
                }

                case InternalMediaLock: {
                    FdoExtension->InternalLockCount++;
                    countChanged = TRUE;
                    break;
                }
            }
        
        } else {

            //
            // This is an unlock command.  If it's a secured one then make sure
            // the caller has a lock outstanding or return an error.
            // note: may need to re-increment the count if actual unlock
            //       operation fails....
            //

            switch(LockType) {

                case SimpleMediaLock: {
                    if(FdoExtension->LockCount != 0) {
                        FdoExtension->LockCount--;
                        countChanged = TRUE;
                    }
                    break;
                }

                case SecureMediaLock: {
                    if(fsContext->LockCount == 0) {
                        status = STATUS_INVALID_DEVICE_STATE;
                        leave;
                    }
                    fsContext->LockCount--;
                    FdoExtension->ProtectedLockCount--;
                    countChanged = TRUE;
                    break;
                }

                case InternalMediaLock: {
                    ASSERT(FdoExtension->InternalLockCount != 0);
                    FdoExtension->InternalLockCount--;
                    countChanged = TRUE;
                    break;
                }
            }

            //
            // We only send an unlock command to the drive if both the
            // secured and unsecured lock counts have dropped to zero.
            //

            if((FdoExtension->ProtectedLockCount != 0) ||
               (FdoExtension->InternalLockCount != 0) ||
               (FdoExtension->LockCount != 0)) {

                status = STATUS_SUCCESS;
                leave;
            }
        }

        status = STATUS_SUCCESS;
        if (TEST_FLAG(Fdo->Characteristics, FILE_REMOVABLE_MEDIA)) {

            srb->CdbLength = 6;
            cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
    
            //
            // TRUE - prevent media removal.
            // FALSE - allow media removal.
            //
    
            cdb->MEDIA_REMOVAL.Prevent = Lock;
    
            //
            // Set timeout value.
            //
    
            srb->TimeOutValue = FdoExtension->TimeOutValue;
    
            //
            // The actual lock operation on the device isn't so important
            // as the internal lock counts.  Ignore failures.
            //
    
            status = ClassSendSrbSynchronous(FdoExtension->DeviceObject,
                                             srb,
                                             NULL,
                                             0,
                                             FALSE);
        }

    } finally {

        if (!NT_SUCCESS(status)) {
            DebugPrint((2,
                        "ClasspEjectionControl: FAILED status %x -- "
                        "reverting lock counts\n", status));
            
            if (countChanged) {

                //
                // have to revert to previous counts if the
                // lock/unlock operation actually failed.
                //

                if(Lock) {
                    
                    switch(LockType) {

                        case SimpleMediaLock: {
                            FdoExtension->LockCount--;
                            break;
                        }

                        case SecureMediaLock: {
                            fsContext->LockCount--;
                            FdoExtension->ProtectedLockCount--;
                            break;
                        }

                        case InternalMediaLock: {
                            FdoExtension->InternalLockCount--;
                            break;
                        }
                    }

                } else {

                    switch(LockType) {

                        case SimpleMediaLock: {
                            FdoExtension->LockCount++;
                            break;
                        }

                        case SecureMediaLock: {
                            fsContext->LockCount++;
                            FdoExtension->ProtectedLockCount++;
                            break;
                        }

                        case InternalMediaLock: {
                            FdoExtension->InternalLockCount++;
                            break;
                        }
                    }
                }

            }

        } else {

            DebugPrint((2,
                        "ClasspEjectionControl: Succeeded\n"));

        }

        DebugPrint((2,
                    "ClasspEjectionControl: "
                    "Current Counts: Internal: %x  Secure: %x  Simple: %x\n",
                    FdoExtension->InternalLockCount,
                    FdoExtension->ProtectedLockCount,
                    FdoExtension->LockCount
                    ));

        KeSetEvent(&(FdoExtension->EjectSynchronizationEvent),
                   IO_NO_INCREMENT,
                   FALSE);
        if (srb) {
            ClassFreeOrReuseSrb(FdoExtension, srb);
        }

    }
    return status;
}

#else

/*
 *  BUGBUG RESTORE
 *      This is a new implementation of the function that doesn't thrash memory
 *      or depend on the srbLookasideList.
 *      HOWEVER, it seems to cause pagefile initialization to fail during boot
 *      for some reason.  Need to resolve this before switching to this function.
 */
NTSTATUS  
ClasspEjectionControl(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp,
    IN MEDIA_LOCK_TYPE LockType,
    IN BOOLEAN Lock
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExt = Fdo->DeviceExtension;
    PFILE_OBJECT_EXTENSION fsContext;
    BOOLEAN fileHandleOk = TRUE;
    BOOLEAN countChanged = FALSE;
    NTSTATUS status;
    
    PAGED_CODE();
    
    status = KeWaitForSingleObject(
                &fdoExt->EjectSynchronizationEvent,
                UserRequest,
                UserMode,
                FALSE,
                NULL);
    ASSERT(status == STATUS_SUCCESS);

    /*
     *  If this is a "secured" request, we have to make sure
     *  that the file handle is valid.
     */
    if (LockType == SecureMediaLock){
        PIO_STACK_LOCATION thisSp = IoGetCurrentIrpStackLocation(Irp);

        /*
         *  Make sure that the file object we are supplied has a
         *  proper FsContext before we try doing a secured lock.
         */
        if (thisSp->FileObject){
            PCOMMON_DEVICE_EXTENSION commonExt = (PCOMMON_DEVICE_EXTENSION)fdoExt;
            fsContext = ClasspGetFsContext(commonExt, thisSp->FileObject);
        }
        else {
            fsContext = NULL;
        }

        if (!fsContext){
            ASSERT(fsContext);
            fileHandleOk = FALSE;
        }
    }

    if (fileHandleOk){

        /*
         *  Adjust the lock counts and make sure they make sense.
         */
        status = STATUS_SUCCESS;
        if (Lock){
            switch(LockType) {
                case SimpleMediaLock:
                    fdoExt->LockCount++;
                    countChanged = TRUE;
                    break;
                case SecureMediaLock: 
                    fsContext->LockCount++;
                    fdoExt->ProtectedLockCount++;
                    countChanged = TRUE;
                    break;
                case InternalMediaLock:
                    fdoExt->InternalLockCount++;
                    countChanged = TRUE;
                    break;
            }
        } 
        else {
            /*
             *  This is an unlock command.  If it's a secured one then make sure
             *  the caller has a lock outstanding or return an error.
             */
            switch (LockType){
                case SimpleMediaLock: 
                    if (fdoExt->LockCount > 0){
                        fdoExt->LockCount--;
                        countChanged = TRUE;
                    }
                    else {
                        ASSERT(fdoExt->LockCount > 0);
                        status = STATUS_INTERNAL_ERROR;
                    }
                    break;
                case SecureMediaLock:
                    if (fsContext->LockCount > 0){
                        ASSERT(fdoExt->ProtectedLockCount > 0);
                        fsContext->LockCount--;
                        fdoExt->ProtectedLockCount--;
                        countChanged = TRUE;
                    }
                    else {
                        ASSERT(fsContext->LockCount > 0);
                        status = STATUS_INVALID_DEVICE_STATE;
                    }
                    break;
                case InternalMediaLock:
                    ASSERT(fdoExt->InternalLockCount > 0);
                    fdoExt->InternalLockCount--;
                    countChanged = TRUE;
                    break;
            }
        }

        if (NT_SUCCESS(status)){
            /*
             *  We only send an unlock command to the drive if
             *  all the lock counts have dropped to zero.
             */
            if (!Lock &&
               (fdoExt->ProtectedLockCount ||
                fdoExt->InternalLockCount ||
                fdoExt->LockCount)){
                
                /*
                 *  The lock count is still positive, so don't unlock yet.
                 */
                status = STATUS_SUCCESS;
            }
            else if (!TEST_FLAG(Fdo->Characteristics, FILE_REMOVABLE_MEDIA)) {
                /*
                 *  The device isn't removable media.  don't send a cmd.
                 */
                status  = STATUS_SUCCESS;
            }
            else {
                TRANSFER_PACKET *pkt;
                
                pkt = DequeueFreeTransferPacket(Fdo, TRUE);
                if (pkt){
                    KEVENT event;
                    
                    /*
                     *  Store the number of packets servicing the irp (one)
                     *  inside the original IRP.  It will be used to counted down 
                     *  to zero when the packet completes.
                     *  Initialize the original IRP's status to success.
                     *  If the packet fails, we will set it to the error status.
                     */
                    Irp->Tail.Overlay.DriverContext[0] = LongToPtr(1);
                    Irp->IoStatus.Status = STATUS_SUCCESS;

                    /*
                     *  Set this up as a SYNCHRONOUS transfer, submit it,
                     *  and wait for the packet to complete.  The result
                     *  status will be written to the original irp.
                     */
                    KeInitializeEvent(&event, SynchronizationEvent, FALSE);                
                    SetupEjectionTransferPacket(pkt, Lock, &event, Irp);
                    SubmitTransferPacket(pkt);
                    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);        
                    status = Irp->IoStatus.Status;
                }
                else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }
    }
    else {
        status = STATUS_INVALID_PARAMETER;
    }

    if (!NT_SUCCESS(status) && countChanged) {

        //
        // have to revert to previous counts if the
        // lock/unlock operation actually failed.
        //

        if(Lock) {

            switch(LockType) {

                case SimpleMediaLock: {
                    FdoExtension->LockCount--;
                    break;
                }

                case SecureMediaLock: {
                    fsContext->LockCount--;
                    FdoExtension->ProtectedLockCount--;
                    break;
                }

                case InternalMediaLock: {
                    FdoExtension->InternalLockCount--;
                    break;
                }
            }

        } else {

            switch(LockType) {

                case SimpleMediaLock: {
                    FdoExtension->LockCount++;
                    break;
                }

                case SecureMediaLock: {
                    fsContext->LockCount++;
                    FdoExtension->ProtectedLockCount++;
                    break;
                }

                case InternalMediaLock: {
                    FdoExtension->InternalLockCount++;
                    break;
                }
            }
        }
    }


    
    KeSetEvent(&fdoExt->EjectSynchronizationEvent, IO_NO_INCREMENT, FALSE);

    return status;
}
#endif

PFILE_OBJECT_EXTENSION
ClasspGetFsContext(
    IN PCOMMON_DEVICE_EXTENSION CommonExtension,
    IN PFILE_OBJECT FileObject
    )
{
    PAGED_CODE();
    return GetDictionaryEntry(&(CommonExtension->FileObjectDictionary),
                              (ULONGLONG) FileObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\classpnp\clntirp.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    clntirp.c

Abstract:

    Client IRP queuing routines for CLASSPNP

Environment:

    kernel mode only

Notes:


Revision History:

--*/

#include "classp.h"
#include "debug.h"


/*
 *  EnqueueDeferredClientIrp
 *
 *      Note: we currently do not support Cancel for storage irps.
 */
VOID EnqueueDeferredClientIrp(PCLASS_PRIVATE_FDO_DATA FdoData, PIRP Irp)
{
    KIRQL oldIrql;

    KeAcquireSpinLock(&FdoData->SpinLock, &oldIrql);
    InsertTailList(&FdoData->DeferredClientIrpList, &Irp->Tail.Overlay.ListEntry);
    KeReleaseSpinLock(&FdoData->SpinLock, oldIrql);
}


/*
 *  DequeueDeferredClientIrp
 *
 */
PIRP DequeueDeferredClientIrp(PCLASS_PRIVATE_FDO_DATA FdoData)
{
    KIRQL oldIrql;
    PLIST_ENTRY listEntry;
    PIRP irp;

    KeAcquireSpinLock(&FdoData->SpinLock, &oldIrql);
    if (IsListEmpty(&FdoData->DeferredClientIrpList)){
        listEntry = NULL;
    }
    else {
        listEntry = RemoveHeadList(&FdoData->DeferredClientIrpList);
    }
    KeReleaseSpinLock(&FdoData->SpinLock, oldIrql);

    if (listEntry == NULL) {
        irp = NULL;
    } else {
        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
        ASSERT(irp->Type == IO_TYPE_IRP);
        InitializeListHead(&irp->Tail.Overlay.ListEntry);
    }

    return irp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\classpnp\classp.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    classp.h

Abstract:

    Private header file for classpnp.sys modules.  This contains private
    structure and function declarations as well as constant values which do
    not need to be exported.

Author:

Environment:

    kernel mode only

Notes:


Revision History:

--*/


#include <stddef.h>
#include <stdarg.h>
#include <ntddk.h>

#include <scsi.h>
#include <wmidata.h>
#include <classpnp.h>

#if CLASS_INIT_GUID
#include <initguid.h>
#endif

#include <mountdev.h>
#include <ioevent.h>

extern CLASSPNP_SCAN_FOR_SPECIAL_INFO ClassBadItems[];

extern GUID ClassGuidQueryRegInfoEx;


#define CLASSP_REG_SUBKEY_NAME                  (L"Classpnp")

#define CLASSP_REG_HACK_VALUE_NAME              (L"HackMask")
#define CLASSP_REG_MMC_DETECTION_VALUE_NAME     (L"MMCDetectionState")
#define CLASSP_REG_WRITE_CACHE_VALUE_NAME       (L"WriteCacheEnableOverride")
#define CLASSP_REG_PERF_RESTORE_VALUE_NAME      (L"RestorePerfAtCount")
#define CLASSP_REG_REMOVAL_POLICY_VALUE_NAME    (L"UserRemovalPolicy")

#define CLASS_PERF_RESTORE_MINIMUM (0x10)
#define CLASS_ERROR_LEVEL_1 (0x4)
#define CLASS_ERROR_LEVEL_2 (0x8)

#define FDO_HACK_CANNOT_LOCK_MEDIA (0x00000001)
#define FDO_HACK_GESN_IS_BAD       (0x00000002)
#define FDO_HACK_NO_SYNC_CACHE     (0x00000004)

#define FDO_HACK_VALID_FLAGS       (0x00000007)
#define FDO_HACK_INVALID_FLAGS     (~FDO_HACK_VALID_FLAGS)

/*
 *  Lots of retries of synchronized SCSI commands that devices may not
 *  even support really slows down the system (especially while booting).
 *  (Even GetDriveCapacity may be failed on purpose if an external disk is powered off).
 *  If a disk cannot return a small initialization buffer at startup
 *  in two attempts (with delay interval) then we cannot expect it to return
 *  data consistently with four retries.
 *  So don't set the retry counts as high here as for data SRBs.
 *
 *  If we find that these requests are failing consecutively,
 *  despite the retry interval, on otherwise reliable media,
 *  then we should either increase the retry interval for
 *  that failure or (by all means) increase these retry counts as appropriate.
 */
#define NUM_LOCKMEDIAREMOVAL_RETRIES    1
#define NUM_MODESENSE_RETRIES           1
#define NUM_DRIVECAPACITY_RETRIES       1


#define CLASS_FILE_OBJECT_EXTENSION_KEY     'eteP'
#define CLASSP_VOLUME_VERIFY_CHECKED        0x34

#define CLASS_TAG_PRIVATE_DATA              'CPcS'
#define CLASS_TAG_PRIVATE_DATA_FDO          'FPcS'
#define CLASS_TAG_PRIVATE_DATA_PDO          'PPcS'

typedef struct _MEDIA_CHANGE_DETECTION_INFO {

    //
    // Mutex to synchronize enable/disable requests and media state changes
    //

    KMUTEX MediaChangeMutex;

    //
    // The current state of the media (present, not present, unknown)
    // protected by MediaChangeSynchronizationEvent
    //

    MEDIA_CHANGE_DETECTION_STATE MediaChangeDetectionState;

    //
    // This is a count of how many time MCD has been disabled.  if it is
    // set to zero, then we'll poll the device for MCN events with the
    // then-current method (ie. TEST UNIT READY or GESN).  this is
    // protected by MediaChangeMutex
    //

    LONG MediaChangeDetectionDisableCount;


    //
    // The timer value to support media change events.  This is a countdown
    // value used to determine when to poll the device for a media change.
    // The max value for the timer is 255 seconds.  This is not protected
    // by an event -- simply InterlockedExchanged() as needed.
    //

    LONG MediaChangeCountDown;

    //
    // recent changes allowed instant retries of the MCN irp.  Since this
    // could cause an infinite loop, keep a count of how many times we've
    // retried immediately so that we can catch if the count exceeds an
    // arbitrary limit.
    //

    LONG MediaChangeRetryCount;

    //
    // use GESN if it's available
    //

    struct {
        BOOLEAN Supported;
        BOOLEAN HackEventMask;
        UCHAR   EventMask;
        UCHAR   NoChangeEventMask;
        PUCHAR  Buffer;
        PMDL    Mdl;
        ULONG   BufferSize;
    } Gesn;

    //
    // If this value is one, then the irp is currently in use.
    // If this value is zero, then the irp is available.
    // Use InterlockedCompareExchange() to set from "available" to "in use".
    // ASSERT that InterlockedCompareExchange() showed previous value of
    //    "in use" when changing back to "available" state.
    // This also implicitly protects the MediaChangeSrb and SenseBuffer
    //

    LONG MediaChangeIrpInUse;

    //
    // Pointer to the irp to be used for media change detection.
    // protected by Interlocked MediaChangeIrpInUse
    //

    PIRP MediaChangeIrp;

    //
    // The srb for the media change detection.
    // protected by Interlocked MediaChangeIrpInUse
    //

    SCSI_REQUEST_BLOCK MediaChangeSrb;
    PUCHAR SenseBuffer;
    ULONG SrbFlags;

    //
    // Second timer to keep track of how long the media change IRP has been
    // in use.  If this value exceeds the timeout (#defined) then we should
    // print out a message to the user and set the MediaChangeIrpLost flag
    // protected by using Interlocked() operations in ClasspSendMediaStateIrp,
    // the only routine which should modify this value.
    //

    LONG MediaChangeIrpTimeInUse;

    //
    // Set by CdRomTickHandler when we determine that the media change irp has
    // been lost
    //

    BOOLEAN MediaChangeIrpLost;

};

typedef enum {
    SimpleMediaLock,
    SecureMediaLock,
    InternalMediaLock
} MEDIA_LOCK_TYPE, *PMEDIA_LOCK_TYPE;

typedef struct _FAILURE_PREDICTION_INFO {
    FAILURE_PREDICTION_METHOD Method;
    ULONG CountDown;                // Countdown timer
    ULONG Period;                   // Countdown period

    PIO_WORKITEM WorkQueueItem;

    KEVENT Event;
} FAILURE_PREDICTION_INFO, *PFAILURE_PREDICTION_INFO;



//
// This struct must always fit within four PVOIDs of info,
// as it uses the irp's "PVOID DriverContext[4]" to store
// this info
//
typedef struct _CLASS_RETRY_INFO {
    struct _CLASS_RETRY_INFO *Next;
} CLASS_RETRY_INFO, *PCLASS_RETRY_INFO;



typedef struct _CSCAN_LIST {

    //
    // The current block which has an outstanding request.
    //

    ULONGLONG BlockNumber;

    //
    // The list of blocks past the CurrentBlock to which we're going to do
    // i/o.  This list is maintained in sorted order.
    //

    LIST_ENTRY CurrentSweep;

    //
    // The list of blocks behind the current block for which we'll have to
    // wait until the next scan across the disk.  This is kept as a stack,
    // the cost of sorting it is taken when it's moved over to be the
    // running list.
    //

    LIST_ENTRY NextSweep;

} CSCAN_LIST, *PCSCAN_LIST;

//
// add to the front of this structure to help prevent illegal
// snooping by other utilities.
//



typedef enum _CLASS_DETECTION_STATE {
    ClassDetectionUnknown = 0,
    ClassDetectionUnsupported = 1,
    ClassDetectionSupported = 2
} CLASS_DETECTION_STATE, *PCLASS_DETECTION_STATE;


typedef struct _CLASS_ERROR_LOG_DATA {
    LARGE_INTEGER TickCount;        // Offset 0x00
    ULONG PortNumber;               // Offset 0x08

    UCHAR ErrorPaging    : 1;       // Offset 0x0c
    UCHAR ErrorRetried   : 1;
    UCHAR ErrorUnhandled : 1;
    UCHAR ErrorReserved  : 5;

    UCHAR Reserved[3];

    SCSI_REQUEST_BLOCK Srb;     // Offset 0x10

    /*
     *  We define the SenseData as the default length.
     *  Since the sense data returned by the port driver may be longer,
     *  SenseData must be at the end of this structure.
     *  For our internal error log, we only log the default length.
     */
    SENSE_DATA SenseData;     // Offset 0x50 for x86 (or 0x68 for ia64) (ULONG32 Alignment required!)
} CLASS_ERROR_LOG_DATA, *PCLASS_ERROR_LOG_DATA;

#define NUM_ERROR_LOG_ENTRIES   16



typedef struct _TRANSFER_PACKET {

        LIST_ENTRY AllPktsListEntry;    // entry in fdoData's static AllTransferPacketsList
        SINGLE_LIST_ENTRY SlistEntry;   // for when in free list (use fast slist)

        PIRP Irp;
        PDEVICE_OBJECT Fdo;

        /*
         *  This is the client IRP that this TRANSFER_PACKET is currently
         *  servicing.
         */
        PIRP OriginalIrp;
        BOOLEAN CompleteOriginalIrpWhenLastPacketCompletes;

        /*
         *  Stuff for retrying the transfer.
         */
        ULONG NumRetries;
        KTIMER RetryTimer;
        KDPC RetryTimerDPC;
        ULONG RetryIntervalSec;

        /*
         *  Event for synchronizing the transfer (optional).
         *  (Note that we can't have the event in the packet itself because
         *  by the time a thread waits on an event the packet may have
         *  been completed and re-issued.
         */
        PKEVENT SyncEventPtr;

        /*
         *  Stuff for retrying during extreme low-memory stress
         *  (when we retry 1 page at a time).
         */
        BOOLEAN InLowMemRetry;
        PUCHAR LowMemRetry_remainingBufPtr;
        ULONG LowMemRetry_remainingBufLen;
        LARGE_INTEGER LowMemRetry_nextChunkTargetLocation;

        /*
         *  Fields used for cancelling the packet.
         */
        // BOOLEAN Cancelled;
        // KEVENT CancelledEvent;

        /*
         *  We keep the buffer and length values here as well
         *  as in the SRB because some miniports return
         *  the transferred length in SRB.DataTransferLength,
         *  and if the SRB failed we need that value again for the retry.
         *  We don't trust the lower stack to preserve any of these values in the SRB.
         */
        PUCHAR BufPtrCopy;
        ULONG BufLenCopy;
        LARGE_INTEGER TargetLocationCopy;

        /*
         *  This is a standard SCSI structure that receives a detailed
         *  report about a SCSI error on the hardware.
         */
        SENSE_DATA SrbErrorSenseData;

        /*
         *  This is the SRB block for this TRANSFER_PACKET.
         *  For IOCTLs, the SRB block includes two DWORDs for
         *  device object and ioctl code; so these must
         *  immediately follow the SRB block.
         */
        SCSI_REQUEST_BLOCK Srb;
        // ULONG SrbIoctlDevObj;        // not handling ioctls yet
        // ULONG SrbIoctlCode;

} TRANSFER_PACKET, *PTRANSFER_PACKET;

/*
 *  MIN_INITIAL_TRANSFER_PACKETS is the minimum number of packets that
 *  we preallocate at startup for each device (we need at least one packet
 *  to guarantee forward progress during memory stress).
 *  MIN_WORKINGSET_TRANSFER_PACKETS is the number of TRANSFER_PACKETs
 *  we allow to build up and remain for each device;
 *  we _lazily_ work down to this number when they're not needed.
 *  MAX_WORKINGSET_TRANSFER_PACKETS is the number of TRANSFER_PACKETs
 *  that we _immediately_ reduce to when they are not needed.
 *
 *  The absolute maximum number of packets that we will allocate is
 *  whatever is required by the current activity, up to the memory limit;
 *  as soon as stress ends, we snap down to MAX_WORKINGSET_TRANSFER_PACKETS;
 *  we then lazily work down to MIN_WORKINGSET_TRANSFER_PACKETS.
 */
#define MIN_INITIAL_TRANSFER_PACKETS                     1
#define MIN_WORKINGSET_TRANSFER_PACKETS_Consumer      4
#define MAX_WORKINGSET_TRANSFER_PACKETS_Consumer     64
#define MIN_WORKINGSET_TRANSFER_PACKETS_Server        64
#define MAX_WORKINGSET_TRANSFER_PACKETS_Server      1024
#define MIN_WORKINGSET_TRANSFER_PACKETS_Enterprise    256
#define MAX_WORKINGSET_TRANSFER_PACKETS_Enterprise   2048


//
// add to the front of this structure to help prevent illegal
// snooping by other utilities.
//
struct _CLASS_PRIVATE_FDO_DATA {

    //
    // this private structure allows us to
    // dynamically re-enable the perf benefits
    // lost due to transient error conditions.
    // in w2k, a reboot was required. :(
    //
    struct {
        ULONG      OriginalSrbFlags;
        ULONG      SuccessfulIO;
        ULONG      ReEnableThreshhold; // 0 means never
    } Perf;

    ULONG_PTR HackFlags;

    STORAGE_HOTPLUG_INFO HotplugInfo;

    // Legacy.  Still used by obsolete legacy code.
    struct {
        LARGE_INTEGER     Delta;       // in ticks
        LARGE_INTEGER     Tick;        // when it should fire
        PCLASS_RETRY_INFO ListHead;    // singly-linked list
        ULONG             Granularity; // static
        KSPIN_LOCK        Lock;        // protective spin lock
        KDPC              Dpc;         // DPC routine object
        KTIMER            Timer;       // timer to fire DPC
    } Retry;

    BOOLEAN TimerStarted;
    BOOLEAN LoggedTURFailureSinceLastIO;
    
    //
    // privately allocated release queue irp
    // protected by fdoExtension->ReleaseQueueSpinLock
    //
    BOOLEAN ReleaseQueueIrpAllocated;
    PIRP ReleaseQueueIrp;

    /*
     *  Queues for TRANSFER_PACKETs that contextualize the IRPs and SRBs
     *  that we send down to the port driver.
     *  (The free list is an slist so that we can use fast
     *   interlocked operations on it; but the relatively-static
     *   AllTransferPacketsList list has to be
     *   a doubly-linked list since we have to dequeue from the middle).
     */
    LIST_ENTRY AllTransferPacketsList;
    SLIST_HEADER FreeTransferPacketsList;
    ULONG NumFreeTransferPackets;
    ULONG NumTotalTransferPackets;
    ULONG DbgPeakNumTransferPackets;

    /*
     *  Queue for deferred client irps
     */
    LIST_ENTRY DeferredClientIrpList;

    /*
     *  Precomputed maximum transfer length for the hardware.
     */
    ULONG HwMaxXferLen;

    /*
     *  SCSI_REQUEST_BLOCK template preconfigured with the constant values.
     *  This is slapped into the SRB in the TRANSFER_PACKET for each transfer.
     */
    SCSI_REQUEST_BLOCK SrbTemplate;

    KSPIN_LOCK SpinLock;

    /*
     *  Circular array of timestamped logs of errors that occurred on this device.
     */
    ULONG ErrorLogNextIndex;
    CLASS_ERROR_LOG_DATA ErrorLogs[NUM_ERROR_LOG_ENTRIES];

};


#define MIN(a, b)   ((a) < (b) ? (a) : (b))
#define MAX(a, b)   ((a) > (b) ? (a) : (b))


#define NOT_READY_RETRY_INTERVAL    10
#define MINIMUM_RETRY_UNITS ((LONGLONG)32)


/*
 *  Simple singly-linked-list queuing macros, with no synchronization.
 */
__inline VOID SimpleInitSlistHdr(SINGLE_LIST_ENTRY *SListHdr)
{
    SListHdr->Next = NULL;
}
__inline VOID SimplePushSlist(SINGLE_LIST_ENTRY *SListHdr, SINGLE_LIST_ENTRY *SListEntry)
{
    SListEntry->Next = SListHdr->Next;
    SListHdr->Next = SListEntry;
}
__inline SINGLE_LIST_ENTRY *SimplePopSlist(SINGLE_LIST_ENTRY *SListHdr)
{
    SINGLE_LIST_ENTRY *sListEntry = SListHdr->Next;
    if (sListEntry){
        SListHdr->Next = sListEntry->Next;
        sListEntry->Next = NULL;
    }
    return sListEntry;
}
__inline BOOLEAN SimpleIsSlistEmpty(SINGLE_LIST_ENTRY *SListHdr)
{
    return (SListHdr->Next == NULL);
}

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
ClassUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
ClassCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ClasspCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ClasspCleanupProtectedLocks(
    IN PFILE_OBJECT_EXTENSION FsContext
    );

NTSTATUS
ClasspEjectionControl(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp,
    IN MEDIA_LOCK_TYPE LockType,
    IN BOOLEAN Lock
    );

NTSTATUS
ClassReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ClassDeviceControlDispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
ClassDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
ClassDispatchPnp(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
ClassPnpStartDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ClassInternalIoControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ClassShutdownFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ClassSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// Class internal routines
//

NTSTATUS
ClassAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN OUT PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
ClasspSendSynchronousCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
RetryRequest(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PSCSI_REQUEST_BLOCK Srb,
    BOOLEAN Associated,
    ULONG RetryInterval
    );

NTSTATUS
ClassIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
ClassPnpQueryFdoRelations(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    );

NTSTATUS
ClassRetrieveDeviceRelations(
    IN PDEVICE_OBJECT Fdo,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS *DeviceRelations
    );

NTSTATUS
ClassGetPdoId(
    IN PDEVICE_OBJECT Pdo,
    IN BUS_QUERY_ID_TYPE IdType,
    IN PUNICODE_STRING IdString
    );

NTSTATUS
ClassQueryPnpCapabilities(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PDEVICE_CAPABILITIES Capabilities
    );

VOID
ClasspStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ClasspPagingNotificationCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_OBJECT RealDeviceObject
    );

NTSTATUS
ClasspMediaChangeCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

PFILE_OBJECT_EXTENSION
ClasspGetFsContext(
    IN PCOMMON_DEVICE_EXTENSION CommonExtension,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
ClasspMcnControl(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
ClasspRegisterMountedDeviceInterface(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ClasspDisableTimer(
    PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ClasspEnableTimer(
    PDEVICE_OBJECT DeviceObject
    );

//
// routines for dictionary list support
//

VOID
InitializeDictionary(
    IN PDICTIONARY Dictionary
    );

BOOLEAN
TestDictionarySignature(
    IN PDICTIONARY Dictionary
    );

NTSTATUS
AllocateDictionaryEntry(
    IN PDICTIONARY Dictionary,
    IN ULONGLONG Key,
    IN ULONG Size,
    IN ULONG Tag,
    OUT PVOID *Entry
    );

PVOID
GetDictionaryEntry(
    IN PDICTIONARY Dictionary,
    IN ULONGLONG Key
    );

VOID
FreeDictionaryEntry(
    IN PDICTIONARY Dictionary,
    IN PVOID Entry
    );


NTSTATUS
ClasspAllocateReleaseRequest(
    IN PDEVICE_OBJECT Fdo
    );

VOID
ClasspFreeReleaseRequest(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
ClassReleaseQueueCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
ClasspReleaseQueue(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP ReleaseQueueIrp
    );

VOID
ClasspDisablePowerNotification(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
);

//
// class power routines
//

NTSTATUS
ClassDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ClassMinimalPowerHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// Child list routines
//

VOID
ClassAddChild(
    IN PFUNCTIONAL_DEVICE_EXTENSION Parent,
    IN PPHYSICAL_DEVICE_EXTENSION Child,
    IN BOOLEAN AcquireLock
    );

PPHYSICAL_DEVICE_EXTENSION
ClassRemoveChild(
    IN PFUNCTIONAL_DEVICE_EXTENSION Parent,
    IN PPHYSICAL_DEVICE_EXTENSION Child,
    IN BOOLEAN AcquireLock
    );

VOID
ClasspRetryDpcTimer(
    IN PCLASS_PRIVATE_FDO_DATA FdoData
    );

VOID
ClasspRetryRequestDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Arg1,
    IN PVOID Arg2
    );

VOID
ClassFreeOrReuseSrb(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
ClassRetryRequest(
    IN PDEVICE_OBJECT SelfDeviceObject,
    IN PIRP           Irp,
    IN LARGE_INTEGER  TimeDelta100ns // in 100ns units
    );

VOID
ClasspBuildRequestEx(
    IN PFUNCTIONAL_DEVICE_EXTENSION Fdo,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb
    );

NTSTATUS
ClasspAllocateReleaseQueueIrp(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );

NTSTATUS
ClasspInitializeGesn(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PMEDIA_CHANGE_DETECTION_INFO Info
    );

VOID
ClasspSendNotification(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN const GUID * Guid,
    IN ULONG  ExtraDataSize,
    IN PVOID  ExtraData
    );

VOID
ClassSendEjectionNotification(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );

VOID
ClasspScanForSpecialInRegistry(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );

VOID
ClasspScanForClassHacks(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN ULONG_PTR Data
    );

NTSTATUS
ClasspInitializeHotplugInfo(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );

VOID
ClasspPerfIncrementErrorCount(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );
VOID
ClasspPerfIncrementSuccessfulIo(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );


PTRANSFER_PACKET NewTransferPacket(PDEVICE_OBJECT Fdo);
VOID DestroyTransferPacket(PTRANSFER_PACKET Pkt);
VOID EnqueueFreeTransferPacket(PDEVICE_OBJECT Fdo, PTRANSFER_PACKET Pkt);
PTRANSFER_PACKET DequeueFreeTransferPacket(PDEVICE_OBJECT Fdo, BOOLEAN AllocIfNeeded);
VOID SetupReadWriteTransferPacket(PTRANSFER_PACKET pkt, PVOID Buf, ULONG Len, LARGE_INTEGER DiskLocation, PIRP OriginalIrp);
VOID SubmitTransferPacket(PTRANSFER_PACKET Pkt);
NTSTATUS TransferPktComplete(IN PDEVICE_OBJECT NullFdo, IN PIRP Irp, IN PVOID Context);
VOID ServiceTransferRequest(PDEVICE_OBJECT Fdo, PIRP Irp);
VOID TransferPacketRetryTimerDpc(IN PKDPC Dpc, IN PVOID DeferredContext, IN PVOID SystemArgument1, IN PVOID SystemArgument2);
BOOLEAN InterpretTransferPacketError(PTRANSFER_PACKET Pkt);
BOOLEAN RetryTransferPacket(PTRANSFER_PACKET Pkt);
VOID EnqueueDeferredClientIrp(PCLASS_PRIVATE_FDO_DATA FdoData, PIRP Irp);
PIRP DequeueDeferredClientIrp(PCLASS_PRIVATE_FDO_DATA FdoData);
VOID InitLowMemRetry(PTRANSFER_PACKET Pkt, PVOID BufPtr, ULONG Len, LARGE_INTEGER TargetLocation);
BOOLEAN StepLowMemRetry(PTRANSFER_PACKET Pkt);
VOID SetupEjectionTransferPacket(TRANSFER_PACKET *Pkt, BOOLEAN PreventMediaRemoval, PKEVENT SyncEventPtr, PIRP OriginalIrp);
VOID SetupModeSenseTransferPacket(TRANSFER_PACKET *Pkt, PKEVENT SyncEventPtr, PVOID ModeSenseBuffer, UCHAR ModeSenseBufferLen, UCHAR PageMode, PIRP OriginalIrp);
VOID SetupDriveCapacityTransferPacket(TRANSFER_PACKET *Pkt, PVOID ReadCapacityBuffer, ULONG ReadCapacityBufferLen, PKEVENT SyncEventPtr, PIRP OriginalIrp);
PMDL BuildDeviceInputMdl(PVOID Buffer, ULONG BufferLen);
VOID FreeDeviceInputMdl(PMDL Mdl);
NTSTATUS InitializeTransferPackets(PDEVICE_OBJECT Fdo);
VOID DestroyAllTransferPackets(PDEVICE_OBJECT Fdo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\classpnp\class.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    class.c

Abstract:

    SCSI class driver routines

Environment:

    kernel mode only

Notes:


Revision History:

--*/

#define CLASS_INIT_GUID 1
#include "classp.h"
#include "debug.h"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(INIT, DriverEntry)
    #pragma alloc_text(PAGE, ClassAddDevice)
    #pragma alloc_text(PAGE, ClassClaimDevice)
    #pragma alloc_text(PAGE, ClassCreateDeviceObject)
    #pragma alloc_text(PAGE, ClassDispatchPnp)
    #pragma alloc_text(PAGE, ClassGetDescriptor)
    #pragma alloc_text(PAGE, ClassGetPdoId)
    #pragma alloc_text(PAGE, ClassInitialize)
    #pragma alloc_text(PAGE, ClassInitializeEx)
    #pragma alloc_text(PAGE, ClassInvalidateBusRelations)
    #pragma alloc_text(PAGE, ClassMarkChildMissing)
    #pragma alloc_text(PAGE, ClassMarkChildrenMissing)
    #pragma alloc_text(PAGE, ClassModeSense)
    #pragma alloc_text(PAGE, ClassPnpQueryFdoRelations)
    #pragma alloc_text(PAGE, ClassPnpStartDevice)
    #pragma alloc_text(PAGE, ClassQueryPnpCapabilities)
    #pragma alloc_text(PAGE, ClassQueryTimeOutRegistryValue)
    #pragma alloc_text(PAGE, ClassRemoveDevice)
    #pragma alloc_text(PAGE, ClassRetrieveDeviceRelations)
    #pragma alloc_text(PAGE, ClassUpdateInformationInRegistry)
    #pragma alloc_text(PAGE, ClassSendDeviceIoControlSynchronous)
    #pragma alloc_text(PAGE, ClassUnload)
    #pragma alloc_text(PAGE, ClasspAllocateReleaseRequest)
    #pragma alloc_text(PAGE, ClasspFreeReleaseRequest)
    #pragma alloc_text(PAGE, ClasspInitializeHotplugInfo)
    #pragma alloc_text(PAGE, ClasspRegisterMountedDeviceInterface)
    #pragma alloc_text(PAGE, ClasspScanForClassHacks)
    #pragma alloc_text(PAGE, ClasspScanForSpecialInRegistry)
#endif

ULONG ClassPnpAllowUnload = TRUE;


#define FirstDriveLetter 'C'
#define LastDriveLetter  'Z'



/*++////////////////////////////////////////////////////////////////////////////

DriverEntry()

Routine Description:

    Temporary entry point needed to initialize the class system dll.
    It doesn't do anything.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

Return Value:

   STATUS_SUCCESS

--*/
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    return STATUS_SUCCESS;
}




/*++////////////////////////////////////////////////////////////////////////////

ClassInitialize()

Routine Description:

    This routine is called by a class driver during its
    DriverEntry routine to initialize the driver.

Arguments:

    Argument1          - Driver Object.
    Argument2          - Registry Path.
    InitializationData - Device-specific driver's initialization data.

Return Value:

    A valid return code for a DriverEntry routine.

--*/
ULONG
ClassInitialize(
    IN  PVOID            Argument1,
    IN  PVOID            Argument2,
    IN  PCLASS_INIT_DATA InitializationData
    )
{
    PDRIVER_OBJECT  DriverObject = Argument1;
    PUNICODE_STRING RegistryPath = Argument2;

    PCLASS_DRIVER_EXTENSION driverExtension;

    NTSTATUS        status;

    PAGED_CODE();

    DebugPrint((3,"\n\nSCSI Class Driver\n"));

    ClasspInitializeDebugGlobals();

    //
    // Validate the length of this structure. This is effectively a
    // version check.
    //

    if (InitializationData->InitializationDataSize != sizeof(CLASS_INIT_DATA)) {

        //
        // This DebugPrint is to help third-party driver writers
        //

        DebugPrint((0,"ClassInitialize: Class driver wrong version\n"));
        return (ULONG) STATUS_REVISION_MISMATCH;
    }

    //
    // Check that each required entry is not NULL. Note that Shutdown, Flush and Error
    // are not required entry points.
    //

    if ((!InitializationData->FdoData.ClassDeviceControl) ||
        (!((InitializationData->FdoData.ClassReadWriteVerification) ||
           (InitializationData->ClassStartIo))) ||
        (!InitializationData->ClassAddDevice) ||
        (!InitializationData->FdoData.ClassStartDevice)) {

        //
        // This DebugPrint is to help third-party driver writers
        //

        DebugPrint((0,
            "ClassInitialize: Class device-specific driver missing required "
            "FDO entry\n"));

        return (ULONG) STATUS_REVISION_MISMATCH;
    }

    if ((InitializationData->ClassEnumerateDevice) &&
        ((!InitializationData->PdoData.ClassDeviceControl) ||
         (!InitializationData->PdoData.ClassStartDevice) ||
         (!((InitializationData->PdoData.ClassReadWriteVerification) ||
            (InitializationData->ClassStartIo))))) {

        //
        // This DebugPrint is to help third-party driver writers
        //

        DebugPrint((0, "ClassInitialize: Class device-specific missing "
                       "required PDO entry\n"));

        return (ULONG) STATUS_REVISION_MISMATCH;
    }

    if((InitializationData->FdoData.ClassStopDevice == NULL) ||
        ((InitializationData->ClassEnumerateDevice != NULL) &&
         (InitializationData->PdoData.ClassStopDevice == NULL))) {

        //
        // This DebugPrint is to help third-party driver writers
        //

        DebugPrint((0, "ClassInitialize: Class device-specific missing "
                       "required PDO entry\n"));
        ASSERT(FALSE);
        return (ULONG) STATUS_REVISION_MISMATCH;
    }

    //
    // Setup the default power handlers if the class driver didn't provide
    // any.
    //

    if(InitializationData->FdoData.ClassPowerDevice == NULL) {
        InitializationData->FdoData.ClassPowerDevice = ClassMinimalPowerHandler;
    }

    if((InitializationData->ClassEnumerateDevice != NULL) &&
       (InitializationData->PdoData.ClassPowerDevice == NULL)) {
        InitializationData->PdoData.ClassPowerDevice = ClassMinimalPowerHandler;
    }

    //
    // warn that unload is not supported
    //
    // ISSUE-2000/02/03-peterwie
    // We should think about making this a fatal error.
    //

    if(InitializationData->ClassUnload == NULL) {

        //
        // This DebugPrint is to help third-party driver writers
        //

        DebugPrint((0, "ClassInitialize: driver does not support unload %wZ\n",
                    RegistryPath));
    }

    //
    // Create an extension for the driver object
    //

    status = IoAllocateDriverObjectExtension(DriverObject,
                                             CLASS_DRIVER_EXTENSION_KEY,
                                             sizeof(CLASS_DRIVER_EXTENSION),
                                             &driverExtension);

    if(NT_SUCCESS(status)) {

        //
        // Copy the registry path into the driver extension so we can use it later
        //

        driverExtension->RegistryPath.Length = RegistryPath->Length;
        driverExtension->RegistryPath.MaximumLength = RegistryPath->MaximumLength;

        driverExtension->RegistryPath.Buffer =
            ExAllocatePoolWithTag(PagedPool,
                                  RegistryPath->MaximumLength,
                                  '1CcS');

        if(driverExtension->RegistryPath.Buffer == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            return status;
        }

        RtlCopyUnicodeString(
            &(driverExtension->RegistryPath),
            RegistryPath);

        //
        // Copy the initialization data into the driver extension so we can reuse
        // it during our add device routine
        //

        RtlCopyMemory(
            &(driverExtension->InitData),
            InitializationData,
            sizeof(CLASS_INIT_DATA));

        driverExtension->DeviceCount = 0;

    } else if (status == STATUS_OBJECT_NAME_COLLISION) {

        //
        // The extension already exists - get a pointer to it
        //

        driverExtension = IoGetDriverObjectExtension(DriverObject,
                                                     CLASS_DRIVER_EXTENSION_KEY);

        ASSERT(driverExtension != NULL);

    } else {

        DebugPrint((1, "ClassInitialize: Class driver extension could not be "
                       "allocated %lx\n", status));
        return status;
    }

    //
    // Update driver object with entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = ClassCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = ClassCreateClose;
    DriverObject->MajorFunction[IRP_MJ_READ] = ClassReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = ClassReadWrite;
    DriverObject->MajorFunction[IRP_MJ_SCSI] = ClassInternalIoControl;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ClassDeviceControlDispatch;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = ClassShutdownFlush;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS] = ClassShutdownFlush;
    DriverObject->MajorFunction[IRP_MJ_PNP] = ClassDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = ClassDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = ClassSystemControl;

    if (InitializationData->ClassStartIo) {
        DriverObject->DriverStartIo = ClasspStartIo;
    }

    if ((InitializationData->ClassUnload) && (ClassPnpAllowUnload == TRUE)) {
        DriverObject->DriverUnload = ClassUnload;
    } else {
        DriverObject->DriverUnload = NULL;
    }

    DriverObject->DriverExtension->AddDevice = ClassAddDevice;

    status = STATUS_SUCCESS;
    return status;
} // end ClassInitialize()

/*++////////////////////////////////////////////////////////////////////////////

ClassInitializeEx()

Routine Description:

    This routine is allows the caller to do any extra initialization or
    setup that is not done in ClassInitialize. The operation is
    controlled by the GUID that is passed and the contents of the Data
    parameter is dependent upon the GUID.

    This is the list of supported operations:

    Guid - GUID_CLASSPNP_QUERY_REGINFOEX
    Data - A PCLASS_QUERY_WMI_REGINFO_EX callback function pointer

        Initialized classpnp to callback a PCLASS_QUERY_WMI_REGINFO_EX
        callback instead of a PCLASS_QUERY_WMI_REGINFO callback. The
        former callback allows the driver to specify the name of the
        mof resource.

Arguments:

    DriverObject
    Guid
    Data

Return Value:

    Status Code

--*/
ULONG
ClassInitializeEx(
    IN  PDRIVER_OBJECT   DriverObject,
    IN  LPGUID           Guid,
    IN  PVOID            Data
    )
{
    PCLASS_DRIVER_EXTENSION driverExtension;

    NTSTATUS        status;

    PAGED_CODE();

    driverExtension = IoGetDriverObjectExtension( DriverObject,
                                                  CLASS_DRIVER_EXTENSION_KEY
                                                  );
    if (IsEqualGUID(Guid, &ClassGuidQueryRegInfoEx))
    {
        PCLASS_QUERY_WMI_REGINFO_EX_LIST List;

        //
        // Indicate the device supports PCLASS_QUERY_REGINFO_EX
        // callback instead of PCLASS_QUERY_REGINFO callback.
        //
        List = (PCLASS_QUERY_WMI_REGINFO_EX_LIST)Data;

        if (List->Size == sizeof(CLASS_QUERY_WMI_REGINFO_EX_LIST))
        {
            driverExtension->ClassFdoQueryWmiRegInfoEx = List->ClassFdoQueryWmiRegInfoEx;
            driverExtension->ClassPdoQueryWmiRegInfoEx = List->ClassPdoQueryWmiRegInfoEx;
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_INVALID_PARAMETER;
        }
    } else {
        status = STATUS_NOT_SUPPORTED;
    }

    return(status);

} // end ClassInitializeEx()

/*++////////////////////////////////////////////////////////////////////////////

ClassUnload()

Routine Description:

    called when there are no more references to the driver.  this allows
    drivers to be updated without rebooting.

Arguments:

    DriverObject - a pointer to the driver object that is being unloaded

Status:

--*/
VOID
ClassUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    PCLASS_DRIVER_EXTENSION driverExtension;
    NTSTATUS status;

    PAGED_CODE();

    ASSERT( DriverObject->DeviceObject == NULL );

    driverExtension = IoGetDriverObjectExtension( DriverObject,
                                                  CLASS_DRIVER_EXTENSION_KEY
                                                  );

    ASSERT(driverExtension != NULL);
    ASSERT(driverExtension->RegistryPath.Buffer != NULL);
    ASSERT(driverExtension->InitData.ClassUnload != NULL);

    DebugPrint((1, "ClassUnload: driver unloading %wZ\n",
                &driverExtension->RegistryPath));

    //
    // attempt to process the driver's unload routine first.
    //

    driverExtension->InitData.ClassUnload(DriverObject);

    //
    // free own allocated resources and return
    //

    ExFreePool( driverExtension->RegistryPath.Buffer );
    driverExtension->RegistryPath.Buffer = NULL;
    driverExtension->RegistryPath.Length = 0;
    driverExtension->RegistryPath.MaximumLength = 0;

    return;
} // end ClassUnload()

/*++////////////////////////////////////////////////////////////////////////////

ClassAddDevice()

Routine Description:

    SCSI class driver add device routine.  This is called by pnp when a new
    physical device come into being.

    This routine will call out to the class driver to verify that it should
    own this device then will create and attach a device object and then hand
    it to the driver to initialize and create symbolic links

Arguments:

    DriverObject - a pointer to the driver object that this is being created for
    PhysicalDeviceObject - a pointer to the physical device object

Status: STATUS_NO_SUCH_DEVICE if the class driver did not want this device
    STATUS_SUCCESS if the creation and attachment was successful
    status of device creation and initialization

--*/
NTSTATUS
ClassAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
{
    PCLASS_DRIVER_EXTENSION driverExtension =
        IoGetDriverObjectExtension(DriverObject,
                                   CLASS_DRIVER_EXTENSION_KEY);

    NTSTATUS status;

    PAGED_CODE();

    status = driverExtension->InitData.ClassAddDevice(DriverObject,
                                                      PhysicalDeviceObject);
    return status;
} // end ClassAddDevice()

/*++////////////////////////////////////////////////////////////////////////////

ClassDispatchPnp()

Routine Description:

    Storage class driver pnp routine.  This is called by the io system when
    a PNP request is sent to the device.

Arguments:

    DeviceObject - pointer to the device object

    Irp - pointer to the io request packet

Return Value:

    status

--*/
NTSTATUS
ClassDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    BOOLEAN isFdo = commonExtension->IsFdo;

    PCLASS_DRIVER_EXTENSION driverExtension;
    PCLASS_INIT_DATA initData;
    PCLASS_DEV_INFO devInfo;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation(Irp);

    NTSTATUS status = Irp->IoStatus.Status;
    BOOLEAN completeRequest = TRUE;
    BOOLEAN lockReleased = FALSE;

    ULONG isRemoved;

    PAGED_CODE();

    //
    // Extract all the useful information out of the driver object
    // extension
    //

    driverExtension = IoGetDriverObjectExtension(DeviceObject->DriverObject,
                                                 CLASS_DRIVER_EXTENSION_KEY);
    if (driverExtension){

        initData = &(driverExtension->InitData);

        if(isFdo) {
            devInfo = &(initData->FdoData);
        } else {
            devInfo = &(initData->PdoData);
        }

        isRemoved = ClassAcquireRemoveLock(DeviceObject, Irp);

        DebugPrint((2, "ClassDispatchPnp (%p,%p): minor code %#x for %s %p\n",
                       DeviceObject, Irp,
                       irpStack->MinorFunction,
                       isFdo ? "fdo" : "pdo",
                       DeviceObject));
        DebugPrint((2, "ClassDispatchPnp (%p,%p): previous %#x, current %#x\n",
                       DeviceObject, Irp,
                       commonExtension->PreviousState,
                       commonExtension->CurrentState));

        switch(irpStack->MinorFunction) {

            case IRP_MN_START_DEVICE: {

                //
                // if this is sent to the FDO we should forward it down the
                // attachment chain before we start the FDO.
                //

                if (isFdo) {
                    status = ClassForwardIrpSynchronous(commonExtension, Irp);
                }
                else {
                    status = STATUS_SUCCESS;
                }

                if (NT_SUCCESS(status)){
                    status = Irp->IoStatus.Status = ClassPnpStartDevice(DeviceObject);
                }

                break;
            }


            case IRP_MN_QUERY_DEVICE_RELATIONS: {

                DEVICE_RELATION_TYPE type =
                    irpStack->Parameters.QueryDeviceRelations.Type;

                PDEVICE_RELATIONS deviceRelations = NULL;

                if(!isFdo) {

                    if(type == TargetDeviceRelation) {

                        //
                        // Device relations has one entry built in to it's size.
                        //

                        status = STATUS_INSUFFICIENT_RESOURCES;

                        deviceRelations = ExAllocatePoolWithTag(PagedPool,
                                                         sizeof(DEVICE_RELATIONS),
                                                         '2CcS');

                        if(deviceRelations != NULL) {

                            RtlZeroMemory(deviceRelations,
                                          sizeof(DEVICE_RELATIONS));

                            Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

                            deviceRelations->Count = 1;
                            deviceRelations->Objects[0] = DeviceObject;
                            ObReferenceObject(deviceRelations->Objects[0]);

                            status = STATUS_SUCCESS;
                        }

                    } else {
                        //
                        // PDO's just complete enumeration requests without altering
                        // the status.
                        //

                        status = Irp->IoStatus.Status;
                    }

                    break;

                } else if (type == BusRelations) {

                    ASSERT(commonExtension->IsInitialized);

                    //
                    // Make sure we support enumeration
                    //

                    if(initData->ClassEnumerateDevice == NULL) {

                        //
                        // Just send the request down to the lower driver.  Perhaps
                        // It can enumerate children.
                        //

                    } else {

                        //
                        // Re-enumerate the device
                        //

                        status = ClassPnpQueryFdoRelations(DeviceObject, Irp);

                        if(!NT_SUCCESS(status)) {
                            completeRequest = TRUE;
                            break;
                        }
                    }
                }

                IoCopyCurrentIrpStackLocationToNext(Irp);
                ClassReleaseRemoveLock(DeviceObject, Irp);
                status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);
                completeRequest = FALSE;

                break;
            }

            case IRP_MN_QUERY_ID: {

                BUS_QUERY_ID_TYPE idType = irpStack->Parameters.QueryId.IdType;
                UNICODE_STRING unicodeString;

                if(isFdo) {

                    //
                    // FDO's should just forward the query down to the lower
                    // device objects
                    //

                    IoCopyCurrentIrpStackLocationToNext(Irp);
                    ClassReleaseRemoveLock(DeviceObject, Irp);

                    status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);
                    completeRequest = FALSE;
                    break;
                }

                //
                // PDO's need to give an answer - this is easy for now
                //

                RtlInitUnicodeString(&unicodeString, NULL);

                status = ClassGetPdoId(DeviceObject,
                                       idType,
                                       &unicodeString);

                if(status == STATUS_NOT_IMPLEMENTED) {
                    //
                    // The driver doesn't implement this ID (whatever it is).
                    // Use the status out of the IRP so that we don't mangle a
                    // response from someone else.
                    //

                    status = Irp->IoStatus.Status;
                } else if(NT_SUCCESS(status)) {
                    Irp->IoStatus.Information = (ULONG_PTR) unicodeString.Buffer;
                } else {
                    Irp->IoStatus.Information = (ULONG_PTR) NULL;
                }

                break;
            }

            case IRP_MN_QUERY_STOP_DEVICE:
            case IRP_MN_QUERY_REMOVE_DEVICE: {

                DebugPrint((2, "ClassDispatchPnp (%p,%p): Processing QUERY_%s irp\n",
                            DeviceObject, Irp,
                            ((irpStack->MinorFunction == IRP_MN_QUERY_STOP_DEVICE) ?
                             "STOP" : "REMOVE")));

                //
                // If this device is in use for some reason (paging, etc...)
                // then we need to fail the request.
                //

                if(commonExtension->PagingPathCount != 0) {

                    DebugPrint((1, "ClassDispatchPnp (%p,%p): device is in paging "
                                "path and cannot be removed\n",
                                DeviceObject, Irp));
                    status = STATUS_DEVICE_BUSY;
                    break;
                }

                //
                // Check with the class driver to see if the query operation
                // can succeed.
                //

                if(irpStack->MinorFunction == IRP_MN_QUERY_STOP_DEVICE) {
                    status = devInfo->ClassStopDevice(DeviceObject,
                                                      irpStack->MinorFunction);
                } else {
                    status = devInfo->ClassRemoveDevice(DeviceObject,
                                                        irpStack->MinorFunction);
                }

                if(NT_SUCCESS(status)) {

                    //
                    // ASSERT that we never get two queries in a row, as
                    // this will severly mess up the state machine
                    //
                    ASSERT(commonExtension->CurrentState != irpStack->MinorFunction);
                    commonExtension->PreviousState = commonExtension->CurrentState;
                    commonExtension->CurrentState = irpStack->MinorFunction;

                    if(isFdo) {
                        DebugPrint((2, "ClassDispatchPnp (%p,%p): Forwarding QUERY_"
                                    "%s irp\n", DeviceObject, Irp,
                                    ((irpStack->MinorFunction == IRP_MN_QUERY_STOP_DEVICE) ?
                                     "STOP" : "REMOVE")));
                        status = ClassForwardIrpSynchronous(commonExtension, Irp);
                    }
                }
                DebugPrint((2, "ClassDispatchPnp (%p,%p): Final status == %x\n",
                            DeviceObject, Irp, status));

                break;
            }

            case IRP_MN_CANCEL_STOP_DEVICE:
            case IRP_MN_CANCEL_REMOVE_DEVICE: {

                //
                // Check with the class driver to see if the query or cancel
                // operation can succeed.
                //

                if(irpStack->MinorFunction == IRP_MN_CANCEL_STOP_DEVICE) {
                    status = devInfo->ClassStopDevice(DeviceObject,
                                                      irpStack->MinorFunction);
                    ASSERTMSG("ClassDispatchPnp !! CANCEL_STOP_DEVICE should "
                              "never be failed\n", NT_SUCCESS(status));
                } else {
                    status = devInfo->ClassRemoveDevice(DeviceObject,
                                                        irpStack->MinorFunction);
                    ASSERTMSG("ClassDispatchPnp !! CANCEL_REMOVE_DEVICE should "
                              "never be failed\n", NT_SUCCESS(status));
                }

                Irp->IoStatus.Status = status;

                //
                // We got a CANCEL - roll back to the previous state only
                // if the current state is the respective QUERY state.
                //

                if(((irpStack->MinorFunction == IRP_MN_CANCEL_STOP_DEVICE) &&
                    (commonExtension->CurrentState == IRP_MN_QUERY_STOP_DEVICE)
                    ) ||
                   ((irpStack->MinorFunction == IRP_MN_CANCEL_REMOVE_DEVICE) &&
                    (commonExtension->CurrentState == IRP_MN_QUERY_REMOVE_DEVICE)
                    )
                   ) {

                    commonExtension->CurrentState =
                        commonExtension->PreviousState;
                    commonExtension->PreviousState = 0xff;

                }

                if(isFdo) {
                    IoCopyCurrentIrpStackLocationToNext(Irp);
                    ClassReleaseRemoveLock(DeviceObject, Irp);
                    status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);
                    completeRequest = FALSE;
                } else {
                    status = STATUS_SUCCESS;
                }

                break;
            }

            case IRP_MN_STOP_DEVICE: {

                //
                // These all mean nothing to the class driver currently.  The
                // port driver will handle all queueing when necessary.
                //

                DebugPrint((2, "ClassDispatchPnp (%p,%p): got stop request for %s\n",
                            DeviceObject, Irp,
                            (isFdo ? "fdo" : "pdo")
                            ));

                ASSERT(commonExtension->PagingPathCount == 0);

                //
                // ISSUE-2000/02/03-peterwie
                // if we stop the timer here then it means no class driver can
                // do i/o in its ClassStopDevice routine.  This is because the
                // retry (among other things) is tied into the tick handler
                // and disabling retries could cause the class driver to deadlock.
                // Currently no class driver we're aware of issues i/o in its
                // Stop routine but this is a case we may want to defend ourself
                // against.
                //

                if (DeviceObject->Timer) {
                    IoStopTimer(DeviceObject);
                }

                status = devInfo->ClassStopDevice(DeviceObject, IRP_MN_STOP_DEVICE);

                ASSERTMSG("ClassDispatchPnp !! STOP_DEVICE should "
                          "never be failed\n", NT_SUCCESS(status));

                if(isFdo) {
                    status = ClassForwardIrpSynchronous(commonExtension, Irp);
                }

                if(NT_SUCCESS(status)) {
                    commonExtension->CurrentState = irpStack->MinorFunction;
                    commonExtension->PreviousState = 0xff;
                }

                break;
            }

            case IRP_MN_REMOVE_DEVICE:
            case IRP_MN_SURPRISE_REMOVAL: {

                PDEVICE_OBJECT lowerDeviceObject = commonExtension->LowerDeviceObject;
                UCHAR removeType = irpStack->MinorFunction;

                if (commonExtension->PagingPathCount != 0) {
                    DBGTRACE(ClassDebugWarning, ("ClassDispatchPnp (%p,%p): paging device is getting removed!", DeviceObject, Irp));
                }

                //
                // Release the lock for this IRP before calling in.
                //
                ClassReleaseRemoveLock(DeviceObject, Irp);
                lockReleased = TRUE;

                /*
                 *  If a timer was started on the device, stop it.
                 */
                if (DeviceObject->Timer) {
                    IoStopTimer(DeviceObject);
                }

                /*
                 *  "Fire-and-forget" the remove irp to the lower stack.
                 *  Don't touch the irp (or the irp stack!) after this.
                 */
                if (isFdo) {
                    IoCopyCurrentIrpStackLocationToNext(Irp);
                    status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);
                    ASSERT(NT_SUCCESS(status));
                    completeRequest = FALSE;
                }
                else {
                    status = STATUS_SUCCESS;
                }

                /*
                 *  Do our own cleanup and call the class driver's remove
                 *  cleanup routine.
                 *  For IRP_MN_REMOVE_DEVICE, this also deletes our device object,
                 *  so don't touch the extension after this.
                 */
                commonExtension->PreviousState = commonExtension->CurrentState;
                commonExtension->CurrentState = removeType;
                ClassRemoveDevice(DeviceObject, removeType);

                break;
            }

            case IRP_MN_DEVICE_USAGE_NOTIFICATION: {

                switch(irpStack->Parameters.UsageNotification.Type) {

                    case DeviceUsageTypePaging: {

                        BOOLEAN setPagable;

                        if((irpStack->Parameters.UsageNotification.InPath) &&
                           (commonExtension->CurrentState != IRP_MN_START_DEVICE)) {

                            //
                            // Device isn't started.  Don't allow adding a
                            // paging file, but allow a removal of one.
                            //

                            status = STATUS_DEVICE_NOT_READY;
                            break;
                        }

                        ASSERT(commonExtension->IsInitialized);

                        //
                        // need to synchronize this now...
                        //

                        KeEnterCriticalRegion();
                        status = KeWaitForSingleObject(&commonExtension->PathCountEvent,
                                                       Executive, KernelMode,
                                                       FALSE, NULL);
                        ASSERT(NT_SUCCESS(status));
                        status = STATUS_SUCCESS;

                        //
                        // If the volume is removable we should try to lock it in
                        // place or unlock it once per paging path count
                        //

                        if (commonExtension->IsFdo){
                            status = ClasspEjectionControl(
                                            DeviceObject,
                                            Irp,
                                            InternalMediaLock,
                                            (BOOLEAN)irpStack->Parameters.UsageNotification.InPath);
                        }

                        if (!NT_SUCCESS(status)){
                            KeSetEvent(&commonExtension->PathCountEvent, IO_NO_INCREMENT, FALSE);
                            KeLeaveCriticalRegion();
                            break;
                        }

                        //
                        // if removing last paging device, need to set DO_POWER_PAGABLE
                        // bit here, and possible re-set it below on failure.
                        //

                        setPagable = FALSE;

                        if (!irpStack->Parameters.UsageNotification.InPath &&
                            commonExtension->PagingPathCount == 1
                            ) {

                            //
                            // removing last paging file
                            // must have DO_POWER_PAGABLE bits set, but only
                            // if noone set the DO_POWER_INRUSH bit
                            //


                            if (TEST_FLAG(DeviceObject->Flags, DO_POWER_INRUSH)) {
                                DebugPrint((2, "ClassDispatchPnp (%p,%p): Last "
                                            "paging file removed, but "
                                            "DO_POWER_INRUSH was set, so NOT "
                                            "setting DO_POWER_PAGABLE\n",
                                            DeviceObject, Irp));
                            } else {
                                DebugPrint((2, "ClassDispatchPnp (%p,%p): Last "
                                            "paging file removed, "
                                            "setting DO_POWER_PAGABLE\n",
                                            DeviceObject, Irp));
                                SET_FLAG(DeviceObject->Flags, DO_POWER_PAGABLE);
                                setPagable = TRUE;
                            }

                        }

                        //
                        // forward the irp before finishing handling the
                        // special cases
                        //

                        status = ClassForwardIrpSynchronous(commonExtension, Irp);

                        //
                        // now deal with the failure and success cases.
                        // note that we are not allowed to fail the irp
                        // once it is sent to the lower drivers.
                        //

                        if (NT_SUCCESS(status)) {

                            IoAdjustPagingPathCount(
                                &commonExtension->PagingPathCount,
                                irpStack->Parameters.UsageNotification.InPath);

                            if (irpStack->Parameters.UsageNotification.InPath) {
                                if (commonExtension->PagingPathCount == 1) {
                                    DebugPrint((2, "ClassDispatchPnp (%p,%p): "
                                                "Clearing PAGABLE bit\n",
                                                DeviceObject, Irp));
                                    CLEAR_FLAG(DeviceObject->Flags, DO_POWER_PAGABLE);
                                }
                            }

                        } else {

                            //
                            // cleanup the changes done above
                            //

                            if (setPagable == TRUE) {
                                DebugPrint((2, "ClassDispatchPnp (%p,%p): Unsetting "
                                            "PAGABLE bit due to irp failure\n",
                                            DeviceObject, Irp));
                                CLEAR_FLAG(DeviceObject->Flags, DO_POWER_PAGABLE);
                                setPagable = FALSE;
                            }

                            //
                            // relock or unlock the media if needed.
                            //

                            if (commonExtension->IsFdo) {

                                ClasspEjectionControl(
                                        DeviceObject,
                                        Irp,
                                        InternalMediaLock,
                                        (BOOLEAN)!irpStack->Parameters.UsageNotification.InPath);
                            }
                        }

                        //
                        // set the event so the next one can occur.
                        //

                        KeSetEvent(&commonExtension->PathCountEvent,
                                   IO_NO_INCREMENT, FALSE);
                        KeLeaveCriticalRegion();
                        break;
                    }

                    case DeviceUsageTypeHibernation: {

                        IoAdjustPagingPathCount(
                            &commonExtension->HibernationPathCount,
                            irpStack->Parameters.UsageNotification.InPath
                            );
                        status = ClassForwardIrpSynchronous(commonExtension, Irp);
                        if (!NT_SUCCESS(status)) {
                            IoAdjustPagingPathCount(
                                &commonExtension->HibernationPathCount,
                                !irpStack->Parameters.UsageNotification.InPath
                                );
                        }

                        break;
                    }

                    case DeviceUsageTypeDumpFile: {
                        IoAdjustPagingPathCount(
                            &commonExtension->DumpPathCount,
                            irpStack->Parameters.UsageNotification.InPath
                            );
                        status = ClassForwardIrpSynchronous(commonExtension, Irp);
                        if (!NT_SUCCESS(status)) {
                            IoAdjustPagingPathCount(
                                &commonExtension->DumpPathCount,
                                !irpStack->Parameters.UsageNotification.InPath
                                );
                        }

                        break;
                    }

                    default: {
                        status = STATUS_INVALID_PARAMETER;
                        break;
                    }
                }
                break;
            }

            case IRP_MN_QUERY_CAPABILITIES: {

                DebugPrint((2, "ClassDispatchPnp (%p,%p): QueryCapabilities\n",
                            DeviceObject, Irp));

                if(!isFdo) {

                    status = ClassQueryPnpCapabilities(
                                DeviceObject,
                                irpStack->Parameters.DeviceCapabilities.Capabilities
                                );

                    break;

                } else {

                    PDEVICE_CAPABILITIES deviceCapabilities;
                    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
                    PCLASS_PRIVATE_FDO_DATA fdoData;

                    fdoExtension = DeviceObject->DeviceExtension;
                    fdoData = fdoExtension->PrivateFdoData;
                    deviceCapabilities =
                        irpStack->Parameters.DeviceCapabilities.Capabilities;

                    //
                    // forward the irp before handling the special cases
                    //

                    status = ClassForwardIrpSynchronous(commonExtension, Irp);
                    if (!NT_SUCCESS(status)) {
                        break;
                    }

                    //
                    // we generally want to remove the device from the hotplug
                    // applet, which requires the SR-OK bit to be set.
                    // only when the user specifies that they are capable of
                    // safely removing things do we want to clear this bit
                    // (saved in WriteCacheEnableOverride)
                    //
                    // setting of this bit is done either above, or by the
                    // lower driver.
                    //
                    // note: may not be started, so check we have FDO data first.
                    //

                    if (fdoData &&
                        fdoData->HotplugInfo.WriteCacheEnableOverride) {
                        if (deviceCapabilities->SurpriseRemovalOK) {
                            DebugPrint((1, "Classpnp: Clearing SR-OK bit in "
                                        "device capabilities due to hotplug "
                                        "device or media\n"));
                        }
                        deviceCapabilities->SurpriseRemovalOK = FALSE;
                    }
                    break;

                } // end QUERY_CAPABILITIES for FDOs

                ASSERT(FALSE);
                break;


            } // end QUERY_CAPABILITIES

            default: {

                if (isFdo){
                    IoCopyCurrentIrpStackLocationToNext(Irp);

                    ClassReleaseRemoveLock(DeviceObject, Irp);
                    status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);

                    completeRequest = FALSE;
                }

                break;
            }
        }
    }
    else {
        ASSERT(driverExtension);
        status = STATUS_INTERNAL_ERROR;
    }

    if (completeRequest){
        Irp->IoStatus.Status = status;

        if (!lockReleased){
            ClassReleaseRemoveLock(DeviceObject, Irp);
        }

        ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);

        DBGTRACE(ClassDebugTrace, ("ClassDispatchPnp (%p,%p): leaving with previous %#x, current %#x.", DeviceObject, Irp, commonExtension->PreviousState, commonExtension->CurrentState));
    }
    else {
        /*
         *  The irp is already completed so don't touch it.
         *  This may be a remove so don't touch the device extension.
         */
        DBGTRACE(ClassDebugTrace, ("ClassDispatchPnp (%p,%p): leaving.", DeviceObject, Irp));
    }

    return status;
} // end ClassDispatchPnp()

/*++////////////////////////////////////////////////////////////////////////////

ClassPnpStartDevice()

Routine Description:

    Storage class driver routine for IRP_MN_START_DEVICE requests.
    This routine kicks off any device specific initialization

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the io request packet

Return Value:

    none

--*/
NTSTATUS ClassPnpStartDevice(IN PDEVICE_OBJECT DeviceObject)
{
    PCLASS_DRIVER_EXTENSION driverExtension;
    PCLASS_INIT_DATA initData;

    PCLASS_DEV_INFO devInfo;

    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    BOOLEAN isFdo = commonExtension->IsFdo;

    BOOLEAN isMountedDevice = TRUE;
    UNICODE_STRING  interfaceName;

    BOOLEAN timerStarted;

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    driverExtension = IoGetDriverObjectExtension(DeviceObject->DriverObject,
                                                 CLASS_DRIVER_EXTENSION_KEY);

    initData = &(driverExtension->InitData);
    if(isFdo) {
        devInfo = &(initData->FdoData);
    } else {
        devInfo = &(initData->PdoData);
    }

    ASSERT(devInfo->ClassInitDevice != NULL);
    ASSERT(devInfo->ClassStartDevice != NULL);

    if (!commonExtension->IsInitialized){

        //
        // perform FDO/PDO specific initialization
        //

        if (isFdo){
            STORAGE_PROPERTY_ID propertyId;

            //
            // allocate a private extension for class data
            //

            if (fdoExtension->PrivateFdoData == NULL) {
                fdoExtension->PrivateFdoData =
                    ExAllocatePoolWithTag(NonPagedPool,
                                          sizeof(CLASS_PRIVATE_FDO_DATA),
                                          CLASS_TAG_PRIVATE_DATA
                                          );
            }

            if (fdoExtension->PrivateFdoData == NULL) {
                DebugPrint((0, "ClassPnpStartDevice: Cannot allocate for "
                            "private fdo data\n"));
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            //
            // initialize the struct's various fields.
            //

            RtlZeroMemory(fdoExtension->PrivateFdoData,
                          sizeof(CLASS_PRIVATE_FDO_DATA)
                          );
            KeInitializeTimer(&fdoExtension->PrivateFdoData->Retry.Timer);
            KeInitializeDpc(&fdoExtension->PrivateFdoData->Retry.Dpc,
                            ClasspRetryRequestDpc,
                            DeviceObject);
            KeInitializeSpinLock(&fdoExtension->PrivateFdoData->Retry.Lock);
            fdoExtension->PrivateFdoData->Retry.Granularity =
                KeQueryTimeIncrement();
            commonExtension->Reserved4 = (ULONG_PTR)(' GPH'); // debug aid

            //
            // NOTE: the old interface allowed the class driver to allocate
            // this.  this was unsafe for low-memory conditions. allocate one
            // unconditionally now, and modify our internal functions to use
            // our own exclusively as it is the only safe way to do this.
            //

            status = ClasspAllocateReleaseQueueIrp(fdoExtension);
            if (!NT_SUCCESS(status)) {
                DebugPrint((0, "ClassPnpStartDevice: Cannot allocate the "
                            "private release queue irp\n"));
                return status;
            }

            //
            // Call port driver to get adapter capabilities.
            //

            propertyId = StorageAdapterProperty;

            status = ClassGetDescriptor(
                        commonExtension->LowerDeviceObject,
                        &propertyId,
                        &fdoExtension->AdapterDescriptor);

            if(!NT_SUCCESS(status)) {

                //
                // This DebugPrint is to help third-party driver writers
                //

                DebugPrint((0, "ClassPnpStartDevice: ClassGetDescriptor "
                               "[ADAPTER] failed %lx\n", status));
                return status;
            }

            //
            // Call port driver to get device descriptor.
            //

            propertyId = StorageDeviceProperty;

            status = ClassGetDescriptor(
                        commonExtension->LowerDeviceObject,
                        &propertyId,
                        &fdoExtension->DeviceDescriptor);

            if(!NT_SUCCESS(status)) {

                //
                // This DebugPrint is to help third-party driver writers
                //

                DebugPrint((0, "ClassPnpStartDevice: ClassGetDescriptor "
                               "[DEVICE] failed %lx\n", status));
                return status;
            }

            ClasspScanForSpecialInRegistry(fdoExtension);
            ClassScanForSpecial(fdoExtension,
                                ClassBadItems,
                                ClasspScanForClassHacks);

            //
            // allow perf to be re-enabled after a given number of failed IOs
            // require this number to be at least CLASS_PERF_RESTORE_MINIMUM
            //

            {
                ULONG t = 0;
                ClassGetDeviceParameter(fdoExtension,
                                        CLASSP_REG_SUBKEY_NAME,
                                        CLASSP_REG_PERF_RESTORE_VALUE_NAME,
                                        &t);
                if (t >= CLASS_PERF_RESTORE_MINIMUM) {
                    fdoExtension->PrivateFdoData->Perf.ReEnableThreshhold = t;
                }
            }


            //
            // compatibility comes first.  writable cd media will not
            // get a SYNCH_CACHE on power down.
            //

            if (fdoExtension->DeviceObject->DeviceType != FILE_DEVICE_DISK) {
                SET_FLAG(fdoExtension->PrivateFdoData->HackFlags,
                         FDO_HACK_NO_SYNC_CACHE);
            }

            //
            // initialize the hotplug information only after the ScanForSpecial
            // routines, as it relies upon the hack flags.
            //

            status = ClasspInitializeHotplugInfo(fdoExtension);

            if (!NT_SUCCESS(status)) {
                DebugPrint((1, "ClassPnpStartDevice: Could not initialize "
                            "hotplug information %lx\n", status));
                return status;
            }

            /*
             *  Allocate/initialize TRANSFER_PACKETs and related resources.
             */
            status = InitializeTransferPackets(DeviceObject);
        }

        //
        // ISSUE - drivers need to disable write caching on the media
        //         if hotplug and !useroverride.  perhaps we should
        //         allow registration of a callback to enable/disable
        //         write cache instead.
        //

        if (NT_SUCCESS(status)){
            status = devInfo->ClassInitDevice(DeviceObject);
        }

    }

    if (!NT_SUCCESS(status)){

        //
        // Just bail out - the remove that comes down will clean up the
        // initialized scraps.
        //

        return status;
    } else {
        commonExtension->IsInitialized = TRUE;

        if (commonExtension->IsFdo) {
            fdoExtension->PrivateFdoData->Perf.OriginalSrbFlags = fdoExtension->SrbFlags;
        }

    }

    //
    // If device requests autorun functionality or a once a second callback
    // then enable the once per second timer.
    //
    // NOTE: This assumes that ClassInitializeMediaChangeDetection is always
    //       called in the context of the ClassInitDevice callback. If called
    //       after then this check will have already been made and the
    //       once a second timer will not have been enabled.
    //
    if ((isFdo) &&
        ((initData->ClassTick != NULL) ||
         (fdoExtension->MediaChangeDetectionInfo != NULL) ||
         ((fdoExtension->FailurePredictionInfo != NULL) &&
          (fdoExtension->FailurePredictionInfo->Method != FailurePredictionNone))))
    {
        ClasspEnableTimer(DeviceObject);
        timerStarted = TRUE;
    } else {
        timerStarted = FALSE;
    }

    //
    // NOTE: the timer looks at commonExtension->CurrentState now
    //       to prevent Media Change Notification code from running
    //       until the device is started, but allows the device
    //       specific tick handler to run.  therefore it is imperative
    //       that commonExtension->CurrentState not be updated until
    //       the device specific startdevice handler has finished.
    //

    status = devInfo->ClassStartDevice(DeviceObject);

    if(NT_SUCCESS(status)) {
        commonExtension->CurrentState = IRP_MN_START_DEVICE;

        if((isFdo) && (initData->ClassEnumerateDevice != NULL)) {
            isMountedDevice = FALSE;
        }

        if((DeviceObject->DeviceType != FILE_DEVICE_DISK) &&
           (DeviceObject->DeviceType != FILE_DEVICE_CD_ROM)) {

            isMountedDevice = FALSE;
        }


        if(isMountedDevice) {
            ClasspRegisterMountedDeviceInterface(DeviceObject);
        }

        if((commonExtension->IsFdo) &&
           (devInfo->ClassWmiInfo.GuidRegInfo != NULL)) {

            IoWMIRegistrationControl(DeviceObject, WMIREG_ACTION_REGISTER);
        }
    } else {

        if (timerStarted) {
            ClasspDisableTimer(DeviceObject);
        }
    }

    return status;
}


/*++////////////////////////////////////////////////////////////////////////////

ClassReadWrite()

Routine Description:

    This is the system entry point for read and write requests. The
    device-specific handler is invoked to perform any validation necessary.

    If the device object is a PDO (partition object) then the request will
    simply be adjusted for Partition0 and issued to the lower device driver.

    IF the device object is an FDO (paritition 0 object), the number of bytes
    in the request are checked against the maximum byte counts that the adapter
    supports and requests are broken up into
    smaller sizes if necessary.

Arguments:

    DeviceObject - a pointer to the device object for this request

    Irp - IO request

Return Value:

    NT Status

--*/
NTSTATUS ClassReadWrite(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PDEVICE_OBJECT      lowerDeviceObject = commonExtension->LowerDeviceObject;
    PIO_STACK_LOCATION  currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    LARGE_INTEGER       startingOffset = currentIrpStack->Parameters.Read.ByteOffset;
    ULONG               transferByteCount = currentIrpStack->Parameters.Read.Length;
    ULONG               isRemoved;
    NTSTATUS            status;

    /*
     *  Grab the remove lock.  If we can't acquire it, bail out.
     */
    isRemoved = ClassAcquireRemoveLock(DeviceObject, Irp);
    if (isRemoved) {
        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        ClassReleaseRemoveLock(DeviceObject, Irp);
        ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
        status = STATUS_DEVICE_DOES_NOT_EXIST;
    }
    else if (TEST_FLAG(DeviceObject->Flags, DO_VERIFY_VOLUME) &&
             (currentIrpStack->MinorFunction != CLASSP_VOLUME_VERIFY_CHECKED) &&
             !TEST_FLAG(currentIrpStack->Flags, SL_OVERRIDE_VERIFY_VOLUME)){

        /*
         *  DO_VERIFY_VOLUME is set for the device object,
         *  but this request is not itself a verify request.
         *  So fail this request.
         */
        IoSetHardErrorOrVerifyDevice(Irp, DeviceObject);
        Irp->IoStatus.Status = STATUS_VERIFY_REQUIRED;
        Irp->IoStatus.Information = 0;
        ClassReleaseRemoveLock(DeviceObject, Irp);
        ClassCompleteRequest(DeviceObject, Irp, 0);
        status = STATUS_VERIFY_REQUIRED;
    }
    else {

        /*
         *  Since we've bypassed the verify-required tests we don't need to repeat
         *  them with this IRP - in particular we don't want to worry about
         *  hitting them at the partition 0 level if the request has come through
         *  a non-zero partition.
         */
        currentIrpStack->MinorFunction = CLASSP_VOLUME_VERIFY_CHECKED;

        /*
         *  Call the miniport driver's pre-pass filter to check if we
         *  should continue with this transfer.
         */
        ASSERT(commonExtension->DevInfo->ClassReadWriteVerification);
        status = commonExtension->DevInfo->ClassReadWriteVerification(DeviceObject, Irp);
        if (!NT_SUCCESS(status)){
            ASSERT(Irp->IoStatus.Status == status);
            ClassReleaseRemoveLock(DeviceObject, Irp);
            ClassCompleteRequest (DeviceObject, Irp, IO_NO_INCREMENT);
        }
        else if (status == STATUS_PENDING){
            /*
             *  ClassReadWriteVerification queued this request.
             *  So don't touch the irp anymore.
             */
        }
        else {

            if (transferByteCount == 0) {
                /*
                 *  Several parts of the code turn 0 into 0xffffffff,
                 *  so don't process a zero-length request any further.
                 */
                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = 0;
                ClassReleaseRemoveLock(DeviceObject, Irp);
                ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
                status = STATUS_SUCCESS;
            }
            else {
                /*
                 *  If the driver has its own StartIo routine, call it.
                 */
                if (commonExtension->DriverExtension->InitData.ClassStartIo) {
                    IoMarkIrpPending(Irp);
                    IoStartPacket(DeviceObject, Irp, NULL, NULL);
                    status = STATUS_PENDING;
                }
                else {
                    /*
                     *  The driver does not have its own StartIo routine.
                     *  So process this request ourselves.
                     */

                    /*
                     *  Add partition byte offset to make starting byte relative to
                     *  beginning of disk.
                     */
                    currentIrpStack->Parameters.Read.ByteOffset.QuadPart +=
                        commonExtension->StartingOffset.QuadPart;

                    if (commonExtension->IsFdo){

                        /*
                         *  Add in any skew for the disk manager software.
                         */
                        currentIrpStack->Parameters.Read.ByteOffset.QuadPart +=
                             commonExtension->PartitionZeroExtension->DMByteSkew;

                        /*
                         *  Perform the actual transfer(s) on the hardware
                         *  to service this request.
                         */
                        ServiceTransferRequest(DeviceObject, Irp);
                        status = STATUS_PENDING;
                    }
                    else {
                        /*
                         *  This is a child PDO enumerated for our FDO by e.g. disk.sys
                         *  and owned by e.g. partmgr.  Send it down to the next device
                         *  and the same irp will come back to us for the FDO.
                         */
                        IoCopyCurrentIrpStackLocationToNext(Irp);
                        ClassReleaseRemoveLock(DeviceObject, Irp);
                        status = IoCallDriver(lowerDeviceObject, Irp);
                    }
                }
            }
        }
    }

    return status;
}


/*++////////////////////////////////////////////////////////////////////////////

ClassReadDriveCapacity()

Routine Description:

    This routine sends a READ CAPACITY to the requested device, updates
    the geometry information in the device object and returns
    when it is complete.  This routine is synchronous.

    This routine must be called with the remove lock held or some other
    assurance that the Fdo will not be removed while processing.

Arguments:

    DeviceObject - Supplies a pointer to the device object that represents
        the device whose capacity is to be read.

Return Value:

    Status is returned.

--*/
NTSTATUS ClassReadDriveCapacity(IN PDEVICE_OBJECT Fdo)
{
    READ_CAPACITY_DATA readCapacityBuffer = {0};
    NTSTATUS status;
    PMDL driveCapMdl;

    driveCapMdl = BuildDeviceInputMdl(&readCapacityBuffer, sizeof(READ_CAPACITY_DATA));
    if (driveCapMdl){

        TRANSFER_PACKET *pkt = DequeueFreeTransferPacket(Fdo, TRUE);
        if (pkt){
            PFUNCTIONAL_DEVICE_EXTENSION fdoExt = Fdo->DeviceExtension;
            KEVENT event;
            NTSTATUS pktStatus;
            IRP pseudoIrp = {0};

            /*
             *  Our engine needs an "original irp" to write the status back to
             *  and to count down packets (one in this case).
             *  Just use a pretend irp for this.
             */
            pseudoIrp.Tail.Overlay.DriverContext[0] = LongToPtr(1);
            pseudoIrp.IoStatus.Status = STATUS_SUCCESS;
            pseudoIrp.IoStatus.Information = 0;
            pseudoIrp.MdlAddress = driveCapMdl;

            /*
             *  Set this up as a SYNCHRONOUS transfer, submit it,
             *  and wait for the packet to complete.  The result
             *  status will be written to the original irp.
             */
            KeInitializeEvent(&event, SynchronizationEvent, FALSE);
            SetupDriveCapacityTransferPacket(   pkt,
                                            &readCapacityBuffer,
                                            sizeof(READ_CAPACITY_DATA),
                                            &event,
                                            &pseudoIrp);
            SubmitTransferPacket(pkt);
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

            status = pseudoIrp.IoStatus.Status;

            /*
             *  If we got an UNDERRUN, retry exactly once.
             *  (The transfer_packet engine didn't retry because the result
             *   status was success).
             */
            if (NT_SUCCESS(status) &&
               (pseudoIrp.IoStatus.Information < sizeof(READ_CAPACITY_DATA))){
                DBGERR(("ClassReadDriveCapacity: read len (%xh) < %xh, retrying ...", (ULONG)pseudoIrp.IoStatus.Information, sizeof(READ_CAPACITY_DATA)));

                pkt = DequeueFreeTransferPacket(Fdo, TRUE);
                if (pkt){
                    pseudoIrp.Tail.Overlay.DriverContext[0] = LongToPtr(1);
                    pseudoIrp.IoStatus.Status = STATUS_SUCCESS;
                    pseudoIrp.IoStatus.Information = 0;
                    KeInitializeEvent(&event, SynchronizationEvent, FALSE);
                    SetupDriveCapacityTransferPacket(   pkt,
                                                    &readCapacityBuffer,
                                                    sizeof(READ_CAPACITY_DATA),
                                                    &event,
                                                    &pseudoIrp);
                    SubmitTransferPacket(pkt);
                    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
                    status = pseudoIrp.IoStatus.Status;
                    if (pseudoIrp.IoStatus.Information < sizeof(READ_CAPACITY_DATA)){
                        status = STATUS_DEVICE_BUSY;
                    }
                }
                else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }


            if (NT_SUCCESS(status)){
                /*
                 *  The request succeeded.
                 *  Read out and store the drive information.
                 */
                ULONG cylinderSize;
                ULONG bytesPerSector;
                ULONG tmp;
                ULONG lastSector;

                /*
                 *  Read the bytesPerSector value,
                 *  which is big-endian in the returned buffer.
                 *  Default to the standard 512 bytes.
                 */
                tmp = readCapacityBuffer.BytesPerBlock;
                ((PFOUR_BYTE)&bytesPerSector)->Byte0 = ((PFOUR_BYTE)&tmp)->Byte3;
                ((PFOUR_BYTE)&bytesPerSector)->Byte1 = ((PFOUR_BYTE)&tmp)->Byte2;
                ((PFOUR_BYTE)&bytesPerSector)->Byte2 = ((PFOUR_BYTE)&tmp)->Byte1;
                ((PFOUR_BYTE)&bytesPerSector)->Byte3 = ((PFOUR_BYTE)&tmp)->Byte0;
                if (bytesPerSector == 0) {
                    bytesPerSector = 512;
                }
                else {
                    /*
                     *  Clear all but the highest set bit.
                     *  That will give us a bytesPerSector value that is a power of 2.
                     */
                    while (bytesPerSector & (bytesPerSector-1)) {
                        bytesPerSector &= bytesPerSector-1;
                    }
                }
                fdoExt->DiskGeometry.BytesPerSector = bytesPerSector;

                //
                // Copy last sector in reverse byte order.
                //

                tmp = readCapacityBuffer.LogicalBlockAddress;
                ((PFOUR_BYTE)&lastSector)->Byte0 = ((PFOUR_BYTE)&tmp)->Byte3;
                ((PFOUR_BYTE)&lastSector)->Byte1 = ((PFOUR_BYTE)&tmp)->Byte2;
                ((PFOUR_BYTE)&lastSector)->Byte2 = ((PFOUR_BYTE)&tmp)->Byte1;
                ((PFOUR_BYTE)&lastSector)->Byte3 = ((PFOUR_BYTE)&tmp)->Byte0;

                //
                // Calculate sector to byte shift.
                //

                WHICH_BIT(fdoExt->DiskGeometry.BytesPerSector, fdoExt->SectorShift);

                DebugPrint((2,"SCSI ClassReadDriveCapacity: Sector size is %d\n",
                    fdoExt->DiskGeometry.BytesPerSector));

                DebugPrint((2,"SCSI ClassReadDriveCapacity: Number of Sectors is %d\n",
                    lastSector + 1));

                if (fdoExt->DMActive){
                    DebugPrint((1, "SCSI ClassReadDriveCapacity: reducing number of sectors by %d\n",
                                fdoExt->DMSkew));
                    lastSector -= fdoExt->DMSkew;
                }

                /*
                 *  Check to see if we have a geometry we should be using already.
                 */
                cylinderSize = (fdoExt->DiskGeometry.TracksPerCylinder *
                                fdoExt->DiskGeometry.SectorsPerTrack);
                if (cylinderSize == 0){
                    DebugPrint((1, "ClassReadDriveCapacity: resetting H & S geometry "
                                   "values from %#x/%#x to %#x/%#x\n",
                                fdoExt->DiskGeometry.TracksPerCylinder,
                                fdoExt->DiskGeometry.SectorsPerTrack,
                                0xff,
                                0x3f));

                    fdoExt->DiskGeometry.TracksPerCylinder = 0xff;
                    fdoExt->DiskGeometry.SectorsPerTrack = 0x3f;


                    cylinderSize = (fdoExt->DiskGeometry.TracksPerCylinder *
                                    fdoExt->DiskGeometry.SectorsPerTrack);
                }

                //
                // Calculate number of cylinders.
                //

                fdoExt->DiskGeometry.Cylinders.QuadPart = (LONGLONG)((lastSector + 1)/cylinderSize);

                //
                // if there are zero cylinders, then the device lied AND it's
                // smaller than 0xff*0x3f (about 16k sectors, usually 8 meg)
                // this can fit into a single LONGLONG, so create another usable
                // geometry, even if it's unusual looking.  This allows small,
                // non-standard devices, such as Sony's Memory Stick, to show
                // up as having a partition.
                //

                if (fdoExt->DiskGeometry.Cylinders.QuadPart == (LONGLONG)0) {
                    fdoExt->DiskGeometry.SectorsPerTrack    = 1;
                    fdoExt->DiskGeometry.TracksPerCylinder  = 1;
                    fdoExt->DiskGeometry.Cylinders.QuadPart = lastSector;
                }


                //
                // Calculate media capacity in bytes.
                //

                fdoExt->CommonExtension.PartitionLength.QuadPart =
                    ((LONGLONG)(lastSector + 1)) << fdoExt->SectorShift;

                /*
                 *  Is this removable or fixed media
                 */
                if (TEST_FLAG(Fdo->Characteristics, FILE_REMOVABLE_MEDIA)){
                    fdoExt->DiskGeometry.MediaType = RemovableMedia;
                }
                else {
                    fdoExt->DiskGeometry.MediaType = FixedMedia;
                }
            }
            else {
                /*
                 *  The request failed.
                 */

                //
                // ISSUE - 2000/02/04 - henrygab - non-512-byte sector sizes and failed geometry update
                //    what happens when the disk's sector size is bigger than
                //    512 bytes and we hit this code path?  this is untested.
        