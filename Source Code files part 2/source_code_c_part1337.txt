        wszString = va_arg(ArgList, LPWSTR);

        awszStrings[cStrings++] = wszString;

        if(cStrings >= PENDING_ALLOC_SIZE)
        {
            break;
        }
    }

    va_end(ArgList);

    //copy the hr error code
    if(fError)
    {
        
        if(S_OK == hr)
            hr=E_FAIL;

	wsprintfW(wszMsg, L"0x%lx", hr);        
        awszStrings[cStrings++] = wszMsg;


        if(0 != FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    hr,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (WCHAR *)&wszHR,
                    0,
                    NULL))
        {
            if(wszHR)
                awszStrings[cStrings++] = wszHR;
        }
    }

    // check if the token is non zero is so then impersonating so get the SID
    if((FALSE == fMachine) && (hToken))
    {
        ptgUser = (PTOKEN_USER)FastBuffer; // try fast buffer first
        cbUser = MAX_DN_SIZE;

        if (!GetTokenInformation(
                        hToken,    // identifies access token
                        TokenUser, // TokenUser info type
                        ptgUser,   // retrieved info buffer
                        cbUser,  // size of buffer passed-in
                        &cbUser  // required buffer size
                        ))
        {
            if(GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                if (NULL != (ptgUser = (PTOKEN_USER)LocalAlloc(LPTR, cbUser)))
                {
                    fAlloced = TRUE;

                    // get the user info and assign the sid if able to
                    if (GetTokenInformation(
                                    hToken,    // identifies access token
                                    TokenUser, // TokenUser info type
                                    ptgUser,   // retrieved info buffer
                                    cbUser,  // size of buffer passed-in
                                    &cbUser  // required buffer size
                                    ))
                    {
                        pSID = ptgUser->User.Sid;
                    }
                }
            }

        }
        else
        {
            // assign the sid when fast buffer worked
            pSID = ptgUser->User.Sid;
        }
    }


    switch(dwEventId >> 30)
    {
        case 0:
            dwEventType = EVENTLOG_SUCCESS;
        break;

        case 1:
            dwEventType = EVENTLOG_INFORMATION_TYPE;
        break;

        case 2:
            dwEventType = EVENTLOG_WARNING_TYPE;
        break;

        case 3:
            dwEventType = EVENTLOG_ERROR_TYPE;
        break;
    }

    ReportEventW(hEventSource,          // handle of event source
                 dwEventType,           // event type
                 0,                     // event category
                 dwEventId,             // event ID
                 pSID,                  // current user's SID
                 cStrings,              // strings in lpszStrings
                 0,                     // no bytes of raw data
                 (LPCWSTR*)awszStrings, // array of error strings
                 NULL                   // no raw data
                 );

    if (hEventSource)
        DeregisterEventSource(hEventSource);  

    if(fAlloced)
    {   
        if(ptgUser)
            LocalFree(ptgUser);
    }

    if(wszHR)
        LocalFree(wszHR);

    return;
}

//--------------------------------------------------------------------------
//
//	  FormatMessageUnicode
//
//--------------------------------------------------------------------------
BOOL FormatMessageUnicode(LPWSTR * ppwszFormat, UINT ids, ...)
{
    // get format string from resources
    WCHAR		wszFormat[1000];
	va_list		argList;
	DWORD		cbMsg=0;
	BOOL		fResult=FALSE;

    if(NULL == ppwszFormat)
        goto Ret;

    if(!LoadStringW(g_hmodThisDll, ids, wszFormat, sizeof(wszFormat) / sizeof(wszFormat[0])))
		goto Ret;

    // format message into requested buffer
    va_start(argList, ids);

    cbMsg = FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        wszFormat,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPWSTR) (ppwszFormat),
        0,                  // minimum size to allocate
        &argList);

    va_end(argList);

	if(!cbMsg)
        goto Ret;

	fResult=TRUE;


Ret:
	return fResult;
}

//--------------------------------------------------------------------------
//
//	  AENetLogonUser
//
//Abstract:
//
//    This module implements the network logon type by interfacing
//    with the NT Lan Man Security Support Provider (NTLMSSP).
//
//    If the logon succeds via the provided credentials, we duplicate
//    the resultant Impersonation token to a Primary level token.
//    This allows the result to be used in a call to CreateProcessAsUser
//
//Author:
//
//    Scott Field (sfield)    09-Jun-96
//--------------------------------------------------------------------------
BOOL
AENetLogonUser(
    LPTSTR UserName,
    LPTSTR DomainName,
    LPTSTR Password,
    PHANDLE phToken
    )
{
    SECURITY_STATUS SecStatus;
    CredHandle CredentialHandle1;
    CredHandle CredentialHandle2;

    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    SecPkgCredentials_Names sNames;

    ULONG ContextAttributes;

    ULONG PackageCount;
    ULONG PackageIndex;
    PSecPkgInfo PackageInfo;
    DWORD cbMaxToken;

    TimeStamp Lifetime;
    SEC_WINNT_AUTH_IDENTITY AuthIdentity;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;


    HANDLE hImpersonationToken;
    BOOL bSuccess = FALSE ; // assume this function will fail

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    sNames.sUserName = NULL;
    ClientContextHandle.dwUpper = -1;
    ClientContextHandle.dwLower = -1;
    ServerContextHandle.dwUpper = -1;
    ServerContextHandle.dwLower = -1;
    CredentialHandle1.dwUpper = -1;
    CredentialHandle1.dwLower = -1;
    CredentialHandle2.dwUpper = -1;
    CredentialHandle2.dwLower = -1;


//
// << this section could be cached in a repeat caller scenario >>
//

    //
    // Get info about the security packages.
    //

    if(EnumerateSecurityPackages(
        &PackageCount,
        &PackageInfo
        ) != NO_ERROR) return FALSE;

    //
    // loop through the packages looking for NTLM
    //

    for(PackageIndex = 0 ; PackageIndex < PackageCount ; PackageIndex++ ) {
        if(PackageInfo[PackageIndex].Name != NULL) {
            if(lstrcmpi(PackageInfo[PackageIndex].Name, MICROSOFT_KERBEROS_NAME) == 0) {
                cbMaxToken = PackageInfo[PackageIndex].cbMaxToken;
                bSuccess = TRUE;
                break;
            }
        }
    }

    FreeContextBuffer( PackageInfo );

    if(!bSuccess) return FALSE;

    bSuccess = FALSE; // reset to assume failure

//
// << end of cached section >>
//

    //
    // Acquire a credential handle for the server side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    MICROSOFT_KERBEROS_NAME,    // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &CredentialHandle1,
                    &Lifetime
                    );

    if ( SecStatus != NO_ERROR ) {
        goto cleanup;
    }


    //
    // Acquire a credential handle for the client side
    //

    ZeroMemory( &AuthIdentity, sizeof(AuthIdentity) );

    if ( DomainName != NULL ) {
        AuthIdentity.Domain = DomainName;
        AuthIdentity.DomainLength = lstrlen(DomainName);
    }

    if ( UserName != NULL ) {
        AuthIdentity.User = UserName;
        AuthIdentity.UserLength = lstrlen(UserName);
    }

    if ( Password != NULL ) {
        AuthIdentity.Password = Password;
        AuthIdentity.PasswordLength = lstrlen(Password);
    }

    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    MICROSOFT_KERBEROS_NAME,    // Package Name
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    (DomainName == NULL && UserName == NULL && Password == NULL) ?
                        NULL : &AuthIdentity,
                    NULL,
                    NULL,
                    &CredentialHandle2,
                    &Lifetime
                    );

    if ( SecStatus != NO_ERROR ) {
        goto cleanup;
    }

    SecStatus =  QueryCredentialsAttributes(&CredentialHandle1, SECPKG_CRED_ATTR_NAMES, &sNames);
    if ( SecStatus != NO_ERROR ) {
        goto cleanup;
    }
    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( LMEM_FIXED, NegotiateBuffer.cbBuffer );

    if ( NegotiateBuffer.pvBuffer == NULL ) {
        goto cleanup;
    }

    SecStatus = InitializeSecurityContext(
                    &CredentialHandle2,
                    NULL,                       // No Client context yet
                    sNames.sUserName,                       // target name
                    ISC_REQ_SEQUENCE_DETECT,
                    0,                          // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                       // No initial input token
                    0,                          // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime
                    );
    if(SecStatus != NO_ERROR)
    {
        goto cleanup;
    }


    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( LMEM_FIXED, ChallengeBuffer.cbBuffer );

    if ( ChallengeBuffer.pvBuffer == NULL ) {
        goto cleanup;
    }

    SecStatus = AcceptSecurityContext(
                    &CredentialHandle1,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ISC_REQ_SEQUENCE_DETECT,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime
                    );
    if(SecStatus != NO_ERROR)
    {
        goto cleanup;
    }


    if(QuerySecurityContextToken(&ServerContextHandle, phToken) != NO_ERROR)
        goto cleanup;

    bSuccess = TRUE;

cleanup:

    //
    // Delete context
    //

    if((ClientContextHandle.dwUpper != -1) ||
        (ClientContextHandle.dwLower != -1))
    {
        DeleteSecurityContext( &ClientContextHandle );
    }
    if((ServerContextHandle.dwUpper != -1) ||
        (ServerContextHandle.dwLower != -1))
    {
        DeleteSecurityContext( &ServerContextHandle );
    }

    //
    // Free credential handles
    //
    if((CredentialHandle1.dwUpper != -1) ||
        (CredentialHandle1.dwLower != -1))
    {
        FreeCredentialsHandle( &CredentialHandle1 );
    }
    if((CredentialHandle2.dwUpper != -1) ||
        (CredentialHandle2.dwLower != -1))
    {
        FreeCredentialsHandle( &CredentialHandle2 );
    }

    if ( NegotiateBuffer.pvBuffer != NULL ) {
        ZeroMemory( NegotiateBuffer.pvBuffer, NegotiateBuffer.cbBuffer );
        LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        ZeroMemory( ChallengeBuffer.pvBuffer, ChallengeBuffer.cbBuffer );
        LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( sNames.sUserName != NULL ) {
        FreeContextBuffer( sNames.sUserName );
    }

    return bSuccess;
}

//--------------------------------------------------------------------------
//
//  AEDebugLog
//
//--------------------------------------------------------------------------
#if DBG
void
AEDebugLog(long Mask,  LPCWSTR Format, ...)
{
    va_list ArgList;
    int     Level = 0;
    int     PrefixSize = 0;
    int     iOut;
    WCHAR    wszOutString[MAX_DEBUG_BUFFER];
    long    OriginalMask = Mask;

    if (Mask & g_AutoenrollDebugLevel)
    {

        // Make the prefix first:  "Process.Thread> GINA-XXX"

        iOut = wsprintfW(
                wszOutString,
                L"%3d.%3d> AUTOENRL: ",
                GetCurrentProcessId(),
                GetCurrentThreadId());

        va_start(ArgList, Format);

        if (wvsprintfW(&wszOutString[iOut], Format, ArgList) < 0)
        {
            static WCHAR wszOverFlow[] = L"\n<256 byte OVERFLOW!>\n";

            // Less than zero indicates that the string would not fit into the
            // buffer.  Output a special message indicating overflow.

            wcscpy(
            &wszOutString[(sizeof(wszOutString) - sizeof(wszOverFlow))/sizeof(WCHAR)],
            wszOverFlow);
        }
        va_end(ArgList);
        OutputDebugStringW(wszOutString);
    }
}
#endif
//--------------------------------------------------------------------------
//
//	AERemoveRegKey
//
//		Remove the registry key for local system and all its sub keys.
//
//--------------------------------------------------------------------------
DWORD AERemoveRegKey(LPWSTR	pwszRegKey)
{
    DWORD           dwLastError=0;      //we should try to clean up as much as possible
	DWORD			dwIndex=0;
    DWORD           dwSubKey=0;
    DWORD           dwSubKeyLen=0;
    DWORD           dwData=0;
	
    HKEY            hDSKey=NULL;
    LPWSTR          pwszSubKey=NULL;

    //remove the optimization registry.  OK if the key does not exist 
    if(ERROR_SUCCESS != RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pwszRegKey, 
                0,
                KEY_ALL_ACCESS,
                &hDSKey))
        goto Ret;

    //remove all subkeys of hDSKey
    if(ERROR_SUCCESS != (dwLastError = RegQueryInfoKey(
                      hDSKey,
                      NULL,
                      NULL,
                      NULL,
                      &dwSubKey,
                      &dwSubKeyLen,
                      NULL,
                      NULL,
                      NULL,
                      NULL,
                      NULL,
                      NULL)))
        goto Ret;

    //terminating NULL
    dwSubKeyLen++;

    pwszSubKey=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * dwSubKeyLen);
    
    if(NULL == pwszSubKey)
    {
        dwLastError=ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    for(dwIndex=0; dwIndex < dwSubKey; dwIndex++)
    {
        dwData = dwSubKeyLen; 

        if(ERROR_SUCCESS == (dwLastError = RegEnumKeyEx(
                           hDSKey,
                           0,           // As we delete, the index changes
                           pwszSubKey,
                           &dwData,
                           NULL,
                           NULL,
                           NULL,
                           NULL)))
        {
            RegDeleteKey(hDSKey, pwszSubKey);
        }
	}

	//remove the root registry key
	dwLastError=RegDeleteKey(HKEY_LOCAL_MACHINE, pwszRegKey);

Ret:

    if(pwszSubKey)
        LocalFree(pwszSubKey);

    if(hDSKey)
        RegCloseKey(hDSKey);

    return dwLastError;
}

//--------------------------------------------------------------------------
//
//  CertAutoRemove
//
//      Function to remove enterprise specific public key trust upon domain disjoin.
//      Should be called under local admin's context.
//
//      The function will:
//          remove autoenrollment directory cache registry;
//          remove certificates under root enterprise store;
//          remove certificates under NTAuth enterprise store;
//          remove certificates under CA enterprise store;
//
//     
//      Parameters:
//          IN  dwFlags:        
//                              CERT_AUTO_REMOVE_COMMIT
//                              CERT_AUTO_REMOVE_ROLL_BACK
//
//      Return Value:
//          BOOL:               TURE is upon success
//
//--------------------------------------------------------------------------
BOOL 
WINAPI
CertAutoRemove(IN DWORD    dwFlags)
{
	DWORD			dwError=0;
    DWORD           dwLastError=0;      //we should try to clean up as much as possible
    DWORD           dwIndex=0;
    PCCERT_CONTEXT  pContext=NULL;
    WCHAR           wszNameBuf[64];

    HANDLE          hEvent=NULL;
    HCERTSTORE      hLocalStore=NULL;

    if((CERT_AUTO_REMOVE_COMMIT != dwFlags)  &&
        (CERT_AUTO_REMOVE_ROLL_BACK != dwFlags))
    {
        dwLastError=ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if(CERT_AUTO_REMOVE_ROLL_BACK == dwFlags)
    {
        //start machine autoenrollment
        wcscpy(wszNameBuf, L"Global\\");
        wcscat(wszNameBuf, MACHINE_AUTOENROLLMENT_TRIGGER_EVENT);

        hEvent=OpenEvent(EVENT_MODIFY_STATE, FALSE, wszNameBuf);
        if (NULL == hEvent) 
        {
            dwLastError=GetLastError();
            goto Ret;
        }

        if (!SetEvent(hEvent)) 
        {
            dwLastError=GetLastError();
            goto Ret;
        }
    }
    else
    {
        //remove all downloaded certificates
        for(dwIndex =0; dwIndex < g_dwStoreInfo; dwIndex++)
        {
            hLocalStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_REGISTRY_W, 
                                        0, 
                                        0, 
                                        CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE, 
                                        g_rgStoreInfo[dwIndex].pwszStoreName);

            if(hLocalStore)
            {
                while(pContext = CertEnumCertificatesInStore(hLocalStore, pContext))
                {
                    CertDeleteCertificateFromStore(CertDuplicateCertificateContext(pContext));
                }

                CertCloseStore(hLocalStore,0);
                hLocalStore=NULL;
            }
        }

		//remove the local machine's DC GUID cache
		dwLastError=AERemoveRegKey(AUTO_ENROLLMENT_DS_KEY);

		dwError=AERemoveRegKey(AUTO_ENROLLMENT_TEMPLATE_KEY);

		if(0 == dwLastError)
			dwLastError=dwError;
    }

Ret:

    if(hLocalStore)
        CertCloseStore(hLocalStore,0);

    if (hEvent) 
        CloseHandle(hEvent);


    if(0 != dwLastError)
    {
        SetLastError(dwLastError);
        return FALSE;
    }

    return TRUE;
}


//--------------------------------------------------------------------------
//
//  DLLMain
//
//
//--------------------------------------------------------------------------
extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    BOOL                        fResult=TRUE;
    INITCOMMONCONTROLSEX        initcomm = {
        sizeof(initcomm), ICC_NATIVEFNTCTL_CLASS | ICC_LISTVIEW_CLASSES | ICC_PROGRESS_CLASS 
    };

    switch( dwReason )
    {
        case DLL_PROCESS_ATTACH:
                g_hmodThisDll=hInstance;
                DisableThreadLibraryCalls( hInstance );

                //Init common control for progress bar
                InitCommonControlsEx(&initcomm);

            break;

        case DLL_PROCESS_DETACH:
            break;
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\contman\policy.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    policy

Abstract:

    This module provides common CSP Algorithm Limit policy control.

Author:

    Doug Barlow (dbarlow) 8/11/2000

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <wincrypt.h>
#include "policy.h"


/*++

LocateAlgorithm:

    This routine searches a PROV_ENUMALGS_EX array for the specified
    Algorithm.

Arguments:

    rgEnumAlgs supplies the array of PROV_ENUMALGS_EX structures to be
        searched.  The last entry in the array must be filled with zeroes.

    algId supplies the algorithm Id for which to search.

Return Value:

    The corresponding PROV_ENUMALGS_EX structure in the array, or NULL if no
    such algorithm entry exists.

Remarks:

Author:

    Doug Barlow (dbarlow) 8/16/2000

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("LocateAlgorithm")

CONST PROV_ENUMALGS_EX *
LocateAlgorithm(
    IN CONST PROV_ENUMALGS_EX *rgEnumAlgs,
    IN ALG_ID algId)
{
    CONST PROV_ENUMALGS_EX *pEnumAlg = rgEnumAlgs;


    //
    // Run through the list and try to find the given algorithm.
    //

    while (0 != pEnumAlg->aiAlgid)
    {
        if (pEnumAlg->aiAlgid == algId)
            return pEnumAlg;
        pEnumAlg += 1;
    }

    return NULL;
}


/*++

IsLegalAlgorithm:

    Given an array of allowed algorithms, is the given algorithm Id in the
    list?

Arguments:

    rgEnumAlgs supplies the array of PROV_ENUMALGS_EX structures identifying
        the policy to enforce.  The last entry in the array must be filled
        with zeroes.

    algId supplies the algorithm Id to be validated.

    ppEnumAlg, if supplied, receives the PROV_ENUMALGS_EX structure containing
        the policies associated with this algorithm Id.  This can be used in
        following routines to speed up access to policy information.

Return Value:

    TRUE -- That algorithm is supported.
    FALSE -- That algorithm is not supported.

Remarks:

Author:

    Doug Barlow (dbarlow) 8/16/2000

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("IsLegalAlgorithm")

BOOL
IsLegalAlgorithm(
    IN  CONST PROV_ENUMALGS_EX *rgEnumAlgs,
    IN  ALG_ID algId,
    OUT CONST PROV_ENUMALGS_EX **ppEnumAlg)
{
    CONST PROV_ENUMALGS_EX *pEnumAlg = LocateAlgorithm(rgEnumAlgs, algId);

    if (NULL != ppEnumAlg)
        *ppEnumAlg = pEnumAlg;
    return (NULL != pEnumAlg);
}


/*++

IsLegalLength:

    This routine determines if the requested key length is valid for the given
    algorithm, according to policy.

Arguments:

    rgEnumAlgs supplies the array of PROV_ENUMALGS_EX structures identifying
        the policy to enforce.  The last entry in the array must be filled
        with zeroes.

    algId supplies the algorithm Id to be validated.

    cBitLength supplies the length of the proposed key, in bits.

    pEnumAlg, if not NULL, supplies the PROV_ENUMALGS_EX structure containing
        the policies associated with this algorithm Id.  This can be obtained
        from the IsLegalAlgorithm call, above.  If this parameter is NULL,
        then the PROV_ENUMALGS_EX structure is located from the algId
        parameter.

Return Value:

    TRUE -- This key length is legal for this algorithm.
    FALSE -- This key length is not allowed for this algorithm.

Remarks:

    This routine only determines policy rules.  It does not address whether or
    not the exact keylength is supported by the algorithm.

Author:

    Doug Barlow (dbarlow) 8/16/2000

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("IsLegalLength")

BOOL
IsLegalLength(
    IN CONST PROV_ENUMALGS_EX *rgEnumAlgs,
    IN ALG_ID algId,
    IN DWORD cBitLength,
    IN CONST PROV_ENUMALGS_EX *pEnumAlg)
{

    //
    // Make sure we've got a PROV_ENUMALGS_EX structure to work with.
    //

    if (NULL == pEnumAlg)
    {
        pEnumAlg = LocateAlgorithm(rgEnumAlgs, algId);
        if (NULL == pEnumAlg)
            return FALSE;
    }


    //
    // Now check the length.
    //

    return ((pEnumAlg->dwMinLen <= cBitLength)
            && (pEnumAlg->dwMaxLen >= cBitLength));
}


/*++

GetDefaultLength:

    This routine determines the default length for a given algorithm, based on
    policy described in an array of PROV_ENUMALGS_EX structures.

Arguments:

    rgEnumAlgs supplies the array of PROV_ENUMALGS_EX structures identifying
        the policy to enforce.  The last entry in the array must be filled
        with zeroes.

    algId supplies the algorithm Id to be validated.

    pEnumAlg, if not NULL, supplies the PROV_ENUMALGS_EX structure containing
        the policies associated with this algorithm Id.  This can be obtained
        from the IsLegalAlgorithm call, above.  If this parameter is NULL,
        then the PROV_ENUMALGS_EX structure is located from the algId
        parameter.

    pcBitLength receives the default length of the proposed key, in bits.

Return Value:

    TRUE -- The algorithm is supported, and the value returned in pcBitLength
            is valid.
    FALSE -- The requested algorithm isn't supported.

Remarks:

Author:

    Doug Barlow (dbarlow) 8/16/2000

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("GetDefaultLength")

BOOL
GetDefaultLength(
    IN  CONST PROV_ENUMALGS_EX *rgEnumAlgs,
    IN  ALG_ID algId,
    IN  CONST PROV_ENUMALGS_EX *pEnumAlg,
    OUT LPDWORD pcBitLength)
{

    //
    // Clear the returned bit length, just in case.
    //

    *pcBitLength = 0;


    //
    // Make sure we've got a PROV_ENUMALGS_EX structure to work with.
    //

    if (NULL == pEnumAlg)
    {
        pEnumAlg = LocateAlgorithm(rgEnumAlgs, algId);
        if (NULL == pEnumAlg)
            return FALSE;
    }


    //
    // Now return the default length.
    //

    *pcBitLength = pEnumAlg->dwDefaultLen;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\contman\contman.c ===
/*++

Copyright (c) 1997, 1998, 1999  Microsoft Corporation

Module Name:

    keyman.cpp

Abstract:

    This module contains routines to read and write data (key containers) from
    and to files.


Author:

    16 Mar 98 jeffspel

--*/

// Don't whine about unnamed unions
#pragma warning (disable: 4201)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <crypt.h>
#include <windows.h>
#include <userenv.h>
#include <userenvp.h> // for GetUserAppDataPathW
#include <wincrypt.h>
#include <cspdk.h>
#include <rpc.h>
#include <shlobj.h>
#include <contman.h>
#include <md5.h>
#include <des.h>
#include <modes.h>
#include <csprc.h>
#include <crtdbg.h>

#ifdef USE_HW_RNG
#ifdef _M_IX86

#include <winioctl.h>

// INTEL h files for on chip RNG
#include "deftypes.h"   //ISD typedefs and constants
#include "ioctldef.h"   //ISD ioctl definitions

#endif // _M_IX86
#endif // USE_HW_RNG

static LPBYTE l_pbStringBlock = NULL;

CSP_STRINGS g_Strings = {
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL };

typedef struct _OLD_KEY_CONTAINER_LENS_
{
    DWORD   cbSigPub;
    DWORD   cbSigEncPriv;
    DWORD   cbExchPub;
    DWORD   cbExchEncPriv;
} OLD_KEY_CONTAINER_LENS, *POLD_KEY_CONTAINER_LENS;

#define OLD_KEY_CONTAINER_FILE_FORMAT_VER   1
#define FAST_BUF_SIZE           256
#define ContInfoAlloc(cb)       ContAlloc(cb)
#define ContInfoReAlloc(pb, cb) ContRealloc(pb, cb)
#define ContInfoFree(pb)        ContFree(pb)

#define MACHINE_KEYS_DIR        L"MachineKeys"

// Location of the keys in the registry (minus the logon name)
// Length of the full location (including the logon name)
#define RSA_REG_KEY_LOC         "Software\\Microsoft\\Cryptography\\UserKeys"
#define RSA_REG_KEY_LOC_LEN     sizeof(RSA_REG_KEY_LOC)
#define RSA_MACH_REG_KEY_LOC    "Software\\Microsoft\\Cryptography\\MachineKeys"
#define RSA_MACH_REG_KEY_LOC_LEN sizeof(RSA_MACH_REG_KEY_LOC)

#define DSS_REG_KEY_LOC         "Software\\Microsoft\\Cryptography\\DSSUserKeys"
#define DSS_REG_KEY_LOC_LEN     sizeof(DSS_REG_KEY_LOC)
#define DSS_MACH_REG_KEY_LOC    "Software\\Microsoft\\Cryptography\\DSSUserKeys"
#define DSS_MACH_REG_KEY_LOC_LEN sizeof(DSS_MACH_REG_KEY_LOC)

#define MAX_DPAPI_RETRY_COUNT   5


//
// Memory allocation support.
//

#ifndef ASSERT
#define ASSERT _ASSERTE
#endif

#ifdef _X86_
#define InterlockedAccess(pl) *(pl)
#define InterlockedPointerAccess(ppv) *(ppv)
#else
#define InterlockedAccess(pl) InterlockedExchangeAdd((pl), 0)
#define InterlockedPointerAccess(ppv) InterlockedExchangePointer((ppv), *(ppv))
#endif

#define CONT_HEAP_FLAGS (HEAP_ZERO_MEMORY)

// Scrub sensitive data from memory
extern void
memnuke(
    volatile BYTE *pData,
    DWORD dwLen);

LPVOID
ContAlloc(
    ULONG cbLen)
{
    return HeapAlloc(GetProcessHeap(), CONT_HEAP_FLAGS, cbLen);
}

LPVOID
ContRealloc(
    LPVOID pvMem,
    ULONG cbLen)
{
    return HeapReAlloc(GetProcessHeap(), CONT_HEAP_FLAGS, pvMem, cbLen);
}

void
ContFree(
    LPVOID pvMem)
{
    if (NULL != pvMem)
        HeapFree(GetProcessHeap(), CONT_HEAP_FLAGS, pvMem);
}

//
// Wrapper for RtlEncryptMemory, which returns an NTSTATUS.  The return
// value is translated to a winerror code.
//
DWORD MyRtlEncryptMemory(
    IN PVOID pvMem,
    IN DWORD cbMem)
{
    NTSTATUS status = RtlEncryptMemory(pvMem, cbMem, 0);

    return RtlNtStatusToDosError(status);
}

//
// Wrapper for RtlDecryptMemory, which returns an NTSTATUS.  The return value
// is translated to a winerror code.
//
DWORD MyRtlDecryptMemory(
    IN PVOID pvMem,
    IN DWORD cbMem)
{
    NTSTATUS status = RtlDecryptMemory(pvMem, cbMem, 0);

    return RtlNtStatusToDosError(status);
}

//
// Return TRUE if Force High Key Protection is set on this machine, return
// FALSE otherwise.
//
BOOL IsForceHighProtectionEnabled(
    IN PKEY_CONTAINER_INFO  pContInfo)
{
    return pContInfo->fForceHighKeyProtection;
}

//
// Retrieves the Force High Key Protection setting for this machine from the 
// registry.
//
DWORD InitializeForceHighProtection(
    IN OUT PKEY_CONTAINER_INFO  pContInfo)
{
    HKEY hKey = 0;
    DWORD dwSts = ERROR_SUCCESS;
    DWORD cbData = 0;
    DWORD dwValue = 0;

    pContInfo->fForceHighKeyProtection = FALSE;

    //
    // Open the Cryptography key
    //
    dwSts = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, 
        szKEY_CRYPTOAPI_PRIVATE_KEY_OPTIONS,
        0, 
        KEY_READ | KEY_WOW64_64KEY, 
        &hKey);

    if (ERROR_FILE_NOT_FOUND == dwSts)
    {
        // Key doesn't exist.  Assume feature should remain off.
        dwSts = ERROR_SUCCESS;
        goto Ret;
    }

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Find out if force high key protection is on
    //
    cbData = sizeof(DWORD);
    
    dwSts = RegQueryValueEx(
        hKey,
        szFORCE_KEY_PROTECTION,
        0, 
        NULL, 
        (PBYTE) &dwValue,
        &cbData);

    if (ERROR_SUCCESS == dwSts && dwFORCE_KEY_PROTECTION_HIGH == dwValue)
        pContInfo->fForceHighKeyProtection = TRUE;
    else if (ERROR_FILE_NOT_FOUND == dwSts)
        // If the value isn't present, assume Force High is turned off.
        dwSts = ERROR_SUCCESS;

Ret:
    if (hKey)
        RegCloseKey(hKey);

    return dwSts;
}

// 
// Returns True is the cached private key of the indicated type
// is still valid.  
//
// Returns False if no cached key is available, or if the available
// cached key is stale.
//
BOOL IsCachedKeyValid(
    IN PKEY_CONTAINER_INFO  pContInfo,
    IN BOOL                 fSigKey) 
{
    DWORD *pdwPreviousTimestamp = NULL;
    
    // If the new caching behavior isn't enabled, let the
    // caller proceed as before.
    if (FALSE == pContInfo->fCachePrivateKeys)
        return TRUE;

    if (fSigKey)
        pdwPreviousTimestamp = &pContInfo->dwSigKeyTimestamp;
    else
        pdwPreviousTimestamp = &pContInfo->dwKeyXKeyTimestamp;

    if ((GetTickCount() - *pdwPreviousTimestamp) > 
             pContInfo->cMaxKeyLifetime)
    {
        // Cached key is stale
        *pdwPreviousTimestamp = 0;
        return FALSE;
    }

    return TRUE;
}

//
// Updates the cache counter for the key of the indicated type.  This
// is called immediately after the key is read from storage, to 
// restart the cached key lifetime "countdown."
//
DWORD SetCachedKeyTimestamp(
    IN PKEY_CONTAINER_INFO  pContInfo,
    IN BOOL                 fSigKey)
{
    if (FALSE == pContInfo->fCachePrivateKeys)
        return ERROR_SUCCESS;

    if (fSigKey)
        pContInfo->dwSigKeyTimestamp = GetTickCount();
    else
        pContInfo->dwKeyXKeyTimestamp = GetTickCount();

    return ERROR_SUCCESS;
}

//
// Reads the key cache initialization parameters from the registry.
//
DWORD InitializeKeyCacheInfo(
    IN OUT PKEY_CONTAINER_INFO pContInfo)
{
    HKEY hKey = 0;
    DWORD dwSts = ERROR_SUCCESS;
    DWORD cbData = 0;

    //
    // Open the Cryptography key
    //
    dwSts = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, 
        szKEY_CRYPTOAPI_PRIVATE_KEY_OPTIONS,
        0, 
        KEY_READ | KEY_WOW64_64KEY, 
        &hKey);

    if (ERROR_FILE_NOT_FOUND == dwSts)
    {
        // Key doesn't exist.  Assume feature should remain off.
        dwSts = ERROR_SUCCESS;
        goto Ret;
    }

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Find out if private key caching is turned on
    //
    cbData = sizeof(DWORD);

    dwSts = RegQueryValueEx(
        hKey,
        szKEY_CACHE_ENABLED,
        0, 
        NULL, 
        (PBYTE) &pContInfo->fCachePrivateKeys,
        &cbData);

    if (ERROR_FILE_NOT_FOUND == dwSts)
    {
        // Reg key enabling the new behavior isn't set, so we're done.
        dwSts = ERROR_SUCCESS;
        goto Ret;
    }
    else if (ERROR_SUCCESS != dwSts || FALSE == pContInfo->fCachePrivateKeys)
        goto Ret;

    //
    // Find out how long to cache private keys
    //
    cbData = sizeof(DWORD);

    dwSts = RegQueryValueEx(
        hKey,
        szKEY_CACHE_SECONDS,
        0,
        NULL,
        (PBYTE) &pContInfo->cMaxKeyLifetime,
        &cbData);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    // Cache lifetime value stored in registry is in seconds.  We'll remember
    // the value in milliseconds for easy comparison.

    pContInfo->cMaxKeyLifetime *= 1000;

Ret:
    if (hKey)
        RegCloseKey(hKey);

    return dwSts;
}

/*++

OpenCallerToken:

    This routine returns the caller's ID token.

Arguments:

    dwFlags supplies the flags to use when opening the token.

    phToken receives the token.  It must be closed via CloseHandle.

Return Value:

    A DWORD status code.

Remarks:

Author:

    Doug Barlow (dbarlow) 5/2/2000

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("OpenCallerToken")

/*static*/ DWORD
OpenCallerToken(
    IN  DWORD  dwFlags,
    OUT HANDLE *phToken)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    DWORD dwSts;
    BOOL fSts;
    HANDLE hToken = NULL;

    fSts = OpenThreadToken(GetCurrentThread(), dwFlags, TRUE, &hToken);
    if (!fSts)
    {
        dwSts = GetLastError();
        if (ERROR_NO_TOKEN != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        // For Jeff, fall back and get the process token
        fSts = OpenProcessToken(GetCurrentProcess(), dwFlags, &hToken);
        if (!fSts)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }
    }

    *phToken = hToken;
    return ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


DWORD
MyCryptProtectData(
    IN          DATA_BLOB   *pDataIn,
    IN          LPCWSTR     szDataDescr,
    IN OPTIONAL DATA_BLOB   *pOptionalEntropy,
    IN          PVOID       pvReserved,
    IN OPTIONAL CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct,
    IN          DWORD       dwFlags,
    OUT         DATA_BLOB   *pDataOut)  // out encr blob
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD   dwRetryCount = 0;
    DWORD   dwMilliseconds = 10;
    DWORD   dwSts;

    for (;;)
    {
        if (CryptProtectData(pDataIn, szDataDescr, pOptionalEntropy,
                             pvReserved, pPromptStruct, dwFlags, pDataOut))
        {
            break;
        }

        dwSts = GetLastError();
        switch (dwSts)
        {
        case RPC_S_SERVER_TOO_BUSY:
            if (MAX_DPAPI_RETRY_COUNT <= dwRetryCount)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
            Sleep(dwMilliseconds);
            dwMilliseconds *= 2;
            dwRetryCount++;
            break;

        case RPC_S_UNKNOWN_IF:  // Make this error code more friendly.
            dwReturn = ERROR_SERVICE_NOT_ACTIVE;
            goto ErrorExit;
            break;

        default:
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}

DWORD
MyCryptUnprotectData(
    IN              DATA_BLOB   *pDataIn,             // in encr blob
    OUT OPTIONAL    LPWSTR      *ppszDataDescr,       // out
    IN OPTIONAL     DATA_BLOB   *pOptionalEntropy,
    IN              PVOID       pvReserved,
    IN OPTIONAL     CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct,
    IN              DWORD       dwFlags,
    OUT             DATA_BLOB   *pDataOut,
    OUT             LPDWORD     pdwReprotectFlags)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD   dwRetryCount = 0;
    DWORD   dwMilliseconds = 10;
    DWORD   dwSts;
    BOOL    fSts;

    if (NULL != pdwReprotectFlags)
    {
        *pdwReprotectFlags = 0;
        dwFlags |= (CRYPTPROTECT_VERIFY_PROTECTION
                    | CRYPTPROTECT_UI_FORBIDDEN);
    }

    for (;;)
    {
        fSts = CryptUnprotectData(pDataIn,             // in encr blob
                                  ppszDataDescr,       // out
                                  pOptionalEntropy,
                                  pvReserved,
                                  pPromptStruct,
                                  dwFlags,
                                  pDataOut);
        if (!fSts)
        {
            dwSts = GetLastError();
            if ((RPC_S_SERVER_TOO_BUSY == dwSts)
                && (MAX_DPAPI_RETRY_COUNT > dwRetryCount))
            {
                Sleep(dwMilliseconds);
                dwMilliseconds *= 2;
                dwRetryCount++;
            }
            else if ((ERROR_PASSWORD_RESTRICTION == dwSts)
                     && (NULL != pdwReprotectFlags))
            {
                *pdwReprotectFlags |= CRYPT_USER_PROTECTED;
                dwFlags &= ~CRYPTPROTECT_UI_FORBIDDEN;
            }
            else
            {
                dwReturn = dwSts;
                break;
            }
        }
        else
        {
            if (NULL != pdwReprotectFlags)
            {
                dwSts = GetLastError();
                if (CRYPT_I_NEW_PROTECTION_REQUIRED == dwSts)
                    *pdwReprotectFlags |= CRYPT_UPDATE_KEY;
            }
            dwReturn = ERROR_SUCCESS;
            break;
        }
    }
    return dwReturn;
}


void
FreeEnumOldMachKeyEntries(
    PKEY_CONTAINER_INFO pInfo)
{
    if (pInfo)
    {
        if (pInfo->pchEnumOldMachKeyEntries)
        {
            ContInfoFree(pInfo->pchEnumOldMachKeyEntries);
            pInfo->dwiOldMachKeyEntry = 0;
            pInfo->cMaxOldMachKeyEntry = 0;
            pInfo->cbOldMachKeyEntry = 0;
            pInfo->pchEnumOldMachKeyEntries = NULL;
        }
    }
}


void
FreeEnumRegEntries(
    PKEY_CONTAINER_INFO pInfo)
{
    if (pInfo)
    {
        if (pInfo->pchEnumRegEntries)
        {
            ContInfoFree(pInfo->pchEnumRegEntries);
            pInfo->dwiRegEntry = 0;
            pInfo->cMaxRegEntry = 0;
            pInfo->cbRegEntry = 0;
            pInfo->pchEnumRegEntries = NULL;
        }
    }
}

void
FreeContainerInfo(
    PKEY_CONTAINER_INFO pInfo)
{
    if (NULL != pInfo)
    {
        if (NULL != pInfo->pbSigPub)
        {
            ContInfoFree(pInfo->pbSigPub);
            pInfo->ContLens.cbSigPub = 0;
            pInfo->pbSigPub = NULL;
        }

        if (NULL != pInfo->pbSigEncPriv)
        {
            memnuke(pInfo->pbSigEncPriv, pInfo->ContLens.cbSigEncPriv);
            ContInfoFree(pInfo->pbSigEncPriv);
            pInfo->ContLens.cbSigEncPriv = 0;
            pInfo->pbSigEncPriv = NULL;
        }

        if (NULL != pInfo->pbExchPub)
        {
            ContInfoFree(pInfo->pbExchPub);
            pInfo->ContLens.cbExchPub = 0;
            pInfo->pbExchPub = NULL;
        }

        if (NULL != pInfo->pbExchEncPriv)
        {
            memnuke(pInfo->pbExchEncPriv, pInfo->ContLens.cbExchEncPriv);
            ContInfoFree(pInfo->pbExchEncPriv);
            pInfo->ContLens.cbExchEncPriv = 0;
            pInfo->pbExchEncPriv = NULL;
        }

        if (NULL != pInfo->pbRandom)
        {
            ContInfoFree(pInfo->pbRandom);
            pInfo->ContLens.cbRandom = 0;
            pInfo->pbRandom = NULL;
        }

        if (NULL != pInfo->pszUserName)
        {
            ContInfoFree(pInfo->pszUserName);
            pInfo->ContLens.cbName = 0;
            pInfo->pszUserName = NULL;
        }

        FreeEnumOldMachKeyEntries(pInfo);
        FreeEnumRegEntries(pInfo);
        if (NULL != pInfo->hFind)
            FindClose(pInfo->hFind);
    }
}

/*static*/ DWORD
GetHashOfContainer(
    LPCSTR pszContainer,
    LPWSTR pszHash)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    MD5_CTX     MD5;
    LPSTR       pszLowerContainer = NULL;
    DWORD       *pdw1;
    DWORD       *pdw2;
    DWORD       *pdw3;
    DWORD       *pdw4;

    pszLowerContainer = (LPSTR)ContInfoAlloc(
                                strlen(pszContainer) + sizeof(CHAR));
    if (NULL == pszLowerContainer)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    lstrcpy(pszLowerContainer, pszContainer);
    _strlwr(pszLowerContainer);

    MD5Init(&MD5);
    MD5Update(&MD5,
              (LPBYTE)pszLowerContainer,
              strlen(pszLowerContainer) + sizeof(CHAR));
    MD5Final(&MD5);

    pdw1 = (DWORD*)&MD5.digest[0];
    pdw2 = (DWORD*)&MD5.digest[4];
    pdw3 = (DWORD*)&MD5.digest[8];
    pdw4 = (DWORD*)&MD5.digest[12];
    wsprintfW(pszHash, L"%08hx%08hx%08hx%08hx", *pdw1, *pdw2, *pdw3, *pdw4);
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pszLowerContainer)
        ContInfoFree(pszLowerContainer);
    return dwReturn;
}


/*static*/ DWORD
GetMachineGUID(
    LPWSTR *ppwszUuid)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    HKEY    hRegKey = 0;
    LPSTR   pszUuid = NULL;
    LPWSTR  pwszUuid = NULL;
    DWORD   cbUuid = sizeof(UUID);
    DWORD   cch = 0;
    DWORD   dwSts;

    *ppwszUuid = NULL;

    // read the GUID from the Local Machine portion of the registry
    dwSts = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZLOCALMACHINECRYPTO,
                         0, KEY_READ | KEY_WOW64_64KEY, &hRegKey);
    if (ERROR_FILE_NOT_FOUND == dwSts)
    {
        dwReturn = ERROR_SUCCESS;
        goto ErrorExit;   // Return a success code, but a null GUID.
    }
    else if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;   // (DWORD)NTE_FAIL
        goto ErrorExit;
    }

    dwSts = RegQueryValueEx(hRegKey, SZCRYPTOMACHINEGUID,
                            0, NULL, NULL, &cbUuid);
    if (ERROR_FILE_NOT_FOUND == dwSts)
    {
        dwReturn = ERROR_SUCCESS;
        goto ErrorExit;   // Return a success code, but a null GUID.
    }
    else if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;   // (DWORD)NTE_FAIL
        goto ErrorExit;
    }

    pszUuid = (LPSTR)ContInfoAlloc(cbUuid);
    if (NULL == pszUuid)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    dwSts = RegQueryValueEx(hRegKey, SZCRYPTOMACHINEGUID,
                            0, NULL, (LPBYTE)pszUuid, &cbUuid);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;   // (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    // convert from ansi to unicode
    cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE, pszUuid, -1, NULL, cch);
    if (0 == cch)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    pwszUuid = ContInfoAlloc((cch + 1) * sizeof(WCHAR));
    if (NULL == pwszUuid)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE, pszUuid, -1,
                              pwszUuid, cch);
    if (0 == cch)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    *ppwszUuid = pwszUuid;
    pwszUuid = NULL;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pwszUuid)
        ContInfoFree(pwszUuid);
    if (NULL != pszUuid)
        ContInfoFree(pszUuid);
    if (NULL != hRegKey)
        RegCloseKey(hRegKey);
    return dwReturn;
}


DWORD
SetMachineGUID(
    void)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    HKEY    hRegKey = 0;
    UUID    Uuid;
    LPSTR   pszUuid = NULL;
    DWORD   cbUuid;
    LPWSTR  pwszOldUuid = NULL;
    DWORD   dwSts;
    DWORD   dwResult;

    dwSts = GetMachineGUID(&pwszOldUuid);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (NULL != pwszOldUuid)
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    UuidCreate(&Uuid);

    dwSts = (DWORD) UuidToStringA(&Uuid, &pszUuid);
    if (RPC_S_OK != dwSts)
    {
        dwReturn = dwSts;   // (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    // read the GUID from the Local Machine portion of the registry
    dwSts = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           SZLOCALMACHINECRYPTO,
                           0, NULL, REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS | KEY_WOW64_64KEY, NULL, &hRegKey,
                           &dwResult);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;   // (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    dwSts = RegQueryValueEx(hRegKey, SZCRYPTOMACHINEGUID,
                            0, NULL, NULL,
                            &cbUuid);
    if (ERROR_FILE_NOT_FOUND != dwSts)
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    dwSts = RegSetValueEx(hRegKey, SZCRYPTOMACHINEGUID,
                          0, REG_SZ, (BYTE*)pszUuid,
                          strlen(pszUuid) + 1);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;   // (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pszUuid)
        RpcStringFreeA(&pszUuid);
    if (pwszOldUuid)
        ContInfoFree(pwszOldUuid);
    if (hRegKey)
        RegCloseKey(hRegKey);
    return dwReturn;
}


/*static*/ DWORD
AddMachineGuidToContainerName(
    LPSTR pszContainer,
    LPWSTR pwszNewContainer)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    WCHAR   rgwszHash[33];
    LPWSTR  pwszUuid = NULL;
    DWORD   dwSts;

    memset(rgwszHash, 0, sizeof(rgwszHash));

    // get the stringized hash of the container name
    dwSts = GetHashOfContainer(pszContainer, rgwszHash);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // get the GUID of the machine
    dwSts = GetMachineGUID(&pwszUuid);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }
    if (NULL == pwszUuid)
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    wcscpy(pwszNewContainer, rgwszHash);
    wcscat(pwszNewContainer, L"_");
    wcscat(pwszNewContainer, pwszUuid);
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pwszUuid)
        ContInfoFree(pwszUuid);
    return dwReturn;
}


//
//    Just tries to use DPAPI to make sure it works before creating a key
//    container.
//

DWORD
TryDPAPI(
    void)
{
    DWORD                       dwReturn = ERROR_INTERNAL_ERROR;
    CRYPTPROTECT_PROMPTSTRUCT   PromptStruct;
    CRYPT_DATA_BLOB             DataIn;
    CRYPT_DATA_BLOB             DataOut;
    CRYPT_DATA_BLOB             ExtraEntropy;
    DWORD                       dwJunk = 0;
    DWORD                       dwSts;

    memset(&PromptStruct, 0, sizeof(PromptStruct));
    memset(&DataIn, 0, sizeof(DataIn));
    memset(&DataOut, 0, sizeof(DataOut));

    PromptStruct.cbSize = sizeof(PromptStruct);

    DataIn.cbData = sizeof(DWORD);
    DataIn.pbData = (BYTE*)&dwJunk;
    ExtraEntropy.cbData = sizeof(STUFF_TO_GO_INTO_MIX);
    ExtraEntropy.pbData = (LPBYTE)STUFF_TO_GO_INTO_MIX;
    dwSts = MyCryptProtectData(&DataIn, L"Export Flag", &ExtraEntropy, NULL,
                               &PromptStruct, 0, &DataOut);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != DataOut.pbData)
        LocalFree(DataOut.pbData);
    return dwReturn;
}


/*static*/ DWORD
ProtectExportabilityFlag(
    IN BOOL fExportable,
    IN BOOL fMachineKeyset,
    OUT BYTE **ppbProtectedExportability,
    OUT DWORD *pcbProtectedExportability)
{
    DWORD                       dwReturn = ERROR_INTERNAL_ERROR;
    CRYPTPROTECT_PROMPTSTRUCT   PromptStruct;
    CRYPT_DATA_BLOB             DataIn;
    CRYPT_DATA_BLOB             DataOut;
    CRYPT_DATA_BLOB             ExtraEntropy;
    DWORD                       dwProtectFlags = 0;
    DWORD                       dwSts = 0;

    memset(&PromptStruct, 0, sizeof(PromptStruct));
    memset(&DataIn, 0, sizeof(DataIn));
    memset(&DataOut, 0, sizeof(DataOut));

    if (fMachineKeyset)
        dwProtectFlags = CRYPTPROTECT_LOCAL_MACHINE;

    PromptStruct.cbSize = sizeof(PromptStruct);

    DataIn.cbData = sizeof(BOOL);
    DataIn.pbData = (BYTE*)&fExportable;

    ExtraEntropy.cbData = sizeof(STUFF_TO_GO_INTO_MIX);
    ExtraEntropy.pbData = (LPBYTE)STUFF_TO_GO_INTO_MIX;

    dwSts = MyCryptProtectData(&DataIn, L"Export Flag", &ExtraEntropy, NULL,
                               &PromptStruct, dwProtectFlags, &DataOut);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    *ppbProtectedExportability = ContInfoAlloc(DataOut.cbData);
    if (NULL == *ppbProtectedExportability)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    *pcbProtectedExportability = DataOut.cbData;
    memcpy(*ppbProtectedExportability, DataOut.pbData, DataOut.cbData);
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != DataOut.pbData)
        LocalFree(DataOut.pbData);
    return dwReturn;
}

/*static*/ DWORD
UnprotectExportabilityFlag(
    IN BOOL fMachineKeyset,
    IN BYTE *pbProtectedExportability,
    IN DWORD cbProtectedExportability,
    IN BOOL *pfExportable)
{
    DWORD                       dwReturn = ERROR_INTERNAL_ERROR;
    CRYPTPROTECT_PROMPTSTRUCT   PromptStruct;
    CRYPT_DATA_BLOB             DataIn;
    CRYPT_DATA_BLOB             DataOut;
    CRYPT_DATA_BLOB             ExtraEntropy;
    DWORD                       dwProtectFlags = 0;
    DWORD                       dwSts = 0;

    memset(&PromptStruct, 0, sizeof(PromptStruct));
    memset(&DataIn, 0, sizeof(DataIn));
    memset(&DataOut, 0, sizeof(DataOut));
    memset(&ExtraEntropy, 0, sizeof(ExtraEntropy));

    if (fMachineKeyset)
        dwProtectFlags = CRYPTPROTECT_LOCAL_MACHINE;

    PromptStruct.cbSize = sizeof(PromptStruct);

    DataIn.cbData = cbProtectedExportability;
    DataIn.pbData = pbProtectedExportability;

    ExtraEntropy.cbData = sizeof(STUFF_TO_GO_INTO_MIX);
    ExtraEntropy.pbData = (LPBYTE)STUFF_TO_GO_INTO_MIX;

    dwSts = MyCryptUnprotectData(&DataIn, NULL, &ExtraEntropy, NULL,
                                 &PromptStruct, dwProtectFlags, &DataOut,
                                 NULL);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;   // NTE_BAD_KEYSET
        goto ErrorExit;
    }

    if (sizeof(BOOL) != DataOut.cbData)
    {
        dwReturn = (DWORD)NTE_BAD_KEYSET;
        goto ErrorExit;
    }

    *pfExportable = *((BOOL*)DataOut.pbData);
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    // free the DataOut struct if necessary
    if (NULL != DataOut.pbData)
        LocalFree(DataOut.pbData);
    return dwReturn;
}


/*++

    Creates a DACL for the MachineKeys directory for
    machine keysets so that Everyone may create machine keys.

--*/

/*static*/ DWORD
GetMachineKeysetDirDACL(
    IN OUT PACL *ppDacl)
{
    DWORD                       dwReturn = ERROR_INTERNAL_ERROR;
    SID_IDENTIFIER_AUTHORITY    siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    siaNTAuth = SECURITY_NT_AUTHORITY;
    PSID                        pEveryoneSid = NULL;
    PSID                        pAdminsSid = NULL;
    DWORD                       dwAclSize;

    //
    // prepare Sids representing the world and admins
    //

    if (!AllocateAndInitializeSid(&siaWorld,
                                  1,
                                  SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &pEveryoneSid))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (!AllocateAndInitializeSid(&siaNTAuth,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0, 0, 0, 0, 0, 0,
                                  &pAdminsSid))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }


    //
    // compute size of new acl
    //

    dwAclSize = sizeof(ACL)
                + 2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD))
                + GetLengthSid(pEveryoneSid)
                + GetLengthSid(pAdminsSid);


    //
    // allocate storage for Acl
    //

    *ppDacl = (PACL)ContInfoAlloc(dwAclSize);
    if (NULL == *ppDacl)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    if (!InitializeAcl(*ppDacl, dwAclSize, ACL_REVISION))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (!AddAccessAllowedAce(*ppDacl,
                             ACL_REVISION,
                             (FILE_GENERIC_WRITE | FILE_GENERIC_READ) & (~WRITE_DAC),
                             pEveryoneSid))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (!AddAccessAllowedAce(*ppDacl,
                             ACL_REVISION,
                             FILE_ALL_ACCESS,
                             pAdminsSid))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pEveryoneSid)
        FreeSid(pEveryoneSid);
    if (NULL != pAdminsSid)
        FreeSid(pAdminsSid);
    return dwReturn;
}


DWORD
CreateSystemDirectory(
    LPCWSTR lpPathName,
    SECURITY_ATTRIBUTES *pSecAttrib)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;

    if(!RtlDosPathNameToNtPathName_U( lpPathName,
                                      &FileName,
                                      NULL,
                                      &RelativeName))
    {
        dwReturn = ERROR_PATH_NOT_FOUND;
        goto ErrorExit;
    }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length )
    {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
    }
    else
    {
        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes( &Obja,
                                &FileName,
                                OBJ_CASE_INSENSITIVE,
                                RelativeName.ContainingDirectory,
                                (NULL != pSecAttrib)
                                    ? pSecAttrib->lpSecurityDescriptor
                                    : NULL);

    // Creating the directory with attribute FILE_ATTRIBUTE_SYSTEM to avoid inheriting encryption
    // property from parent directory

    Status = NtCreateFile( &Handle,
                           FILE_LIST_DIRECTORY | SYNCHRONIZE,
                           &Obja,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_SYSTEM,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_CREATE,
                           FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                           NULL,
                           0L );

    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    if(NT_SUCCESS(Status))
    {
        NtClose(Handle);
        dwReturn = ERROR_SUCCESS;
    }
    else
    {
        if (STATUS_TIMEOUT == Status)
            dwReturn = ERROR_TIMEOUT;
        else
            dwReturn = RtlNtStatusToDosError(Status);
    }

ErrorExit:
    return dwReturn;
}


/*++

    Create all subdirectories if they do not exists starting at
    szCreationStartPoint.

    szCreationStartPoint must point to a character within the null terminated
    buffer specified by the szFullPath parameter.

    Note that szCreationStartPoint should not point at the first character
    of a drive root, eg:

    d:\foo\bar\bilge\water
    \\server\share\foo\bar
    \\?\d:\big\path\bilge\water

    Instead, szCreationStartPoint should point beyond these components, eg:

    bar\bilge\water
    foo\bar
    big\path\bilge\water

    This function does not implement logic for adjusting to compensate for
    these inputs because the environment it was design to be used in causes
    the input szCreationStartPoint to point well into the szFullPath input
    buffer.

--*/

/*static*/ DWORD
CreateNestedDirectories(
    IN      LPWSTR wszFullPath,
    IN      LPWSTR wszCreationStartPoint, // must point in null-terminated range of szFullPath
    IN      BOOL fMachineKeyset)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    DWORD               i;
    DWORD               dwPrevious = 0;
    DWORD               cchRemaining;
    SECURITY_ATTRIBUTES SecAttrib;
    SECURITY_ATTRIBUTES *pSecAttrib;
    SECURITY_DESCRIPTOR sd;
    PACL                pDacl = NULL;
    DWORD               dwSts = ERROR_SUCCESS;
    BOOL                fSts;

    if (wszCreationStartPoint < wszFullPath ||
        wszCreationStartPoint  > (wcslen(wszFullPath) + wszFullPath))
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    cchRemaining = wcslen(wszCreationStartPoint);


    //
    // scan from left to right in the szCreationStartPoint string
    // looking for directory delimiter.
    //

    for (i = 0; i < cchRemaining; i++)
    {
        WCHAR charReplaced = wszCreationStartPoint[i];

        if (charReplaced == '\\' || charReplaced == '/')
        {
            wszCreationStartPoint[ i ] = '\0';

            pSecAttrib = NULL;
            if (fMachineKeyset)
            {
                memset(&SecAttrib, 0, sizeof(SecAttrib));
                SecAttrib.nLength = sizeof(SecAttrib);

                if (0 == wcscmp(MACHINE_KEYS_DIR,
                                &(wszCreationStartPoint[ dwPrevious ])))
                {
                    dwSts = GetMachineKeysetDirDACL(&pDacl);
                    if (ERROR_SUCCESS != dwSts)
                    {
                        dwReturn = dwSts;
                        goto ErrorExit;
                    }
                    fSts = InitializeSecurityDescriptor(&sd,
                                                        SECURITY_DESCRIPTOR_REVISION);
                    if (!fSts)
                    {
                        dwReturn = GetLastError();
                        goto ErrorExit;
                    }

                    fSts = SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE);
                    if (!fSts)
                    {
                        dwReturn = GetLastError();
                        goto ErrorExit;
                    }

                    SecAttrib.lpSecurityDescriptor = &sd;
                    pSecAttrib = &SecAttrib;
                }
            }

            dwSts = CreateSystemDirectory(wszFullPath, pSecAttrib);
            dwPrevious = i + 1;
            wszCreationStartPoint[ i ] = charReplaced;

            if (ERROR_SUCCESS != dwSts)
            {

                //
                // continue onwards, trying to create specified
                // subdirectories.  This is done to address the obscure
                // scenario where the Bypass Traverse Checking Privilege
                // allows the caller to create directories below an
                // existing path where one component denies the user
                // access.  We just keep trying and the last
                // CreateDirectory() result is returned to the caller.
                //

                continue;
            }
        }
    }

    if (ERROR_ALREADY_EXISTS == dwSts)
        dwSts = ERROR_SUCCESS;
    dwReturn = dwSts;

ErrorExit:
    if (NULL != pDacl)
        ContInfoFree(pDacl);
    return dwReturn;
}


#ifdef _M_IX86

BOOL WINAPI
FIsWinNT(
    void)
{

    static BOOL fIKnow = FALSE;
    static BOOL fIsWinNT = FALSE;

    OSVERSIONINFO osVer;

    if (fIKnow)
        return(fIsWinNT);

    memset(&osVer, 0, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (GetVersionEx(&osVer))
        fIsWinNT = (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT);

    // even on an error, this is as good as it gets
    fIKnow = TRUE;

    return fIsWinNT;
}

#else   // other than _M_IX86

BOOL WINAPI
FIsWinNT(
    void)
{
    return TRUE;
}

#endif  // _M_IX86


/*++

    This function determines if the user associated with the
    specified token is the Local System account.

--*/

DWORD
IsLocalSystem(
    BOOL *pfIsLocalSystem)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    HANDLE  hToken = 0;
    HANDLE  hThreadToken = NULL;
    UCHAR InfoBuffer[1024];
    DWORD dwInfoBufferSize = sizeof(InfoBuffer);
    PTOKEN_USER SlowBuffer = NULL;
    PTOKEN_USER pTokenUser = (PTOKEN_USER)InfoBuffer;
    PSID psidLocalSystem = NULL;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    BOOL fSts;
    DWORD dwSts;

    *pfIsLocalSystem = FALSE;

    fSts = OpenThreadToken(GetCurrentThread(),
                           MAXIMUM_ALLOWED,
                           TRUE,
                           &hThreadToken);
    if (fSts)
    {
        // impersonation is going on need to save handle
        RevertToSelf();
    }

    fSts = OpenProcessToken(GetCurrentProcess(),
                            TOKEN_QUERY,
                            &hToken);

    if (!fSts)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (NULL != hThreadToken)
    {
        // put the impersonation token back
        fSts = SetThreadToken(NULL, hThreadToken);
        if (!fSts)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }
    }

    fSts = GetTokenInformation(hToken, TokenUser, pTokenUser,
                               dwInfoBufferSize, &dwInfoBufferSize);

    if (!fSts)
    {
        dwSts = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER == dwSts)
        {

            //
            // if fast buffer wasn't big enough, allocate enough storage
            // and try again.
            //

            SlowBuffer = (PTOKEN_USER)ContInfoAlloc(dwInfoBufferSize);
            if (NULL == SlowBuffer)
            {
                dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorExit;
            }

            pTokenUser = SlowBuffer;
            fSts = GetTokenInformation(hToken, TokenUser, pTokenUser,
                                       dwInfoBufferSize,
                                       &dwInfoBufferSize);
            if (!fSts)
            {
                dwReturn = GetLastError();
                goto ErrorExit;
            }
        }
        else
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    fSts = AllocateAndInitializeSid(&siaNtAuthority,
                                    1,
                                    SECURITY_LOCAL_SYSTEM_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &psidLocalSystem);
    if (!fSts)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (EqualSid(psidLocalSystem, pTokenUser->User.Sid))
        *pfIsLocalSystem = TRUE;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != SlowBuffer)
        ContInfoFree(SlowBuffer);
    if (NULL != psidLocalSystem)
        FreeSid(psidLocalSystem);
    if (NULL != hThreadToken)
        CloseHandle(hThreadToken);
    if (NULL != hToken)
        CloseHandle(hToken);
    return dwReturn;
}


/*++

    This function determines if the user associated with the
    specified token is the Local System account.

--*/

/*static*/ DWORD
IsThreadLocalSystem(
    BOOL *pfIsLocalSystem)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    BOOL fSts;
    DWORD dwSts;
    HANDLE  hToken = 0;
    UCHAR InfoBuffer[1024];
    DWORD dwInfoBufferSize = sizeof(InfoBuffer);
    PTOKEN_USER SlowBuffer = NULL;
    PTOKEN_USER pTokenUser = (PTOKEN_USER)InfoBuffer;
    PSID psidLocalSystem = NULL;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;

    *pfIsLocalSystem = FALSE;

    dwSts = OpenCallerToken(TOKEN_QUERY, &hToken);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    fSts = GetTokenInformation(hToken, TokenUser, pTokenUser,
                               dwInfoBufferSize, &dwInfoBufferSize);

    //
    // if fast buffer wasn't big enough, allocate enough storage
    // and try again.
    //

    if (!fSts)
    {
        dwSts = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        SlowBuffer = (PTOKEN_USER)ContInfoAlloc(dwInfoBufferSize);
        if (NULL == SlowBuffer)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        pTokenUser = SlowBuffer;
        fSts = GetTokenInformation(hToken, TokenUser, pTokenUser,
                                   dwInfoBufferSize, &dwInfoBufferSize);
        if (!fSts)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }
    }

    fSts = AllocateAndInitializeSid(&siaNtAuthority,
                                    1,
                                    SECURITY_LOCAL_SYSTEM_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &psidLocalSystem);
    if (!fSts)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (EqualSid(psidLocalSystem, pTokenUser->User.Sid))
        *pfIsLocalSystem = TRUE;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != SlowBuffer)
        ContInfoFree(SlowBuffer);
    if (NULL != psidLocalSystem)
        FreeSid(psidLocalSystem);
    if (NULL != hToken)
        CloseHandle(hToken);
    return dwReturn;
}


/*static*/ DWORD
GetTextualSidA(
    PSID pSid,              // binary Sid
    LPSTR TextualSid,       // buffer for Textual representaion of Sid
    LPDWORD dwBufferLen)    // required/provided TextualSid buffersize
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    BOOL fSts;
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;
    DWORD dwSidSize;


    fSts = IsValidSid(pSid);
    if (!fSts)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    // obtain SidIdentifierAuthority
    psia = GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // compute buffer length (conservative guess)
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    dwSidSize = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(WCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    if (*dwBufferLen < dwSidSize)
    {
        *dwBufferLen = dwSidSize;
        dwReturn = ERROR_INSUFFICIENT_BUFFER;
        goto ErrorExit;
    }

    //
    // prepare S-SID_REVISION-
    dwSidSize = wsprintfA(TextualSid, "S-%lu-", SID_REVISION );

    //
    // prepare SidIdentifierAuthority
    if ((psia->Value[0] != 0) || (psia->Value[1] != 0))
    {
        dwSidSize += wsprintfA(TextualSid + dwSidSize,
                               "0x%02hx%02hx%02hx%02hx%02hx%02hx",
                               (USHORT)psia->Value[0],
                               (USHORT)psia->Value[1],
                               (USHORT)psia->Value[2],
                               (USHORT)psia->Value[3],
                               (USHORT)psia->Value[4],
                               (USHORT)psia->Value[5]);
    }
    else
    {
        dwSidSize += wsprintfA(TextualSid + dwSidSize,
                               "%lu",
                               (ULONG)(psia->Value[5])
                               + (ULONG)(psia->Value[4] <<  8)
                               + (ULONG)(psia->Value[3] << 16)
                               + (ULONG)(psia->Value[2] << 24));
    }

    //
    // loop through SidSubAuthorities
    for (dwCounter = 0; dwCounter < dwSubAuthorities; dwCounter++)
    {
        dwSidSize += wsprintfA(TextualSid + dwSidSize,
                               "-%lu",
                               *GetSidSubAuthority(pSid, dwCounter));
    }

    *dwBufferLen = dwSidSize + 1; // tell caller how many chars (include NULL)
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*static*/ DWORD
GetTextualSidW(
    PSID pSid,              // binary Sid
    LPWSTR wszTextualSid,   // buffer for Textual representaion of Sid
    LPDWORD dwBufferLen)    // required/provided TextualSid buffersize
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    BOOL fSts;
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;
    DWORD dwSidSize;


    fSts = IsValidSid(pSid);
    if (!fSts)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    // obtain SidIdentifierAuthority
    psia = GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // compute buffer length (conservative guess)
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    dwSidSize = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(WCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    if (*dwBufferLen < dwSidSize)
    {
        *dwBufferLen = dwSidSize;
        dwReturn = ERROR_INSUFFICIENT_BUFFER;
        goto ErrorExit;
    }

    //
    // prepare S-SID_REVISION-
    dwSidSize = wsprintfW(wszTextualSid, L"S-%lu-", SID_REVISION);

    //
    // prepare SidIdentifierAuthority
    if ((psia->Value[0] != 0) || (psia->Value[1] != 0))
    {
        dwSidSize += wsprintfW(wszTextualSid + dwSidSize,
                               L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                               (USHORT)psia->Value[0],
                               (USHORT)psia->Value[1],
                               (USHORT)psia->Value[2],
                               (USHORT)psia->Value[3],
                               (USHORT)psia->Value[4],
                               (USHORT)psia->Value[5]);
    }
    else
    {
        dwSidSize += wsprintfW(wszTextualSid + dwSidSize,
                               L"%lu",
                               (ULONG)(psia->Value[5])
                               + (ULONG)(psia->Value[4] <<  8)
                               + (ULONG)(psia->Value[3] << 16)
                               + (ULONG)(psia->Value[2] << 24));
    }

    //
    // loop through SidSubAuthorities
    for (dwCounter = 0; dwCounter < dwSubAuthorities; dwCounter++)
    {
        dwSidSize += wsprintfW(wszTextualSid + dwSidSize,
                               L"-%lu",
                               *GetSidSubAuthority(pSid, dwCounter));
    }

    *dwBufferLen = dwSidSize + 1; // tell caller how many chars (include NULL)
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*static*/ DWORD
GetUserSid(
    PTOKEN_USER *pptgUser,
    DWORD *pcbUser,
    BOOL *pfAlloced)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    BOOL        fSts;
    DWORD       dwSts;
    HANDLE      hToken = 0;

    *pfAlloced = FALSE;

    dwSts = OpenCallerToken(TOKEN_QUERY, &hToken);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    fSts = GetTokenInformation(hToken,    // identifies access token
                               TokenUser, // TokenUser info type
                               *pptgUser, // retrieved info buffer
                               *pcbUser,  // size of buffer passed-in
                               pcbUser);  // required buffer size
    if (!fSts)
    {
        dwSts = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        //
        // try again with the specified buffer size
        //

        *pptgUser = (PTOKEN_USER)ContInfoAlloc(*pcbUser);
        if (NULL == *pptgUser)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        *pfAlloced = TRUE;
        fSts = GetTokenInformation(hToken,    // identifies access token
                                   TokenUser, // TokenUser info type
                                   *pptgUser, // retrieved info buffer
                                   *pcbUser,  // size of buffer passed-in
                                   pcbUser);  // required buffer size
        if (!fSts)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != hToken)
        CloseHandle(hToken);
    return dwReturn;
}


DWORD
GetUserTextualSidA(
    LPSTR lpBuffer,
    LPDWORD nSize)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    DWORD       dwSts;
    BYTE        FastBuffer[FAST_BUF_SIZE];
    PTOKEN_USER ptgUser;
    DWORD       cbUser;
    BOOL        fAlloced = FALSE;

    ptgUser = (PTOKEN_USER)FastBuffer; // try fast buffer first
    cbUser = FAST_BUF_SIZE;
    dwSts = GetUserSid(&ptgUser, &cbUser, &fAlloced);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }


    //
    // obtain the textual representaion of the Sid
    //

    dwSts = GetTextualSidA(ptgUser->User.Sid, // user binary Sid
                           lpBuffer,          // buffer for TextualSid
                           nSize);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (fAlloced)
    {
        if (NULL != ptgUser)
            ContInfoFree(ptgUser);
    }
    return dwReturn;
}

DWORD
GetUserTextualSidW(
    LPWSTR lpBuffer,
    LPDWORD nSize)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    DWORD       dwSts;
    BYTE        FastBuffer[FAST_BUF_SIZE];
    PTOKEN_USER ptgUser;
    DWORD       cbUser;
    BOOL        fAlloced = FALSE;

    ptgUser = (PTOKEN_USER)FastBuffer; // try fast buffer first
    cbUser = FAST_BUF_SIZE;
    dwSts = GetUserSid(&ptgUser, &cbUser, &fAlloced);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }


    //
    // obtain the textual representaion of the Sid
    //

    dwSts = GetTextualSidW(ptgUser->User.Sid, // user binary Sid
                           lpBuffer,          // buffer for TextualSid
                           nSize);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (fAlloced)
    {
        if (NULL != ptgUser)
            ContInfoFree(ptgUser);
    }
    return dwReturn;
}

/*static*/ DWORD
GetUserDirectory(
    IN BOOL fMachineKeyset,
    OUT LPWSTR pwszUser,
    OUT DWORD *pcbUser)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    DWORD dwSts;

    if (fMachineKeyset)
    {
        wcscpy(pwszUser, MACHINE_KEYS_DIR);
        *pcbUser = wcslen(pwszUser) + 1;
    }
    else
    {
        if (FIsWinNT())
        {
            dwSts = GetUserTextualSidW(pwszUser, pcbUser);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }
        else
        {
            dwReturn = (DWORD)NTE_FAIL;
            goto ErrorExit;
        }
    }
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


#define WSZRSAPRODUCTSTRING  L"\\Microsoft\\Crypto\\RSA\\"
#define WSZDSSPRODUCTSTRING  L"\\Microsoft\\Crypto\\DSS\\"
#define PRODUCTSTRINGLEN    sizeof(WSZRSAPRODUCTSTRING) - sizeof(WCHAR)

typedef HRESULT
(WINAPI *SHGETFOLDERPATHW)(
    HWND hwnd,
    int csidl,
    HANDLE hToken,
    DWORD dwFlags,
    LPWSTR pwszPath);

/*static*/ DWORD
GetUserStorageArea(
    IN  DWORD dwProvType,
    IN  BOOL fMachineKeyset,
    IN  BOOL fOldWin2KMachineKeyPath,
    OUT BOOL *pfIsLocalSystem,  // used if fMachineKeyset is FALSE, in this
                                // case TRUE is returned if running as Local
                                // System
    IN  OUT LPWSTR *ppwszUserStorageArea)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    WCHAR wszUserStorageRoot[MAX_PATH+1];
    DWORD cbUserStorageRoot;
    WCHAR *wszProductString = NULL;
    WCHAR wszUser[MAX_PATH];
    DWORD cbUser;
    DWORD cchUser = MAX_PATH;
    HANDLE hToken = NULL;
    DWORD dwTempProfileFlags = 0;
    DWORD dwSts;
    BOOL fSts;
    HMODULE hShell32 = NULL;
    PBYTE pbCurrent;

    *pfIsLocalSystem = FALSE;

    if ((PROV_RSA_SIG == dwProvType)
        || (PROV_RSA_FULL == dwProvType)
        || (PROV_RSA_SCHANNEL == dwProvType)
        || (PROV_RSA_AES == dwProvType))
    {
        wszProductString = WSZRSAPRODUCTSTRING;
    }
    else if ((PROV_DSS == dwProvType)
             || (PROV_DSS_DH == dwProvType)
             || (PROV_DH_SCHANNEL == dwProvType))
    {
        wszProductString = WSZDSSPRODUCTSTRING;
    }


    //
    // check if running in the LocalSystem context
    //

    if (!fMachineKeyset)
    {
        dwSts = IsThreadLocalSystem(pfIsLocalSystem);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }


    //
    // determine path to per-user storage area, based on whether this
    // is a local machine disposition call or a per-user disposition call.
    //

    if (fMachineKeyset || *pfIsLocalSystem)
    {
        if (!fOldWin2KMachineKeyPath)
        {
            // Should not call SHGetFolderPathW with a caller token for 
            // the local machine case.  The COMMON_APPDATA location is 
            // per-machine, not per-user, therefor we shouldn't be supplying
            // a user token.  The shell team should make their own change to ignore
            // this, though.
            /*
            dwSts = OpenCallerToken(TOKEN_QUERY | TOKEN_IMPERSONATE,
                                    &hToken);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
            */

            dwSts = (DWORD) SHGetFolderPathW(NULL,
                                             CSIDL_COMMON_APPDATA | CSIDL_FLAG_CREATE,
                                             0 /*hToken*/,
                                             0,
                                             wszUserStorageRoot);
            if (dwSts != ERROR_SUCCESS)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            /*
            CloseHandle(hToken);
            hToken = NULL;
            */

            cbUserStorageRoot = wcslen( wszUserStorageRoot ) * sizeof(WCHAR);
        }
        else
        {
            cbUserStorageRoot = GetSystemDirectoryW(wszUserStorageRoot,
                                                    MAX_PATH);
            cbUserStorageRoot *= sizeof(WCHAR);
        }
    }
    else
    {
        // check if the profile is temporary
        fSts = GetProfileType(&dwTempProfileFlags);
        if (!fSts)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

         if ((dwTempProfileFlags & PT_MANDATORY)
             || ((dwTempProfileFlags & PT_TEMPORARY)
                 && !(dwTempProfileFlags & PT_ROAMING)))
        {
            dwReturn = (DWORD)NTE_TEMPORARY_PROFILE;
            goto ErrorExit;
        }

        dwSts = OpenCallerToken(TOKEN_QUERY | TOKEN_IMPERSONATE,
                                &hToken);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        // Use new private shell entry point for finding user storage path
        if (ERROR_SUCCESS != 
            (dwSts = GetUserAppDataPathW(hToken, wszUserStorageRoot)))
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        CloseHandle(hToken);
        hToken = NULL;
        cbUserStorageRoot = wcslen( wszUserStorageRoot ) * sizeof(WCHAR);
    }

    if (cbUserStorageRoot == 0)
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }


    //
    // get the user name associated with the call.
    // Note: this is the textual Sid on NT, and will fail on Win95.
    //

    dwSts = GetUserDirectory(fMachineKeyset, wszUser, &cchUser);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    cbUser = (cchUser-1) * sizeof(WCHAR);
    *ppwszUserStorageArea = (LPWSTR)ContInfoAlloc(cbUserStorageRoot
                                                  + PRODUCTSTRINGLEN
                                                  + cbUser
                                                  + 2 * sizeof(WCHAR)); // trailing slash and NULL
    if (NULL == *ppwszUserStorageArea)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    pbCurrent = (PBYTE)*ppwszUserStorageArea;

    CopyMemory(pbCurrent, wszUserStorageRoot, cbUserStorageRoot);
    pbCurrent += cbUserStorageRoot;

    CopyMemory(pbCurrent, wszProductString, PRODUCTSTRINGLEN);
    pbCurrent += PRODUCTSTRINGLEN;

    CopyMemory(pbCurrent, wszUser, cbUser);
    pbCurrent += cbUser; // note: cbUser does not include terminal NULL

    ((LPSTR)pbCurrent)[0] = '\\';
    ((LPSTR)pbCurrent)[1] = '\0';


    dwSts = CreateNestedDirectories(*ppwszUserStorageArea,
                                    (LPWSTR)((LPBYTE)*ppwszUserStorageArea
                                                      + cbUserStorageRoot
                                                      + sizeof(WCHAR)),
                                    fMachineKeyset);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != hToken)
        CloseHandle(hToken);
    return dwReturn;
}


/*static*/ DWORD
GetFilePath(
    IN      LPCWSTR  pwszUserStorageArea,
    IN      LPCWSTR  pwszFileName,
    IN OUT  LPWSTR   *ppwszFilePath)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    DWORD cbUserStorageArea;
    DWORD cbFileName;

    cbUserStorageArea = wcslen(pwszUserStorageArea) * sizeof(WCHAR);
    cbFileName = wcslen(pwszFileName) * sizeof(WCHAR);
    *ppwszFilePath = (LPWSTR)ContInfoAlloc(cbUserStorageArea
                                           + cbFileName
                                           + sizeof(WCHAR));
    if (*ppwszFilePath == NULL)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    CopyMemory(*ppwszFilePath, pwszUserStorageArea, cbUserStorageArea);
    CopyMemory((LPBYTE)*ppwszFilePath+cbUserStorageArea, pwszFileName, cbFileName + sizeof(WCHAR));
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


static DWORD
    rgdwCreateFileRetryMilliseconds[] =
        { 1, 10, 100, 500, 1000, 5000 };

#define MAX_CREATE_FILE_RETRY_COUNT     \
            (sizeof(rgdwCreateFileRetryMilliseconds) \
             / sizeof(rgdwCreateFileRetryMilliseconds[0]))

/*static*/ DWORD
MyCreateFile(
    IN BOOL fMachineKeyset,         // indicates if this is a machine keyset
    IN LPCWSTR wszFilePath,         // pointer to name of the file
    IN DWORD dwDesiredAccess,       // access (read-write) mode
    IN DWORD dwShareMode,           // share mode
    IN DWORD dwCreationDisposition, // how to create
    IN DWORD dwAttribs,             // file attributes
    OUT HANDLE *phFile)             // Resultant handle
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    HANDLE          hToken = 0;
    BYTE            rgbPriv[sizeof(PRIVILEGE_SET) + sizeof(LUID_AND_ATTRIBUTES)];
    PRIVILEGE_SET   *pPriv = (PRIVILEGE_SET*)rgbPriv;
    BOOL            fPrivSet = FALSE;
    HANDLE          hFile = INVALID_HANDLE_VALUE;
    DWORD           dwSts, dwSavedSts;
    BOOL            fSts;

    hFile = CreateFileW(wszFilePath,
                        dwDesiredAccess,
                        dwShareMode,
                        NULL,
                        dwCreationDisposition,
                        dwAttribs,
                        NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        dwSts = GetLastError();

        // check if machine keyset
        if (fMachineKeyset)
        {
            dwSavedSts = dwSts;

            // open a token handle
            dwSts = OpenCallerToken(TOKEN_QUERY, &hToken);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            memset(rgbPriv, 0, sizeof(rgbPriv));
            pPriv->PrivilegeCount = 1;
            // reading file
            if (dwDesiredAccess & GENERIC_READ)
            {
                fSts = LookupPrivilegeValue(NULL, SE_BACKUP_NAME,
                                           &(pPriv->Privilege[0].Luid));
            }
            // writing
            else
            {
                fSts = LookupPrivilegeValue(NULL, SE_RESTORE_NAME,
                                            &(pPriv->Privilege[0].Luid));
            }
            if (!fSts)
            {
                dwReturn = GetLastError();
                goto ErrorExit;
            }

            // check if the BACKUP or RESTORE privileges are set
            pPriv->Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;
            fSts = PrivilegeCheck(hToken, pPriv, &fPrivSet);
            if (!fSts)
            {
                dwReturn = GetLastError();
                goto ErrorExit;
            }

            if (fPrivSet)
            {
                hFile = CreateFileW(wszFilePath,
                                    dwDesiredAccess,
                                    dwShareMode,
                                    NULL,
                                    dwCreationDisposition,
                                    dwAttribs | FILE_FLAG_BACKUP_SEMANTICS,
                                    NULL);
                if (INVALID_HANDLE_VALUE == hFile)
                {
                    dwReturn = GetLastError();
                    goto ErrorExit;
                }
            }
            else
            {
                dwReturn = dwSavedSts;
                goto ErrorExit;
            }
        }
        else
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    *phFile = hFile;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != hToken)
        CloseHandle(hToken);
    return dwReturn;
}


/*static*/ DWORD
OpenFileInStorageArea(
    IN      BOOL    fMachineKeyset,
    IN      DWORD   dwDesiredAccess,
    IN      LPCWSTR wszUserStorageArea,
    IN      LPCWSTR wszFileName,
    IN OUT  HANDLE  *phFile)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    LPWSTR wszFilePath = NULL;
    DWORD dwShareMode = 0;
    DWORD dwCreationDistribution = OPEN_EXISTING;
    DWORD dwRetryCount;
    DWORD dwAttribs = 0;
    DWORD dwSts;

    *phFile = INVALID_HANDLE_VALUE;

    if (dwDesiredAccess & GENERIC_READ)
    {
        dwShareMode |= FILE_SHARE_READ;
        dwCreationDistribution = OPEN_EXISTING;
    }

    if (dwDesiredAccess & GENERIC_WRITE)
    {
        dwShareMode = 0;
        dwCreationDistribution = OPEN_ALWAYS;
        dwAttribs = FILE_ATTRIBUTE_SYSTEM;
    }

    dwSts = GetFilePath(wszUserStorageArea, wszFileName, &wszFilePath);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwRetryCount = 0;
    for (;;)
    {
        dwSts = MyCreateFile(fMachineKeyset,
                             wszFilePath,
                             dwDesiredAccess,
                             dwShareMode,
                             dwCreationDistribution,
                             dwAttribs | FILE_FLAG_SEQUENTIAL_SCAN,
                             phFile);
        if (ERROR_SUCCESS == dwSts)
            break;

        if (((ERROR_SHARING_VIOLATION == dwSts)
             || (ERROR_ACCESS_DENIED == dwSts))
            && (MAX_CREATE_FILE_RETRY_COUNT > dwRetryCount))
        {
            Sleep(rgdwCreateFileRetryMilliseconds[dwRetryCount]);
            dwRetryCount++;
        }
        else
        {
            if (ERROR_FILE_NOT_FOUND == dwSts)
                dwReturn = (DWORD)NTE_BAD_KEYSET;
            else
                dwReturn = dwSts;
            goto ErrorExit;
        }
    }
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != wszFilePath)
        ContInfoFree(wszFilePath);
    return dwReturn;
}


/*static*/ DWORD
FindClosestFileInStorageArea(
    IN      LPCWSTR  pwszUserStorageArea,
    IN      LPCSTR   pszContainer,
    OUT     LPWSTR   pwszNewFileName,
    IN OUT  HANDLE  *phFile)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    LPWSTR pwszFilePath = NULL;
    WCHAR  rgwszNewFileName[35];
    DWORD dwShareMode = 0;
    DWORD dwCreationDistribution = OPEN_EXISTING;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW FindData;
    DWORD dwSts;

    memset(&FindData, 0, sizeof(FindData));
    memset(rgwszNewFileName, 0, sizeof(rgwszNewFileName));

    *phFile = INVALID_HANDLE_VALUE;

    dwShareMode |= FILE_SHARE_READ;
    dwCreationDistribution = OPEN_EXISTING;

    // get the stringized hash of the container name
    dwSts = GetHashOfContainer(pszContainer, rgwszNewFileName);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // ContInfoAlloc zeros memory so no need to set NULL terminator
    rgwszNewFileName[32] = '_';
    rgwszNewFileName[33] = '*';

    dwSts = GetFilePath(pwszUserStorageArea, rgwszNewFileName, &pwszFilePath);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    hFind = FindFirstFileExW(pwszFilePath,
                             FindExInfoStandard,
                             &FindData,
                             FindExSearchNameMatch,
                             NULL,
                             0);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        dwSts = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwSts)
            dwReturn = (DWORD)NTE_BAD_KEYSET;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    ContInfoFree(pwszFilePath);
    pwszFilePath = NULL;

    dwSts = GetFilePath(pwszUserStorageArea, FindData.cFileName,
                        &pwszFilePath);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    *phFile = CreateFileW(pwszFilePath,
                          GENERIC_READ,
                          dwShareMode,
                          NULL,
                          dwCreationDistribution,
                          FILE_FLAG_SEQUENTIAL_SCAN,
                          NULL);
    if (*phFile == INVALID_HANDLE_VALUE)
    {
        dwSts = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwSts)
            dwReturn = (DWORD)NTE_BAD_KEYSET;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    // allocate and copy in the real file name to be returned
    wcscpy(pwszNewFileName, FindData.cFileName);
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != hFind)
        FindClose(hFind);
    if (NULL != pwszFilePath)
        ContInfoFree(pwszFilePath);
    return dwReturn;
}


//
//  This function gets the determines if the user associated with the
//  specified token is the Local System account.
//

/*static*/ DWORD
ZeroizeFile(
    IN LPCWSTR wszFilePath)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    BYTE    *pb = NULL;
    DWORD   cb;
    DWORD   dwBytesWritten = 0;
    DWORD   dwSts;
    BOOL    fSts;

    hFile = CreateFileW(wszFilePath,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_SYSTEM,
                        NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        dwSts = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwSts)
            dwReturn = (DWORD)NTE_BAD_KEYSET;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    cb = GetFileSize(hFile, NULL);
    if ((DWORD)(-1) == cb)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    pb = ContInfoAlloc(cb);
    if (NULL == pb)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    fSts = WriteFile(hFile, pb, cb, &dwBytesWritten, NULL);
    if (!fSts)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pb)
        ContInfoFree(pb);
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    return dwReturn;
}


/*static*/ DWORD
DeleteFileInStorageArea(
    IN LPCWSTR wszUserStorageArea,
    IN LPCWSTR wszFileName)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    LPWSTR wszFilePath = NULL;
    DWORD cbUserStorageArea;
    DWORD cbFileName;
    DWORD dwSts;

    cbUserStorageArea = wcslen(wszUserStorageArea) * sizeof(WCHAR);
    cbFileName = wcslen(wszFileName) * sizeof(WCHAR);

    wszFilePath = (LPWSTR)ContInfoAlloc((cbUserStorageArea + cbFileName + 1) * sizeof(WCHAR));
    if (wszFilePath == NULL)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    CopyMemory(wszFilePath, wszUserStorageArea, cbUserStorageArea);
    CopyMemory((LPBYTE)wszFilePath + cbUserStorageArea, wszFileName,
               cbFileName + sizeof(WCHAR));

    // write a file of the same size with all zeros first
    dwSts = ZeroizeFile(wszFilePath);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (!DeleteFileW(wszFilePath))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != wszFilePath)
        ContInfoFree(wszFilePath);
    return dwReturn;
}


DWORD
SetContainerUserName(
    IN LPSTR pszUserName,
    IN PKEY_CONTAINER_INFO pContInfo)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;

    pContInfo->pszUserName = (LPSTR)ContInfoAlloc((strlen(pszUserName) + 1) * sizeof(CHAR));
    if (NULL == pContInfo->pszUserName)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    strcpy(pContInfo->pszUserName, pszUserName);
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


DWORD
ReadContainerInfo(
    IN DWORD dwProvType,
    IN LPSTR pszContainerName,
    IN BOOL fMachineKeyset,
    IN DWORD dwFlags,
    OUT PKEY_CONTAINER_INFO pContInfo)
{
    DWORD                   dwReturn = ERROR_INTERNAL_ERROR;
    HANDLE                  hMap = NULL;
    BYTE                    *pbFile = NULL;
    DWORD                   cbFile;
    DWORD                   cb;
    HANDLE                  hFile = INVALID_HANDLE_VALUE;
    KEY_EXPORTABILITY_LENS  Exportability;
    LPWSTR                  pwszFileName = NULL;
    LPWSTR                  pwszFilePath = NULL;
    WCHAR                   rgwszOtherMachineFileName[84];
    BOOL                    fGetUserNameFromFile = FALSE;
    BOOL                    fIsLocalSystem = FALSE;
    BOOL                    fRetryWithHashedName = TRUE;
    DWORD                   cch = 0;
    DWORD                   dwSts;

    memset(&Exportability, 0, sizeof(Exportability));

    // get the correct storage area (directory)
    dwSts = GetUserStorageArea(dwProvType, fMachineKeyset, FALSE,
                               &fIsLocalSystem, &pwszFilePath);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // check if the length of the container name is the length of a new unique container,
    // then try with the container name which was passed in, if this fails
    // then try with the container name with the machine GUID appended
    if (69 == strlen(pszContainerName))
    {
        // convert to UNICODE pszContainerName -> pwszFileName
        cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
                                  pszContainerName,
                                  -1, NULL, cch);
        if (0 == cch)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        pwszFileName = ContInfoAlloc((cch + 1) * sizeof(WCHAR));
        if (NULL == pwszFileName)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
                                  pszContainerName,
                                  -1, pwszFileName, cch);
        if (0 == cch)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        dwSts = OpenFileInStorageArea(fMachineKeyset, GENERIC_READ,
                                      pwszFilePath, pwszFileName, &hFile);
        if (ERROR_SUCCESS == dwSts)
        {
            wcscpy(pContInfo->rgwszFileName, pwszFileName);

            // set the flag so the name of the key container will be retrieved
            // from the file
            fGetUserNameFromFile = TRUE;
            fRetryWithHashedName = FALSE;
        }
    }

    if (fRetryWithHashedName)
    {
        dwSts = AddMachineGuidToContainerName(pszContainerName,
                                              pContInfo->rgwszFileName);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = OpenFileInStorageArea(fMachineKeyset, GENERIC_READ,
                                      pwszFilePath,
                                      pContInfo->rgwszFileName,
                                      &hFile);
        if (ERROR_SUCCESS != dwSts)
        {
            if ((ERROR_ACCESS_DENIED == dwSts) && (dwFlags & CRYPT_NEWKEYSET))
            {
                dwReturn = (DWORD)NTE_EXISTS;
                goto ErrorExit;
            }

            if (NTE_BAD_KEYSET == dwSts)
            {
                if (fMachineKeyset || fIsLocalSystem)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }
                else
                {
                    memset(rgwszOtherMachineFileName, 0,
                           sizeof(rgwszOtherMachineFileName));
                    // try to open any file from another machine with this
                    // container name
                    dwSts = FindClosestFileInStorageArea(pwszFilePath,
                                                         pszContainerName,
                                                         rgwszOtherMachineFileName,
                                                         &hFile);
                    if (ERROR_SUCCESS != dwSts)
                    {
                        dwReturn = dwSts;
                        goto ErrorExit;
                    }
                    wcscpy(pContInfo->rgwszFileName,
                           rgwszOtherMachineFileName);
                }
            }
        }
    }

    if (dwFlags & CRYPT_NEWKEYSET)
    {
        dwReturn = (DWORD)NTE_EXISTS;
        goto ErrorExit;
    }

    cbFile = GetFileSize(hFile, NULL);
    if ((DWORD)(-1) == cbFile)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (sizeof(KEY_CONTAINER_LENS) > cbFile)
    {
        dwSts = (DWORD)NTE_KEYSET_ENTRY_BAD;
        goto ErrorExit;
    }

    hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (NULL == hMap)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    pbFile = (BYTE*)MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
    if (NULL == pbFile)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    // get the length information out of the file
    memcpy(&pContInfo->dwVersion, pbFile, sizeof(DWORD));
    cb = sizeof(DWORD);
    if (KEY_CONTAINER_FILE_FORMAT_VER != pContInfo->dwVersion)
    {
        dwSts = (DWORD)NTE_KEYSET_ENTRY_BAD;
        goto ErrorExit;
    }

    memcpy(&pContInfo->ContLens, pbFile + cb, sizeof(KEY_CONTAINER_LENS));
    cb += sizeof(KEY_CONTAINER_LENS);

    if (pContInfo->fCryptSilent && (0 != pContInfo->ContLens.dwUIOnKey))
    {
        dwReturn = (DWORD)NTE_SILENT_CONTEXT;
        goto ErrorExit;
    }

    // get the private key exportability stuff
    memcpy(&Exportability, pbFile + cb, sizeof(KEY_EXPORTABILITY_LENS));
    cb += sizeof(KEY_EXPORTABILITY_LENS);

    // get the user name
    pContInfo->pszUserName = ContInfoAlloc(pContInfo->ContLens.cbName);
    if (NULL == pContInfo->pszUserName)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    memcpy(pContInfo->pszUserName, pbFile + cb, pContInfo->ContLens.cbName);
    cb += pContInfo->ContLens.cbName;

    // get the random seed
    pContInfo->pbRandom = ContInfoAlloc(pContInfo->ContLens.cbRandom);
    if (NULL == pContInfo->pbRandom)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    memcpy(pContInfo->pbRandom, pbFile + cb, pContInfo->ContLens.cbRandom);
    cb += pContInfo->ContLens.cbRandom;

    // get the signature key info out of the file
    if (pContInfo->ContLens.cbSigPub && pContInfo->ContLens.cbSigEncPriv)
    {
        pContInfo->pbSigPub = ContInfoAlloc(pContInfo->ContLens.cbSigPub);
        if (NULL == pContInfo->pbSigPub)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        memcpy(pContInfo->pbSigPub, pbFile + cb, pContInfo->ContLens.cbSigPub);
        cb += pContInfo->ContLens.cbSigPub;

        pContInfo->pbSigEncPriv = ContInfoAlloc(pContInfo->ContLens.cbSigEncPriv);
        if (NULL == pContInfo->pbSigEncPriv)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        memcpy(pContInfo->pbSigEncPriv, pbFile + cb,
               pContInfo->ContLens.cbSigEncPriv);
        cb += pContInfo->ContLens.cbSigEncPriv;

        // get the exportability info for the sig key
        dwSts = UnprotectExportabilityFlag(fMachineKeyset, pbFile + cb,
                                           Exportability.cbSigExportability,
                                           &pContInfo->fSigExportable);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        cb += Exportability.cbSigExportability;
    }

    // get the signature key info out of the file
    if (pContInfo->ContLens.cbExchPub && pContInfo->ContLens.cbExchEncPriv)
    {
        pContInfo->pbExchPub = ContInfoAlloc(pContInfo->ContLens.cbExchPub);
        if (NULL == pContInfo->pbExchPub)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        memcpy(pContInfo->pbExchPub, pbFile + cb,
               pContInfo->ContLens.cbExchPub);
        cb += pContInfo->ContLens.cbExchPub;

        pContInfo->pbExchEncPriv = ContInfoAlloc(pContInfo->ContLens.cbExchEncPriv);
        if (NULL == pContInfo->pbExchEncPriv)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        memcpy(pContInfo->pbExchEncPriv, pbFile + cb,
               pContInfo->ContLens.cbExchEncPriv);
        cb += pContInfo->ContLens.cbExchEncPriv;

        // get the exportability info for the sig key
        dwSts = UnprotectExportabilityFlag(fMachineKeyset, pbFile + cb,
                                           Exportability.cbExchExportability,
                                           &pContInfo->fExchExportable);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        cb += Exportability.cbExchExportability;
    }

    pContInfo = NULL;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pwszFileName)
        ContInfoFree(pwszFileName);
    if (NULL != pContInfo)
        FreeContainerInfo(pContInfo);
    if (NULL != pwszFilePath)
        ContInfoFree(pwszFilePath);
    if (NULL != pbFile)
        UnmapViewOfFile(pbFile);
    if (NULL != hMap)
        CloseHandle(hMap);
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    return dwReturn;
}


DWORD
WriteContainerInfo(
    IN DWORD dwProvType,
    IN LPWSTR pwszFileName,
    IN BOOL fMachineKeyset,
    IN PKEY_CONTAINER_INFO pContInfo)
{
    DWORD                   dwReturn = ERROR_INTERNAL_ERROR;
    BYTE                    *pbProtectedSigExportFlag = NULL;
    BYTE                    *pbProtectedExchExportFlag = NULL;
    KEY_EXPORTABILITY_LENS  ExportabilityLens;
    BYTE                    *pb = NULL;
    DWORD                   cb;
    LPWSTR                  pwszFilePath = NULL;
    HANDLE                  hFile = 0;
    DWORD                   dwBytesWritten;
    BOOL                    fIsLocalSystem = FALSE;
    DWORD                   dwSts;
    BOOL                    fSts;

    memset(&ExportabilityLens, 0, sizeof(ExportabilityLens));

    // protect the signature exportability flag if necessary
    if (pContInfo->ContLens.cbSigPub && pContInfo->ContLens.cbSigEncPriv)
    {
        dwSts = ProtectExportabilityFlag(pContInfo->fSigExportable,
                                         fMachineKeyset, &pbProtectedSigExportFlag,
                                         &ExportabilityLens.cbSigExportability);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    // protect the key exchange exportability flag if necessary
    if (pContInfo->ContLens.cbExchPub && pContInfo->ContLens.cbExchEncPriv)
    {
        dwSts = ProtectExportabilityFlag(pContInfo->fExchExportable,
                                         fMachineKeyset, &pbProtectedExchExportFlag,
                                         &ExportabilityLens.cbExchExportability);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    pContInfo->ContLens.cbName = strlen(pContInfo->pszUserName) + sizeof(CHAR);

    // calculate the buffer length required for the container info
    cb = pContInfo->ContLens.cbSigPub + pContInfo->ContLens.cbSigEncPriv +
         pContInfo->ContLens.cbExchPub + pContInfo->ContLens.cbExchEncPriv +
         ExportabilityLens.cbSigExportability +
         ExportabilityLens.cbExchExportability +
         pContInfo->ContLens.cbName +
         pContInfo->ContLens.cbRandom +
         sizeof(KEY_EXPORTABILITY_LENS) + sizeof(KEY_CONTAINER_INFO) +
         sizeof(DWORD);

    pb = (BYTE*)ContInfoAlloc(cb);
    if (NULL == pb)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    // copy the length information
    pContInfo->dwVersion = KEY_CONTAINER_FILE_FORMAT_VER;
    memcpy(pb, &pContInfo->dwVersion, sizeof(DWORD));
    cb = sizeof(DWORD);
    memcpy(pb + cb, &pContInfo->ContLens, sizeof(KEY_CONTAINER_LENS));
    cb += sizeof(KEY_CONTAINER_LENS);
    if (KEY_CONTAINER_FILE_FORMAT_VER != pContInfo->dwVersion)
    {
        dwReturn = (DWORD)NTE_KEYSET_ENTRY_BAD;
        goto ErrorExit;
    }

    memcpy(pb + cb, &ExportabilityLens, sizeof(KEY_EXPORTABILITY_LENS));
    cb += sizeof(KEY_EXPORTABILITY_LENS);

    // copy the name of the container to the file
    memcpy(pb + cb, pContInfo->pszUserName, pContInfo->ContLens.cbName);
    cb += pContInfo->ContLens.cbName;

    // copy the random seed to the file
    memcpy(pb + cb, pContInfo->pbRandom, pContInfo->ContLens.cbRandom);
    cb += pContInfo->ContLens.cbRandom;

    // copy the signature key info to the file
    if (pContInfo->ContLens.cbSigPub || pContInfo->ContLens.cbSigEncPriv)
    {
        memcpy(pb + cb, pContInfo->pbSigPub, pContInfo->ContLens.cbSigPub);
        cb += pContInfo->ContLens.cbSigPub;

        memcpy(pb + cb, pContInfo->pbSigEncPriv,
               pContInfo->ContLens.cbSigEncPriv);
        cb += pContInfo->ContLens.cbSigEncPriv;

        // write the exportability info for the sig key
        memcpy(pb + cb, pbProtectedSigExportFlag,
               ExportabilityLens.cbSigExportability);
        cb += ExportabilityLens.cbSigExportability;
    }

    // get the signature key info out of the file
    if (pContInfo->ContLens.cbExchPub || pContInfo->ContLens.cbExchEncPriv)
    {
        memcpy(pb + cb, pContInfo->pbExchPub, pContInfo->ContLens.cbExchPub);
        cb += pContInfo->ContLens.cbExchPub;

        memcpy(pb + cb, pContInfo->pbExchEncPriv,
               pContInfo->ContLens.cbExchEncPriv);
        cb += pContInfo->ContLens.cbExchEncPriv;

        // write the exportability info for the sig key
        memcpy(pb + cb, pbProtectedExchExportFlag,
               ExportabilityLens.cbExchExportability);
        cb += ExportabilityLens.cbExchExportability;
    }

    // get the correct storage area (directory)
    dwSts = GetUserStorageArea(dwProvType, fMachineKeyset, FALSE,
                               &fIsLocalSystem, &pwszFilePath);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // open the file to write the information to
    dwSts = OpenFileInStorageArea(fMachineKeyset, GENERIC_WRITE,
                                  pwszFilePath, pwszFileName,
                                  &hFile);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;   // NTE_FAIL
        goto ErrorExit;
    }

    fSts = WriteFile(hFile, pb, cb, &dwBytesWritten, NULL);
    if (!fSts)
    {
        dwReturn = GetLastError();  // NTE_FAIL
        goto ErrorExit;
    }
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pwszFilePath)
        ContInfoFree(pwszFilePath);
    if (NULL != pbProtectedSigExportFlag)
        ContInfoFree(pbProtectedSigExportFlag);
    if (NULL != pbProtectedExchExportFlag)
        ContInfoFree(pbProtectedExchExportFlag);
    if (NULL != pb)
        ContInfoFree(pb);
    if (NULL != hFile)
        CloseHandle(hFile);
    return dwReturn;
}


/*static*/ DWORD
DeleteKeyContainer(
    IN LPWSTR pwszFilePath,
    IN LPSTR pszContainer)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    LPWSTR  pwszFileName = NULL;
    WCHAR   rgwchNewFileName[80];
    BOOL    fRetryWithHashedName = TRUE;
    DWORD   cch = 0;
    DWORD   dwSts;

    memset(rgwchNewFileName, 0, sizeof(rgwchNewFileName));

    // first try with the container name which was passed in, if this fails
    if (69 == strlen(pszContainer))
    {
        // convert to UNICODE pszContainer -> pwszFileName
        cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
                                  pszContainer,
                                  -1, NULL, cch);
        if (0 == cch)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        pwszFileName = ContInfoAlloc((cch + 1) * sizeof(WCHAR));
        if (NULL == pwszFileName)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
                                  pszContainer,
                                  -1, pwszFileName, cch);
        if (0 == cch)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        dwSts = DeleteFileInStorageArea(pwszFilePath, pwszFileName);
        if (ERROR_SUCCESS == dwSts)
            fRetryWithHashedName = FALSE;
    }

    // then try with hash of container name and the machine GUID appended
    if (fRetryWithHashedName)
    {
        dwSts = AddMachineGuidToContainerName(pszContainer,
                                              rgwchNewFileName);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = DeleteFileInStorageArea(pwszFilePath, rgwchNewFileName);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pwszFileName)
        ContInfoFree(pwszFileName);
    return dwReturn;
}


DWORD
DeleteContainerInfo(
    IN DWORD dwProvType,
    IN LPSTR pszContainer,
    IN BOOL fMachineKeyset)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    LPWSTR  pwszFilePath = NULL;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    BOOL    fIsLocalSystem = FALSE;
    WCHAR   rgwchNewFileName[80];
    BOOL    fDeleted = FALSE;
    DWORD   dwSts;

    // get the correct storage area (directory)
    dwSts = GetUserStorageArea(dwProvType, fMachineKeyset, FALSE,
                               &fIsLocalSystem, &pwszFilePath);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwSts = DeleteKeyContainer(pwszFilePath, pszContainer);
    if (ERROR_SUCCESS != dwSts)
    {
        // for migration of machine keys from system to All Users\App Data
        if (fMachineKeyset)
        {
            ContInfoFree(pwszFilePath);
            pwszFilePath = NULL;

            dwSts = GetUserStorageArea(dwProvType, fMachineKeyset, TRUE,
                                       &fIsLocalSystem, &pwszFilePath);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            dwSts = DeleteKeyContainer(pwszFilePath, pszContainer);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
            else
            {
                fDeleted = TRUE;
            }
        }
    }
    else
    {
        fDeleted = TRUE;
    }

    // there may be other keys created with the same container name on
    // different machines and these also need to be deleted
    for (;;)
    {
        memset(rgwchNewFileName, 0, sizeof(rgwchNewFileName));

        dwSts = FindClosestFileInStorageArea(pwszFilePath, pszContainer,
                                             rgwchNewFileName, &hFile);
        if (ERROR_SUCCESS != dwSts)
            break;

        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;

        dwSts = DeleteFileInStorageArea(pwszFilePath, rgwchNewFileName);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        else
            fDeleted = TRUE;
    }

    if (!fDeleted)
    {
        dwReturn = (DWORD)NTE_BAD_KEYSET;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    if (NULL != pwszFilePath)
        ContInfoFree(pwszFilePath);
    return dwReturn;
}


/*static*/ DWORD
ReadContainerNameFromFile(
    IN BOOL fMachineKeyset,
    IN LPWSTR pwszFileName,
    IN LPWSTR pwszFilePath,
    OUT LPSTR pszNextContainer,
    IN OUT DWORD *pcbNextContainer)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    HANDLE              hMap = NULL;
    BYTE                *pbFile = NULL;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    DWORD               cbFile = 0;
    DWORD               *pdwVersion;
    PKEY_CONTAINER_LENS pContLens;
    DWORD               dwSts;

    // open the file
    dwSts = OpenFileInStorageArea(fMachineKeyset,
                                  GENERIC_READ,
                                  pwszFilePath,
                                  pwszFileName,
                                  &hFile);
    if (ERROR_SUCCESS != dwSts)
    {
        if (ERROR_FILE_NOT_FOUND == dwSts)
            dwReturn = (DWORD)NTE_BAD_KEYSET;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    cbFile = GetFileSize(hFile, NULL);
    if ((DWORD)(-1) == cbFile)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }
    if ((sizeof(DWORD) + sizeof(KEY_CONTAINER_LENS)) > cbFile)
    {
        dwReturn = (DWORD)NTE_KEYSET_ENTRY_BAD;
        goto ErrorExit;
    }

    hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY,
                             0, 0, NULL);
    if (NULL == hMap)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    pbFile = (BYTE*)MapViewOfFile(hMap, FILE_MAP_READ,
                                  0, 0, 0 );
    if (NULL == pbFile)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    // get the length information out of the file
    pdwVersion = (DWORD*)pbFile;
    if (KEY_CONTAINER_FILE_FORMAT_VER != *pdwVersion)
    {
        dwReturn = (DWORD)NTE_KEYSET_ENTRY_BAD;
        goto ErrorExit;
    }
    pContLens = (PKEY_CONTAINER_LENS)(pbFile + sizeof(DWORD));

    if (NULL == pszNextContainer)
    {
        *pcbNextContainer = MAX_PATH + 1;
        dwReturn = ERROR_SUCCESS;   // Just tell them the length.
        goto ErrorExit;
    }

    if (*pcbNextContainer < pContLens->cbName)
    {
        *pcbNextContainer = MAX_PATH + 1;
    }
    else if ((sizeof(DWORD) + sizeof(KEY_CONTAINER_LENS) +
             sizeof(KEY_EXPORTABILITY_LENS) + pContLens->cbName) > cbFile)
    {
        dwReturn = (DWORD)NTE_KEYSET_ENTRY_BAD;
        goto ErrorExit;
    }
    else
    {
        // get the container name
        memcpy(pszNextContainer,
            pbFile + sizeof(DWORD) + sizeof(KEY_CONTAINER_LENS) +
            sizeof(KEY_EXPORTABILITY_LENS), pContLens->cbName);
        // *pcbNextContainer = pContLens->cbName;
    }
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pbFile)
        UnmapViewOfFile(pbFile);
    if (NULL != hMap)
        CloseHandle(hMap);
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    return dwReturn;
}


DWORD
GetUniqueContainerName(
    IN KEY_CONTAINER_INFO *pContInfo,
    OUT BYTE *pbData,
    OUT DWORD *pcbData)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    LPSTR   pszUniqueContainer = NULL;
    DWORD   cch;

    cch = WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS,
                        pContInfo->rgwszFileName, -1,
                        NULL, 0, NULL, NULL);
    if (0 == cch)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    pszUniqueContainer = (LPSTR)ContInfoAlloc((cch + 1) * sizeof(WCHAR));
    if (NULL == pszUniqueContainer)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    cch = WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS,
                              pContInfo->rgwszFileName, -1,
                              pszUniqueContainer, cch,
                              NULL, NULL);
    if (0 == cch)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (pbData == NULL)
    {
        *pcbData = strlen(pszUniqueContainer) + 1;
    }
    else if (*pcbData < (strlen(pszUniqueContainer) + 1))
    {
        *pcbData = strlen(pszUniqueContainer) + 1;
        dwReturn = ERROR_MORE_DATA;
        goto ErrorExit;
    }
    else
    {
        *pcbData = strlen(pszUniqueContainer) + 1;
        strcpy((LPSTR)pbData, pszUniqueContainer);
    }
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pszUniqueContainer)
        ContInfoFree(pszUniqueContainer);
    return dwReturn;
}


//
// Function : MachineGuidInFilename
//
// Description : Check if the given Machine GUID is in the given filename.
//               Returns TRUE if it is FALSE if it is not.
//

/*static*/ BOOL
MachineGuidInFilename(
    LPWSTR pwszFileName,
    LPWSTR pwszMachineGuid)
{
    DWORD   cbFileName;
    BOOL    fRet = FALSE;

    cbFileName = wcslen(pwszFileName);

    // make sure the length of the filename is longer than the GUID
    if (cbFileName >= (DWORD)wcslen(pwszMachineGuid))
    {
        // compare the GUID with the last 36 characters of the file name
        if (0 == memcmp(pwszMachineGuid, &(pwszFileName[cbFileName - 36]),
            36 * sizeof(WCHAR)))
            fRet = TRUE;
    }
    return fRet;
}


DWORD
GetNextContainer(
    IN      DWORD   dwProvType,
    IN      BOOL    fMachineKeyset,
    IN      DWORD   dwFlags,
    OUT     LPSTR   pszNextContainer,
    IN OUT  DWORD   *pcbNextContainer,
    IN OUT  HANDLE  *phFind)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    LPWSTR              pwszFilePath = NULL;
    LPWSTR              pwszEnumFilePath = NULL;
    WIN32_FIND_DATAW    FindData;
    BOOL                fIsLocalSystem = FALSE;
    LPWSTR              pwszMachineGuid = NULL;
    DWORD               dwSts;

    memset(&FindData, 0, sizeof(FindData));

    // get the correct storage area (directory)
    dwSts = GetUserStorageArea(dwProvType, fMachineKeyset, FALSE,
                               &fIsLocalSystem, &pwszFilePath);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (dwFlags & CRYPT_FIRST)
    {
        *phFind = INVALID_HANDLE_VALUE;

        pwszEnumFilePath = (LPWSTR)ContInfoAlloc((wcslen(pwszFilePath) + 2) * sizeof(WCHAR));
        if (NULL == pwszEnumFilePath)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        wcscpy(pwszEnumFilePath, pwszFilePath);
        pwszEnumFilePath[wcslen(pwszFilePath)] = '*';

        *phFind = FindFirstFileExW(
                                  pwszEnumFilePath,
                                  FindExInfoStandard,
                                  &FindData,
                                  FindExSearchNameMatch,
                                  NULL,
                                  0);
        if (INVALID_HANDLE_VALUE == *phFind)
        {
            dwReturn = ERROR_NO_MORE_ITEMS;
            goto ErrorExit;
        }

        // skip past . and ..
        if (!FindNextFileW(*phFind, &FindData))
        {
            dwSts = GetLastError();
            if (ERROR_NO_MORE_FILES == dwSts)
                dwReturn = ERROR_NO_MORE_ITEMS;
            else
                dwReturn = dwSts;
            goto ErrorExit;
        }

        if (!FindNextFileW(*phFind, &FindData))
        {
            dwSts = GetLastError();
            if (ERROR_NO_MORE_FILES == dwSts)
                dwReturn = ERROR_NO_MORE_ITEMS;
            else
                dwReturn = dwSts;
            goto ErrorExit;
        }
    }
    else
    {
GetNextFile:
        {
            if (!FindNextFileW(*phFind, &FindData))
            {
                dwSts = GetLastError();
                if (ERROR_NO_MORE_FILES == dwSts)
                    dwReturn = ERROR_NO_MORE_ITEMS;
                else
                    dwReturn = dwSts;
                goto ErrorExit;
            }
        }
    }

    // if this is a machine keyset or this is local system then we want to
    // ignore key containers not matching the current machine GUID
    if (fMachineKeyset || fIsLocalSystem)
    {
        // get the GUID of the machine
        dwSts = GetMachineGUID(&pwszMachineGuid);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        if (NULL == pwszMachineGuid)
        {
            dwReturn = (DWORD)NTE_FAIL;
            goto ErrorExit;
        }

        // check if the file name has the machine GUID
        while (!MachineGuidInFilename(FindData.cFileName, pwszMachineGuid))
        {
            if (!FindNextFileW(*phFind, &FindData))
            {
                dwSts = GetLastError();
                if (ERROR_NO_MORE_FILES == dwSts)
                    dwReturn = ERROR_NO_MORE_ITEMS;
                else
                    dwReturn = dwSts;
                goto ErrorExit;
            }
        }
    }

    // return the container name, in order to do that we need to open the
    // file and pull out the container name
    //
    // we try to get the next file if failure occurs in case the file was
    // deleted since the FindNextFile
    //
    dwSts = ReadContainerNameFromFile(fMachineKeyset,
                                      FindData.cFileName,
                                      pwszFilePath,
                                      pszNextContainer,
                                      pcbNextContainer);
    if (ERROR_SUCCESS != dwSts)
        goto GetNextFile;
    else if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pwszMachineGuid)
        ContInfoFree(pwszMachineGuid);
    if (NULL != pwszFilePath)
        ContInfoFree(pwszFilePath);
    if (NULL != pwszEnumFilePath)
        ContInfoFree(pwszEnumFilePath);
    return dwReturn;
}


// Converts to UNICODE and uses RegOpenKeyExW
DWORD
MyRegOpenKeyEx(
    IN HKEY hRegKey,
    IN LPSTR pszKeyName,
    IN DWORD dwReserved,
    IN REGSAM SAMDesired,
    OUT HKEY *phNewRegKey)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    WCHAR   rgwchFastBuff[(MAX_PATH + 1) * 2];
    LPWSTR  pwsz = NULL;
    BOOL    fAlloced = FALSE;
    DWORD   cch;
    DWORD   dwSts;

    memset(rgwchFastBuff, 0, sizeof(rgwchFastBuff));

    // convert reg key name to unicode
    cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
                              pszKeyName, -1,
                              NULL, 0);
    if (0 == cch)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if ((cch + 1) > ((MAX_PATH + 1) * 2))
    {
        pwsz = ContInfoAlloc((cch + 1) * sizeof(WCHAR));
        if (NULL == pwsz)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }
        fAlloced = TRUE;
    }
    else
    {
        pwsz = rgwchFastBuff;
    }

    cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
                              pszKeyName, -1, pwsz, cch);
    if (0 == cch)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    dwSts = RegOpenKeyExW(hRegKey,
                          pwsz,
                          dwReserved,
                          SAMDesired,
                          phNewRegKey);
    if (ERROR_SUCCESS != dwSts)
    {
        if (ERROR_FILE_NOT_FOUND == dwSts)
            dwReturn = (DWORD)NTE_BAD_KEYSET;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (fAlloced && (NULL != pwsz))
        ContInfoFree(pwsz);
    return dwReturn;
}


// Converts to UNICODE and uses RegDeleteKeyW
DWORD
MyRegDeleteKey(
    IN HKEY hRegKey,
    IN LPSTR pszKeyName)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    WCHAR   rgwchFastBuff[(MAX_PATH + 1) * 2];
    LPWSTR  pwsz = NULL;
    BOOL    fAlloced = FALSE;
    DWORD   cch;
    DWORD   dwSts;

    memset(rgwchFastBuff, 0, sizeof(rgwchFastBuff));

    // convert reg key name to unicode
    cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
                              pszKeyName, -1,
                              NULL, 0);
    if (0 == cch)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if ((cch + 1) > ((MAX_PATH + 1) * 2))
    {
        pwsz = ContInfoAlloc((cch + 1) * sizeof(WCHAR));
        if (NULL == pwsz)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }
        fAlloced = TRUE;
    }
    else
    {
        pwsz = rgwchFastBuff;
    }

    cch = MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
                              pszKeyName, -1,
                              pwsz, cch);
    if (0 == cch)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    dwSts = RegDeleteKeyW(hRegKey, pwsz);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (fAlloced && (NULL != pwsz))
        ContInfoFree(pwsz);
    return dwReturn;
}


DWORD
AllocAndSetLocationBuff(
    BOOL fMachineKeySet,
    DWORD dwProvType,
    CONST char *pszUserID,
    HKEY *phTopRegKey,
    TCHAR **ppszLocBuff,
    BOOL fUserKeys,
    BOOL *pfLeaveOldKeys,
    LPDWORD pcbBuff)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD   dwSts;
    CHAR    szSID[MAX_PATH];
    DWORD   cbSID = MAX_PATH;
    DWORD   cbLocBuff = 0;
    DWORD   cbTmp = 0;
    CHAR    *pszTmp;
    BOOL    fIsThreadLocalSystem = FALSE;

    if (fMachineKeySet)
    {
        *phTopRegKey = HKEY_LOCAL_MACHINE;
        if ((PROV_RSA_FULL == dwProvType) ||
            (PROV_RSA_SCHANNEL == dwProvType) ||
            (PROV_RSA_AES == dwProvType))
        {
            cbTmp = RSA_MACH_REG_KEY_LOC_LEN;
            pszTmp = RSA_MACH_REG_KEY_LOC;
        }
        else if ((PROV_DSS == dwProvType) ||
                 (PROV_DSS_DH == dwProvType) ||
                 (PROV_DH_SCHANNEL == dwProvType))
        {
            cbTmp = DSS_MACH_REG_KEY_LOC_LEN;
            pszTmp = DSS_MACH_REG_KEY_LOC;
        }
        else
        {
            dwReturn = (DWORD)NTE_FAIL;
            goto ErrorExit;
        }
    }
    else
    {
        if ((PROV_RSA_FULL == dwProvType) ||
            (PROV_RSA_SCHANNEL == dwProvType) ||
            (PROV_RSA_AES == dwProvType))
        {
            cbTmp = RSA_REG_KEY_LOC_LEN;
            pszTmp = RSA_REG_KEY_LOC;
        }
        else if ((PROV_DSS == dwProvType) ||
                 (PROV_DSS_DH == dwProvType) ||
                 (PROV_DH_SCHANNEL == dwProvType))
        {
            cbTmp = DSS_REG_KEY_LOC_LEN;
            pszTmp = DSS_REG_KEY_LOC;
        }
        else
        {
            dwReturn = (DWORD)NTE_FAIL;
            goto ErrorExit;
        }

        if (FIsWinNT())
        {
            dwSts = IsThreadLocalSystem(&fIsThreadLocalSystem);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            dwSts = GetUserTextualSidA(szSID, &cbSID);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;    // NTE_BAD_KEYSET
                goto ErrorExit;
            }

            // this checks to see if the key to the current user may be opened
            if (!fMachineKeySet)
            {
                dwSts = RegOpenKeyEx(HKEY_USERS,
                                     szSID,
                                     0,      // dwOptions
                                     KEY_READ,
                                     phTopRegKey);
                if (ERROR_SUCCESS != dwSts)
                {
                    //
                    // if that failed, try HKEY_USERS\.Default (for services on NT).
                    //
                    cbSID = strlen(".DEFAULT") + 1;
                    strcpy(szSID, ".DEFAULT");
                    dwSts = RegOpenKeyEx(HKEY_USERS,
                                         szSID,
                                         0,        // dwOptions
                                         KEY_READ,
                                         phTopRegKey);
                    if (ERROR_SUCCESS != dwSts)
                    {
                        dwReturn = dwSts;
                        goto ErrorExit;
                    }
                    *pfLeaveOldKeys = TRUE;
                }
            }
        }
        else
        {
            *phTopRegKey = HKEY_CURRENT_USER;
        }
    }

    if (!fUserKeys)
        cbLocBuff = strlen(pszUserID);
    cbLocBuff = cbLocBuff + cbTmp + 2;

    *ppszLocBuff = (CHAR*)ContInfoAlloc(cbLocBuff);
    if (NULL == *ppszLocBuff)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    // Copy the location of the key groups, append the userID to it
    memcpy(*ppszLocBuff, pszTmp, cbTmp);
    if (!fUserKeys)
    {
        (*ppszLocBuff)[cbTmp-1] = '\\';
        strcpy(&(*ppszLocBuff)[cbTmp], pszUserID);
    }

    if (NULL != pcbBuff)
        *pcbBuff = cbLocBuff;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


//
// Enumerates the old machine keys in the file system
// keys were in this location in Beta 2 and Beta 3 of NT5/Win2K
//
DWORD
EnumOldMachineKeys(
    IN DWORD dwProvType,
    IN OUT PKEY_CONTAINER_INFO pContInfo)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    HANDLE              hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    FindData;
    LPWSTR              pwszUserStorageArea = NULL;
    LPWSTR              pwszTmp = NULL;
    BOOL                fIsLocalSystem;
    DWORD               i;
    LPSTR               pszNextContainer;
    DWORD               cbNextContainer;
    LPSTR               pszTmpContainer;
    DWORD               dwSts;

    // first check if the enumeration table is already set up
    if (NULL != pContInfo->pchEnumOldMachKeyEntries)
    {
        dwReturn = ERROR_SUCCESS;   // Nothing to do!
        goto ErrorExit;
    }

    memset(&FindData, 0, sizeof(FindData));

    dwSts = GetUserStorageArea(dwProvType, TRUE, TRUE,
                               &fIsLocalSystem, &pwszUserStorageArea);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = ERROR_NO_MORE_ITEMS;
        goto ErrorExit;
    }

    // last character is backslash, so strip that off
    pwszTmp = (LPWSTR)ContInfoAlloc((wcslen(pwszUserStorageArea) + 3) * sizeof(WCHAR));
    if (NULL == pwszTmp)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    wcscpy(pwszTmp, pwszUserStorageArea);
    wcscat(pwszTmp, L"*");

    // figure out how many files are in the directroy

    hFind = FindFirstFileExW(pwszTmp,
                             FindExInfoStandard,
                             &FindData,
                             FindExSearchNameMatch,
                             NULL,
                             0);
    if (INVALID_HANDLE_VALUE == hFind)
    {
        dwSts = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwSts)
            dwReturn = ERROR_NO_MORE_ITEMS;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    // skip past . and ..
    if (!FindNextFileW(hFind, &FindData))
    {
        dwSts = GetLastError();
        if (ERROR_NO_MORE_FILES == dwSts)
            dwReturn = ERROR_NO_MORE_ITEMS;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }
    if (!FindNextFileW(hFind, &FindData))
    {
        dwSts = GetLastError();
        if (ERROR_NO_MORE_FILES == dwSts)
            dwReturn = ERROR_NO_MORE_ITEMS;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    for (i = 1; ; i++)
    {
        memset(&FindData, 0, sizeof(FindData));
        if (!FindNextFileW(hFind, &FindData))
        {
            dwSts = GetLastError();
            if (ERROR_NO_MORE_FILES == dwSts)
                break;
            else if (ERROR_ACCESS_DENIED != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }
    }

    FindClose(hFind);
    hFind = INVALID_HANDLE_VALUE;

    pContInfo->cbOldMachKeyEntry = MAX_PATH + 1;
    pContInfo->dwiOldMachKeyEntry = 0;
    pContInfo->cMaxOldMachKeyEntry = i;

    // allocate space for the file names
    pContInfo->pchEnumOldMachKeyEntries = ContInfoAlloc(i * (MAX_PATH + 1));
    if (NULL == pContInfo->pchEnumOldMachKeyEntries)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    // enumerate through getting file name from each
    memset(&FindData, 0, sizeof(FindData));
    hFind = FindFirstFileExW(pwszTmp,
                             FindExInfoStandard,
                             &FindData,
                             FindExSearchNameMatch,
                             NULL,
                             0);
    if (INVALID_HANDLE_VALUE == hFind)
    {
        dwSts = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwSts)
            dwReturn = ERROR_NO_MORE_ITEMS;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    // skip past . and ..
    if (!FindNextFileW(hFind, &FindData))
    {
        dwSts = GetLastError();
        if (ERROR_NO_MORE_FILES == dwSts)
            dwReturn = ERROR_NO_MORE_ITEMS;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }
    memset(&FindData, 0, sizeof(FindData));
    if (!FindNextFileW(hFind, &FindData))
    {
        dwSts = GetLastError();
        if (ERROR_NO_MORE_FILES == dwSts)
            dwReturn = ERROR_NO_MORE_ITEMS;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    pszNextContainer = pContInfo->pchEnumOldMachKeyEntries;

    for (i = 0; i < pContInfo->cMaxOldMachKeyEntry; i++)
    {
        cbNextContainer = MAX_PATH;

        // return the container name, in order to do that we need to open the
        // file and pull out the container name
        dwSts = ReadContainerNameFromFile(TRUE,
                                          FindData.cFileName,
                                          pwszUserStorageArea,
                                          pszNextContainer,
                                          &cbNextContainer);
        if (ERROR_SUCCESS != dwSts)
        {
            pszTmpContainer = pszNextContainer;
        }
        else
        {
            pszTmpContainer = pszNextContainer + MAX_PATH + 1;
        }

        memset(&FindData, 0, sizeof(FindData));
        if (!FindNextFileW(hFind, &FindData))
        {
            dwSts = GetLastError();
            if (ERROR_NO_MORE_FILES == dwSts)
                break;
            else if (ERROR_ACCESS_DENIED != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }
        pszNextContainer = pszTmpContainer;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pwszTmp)
        ContInfoFree(pwszTmp);
    if (NULL != pwszUserStorageArea)
        ContInfoFree(pwszUserStorageArea);
    if (INVALID_HANDLE_VALUE != hFind)
        FindClose(hFind);
    return dwReturn;
}


DWORD
GetNextEnumedOldMachKeys(
    IN PKEY_CONTAINER_INFO pContInfo,
    IN BOOL fMachineKeyset,
    OUT BYTE *pbData,
    OUT DWORD *pcbData)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    CHAR    *psz;

    if (!fMachineKeyset)
    {
        dwReturn = ERROR_SUCCESS;   // Nothing to do!
        goto ErrorExit;
    }

    if ((NULL == pContInfo->pchEnumOldMachKeyEntries) ||
        (pContInfo->dwiOldMachKeyEntry >= pContInfo->cMaxOldMachKeyEntry))
    {
        dwReturn = ERROR_NO_MORE_ITEMS;
        goto ErrorExit;
    }

    if (NULL == pbData)
        *pcbData = pContInfo->cbRegEntry;
    else if (*pcbData < pContInfo->cbRegEntry)
    {
        *pcbData = pContInfo->cbRegEntry;
        dwReturn = ERROR_MORE_DATA;
        goto ErrorExit;
    }
    else
    {
        psz = pContInfo->pchEnumOldMachKeyEntries + (pContInfo->dwiOldMachKeyEntry *
            pContInfo->cbOldMachKeyEntry);
        memcpy(pbData, psz, strlen(psz) + 1);
        pContInfo->dwiOldMachKeyEntry++;
    }
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (fMachineKeyset)
        *pcbData = pContInfo->cbOldMachKeyEntry;
    return dwReturn;
}


//
// Enumerates the keys in the registry into a list of entries
//
DWORD
EnumRegKeys(
    IN OUT PKEY_CONTAINER_INFO pContInfo,
    IN BOOL fMachineKeySet,
    IN DWORD dwProvType,
    OUT BYTE *pbData,
    IN OUT DWORD *pcbData)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    HKEY        hTopRegKey = 0;
    LPSTR       pszBuff = NULL;
    DWORD       cbBuff;
    BOOL        fLeaveOldKeys = FALSE;
    HKEY        hKey = 0;
    DWORD       cSubKeys;
    DWORD       cchMaxSubkey;
    DWORD       cchMaxClass;
    DWORD       cValues;
    DWORD       cchMaxValueName;
    DWORD       cbMaxValueData;
    DWORD       cbSecurityDesriptor;
    FILETIME    ftLastWriteTime;
    CHAR        *psz;
    DWORD       i;
    DWORD       dwSts;

    // first check if the enumeration table is already set up
    if (NULL != pContInfo->pchEnumRegEntries)
    {
        dwReturn = ERROR_SUCCESS;   // Nothing to do!
        goto ErrorExit;
    }

    // get the path to the registry keys
    dwSts = AllocAndSetLocationBuff(fMachineKeySet,
                                    dwProvType,
                                    pContInfo->pszUserName,
                                    &hTopRegKey,
                                    &pszBuff,
                                    TRUE,
                                    &fLeaveOldKeys,
                                    &cbBuff);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // open the reg key
    dwSts = MyRegOpenKeyEx(hTopRegKey,
                           pszBuff,
                           0,
                           KEY_READ,
                           &hKey);
    if (ERROR_SUCCESS != dwSts)
    {
        if (NTE_BAD_KEYSET == dwSts)
            dwReturn = ERROR_NO_MORE_ITEMS;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    // find out info on old key containers
    dwSts = RegQueryInfoKey(hKey,
                            NULL,
                            NULL,
                            NULL,
                            &cSubKeys,
                            &cchMaxSubkey,
                            &cchMaxClass,
                            &cValues,
                            &cchMaxValueName,
                            &cbMaxValueData,
                            &cbSecurityDesriptor,
                            &ftLastWriteTime);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // if there are old keys then enumerate them into a table
    if (0 != cSubKeys)
    {
        pContInfo->cMaxRegEntry = cSubKeys;
        pContInfo->cbRegEntry = cchMaxSubkey + 1;

        pContInfo->pchEnumRegEntries =
            ContInfoAlloc(pContInfo->cMaxRegEntry
                          * pContInfo->cbRegEntry
                          * sizeof(CHAR));
        if (NULL == pContInfo->pchEnumRegEntries)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        for (i = 0; i < pContInfo->cMaxRegEntry; i++)
        {
            psz = pContInfo->pchEnumRegEntries + (i * pContInfo->cbRegEntry);
            dwSts = RegEnumKey(hKey,
                               i,
                               psz,
                               pContInfo->cbRegEntry);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }

        if (NULL == pbData)
            *pcbData = pContInfo->cbRegEntry;
        else if (*pcbData < pContInfo->cbRegEntry)
        {
            *pcbData = pContInfo->cbRegEntry;
            dwReturn = ERROR_MORE_DATA;
            goto ErrorExit;
        }
        else
        {
            *pcbData = pContInfo->cbRegEntry;
            // ?BUGBUG? What?
            // CopyMemory(pbData, pContInfo->pbRegEntry, pContInfo->cbRegEntry);
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if ((NULL != hTopRegKey)
        && (HKEY_CURRENT_USER != hTopRegKey)
        && (HKEY_LOCAL_MACHINE != hTopRegKey))
    {
        RegCloseKey(hTopRegKey);
    }
    if (NULL != pszBuff)
        ContInfoFree(pszBuff);
    if (NULL != hKey)
        RegCloseKey(hKey);
    return dwReturn;
}


DWORD
GetNextEnumedRegKeys(
    IN PKEY_CONTAINER_INFO pContInfo,
    OUT BYTE *pbData,
    OUT DWORD *pcbData)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    CHAR    *psz;

    if ((NULL == pContInfo->pchEnumRegEntries) ||
        (pContInfo->dwiRegEntry >= pContInfo->cMaxRegEntry))
    {
        dwReturn = ERROR_NO_MORE_ITEMS;
        goto ErrorExit;
    }

    if (NULL == pbData)
        *pcbData = pContInfo->cbRegEntry;
    else if (*pcbData < pContInfo->cbRegEntry)
    {
        *pcbData = pContInfo->cbRegEntry;
        dwReturn = ERROR_MORE_DATA;
        goto ErrorExit;
    }
    else
    {
        psz = pContInfo->pchEnumRegEntries + (pContInfo->dwiRegEntry *
            pContInfo->cbRegEntry);
        memcpy(pbData, psz, pContInfo->cbRegEntry);
        pContInfo->dwiRegEntry++;
    }
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


//+ ===========================================================================
//
//      The function adjusts the token priviledges so that SACL information
//      may be gotten and then opens the indicated registry key.  If the token
//      priviledges may be set then the reg key is opened anyway but the
//      flags field will not have the PRIVILEDGE_FOR_SACL value set.
//
//- ============================================================================

DWORD
OpenRegKeyWithTokenPriviledges(
    IN HKEY hTopRegKey,
    IN LPSTR pszRegKey,
    OUT HKEY *phRegKey,
    OUT DWORD *pdwFlags)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    TOKEN_PRIVILEGES    tp;
    TOKEN_PRIVILEGES    tpPrevious;
    DWORD               cbPrevious = sizeof(TOKEN_PRIVILEGES);
    LUID                luid;
    HANDLE              hToken = 0;
    HKEY                hRegKey = 0;
    BOOL                fSts;
    BOOL                fImpersonating = FALSE;
    BOOL                fAdjusted = FALSE;
    DWORD               dwAccessFlags = 0;
    DWORD               dwSts;

    // check if there is a registry key to open
    dwSts = MyRegOpenKeyEx(hTopRegKey, pszRegKey, 0,
                           KEY_ALL_ACCESS, &hRegKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    RegCloseKey(hRegKey);
    hRegKey = 0;

    // check if there is a thread token
    fSts = OpenThreadToken(GetCurrentThread(),
                           MAXIMUM_ALLOWED, TRUE,
                           &hToken);
    if (!fSts)
    {
        if (!ImpersonateSelf(SecurityImpersonation))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        fImpersonating = TRUE;
        // get the process token
        fSts = OpenThreadToken(GetCurrentThread(),
                               MAXIMUM_ALLOWED,
                               TRUE,
                               &hToken);
    }

    // set up the new priviledge state
    if (fSts)
    {
        memset(&tp, 0, sizeof(tp));
        memset(&tpPrevious, 0, sizeof(tpPrevious));

        fSts = LookupPrivilegeValueA(NULL, SE_SECURITY_NAME, &luid);
        if (fSts)
        {
            //
            // first pass.  get current privilege setting
            //
            tp.PrivilegeCount           = 1;
            tp.Privileges[0].Luid       = luid;
            tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            // adjust privilege
            fSts = AdjustTokenPrivileges(hToken,
                                         FALSE,
                                         &tp,
                                         sizeof(TOKEN_PRIVILEGES),
                                         &tpPrevious,
                                         &cbPrevious);
            if (fSts && (ERROR_SUCCESS == GetLastError()))
            {
                fAdjusted = TRUE;
                *pdwFlags |= PRIVILEDGE_FOR_SACL;
                dwAccessFlags = ACCESS_SYSTEM_SECURITY;
            }
        }
    }

    // open the registry key
    dwSts = MyRegOpenKeyEx(hTopRegKey,
                           pszRegKey,
                           0,
                           KEY_ALL_ACCESS | dwAccessFlags,
                           phRegKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    // now set the privilege back if necessary
    if (fAdjusted)
    {
        // adjust the priviledge and with the previous state
        fSts = AdjustTokenPrivileges(hToken,
                                     FALSE,
                                     &tpPrevious,
                                     sizeof(TOKEN_PRIVILEGES),
                                     NULL,
                                     NULL);
    }
    if (NULL != hToken)
        CloseHandle(hToken);
    if (fImpersonating)
        RevertToSelf();
    return dwReturn;
}


//+ ===========================================================================
//
//      The function adjusts the token priviledges so that SACL information
//      may be set on a key container.  If the token priviledges may be set
//      indicated by the pUser->dwOldKeyFlags having the PRIVILEDGE_FOR_SACL value set.
//      value set then the token privilege is adjusted before the security
//      descriptor is set on the container.  This is needed for the key
//      migration case when keys are being migrated from the registry to files.
//- ============================================================================

DWORD
SetSecurityOnContainerWithTokenPriviledges(
    IN DWORD dwOldKeyFlags,
    IN LPCWSTR wszFileName,
    IN DWORD dwProvType,
    IN DWORD fMachineKeyset,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    TOKEN_PRIVILEGES    tp;
    TOKEN_PRIVILEGES    tpPrevious;
    DWORD               cbPrevious = sizeof(TOKEN_PRIVILEGES);
    LUID                luid;
    HANDLE              hToken = 0;
    BOOL                fStatus;
    BOOL                fImpersonating = FALSE;
    BOOL                fAdjusted = FALSE;
    DWORD               dwSts;

    if (dwOldKeyFlags & PRIVILEDGE_FOR_SACL)
    {
        // check if there is a thread token
        fStatus = OpenThreadToken(GetCurrentThread(),
                                  MAXIMUM_ALLOWED, TRUE,
                                  &hToken);
        if (!fStatus)
        {
            if (!ImpersonateSelf(SecurityImpersonation))
            {
                dwReturn = GetLastError();
                goto ErrorExit;
            }

            fImpersonating = TRUE;
            // get the process token
            fStatus = OpenThreadToken(GetCurrentThread(),
                                      MAXIMUM_ALLOWED,
                                      TRUE,
                                      &hToken);
        }

        // set up the new priviledge state
        if (fStatus)
        {
            memset(&tp, 0, sizeof(tp));
            memset(&tpPrevious, 0, sizeof(tpPrevious));

            fStatus = LookupPrivilegeValueA(NULL,
                                            SE_SECURITY_NAME,
                                            &luid);
            if (fStatus)
            {
                //
                // first pass.  get current privilege setting
                //
                tp.PrivilegeCount           = 1;
                tp.Privileges[0].Luid       = luid;
                tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                // adjust privilege
                fAdjusted = AdjustTokenPrivileges(hToken,
                                                  FALSE,
                                                  &tp,
                                                  sizeof(TOKEN_PRIVILEGES),
                                                  &tpPrevious,
                                                  &cbPrevious);
            }
        }
    }

    dwSts = SetSecurityOnContainer(wszFileName,
                                   dwProvType,
                                   fMachineKeyset,
                                   SecurityInformation,
                                   pSecurityDescriptor);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    // now set the privilege back if necessary
    // now set the privilege back if necessary
    if (dwOldKeyFlags & PRIVILEDGE_FOR_SACL)
    {
        if (fAdjusted)
        {
            // adjust the priviledge and with the previous state
            fStatus = AdjustTokenPrivileges(hToken,
                                            FALSE,
                                            &tpPrevious,
                                            sizeof(TOKEN_PRIVILEGES),
                                            NULL,
                                            NULL);
        }
    }
    if (NULL != hToken)
        CloseHandle(hToken);
    if (fImpersonating)
        RevertToSelf();
    return dwReturn;
}


// Loops through the ACEs of an ACL and checks for special access bits
// for registry keys and converts the access mask so generic access
// bits are used

/*static*/ DWORD
CheckAndChangeAccessMasks(
    IN PACL pAcl)
{
    DWORD                   dwReturn = ERROR_INTERNAL_ERROR;
    ACL_SIZE_INFORMATION    AclSizeInfo;
    DWORD                   i;
    ACCESS_ALLOWED_ACE      *pAce;
    ACCESS_MASK             NewMask;

    memset(&AclSizeInfo, 0, sizeof(AclSizeInfo));

    // get the number of ACEs in the ACL
    if (!GetAclInformation(pAcl, &AclSizeInfo, sizeof(AclSizeInfo),
                           AclSizeInformation))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    // loop through the ACEs checking and changing the access bits
    for (i = 0; i < AclSizeInfo.AceCount; i++)
    {
        if (!GetAce(pAcl, i, &pAce))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        NewMask = 0;

        // check if the specific access bits are set, if so convert to generic
        if ((pAce->Mask & KEY_QUERY_VALUE) || (pAce->Mask & GENERIC_READ))
            NewMask |= GENERIC_READ;

        if ((pAce->Mask & KEY_SET_VALUE) || (pAce->Mask & GENERIC_ALL) ||
            (pAce->Mask & GENERIC_WRITE))
        {
            NewMask |= GENERIC_ALL;
        }

        pAce->Mask = NewMask;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


// Converts a security descriptor from special access to generic access

/*static*/ DWORD
ConvertContainerSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR *ppNewSD,
    OUT DWORD *pcbNewSD)
{
    DWORD                       dwReturn = ERROR_INTERNAL_ERROR;
    DWORD                       cbSD;
    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD                       dwRevision;
    PACL                        pDacl;
    BOOL                        fDACLPresent;
    BOOL                        fDaclDefaulted;
    PACL                        pSacl;
    BOOL                        fSACLPresent;
    BOOL                        fSaclDefaulted;
    DWORD                       dwSts;

    // ge the control on the security descriptor to check if self relative
    if (!GetSecurityDescriptorControl(pSecurityDescriptor,
                                      &Control, &dwRevision))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    // get the length of the security descriptor and alloc space for a copy
    cbSD = GetSecurityDescriptorLength(pSecurityDescriptor);
    *ppNewSD =(PSECURITY_DESCRIPTOR)ContInfoAlloc(cbSD);
    if (NULL == *ppNewSD)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    if (SE_SELF_RELATIVE & Control)
    {
        // if the Security Descriptor is self relative then make a copy
        memcpy(*ppNewSD, pSecurityDescriptor, cbSD);
    }
    else
    {
        // if not self relative then make a self relative copy
        if (!MakeSelfRelativeSD(pSecurityDescriptor, *ppNewSD, &cbSD))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }
    }

    // get the DACL out of the security descriptor
    if (!GetSecurityDescriptorDacl(*ppNewSD, &fDACLPresent, &pDacl,
                                   &fDaclDefaulted))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (fDACLPresent && pDacl)
    {
        dwSts = CheckAndChangeAccessMasks(pDacl);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    // get the SACL out of the security descriptor
    if (!GetSecurityDescriptorSacl(*ppNewSD, &fSACLPresent, &pSacl,
                                   &fSaclDefaulted))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (fSACLPresent && pSacl)
    {
        dwSts = CheckAndChangeAccessMasks(pSacl);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    *pcbNewSD = cbSD;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


DWORD
SetSecurityOnContainer(
    IN LPCWSTR wszFileName,
    IN DWORD dwProvType,
    IN DWORD fMachineKeyset,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    DWORD                   dwReturn = ERROR_INTERNAL_ERROR;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    DWORD                   cbSD;
    LPWSTR                  wszFilePath = NULL;
    LPWSTR                  wszUserStorageArea = NULL;
    DWORD                   cbUserStorageArea;
    DWORD                   cbFileName;
    BOOL                    fIsLocalSystem = FALSE;
    DWORD                   dwSts;

    dwSts = ConvertContainerSecurityDescriptor(pSecurityDescriptor,
                                               &pSD, &cbSD);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // get the correct storage area (directory)
    dwSts = GetUserStorageArea(dwProvType, fMachineKeyset, FALSE,
                               &fIsLocalSystem, &wszUserStorageArea);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    cbUserStorageArea = wcslen( wszUserStorageArea ) * sizeof(WCHAR);
    cbFileName = wcslen( wszFileName ) * sizeof(WCHAR);

    wszFilePath = (LPWSTR)ContInfoAlloc(cbUserStorageArea
                                        + cbFileName
                                        + sizeof(WCHAR));
    if (wszFilePath == NULL)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    CopyMemory((BYTE*)wszFilePath, (BYTE*)wszUserStorageArea, cbUserStorageArea);
    CopyMemory((LPBYTE)wszFilePath+cbUserStorageArea, wszFileName, cbFileName + sizeof(WCHAR));

    if (!SetFileSecurityW(wszFilePath, SecurityInformation, pSD))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pSD)
        ContInfoFree(pSD);
    if (NULL != wszUserStorageArea)
        ContInfoFree(wszUserStorageArea);
    if (NULL != wszFilePath)
        ContInfoFree(wszFilePath);
    return dwReturn;
}


DWORD
GetSecurityOnContainer(
    IN LPCWSTR wszFileName,
    IN DWORD dwProvType,
    IN DWORD fMachineKeyset,
    IN SECURITY_INFORMATION RequestedInformation,
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN OUT DWORD *pcbSecurityDescriptor)
{
    DWORD                   dwReturn = ERROR_INTERNAL_ERROR;
    LPWSTR                  wszFilePath = NULL;
    LPWSTR                  wszUserStorageArea = NULL;
    DWORD                   cbUserStorageArea;
    DWORD                   cbFileName;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    DWORD                   cbSD;
    PSECURITY_DESCRIPTOR    pNewSD = NULL;
    DWORD                   cbNewSD;
    BOOL                    fIsLocalSystem = FALSE;
    DWORD                   dwSts;

    // get the correct storage area (directory)
    dwSts = GetUserStorageArea(dwProvType, fMachineKeyset, FALSE,
                               &fIsLocalSystem, &wszUserStorageArea);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    cbUserStorageArea = wcslen( wszUserStorageArea ) * sizeof(WCHAR);
    cbFileName = wcslen( wszFileName ) * sizeof(WCHAR);

    wszFilePath = (LPWSTR)ContInfoAlloc(cbUserStorageArea
                                        + cbFileName
                                        + sizeof(WCHAR));
    if (wszFilePath == NULL)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    CopyMemory(wszFilePath, wszUserStorageArea, cbUserStorageArea);
    CopyMemory((LPBYTE)wszFilePath+cbUserStorageArea, wszFileName, cbFileName + sizeof(WCHAR));

    // get the security descriptor on the file
    cbSD = sizeof(cbSD);
    pSD = &cbSD;
    if (!GetFileSecurityW(wszFilePath, RequestedInformation, pSD,
                          cbSD, &cbSD))
    {
        dwSts = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER != dwSts)
        {
            dwReturn = dwSts;
            pSD = NULL;
            goto ErrorExit;
        }
    }

    pSD = (PSECURITY_DESCRIPTOR)ContInfoAlloc(cbSD);
    if (NULL == pSD)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    if (!GetFileSecurityW(wszFilePath, RequestedInformation, pSD,
                          cbSD, &cbSD))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    // convert the security descriptor from specific to generic
    dwSts = ConvertContainerSecurityDescriptor(pSD, &pNewSD, &cbNewSD);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (NULL == pSecurityDescriptor)
        *pcbSecurityDescriptor = cbNewSD;
    else if (*pcbSecurityDescriptor < cbNewSD)
    {
        *pcbSecurityDescriptor = cbNewSD;
        dwReturn = ERROR_MORE_DATA;
        goto ErrorExit;
    }
    else
    {
        *pcbSecurityDescriptor = cbNewSD;
        memcpy(pSecurityDescriptor, pNewSD, *pcbSecurityDescriptor);
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pNewSD)
        ContInfoFree(pNewSD);
    if (NULL != pSD)
        ContInfoFree(pSD);
    if (NULL != wszUserStorageArea)
        ContInfoFree(wszUserStorageArea);
    if (NULL != wszFilePath)
        ContInfoFree(wszFilePath);
    return dwReturn;
}


//
// Function : FreeOffloadInfo
//
// Description : The function takes a pointer to Offload Information as the
//               first parameter of the call.  The function frees the
//               information.
//

void
FreeOffloadInfo(
    IN OUT PEXPO_OFFLOAD_STRUCT pOffloadInfo)
{
    if (NULL != pOffloadInfo)
    {
        if (NULL != pOffloadInfo->hInst)
            FreeLibrary(pOffloadInfo->hInst);
        ContInfoFree(pOffloadInfo);
    }
}


//
// Function : InitExpOffloadInfo
//
// Description : The function takes a pointer to Offload Information as the
//               first parameter of the call.  The function checks in the
//               registry to see if an offload module has been registered.
//               If a module is registered then it loads the module
//               and gets the OffloadModExpo function pointer.
//

BOOL
InitExpOffloadInfo(
    IN OUT PEXPO_OFFLOAD_STRUCT *ppOffloadInfo)
{
    BYTE                    rgbModule[MAX_PATH + 1];
    BYTE                    *pbModule = NULL;
    DWORD                   cbModule;
    BOOL                    fAlloc = FALSE;
    PEXPO_OFFLOAD_STRUCT    pTmpOffloadInfo = NULL;
    HKEY                    hOffloadRegKey = 0;
    DWORD                   dwSts;
    BOOL                    fRet = FALSE;

    // wrap with try/except
    __try
    {
        // check for registration of an offload module
        dwSts = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             "Software\\Microsoft\\Cryptography\\Offload",
                             0,        // dwOptions
                             KEY_READ,
                             &hOffloadRegKey);
        if (ERROR_SUCCESS != dwSts)
            goto ErrorExit;

        // get the name of the offload module
        cbModule = sizeof(rgbModule);
        dwSts = RegQueryValueEx(hOffloadRegKey,
                                EXPO_OFFLOAD_REG_VALUE,
                                0, NULL, rgbModule,
                                &cbModule);
        if (ERROR_SUCCESS != dwSts)
        {
            if (ERROR_MORE_DATA == dwSts)
            {
                pbModule = (BYTE*)ContInfoAlloc(cbModule);
                if (NULL == pbModule)
                    goto ErrorExit;

                fAlloc = TRUE;
                dwSts = RegQueryValueEx(HKEY_LOCAL_MACHINE,
                                        EXPO_OFFLOAD_REG_VALUE,
                                        0, NULL, pbModule,
                                        &cbModule);
                if (ERROR_SUCCESS != dwSts)
                    goto ErrorExit;
            }
            else
                goto ErrorExit;
        }
        else
            pbModule = rgbModule;

        // alloc space for the offload info
        pTmpOffloadInfo = (PEXPO_OFFLOAD_STRUCT)ContInfoAlloc(sizeof(EXPO_OFFLOAD_STRUCT));
        if (NULL == pTmpOffloadInfo)
            goto ErrorExit;

        pTmpOffloadInfo->dwVersion = sizeof(EXPO_OFFLOAD_STRUCT);

        // load the module and get the function pointer
        pTmpOffloadInfo->hInst = LoadLibraryEx((LPTSTR)pbModule, NULL, 0);
        if (NULL == pTmpOffloadInfo->hInst)
            goto ErrorExit;

        pTmpOffloadInfo->pExpoFunc = GetProcAddress(pTmpOffloadInfo->hInst,
                                                    EXPO_OFFLOAD_FUNC_NAME);
        if (NULL == pTmpOffloadInfo->pExpoFunc)
            goto ErrorExit;

        *ppOffloadInfo = pTmpOffloadInfo;
        fRet = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        goto ErrorExit;
    }

ErrorExit:
    if (NULL != hOffloadRegKey)
        RegCloseKey(hOffloadRegKey);
    if (fAlloc && (NULL != pbModule))
        ContInfoFree(pbModule);
    if (!fRet)
        FreeOffloadInfo(pTmpOffloadInfo);
    return fRet;
}


//
// Function : ModularExpOffload
//
// Description : This function does the offloading of modular exponentiation.
//               The function takes a pointer to Offload Information as the
//               first parameter of the call.  If this pointer is not NULL
//               then the function will use this module and call the function.
//               The exponentiation with MOD function will implement
//               Y^X MOD P  where Y is the buffer pbBase, X is the buffer
//               pbExpo and P is the buffer pbModulus.  The length of the
//               buffer pbExpo is cbExpo and the length of pbBase and
//               pbModulus is cbModulus.  The resulting value is output
//               in the pbResult buffer and has length cbModulus.
//               The pReserved and dwFlags parameters are currently ignored.
//               If any of these functions fail then the function fails and
//               returns FALSE.  If successful then the function returns
//               TRUE.  If the function fails then most likely the caller
//               should fall back to using hard linked modular exponentiation.
//

BOOL
ModularExpOffload(
    IN PEXPO_OFFLOAD_STRUCT pOffloadInfo,
    IN BYTE *pbBase,
    IN BYTE *pbExpo,
    IN DWORD cbExpo,
    IN BYTE *pbModulus,
    IN DWORD cbModulus,
    OUT BYTE *pbResult,
    IN VOID *pReserved,
    IN DWORD dwFlags)
{
    BOOL    fRet = FALSE;

    // wrap with try/except
    __try
    {
        if (NULL == pOffloadInfo)
            goto ErrorExit;

        // call the offload module
        if (!pOffloadInfo->pExpoFunc(pbBase, pbExpo, cbExpo, pbModulus,
                                     cbModulus, pbResult, pReserved, dwFlags))
        {
            goto ErrorExit;
        }

        fRet = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        goto ErrorExit;
    }

ErrorExit:
    return fRet;
}


//
// The following section of code is for the loading and unloading of
// unicode string resources from a resource DLL (csprc.dll).  This
// allows the resources to be localize even though the CSPs
// themselves are signed.
//

#define MAX_STRING_RSC_SIZE 512

#define GLOBAL_STRING_BUFFERSIZE_INC 1000
#define GLOBAL_STRING_BUFFERSIZE 20000


//
// Function : FetchString
//
// Description : This function gets the specified string resource from
//               the resource DLL, allocates memory for it and copies
//               the string into that memory.
//

/*static*/ DWORD
FetchString(
    HMODULE hModule,                // module to get string from
    DWORD dwResourceId,             // resource identifier
    LPWSTR *ppString,               // target buffer for string
    BYTE **ppStringBlock,           // string buffer block
    DWORD *pdwBufferSize,           // size of string buffer block
    DWORD *pdwRemainingBufferSize)  // remaining size of string buffer block
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    WCHAR   szMessage[MAX_STRING_RSC_SIZE];
    DWORD   cchMessage;
    DWORD   dwOldSize;
    DWORD   dwNewSize;
    LPWSTR  pNewStr;

    if (ppStringBlock == NULL || *ppStringBlock == NULL || ppString == NULL)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    cchMessage = LoadStringW(hModule, dwResourceId, szMessage,
                             MAX_STRING_RSC_SIZE);
    if (0 == cchMessage)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (*pdwRemainingBufferSize < ((cchMessage + 1) * sizeof(WCHAR)))
    {

        //
        // realloc buffer and update size
        //

        dwOldSize = *pdwBufferSize;
        dwNewSize = dwOldSize + max(GLOBAL_STRING_BUFFERSIZE_INC,
                                    (((cchMessage + 1) * sizeof(WCHAR)) - *pdwRemainingBufferSize));

        *ppStringBlock = (BYTE*)ContInfoReAlloc(*ppStringBlock, dwNewSize);
        if (NULL == *ppStringBlock)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        *pdwBufferSize = dwNewSize;
        *pdwRemainingBufferSize += dwNewSize - dwOldSize;
    }

    pNewStr = (LPWSTR)(*ppStringBlock + *pdwBufferSize -
                       *pdwRemainingBufferSize);

    // only store the offset just in case a realloc of the entire
    // string buffer needs to be performed at a later time.
    *ppString = (LPWSTR)((BYTE *)pNewStr - (BYTE *)*ppStringBlock);

    wcscpy(pNewStr, szMessage);
    *pdwRemainingBufferSize -= (cchMessage + 1) * sizeof(WCHAR);

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


DWORD
LoadStrings(
    void)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    HMODULE hMod = 0;
    DWORD   dwBufferSize;
    DWORD   dwRemainingBufferSize;
    DWORD   dwSts;

    if (NULL == l_pbStringBlock)
    {
        hMod = LoadLibraryEx("crypt32.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (NULL == hMod)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        //
        // get size of all string resources, and then allocate a single block
        // of memory to contain all the strings.  This way, we only have to
        // free one block and we benefit memory wise due to locality of reference.
        //

        dwBufferSize = dwRemainingBufferSize = GLOBAL_STRING_BUFFERSIZE;

        l_pbStringBlock = (BYTE*)ContInfoAlloc(dwBufferSize);
        if (NULL == l_pbStringBlock)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_RSA_SIG_DESCR, &g_Strings.pwszRSASigDescr,
                           &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_RSA_EXCH_DESCR, &g_Strings.pwszRSAExchDescr,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_IMPORT_SIMPLE, &g_Strings.pwszImportSimple,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_SIGNING_E, &g_Strings.pwszSignWExch,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_CREATE_RSA_SIG, &g_Strings.pwszCreateRSASig,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_CREATE_RSA_EXCH, &g_Strings.pwszCreateRSAExch,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_DSS_SIG_DESCR, &g_Strings.pwszDSSSigDescr,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_DSS_EXCH_DESCR, &g_Strings.pwszDHExchDescr,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_CREATE_DSS_SIG, &g_Strings.pwszCreateDSS,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_CREATE_DH_EXCH, &g_Strings.pwszCreateDH,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_IMPORT_E_PUB, &g_Strings.pwszImportDHPub,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_MIGR, &g_Strings.pwszMigrKeys,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_DELETE_SIG, &g_Strings.pwszDeleteSig,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_DELETE_KEYX, &g_Strings.pwszDeleteExch,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_DELETE_SIG_MIGR, &g_Strings.pwszDeleteMigrSig,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_DELETE_KEYX_MIGR, &g_Strings.pwszDeleteMigrExch,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_SIGNING_S, &g_Strings.pwszSigning,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_EXPORT_E_PRIV, &g_Strings.pwszExportPrivExch,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_EXPORT_S_PRIV, &g_Strings.pwszExportPrivSig,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_IMPORT_E_PRIV, &g_Strings.pwszImportPrivExch,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_IMPORT_S_PRIV, &g_Strings.pwszImportPrivSig,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = FetchString(hMod, IDS_CSP_AUDIT_CAPI_KEY, &g_Strings.pwszAuditCapiKey,
                            &l_pbStringBlock, &dwBufferSize, &dwRemainingBufferSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        // Fix up all the strings to be real pointers rather than offsets.
        // the reason that offsets are originally stored is because we may
        // need to reallocate the buffer that all the strings are stored in.
        // So offsets are stored so that the pointers for those strings in
        // the buffers don't become invalid.
        g_Strings.pwszRSASigDescr    = (LPWSTR)(((ULONG_PTR) g_Strings.pwszRSASigDescr)    + l_pbStringBlock);
        g_Strings.pwszRSAExchDescr   = (LPWSTR)(((ULONG_PTR) g_Strings.pwszRSAExchDescr)   + l_pbStringBlock);
        g_Strings.pwszImportSimple   = (LPWSTR)(((ULONG_PTR) g_Strings.pwszImportSimple)   + l_pbStringBlock);
        g_Strings.pwszSignWExch      = (LPWSTR)(((ULONG_PTR) g_Strings.pwszSignWExch)      + l_pbStringBlock);
        g_Strings.pwszCreateRSASig   = (LPWSTR)(((ULONG_PTR) g_Strings.pwszCreateRSASig)   + l_pbStringBlock);
        g_Strings.pwszCreateRSAExch  = (LPWSTR)(((ULONG_PTR) g_Strings.pwszCreateRSAExch)  + l_pbStringBlock);
        g_Strings.pwszDSSSigDescr    = (LPWSTR)(((ULONG_PTR) g_Strings.pwszDSSSigDescr)    + l_pbStringBlock);
        g_Strings.pwszDHExchDescr    = (LPWSTR)(((ULONG_PTR) g_Strings.pwszDHExchDescr)    + l_pbStringBlock);
        g_Strings.pwszCreateDSS      = (LPWSTR)(((ULONG_PTR) g_Strings.pwszCreateDSS)      + l_pbStringBlock);
        g_Strings.pwszCreateDH       = (LPWSTR)(((ULONG_PTR) g_Strings.pwszCreateDH)       + l_pbStringBlock);
        g_Strings.pwszImportDHPub    = (LPWSTR)(((ULONG_PTR) g_Strings.pwszImportDHPub)    + l_pbStringBlock);
        g_Strings.pwszMigrKeys       = (LPWSTR)(((ULONG_PTR) g_Strings.pwszMigrKeys)       + l_pbStringBlock);
        g_Strings.pwszDeleteSig      = (LPWSTR)(((ULONG_PTR) g_Strings.pwszDeleteSig)      + l_pbStringBlock);
        g_Strings.pwszDeleteExch     = (LPWSTR)(((ULONG_PTR) g_Strings.pwszDeleteExch)     + l_pbStringBlock);
        g_Strings.pwszDeleteMigrSig  = (LPWSTR)(((ULONG_PTR) g_Strings.pwszDeleteMigrSig)  + l_pbStringBlock);
        g_Strings.pwszDeleteMigrExch = (LPWSTR)(((ULONG_PTR) g_Strings.pwszDeleteMigrExch) + l_pbStringBlock);
        g_Strings.pwszSigning        = (LPWSTR)(((ULONG_PTR) g_Strings.pwszSigning)        + l_pbStringBlock);
        g_Strings.pwszExportPrivExch = (LPWSTR)(((ULONG_PTR) g_Strings.pwszExportPrivExch) + l_pbStringBlock);
        g_Strings.pwszExportPrivSig  = (LPWSTR)(((ULONG_PTR) g_Strings.pwszExportPrivSig)  + l_pbStringBlock);
        g_Strings.pwszImportPrivExch = (LPWSTR)(((ULONG_PTR) g_Strings.pwszImportPrivExch) + l_pbStringBlock);
        g_Strings.pwszImportPrivSig  = (LPWSTR)(((ULONG_PTR) g_Strings.pwszImportPrivSig)  + l_pbStringBlock);
        g_Strings.pwszAuditCapiKey   = (LPWSTR)(((ULONG_PTR) g_Strings.pwszAuditCapiKey)   + l_pbStringBlock);

        FreeLibrary(hMod);
        hMod = NULL;
    }

    return ERROR_SUCCESS;

ErrorExit:
    if (NULL != l_pbStringBlock)
    {
        ContInfoFree(l_pbStringBlock);
        l_pbStringBlock = NULL;
    }
    if (hMod)
        FreeLibrary(hMod);
    return dwReturn;
}


void
UnloadStrings(
    void)
{
    if (NULL != l_pbStringBlock)
    {
        ContInfoFree(l_pbStringBlock);
        l_pbStringBlock = NULL;
        memset(&g_Strings, 0, sizeof(g_Strings));
    }
}


#ifdef USE_HW_RNG
#ifdef _M_IX86

// stuff for INTEL RNG usage

//
// Function : GetRNGDriverHandle
//
// Description : Gets the handle to the INTEL RNG driver if available, then
//               checks if the chipset supports the hardware RNG.  If so
//               the previous driver handle is closed if necessary and the
//               new handle is assigned to the passed in parameter.
//

DWORD
GetRNGDriverHandle(
    IN OUT HANDLE *phDriver)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    ISD_Capability  ISD_Cap;                //in/out for GetCapability
    DWORD           dwBytesReturned;
    char            szDeviceName[80] = "";  //Name of device
    HANDLE          hDriver = INVALID_HANDLE_VALUE; //Driver handle
    BOOL            fReturnCode;            //Return code from IOCTL call

    memset(&ISD_Cap, 0, sizeof(ISD_Cap));

    wsprintf(szDeviceName,"\\\\.\\"DRIVER_NAME);
    hDriver = CreateFileA(szDeviceName,
                          FILE_SHARE_READ | FILE_SHARE_WRITE
                          | GENERIC_READ | GENERIC_WRITE,
                          0, NULL,
                          OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == hDriver)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    //Get RNG Enabled
    ISD_Cap.uiIndex = ISD_RNG_ENABLED;  //Set input member
    fReturnCode = DeviceIoControl(hDriver,
                                  IOCTL_ISD_GetCapability,
                                  &ISD_Cap, sizeof(ISD_Cap),
                                  &ISD_Cap, sizeof(ISD_Cap),
                                  &dwBytesReturned,
                                  NULL);
    if (fReturnCode == FALSE || ISD_Cap.iStatus != ISD_EOK)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    // close the previous handle if already there
    if (INVALID_HANDLE_VALUE != *phDriver)
        CloseHandle(*phDriver);

    *phDriver = hDriver;
    return ERROR_SUCCESS;

ErrorExit:
    if (INVALID_HANDLE_VALUE != hDriver)
        CloseHandle(hDriver);
    return dwReturn;
}


//
// Function : CheckIfRNGAvailable
//
// Description : Checks if the INTEL RNG driver is available, if so then
//               checks if the chipset supports the hardware RNG.
//

DWORD
CheckIfRNGAvailable(
    void)
{
    HANDLE  hDriver = INVALID_HANDLE_VALUE; //Driver handle
    DWORD   dwSts;

    dwSts = GetRNGDriverHandle(&hDriver);
    if (ERROR_SUCCESS == dwSts)
        CloseHandle(hDriver);
    return dwSts;
}


//
// Function : HWRNGGenRandom
//
// Description : Uses the passed in handle to the INTEL RNG driver
//               to fill the buffer with random bits.  Actually uses
//               XOR to fill the buffer so that the passed in buffer
//               is also mixed in.
//

DWORD
HWRNGGenRandom(
    IN HANDLE hRNGDriver,
    IN OUT BYTE *pbBuffer,
    IN DWORD dwLen)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    ISD_RandomNumber    ISD_Random;             //in/out for GetRandomNumber
    DWORD               dwBytesReturned = 0;
    DWORD               i;
    DWORD               *pdw;
    BYTE                *pb;
    BYTE                *pbRand;
    BOOL                fReturnCode;            //Return code from IOCTL call

    memset(&ISD_Random, 0, sizeof(ISD_Random));

    for (i = 0; i < (dwLen / sizeof(DWORD)); i++)
    {
        pdw = (DWORD*)(pbBuffer + i * sizeof(DWORD));

        //No input needed in the ISD_Random structure for this operation,
        //so just send it in as is.
        fReturnCode = DeviceIoControl(hRNGDriver,
                                      IOCTL_ISD_GetRandomNumber,
                                      &ISD_Random, sizeof(ISD_Random),
                                      &ISD_Random, sizeof(ISD_Random),
                                      &dwBytesReturned,
                                      NULL);
        if (fReturnCode == 0 || ISD_Random.iStatus != ISD_EOK)
        {
            //Error - ignore the data returned
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        *pdw = *pdw ^ ISD_Random.uiRandomNum;
    }

    pb = pbBuffer + i * sizeof(DWORD);
    fReturnCode = DeviceIoControl(hRNGDriver,
                                  IOCTL_ISD_GetRandomNumber,
                                  &ISD_Random, sizeof(ISD_Random),
                                  &ISD_Random, sizeof(ISD_Random),
                                  &dwBytesReturned,
                                  NULL);
    if (fReturnCode == 0 || ISD_Random.iStatus != ISD_EOK)
    {
        //Error - ignore the data returned
        dwReturn = GetLastError();
        goto ErrorExit;
    }
    pbRand = (BYTE*)&ISD_Random.uiRandomNum;

    for (i = 0; i < (dwLen % sizeof(DWORD)); i++)
        pb[i] ^= pbRand[i];

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


#ifdef TEST_HW_RNG
//
// Function : SetupHWRNGIfRegistered
//
// Description : Checks if there is a registry setting indicating the HW RNG
//               is to be used.  If the registry entry is there then it attempts
//               to get the HW RNG driver handle.
//
DWORD
SetupHWRNGIfRegistered(
    OUT HANDLE *phRNGDriver)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD   dwSts;
    HKEY    hRegKey = NULL;

    // first check the registry entry to see if supposed to use HW RNG
    dwSts = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         "Software\\Microsoft\\Cryptography\\UseHWRNG",
                         0,        // dwOptions
                         KEY_READ,
                         &hRegKey);
    if (ERROR_SUCCESS == dwSts)
    {
        // get the driver handle
        dwSts = GetRNGDriverHandle(phRNGDriver);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != hRegKey)
        RegCloseKey(hRegKey);
    return dwReturn;
}
#endif // TEST_HW_RNG
#endif // _M_IX86
#endif // USE_HW_RNG


// The function MACs the given bytes.
/*static*/ void
MACBytes(
    IN DESTable *pDESKeyTable,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN OUT BYTE *pbTmp,
    IN OUT DWORD *pcbTmp,
    IN OUT BYTE *pbMAC)
{
    DWORD   cb = cbData;
    DWORD   cbMACed = 0;

    while (cb)
    {
        if ((cb + *pcbTmp) < DES_BLOCKLEN)
        {
            memcpy(pbTmp + *pcbTmp, pbData + cbMACed, cb);
            *pcbTmp += cb;
            break;
        }
        else
        {
            memcpy(pbTmp + *pcbTmp, pbData + cbMACed, DES_BLOCKLEN - *pcbTmp);
            CBC(des, DES_BLOCKLEN, pbMAC, pbTmp, pDESKeyTable,
                ENCRYPT, pbMAC);
            cbMACed = cbMACed + (DES_BLOCKLEN - *pcbTmp);
            cb = cb - (DES_BLOCKLEN - *pcbTmp);
            *pcbTmp = 0;
        }
    }
}


// Given hInst, allocs and returns pointers to MAC pulled from
// resource

/*static*/ DWORD
GetResourcePtr(
    IN HMODULE hInst,
    IN LPSTR pszRsrcName,
    OUT BYTE **ppbRsrcMAC,
    OUT DWORD *pcbRsrcMAC)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    HRSRC   hRsrc;

    // Nab resource handle for our signature
    hRsrc = FindResourceA(hInst, pszRsrcName, RT_RCDATA);
    if (NULL == hRsrc)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    // get a pointer to the actual signature data
    *ppbRsrcMAC = (PBYTE)LoadResource(hInst, hRsrc);
    if (NULL == *ppbRsrcMAC)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    // determine the size of the resource
    *pcbRsrcMAC = SizeofResource(hInst, hRsrc);
    if (0 == *pcbRsrcMAC)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


#define CSP_TO_BE_MACED_CHUNK  4096

// Given hFile, reads the specified number of bytes (cbToBeMACed) from the file
// and MACs these bytes.  The function does this in chunks.

/*static*/ DWORD
MACBytesOfFile(
    IN HANDLE hFile,
    IN DWORD cbToBeMACed,
    IN DESTable *pDESKeyTable,
    IN BYTE *pbTmp,
    IN DWORD *pcbTmp,
    IN BYTE *pbMAC)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BYTE    rgbChunk[CSP_TO_BE_MACED_CHUNK];
    DWORD   cbRemaining = cbToBeMACed;
    DWORD   cbToRead;
    DWORD   dwBytesRead;

    //
    // loop over the file for the specified number of bytes
    // updating the hash as we go.
    //

    while (cbRemaining > 0)
    {
        if (cbRemaining < CSP_TO_BE_MACED_CHUNK)
            cbToRead = cbRemaining;
        else
            cbToRead = CSP_TO_BE_MACED_CHUNK;

        if (!ReadFile(hFile, rgbChunk, cbToRead, &dwBytesRead, NULL))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        MACBytes(pDESKeyTable, rgbChunk, dwBytesRead, pbTmp, pcbTmp,
                 pbMAC);
        cbRemaining -= cbToRead;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*static*/ DWORD
MACTheFile(
    LPCSTR pszImage,
    DWORD cbImage)
{
    static CONST BYTE rgbMACDESKey[]
        = { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef };
    DWORD                       dwReturn = ERROR_INTERNAL_ERROR;
    HMODULE                     hInst;
    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbRsrcMAC;
    DWORD                       cbRsrcMAC;
    BYTE                        *pbRsrcSig;
    DWORD                       cbRsrcSig;
    BYTE                        *pbStart = NULL;
    BYTE                        rgbMAC[DES_BLOCKLEN];
    BYTE                        rgbZeroMAC[DES_BLOCKLEN + sizeof(DWORD) * 2];
    BYTE                        rgbZeroSig[144];
    BYTE                        *pbPostCRC;   // pointer to just after CRC
    DWORD                       cbCRCToRsrc1; // number of bytes from CRC to first rsrc
    DWORD                       cbRsrc1ToRsrc2; // number of bytes from first rsrc to second
    DWORD                       cbPostRsrc;    // size - (already hashed + signature size)
    BYTE                        *pbRsrc1ToRsrc2;
    BYTE                        *pbPostRsrc;
    BYTE                        *pbZeroRsrc1;
    BYTE                        *pbZeroRsrc2;
    DWORD                       cbZeroRsrc1;
    DWORD                       cbZeroRsrc2;
    DWORD                       *pdwMACInFileVer;
    DWORD                       *pdwCRCOffset;
    DWORD                       dwCRCOffset;
    DWORD                       dwZeroCRC = 0;
    OFSTRUCT                    ImageInfoBuf;
    HFILE                       hFile = HFILE_ERROR;
    HANDLE                      hMapping = NULL;
    DESTable                    DESKeyTable;
    BYTE                        rgbTmp[DES_BLOCKLEN];
    DWORD                       cbTmp = 0;
    DWORD                       dwSts;

    memset(&MemInfo, 0, sizeof(MemInfo));
    memset(rgbMAC, 0, sizeof(rgbMAC));
    memset(rgbTmp, 0, sizeof(rgbTmp));

    // Load the file
    hFile = OpenFile(pszImage, &ImageInfoBuf, OF_READ);
    if (HFILE_ERROR == hFile)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    hMapping = CreateFileMapping((HANDLE)IntToPtr(hFile),
                                 NULL,
                                 PAGE_READONLY,
                                 0,
                                 0,
                                 NULL);
    if (hMapping == NULL)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    pbStart = MapViewOfFile(hMapping,
                          FILE_MAP_READ,
                          0,
                          0,
                          0);
    if (pbStart == NULL)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    // Convert pointer to HMODULE, using the same scheme as
    // LoadLibrary (windows\base\client\module.c).
    hInst = (HMODULE)((ULONG_PTR)pbStart | 0x00000001);

    // the MAC resource
    dwSts = GetResourcePtr(hInst, CRYPT_MAC_RESOURCE, &pbRsrcMAC, &cbRsrcMAC);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // the SIG resource
    dwSts = GetResourcePtr(hInst, CRYPT_SIG_RESOURCE, &pbRsrcSig, &cbRsrcSig);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (cbRsrcMAC < (sizeof(DWORD) * 2))
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    // create a zero byte MAC
    memset(rgbZeroMAC, 0, sizeof(rgbZeroMAC));

    // check the sig in file version and get the CRC offset
    pdwMACInFileVer = (DWORD*)pbRsrcMAC;
    pdwCRCOffset = (DWORD*)(pbRsrcMAC + sizeof(DWORD));
    dwCRCOffset = *pdwCRCOffset;
    if ((0x00000100 != *pdwMACInFileVer) || (dwCRCOffset > cbImage))
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    if (DES_BLOCKLEN != (cbRsrcMAC - (sizeof(DWORD) * 2)))
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    // create a zero byte Sig
    memset(rgbZeroSig, 0, sizeof(rgbZeroSig));

    // set up the pointers
    pbPostCRC = pbStart + *pdwCRCOffset + sizeof(DWORD);
    if (pbRsrcSig > pbRsrcMAC)    // MAC is first Rsrc
    {
        cbCRCToRsrc1 = (DWORD)(pbRsrcMAC - pbPostCRC);
        pbRsrc1ToRsrc2 = pbRsrcMAC + cbRsrcMAC;
        cbRsrc1ToRsrc2 = (DWORD)(pbRsrcSig - pbRsrc1ToRsrc2);
        pbPostRsrc = pbRsrcSig + cbRsrcSig;
        cbPostRsrc = (cbImage - (DWORD)(pbPostRsrc - pbStart));

        // zero pointers
        pbZeroRsrc1 = rgbZeroMAC;
        cbZeroRsrc1 = cbRsrcMAC;
        pbZeroRsrc2 = rgbZeroSig;
        cbZeroRsrc2 = cbRsrcSig;
    }
    else                        // Sig is first Rsrc
    {
        cbCRCToRsrc1 = (DWORD)(pbRsrcSig - pbPostCRC);
        pbRsrc1ToRsrc2 = pbRsrcSig + cbRsrcSig;
        cbRsrc1ToRsrc2 = (DWORD)(pbRsrcMAC - pbRsrc1ToRsrc2);
        pbPostRsrc = pbRsrcMAC + cbRsrcMAC;
        cbPostRsrc = (cbImage - (DWORD)(pbPostRsrc - pbStart));

        // zero pointers
        pbZeroRsrc1 = rgbZeroSig;
        cbZeroRsrc1 = cbRsrcSig;
        pbZeroRsrc2 = rgbZeroMAC;
        cbZeroRsrc2 = cbRsrcMAC;
    }

    // init the key table
    deskey(&DESKeyTable, (LPBYTE)rgbMACDESKey);

    // MAC up to the CRC
    dwSts = MACBytesOfFile((HANDLE)IntToPtr(hFile), dwCRCOffset, &DESKeyTable,
                           rgbTmp, &cbTmp, rgbMAC);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // pretend CRC is zeroed
    MACBytes(&DESKeyTable, (BYTE*)&dwZeroCRC, sizeof(DWORD), rgbTmp, &cbTmp,
             rgbMAC);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), sizeof(DWORD), NULL, FILE_CURRENT))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    // MAC from CRC to first resource
    dwSts = MACBytesOfFile((HANDLE)IntToPtr(hFile), cbCRCToRsrc1, &DESKeyTable,
                           rgbTmp, &cbTmp, rgbMAC);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // pretend image has zeroed first resource
    MACBytes(&DESKeyTable, (BYTE*)pbZeroRsrc1, cbZeroRsrc1, rgbTmp, &cbTmp,
             rgbMAC);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), cbZeroRsrc1, NULL, FILE_CURRENT))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    // MAC from first resource to second
    dwSts = MACBytesOfFile((HANDLE)IntToPtr(hFile), cbRsrc1ToRsrc2,
                           &DESKeyTable, rgbTmp, &cbTmp, rgbMAC);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // pretend image has zeroed second Resource
    MACBytes(&DESKeyTable, (BYTE*)pbZeroRsrc2, cbZeroRsrc2, rgbTmp, &cbTmp,
             rgbMAC);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), cbZeroRsrc2, NULL, FILE_CURRENT))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    // MAC after the resource
    dwSts = MACBytesOfFile((HANDLE)IntToPtr(hFile), cbPostRsrc, &DESKeyTable,
                           rgbTmp, &cbTmp, rgbMAC);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (0 != memcmp(rgbMAC, pbRsrcMAC + sizeof(DWORD) * 2, DES_BLOCKLEN))
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pbStart)
        UnmapViewOfFile(pbStart);
    if (NULL != hMapping)
        CloseHandle(hMapping);
    if (HFILE_ERROR != hFile)
        _lclose(hFile);
    return dwReturn;
}


// **********************************************************************
// SelfMACCheck performs a DES MAC on the binary image of this DLL
// **********************************************************************

DWORD
SelfMACCheck(
    IN LPSTR pszImage)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    HFILE       hFileProv = HFILE_ERROR;
    DWORD       cbImage;
    OFSTRUCT    ImageInfoBuf;
    DWORD       dwSts;

#ifdef _DEBUG
    return ERROR_SUCCESS;
#endif


    // Check file size
    hFileProv = OpenFile(pszImage, &ImageInfoBuf, OF_READ);
    if (HFILE_ERROR == hFileProv)
    {
        dwSts = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwSts)
            dwReturn = (DWORD)NTE_PROV_DLL_NOT_FOUND;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    cbImage = GetFileSize((HANDLE)IntToPtr(hFileProv), NULL);
    if ((DWORD)(-1) == cbImage)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    _lclose(hFileProv);
    hFileProv = HFILE_ERROR;

    dwSts = MACTheFile(pszImage, cbImage);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (HFILE_ERROR != hFileProv)
        _lclose(hFileProv);
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\autoenrl\pautoenr\pautoenr.c ===
#include <windows.h>
#include <wincrypt.h>
#include <autoenr.h>
#include <cryptui.h>

#define MY_TEST_REG_ENTRY   "Software\\Microsoft\\Cryptography\\AutoEnroll"
#define PST_EVENT_INIT "PS_SERVICE_STARTED"


/*BOOL SmallTest(DWORD dw)
{
    HKEY    hRegKey = 0;
    DWORD   dwDisposition;
    BOOL    fRet = FALSE;

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CURRENT_USER, MY_TEST_REG_ENTRY,
                                        0, NULL, REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS, NULL, &hRegKey,
                                        &dwDisposition))
        goto Ret;

    if (ERROR_SUCCESS != RegSetValueEx(hRegKey, "AutoEnrollTest", 0,
                                       REG_BINARY, (BYTE*)&dw, sizeof(dw)))
        goto Ret;

    fRet = TRUE;
Ret:
    if (hRegKey)
        RegCloseKey(hRegKey);
    SetLastError(dw);
    return fRet;
}*/

void AutoEnrollErrorLogging(DWORD dwErr)
{
    return;
    // UNDONE - log the error along with some useful message
    //SmallTest(dwErr);
}

#define FAST_BUFF_LEN   256



BOOL EnrollForACert(
                    IN BOOL fMachineEnrollment,
                    IN BOOL fRenewalRequired,
                    IN PAUTO_ENROLL_INFO pInfo
                    )
{
    CRYPTUI_WIZ_CERT_REQUEST_INFO       CertRequestInfo;
    CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW    NewKeyInfo;
    CRYPTUI_WIZ_CERT_TYPE               CertType;
    CRYPT_KEY_PROV_INFO                 ProviderInfo;
    PCCERT_CONTEXT                      pCertContext = NULL;
    PCCERT_CONTEXT                      pCert = NULL;
    DWORD                               dwCAStatus;
    DWORD                               dwAcquireFlags = 0;
    LPWSTR                              pwszProvName = NULL;
	WCHAR								rgwszMachineName[MAX_COMPUTERNAME_LENGTH + 1]; 
    DWORD                               cMachineName = MAX_COMPUTERNAME_LENGTH + 1;
    CRYPT_DATA_BLOB                     CryptData;
    DWORD                               dwErr = 0;
    BOOL                                fRet = FALSE;

    memset(&CertRequestInfo, 0, sizeof(CertRequestInfo));
    memset(&NewKeyInfo, 0, sizeof(NewKeyInfo));
    memset(&ProviderInfo, 0, sizeof(ProviderInfo));
    memset(&rgwszMachineName, 0, sizeof(rgwszMachineName));
    memset(&CryptData, 0, sizeof(CryptData));
    memset(&CertType, 0, sizeof(CertType));

    if (fMachineEnrollment)
    {
        dwAcquireFlags = CRYPT_MACHINE_KEYSET;
	    if (0 == GetComputerNameW(rgwszMachineName,
                                  &cMachineName))
        {
            goto Ret;
        }
        CertRequestInfo.pwszMachineName = rgwszMachineName;
    }
    
    // set up the provider info
    ProviderInfo.dwProvType = pInfo->dwProvType;

    ProviderInfo.pwszProvName = NULL;  // The wizard will choose one based
                                       // on the cert type

    // set the acquire context flags
    // UNDONE - need to add silent flag
    ProviderInfo.dwFlags = dwAcquireFlags;

    // set the key specification
    ProviderInfo.dwKeySpec = pInfo->dwKeySpec;

    // set up the new key info
    NewKeyInfo.dwSize = sizeof(NewKeyInfo);
    NewKeyInfo.pKeyProvInfo = &ProviderInfo;
    // set the flags to be passed when calling CryptGenKey
    NewKeyInfo.dwGenKeyFlags = pInfo->dwGenKeyFlags;

    // set the request info
    CertRequestInfo.dwSize = sizeof(CertRequestInfo);

    // UNDONE - if cert exists then check if expired (if so do renewal)
    if (pInfo->fRenewal)
    {
        CertRequestInfo.dwPurpose = CRYPTUI_WIZ_CERT_RENEW;
        CertRequestInfo.pRenewCertContext = pInfo->pOldCert;
    }
    else
    {
        CertRequestInfo.dwPurpose = CRYPTUI_WIZ_CERT_ENROLL;
        CertRequestInfo.pRenewCertContext = NULL;
    }

    // UNDONE - for now always gen a new key, later may allow using existing key
    // for things like renewal
    CertRequestInfo.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW;
    CertRequestInfo.pPvkNew = &NewKeyInfo;

    // destination cert store is the MY store (!!!! hard coded !!!!)
    CertRequestInfo.pwszDesStore = L"MY";

    // set algorithm for hashing
    CertRequestInfo.pszHashAlg = NULL;

    // set the cert type
    CertRequestInfo.dwCertChoice = CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE;
    CertType.dwSize = sizeof(CertType);
    CertType.cCertType = 1;
    CertType.rgwszCertType = &pInfo->pwszCertType;
    CertRequestInfo.pCertType = &CertType;

    // set the requested cert extensions
    CertRequestInfo.pCertRequestExtensions = &pInfo->CertExtensions;

    // set post option  
    CertRequestInfo.dwPostOption = 0;

    // set the Cert Server machine and authority
    CertRequestInfo.pwszCALocation = pInfo->pwszCAMachine;
    CertRequestInfo.pwszCAName = pInfo->pwszCAAuthority;

    // certify and create a key at the same time
    if (!CryptUIWizCertRequest(CRYPTUI_WIZ_NO_UI, 0, NULL,
                               &CertRequestInfo, &pCertContext,     
                               &dwCAStatus))    
    {
        AutoEnrollErrorLogging(GetLastError());
        goto Ret;
    }

    if (CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED == dwCAStatus)
    {
        BYTE aHash[20];
        CRYPT_HASH_BLOB blobHash;

        blobHash.pbData = aHash;
        blobHash.cbData = sizeof(aHash);
        CryptData.cbData = (wcslen(pInfo->pwszAutoEnrollmentID) + 1) * sizeof(WCHAR);
        CryptData.pbData = (BYTE*)pInfo->pwszAutoEnrollmentID;
        
        // We need to get the real certificate of the store, as the one
        // passed back is self contained.
        if(!CertGetCertificateContextProperty(pCertContext,
                                          CERT_SHA1_HASH_PROP_ID,
                                          blobHash.pbData,
                                          &blobHash.cbData))
        {
            AutoEnrollErrorLogging(GetLastError());
            goto Ret;
        }

        pCert =  CertFindCertificateInStore(pInfo->hMYStore,
                                            pCertContext->dwCertEncodingType,
                                            0,
                                            CERT_FIND_SHA1_HASH,
                                            &blobHash,
                                            NULL);
        if(pCert == NULL)
        {
            AutoEnrollErrorLogging(GetLastError());
            goto Ret;
        }

        // place the auto enrollment property on the cert
        if (!CertSetCertificateContextProperty(pCert,
                        CERT_AUTO_ENROLL_PROP_ID, 0, &CryptData))
        {
            AutoEnrollErrorLogging(GetLastError());
            goto Ret;
        }
    }

    // UNDONE - request did not return cert so take appropriate action
//    else
//    {
//        goto Ret;
//    }

    fRet = TRUE;
Ret:
    if (pCertContext)
        CertFreeCertificateContext(pCertContext);

    if (pCert)
        CertFreeCertificateContext(pCert);

    if (pwszProvName)
        LocalFree(pwszProvName);

    return fRet;
}









//+---------------------------------------------------------------------------
//
//  Function:   ProvAutoEnrollment
//
//  Synopsis:   Entry point for the default MS auto enrollment client provider.
//
//  Arguments:  
//          fMachineEnrollment - TRUE if machine is enrolling, FALSE if user
//
//          pInfo - information needed to enroll (see AUTO_ENROLL_INFO struct
//                  in autoenrl.h)
//
//  History:    01-12-98   jeffspel   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL ProvAutoEnrollment(
                        IN BOOL fMachineEnrollment,
                        IN PAUTO_ENROLL_INFO pInfo
                        )
{
    BOOL                fRenewalRequired = FALSE;
    BOOL                fRet = FALSE;

 
        // enroll for a cert
        if (!EnrollForACert(fMachineEnrollment, fRenewalRequired, pInfo))
            goto Ret;

    fRet = TRUE;
Ret:
    return fRet;
}

BOOLEAN
DllInitialize(
    IN PVOID hmod,
    IN ULONG Reason,
    IN PCONTEXT Context
    )
{

    return( TRUE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\dssinc\cryptdsa.h ===
#ifndef __CRYPTDSA_
#define __CRYPTDSA_

#ifdef __cplusplus
extern "C" {
#endif

#define SHA_BITS      160
                            // Number of bits output by SHA
#define SHA_DWORDS      5
                            // Number of DWORDS output by SHA
#define DSA_Q_MINDWORDS 5
                            // Minimum number of DWORDS in q
#define DSA_Q_MAXDWORDS 128
                            // Maximum number of DWORDS in q
#define DSA_P_MINDWORDS 16
                            // Minimum number of DWORDS in p
#define DSA_P_MAXDWORDS 128
                            // Maximum number of DWORDS in p

#define DSA_Q_MAXDIGITS DWORDS_TO_DIGITS(DSA_Q_MAXDWORDS)
#define DSA_P_MAXDIGITS DWORDS_TO_DIGITS(DSA_P_MAXDWORDS)


typedef struct {
        void             *pInfo;
        void             *pFuncRNG;
        } RNGINFO;

typedef struct {
                DWORD    nbitp;             // Number of significant bits in p.
                                            // (Multiple of 64,   512 <= nbitp <= 1024)
                DWORD    nbitq;             // Number of significant bits in q.
                                            // Must be exactly 160.
                DWORD    p[DSA_P_MAXDWORDS];// Public prime p, 512-1024 bits
                DWORD    q[DSA_Q_MAXDWORDS];// Public prime q (160 bits, divides p-1)
                DWORD    g[DSA_P_MAXDWORDS];// Public generator g of order q (mod p)
                DWORD    j[DSA_P_MAXDWORDS];// j = (p - 1) / q
                DWORD    y[DSA_P_MAXDWORDS];// Public value g^x (mod p), where x is private
                DWORD    S[SHA_DWORDS];     // 160-bit pattern used to construct q
                DWORD    C;                 // 12-bit value of C used to construct p
               } dsa_public_t;

typedef struct {
                digit_t        qdigit[DSA_Q_MAXDIGITS];
                DWORD          lngq_digits;           // Length of q in digits
                reciprocal_1_t qrecip;                // Information about 1/q
                digit_t        gmodular[DSA_P_MAXDIGITS];
                                                      // g as residue mod p
                digit_t        ymodular[DSA_P_MAXDIGITS];
                                                      // y as residue mod p
                mp_modulus_t   pmodulus;              // Constants mod p
               } dsa_precomputed_t;


typedef struct {
                dsa_public_t      pub;               // Public data
                DWORD             x[DSA_P_MAXDWORDS];// Private exponent x (mod q)
                dsa_precomputed_t precomputed;       // Precomputed public data
               } dsa_private_t;

typedef struct {
                DWORD r[SHA_DWORDS];            // (g^k mod p)       mod q
                DWORD s[SHA_DWORDS];            // (SHA(m) + x*r)/k  mod q
               } dsa_signature_t;

typedef struct {
                VOID *pOffload;            // pointer to expo offload info
                FARPROC pFuncExpoOffload;
                RNGINFO *pRNGInfo;            // pointer to RNG info
               } dsa_other_info;

typedef const dsa_precomputed_t dsa_precomputed_tc;
typedef const dsa_private_t     dsa_private_tc;
typedef const dsa_public_t      dsa_public_tc;
typedef const dsa_signature_t   dsa_signature_tc;

void DSA_gen_x(DWORDC cXDigits,                         // In
               DWORDC cXDwords,                         // In
               digit_t *pMod,                           // In
               dsa_other_info *pOtherInfo,              // In
               DWORD *pdwX,                             // Out
               digit_t *pXDigit);                       // Out

BOOL DSA_gen_x_and_y(BOOL fUseQ,                             // In
                     dsa_other_info *pOtherInfo,             // In
                     dsa_private_t *privkey);                // Out

BOOL DSA_check_g(DWORDC         lngp_digits,                   // In
                 digit_tc       *pGModular,                    // In
                 mp_modulus_t   *pPModulo,                     // In
                 DWORDC         lngq_digits,                   // In
                 digit_tc       *pQDigit);                     // In

BOOL DSA_key_generation(DWORDC         nbitp,                   // In
                        DWORDC         nbitq,                   // In
                        dsa_other_info *pOtherInfo,             // In
                        dsa_private_t  *privkey);               // Out

BOOL DSA_key_import_fillin(dsa_private_t *privkey);                             // In, Out

BOOL DSA_precompute_pgy(dsa_public_tc     *pubkey,               // In
                        dsa_precomputed_t *precomputed);         // Out

BOOL DSA_precompute(dsa_public_tc     *pubkey,                    // In
                    dsa_precomputed_t *precomputed,               // Out
                    const BOOL         checkSC);                  // In

BOOL DSA_sign(DWORDC           message_hash[SHA_DWORDS],   /* TBD */
              dsa_private_tc   *privkey,
              dsa_signature_t  *signature,
              dsa_other_info   *pOtherInfo);

BOOL DSA_signature_verification(DWORDC              message_hash[SHA_DWORDS],
                                dsa_public_tc       *pubkey,
                                dsa_precomputed_tc  *precomputed_argument,
                                dsa_signature_tc    *signature,
                                dsa_other_info      *pOtherInfo);

BOOL DSA_parameter_verification(
                                dsa_public_tc       *pPubkey,
                                dsa_precomputed_tc  *pPrecomputed
                                );

BOOL DSA_verify_j(
                  dsa_public_tc       *pPubkey,
                  dsa_precomputed_tc  *pPrecomputed
                  );

#ifdef __cplusplus
}
#endif

#endif __CRYPTDSA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\dssinc\context.h ===
/* context.h */

#include <windows.h>

#ifndef DSSCSP_CONTEXT_H
#define DSSCSP_CONTEXT_H

#ifdef CSP_USE_MD5
#include "md5.h"
#endif
#ifdef CSP_USE_SHA1
#include "sha.h"
#endif

// definition for disabling encryption in France
#define CRYPT_DISABLE_CRYPT         0x1

/*********************************/
/* Definitions                   */
/*********************************/

#define     KEY_MAGIC   0xBADF

/* State definitions */
#define     KEY_INIT    0x0001

#define     MAX_BLOCKLEN     8

// types of key storage
#define PROTECTED_STORAGE_KEYS      1
#define PROTECTION_API_KEYS         2

#define     HASH_MAGIC      0xBADE

/* State Flags */
#define     HASH_INIT       0x0001
#define     HASH_DATA       0x0002
#define     HASH_FINISH     0x0004

#define     MAX_HASH_LEN    20

#define     CRYPT_BLKLEN    8

#define     HMAC_DEFAULT_STRING_LEN     64
#define     HMAC_STARTED    1
#define     HMAC_FINISHED   2


/*********************************/
/* Structure Definitions         */
/*********************************/

typedef struct _Key_t_ {
    int             magic;              // Magic number
    void            *pContext;
    int             state;              // State of object
    ALG_ID          algId;              // Algorithm Id
    DWORD           flags;              // General flags associated with key
    void            *algParams;         // Parameters for algorithm
    uchar           IV[MAX_BLOCKLEN];
    uchar           Temp_IV[MAX_BLOCKLEN];
    uchar           *pbKey;
    DWORD           cbKey;
    uchar           *pbSalt;
    DWORD           cbSalt;
    BYTE            *pbData;
    DWORD           cbData;
    DWORD           cbEffectiveKeyLen;
    int             mode;
    int             pad;
    int             mode_bits;
    BOOL            InProgress;         // if key is being used
    BOOL            fUIOnKey;           // flag to indicate if UI was to be set on the key
} Key_t;


// Packed version of Key_t. This is used when building opaque
// blobs, and is necessary to properly support WOW64 operation.
typedef struct _Packed_Key_t_ {
    // BLOBHEADER
    int             magic;              // Magic number
    int             state;              // State of object
    ALG_ID          algId;              // Algorithm Id
    DWORD           flags;              // General flags associated with key
    uchar           IV[MAX_BLOCKLEN];
    uchar           Temp_IV[MAX_BLOCKLEN];
    DWORD           cbKey;
    DWORD           cbData;
    DWORD           cbEffectiveKeyLen;
    int             mode;
    int             pad;
    int             mode_bits;
    BOOL            InProgress;         // if key is being used
    BOOL            fUIOnKey;           // flag to indicate if UI was to be set on the key
    // cbKey data bytes
    // cbData data bytes
} Packed_Key_t;


typedef struct {
    int             magic;                  // Magic number
    void            *pContext;              // associated context
    int             state;                  // State of hash object
    ALG_ID          algId;                  // Algorithm Id
    DWORD           size;                   // Size of hash
    void            *pMAC;                  // pointer to mac state
    BYTE            hashval[MAX_HASH_LEN];
    BYTE            *pbData;
    DWORD           cbData;
    Key_t           *pKey;
    BOOL            fInternalKey;
    ALG_ID          HMACAlgid;
    DWORD           HMACState;
    BYTE            *pbHMACInner;
    DWORD           cbHMACInner;
    BYTE            *pbHMACOuter;
    DWORD           cbHMACOuter;
    union {
#ifdef CSP_USE_MD5
        MD5_CTX md5;
#endif // CSP_USE_MD5
#ifdef CSP_USE_SHA1
        A_SHA_CTX   sha;
#endif // CSP_USE_SHA1
    } algData;
} Hash_t;


/*********************************/
/* Definitions                   */
/*********************************/

#define CONTEXT_MAGIC           0xDEADBEEF
#define CONTEXT_RANDOM_LENGTH   20


typedef struct _PStore_Info
{
    HINSTANCE   hInst;
    void        *pProv;
    GUID        SigType;
    GUID        SigSubtype;
    GUID        ExchType;
    GUID        ExchSubtype;
    LPWSTR      szPrompt;
    DWORD       cbPrompt;
} PSTORE_INFO;


/*********************************/
/* Structure Definitions         */
/*********************************/

typedef struct {
    DWORD               magic;                  // Magic number
    DWORD               dwProvType;             // Type of provider being called as
    LPSTR               szProvName;             // Name of provider being called as
    BOOL                fMachineKeyset;         // TRUE if keyset is for machine
    DWORD               rights;                 // Privileges
    BOOL                fIsLocalSystem;         // check if running as local system
    KEY_CONTAINER_INFO  ContInfo;
    Key_t               *pSigKey;               // pointer to the DSS sig key
    Key_t               *pKExKey;               // pointer to the DH key exchange key
    HKEY                hKeys;                  // Handle to registry
    DWORD               dwEnumalgs;             // index for enumerating algorithms
    DWORD               dwEnumalgsEx;           // index for enumerating algorithms
    DWORD               dwiSubKey;              // index for enumerating containers
    DWORD               dwMaxSubKey;            // max number of containers
    void                *contextData;           // Context specific data
    CRITICAL_SECTION    CritSec;                // critical section for decrypting keys
    HWND                hWnd;                   // handle to window for UI
    PSTORE_INFO         *pPStore;               // pointer to PStore information
    LPWSTR              pwszPrompt;             // UI prompt to be used
    DWORD               dwOldKeyFlags;          // flags to tell how keys should be migrated
    DWORD               dwKeysetType;           // type of storage used
    HANDLE              hRNGDriver;             // handle to hardware RNG driver
    EXPO_OFFLOAD_STRUCT *pOffloadInfo;          // info for offloading modular expo
    DWORD               dwPolicyId;             // Index into policy keylengh arrays.
} Context_t;


/*********************************/
/* Policy Definitions            */
/*********************************/

extern PROV_ENUMALGS_EX *g_AlgTables[];
// NOTE -- These definitions must match the order of entries in g_AlgTables.
#define POLICY_DSS_BASE       0 // Policy for MS_DEF_DSS_PROV
#define POLICY_DSSDH_BASE     1 // Policy for MS_DEF_DSS_DH_PROV
#define POLICY_DSSDH_ENHANCED 2 // Policy for MS_ENH_DSS_DH_PROV
#define POLICY_DSSDH_SCHANNEL 3 // Policy for MS_DEF_DH_SCHANNEL_PROV


/*********************************/
/* Function Definitions          */
/*********************************/

extern void
freeContext(
    Context_t *pContext);

extern Context_t *
checkContext(
    HCRYPTPROV hProv);

extern Context_t *
allocContext(
    void);

// Initialize a context
extern DWORD
initContext(
    IN OUT Context_t *pContext,
    IN DWORD dwFlags,
    IN DWORD dwProvType,
    IN LPCSTR szProvName,
    IN DWORD dwPolicyId);

extern HCRYPTPROV
AddContext(
    Context_t *pContext);

extern HCRYPTHASH
addContextHash(
    Context_t *pContext,
    Hash_t *pHash);

extern Hash_t *
checkContextHash(
    Context_t *pContext,
    HCRYPTHASH hHash);

// Add key to context
extern HCRYPTKEY
addContextKey(
    Context_t *pContext,
    Key_t *pKey);

// Check if key exists in context
extern Key_t *
checkContextKey(
    IN Context_t *pContext,
    IN HCRYPTKEY hKey);

// random number generation prototype
extern DWORD
FIPS186GenRandom(
    IN HANDLE hRNGDriver,
    IN BYTE **ppbContextSeed,
    IN DWORD *pcbContextSeed,
    IN OUT BYTE *pb,
    IN DWORD cb);

// Scrub sensitive data from memory
extern void
memnuke(
    volatile BYTE *pData,
    DWORD dwLen);

#include "dh_key.h"

extern DWORD EncryptPrivateKeyInMemory(
    IN DHKey_t  *pDH,
    IN BOOL     fSigKey);

extern DWORD CopyAndDecryptPrivateKey(
    IN DHKey_t  *pDH,
    IN DHKey_t  *pDH_copy,
    IN BOOL     fSigKey);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\dssinc\crypto.h ===
/****************************************************************************
*
*
*	FILENAME:		crypto.h
*
*	PRODUCT NAME:	CRYPTOGRAPHIC TOOLKIT
*
*	FILE STATUS:
*
*	DESCRIPTION:	Cryptographic Toolkit File
*					Common Definitions
*		    
*
*	PUBLIC FUNCTIONS:
*
*
*	REVISION  HISTORY:
*
*
*		10 Feb 96	AK		Created
*
*
* Created for Cylink Corporation by Secant
*
****************************************************************************/


#ifndef CRYPTO_H
#define CRYPTO_H

/* For C++ */
#ifdef __cplusplus
extern "C" {
#endif

/*************************************
*
* Module Defines
*
*************************************/

#define	FALSE		0
#define	TRUE        1
#define	SUCCESS		0

/*-- ANSI-recommended NULL Pointer definition --*/
#ifndef	NULL
#define	NULL		(void *) 0
#endif


/*************************************
*
* Error Definitions
*
*************************************/
#define	ERR_ALLOC		-1



/*************************************
*
* Type Definitions
*
*************************************/
typedef unsigned char	uchar;
typedef unsigned short	ushort;
typedef unsigned long	ulong;
typedef	unsigned char	BYTE;
typedef	unsigned short	USHORT;
typedef	unsigned int	UINT;
typedef	unsigned long	ULONG;
typedef int		BOOL;


#ifdef ORD_16
typedef unsigned short ord;
typedef unsigned long dord;
#endif
#ifdef ORD_32
typedef unsigned long ord;
typedef unsigned long dord;
#endif


#ifdef __cplusplus
}
#endif


#endif     /* CRYPTO_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\dssinc\csp.h ===
/* csp.h */

#include <windows.h>
#include <windef.h>
#include <wtypes.h>
#include <wincrypt.h>
#include <cspdk.h>
#include <winerror.h>
#include <crypto.h>
#include <mem.h>
#include <contman.h>
#include <policy.h>
#include <fxupbn.h>
#include <delayimp.h>
#include <pstore.h>

#ifdef _WIN64
#define ALIGNMENT_BOUNDARY 7
#else
#define ALIGNMENT_BOUNDARY 3
#endif

#ifdef _DEBUG
#include <crtdbg.h>
// #define BreakPoint
#define BreakPoint _CrtDbgBreak();
#define EntryPoint
// #define EntryPoint BreakPoint
#ifndef ASSERT
#define ASSERT _ASSERTE
#endif
#else   // _DEBUG
#define BreakPoint
#define EntryPoint
#ifndef ASSERT
#define ASSERT
#endif
#endif  // _DEBUG

// Specify which algorithms are supported
#define CSP_USE_SHA1
#define CSP_USE_MD5
#define CSP_USE_RC4
#define CSP_USE_RC2
#define CSP_USE_MAC
#define CSP_USE_DES40
#define CSP_USE_DES
#define CSP_USE_3DES
#define CSP_USE_SSL3

// Special definitions
#define RC_MAXSALTSIZE          256
#define RC2_DEFEFFSIZE           40
#define RC2_MINEFFSIZE           40
#define RC2_BLOCKLEN              8
#define RC_DEFSALTSIZE           11

#define RC2_WEAK_MAXEFFSIZE      56
#define RC2_STRONG_MAXEFFSIZE   128


/*********************************/
/* Definitions                   */
/*********************************/

/*********************************/
/* Structure Definitions         */
/*********************************/

#define CALG_DES40  CALG_CYLINK_MEK

typedef struct _dhSharedNumber
{
    BYTE            *shared;
    DWORD           len;
} dhSharedNumber;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\dssinc\des_key.h ===
/* des_key.h */


/*********************************/
/* Definitions                   */
/*********************************/
#define		DES_MAGIC		0x44455331

/*********************************/
/* Function Definitions          */
/*********************************/

DWORD initKeyDES (Key_t *des);
DWORD getDESParams (Key_t *des, DWORD param, BYTE *data, DWORD *len);
DWORD setDESParams (Key_t *des, DWORD param, CONST BYTE *data);

// Get DES key length
DWORD desGetKeyLength (
                       IN ALG_ID Algid,
                       IN DWORD dwFlags,
                       OUT DWORD *pcbKey,
                       OUT DWORD *pcbData
                       );

// Derive a des key
DWORD desDeriveKey (
                   IN OUT Key_t *pKey,
                   IN CONST BYTE *pbData,
                   IN DWORD dwFlags
                   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\dssinc\mem.h ===
/* mem.h */


  #define       DSSMalloc(a)       ContAlloc(a)
  #define       DSSFree(a)         if (NULL != (a)) ContFree(a)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\dssinc\handle.h ===
/* handle.h */

/*****************************/
/* Definitions               */
/*****************************/

#define		MAX_HANDLES		100

/*****************************/
/* Function Definitions      */
/*****************************/

cspContext_t *checkHandle (HCRYPTPROV handle);
BOOL setHandle(cspContext_t *context, HCRYPTPROV handle);
HCRYPTPROV getNextHandle ();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\dssinc\fxupbn.h ===
#include <bignum.h>
#include "cryptdsa.h"
#include <crtdbg.h>

inline void WINAPI BN_ResetError(void)
{
    SetMpErrno(MP_ERRNO_NO_ERROR);
}

inline DWORD WINAPI BN_MapError(BOOL fSts)
{
    DWORD dwRet = ERROR_INTERNAL_ERROR;

    if (fSts)
        dwRet = ERROR_SUCCESS;
    else if (MP_ERRNO_NO_MEMORY == GetMpErrno())
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
    else
        dwRet = (DWORD)NTE_FAIL;
    return dwRet;
}


// extern digit_t Stdcall86 sub_same(digit_tc a[], digit_tc b[], digit_t c[], DWORDC d);

inline DWORD
BN_DSA_verify_j(
    dsa_public_tc *pPubkey,
    dsa_precomputed_tc *pPrecomputed)
{
    BOOL fSts;
    BN_ResetError();
    fSts = DSA_verify_j(pPubkey, pPrecomputed);
    return BN_MapError(fSts);
}

inline DWORD
BN_DSA_check_g(
    DWORDC         lngp_digits, // In
    digit_tc       *pGModular,  // In
    mp_modulus_t   *pPModulo,   // In
    DWORDC         lngq_digits, // In
    digit_tc       *pQDigit)    // In
{
    BOOL fSts;
    BN_ResetError();
    fSts = DSA_check_g(lngp_digits, pGModular, pPModulo, lngq_digits, pQDigit);
    return BN_MapError(fSts);
}

inline DWORD
BN_DSA_parameter_verification(
    dsa_public_tc       *pPubkey,
    dsa_precomputed_tc  *pPrecomputed)
{
    BOOL fSts;
    BN_ResetError();
    fSts = DSA_parameter_verification(pPubkey, pPrecomputed);
    return BN_MapError(fSts);
}

inline DWORD
BN_DSA_precompute(
    dsa_public_tc     *pubkey,      // In
    dsa_precomputed_t *precomputed, // Out
    const BOOL         checkSC)     // In
{
    BOOL fSts;
    BN_ResetError();
    fSts = DSA_precompute(pubkey, precomputed, checkSC);
    return BN_MapError(fSts);
}

inline DWORD
BN_from_modular(
    digit_tc a[],
    digit_t b[],
    mp_modulus_tc *modulo)
{
    DWORD dwSts;
    BN_ResetError();
    dwSts = from_modular(a, b, modulo);
    if (ERROR_SUCCESS != BN_MapError(0 != dwSts))
        dwSts = 0;
    return dwSts;
}

inline DWORD
BN_mod_exp(
    digit_tc base[],
    digit_tc exponent[],
    DWORDC lngexpon,
    digit_t answer[],
    mp_modulus_tc *modulo)
{
    BN_ResetError();
    mod_exp(base, exponent, lngexpon, answer, modulo);
    return BN_MapError(TRUE);
}

inline DWORD
BN_to_modular(
    digit_tc a[],
    DWORDC lnga,
    digit_t b[],
    mp_modulus_tc *modulo)
{
    DWORD dwSts;
    BN_ResetError();
    dwSts = to_modular(a, lnga, b, modulo);
    if (ERROR_SUCCESS != BN_MapError(0 != dwSts))
        dwSts = 0;
    return dwSts;
}

inline DWORD
BN_DSA_gen_x_and_y(
    BOOL fUseQ,                 // In
    dsa_other_info *pOtherInfo, // In
    dsa_private_t *privkey)     // Out
{
    BOOL fSts;
    BN_ResetError();
    fSts = DSA_gen_x_and_y(fUseQ, pOtherInfo, privkey);
    return BN_MapError(fSts);
}

inline DWORD
BN_DSA_precompute_pgy(
    dsa_public_tc     *pubkey,      // In
    dsa_precomputed_t *precomputed) // Out
{
    BOOL fSts;
    BN_ResetError();
    fSts = DSA_precompute_pgy(pubkey, precomputed);
    return BN_MapError(fSts);
}

inline DWORD
BN_DSA_key_generation(
    DWORDC         nbitp,       // In
    DWORDC         nbitq,       // In
    dsa_other_info *pOtherInfo, // In
    dsa_private_t  *privkey)    // Out
{
    BOOL fSts;
    BN_ResetError();
    fSts = DSA_key_generation(nbitp, nbitq, pOtherInfo, privkey);
    return BN_MapError(fSts);
}

inline DWORD
BN_DSA_signature_verification(
    DWORDC              message_hash[SHA_DWORDS],
    dsa_public_tc       *pubkey,
    dsa_precomputed_tc  *precomputed_argument,
    dsa_signature_tc    *signature,
    dsa_other_info      *pOtherInfo)
{
    BOOL fSts;
    BN_ResetError();
    fSts = DSA_signature_verification(message_hash, pubkey,
                                      precomputed_argument,
                                      signature, pOtherInfo);
    return BN_MapError(fSts);
}

inline DWORD
BN_DSA_sign(
    DWORDC           message_hash[SHA_DWORDS],   /* TBD */
    dsa_private_tc   *privkey,
    dsa_signature_t  *signature,
    dsa_other_info   *pOtherInfo)
{
    BOOL fSts;
    BN_ResetError();
    fSts = DSA_sign(message_hash, privkey,  signature, pOtherInfo);
    return BN_MapError(fSts);
}

inline DWORD
BN_create_modulus(
    digit_tc a[],
    DWORDC lnga,
    reddir_tc reddir,
    mp_modulus_t *modulo)
{
    BOOL fSts;
    BN_ResetError();
    fSts = create_modulus(a, lnga, reddir, modulo);
    return BN_MapError(fSts);
}

inline DWORD
BN_DSA_key_import_fillin(
    dsa_private_t *privkey)
{
    BOOL fSts;
    BN_ResetError();
    fSts = DSA_key_import_fillin(privkey);
    return BN_MapError(fSts);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\dssinc\dh_key.h ===
/* dh_key.h */

#ifdef __cplusplus
extern "C" {
#endif

#define DH_MAX_LENGTH           0x00000200     // in bytes, 512 bytes, 4096 bits
#define DH_KEYSIZE_INC          0x40

/*********************************/
/* Definitions                   */
/*********************************/
#define DH_PUBLIC_MAGIC         0x31484400
#define DH_PRIVATE_MAGIC        0x32484400
#define DH_PUBLIC_MAGIC_VER3    0x33484400
#define DH_PRIV_MAGIC_VER3      0x34484400

/*********************************/
/* Structure Definitions         */
/*********************************/

typedef dsa_private_t DHKey_t; // use a DSA key since X 9.42 requires key
                               // gen like DSA

/*
typedef struct {
    ALG_ID      Algid;          // algorithm type of the key (SF or EPHEM)
    DH_PRIV_KEY Priv;
} DHKey_t;
*/

/*********************************/
/* Function Definitions          */
/*********************************/

// Initialize DH key
DWORD
initKeyDH(
    IN Context_t *pContext,
    IN OUT DHKey_t *pDH,
    IN ALG_ID Algid,
    IN DWORD dwFlags,
    IN BOOL fAnyLength);

DHKey_t *allocDHKey ();
void freeKeyDH (DHKey_t *dh);

// Get the DH parameters
DWORD getDHParams (
                   IN DHKey_t *dh,
                   IN DWORD param,
                   OUT BYTE *data,
                   OUT DWORD *len
                   );

// Set the DH parameters
DWORD setDHParams (
                   IN OUT DHKey_t *pDH,
                   IN DWORD dwParam,
                   IN CONST BYTE *pbData,
                   IN OUT Context_t *pContext
                   );

// Generate a dh key
DWORD dhGenerateKey (
                     IN Context_t *pContext,
                     IN OUT DHKey_t *pDH);

DWORD dhDeriveKey (DHKey_t *dh, BYTE *data, DWORD len);

// Export the DH key in blob format
DWORD exportDHKey (
                   IN Context_t *pContext,
                   IN DHKey_t *pDH,
                   IN ALG_ID Algid,
                   IN DWORD dwFlags,
                   IN DWORD dwReserved,
                   IN DWORD dwBlobType,
                   OUT BYTE *pbData,
                   OUT DWORD *pcbData,
                   IN BOOL fInternal
                   );

DWORD DHPrivBlobToKey(
                      IN Context_t *pContext,
                      IN BLOBHEADER *pBlob,
                      IN DWORD cbBlob,
                      IN DWORD dwKeysetType,
                      OUT Key_t *pPrivKey
                      );

// Import the blob into DH key
DWORD importDHKey(
                  IN OUT Key_t *pPrivKey,
                  IN Context_t *pContext,
                  IN BYTE *pbBlob,
                  IN DWORD cbBlob,
                  OUT Key_t *pKey,
                  IN DWORD dwKeysetType,
                  IN BOOL fInternal
                  );

void copyDHPubKey(
                  IN DHKey_t *pDH1,
                  IN DHKey_t *pDH2
                  );

DWORD copyDHKey(
                IN DHKey_t *pDH1,
                IN DHKey_t *pDH2,
                IN ALG_ID Algid,
                IN Context_t *pContext
                );

//
// Function : UseDHKey
//
// Description : This function creates an ephemeral DH key and then generates
//               two agreed keys, thus simulating a DH exchange.  If the
//               agreed keys are not the same then the function fails.
//

DWORD UseDHKey(
               IN Context_t *pContext,
               IN PEXPO_OFFLOAD_STRUCT pOffloadInfo,
               IN DHKey_t *pDH
               );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\dssinc\protstr.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : protstor.h                                             //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Dec  4 1996 jeffspel  Create                                       //
//      Apr 21 1997 jeffspel  Changes for NT 5 tree                        //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __PROTSTOR_H__
#define __PROTSTOR_H__

#ifdef __cplusplus
extern "C" {
#endif

extern BOOL
CheckPStoreAvailability(
    PSTORE_INFO *pPStore);

extern DWORD
CreateNewPSKeyset(
    PSTORE_INFO *pPStore,
    DWORD dwFlags);

extern DWORD
GetKeysetTypeAndSubType(
    Context_t *pContext);

extern DWORD
SetKeyTypeSubtype(
    Context_t *pContext,
    PKEY_TYPE_SUBTYPE pTypeSubtype);

extern DWORD
RestoreKeysetFromProtectedStorage(
    Context_t *pContext,
    Key_t *pKey,
    LPWSTR szPrompt,
    BOOL fSigKey,
    BOOL *pfUIOnKey);

extern DWORD
SetKeysetTypeAndSubtype(
    Context_t *pContext);

extern DWORD
SetUIPrompt(
    Context_t *pContext,
    LPWSTR szPrompt);

extern DWORD
DeleteKeyFromProtectedStorage(
    Context_t *pContext,
    PCSP_STRINGS pStrings,
    DWORD dwKeySpec,
    BOOL fMigration);

extern DWORD
DeleteFromProtectedStorage(
    IN Context_t *pContext,
    PCSP_STRINGS pStrings,
    IN BOOL fMigration);

extern void
FreePSInfo(
    PSTORE_INFO *pPStore);

#ifdef __cplusplus
}
#endif

#endif // __PROTSTOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\dssinc\key.h ===
/* key.h */

#ifdef __cplusplus
extern "C" {
#endif

// needs to be put into wincrypt.h or left open in wincrypt.h
#define     KP_Z                    30
#define     IPSEC_FLAG_CHECK        0xF42A19B6

static BYTE rgbSymmetricKeyWrapIV[8] = {0x4a, 0xdd, 0xa2, 0x2c, 0x79, 0xe8, 0x21, 0x05};

/*********************************/
/* Function Definitions          */
/*********************************/

extern void
UnpickleKey(
    ALG_ID Algid,
    BYTE *pbData,
    DWORD cbData,
    BOOL *pfExportable,
    Key_t *pKey);

extern Key_t *
allocKey(
    void);

// Delete a key
extern void
freeKey(
    IN OUT Key_t *key);

// Copy a public key
extern void
CopyPubKey(
    IN Key_t *pKeyIn,
    OUT Key_t *pKeyOut);

// Initialize a key
extern DWORD
initKey(
    IN OUT Key_t *key,
    IN Context_t *pContext,
    IN ALG_ID algId,
    IN DWORD dwFlags);

extern BOOL
checkKey(
    Key_t *key);

// Derive key
// if the pHash parameter is non zero and the key to be derived is a
// 3 Key triple DES key, then the data is expanded to the appropriate key size
extern DWORD
deriveKey(
    Key_t *pKey,
    Context_t *pContext,
    BYTE *pbData,
    DWORD cbData,
    DWORD dwFlags,
    Hash_t *pHash,
    BOOL fGenKey,
    BOOL fAnySizeRC2);

// generate a key
extern DWORD
generateKey(
    IN OUT Key_t *pKey,
    IN DWORD dwFlags,
    IN OUT uchar *pbRandom,
    IN DWORD cbRandom,
    IN Context_t *pContext);

// duplicate a key
extern DWORD
DuplicateKey(
    Context_t *pContext,
    Key_t *pKey,
    Key_t *pNewKey,
    BOOL fCopyContext);

// set the parameters on a key
extern DWORD
setKeyParams(
    IN OUT Key_t *pKey,
    IN DWORD dwParam,
    IN CONST BYTE *pbData,
    IN OUT Context_t *pContext,
    IN DWORD dwFlags);

extern DWORD
getKeyParams(
    IN Context_t *pContext,
    IN Key_t *key,
    IN DWORD param,
    IN DWORD dwFlags,
    OUT BYTE *data,
    OUT DWORD *len);

extern DWORD
ImportOpaqueBlob(
    Context_t *pContext,
    CONST BYTE *pbData,
    DWORD cbData,
    HCRYPTKEY *phKey);

// Export the requested key into blob format
extern DWORD
exportKey(
    IN Context_t *pContext,
    IN Key_t *pKey,
    IN Key_t *pEncKey,
    IN DWORD dwBlobType,
    IN DWORD dwFlags,
    OUT BYTE *pbBlob,
    OUT DWORD *pcbBlob,
    IN BOOL fInternalExport);

extern DWORD
feedPlainText(
    Key_t *pKey,
    BYTE *pbData,
    DWORD dwBufLen,
    DWORD *pdwDataLen,
    int final);

extern DWORD
feedCypherText(
    Key_t *pKey,
    BYTE *pbData,
    DWORD *pdwDataLen,
    int final);

extern DWORD
generateSignature(
    IN Context_t *pContext,
    IN Key_t *key,
    IN uchar *hashVal,
    OUT uchar *pbSignature,
    OUT DWORD *pdwSigLen);

// Verify signature
extern DWORD
verifySignature(
    IN Context_t *pContext,
    IN Key_t *pKey,
    IN uchar *pbHash,
    IN DWORD cbHash,
    IN uchar *pbSignature,
    IN DWORD cbSignature);

extern DWORD
BlockEncrypt(
    void EncFun(BYTE *In, BYTE *Out, void *key, int op),
    Key_t *pKey,
    int BlockLen,
    BOOL Final,
    BYTE  *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen);

extern DWORD
BlockDecrypt(
    void DecFun(BYTE *In, BYTE *Out, void *key, int op),
    Key_t *pKey,
    int BlockLen,
    BOOL Final,
    BYTE  *pbData,
    DWORD *pdwDataLen);

//
// Function : TestSymmetricAlgorithm
//
// Description : This function expands the passed in key buffer for the appropriate algorithm,
//               encrypts the plaintext buffer with the same algorithm and key, and the
//               compares the passed in expected ciphertext with the calculated ciphertext
//               to make sure they are the same.  The function only uses ECB mode for
//               block ciphers and the plaintext buffer must be the same length as the
//               ciphertext buffer.  The length of the plaintext must be either the
//               the block length of the cipher if it is a block cipher or less
//               than MAX_BLOCKLEN if a stream cipher is being used.
//
extern DWORD
TestSymmetricAlgorithm(
    IN ALG_ID Algid,
    IN CONST BYTE *pbKey,
    IN DWORD cbKey,
    IN CONST BYTE *pbPlaintext,
    IN DWORD cbPlaintext,
    IN CONST BYTE *pbCiphertext,
    IN CONST BYTE *pbIV);

/*
 -  GetRC4KeyForSymWrap
 -
 *  Purpose:
 *            RC4 or more precisely stream ciphers are not supported by the CMS spec
 *            on symmetric key wrapping so we had to do something proprietary since
 *            we want to support RC4 for applications other than SMIME
 *
 *
 *  Parameters:
 *               IN  pContext   - Pointer to the context
 *               IN  pbSalt     - Pointer to the 8 byte salt buffer
 *               IN  pKey       - Pointer to the orignial key
 *               OUT ppNewKey   - Pointer to a pointer to the new key
 */
extern DWORD
GetRC4KeyForSymWrap(
    IN Context_t *pContext,
    IN BYTE *pbSalt,
    IN Key_t *pKey,
    OUT Key_t **ppNewKey);

/*
 -  GetSymmetricKeyChecksum
 -
 *  Purpose:
 *                Calculates the checksum for a symmetric key which is to be
 *                wrapped with another symmetric key.  This should meet the
 *                CMS specification
 *
 *
 *  Parameters:
 *               IN  pKey       - Pointer to the key
 *               OUT pbChecksum - Pointer to the 8 byte checksum
 */
extern void
GetSymmetricKeyChecksum(
    IN BYTE *pbKey,
    IN DWORD cbKey,
    OUT BYTE *pbChecksum);

// check for symmetric wrapping support
#define UnsupportedSymKey(pKey) ((CALG_RC4 != pKey->algId) && \
                                 (CALG_RC2 != pKey->algId) && \
                                 (CALG_DES != pKey->algId) && \
                                 (CALG_CYLINK_MEK != pKey->algId) && \
                                 (CALG_3DES != pKey->algId) && \
                                 (CALG_3DES_112 != pKey->algId))

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\dssinc\dss_key.h ===
#ifdef __cplusplus
extern "C" {
#endif

/* dss_key.h */

#define DSS_KEYSIZE_INC       64

/*********************************/
/* Definitions                   */
/*********************************/
#define DSS_MAGIC           0x31535344
#define DSS_PRIVATE_MAGIC   0x32535344
#define DSS_PUB_MAGIC_VER3  0x33535344
#define DSS_PRIV_MAGIC_VER3 0x34535344

/*********************************/
/* Structure Definitions         */
/*********************************/

typedef dsa_private_t DSSKey_t;

/*********************************/
/* Function Definitions          */
/*********************************/

extern DSSKey_t *
allocDSSKey(
    void);

extern void
freeKeyDSS(
    DSSKey_t *dss);

extern DWORD
initKeyDSS(
    IN Context_t *pContext,
    IN ALG_ID Algid,
    IN OUT DSSKey_t *pDss,
    IN DWORD dwBitLen);

// Generate the DSS keys
extern DWORD
genDSSKeys(
    IN Context_t *pContext,
    IN OUT DSSKey_t *pDss);

extern void
copyDSSPubKey(
    IN DSSKey_t *dss1,
    IN DSSKey_t *dss2);

extern void
copyDSSKey(
    IN DSSKey_t *dss1,
    IN DSSKey_t *dss2);

extern DWORD
getDSSParams(
    DSSKey_t *dss,
    DWORD param,
    BYTE *data,
    DWORD *len);

extern DWORD
setDSSParams(
    IN Context_t *pContext,
    IN OUT DSSKey_t *pDss,
    IN DWORD dwParam,
    IN CONST BYTE *pbData);

extern BOOL
DSSValueExists(
    IN DWORD *pdw,
    IN DWORD cdw,
    OUT DWORD *pcb);

extern DWORD
ExportDSSPrivBlob3(
    IN Context_t *pContext,
    IN DSSKey_t *pDSS,
    IN DWORD dwMagic,
    IN ALG_ID Algid,
    IN BOOL fInternalExport,
    IN BOOL fSigKey,
    OUT BYTE *pbKeyBlob,
    IN OUT DWORD *pcbKeyBlob);

extern DWORD
ImportDSSPrivBlob3(
    IN BOOL fInternalExport,
    IN CONST BYTE *pbKeyBlob,
    IN DWORD cbKeyBlob,
    OUT DSSKey_t *pDSS);

extern DWORD
ExportDSSPubBlob3(
    IN DSSKey_t *pDSS,
    IN DWORD dwMagic,
    IN ALG_ID Algid,
    OUT BYTE *pbKeyBlob,
    IN OUT DWORD *pcbKeyBlob);

extern DWORD
ImportDSSPubBlob3(
    IN CONST BYTE *pbKeyBlob,
    IN DWORD cbKeyBlob,
    IN BOOL fYIncluded,
    OUT DSSKey_t *pDSS);

// Export DSS key into blob format
extern DWORD
exportDSSKey(
    IN Context_t *pContext,
    IN DSSKey_t *pDSS,
    IN DWORD dwFlags,
    IN DWORD dwBlobType,
    IN BYTE *pbKeyBlob,
    IN DWORD *pcbKeyBlob,
    IN BOOL fInternalExport);

// Import the blob into DSS key
extern DWORD
importDSSKey(
    IN Context_t *pContext,
    IN Key_t *pKey,
    IN CONST BYTE *pbKeyBlob,
    IN DWORD cbKeyBlob,
    IN DWORD dwKeysetType,
    IN BOOL fInternal);

extern DWORD
dssGenerateSignature(
    Context_t *pContext,
    DSSKey_t *pDss,
    BYTE *pbHash,
    BYTE *pbSig,
    DWORD *pcbSig);

//
// Function : SignAndVerifyWithKey
//
// Description : This function creates a hash and then signs that hash with
//               the passed in key and verifies the signature.  The function
//               is used for FIPS 140-1 compliance to make sure that newly
//               generated/imported keys work and in the self test during
//               DLL initialization.
//

extern DWORD
SignAndVerifyWithKey(
    IN DSSKey_t *pDss,
    IN EXPO_OFFLOAD_STRUCT *pOffloadInfo,
    IN HANDLE hRNGDriver,
    IN BYTE *pbData,
    IN DWORD cbData);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\dssinc\hash.h ===
/* hash.h */

/*********************************/
/* Function Definitions          */
/*********************************/

#ifdef CSP_USE_MD5
//
// Function : TestMD5
//
// Description : This function hashes the passed in message with the MD5 hash
//               algorithm and returns the resulting hash value.
//
BOOL TestMD5(
             BYTE *pbMsg,
             DWORD cbMsg,
             BYTE *pbHash
             );
#endif // CSP_USE_MD5

#ifdef CSP_USE_SHA1
//
// Function : TestSHA1
//
// Description : This function hashes the passed in message with the SHA1 hash
//               algorithm and returns the resulting hash value.
//
BOOL TestSHA1(
              BYTE *pbMsg,
              DWORD cbMsg,
              BYTE *pbHash
              );
#endif // CSP_USE_SHA1

Hash_t *allocHash ();
void freeHash (Hash_t *hash);

DWORD feedHashData (Hash_t *hash, BYTE *data, DWORD len);
DWORD finishHash (Hash_t *hash, BYTE *pbData, DWORD *len);
DWORD getHashParams (Hash_t *hash, DWORD param, BYTE *pbData, DWORD *len);
DWORD setHashParams (Hash_t *hash, DWORD param, CONST BYTE *pbData);

DWORD DuplicateHash(
                    Hash_t *pHash,
                    Hash_t *pNewHash
                    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\dssinc\schderiv.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : schderiv.h                                             //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Oct  9 1997 jeffspel  Create                                       //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __SCHDERIV_H__
#define __SCHDERIV_H__

#ifdef __cplusplus
extern "C" {
#endif

#define     RC_KEYLEN            16
#define     MAX_PREMASTER_LEN   512  // DH key must be <= 4096 bits
#define     MAX_RANDOM_LEN      256

#define     TLS_MASTER_LEN       48
#define     SSL3_MASTER_LEN      48

// definition of a Secure Channel hash structure
typedef struct _SCH_KeyData
{
    BYTE        rgbPremaster[MAX_PREMASTER_LEN];
    DWORD       cbPremaster;
    BYTE        rgbClientRandom[MAX_RANDOM_LEN];
    DWORD       cbClientRandom;
    BYTE        rgbServerRandom[MAX_RANDOM_LEN];
    DWORD       cbServerRandom;
    ALG_ID      EncAlgid;
    ALG_ID      HashAlgid;
    DWORD       cbEnc;
    DWORD       cbEncMac;
    DWORD       cbHash;
    DWORD       cbIV;
    BOOL        fFinished;
    BOOL        dwFlags;
} SCH_KEY, *PSCH_KEY;

// definition of a Secure Channel hash structure
typedef struct _SCH_HashData
{
    ALG_ID      ProtocolAlgid;
    ALG_ID      EncAlgid;
    ALG_ID      HashAlgid;
    DWORD       cbEnc;
    DWORD       cbEncMac;
    DWORD       cbHash;
    DWORD       cbIV;
    BYTE        rgbClientRandom[MAX_RANDOM_LEN];
    DWORD       cbClientRandom;
    BYTE        rgbServerRandom[MAX_RANDOM_LEN];
    DWORD       cbServerRandom;
    BYTE        rgbFinal[MAX_RANDOM_LEN];
    DWORD       cbFinal;
    BOOL        dwFlags;
} SCH_HASH, *PSCH_HASH;

// definition of a TLS1 PRF hash structure
typedef struct _PRF_HashData
{
    BYTE        rgbLabel[MAX_RANDOM_LEN];
    DWORD       cbLabel;
    BYTE        rgbSeed[MAX_RANDOM_LEN];
    DWORD       cbSeed;
    BYTE        rgbMasterKey[TLS_MASTER_LEN];
} PRF_HASH;

extern DWORD
SCHSetKeyParam(
    IN Context_t *pContext,
    IN Key_t *pKey,
    IN DWORD dwParam,
    IN CONST BYTE *pbData);

extern BOOL
SCHGetKeyParam(
    Key_t *pKey,
    DWORD dwParam,
    PBYTE pbData);

extern DWORD
SChGenMasterKey(
    Key_t *pKey,
    PSCH_HASH pSChHash);

extern DWORD
SecureChannelDeriveKey(
    Hash_t *pHash,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

extern DWORD
SetPRFHashParam(
    PRF_HASH *pPRFHash,
    DWORD dwParam,
    CONST BYTE *pbData);

extern DWORD
CalculatePRF(
    PRF_HASH *pPRFHash,
    BYTE *pbData,
    DWORD *pcbData);

#ifdef __cplusplus
}
#endif

#endif // __SCHDERIV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\dssinc\queue.h ===
/* queue.h */

/*********************************/
/* Definitions                   */
/*********************************/

#define		QUEUE_MAGIC	0xBADD



/*********************************/
/* Structure Definitions         */
/*********************************/

typedef struct {
	void		*next;				// Next element
	void		*prev;				// Previous element
	void		*data;				// Data
} Element_t;

typedef struct {
	Element_t	*elem;				// Next element to be returned
} Iter_t;

typedef struct {
	int			magic;				// Magic number
	Element_t	*head;				// Head of queue
	Element_t	*tail;				// End of queue
	long		count;				// Number of entries
	long		mark;				// Watermark
} Queue_t;


/*********************************/
/* Function Definitions          */
/*********************************/
Element_t *elementAlloc();
void elementFree(Element_t *element);
void queueInit (Queue_t *queue);
Element_t *queueAdd (Queue_t *queue, Element_t *element);
Element_t *queueRemove (Queue_t *queue, Element_t *element);
void queueFree (Queue_t *queue);
void iterInit (Queue_t *queue, Iter_t *iter);
Element_t *queueIterate (Iter_t *iter);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\dssinc\reg.h ===
/* reg.h */

#ifdef __cplusplus
extern "C" {
#endif

/*********************************/
/* Definitions                   */
/*********************************/

/*********************************/
/* Structure Definitions         */
/*********************************/


/*********************************/
/* Function Definitions          */
/*********************************/

extern DWORD
OpenUserKeyGroup(
    Context_t *pContext,
    LPSTR szUserName,
    DWORD dwFlags);

extern DWORD
openKeyGroup(
    IN OUT Context_t *pContext);

extern DWORD
closeKeyGroup(
    IN Context_t *pContext);

// Delete the user group
extern DWORD
DeleteOldKeyGroup(
    IN Context_t *pContext,
    IN BOOL fMigration);

extern DWORD
DeleteKeyGroup(
IN Context_t *pContext);

extern DWORD
readKey(
    HKEY hLoc,
    char *pszName,
    BYTE **Data,
    DWORD *pcbLen);

extern DWORD
saveKey(
    HKEY hLoc,
    CONST char *pszName,
    void *Data,
    DWORD dwLen);

extern void
CheckKeySetType(
    Context_t *pContext);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\dssinc\user.h ===
/* user.h */

/*********************************/
/* Definitions                   */
/*********************************/


/*********************************/
/* Structure Definitions         */
/*********************************/


/*********************************/
/* Function Definitions          */
/*********************************/

extern DWORD
logonUser(
    LPCSTR pszUserID,
    DWORD dwFlags,
    DWORD dwProvType,
    LPCSTR szProvName,
    HCRYPTPROV *phUID);

extern DWORD
logoffUser(
    Context_t *context);

// Read the user record
extern DWORD
readUserKeys(
    IN Context_t *pContext,
    IN DWORD dwKeysetType);

extern DWORD
writeUserKeys(
    Context_t *context);

//
// Routine : ProtectPrivKey
//
// Description : Encrypts the private key and persistently stores it.
//

extern DWORD
ProtectPrivKey(
    IN OUT Context_t *pContext,
    IN LPWSTR szPrompt,
    IN DWORD dwFlags,
    IN BOOL fSigKey);

//
// Routine : UnprotectPrivKey
//
// Description : Decrypts the private key.  If the fAlwaysDecrypt flag is set
//               then it checks if the private key is already in the buffer
//               and if so then it does not decrypt.
//

extern DWORD
UnprotectPrivKey(
    IN OUT Context_t *pContext,
    IN LPWSTR szPrompt,
    IN BOOL fSigKey,
    IN BOOL fAlwaysDecrypt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\fips\driver\algself.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : fipslib.c                                              //
//  DESCRIPTION   : FIPS 140 support code.                                 //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Oct 20 1999 jeffspel/ramas  Merge STT into default CSP             //
//                                                                         //
//  Copyright (C) 2000 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincrypt.h>

#ifdef KERNEL_MODE
#if WINVER == 0x0500
#include <ntos.h>
#else
#include <ntosp.h>
#endif
#endif

#include <sha.h>
#include <des.h>
#include <tripldes.h>
#include <modes.h>

// known result of an SHA-1 hash on the above buffer
static UCHAR rgbKnownSHA1[] =
{
0xe8, 0x96, 0x82, 0x85, 0xeb, 0xae, 0x01, 0x14,
0x73, 0xf9, 0x08, 0x45, 0xc0, 0x6a, 0x6d, 0x3e,
0x69, 0x80, 0x6a, 0x0c
};

// IV for all block ciphers
UCHAR rgbIV[] = {0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF};

// known key, plaintext, and ciphertext for DES
UCHAR rgbDESKey[] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef};
UCHAR rgbDESKnownPlaintext[] = {0x4E, 0x6F, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74};
UCHAR rgbDESKnownCiphertext[] = {0x3F, 0xA4, 0x0E, 0x8A, 0x98, 0x4D, 0x48, 0x15};
UCHAR rgbDESCBCCiphertext[] = {0xE5, 0xC7, 0xCD, 0xDE, 0x87, 0x2B, 0xF2, 0x7C};

// known key, plaintext, and ciphertext for 3 key 3DES
UCHAR rgb3DESKey[] =
{
0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23
};
UCHAR rgb3DESKnownPlaintext[] = {0x4E, 0x6F, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74};
UCHAR rgb3DESKnownCiphertext[] = {0x31, 0x4F, 0x83, 0x27, 0xFA, 0x7A, 0x09, 0xA8};
UCHAR rgb3DESCBCCiphertext[] = {0xf3, 0xc0, 0xff, 0x02, 0x6c, 0x02, 0x30, 0x89};

// known key, plaintext, and ciphertext for 2 key 3DES
UCHAR rgb3DES112Key[] =
{
0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01
};
UCHAR rgb3DES112KnownPlaintext[] = {0x4E, 0x6F, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74};
UCHAR rgb3DES112KnownCiphertext[] = {0xb7, 0x83, 0x57, 0x79, 0xee, 0x26, 0xac, 0xb7};
UCHAR rgb3DES112CBCCiphertext[] = {0x13, 0x4b, 0x98, 0xf8, 0xee, 0xb3, 0xf6, 0x07};

#define MAX_BLOCKLEN        8
#define MAXKEYSTRUCTSIZE    DES3_TABLESIZE // currently the max is a 3DES key structure

// Known answer test for SHA HMAC from Fips draft
UCHAR rgbHmacKey []         = {
    0x01, 0x02, 0x03, 0x04, 0x05,
    0x06, 0x07, 0x08, 0x09, 0x0a,
    0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    0x10, 0x11, 0x12, 0x13, 0x14,
    0x15, 0x16, 0x17, 0x18, 0x19
};
UCHAR rgbHmacData [50];     // set bytes to 0xcd
UCHAR rgbHmac []            = {
    0x4c, 0x90, 0x07, 0xf4, 0x02,
    0x62, 0x50, 0xc6, 0xbc, 0x84,
    0x14, 0xf9, 0xbf, 0x50, 0xc8,
    0x6c, 0x2d, 0x72, 0x35, 0xda
};

extern VOID FipsHmacSHAInit(
    OUT A_SHA_CTX *pShaCtx,
    IN UCHAR *pKey,
    IN unsigned int cbKey
    );

extern VOID FipsHmacSHAUpdate(
    IN OUT A_SHA_CTX *pShaCtx,
    IN UCHAR *pb,
    IN unsigned int cb
    );

extern VOID FipsHmacSHAFinal(
    IN A_SHA_CTX *pShaCtx,
    IN UCHAR *pKey,
    IN unsigned int cbKey,
    OUT UCHAR *pHash
    ); 

//
// Function : TestSHA1
//
// Description : This function hashes the passed in message with the SHA1 hash
//               algorithm and returns the resulting hash value.
//
void TestSHA1(
              UCHAR *pbMsg,
              ULONG cbMsg,
              UCHAR *pbHash
              )
{
    A_SHA_CTX   HashContext;

    // Initialize SHA
    A_SHAInit(&HashContext);

    // Compute SHA 
    A_SHAUpdate(&HashContext, pbMsg, cbMsg);

    A_SHAFinal(&HashContext, pbHash);
}

//
// Function : TestEncDec
//
// Description : This function expands the passed in key buffer for the appropriate
//               algorithm, and then either encryption or decryption is performed.
//               A comparison is then made to see if the ciphertext or plaintext
//               matches the expected value.
//               The function only uses ECB mode for block ciphers and the plaintext
//               buffer must be the same length as the ciphertext buffer.  The length
//               of the plaintext must be either the block length of the cipher if it
//               is a block cipher or less than MAX_BLOCKLEN if a stream cipher is
//               being used.
//
NTSTATUS TestEncDec(
                IN ALG_ID Algid,
                IN UCHAR *pbKey,
                IN ULONG cbKey,
                IN UCHAR *pbPlaintext,
                IN ULONG cbPlaintext,
                IN UCHAR *pbCiphertext,
                IN UCHAR *pbIV,
                IN int iOperation
                )
{
    UCHAR    rgbExpandedKey[MAXKEYSTRUCTSIZE];
    UCHAR    rgbBuffIn[MAX_BLOCKLEN];
    UCHAR    rgbBuffOut[MAX_BLOCKLEN];
    ULONG    i;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    RtlZeroMemory(rgbExpandedKey, sizeof(rgbExpandedKey));
    RtlZeroMemory(rgbBuffIn, sizeof(rgbBuffIn));
    RtlZeroMemory(rgbBuffOut, sizeof(rgbBuffOut));

    // length of data to encrypt must be < MAX_BLOCKLEN 
    if (cbPlaintext > MAX_BLOCKLEN)
    {
        goto Ret;
    }

    // alloc for and expand the key
    switch(Algid)
    {
        case (CALG_DES):
        {
            desparityonkey(pbKey, cbKey);
            deskey((DESTable*)rgbExpandedKey, pbKey);
            break;
        }

        case (CALG_3DES):
        {
            desparityonkey(pbKey, cbKey);
            tripledes3key((PDES3TABLE)rgbExpandedKey, pbKey);
            break;
        }

        case (CALG_3DES_112):
        {
            desparityonkey(pbKey, cbKey);
            tripledes2key((PDES3TABLE)rgbExpandedKey, pbKey);
            break;
        }
    }

    // if encrypting and there is an IV then use it
    if (ENCRYPT == iOperation)
    {
        memcpy(rgbBuffIn, pbPlaintext, cbPlaintext);

        if (NULL != pbIV)
        {
            for(i = 0; i < cbPlaintext; i++)
            {
                rgbBuffIn[i] = rgbBuffIn[i] ^ pbIV[i];
            }
        }
    }

    // encrypt the plaintext
    switch(Algid)
    {
        case (CALG_DES):
        {
            if (ENCRYPT == iOperation)
            {
                des(rgbBuffOut, rgbBuffIn, rgbExpandedKey, ENCRYPT);
            }
            else
            {
                des(rgbBuffOut, pbCiphertext, rgbExpandedKey, DECRYPT);
            }
            break;
        }

        case (CALG_3DES):
        case (CALG_3DES_112):
        {
            if (ENCRYPT == iOperation)
            {
                tripledes(rgbBuffOut, rgbBuffIn, rgbExpandedKey, ENCRYPT);
            }
            else
            {
                tripledes(rgbBuffOut, pbCiphertext, rgbExpandedKey, DECRYPT);
            }
            break;
        }
    }

    // compare the encrypted plaintext with the passed in ciphertext
    if (ENCRYPT == iOperation)
    {
        if (memcmp(pbCiphertext, rgbBuffOut, cbPlaintext))
        {
            goto Ret;
        }
    }
    // compare the decrypted ciphertext with the passed in plaintext
    else
    {
        // if there is an IV then use it
        if (NULL != pbIV)
        {
            for(i = 0; i < cbPlaintext; i++)
            {
                rgbBuffOut[i] = rgbBuffOut[i] ^ pbIV[i];
            }
        }

        if (memcmp(pbPlaintext, rgbBuffOut, cbPlaintext))
        {
            goto Ret;
        }
    }

    Status = STATUS_SUCCESS;
Ret:
    return Status;
}

//
// Function : TestSymmetricAlgorithm
//
// Description : This function expands the passed in key buffer for the appropriate algorithm,
//               encrypts the plaintext buffer with the same algorithm and key, and the
//               compares the passed in expected ciphertext with the calculated ciphertext
//               to make sure they are the same.  The opposite is then done with decryption.
//               The function only uses ECB mode for block ciphers and the plaintext
//               buffer must be the same length as the ciphertext buffer.  The length
//               of the plaintext must be either the block length of the cipher if it
//               is a block cipher or less than MAX_BLOCKLEN if a stream cipher is
//               being used.
//
NTSTATUS TestSymmetricAlgorithm(
                            IN ALG_ID Algid,
                            IN UCHAR *pbKey,
                            IN ULONG cbKey,
                            IN UCHAR *pbPlaintext,
                            IN ULONG cbPlaintext,
                            IN UCHAR *pbCiphertext,
                            IN UCHAR *pbIV
                            )
{
    NTSTATUS  Status = STATUS_UNSUCCESSFUL;

    Status = TestEncDec(Algid, pbKey, cbKey, pbPlaintext, cbPlaintext,
                        pbCiphertext, pbIV, ENCRYPT);
    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    Status = TestEncDec(Algid, pbKey, cbKey, pbPlaintext, cbPlaintext,
                        pbCiphertext, pbIV, DECRYPT);
    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }
Ret:
    return Status;
}



// **********************************************************************
// AlgorithmCheck performs known answer tests using the algorithms
// supported by the provider.
// **********************************************************************
NTSTATUS AlgorithmCheck()
{
    UCHAR        rgbSHA1[A_SHA_DIGEST_LEN]; 
    NTSTATUS    Status = STATUS_UNSUCCESSFUL;
    A_SHA_CTX    ShaCtx;
    ULONG        ul;

    RtlZeroMemory(rgbSHA1, sizeof(rgbSHA1));

    // known answer test with SHA-1  (this function is found in hash.c)
    TestSHA1("HashThis", 8, rgbSHA1);
    if (!RtlEqualMemory(rgbSHA1, rgbKnownSHA1, sizeof(rgbSHA1)))
    {
        goto Ret;
    }

    // known answer test with DES - ECB
    Status = TestSymmetricAlgorithm(CALG_DES, rgbDESKey, sizeof(rgbDESKey),
                                rgbDESKnownPlaintext,
                                sizeof(rgbDESKnownPlaintext),
                                rgbDESKnownCiphertext,
                                NULL);
    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }
    // known answer test with DES - CBC
    Status = TestSymmetricAlgorithm(CALG_DES, rgbDESKey, sizeof(rgbDESKey),
                                    rgbDESKnownPlaintext,
                                    sizeof(rgbDESKnownPlaintext),
                                    rgbDESCBCCiphertext,
                                    rgbIV);
    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    // known answer test with 3DES - ECB
    Status = TestSymmetricAlgorithm(CALG_3DES, rgb3DESKey, sizeof(rgb3DESKey),
                                    rgb3DESKnownPlaintext,
                                    sizeof(rgb3DESKnownPlaintext),
                                    rgb3DESKnownCiphertext,
                                    NULL);
    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    // known answer test with 3DES - CBC
    Status = TestSymmetricAlgorithm(CALG_3DES, rgb3DESKey, sizeof(rgb3DESKey),
                                    rgb3DESKnownPlaintext,
                                    sizeof(rgb3DESKnownPlaintext),
                                    rgb3DESCBCCiphertext,
                                    rgbIV);
    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    // known answer test with 3DES 112 - ECB
    Status = TestSymmetricAlgorithm(CALG_3DES_112, rgb3DES112Key,
                                    sizeof(rgb3DES112Key),
                                    rgb3DES112KnownPlaintext,
                                    sizeof(rgb3DES112KnownPlaintext),
                                    rgb3DES112KnownCiphertext,
                                    NULL);
    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    Status = TestSymmetricAlgorithm(CALG_3DES_112, rgb3DES112Key,
                                    sizeof(rgb3DES112Key),
                                    rgb3DES112KnownPlaintext,
                                    sizeof(rgb3DES112KnownPlaintext),
                                    rgb3DES112CBCCiphertext,
                                    rgbIV);
    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    // Known answer test for SHA-HMAC
    RtlZeroMemory(rgbSHA1, sizeof(rgbSHA1));
    RtlZeroMemory(&ShaCtx, sizeof(ShaCtx));
    
    for (ul = 0; ul < sizeof(rgbHmacData); ul++)
        rgbHmacData[ul] = 0xcd;

    FipsHmacSHAInit(&ShaCtx, rgbHmacKey, sizeof(rgbHmacKey));
    FipsHmacSHAUpdate(&ShaCtx, rgbHmacData, sizeof(rgbHmacData));
    FipsHmacSHAFinal(&ShaCtx, rgbHmacKey, sizeof(rgbHmacKey), rgbSHA1);

    if (! RtlEqualMemory(rgbSHA1, rgbHmac, sizeof(rgbHmac)))
        goto Ret;

    Status = STATUS_SUCCESS;
Ret:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\fips\driver\fipsapi.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : fipsdll.c                                              //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Nov 29 1999 jeffspel Created                                       //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <ntddk.h>
#include <fipsapi.h>
#include <rsa_fast.h>
#include <rsa_math.h>
#include <randlib.h>

//
//     Fill in the DESTable struct with the decrypt and encrypt
//     key expansions.
//
//     Assumes that the second parameter points to DES_BLOCKLEN
//     bytes of key.
//
//

#pragma alloc_text(PAGER32C, FipsDesKey)
#pragma alloc_text(PAGER32C, FipsDes)
#pragma alloc_text(PAGER32C, Fips3Des3Key)
#pragma alloc_text(PAGER32C, Fips3Des)
#pragma alloc_text(PAGER32C, FipsSHAInit)
#pragma alloc_text(PAGER32C, FipsSHAUpdate)
#pragma alloc_text(PAGER32C, FipsSHAFinal)
#pragma alloc_text(PAGER32C, FipsCBC)
#pragma alloc_text(PAGER32C, FIPSGenRandom)
#pragma alloc_text(PAGER32C, FipsCBC)
#pragma alloc_text(PAGER32C, FIPSGenRandom)
#pragma alloc_text(PAGER32C, FipsBlockCBC)
#pragma alloc_text(PAGER32C, FipsHmacSHAInit)
#pragma alloc_text(PAGER32C, FipsHmacSHAUpdate)
#pragma alloc_text(PAGER32C, FipsHmacSHAFinal)
#pragma alloc_text(PAGER32C, HmacMD5Init)
#pragma alloc_text(PAGER32C, HmacMD5Update)
#pragma alloc_text(PAGER32C, HmacMD5Final)

void *
__stdcall
RSA32Alloc(
    unsigned long cb
    )
{
    return (void *)ExAllocatePool(PagedPool, cb);
}

void
__stdcall
RSA32Free(
    void *pv
    )
{
    ExFreePool( pv );
}

VOID FipsDesKey(DESTable *DesTable, UCHAR *pbKey)
{
    UCHAR rgbTmpKey[DES_KEYSIZE];

    RtlCopyMemory(rgbTmpKey, pbKey, DES_KEYSIZE);

    deskey(DesTable, rgbTmpKey);

    RtlZeroMemory(rgbTmpKey, DES_KEYSIZE);
}

//
//     Encrypt or decrypt with the key in DESTable
//
//

VOID FipsDes(UCHAR *pbOut, UCHAR *pbIn, void *pKey, int iOp)
{
    DESTable TmpDESTable;

    RtlCopyMemory(&TmpDESTable, pKey, sizeof(DESTable));

    des(pbOut, pbIn, &TmpDESTable, iOp);
    RtlZeroMemory(&TmpDESTable, sizeof(DESTable));
}

//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 3 * DES_BLOCKLEN
//   bytes of key.
//
//

VOID Fips3Des3Key(PDES3TABLE pDES3Table, UCHAR *pbKey)
{
    UCHAR rgbTmpKey[DES3_KEYSIZE];

    RtlCopyMemory(rgbTmpKey, pbKey, DES3_KEYSIZE);

    tripledes3key(pDES3Table, rgbTmpKey);
    RtlZeroMemory(rgbTmpKey, DES3_KEYSIZE);
}

//
//   Encrypt or decrypt with the key in pKey
//

VOID Fips3Des(UCHAR *pbIn, UCHAR *pbOut, void *pKey, int op)
{
    DES3TABLE Tmp3DESTable;

    RtlCopyMemory(&Tmp3DESTable, pKey, sizeof(DES3TABLE));

    tripledes(pbIn, pbOut, &Tmp3DESTable, op);
    RtlZeroMemory(&Tmp3DESTable, sizeof(DES3TABLE));
}

//
//   Initialize the SHA context.
//

VOID FipsSHAInit(A_SHA_CTX *pShaCtx)
{
    A_SHAInit(pShaCtx);
}

//
//   Hash data into the hash context.
//

VOID FipsSHAUpdate(A_SHA_CTX *pShaCtx, UCHAR *pb, unsigned int cb)
{
    A_SHAUpdate(pShaCtx, pb, cb);
}

//
//   Finish the SHA hash and copy the final hash value into the pbHash out param.
//

VOID FipsSHAFinal(A_SHA_CTX *pShaCtx, UCHAR *pbHash)
{
    A_SHAFinal(pShaCtx, pbHash);
}

typedef void (*FIPSCIPHER)(UCHAR*, UCHAR*, void*, int);

//
// FipsCBC (cipher block chaining) performs a XOR of the feedback register
// with the plain text before calling the block cipher
//
// NOTE - Currently this function assumes that the block length is
// DES_BLOCKLEN (8 bytes).
//
// Return: Failure if FALSE is returned, TRUE if it succeeded.
//

BOOL FipsCBC(
        ULONG  EncryptionAlg,
        PBYTE  pbOutput,
        PBYTE  pbInput,
        void   *pKeyTable,
        int    Operation,
        PBYTE  pbFeedback
        )
{
    UCHAR rgbTmpKeyTable[DES3_TABLESIZE]; // 3DES is the max table size
    ULONG cbKeyTable;
    FIPSCIPHER FipsCipher;
    BOOL fRet = TRUE;
    PBYTE pbOutputSave = NULL, pbInputSave = NULL, pbFeedbackSave = NULL;
    UINT64 OutputAlignedBuffer, InputAlignedBuffer, FeedbackAlignedBuffer;

#ifdef IA64
#define ALIGNMENT_BOUNDARY 7
#else
#define ALIGNMENT_BOUNDARY 3
#endif

    // align input buffer
    if ((ULONG_PTR) pbInput & ALIGNMENT_BOUNDARY) {

        InputAlignedBuffer = *(UINT64 UNALIGNED *) pbInput;
        pbInputSave = pbInput;

        if (pbOutput == pbInput) {

            pbOutput = (PBYTE) &InputAlignedBuffer;
        }

        pbInput = (PBYTE) &InputAlignedBuffer;
    } 

    // align output buffer
    if ((ULONG_PTR) pbOutput & ALIGNMENT_BOUNDARY) {

        OutputAlignedBuffer = *(UINT64 UNALIGNED *) pbOutput;
        pbOutputSave = pbOutput;
        pbOutput = (PBYTE) &OutputAlignedBuffer;
    } 

    if ((ULONG_PTR) pbFeedback & ALIGNMENT_BOUNDARY) {

        FeedbackAlignedBuffer = *(UINT64 UNALIGNED *) pbFeedback;
        pbFeedbackSave = pbFeedback;
        pbFeedback = (PBYTE) &FeedbackAlignedBuffer;
    } 
        
        

    //
    // determine the algorithm to use
    //
    switch(EncryptionAlg)
    {
        case FIPS_CBC_DES:
        {
            FipsCipher = des;
            cbKeyTable = DES_TABLESIZE;
            break;
        }
        case FIPS_CBC_3DES:
        {
            FipsCipher = tripledes;
            cbKeyTable = DES3_TABLESIZE;
            break;
        }
        default:
            fRet = FALSE;
            goto Ret;
    }

    RtlCopyMemory(rgbTmpKeyTable, (UCHAR*)pKeyTable, cbKeyTable);

    
    //
    // optimize very common codepath: 8 byte blocks
    //

    if (Operation == ENCRYPT)
    {
        ((PUINT64) pbOutput)[0] = 
            ((PUINT64) pbInput)[0] ^ ((PUINT64) pbFeedback)[0];

        FipsCipher(pbOutput, pbOutput, rgbTmpKeyTable, ENCRYPT);

        ((PUINT64) pbFeedback)[0] = ((PUINT64) pbOutput)[0];
    }
    else
    {

        //
        // two cases for output:
        // input and output are separate buffers
        // input and output are same buffers
        //

        if( pbOutput != pbInput )
        {

            FipsCipher(pbOutput, pbInput, rgbTmpKeyTable, DECRYPT);

            ((PUINT64) pbOutput)[0] ^= ((PUINT64) pbFeedback)[0];
            ((PUINT64) pbFeedback)[0] = ((PUINT64) pbInput)[0];

        } else {

            UINT64 inputTemp;

            inputTemp = ((PUINT64) pbInput)[0];

            FipsCipher(pbOutput, pbInput, rgbTmpKeyTable, DECRYPT);

            ((PUINT64) pbOutput)[0] ^= ((PUINT64) pbFeedback)[0];
            ((PUINT64) pbFeedback)[0] = inputTemp;
        }
    }   

    RtlZeroMemory(rgbTmpKeyTable, DES3_TABLESIZE);

    if (pbInputSave) {

        *(UINT64 UNALIGNED *) pbInputSave = InputAlignedBuffer;
    }

    if (pbOutputSave) {

        *(UINT64 UNALIGNED *) pbOutputSave = OutputAlignedBuffer;
    }

    if (pbFeedbackSave) {

        *(UINT64 UNALIGNED *) pbFeedbackSave = FeedbackAlignedBuffer;
    }   

Ret:
    return fRet;
}


//
// FipsBlockCBC (cipher block chaining) performs a XOR of the feedback register
// with the plain text before calling the block cipher
//
// NOTE - Currently this function assumes that the block length is
// DES_BLOCKLEN (8 bytes).
//
// Return: Failure if FALSE is returned, TRUE if it succeeded.
//

BOOL FipsBlockCBC(
        ULONG  EncryptionAlg,
        PBYTE  pbOutput,
        PBYTE  pbInput,
        ULONG  Length,
        void   *pKeyTable,
        int    Operation,
        PBYTE  pbFeedback
        )
{
    UCHAR rgbTmpKeyTable[DES3_TABLESIZE]; // 3DES is the max table size
    ULONG cbKeyTable;
    FIPSCIPHER FipsCipher;
    BOOL fRet = TRUE;


    ASSERT ((Length % DESX_BLOCKLEN == 0) && (Length > 0));
    if ((Length % DESX_BLOCKLEN != 0) || (Length == 0)) {
        return FALSE;
    }

    //
    // determine the algorithm to use
    //
    switch(EncryptionAlg)
    {
        case FIPS_CBC_DES:
        {
            FipsCipher = des;
            cbKeyTable = DES_TABLESIZE;
            break;
        }
        case FIPS_CBC_3DES:
        {
            FipsCipher = tripledes;
            cbKeyTable = DES3_TABLESIZE;
            break;
        }
        default:
            fRet = FALSE;
            goto Ret;
    }

    RtlCopyMemory(rgbTmpKeyTable, (UCHAR*)pKeyTable, cbKeyTable);

    //
    // optimize very common codepath: 8 byte blocks
    //

    if (Operation == ENCRYPT)
    {
        ULONGLONG tmpData; // Make sure the input buffer not touched more than once. Else EFS will break mysteriously.
        ULONGLONG chainBlock;

        chainBlock = *(ULONGLONG *)pbFeedback;
        while (Length > 0){

            tmpData = *(ULONGLONG *)pbInput;
            tmpData ^= chainBlock;

            FipsCipher(pbOutput, (PUCHAR)&tmpData, rgbTmpKeyTable, ENCRYPT);
            chainBlock = *(ULONGLONG *)pbOutput;

            Length -= DES_BLOCKLEN;
            pbInput += DES_BLOCKLEN;
            pbOutput += DES_BLOCKLEN;
    

        }
        ((PUINT64) pbFeedback)[0] = chainBlock;
    }
    else
    {

        PUCHAR  pBuffer;
        PUCHAR  pOutBuffer;
        ULONGLONG SaveFeedBack;

        //
        // two cases for output:
        // input and output are separate buffers
        // input and output are same buffers
        //

        pBuffer = pbInput + Length - DES_BLOCKLEN;
        pOutBuffer = pbOutput + Length - DES_BLOCKLEN;
        SaveFeedBack = *(ULONGLONG *)pBuffer;

        while (pBuffer > pbInput) {

            FipsCipher(pOutBuffer, pBuffer, rgbTmpKeyTable, DECRYPT);
            ((PUINT64) pOutBuffer)[0] ^= *(ULONGLONG *)( pBuffer - DES_BLOCKLEN );
    
            pBuffer -= DES_BLOCKLEN;
            pOutBuffer -= DES_BLOCKLEN;

        }

        FipsCipher(pOutBuffer, pBuffer, rgbTmpKeyTable, DECRYPT);
        ((PUINT64) pOutBuffer)[0] ^= *(ULONGLONG *)pbFeedback;
        ((PUINT64) pbFeedback)[0] = SaveFeedBack;

    }

    RtlZeroMemory(rgbTmpKeyTable, DES3_TABLESIZE);


Ret:
    return fRet;
}

//
// Function: FipsHmacSHAInit
//
// Description: Initialize a SHA-HMAC context 
//

VOID FipsHmacSHAInit(
    OUT A_SHA_CTX *pShaCtx,
    IN UCHAR *pKey,
    IN unsigned int cbKey)
{
    PUCHAR      key = pKey;
    ULONG       key_len = cbKey;
    UCHAR       k_ipad[MAX_LEN_PAD];    /* inner padding - key XORd with ipad */
    UCHAR       tk[A_SHA_DIGEST_LEN];
    ULONG       i;
    UCHAR       tmpKey[MAX_KEYLEN_SHA];

    //
    // if key is longer than 64 bytes reset it to key=A_SHA_(key) */
    //
    if (key_len > MAX_KEYLEN_SHA) {
        A_SHA_CTX      tctx;

        A_SHAInit(&tctx);
        A_SHAUpdate(&tctx, key, key_len);
        A_SHAFinal(&tctx, tk);

        key = tk;
        key_len = A_SHA_DIGEST_LEN;
    }

    // For FIPS compliance
    RtlCopyMemory(tmpKey, key, key_len);

    //
    // Zero out the scratch arrays
    //
    RtlZeroMemory(k_ipad, sizeof(k_ipad));

    RtlCopyMemory(k_ipad, tmpKey, key_len);

    //
    // XOR key with ipad and opad values
    //
    for (i = 0; i < MAX_KEYLEN_SHA/sizeof(unsigned __int64); i++) {
        ((unsigned __int64*)k_ipad)[i] ^= 0x3636363636363636;
    }

    //
    // Init the algorithm context
    //
    A_SHAInit(pShaCtx);

    //
    // Inner A_SHA_: start with inner pad
    //
    A_SHAUpdate(pShaCtx, k_ipad, MAX_KEYLEN_SHA);

    RtlZeroMemory(tmpKey, key_len);
}

//
// Function: FipsHmacSHAUpdate
//
// Description: Add more data to a SHA-HMAC context
//

VOID FipsHmacSHAUpdate(
    IN OUT A_SHA_CTX *pShaCtx,
    IN UCHAR *pb,
    IN unsigned int cb)
{
    A_SHAUpdate(pShaCtx, pb, cb);
}

//
// Function: FipsHmacSHAFinal
//
// Description: Return result of SHA-HMAC 
//

VOID FipsHmacSHAFinal(
    IN A_SHA_CTX *pShaCtx,
    IN UCHAR *pKey,
    IN unsigned int cbKey,
    OUT UCHAR *pHash)
{
    UCHAR       k_opad[MAX_LEN_PAD];    /* outer padding - key XORd with opad */
    UCHAR       tk[A_SHA_DIGEST_LEN];
    PUCHAR      key = pKey;
    ULONG       key_len = cbKey;
    ULONG       i;
    UCHAR       tmpKey[MAX_KEYLEN_SHA];

    A_SHAFinal(pShaCtx, pHash);

    //
    // if key is longer than 64 bytes reset it to key=A_SHA_(key) */
    //
    if (key_len > MAX_KEYLEN_SHA) {
        A_SHA_CTX      tctx;

        A_SHAInit(&tctx);
        A_SHAUpdate(&tctx, key, key_len);
        A_SHAFinal(&tctx, tk);

        key = tk;
        key_len = A_SHA_DIGEST_LEN;
    }

    // For FIPS Compliance
    RtlCopyMemory(tmpKey, key, key_len);

    RtlZeroMemory(k_opad, sizeof(k_opad));
    RtlCopyMemory(k_opad, tmpKey, key_len);

    //
    // XOR key with ipad and opad values
    //
    for (i = 0; i < MAX_KEYLEN_SHA/sizeof(unsigned __int64); i++) {
        ((unsigned __int64*)k_opad)[i] ^= 0x5c5c5c5c5c5c5c5c;
    }

    //
    // Now do outer A_SHA_
    //
    A_SHAInit(pShaCtx);

    //
    // start with outer pad
    //
    A_SHAUpdate(pShaCtx, k_opad, MAX_KEYLEN_SHA);

    //
    // then results of 1st hash
    //
    A_SHAUpdate(pShaCtx, pHash, A_SHA_DIGEST_LEN);

    A_SHAFinal(pShaCtx, pHash);

    RtlZeroMemory(tmpKey, key_len);
}

//
// Function: HmacMD5Init
//
// Description: Initialize a MD5-HMAC context 
//

VOID HmacMD5Init(
    OUT MD5_CTX *pMD5Ctx,
    IN UCHAR *pKey,
    IN unsigned int cbKey)
{
    PUCHAR      key = pKey;
    ULONG       key_len = cbKey;
    UCHAR       k_ipad[MAX_LEN_PAD];    /* inner padding - key XORd with ipad */
    UCHAR       tk[MD5DIGESTLEN];
    ULONG       i;

    //
    // if key is longer than 64 bytes reset it to key=MD5(key) */
    //
    if (key_len > MAX_KEYLEN_MD5) {
        MD5_CTX      tctx;

        MD5Init(&tctx);
        MD5Update(&tctx, key, key_len);
        MD5Final(&tctx);

        //
        // Copy out the partial hash
        //
        RtlCopyMemory (tk, tctx.digest, MD5DIGESTLEN);

        key = tk;
        key_len = MD5DIGESTLEN;
    }

    //
    // Zero out the scratch arrays
    //
    RtlZeroMemory(k_ipad, sizeof(k_ipad));

    RtlCopyMemory(k_ipad, key, key_len);

    //
    // XOR key with ipad and opad values
    //
    for (i = 0; i < MAX_KEYLEN_MD5/sizeof(unsigned __int64); i++) {
        ((unsigned __int64*)k_ipad)[i] ^= 0x3636363636363636;
    }

    //
    // Init the algorithm context
    //
    MD5Init(pMD5Ctx);

    //
    // Inner MD5: start with inner pad
    //
    MD5Update(pMD5Ctx, k_ipad, MAX_KEYLEN_MD5);
}

//
// Function: HmacMD5Update
//
// Description: Add more data to a MD5-HMAC context
//

VOID HmacMD5Update(
    IN OUT MD5_CTX *pMD5Ctx,
    IN UCHAR *pb,
    IN unsigned int cb)
{
    MD5Update(pMD5Ctx, pb, cb);
}

//
// Function: HmacMD5Final
//
// Description: Return result of MD5-HMAC 
//

VOID HmacMD5Final(
    IN MD5_CTX *pMD5Ctx,
    IN UCHAR *pKey,
    IN unsigned int cbKey,
    OUT UCHAR *pHash)
{
    UCHAR       k_opad[MAX_LEN_PAD];    /* outer padding - key XORd with opad */
    UCHAR       tk[MD5DIGESTLEN];
    PUCHAR      key = pKey;
    ULONG       key_len = cbKey;
    ULONG       i;

    MD5Final(pMD5Ctx);

    //
    // Copy out the partial hash
    //
    RtlCopyMemory (pHash, pMD5Ctx->digest, MD5DIGESTLEN);

    //
    // if key is longer than 64 bytes reset it to key=MD5(key) */
    //
    if (key_len > MAX_KEYLEN_MD5) {
        MD5_CTX      tctx;

        MD5Init(&tctx);
        MD5Update(&tctx, key, key_len);
        MD5Final(&tctx);

        //
        // Copy out the partial hash
        //
        RtlCopyMemory (tk, tctx.digest, MD5DIGESTLEN);

        key = tk;
        key_len = MD5DIGESTLEN;
    }

    RtlZeroMemory(k_opad, sizeof(k_opad));
    RtlCopyMemory(k_opad, key, key_len);

    //
    // XOR key with ipad and opad values
    //
    for (i = 0; i < MAX_KEYLEN_MD5/sizeof(unsigned __int64); i++) {
        ((unsigned __int64*)k_opad)[i] ^= 0x5c5c5c5c5c5c5c5c;
    }

    //
    // Now do outer MD5
    //
    MD5Init(pMD5Ctx);

    //
    // start with outer pad
    //
    MD5Update(pMD5Ctx, k_opad, MAX_KEYLEN_MD5);

    //
    // then results of 1st hash
    //
    MD5Update(pMD5Ctx, pHash, MD5DIGESTLEN);

    MD5Final(pMD5Ctx);

    RtlCopyMemory(pHash, pMD5Ctx->digest, MD5DIGESTLEN);
}

static UCHAR DSSPRIVATEKEYINIT[] =
{ 0x67, 0x45, 0x23, 0x01, 0xef, 0xcd, 0xab, 0x89,
  0x98, 0xba, 0xdc, 0xfe, 0x10, 0x32, 0x54, 0x76,
  0xc3, 0xd2, 0xe1, 0xf0};

static UCHAR MODULUS[] =
{ 0xf5, 0xc1, 0x56, 0xb1, 0xd5, 0x48, 0x42, 0x2e,
  0xbd, 0xa5, 0x44, 0x41, 0xc7, 0x1c, 0x24, 0x08,
  0x3f, 0x80, 0x3c, 0x90};


UCHAR g_rgbRNGState[A_SHA_DIGEST_LEN];

//
// Function : AddSeeds
//
// Description : This function adds the 160 bit seeds pointed to by pdwSeed1 and
//               pdwSeed2, it also adds 1 to this sum and mods the sum by
//               2^160.
//

VOID AddSeeds(
              IN ULONG *pdwSeed1,
              IN OUT ULONG *pdwSeed2
              )
{
    ULONG   dwTmp;
    ULONG   dwOverflow = 1;
    ULONG   i;

    for (i = 0; i < 5; i++)
    {
        dwTmp = dwOverflow + pdwSeed1[i];
        dwOverflow = (dwOverflow > dwTmp);
        pdwSeed2[i] = pdwSeed2[i] + dwTmp;
        dwOverflow = ((dwTmp > pdwSeed2[i]) || dwOverflow);
    }
}


void SHA_mod_q(
               IN UCHAR     *pbHash,
               IN UCHAR     *pbQ,
               OUT UCHAR     *pbNewHash
               )    
//
//      Given SHA(message), compute SHA(message) mod qdigit.
//      Output is in the interval [0, qdigit-1].
//      Although SHA(message) may exceed qdigit,
//      it cannot exceed 2*qdigit since the leftmost bit 
//      of qdigit is 1.
//

{
    UCHAR    rgbHash[A_SHA_DIGEST_LEN];

    if (-1 != Compare((DWORD*)rgbHash,  // hash is greater so subtract
                      (DWORD*)pbQ,
                      A_SHA_DIGEST_LEN / sizeof(ULONG)))  
    {
        Sub((DWORD*)pbNewHash,
            (DWORD*)rgbHash,
            (DWORD*)pbQ,
            A_SHA_DIGEST_LEN / sizeof(ULONG));
    }
    else
    {
        memcpy(pbNewHash, pbHash, A_SHA_DIGEST_LEN / sizeof(ULONG));
    }
} // SHA_mod_q 

//
// Function : RNG16BitStateCheck
//
// Description : This function compares each 160 bits of the buffer with
//               the next 160 bits and if they are the same the function
//               errors out.  The IN buffer is expected to be A_SHA_DIGEST_LEN
//               bytes long.  The function fails if the RNG is gets the same
//               input buffer of 160 bits twice in a row.
//

BOOL RNG16BitStateCheck(
                        IN OUT ULONG *pdwOut,
                        IN ULONG *pdwIn,
                        IN ULONG cbNeeded
                        )
{
    BOOL    fRet = FALSE;

    if (RtlEqualMemory(g_rgbRNGState, pdwIn, A_SHA_DIGEST_LEN))
    {
        RtlCopyMemory(g_rgbRNGState, (BYTE*)pdwIn, A_SHA_DIGEST_LEN);
        goto Ret;
    }

    RtlCopyMemory(g_rgbRNGState, (BYTE*)pdwIn, A_SHA_DIGEST_LEN);

    RtlCopyMemory((BYTE*)pdwOut, (BYTE*)pdwIn, cbNeeded);

    fRet = TRUE;
Ret:
    return fRet;
}

//
// Function : FIPSGenRandom
//
// Description : FIPS 186 RNG, the seed is generated by calling NewGenRandom.
//

BOOL FIPSGenRandom(
                   IN OUT UCHAR *pb,
                   IN ULONG cb
                   )
{
    ULONG           rgdwSeed[A_SHA_DIGEST_LEN/sizeof(ULONG)];    // 160 bits
    ULONG           rgdwNewSeed[A_SHA_DIGEST_LEN/sizeof(ULONG)]; // 160 bits
    A_SHA_CTX       SHACtxt;
    UCHAR           rgbBuf[A_SHA_DIGEST_LEN];
    ULONG           cbBuf;
    UCHAR           *pbTmp = pb;
    ULONG           cbTmp = cb;
    ULONG           i;
    BOOL            fRet = FALSE;

    while (cbTmp)
    {
        // get a 160 bit random seed
        NewGenRandom(NULL, NULL, (BYTE*)rgdwNewSeed, sizeof(rgdwNewSeed));

        for (i = 0; i < A_SHA_DIGEST_LEN/sizeof(ULONG); i++)
        {
            rgdwSeed[i] ^= rgdwNewSeed[i];
        }

        A_SHAInit (&SHACtxt);
        RtlCopyMemory(SHACtxt.state, DSSPRIVATEKEYINIT, A_SHA_DIGEST_LEN);

        // perform the one way function
        A_SHAUpdate(&SHACtxt, (BYTE*)rgdwSeed, sizeof(rgdwSeed));
        A_SHAFinal(&SHACtxt, rgbBuf);

        // continuous 16 bit state check
        if (A_SHA_DIGEST_LEN < cbTmp)
        {
            cbBuf = A_SHA_DIGEST_LEN;
        }
        else
        {
            cbBuf = cbTmp;
        }
        if (!RNG16BitStateCheck((ULONG*)pbTmp, (ULONG*)rgbBuf, cbBuf))
        {
            goto Ret;
        }
        pbTmp += cbBuf;
        cbTmp -= cbBuf;
        if (0 == cbTmp)
            break;

        // modular reduction with modulus Q
        SHA_mod_q(rgbBuf, MODULUS, (UCHAR*)rgdwNewSeed);

        // (1 + previous seed + new random) mod 2^160
        AddSeeds(rgdwNewSeed, rgdwSeed);
    }

    fRet = TRUE;
Ret:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\fips\selfmac.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : selfmac.c                                              //
//  DESCRIPTION   : Code to do self MACing                                 //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Nov 04 1999 jeffspel Added provider type checking                  //
//      Mar    2000 kschutz  Added stuff to make it work in kernel		   //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <zwapi.h>
#include <windows.h>

#ifdef KERNEL_MODE
#include <ntosp.h>
#else
#include <imagehlp.h>
#endif // KERNEL_MODE

#include <des.h>
#include <modes.h>

// MAC in file
typedef struct _MAC_STRUCT
{
    ULONG	CoolMac[2];
    ULONG   dwMACStructOffset;
    UCHAR	rgbMac[DES_BLOCKLEN];
	ULONG	dwImageCheckSumOffset;
} MAC_STRUCT;

#define MAC_STRING      "COOL MAC            "

static LPSTR g_pszMAC = MAC_STRING;
static MAC_STRUCT *g_pMACStruct;

// The function MACs the given bytes.
VOID 
MACBytes(
	IN DESTable *pDESKeyTable,
	IN UCHAR *pbData,
	IN ULONG cbData,
	IN OUT UCHAR *pbTmp,
	IN OUT ULONG *pcbTmp,
	IN OUT UCHAR *pbMAC,
	IN BOOLEAN fFinal
	)
{
    ULONG   cb = cbData;
    ULONG   cbMACed = 0;

    while (cb)
    {
        if ((cb + *pcbTmp) < DES_BLOCKLEN)
        {
            memcpy(pbTmp + *pcbTmp, pbData + cbMACed, cb);
            *pcbTmp += cb;
            break;
        }
        else
        {
            memcpy(pbTmp + *pcbTmp, pbData + cbMACed, DES_BLOCKLEN - *pcbTmp);
            CBC(des, DES_BLOCKLEN, pbMAC, pbTmp, pDESKeyTable,
                ENCRYPT, pbMAC);
            cbMACed = cbMACed + (DES_BLOCKLEN - *pcbTmp);
            cb = cb - (DES_BLOCKLEN - *pcbTmp);
            *pcbTmp = 0;
        }
    }
}

#define CSP_TO_BE_MACED_CHUNK  512

// Given hFile, reads the specified number of bytes (cbToBeMACed) from the file
// and MACs these bytes.  The function does this in chunks.
NTSTATUS 
MACBytesOfFile(
	IN HANDLE hFile,
	IN ULONG cbToBeMACed,
	IN DESTable *pDESKeyTable,
	IN UCHAR *pbTmp,
	IN ULONG *pcbTmp,
	IN UCHAR *pbMAC,
	IN BOOLEAN fNoMacing,
	IN BOOLEAN fFinal
	)
{
    UCHAR           rgbChunk[CSP_TO_BE_MACED_CHUNK];
    ULONG           cbRemaining = cbToBeMACed, cbToRead, cbBytesRead;
    NTSTATUS        Status = STATUS_SUCCESS;
#ifdef KERNEL_MODE
    IO_STATUS_BLOCK IoStatusBlock;
#endif // END KERNEL/USER MODE CHECK

    //
    // loop over the file for the specified number of bytes
    // updating the hash as we go.
    //

    while (cbRemaining > 0)
    {
        if (cbRemaining < CSP_TO_BE_MACED_CHUNK)
            cbToRead = cbRemaining;
        else
            cbToRead = CSP_TO_BE_MACED_CHUNK;

#ifdef KERNEL_MODE
        Status = ZwReadFile(hFile,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            rgbChunk,
                            cbToRead,
                            NULL,
                            NULL);

        if (!NT_SUCCESS(Status))
        {
            goto Ret;
        }

        if (cbToRead != IoStatusBlock.Information)
        {
            Status = STATUS_UNSUCCESSFUL;
            goto Ret;
        }
        cbBytesRead = cbToRead;
#else // USER MODE
        if(!ReadFile(hFile,
                     rgbChunk,
                     cbToRead,
                     &cbBytesRead,
                     NULL))
        {
            Status = STATUS_UNSUCCESSFUL;
            goto Ret;
        }

        if (cbBytesRead != cbToRead)
        {
            Status = STATUS_UNSUCCESSFUL;
            goto Ret;
        }
#endif // END KERNEL/USER MODE CHECK

        if (!fNoMacing)
        {
            MACBytes(pDESKeyTable,
                     rgbChunk,
                     cbBytesRead,
                     pbTmp,
                     pcbTmp,
                     pbMAC,
                     fFinal);
        }

        cbRemaining -= cbToRead;
    }
Ret:
    return Status;
}

static UCHAR rgbMACDESKey[] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef};

NTSTATUS 
MACTheFile(
	LPCWSTR pszImage,
	ULONG cbImageCheckSumOffset,
	ULONG cbMACStructOffset,
	UCHAR *pbMAC
	)
{
    ULONG                       cbFileLen = 0,cbHighPart, cbBytesToMac;
    HANDLE                      hFile = INVALID_HANDLE_VALUE;
    DESTable                    DESKeyTable;
    BYTE                        rgbTmp[DES_BLOCKLEN];
    DWORD                       cbTmp = 0;
    MAC_STRUCT                  TmpMacStruct;
    NTSTATUS                    Status = STATUS_SUCCESS;

#ifdef KERNEL_MODE
    UNICODE_STRING              ObjectName;
    OBJECT_ATTRIBUTES           ObjectAttribs;
    IO_STATUS_BLOCK             IoStatusBlock;
    BOOLEAN                     fFileOpened = FALSE;
    FILE_STANDARD_INFORMATION   FileInformation;
#endif // END KERNEL/USER MODE CHECK

    RtlZeroMemory(pbMAC, DES_BLOCKLEN);
    RtlZeroMemory(rgbTmp, sizeof(rgbTmp));
    RtlZeroMemory(&TmpMacStruct, sizeof(TmpMacStruct));

#ifdef KERNEL_MODE
	//
	// get file length - kernel mode version
	//

    RtlZeroMemory(&ObjectAttribs, sizeof(ObjectAttribs));
    RtlInitUnicodeString( &ObjectName, pszImage );

    InitializeObjectAttributes(
        &ObjectAttribs,
        &ObjectName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwCreateFile(
		&hFile,
	    SYNCHRONIZE | FILE_READ_DATA,
	    &ObjectAttribs,
	    &IoStatusBlock,
	    NULL,
	    FILE_ATTRIBUTE_NORMAL,
	    FILE_SHARE_READ ,
	    FILE_OPEN,
	    FILE_SYNCHRONOUS_IO_NONALERT, 
	    NULL,
	    0
		);

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    fFileOpened = TRUE;

    Status = ZwQueryInformationFile(
		hFile,
        &IoStatusBlock,
        &FileInformation,
        sizeof(FILE_STANDARD_INFORMATION),
        FileStandardInformation
		);

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    cbFileLen = FileInformation.EndOfFile.LowPart;

#else // USER MODE

	// 
	// get file length - user mode version
	//

    if ((hFile = CreateFileW(
		pszImage,
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL)) == INVALID_HANDLE_VALUE)
    {
		
        Status = STATUS_UNSUCCESSFUL;
        goto Ret;
    }

    cbFileLen = GetFileSize(hFile, &cbHighPart);

#endif // END KERNEL/USER MODE CHECK

    if (cbFileLen < sizeof(MAC_STRUCT))
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Ret;
    }

    // init the key table
	deskey(&DESKeyTable, rgbMACDESKey);

	// MAC the file the following way:
	// - MAC from start to image check sum
	// - skip over the image check sum
	// - mac from after the image check sum to the mac struct
	// - skip over the mac struct
	// - mac the rest of the file

    // MAC from the start to the image check sum offset
    Status = MACBytesOfFile(
		hFile,
        cbImageCheckSumOffset,
        &DESKeyTable,
        rgbTmp,
        &cbTmp,
        pbMAC,
        FALSE,
        FALSE
		);

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

	// Skip over the image checksum
    Status = MACBytesOfFile(
		hFile,
        sizeof(DWORD),
        &DESKeyTable,
        rgbTmp,
        &cbTmp,
        pbMAC,
        TRUE,
        FALSE
		);

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    // MAC from after the image checksum to the MAC struct offset
	cbBytesToMac = cbMACStructOffset - sizeof(DWORD) - cbImageCheckSumOffset;
    Status = MACBytesOfFile(
		hFile,
        cbBytesToMac,
        &DESKeyTable,
        rgbTmp,
        &cbTmp,
        pbMAC,
        FALSE,
        FALSE
		);

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

	// skip over the mac struct 
    Status = MACBytesOfFile(
		hFile,
        sizeof(MAC_STRUCT),
        &DESKeyTable,
        rgbTmp,
        &cbTmp,
        pbMAC,
        TRUE,
        FALSE
		);

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    // MAC data after the MAC struct
	cbBytesToMac = cbFileLen - cbMACStructOffset - sizeof(MAC_STRUCT);
    Status = MACBytesOfFile(
		hFile,
        cbBytesToMac,
        &DESKeyTable,
        rgbTmp,
        &cbTmp,
        pbMAC,
        FALSE,
        TRUE
		);

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }
Ret:

#ifdef KERNEL_MODE
    if (fFileOpened)
    {
        ZwClose(hFile);
    }
#else 
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }
#endif 

    return Status;
}

// **********************************************************************
// SelfMACCheck performs a DES MAC on the binary image of this DLL
// **********************************************************************
NTSTATUS 
SelfMACCheck(
	IN LPWSTR pszImage
	)
{
    UCHAR       rgbMac[DES_BLOCKLEN];
    NTSTATUS    Status = STATUS_SUCCESS;

    g_pMACStruct = (MAC_STRUCT*) g_pszMAC;

    Status = MACTheFile(
		pszImage,
		g_pMACStruct->dwImageCheckSumOffset,
        g_pMACStruct->dwMACStructOffset,
        rgbMac
		);

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    if (RtlCompareMemory(
		rgbMac,
        g_pMACStruct->rgbMac,
        sizeof(rgbMac)) != sizeof(rgbMac))
    {
        Status = STATUS_IMAGE_CHECKSUM_MISMATCH;
        goto Ret;
    }

Ret:
    return Status;
}

#ifndef KERNEL_MODE

//
// Find the offset to the MAC structure
//
NTSTATUS 
FindTheMACStructOffset(
	LPWSTR pszImage,
    ULONG *pcbMACStructOffset
	)
{
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    ULONG       cbRemaining, cbBytesRead, cbHighPart, cbFileLen, cbCompare = 0;
    UCHAR       b;
    NTSTATUS    Status = STATUS_SUCCESS;

    *pcbMACStructOffset = 0;

    // Load the file
    if ((hFile = CreateFileW(
		pszImage,
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL)) == INVALID_HANDLE_VALUE)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Ret;
    }

    cbFileLen = GetFileSize(hFile, &cbHighPart);
    cbRemaining = cbFileLen;

    // read file to the correct location
    while (cbRemaining > 0)
    {
        if(!ReadFile(hFile,
                     &b,
                     1,
                     &cbBytesRead,
                     NULL))
        {
            Status = STATUS_UNSUCCESSFUL;
            goto Ret;
        }

        if (cbBytesRead != 1)
        {
            Status = STATUS_UNSUCCESSFUL;
            goto Ret;
        }

        if (b == g_pszMAC[cbCompare])
        {
            cbCompare++;
            if (cbCompare == 8)
            {
                *pcbMACStructOffset =  (cbFileLen - (cbRemaining + 7)) ;
                break;
            }
        }
        else
        {
            cbCompare = 0;
        }

        cbRemaining--;
    }

    if (cbCompare != 8)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Ret;
    }
Ret:
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }

    return Status;
}

NTSTATUS 
GetImageCheckSumOffset(
	LPWSTR pszImage,
    ULONG *pcbImageCheckSumOffset
	)
{
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    HANDLE      hFileMap = INVALID_HANDLE_VALUE;
    ULONG       cbHighPart;
    ULONG       cbFileLen;
	PBYTE		pbFilePtr = NULL;
	NTSTATUS	Status = STATUS_UNSUCCESSFUL;
    PIMAGE_NT_HEADERS   pImageNTHdrs;
    DWORD       OldCheckSum;
    DWORD       NewCheckSum;

    if (INVALID_HANDLE_VALUE == (hFile = CreateFileW(
		pszImage,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL)))
    {
        goto Ret;
    }

    // make sure the file is larger than the indicated offset
    cbFileLen = GetFileSize(hFile, &cbHighPart);

	// map the file to memory
    if (NULL == (hFileMap = CreateFileMapping(
		hFile,
		NULL,
		PAGE_READWRITE,
		0,
		0,
		NULL)))
    {
        goto Ret;
    }

	// get a memory view of the file
    if (NULL == (pbFilePtr = (PBYTE) MapViewOfFile(
        hFileMap,
        FILE_MAP_ALL_ACCESS,
        0,
        0,
        0)))
    {
        goto Ret;
    }

	// get the pointer to the image checksum
    if (NULL == (pImageNTHdrs = CheckSumMappedFile(
		pbFilePtr, cbFileLen,
        &OldCheckSum, &NewCheckSum))) {

        goto Ret;
	}

	*pcbImageCheckSumOffset = 
		(ULONG) ((PBYTE) &pImageNTHdrs->OptionalHeader.CheckSum - pbFilePtr);

	Status = STATUS_SUCCESS;

Ret:
    if (pbFilePtr) {

        UnmapViewOfFile(pbFilePtr);
	}

    if (INVALID_HANDLE_VALUE != hFileMap) {

        CloseHandle(hFileMap);
	}

    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }
	return Status;
}

// write the MAC information into the MAC struct in the file
NTSTATUS 
WriteMACToTheFile(
    LPWSTR pszImage,
    MAC_STRUCT *pMacStructOriginal,
    ULONG cbMACStructOffset,
    UCHAR *pbMac
	)
{
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    HANDLE      hFileMap = INVALID_HANDLE_VALUE;
	PBYTE		pbFilePtr = NULL;
    MAC_STRUCT  TmpMacStruct;
    ULONG       cbWritten = 0, cbRemaining = cbMACStructOffset;
    ULONG       cbToRead, cbBytesRead, cbHighPart,cbFileLen;
    UCHAR       rgbChunk[CSP_TO_BE_MACED_CHUNK];
    NTSTATUS    Status = STATUS_SUCCESS;
    DWORD       OldCheckSum, NewCheckSum;
    PIMAGE_NT_HEADERS   pImageNTHdrs;

    RtlCopyMemory(&TmpMacStruct, pMacStructOriginal, sizeof(TmpMacStruct));

    // Load the file
    if ((hFile = CreateFileW(
		pszImage,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL)) == INVALID_HANDLE_VALUE)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Ret;
    }

    // make sure the file is larger than the indicated offset
    cbFileLen = GetFileSize(hFile, &cbHighPart);

    if (cbFileLen < cbMACStructOffset)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Ret;
    }

	// map the file to memory
    if ((hFileMap = CreateFileMapping(
		hFile,
        NULL,
        PAGE_READWRITE,
        0,
        0,
        NULL)) == NULL)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Ret;
    }

	// get a memory view of the file
    if ((pbFilePtr = (PBYTE) MapViewOfFile(
		hFileMap,
        FILE_MAP_ALL_ACCESS,
        0,
        0,
        0)) == NULL)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Ret;
    }

	// get the pointer to the image checksum
    if (NULL == (pImageNTHdrs = CheckSumMappedFile(
		pbFilePtr, cbFileLen,
        &OldCheckSum, &NewCheckSum))) {

        Status = STATUS_UNSUCCESSFUL;
        goto Ret;
	}

    // set up and write the MAC struct
	TmpMacStruct.dwImageCheckSumOffset = 
		(ULONG) ((PBYTE) &pImageNTHdrs->OptionalHeader.CheckSum - pbFilePtr);
    TmpMacStruct.dwMACStructOffset = cbMACStructOffset;
    RtlCopyMemory(TmpMacStruct.rgbMac, pbMac, sizeof(TmpMacStruct.rgbMac));

	// now copy the new mac struct back to the view
	RtlCopyMemory(pbFilePtr + cbMACStructOffset, &TmpMacStruct, sizeof(TmpMacStruct));

    // compute a new checksum
    if (NULL == (pImageNTHdrs = CheckSumMappedFile(
		pbFilePtr, cbFileLen,
        &OldCheckSum, &NewCheckSum))) {

        Status = STATUS_UNSUCCESSFUL;
        goto Ret;
	}

	// and copy the new checksum back to the header
    CopyMemory(&pImageNTHdrs->OptionalHeader.CheckSum, &NewCheckSum, sizeof(DWORD));

Ret:
    if (pbFilePtr) {

        UnmapViewOfFile(pbFilePtr);
	}

    if (INVALID_HANDLE_VALUE != hFileMap) {

        CloseHandle(hFileMap);
	}
													 
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }

    return Status;
}


// **********************************************************************
// MACTheBinary performs a MAC on the binary and writes the value into
// the g_pMACStruct
// **********************************************************************
NTSTATUS 
MACTheBinary(
	IN LPWSTR pszImage
	)
{
    UCHAR       rgbMAC[DES_BLOCKLEN];
    ULONG       cbMACStructOffset = 0, cbImageCheckSumOffset = 0;
    NTSTATUS    Status = STATUS_SUCCESS;

    g_pMACStruct = (MAC_STRUCT*) g_pszMAC;

    // Find the offset to the MAC structure
    Status = FindTheMACStructOffset(
		pszImage,
        &cbMACStructOffset
		);

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

	// Get the offset of the image checksum
	Status = GetImageCheckSumOffset(
		pszImage,
        &cbImageCheckSumOffset
		);

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    // MAC the file
    Status = MACTheFile(
		pszImage,
		cbImageCheckSumOffset,
        cbMACStructOffset,
        rgbMAC
		);

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

    // write the MAC information into the MAC struct in the file
    Status = WriteMACToTheFile(
		pszImage,
        g_pMACStruct,
        cbMACStructOffset,
        rgbMAC
		);

    if (!NT_SUCCESS(Status))
    {
        goto Ret;
    }

Ret:
    return Status;
}
#endif // NOT IN KERNEL_MODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\fips\driver\fipsapi.h ===
#ifndef __FIPSAPI_H__
#define __FIPSAPI_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <windef.h>
#include <des.h>
#include <tripldes.h>
#include <sha.h>
#include <modes.h>
#include <md5.h>

#if DEBUG 
#define FipsDebug(LEVEL, STRING) \
        { \
          DbgPrint STRING; \
        }
#else
#define FipsDebug(LEVEL, STRING)
#endif

#define     FIPS_DEVICE_NAME            L"\\Device\\Fips"

#define FIPS_CTL_CODE(code)         CTL_CODE(FILE_DEVICE_FIPS, \
                                            (code), \
                                            METHOD_BUFFERED, \
                                            FILE_ANY_ACCESS)

#define IOCTL_FIPS_GET_FUNCTION_TABLE   FIPS_CTL_CODE( 1)

#define     FIPS_CBC_DES    0x1
#define     FIPS_CBC_3DES   0x2

//
// Defines for IPSEC HMAC use
//
#define     MAX_LEN_PAD     65
#define     MAX_KEYLEN_SHA  64
#define     MAX_KEYLEN_MD5  64   

//
//     Fill in the DESTable struct with the decrypt and encrypt
//     key expansions.
//
//     Assumes that the second parameter points to DES_BLOCKLEN
//     bytes of key.
//
//

VOID FipsDesKey(DESTable *DesTable, UCHAR *pbKey);

//
//     Encrypt or decrypt with the key in DESTable
//
//

VOID FipsDes(UCHAR *pbOut, UCHAR *pbIn, void *pKey, int iOp);

//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 2 * DES_BLOCKLEN
//   bytes of key.
//
//

VOID Fips3Des3Key(PDES3TABLE pDES3Table, UCHAR *pbKey);

//
//   Encrypt or decrypt with the key in pKey
//

VOID Fips3Des(UCHAR *pbIn, UCHAR *pbOut, void *pKey, int op);

//
//   Initialize the SHA context.
//

VOID FipsSHAInit(A_SHA_CTX *pShaCtx);

//
//   Hash data into the hash context.
//

VOID FipsSHAUpdate(A_SHA_CTX *pShaCtx, UCHAR *pb, unsigned int cb);

//
//   Finish the SHA hash and copy the final hash value into the pbHash out param.
//

VOID FipsSHAFinal(A_SHA_CTX *pShaCtx, UCHAR *pbHash);

//
// FipsCBC (cipher block chaining) performs a XOR of the feedback register
// with the plain text before calling the block cipher
//
// NOTE - Currently this function assumes that the block length is
// DES_BLOCKLEN (8 bytes).
//
// Return: Failure if FALSE is returned, TRUE if it succeeded.
//

BOOL FipsCBC(
    ULONG  EncryptionAlg,
    BYTE   *pbOutput,
    BYTE   *pbInput,
    void   *pKeyTable,
    int    Operation,
    BYTE   *pbFeedback
    );

//
// FipsBlockCBC (cipher block chaining) performs a XOR of the feedback register
// with the plain text before calling the block cipher
//
// NOTE - The Length must be multiple of DES_BLOCKLEN (8)
// All the input buffer must be aligned on LONGLONG for performane reason.
//
// Return: Failure if FALSE is returned, TRUE if it succeeded.
//

BOOL FipsBlockCBC(
    ULONG  EncryptionAlg,
    BYTE   *pbOutput,
    BYTE   *pbInput,
    ULONG  Length,
    void   *pKeyTable,
    int    Operation,
    BYTE   *pbFeedback
    );

//
// Function : FIPSGenRandom
//
// Description : FIPS 186 RNG, the seed is generated by calling NewGenRandom.
//

BOOL FIPSGenRandom(
    IN OUT UCHAR *pb,
    IN ULONG cb
    );

//
// Function: FipsHmacSHAInit
//
// Description: Initialize a SHA-HMAC context 
//

VOID FipsHmacSHAInit(
    OUT A_SHA_CTX *pShaCtx,
    IN UCHAR *pKey,
    IN unsigned int cbKey
    );

//
// Function: FipsHmacSHAUpdate
//
// Description: Add more data to a SHA-HMAC context
//

VOID FipsHmacSHAUpdate(
    IN OUT A_SHA_CTX *pShaCtx,
    IN UCHAR *pb,
    IN unsigned int cb
    );

//
// Function: FipsHmacSHAFinal
//
// Description: Return result of SHA-HMAC 
//

VOID FipsHmacSHAFinal(
    IN A_SHA_CTX *pShaCtx,
    IN UCHAR *pKey,
    IN unsigned int cbKey,
    OUT UCHAR *pHash
    );

//
// Function: HmacMD5Init
//
// Description: Initialize a MD5-HMAC context 
//

VOID HmacMD5Init(
    OUT MD5_CTX *pMD5Ctx,
    IN UCHAR *pKey,
    IN unsigned int cbKey
    );

//
// Function: HmacMD5Update
//
// Description: Add more data to a MD5-HMAC context
//

VOID HmacMD5Update(
    IN OUT MD5_CTX *pMD5Ctx,
    IN UCHAR *pb,
    IN unsigned int cb
    );

//
// Function: HmacMD5Final
//
// Description: Return result of MD5-HMAC 
//

VOID HmacMD5Final(
    IN MD5_CTX *pMD5Ctx,
    IN UCHAR *pKey,
    IN unsigned int cbKey,
    OUT UCHAR *pHash
    );

// 
// Current FIPS function table
// Includes HMAC entry points
//
typedef struct _FIPS_FUNCTION_TABLE {

    VOID (*FipsDesKey)(DESTable *DesTable, UCHAR *pbKey);
    VOID (*FipsDes)(UCHAR *pbOut, UCHAR *pbIn, void *pKey, int iOp);
    VOID (*Fips3Des3Key)(PDES3TABLE pDES3Table, UCHAR *pbKey);
    VOID (*Fips3Des)(UCHAR *pbIn, UCHAR *pbOut, void *pKey, int op);
    VOID (*FipsSHAInit)(A_SHA_CTX *pShaCtx);
    VOID (*FipsSHAUpdate)(A_SHA_CTX *pShaCtx, UCHAR *pb, unsigned int cb);
    VOID (*FipsSHAFinal)(A_SHA_CTX *pShaCtx, UCHAR *pbHash);
    BOOL (*FipsCBC)(
        ULONG  EncryptionAlg,
        BYTE   *pbOutput,
        BYTE   *pbInput,
        void   *pKeyTable,
        int    Operation,
        BYTE   *pbFeedback
        );
    BOOL (*FIPSGenRandom)(
        IN OUT UCHAR *pb,
        IN ULONG cb
        );
    BOOL (*FipsBlockCBC)(
        ULONG  EncryptionAlg,
        BYTE   *pbOutput,
        BYTE   *pbInput,
        ULONG  Length,
        void   *pKeyTable,
        int    Operation,
        BYTE   *pbFeedback
        );
    VOID (*FipsHmacSHAInit)(
        OUT A_SHA_CTX *pShaCtx,
        IN UCHAR *pKey,
        IN unsigned int cbKey
        );   
    VOID (*FipsHmacSHAUpdate)(
        IN OUT A_SHA_CTX *pShaCtx,
        IN UCHAR *pb,
        IN unsigned int cb
        );
    VOID (*FipsHmacSHAFinal)(
        IN A_SHA_CTX *pShaCtx,
        IN UCHAR *pKey,
        IN unsigned int cbKey,
        OUT UCHAR *pHash
        );
    VOID (*HmacMD5Init)(
        OUT MD5_CTX *pMD5Ctx,
        IN UCHAR *pKey,
        IN unsigned int cbKey
        );
    VOID (*HmacMD5Update)(
        IN OUT MD5_CTX *pMD5Ctx,
        IN UCHAR *pb,
        IN unsigned int cb
        );
    VOID (*HmacMD5Final)(
        IN MD5_CTX *pMD5Ctx,
        IN UCHAR *pKey,
        IN unsigned int cbKey,
        OUT UCHAR *pHash
        );

} FIPS_FUNCTION_TABLE, *PFIPS_FUNCTION_TABLE;

//
// Old FIPS function table - please don't use
//
typedef struct _FIPS_FUNCTION_TABLE_1 {

    VOID (*FipsDesKey)(DESTable *DesTable, UCHAR *pbKey);
    VOID (*FipsDes)(UCHAR *pbOut, UCHAR *pbIn, void *pKey, int iOp);
    VOID (*Fips3Des3Key)(PDES3TABLE pDES3Table, UCHAR *pbKey);
    VOID (*Fips3Des)(UCHAR *pbIn, UCHAR *pbOut, void *pKey, int op);
    VOID (*FipsSHAInit)(A_SHA_CTX *pShaCtx);
    VOID (*FipsSHAUpdate)(A_SHA_CTX *pShaCtx, UCHAR *pb, unsigned int cb);
    VOID (*FipsSHAFinal)(A_SHA_CTX *pShaCtx, UCHAR *pbHash);
    BOOL (*FipsCBC)(
        ULONG  EncryptionAlg,
        BYTE   *pbOutput,
        BYTE   *pbInput,
        void   *pKeyTable,
        int    Operation,
        BYTE   *pbFeedback
        );
    BOOL (*FIPSGenRandom)(
        IN OUT UCHAR *pb,
        IN ULONG cb
        );
    BOOL (*FipsBlockCBC)(
        ULONG  EncryptionAlg,
        BYTE   *pbOutput,
        BYTE   *pbInput,
        ULONG  Length,
        void   *pKeyTable,
        int    Operation,
        BYTE   *pbFeedback
        );

} FIPS_FUNCTION_TABLE_1, *PFIPS_FUNCTION_TABLE_1;


#ifdef __cplusplus
}
#endif

#endif // __FIPSAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\csprc.h ===
// 
// Used by resource.rc
//
#define IDS_RSA_SIG_DESCR       1
#define IDS_RSA_EXCH_DESCR      2
#define IDS_IMPORT_SIMPLE       3
#define IDS_SIGNING_E           4
#define IDS_CREATE_RSA_SIG      5
#define IDS_CREATE_RSA_EXCH     6
#define IDS_DSS_SIG_DESCR       7
#define IDS_DSS_EXCH_DESCR      8
#define IDS_CREATE_DSS_SIG      9
#define IDS_CREATE_DH_EXCH      10
#define IDS_IMPORT_E_PUB        11
#define IDS_MIGR                12
#define IDS_DELETE_SIG          13
#define IDS_DELETE_KEYX         14
#define IDS_DELETE_SIG_MIGR     15
#define IDS_DELETE_KEYX_MIGR    16
#define IDS_SIGNING_S           17
#define IDS_EXPORT_E_PRIV       18
#define IDS_EXPORT_S_PRIV       19
#define IDS_IMPORT_E_PRIV       20
#define IDS_IMPORT_S_PRIV       21

#define         IDS_CSP_RSA_SIG_DESCR               7501
#define         IDS_CSP_RSA_EXCH_DESCR              7502
#define         IDS_CSP_IMPORT_SIMPLE               7503
#define         IDS_CSP_SIGNING_E                   7504
#define         IDS_CSP_CREATE_RSA_SIG              7505
#define         IDS_CSP_CREATE_RSA_EXCH             7506
#define         IDS_CSP_DSS_SIG_DESCR               7507
#define         IDS_CSP_DSS_EXCH_DESCR              7508
#define         IDS_CSP_CREATE_DSS_SIG              7509
#define         IDS_CSP_CREATE_DH_EXCH              7510
#define         IDS_CSP_IMPORT_E_PUB                7511
#define         IDS_CSP_MIGR                        7512
#define         IDS_CSP_DELETE_SIG                  7513
#define         IDS_CSP_DELETE_KEYX                 7514
#define         IDS_CSP_DELETE_SIG_MIGR             7515
#define         IDS_CSP_DELETE_KEYX_MIGR            7516
#define         IDS_CSP_SIGNING_S                   7517
#define         IDS_CSP_EXPORT_E_PRIV               7518
#define         IDS_CSP_EXPORT_S_PRIV               7519
#define         IDS_CSP_IMPORT_E_PRIV               7520
#define         IDS_CSP_IMPORT_S_PRIV               7521
#define         IDS_CSP_AUDIT_CAPI_KEY              7522
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\fips\macutil\macutil.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : client.cxx                                             //
//  DESCRIPTION   : Crypto API interface                                   //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Mar  8 1996 larrys  New                                            //
//                  dbarlow                                                //
//                                                                         //
//  Copyright (C) 1996 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>

NTSTATUS MACTheBinary(
                      IN LPWSTR pszImage
                      );

void ShowHelp()
{
    printf("Internal FIPS Module MACing Utility\n");
    printf("macutil <filename>\n");
}

void __cdecl main( int argc, char *argv[])
{
    LPWSTR      szInFile = NULL;
    ULONG       cch = 0;
    ULONG       dwErr;
    NTSTATUS    Status;
    DWORD       dwRet = 1;

    //
    // Parse the command line.
    //

    if (argc != 2)
    {
        ShowHelp();
        goto Ret;
    }

    //
    // convert to UNICODE file name
    //
    if (0 == (cch = MultiByteToWideChar(CP_ACP,
                                        MB_COMPOSITE,
                                        &argv[1][0],
                                        -1,
                                        NULL,
                                        cch)))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    if (NULL == (szInFile = LocalAlloc(LMEM_ZEROINIT, (cch + 1) * sizeof(WCHAR))))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    if (0 == (cch = MultiByteToWideChar(CP_ACP,
                                        MB_COMPOSITE,
                                        &argv[1][0],
                                        -1,
                                        szInFile,
                                        cch)))
    {
         dwErr = GetLastError();
         goto Ret;
    }

    // MAC the binary
    Status = MACTheBinary(szInFile);

    if (!NT_SUCCESS(Status))
    {
        ShowHelp();
        goto Ret;
    }

    //
    // Clean up and return.
    //

    dwRet = 0;
    printf("SUCCESS\n");

Ret:
    exit(dwRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\cppapi.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : cppapi.h                                               //
//  DESCRIPTION   : Cryptography Provider Private APIs                     //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      May  9 1995 larrys  New                                            //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////


typedef unsigned long HPRIVUID;

#define	CPPAPI_FAILED		FALSE
#define	CPPAPI_SUCCEED		TRUE


/*
 -  CryptLogonVerify
 -
 *  Purpose:
 *                Used by CryptAcquireContext to verify logon password.
 *
 *
 *  Parameters:
 *               OUT     hPrivid -  Handle to the id of the user
 *
 *  Returns:
 */
BOOL CryptLogonVerify(OUT HPRIVUID *hUID);


/*
 -  CryptGetUserData
 -
 *  Purpose:
 *                Get required data from user.
 *
 *
 *  Parameters:
 *               IN      hPrivid  -  Handle to the id of the user
 *               OUT     pbData   -  bufer containing user-supplied data
 *               OUT     dwBufLen -  lenght of user-supplied data
 *
 *  Returns:
 */
BOOL CryptGetUserData(IN  HPRIVUID hUID,
                      OUT BYTE **pbData,
                      OUT DWORD *dwBufLen);

/*
 -  CryptConfirmSignature
 -
 *  Purpose:
 *                Determine weather the signing should proceed.
 *
 *
 *  Parameters:
 *               IN      pTmpUser     -  Pointer to the user list structure
 *               IN      dwKeySpec    -  Type of key to be used for signing
 *               IN      sDescription -  Description of document to be signed
 *
 *  Returns:
 */
BOOL CryptConfirmSignature(
                           IN PNTAGUserList pTmpUser,
                           IN DWORD dwKeySpec,
                           IN LPCTSTR sDescription
                           );

/*
 -  CryptUserProtectKey
 -
 *  Purpose:      Obtain or determine user protection information.
 *                
 *
 *
 *  Parameters:
 *               IN      hPrivid      -  Handle to the id of the user
 *               IN      hKey         -  Handle to key
 *
 *  Returns:
 */
BOOL CryptUserProtectKey(IN HPRIVUID hUID,
                         IN HCRYPTKEY hKey);


/*
 -  CryptConfirmEncryption
 -
 *  Purpose:
 *                Determine weather the encryption should proceed.
 *
 *
 *  Parameters:
 *               IN      hPrivid      -  Handle to the id of the user
 *               IN      hKey         -  Handle to key
 *               IN      final        -  flag indicating last encrypt for a
 *                                       block of data
 *
 *  Returns:
 */
BOOL CryptConfirmEncryption(IN HPRIVUID hUID,
                            IN HCRYPTKEY hKey,
                            IN BOOL final);

/*
 -  CryptConfirmDecryption
 -
 *  Purpose:
 *                Determine weather the DEcryption should proceed.
 *
 *
 *  Parameters:
 *               IN      hPrivid      -  Handle to the id of the user
 *               IN      hKey         -  Handle to key
 *               IN      final        -  flag indicating last encrypt for a
 *                                       block of data
 *
 *  Returns:
 */
BOOL CryptConfirmDecryption(IN HPRIVUID hUID,
                            IN HCRYPTKEY hKey,
                            IN BOOL final);

/*
 -  CryptConfirmTranslation
 -
 *  Purpose:
 *                Determine weather the translation should proceed.
 *
 *
 *  Parameters:
 *               IN      hPrivid      -  Handle to the id of the user
 *               IN      hKey         -  Handle to key
 *               IN      final        -  flag indicating last encrypt for a
 *                                       block of data
 *
 *  Returns:
 */
BOOL CryptConfirmTranslation(IN HPRIVUID hUID,
                             IN HCRYPTKEY hKey,
                             IN BOOL final);

/*
 -  CryptConfirmExportKey
 -
 *  Purpose:
 *                Determine whether the export key should proceed.
 *
 *
 *  Parameters:
 *               IN      pTmpUser     -  Pointer to the user list structure
 *               IN      dwKeySpec    -  Type of key to be exported
 *
 *  Returns:
 */
BOOL CryptConfirmExportKey(
                           IN PNTAGUserList pTmpUser,
                           IN DWORD dwKeySpec
                           );

/*
 -  CryptConfirmImportKey
 -
 *  Purpose:
 *                Determine whether the import key should proceed.
 *
 *
 *  Parameters:
 *               IN      pTmpUser     -  Pointer to the user list structure
 *               IN      pKey         -  Pointer to the key list structure
 *               IN      dwBlobType   -  Type of blob to be imported
 *               IN      dwKeySpec    -  Type of key to be imported
 *
 *  Returns:
 */
BOOL CryptConfirmImportKey(
                           IN PNTAGUserList pTmpUser,
                           IN DWORD dwBlobType,
                           IN DWORD dwKeySpec
                           );

/*
 -  CryptConfirmGenKey
 -
 *  Purpose:
 *                Determine whether the gen key should proceed.
 *
 *
 *  Parameters:
 *               IN      pTmpUser     -  Pointer to the user list structure
 *               IN      pKey         -  Pointer to the key list structure
 *               IN      dwKeySpec    -  Type of key to be imported
 *
 *  Returns:
 */
BOOL CryptConfirmGenKey(
                        IN PNTAGUserList pTmpUser,
                        IN DWORD dwKeySpec
                        );

/*
 -  CryptConfirmChangePassword
 -
 *  Purpose:
 *                Determine whether the key password should be changed.
 *
 *
 *  Parameters:
 *               IN      pTmpUser     -  Pointer to the user list structure
 *               IN      dwKeySpec    -  Type of key changing the password for
 *
 *  Returns:
 */
BOOL CryptConfirmChangePassword(
                                IN PNTAGUserList pTmpUser,
                                IN DWORD dwKeySpec
                                );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\contman.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : contman.h                                              //
//  DESCRIPTION   : include file                                           //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Mar 16 1998 jeffspel Created                                       //
//                                                                         //
//  Copyright (C) 1998 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __CONTMAN_H__
#define __CONTMAN_H__

#ifdef __cplusplus
extern "C" {
#endif

#ifndef RtlSecureZeroMemory
#define RtlSecureZeroMemory(ptr, cnt) (memset(ptr, 0x0, cnt))
#endif

extern LPVOID ContAlloc(ULONG cbLen);
extern LPVOID ContRealloc(LPVOID pvMem, ULONG cbLen);
extern void ContFree(LPVOID pvMem);

// Display Strings
typedef struct _CSP_STRINGS_ {
    // RSA
    LPWSTR  pwszSignWExch;
    LPWSTR  pwszCreateRSASig;
    LPWSTR  pwszCreateRSAExch;
    LPWSTR  pwszRSASigDescr;
    LPWSTR  pwszRSAExchDescr;
    LPWSTR  pwszImportSimple;

    // DSS-DH
    LPWSTR  pwszCreateDSS;
    LPWSTR  pwszCreateDH;
    LPWSTR  pwszImportDHPub;
    LPWSTR  pwszDSSSigDescr;
    LPWSTR  pwszDHExchDescr;

    // BOTH
    LPWSTR  pwszSigning;
    LPWSTR  pwszMigrKeys;
    LPWSTR  pwszImportPrivSig;
    LPWSTR  pwszImportPrivExch;
    LPWSTR  pwszExportPrivSig;
    LPWSTR  pwszExportPrivExch;
    LPWSTR  pwszDeleteSig;
    LPWSTR  pwszDeleteMigrSig;
    LPWSTR  pwszDeleteExch;
    LPWSTR  pwszDeleteMigrExch;
    LPWSTR  pwszAuditCapiKey;
} CSP_STRINGS, *PCSP_STRINGS;

#define SZLOCALMACHINECRYPTO "Software\\Microsoft\\Cryptography"
#define SZCRYPTOMACHINEGUID "MachineGuid"

#define KEY_CONTAINER_FILE_FORMAT_VER   2

#define STUFF_TO_GO_INTO_MIX    "Hj1diQ6kpUx7VC4m"

typedef struct _KEY_EXPORTABILITY_LENS_ {
    DWORD                   cbSigExportability;
    DWORD                   cbExchExportability;
} KEY_EXPORTABILITY_LENS, *PKEY_EXPORTABILITY_LENS;

typedef struct _KEY_CONTAINER_LENS_ {
    DWORD                   dwUIOnKey;
    DWORD                   cbName;
    DWORD                   cbSigPub;
    DWORD                   cbSigEncPriv;
    DWORD                   cbExchPub;
    DWORD                   cbExchEncPriv;
    DWORD                   cbRandom;                       // length of Random number seed
} KEY_CONTAINER_LENS, *PKEY_CONTAINER_LENS;

typedef struct _KEY_CONTAINER_INFO_ {
    DWORD                   dwVersion;
    KEY_CONTAINER_LENS      ContLens;
    BOOL                    fCryptSilent;
    BYTE                    *pbSigPub;
    BYTE                    *pbSigEncPriv;
    BOOL                    fSigExportable;
    BYTE                    *pbExchPub;
    BYTE                    *pbExchEncPriv;
    BOOL                    fExchExportable;
    BYTE                    *pbRandom;
    LPSTR                   pszUserName;
    WCHAR                   rgwszFileName[80];
    HANDLE                  hFind;                  // for enuming containers
    DWORD                   dwiRegEntry;            // for enuming containers
    DWORD                   cMaxRegEntry;           // for enuming containers
    DWORD                   cbRegEntry;             // for enuming containers
    CHAR                    *pchEnumRegEntries;     // for enuming containers
    BOOL                    fCryptFirst;            // for enuming containers
    BOOL                    fNoMoreFiles;           // for enuming containers
    DWORD                   cbOldMachKeyEntry;      // for enuming containers
    DWORD                   dwiOldMachKeyEntry;     // for enuming containers
    DWORD                   cMaxOldMachKeyEntry;    // for enuming containers
    CHAR                    *pchEnumOldMachKeyEntries; // for enuming containers
    BOOL                    fForceHighKeyProtection;
    
    // Context items required for caching private keys
    BOOL                    fCachePrivateKeys;
    DWORD                   cMaxKeyLifetime; // in milliseconds
    DWORD                   dwSigKeyTimestamp;
    DWORD                   dwKeyXKeyTimestamp;
} KEY_CONTAINER_INFO, *PKEY_CONTAINER_INFO;

// define flag for leaving old keys in the registry if they are in the .Default
// hive but are user keys
#define LEAVE_OLD_KEYS          1
// define flag indicating that the thread cannot get the SACL info from the
// old registry key when migrating keys
#define PRIVILEDGE_FOR_SACL     2

DWORD MyRtlEncryptMemory(
    IN PVOID pvMem,
    IN DWORD cbMem);

DWORD MyRtlDecryptMemory(
    IN PVOID pvMem,
    IN DWORD cbMem);

//
//    Just tries to use DPAPI to make sure it works before creating a key
//    container.
//
DWORD TryDPAPI();

DWORD
MyCryptProtectData(
    IN              DATA_BLOB*      pDataIn,
    IN              LPCWSTR         szDataDescr,
    IN OPTIONAL     DATA_BLOB*      pOptionalEntropy,
    IN              PVOID           pvReserved,
    IN OPTIONAL     CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct,
    IN              DWORD           dwFlags,
    OUT             DATA_BLOB*      pDataOut            // out encr blob
    );

DWORD
MyCryptUnprotectData(
    IN              DATA_BLOB*      pDataIn,             // in encr blob
    OUT OPTIONAL    LPWSTR*         ppszDataDescr,       // out
    IN OPTIONAL     DATA_BLOB*      pOptionalEntropy,
    IN              PVOID           pvReserved,
    IN OPTIONAL     CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct,
    IN              DWORD           dwFlags,
    OUT             DATA_BLOB*      pDataOut,
    OUT             LPDWORD         pdwReprotectFlags);

void FreeEnumOldMachKeyEntries(
                               PKEY_CONTAINER_INFO pInfo
                               );

void FreeEnumRegEntries(
                       PKEY_CONTAINER_INFO pInfo
                       );

void FreeContainerInfo(
                       PKEY_CONTAINER_INFO pInfo
                       );

BOOL WINAPI FIsWinNT(void);

DWORD
IsLocalSystem(
              BOOL *pfIsLocalSystem
              );

DWORD
GetUserTextualSidA(
    LPSTR lpBuffer,
    LPDWORD nSize
    );

DWORD
GetUserTextualSidW(
    LPWSTR lpBuffer,
    LPDWORD nSize
    );

DWORD SetMachineGUID();

DWORD SetContainerUserName(
                           IN LPSTR pszUserName,
                           IN PKEY_CONTAINER_INFO pContInfo
                           );

DWORD ReadContainerInfo(
                        IN DWORD dwProvType,
                        IN LPSTR pszContainerName,
                        IN BOOL fMachineKeyset,
                        IN DWORD dwFlags,
                        OUT PKEY_CONTAINER_INFO pContInfo
                        );

DWORD WriteContainerInfo(
                         IN DWORD dwProvType,
                         IN LPWSTR pwszFileName,
                         IN BOOL fMachineKeyset,
                         IN PKEY_CONTAINER_INFO pContInfo
                         );

DWORD DeleteContainerInfo(
                          IN DWORD dwProvType,
                          IN LPSTR pszFileName,
                          IN BOOL fMachineKeyset
                          );

DWORD GetUniqueContainerName(
                             IN KEY_CONTAINER_INFO *pContInfo,
                             OUT BYTE *pbData,
                             OUT DWORD *pcbData
                             );

DWORD GetNextContainer(
    IN      DWORD   dwProvType,
    IN      BOOL    fMachineKeyset,
    IN      DWORD   dwFlags,
    OUT     LPSTR   pszNextContainer,
    IN OUT  DWORD   *pcbNextContainer,
    IN OUT  HANDLE  *phFind
    );

DWORD SetSecurityOnContainer(
                             IN LPCWSTR wszFileName,
                             IN DWORD dwProvType,
                             IN DWORD fMachineKeyset,
                             IN SECURITY_INFORMATION SecurityInformation,
                             IN PSECURITY_DESCRIPTOR pSecurityDescriptor
                             );

//+ ===========================================================================
//
//      The function adjusts the token priviledges so that SACL information
//      may be set on a key container.  If the token priviledges may be set
//      indicated by the pUser->dwOldKeyFlags having the PRIVILEDGE_FOR_SACL value set.
//      value set then the token privilege is adjusted before the security
//      descriptor is set on the container.  This is needed for the key
//      migration case when keys are being migrated from the registry to files.
//- ============================================================================
DWORD SetSecurityOnContainerWithTokenPriviledges(
                                          IN DWORD dwOldKeyFlags,
                                          IN LPCWSTR wszFileName,
                                          IN DWORD dwProvType,
                                          IN DWORD fMachineKeyset,
                                          IN SECURITY_INFORMATION SecurityInformation,
                                          IN PSECURITY_DESCRIPTOR pSecurityDescriptor
                                          );

DWORD GetSecurityOnContainer(
                             IN LPCWSTR wszFileName,
                             IN DWORD dwProvType,
                             IN DWORD fMachineKeyset,
                             IN SECURITY_INFORMATION RequestedInformation,
                             OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
                             IN OUT DWORD *pcbSecurityDescriptor
                             );

// Converts to UNICODE and uses RegOpenKeyExW
DWORD MyRegOpenKeyEx(IN HKEY hRegKey,
                     IN LPSTR pszKeyName,
                     IN DWORD dwReserved,
                     IN REGSAM SAMDesired,
                     OUT HKEY *phNewRegKey);

// Converts to UNICODE and uses RegDeleteKeyW
DWORD MyRegDeleteKey(IN HKEY hRegKey,
                     IN LPSTR pszKeyName);

DWORD AllocAndSetLocationBuff(
                              BOOL fMachineKeySet,
                              DWORD dwProvType,
                              CONST char *pszUserID,
                              HKEY *phTopRegKey,
                              TCHAR **ppszLocBuff,
                              BOOL fUserKeys,
                              BOOL *pfLeaveOldKeys,
                              LPDWORD pcbBuff);

//
// Enumerates the old machine keys in the file system
// keys were in this location in Beta 2 and Beta 3 of NT5/Win2K
//
DWORD EnumOldMachineKeys(
                         IN DWORD dwProvType,
                         IN OUT PKEY_CONTAINER_INFO pContInfo
                         );

DWORD GetNextEnumedOldMachKeys(
                              IN PKEY_CONTAINER_INFO pContInfo,
                              IN BOOL fMachineKeyset,
                              OUT BYTE *pbData,
                              OUT DWORD *pcbData
                              );

//
// Enumerates the keys in the registry into a list of entries
//
DWORD EnumRegKeys(
                  IN OUT PKEY_CONTAINER_INFO pContInfo,
                  IN BOOL fMachineKeySet,
                  IN DWORD dwProvType,
                  OUT BYTE *pbData,
                  IN OUT DWORD *pcbData
                  );

DWORD GetNextEnumedRegKeys(
                           IN PKEY_CONTAINER_INFO pContInfo,
                           OUT BYTE *pbData,
                           OUT DWORD *pcbData
                           );

//+ ===========================================================================
//
//      The function adjusts the token priviledges so that SACL information
//      may be gotten and then opens the indicated registry key.  If the token
//      priviledges may be set then the reg key is opened anyway but the
//      flags field will not have the PRIVILEDGE_FOR_SACL value set.
//
//- ============================================================================
DWORD OpenRegKeyWithTokenPriviledges(
                                     IN HKEY hTopRegKey,
                                     IN LPSTR pszRegKey,
                                     OUT HKEY *phRegKey,
                                     OUT DWORD *pdwFlags);

DWORD LoadStrings();

void UnloadStrings();

typedef struct _EXPO_OFFLOAD_STRUCT {
        DWORD       dwVersion;
        HMODULE     hInst;
        FARPROC     pExpoFunc;
} EXPO_OFFLOAD_STRUCT, *PEXPO_OFFLOAD_STRUCT;

//
// Function : FreeOffloadInfo
//
// Description : The function takes a pointer to Offload Information as the
//               first parameter of the call.  The function frees the
//               information.
//
void FreeOffloadInfo(
                     IN OUT PEXPO_OFFLOAD_STRUCT pOffloadInfo
                     );

//
// Function : InitExpOffloadInfo
//
// Description : The function takes a pointer to Offload Information as the
//               first parameter of the call.  The function checks in the
//               registry to see if an offload module has been registered.
//               If a module is registered then it loads the module
//               and gets the OffloadModExpo function pointer.
//
BOOL InitExpOffloadInfo(
                        IN OUT PEXPO_OFFLOAD_STRUCT *ppExpoOffloadInfo
                        );

//
// Function : ModularExpOffload
//
// Description : This function does the offloading of modular exponentiation.
//               The function takes a pointer to Offload Information as the
//               first parameter of the call.  If this pointer is not NULL
//               then the function will use this module and call the function.
//               The exponentiation with MOD function will implement
//               Y^X MOD P  where Y is the buffer pbBase, X is the buffer
//               pbExpo and P is the buffer pbModulus.  The length of the
//               buffer pbExpo is cbExpo and the length of pbBase and
//               pbModulus is cbModulus.  The resulting value is output
//               in the pbResult buffer and has length cbModulus.
//               The pReserved and dwFlags parameters are currently ignored.
//               If any of these functions fail then the function fails and
//               returns FALSE.  If successful then the function returns
//               TRUE.  If the function fails then most likely the caller
//               should fall back to using hard linked modular exponentiation.
//
BOOL ModularExpOffload(
                       IN PEXPO_OFFLOAD_STRUCT pOffloadInfo,
                       IN BYTE *pbBase,
                       IN BYTE *pbExpo,
                       IN DWORD cbExpo,
                       IN BYTE *pbModulus,
                       IN DWORD cbModulus,
                       OUT BYTE *pbResult,
                       IN VOID *pReserved,
                       IN DWORD dwFlags
                       );

#ifdef USE_HW_RNG
#ifdef _M_IX86
// stuff for INTEL RNG usage

//
// Function : GetRNGDriverHandle
//
// Description : Gets the handle to the INTEL RNG driver if available, then
//               checks if the chipset supports the hardware RNG.  If so
//               the previous driver handle is closed if necessary and the
//               new handle is assigned to the passed in parameter.
//
extern DWORD
GetRNGDriverHandle(
    IN OUT HANDLE *phDriver);

//
// Function : CheckIfRNGAvailable
//
// Description : Checks if the INTEL RNG driver is available, if so then
//               checks if the chipset supports the hardware RNG.
//
extern DWORD
CheckIfRNGAvailable(
    void);

//
// Function : HWRNGGenRandom
//
// Description : Uses the passed in handle to the INTEL RNG driver
//               to fill the buffer with random bits.  Actually uses
//               XOR to fill the buffer so that the passed in buffer
//               is also mixed in.
//
DWORD
HWRNGGenRandom(
               IN HANDLE hRNGDriver,
               IN OUT BYTE *pbBuffer,
               IN DWORD dwLen);

#ifdef TEST_HW_RNG
//
// Function : SetupHWRNGIfRegistered
//
// Description : Checks if there is a registry setting indicating the HW RNG
//               is to be used.  If the registry entry is there then it attempts
//               to get the HW RNG driver handle.
//
extern DWORD
SetupHWRNGIfRegistered(
    OUT HANDLE *phRNGDriver);
#endif // TEST_HW_RNG

#endif // _M_IX86
#endif // USE_HW_RNG

//
// Function for managing Force High Key Protection
//

BOOL IsForceHighProtectionEnabled(
    IN PKEY_CONTAINER_INFO  pContInfo);

DWORD InitializeForceHighProtection(
    IN OUT PKEY_CONTAINER_INFO  pContInfo);

//
// Functions for managing cached private keys.
//

BOOL IsCachedKeyValid(
    IN PKEY_CONTAINER_INFO  pContInfo,
    IN BOOL                 fSigKey);

DWORD SetCachedKeyTimestamp(
    IN PKEY_CONTAINER_INFO  pContInfo,
    IN BOOL                 fSigKey);

DWORD InitializeKeyCacheInfo(
    IN OUT PKEY_CONTAINER_INFO pContInfo);

#ifdef __cplusplus
}
#endif

#endif // __CONTMAN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\encode.h ===
#include "algid.h"

#ifndef _ENCODE_H_
#define	_ENCODE_H_

#ifdef __cplusplus
extern "C" {
#endif

/* tag definitions for ASN.1 encoding decoding */
#define	INTEGER_TAG			0x02
#define	CHAR_STRING_TAG		0x16
#define	OCTET_STRING_TAG	0x04
#define	BIT_STRING_TAG		0x03
#define	UTCTIME_TAG			0x17
#define	SEQUENCE_TAG		0x36
#define	SET_OF_TAG			0x11
#define	OBJECT_ID_TAG		0x06

/* definitions of maximum lengths needed for the ASN.1 encoded
   form of some of the common fields in a certificate */
#define	MAXVALIDITYLEN		0x24
#define	MAXKEYINFOLEN		0x50
#define MAXALGIDLEN			0x0A
#define	MAXOBJIDLEN			0x0A
#define MAXNAMEVALUELEN		0x40
#define	UTCTIMELEN			0x0F
#define	MAXPUBKEYDATALEN	0x30
#define	VERSIONLEN			0x03
#define MAXENCODEDSIGLEN	0x30
#define	MAXHEADERLEN		0x08
#define	MINHEADERLEN		0x03
#define	MAXTIMELEN			0x20

/* definitions for scrubbing memory */
#define	ALLBITSOFF			0x00
#define	ALLBITSON			0xFF

/* prototypes for the functions in encode.c */
long EncodeLength (BYTE *pbEncoded, DWORD dwLen, BOOL Writeflag);
long EncodeAlgid (BYTE *pbEncoded, ALG_ID Algid, BOOL Writeflag);
long EncodeInteger (BYTE *pbEncoded, CONST BYTE *pbInt, DWORD dwLen, BOOL Writeflag);
long EncodeString (BYTE *pbEncoded, CONST BYTE *pbStr, DWORD dwLen, BOOL Writeflag);
long EncodeOctetString (BYTE *pbEncoded, CONST BYTE *pbStr, DWORD dwLen, BOOL Writeflag);
long EncodeBitString (BYTE *pbEncoded, CONST BYTE *pbStr, DWORD dwLen, BOOL Writeflag);
long EncodeUTCTime (BYTE *pbEncoded, time_t Time, BOOL Writeflag);
long EncodeHeader (BYTE *pbEncoded, DWORD dwLen, BOOL Writeflag);
long EncodeSetOfHeader (BYTE *pbEncoded, DWORD dwLen, BOOL Writeflag);
long EncodeName (BYTE *pbEncoded, CONST BYTE *pbName, DWORD dwLen, BOOL Writeflag);
long DecodeLength (DWORD *pdwLen, CONST BYTE *pbEncoded);
long DecodeAlgid (ALG_ID *pAlgid, CONST BYTE *pbEncoded, BOOL Writeflag);
long DecodeHeader (DWORD *pdwLen, CONST BYTE *pbEncoded);
long DecodeSetOfHeader (DWORD *pdwLen, CONST BYTE *pbEncoded);
long DecodeInteger (BYTE *pbInt, DWORD *pdwLen, CONST BYTE *pbEncoded, BOOL Writeflag);
long DecodeString (BYTE *pbStr, DWORD *pdwLen, CONST BYTE *pbEncoded, BOOL Writeflag);
long DecodeOctetString (BYTE *pbStr, DWORD *pdwLen, CONST BYTE *pbEncoded, BOOL Writeflag);
long DecodeBitString (BYTE *pbStr, DWORD *pdwLen, CONST BYTE *pbEncoded, BOOL Writeflag);
long DecodeUTCTime (time_t *pTime, CONST BYTE *pbEncoded, BOOL Writeflag);
long DecodeName (BYTE *pbName, DWORD *pdwLen, CONST BYTE *pbEncoded, BOOL Writeflag);

#ifdef __cplusplus
}
#endif

#endif	// _ENCODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\fips\driver\fipscryp.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1999
//
// File:        fipscryp.c
//
// Contents:    Base level stuff for the FIPS mode crypto device driver
//
//
// History:     04 JAN 00,  Jeffspel    Stolen from KSECDD
//                 FEB 00,  kschutz
//
//------------------------------------------------------------------------

#include <ntddk.h>
#include <fipsapi.h>
#include <fipslog.h>
#include <randlib.h>

#pragma hdrstop

NTSTATUS SelfMACCheck(IN LPWSTR pszImage);
NTSTATUS AlgorithmCheck(void);


/*
typedef struct _DEVICE_EXTENSION {

    ULONG   OpenCount;
    PVOID   CodeHandle;
    PVOID   DataHandle;
    
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;
*/

VOID
FipsLogError(
    IN  PVOID Object,
    IN  NTSTATUS ErrorCode,
    IN  PUNICODE_STRING Insertion,
    IN  ULONG DumpData
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DeviceObject -  Supplies a pointer to the device object associated
                    with the device that had the error, early in
                    initialization, one may not yet exist.

    Insertion -     An insertion string that can be used to log
                    additional data. Note that the message file
                    needs %2 for this insertion, since %1
                    is the name of the driver

    ErrorCode -     Supplies the IO status for this particular error.

    DumpData -      One word to dump

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;

    errorLogEntry = IoAllocateErrorLogEntry(
        Object,
        (UCHAR) (
            sizeof(IO_ERROR_LOG_PACKET) + 
            (Insertion ? Insertion->Length + sizeof(WCHAR) : 0)
            )
        );

    ASSERT(errorLogEntry != NULL);

    if (errorLogEntry == NULL) {

        return;
    }

    errorLogEntry->ErrorCode = ErrorCode;
    errorLogEntry->SequenceNumber = 0;
    errorLogEntry->MajorFunctionCode = 0;
    errorLogEntry->RetryCount = 0;
    errorLogEntry->UniqueErrorValue = 0;
    errorLogEntry->FinalStatus = STATUS_SUCCESS;
    errorLogEntry->DumpDataSize = (DumpData ? sizeof(ULONG) : 0);
    errorLogEntry->DumpData[0] = DumpData;

    if (Insertion) {

        errorLogEntry->StringOffset = 
            sizeof(IO_ERROR_LOG_PACKET);

        errorLogEntry->NumberOfStrings = 1;

        RtlCopyMemory(
            ((PCHAR)(errorLogEntry) + errorLogEntry->StringOffset),
            Insertion->Buffer,
            Insertion->Length
            );
    } 

    IoWriteErrorLogEntry(errorLogEntry);
}

NTSTATUS
FipsCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    //PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    /*
    if (irpStack->MajorFunction == IRP_MJ_CREATE) {

        if (deviceExtension->OpenCount++ == 0) {

            extern DWORD Spbox[8][64];

            deviceExtension->CodeHandle = MmLockPagableCodeSection(A_SHAInit);
            MmLockPagableSectionByHandle(deviceExtension->CodeHandle);

            deviceExtension->DataHandle = MmLockPagableDataSection(Spbox);
            MmLockPagableSectionByHandle(deviceExtension->DataHandle);

        }
        
    } else {

        if (--deviceExtension->OpenCount == 0) {

            MmUnlockPagableImageSection(deviceExtension->CodeHandle);
            MmUnlockPagableImageSection(deviceExtension->DataHandle);

        }
    }
    */

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

NTSTATUS
FipsDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION  ioStackLocation = IoGetCurrentIrpStackLocation(Irp);
    ULONG ioControlCode = ioStackLocation->Parameters.DeviceIoControl.IoControlCode;
    NTSTATUS status = STATUS_NOT_SUPPORTED;
    
    Irp->IoStatus.Information = 0;

    switch (ioControlCode) {
     
        FIPS_FUNCTION_TABLE FipsFuncs;
        FIPS_FUNCTION_TABLE_1 OldFipsFuncsV1;

        case IOCTL_FIPS_GET_FUNCTION_TABLE:

            if (ioStackLocation->Parameters.DeviceIoControl.OutputBufferLength >=
                sizeof(FipsFuncs)) {

                FipsFuncs.FipsDesKey = FipsDesKey;
                FipsFuncs.FipsDes = FipsDes;
                FipsFuncs.Fips3Des3Key = Fips3Des3Key;
                FipsFuncs.Fips3Des = Fips3Des;
                FipsFuncs.FipsSHAInit = FipsSHAInit;
                FipsFuncs.FipsSHAUpdate = FipsSHAUpdate;
                FipsFuncs.FipsSHAFinal = FipsSHAFinal;
                FipsFuncs.FipsCBC = FipsCBC;
                FipsFuncs.FIPSGenRandom = FIPSGenRandom;
                FipsFuncs.FipsBlockCBC = FipsBlockCBC;
                FipsFuncs.FipsHmacSHAInit = FipsHmacSHAInit;
                FipsFuncs.FipsHmacSHAUpdate = FipsHmacSHAUpdate;
                FipsFuncs.FipsHmacSHAFinal = FipsHmacSHAFinal;
                FipsFuncs.HmacMD5Init = HmacMD5Init;
                FipsFuncs.HmacMD5Update = HmacMD5Update;
                FipsFuncs.HmacMD5Final = HmacMD5Final;

                *((PFIPS_FUNCTION_TABLE) Irp->AssociatedIrp.SystemBuffer) = 
                    FipsFuncs;

                Irp->IoStatus.Information = sizeof(FipsFuncs);

                status = STATUS_SUCCESS;
            
            } else if (ioStackLocation->Parameters.DeviceIoControl.OutputBufferLength >=
                        sizeof(OldFipsFuncsV1)) {

                OldFipsFuncsV1.FipsDesKey = FipsDesKey;
                OldFipsFuncsV1.FipsDes = FipsDes;
                OldFipsFuncsV1.Fips3Des3Key = Fips3Des3Key;
                OldFipsFuncsV1.Fips3Des = Fips3Des;
                OldFipsFuncsV1.FipsSHAInit = FipsSHAInit;
                OldFipsFuncsV1.FipsSHAUpdate = FipsSHAUpdate;
                OldFipsFuncsV1.FipsSHAFinal = FipsSHAFinal;
                OldFipsFuncsV1.FipsCBC = FipsCBC;
                OldFipsFuncsV1.FIPSGenRandom = FIPSGenRandom;
                OldFipsFuncsV1.FipsBlockCBC = FipsBlockCBC;
                
                *((PFIPS_FUNCTION_TABLE_1) Irp->AssociatedIrp.SystemBuffer) = 
                    OldFipsFuncsV1;

                Irp->IoStatus.Information = sizeof(OldFipsFuncsV1);

                status = STATUS_SUCCESS;
                
            } else {

                status = STATUS_BUFFER_TOO_SMALL;            
            }

            break;
    }

    Irp->IoStatus.Status = status;

    IoCompleteRequest(
        Irp, 
        IO_NO_INCREMENT
        );

    return status;
}

VOID
FipsUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    PDEVICE_OBJECT deviceObject = DriverObject->DeviceObject;

    ShutdownRNG(NULL);

    // Delete the device from the system 
    IoDeleteDevice(deviceObject);

    FipsDebug(
        DEBUG_TRACE,
        ("Fips driver unloaded\n")
        );
}

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the synchronous NULL device driver.
    This routine creates the device object for the NullS device and performs
    all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    RTL_QUERY_REGISTRY_TABLE paramTable[2];
    UNICODE_STRING fileName, deviceName;
    PDEVICE_OBJECT deviceObject = NULL;
    NTSTATUS status;
    BOOL rngInitialized = FALSE;

    __try {

        //
        // Create the device object.
        //
        RtlInitUnicodeString( 
            &deviceName,
            FIPS_DEVICE_NAME 
            );

        status = IoCreateDevice( 
            DriverObject,
            0 /*sizeof(DEVICE_EXTENSION)*/,
            &deviceName,
            FILE_DEVICE_FIPS,
            0,
            FALSE,
            &deviceObject 
            );

        if (!NT_SUCCESS( status )) {

            __leave;
        }

        deviceObject->Flags |= DO_BUFFERED_IO;

        // initialize the device extension
        /*
        RtlZeroMemory(
            deviceObject->DeviceExtension,
            sizeof(PDEVICE_EXTENSION)
            );
        */

        // append the name of our driver to the system root path
        RtlInitUnicodeString(
            &fileName,
            L"\\SystemRoot\\System32\\Drivers\\fips.sys"
            );

        status = SelfMACCheck(fileName.Buffer); 

        if (!NT_SUCCESS(status)) {

            FipsLogError(
                DriverObject,
                FIPS_MAC_INCORRECT,
                NULL,
                status
                );  

            __leave;
        }

        InitializeRNG(NULL);
        rngInitialized = TRUE;

        status = AlgorithmCheck();

        if (!NT_SUCCESS(status)) {

            FipsLogError(
                DriverObject,
                FIPS_SELF_TEST_FAILURE,
                NULL,
                status
                );  

            __leave;
        }

        //
        // Initialize the driver object with this device driver's entry points.
        //
        DriverObject->DriverUnload = FipsUnload;
        DriverObject->MajorFunction[IRP_MJ_CREATE] = FipsCreateClose;
        DriverObject->MajorFunction[IRP_MJ_CLOSE]  = FipsCreateClose;
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = FipsDeviceControl ;
    }
    __finally {

        if (status != STATUS_SUCCESS) {

            if (rngInitialized) {

                ShutdownRNG(NULL);
            }

            if (deviceObject) {

                IoDeleteDevice(deviceObject);
            }

        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\global.h ===
#ifndef __AWGLOBAL_H__
#define __AWGLOBAL_H__ 1

#ifdef __cplusplus
extern "C" {
#endif

#include "rsa.h"

BYTE TransByte(BYTE in);
BYTE UnTransByte(BYTE in);
WORD Conv11to5(BYTE FAR *src, BYTE FAR *dest, WORD group);
void Conv5to11(BYTE FAR *src, BYTE FAR *dest, WORD group);

void RestoreKeyFromData (BSAFE_KEY BSAFE_PTR, LPWORD);
DWORD RandDWord(void);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\mac.h ===
// Message Authentication Code structures

typedef struct _MACstate {
    DWORD dwBufLen;
    BYTE  Feedback[MAX_BLOCKLEN];
    BYTE  Buffer[MAX_BLOCKLEN];
    BOOL  FinishFlag;
} MACstate;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\global32.h ===
#ifndef __AWGLOBAL32_H__
#define __AWGLOBAL32_H__ 1

#include <windows.h>
#include "rsa.h"

#define BSAFE_PTR	 far *
#define UWORD		 WORD
#define ULONG		 DWORD

#define RSAM ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'M'<<24))

void B_ADD_32(LPDWORD, LPDWORD, LPDWORD, DWORD);
void B_SUB_32(LPDWORD, LPDWORD, LPDWORD, DWORD);
void B_INC_32(LPDWORD, DWORD);
void B_DEC_32(LPDWORD, DWORD);
void B_CONST_32(LPDWORD, DWORD, DWORD);
void B_2EXP_32(LPDWORD, DWORD, DWORD);
DWORD B_ACC_32(LPDWORD, DWORD, LPDWORD, DWORD);
DWORD B_LENW_32(LPDWORD, DWORD);
DWORD B_LEN_32(LPDWORD, DWORD);
void B_PSQ_32(LPDWORD, LPDWORD, DWORD);
void B_PMPYL_32(LPDWORD, LPDWORD, LPDWORD, DWORD);
int  B_CMP_32(LPDWORD, LPDWORD, DWORD);
void B_QRX_32(LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, DWORD, DWORD);
void B_PMPY_32(LPDWORD, LPDWORD, LPDWORD, DWORD);
void MOD_SQX_32(LPDWORD, LPDWORD, LPDWORD, DWORD, DWORD);
void MOD_MPYX_32(LPDWORD, LPDWORD, LPDWORD, LPDWORD, DWORD, DWORD);
void B_PDIV_32(LPDWORD, LPDWORD, LPDWORD, LPDWORD, DWORD, DWORD);
void B_PEGCD_32(LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, DWORD);
void MOD_EXP_32(LPDWORD, LPDWORD, LPDWORD, LPDWORD, DWORD);
void B_UNEXP_32(LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD);
void BSAFE_ENC_DEC_PUBLIC_PRIVATE_32(LPBSAFE_KEY, LPBYTE, LPBYTE, WORD);

LPVOID IFGlobalAlloc32(WORD, DWORD);
void IFGlobalFree32(LPVOID); 
   
typedef struct {
    DWORD FEE[MAXMODWORDS]; /* encryption exponent */
    DWORD FPP[MAXPRMWORDS]; /* first prime */
    DWORD FQQ[MAXPRMWORDS]; /* second prime */
    DWORD FNN[MAXMODWORDS]; /* modulus n = p * q */
} FRAME_32, FAR *LPFRAME_32;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\montgome.h ===
struct MontgomeryData
{
	DWORD K;			/* length of modulus */
	DWORD M0Prime;  	/* -M[0]**(-1) mod 2**DIGIT_BITS */
	LPDWORD M;      	/* modulus */
	LPDWORD product;	/* space for temporary product */
};

void MontgomerySetup(struct MontgomeryData *context, LPDWORD M, DWORD N);
void MontgomeryTeardown(struct MontgomeryData *context);
void MontgomeryTransform(struct MontgomeryData *context, LPDWORD X);
void MontgomeryReduce(struct MontgomeryData *context, LPDWORD T, LPDWORD X);
void MontgomeryModSquare(struct MontgomeryData *context, LPDWORD A, LPDWORD B);
void MontgomeryModMultiply(struct MontgomeryData *context, LPDWORD A, LPDWORD B, LPDWORD C);
void MontgomeryModExp(LPDWORD A, LPDWORD B, LPDWORD C, LPDWORD D, DWORD len);
void MontgomeryModRoot(LPDWORD M, LPDWORD C, LPDWORD PP, LPDWORD QQ, LPDWORD DP, LPDWORD DQ, LPDWORD CR, DWORD PSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\ntagum.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ntagum.h                                               //
//  DESCRIPTION   : include file                                           //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Feb 16 1995 larrys  Fix problem for 944 build                      //
//      May 23 1997 jeffspel Added provider type checking                  //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////
#ifndef __NTAGUM_H__
#define __NTAGUM_H__

#ifdef __cplusplus
extern "C" {
#endif

// prototypes for the NameTag User Manager
extern BOOL WINAPI FIsWinNT(void);

extern DWORD
NTagLogonUser(
    LPCSTR pszUserID,
    DWORD dwFlags,
    void **UserInfo,
    HCRYPTPROV *phUID,
    DWORD dwProvType,
    LPSTR pszProvName);

extern void LogoffUser(void *UserInfo);

extern DWORD
ReadRegValue(
    HKEY hLoc,
    char *pszName,
    BYTE **ppbData,
    DWORD *pcbLen,
    BOOL fAlloc);

extern DWORD
ReadKey(
    HKEY hLoc,
    char *pszName,
    BYTE **ppbData,
    DWORD *pcbLen,
    PNTAGUserList pUser,
    HCRYPTKEY hKey,
    BOOL *pfPrivKey,
    BOOL fKeyExKey,
    BOOL fLastKey);

BOOL SaveKey(
             HKEY hRegKey,
             CONST char *pszName,
             void *pbData,
             DWORD dwLen,
             PNTAGUserList pUser,
             BOOL fPrivKey,
             DWORD dwFlags,
             BOOL fExportable
             );

extern DWORD
ProtectPrivKey(
    IN OUT PNTAGUserList pTmpUser,
    IN LPWSTR szPrompt,
    IN DWORD dwFlags,
    IN BOOL fSigKey);

extern DWORD
UnprotectPrivKey(
    IN OUT PNTAGUserList pTmpUser,
    IN LPWSTR szPrompt,
    IN BOOL fSigKey,
    IN BOOL fAlwaysDecrypt);

#if 0
extern DWORD
RemovePublicKeyExportability(
    IN PNTAGUserList pUser,
    IN BOOL fExchange);

extern DWORD
MakePublicKeyExportable(
    IN PNTAGUserList pUser,
    IN BOOL fExchange);

extern DWORD
CheckPublicKeyExportability(
    IN PNTAGUserList pUser,
    IN BOOL fExchange);
#endif

#ifdef __cplusplus
}
#endif


#endif // __NTAGUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\ntagimp1.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ntagimp1.h                                             //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Apr 19 1995 larrys  Cleanup                                        //
//      May  5 1995 larrys  Changed struct Hash_List_Defn                  //
//      May 10 1995 larrys  added private api calls                        //
//      Aug 15 1995 larrys  Moved CSP_USE_DES to sources file              //
//      Sep 12 1995 Jeffspel/ramas  Merged STT onto CSP                    //
//      Sep 25 1995 larrys  Changed MAXHASHLEN                             //
//      Oct 27 1995 rajeshk Added RandSeed stuff to UserList               //
//      Feb 29 1996 rajeshk Added HashFlags                                                //
//      Sep  4 1996 mattt       Changes to facilitate building STRONG algs         //
//      Sep 16 1996 mattt   Added Domestic naming                          //
//      Apr 29 1997 jeffspel Protstor support and EnumAlgsEx support       //
//      May 23 1997 jeffspel Added provider type checking                  //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __NTAGIMP1_H__
#define __NTAGIMP1_H__

#ifdef __cplusplus
extern "C" {
#endif

// define which algorithms to include
#define CSP_USE_SHA
#define CSP_USE_RC4
#define CSP_USE_MD2
#define CSP_USE_MD4
#define CSP_USE_MD5
#define CSP_USE_SHA1
#define CSP_USE_MAC
#define CSP_USE_RC2
#define CSP_USE_SSL3SHAMD5
#define CSP_USE_SSL3
#define CSP_USE_DES
#define CSP_USE_3DES
#define CSP_USE_AES

// handle definition types
#define USER_HANDLE                             0x0
#define HASH_HANDLE                             0x1
#define KEY_HANDLE                              0x2
#define SIGPUBKEY_HANDLE                        0x3
#define EXCHPUBKEY_HANDLE                       0x4

#ifdef _WIN64
#define     HANDLE_MASK     0xE35A172CD96214A0
#define     ALIGNMENT_BOUNDARY 7
#else
#define     HANDLE_MASK     0xE35A172C
#define     ALIGNMENT_BOUNDARY 3
#endif // _WIN64

typedef ULONG_PTR HNTAG;

typedef struct _htbl {
        void                    *pItem;
        DWORD                   dwType;
} HTABLE;

#define HNTAG_TO_HTYPE(hntag)   (BYTE)(((HTABLE*)((HNTAG)hntag ^ HANDLE_MASK))->dwType)

#define MAXHASHLEN              A_SHA_DIGEST_LEN    // Longest expected hash.

#define PCT1_MASTER_KEYSIZE     16
#define SSL2_MASTER_KEYSIZE      5
#define SSL3_MASTER_KEYSIZE     48

#define RSA_KEYSIZE_INC          8

#define DEFAULT_WEAK_SALT_LENGTH   11   // salt length in bytes
#define DEFAULT_STRONG_SALT_LENGTH  0   // salt length in bytes

#define MAX_KEY_SIZE            48      // largest key size (SSL3 masterkey)

#define SSL2_MAX_MASTER_KEYSIZE 24

#define RC2_MAX_WEAK_EFFECTIVE_KEYLEN     56
#define RC2_MAX_STRONG_EFFECTIVE_KEYLEN 1024

// effective key length defines for RC2
#define RC2_DEFAULT_EFFECTIVE_KEYLEN    40
#define RC2_SCHANNEL_DEFAULT_EFFECTIVE_KEYLEN    128
#define RC2_MIN_EFFECTIVE_KEYLEN        1

// this is for the domestic provider which is backward compatible
// with the international provider
#define RC2_MAX_STRONG_EFFECTIVE_KEYLEN    1024
#define RC2_MAX_WEAK_EFFECTIVE_KEYLEN        56

// defines for SGC
#define SGC_RSA_MAX_EXCH_MODLEN     2048    // 16384 bit
#define SGC_RSA_DEF_EXCH_MODLEN     128

#define     STORAGE_RC4_KEYLEN      5   // keys always stored under 40-bit RC4 key
#define     STORAGE_RC4_TOTALLEN    16  // 0-value salt fills rest

// types of key storage
#define REG_KEYS                    0
#define PROTECTED_STORAGE_KEYS      1
#define PROTECTION_API_KEYS         2

// structure to hold protected storage info
typedef struct _PStore_Info
{
    HINSTANCE   hInst;
    void        *pProv;
    GUID        SigType;
    GUID        SigSubtype;
    GUID        ExchType;
    GUID        ExchSubtype;
    LPWSTR      szPrompt;
    DWORD       cbPrompt;
} PSTORE_INFO;

// definition of a user list
typedef struct _UserList
{
    DWORD                           Rights;
    DWORD                           dwProvType;
    DWORD                           hPrivuid;
    HCRYPTPROV                      hUID;
    BOOL                            fIsLocalSystem;
    DWORD                           dwEnumalgs;
    DWORD                           dwEnumalgsEx;
    KEY_CONTAINER_INFO              ContInfo;
    DWORD                           ExchPrivLen;
    BYTE                            *pExchPrivKey;
    DWORD                           SigPrivLen;
    BYTE                            *pSigPrivKey;
    HKEY                            hKeys;              // AT NTag only
    size_t                          UserLen;
    BYTE                            *pCachePW;
    BYTE                            *pUser;
    HANDLE                          hWnd;
    DWORD                           dwKeyStorageType;
    PSTORE_INFO                     *pPStore;
    LPWSTR                          pwszPrompt;
    DWORD                           dwOldKeyFlags;
#ifdef USE_SGC
    BOOL                            dwSGCFlags;
    BYTE                            *pbSGCKeyMod;
    DWORD                           cbSGCKeyMod;
    DWORD                           dwSGCKeyExpo;
#endif
    HANDLE                          hRNGDriver;
    CRITICAL_SECTION                CritSec;
    EXPO_OFFLOAD_STRUCT             *pOffloadInfo; // info for offloading modular expo
    DWORD                           dwCspTypeId;
    LPSTR                           szProviderName;
} NTAGUserList, *PNTAGUserList;


// UserList Rights flags (uses CRYPT_MACHINE_KEYSET and CRYPT_VERIFYCONTEXT)
#define CRYPT_DISABLE_CRYPT             0x1
#define CRYPT_DES_HASHKEY_BACKWARDS     0x4

#ifdef CSP_USE_AES
#define CRYPT_AES128_ROUNDS             10
#define CRYPT_AES192_ROUNDS             12
#define CRYPT_AES256_ROUNDS             14

#define CRYPT_AES128_BLKLEN             16
#define CRYPT_AES192_BLKLEN             16
#define CRYPT_AES256_BLKLEN             16
#endif

#define CRYPT_BLKLEN    8               // Bytes in a crypt block
#define MAX_SALT_LEN    24

#ifdef CSP_USE_AES
#define MAX_BLOCKLEN                    CRYPT_AES256_BLKLEN
#else
#define MAX_BLOCKLEN                    8
#endif

// definition of a key list
typedef struct _KeyList
{
    HCRYPTPROV      hUID;                   // must be first
    ALG_ID          Algid;
    DWORD           Rights;
    DWORD           cbKeyLen;
    BYTE            *pKeyValue;             // Actual Key
    DWORD           cbDataLen;
    BYTE            *pData;                 // Inflated Key or Multi-phase
    BYTE            IV[MAX_BLOCKLEN];       // Initialization vector
    BYTE            FeedBack[MAX_BLOCKLEN]; // Feedback register
    DWORD           InProgress;             // Flag to indicate encryption
    DWORD           cbSaltLen;              // Salt length
    BYTE            rgbSalt[MAX_SALT_LEN];  // Salt value
    DWORD           Padding;                // Padding values
    DWORD           Mode;                   // Mode of cipher
    DWORD           ModeBits;               // Number of bits to feedback
    DWORD           Permissions;            // Key permissions
    DWORD           EffectiveKeyLen;        // used by RC2
    BYTE            *pbParams;              // may be used in OAEP
    DWORD           cbParams;               // length of pbParams
    DWORD           dwBlockLen;             // encryption block length; 
                                            // valid for block ciphers only
#ifdef STT
    DWORD           cbInfo;
    BYTE            rgbInfo[MAXCCNLEN];
#endif
} NTAGKeyList, *PNTAGKeyList;


// Packed version of NTAGKeyList. This is used when building opaque
// blobs, and is necessary to properly support WOW64 operation.
typedef struct _PackedKeyList
{
    // BLOBHEADER
    ALG_ID          Algid;
    DWORD           Rights;
    DWORD           cbKeyLen;
    DWORD           cbDataLen;
    BYTE            IV[MAX_BLOCKLEN];       // Initialization vector
    BYTE            FeedBack[MAX_BLOCKLEN]; // Feedback register
    DWORD           InProgress;             // Flag to indicate encryption
    DWORD           cbSaltLen;              // Salt length
    BYTE            rgbSalt[MAX_SALT_LEN];  // Salt value
    DWORD           Padding;                // Padding values
    DWORD           Mode;                   // Mode of cipher
    DWORD           ModeBits;               // Number of bits to feedback
    DWORD           Permissions;            // Key permissions
    DWORD           EffectiveKeyLen;        // used by RC2
    DWORD           dwBlockLen;             // Block ciphers only
    // cbKeyLen data bytes
    // cbDataLen data bytes
} NTAGPackedKeyList, *PNTAGPackedKeyList;


#define     HMAC_DEFAULT_STRING_LEN     64

// definition of a hash list
typedef struct Hash_List_Defn
{
    HCRYPTPROV      hUID;
    ALG_ID          Algid;
    DWORD           dwDataLen;
    void            *pHashData;
    HCRYPTKEY       hKey;
    DWORD           HashFlags;
    ALG_ID          HMACAlgid;
    DWORD           HMACState;
    BYTE            *pbHMACInner;
    DWORD           cbHMACInner;
    BYTE            *pbHMACOuter;
    DWORD           cbHMACOuter;
    DWORD           dwHashState;
    BOOL            fTempKey;
} NTAGHashList, *PNTAGHashList;

#define     HMAC_STARTED    1
#define     HMAC_FINISHED   2

#define     DATA_IN_HASH    1

// Values of the HashFlags

#define HF_VALUE_SET    1

// Hash algorithm's internal state
// -- Placed into PNTAGHashList->pHashData

// for MD5
#define MD5_object      MD5_CTX

// for MD4
// see md4.h for MD4_object

// Stuff for weird SSL 3.0 signature format
#define SSL3_SHAMD5_LEN   (A_SHA_DIGEST_LEN + MD5DIGESTLEN)

// prototypes
void memnuke(volatile BYTE *data, DWORD len);

extern DWORD
LocalCreateHash(
    IN ALG_ID Algid,
    OUT BYTE **ppbHashData,
    OUT DWORD *pcbHashData);

extern DWORD
LocalHashData(
    IN ALG_ID Algid,
    IN OUT BYTE *pbHashData,
    IN BYTE *pbData,
    IN DWORD cbData);

extern DWORD
LocalEncrypt(
    IN HCRYPTPROV hUID,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwBufSize,
    IN BOOL fIsExternal);

extern DWORD
LocalDecrypt(
    IN HCRYPTPROV hUID,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN BOOL fIsExternal);

extern DWORD
FIPS186GenRandom(
    IN HANDLE *phRNGDriver,
    IN BYTE **ppbContextSeed,
    IN DWORD *pcbContextSeed,
    IN OUT BYTE *pb,
    IN DWORD cb);

//
// Function : TestSymmetricAlgorithm
//
// Description : This function expands the passed in key buffer for the appropriate algorithm,
//               encrypts the plaintext buffer with the same algorithm and key, and the
//               compares the passed in expected ciphertext with the calculated ciphertext
//               to make sure they are the same.  The opposite is then done with decryption.
//               The function only uses ECB mode for block ciphers and the plaintext
//               buffer must be the same length as the ciphertext buffer.  The length
//               of the plaintext must be either the block length of the cipher if it
//               is a block cipher or less than MAX_BLOCKLEN if a stream cipher is
//               being used.
//
extern DWORD
TestSymmetricAlgorithm(
    IN ALG_ID Algid,
    IN BYTE *pbKey,
    IN DWORD cbKey,
    IN BYTE *pbPlaintext,
    IN DWORD cbPlaintext,
    IN BYTE *pbCiphertext,
    IN BYTE *pbIV);

#ifdef CSP_USE_MD5
//
// Function : TestMD5
//
// Description : This function hashes the passed in message with the MD5 hash
//               algorithm and returns the resulting hash value.
//
BOOL TestMD5(
             BYTE *pbMsg,
             DWORD cbMsg,
             BYTE *pbHash
             );
#endif // CSP_USE_MD5

#ifdef CSP_USE_SHA1
//
// Function : TestSHA1
//
// Description : This function hashes the passed in message with the SHA1 hash
//               algorithm and returns the resulting hash value.
//
BOOL TestSHA1(
              BYTE *pbMsg,
              DWORD cbMsg,
              BYTE *pbHash
              );
#endif // CSP_USE_SHA1

// These may later be changed to set/use NT's [GS]etLastErrorEx
// so make it easy to switch over..
#ifdef MTS
__declspec(thread)
#endif

#ifdef __cplusplus
}
#endif

#endif // __NTAGIMP1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\manage.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : manage.h                                               //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Apr 19 1995 larrys  Cleanup                                        //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __MANAGE_H__
#define __MANAGE_H__

#ifdef __cplusplus
extern "C" {
#endif

DWORD NTLValidate(HCRYPTPROV hUID, HCRYPTKEY hKey, BYTE bTypeValue,
                  LPVOID *ppvRet);
DWORD NTLMakeItem(HCRYPTKEY *phKey, BYTE bTypeValue, void *NewData);
void *NTLCheckList(HNTAG hThisThing, BYTE bTypeValue);
void  NTLDelete(HNTAG hItem);

#define _nt_malloc(cb)  ContAlloc(cb)
#define _nt_free(pv, _cbSizeToZero_)    ContFree(pv)

#ifdef __cplusplus
}
#endif

#endif // __MANAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\nt_blobs.h ===
#ifndef	__NT_BLOBS_H__
#define	__NT_BLOBS_H__

/* nt_blobs.h
 *
 *	Structure definitions for the NameTag keyblob formats.
 *
 *	Note: the code assumes that all structures begin with the
 *	STD_PRELUDE macro and end with the STD_POSTLUDE macro.
 *	This allows the "fill in the blanks" code to work more efficiently.
 *
 *	NTStdHeader is the data that goes before the encrypted portion of
 *	the key blob.
 *
 *	!!!!!!!!!!!!!!!ALERT!!!!!!!!!!!!!!!!!!!!!!!!!
 *	Since these structs define a net packet, we always
 *	assume Intel byte order on these structures!!!!!
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

#define CUR_BLOB_VERSION	2
#define NT_HASH_BYTES	MAXHASHLEN

typedef struct _SIMPLEBLOB {
	ALG_ID	aiEncAlg;
} NTSimpleBlob;

typedef struct _STKXB {
	DWORD	dwRights;
	DWORD	dwKeyLen;
	BYTE	abHashData[NT_HASH_BYTES];
} NTKeyXBlob ;

#ifdef __cplusplus
}
#endif

#endif // __NT_BLOBS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\nt_rsa.h ===
#ifndef	__NT_RSA_H__
#define	__NT_RSA_H__

#include "md2.h"
#include "md4.h"
#include "md5.h"
#include "sha.h"
#include "rc2.h"
#include "rc4.h"
#include "des.h"
#include "modes.h"

/* nt_rsa.h
 *
 *	Stuff local to NameTag, but necessary for the RSA library.
 */

#ifdef __cplusplus
extern "C" {
#endif

// This structure keeps state for MD4 hashing.
typedef struct MD4stuff
{
	MDstruct			MD;		// MD4's state
	BOOL				FinishFlag;
	DWORD				BufLen;
	BYTE				Buf[MD4BLOCKSIZE];// staging buffer
} MD4_object;

typedef struct MD2stuff
{
	MD2_CTX                         MD;		// MD2's state
	BOOL				FinishFlag;
} MD2_object;

#define MD2DIGESTLEN    16

#ifdef __cplusplus
}
#endif

#endif // __NT_RSA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\nt_mphas.h ===
// nt_mphase.h

// exported multiphase functions.

BOOL GenerateKeyXPacket(PNTAGUserList pUser,
			NTStdHeader *pHeader,
			NTAGKeyList *pKey,
			NTAGKeyList *pPubKey,
			BYTE *pbPackOut);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\policy.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    policy

Abstract:

    This header file describes the services provided by the algorithm strength
    policy modules.

Author:

    Doug Barlow (dbarlow) 8/11/2000

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#ifndef _POLICY_H_
#define _POLICY_H_
#ifdef __cplusplus
extern "C" {
#endif

extern BOOL
IsLegalAlgorithm(
    IN  CONST PROV_ENUMALGS_EX *rgEnumAlgs,
    IN  ALG_ID algId,
    OUT CONST PROV_ENUMALGS_EX **ppEnumAlg);

extern BOOL
IsLegalLength(
    IN CONST PROV_ENUMALGS_EX *rgEnumAlgs,
    IN ALG_ID algId,
    IN DWORD cBitLength,
    IN CONST PROV_ENUMALGS_EX *pEnumAlg);

extern BOOL
GetDefaultLength(
    IN  CONST PROV_ENUMALGS_EX *rgEnumAlgs,
    IN  ALG_ID algId,
    IN  CONST PROV_ENUMALGS_EX *pEnumAlg,
    OUT LPDWORD pcBitLength);

#ifdef __cplusplus
}
#endif
#endif // _POLICY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\precomp.h ===
#undef UNICODE					// ## Not Yet
#include <windows.h>
#include <windef.h>
#include <wincrypt.h>
#include <cspdk.h>
#include <malloc.h>
#include <string.h>
#include <time.h>
#include <wtypes.h>

#ifndef WIN95
#include "assert.h"
#endif
#ifdef SECDBG					// ITV Security
#define	NTAGDEBUG				// Turn on internal debugging
#else	// SECDBG
#ifndef ASSERT
#define ASSERT(x)				// default to base
#endif
#endif	// SECDBG

#include "scp.h"
#include "rsa.h"
#include "contman.h"
#include "ntagimp1.h"
#include "manage.h"

#pragma	hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\pkcsdll.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    PKCSlib

Abstract:

    This header file describes the services and definitions necessary to use the
    Crypto Certificate API.

Author:

    Doug Barlow (dbarlow) 8/17/1995

Environment:

    Win32, Crypto API

Notes:

    Current X.509 Support Level : V3
    Current PKCS Support Level  : V1

--*/

#ifndef _PKCSLIB_H_
#define _PKCSLIB_H_

#include <wincrypt.h>

#ifdef _cplusplus
extern "C" {
#endif

#ifndef PKCSDLLAPI
#define PKCSDLLAPI
#endif

typedef const void *
    PKCSHANDLE;


//
//==============================================================================
//
//  Attribute List services.
//
//  Also see the list of standard Attribute types, below.
//

typedef PKCSHANDLE
    ATTRIBLISTHANDLE;               // Reference handle type.
typedef ATTRIBLISTHANDLE
    *PATTRIBLISTHANDLE,             // Pointers to reference handles.
    *LPATTRIBLISTHANDLE;

extern PKCSDLLAPI BOOL WINAPI
PkcsAttributeListCreate(
    OUT LPATTRIBLISTHANDLE hAtrList); // Handle for future reference.

extern PKCSDLLAPI BOOL WINAPI
PkcsAttributeListClose(
    IN ATTRIBLISTHANDLE hAtrList);  // The handle to the attrList to discard

extern PKCSDLLAPI BOOL WINAPI
PkcsAttributeListAdd(
    IN ATTRIBLISTHANDLE hAtrList,   // The reference handle to the List.
    IN LPCTSTR szAtrType,           // The Object Identifier of the attribute
    IN const BYTE * pbAtrValue);    // The Value of the ASN.1 encoded attribute

extern PKCSDLLAPI BOOL WINAPI
PkcsAttributeListLookup(
    IN ATTRIBLISTHANDLE hAtrList,   // The reference handle to the List.
    IN LPCTSTR szAtrType,           // The Object Identifier of the attribute
    OUT LPBYTE pbAtrValue,          // The value of the attribute
    IN OUT LPDWORD pcbAtrValLen);   // The length of the pbAtrValue buffer

extern PKCSDLLAPI BOOL WINAPI
PkcsAttributeListContents(
    IN ATTRIBLISTHANDLE hAtrList,   // The reference handle to the List.
    OUT LPTSTR mszAtrTypes,         // The Object Identifier list
    IN OUT LPDWORD pcbAtrTypesLen); // The length of the mszAtrTypes buffer

    //
    // ?Q? - Is there any need for a remove service?
    //


//
//==============================================================================
//
//  X.509 v3 Certificate Extension List services.
//
// ?TODO?
//

typedef PKCSHANDLE
    EXTENSIONLISTHANDLE;            // Reference handle type.
typedef EXTENSIONLISTHANDLE
    *PEXTENSIONLISTHANDLE,          // Pointers to reference handles.
    *LPEXTENSIONLISTHANDLE;


//
//==============================================================================
//
//  Subject services.  To use these services, you must have created a
//      key, either directly via the CryptoAPI, or via the
//      convenience service PkcsCreateSubject.
//

typedef PKCSHANDLE
    SUBJECTHANDLE;                  // Reference handle type.
typedef SUBJECTHANDLE
    *PSUBJECTHANDLE,                // Pointers to reference handles.
    *LPSUBJECTHANDLE;

extern PKCSDLLAPI BOOL WINAPI
PkcsSetDNamePrefix(
    IN DWORD dwStore,               // The Certificate Store.
    IN LPCTSTR szPrefix);           // The Prefix to set.

extern PKCSDLLAPI BOOL WINAPI
PkcsSubjectCreate(
    OUT LPSUBJECTHANDLE phSubject,  // Handle for future reference
    IN LPCTSTR szKeySet,            // What to name the new Subject keyset
    IN LPCTSTR szProvider,          // The specific name of the CSP, or Blank
    IN DWORD dwKeyType,             // Specifies the type of key
    IN DWORD dwProvType,            // Should be PROV_RSA_FULL
    IN ALG_ID algPref,              // Suggest optional algorithm preferences
    IN DWORD dwStore);              // Store Id or zero.

extern PKCSDLLAPI BOOL WINAPI
PkcsSubjectOpen(
    OUT LPSUBJECTHANDLE phSubject,  // Handle for future reference
    IN LPCTSTR szKeySet,            // The name of the Subject keyset
    IN LPCTSTR szProvider,          // The specific name of the CSP, or Blank
    IN DWORD dwKeyType,             // Specifies the type of key
    IN DWORD dwProvType,            // Should be PROV_RSA_FULL
    IN ALG_ID algPref,              // Suggest optional algorithm preferences
    IN DWORD dwStore);              // Store Id or zero.

extern PKCSDLLAPI BOOL WINAPI
PkcsSubjectSign(
    IN SUBJECTHANDLE hSubject,      // The reference handle to the Subject
    IN const BYTE *pbData,          // The data to be signed
    IN DWORD cbDataLen,             // The length of the data to be signed
    IN LPCTSTR szComment,           // Comment string associated with signature
    OUT LPBYTE pbSignature,         // Buffer to receive the signature
    IN OUT LPDWORD pcbSigLen);      // Length of the pbSignature buffer.

extern PKCSDLLAPI BOOL WINAPI
PkcsSubjectClose(
    IN SUBJECTHANDLE hSubject);     // The reference handle to the Subject

extern PKCSDLLAPI BOOL WINAPI
PkcsSubjectDelete(
    IN SUBJECTHANDLE hSubject);     // The handle to the Subject to remove

extern PKCSDLLAPI BOOL WINAPI
PkcsSubjectRequestCertification(
    IN SUBJECTHANDLE hSubject,      // The reference handle to the Subject
    IN ATTRIBLISTHANDLE hAtrList,   // reference to subject attributes, if any
    OUT LPBYTE pbCertReq,           // Buffer to receive certificate request
    IN OUT LPDWORD pcbCertReqLen);  // Length of pbCertReq buffer

extern PKCSDLLAPI BOOL WINAPI
PkcsSubjectDistinguishedName(
    IN SUBJECTHANDLE hSubject,      // The reference handle to the Subject
    OUT LPTSTR szDname,             // Buffer to receive the distinguished name
    IN OUT LPDWORD pcbDnameLen);    // Length of pbCertReq buffer

    //
    // ?TODO? - Need to attach an X.509 v2 UniqueIdentifier to the Subject.
    // ?HOW? -  Can we attach an X.509 v2 UniqueIdentifier to the request?
    //


//
//==============================================================================
//
//  Issuer services.  To use these services, you must have created an
//      AT_SIGNATURE key, either directly via the CryptoAPI, or via the
//      convienience service PkcsCreateIssuer, and you will be certifying
//      other's keys.
//

typedef PKCSHANDLE
    ISSUERHANDLE;                   // Reference handle type.
typedef ISSUERHANDLE
    *PISSUERHANDLE,                 // Pointers to reference handles.
    *LPISSUERHANDLE;

extern PKCSDLLAPI BOOL WINAPI
PkcsIssuerCreate(
    OUT LPISSUERHANDLE phIssuer,    // Handle for future reference
    IN LPCTSTR szKeySet,            // What to name the new Issuer keyset
    IN LPCTSTR szProvider,          // The specific name of the CSP, or Blank
    IN DWORD dwProvType,            // Should be PROV_RSA_FULL
    IN ALG_ID algPref,              // Suggest optional algorithm preferences
    IN DWORD dwStore);              // Store Id or zero.

extern PKCSDLLAPI BOOL WINAPI
PkcsIssuerOpen(
    OUT LPISSUERHANDLE phIssuer,    // Handle for future reference
    IN LPCTSTR szKeySet,            // The name of the Issuer keyset
    IN LPCTSTR szProvider,          // The specific name of the CSP, or Blank
    IN DWORD dwProvType,            // Should be PROV_RSA_FULL
    IN ALG_ID algPref,              // Suggest optional algorithm preferences
    IN DWORD dwStore);              // Store Id or zero.

extern PKCSDLLAPI BOOL WINAPI
PkcsIssuerClose(
    IN ISSUERHANDLE hIssuer);       // The reference handle to the Issuer

extern PKCSDLLAPI BOOL WINAPI
PkcsIssuerDelete(
    IN ISSUERHANDLE hIssuer);       // The handle to the Issuer to remove

extern PKCSDLLAPI BOOL WINAPI
PkcsIssuerRequestCertification(
    IN ISSUERHANDLE hIssuer,        // The reference handle to the Issuer
    IN ATTRIBLISTHANDLE hAtrList,   // reference to issuer attributes, if any
    OUT LPBYTE pbCertReq,           // Buffer to receive the certificate request
    IN OUT LPDWORD pcbCertReqLen);  // Length of the pbCertReq buffer

    //
    // ?TODO? - Need to attach an X.509 v2 UniqueIdentifier to the Issuer.
    //          It would be nice to get at the X.509 name.  Other info?
    // ?HOW? -  How can we attach an X.509 v2 UniqueIdentifier to the request?
    //

extern PKCSDLLAPI BOOL WINAPI
PkcsIssuerIssueLocalCA(
    IN ISSUERHANDLE hIssuer,        // The reference handle to the Issuer
    OUT LPBYTE pbCert,              // Buffer to receive certificate
    IN OUT LPDWORD pcbCertLen);     // Length of the pbCert buffer.

extern PKCSDLLAPI BOOL WINAPI
PkcsIssuerCertify(
    IN ISSUERHANDLE hIssuer,        // The reference handle to the Issuer
    IN const BYTE *pbCertReq,       // Buffer containing the certificate request
    IN const BYTE *pbSerialNo,      // Serial number to assign to certificate
    IN DWORD cbSerialNoLen,         // Length of the serial number
    IN LPFILETIME pftStartDate,     // Effective date of the certificate
    IN LPFILETIME pftEndDate,       // Termination date of the certificate
    OUT LPBYTE pbCert,              // Buffer to receive the certificate
    IN OUT LPDWORD pcbCertLen);     // Length of the pbCert buffer.

extern PKCSDLLAPI BOOL WINAPI
PkcsIssuerRecertify(
    IN ISSUERHANDLE hIssuer,        // The reference handle to the Issuer
    IN const BYTE *pbInCert,        // Buffer containing the old certificate
    IN const BYTE *pbSerialNo,      // Serial number to assign to certificate
    IN DWORD cbSerialNoLen,         // Length of the serial number
    IN LPFILETIME pftStartDate,     // Effective date of the certificate
    IN LPFILETIME pftEndDate,       // Termination date of the certificate
    OUT LPBYTE pbOutCert,           // Buffer to receive the certificate
    IN OUT LPDWORD pcbCertLen);     // Length of the pbCert buffer.

extern PKCSDLLAPI BOOL WINAPI
PkcsIssuerDistinguishedName(
    IN ISSUERHANDLE hIssuer,        // The reference handle to the Issuer
    OUT LPTSTR szDname,             // Buffer to receive the distinguished name
    IN OUT LPDWORD pcbDnameLen);    // Length of pbCertReq buffer

    //
    // ?HOW? -  How do we get the Issuer's UniqueIdentifier?
    //          How do we attach X.509 v3 Extensions to the certificate?
    //


//
//==============================================================================
//
//  CRL services.
//

typedef PKCSHANDLE
    CRLHANDLE;                      // Reference handle type.
typedef CRLHANDLE
    *PCRLHANDLE,                    // Pointers to reference handles.
    *LPCRLHANDLE;

extern PKCSDLLAPI BOOL WINAPI
PkcsCrlCreate(
    OUT LPCRLHANDLE phCrl,          // Handle for future reference
    IN ISSUERHANDLE hIssuer);       // Handle of controlling issuer

extern PKCSDLLAPI BOOL WINAPI
PkcsCrlLoad(
    OUT LPCRLHANDLE phCrl,          // Handle for future reference
    IN ISSUERHANDLE hIssuer,        // Handle of controlling issuer
    IN const BYTE *pbCrl);          // Buffer containing the CRL.

extern PKCSDLLAPI BOOL WINAPI
PkcsCrlRevoke(
    IN CRLHANDLE hCrl,              // The reference handle to the CRL
    IN const BYTE *pbSerialNo,      // Serial number of certificate to revoke
    IN DWORD cbSerialNoLen,         // Length of the serial number
    IN LPFILETIME pfmStartDate);    // Effective date of revokation

extern PKCSDLLAPI BOOL WINAPI
PkcsCrlIssue(
    IN CRLHANDLE hCrl,              // The reference handle to the CRL
    IN LPFILETIME pftEndDate,       // Termination date of the CRL
    OUT LPBYTE pbCrl,               // Buffer to receive the CRL
    IN OUT LPDWORD pcbCrlLen);      // Length of the pbCrl buffer

extern PKCSDLLAPI BOOL WINAPI
PkcsCrlClose(
    IN CRLHANDLE hCrl);             // The reference handle to the Crl

    //
    // ?HOW? -  How do we attach X.509 CRL v2 Extensions to the revokee?
    //


//
//==============================================================================
//
//  Certificate services.
//

typedef PKCSHANDLE
    CERTIFICATEHANDLE;              // Reference handle type.
typedef CERTIFICATEHANDLE
    *PCERTIFICATEHANDLE,            // Pointers to reference handles.
    *LPCERTIFICATEHANDLE;

#define CERT_PKCSV1_INFO 1          // The type of Cert Info Struct following:

//
// Supported Certificate Types.
//

#define CERTYPE_UNKNOWN         0   // Unknown Certificate Type.
#define CERTYPE_LOCAL_CA        1   // A local CA pointer.
#define CERTYPE_X509            2   // An X.509 certificate.
#define CERTYPE_PKCS_X509       3   // A PKCS & imbedded X.509 Certificate.
#define CERTYPE_PKCS_REQUEST    4   // A PKCS Certificate Request (internal use)


//
// Supported Certificate Types.
//

// Local CA Specifics

#define LCA_VERSION_1 0             // This Local CA is version 1.
#define LCA_MAX_VERSION LCA_VERSION_1 // Max version supported.

typedef struct {
    DWORD   dwVersion;              // The version of the local CA
    LPTSTR  szSubject;              // Address for Subject name
    DWORD   cbSubjectLen;           // Length of szSubject buffer
    LPTSTR  szProvider;             // Address for the provider name
    DWORD   cbProviderLen;          // Length of szProvider buffer
    DWORD   dwProvType;             // The type of Provider
    LPTSTR  szKeyset;               // Address for the keyset name
    DWORD   cbKeysetLen;            // Length of the szKeyset buffer
    DWORD   dwKeySpec;              // The specific key identifier
} LOCALCACERTINFO, *PLOCALCACERTINFO, *LPLOCALCACERTINFO;


// X.509 Certificate specifics

#define X509_VERSION_1 0            // This certificate is X.509 version 1
#define X509_VERSION_2 1            // This certificate is X.509 version 2
#define X509_VERSION_3 2            // This certificate is X.509 version 3
#define X509_MAX_VERSION X509_VERSION_1 // Max version supported.

typedef struct {
    DWORD   dwX509Version;          // The version of the certificate
    LPBYTE  pbSerialNumber;         // Address for serial number.
    DWORD   cbSerialNumLen;         // Length of pbSerialNumber buffer.
    ALG_ID  algId;                  // Algorithm Id.
    LPTSTR  szIssuer;               // Address for Issuer name
    DWORD   cbIssuerLen;            // Length of szIssuer buffer
    FILETIME ftNotBefore;           // Certificate effective date
    FILETIME ftNotAfter;            // Certificate expiration date
    LPTSTR  szSubject;              // Address for Subject name
    DWORD   cbSubjectLen;           // Length of szSubject buffer
    LPVOID  pvIssuerUid;            // Address for Issuer Id ?q?
    DWORD   cbIssuerUidLen;         // Length of pvIssuerUid buffer
    LPVOID  pvSubjectUid;           // Address for Subject Id ?q?
    DWORD   cbSubjectUidLen;        // Length of pvSubjectUid buffer
    EXTENSIONLISTHANDLE
            hExtensions;            // Extension List handle
} X509CERTINFO, *PX509CERTINFO, *LPX509CERTINFO;


// PKCS-6 with embedded X.509 Certificate specifics

#define PKCS_NOTUSED   0xffff       // PKCS isn't used on this certificate
#define PKCS_VERSION_1 0            // This certificate is PKCS version 1
#define PKCS_MAX_VERSION PKCS_VERSION_1 // Max version supported.

typedef struct {
    DWORD   dwPKCSVersion;          // The version of the certificate
    ATTRIBLISTHANDLE hAttributes;   // Attribute list handle
    X509CERTINFO x509Info;          // Info from the X.509 Certificate
} PKCSX509CERTINFO, *PPKCSX509CERTINFO, *LPPKCSX509CERTINFO;


// PKCS-10 Certificate Request Specifics
typedef struct {
    DWORD   dwPKCSVersion;          // The version of the certificate request
    LPTSTR  szSubject;              // Address for Subject name
    DWORD   cbSubjectLen;           // Length of szSubject buffer
    ATTRIBLISTHANDLE hAttributes;   // Attribute list handle
} PKCSREQCERTINFO, *PPKCSREQCERTINFO, *LPPKCSREQCERTINFO;


// Common Certificate Info Header.

typedef struct {
    // This part is common to all certificate info structure types.  (?Q?)
    DWORD   cbStructLen;            // Length of this structure
    WORD    wCertInfoVersion;       // The version (CERT_PKCSV1_INFO)
    WORD    wCertInfoType;          // The type of the following structure
    union {
        LOCALCACERTINFO localCA;    // Local CA Characteristics
        X509CERTINFO x509;          // X.509 Characteristics
        PKCSX509CERTINFO pkcs;      // PKCS-6 Characteristics
        PKCSREQCERTINFO req;        // PKCS-10 Request Characteristics
    } certInfo;
} CERTIFICATEINFO, *PCERTIFICATEINFO, *LPCERTIFICATEINFO;


// Crypto API Definitions
#define CAPI_MAX_VERSION 2          // Supported version of CAPI.


// Certificate Store Definitions
#define CERTSTORE_NONE          0   // No store to be used.
#define CERTSTORE_APPLICATION   1   // Store in application volatile memory
#define CERTSTORE_CURRENT_USER  3   // Store in Registry under current user
#define CERTSTORE_LOCAL_MACHINE 5   // Store in Registry under local machine


// Certificate Warning Definitions
#define CERTWARN_NOCRL       0x01   // At least one of the signing CAs didn't
                                    // have an associated CRL.
#define CERTWARN_EARLYCRL    0x02   // At least one of the signing CAs had an
                                    // associated CRL who's issuing date was
                                    // in the future.
#define CERTWARN_LATECRL     0x04   // At least one of the signing CAs had an
                                    // expired CRL.
#define CERTWARN_TOBEREVOKED 0x08   // At least one of the signing CAs contained
                                    // a revocation for a certificate, but its
                                    // effective date has not yet been reached.

extern PKCSDLLAPI BOOL WINAPI
PkcsCertificateLoad(
    OUT LPCERTIFICATEHANDLE phCert, // Handle for future reference
    IN const BYTE *pbCert,          // Buffer containing the certificate
    IN const BYTE *pbCrl,           // Buffer containing any associated CRL
    IN OUT LPDWORD pdwType,         // Certificate Type
    IN DWORD dwStore,               // Which certificate store to load
    IN LPCTSTR szKeySet,            // The name of the keyset to use
    IN LPCTSTR szProvider,          // The specific name of the CSP to use
    IN DWORD dwProvType,            // Provider type hint
    OUT LPBYTE szIssuerName,        // The root or missing issuer
    IN OUT LPDWORD pcbIssuerLen,    // Length of the szIssuerName buffer
    OUT LPDWORD pdwWarnings);       // Receives warning flags.

extern PKCSDLLAPI BOOL WINAPI
PkcsCertificateOpen(
    OUT LPCERTIFICATEHANDLE phCert, // Handle for future reference
    IN LPCTSTR szSubjName,          // Name of subject of existing certificate
    IN LPCTSTR szKeySet,            // The name of the keyset to use
    IN LPCTSTR szProvider,          // The specific name of the CSP to use
    IN DWORD dwProvType,            // Provider type hint
    OUT LPDWORD pdwCertType,        // Certificate Type
    IN OUT LPDWORD pfStore,         // Certificate store search/found limits
    OUT LPTSTR szIssuerName,        // The root or missing issuer
    IN OUT LPDWORD pcbIssuerLen,    // Length of the szIssuerName buffer
    OUT LPDWORD pdwWarnings);       // Receives warning flags.

extern PKCSDLLAPI BOOL WINAPI
PkcsCertificateUpdateCrl(
    IN CERTIFICATEHANDLE hCert,     // The reference handle to the Certificate
    IN const BYTE *pbCrl);          // Buffer containing the associated CRL

extern PKCSDLLAPI BOOL WINAPI
PkcsCertificateVerify(
    IN CERTIFICATEHANDLE hCert,     // The reference handle to the Certificate
    IN const BYTE *pbData,          // The data to be verified
    IN DWORD cbDataLen,             // The length of the data to be signed
    IN LPCTSTR szComment,           // Comment string associated with signature
    IN ALG_ID algId,                // Algorithm suggestion
    IN const BYTE *pbSignature,     // The supplied signature
    IN DWORD cbSigLen);             // Length of the pbSignature buffer.

extern PKCSDLLAPI BOOL WINAPI
PkcsCertificateGetInfo(
    IN CERTIFICATEHANDLE hCert,     // The reference handle to the Certificate
    IN OUT LPCERTIFICATEINFO pCertInfo); // The info structure to fill in

extern PKCSDLLAPI BOOL WINAPI
PkcsCertificateClose(
    IN CERTIFICATEHANDLE hCert);    // The reference handle to the Certificate

extern PKCSDLLAPI BOOL WINAPI
PkcsCertificateDelete(
    IN CERTIFICATEHANDLE hCert);    // The handle to the Certificate to remove


#if defined(_MSVC) && defined(_DEBUG)
//
//==============================================================================
//
//  Debugging extensions
//

extern PKCSDLLAPI void WINAPI
PkcsMemoryClean(
    void);
#endif


//
//==============================================================================
//
//  Attribute Type definitions
//

#define X500_commonName                     TEXT("2.5.4.3")
#define X500_surname                        TEXT("2.5.4.4")
#define X500_serialNumber                   TEXT("2.5.4.5")
#define X500_countryName                    TEXT("2.5.4.6")
#define X500_locality                       TEXT("2.5.4.7")
#define X500_stateOrProvinceName            TEXT("2.5.4.8")
#define X500_streetAddress                  TEXT("2.5.4.9")
#define X500_organizationName               TEXT("2.5.4.10")
#define X500_orginazationalUnitName         TEXT("2.5.4.11")
#define X500_title                          TEXT("2.5.4.12")
#define X500_description                    TEXT("2.5.4.13")
#define X500_businessCategory               TEXT("2.5.4.15")
#define X500_postalCode                     TEXT("2.5.4.17")
#define X500_postOfficeBox                  TEXT("2.5.4.18")
#define X500_physicalDeliveryOfficeName     TEXT("2.5.4.19")
#define X500_telephoneNumber                TEXT("2.5.4.20")
#define X500_x121Address                    TEXT("2.5.4.24")
#define X500_internationalISDNNumber        TEXT("2.5.4.25")
#define X500_destinationIndicator           TEXT("2.5.4.27")

#define PKCS1_md2                           TEXT("1.2.840.113549.2.2")
#define PKCS1_md4                           TEXT("1.2.840.113549.2.4")
#define PKCS1_md5                           TEXT("1.2.840.113549.2.5")
#define PKCS1_rsaEncryption                 TEXT("1.2.840.113549.1.1.1")
#define PKCS1_md2WithRSAEncryption          TEXT("1.2.840.113549.1.1.2")
#define PKCS1_md4WithRSAEncryption          TEXT("1.2.840.113549.1.1.3")
#define PKCS1_md5WithRSAEncryption          TEXT("1.2.840.113549.1.1.4")

#define PKCS3_dhKeyAgreement                TEXT("1.2.840.113549.1.3.1")

#define PKCS5_pbeWithMD2AndDES_CBC          TEXT("1.2.840.113549.1.5.1")
#define PKCS5_pbeWithMD5AndDES_CBC          TEXT("1.2.840.113549.1.5.3")

#define PKCS7_data                          TEXT("1.2.840.113549.1.7.1")
#define PKCS7_signedData                    TEXT("1.2.840.113549.1.7.2")
#define PKCS7_envelopedData                 TEXT("1.2.840.113549.1.7.3")
#define PKCS7_signedAndEnvelopedData        TEXT("1.2.840.113549.1.7.4")
#define PKCS7_digestedData                  TEXT("1.2.840.113549.1.7.5")
#define PKCS7_encryptedData                 TEXT("1.2.840.113549.1.7.6")

#define PKCS9_emailAddress                  TEXT("1.2.840.113549.1.9.1")
#define PKCS9_unstructuredName              TEXT("1.2.840.113549.1.9.2")
#define PKCS9_contentType                   TEXT("1.2.840.113549.1.9.3")
#define PKCS9_messageDigest                 TEXT("1.2.840.113549.1.9.4")
#define PKCS9_signingTime                   TEXT("1.2.840.113549.1.9.5")
#define PKCS9_countersignature              TEXT("1.2.840.113549.1.9.6")
#define PKCS9_challengePassword             TEXT("1.2.840.113549.1.9.7")
#define PKCS9_unstructuredAddress           TEXT("1.2.840.113549.1.9.8")
#define PKCS9_extendedCertificateAttributes TEXT("1.2.840.113549.1.9.9")
#define PKCS9_description                   TEXT("1.2.840.113549.1.9.10")

#ifdef _cplusplus
}
#endif
#endif // _PKCSLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\prodname.h ===
#ifndef __PRODNAME_H__
#define __PRODNAME_H__

#ifdef __cplusplus
extern "C" {
#endif

#define PRODUCT_NAME "ECM" // 

#ifdef __cplusplus
}
#endif

#endif // __PRODNAME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\scp.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : scp.h                                                  //
//  DESCRIPTION   : Crypto Provider prototypes                             //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Jan 25 1995 larrys  Changed from Nametag                           //
//      Apr  9 1995 larrys  Removed some APIs                              //
//      Apr 19 1995 larrys  Cleanup                                        //
//      May 10 1995 larrys  added private api calls                        //
//      May 16 1995 larrys  updated to spec                                //
//      Aug 30 1995 larrys  Changed a parameter to IN OUT                  //
//      Oct 06 1995 larrys  Added more APIs                                //
//      OCt 13 1995 larrys  Removed CryptGetHashValue                      //
//      Apr  7 2000 dbarlow Moved all the entry point definitions to       //
//                  the cspdk.h header file                                //
//                                                                         //
//  Copyright (C) 1993 - 2000 Microsoft Corporation   All Rights Reserved  //
/////////////////////////////////////////////////////////////////////////////

#include <time.h>
#include <wincrypt.h>
#include <policy.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _DEBUG
#include <crtdbg.h>
// #define BreakPoint
#define BreakPoint _CrtDbgBreak();
#define EntryPoint
// #define EntryPoint BreakPoint
#else   // _DEBUG
#define BreakPoint
#define EntryPoint
#endif  // _DEBUG

// type definition of a NameTag error
typedef unsigned int NTAG_ERROR;

#define NTF_FAILED              FALSE
#define NTF_SUCCEED             TRUE

#define NTAG_SUCCEEDED(ntag_error)  ((ntag_error) == NTF_SUCCEED)
#define NTAG_FAILED(ntag_error)     ((ntag_error) == NTF_FAILED)

#define NASCENT                 0x00000002

#define NTAG_MAXPADSIZE         8
#define MAXSIGLEN               64

// definitions max length of logon pszUserID parameter
#define MAXUIDLEN               64

// udp type flag
#define KEP_UDP                 1

// Flags for NTagGetPubKey
#define SIGPUBKEY               0x1000
#define EXCHPUBKEY              0x2000


//
// NOTE:    The following values must match the indicies in the g_AlgTables
//          array, defined below.
//

#define POLICY_MS_DEF       0   // Key length table for PROV_MS_DEF
#define POLICY_MS_STRONG    1   // Key length table for PROV_MS_STRONG
#define POLICY_MS_ENHANCED  2   // Key length table for PROV_MS_ENHANCED
#define POLICY_MS_SCHANNEL  3   // Key length table for PROV_MS_SCHANNEL
#define POLICY_MS_SIGONLY   4   // Key length table for undefined
                                // signature-only CSP.
#define POLICY_MS_RSAAES    5   // Key length table for MS_ENH_RSA_AES_PROV
extern PROV_ENUMALGS_EX *g_AlgTables[];

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\protstor.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : protstor.h                                             //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Dec  4 1996 jeffspel  Create                                       //
//      Apr 21 1997 jeffspel  Changes for NT 5 tree                        //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __PROTSTOR_H__
#define __PROTSTOR_H__

#ifdef __cplusplus
extern "C" {
#endif

extern BOOL
CheckPStoreAvailability(
    PSTORE_INFO *pPStore);

extern DWORD
CreateNewPSKeyset(
    PSTORE_INFO *pPStore,
    DWORD dwFlags);

extern DWORD
GetKeysetTypeAndSubType(
    PNTAGUserList pUser);

extern DWORD
RestoreKeysetFromProtectedStorage(
    PNTAGUserList pUser,
    LPWSTR szPrompt,
    BYTE **ppbKey,
    DWORD *pcbKey,
    BOOL fSigKey,
    BOOL fMachineKeySet,
    BOOL *pfUIOnKey);

void RemoveKeysetFromMemory(
                            PNTAGUserList pUser
                            );

extern DWORD
SetUIPrompt(
    PNTAGUserList pUser,
    LPWSTR szPrompt);

extern DWORD
SaveKeyToProtectedStorage(
    PNTAGUserList pUser,
    DWORD dwFlags,
    LPWSTR szPrompt,
    BOOL fSigKey,
    BOOL fMachineKeySet);

extern DWORD
DeleteKeyFromProtectedStorage(
    NTAGUserList *pUser,
    PCSP_STRINGS pStrings,
    DWORD dwKeySpec,
    BOOL fMachineKeySet,
    BOOL fMigration);

extern DWORD
DeleteFromProtectedStorage(
    CONST char *pszUserID,
    PCSP_STRINGS pStrings,
    HKEY hRegKey,
    BOOL fMachineKeySet);

void FreePSInfo(
                PSTORE_INFO *pPStore
                );

#ifdef __cplusplus
}
#endif

#endif // __PROTSTOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\ssl3.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ssl3.h                                             //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Dec  2 1996 jeffspel  Create                                        //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __SSL3_H__
#define __SSL3_H__

#ifdef __cplusplus
extern "C" {
#endif

#define     EXPORTABLE_KEYLEN   5
#define     EXPORTABLE_SALTLEN  11
#define     RC_KEYLEN           16
#define     MAX_PREMASTER_LEN   48
#define     MAX_RANDOM_LEN      256

#define     TLS_MASTER_LEN   48

// definition of a Secure Channel hash structure
typedef struct _SCH_KeyData
{
    BYTE        rgbPremaster[MAX_PREMASTER_LEN];
    DWORD       cbPremaster;
    BYTE        rgbClientRandom[MAX_RANDOM_LEN];
    DWORD       cbClientRandom;
    BYTE        rgbServerRandom[MAX_RANDOM_LEN];
    DWORD       cbServerRandom;
    BYTE        *pbCertData;
    DWORD       cbCertData;
    BYTE        rgbClearData[MAX_RANDOM_LEN];
    DWORD       cbClearData;
    ALG_ID      EncAlgid;
    ALG_ID      HashAlgid;
    DWORD       cbEnc;
    DWORD       cbEncMac;
    DWORD       cbHash;
    DWORD       cbIV;
    BOOL        fFinished;
    BOOL        dwFlags;
} SCH_KEY, *PSCH_KEY;

// definition of a Secure Channel hash structure
typedef struct _SCH_HashData
{
    ALG_ID      ProtocolAlgid;
    ALG_ID      EncAlgid;
    ALG_ID      HashAlgid;
    DWORD       cbEnc;
    DWORD       cbEncMac;
    DWORD       cbHash;
    DWORD       cbIV;
    BYTE        rgbClientRandom[MAX_RANDOM_LEN];
    DWORD       cbClientRandom;
    BYTE        rgbServerRandom[MAX_RANDOM_LEN];
    DWORD       cbServerRandom;
    BYTE        *pbCertData;
    DWORD       cbCertData;
    BYTE        rgbClearData[MAX_RANDOM_LEN];
    DWORD       cbClearData;
    BYTE        rgbFinal[MAX_RANDOM_LEN];
    DWORD       cbFinal;
    BOOL        dwFlags;
} SCH_HASH, *PSCH_HASH;

// definition of a TLS1 PRF hash structure
typedef struct _PRF_HashData
{
    BYTE        rgbLabel[MAX_RANDOM_LEN];
    DWORD       cbLabel;
    BYTE        rgbSeed[MAX_RANDOM_LEN];
    DWORD       cbSeed;
    BYTE        rgbMasterKey[TLS_MASTER_LEN];
} PRF_HASH;

// strings for deriving PCT1 keys
#define     PCT1_C_WRT          "cw"
#define     PCT1_C_WRT_LEN      2
#define     PCT1_S_WRT          "svw"
#define     PCT1_S_WRT_LEN      3
#define     PCT1_C_MAC          "cmac"
#define     PCT1_C_MAC_LEN      4
#define     PCT1_S_MAC          "svmac"
#define     PCT1_S_MAC_LEN      5

void FreeSChHash(
                 PSCH_HASH       pSChHash
                 );

void FreeSChKey(
                PSCH_KEY    pSChKey
                );

extern DWORD
SCHSetKeyParam(
    IN PNTAGUserList pTmpUser,
    IN OUT PNTAGKeyList pKey,
    IN DWORD dwParam,
    IN CONST BYTE *pbData);

extern DWORD
SChGenMasterKey(
    PNTAGKeyList pKey,
    PSCH_HASH pSChHash);

extern DWORD
SecureChannelDeriveKey(
    PNTAGUserList pTmpUser,
    PNTAGHashList pHash,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

extern DWORD
SetPRFHashParam(
    PRF_HASH *pPRFHash,
    DWORD dwParam,
    CONST BYTE *pbData);

extern DWORD
CalculatePRF(
    PRF_HASH *pPRFHash,
    BYTE *pbData,
    DWORD *pcbData);

#ifdef __cplusplus
}
#endif

#endif // __SSL3_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\sgccheck.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : sgccheck.h                                              //
//  DESCRIPTION   : include file                                           //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Jun 23 1998 jeffspel Created                                       //
//                                                                         //
//  Copyright (C) 1998 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __SGCCHECK_H__
#define __SGCCHECK_H__

#ifdef __cplusplus
extern "C" {
#endif

extern DWORD
LoadSGCRoots(
    IN CRITICAL_SECTION *pCritSec); // must be initialized


//
// delete the public key values
//
void SGCDeletePubKeyValues(
                           IN OUT BYTE **ppbKeyMod,
                           IN OUT DWORD *pcbKeyMod,
                           IN OUT DWORD *pdwKeyExpo
                           );

//
// get the public key form the cert context and assign it to the
// passed in parameters
//

extern DWORD
SGCAssignPubKey(
    IN PCCERT_CONTEXT pCertContext,
    IN OUT BYTE **ppbKeyMod,
    IN OUT DWORD *pcbKeyMod,
    IN OUT DWORD *pdwKeyExpo);

//
// check if the context may be SGC enabled
//

extern DWORD
SPQueryCFLevel(
    IN PCCERT_CONTEXT pCertContext,
    IN BYTE *pbExchKeyMod,
    IN DWORD cbExchKeyMod,
    IN DWORD dwExchKeyExpo,
    OUT DWORD *pdwSGCFlags);

#ifdef __cplusplus
}
#endif

#endif // __SGCCHECK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\sttalgid.h ===
#define  KP_INFO	0xffff0000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\vectest.h ===
// CJ vector test constants
//

// GenKey flag to get vectors into key.
#define	VECTTEST	0x4000

BYTE VTRC2[/*RC2_KEYSIZE*/] = { 0x59, 0x45, 0x9a, 0xf9, 0x27 };
// 0x84, 0x74, 0xca };

BYTE VTRC4[/*RC4_KEYSIZE*/] = { 0x61, 0x8a, 0x63, 0xd2, 0xfb };

#define DES_TEST        0x2000

BYTE DESTEST[/*DES_KEYSIZE*/] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef};

#define DES3_TEST       0x1000

BYTE DES3TEST[/*DES3_KEYSIZE*/] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
                                  0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
                                  0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\inc\swnt_pk.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : swnt_pk.h                                              //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Apr 19 1995 larrys  Cleanup                                        //
//      Oct 27 1995 rajeshk  RandSeed Stuff added hUID to PKCS2Encrypt     //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __SWNT_PK_H__
#define __SWNT_PK_H__

#include <delayimp.h>
#include <pstore.h>
#include <alloca.h>

#ifdef __cplusplus
extern "C" {
#endif

#define NTPK_USE_SIG    0
#define NTPK_USE_EXCH   1


#define PKCS_BLOCKTYPE_1        1
#define PKCS_BLOCKTYPE_2        2

//
// Function : EncryptAndDecryptWithRSAKey
//
// Description : This function creates a buffer and then encrypts that with
//               the passed in private key and decrypts with the passed in
//               public key.  The function is used for FIPS 140-1 compliance
//               to make sure that newly generated/imported keys work and
//               in the self test during DLL initialization.
//

extern DWORD
EncryptAndDecryptWithRSAKey(
    IN BYTE *pbRSAPub,
    IN BYTE *pbRSAPriv,
    IN BOOL fSigKey,
    IN BOOL fEncryptCheck,
    IN BOOL fHardCodedKey);

extern DWORD
ReGenKey(
    HCRYPTPROV hUser,
    DWORD dwFlags,
    DWORD dwWhichKey,
    HCRYPTKEY *phKey,
    DWORD bits);

extern BOOL
CheckDataLenForRSAEncrypt(
    IN DWORD cbMod,     // length of the modulus
    IN DWORD cbData,    // length of the data
    IN DWORD dwFlags);  // flags

// do the modular exponentiation calculation M^PubKey mod N
extern DWORD
RSAPublicEncrypt(
    IN PEXPO_OFFLOAD_STRUCT pOffloadInfo,
    IN BSAFE_PUB_KEY *pBSPubKey,
    IN BYTE *pbInput,
    IN BYTE *pbOutput);

// do the modular exponentiation calculation M^PrivKey Exponent mod N
extern DWORD
RSAPrivateDecrypt(
    IN PEXPO_OFFLOAD_STRUCT pOffloadInfo,
    IN BSAFE_PRV_KEY *pBSPrivKey,
    IN BYTE *pbInput,
    IN BYTE *pbOutput);

/************************************************************************/
/* RSAEncrypt performs a RSA encryption.                                */
/************************************************************************/
extern DWORD
RSAEncrypt(
    IN PNTAGUserList pTmpUser,
    IN BSAFE_PUB_KEY *pBSPubKey,
    IN BYTE *pbPlaintext,
    IN DWORD cbPlaintext,
    IN BYTE *pbParams,
    IN DWORD cbParams,
    IN DWORD dwFlags,
    OUT BYTE *pbOut);

/************************************************************************/
/* RSADecrypt performs a RSA decryption.                                */
/************************************************************************/
extern DWORD
RSADecrypt(
    IN PNTAGUserList pTmpUser,
    IN BSAFE_PRV_KEY *pBSPrivKey,
    IN CONST BYTE *pbBlob,
    IN DWORD cbBlob,
    IN BYTE *pbParams,
    IN DWORD cbParams,
    IN DWORD dwFlags,
    OUT BYTE **ppbPlaintext,
    OUT DWORD *pcbPlaintext);

//
// Routine : DerivePublicFromPrivate
//
// Description : Derive the public RSA key from the private RSA key.  This is
//               done and the resulting public key is placed in the appropriate
//               place in the context pointer (pTmpUser).
//

extern DWORD
DerivePublicFromPrivate(
    IN PNTAGUserList pUser,
    IN BOOL fSigKey);

#ifdef __cplusplus
}
#endif

#endif // __SWNT_PK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\keylimit\limittest1.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    LimitTest1

Abstract:

    This file provides the static data structures used to declare National Key
    Length Limits, modified for specific testing requirements.

Author:

    Doug Barlow (dbarlow) 2/2/2000

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <limits.h>
#include <wincrypt.h>
#include <keylimit.h>

// #define KEYLIMIT_API __declspec(dllexport)
#define KEYLIMIT_API

// Shorthand notation
#define PCT     CRYPTLIMIT_USING_PCT
#define SGC     CRYPTLIMIT_USING_SGC
#define PCT_SGC (PCT | SGC)


//
// Add country-specific limit arrays here.  These lists will be referenced in
// the locale array, below.
//
/*  Here's an example:

static KEYLIMIT_LIMITS FranceLimits[] =
{ // Add algorithmic limits here.
  //Algorithm                 Minimum    Maximum    Required    Disallowed
  //   Id                       Key        Key       Flags        Flags
  //----------------------    -------    -------    --------    ----------
  { ALG_CLASS_SIGNATURE,            0, ULONG_MAX,         0,             0 },
  { ALG_CLASS_KEY_EXCHANGE,         0, ULONG_MAX,         0,             0 },
  { ALG_CLASS_MSG_ENCRYPT,          0,       128,         0,           PCT },
  { ALG_CLASS_DATA_ENCRYPT,         0,       128,         0,           PCT },
  { ALG_CLASS_MSG_ENCRYPT,          0,        40,         0,             0 },
  { ALG_CLASS_DATA_ENCRYPT,         0,        40,         0,             0 },
  { ALG_CLASS_HASH,                 0, ULONG_MAX,         0,             0 },

  // This entry terminates the list, and disallows any other algId.
  { 0,                            0,           0,         0,             0 }
};
*/

/* Small subset of interesting flags and keysize combinations */
static KEYLIMIT_LIMITS FranceLimits[] =
{
  //Algorithm                 Minimum    Maximum    Required    Disallowed
  //   Id                       Key        Key       Flags        Flags
  //----------------------    -------    -------    --------    ----------
  { ALG_CLASS_SIGNATURE,         1024, ULONG_MAX,          0,            0 },
  { ALG_CLASS_KEY_EXCHANGE,         0, ULONG_MAX,          0,            0 },
  { ALG_CLASS_MSG_ENCRYPT,          0,       128,        PCT,            0 },
  { ALG_CLASS_MSG_ENCRYPT,          0,        40,          0,            0 },
  { ALG_CLASS_DATA_ENCRYPT,        56,       128,        SGC,            0 },
  { ALG_CLASS_DATA_ENCRYPT,         0,        40,          0,            0 },
  { ALG_CLASS_HASH,                 0, ULONG_MAX,          0,            0 },

  // This entry terminates the list, and disallows any other algId.
  { 0,                            0,           0,         0,             0 }
};

/* hashing enabled, but no encryption */
static KEYLIMIT_LIMITS ChinaLimits[] =
{
  //Algorithm                 Minimum    Maximum    Required    Disallowed
  //   Id                       Key        Key       Flags        Flags
  //----------------------    -------    -------    --------    ----------
  { ALG_CLASS_SIGNATURE,            0,         0,          0,            0 },
  { ALG_CLASS_KEY_EXCHANGE,         0,         0,          0,            0 },
  { ALG_CLASS_MSG_ENCRYPT,          0,         0,          0,            0 },
  { ALG_CLASS_DATA_ENCRYPT,         0,         0,          0,            0 },
  { ALG_CLASS_HASH,                 0, ULONG_MAX,          0,            0 },

  // This entry terminates the list, and disallows any other algId.
  { 0,                            0,           0,         0,             0 }
};


//
// This is the local array.  It is the actual exported structure.
//

KEYLIMIT_API KEYLIMIT_LOCALE g_LimitsList[] =
{ // Add National Limit structures here.
/* Here's an example:
  { CTRY_FRANCE,        MAKELANGID(LANG_FRENCH ,SUBLANG_FRENCH),      FranceLimits },
*/
  { CTRY_FRANCE,    MAKELANGID(LANG_FRENCH, SUBLANG_FRENCH),                FranceLimits },
  { CTRY_PRCHINA,   MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED),   ChinaLimits },

  // This entry terminates the list.
  { 0, 0, NULL }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\keylimit\keylimit.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    keylimit

Abstract:

    This file provides the static data structures used to declare National Key
    Length Limits.

Author:

    Doug Barlow (dbarlow) 2/2/2000

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <limits.h>
#include <wincrypt.h>
#include <keylimit.h>

// #define KEYLIMIT_API __declspec(dllexport)
#define KEYLIMIT_API

// Shorthand notation
#define PCT CRYPTLIMIT_USING_PCT
#define SGC CRYPTLIMIT_USING_SGC


//
// Add country-specific limit arrays here.  These lists will be referenced in
// the locale array, below.
//
/*  Here's an example:

static KEYLIMIT_LIMITS FranceLimits[] =
{ // Add algorithmic limits here.
  //Algorithm                 Minimum    Maximum    Required    Disallowed
  //   Id                       Key        Key       Flags        Flags
  //----------------------    -------    -------    --------    ----------
  { ALG_CLASS_SIGNATURE,            0, ULONG_MAX,         0,             0 },
  { ALG_CLASS_KEY_EXCHANGE,         0, ULONG_MAX,         0,             0 },
  { ALG_CLASS_MSG_ENCRYPT,          0,       128,         0,           PCT },
  { ALG_CLASS_DATA_ENCRYPT,         0,       128,         0,           PCT },
  { ALG_CLASS_MSG_ENCRYPT,          0,        40,         0,             0 },
  { ALG_CLASS_DATA_ENCRYPT,         0,        40,         0,             0 },
  { ALG_CLASS_HASH,                 0, ULONG_MAX,         0,             0 },

  // This entry terminates the list, and disallows any other algId.
  { 0,                            0,       0,       0,           0 }
};
*/


//
// This is the local array.  It is the actual exported structure.
//

KEYLIMIT_API KEYLIMIT_LOCALE g_LimitsList[] =
{ // Add National Limit structures here.
/* Here's an example:
  { CTRY_FRANCE,        MAKELANGID(LANG_FRENCH ,SUBLANG_FRENCH),      FranceLimits },
*/

  // This entry terminates the list.
  { 0, 0, NULL }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\keylimit\limittest2.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    LimitTest1

Abstract:

    This file provides the static data structures used to declare National Key
    Length Limits, modified for specific testing requirements.

Author:

    Doug Barlow (dbarlow) 2/2/2000

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <limits.h>
#include <wincrypt.h>
#include <keylimit.h>

// #define KEYLIMIT_API __declspec(dllexport)
#define KEYLIMIT_API

// Shorthand notation
#define PCT     CRYPTLIMIT_USING_PCT
#define SGC     CRYPTLIMIT_USING_SGC
#define PCT_SGC (PCT | SGC)


//
// Add country-specific limit arrays here.  These lists will be referenced in
// the locale array, below.
//
/*  Here's an example:

static KEYLIMIT_LIMITS FranceLimits[] =
{ // Add algorithmic limits here.
  //Algorithm                 Minimum    Maximum    Required    Disallowed
  //   Id                       Key        Key       Flags        Flags
  //----------------------    -------    -------    --------    ----------
  { ALG_CLASS_SIGNATURE,            0, ULONG_MAX,         0,             0 },
  { ALG_CLASS_KEY_EXCHANGE,         0, ULONG_MAX,         0,             0 },
  { ALG_CLASS_MSG_ENCRYPT,          0,       128,         0,           PCT },
  { ALG_CLASS_DATA_ENCRYPT,         0,       128,         0,           PCT },
  { ALG_CLASS_MSG_ENCRYPT,          0,        40,         0,             0 },
  { ALG_CLASS_DATA_ENCRYPT,         0,        40,         0,             0 },
  { ALG_CLASS_HASH,                 0, ULONG_MAX,         0,             0 },

  // This entry terminates the list, and disallows any other algId.
  { 0,                            0,           0,         0,             0 }
};
*/

/* Small subset of interesting flags and keysize combinations */
static KEYLIMIT_LIMITS FranceLimits[] =
{
  //Algorithm                 Minimum    Maximum    Required    Disallowed
  //   Id                       Key        Key       Flags        Flags
  //----------------------    -------    -------    --------    ----------
  { ALG_CLASS_SIGNATURE,         1024, ULONG_MAX,          0,            0 },
  { ALG_CLASS_KEY_EXCHANGE,         0, ULONG_MAX,          0,            0 },
  { ALG_CLASS_MSG_ENCRYPT,          0,       128,        PCT,            0 },
  { ALG_CLASS_MSG_ENCRYPT,          0,        40,          0,            0 },
  { ALG_CLASS_DATA_ENCRYPT,        56,       128,        SGC,            0 },
  { ALG_CLASS_DATA_ENCRYPT,         0,        40,          0,            0 },
  { ALG_CLASS_HASH,                 0, ULONG_MAX,          0,            0 },

  // This entry terminates the list, and disallows any other algId.
  { 0,                            0,           0,         0,             0 }
};

/* hashing enabled, plus weak encryption */
static KEYLIMIT_LIMITS ChinaLimits[] =
{
  //Algorithm                 Minimum    Maximum    Required    Disallowed
  //   Id                       Key        Key       Flags        Flags
  //----------------------    -------    -------    --------    ----------
  { ALG_CLASS_SIGNATURE,            0,       512,          0,            0 },
  { ALG_CLASS_KEY_EXCHANGE,         0,       512,          0,            0 },
  { ALG_CLASS_MSG_ENCRYPT,          0,        40,          0,            0 },
  { ALG_CLASS_DATA_ENCRYPT,         0,        40,          0,            0 },
  { ALG_CLASS_HASH,                 0, ULONG_MAX,          0,            0 },

  // This entry terminates the list, and disallows any other algId.
  { 0,                            0,           0,         0,             0 }
};


//
// This is the local array.  It is the actual exported structure.
//

KEYLIMIT_API KEYLIMIT_LOCALE g_LimitsList[] =
{ // Add National Limit structures here.
/* Here's an example:
  { CTRY_FRANCE,        MAKELANGID(LANG_FRENCH ,SUBLANG_FRENCH),      FranceLimits },
*/
    { CTRY_FRANCE,    MAKELANGID(LANG_FRENCH, SUBLANG_FRENCH),                FranceLimits },
    { CTRY_PRCHINA,   MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED),   ChinaLimits },

  // This entry terminates the list.
  { 0, 0, NULL }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\programs\init\init.c ===
#undef UNICODE					// ## Not Yet
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <windows.h>
#include <wincrypt.h>

CHAR			pszMyName[64];
HCRYPTKEY		hClientKey;
HCRYPTPROV		hMe;
HCRYPTKEY		hKey2;

BOOL Logon(int cArg);

int __cdecl main(int cArg, char *rgszArg[])
{

        // Logon to provider
	if (!Logon(cArg))
	    goto exit;

exit:
    return(0);

}

BOOL Logon(int cArg)
{
	HCRYPTKEY	hTestKey;

	pszMyName[0] = 0;

	if (RCRYPT_FAILED(CryptAcquireContext(&hMe, pszMyName, MS_DEF_PROV,
                          PROV_RSA_FULL, 0)))
	{
            if (cArg > 1)
		printf("\nUser doesn't exists, try to create it	");

	    if (RCRYPT_FAILED(CryptAcquireContext(&hMe, pszMyName,
                              MS_DEF_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET)))
            {
	        if (cArg > 1)
                    printf("FAIL Error = %x\n", GetLastError());
                return(FALSE);
	    }
	    else
	    {
	    if (cArg > 1)
                printf("SUCCEED\n");
            }
        }
	else
        {
            if (cArg > 1)
		printf("CryptAcquireContext for user: %s\n", pszMyName);
        }

	
	if (RCRYPT_FAILED(CryptGetUserKey(hMe, AT_SIGNATURE, &hTestKey)))
	{

            if (cArg > 1)
                printf("Create signature key for %s:	", pszMyName);
    
	    if (RCRYPT_FAILED(CryptGenKey(hMe, CALG_RSA_SIGN,
                                          CRYPT_EXPORTABLE, &hClientKey)))
	    {
	        if (cArg > 1)
                    printf("FAIL Error = %x\n", GetLastError());
	        return(FALSE);
	    }
	    if (cArg > 1)
                printf("SUCCEED\n");
        }
	else
		CryptDestroyKey(hTestKey);
		
	if (RCRYPT_FAILED(CryptGetUserKey(hMe, AT_KEYEXCHANGE, &hTestKey)))
	{
            if (cArg > 1 )
                printf("Create key exchange for %s:		", pszMyName);

	    if (RCRYPT_FAILED(CryptGenKey(hMe, CALG_RSA_KEYX,
                                          CRYPT_EXPORTABLE, &hKey2)))
	    {
	        if (cArg > 1)
                    printf("FAIL Error = %x\n", GetLastError());
	        return(FALSE);
	    }
            if (cArg > 1)
                printf("SUCCEED\n");
        }
	else
		CryptDestroyKey(hTestKey);

        if (cArg > 1)
            printf("Init completed\n");

	return(TRUE);
       
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\programs\keymigrt\keymigrt.c ===
//
//  keymigrt.c
//
//  Copyright (c) Microsoft Corp, 2000
//
//
#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <wincrypt.h>
#include <cspdk.h>
#include "dpapiprv.h"
#include "contman.h"


#define BEHAVIOR_FORCE_KEY  0x1
#define BEHAVIOR_VERBOSE    0x2
#define BEHAVIOR_ALLOW_UI   0x4
#define BEHAVIOR_MACHINE    0x8
#define BEHAVIOR_NO_CHANGE  0x10
#define BEHAVIOR_EXPORT     0x20
#define BEHAVIOR_FORCE_ENC  0x40

typedef struct _ALG_TO_STRING
{
    DWORD   AlgId;
    LPCWSTR  wszString;
} ALG_TO_STRING;


#define             MS_BASE_CRYPTPROTECT_VERSION    0x01

ALG_TO_STRING g_AlgToString[] =
{
    { CALG_MD2, L"MD2-%d " },
    { CALG_MD4, L"MD4-%d " },
    { CALG_MD5, L"MD5-%d " },
    { CALG_SHA1, L"SHA1-%d " },
    { CALG_DES, L"DES-%d " },
    { CALG_3DES_112, L"3DES-%d " },
    { CALG_3DES, L"3DES-%d " },
    { CALG_DESX, L"DESX-%d " },
    { CALG_RC2, L"RC2-%d " },
    { CALG_RC4, L"RC4-%d " },
    { CALG_SEAL, L"SEAL-%d " },
    { CALG_RSA_SIGN, L"RSA Signature-%d " },
    { CALG_RSA_KEYX, L"RSA Exchange-%d " },
    { CALG_DSS_SIGN, L"DSS-%d " },
    { CALG_DH_SF, L"DH-%d " },
    { CALG_DH_EPHEM, L"DH Ephemeral-%d " },
    { CALG_KEA_KEYX, L"KEA Exchange-%d " },
    { CALG_SKIPJACK, L"SKIPJACK-%d " },
    { CALG_TEK, L"TEK-%d " },
    { CALG_RC5, L"RC5-%d " },
    { CALG_HMAC, L"HMAC-%d " }
};

DWORD   g_cAlgToString = sizeof(g_AlgToString)/sizeof(g_AlgToString[0]);

ALG_TO_STRING g_ProviderToString[] =
{
    {PROV_RSA_FULL,     L"RSA Full"},
    {PROV_RSA_SIG ,     L"RSA Signature Only"},
    {PROV_DSS,          L"DSS"},
    {PROV_FORTEZZA,     L"Fortezza"},
    {PROV_MS_EXCHANGE,  L"Microsoft Exchange"},
    {PROV_SSL,          L"SSL"},
    {PROV_RSA_SCHANNEL, L"RSA SCHANNEL"},
    {PROV_DSS_DH,       L"DSS DH"},
    {PROV_DH_SCHANNEL,  L"DH SCHANNEL"},
    {PROV_SPYRUS_LYNKS, L"Spyrus LYNKS"},
    {PROV_INTEL_SEC,    L"Intel SEC"}

};

DWORD   g_cProviderToString = sizeof(g_ProviderToString)/sizeof(g_ProviderToString[0]);



DWORD        g_dwDefaultCryptProvType    = PROV_RSA_FULL;
DWORD        g_dwAlgID_Encr_Alg          = CALG_RC4;
DWORD        g_dwAlgID_Encr_Alg_KeySize  = 40;
DWORD        g_dwAlgID_MAC_Alg           = CALG_SHA1;
DWORD        g_dwAlgID_MAC_Alg_KeySize   = 160;



void Usage();
VOID PrintAlgID(DWORD dwAlgID, DWORD dwStrength);
BOOL FProviderSupportsAlg(
        HCRYPTPROV  hQueryProv,
        DWORD       dwAlgId,
        DWORD*      pdwKeySize);
DWORD UpdateRegistrySettings(DWORD dwBehavior, HCRYPTPROV hProv);

DWORD UpgradeDPAPIBlob(DWORD dwBehavior,
                 PBYTE *ppbData,
                 DWORD *pcbData,
                 BOOL  *pfModified);

DWORD UpgradeKeys(DWORD dwBehavior);


extern DWORD
GetLocalSystemToken(HANDLE* phRet);


int __cdecl main(int cArg, char *rgszArg[])
{

    DWORD dwBehavior = 0;
    DWORD dwError = ERROR_SUCCESS;
    HCRYPTPROV hProv = 0;
    HANDLE      hToken = NULL;
    int i;

    // Parse command line

    for(i=1; i < cArg; i++)
    {
        LPSTR szCurrentArg = rgszArg[i];

        if((*szCurrentArg != '-') &&
           (*szCurrentArg != '/'))
        {
            Usage();
            goto error;
        }
        szCurrentArg++;

        while(*szCurrentArg)
        {

            switch(*szCurrentArg++)
            {
                case 'f':
                case 'F':
                    dwBehavior |= BEHAVIOR_FORCE_KEY;
                    break;

                case 'e':
                case 'E':
                    dwBehavior |= BEHAVIOR_FORCE_ENC;
                    break;

                case 'v':
                case 'V':
                    dwBehavior |= BEHAVIOR_VERBOSE;
                    break;

                case 'u':
                case 'U':
                    dwBehavior |= BEHAVIOR_ALLOW_UI;
                    break;

                case 'm':
                case 'M':
                    dwBehavior |= BEHAVIOR_MACHINE;
                    break;

                case 's':
                case 'S':
                    dwBehavior |= BEHAVIOR_NO_CHANGE | BEHAVIOR_VERBOSE;
                    break;

                default:
                    Usage();
                    goto error;
            }


        }
    }

    if(!CryptAcquireContext(&hProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
        if(!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
        {
            dwError = GetLastError();
            printf("Could not acquire a crypt context:%lx\n", dwError);
            goto error;
        }
        dwBehavior |= BEHAVIOR_EXPORT;

    }

    dwError = UpdateRegistrySettings(dwBehavior, hProv);

    if(dwError != ERROR_SUCCESS)
    {
        goto error;
    }

    if(dwBehavior & BEHAVIOR_MACHINE)
    {
        dwError = GetLocalSystemToken(&hToken);

        if(ERROR_SUCCESS == dwError)
        {
            if(!ImpersonateLoggedOnUser(hToken))
            {
                dwError = GetLastError();
            }
        }

        if(ERROR_ACCESS_DENIED == dwError)
        {
            printf("You must be an administrator to upgrade machine keys\n");
            goto error;
        }
        if(ERROR_SUCCESS != dwError)
        {
            printf("Cannot impersonate local machine:%lx\n", dwError);
        }

    }

    dwError = UpgradeKeys(dwBehavior);

    if(dwError != ERROR_SUCCESS)
    {
        goto error;
    }

error:

    if(hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    if(hToken)
    {
        RevertToSelf();
        CloseHandle(hToken);
    }
    return (ERROR_SUCCESS == dwError)?0:-1;

}


void Usage()
{
    printf("Usage: keymigrt [-f] [-v] [-u] [-m] [-s]\n");
    printf("CAPI Key upgrade utility\n");
    printf("\t-f - Force key upgrade\n");
    printf("\t-e - Force Encryption Settings upgrade\n");
    printf("\t-v - Verbose\n");
    printf("\t-u - Allow upgrade of UI protected keys\n");
    printf("\t-m - Upgrade machine keys\n");
    printf("\t-s - Show current state, but make no modifications\n\n");
}



VOID PrintAlgID(DWORD dwAlgID, DWORD dwStrength)
{
    DWORD i;
    for(i=0; i < g_cAlgToString; i++)
    {
        if(dwAlgID == g_AlgToString[i].AlgId)
        {
             wprintf(g_AlgToString[i].wszString, dwStrength);
             break;
        }
    }

    if(i == g_cAlgToString)
    {
        wprintf(L"Unknown 0x%lx - %d", dwAlgID, dwStrength);
    }
};


VOID PrintProviderID(DWORD dwProviderID)
{
    DWORD i;
    for(i=0; i < g_cProviderToString; i++)
    {
        if(dwProviderID == g_ProviderToString[i].AlgId)
        {
             wprintf(g_ProviderToString[i].wszString);
             break;
        }
    }

    if(i == g_cProviderToString)
    {
        wprintf(L"Unknown 0x%lx ", dwProviderID);
    }
};

DWORD UpdateRegistrySettings(DWORD dwBehavior, HCRYPTPROV hProv)
{

    DWORD   dwReturn = ERROR_SUCCESS;
    HKEY    hKey = NULL;
    static const WCHAR szProviderKeyName[] = REG_CRYPTPROTECT_LOC L"\\" REG_CRYPTPROTECT_PROVIDERS_SUBKEYLOC L"\\" CRYPTPROTECT_DEFAULT_PROVIDER_GUIDSZ ;

    DWORD        dwDefaultCryptProvType    = 0;
    DWORD        dwAlgID_Encr_Alg          = 0;
    DWORD        dwAlgID_Encr_Alg_KeySize  = -1;
    DWORD        dwAlgID_MAC_Alg           = 0;
    DWORD        dwAlgID_MAC_Alg_KeySize   = -1;

    DWORD        cbParameter;
    DWORD        dwValueType;
    DWORD        dwParameterValue;
    DWORD        dwDisposition;
    BOOL         fUpgrade = FALSE;

    SC_HANDLE    hscManager = NULL;
    SC_HANDLE    hscProtectedStorage = NULL;
    SERVICE_STATUS sStatus;
    DWORD        dwWaitTime = 0;


    dwReturn = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                 szProviderKeyName,
                 0,
                 KEY_READ,
                 &hKey);

    if((ERROR_SUCCESS != dwReturn) &&
       (ERROR_FILE_NOT_FOUND != dwReturn))
    {
        printf("Could not open registry: %lx\n", dwReturn);
        goto error;
    }

    if(hKey)
    {
        cbParameter = sizeof(DWORD);
        dwReturn = RegQueryValueExW(
                        hKey,
                        CRYPTPROTECT_DEFAULT_PROVIDER_ENCR_ALG,
                        NULL,
                        &dwValueType,
                        (PBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( dwReturn == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            // if successful, commit
            dwAlgID_Encr_Alg = dwParameterValue;
        }

        cbParameter = sizeof(DWORD);
        dwReturn = RegQueryValueExW(
                        hKey,
                        CRYPTPROTECT_DEFAULT_PROVIDER_ENCR_ALG_KEYSIZE,
                        NULL,
                        &dwValueType,
                        (PBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( dwReturn == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            // if successful, commit
            dwAlgID_Encr_Alg_KeySize = dwParameterValue;
        }

        cbParameter = sizeof(DWORD);
        dwReturn = RegQueryValueExW(
                        hKey,
                        CRYPTPROTECT_DEFAULT_PROVIDER_MAC_ALG,
                        NULL,
                        &dwValueType,
                        (PBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( dwReturn == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            // if successful, commit
            dwAlgID_MAC_Alg = dwParameterValue;
        }

        cbParameter = sizeof(DWORD);
        dwReturn = RegQueryValueExW(
                        hKey,
                        CRYPTPROTECT_DEFAULT_PROVIDER_MAC_ALG_KEYSIZE,
                        NULL,
                        &dwValueType,
                        (PBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( dwReturn == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            // if successful, commit
            dwAlgID_MAC_Alg_KeySize = dwParameterValue;
        }

        cbParameter = sizeof(DWORD);
        dwReturn = RegQueryValueExW(
                        hKey,
                        CRYPTPROTECT_DEFAULT_PROVIDER_CRYPT_PROV_TYPE,
                        NULL,
                        &dwValueType,
                        (PBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( dwReturn == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            // if successful, commit
            dwDefaultCryptProvType = dwParameterValue;
        }
    }

    if(0 != dwAlgID_Encr_Alg)
    {
        g_dwAlgID_Encr_Alg = dwAlgID_Encr_Alg;
    }
    g_dwAlgID_Encr_Alg_KeySize = dwAlgID_Encr_Alg_KeySize;

    FProviderSupportsAlg(hProv, g_dwAlgID_Encr_Alg, &g_dwAlgID_Encr_Alg_KeySize);

    if(0 != dwAlgID_MAC_Alg)
    {
        g_dwAlgID_MAC_Alg = dwAlgID_MAC_Alg;
    }
    g_dwAlgID_MAC_Alg_KeySize = dwAlgID_MAC_Alg_KeySize;

    FProviderSupportsAlg(hProv, g_dwAlgID_MAC_Alg, &g_dwAlgID_MAC_Alg_KeySize);

    if(0 != dwDefaultCryptProvType)
    {
        g_dwDefaultCryptProvType = dwDefaultCryptProvType;
    }


    if(dwBehavior & BEHAVIOR_VERBOSE)
    {
        printf("System Encryption Settings\n");
        printf("Provider Type:\t");
        PrintProviderID(g_dwDefaultCryptProvType);
        if(0 == dwDefaultCryptProvType)
        {
            printf(" (default)");
        }
        printf("\n");

        printf("Encryption Alg:\t");
        PrintAlgID(g_dwAlgID_Encr_Alg, g_dwAlgID_Encr_Alg_KeySize);
        if(-1 == dwAlgID_Encr_Alg_KeySize)
        {
            printf(" (default)");
        }
        printf("\n");

        printf("MAC Alg:\t");
        PrintAlgID(g_dwAlgID_MAC_Alg, g_dwAlgID_MAC_Alg_KeySize);
        if(-1 == dwAlgID_MAC_Alg_KeySize)
        {
            printf(" (default)");
        }
        printf("\n\n");
    }


    if(dwBehavior & BEHAVIOR_NO_CHANGE)
    {
        goto error;
    }
    //
    // Ok, upgrade the settings
    //
    if(hKey)
    {
        RegCloseKey(hKey);
        hKey = NULL;
    }


    // upgrade the algorithms (but never downgrade)

    if(dwBehavior & BEHAVIOR_EXPORT)
    {
        DWORD dwDESKeySize = -1;
        FProviderSupportsAlg(hProv, CALG_DES, &dwDESKeySize);


        // upgrade to export strength
        if((BEHAVIOR_FORCE_ENC & dwBehavior) ||     // upgrade if forced
            (0 == dwAlgID_Encr_Alg) ||              // upgrade if no settings are present
            ( dwDESKeySize > g_dwAlgID_Encr_Alg_KeySize))   // upgrade if other is weak
        {
            dwAlgID_Encr_Alg = CALG_DES;
            dwAlgID_Encr_Alg_KeySize = dwDESKeySize;
            fUpgrade = TRUE;
        }
        else
        {
            dwAlgID_Encr_Alg = g_dwAlgID_Encr_Alg;
            dwAlgID_Encr_Alg_KeySize = g_dwAlgID_Encr_Alg_KeySize;
        }
    }
    else
    {
        DWORD dw3DESKeySize = -1;
        FProviderSupportsAlg(hProv, CALG_3DES, &dw3DESKeySize);

        // upgrade to domestic strength
        if((BEHAVIOR_FORCE_ENC & dwBehavior) ||     // upgrade if forced
            (0 == dwAlgID_Encr_Alg) ||              // upgrade if no settings
            (CALG_DES == dwAlgID_Encr_Alg) ||       // upgrade if previously DES
            ( dw3DESKeySize > g_dwAlgID_Encr_Alg_KeySize) ) // upgrade if weak
        {
            dwAlgID_Encr_Alg = CALG_3DES;
            dwAlgID_Encr_Alg_KeySize = dw3DESKeySize;
            fUpgrade = TRUE;
        }
        else
        {
            dwAlgID_Encr_Alg = g_dwAlgID_Encr_Alg;
            dwAlgID_Encr_Alg_KeySize = g_dwAlgID_Encr_Alg_KeySize;
        }

    }


    FProviderSupportsAlg(hProv, CALG_SHA1, &dwAlgID_MAC_Alg_KeySize);

    if((BEHAVIOR_FORCE_ENC & dwBehavior) ||
       (g_dwAlgID_MAC_Alg_KeySize < dwAlgID_MAC_Alg_KeySize))
    {

        dwAlgID_MAC_Alg = CALG_SHA1;
        fUpgrade = TRUE;
    }
    else
    {
        dwAlgID_MAC_Alg_KeySize = g_dwAlgID_MAC_Alg_KeySize;
        dwAlgID_MAC_Alg = g_dwAlgID_MAC_Alg;
    }

    if(!fUpgrade)
    {
        // no upgrade necessary

        if(dwBehavior & BEHAVIOR_VERBOSE)
        {
            printf("No system encryption settings upgrade is necessary\n");
        }
        goto error;
    }

    dwReturn = RegCreateKeyExW(
                HKEY_LOCAL_MACHINE,
                szProviderKeyName,
                0,
                NULL,
                0,
                KEY_ALL_ACCESS,
                NULL,
                &hKey,
                &dwDisposition
                );

    if(ERROR_ACCESS_DENIED == dwReturn)
    {
        printf("You must be administrator to upgrade system encryption settings.\n");
        dwReturn = ERROR_SUCCESS;
        goto error;
    }
    if(ERROR_SUCCESS != dwReturn)
    {
        printf("Could not open system's encryption settings for write:%lx\n", dwReturn);
        goto error;
    }


    dwReturn = RegSetValueExW(
                    hKey,
                    CRYPTPROTECT_DEFAULT_PROVIDER_ENCR_ALG,
                    0,
                    REG_DWORD,
                    (PBYTE)&dwAlgID_Encr_Alg,
                    sizeof(dwAlgID_Encr_Alg)
                    );
    if( dwReturn == ERROR_SUCCESS) {
        // if successful, commit
        g_dwAlgID_Encr_Alg = dwAlgID_Encr_Alg;
    }
    else
    {
        printf("Could not set encryption alg:%lx\n", dwReturn);
        goto error;
    }


    dwReturn = RegSetValueExW(
                    hKey,
                    CRYPTPROTECT_DEFAULT_PROVIDER_ENCR_ALG_KEYSIZE,
                    0,
                    REG_DWORD,
                    (PBYTE)&dwAlgID_Encr_Alg_KeySize,
                    sizeof(dwAlgID_Encr_Alg_KeySize)
                    );
    if( dwReturn == ERROR_SUCCESS ) {
        // if successful, commit
        g_dwAlgID_Encr_Alg_KeySize = dwAlgID_Encr_Alg_KeySize;
    }
    else
    {
        printf("Could not set encryption Key Size:%lx\n", dwReturn);
        goto error;
    }

    dwReturn = RegSetValueExW(
                    hKey,
                    CRYPTPROTECT_DEFAULT_PROVIDER_MAC_ALG,
                    0,
                    REG_DWORD,
                    (PBYTE)&dwAlgID_MAC_Alg,
                    sizeof(dwAlgID_MAC_Alg)
                    );
    if( dwReturn == ERROR_SUCCESS) {
        // if successful, commit
        g_dwAlgID_MAC_Alg = dwAlgID_MAC_Alg;
    }
    else
    {
        printf("Could not set MAC Alg:%lx\n", dwReturn);
        goto error;
    }

    dwReturn = RegSetValueExW(
                    hKey,
                    CRYPTPROTECT_DEFAULT_PROVIDER_MAC_ALG_KEYSIZE,
                    0,
                    REG_DWORD,
                    (PBYTE)&dwAlgID_MAC_Alg_KeySize,
                    sizeof(dwAlgID_MAC_Alg_KeySize)
                    );
    if( dwReturn == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
        // if successful, commit
        g_dwAlgID_MAC_Alg_KeySize = dwAlgID_MAC_Alg_KeySize;
    }
    else
    {
        printf("Could not set MAC Key size:%lx\n", dwReturn);
        goto error;
    }

    dwReturn = RegSetValueExW(
                    hKey,
                    CRYPTPROTECT_DEFAULT_PROVIDER_CRYPT_PROV_TYPE,
                    0,
                    REG_DWORD,
                    (PBYTE)&dwDefaultCryptProvType,
                    sizeof(dwDefaultCryptProvType)
                    );
    if( dwReturn == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
        // if successful, commit
        g_dwDefaultCryptProvType = dwDefaultCryptProvType;
    }
    else
    {
        printf("Could not set provider type:%lx\n", dwReturn);
        goto error;
    }
    if(dwBehavior & BEHAVIOR_VERBOSE)
    {
        printf("Upgrading system encryption settings\n");
        printf("System Encryption Settings\n");
        printf("Provider Type:\t");
        PrintProviderID(g_dwDefaultCryptProvType);
        if(0 == dwDefaultCryptProvType)
        {
            printf(" (default)");
        }
        printf("\n");

        printf("Encryption Alg:\t");
        PrintAlgID(g_dwAlgID_Encr_Alg, g_dwAlgID_Encr_Alg_KeySize);
        if(-1 == dwAlgID_Encr_Alg_KeySize)
        {
            printf(" (default)");
        }
        printf("\n");

        printf("MAC Alg:\t");
        PrintAlgID(g_dwAlgID_MAC_Alg, g_dwAlgID_MAC_Alg_KeySize);
        if(-1 == dwAlgID_MAC_Alg_KeySize)
        {
            printf(" (default)");
        }
        printf("\n\n");

        printf("Restarting ProtectedStorage Service...\n");
    }

    // Attempt to restart the protected storage service

    hscManager = OpenSCManager(NULL, NULL, GENERIC_EXECUTE);

    if(NULL == hscManager)
    {
        dwReturn = GetLastError();
        printf("Could not open service controller:%lx\n", dwReturn);
    }

    hscProtectedStorage = OpenServiceW(hscManager, L"ProtectedStorage", GENERIC_READ | GENERIC_EXECUTE);
    if(NULL == hscManager)
    {
        dwReturn = GetLastError();
        printf("Could not open ProtectedStorage service:%lx\n", dwReturn);
    }

    // Shut down pstore

    if(!QueryServiceStatus(hscProtectedStorage, &sStatus))
    {
        dwReturn = GetLastError();
        printf("Could not query ProtectedStorage service status:%lx\n", dwReturn);
        goto error;
    }

    while(SERVICE_STOPPED != sStatus.dwCurrentState)
    {
        DWORD dwLastStatus = sStatus.dwCurrentState;
        DWORD dwCheckpoint = sStatus.dwCheckPoint;

        switch(sStatus.dwCurrentState)
        {
        case SERVICE_RUNNING:
            if(!ControlService(hscProtectedStorage, SERVICE_CONTROL_STOP, &sStatus))
            {
                dwReturn = GetLastError();
                printf("Could not stop ProtectedStorage service:%lx\n", dwReturn);
                goto error;
            }
            break;
        case SERVICE_PAUSED:
            if(!ControlService(hscProtectedStorage, SERVICE_CONTROL_CONTINUE, &sStatus))
            {
                dwReturn = GetLastError();
                printf("Could not continue ProtectedStorage service:%lx\n", dwReturn);
                goto error;
            }
            break;
        default:

            if(!QueryServiceStatus(hscProtectedStorage, &sStatus))
            {
                dwReturn = GetLastError();
                printf("Could not query ProtectedStorage service status:%lx\n", dwReturn);
                goto error;
            }

            break;
        }

        Sleep(sStatus.dwWaitHint);

        if((sStatus.dwCheckPoint == dwCheckpoint) &&
           (sStatus.dwCurrentState == dwLastStatus))
        {
            dwWaitTime += sStatus.dwWaitHint;

            if(dwWaitTime > 120000) // 2 minutes
            {
                printf("Service is not responding\n");
                goto error;
            }
        }
        else
        {
            dwWaitTime = 0;
        }
    }

    if(!StartService(hscProtectedStorage, 0, NULL))
    {
        dwReturn = GetLastError();
        printf("Could not start ProtectedStorage service:%lx\n", dwReturn);
        goto error;
    }

error:

    if(hKey)
    {
        RegCloseKey(hKey);
    }

    return dwReturn;
}


BOOL FProviderSupportsAlg(
        HCRYPTPROV  hQueryProv,
        DWORD       dwAlgId,
        DWORD*      pdwKeySize)
{
    PROV_ENUMALGS       sSupportedAlgs;
    PROV_ENUMALGS_EX    sSupportedAlgsEx;
    DWORD       cbSupportedAlgs = sizeof(sSupportedAlgs);
    DWORD       cbSupportedAlgsEx = sizeof(sSupportedAlgsEx);
    int iAlgs;


    // now we have provider; enum the algorithms involved
    for(iAlgs=0; ; iAlgs++)
    {

        //
        // Attempt the EX alg enumeration
        if (CryptGetProvParam(
                hQueryProv,
                PP_ENUMALGS_EX,
                (PBYTE)&sSupportedAlgsEx,
                &cbSupportedAlgsEx,
                (iAlgs == 0) ? CRYPT_FIRST : 0  ))
        {
            if (sSupportedAlgsEx.aiAlgid == dwAlgId)
            {
                if(*pdwKeySize == -1)
                {
                    *pdwKeySize = sSupportedAlgsEx.dwMaxLen;
                }
                else
                {
                    if ((sSupportedAlgsEx.dwMinLen > *pdwKeySize) ||
                        (sSupportedAlgsEx.dwMaxLen < *pdwKeySize))
                        return FALSE;
                }

                return TRUE;

            }
        }
        else if (!CryptGetProvParam(
                hQueryProv,
                PP_ENUMALGS,
                (PBYTE)&sSupportedAlgs,
                &cbSupportedAlgs,
                (iAlgs == 0) ? CRYPT_FIRST : 0  ))
        {
            // trouble enumerating algs
            break;


            if (sSupportedAlgs.aiAlgid == dwAlgId)
            {
                // were we told to ignore size?
                if (*pdwKeySize != -1)
                {
                    // else, if defaults don't match
                    if (sSupportedAlgs.dwBitLen != *pdwKeySize)
                    {
                        return FALSE;
                    }
                }

                // report back size
                *pdwKeySize = sSupportedAlgs.dwBitLen;
                return TRUE;
            }
        }
        else
        {
            // trouble enumerating algs
            break;
        }
    }

    return FALSE;
}
    DWORD
GetUserStorageArea(
    IN      DWORD dwProvType,
    IN      BOOL fMachineKeyset,
    IN      BOOL fOldWin2KMachineKeyPath,
    OUT     BOOL *pfIsLocalSystem,      // used if fMachineKeyset is FALSE, in this
                                        // case TRUE is returned if running as Local System
    IN  OUT LPWSTR *ppwszUserStorageArea
    );



DWORD UpgradeKeys(DWORD dwBehavior)
{

    DWORD   aProvTypes[] = {PROV_RSA_FULL, PROV_DSS };
    DWORD   cProvTypes = sizeof(aProvTypes)/sizeof(aProvTypes[0]);
    DWORD   iProv;

    DWORD   dwLastError = ERROR_SUCCESS;
    HANDLE  hFind = INVALID_HANDLE_VALUE;
    CHAR   szContainerName[MAX_PATH+1];
    DWORD   cbContainerName = 0;
    BOOL    fModified;


    for(iProv = 0; iProv < cProvTypes; iProv++)
    {
        DWORD dwContainerFlags = CRYPT_FIRST;


        while(TRUE)
        {
            KEY_CONTAINER_INFO ContInfo;
            cbContainerName = MAX_PATH + 1;
            ZeroMemory(&ContInfo, sizeof(ContInfo));

            dwLastError = GetNextContainer(aProvTypes[iProv],
                               dwBehavior & BEHAVIOR_MACHINE,
                               dwContainerFlags,
                               szContainerName,
                               &cbContainerName,
                               &hFind);

            if(ERROR_NO_MORE_ITEMS == dwLastError)
            {
                hFind = INVALID_HANDLE_VALUE;
            }
            if(ERROR_SUCCESS != dwLastError)
            {
                break;
            }

            dwContainerFlags = 0;
            fModified = FALSE;

            dwLastError = ReadContainerInfo(
                                aProvTypes[iProv],
                                szContainerName,
                                dwBehavior & BEHAVIOR_MACHINE,
                                0,
                                &ContInfo
                                );

            if(ERROR_SUCCESS != dwLastError)
            {
                continue;
            }


            if(dwBehavior & BEHAVIOR_VERBOSE)
            {
                printf("========================================\n");
                printf("Key Container:\t\t%s\n\n",szContainerName);
            }

            if((ContInfo.ContLens.cbExchEncPriv) &&
               (ContInfo.pbExchEncPriv))
            {
                if(dwBehavior & BEHAVIOR_VERBOSE)
                {
                    printf(" Exchange Key\n");
                }

                dwLastError = UpgradeDPAPIBlob(dwBehavior,
                                               &ContInfo.pbExchEncPriv,
                                               &ContInfo.ContLens.cbExchEncPriv,
                                               &fModified);
                printf("\n");
            }

            if((ContInfo.ContLens.cbSigEncPriv) &&
               (ContInfo.pbSigEncPriv))
            {
                if(dwBehavior & BEHAVIOR_VERBOSE)
                {
                    printf(" Signature Key\n");
                }

                dwLastError = UpgradeDPAPIBlob(dwBehavior,
                                               &ContInfo.pbSigEncPriv,
                                               &ContInfo.ContLens.cbSigEncPriv,
                                               &fModified);
                printf("\n");
            }

            if(dwBehavior & BEHAVIOR_VERBOSE)
            {

                if(((0 == ContInfo.ContLens.cbExchEncPriv) ||
                    (NULL == ContInfo.pbExchEncPriv)) &&
                   ((0 == ContInfo.ContLens.cbSigEncPriv) ||
                    (NULL == ContInfo.pbSigEncPriv)))
                {
                    printf(" There are no keys in this container\n\n");
                }
            }

            if(((dwBehavior & BEHAVIOR_FORCE_ENC) || fModified) &&
                (0 == (dwBehavior & BEHAVIOR_NO_CHANGE)));
            {
                dwLastError = WriteContainerInfo(
                                    aProvTypes[iProv],
                                    ContInfo.rgwszFileName,
                                    dwBehavior & BEHAVIOR_MACHINE,
                                    &ContInfo
                                    );
            }
            FreeContainerInfo(&ContInfo);
        }
    }


    if(INVALID_HANDLE_VALUE != hFind)
    {
        CloseHandle(hFind);
    }
    return dwLastError;
}


typedef struct _DPAPI_BLOB_DATA
{
    DWORD dwVersion;
    DWORD dwFlags;
    LPWSTR wszDataDescription;
    DWORD cbDataDescription;
    DWORD EncrAlg;
    DWORD EncrAlgSize;
    DWORD MacAlg;
    DWORD MacAlgSize;
} DPAPI_BLOB_DATA, *PDPAPI_BLOB_DATA;





DWORD GetBlobData(PBYTE pbData, DWORD cbData, PDPAPI_BLOB_DATA BlobData)
{
    PBYTE pbCurrent = pbData;
    DWORD dwKeySize = 0;

    if(cbData < sizeof (DWORD) +
                sizeof(GUID) +
                sizeof(DWORD) +
                sizeof(GUID) +
                sizeof(DWORD) +
                sizeof(DWORD))
    {
        return ERROR_INVALID_DATA;
    }

    pbCurrent += sizeof(DWORD) + sizeof(GUID);

    BlobData->dwVersion = *(DWORD UNALIGNED *)pbCurrent;
    pbCurrent += sizeof(DWORD) + sizeof(GUID);

    BlobData->dwFlags = *(DWORD UNALIGNED *)pbCurrent;
    pbCurrent += sizeof(DWORD);

    BlobData->cbDataDescription = *(DWORD UNALIGNED *)pbCurrent;
    pbCurrent += sizeof(DWORD);

    if((DWORD)(pbCurrent - pbData) +
              BlobData->cbDataDescription +
              sizeof(DWORD) +
              sizeof(DWORD) +
              sizeof(DWORD)> cbData)
    {
        return ERROR_INVALID_DATA;
    }
    BlobData->wszDataDescription = (LPWSTR)pbCurrent;
    pbCurrent += BlobData->cbDataDescription;

    BlobData->EncrAlg = *(DWORD UNALIGNED *)pbCurrent;
    pbCurrent += sizeof(DWORD);

    BlobData->EncrAlgSize = *(DWORD UNALIGNED *)pbCurrent;
    pbCurrent += sizeof(DWORD);

    // skip past key
    dwKeySize = *(DWORD UNALIGNED *)pbCurrent;
    pbCurrent += sizeof(DWORD);

    if((DWORD)(pbCurrent - pbData) +
        dwKeySize +
        sizeof(DWORD) > cbData)
    {
        return ERROR_INVALID_DATA;
    }
    pbCurrent += dwKeySize;

    // skip past salt
    dwKeySize = *(DWORD UNALIGNED *)pbCurrent;
    pbCurrent += sizeof(DWORD);

    if((DWORD)(pbCurrent - pbData) +
        dwKeySize +
        sizeof(DWORD) +
        sizeof(DWORD)> cbData)
    {
        return ERROR_INVALID_DATA;
    }
    pbCurrent += dwKeySize;

    BlobData->MacAlg = *(DWORD UNALIGNED *)pbCurrent;
    pbCurrent += sizeof(DWORD);

    BlobData->MacAlgSize = *(DWORD UNALIGNED *)pbCurrent;
    pbCurrent += sizeof(DWORD);


    return ERROR_SUCCESS;
}

DWORD PrintBlobData(PDPAPI_BLOB_DATA BlobData)
{
    wprintf(L"  Description:\t\t%s\n", BlobData->wszDataDescription);
    wprintf(L"  Encryption Alg:\t");
    PrintAlgID(BlobData->EncrAlg, BlobData->EncrAlgSize);
    wprintf(L"\n");

    wprintf(L"  MAC Alg:\t\t");
    PrintAlgID(BlobData->MacAlg, BlobData->MacAlgSize);
    wprintf(L"\n\n");

    return ERROR_SUCCESS;
}


DWORD UpgradeDPAPIBlob(DWORD dwBehavior,
                 PBYTE *ppbData,
                 DWORD *pcbData,
                 BOOL  *pfModified)
{

    DPAPI_BLOB_DATA BlobData;
    DWORD           dwError = ERROR_SUCCESS;

    DATA_BLOB       DataIn;
    DATA_BLOB       DataOut;
    LPWSTR          wszDescription = NULL;
    CRYPTPROTECT_PROMPTSTRUCT Prompt;
    DWORD           dwFlags = 0;

    DataIn.pbData = NULL;
    DataIn.cbData = 0;
    DataOut.pbData = NULL;
    DataOut.cbData = 0;

    dwError = GetBlobData(*ppbData, *pcbData, &BlobData);

    if(ERROR_SUCCESS != dwError)
    {
        printf("Could not open key:%lx\n ", dwError);
        goto error;
    }

    if(MS_BASE_CRYPTPROTECT_VERSION != BlobData.dwVersion)
    {
        printf("Unknown data version\n");
        dwError = ERROR_INVALID_DATA;
        goto error;
    }
    if(dwBehavior & BEHAVIOR_VERBOSE)
    {
        dwError = PrintBlobData(&BlobData);
    }

    if(dwBehavior & BEHAVIOR_NO_CHANGE)
    {
        goto error;
    }

    // Check to see if upgrade is required
    if((BlobData.EncrAlgSize >= g_dwAlgID_Encr_Alg_KeySize) &&
       (0 == (dwBehavior & BEHAVIOR_FORCE_KEY)))
    {
        if(dwBehavior & BEHAVIOR_VERBOSE)
        {
            printf("  No upgrade necessary\n");
        }
        goto error;
    }
    if(((BlobData.dwFlags & CRYPTPROTECT_PROMPT_ON_UNPROTECT) ||
       (BlobData.dwFlags & CRYPTPROTECT_PROMPT_ON_PROTECT)) &&
       (0 == (dwBehavior & BEHAVIOR_ALLOW_UI)))
    {
        if(dwBehavior & BEHAVIOR_VERBOSE)
        {
            printf("  This key requires UI, and will not be upgraded\n");
        }
        goto error;
    }

    //
    // Upgrade the key
    //
    DataIn.pbData = *ppbData;
    DataIn.cbData = *pcbData;

    Prompt.cbSize = sizeof(Prompt);
    Prompt.dwPromptFlags = BlobData.dwFlags & (CRYPTPROTECT_PROMPT_ON_UNPROTECT | CRYPTPROTECT_PROMPT_ON_PROTECT);
    Prompt.hwndApp = NULL;
    Prompt.szPrompt = L"Key Upgrade Utility\n";

    if(0 == (dwBehavior & BEHAVIOR_ALLOW_UI))
    {
        dwFlags |= CRYPTPROTECT_UI_FORBIDDEN;
    }

    if(0 == (dwBehavior & BEHAVIOR_MACHINE))
    {
        dwFlags |= CRYPTPROTECT_LOCAL_MACHINE;
    }

    if(!CryptUnprotectData(&DataIn,
                       &wszDescription,
                       NULL,
                       NULL,
                       &Prompt,
                       dwFlags,
                       &DataOut))
    {
        dwError = GetLastError();
        printf("Could not unprotect key:%lx\n", dwError);
        goto error;
    }

    DataIn.pbData = NULL;
    DataIn.cbData = 0;
    if(!CryptProtectData(&DataOut,
                       wszDescription,
                       NULL,
                       NULL,
                       &Prompt,
                       dwFlags,
                       &DataIn))
    {
        dwError = GetLastError();
        printf("Could not protect key:%lx\n", dwError);
        goto error;
    }

    dwError = GetBlobData(DataIn.pbData, DataIn.cbData, &BlobData);

    if(ERROR_SUCCESS != dwError)
    {
        printf("Could not open key:%lx\n ", dwError);
        goto error;
    }

    if(MS_BASE_CRYPTPROTECT_VERSION != BlobData.dwVersion)
    {
        printf("Unknown data version\n");
        dwError = ERROR_INVALID_DATA;
        goto error;
    }
    if(dwBehavior & BEHAVIOR_VERBOSE)
    {
        printf("  Upgraded To\n");
        PrintBlobData(&BlobData);
    }


    LocalFree(*ppbData);

    *ppbData = DataIn.pbData;
    *pcbData = DataIn.cbData;


    *pfModified = TRUE;


error:

    if(DataOut.pbData)
    {
        ZeroMemory(DataOut.pbData, DataOut.cbData);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\programs\dssinstl\dssinstl.c ===
#undef UNICODE					// ## Not Yet
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <windows.h>
#include <wincrypt.h>

#define MS_DSS_TYPE     "DSS Signature"
#define MS_DH_TYPE      "DSS Signature with Diffie-Hellman Key Exachange"

#define PROVPATH        "SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider\\"
#define PROVPATH_LEN    sizeof(PROVPATH)

#define TYPEPATH        "SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider Types\\Type "
#define TYPEPATH_LEN    sizeof(TYPEPATH)

#define IMAGEPATH       "dssbase.dll"
#define IMAGEPATH_LEN    sizeof(IMAGEPATH)

BOOL SetCSPInfo(
                LPSTR pszProvider,
                LPSTR pszImagePath,
                BYTE *pbSig,
                DWORD cbSig,
                DWORD dwProvType,
                LPSTR pszTypeName
                )
{
    DWORD   dwIgn;
    HKEY    hKey = 0;
    HKEY    hTypeKey = 0;
    DWORD   cbProv;
    BYTE    *pszProv = NULL;
    CHAR    pszTypeString[32];
    DWORD   cbType;
    BYTE    *pszType = NULL;
    DWORD   err;
    BOOL    fRet = FALSE;

    cbProv = PROVPATH_LEN + strlen(pszProvider);
    if (NULL == (pszProv = (LPSTR)LocalAlloc(LMEM_ZEROINIT, cbProv)))
        goto Ret;

    strcpy(pszProv, PROVPATH);
    strcat(pszProv, pszProvider);

	//
	// Create or open in local machine for provider:
	// Microsoft Base Cryptographic Provider v1.0
	//
    if (ERROR_SUCCESS != (err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                               (const char *)pszProv,
                                               0L, "", REG_OPTION_NON_VOLATILE,
                                               KEY_ALL_ACCESS, NULL, &hKey,
                                               &dwIgn)))
        goto Ret;

	//
	// Set Image path to: scp.dll
	//
    if (ERROR_SUCCESS != (err = RegSetValueEx(hKey, "Image Path", 0L, REG_SZ,
	                                          pszImagePath,
                                              strlen(pszImagePath) + 1)))
        goto Ret;

	//
	// Set Type to: Type 003
	//
    if (ERROR_SUCCESS != (err = RegSetValueEx(hKey, "Type", 0L, REG_DWORD,
                                              (LPTSTR)&dwProvType,
                                              sizeof(DWORD))))
        goto Ret;

	//
	// Place signature
	//
    if (ERROR_SUCCESS != (err = RegSetValueEx(hKey, "Signature", 0L,
                                              REG_BINARY, pbSig, cbSig)))
        goto Ret;

	//
	// Create or open in local machine for provider type:
	//

    memset(pszTypeString, 0, sizeof(pszTypeString));
    sprintf(pszTypeString, "%.3d", dwProvType);

    cbType = TYPEPATH_LEN + strlen(pszTypeString);
    if (NULL == (pszType = (LPSTR)LocalAlloc(LMEM_ZEROINIT, cbType)))
        goto Ret;

    strcpy(pszType, TYPEPATH);
    strcat(pszType, pszTypeString);

    if (ERROR_SUCCESS != (err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                               (const char *) pszType,
                                               0L, "", REG_OPTION_NON_VOLATILE,
                                               KEY_ALL_ACCESS, NULL, &hTypeKey,
                                               &dwIgn)))
        goto Ret;

    if (ERROR_SUCCESS != (err = RegSetValueEx(hTypeKey, "Name", 0L,
                                              REG_SZ, pszProvider,
                                              strlen(pszProvider) + 1)))
        goto Ret;

    if (ERROR_SUCCESS != (err = RegSetValueEx(hTypeKey, "TypeName", 0L,
                                              REG_SZ, pszTypeName,
                                              strlen(pszTypeName) + 1)))
        goto Ret;

    fRet = TRUE;
Ret:
    if (hKey)
        RegCloseKey(hKey);
    if (hTypeKey)
        RegCloseKey(hTypeKey);
    if (pszProv)
        LocalFree(pszProv);
    if (pszType)
        LocalFree(pszType);
    return fRet;
}

int __cdecl main(int cArg, char *rgszArg[])
{
    DWORD   err;
    DWORD   dwValue;
    HANDLE  hFileSig = INVALID_HANDLE_VALUE;
    DWORD   NumBytesRead;
    DWORD   lpdwFileSizeHigh;
    LPVOID  lpvAddress = NULL;    
    DWORD   NumBytes;
    BOOL    fRet = FALSE;

    //
    // Just to open scp.dll signature file.  This file was created by
    // sign.exe.
    //
    if (INVALID_HANDLE_VALUE == (hFileSig = CreateFile("dssbase.sig",
                                                       GENERIC_READ, 0, NULL,
			                                           OPEN_EXISTING,
                                                       FILE_ATTRIBUTE_NORMAL,
			                                           0)))
    {
        printf("Install failed: Unable to open dssbase.sig: %x\n", GetLastError());
        goto Ret;
    }

    if ((NumBytes = GetFileSize((HANDLE) hFileSig, &lpdwFileSizeHigh)) ==
                                0xffffffff)
    {
        printf("Install failed: Getting size of file dssbase.sig: %x\n", GetLastError());
        goto Ret;
    }

    if ((lpvAddress = VirtualAlloc(NULL, NumBytes, MEM_RESERVE |
		                           MEM_COMMIT,
                                   PAGE_READWRITE)) == NULL)
    {
        printf("Install failed: Alloc to read dssbase.sig: %x\n", GetLastError());
        goto Ret;
    }

    if (!ReadFile((HANDLE) hFileSig, lpvAddress, NumBytes,
		  &NumBytesRead, 0))
    {

        printf("Install failed: Reading dssbase.sig: %x\n", GetLastError());
        goto Ret;
    }

    if (NumBytesRead != NumBytes)
    {
        printf("Install failed: Bytes read doesn't match file size\n");
        goto Ret;
    }

	//
	// install the default DSS provider
	// Type 003
	//
    if (!SetCSPInfo(MS_DEF_DSS_PROV,
                    IMAGEPATH,
                    lpvAddress,
                    NumBytesRead,
                    PROV_DSS,
                    MS_DSS_TYPE))
    {
        printf("Unable to install dssbase.dll");
        goto Ret;
    }

	//
	// install the default DSS/DH provider
	// Type 013
	//
    if (!SetCSPInfo(MS_DEF_DSS_DH_PROV,
                    IMAGEPATH,
                    lpvAddress,
                    NumBytesRead,
                    PROV_DSS_DH,
                    MS_DH_TYPE))
    {
        printf("Unable to install dssbase.dll");
        goto Ret;
    }

	printf("Installed: %s\n", IMAGEPATH);
    fRet = TRUE;
Ret:
    if (lpvAddress)
        VirtualFree(lpvAddress, 0, MEM_RELEASE);
    if (INVALID_HANDLE_VALUE != hFileSig)
        CloseHandle(hFileSig);
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\programs\keymigrt\systok.cpp ===
//
//  chngpwd.cpp
//
//  Copyright (c) Microsoft Corp, 1998
//
//  This file contains source code for testing protected storage's key
//  backup and recovery capabilities under a real world scenario, by creating
//  a local user account, performing a data protection operation, and then
//  change the pwd, then performing data unprotect, and comparing the data.
//
//  History:
//
//  Todds       8/15/98     Created
//
#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <wincrypt.h>
#include <userenv.h>
#include <lm.h>
#include <psapi.h>

#define TERROR(msg)          LogError(__FILE__, __LINE__, msg)
#define TERRORVAL(msg, val)  LogErrorVal(__FILE__, __LINE__, msg, val)
#define TCOMMENT(msg)        LogComment(msg)
#define MyAlloc(cb)          HeapAlloc(GetProcessHeap(), 0, cb)
#define MyFree(pv)           HeapFree(GetProcessHeap(), 0, pv)
#define WSZ_BYTECOUNT(s)     (2 * wcslen(s) + 2)
#define CHECK_NULL(s)        if (s == NULL) \
                                LogError(__FILE__, __LINE__, L"## CHECK_NULL ##")

#define MAX_BLOBS           20
#define MAX_PROCESSES       200
#define MAX_SD              2048
#define BLOB_INCREMENT      0x4001 // 1 page + 1 byte...




//
//  Error Logging Functions  # defined as follows to include
//  Line and FILE macros:
//
//  TERROR       -   LogError()
//  TERRORVAL    -   LogErrorVal()
//
//

void
LogError(LPSTR szFile,
         int iLine,
         LPWSTR wszMsg)
{

    //
    //  Event log or testutil logging later...
    //

    WCHAR buffer[512];
    swprintf(buffer, L"ERROR Line: %i -> %s\n", iLine, wszMsg);
    OutputDebugStringW(buffer);
    wprintf(buffer);


}

void
LogErrorVal(LPSTR  szFile,
            int    iLine,
            LPWSTR wszMsg,
            DWORD  dwVal)
{

    WCHAR buffer[256]; // this should be adequate.
    swprintf(buffer, L"%s Error:: %x", wszMsg, dwVal);
    LogError(szFile, iLine, buffer);
}

void
LogComment(LPWSTR wszMsg)
{

    //
    //  Event log or testutil logging later...
    //

    WCHAR buffer[512];
    OutputDebugStringW(wszMsg);
    wprintf(wszMsg);
}



void 
DumpBin(CRYPT_DATA_BLOB hash)
{

    WCHAR buff[256], out[256];
    ULONG cb;

    swprintf(out, L"");
    while (hash.cbData > 0) {
        cb = min(4, hash.cbData);
        hash.cbData -= cb;
        for (; cb > 0; cb--, hash.pbData++) {
            swprintf(buff, L"%02X", *hash.pbData);
            wcscat(out, buff);
        }
        wcscat(out, L" ");
    }
    
    wcscat(out, L"\n");

    TCOMMENT(out);
}
//
//  SetSidOnAcl
//


BOOL
SetSidOnAcl(
    PSID pSid,
    PACL pAclSource,
    PACL *pAclDestination,
    DWORD AccessMask,
	BYTE AceFlags,
    BOOL bAddSid
    )
{
    ACL_SIZE_INFORMATION AclInfo;
    DWORD dwNewAclSize, dwErr = S_OK;
    LPVOID pAce;
    DWORD AceCounter;
    BOOL bSuccess=FALSE; // assume this function will fail

    //
    // If we were given a NULL Acl, just provide a NULL Acl
    //
    if(pAclSource == NULL) {
        *pAclDestination = NULL;
        return TRUE;
    }

    if(!IsValidSid(pSid)) return FALSE;

    if(!GetAclInformation(
        pAclSource,
        &AclInfo,
        sizeof(ACL_SIZE_INFORMATION),
        AclSizeInformation
        )) return FALSE;

    //
    // compute size for new Acl, based on addition or subtraction of Ace
    //
    if(bAddSid) {
        dwNewAclSize=AclInfo.AclBytesInUse  +
            sizeof(ACCESS_ALLOWED_ACE)  +
            GetLengthSid(pSid)          -
            sizeof(DWORD)               ;
    }
    else {
        dwNewAclSize=AclInfo.AclBytesInUse  -
            sizeof(ACCESS_ALLOWED_ACE)  -
            GetLengthSid(pSid)          +
            sizeof(DWORD)               ;
    }

    *pAclDestination = (PACL)MyAlloc(dwNewAclSize);

    if(*pAclDestination == NULL) 
    {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        return FALSE;
    }

    
    //
    // initialize new Acl
    //
    if(!InitializeAcl(
            *pAclDestination, 
            dwNewAclSize, 
            ACL_REVISION
            )){
        dwErr = GetLastError();
        TERRORVAL(L"InitilizeAcl failed!", dwErr);
        goto ret;
    }

    //
    // if appropriate, add ace representing pSid
    //
    if(bAddSid) {
		PACCESS_ALLOWED_ACE pNewAce;

        if(!AddAccessAllowedAce(
            *pAclDestination,
            ACL_REVISION,
            AccessMask,
            pSid
            )) {
            dwErr = GetLastError();
            TERRORVAL(L"AddAccessAllowedAce failed!", dwErr);
            goto ret;
        }

		//
		// get pointer to ace we just added, so we can change the AceFlags
		//
		if(!GetAce(
			*pAclDestination,
			0, // this is the first ace in the Acl
			(void**) &pNewAce
			)){
        
            dwErr = GetLastError();
            TERRORVAL(L"GetAce failed!", dwErr);
            goto ret;
        }

		pNewAce->Header.AceFlags = AceFlags;	
    }

    //
    // copy existing aces to new Acl
    //
    for(AceCounter = 0 ; AceCounter < AclInfo.AceCount ; AceCounter++) {
        //
        // fetch existing ace
        //
        if(!GetAce(pAclSource, AceCounter, &pAce)){
            dwErr = GetLastError();
            TERRORVAL(L"GetAce failed!", dwErr);
            goto ret;
        }
        //
        // check to see if we are removing the Ace
        //
        if(!bAddSid) {
            //
            // we only care about ACCESS_ALLOWED aces
            //
            if((((PACE_HEADER)pAce)->AceType) == ACCESS_ALLOWED_ACE_TYPE) {
                PSID pTempSid=(PSID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;
                //
                // if the Sid matches, skip adding this Sid
                //
                if(EqualSid(pSid, pTempSid)) continue;
            }
        }

        //
        // append ace to Acl
        //
        if(!AddAce(
            *pAclDestination,
            ACL_REVISION,
            MAXDWORD,  // maintain Ace order
            pAce,
            ((PACE_HEADER)pAce)->AceSize
            )) {
         
            dwErr = GetLastError();
            TERRORVAL(L"AddAccessAllowedAce failed!", dwErr);
            goto ret;
        }
    }

    bSuccess=TRUE; // indicate success

    
ret:

    //
    // free memory if an error occurred
    //
    if(!bSuccess) {
        if(*pAclDestination != NULL)
            MyFree(*pAclDestination);
    }

    

    return bSuccess;
}
//
//  AddSIDToKernelObject()
//
//  This function takes a given SID and dwAccess and adds it to a given token.
//
//  **  Be sure to restore old kernel object
//  **  using call to GetKernelObjectSecurity()
//
BOOL
AddSIDToKernelObjectDacl(PSID                   pSid,
                         DWORD                  dwAccess,
                         HANDLE                 OriginalToken,
                         PSECURITY_DESCRIPTOR*  ppSDOld)
{

    PSECURITY_DESCRIPTOR    pSD = NULL;
    SECURITY_DESCRIPTOR     sdNew;
    DWORD                   cbByte = MAX_SD, cbNeeded = 0, dwErr = 0; 
    PACL                    pOldDacl = NULL, pNewDacl = NULL;
    BOOL                    fDaclPresent, fDaclDefaulted, fRet = FALSE;                    
   
    pSD = (PSECURITY_DESCRIPTOR) MyAlloc(cbByte);
    if (NULL == pSD) {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        return FALSE;
    }

    if (!InitializeSecurityDescriptor(
                &sdNew, 
                SECURITY_DESCRIPTOR_REVISION
                )) {

        dwErr = GetLastError();
        TERRORVAL(L"InitializeSecurityDescriptor failed!", dwErr);
        goto ret;
    }

    if (!GetKernelObjectSecurity(
        OriginalToken,
        DACL_SECURITY_INFORMATION,
        pSD,
        cbByte,
        &cbNeeded
        )) {
        
        dwErr = GetLastError();
        if (cbNeeded > MAX_SD && dwErr == ERROR_MORE_DATA) { 
    
            MyFree(pSD);
            pSD = NULL;
            pSD = (PSECURITY_DESCRIPTOR) MyAlloc(cbNeeded);
            if (NULL == pSD) {
                TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
                dwErr = E_OUTOFMEMORY;
                goto ret;
            }
            
            dwErr = S_OK;
            if (!GetKernelObjectSecurity(
                OriginalToken,
                DACL_SECURITY_INFORMATION,
                pSD,
                cbNeeded,
                &cbNeeded
                )) {
                dwErr = GetLastError();
            }
            
        }
        
        if (dwErr != S_OK) {
            TERRORVAL(L"GetKernelObjectSecurity failed!", dwErr);
            goto ret;
        }
    }
    
    if (!GetSecurityDescriptorDacl(
        pSD,
        &fDaclPresent,
        &pOldDacl,
        &fDaclDefaulted
        )) {
        dwErr = GetLastError();
        TERRORVAL(L"GetSecurityDescriptorDacl failed!", dwErr);
        goto ret;
    }
    
    if (!SetSidOnAcl(
        pSid,
        pOldDacl,
        &pNewDacl,
        dwAccess,
        0,
        TRUE
        )) {
        goto ret;
    }
    
    if (!SetSecurityDescriptorDacl(
        &sdNew,
        TRUE,
        pNewDacl,
        FALSE
        )) {
        dwErr = GetLastError();
        TERRORVAL(L"SetSecurityDescriptorDacl failed!", dwErr);
        goto ret;
    } 
    
    if (!SetKernelObjectSecurity(
        OriginalToken,
        DACL_SECURITY_INFORMATION,
        &sdNew
        )) {
        
        dwErr = GetLastError();
        TERRORVAL(L"SetKernelObjectSecurity failed!", dwErr);
        goto ret;
    }
    
    *ppSDOld = pSD;
    fRet = TRUE;

ret:

    if (NULL != pNewDacl) {
        MyFree(pNewDacl);
    }

    if (!fRet) {
        if (NULL != pSD) {
            MyFree(pSD);
            *ppSDOld = NULL;
        }

    }
       
    return fRet;
}


//
//  DataFree()
//
//  Utility for freeing array of DATA_BLOB structs
//
void
DataFree(DATA_BLOB* arDataBlob, 
         BOOL       fCryptAlloc)
{

    if (arDataBlob == NULL) return; // not alloc'd
    
    for (DWORD i = 0; i < MAX_BLOBS;i++) {

        if (arDataBlob[i].pbData != NULL) {
            
            if (!fCryptAlloc) { 
                MyFree(arDataBlob[i].pbData);
            } else { // Data member alloc'd by DataProtect call
                LocalFree(arDataBlob[i].pbData);
            }
        }
       
    }

    MyFree(arDataBlob);
}

    


BOOL
SetPrivilege(
    HANDLE hToken,          // token handle
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious=sizeof(TOKEN_PRIVILEGES);

    if(!LookupPrivilegeValue( NULL, Privilege, &luid )) return FALSE;

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    //
    // second pass.  set privilege based on previous setting
    //
    tpPrevious.PrivilegeCount       = 1;
    tpPrevious.Privileges[0].Luid   = luid;

    if(bEnablePrivilege) {
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    }
    else {
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
            tpPrevious.Privileges[0].Attributes);
    }

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tpPrevious,
            cbPrevious,
            NULL,
            NULL
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    return TRUE;
}

BOOL
SetCurrentPrivilege(
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    BOOL bSuccess=FALSE; // assume failure
    HANDLE hToken;

    if (!OpenThreadToken(
            GetCurrentThread(), 
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            FALSE,
            &hToken)){       
                
        if(!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            &hToken
            )) return FALSE;
    }

    if(SetPrivilege(hToken, Privilege, bEnablePrivilege)) bSuccess=TRUE;
    CloseHandle(hToken);

    return bSuccess;
}


//
//  GetUserSid
//
//  This function takes a token, and returns the user SID from that token.
//
//  Note:   SID must be freed by MyFree()
//          hToken is optional...  NULL means we'll grab it.
//
BOOL
GetUserSid(HANDLE   hClientToken,
           PSID*    ppSid,
           DWORD*   lpcbSid)
{
    DWORD                       cbUserInfo = 0;
    PTOKEN_USER                 pUserInfo = NULL;
    PUCHAR                      pnSubAuthorityCount = 0;
    DWORD                       cbSid = 0;
    BOOL                        fRet = FALSE;
    HANDLE                      hToken = hClientToken;
    
    *ppSid = NULL;

    if (NULL == hClientToken) {
        
        if (!OpenThreadToken(   
            GetCurrentThread(),
            TOKEN_QUERY,
            FALSE,
            &hToken
            )) { 
            
            // not impersonating, use process token...
            if (!OpenProcessToken(
                GetCurrentProcess(),
                TOKEN_QUERY,
                &hToken
                )) {

                TERRORVAL(L"OpenProcessToken failed!", GetLastError());
                return FALSE;
            }
        }
    }
    
    // this will fail, usually w/ ERROR_INSUFFICIENT_BUFFER
    GetTokenInformation(
        hToken, 
        TokenUser, 
        NULL, 
        0, 
        &cbUserInfo
        );
    
    pUserInfo = (PTOKEN_USER) MyAlloc(cbUserInfo);
    if (NULL == pUserInfo) {
        TERRORVAL(L"ALLOC FAILURE!", E_OUTOFMEMORY);
        return FALSE;
    }
    
    if (!GetTokenInformation(
        hToken,
        TokenUser,
        pUserInfo,
        cbUserInfo,
        &cbUserInfo
        )) {
        
        TERRORVAL(L"GetTokenInformation failed!", GetLastError());
        goto ret;
    }
 
    //
    //  Now that we've got the SID AND ATTRIBUTES struct, get the SID lenght,
    //  alloc room, and return *just the SID*
    //
    if (!IsValidSid(pUserInfo->User.Sid)) goto ret;
    pnSubAuthorityCount = GetSidSubAuthorityCount(pUserInfo->User.Sid);
    cbSid = GetSidLengthRequired(*pnSubAuthorityCount);

    *ppSid = (PSID) MyAlloc(cbSid);
    if (NULL == *ppSid ) {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        goto ret;
    }

    if (!CopySid(
            cbSid,
            *ppSid, 
            pUserInfo->User.Sid
            )) {
        
        TERRORVAL(L"CopySid failed!", GetLastError());
        goto copyerr;
    }

    *lpcbSid = cbSid; // may be useful later on...
    fRet = TRUE;

ret:
    if (NULL == hClientToken && NULL != hToken) { // supplied our own
        CloseHandle(hToken);
    }

    if (NULL != pUserInfo) {
        MyFree(pUserInfo);
    }

    return fRet;

copyerr:

    if (NULL != *ppSid) {
        MyFree(*ppSid);
        *ppSid = NULL;
    }

    goto ret;
}

//
//  IsLocalSystem()
//  This function makes the determination if the given process token
//  is running as local system.
//
BOOL
IsLocalSystem(HANDLE hToken) 
{


    PSID                        pLocalSid = NULL, pTokenSid = NULL;
    SID_IDENTIFIER_AUTHORITY    IDAuthorityNT      = SECURITY_NT_AUTHORITY;
    DWORD                       cbSid = 0;    
    BOOL                        fRet = FALSE;

    if (!GetUserSid(
            hToken,
            &pTokenSid,
            &cbSid
            )) {
        goto ret;
    }

    if (!AllocateAndInitializeSid(
                &IDAuthorityNT,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0,0,0,0,0,0,0,
                &pLocalSid
                )) {

        TERRORVAL(L"AllocateAndInitializeSid failed!", GetLastError());
        goto ret;
    }

    if (EqualSid(pLocalSid, pTokenSid)) {
        fRet = TRUE; // got one!
    } 

ret:

    if (NULL != pTokenSid) {
        MyFree(pTokenSid);
    }

    if (NULL != pLocalSid) {
        FreeSid(pLocalSid);
    }

    return fRet;
}




//
//  GetLocalSystemToken()
//
//  This function grabs a process token from a LOCAL SYSTEM process and uses it
//  to run as local system for the duration of the test
//
extern "C" DWORD
GetLocalSystemToken(HANDLE* phRet)
{

    HANDLE  hProcess = NULL;
    HANDLE  hPToken = NULL, hPTokenNew = NULL, hPDupToken = NULL;

    DWORD   rgPIDs[MAX_PROCESSES], cbNeeded = 0, dwErr = S_OK, i = 0;
    DWORD   cbrgPIDs = sizeof(DWORD) * MAX_PROCESSES;

    PSECURITY_DESCRIPTOR    pSD = NULL;
    PSID                    pSid = NULL;
    DWORD                   cbSid = 0;
    BOOL                    fSet = FALSE;

    //  SLOW BUFFERs
    BYTE    rgByte[MAX_SD], rgByte2[MAX_SD];
    DWORD   cbByte = MAX_SD, cbByte2 = MAX_SD;
  
    *phRet = NULL;

    if(!SetCurrentPrivilege(SE_DEBUG_NAME, TRUE)) {
        TERROR(L"SetCurrentPrivilege (debug) failed!");
        return E_FAIL;
    }

    if(!SetCurrentPrivilege(SE_TAKE_OWNERSHIP_NAME, TRUE)) {
        TERROR(L"SetCurrentPrivilege (to) failed!");
        return E_FAIL;
    }

    if (!EnumProcesses(
                rgPIDs,
                cbrgPIDs,
                &cbNeeded
                )) {

        dwErr = GetLastError();
        TERRORVAL(L"EnumProcesses failed!", dwErr);
        goto ret;
    }

    //
    //  Get current user's sid for use in expanding SD.
    //
    if (!GetUserSid(
        NULL, 
        &pSid,
        &cbSid
        )) {
        goto ret;
    }

    //
    //  Walk processes until we find one that's running as
    //  local system
    //
    for (i = 1; i < (cbNeeded / sizeof(DWORD)); i++) {

        hProcess = OpenProcess(
                    PROCESS_ALL_ACCESS,
                    FALSE,
                    rgPIDs[i]
                    );
        
        if (NULL == hProcess) {
            dwErr = GetLastError();
            TERRORVAL(L"OpenProcess failed!", dwErr);
            goto ret;
        }

        if (!OpenProcessToken(
                    hProcess,
                    READ_CONTROL | WRITE_DAC,
                    &hPToken
                    )) {

            dwErr = GetLastError();
            TERRORVAL(L"OpenProcessToken failed!", dwErr);
            goto ret;
        }

        //
        //  We've got a token, but we can't use it for 
        //  TOKEN_DUPLICATE access.  So, instead, we'll go
        //  ahead and whack the DACL on the object to grant us
        //  this access, and get a new token.
        //  **** BE SURE TO RESTORE hProcess to Original SD!!! ****
        //
        if (!AddSIDToKernelObjectDacl(
                         pSid,
                         TOKEN_DUPLICATE,
                         hPToken,
                         &pSD
                         )) {
            goto ret;
        }
                       
        fSet = TRUE;
        
        if (!OpenProcessToken(
            hProcess,
            TOKEN_DUPLICATE,
            &hPTokenNew
            )) {
            
            dwErr = GetLastError();
            TERRORVAL(L"OpenProcessToken failed!", dwErr);
            goto ret;
        }
        
        //
        //  Duplicate the token
        //
        if (!DuplicateTokenEx(
                    hPTokenNew,
                    TOKEN_ALL_ACCESS,
                    NULL,
                    SecurityImpersonation,
                    TokenPrimary,
                    &hPDupToken
                    )) {

            dwErr = GetLastError();
            TERRORVAL(L"DuplicateToken failed!", dwErr);
            goto ret;
        }

        if (IsLocalSystem(hPDupToken)) {
            *phRet = hPDupToken;
            break; // found a local system token
        }

        //  Loop cleanup
        if (!SetKernelObjectSecurity(
            hPToken,
            DACL_SECURITY_INFORMATION,
            pSD
            )) {

            dwErr = GetLastError();
            TERRORVAL(L"SetKernelObjectSecurity failed!", dwErr);
            goto ret;
        } 
        
        fSet = FALSE;
        
        if (NULL != hPDupToken) {
            CloseHandle(hPDupToken);
            hPDupToken = NULL;
        }

        if (NULL != pSD) { 
            MyFree(pSD);
            pSD = NULL;
        }

        if (NULL != hPToken) {
            CloseHandle(hPToken);
            hPToken = NULL;
        }

        if (NULL != hProcess) {
            CloseHandle(hProcess);
            hProcess = NULL;
        }

    } // ** FOR ** 

ret:


    //***** REMEMBER TO RESTORE ORIGINAL SD TO OBJECT*****
    
    if (fSet) {
        
        if (!SetKernelObjectSecurity(
            hPToken,
            DACL_SECURITY_INFORMATION,
            pSD
            )) {
            
            dwErr = GetLastError();
            TERRORVAL(L"SetKernelObjectSecurity failed (cleanup)!", dwErr);
        } 
    }

    if (NULL != pSid) {
        MyFree(pSid);
    }

    if (NULL != hPToken) {
        CloseHandle(hPToken);
    }
    
    if (NULL != pSD) {
        MyFree(pSD);
    }

    if (NULL != hProcess) {
        CloseHandle(hProcess);
    }
    
    return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\programs\maccsp\maccsp.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : client.cxx                                             //
//  DESCRIPTION   : Crypto API interface                                   //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Mar  8 1996 larrys  New                                            //
//                  dbarlow                                                //
//                                                                         //
//  Copyright (C) 1996 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>
#include <imagehlp.h>
#include "des.h"
#include "modes.h"

// SIG in file
#define SIG_RESOURCE_NAME   "#666"
// MAC in file
#define MAC_RESOURCE_NAME   "#667"

static DWORD dwMACInFileVersion = 0x100;

BYTE rgbDESKey[] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef};

// The function MACs the given bytes.
void MACBytes(
              IN DESTable *pDESKeyTable,
              IN BYTE *pbData,
              IN DWORD cbData,
              IN OUT BYTE *pbTmp,
              IN OUT DWORD *pcbTmp,
              IN OUT BYTE *pbMAC,
              IN BOOL fFinal
              )
{
    DWORD   cb = cbData;
    DWORD   cbMACed = 0;

    while (cb)
    {
        if ((cb + *pcbTmp) < DES_BLOCKLEN)
        {
            memcpy(pbTmp + *pcbTmp, pbData + cbMACed, cb);
            *pcbTmp += cb;
            break;
        }
        else
        {
            memcpy(pbTmp + *pcbTmp, pbData + cbMACed, DES_BLOCKLEN - *pcbTmp);
            CBC(des, DES_BLOCKLEN, pbMAC, pbTmp, pDESKeyTable,
                ENCRYPT, pbMAC);
            cbMACed = cbMACed + (DES_BLOCKLEN - *pcbTmp);
            cb = cb - (DES_BLOCKLEN - *pcbTmp);
            *pcbTmp = 0;
        }
    }
}

/*
void QuickTest()
{
    BYTE        rgbTmp[DES_BLOCKLEN];
    DWORD       cbTmp = 0;
    BYTE        rgbMAC[DES_BLOCKLEN] =
    {
        0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef
    };
    DESTable    DESKeyTable;
    DWORD       i;
    BYTE        rgbData[] =
    {
        0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31, 0x20,
        0x4e, 0x6f, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74,
        0x68, 0x65, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20,
        0x66, 0x6f, 0x72, 0x20, 0x00, 0x00, 0x00, 0x00
    };

    memset(&DESKeyTable, 0, sizeof(DESKeyTable));
    memset(rgbTmp, 0, sizeof(rgbTmp));

    // init the key table
    deskey(&DESKeyTable, rgbDESKey);

    MACBytes(&DESKeyTable, rgbData, sizeof(rgbData), rgbTmp,
             &cbTmp, rgbMAC, TRUE);

    printf("MAC - ");
    for (i = 0; i < DES_BLOCKLEN; i++)
    {
        printf("%02X", rgbMAC[i]);
    }
    printf("\n");
}
*/

// Given hInst, allocs and returns pointers to MAC pulled from
// resource
BOOL GetResourcePtr(
                    IN HMODULE hInst,
                    IN LPSTR pszRsrcName,
                    OUT BYTE **ppbRsrcMAC,
                    OUT DWORD *pcbRsrcMAC
                    )
{
    HRSRC   hRsrc;
    BOOL    fRet = FALSE;

    // Nab resource handle for our signature
    if (NULL == (hRsrc = FindResourceA(hInst, pszRsrcName,
                                       RT_RCDATA)))
        goto Ret;

    // get a pointer to the actual signature data
    if (NULL == (*ppbRsrcMAC = (PBYTE)LoadResource(hInst, hRsrc)))
        goto Ret;

    // determine the size of the resource
    if (0 == (*pcbRsrcMAC = SizeofResource(hInst, hRsrc)))
        goto Ret;

    fRet = TRUE;
Ret:
    return fRet;
}

#define CSP_TO_BE_MACED_CHUNK  4096

// Given hFile, reads the specified number of bytes (cbToBeMACed) from the file
// and MACs these bytes.  The function does this in chunks.
BOOL MACBytesOfFile(
                     IN HANDLE hFile,
                     IN DWORD cbToBeMACed,
                     IN DESTable *pDESKeyTable,
                     IN BYTE *pbTmp,
                     IN DWORD *pcbTmp,
                     IN BYTE *pbMAC,
                     IN BYTE fFinal
                     )
{
    BYTE    rgbChunk[CSP_TO_BE_MACED_CHUNK];
    DWORD   cbRemaining = cbToBeMACed;
    DWORD   cbToRead;
    DWORD   dwBytesRead;
    BOOL    fRet = FALSE;

    //
    // loop over the file for the specified number of bytes
    // updating the hash as we go.
    //

    while (cbRemaining > 0)
    {
        if (cbRemaining < CSP_TO_BE_MACED_CHUNK)
            cbToRead = cbRemaining;
        else
            cbToRead = CSP_TO_BE_MACED_CHUNK;

        if(!ReadFile(hFile, rgbChunk, cbToRead, &dwBytesRead, NULL))
            goto Ret;
        if (dwBytesRead != cbToRead)
            goto Ret;

        MACBytes(pDESKeyTable, rgbChunk, dwBytesRead, pbTmp, pcbTmp,
                 pbMAC, fFinal);
        cbRemaining -= cbToRead;
    }

    fRet = TRUE;
Ret:
    return fRet;
}


BOOL MACTheFileNoSig(
                     IN LPCSTR pszImage,
                     IN DWORD cbImage,
                     IN DWORD dwMACVersion,
                     IN DWORD dwCRCOffset,
                     OUT BYTE *pbMAC
                     )
{
    HMODULE                     hInst = 0;
    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbStart;
    BYTE                        rgbMAC[DES_BLOCKLEN];
    BYTE                        rgbZeroMAC[DES_BLOCKLEN + sizeof(DWORD) * 2];
    BYTE                        *pbPostCRC;   // pointer to just after CRC
    DWORD                       cbCRCToMAC;   // number of bytes from CRC to sig
    DWORD                       cbPostMAC;    // size - (already hashed + signature size)
    BYTE                        *pbPostMAC;
    DWORD                       dwZeroCRC = 0;
    DWORD                       dwBytesRead = 0;
    OFSTRUCT                    ImageInfoBuf;
    HFILE                       hFile = HFILE_ERROR;
    HANDLE                      hMapping = NULL;
    DESTable                    DESKeyTable;
    BYTE                        rgbTmp[DES_BLOCKLEN];
    DWORD                       cbTmp = 0;
    BYTE                        *pbRsrcMAC = NULL;
    DWORD                       cbRsrcMAC;
    BOOL                        fRet = FALSE;

    memset(&MemInfo, 0, sizeof(MemInfo));
    memset(rgbMAC, 0, sizeof(rgbMAC));
    memset(rgbTmp, 0, sizeof(rgbTmp));

    // Load the file
    if (HFILE_ERROR == (hFile = OpenFile(pszImage, &ImageInfoBuf,
                                         OF_READ)))
    {
        goto Ret;
    }

    hMapping = CreateFileMapping((HANDLE)IntToPtr(hFile),
                                  NULL,
                                  PAGE_READONLY,
                                  0,
                                  0,
                                  NULL);
    if(hMapping == NULL)
    {
        goto Ret;
    }

    hInst = MapViewOfFile(hMapping,
                          FILE_MAP_READ,
                          0,
                          0,
                          0);
    if(hInst == NULL)
    {
        goto Ret;
    }
    pbStart = (BYTE*)hInst;

    // Convert pointer to HMODULE, using the same scheme as
    // LoadLibrary (windows\base\client\module.c).
    *((ULONG_PTR*)&hInst) |= 0x00000001;

    // create a zero byte MAC
    memset(rgbZeroMAC, 0, sizeof(rgbZeroMAC));

    if (!GetResourcePtr(hInst, MAC_RESOURCE_NAME, &pbRsrcMAC, &cbRsrcMAC))
    {
        printf("Couldn't find MAC placeholder\n");
        goto Ret;
    }

    pbPostCRC = pbStart + dwCRCOffset + sizeof(DWORD);
    cbCRCToMAC = (DWORD)(pbRsrcMAC - pbPostCRC);
    pbPostMAC = pbRsrcMAC + (DES_BLOCKLEN + sizeof(DWORD) * 2);
    cbPostMAC = (cbImage - (DWORD)(pbPostMAC - pbStart));

    // copy the resource MAC
    if (DES_BLOCKLEN != (cbRsrcMAC - (sizeof(DWORD) * 2)))
    {
        goto Ret;
    }

    // init the key table
    deskey(&DESKeyTable, rgbDESKey);

    // MAC up to the CRC
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), dwCRCOffset, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend CRC is zeroed
    MACBytes(&DESKeyTable, (BYTE*)&dwZeroCRC, sizeof(DWORD), rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), sizeof(DWORD), NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC from CRC to MAC resource
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbCRCToMAC, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend image has zeroed MAC
    MACBytes(&DESKeyTable, (BYTE*)rgbZeroMAC, cbRsrcMAC, rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), cbRsrcMAC, NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC after the resource
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbPostMAC, &DESKeyTable, rgbTmp, &cbTmp,
                        rgbMAC, TRUE))
    {
        goto Ret;
    }

    memcpy(pbMAC, rgbMAC, DES_BLOCKLEN);

    fRet = TRUE;
Ret:
    if (pbRsrcMAC)
        FreeResource(pbRsrcMAC);
    if(hInst)
        UnmapViewOfFile(hInst);
    if(hMapping)
        CloseHandle(hMapping);
    if (HFILE_ERROR != hFile)
        _lclose(hFile);

    return fRet;
}

BOOL MACTheFileWithSig(
                       LPCSTR pszImage,
                       DWORD cbImage,
                       IN DWORD dwMACVersion,
                       IN DWORD dwCRCOffset,
                       OUT BYTE *pbMAC
                       )
{
    HMODULE                     hInst = 0;
    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbRsrcMAC = NULL;
    DWORD                       cbRsrcMAC;
    BYTE                        *pbRsrcSig = NULL;
    DWORD                       cbRsrcSig;
    BYTE                        *pbStart;
    BYTE                        rgbMAC[DES_BLOCKLEN];
    BYTE                        rgbZeroMAC[DES_BLOCKLEN + sizeof(DWORD) * 2];
    BYTE                        rgbZeroSig[144];
    BYTE                        *pbPostCRC;   // pointer to just after CRC
    DWORD                       cbCRCToRsrc1; // number of bytes from CRC to first rsrc
    DWORD                       cbRsrc1ToRsrc2; // number of bytes from first rsrc to second
    DWORD                       cbPostRsrc;    // size - (already hashed + signature size)
    BYTE                        *pbRsrc1ToRsrc2;
    BYTE                        *pbPostRsrc;
    BYTE                        *pbZeroRsrc1;
    BYTE                        *pbZeroRsrc2;
    DWORD                       cbZeroRsrc1;
    DWORD                       cbZeroRsrc2;
    DWORD                       dwZeroCRC = 0;
    DWORD                       dwBytesRead = 0;
    OFSTRUCT                    ImageInfoBuf;
    HFILE                       hFile = HFILE_ERROR;
    HANDLE                      hMapping = NULL;
    DESTable                    DESKeyTable;
    BYTE                        rgbTmp[DES_BLOCKLEN];
    DWORD                       cbTmp = 0;
    BOOL                        fRet = FALSE;

    memset(&MemInfo, 0, sizeof(MemInfo));
    memset(rgbMAC, 0, sizeof(rgbMAC));
    memset(rgbTmp, 0, sizeof(rgbTmp));

    // Load the file
    if (HFILE_ERROR == (hFile = OpenFile(pszImage, &ImageInfoBuf,
                                         OF_READ)))
    {
        goto Ret;
    }

    hMapping = CreateFileMapping((HANDLE)IntToPtr(hFile),
                                  NULL,
                                  PAGE_READONLY,
                                  0,
                                  0,
                                  NULL);
    if(hMapping == NULL)
    {
        goto Ret;
    }

    hInst = MapViewOfFile(hMapping,
                          FILE_MAP_READ,
                          0,
                          0,
                          0);
    if(hInst == NULL)
    {
        goto Ret;
    }
    pbStart = (BYTE*)hInst;

    // Convert pointer to HMODULE, using the same scheme as
    // LoadLibrary (windows\base\client\module.c).
    *((ULONG_PTR*)&hInst) |= 0x00000001;

    // the MAC resource
    if (!GetResourcePtr(hInst, MAC_RESOURCE_NAME, &pbRsrcMAC, &cbRsrcMAC))
        goto Ret;

    // the MAC resource
    if (!GetResourcePtr(hInst, SIG_RESOURCE_NAME, &pbRsrcSig, &cbRsrcSig))
        goto Ret;

    if (cbRsrcMAC < (sizeof(DWORD) * 2))
        goto Ret;

    // create a zero byte MAC
    memset(rgbZeroMAC, 0, sizeof(rgbZeroMAC));

    // create a zero byte Sig
    memset(rgbZeroSig, 0, sizeof(rgbZeroSig));

    // set up the pointers
    pbPostCRC = pbStart + dwCRCOffset + sizeof(DWORD);
    if (pbRsrcSig > pbRsrcMAC)    // MAC is first Rsrc
    {
        cbCRCToRsrc1 = (DWORD)(pbRsrcMAC - pbPostCRC);
        pbRsrc1ToRsrc2 = pbRsrcMAC + cbRsrcMAC;
        cbRsrc1ToRsrc2 = (DWORD)(pbRsrcSig - pbRsrc1ToRsrc2);
        pbPostRsrc = pbRsrcSig + cbRsrcSig;
        cbPostRsrc = (cbImage - (DWORD)(pbPostRsrc - pbStart));

        // zero pointers
        pbZeroRsrc1 = rgbZeroMAC;
        cbZeroRsrc1 = cbRsrcMAC;
        pbZeroRsrc2 = rgbZeroSig;
        cbZeroRsrc2 = cbRsrcSig;
    }
    else                        // Sig is first Rsrc
    {
        cbCRCToRsrc1 = (DWORD)(pbRsrcSig - pbPostCRC);
        pbRsrc1ToRsrc2 = pbRsrcSig + cbRsrcSig;
        cbRsrc1ToRsrc2 = (DWORD)(pbRsrcMAC - pbRsrc1ToRsrc2);
        pbPostRsrc = pbRsrcMAC + cbRsrcMAC;
        cbPostRsrc = (cbImage - (DWORD)(pbPostRsrc - pbStart));

        // zero pointers
        pbZeroRsrc1 = rgbZeroSig;
        cbZeroRsrc1 = cbRsrcSig;
        pbZeroRsrc2 = rgbZeroMAC;
        cbZeroRsrc2 = cbRsrcMAC;
    }

    // init the key table
    deskey(&DESKeyTable, rgbDESKey);

    // MAC up to the CRC
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), dwCRCOffset, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend CRC is zeroed
    MACBytes(&DESKeyTable, (BYTE*)&dwZeroCRC, sizeof(DWORD), rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), sizeof(DWORD), NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC from CRC to first resource
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbCRCToRsrc1, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend image has zeroed first resource
    MACBytes(&DESKeyTable, (BYTE*)pbZeroRsrc1, cbZeroRsrc1, rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), cbZeroRsrc1, NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC from first resource to second
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbRsrc1ToRsrc2, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend image has zeroed second Resource
    MACBytes(&DESKeyTable, (BYTE*)pbZeroRsrc2, cbZeroRsrc2, rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), cbZeroRsrc2, NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC after the resource
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbPostRsrc, &DESKeyTable, rgbTmp, &cbTmp,
                        rgbMAC, TRUE))
    {
        goto Ret;
    }

    memcpy(pbMAC, rgbMAC, DES_BLOCKLEN);

    fRet = TRUE;
Ret:
    if (pbRsrcMAC)
        FreeResource(pbRsrcMAC);
    if (pbRsrcSig)
        FreeResource(pbRsrcSig);
    if(hInst)
        UnmapViewOfFile(hInst);
    if(hMapping)
        CloseHandle(hMapping);
    if (HFILE_ERROR != hFile)
        _lclose(hFile);

    return fRet;
}

DWORD GetCRCOffset(
                   LPCSTR szFile,
                   DWORD cbImage,
                   DWORD *pdwCRCOffset
                   )
{
    DWORD               dwErr = 0x1;

    HANDLE              hFileProv = NULL;
    PBYTE               pbFilePtr = NULL;
    DWORD               OldCheckSum;
    DWORD               NewCheckSum;
    PIMAGE_NT_HEADERS   pImageNTHdrs;

    HANDLE              hFileMap = NULL;


    if (INVALID_HANDLE_VALUE == (hFileProv = CreateFile(szFile,
                                GENERIC_READ | GENERIC_WRITE,
                                0,  // don't share
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                0)))
    {
        printf("Couldn't CreateFile: 0x%x\n", GetLastError());
        goto Ret;
    }

    if (NULL == (hFileMap = CreateFileMapping(
                                hFileProv,
                                NULL,
                                PAGE_READWRITE,
                                0,
                                0,
                                NULL)))
    {
        printf("Couldn't map file\n");
        goto Ret;
    }

    if (NULL == (pbFilePtr = (PBYTE)MapViewOfFile(
                                hFileMap,
                                FILE_MAP_ALL_ACCESS,
                                0,
                                0,
                                0)))
    {
        printf("Couldn't create view\n");
        goto Ret;
    }

    // compute a new checksum
    if (NULL == (pImageNTHdrs = CheckSumMappedFile(pbFilePtr, cbImage,
                                                   &OldCheckSum, &NewCheckSum)))
        goto Ret;

    *pdwCRCOffset = (DWORD)((BYTE*)&pImageNTHdrs->OptionalHeader.CheckSum - pbFilePtr);
    dwErr = ERROR_SUCCESS;
Ret:
    if (pbFilePtr)
        UnmapViewOfFile(pbFilePtr);

    if (hFileMap)
        CloseHandle(hFileMap);

    if (hFileProv)
        CloseHandle(hFileProv);

    return dwErr;
}

// SetCryptMACResource
//
// slams MAC resource in file with the new MAC
//
DWORD SetCryptMACResource(
                          IN LPCSTR szFile,
                          IN DWORD dwMACVersion,
                          IN DWORD dwCRCOffset,
                          IN PBYTE pbNewMAC,
                          IN DWORD cbImage
                          )
{
    DWORD   dwErr = 0x1;

    HANDLE  hFileProv = NULL;
    HMODULE hInst = NULL;

    PBYTE   pbFilePtr = NULL;
    DWORD   cbMACOffset;

    PBYTE   pbMAC;
    DWORD   cbMAC;

    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbStart;

    DWORD               OldCheckSum;
    DWORD               NewCheckSum;
    PIMAGE_NT_HEADERS   pImageNTHdrs;

    HANDLE  hFileMap = NULL;

    memset(&MemInfo, 0, sizeof(MemInfo));

    // Load the file as a datafile
    if (NULL == (hInst = LoadLibraryEx(szFile, NULL, LOAD_LIBRARY_AS_DATAFILE)))
    {
        printf("Couldn't load file\n");
        goto Ret;
    }
    if (!GetResourcePtr(hInst, MAC_RESOURCE_NAME, &pbMAC, &cbMAC))
    {
        printf("Couldn't find MAC placeholder\n");
        goto Ret;
    }

    // get image start address
    VirtualQuery(hInst, &MemInfo, sizeof(MemInfo));
    pbStart = (BYTE*)MemInfo.BaseAddress;

    FreeLibrary(hInst); hInst = NULL;

    cbMACOffset = (DWORD)(pbMAC - pbStart);

    if (cbMAC != (DES_BLOCKLEN + sizeof(DWORD) * 2))
    {
        printf("Attempt to replace %d zeros with new MAC!\n", cbMAC);
        goto Ret;
    }

    if (INVALID_HANDLE_VALUE == (hFileProv = CreateFile(szFile,
                                GENERIC_READ | GENERIC_WRITE,
                                0,  // don't share
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                0)))
    {
        printf("Couldn't CreateFile: 0x%x\n", GetLastError());
        goto Ret;
    }

    if (NULL == (hFileMap = CreateFileMapping(
                                hFileProv,
                                NULL,
                                PAGE_READWRITE,
                                0,
                                0,
                                NULL)))
    {
        printf("Couldn't map file\n");
        goto Ret;
    }

    if (NULL == (pbFilePtr = (PBYTE)MapViewOfFile(
                                hFileMap,
                                FILE_MAP_ALL_ACCESS,
                                0,
                                0,
                                0)))
    {
        printf("Couldn't create view\n");
        goto Ret;
    }

    // copy version, CRC offset and new sig
    CopyMemory(pbFilePtr+cbMACOffset, &dwMACVersion, sizeof(dwMACVersion));
    cbMACOffset += sizeof(dwMACVersion);
    CopyMemory(pbFilePtr+cbMACOffset, &dwCRCOffset, sizeof(dwCRCOffset));
    cbMACOffset += sizeof(dwCRCOffset);
    CopyMemory(pbFilePtr+cbMACOffset, pbNewMAC, DES_BLOCKLEN);

    // compute a new checksum
    if (NULL == (pImageNTHdrs = CheckSumMappedFile(pbFilePtr, cbImage,
                                                   &OldCheckSum, &NewCheckSum)))
        goto Ret;

    CopyMemory(&pImageNTHdrs->OptionalHeader.CheckSum, &NewCheckSum, sizeof(DWORD));

    if (NULL == (pImageNTHdrs = CheckSumMappedFile(pbFilePtr, cbImage,
                                                   &OldCheckSum, &NewCheckSum)))
        goto Ret;

    if (OldCheckSum != NewCheckSum)
        goto Ret;

    dwErr = ERROR_SUCCESS;
Ret:
    if (pbFilePtr)
        UnmapViewOfFile(pbFilePtr);

    if (hFileMap)
        CloseHandle(hFileMap);

    if (hInst)
        FreeLibrary(hInst);

    if (hFileProv)
        CloseHandle(hFileProv);

    return dwErr;
}

void ShowHelp()
{
    printf("CryptoAPI Internal CSP MACing Utility\n");
    printf("maccsp <option> <filename>\n");
    printf("    options\n");
    printf("        m     MAC with no sig resource\n");
    printf("        s     MAC with sig resource\n");
    printf("        ?     Show this message\n");
}

void __cdecl main( int argc, char *argv[])
{
    LPCSTR  szInFile = NULL;
    DWORD   cbImage;
    DWORD   dwCRCOffset;
    HANDLE  hFileProv = 0;
    BYTE    rgbMAC[DES_BLOCKLEN];
    BOOL    fSigInFile = FALSE;
    DWORD   dwRet = 1;

    memset(rgbMAC, 0, sizeof(rgbMAC));

    //
    // Parse the command line.
    //

    if ((argc != 3) || (argv[1][0] == '?'))
    {
        ShowHelp();
        goto Ret;
    }
    else if ('s' == argv[1][0])
    {
        fSigInFile = TRUE;
    }
    else if ('m' == argv[1][0])
    {
        fSigInFile = FALSE;
    }
    else
    {
        ShowHelp();
        goto Ret;
    }


    szInFile = &argv[2][0];

    //
    // Command consistency checks.
    //

    if (NULL == szInFile)
    {
        printf("No input file specified.\n");
        goto Ret;
    }


    // get the file size
    if ((hFileProv = CreateFile(szInFile,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                0)) == INVALID_HANDLE_VALUE)
    {
        printf("CSP specified was not found!\n");
        goto Ret;
    }

    if (0xffffffff == (cbImage = GetFileSize(hFileProv, NULL)))
    {
        printf("CSP specified was not found!\n");
        goto Ret;
    }

    CloseHandle(hFileProv);
    hFileProv = NULL;

    if (0 != GetCRCOffset(szInFile, cbImage, &dwCRCOffset))
    {
        printf("Unable to get CRC!\n");
        goto Ret;
    }

    // calculate the MAC
    if (fSigInFile)
    {
        if (!MACTheFileWithSig(szInFile, cbImage, dwMACInFileVersion,
                               dwCRCOffset, rgbMAC))
        {
            printf("MAC failed!\n");
            goto Ret;
        }
    }
    else
    {
        if (!MACTheFileNoSig(szInFile, cbImage, dwMACInFileVersion,
                             dwCRCOffset, rgbMAC))
        {
            printf("MAC failed!\n");
            goto Ret;
        }
    }

    //
    // Place the MAC into the resource in the file
    //

    if (ERROR_SUCCESS != SetCryptMACResource(szInFile, dwMACInFileVersion,
                                             dwCRCOffset, rgbMAC, cbImage))
    {
        printf("Unable to set the MAC into the file resource!\n");
        goto Ret;
    }

    //
    // Clean up and return.
    //

    dwRet = 0;


Ret:
    exit(dwRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\programs\showsig\showsig.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : showsig.cpp                                             //
//  DESCRIPTION   : Crypto API interface                                   //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      May 4 1998 jeffspel                                                //
//                                                                         //
//  Copyright (C) 1998 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>
#include <rsa.h>
#include <md5.h>
#include <rc4.h>
#include <des.h>
#include <modes.h>

#define MS_INTERNAL_KEY

#define RC4_KEYSIZE 5

#define KEYSIZE512 0x48
#define KEYSIZE1024 0x88
#define SIG_RESOURCE_NUM    1

// designatred resource for in file signatures
#define CRYPT_SIG_RESOURCE_NUMBER   "#666"

// MAC in file
#define MAC_RESOURCE_NUMBER   "#667"

typedef struct _SECONDTIER_SIG
{
    DWORD           dwMagic;
    DWORD           cbSig;
    BSAFE_PUB_KEY   Pub;
} SECOND_TIER_SIG, *PSECOND_TIER_SIG;

BOOL g_fUseTestKey = TRUE;

#ifdef TEST_BUILD_EXPONENT
#pragma message("WARNING: building showsig.exe with TESTKEY enabled!")
static struct _TESTKEY
{
    BSAFE_PUB_KEY PUB;
    unsigned char pubmodulus[KEYSIZE512];
} TESTKEY = {
    {
        0x66b8443b,
        0x6f5fc900,
        0xa12132fe,
        0xff1b06cf,
        0x2f4826eb,
    },
    {
        0x3e, 0x69, 0x4f, 0x45, 0x31, 0x95, 0x60, 0x6c,
        0x80, 0xa5, 0x41, 0x99, 0x3e, 0xfc, 0x92, 0x2c,
        0x93, 0xf9, 0x86, 0x23, 0x3d, 0x48, 0x35, 0x81,
        0x19, 0xb6, 0x7c, 0x04, 0x43, 0xe6, 0x3e, 0xd4,
        0xd5, 0x43, 0xaf, 0x52, 0xdd, 0x51, 0x20, 0xac,
        0xc3, 0xca, 0xee, 0x21, 0x9b, 0x4a, 0x2d, 0xf7,
        0xd8, 0x5f, 0x32, 0xeb, 0x49, 0x72, 0xb9, 0x8d,
        0x2e, 0x1a, 0x76, 0x7f, 0xde, 0xc6, 0x75, 0xab,
        0xaf, 0x67, 0xe0, 0xf0, 0x8b, 0x30, 0x20, 0x92,
    }
};
#endif

static struct _mskey
{
    BSAFE_PUB_KEY PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} MSKEY = {
    {
        0x2bad85ae,
        0x883adacc,
        0xb32ebd68,
        0xa7ec8b06,
        0x58dbeb81,
    },
    {
        0x42, 0x34, 0xb7, 0xab, 0x45, 0x0f, 0x60, 0xcd,
        0x8f, 0x77, 0xb5, 0xd1, 0x79, 0x18, 0x34, 0xbe,
        0x66, 0xcb, 0x5c, 0x66, 0x4a, 0x9f, 0x03, 0x18,
        0x13, 0x36, 0x8e, 0x88, 0x21, 0x78, 0xb1, 0x94,
        0xa1, 0xd5, 0x8f, 0x8c, 0xa5, 0xd3, 0x9f, 0x86,
        0x43, 0x89, 0x05, 0xa0, 0xe3, 0xee, 0xe2, 0xd0,
        0xe5, 0x1d, 0x5f, 0xaf, 0xff, 0x85, 0x71, 0x7a,
        0x0a, 0xdb, 0x2e, 0xd8, 0xc3, 0x5f, 0x2f, 0xb1,
        0xf0, 0x53, 0x98, 0x3b, 0x44, 0xee, 0x7f, 0xc9,
        0x54, 0x26, 0xdb, 0xdd, 0xfe, 0x1f, 0xd0, 0xda,
        0x96, 0x89, 0xc8, 0x9e, 0x2b, 0x5d, 0x96, 0xd1,
        0xf7, 0x52, 0x14, 0x04, 0xfb, 0xf8, 0xee, 0x4d,
        0x92, 0xd1, 0xb6, 0x37, 0x6a, 0xe0, 0xaf, 0xde,
        0xc7, 0x41, 0x06, 0x7a, 0xe5, 0x6e, 0xb1, 0x8c,
        0x8f, 0x17, 0xf0, 0x63, 0x8d, 0xaf, 0x63, 0xfd,
        0x22, 0xc5, 0xad, 0x1a, 0xb1, 0xe4, 0x7a, 0x6b,
        0x1e, 0x0e, 0xea, 0x60, 0x56, 0xbd, 0x49, 0xd0,
    }
};

static struct _key
{
    BSAFE_PUB_KEY PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} KEY = {
    {
        0x3fcbf1a9,
        0x08f597db,
        0xe4aecab4,
        0x75360f90,
        0x9d6c0f00,
    },
    {
        0x85, 0xdd, 0x9b, 0xf4, 0x4d, 0x0b, 0xc4, 0x96,
        0x3e, 0x79, 0x86, 0x30, 0x6d, 0x27, 0x31, 0xee,
        0x4a, 0x85, 0xf5, 0xff, 0xbb, 0xa9, 0xbd, 0x81,
        0x86, 0xf2, 0x4f, 0x87, 0x6c, 0x57, 0x55, 0x19,
        0xe4, 0xf4, 0x49, 0xa3, 0x19, 0x27, 0x08, 0x82,
        0x9e, 0xf9, 0x8a, 0x8e, 0x41, 0xd6, 0x91, 0x71,
        0x47, 0x48, 0xee, 0xd6, 0x24, 0x2d, 0xdd, 0x22,
        0x72, 0x08, 0xc6, 0xa7, 0x34, 0x6f, 0x93, 0xd2,
        0xe7, 0x72, 0x57, 0x78, 0x7a, 0x96, 0xc1, 0xe1,
        0x47, 0x38, 0x78, 0x43, 0x53, 0xea, 0xf3, 0x88,
        0x82, 0x66, 0x41, 0x43, 0xd4, 0x62, 0x44, 0x01,
        0x7d, 0xb2, 0x16, 0xb3, 0x50, 0x89, 0xdb, 0x0a,
        0x93, 0x17, 0x02, 0x02, 0x46, 0x49, 0x79, 0x76,
        0x59, 0xb6, 0xb1, 0x2b, 0xfc, 0xb0, 0x9a, 0x21,
        0xe6, 0xfa, 0x2d, 0x56, 0x07, 0x36, 0xbc, 0x13,
        0x7f, 0x1c, 0xde, 0x55, 0xfb, 0x0d, 0x67, 0x0f,
        0xc2, 0x17, 0x45, 0x8a, 0x14, 0x2b, 0xba, 0x55,
    }
};


static struct _key2
{
    BSAFE_PUB_KEY PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} KEY2 =  {
    {
        0x685fc690,
        0x97d49b6b,
        0x1dccd9d2,
        0xa5ec9b52,
        0x64fd29d7,
    },
    {
        0x03, 0x8c, 0xa3, 0x9e, 0xfb, 0x93, 0xb6, 0x72,
        0x2a, 0xda, 0x6f, 0xa5, 0xec, 0x26, 0x39, 0x58,
        0x41, 0xcd, 0x3f, 0x49, 0x10, 0x4c, 0xcc, 0x7e,
        0x23, 0x94, 0xf9, 0x5d, 0x9b, 0x2b, 0xa3, 0x6b,
        0xe8, 0xec, 0x52, 0xd9, 0x56, 0x64, 0x74, 0x7c,
        0x44, 0x6f, 0x36, 0xb7, 0x14, 0x9d, 0x02, 0x3c,
        0x0e, 0x32, 0xb6, 0x38, 0x20, 0x25, 0xbd, 0x8c,
        0x9b, 0xd1, 0x46, 0xa7, 0xb3, 0x58, 0x4a, 0xb7,
        0xdd, 0x0e, 0x38, 0xb6, 0x16, 0x44, 0xbf, 0xc1,
        0xca, 0x4d, 0x6a, 0x9f, 0xcb, 0x6f, 0x3c, 0x5f,
        0x03, 0xab, 0x7a, 0xb8, 0x16, 0x70, 0xcf, 0x98,
        0xd0, 0xca, 0x8d, 0x25, 0x57, 0x3a, 0x22, 0x8b,
        0x44, 0x96, 0x37, 0x51, 0x30, 0x00, 0x92, 0x1b,
        0x03, 0xb9, 0xf9, 0x0d, 0xb3, 0x1a, 0xe2, 0xb4,
        0xc5, 0x7b, 0xc9, 0x4b, 0xe2, 0x42, 0x25, 0xfe,
        0x3d, 0x42, 0xfa, 0x45, 0xc6, 0x94, 0xc9, 0x8e,
        0x87, 0x7e, 0xf6, 0x68, 0x90, 0x30, 0x65, 0x10,
    }
};

void
EncryptKey(
    BYTE *pdata,
    DWORD size,
    BYTE val)
{
    RC4_KEYSTRUCT key;
    BYTE          RealKey[RC4_KEYSIZE] = {0xa2, 0x17, 0x9c, 0x98, 0xca};
    DWORD         index;

    for (index = 0; index < RC4_KEYSIZE; index++)
    {
        RealKey[index] = RealKey[index] ^ val;
    }

    rc4_key(&key, RC4_KEYSIZE, RealKey);

    rc4(&key, size, pdata);
}

void
MD5HashData(
    BYTE *pb,
    DWORD cb,
    BYTE *pbHash)
{
    MD5_CTX HashState;

    MD5Init(&HashState);

    MD5Update(&HashState, pb, cb);

    // Finish the hash
    MD5Final(&HashState);

    memcpy(pbHash, HashState.digest, 16);
}


BOOL
CheckSignature(
    BYTE *pbKey,
    DWORD cbKey,
    BYTE *pbSig,
    DWORD cbSig,
    BYTE *pbHash,
    BOOL fUnknownLen)
{
    BYTE                rgbResult[KEYSIZE1024];
    BYTE                rgbSig[KEYSIZE1024];
    BYTE                rgbKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
    BYTE                rgbKeyHash[16];
    BYTE                *pbSecondKey;
    DWORD               cbSecondKey;
    BYTE                *pbKeySig;
    PSECOND_TIER_SIG    pSecondTierSig;
    LPBSAFE_PUB_KEY     pTmp;
    BOOL                fRet = FALSE;

    memset(rgbResult, 0, KEYSIZE1024);
    memset(rgbSig, 0, KEYSIZE1024);

    // just check the straight signature if version is 1
    pTmp = (LPBSAFE_PUB_KEY)pbKey;

    // check if sig length is the same as the key length
    if (fUnknownLen || (cbSig == pTmp->keylen))
    {
        memcpy(rgbSig, pbSig, pTmp->keylen);
        BSafeEncPublic(pTmp, rgbSig, rgbResult);

        if (RtlEqualMemory(pbHash, rgbResult, 16) &&
            rgbResult[cbKey-1] == 0 &&
            rgbResult[cbKey-2] == 1 &&
            rgbResult[16] == 0 &&
            rgbResult[17] == 0xFF)
        {
            fRet = TRUE;
            goto Ret;
        }
    }

    // check the the second tier signature if the magic equals 2
    pSecondTierSig = (PSECOND_TIER_SIG)pbSig;
    if (0x00000002 != pSecondTierSig->dwMagic)
        goto Ret;

    if (0x31415352 != pSecondTierSig->Pub.magic)
        goto Ret;

    // assign the pointers
    cbSecondKey = sizeof(BSAFE_PUB_KEY) + pSecondTierSig->Pub.keylen;
    pbSecondKey = pbSig + (sizeof(SECOND_TIER_SIG) - sizeof(BSAFE_PUB_KEY));
    pbKeySig = pbSecondKey + cbSecondKey;

    // hash the second tier key
    MD5HashData(pbSecondKey, cbSecondKey, rgbKeyHash);

    // Decrypt the signature data on the second tier key
    memset(rgbResult, 0, sizeof(rgbResult));
    memset(rgbSig, 0, sizeof(rgbSig));
    memcpy(rgbSig, pbKeySig, pSecondTierSig->cbSig);
    BSafeEncPublic(pTmp, rgbSig, rgbResult);

    if ((FALSE == RtlEqualMemory(rgbKeyHash, rgbResult, 16)) ||
        rgbResult[cbKey-1] != 0 ||
        rgbResult[cbKey-2] != 1 ||
        rgbResult[16] != 0 ||
        rgbResult[17] != 0)
    {
        goto Ret;
    }

    // Decrypt the signature data on the CSP
    memset(rgbResult, 0, sizeof(rgbResult));
    memset(rgbSig, 0, sizeof(rgbSig));
    memset(rgbKey, 0, sizeof(rgbKey));
    memcpy(rgbSig, pbKeySig + pSecondTierSig->cbSig, pSecondTierSig->cbSig);
    memcpy(rgbKey, pbSecondKey, cbSecondKey);
    pTmp = (LPBSAFE_PUB_KEY)rgbKey;
    BSafeEncPublic(pTmp, rgbSig, rgbResult);

    if (RtlEqualMemory(pbHash, rgbResult, 16) &&
        rgbResult[cbKey-1] == 0 &&
        rgbResult[cbKey-2] == 1 &&
        rgbResult[16] == 0)
    {
        fRet = TRUE;
        if (0xff != rgbResult[18])
        {
            DWORD dwI;

            printf("2nd Tier signature performed by ");
            for (dwI = 18; 0xff != rgbResult[dwI]; dwI += 1)
                printf("%c", rgbResult[dwI]);
            printf(".\n");
        }
    }

Ret:
    return fRet;
}

// Given hInst, allocs and returns pointers to SIG and MAC pulled from
// resource
BOOL
GetResourcePtr(
    IN HMODULE hInst,
    IN LPSTR pszRsrcName,
    OUT BYTE **ppbRsrcMAC,
    OUT DWORD *pcbRsrcMAC)
{
    HRSRC   hRsrc;
    BOOL    fRet = FALSE;

    // Nab resource handle for our signature
    if (NULL == (hRsrc = FindResourceA(hInst, pszRsrcName,
                                       RT_RCDATA)))
        goto Ret;

    // get a pointer to the actual signature data
    if (NULL == (*ppbRsrcMAC = (PBYTE)LoadResource(hInst, hRsrc)))
        goto Ret;

    // determine the size of the resource
    if (0 == (*pcbRsrcMAC = SizeofResource(hInst, hRsrc)))
        goto Ret;

    fRet = TRUE;

Ret:
    return fRet;
}


// GetCryptSignatureResource
//
DWORD
GetCryptSignatureResource(
    LPCSTR szFile,
    PBYTE *ppbNewSig,
    DWORD *pcbNewSig)
{
    DWORD   dwErr = 0x1;
    BYTE    *pbSig;

    HMODULE hInst = NULL;

    // Load the file as a datafile
    if (NULL == (hInst = LoadLibraryEx(szFile, NULL, LOAD_LIBRARY_AS_DATAFILE)))
    {
        printf("Couldn't load file\n");
        goto Ret;
    }
    if (!GetResourcePtr(hInst,
                        CRYPT_SIG_RESOURCE_NUMBER,
                        &pbSig,
                        pcbNewSig))
    {
        printf("Couldn't find signature placeholder\n");
        goto Ret;
    }

    if (NULL == (*ppbNewSig = (BYTE*)LocalAlloc(LMEM_ZEROINIT, *pcbNewSig)))
        goto Ret;

    memcpy(*ppbNewSig, pbSig, *pcbNewSig);

    dwErr = ERROR_SUCCESS;

Ret:
    if (hInst)
        FreeLibrary(hInst);
    return dwErr;
}

#define CSP_TO_BE_MACED_CHUNK  4096

// The function MACs the given bytes.
void
MACBytes(
    IN DESTable *pDESKeyTable,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN OUT BYTE *pbTmp,
    IN OUT DWORD *pcbTmp,
    IN OUT BYTE *pbMAC,
    IN BOOL fFinal)
{
    DWORD   cb = cbData;
    DWORD   cbMACed = 0;

    while (cb)
    {
        if ((cb + *pcbTmp) < DES_BLOCKLEN)
        {
            memcpy(pbTmp + *pcbTmp, pbData + cbMACed, cb);
            *pcbTmp += cb;
            break;
        }
        else
        {
            memcpy(pbTmp + *pcbTmp, pbData + cbMACed, DES_BLOCKLEN - *pcbTmp);
            CBC(des, DES_BLOCKLEN, pbMAC, pbTmp, pDESKeyTable,
                ENCRYPT, pbMAC);
            cbMACed = cbMACed + (DES_BLOCKLEN - *pcbTmp);
            cb = cb - (DES_BLOCKLEN - *pcbTmp);
            *pcbTmp = 0;
        }
    }
}

// Given hFile, reads the specified number of bytes (cbToBeMACed) from the file
// and MACs these bytes.  The function does this in chunks.
BOOL
MACBytesOfFile(
    IN HANDLE hFile,
    IN DWORD cbToBeMACed,
    IN DESTable *pDESKeyTable,
    IN BYTE *pbTmp,
    IN DWORD *pcbTmp,
    IN BYTE *pbMAC,
    IN BYTE fFinal)
{
    BYTE    rgbChunk[CSP_TO_BE_MACED_CHUNK];
    DWORD   cbRemaining = cbToBeMACed;
    DWORD   cbToRead;
    DWORD   dwBytesRead;
    BOOL    fRet = FALSE;

    //
    // loop over the file for the specified number of bytes
    // updating the hash as we go.
    //

    while (cbRemaining > 0)
    {
        if (cbRemaining < CSP_TO_BE_MACED_CHUNK)
            cbToRead = cbRemaining;
        else
            cbToRead = CSP_TO_BE_MACED_CHUNK;

        if (!ReadFile(hFile, rgbChunk, cbToRead, &dwBytesRead, NULL))
            goto Ret;
        if (dwBytesRead != cbToRead)
            goto Ret;

        MACBytes(pDESKeyTable, rgbChunk, dwBytesRead, pbTmp, pcbTmp,
                 pbMAC, fFinal);
        cbRemaining -= cbToRead;
    }

    fRet = TRUE;

Ret:
    return fRet;
}

BYTE rgbMACDESKey[] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef};

BOOL
MACTheFile(
    LPCSTR pszImage,
    DWORD cbImage)
{
    HMODULE                     hInst = 0;
    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbRsrcMAC;
    DWORD                       cbRsrcMAC;
    BYTE                        *pbRsrcSig;
    DWORD                       cbRsrcSig;
    BYTE                        *pbStart;
    BYTE                        rgbMAC[DES_BLOCKLEN];
    BYTE                        *pbZeroRsrc = NULL;
    BYTE                        *pbPostCRC;   // pointer to just after CRC
    DWORD                       cbCRCToRsrc1; // number of bytes from CRC to first rsrc
    DWORD                       cbRsrc1ToRsrc2; // number of bytes from first rsrc to second
    DWORD                       cbPostRsrc;    // size - (already hashed + signature size)
    BYTE                        *pbRsrc1ToRsrc2;
    BYTE                        *pbPostRsrc;
    BYTE                        *pbZeroRsrc1;
    BYTE                        *pbZeroRsrc2;
    DWORD                       cbZeroRsrc1;
    DWORD                       cbZeroRsrc2;
    DWORD                       *pdwMACInFileVer;
    DWORD                       *pdwCRCOffset;
    DWORD                       dwCRCOffset;
    DWORD                       dwZeroCRC = 0;
    DWORD                       dwBytesRead = 0;
    OFSTRUCT                    ImageInfoBuf;
    HFILE                       hFile = HFILE_ERROR;
    HANDLE                      hMapping = NULL;
    DESTable                    DESKeyTable;
    BYTE                        rgbTmp[DES_BLOCKLEN];
    DWORD                       cbTmp = 0;
    BOOL                        fRet = FALSE;
    DWORD                       i;

    memset(&MemInfo, 0, sizeof(MemInfo));
    memset(rgbMAC, 0, sizeof(rgbMAC));
    memset(rgbTmp, 0, sizeof(rgbTmp));

    // Load the file
    if (HFILE_ERROR == (hFile = OpenFile(pszImage, &ImageInfoBuf,
                                         OF_READ)))
    {
        goto Ret;
    }

    hMapping = CreateFileMapping((HANDLE)IntToPtr(hFile),
                                 NULL,
                                 PAGE_READONLY,
                                 0,
                                 0,
                                 NULL);
    if (hMapping == NULL)
    {
        goto Ret;
    }

    hInst = (HMODULE)MapViewOfFile(hMapping,
                                   FILE_MAP_READ,
                                   0,
                                   0,
                                   0);
    if (hInst == NULL)
    {
        goto Ret;
    }
    pbStart = (BYTE*)hInst;

    // Convert pointer to HMODULE, using the same scheme as
    // LoadLibrary (windows\base\client\module.c).
    *((ULONG_PTR*)&hInst) |= 0x00000001;

    // the MAC resource
    if (!GetResourcePtr(hInst, MAC_RESOURCE_NUMBER, &pbRsrcMAC, &cbRsrcMAC))
        goto Ret;

    // display the MAC
    printf("--- MAC Resource ---\n");
    for (i = 0; i < cbRsrcMAC; i++)
    {
        printf("0x%02X ", pbRsrcMAC[i]);
        if (((i + 1) % 8) == 0)
            printf("\n");
    }
    if (0 != (i % 8))
        printf("\n");


    // the Signature resource
    if (!GetResourcePtr(hInst, CRYPT_SIG_RESOURCE_NUMBER, &pbRsrcSig, &cbRsrcSig))
    {
        pbRsrcSig = NULL;
        cbRsrcSig = 0;
    }

    if (cbRsrcMAC < (sizeof(DWORD) * 2))
        goto Ret;

    // check the MAC in file version and get the CRC offset
    pdwMACInFileVer = (DWORD*)pbRsrcMAC;
    pdwCRCOffset = (DWORD*)(pbRsrcMAC + sizeof(DWORD));
    dwCRCOffset = *pdwCRCOffset;
    if ((0x00000100 != *pdwMACInFileVer) || (dwCRCOffset > cbImage))
        goto Ret;
    if (DES_BLOCKLEN != (cbRsrcMAC - (sizeof(DWORD) * 2)))
    {
        goto Ret;
    }

    // create a zero byte Sig
    pbZeroRsrc = (LPBYTE)LocalAlloc(LPTR, max(cbRsrcMAC, cbRsrcSig));

    // set up the pointers
    pbPostCRC = pbStart + *pdwCRCOffset + sizeof(DWORD);
    if (NULL == pbRsrcSig)  // No sig resource
    {
        cbCRCToRsrc1 = (DWORD)(pbRsrcMAC - pbPostCRC);
        pbRsrc1ToRsrc2 = pbRsrcMAC + cbRsrcMAC;
        cbRsrc1ToRsrc2 = 0;
        pbPostRsrc = pbRsrcMAC + cbRsrcMAC;
        cbPostRsrc = (cbImage - (DWORD)(pbPostRsrc - pbStart));

        // zero pointers
        pbZeroRsrc1 = pbZeroRsrc;
        cbZeroRsrc1 = cbRsrcMAC;
        pbZeroRsrc2 = pbZeroRsrc;
        cbZeroRsrc2 = 0;
    }
    else if (pbRsrcSig > pbRsrcMAC)    // MAC is first Rsrc
    {
        cbCRCToRsrc1 = (DWORD)(pbRsrcMAC - pbPostCRC);
        pbRsrc1ToRsrc2 = pbRsrcMAC + cbRsrcMAC;
        cbRsrc1ToRsrc2 = (DWORD)(pbRsrcSig - pbRsrc1ToRsrc2);
        pbPostRsrc = pbRsrcSig + cbRsrcSig;
        cbPostRsrc = (cbImage - (DWORD)(pbPostRsrc - pbStart));

        // zero pointers
        pbZeroRsrc1 = pbZeroRsrc;
        cbZeroRsrc1 = cbRsrcMAC;
        pbZeroRsrc2 = pbZeroRsrc;
        cbZeroRsrc2 = cbRsrcSig;
    }
    else                        // Sig is first Rsrc
    {
        cbCRCToRsrc1 = (DWORD)(pbRsrcSig - pbPostCRC);
        pbRsrc1ToRsrc2 = pbRsrcSig + cbRsrcSig;
        cbRsrc1ToRsrc2 = (DWORD)(pbRsrcMAC - pbRsrc1ToRsrc2);
        pbPostRsrc = pbRsrcMAC + cbRsrcMAC;
        cbPostRsrc = (cbImage - (DWORD)(pbPostRsrc - pbStart));

        // zero pointers
        pbZeroRsrc1 = pbZeroRsrc;
        cbZeroRsrc1 = cbRsrcSig;
        pbZeroRsrc2 = pbZeroRsrc;
        cbZeroRsrc2 = cbRsrcMAC;
    }

    // init the key table
    deskey(&DESKeyTable, rgbMACDESKey);

    // MAC up to the CRC
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), dwCRCOffset, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend CRC is zeroed
    MACBytes(&DESKeyTable, (BYTE*)&dwZeroCRC, sizeof(DWORD), rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), sizeof(DWORD), NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC from CRC to first resource
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbCRCToRsrc1, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend image has zeroed first resource
    MACBytes(&DESKeyTable, (BYTE*)pbZeroRsrc1, cbZeroRsrc1, rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), cbZeroRsrc1, NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC from first resource to second
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbRsrc1ToRsrc2, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend image has zeroed second Resource
    MACBytes(&DESKeyTable, (BYTE*)pbZeroRsrc2, cbZeroRsrc2, rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), cbZeroRsrc2, NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC after the resource
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbPostRsrc, &DESKeyTable, rgbTmp, &cbTmp,
                        rgbMAC, TRUE))
    {
        goto Ret;
    }

    if (0 != memcmp(rgbMAC, pbRsrcMAC + sizeof(DWORD) * 2, DES_BLOCKLEN))
        goto Ret;

    fRet = TRUE;

Ret:
    if (hInst)
        UnmapViewOfFile(hInst);
    if (hMapping)
        CloseHandle(hMapping);
    if (HFILE_ERROR != hFile)
        _lclose(hFile);
    if (NULL != pbZeroRsrc)
        LocalFree(pbZeroRsrc);
    return fRet;
}

// **********************************************************************
// SelfMACCheck performs a DES MAC on the binary image of this DLL
// **********************************************************************
BOOL
SelfMACCheck(
    IN LPCSTR pszImage)
{
    HFILE       hFileProv = HFILE_ERROR;
    DWORD       cbImage;
    OFSTRUCT    ImageInfoBuf;
    HMODULE     hInst = NULL;
    PBYTE       pbMAC;
    DWORD       cbMAC;
    BOOL        fRet = FALSE;

    // check if the MAC resource is in the CSP and exit if not
    // Load the file as a datafile
    if (NULL == (hInst = LoadLibraryEx(pszImage,
                                       NULL,
                                       LOAD_LIBRARY_AS_DATAFILE)))
    {
        fRet = TRUE;
        goto Ret;
    }
    if (!GetResourcePtr(hInst, MAC_RESOURCE_NUMBER, &pbMAC, &cbMAC))
    {
        fRet = TRUE;
        goto Ret;
    }
    FreeLibrary(hInst);
    hInst = NULL;

    // Check file size
    if (HFILE_ERROR == (hFileProv = OpenFile(pszImage, &ImageInfoBuf, OF_READ)))
    {
        printf("FAILURE - Unable to open the requested file\n");
        goto Ret;
    }

    if (0xffffffff == (cbImage = GetFileSize((HANDLE)IntToPtr(hFileProv), NULL)))
    {
        printf("FAILURE - Unable to open the requested file\n");
        goto Ret;
    }

    _lclose(hFileProv);
    hFileProv = HFILE_ERROR;

    if (!MACTheFile(pszImage, cbImage))
    {
        printf("FAILURE - The MAC resource does not verify!\n");
        goto Ret;
    }
    else
        printf("MAC Verifies.\n\n");

    fRet = TRUE;

Ret:
    if (hInst)
    {
        FreeLibrary(hInst);
    }

    if (HFILE_ERROR != hFileProv)
        _lclose(hFileProv);

    return fRet;
}

#define CSP_TO_BE_HASHED_CHUNK  4096

// Given hFile, reads the specified number of bytes (cbToBeHashed) from the file
// and hashes these bytes.  The function does this in chunks.
BOOL
HashBytesOfFile(
    IN HFILE hFile,
    IN DWORD cbToBeHashed,
    IN OUT MD5_CTX *pMD5Hash)
{
    BYTE    rgbChunk[CSP_TO_BE_HASHED_CHUNK];
    DWORD   cbRemaining = cbToBeHashed;
    DWORD   cbToRead;
    DWORD   dwBytesRead;
    BOOL    fRet = FALSE;

    //
    // loop over the file for the specified number of bytes
    // updating the hash as we go.
    //

    while (cbRemaining > 0)
    {
        if (cbRemaining < CSP_TO_BE_HASHED_CHUNK)
            cbToRead = cbRemaining;
        else
            cbToRead = CSP_TO_BE_HASHED_CHUNK;

        if (!ReadFile((HANDLE)IntToPtr(hFile), rgbChunk, cbToRead, &dwBytesRead, NULL))
            goto Ret;
        if (dwBytesRead != cbToRead)
            goto Ret;

        MD5Update(pMD5Hash, rgbChunk, dwBytesRead);
        cbRemaining -= cbToRead;
    }

    fRet = TRUE;

Ret:
    return fRet;
}

BOOL
HashTheFile(
    LPCSTR pszImage,
    DWORD cbImage,
    BYTE **ppbSig,
    DWORD *pcbSig,
    BYTE *pbHash)
{
    HMODULE                     hInst = 0;
    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbRsrcSig;
    DWORD                       cbRsrcSig;
    BYTE                        *pbStart;
    BYTE                        *pbZeroRsrc = NULL;
    MD5_CTX                     MD5Hash;
    BYTE                        *pbPostCRC;   // pointer to just after CRC
    DWORD                       cbCRCToSig;   // number of bytes from CRC to sig
    DWORD                       cbPostSig;    // size - (already hashed + signature size)
    BYTE                        *pbPostSig;
    DWORD                       *pdwSigInFileVer;
    DWORD                       *pdwCRCOffset;
    DWORD                       dwCRCOffset;
    DWORD                       dwZeroCRC = 0;
    DWORD                       dwBytesRead = 0;
    OFSTRUCT                    ImageInfoBuf;
    HFILE                       hFile = HFILE_ERROR;
    BOOL                        fRet = FALSE;

    memset(&MD5Hash, 0, sizeof(MD5Hash));
    memset(&MemInfo, 0, sizeof(MemInfo));

    // Load the file as a datafile
    if (NULL == (hInst = LoadLibraryEx(pszImage, NULL, LOAD_LIBRARY_AS_DATAFILE)))
        goto Ret;

    // get image start address
    VirtualQuery(hInst, &MemInfo, sizeof(MemInfo));
    pbStart = (BYTE*)MemInfo.BaseAddress;

    // the resources signature
    if ((NULL == ppbSig) || !GetResourcePtr(hInst, CRYPT_SIG_RESOURCE_NUMBER, &pbRsrcSig, &cbRsrcSig))
    {
        dwCRCOffset = 0;
        pbPostCRC = NULL;
        cbCRCToSig = 0;
        pbPostSig = NULL;
        cbPostSig = cbImage;
        cbRsrcSig = 0;
        if (NULL != pcbSig)
            *pcbSig = 0;
    }
    else
    {
        if (cbRsrcSig < (sizeof(DWORD) * 2))
            goto Ret;

        // check the sig in file version and get the CRC offset
        pdwSigInFileVer = (DWORD*)pbRsrcSig;
        pdwCRCOffset = (DWORD*)(pbRsrcSig + sizeof(DWORD));
        dwCRCOffset = *pdwCRCOffset;
        if ((0x00000100 != *pdwSigInFileVer) || (dwCRCOffset > cbImage))
            goto Ret;

        // create a zero byte signature
        if (NULL == (pbZeroRsrc = (BYTE*)LocalAlloc(LMEM_ZEROINIT, cbRsrcSig)))
            goto Ret;
        memcpy(pbZeroRsrc, pbRsrcSig, sizeof(DWORD) * 2);

        pbPostCRC = pbStart + *pdwCRCOffset + sizeof(DWORD);
        cbCRCToSig = (DWORD)(pbRsrcSig - pbPostCRC);
        pbPostSig = pbRsrcSig + cbRsrcSig;
        cbPostSig = (cbImage - (DWORD)(pbPostSig - pbStart));

        // allocate the real signature and copy the resource sig into the real sig
        *pcbSig = cbRsrcSig - (sizeof(DWORD) * 2);
        if (NULL == (*ppbSig = (BYTE*)LocalAlloc(LMEM_ZEROINIT, *pcbSig)))
            goto Ret;

        memcpy(*ppbSig, pbRsrcSig + (sizeof(DWORD) * 2), *pcbSig);
    }

    FreeLibrary(hInst);
    hInst = 0;

    // hash over the relevant data
    {
        if (HFILE_ERROR == (hFile = OpenFile(pszImage, &ImageInfoBuf, OF_READ)))
        {
            goto Ret;
        }

        MD5Init(&MD5Hash);

        if (0 != dwCRCOffset)
        {
            // hash up to the CRC
            if (!HashBytesOfFile(hFile, dwCRCOffset, &MD5Hash))
                goto Ret;

            // pretend CRC is zeroed
            MD5Update(&MD5Hash, (BYTE*)&dwZeroCRC, sizeof(DWORD));
            if (!ReadFile((HANDLE)IntToPtr(hFile), (BYTE*)&dwZeroCRC, sizeof(DWORD),
                          &dwBytesRead, NULL))
            {
                goto Ret;
            }
        }

        if (0 != cbRsrcSig)
        {
            // hash from CRC to sig resource
            if (!HashBytesOfFile(hFile, cbCRCToSig, &MD5Hash))
                goto Ret;

            // pretend image has zeroed sig
            MD5Update(&MD5Hash, pbZeroRsrc, cbRsrcSig);
            if (!ReadFile((HANDLE)IntToPtr(hFile), (BYTE*)pbZeroRsrc, cbRsrcSig,
                          &dwBytesRead, NULL))
            {
                goto Ret;
            }
        }

        // hash after the sig resource
        if (!HashBytesOfFile(hFile, cbPostSig, &MD5Hash))
            goto Ret;

        // Finish the hash
        MD5Final(&MD5Hash);

        memcpy(pbHash, MD5Hash.digest, MD5DIGESTLEN);
    }

    fRet = TRUE;

Ret:
    if (pbZeroRsrc)
        LocalFree(pbZeroRsrc);
    if (hInst)
        FreeLibrary(hInst);
    if (HFILE_ERROR != hFile)
        _lclose(hFile);
    return fRet;
}

/*
 -      CheckAllSignatures
 -
 *      Purpose:
 *                Check signature against all keys
 *
 *
 *      Returns:
 *                BOOL
 */
BOOL
CheckAllSignatures(
    BYTE *pbSig,
    DWORD cbSig,
    BYTE *pbHash,
    BOOL fUnknownLen)
{
    BYTE        rgbKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
    BYTE        rgbKey2[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
    BYTE        rgbMSKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
#ifdef TEST_BUILD_EXPONENT
    BYTE        rgbTestKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE512];
    HMODULE     hMod;
    HRSRC       hRes;
    HGLOBAL     pRes;
    DWORD       dwSize;
#endif
    BOOL        fRet = FALSE;

    // decrypt the keys once for each process
#ifdef TEST_BUILD_EXPONENT
    hMod = GetModuleHandle("advapi32.dll");
    if (hRes = FindResource(hMod, (LPCTSTR) IDR_PUBKEY1, RT_RCDATA))
    {
        if (pRes = LoadResource(hMod, hRes))
        {
            dwSize = SizeofResource(hMod, hRes);
            memcpy(&TESTKEY, (CHAR *) pRes, dwSize);
        }
    }
#endif
    memcpy(rgbKey, (BYTE*)&KEY, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024);
    EncryptKey(rgbKey, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024, 0);

    memcpy(rgbMSKey, (BYTE*)&MSKEY, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024);
    EncryptKey(rgbMSKey, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024, 1);

    memcpy(rgbKey2, (BYTE*)&KEY2, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024);
    EncryptKey(rgbKey2, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024, 2);

#ifdef TEST_BUILD_EXPONENT
    memcpy(rgbTestKey, (BYTE*)&TESTKEY, sizeof(BSAFE_PUB_KEY) + KEYSIZE512);
    EncryptKey(rgbTestKey, sizeof(BSAFE_PUB_KEY) + KEYSIZE512, 3);
#ifdef WIN95
    TESTKEY.PUB.pubexp = TEST_BUILD_EXPONENT;
#else
    TESTKEY.PUB.pubexp = USER_SHARED_DATA->CryptoExponent;
#endif // WIN95
#endif // TEST_BUILD_EXPONENT

    if (TRUE == (fRet = CheckSignature(rgbKey, 128, pbSig,
                                       cbSig, pbHash, fUnknownLen)))
    {
        printf("Checked against the retail CSP key\n" );
        fRet = TRUE;
        goto Ret;
    }

    if (g_fUseTestKey)
    {
        if (TRUE == (fRet = CheckSignature(rgbMSKey, 128, pbSig,
                                           cbSig, pbHash, fUnknownLen)))
        {
            printf("Checked against the Internal Only \"Enigma\" Key\n" );
            fRet = TRUE;
            goto Ret;
        }
    }

    if (TRUE == (fRet = CheckSignature(rgbKey2, 128, pbSig,
                                       cbSig, pbHash, fUnknownLen)))
    {
        printf("Checked against retail Key2\n" );
        fRet = TRUE;
        goto Ret;
    }

#ifdef TEST_BUILD_EXPONENT
    if (TRUE == (fRet = CheckSignature(rgbTestKey, 64, pbSig,
                                       cbSig, pbHash, fUnknownLen)))
    {
        printf("Checked against Test key\n" );
        fRet = TRUE;
        goto Ret;
    }
#endif // TEST_BUILD_EXPONENT

Ret:
    return fRet;
}

/*
 -      CheckSignatureInFile
 -
 *      Purpose:
 *                Check signature which is in the resource in the file
 *
 *
 *      Parameters:
 *                IN pszImage       - address of file
 *
 *      Returns:
 *                BOOL
 */
BOOL
CheckSignatureInFile(
    LPCSTR pszImage)
{
    HFILE       hFileProv = HFILE_ERROR;
    DWORD       cbImage;
    BYTE        *pbSig = NULL;
    DWORD       cbSig;
    BYTE        rgbHash[MD5DIGESTLEN];
    OFSTRUCT    ImageInfoBuf;
    BOOL        fRet = FALSE;

    // Check file size
    {
        if (HFILE_ERROR == (hFileProv = OpenFile(pszImage, &ImageInfoBuf, OF_READ)))
        {
            SetLastError((DWORD) NTE_PROV_DLL_NOT_FOUND);
            goto Ret;
        }

        if (0xffffffff == (cbImage = GetFileSize((HANDLE)IntToPtr(hFileProv), NULL)))
            goto Ret;

        _lclose(hFileProv);
        hFileProv = HFILE_ERROR;
    }

    if (!HashTheFile(pszImage, cbImage, &pbSig, &cbSig, rgbHash))
        goto Ret;

    // check signature against all public keys
    if (!CheckAllSignatures(pbSig, cbSig, rgbHash, FALSE))
        goto Ret;

    fRet = TRUE;

Ret:
    if (HFILE_ERROR != hFileProv)
        _lclose(hFileProv);
    if (pbSig)
        LocalFree(pbSig);
    return fRet;
}


/*++

ShowHelp:

    This routine displays a short help message to the given output stream.

Arguments:

    ostr - The output stream to receive the help message.

Return Value:

    None

Author:

    Jeff Spelman

--*/

void
ShowHelp(
    void)
{
    printf("CryptoAPI Display Signature Utility\n");
    printf("   showsig <filename>\n");
    printf("or\n");
    printf("   showsig -s <rsrcfile> <filename>\n");
    printf("or\n");
    printf("   showsig -b <sigfile> <filename>\n");
    printf("Other options:\n");
    printf("   +t - Enable the use of the Enigma key\n");
    printf("        (On by default).\n");
    printf("   -t - Disable the use of the Enigma key\n");
}


/*++

main:

    This is the main entry point of the application.

Arguments:

    argc - Count of arguments
    argv - array of arguments

Return Value:

    0 - Success
    1 - Error

Author:

    Jeff Spelman

--*/
extern "C" void __cdecl
main(
    int argc,
    char *argv[])
{
    TCHAR   szFullPath[MAX_PATH];
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    HMODULE hResFile = NULL;
    DWORD exStatus = 1;
    LPCTSTR szInFile = NULL;
    LPCTSTR szResFile = NULL;
    LPCTSTR szSigFile = NULL;
    LPTSTR szTail;
    BOOL fOutput = FALSE;
    DWORD   i;
    HRSRC   hRes;
    DWORD   cbImage;
    BOOL    fFreeSignature = FALSE;
    BYTE    rgbHash[MD5DIGESTLEN];
    LPBYTE pbSignature = NULL;
    DWORD cbSignatureLen;


    //
    // Parse the command line.
    //

    for (i = 1; i < (DWORD)argc; i++)
    {
        if (0 == _stricmp("-h", argv[i]))
        {
            ShowHelp();
            exStatus = 1;
            goto ErrorExit;
        }
        else if (0 == _stricmp("-s", argv[i]))
        {
            i += 1;
            if ((NULL != szResFile) || (i >= (DWORD)argc))
            {
                ShowHelp();
                exStatus = 1;
                goto ErrorExit;
            }

            szResFile = argv[i];
        }
        else if (0 == _stricmp("-b", argv[i]))
        {
            i += 1;
            if ((NULL != szSigFile) || (i >= (DWORD)argc))
            {
                ShowHelp();
                exStatus = 1;
                goto ErrorExit;
            }

            szSigFile = argv[i];
        }
        else if (0 == _stricmp("-t", argv[i]))
        {
            g_fUseTestKey = FALSE;
        }
        else if (0 == _stricmp("+t", argv[i]))
        {
            g_fUseTestKey = TRUE;
        }
        else
        {
            if (NULL != szInFile)
            {
                ShowHelp();
                exStatus = 1;
                goto ErrorExit;
            }

            szInFile = argv[i];
        }
    }


    //
    // Command consistency checks.
    //

    if (NULL == szInFile)
    {
        printf("No input file specified.\n");
        ShowHelp();
        exStatus = 4 ;
        goto ErrorExit;
    }

    i = GetFullPathName(szInFile,
                        sizeof(szFullPath) / sizeof(TCHAR),
                        szFullPath,
                        &szTail);
    if (0 == i)
    {
        printf("Can't expand file name.\n");
        exStatus = 4;
        goto ErrorExit;
    }
    else if (sizeof(szFullPath) / sizeof(TCHAR) < i)
    {
        printf("File path too long.\n");
        exStatus = 4;
        goto ErrorExit;
    }
    szInFile = szFullPath;


    //
    // If the DLL has a FIPS 140-1 MAC resource then check it
    //
    if (!SelfMACCheck(szInFile))
        exStatus = 3 ;


    //
    // Where's our signature?
    //

    if (NULL != szSigFile)
    {

        //
        // This file has an accompanying binary signature file.
        // Verify the file, and get its length.
        //

        hFile = CreateFile(szInFile,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            printf("Unable to open the CSP file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        cbImage = GetFileSize(hFile, NULL);
        if (0 == cbImage)
        {
            printf("Unable to get size of CSP file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;

        //
        // Get the signature from the file.
        //

        hFile = CreateFile(szSigFile,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            printf("Unable to open the Signature file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        cbSignatureLen = GetFileSize(hFile, NULL);
        if (0 == cbImage)
        {
            printf("Unable to get size of the Signature file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        pbSignature = (LPBYTE)LocalAlloc(LPTR, cbSignatureLen);
        if (NULL == pbSignature)
        {
            printf("No memory!\n");
            exStatus = 2;
            goto ErrorExit;
        }
        fFreeSignature = TRUE;

        if (!ReadFile(hFile,
                      pbSignature,
                      cbSignatureLen,
                      &cbSignatureLen,
                      NULL))
        {
            printf("Unable to read the Signature file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;


        // display the signature
        printf("--- Signature ---\n");
        for (i = 0; i < cbSignatureLen; i++)
        {
            printf("0x%02X ", pbSignature[i]);
            if (((i + 1) % 8) == 0)
                printf("\n");
        }
        if (0 != (i % 8))
            printf("\n");

        if (!HashTheFile(szInFile, cbImage, NULL, NULL, rgbHash))
        {
            printf("Unable to hash the CSP file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        // check signature against all public keys
        if (!CheckAllSignatures(pbSignature, cbSignatureLen, rgbHash, FALSE))
        {
            printf("The signature on %s FAILED to verify!\n", szInFile);
            exStatus = 1 ;
        }
        else
        {
            printf("The signature on %s VERIFIED!\n", szInFile);
            exStatus = 0;
        }
    }
    else if (NULL != szResFile)
    {

        //
        // This file has an accompanying signature resource file.
        // Verify the file, and get its length.
        //

        hFile = CreateFile(szInFile,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            printf("Unable to open the CSP file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        cbImage = GetFileSize(hFile, NULL);
        if (0 == cbImage)
        {
            printf("Unable to get size of CSP file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;


        //
        // Load the resource from the associated resource file.
        //

        hResFile = LoadLibraryEx(szResFile, NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (NULL == hResFile)
        {
            printf("Unable to load the resource file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        hRes = FindResource(hResFile, (LPCTSTR)SIG_RESOURCE_NUM, RT_RCDATA);
        if (NULL == hRes)
        {
            printf("Unable to find the signature in the resource file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        pbSignature = (LPBYTE)LoadResource(hResFile, hRes);
        if (NULL == pbSignature)
        {
            printf("Unable to find the signature in the resource file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        cbSignatureLen = SizeofResource(hResFile, hRes);

        // display the signature
        printf("--- Signature ---\n");
        for (i = 0; i < cbSignatureLen; i++)
        {
            printf("0x%02X ", pbSignature[i]);
            if (((i + 1) % 8) == 0)
                printf("\n");
        }
        if (0 != (i % 8))
            printf("\n");

        if (!HashTheFile(szInFile, cbImage, NULL, NULL, rgbHash))
        {
            printf("Unable to hash the CSP file!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        // check signature against all public keys
        if (!CheckAllSignatures(pbSignature, cbSignatureLen, rgbHash, FALSE))
        {
            printf("The signature on %s FAILED to verify!\n", szInFile);
            exStatus = 1 ;
        }
        else
        {
            printf("The signature on %s VERIFIED!\n", szInFile);
            exStatus = 0;
        }
    }
    else
    {

        //
        // Get the signature from the resource in the file
        //

        if (ERROR_SUCCESS != GetCryptSignatureResource(szInFile,
                                                       &pbSignature,
                                                       &cbSignatureLen))
        {
            printf("Unable to get the signature from the file resource!\n");
            exStatus = 2 ;
            goto ErrorExit;
        }

        // display the signature
        printf("--- Signature ---\n");
        for (i = 0; i < cbSignatureLen; i++)
        {
            printf("0x%02X ", pbSignature[i]);
            if (((i + 1) % 8) == 0)
                printf("\n");
        }
        if (0 != (i % 8))
            printf("\n");


        //
        // check the signature against the file
        //

        if (CheckSignatureInFile(szInFile))
        {
            printf("The signature on %s VERIFIED!\n", szInFile);
            exStatus = 0;
        }
        else
        {
            printf("The signature on %s FAILED to verify!\n", szInFile);
            exStatus = 1 ;
        }
    }


    //
    // Clean up and return.
    //

ErrorExit:
    if (fFreeSignature && (NULL != pbSignature))
        LocalFree(pbSignature);
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    if (NULL != hResFile)
        FreeLibrary(hResFile);
    exit(exStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\programs\signcsp\mainrpc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Mar 08 11:33:02 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __mainrpc_h__
#define __mainrpc_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __hello_INTERFACE_DEFINED__
#define __hello_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: hello
 * at Fri Mar 08 11:33:02 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [implicit_handle][version][uuid] */ 


			/* size is 4 */
typedef unsigned long DWORD;

			/* size is 1 */
typedef unsigned char UCHAR;

			/* size is 1 */
boolean GenSignature( 
    /* [size_is][in] */ UCHAR __RPC_FAR *InData,
    /* [out][in] */ DWORD __RPC_FAR *cbSignatureLen,
    /* [size_is][out] */ UCHAR __RPC_FAR *pbSignature);


extern handle_t hello_IfHandle;


extern RPC_IF_HANDLE hello_v1_0_c_ifspec;
extern RPC_IF_HANDLE hello_v1_0_s_ifspec;
#endif /* __hello_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\programs\signcsp\signcsp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : client.cxx                                             //
//  DESCRIPTION   : Crypto API interface                                   //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Mar  8 1996 larrys  New                                            //
//                  dbarlow                                                //
//                                                                         //
//  Copyright (C) 1996 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>
#include "mainrpc.h"    // header file generated by the MIDL compiler
#include <imagehlp.h>
#include "des.h"
#include "modes.h"


#include "skrpc.h"
extern "C" {
#include "md5.h"
};

// designatred resource for in file signatures
#define CRYPT_SIG_RESOURCE_NUMBER   "#666"

// MAC in file
#define MAC_RESOURCE_NUMBER   "#667"

static DWORD dwMACInFileVersion = 0x100;

BYTE rgbDESKey[] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef};


BOOL HashTheFile(
                 LPCSTR pszFile,
                 DWORD dwCRCOffset,
                 BYTE *pbHash,
                 DWORD *pcbHash,
                 DWORD cbImage
                 );

DWORD GetCRCOffset(
                   LPCSTR szFile,
                   DWORD cbImage,
                   DWORD *pdwCRCOffset
                   );

static DWORD dwSigInFileVersion = 0x100;

DWORD SetCryptSignatureResource(
                                LPCSTR szFile,
                                DWORD dwSigVersion,
                                DWORD dwCRCOffset,
                                PBYTE pbNewSig,
                                DWORD cbNewSig,
                                DWORD cbImage
                                );

void ShowHelp();
BOOL DumpFile(LPCTSTR szFile, const BYTE *pb, UINT cb);
void CallServer(void);

BYTE pbSignature[256];
BYTE pbDigest[80];
DWORD cbDigestLen = sizeof(pbDigest);
DWORD cbSignatureLen = sizeof(pbSignature);

// The function MACs the given bytes.
void MACBytes(
              IN DESTable *pDESKeyTable,
              IN BYTE *pbData,
              IN DWORD cbData,
              IN OUT BYTE *pbTmp,
              IN OUT DWORD *pcbTmp,
              IN OUT BYTE *pbMAC,
              IN BOOL fFinal
              )
{
    DWORD   cb = cbData;
    DWORD   cbMACed = 0;

    while (cb)
    {
        if ((cb + *pcbTmp) < DES_BLOCKLEN)
        {
            memcpy(pbTmp + *pcbTmp, pbData + cbMACed, cb);
            *pcbTmp += cb;
            break;
        }
        else
        {
            memcpy(pbTmp + *pcbTmp, pbData + cbMACed, DES_BLOCKLEN - *pcbTmp);
            CBC(des, DES_BLOCKLEN, pbMAC, pbTmp, pDESKeyTable,
                ENCRYPT, pbMAC);
            cbMACed = cbMACed + (DES_BLOCKLEN - *pcbTmp);
            cb = cb - (DES_BLOCKLEN - *pcbTmp);
            *pcbTmp = 0;
        }
    }
}

// Given hInst, allocs and returns pointers to MAC pulled from
// resource
BOOL GetResourcePtr(
                    IN HMODULE hInst,
                    IN LPSTR pszRsrcName,
                    OUT BYTE **ppbRsrcMAC,
                    OUT DWORD *pcbRsrcMAC
                    )
{
    HRSRC   hRsrc;
    BOOL    fRet = FALSE;

    // Nab resource handle for our signature
    if (NULL == (hRsrc = FindResourceA(hInst, pszRsrcName,
                                       RT_RCDATA)))
        goto Ret;

    // get a pointer to the actual signature data
    if (NULL == (*ppbRsrcMAC = (PBYTE)LoadResource(hInst, hRsrc)))
        goto Ret;

    // determine the size of the resource
    if (0 == (*pcbRsrcMAC = SizeofResource(hInst, hRsrc)))
        goto Ret;

    fRet = TRUE;
Ret:
    return fRet;
}

#define CSP_TO_BE_MACED_CHUNK  4096

// Given hFile, reads the specified number of bytes (cbToBeMACed) from the file
// and MACs these bytes.  The function does this in chunks.
BOOL MACBytesOfFile(
                     IN HANDLE hFile,
                     IN DWORD cbToBeMACed,
                     IN DESTable *pDESKeyTable,
                     IN BYTE *pbTmp,
                     IN DWORD *pcbTmp,
                     IN BYTE *pbMAC,
                     IN BYTE fFinal
                     )
{
    BYTE    rgbChunk[CSP_TO_BE_MACED_CHUNK];
    DWORD   cbRemaining = cbToBeMACed;
    DWORD   cbToRead;
    DWORD   dwBytesRead;
    BOOL    fRet = FALSE;

    //
    // loop over the file for the specified number of bytes
    // updating the hash as we go.
    //

    while (cbRemaining > 0)
    {
        if (cbRemaining < CSP_TO_BE_MACED_CHUNK)
            cbToRead = cbRemaining;
        else
            cbToRead = CSP_TO_BE_MACED_CHUNK;

        if(!ReadFile(hFile, rgbChunk, cbToRead, &dwBytesRead, NULL))
            goto Ret;
        if (dwBytesRead != cbToRead)
            goto Ret;

        MACBytes(pDESKeyTable, rgbChunk, dwBytesRead, pbTmp, pcbTmp,
                 pbMAC, fFinal);
        cbRemaining -= cbToRead;
    }

    fRet = TRUE;
Ret:
    return fRet;
}


BOOL MACTheFileWithSig(
                       LPCSTR pszImage,
                       DWORD cbImage,
                       IN DWORD dwMACVersion,
                       IN DWORD dwCRCOffset,
                       OUT BYTE *pbMAC
                       )
{
    HMODULE                     hInst = 0;
    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbRsrcMAC;
    DWORD                       cbRsrcMAC;
    BYTE                        *pbRsrcSig;
    DWORD                       cbRsrcSig;
    BYTE                        *pbStart;
    BYTE                        rgbMAC[DES_BLOCKLEN];
    BYTE                        rgbZeroMAC[DES_BLOCKLEN + sizeof(DWORD) * 2];
    BYTE                        rgbZeroSig[144];
    BYTE                        *pbPostCRC;   // pointer to just after CRC
    DWORD                       cbCRCToRsrc1; // number of bytes from CRC to first rsrc
    DWORD                       cbRsrc1ToRsrc2; // number of bytes from first rsrc to second
    DWORD                       cbPostRsrc;    // size - (already hashed + signature size)
    BYTE                        *pbRsrc1ToRsrc2;
    BYTE                        *pbPostRsrc;
    BYTE                        *pbZeroRsrc1;
    BYTE                        *pbZeroRsrc2;
    DWORD                       cbZeroRsrc1;
    DWORD                       cbZeroRsrc2;
    DWORD                       dwZeroCRC = 0;
    DWORD                       dwBytesRead = 0;
    OFSTRUCT                    ImageInfoBuf;
    HFILE                       hFile = HFILE_ERROR;
    HANDLE                      hMapping = NULL;
    DESTable                    DESKeyTable;
    BYTE                        rgbTmp[DES_BLOCKLEN];
    DWORD                       cbTmp = 0;
    BOOL                        fRet = FALSE;

    memset(&MemInfo, 0, sizeof(MemInfo));
    memset(rgbMAC, 0, sizeof(rgbMAC));
    memset(rgbTmp, 0, sizeof(rgbTmp));

    // Load the file
    if (HFILE_ERROR == (hFile = OpenFile(pszImage, &ImageInfoBuf,
                                         OF_READ)))
    {
        goto Ret;
    }

    hMapping = CreateFileMapping((HANDLE)IntToPtr(hFile),
                                  NULL,
                                  PAGE_READONLY,
                                  0,
                                  0,
                                  NULL);
    if(hMapping == NULL)
    {
        goto Ret;
    }

    hInst = (HMODULE)MapViewOfFile(hMapping,
                          FILE_MAP_READ,
                          0,
                          0,
                          0);
    if(hInst == NULL)
    {
        goto Ret;
    }
    pbStart = (BYTE*)hInst;

    // Convert pointer to HMODULE, using the same scheme as
    // LoadLibrary (windows\base\client\module.c).
    *((ULONG_PTR*)&hInst) |= 0x00000001;

    // the MAC resource
    if (!GetResourcePtr(hInst, MAC_RESOURCE_NUMBER, &pbRsrcMAC, &cbRsrcMAC))
        goto Ret;

    // the MAC resource
    if (!GetResourcePtr(hInst, CRYPT_SIG_RESOURCE_NUMBER, &pbRsrcSig, &cbRsrcSig))
        goto Ret;

    if (cbRsrcMAC < (sizeof(DWORD) * 2))
        goto Ret;

    // create a zero byte MAC
    memset(rgbZeroMAC, 0, sizeof(rgbZeroMAC));

    // create a zero byte Sig
    memset(rgbZeroSig, 0, sizeof(rgbZeroSig));

    // set up the pointers
    pbPostCRC = pbStart + dwCRCOffset + sizeof(DWORD);
    if (pbRsrcSig > pbRsrcMAC)    // MAC is first Rsrc
    {
        cbCRCToRsrc1 = (DWORD)(pbRsrcMAC - pbPostCRC);
        pbRsrc1ToRsrc2 = pbRsrcMAC + cbRsrcMAC;
        cbRsrc1ToRsrc2 = (DWORD)(pbRsrcSig - pbRsrc1ToRsrc2);
        pbPostRsrc = pbRsrcSig + cbRsrcSig;
        cbPostRsrc = (cbImage - (DWORD)(pbPostRsrc - pbStart));

        // zero pointers
        pbZeroRsrc1 = rgbZeroMAC;
        cbZeroRsrc1 = cbRsrcMAC;
        pbZeroRsrc2 = rgbZeroSig;
        cbZeroRsrc2 = cbRsrcSig;
    }
    else                        // Sig is first Rsrc
    {
        cbCRCToRsrc1 = (DWORD)(pbRsrcSig - pbPostCRC);
        pbRsrc1ToRsrc2 = pbRsrcSig + cbRsrcSig;
        cbRsrc1ToRsrc2 = (DWORD)(pbRsrcMAC - pbRsrc1ToRsrc2);
        pbPostRsrc = pbRsrcMAC + cbRsrcMAC;
        cbPostRsrc = (cbImage - (DWORD)(pbPostRsrc - pbStart));

        // zero pointers
        pbZeroRsrc1 = rgbZeroSig;
        cbZeroRsrc1 = cbRsrcSig;
        pbZeroRsrc2 = rgbZeroMAC;
        cbZeroRsrc2 = cbRsrcMAC;
    }

    // init the key table
    deskey(&DESKeyTable, rgbDESKey);

    // MAC up to the CRC
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), dwCRCOffset, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend CRC is zeroed
    MACBytes(&DESKeyTable, (BYTE*)&dwZeroCRC, sizeof(DWORD), rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), sizeof(DWORD), NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC from CRC to first resource
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbCRCToRsrc1, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend image has zeroed first resource
    MACBytes(&DESKeyTable, (BYTE*)pbZeroRsrc1, cbZeroRsrc1, rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), cbZeroRsrc1, NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC from first resource to second
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbRsrc1ToRsrc2, &DESKeyTable, rgbTmp,
                        &cbTmp, rgbMAC, FALSE))
    {
        goto Ret;
    }

    // pretend image has zeroed second Resource
    MACBytes(&DESKeyTable, (BYTE*)pbZeroRsrc2, cbZeroRsrc2, rgbTmp, &cbTmp,
             rgbMAC, FALSE);
    if (!SetFilePointer((HANDLE)IntToPtr(hFile), cbZeroRsrc2, NULL, FILE_CURRENT))
    {
        goto Ret;
    }

    // MAC after the resource
    if (!MACBytesOfFile((HANDLE)IntToPtr(hFile), cbPostRsrc, &DESKeyTable, rgbTmp, &cbTmp,
                        rgbMAC, TRUE))
    {
        goto Ret;
    }

    memcpy(pbMAC, rgbMAC, DES_BLOCKLEN);

    fRet = TRUE;
Ret:
    if(hInst)
        UnmapViewOfFile(hInst);
    if(hMapping)
        CloseHandle(hMapping);
    if (HFILE_ERROR != hFile)
        _lclose(hFile);

    return fRet;
}

// SetCryptMACResource
//
// slams MAC resource in file with the new MAC
//
DWORD SetCryptMACResource(
                          IN LPCSTR szFile,
                          IN DWORD dwMACVersion,
                          IN DWORD dwCRCOffset,
                          IN PBYTE pbNewMAC,
                          IN DWORD cbImage
                          )
{
    DWORD   dwErr = 0x1;

    HANDLE  hFileProv = NULL;
    HMODULE hInst = NULL;

    PBYTE   pbFilePtr = NULL;
    DWORD   cbImageSize, cbMACOffset;

    PBYTE   pbMAC;
    DWORD   cbMAC;

    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbStart;

    DWORD               OldCheckSum;
    DWORD               NewCheckSum;
    PIMAGE_NT_HEADERS   pImageNTHdrs;

    HANDLE  hFileMap = NULL;

    memset(&MemInfo, 0, sizeof(MemInfo));

    // Load the file as a datafile
    if (NULL == (hInst = LoadLibraryEx(szFile, NULL, LOAD_LIBRARY_AS_DATAFILE)))
    {
        printf("Couldn't load file\n");
        goto Ret;
    }
    if (!GetResourcePtr(hInst, MAC_RESOURCE_NUMBER, &pbMAC, &cbMAC))
    {
        printf("Couldn't find MAC placeholder\n");
        goto Ret;
    }

    // get image start address
    VirtualQuery(hInst, &MemInfo, sizeof(MemInfo));
    pbStart = (BYTE*)MemInfo.BaseAddress;

    FreeLibrary(hInst); hInst = NULL;

    cbMACOffset = (DWORD)(pbMAC - pbStart);

    if (cbMAC != (DES_BLOCKLEN + sizeof(DWORD) * 2))
    {
        printf("Attempt to replace %d zeros with new MAC!\n", cbMAC);
        goto Ret;
    }

    if (INVALID_HANDLE_VALUE == (hFileProv = CreateFile(szFile,
                                GENERIC_READ | GENERIC_WRITE,
                                0,  // don't share
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                0)))
    {
        printf("Couldn't CreateFile: 0x%x\n", GetLastError());
        goto Ret;
    }

    if (NULL == (hFileMap = CreateFileMapping(
                                hFileProv,
                                NULL,
                                PAGE_READWRITE,
                                0,
                                0,
                                NULL)))
    {
        printf("Couldn't map file\n");
        goto Ret;
    }

    if (NULL == (pbFilePtr = (PBYTE)MapViewOfFile(
                                hFileMap,
                                FILE_MAP_ALL_ACCESS,
                                0,
                                0,
                                0)))
    {
        printf("Couldn't create view\n");
        goto Ret;
    }

    // copy version, CRC offset and new sig
    CopyMemory(pbFilePtr+cbMACOffset, &dwMACVersion, sizeof(dwMACVersion));
    cbMACOffset += sizeof(dwMACVersion);
    CopyMemory(pbFilePtr+cbMACOffset, &dwCRCOffset, sizeof(dwCRCOffset));
    cbMACOffset += sizeof(dwCRCOffset);
    CopyMemory(pbFilePtr+cbMACOffset, pbNewMAC, DES_BLOCKLEN);

    // compute a new checksum
    if (NULL == (pImageNTHdrs = CheckSumMappedFile(pbFilePtr, cbImage,
                                                   &OldCheckSum, &NewCheckSum)))
        goto Ret;

    CopyMemory(&pImageNTHdrs->OptionalHeader.CheckSum, &NewCheckSum, sizeof(DWORD));

    if (NULL == (pImageNTHdrs = CheckSumMappedFile(pbFilePtr, cbImage,
                                                   &OldCheckSum, &NewCheckSum)))
        goto Ret;

    if (OldCheckSum != NewCheckSum)
        goto Ret;

    dwErr = ERROR_SUCCESS;
Ret:
    if (pbFilePtr)
        UnmapViewOfFile(pbFilePtr);

    if (hFileMap)
        CloseHandle(hFileMap);

    if (hInst)
        FreeLibrary(hInst);

    if (hFileProv)
        CloseHandle(hFileProv);

    return dwErr;
}

void MacCSP(
            LPCSTR pszInFile
            )
{
    DWORD   cbImage;
    DWORD   dwCRCOffset;
    HANDLE  hFileProv = INVALID_HANDLE_VALUE;
    BYTE    rgbMAC[DES_BLOCKLEN];
    HMODULE hInst = NULL;

    PBYTE   pbFilePtr = NULL;
    DWORD   cbImageSize, cbMACOffset;

    PBYTE   pbMAC;
    DWORD   cbMAC;

    memset(rgbMAC, 0, sizeof(rgbMAC));

    // check if the MAC resource is in the CSP and exit if not
    // Load the file as a datafile
    if (NULL == (hInst = LoadLibraryEx(pszInFile,
                                       NULL,
                                       LOAD_LIBRARY_AS_DATAFILE)))
    {
        printf("Couldn't load file\n");
        goto Ret;
    }
    if (!GetResourcePtr(hInst, MAC_RESOURCE_NUMBER, &pbMAC, &cbMAC))
    {
        goto Ret;
    }
    FreeLibrary(hInst);
    hInst = NULL;

    // get the file size
    if ((hFileProv = CreateFile(pszInFile,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                0)) == INVALID_HANDLE_VALUE)
    {
        printf("CSP specified was not found!\n");
        goto Ret;
    }

    if (0xffffffff == (cbImage = GetFileSize(hFileProv, NULL)))
    {
        printf("CSP specified was not found!\n");
        goto Ret;
    }

    CloseHandle(hFileProv);
    hFileProv = NULL;

    if (0 != GetCRCOffset(pszInFile, cbImage, &dwCRCOffset))
    {
        printf("Unable to get CRC!\n");
        goto Ret;
    }

    // calculate the MAC
    if (!MACTheFileWithSig(pszInFile,
                           cbImage,
                           dwMACInFileVersion,
                           dwCRCOffset,
                           rgbMAC))
    {
        printf("MAC failed!\n");
        goto Ret;
    }

    //
    // Place the MAC into the resource in the file
    //

    if (ERROR_SUCCESS != SetCryptMACResource(pszInFile,
                                             dwMACInFileVersion,
                                             dwCRCOffset,
                                             rgbMAC,
                                             cbImage))
    {
        printf("Unable to set the MAC into the file resource!\n");
        goto Ret;
    }
Ret:
    if (hInst)
    {
        FreeLibrary(hInst);
    }

    if (INVALID_HANDLE_VALUE != hFileProv)
    {
        CloseHandle(hFileProv);
    }

    return;
}

/*++

main:

    This is the main entry point of the application.

Arguments:

    argc - Count of arguments
    argv - array of arguments

Return Value:

    0 - Success
    1 - Error

Author:

    Doug Barlow (dbarlow) 1/25/1996

--*/
extern "C" void __cdecl
main(
    int argc,
    char *argv[])
{
    DWORD exStatus = 1;
    DWORD index;
    LPCTSTR szBinFile = NULL;
    LPCTSTR szInFile = NULL;
    BOOL fOutput = FALSE;
    int status;
    DWORD ThreadId;
    HANDLE hThread;

    // RPC Specific variables.
    RPC_STATUS rpcStatus;
    unsigned char * pszUuid = NULL;
    char * pszProtocolSequence = "ncacn_np";
    unsigned char * pszNetworkAddress   = (LPBYTE)"\\\\enigma.ntdev.microsoft.com";
    char * pszEndpoint = "\\pipe\\sign";
    unsigned char * pszOptions      = NULL;
    unsigned char * pszStringBinding    = NULL;
    DWORD dwrt;
    DWORD i;
    DWORD cbImage;
    DWORD dwCRCOffset;
    HANDLE hFileProv = 0;

    //
    // Parse the command line.
    //

    if ((argc != 2) || (argv[1][0] == '?'))
    {
        ShowHelp();
        exStatus = 0;
        goto ErrorExit;
    }

    szInFile = &argv[1][0];

    //
    // Command consistency checks.
    //

    if (NULL == szInFile)
    {
        printf("No input file specified.\n");
        goto ErrorExit;
    }

    MacCSP(szInFile);

    // get the file size
    if ((hFileProv = CreateFile(szInFile,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                0)) == INVALID_HANDLE_VALUE)
    {
        printf("CSP specified was not found!\n");
        goto ErrorExit;
    }

    if (0xffffffff == (cbImage = GetFileSize(hFileProv, NULL)))
    {
        printf("CSP specified was not found!\n");
        goto ErrorExit;
    }

    CloseHandle(hFileProv);
    hFileProv = NULL;

    if (ERROR_SUCCESS != GetCRCOffset(szInFile, cbImage, &dwCRCOffset))
    {
        printf("Unable to get the CRC offset on the file!\n");
        goto ErrorExit;
    }

    //
    // Compute the hash.
    //

    if (!HashTheFile(szInFile, dwCRCOffset, pbDigest, &cbDigestLen, cbImage))
    {
        printf("Unable to hash the file!\n");
        goto ErrorExit;
    }

    //
    // Get the signature.
    //

    // Try to make rpc connection
    rpcStatus = RpcStringBindingCompose(pszUuid,
                     (unsigned char *) pszProtocolSequence,
                     pszNetworkAddress,
                     (unsigned char *) pszEndpoint,
                     pszOptions,
                     &pszStringBinding);

#ifdef DEBUG
    printf("RpcStringBindingCompose returned 0x%x\n", rpcStatus);
    printf("pszStringBinding = %s\n", pszStringBinding);
#endif
    if (0 != rpcStatus)
    {
        printf("Failed to compose binding string for target RPC server.\n");
        goto ErrorExit;
    }

    /* Set the binding handle that will */
    /* be used to bind to the server  */
    rpcStatus = RpcBindingFromStringBinding(pszStringBinding,
                     &hello_IfHandle);

#ifdef DEBUG
    printf("RpcBindingFromStringBinding returned 0x%x\n", rpcStatus);
#endif
    if (0 != rpcStatus)
    {
        printf("Failed to bind to target RPC server.\n");
        goto ErrorExit;
    }

    if ((hThread = CreateThread(NULL,
                                0,
                                (LPTHREAD_START_ROUTINE) CallServer,
                                NULL,
                                0,
                                &ThreadId)) == NULL)
    {
        printf("Call to CreateThread failed\n");
        goto ErrorExit;
    }

    printf("Sending request to be signed, will wait 5 minutes\n");
    for (i = 0; i < 20; i++)
    {
        printf("Waited   %d  seconds\n", i*30);
        dwrt = WaitForSingleObject(hThread, 15000);
        if (dwrt == WAIT_OBJECT_0)
        {
            break;
        }
    }

    if (i == 20)
    {
        printf("Call to Server timed out\n");
        goto ErrorExit;
    }

    GetExitCodeThread(hThread, &dwrt);

    if (dwrt)
    {
        goto ErrorExit;
    }

    //
    // Place the signature into the resource in the file
    //

    if (ERROR_SUCCESS != SetCryptSignatureResource(szInFile, dwSigInFileVersion,
                                                   dwCRCOffset, pbSignature,
                                                   cbSignatureLen, cbImage))
    {
        printf("Unable to set the signature into the file resource!\n");
        goto ErrorExit;
    }

    //
    // Clean up and return.
    //

    exStatus = 0;


ErrorExit:
    exit(exStatus);

}

void CallServer(void)
{
    RpcTryExcept
    {
        cbSignatureLen = sizeof(pbSignature);
        if (GenSignature(pbDigest, &cbSignatureLen, pbSignature))
        {
            printf("GenSignature returned an error \n");
            ExitThread(TRUE);
        }
    }
    RpcExcept(1)
    {
        printf("RPC error -- exception code is  0x%X\n", RpcExceptionCode());
        ExitThread(RpcExceptionCode());
    }
    RpcEndExcept

    ExitThread(FALSE);

}

// Given hInst, allocs and returns pointers to signature pulled from
// resource
BOOL GetCryptSigResourcePtr(
                            HMODULE hInst,
                            BYTE **ppbRsrcSig,
                            DWORD *pcbRsrcSig
                            )
{
    HRSRC   hRsrc;
    BOOL    fRet = FALSE;

    // Nab resource handle for our signature
    if (NULL == (hRsrc = FindResource(hInst, CRYPT_SIG_RESOURCE_NUMBER,
                                      RT_RCDATA)))
        goto Ret;

    // get a pointer to the actual signature data
    if (NULL == (*ppbRsrcSig = (PBYTE)LoadResource(hInst, hRsrc)))
        goto Ret;

    // determine the size of the resource
    if (0 == (*pcbRsrcSig = SizeofResource(hInst, hRsrc)))
        goto Ret;

    fRet = TRUE;
Ret:
    return fRet;
}

// Given hInst, hashes over the file skipping, hashing zero bytes where the
// resource is
BOOL HashTheFile(
                 LPCSTR pszFile,
                 DWORD dwCRCOffset,
                 BYTE *pbHash,
                 DWORD *pcbHash,
                 DWORD cbImage
                 )
{
    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbRsrcSig;
    DWORD                       cbRsrcSig;
    BYTE                        *pbStart;
    BYTE                        *pbZeroSig = NULL;
    MD5_CTX                     MD5Hash;
    DWORD                       dwZeroCRC = 0;
    DWORD                       cbPreCRC;     // start of CRC
    DWORD                       cbCRCToSig;   // end of CRC to start of sig
    BYTE                        *pbPostCRC;   // just after CRC
    DWORD                       cbPostSig;    // size - (already hashed + signature size)
    BYTE                        *pbPostSig;
    HMODULE                     hInst = 0;
    BOOL                        fRet = FALSE;

    memset(&MD5Hash, 0, sizeof(MD5Hash));
    memset(&MemInfo, 0, sizeof(MemInfo));

    // Load the file as a datafile
    if (NULL == (hInst = LoadLibraryEx(pszFile, NULL, LOAD_LIBRARY_AS_DATAFILE)))
        goto Ret;

    // get image start address
    VirtualQuery(hInst, &MemInfo, sizeof(MemInfo));
    pbStart = (BYTE*)MemInfo.BaseAddress;

    // the resources signature
    if (!GetCryptSigResourcePtr(hInst, &pbRsrcSig, &cbRsrcSig))
        goto Ret;

    // create a zero byte signature
    if (NULL == (pbZeroSig = (BYTE*)LocalAlloc(LMEM_ZEROINIT, cbRsrcSig)))
        goto Ret;

    // want to hash the version and the CRC offset
    CopyMemory(pbZeroSig, &dwSigInFileVersion, sizeof(dwSigInFileVersion));
    CopyMemory(pbZeroSig + sizeof(dwSigInFileVersion), &dwCRCOffset,
               sizeof(dwCRCOffset));

    // hash over the relevant data
    {
        pbPostCRC = pbStart + dwCRCOffset + sizeof(dwZeroCRC);
        cbCRCToSig = (DWORD)(pbRsrcSig - pbPostCRC);
        pbPostSig = pbRsrcSig + cbRsrcSig;
        cbPostSig = (cbImage - (DWORD)(pbPostSig - pbStart));

        MD5Init(&MD5Hash);

        MD5Update(&MD5Hash, pbStart, dwCRCOffset);

        // pretend CRC is zeroed
        MD5Update(&MD5Hash, (BYTE*)&dwZeroCRC, sizeof(dwZeroCRC));

        // pretend image has zeroed sig
        MD5Update(&MD5Hash, pbPostCRC, cbCRCToSig);

        // pretend image has zeroed sig
        MD5Update(&MD5Hash, pbZeroSig, cbRsrcSig);

        MD5Update(&MD5Hash, pbPostSig, cbPostSig);

        // Finish the hash
        MD5Final(&MD5Hash);

        *pcbHash = MD5DIGESTLEN;
        memcpy(pbHash, MD5Hash.digest, MD5DIGESTLEN);
    }

    fRet = TRUE;
Ret:
    if (hInst)
        FreeLibrary(hInst);
    if (pbZeroSig)
        LocalFree(pbZeroSig);
    return fRet;
}

DWORD GetCRCOffset(
                   LPCSTR szFile,
                   DWORD cbImage,
                   DWORD *pdwCRCOffset
                   )
{
    DWORD               dwErr = 0x1;

    HANDLE              hFileProv = NULL;
    PBYTE               pbFilePtr = NULL;
    DWORD               OldCheckSum;
    DWORD               NewCheckSum;
    PIMAGE_NT_HEADERS   pImageNTHdrs;

    HANDLE              hFileMap = NULL;


    if (INVALID_HANDLE_VALUE == (hFileProv = CreateFile(szFile,
                                GENERIC_READ | GENERIC_WRITE,
                                0,  // don't share
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                0)))
    {
        printf("Couldn't CreateFile: 0x%x\n", GetLastError());
        goto Ret;
    }

    if (NULL == (hFileMap = CreateFileMapping(
                                hFileProv,
                                NULL,
                                PAGE_READWRITE,
                                0,
                                0,
                                NULL)))
    {
        printf("Couldn't map file\n");
        goto Ret;
    }

    if (NULL == (pbFilePtr = (PBYTE)MapViewOfFile(
                                hFileMap,
                                FILE_MAP_ALL_ACCESS,
                                0,
                                0,
                                0)))
    {
        printf("Couldn't create view\n");
        goto Ret;
    }

    // compute a new checksum
    if (NULL == (pImageNTHdrs = CheckSumMappedFile(pbFilePtr, cbImage,
                                                   &OldCheckSum, &NewCheckSum)))
        goto Ret;

    *pdwCRCOffset = (DWORD)((BYTE*)&pImageNTHdrs->OptionalHeader.CheckSum - pbFilePtr);
    dwErr = ERROR_SUCCESS;
Ret:
    if (pbFilePtr)
        UnmapViewOfFile(pbFilePtr);

    if (hFileMap)
        CloseHandle(hFileMap);

    if (hFileProv)
        CloseHandle(hFileProv);

    return dwErr;
}

// SetCryptSignatureResource
//
// slams signature resource in file with the new signature
//
// szFile is file to modify
// pbNewSig is new signature
// cbNewSig is new signature length
DWORD SetCryptSignatureResource(
                                LPCSTR szFile,
                                DWORD dwSigVersion,
                                DWORD dwCRCOffset,
                                PBYTE pbNewSig,
                                DWORD cbNewSig,
                                DWORD cbImage
                                )
{
    DWORD   dwErr = 0x1;

    HANDLE  hFileProv = NULL;
    HMODULE hInst = NULL;

    PBYTE   pbFilePtr = NULL;
    DWORD   cbImageSize, cbSigOffset;

    PBYTE   pbSig;
    DWORD   cbSig;

    MEMORY_BASIC_INFORMATION    MemInfo;
    BYTE                        *pbStart;

    DWORD               OldCheckSum;
    DWORD               NewCheckSum;
    PIMAGE_NT_HEADERS   pImageNTHdrs;

    HANDLE  hFileMap = NULL;

    memset(&MemInfo, 0, sizeof(MemInfo));

    // Load the file as a datafile
    if (NULL == (hInst = LoadLibraryEx(szFile, NULL, LOAD_LIBRARY_AS_DATAFILE)))
    {
        printf("Couldn't load file\n");
        goto Ret;
    }
    if (!GetCryptSigResourcePtr(hInst,
                                &pbSig,
                                &cbSig))
    {
        printf("Couldn't find signature placeholder\n");
        goto Ret;
    }

    // get image start address
    VirtualQuery(hInst, &MemInfo, sizeof(MemInfo));
    pbStart = (BYTE*)MemInfo.BaseAddress;

    FreeLibrary(hInst); hInst = NULL;

    cbSigOffset = (DWORD)(pbSig - pbStart);

    if (cbSig < (cbNewSig + (sizeof(DWORD) * 2)))
    {
        printf("Attempt to replace %d zeros with %d byte signature!\n", cbSig, cbNewSig);
        goto Ret;
    }

    if (INVALID_HANDLE_VALUE == (hFileProv = CreateFile(szFile,
                                GENERIC_READ | GENERIC_WRITE,
                                0,  // don't share
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                0)))
    {
        printf("Couldn't CreateFile: 0x%x\n", GetLastError());
        goto Ret;
    }

    if (NULL == (hFileMap = CreateFileMapping(
                                hFileProv,
                                NULL,
                                PAGE_READWRITE,
                                0,
                                0,
                                NULL)))
    {
        printf("Couldn't map file\n");
        goto Ret;
    }

    if (NULL == (pbFilePtr = (PBYTE)MapViewOfFile(
                                hFileMap,
                                FILE_MAP_ALL_ACCESS,
                                0,
                                0,
                                0)))
    {
        printf("Couldn't create view\n");
        goto Ret;
    }

    // copy version, CRC offset and new sig
    CopyMemory(pbFilePtr+cbSigOffset, &dwSigVersion, sizeof(dwSigVersion));
    cbSigOffset += sizeof(dwSigVersion);
    CopyMemory(pbFilePtr+cbSigOffset, &dwCRCOffset, sizeof(dwCRCOffset));
    cbSigOffset += sizeof(dwCRCOffset);
    CopyMemory(pbFilePtr+cbSigOffset, pbNewSig, cbNewSig);
    if (cbSig > (cbNewSig + (sizeof(DWORD) * 2)))
    {
        ZeroMemory(pbFilePtr+cbSigOffset+cbNewSig,
                   cbSig - (cbNewSig + (sizeof(DWORD) * 2)));
    }

    // compute a new checksum
    if (NULL == (pImageNTHdrs = CheckSumMappedFile(pbFilePtr, cbImage,
                                                   &OldCheckSum, &NewCheckSum)))
        goto Ret;

    CopyMemory(&pImageNTHdrs->OptionalHeader.CheckSum, &NewCheckSum, sizeof(DWORD));

    if (NULL == (pImageNTHdrs = CheckSumMappedFile(pbFilePtr, cbImage,
                                                   &OldCheckSum, &NewCheckSum)))
        goto Ret;

    if (OldCheckSum != NewCheckSum)
        goto Ret;

    dwErr = ERROR_SUCCESS;
Ret:
    if (pbFilePtr)
        UnmapViewOfFile(pbFilePtr);

    if (hFileMap)
        CloseHandle(hFileMap);

    if (hInst)
        FreeLibrary(hInst);

    if (hFileProv)
        CloseHandle(hFileProv);

    return dwErr;
}


/*++

ShowHelp:

    This routine displays a short help message to the given output stream.

Arguments:

    ostr - The output stream to receive the help message.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 7/21/1995

--*/

void
ShowHelp()
{
    printf("CryptoAPI Internal CSP Signing Utility\n");
    printf("signcsp <filename>\n");
}

/* MIDL allocate and free */

void __RPC_FAR * __RPC_API midl_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\programs\stress\stress.c ===
#undef UNICODE					// ## Not Yet
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <windows.h>
#include <wincrypt.h>

#define NTAG_MULTIPHASE		0x80000000
#define DES_TEST                0x00000008

#define UTILITY_BUF_SIZE	1024
#define UTILITY_BUF_SIZE_2	1050
#define EXPORT_BUFFER_LEN	32768

#define MAXKEYLEN  128

HCRYPTPROV	hMe;
CHAR		pszMyName[64];
OFSTRUCT        ImageInfoBuf;
HFILE           hFile;
BYTE		buf[UTILITY_BUF_SIZE];
BYTE		buf2[UTILITY_BUF_SIZE];
DWORD		BLen, BLen2, i;
HCRYPTKEY	hKey = 0;
HCRYPTKEY	hKey2 = 0;
HCRYPTKEY	hMyPubKey;
HCRYPTKEY	hClientKey;
WORD            wRandomSize;
DWORD           dRandom;
BYTE            *pTmp;
DWORD           count;
BYTE            *bRanbuf;
BYTE            *bcryptbuf;
DWORD           i;
BYTE            pData[8];
BYTE            pHashData1[50];
DWORD           BHashLen1;
BYTE            pHashData2[50];
DWORD           BHashLen2;
BYTE            pHashSignData1[MAXKEYLEN];
DWORD           BHashSignLen1;
BYTE            pHashSignData2[MAXKEYLEN];
DWORD           BHashSignLen2;
HCRYPTHASH	hHash = 0;

BOOL Logon(int cArg);

BOOL TEncrypt(HCRYPTKEY hTKey, HCRYPTHASH hTHash, BOOL FinalFlag,
              DWORD dwFlags, BYTE *Tbuf, DWORD *pBLen, DWORD pdwBufLen,
              int cArg, CHAR *szAlgid, CHAR *szmode);
BOOL TDecrypt(HCRYPTKEY hTKey, HCRYPTHASH hTHash, BOOL FinalFlag,
              DWORD dwFlags, BYTE *Tbuf, DWORD *pBLen, int cArg,
              CHAR *szAlgid, CHAR *szmode);

BOOL TestRC2(int cArg, CHAR *bbuf, DWORD bsize);

BOOL TestRC4(int cArg, CHAR *bbuf, DWORD bsize);

#ifdef TEST_VERSION
BOOL TestDES(int cArg, CHAR *bbuf, DWORD bsize);
#endif

BOOL TestHash(int cArg, CHAR *bbuf, DWORD bsize);

BOOL TestExchange(int cArg, CHAR *bbuf, DWORD bsize);

BOOL Hash(int cArg, CHAR *bbuf, DWORD bsize, BYTE *pHashOut,
          DWORD *pHashLenOut,  BYTE *pSigData, DWORD *pdwSigLen, DWORD Algid);

int __cdecl main(int cArg, char *rgszArg[])
{

    // Make sure keys don't exist to start
    strcpy(pszMyName, "stress");
    CryptAcquireContext(&hMe, pszMyName, MS_DEF_PROV, PROV_RSA_FULL,
                        CRYPT_DELETEKEYSET);

    while (TRUE)
    {

        // Logon to provider
        if (Logon(cArg))
	    exit(0);

        pTmp = (BYTE *) &wRandomSize;

	while (1)
	{
            if (RCRYPT_FAILED(CryptGenRandom(hMe, 2, pTmp)))
            {
                if (cArg > 1)
	            printf("GenRandom failed = %x\n", GetLastError());
                else
                    printf("FAIL\n");
                return(TRUE);
	    }
	    if (wRandomSize != 0)
               break;
        }

	dRandom = (DWORD) (wRandomSize + (wRandomSize % 8));

	if ((bRanbuf = VirtualAlloc(0, dRandom, MEM_COMMIT |
                                      MEM_RESERVE, PAGE_READWRITE)) == 0)
        {
            if (cArg > 1)
	    {
	        printf("malloc failed = %x\n", GetLastError());
            }
	    else
                printf("malloc FAIL\n");
            return(TRUE);
        }

	if (RCRYPT_FAILED(CryptGenRandom(hMe, dRandom, bRanbuf)))
        {
            if (cArg > 1)
	        printf("GenRandom failed = %x\n", GetLastError());
	    else
                printf("FAIL\n");
            return(TRUE);
        }

	if ((bcryptbuf = VirtualAlloc(0, dRandom + 8, MEM_COMMIT |
                                      MEM_RESERVE, PAGE_READWRITE)) == 0)
	{
            if (cArg > 1)
	    {
	        printf("malloc failed = %x\n", GetLastError());
            }
	    else
                printf("malloc FAIL\n");
            return(TRUE);
        }

	if (cArg > 1)
        {
            printf("bytes generated			 %x\n", wRandomSize);
        }

        memcpy(bcryptbuf, bRanbuf, dRandom);

	if (TestRC2(cArg, bcryptbuf, dRandom))
            exit(0);

	if (TestRC4(cArg, bcryptbuf, dRandom))
            exit(0);

#ifdef TEST_VERSION
	if (TestDES(cArg, bcryptbuf, dRandom))
            exit(0);
#endif

	if (TestHash(cArg, bcryptbuf, dRandom))
            exit(0);

	if (TestExchange(cArg, bcryptbuf, dRandom))
		exit(0);

        if (VirtualFree(bRanbuf, 0, MEM_RELEASE) != TRUE)
        {
            if (cArg > 1)
	        printf("VirtulaFree failed: %x\n", GetLastError());
        }

	if (VirtualFree(bcryptbuf, 0, MEM_RELEASE) != TRUE)
        {
            if (cArg > 1)
	        printf("VirtulaFree failed: %x\n", GetLastError());
        }

        if (cArg > 1)
            printf("CryptReleaseContext		");

        if (RCRYPT_FAILED(CryptReleaseContext(hMe, 0)))
	{
	    printf("FAIL Error = %x\n", GetLastError());
            return(TRUE);
	}
	else
            if (cArg > 1)
                printf("SUCCEED\n");

        if (cArg > 1)
            printf("CryptAcquireContext Delete	");

        strcpy(pszMyName, "stress");
        if (RCRYPT_FAILED(CryptAcquireContext(&hMe, pszMyName,
                          MS_DEF_PROV, PROV_RSA_FULL, CRYPT_DELETEKEYSET)))
        {
	    if (cArg > 1)
                printf("FAIL Error = %x\n", GetLastError());
            return(FALSE);
	}
	else
	{
	    if (cArg > 1)
            {
               printf("SUCCEED\n");
               printf("\n");
            }
        }

    }

    exit(0);

}


BOOL TestExchange(int cArg, CHAR *bbuf, DWORD bsize)
{
	BYTE		ExpBuf[EXPORT_BUFFER_LEN];
	BYTE		SigBuf[UTILITY_BUF_SIZE];
	DWORD		ExpBufLen, SigBufLen;
	HCRYPTKEY	hKey2;
	HCRYPTHASH	hHash;
	PUBLICKEYSTRUC	*pPubKey;
	RSAPUBKEY	*pRSAKey;
	
//
// Generate a RC4 key
//
	
    if (RCRYPT_FAILED(CryptGenKey(hMe, CALG_RC4, CRYPT_EXPORTABLE, &hKey)))
    {
	if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else
	    printf("CryptGenKey FAIL\n");
	return(TRUE);
    }

//
// Look for our own exchange key
//

    if (RCRYPT_FAILED(CryptGetUserKey(hMe, AT_KEYEXCHANGE, &hKey2)))
    {
	    if (cArg > 1)
		    printf("cguk failed = %x", GetLastError());
	    else
		    printf("CryptGetUserKey FAIL\n");
	    return (TRUE);
    }

//
// Export it in PUBLICKEYBLOB form
//
    if (cArg > 1)
	    printf("CryptExportKey (PKB)		");

    ExpBufLen = EXPORT_BUFFER_LEN;
    if (RCRYPT_FAILED(CryptExportKey(hKey2, 0, PUBLICKEYBLOB, 0,
				     ExpBuf, &ExpBufLen)))
    {
	    if (cArg > 1)
		    printf("failed = %x", GetLastError());
	    else
		    printf("CryptExportKey FAIL\n");
	    return (TRUE);
    }

    
    if (cArg > 1)
	    printf("SUCCEED\n");

    CryptDestroyKey(hKey2);

    pPubKey = (PUBLICKEYSTRUC *)ExpBuf;
    pRSAKey = (RSAPUBKEY *)(ExpBuf + sizeof(PUBLICKEYSTRUC));

    if (pPubKey->aiKeyAlg != CALG_RSA_KEYX)
    {
	    printf("Pub key fails check\n");
	    return(TRUE);
    }
    
    if (pRSAKey->pubexp != 0x10001)
    {
	    printf("RSA key fails check\n");
	    return(TRUE);
    }
    
//
// Import it in PUBLICKEYBLOB form
//
    
    if (cArg > 1)
	    printf("CryptImportKey (PKB)		");

    if (RCRYPT_FAILED(CryptImportKey(hMe, ExpBuf, ExpBufLen, 0, 0, &hKey2)))
    {
	    if (cArg > 1)
		    printf("failed = %x", GetLastError());
	    else
		    printf("CryptImportKey FAIL\n");
	    return (TRUE);
    }

    if (cArg > 1)
	    printf("SUCCEED\n");

//
// Encrypt and Decrypt
//
    BLen = bsize;
    BLen2 = bsize + 8;
    if (TEncrypt(hKey, 0, TRUE, 0, bbuf, &BLen, BLen2, cArg, "RC4", ""))
    {
        return(TRUE);
    }

//
// Export the key in SIMPLEBLOB form
//
    
    if (cArg > 1)
	    printf("CryptExportKey			");

    ExpBufLen = EXPORT_BUFFER_LEN;
    
    if (RCRYPT_FAILED(CryptExportKey(hKey, hKey2, SIMPLEBLOB, 0,
				     ExpBuf, &ExpBufLen)))
    {
	    if (cArg > 1)
		    printf("failed = %x", GetLastError());
	    else
		    printf("CryptExportKey FAIL\n");
	    return (TRUE);
    }    

    if (cArg > 1)
	    printf("SUCCEED\n");

//
// Nuke the old key
//
    
    if (RCRYPT_FAILED(CryptDestroyKey(hKey)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyKey FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptDestroyKey(hKey2)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyKey FAIL\n");
        return(TRUE);
    }

//
// Sign the blob with the key exchange key
//

    if (cArg > 1)
	    printf("CryptCreateHash			");
    
    if (RCRYPT_FAILED(CryptCreateHash(hMe, CALG_SHA, 0, 0, &hHash)))
    {
	    if (cArg > 1)
		    printf("failed = %x", GetLastError());
	    else
		    printf("CryptCreateHash FAIL\n");
	    return (TRUE);
    }

    if (cArg > 1)
	    printf("SUCCEED\n");

    if (cArg > 1)
	    printf("CryptHashData			");
    
    if (RCRYPT_FAILED(CryptHashData(hHash, ExpBuf, ExpBufLen, 0)))
    {
	    if (cArg > 1)
		    printf("failed = %x", GetLastError());
	    else
		    printf("CryptHashData FAIL\n");
	    return (TRUE);
    }    

    if (cArg > 1)
	    printf("SUCCEED\n");

    if (cArg > 1)
	    printf("CryptSignHash (KEYX)		");

    SigBufLen = UTILITY_BUF_SIZE;
    if (RCRYPT_FAILED(CryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0,
				    SigBuf, &SigBufLen)))
    {
	    if (cArg > 1)
		    printf("failed = %x", GetLastError());
	    else
		    printf("CryptSignHash FAIL\n");
	    return (TRUE);
    }

    if (cArg > 1)
	    printf("SUCCEED\n");


    if (RCRYPT_FAILED(CryptDestroyHash(hHash)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyHash FAIL\n");
        return(TRUE);
    }

    if (cArg > 1)
	    printf("CryptCreateHash			");
    
    if (RCRYPT_FAILED(CryptCreateHash(hMe, CALG_SHA, 0, 0, &hHash)))
    {
	    if (cArg > 1)
		    printf("failed = %x", GetLastError());
	    else
		    printf("CryptCreateHash FAIL\n");
	    return (TRUE);
    }

    if (cArg > 1)
	    printf("SUCCEED\n");

    if (cArg > 1)
	    printf("CryptHashData			");
    
    if (RCRYPT_FAILED(CryptHashData(hHash, ExpBuf, ExpBufLen, 0)))
    {
	    if (cArg > 1)
		    printf("failed = %x", GetLastError());
	    else
		    printf("CryptHashData FAIL\n");
	    return (TRUE);
    }    

    if (cArg > 1)
	    printf("SUCCEED\n");

    if (RCRYPT_FAILED(CryptGetUserKey(hMe, AT_KEYEXCHANGE, &hKey2)))
    {
	    if (cArg > 1)
		    printf("cguk failed = %x", GetLastError());
	    else
		    printf("CryptGetUserKey FAIL\n");
	    return (TRUE);
    }

    if (cArg > 1)
	    printf("CryptVerifySignature (KEYX)	");
    
    if (RCRYPT_FAILED(CryptVerifySignature(hHash, SigBuf, SigBufLen, hKey2,
					   0, 0)))
    {
	    if (cArg > 1)
		    printf("failed = %x", GetLastError());
	    else
		    printf("CryptVerifySignature FAIL\n");
	    return (TRUE);
    }    

    if (cArg > 1)
	    printf("SUCCEED\n");

    if (RCRYPT_FAILED(CryptDestroyKey(hKey2)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyKey FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptDestroyHash(hHash)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyHash FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptGetUserKey(hMe, AT_KEYEXCHANGE, &hKey2)))
    {
	    if (cArg > 1)
		    printf("cguk failed = %x", GetLastError());
	    else
		    printf("CryptGetUserKey FAIL\n");
	    return (TRUE);
    }

    if (cArg > 1)
	    printf("CryptImportKey			");
    
    if (RCRYPT_FAILED(CryptImportKey(hMe, ExpBuf, ExpBufLen, 0, 0,
				     &hKey)))
    {
	    if (cArg > 1)
		    printf("failed = %x", GetLastError());
	    else
		    printf("CryptImportKey FAIL\n");
	    return (TRUE);
    }    

    if (cArg > 1)
	    printf("SUCCEED\n");

    if (RCRYPT_FAILED(CryptDestroyKey(hKey2)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyKey FAIL\n");
        return(TRUE);
    }

    if (TDecrypt(hKey, 0, TRUE, 0, bbuf, &BLen, cArg, "RC4", ""))
    {
        return(TRUE);
    }

    if (cArg > 1)
        printf("Compare data			");
    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("FAIL\n");
	return(TRUE);
    }
    if (cArg > 1)
	printf("SUCCEED\n");

    if (RCRYPT_FAILED(CryptDestroyKey(hKey)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyKey FAIL\n");
        return(TRUE);
    }

    return(FALSE);

}

BOOL TestRC2(int cArg, CHAR *bbuf, DWORD bsize)
{

//
// Generate a RC2 key
//
    if (RCRYPT_FAILED(CryptGenKey(hMe, CALG_RC2, 0, &hKey)))
    {
	if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else
	    printf("CryptGenKey FAIL\n");
	return(TRUE);
    }

//
// Encrypt and Decrypt using CBC default mode
//
    BLen = bsize;
    BLen2 = bsize + 8;
    if (TEncrypt(hKey, 0, TRUE, 0, bbuf, &BLen, BLen2, cArg, "RC2", "CBC"))
    {
        return(TRUE);
    }

    if (TDecrypt(hKey, 0, TRUE, 0, bbuf, &BLen, cArg, "RC2", "CBC"))
    {
        return(TRUE);
    }

    if (cArg > 1)
        printf("Compare data			");
    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("FAIL\n");
	return(TRUE);
    }
    if (cArg > 1)
	printf("SUCCEED\n");

//
// Change mode to ECB
//
    *pData = CRYPT_MODE_ECB;

    if (RCRYPT_FAILED(CryptSetKeyParam(hKey, KP_MODE, pData, 0)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else
	    printf("CryptSetKeyParam FAIL\n");
        return(TRUE);
    }

    BLen = bsize;
    BLen2 = bsize + 8;
    if (TEncrypt(hKey, 0, TRUE, 0, bbuf, &BLen, BLen2, cArg, "RC2", "ECB"))
    {
        return(TRUE);
    }

    if (TDecrypt(hKey, 0, TRUE, 0, bbuf, &BLen, cArg, "RC2", "ECB"))
    {
        return(TRUE);
    }

    if (cArg > 1)
        printf("Compare data			");
    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("FAIL\n");
	return(TRUE);
    }
    if (cArg > 1)
	printf("SUCCEED\n");

//
// Change mode to CFB
//
    *pData = CRYPT_MODE_CFB;

    if (RCRYPT_FAILED(CryptSetKeyParam(hKey, KP_MODE, pData, 0)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else
	    printf("CryptSetKeyParam FAIL\n");
        return(TRUE);
    }

    BLen = bsize;
    BLen2 = bsize + 8;
    if (TEncrypt(hKey, 0, TRUE, 0, bbuf, &BLen, BLen2, cArg, "RC2", "CFB"))
    {
        return(TRUE);
    }

    if (TDecrypt(hKey, 0, TRUE, 0, bbuf, &BLen, cArg, "RC2", "CFB"))
    {
        return(TRUE);
    }

    if (cArg > 1)
        printf("Compare data			");
    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("FAIL\n");
	return(TRUE);
    }
    if (cArg > 1)
	printf("SUCCEED\n");

    if (RCRYPT_FAILED(CryptDestroyKey(hKey)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyKey FAIL\n");
        return(TRUE);
    }

    return(FALSE);

}


BOOL TestRC4(int cArg, CHAR *bbuf, DWORD bsize)
{

//
// Generate a RC4 key
//
	
    if (RCRYPT_FAILED(CryptGenKey(hMe, CALG_RC4, 0, &hKey)))
    {
	if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else
	    printf("CryptGenKey FAIL\n");
	return(TRUE);
    }

//
// Encrypt and Decrypt
//
    BLen = bsize;
    BLen2 = bsize + 8;
    if (TEncrypt(hKey, 0, TRUE, 0, bbuf, &BLen, BLen2, cArg, "RC4", ""))
    {
        return(TRUE);
    }

    if (TDecrypt(hKey, 0, TRUE, 0, bbuf, &BLen, cArg, "RC4", ""))
    {
        return(TRUE);
    }

    if (cArg > 1)
        printf("Compare data			");
    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("FAIL\n");
	return(TRUE);
    }
    if (cArg > 1)
	printf("SUCCEED\n");

    if (RCRYPT_FAILED(CryptDestroyKey(hKey)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyKey FAIL\n");
        return(TRUE);
    }

    return(FALSE);

}

#ifdef TEST_VERSION
BOOL TestDES(int cArg, CHAR *bbuf, DWORD bsize)
{

//
// Generate a DES key
//
    if (RCRYPT_FAILED(CryptGenKey(hMe, CALG_DES, 0, &hKey)))
    {
	if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else
	    printf("CryptGenKey FAIL\n");
	return(TRUE);
    }

//
// Encrypt and Decrypt using CBC default mode
//
    BLen = bsize;
    BLen2 = bsize + 8;
    if (TEncrypt(hKey, 0, TRUE, 0, bbuf, &BLen, BLen2, cArg, "DES", "CBC"))
    {
        return(TRUE);
    }

    if (TDecrypt(hKey, 0, TRUE, 0, bbuf, &BLen, cArg, "DES", "CBC"))
    {
        return(TRUE);
    }

    if (cArg > 1)
        printf("Compare data			");
    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("FAIL\n");
	return(TRUE);
    }
    if (cArg > 1)
	printf("SUCCEED\n");

//
// Change mode to ECB
//
    *pData = CRYPT_MODE_ECB;

    if (RCRYPT_FAILED(CryptSetKeyParam(hKey, KP_MODE, pData, 0)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else
	    printf("CryptSetKeyParam FAIL\n");
        return(TRUE);
    }

    BLen = bsize;
    BLen2 = bsize + 8;
    if (TEncrypt(hKey, 0, TRUE, 0, bbuf, &BLen, BLen2, cArg, "DES", "ECB"))
    {
        return(TRUE);
    }

    if (TDecrypt(hKey, 0, TRUE, 0, bbuf, &BLen, cArg, "DES", "ECB"))
    {
        return(TRUE);
    }

    if (cArg > 1)
        printf("Compare data			");
    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("FAIL\n");
	return(TRUE);
    }
    if (cArg > 1)
	printf("SUCCEED\n");

//
// Change mode to CFB
//
    *pData = CRYPT_MODE_CFB;

    if (RCRYPT_FAILED(CryptSetKeyParam(hKey, KP_MODE, pData, 0)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else
	    printf("CryptSetKeyParam FAIL\n");
        return(TRUE);
    }

    BLen = bsize;
    BLen2 = bsize + 8;
    if (TEncrypt(hKey, 0, TRUE, 0, bbuf, &BLen, BLen2, cArg, "DES", "CFB"))
    {
        return(TRUE);
    }

    if (TDecrypt(hKey, 0, TRUE, 0, bbuf, &BLen, cArg, "DES", "CFB"))
    {
        return(TRUE);
    }

    if (cArg > 1)
        printf("Compare data			");
    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("FAIL\n");
	return(TRUE);
    }
    if (cArg > 1)
	printf("SUCCEED\n");

    if (RCRYPT_FAILED(CryptDestroyKey(hKey)))
    {
        if (cArg > 1)
	    printf("failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyKey FAIL\n");
        return(TRUE);
    }

    return(FALSE);

}
#endif


BOOL TestHash(int cArg, CHAR *bbuf, DWORD bsize)
{

    if (cArg > 1)
        printf("Hash, compare with MD4 & MD5	");

    BHashLen1 = 50;
    BHashSignLen1 = MAXKEYLEN;
    if (Hash(cArg, bbuf, bsize, pHashData1, &BHashLen1, pHashSignData1,
             &BHashSignLen1, CALG_MD4))
    {
        return(TRUE);
    }

    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("Data corrupted check 1 in Hash test\n");
	return(TRUE);
    }

    BHashLen2 = 50;
    BHashSignLen2 = MAXKEYLEN;
    if (Hash(cArg, bbuf, bsize, pHashData2, &BHashLen2, pHashSignData2,
             &BHashSignLen2, CALG_MD4))
    {
        return(TRUE);
    }

    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("Data corrupted check 2 in Hash test\n");
	return(TRUE);
    }

    if (BHashLen1 != BHashLen2)
    {
	printf("Hash lengths don't match MD4 FAIL\n");
	return(TRUE);
    }

    if (memcmp(pHashData1, pHashData2, BHashLen1) != 0)
    {
	printf("Hash data doesn't compare MD4 FAIL\n");
	return(TRUE);
    }

    if (BHashSignLen1 != BHashSignLen2)
    {
	printf("Hash signatures lengths don't match MD4 FAIL\n");
	return(TRUE);
    }

    if (memcmp(pHashSignData1, pHashSignData2, BHashLen1) != 0)
    {
	printf("Hash signature data doesn't compare MD4 FAIL\n");
	return(TRUE);
    }

    BHashLen1 = 50;
    BHashSignLen1 = MAXKEYLEN;
    if (Hash(cArg, bbuf, bsize, pHashData1, &BHashLen1, pHashSignData1,
             &BHashSignLen1, CALG_MD5))
    {
        return(TRUE);
    }

    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("Data corrupted check 3 in Hash test\n");
	return(TRUE);
    }

    BHashLen2 = 50;
    BHashSignLen2 = MAXKEYLEN;
    if (Hash(cArg, bbuf, bsize, pHashData2, &BHashLen2, pHashSignData2,
             &BHashSignLen2, CALG_MD5))
    {
        return(TRUE);
    }

    if (memcmp(bbuf, bRanbuf, bsize) != 0)
    {
	printf("Data corrupted check 4 in Hash test\n");
	return(TRUE);
    }

    if (BHashLen1 != BHashLen2)
    {
	printf("Hash lengths don't match MD5 FAIL\n");
	return(TRUE);
    }

    if (memcmp(pHashData1, pHashData2, BHashLen1) != 0)
    {
	printf("Hash data doesn't compare MD5 FAIL\n");
	return(TRUE);
    }

    if (BHashSignLen1 != BHashSignLen2)
    {
	printf("Hash signatures lengths don't match MD5 FAIL\n");
	return(TRUE);
    }

    if (memcmp(pHashSignData1, pHashSignData2, BHashSignLen1) != 0)
    {
	printf("Hash signature data doesn't compare MD5 FAIL\n");
	return(TRUE);
    }

    if (cArg > 1)
	printf("SUCCEED\n");

    return(FALSE);
    
}


BOOL Hash(int cArg, CHAR *bbuf, DWORD bsize, BYTE *pHashOut,
          DWORD *pHashLenOut, BYTE *pSigData, DWORD *pdwSigLen, DWORD Algid)
{

    if (RCRYPT_FAILED(CryptCreateHash(hMe, Algid, 0, 0, &hHash)))
    {
        if (cArg > 1)
	    printf("CryptCreateHash failed = %x\n", GetLastError());
	else 
	    printf("CryptCreateHash FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptHashData(hHash, bbuf, bsize, 0)))
    {
        if (cArg > 1)
	    printf("CryptUpDataHash failed = %x\n", GetLastError());
	else 
	    printf("CryptHashData FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptSignHash(hHash, AT_SIGNATURE, 0, 0, pSigData,
	              pdwSigLen)))
    {
        if (cArg > 1)
	    printf("CryptSignHash failed = %x\n", GetLastError());
	else 
	    printf("CryptSignHash FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptDestroyHash(hHash)))
    {
        if (cArg > 1)
	    printf("CryptDestroyHash failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyHash FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptCreateHash(hMe, Algid, 0, 0, &hHash)))
    {
        if (cArg > 1)
	    printf("CryptCreateHash failed = %x\n", GetLastError());
	else 
	    printf("CryptCreateHash FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptHashData(hHash, bbuf, bsize, 0)))
    {
        if (cArg > 1)
	    printf("CryptUpDataHash failed = %x\n", GetLastError());
	else 
	    printf("CryptHashData FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptGetUserKey(hMe, AT_SIGNATURE, &hKey2)))
    {
	    if (cArg > 1)
		    printf("cguk failed = %x", GetLastError());
	    else
		    printf("CryptGetUserKey FAIL\n");
	    return (TRUE);
    }

    if (RCRYPT_FAILED(CryptVerifySignature(hHash, pSigData, *pdwSigLen,
                                           hKey2, 0, 0)))
    {
        if (cArg > 1)
	    printf("CryptVerifySignature failed = %x\n", GetLastError());
	else 
	    printf("CryptVerifySignature FAIL\n");
        return(TRUE);
    }



    if (RCRYPT_FAILED(CryptDestroyKey(hKey2)))
    {
        if (cArg > 1)
	    printf("CryptDestroyKey failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyKey FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptDestroyHash(hHash)))
    {
        if (cArg > 1)
	    printf("CryptDestroyHash failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyHash FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptCreateHash(hMe, Algid, 0, 0, &hHash)))
    {
        if (cArg > 1)
	    printf("CryptCreateHash failed = %x\n", GetLastError());
	else 
	    printf("CryptCreateHash FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptHashData(hHash, bbuf, bsize, 0)))
    {
        if (cArg > 1)
	    printf("CryptUpDataHash failed = %x\n", GetLastError());
	else 
	    printf("CryptHashData FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptGetHashParam(hHash, HP_HASHVAL, pHashOut,
	              pHashLenOut, 0)))
    {
        if (cArg > 1)
	    printf("CryptGetHashParam failed = %x\n", GetLastError());
	else 
	    printf("CryptGetHashParam FAIL\n");
        return(TRUE);
    }

    if (RCRYPT_FAILED(CryptDestroyHash(hHash)))
    {
        if (cArg > 1)
	    printf("CryptDestroyHash failed = %x\n", GetLastError());
	else 
	    printf("CryptDestroyHash FAIL\n");
        return(TRUE);
    }

    return(FALSE);

}


BOOL Logon(int cArg)
{

	strcpy(pszMyName, "stress");

        if (cArg > 1)
            printf("CryptAcquireContext		");

        if (RCRYPT_FAILED(CryptAcquireContext(&hMe, pszMyName,
                          MS_DEF_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET)))
        {
	    if (cArg > 1)
                printf("FAIL Error = %x\n", GetLastError());
            return(TRUE);
	}
	else
	{
	if (cArg > 1)
           printf("SUCCEED\n");
        }

        if (cArg > 1)
            printf("CryptGenKeys			");

        if (RCRYPT_FAILED(CryptGenKey(hMe, CALG_RSA_SIGN,
                                          CRYPT_EXPORTABLE, &hClientKey)))
        {
	    if (cArg > 1)
                printf("FAIL Error = %x\n", GetLastError());
	    return(TRUE);
	}

        CryptDestroyKey(hClientKey);

        if (RCRYPT_FAILED(CryptGenKey(hMe, CALG_RSA_KEYX,
                                          CRYPT_EXPORTABLE, &hClientKey)))
        {
	    if (cArg > 1)
                printf("FAIL Error = %x\n", GetLastError());
	    return(TRUE);
	}
	if (cArg > 1)
            printf("SUCCEED\n");

        CryptDestroyKey(hClientKey);

	return(FALSE);

}



BOOL TEncrypt(HCRYPTKEY hTKey, HCRYPTHASH hTHash, BOOL FinalFlag,
              DWORD dwFlags, BYTE *Tbuf, DWORD *pBLen, DWORD pdwBufLen,
              int cArg, CHAR *szAlgid, CHAR *szmode)
{
        if (cArg > 1)
            printf("CryptEncrypt %s-%s		", szAlgid, szmode);
	if (RCRYPT_FAILED(CryptEncrypt(hTKey, hTHash, FinalFlag, dwFlags,
                                       Tbuf, pBLen, pdwBufLen)))
	{
            if (cArg > 1)
	        printf("failed = %x\n", GetLastError());
	    else 
	        printf("CryptEncrypt FAIL\n");
            return(TRUE);
	}
        if (cArg > 1)
	    printf("SUCCEED\n");

        return(FALSE);

}


BOOL TDecrypt(HCRYPTKEY hTKey, HCRYPTHASH hTHash, BOOL FinalFlag,
              DWORD dwFlags, BYTE *Tbuf, DWORD *pBLen, int cArg,
              CHAR *szAlgid, CHAR *szmode)
{

        if (cArg > 1)
            printf("CryptDecrypt %s-%s		", szAlgid, szmode);
	if (RCRYPT_FAILED(CryptDecrypt(hTKey, hTHash, FinalFlag, dwFlags,
                                       Tbuf, pBLen)))
	{
            if (cArg > 1)
	        printf("failed = %x\n", GetLastError());
	    else 
	        printf("CryptDecrypt FAIL\n");
            return(TRUE);
	}
        if (cArg > 1)
	    printf("SUCCEED\n");

        return(FALSE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\randlib\cpu.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cpu.h

Abstract:

    Read CPU specifics performance counters.

Author:

    Scott Field (sfield)    24-Sep-98

--*/

#ifndef __CPU_H__
#define __CPU_H__

unsigned int
GatherCPUSpecificCounters(
    IN      unsigned char *pbCounterState,
    IN  OUT unsigned long *pcbCounterState
    );


#endif  // __CPU_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\randlib\cpu.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cpu.c

Abstract:

    Read CPU specifics performance counters.

Author:

    Scott Field (sfield)    24-Sep-98

--*/

#ifndef KMODE_RNG

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#else

#include <ntifs.h>
#include <windef.h>

#endif  // KMODE_RNG

#include "cpu.h"


unsigned int
GatherCPUSpecificCountersPrivileged(
    IN      unsigned char *pbCounterState,
    IN  OUT unsigned long *pcbCounterState
    );


#define X86_CAPS_RDTSC  0x01
#define X86_CAPS_RDMSR  0x02
#define X86_CAPS_RDPMC  0x04

VOID
X86_GetCapabilities(
    IN  OUT BYTE *pbCapabilities
    );

VOID
X86_ReadRDTSC(
    IN      PLARGE_INTEGER prdtsc   // RDTSC
    );

VOID
X86_ReadRDMSR(
    IN      PLARGE_INTEGER pc0,     // counter0
    IN      PLARGE_INTEGER pc1      // counter1
    );

VOID
X86_ReadRDPMC(
    IN      PLARGE_INTEGER pc0,     // counter0
    IN      PLARGE_INTEGER pc1      // counter1
    );


#ifdef KMODE_RNG

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, GatherCPUSpecificCounters)
#pragma alloc_text(PAGE, GatherCPUSpecificCountersPrivileged)

#ifdef _X86_
#pragma alloc_text(PAGE, X86_ReadRDTSC)
#pragma alloc_text(PAGE, X86_ReadRDMSR)
#pragma alloc_text(PAGE, X86_ReadRDPMC)
#pragma alloc_text(PAGE, X86_GetCapabilities)
#endif  // _X86_

#endif  // ALLOC_PRAGMA
#endif  // KMODE_RNG




unsigned int
GatherCPUSpecificCounters(
    IN      unsigned char *pbCounterState,
    IN  OUT unsigned long *pcbCounterState
    )
{

#ifndef KMODE_RNG

    //
    // NT5 doesn't set CR4.PCE by default, so don't bother trying for usermode.
    //

    return FALSE;

#else

    PAGED_CODE();

    //
    // kernel mode version of library: just call the privileged routine directly.
    // user mode version of library: try privileged routine first, if it fails, use
    // device driver provided interface.
    //

    if( pbCounterState == NULL || pcbCounterState == NULL )
        return FALSE;

    return GatherCPUSpecificCountersPrivileged( pbCounterState, pcbCounterState );

#endif

}

unsigned int
GatherCPUSpecificCountersPrivileged(
    IN      unsigned char *pbCounterState,
    IN  OUT unsigned long *pcbCounterState
    )
/*++

    we are at ring0 in kernel mode, so we can issue the privileges CPU
    instructions directly.  Note that this routine also serves as the
    core code which is executed by the ksecdd.sys device driver for user
    mode clients.
    This call can also be made directly in usermode by certain CPUs,
    or when certain CPUs are configured to allow such calls from ring3.

--*/
{

#ifdef _X86_
    PLARGE_INTEGER prdtsc;
    PLARGE_INTEGER pc0;
    PLARGE_INTEGER pc1;

    DWORD cbCounters;
    BYTE ProcessorCaps;
#endif  // _X86_


#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

#ifdef _X86_



    cbCounters = 3 * sizeof( LARGE_INTEGER ) ;

    if( *pcbCounterState < cbCounters ) {
        *pcbCounterState = cbCounters;
        return FALSE;
    }

    cbCounters = 0;


    prdtsc = (PLARGE_INTEGER)pbCounterState;
    pc0 = prdtsc + 1;
    pc1 = pc0 + 1;


    //
    // make the initial determination about what the countertype is in this
    // system.
    // in theory, this could be cached, but things get a little complicated
    // in an SMP machine -- we'd have to track caps across all processors
    // to be correct.  Since we don't really care about perf, just check the
    // caps every time.
    //

    __try {
        X86_GetCapabilities( &ProcessorCaps );
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        ProcessorCaps = 0;
        ; // swallow exception
    }

    //
    // wrap the query in a try/except.  This is just paranoia.  Since we aren't
    // particularly interested in the values of the perf counters for the normal
    // (eg: perfmon) reasons, introducing the extra overhead of try/except is
    // of no relevance to us.
    // note that in the case of the p6, we could be calling this from usermode,
    // and CR4.PCE could be toggled which could cause subsequent AV(s).
    // In theory, the KMODE build could avoid the try/except, but there is a
    // remote possiblity the code above which makes the initial countertype
    // determination may not be supported on every installed processor in a
    // SMP machine.  The cost of try/except is well worth avoiding the possibility
    // of a access violation / bluescreen in usermode vs. kernel mode respectively.
    //

    if( ProcessorCaps & X86_CAPS_RDTSC ) {
        __try {
            X86_ReadRDTSC( prdtsc );
            cbCounters += sizeof( LARGE_INTEGER );
        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            ; // swallow exception.
        }
    }

    if( ProcessorCaps & X86_CAPS_RDPMC ) {
        __try {
            X86_ReadRDPMC( pc0, pc1 );
            cbCounters += (2*sizeof( LARGE_INTEGER ));
        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            ; // swallow exception.
        }
    }
#ifdef KMODE_RNG
    else if ( ProcessorCaps & X86_CAPS_RDMSR ) {
        __try {
            X86_ReadRDMSR( pc0, pc1 );
            cbCounters += (2*sizeof( LARGE_INTEGER ));
        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            ; // swallow exception.
        }
    }
#endif  // KMODE_RNG

    *pcbCounterState = cbCounters;
    return TRUE;

#else   // _X86_


    //
    // no non-x86 counter handling code at this time.
    //

    return FALSE;

#endif

}

#ifdef _X86_

VOID
X86_ReadRDTSC(
    IN      PLARGE_INTEGER prdtsc   // RDTSC
    )
{
    DWORD prdtscLow ;
    DWORD prdtscHigh ;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    __asm {
        push    eax
        push    ecx
        push    edx

        // RDTSC

        _emit   0fh
        _emit   31h
        mov     prdtscLow, eax
        mov     prdtscHigh, edx

        pop     edx
        pop     ecx
        pop     eax
    }

    prdtsc->LowPart = prdtscLow;
    prdtsc->HighPart = prdtscHigh;

}

VOID
X86_ReadRDMSR(
    IN      PLARGE_INTEGER pc0,     // counter0
    IN      PLARGE_INTEGER pc1      // counter1
    )
{
    DWORD pc0Low ;
    DWORD pc0High ;
    DWORD pc1Low ;
    DWORD pc1High ;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    __asm {
        push    eax
        push    ecx
        push    edx

        // RDMSR counter0

        mov     ecx, 12h
        _emit   0fh
        _emit   32h
        mov     pc0Low, eax
        mov     pc0High, edx

        // RDMSR counter1

        mov     ecx, 13h
        _emit   0fh
        _emit   32h
        mov     pc1Low, eax
        mov     pc1High, edx

        pop     edx
        pop     ecx
        pop     eax
    }

    pc0->LowPart = pc0Low;
    pc0->HighPart = pc0High;
    pc1->LowPart = pc1Low;
    pc1->HighPart = pc1High;

}

VOID
X86_ReadRDPMC(
    IN      PLARGE_INTEGER pc0,     // counter0
    IN      PLARGE_INTEGER pc1      // counter1
    )
{
    DWORD pc0Low ;
    DWORD pc0High ;
    DWORD pc1Low ;
    DWORD pc1High ;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    __asm {
        push    eax
        push    ecx
        push    edx

        // RDPMC executes from ring3 if CR4.PCE is set, otherwise, runs from ring0 only.

        // RDPMC counter0

        xor     ecx, ecx
        _emit   0fh
        _emit   33h
        mov     pc0Low, eax
        mov     pc0High, edx

        // RDPMC counter1

        mov     ecx, 1
        _emit   0fh
        _emit   33h
        mov     pc1Low, eax
        mov     pc1High, edx

        pop     edx
        pop     ecx
        pop     eax
    }

    pc0->LowPart = pc0Low;
    pc0->HighPart = pc0High;
    pc1->LowPart = pc1Low;
    pc1->HighPart = pc1High;

}

#if _MSC_FULL_VER >= 13008827 && defined(_M_IX86)
#pragma warning(push)
#pragma warning(disable:4731)			// EBP modified with inline asm
#endif

VOID
X86_GetCapabilities(
    IN  OUT BYTE *pbCapabilities
    )
{
    DWORD dwLevels;
    DWORD dwStdFeatures;
    DWORD dwVersionInfo;
    DWORD Family;
    DWORD Model;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    *pbCapabilities = 0;

    __asm {

        push    eax
        push    ecx
        push    ebx
        push    edx
        push    edi
        push    esi
        push    ebp
        xor     eax, eax
        _emit   0x0f
        _emit   0xa2
        mov     dwLevels, eax
        pop     ebp
        pop     esi
        pop     edi
        pop     edx
        pop     ebx
        pop     ecx
        pop     eax
    }

    if( dwLevels == 0 )
        return;


    //
    // try CPUID at level1 to get standard features.
    //

    __asm {

        push    eax
        push    ecx
        push    ebx
        push    edx
        push    edi
        push    esi
        push    ebp
        mov     eax, 1
        _emit   0x0f
        _emit   0xa2
        mov     dwVersionInfo, eax
        mov     dwStdFeatures, edx
        pop     ebp
        pop     esi
        pop     edi
        pop     edx
        pop     ebx
        pop     ecx
        pop     eax
    }


    //
    // determine if RDTSC supported.
    //

    if( dwStdFeatures & 0x10 ) {
        *pbCapabilities |= X86_CAPS_RDTSC;
    }

    Model = (dwVersionInfo >> 4) & 0xf;
    Family = (dwVersionInfo >> 8) & 0xf;

// AMD K6-2 model 8 proved buggy and left interrupts disabled during RDMSR

#if 0

    //
    // determine if RDMSR supported.
    //

    if( dwStdFeatures & 0x20 && (Model == 1 || Model == 2) ) {
        *pbCapabilities |= X86_CAPS_RDMSR;
    }

    //
    // extract family, > pentium (family5) supports RDPMC
    //

    if( Family > 5 ) {
        *pbCapabilities |= X86_CAPS_RDPMC;
    }
#endif

}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


#endif  // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\randlib\circhash.c ===
// Circular hash code.
//
// This code implements a circular hash algorithm, intended as a variable
// length hash function that is fast to update. (The hash function will be
// called many times.)  This is done by SHA-1'ing each of the inputs, then
// circularly XORing this value into a buffer.

#ifndef KMODE_RNG

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#else

#include <ntifs.h>
#include <windef.h>

#endif  // KMODE_RNG

#include <sha.h>
#include <md4.h>

#include "circhash.h"


#ifdef KMODE_RNG
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, InitCircularHash)
#pragma alloc_text(PAGE, DestroyCircularHash)
#pragma alloc_text(PAGE, GetCircularHashValue)
#pragma alloc_text(PAGE, UpdateCircularHash)
#endif  // ALLOC_PRAGMA
#endif  // KMODE_RNG


//
// internal state flags
//

#define CH_INVALID_HASH_CTXT    0
#define CH_VALID_HASH_CTXT      0x1423

BOOL
InitCircularHash(
    IN      CircularHash *NewHash,
    IN      DWORD dwUpdateInc,
    IN      DWORD dwAlgId,
    IN      DWORD dwMode
    )
{

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    if (NULL == NewHash)
        return FALSE;

    NewHash->dwCircHashVer = CH_VALID_HASH_CTXT;
    NewHash->dwCircSize = sizeof(NewHash->CircBuf);
    NewHash->dwMode = dwMode;
    NewHash->dwCircInc = dwUpdateInc;
    NewHash->dwCurCircPos = 0;
    NewHash->dwAlgId = dwAlgId;

    return TRUE;
}

VOID
DestroyCircularHash(
    IN      CircularHash *OldHash
    )
{
#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    if ((NULL == OldHash) || (CH_VALID_HASH_CTXT != OldHash->dwCircHashVer))
        return;

    RtlZeroMemory( OldHash, sizeof( *OldHash ) );
}

BOOL
GetCircularHashValue(
    IN      CircularHash *CurrentHash,
        OUT BYTE **ppbHashValue,
        OUT DWORD *pcbHashValue
        )
{
#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    if ((NULL == CurrentHash) || (CH_VALID_HASH_CTXT != CurrentHash->dwCircHashVer))
        return FALSE;

    *ppbHashValue = CurrentHash->CircBuf;
    *pcbHashValue = CurrentHash->dwCircSize;

    return TRUE;
}

BOOL
UpdateCircularHash(
    IN      CircularHash *CurrentHash,
    IN      VOID *pvData,
    IN      DWORD cbData
    )
{
    A_SHA_CTX   shaCtx;
    MD4_CTX     md4Ctx;
    BYTE        LocalResBuf[A_SHA_DIGEST_LEN];
    PBYTE       pHash;
    DWORD       dwHashSize;
    DWORD       i, j;

    PBYTE       pbCircularBuffer;
    DWORD       cbCircularBuffer;
    DWORD       cbCircularPosition;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG


    if ((NULL == CurrentHash) || (CH_VALID_HASH_CTXT != CurrentHash->dwCircHashVer))
        return FALSE;

    pbCircularBuffer = CurrentHash->CircBuf;
    cbCircularBuffer = CurrentHash->dwCircSize;
    cbCircularPosition = CurrentHash->dwCurCircPos;

    //
    // First, hash in the result
    //

    if( CurrentHash->dwAlgId == CH_ALG_MD4 ) {

        dwHashSize = MD4DIGESTLEN;

        MD4Init(&md4Ctx);
        MD4Update(&md4Ctx, (unsigned char*)pvData, cbData);

        if (CurrentHash->dwMode & CH_MODE_FEEDBACK)
        {
            MD4Update(&md4Ctx, pbCircularBuffer, cbCircularBuffer);
        }

        MD4Final(&md4Ctx);
        pHash = md4Ctx.digest;

    } else {

        dwHashSize = A_SHA_DIGEST_LEN;

        A_SHAInit(&shaCtx);
        A_SHAUpdateNS(&shaCtx, (unsigned char*)pvData, cbData);

        if (CurrentHash->dwMode & CH_MODE_FEEDBACK)
        {
            A_SHAUpdateNS(&shaCtx, pbCircularBuffer, cbCircularBuffer);
        }

        A_SHAFinalNS(&shaCtx, LocalResBuf);
        pHash = LocalResBuf;
    }

    //
    // Now, XOR this into the circular buffer
    //

    //
    // this is a slow way of doing this (byte at time, versus DWORD/DWORD64),
    // but it'll work for now...
    //    In most cases, we can assume we'll wrap once, but let's keep it general for now.
    //

    j = cbCircularPosition;

    for( i = 0 ; i < dwHashSize ; i++ )
    {
        if (j >= cbCircularBuffer)
            j = 0;

        pbCircularBuffer[j] ^= pHash[i];

        j++;
    }

    //
    // Update.  Since dwCircInc should be relatively prime to dwCircSize, this
    // should result in the pointer continually cycling through dwCircSize values.
    //

    CurrentHash->dwCurCircPos = (cbCircularPosition + CurrentHash->dwCircInc)
                                     % cbCircularBuffer;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\randlib\rc4safe.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    rc4safe.c

Abstract:

    access rc4 key material in thread safe manner, without adversly affecting
    performance of multi-thread users.

Author:

    Scott Field (sfield)    02-Jul-99

--*/

#ifndef KMODE_RNG

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <zwapi.h>

#else

#include <ntosp.h>
#include <windef.h>

#endif  // KMODE_RNG


#include <rc4.h>
#include <randlib.h>

#include "umkm.h"




typedef struct {
    unsigned int    BytesUsed;  // bytes processed for key associated with this entry
    __LOCK_TYPE     lock;       // lock for serializing key entry
    RC4_KEYSTRUCT   rc4key;     // key material associated with this entry
} RC4_SAFE, *PRC4_SAFE, *LPRC4_SAFE;


typedef enum _MemoryMode {
    Paged = 1,
    NonPaged
} MemoryMode;


typedef struct {
    unsigned int    Entries;    // count of array entries.
    MemoryMode      Mode;       // allocation & behavior mode of SAFE_ARRAY
    RC4_SAFE        *Array[];   // array of pointers to RC4_SAFE entries.
} RC4_SAFE_ARRAY, *PRC4_SAFE_ARRAY, *LPRC4_SAFE_ARRAY;




//
// !!! RC4_SAFE_ENTRIES must be even multiple of 4 !!!
//

#ifndef KMODE_RNG
#define RC4_SAFE_ENTRIES    (8)
#else
//
// we don't expect as much traffic in kernel mode, so use less resources.
//
#define RC4_SAFE_ENTRIES    (4)
#endif





#ifdef KMODE_RNG

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, rc4_safe_select)
#pragma alloc_text(PAGE, rc4_safe)
#pragma alloc_text(PAGE, rc4_safe_key)
#pragma alloc_text(PAGE, rc4_safe_select)
#pragma alloc_text(PAGE, rc4_safe_startup)
#pragma alloc_text(PAGE, rc4_safe_shutdown)

#endif  // ALLOC_PRAGMA
#endif  // KMODE_RNG



void
rc4_safe_select(
    IN      void *pContext,
    OUT     unsigned int *pEntry,
    OUT     unsigned int *pBytesUsed
    )
/*++

Routine Description:

    key selector:  choose a thread safe key.
    outputs key identifier and bytes used with key.

--*/
{
    RC4_SAFE_ARRAY *pRC4SafeArray;
    RC4_SAFE *pRC4Safe;

    static unsigned int circular;
    unsigned int local;


#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    pRC4SafeArray = (RC4_SAFE_ARRAY*)pContext;


//
// there are 2 ways to increment the array selector:
// 1. Just increment the pointer.  On a multi-processor system,
//    with multiple threads calling rc4_safe_select simultaneously,
//    this can lead to several threads selecting the same array element.
//    This will lead to lock contention on the array element lock.
//    Currently, we've decided this scenario will be fairly rare, so the
//    penalty associated with option 2 is avoided.
// 2. Use InterlockedIncrement to determine the array element.  This would
//    yield no collision on an array element, hence no lock contention
//    on the embedded array lock.  This introduces additional bus traffic
//    on SMP machines due to the lock primitive.
//
//

#ifdef KMODE_RNG

    local = (unsigned int)InterlockedIncrement( (PLONG)&circular );

#else

    circular++;
    local = circular;

#endif  // KMODE_RNG


    //
    // array index will not wrap.
    //

    local &= ( pRC4SafeArray->Entries-1 );
    pRC4Safe = pRC4SafeArray->Array[local];

    *pEntry = local;
    *pBytesUsed = pRC4Safe->BytesUsed;
}


#ifdef KMODE_RNG

void
rc4_safe_select_np(
    IN      void *pContext,
    OUT     unsigned int *pEntry,
    OUT     unsigned int *pBytesUsed
    )
/*++

Routine Description:

    Non-paged, high-IRQL version of rc4_safe_select()

--*/
{
    RC4_SAFE_ARRAY *pRC4SafeArray;
    RC4_SAFE *pRC4Safe;
    unsigned int local;

    pRC4SafeArray = (RC4_SAFE_ARRAY*)pContext;

    if( *pEntry == 0 ) {

        if( pRC4SafeArray->Entries == 1 ) {
            local = 0;
        } else {
            static unsigned int circular;

            local = (unsigned int)InterlockedIncrement( (PLONG)&circular );

            //
            // array index will not wrap.
            //

            local = (local % pRC4SafeArray->Entries);
        }

    } else {

        local = KeGetCurrentProcessorNumber();
    }

    pRC4Safe = pRC4SafeArray->Array[local];
    *pEntry = local;
    *pBytesUsed = pRC4Safe->BytesUsed;
}


#endif  // KMODE_RNG



void
rc4_safe(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      void *pv
    )
/*++

Routine Description:

    Initializes the rc4 key identified by the Entry index.

    Input key material is pv, of size cb.

--*/
{
    RC4_SAFE_ARRAY *pRC4SafeArray;
    RC4_SAFE *pRC4Safe;

#ifdef KMODE_RNG
    KIRQL OldIrql;

    PAGED_CODE();
#endif  // KMODE_RNG

    pRC4SafeArray = (RC4_SAFE_ARRAY*)pContext;

    Entry &= ( pRC4SafeArray->Entries - 1 );
    pRC4Safe = pRC4SafeArray->Array[ Entry ];

    ENTER_LOCK( &(pRC4Safe->lock) );

    rc4( &(pRC4Safe->rc4key), cb, (unsigned char*) pv );
    pRC4Safe->BytesUsed += cb;

    LEAVE_LOCK( &(pRC4Safe->lock) );

}

#ifdef KMODE_RNG

void
rc4_safe_np(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      void *pv
    )
/*++

Routine Description:

    Non-paged, high IRQL version of rc4_safe()

--*/
{
    RC4_SAFE_ARRAY *pRC4SafeArray;
    RC4_SAFE *pRC4Safe;

    pRC4SafeArray = (RC4_SAFE_ARRAY*)pContext;

    // NOTE:
    // we ignore the Entry parameter.
    // future consideration may be ignore only when Entry == 0xffffffff
    // but, this would only be perf penalty currently.
    //

    Entry = KeGetCurrentProcessorNumber();

    pRC4Safe = pRC4SafeArray->Array[ Entry ];

    rc4( &(pRC4Safe->rc4key), cb, (unsigned char*) pv );
    pRC4Safe->BytesUsed += cb;

}

#endif // KMODE_RNG

void
rc4_safe_key(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      const void *pv
    )
/*++

Routine Description:

    Initializes the rc4 key identified by the Entry index.

    Input key material is pv, of size cb.

--*/
{
    RC4_SAFE_ARRAY *pRC4SafeArray;
    RC4_SAFE *pRC4Safe;

#ifdef KMODE_RNG
    KIRQL OldIrql;

    PAGED_CODE();
#endif  // KMODE_RNG

    pRC4SafeArray = (RC4_SAFE_ARRAY*)pContext;


    Entry &= ( pRC4SafeArray->Entries - 1 );
    pRC4Safe = pRC4SafeArray->Array[ Entry ];

    ENTER_LOCK( &(pRC4Safe->lock) );

    rc4_key( &(pRC4Safe->rc4key), cb, (unsigned char*) pv );
    pRC4Safe->BytesUsed = 0;

    LEAVE_LOCK( &(pRC4Safe->lock) );

}

#ifdef KMODE_RNG

void
rc4_safe_key_np(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      const void *pv
    )
/*++

Routine Description:

    Non-paged, high-IRQL version of rc4_safe_key()

--*/
{
    RC4_SAFE_ARRAY *pRC4SafeArray;
    RC4_SAFE *pRC4Safe;

    pRC4SafeArray = (RC4_SAFE_ARRAY*)pContext;

    if( Entry == 0xffffffff ) {
        Entry = KeGetCurrentProcessorNumber();
    }

    pRC4Safe = pRC4SafeArray->Array[ Entry ];

    rc4_key( &pRC4Safe->rc4key, cb, (unsigned char*) pv );
    pRC4Safe->BytesUsed = 0;

}

#endif // KMODE_RNG

unsigned int
rc4_safe_startup(
    IN OUT  void **ppContext
    )
/*++

Routine Description:

    key selector:  choose a thread safe key.
    outputs key identifier and bytes used with key.

--*/
{
    RC4_SAFE_ARRAY *pRC4SafeArray;
    RC4_SAFE *pRC4Safe;
    unsigned int Entries;
    unsigned int i;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    Entries = RC4_SAFE_ENTRIES;


    pRC4SafeArray = (RC4_SAFE_ARRAY *)ALLOC_NP(
                                    sizeof(RC4_SAFE_ARRAY) +
                                    (Entries * sizeof(RC4_SAFE *)) +
                                    (Entries * sizeof(RC4_SAFE))
                                    );

    if( pRC4SafeArray == NULL ) {
        return FALSE;
    }

    pRC4SafeArray->Entries = Entries;
    pRC4SafeArray->Mode = Paged;

    pRC4Safe = (RC4_SAFE*) ((unsigned char*)pRC4SafeArray +
                                            sizeof(RC4_SAFE_ARRAY) +
                                            (Entries * sizeof(RC4_SAFE*))
                                            );

    for ( i = 0 ; i < Entries ; i++, pRC4Safe++ ) {

        pRC4SafeArray->Array[i] = pRC4Safe;

        INIT_LOCK( &(pRC4Safe->lock) );

        //
        // cause client to re-key for each initialized array entry.
        //

        pRC4Safe->BytesUsed = 0xffffffff;
    }

    *ppContext = pRC4SafeArray;

    return TRUE;
}


#ifdef KMODE_RNG

unsigned int
rc4_safe_startup_np(
    IN OUT  void **ppContext
    )
/*++

Routine Description:

    Non-Paged, high IRQL version of rc4_safe_startup()

--*/
{
    RC4_SAFE_ARRAY *pRC4SafeArray;
    RC4_SAFE *pRC4Safe;
    unsigned int Entries;
    unsigned int i;

    //
    // get installed processor count.
    //

    Entries = KeNumberProcessors;

    pRC4SafeArray = (RC4_SAFE_ARRAY *)ALLOC_NP(
                                    sizeof(RC4_SAFE_ARRAY) +
                                    (Entries * sizeof(RC4_SAFE *)) +
                                    (Entries * sizeof(RC4_SAFE))
                                    );

    if( pRC4SafeArray == NULL ) {
        return FALSE;
    }

    pRC4SafeArray->Entries = Entries;
    pRC4SafeArray->Mode = NonPaged;

    pRC4Safe = (RC4_SAFE*) ((unsigned char*)pRC4SafeArray +
                                            sizeof(RC4_SAFE_ARRAY) +
                                            (Entries * sizeof(RC4_SAFE*))
                                            );

    for ( i = 0 ; i < Entries ; i++, pRC4Safe++ ) {

        pRC4SafeArray->Array[i] = pRC4Safe;

        //
        // cause client to re-key for each initialized array entry.
        //

        pRC4Safe->BytesUsed = 0xffffffff;
    }

    *ppContext = pRC4SafeArray;

    return TRUE;
}

#endif


void
rc4_safe_shutdown(
    IN      void *pContext
    )
/*++

Routine Description:

    rc4_safe_shutdown called to free resources associated with internal structures.
    typically called during DLL_PROCESS_DETACH type shutdown code.

--*/
{

    RC4_SAFE_ARRAY *SafeArray;
    unsigned int SafeEntries;
    unsigned int i;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG


    SafeArray = (RC4_SAFE_ARRAY*)pContext;
    SafeEntries = SafeArray->Entries;

    for ( i = 0 ; i < SafeEntries ; i++ ) {
        RC4_SAFE *pRC4Safe = SafeArray->Array[i];

        DELETE_LOCK( &(pRC4Safe->lock) );
    }

    FREE( pContext );
}



#ifdef KMODE_RNG

void
rc4_safe_shutdown_np(
    IN      void *pContext
    )
/*++

Routine Description:

    Non-paged, high-IRQL version of rc4_safe_shutdown()

--*/
{
    FREE( pContext );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\randlib\circhash.h ===
// Circular Hash
//
// This code implements a circular hash algorithm, intended as a variable
// length hash function that is fast to update. (The hash function will be
// called many times.)  This is done by SHA-1'ing each of the inputs, then
// circularly XORing this value into a buffer.

#ifndef __CIRCHASH_H__
#define __CIRCHASH_H__

typedef struct {
    DWORD       dwCircHashVer;
    DWORD       dwCircSize;
    DWORD       dwMode;
    DWORD       dwCircInc;
    DWORD       dwCurCircPos;
    DWORD       dwAlgId;
    DWORD       dwPad1;
    DWORD       dwPad2;
    BYTE        CircBuf[ 256 ];
} CircularHash;


// mode flags
#define CH_MODE_FEEDBACK        0x01

// alg flags
#define CH_ALG_SHA1_NS          0       // SHA-1 without endian transform
#define CH_ALG_MD4              1       // RSA MD4

BOOL
InitCircularHash(
    IN      CircularHash *NewHash,
    IN      DWORD dwUpdateInc,
    IN      DWORD dwAlgId,
    IN      DWORD dwMode
    );

VOID
DestroyCircularHash(
    IN      CircularHash *OldHash
    );

BOOL
GetCircularHashValue(
    IN      CircularHash *CurrentHash,
        OUT BYTE **ppbHashValue,
        OUT DWORD *pcbHashValue
        );

BOOL
UpdateCircularHash(
    IN      CircularHash *CurrentHash,
    IN      VOID *pvData,
    IN      DWORD cbData
    );

#endif  // __CIRCHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\randlib\seed.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    seed.h

Abstract:

    Storage and retrieval of cryptographic RNG seed material.

Author:

    Scott Field (sfield)    24-Sep-98

--*/

#ifndef __SEED_H__
#define __SEED_H__

BOOL
ReadSeed(
    IN      PBYTE           pbSeed,
    IN      DWORD           cbSeed
    );

BOOL
WriteSeed(
    IN      PBYTE           pbSeed,
    IN      DWORD           cbSeed
    );

#endif  // __SEED_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\randlib\seed.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    seed.c

Abstract:

    Storage and retrieval of cryptographic RNG seed material.

Author:

    Scott Field (sfield)    24-Sep-98

--*/

#ifndef KMODE_RNG

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <zwapi.h>
#include <windows.h>

#else

#include <ntifs.h>
#include <windef.h>

#endif  // KMODE_RNG

#include "seed.h"
#include "umkm.h"

BOOL
AccessSeed(
    IN      ACCESS_MASK     DesiredAccess,
    IN  OUT PHKEY           phkResult
    );


BOOL
AdjustSeedSecurity(
    IN      HKEY            hKeySeed
    );

#ifdef KMODE_RNG

#define SEED_KEY_LOCATION   L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Cryptography\\RNG"
#define SEED_VALUE_NAME     L"Seed"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ReadSeed)
#pragma alloc_text(PAGE, WriteSeed)
#pragma alloc_text(PAGE, AccessSeed)
#endif  // ALLOC_PRAGMA

#else

#define SEED_KEY_LOCATION   "SOFTWARE\\Microsoft\\Cryptography\\RNG"
#define SEED_VALUE_NAME     "Seed"

#endif  // KMODE_RNG


//
// globally cached registry handle to seed material.
// TODO: later.
//

///HKEY g_hKeySeed = NULL;



BOOL
ReadSeed(
    IN      PBYTE           pbSeed,
    IN      DWORD           cbSeed
    )
{
    HKEY hKeySeed;

#ifndef KMODE_RNG
    DWORD dwType;
    LONG lRet;
#else

    static const WCHAR wszValue[] = SEED_VALUE_NAME;
    BYTE FastBuffer[ 256 ];
    PKEY_VALUE_PARTIAL_INFORMATION pKeyInfo;
    DWORD cbKeyInfo;
    UNICODE_STRING ValueName;
    NTSTATUS Status;

    PAGED_CODE();
#endif  // KMODE_RNG


    //
    // open handle to RNG registry key.
    //

    if(!AccessSeed( KEY_QUERY_VALUE, &hKeySeed ))
        return FALSE;

#ifndef KMODE_RNG

    lRet = RegQueryValueExA(
                    hKeySeed,
                    SEED_VALUE_NAME,
                    NULL,
                    &dwType,
                    pbSeed,
                    &cbSeed
                    );

    REGCLOSEKEY( hKeySeed );

    if( lRet != ERROR_SUCCESS )
        return FALSE;

    return TRUE;

#else

    ValueName.Buffer = (LPWSTR)wszValue;
    ValueName.Length = sizeof(wszValue) - sizeof(WCHAR);
    ValueName.MaximumLength = sizeof(wszValue);


    pKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)FastBuffer;
    cbKeyInfo = sizeof(FastBuffer);

    Status = ZwQueryValueKey(
                    hKeySeed,
                    &ValueName,
                    KeyValuePartialInformation,
                    pKeyInfo,
                    cbKeyInfo,
                    &cbKeyInfo
                    );

    REGCLOSEKEY( hKeySeed );

    if(!NT_SUCCESS(Status))
        return FALSE;

    if( pKeyInfo->DataLength > cbSeed )
        return FALSE;

    RtlCopyMemory( pbSeed, pKeyInfo->Data, pKeyInfo->DataLength );

    return TRUE;

#endif
}

BOOL
WriteSeed(
    IN      PBYTE           pbSeed,
    IN      DWORD           cbSeed
    )
{
    HKEY hKeySeed;

#ifndef KMODE_RNG
    LONG lRet;
#else
    static const WCHAR wszValue[] = SEED_VALUE_NAME;
    UNICODE_STRING ValueName;
    NTSTATUS Status;

    PAGED_CODE();
#endif  // KMODE_RNG


    //
    // open handle to RNG registry key.
    //

    if(!AccessSeed( KEY_SET_VALUE, &hKeySeed ))
        return FALSE;


#ifndef KMODE_RNG

    lRet = RegSetValueExA(
                    hKeySeed,
                    SEED_VALUE_NAME,
                    0,
                    REG_BINARY,
                    pbSeed,
                    cbSeed
                    );

    REGCLOSEKEY( hKeySeed );

    if( lRet != ERROR_SUCCESS )
        return FALSE;

    return TRUE;

#else

    ValueName.Buffer = (LPWSTR)wszValue;
    ValueName.Length = sizeof(wszValue) - sizeof(WCHAR);
    ValueName.MaximumLength = sizeof(wszValue);

    Status = ZwSetValueKey(
                    hKeySeed,
                    &ValueName,
                    0,
                    REG_BINARY,
                    pbSeed,
                    cbSeed
                    );

    REGCLOSEKEY( hKeySeed );

    if(!NT_SUCCESS(Status))
        return FALSE;

    return TRUE;

#endif

}

BOOL
AccessSeed(
    IN      ACCESS_MASK     DesiredAccess,
    IN  OUT PHKEY           phkResult
    )
{

#ifndef KMODE_RNG

    DWORD dwDisposition;
    LONG lRet;

    lRet = RegCreateKeyExA(
                HKEY_LOCAL_MACHINE,
                SEED_KEY_LOCATION,
                0,
                NULL,
                0,
                DesiredAccess,
                NULL,   // sa
                phkResult,
                &dwDisposition
                );


    if( lRet != ERROR_SUCCESS )
        return FALSE;

#if 0
    if( dwDisposition == REG_CREATED_NEW_KEY ) {

        //
        // if we just created the seed, make sure it's Acl'd appropriately.
        //

        AdjustSeedSecurity( *phkResult );
    }
#endif

    return TRUE;
#else

    NTSTATUS Status;

/// TODO at a later date: cache the registry key
///    *phkResult = g_hKeySeed;
///    if( *phkResult == NULL ) {

        UNICODE_STRING RegistryKeyName;
        static const WCHAR KeyLocation[] = SEED_KEY_LOCATION;
        ULONG Disposition;
        OBJECT_ATTRIBUTES ObjAttr;

///        HKEY hKeyPrevious;

        PAGED_CODE();

        RegistryKeyName.Buffer = (LPWSTR)KeyLocation;
        RegistryKeyName.Length = sizeof(KeyLocation) - sizeof(WCHAR);
        RegistryKeyName.MaximumLength = sizeof(KeyLocation);

        InitializeObjectAttributes(
                    &ObjAttr,
                    &RegistryKeyName,
                    OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                    0,
                    NULL
                    );

        Status = ZwCreateKey(
                    phkResult,
                    DesiredAccess,
                    &ObjAttr,
                    0,
                    NULL,
                    0,
                    &Disposition
                    );


        if(!NT_SUCCESS(Status))
            return FALSE;

///        hKeyPrevious = INTERLOCKEDCOMPAREEXCHANGEPOINTER( &g_hKeySeed, *phkResult, NULL );
///        if( hKeyPrevious ) {
///            REGCLOSEKEY( *phkResult );
///            *phkResult = hKeyPrevious;
///        }
///    }

    return TRUE;

#endif

}


#ifndef KMODE_RNG

//
// NOTE: this function should be removed if we can get the key into
// the setup hives with Acl applied appropriately.
//

#if 0

BOOL
AdjustSeedSecurity(
    IN      HKEY            hKeySeed
    )
{
    HKEY hKeySecurityAdjust = NULL;

    SID_IDENTIFIER_AUTHORITY siaWorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    SECURITY_DESCRIPTOR sd;
    BYTE FastBuffer[ 256 ];
    PACL pDacl;
    DWORD cbDacl;
    PSID psidAdministrators = NULL;
    PSID psidEveryone = NULL;

    LONG lRet;
    BOOL fSuccess = FALSE;

    //
    // re-open key with WRITE_DAC access and update security.
    // note: Wide version will fail on Win9x, which is fine, since
    // no security there...
    //

    lRet = RegOpenKeyExW(
                    hKeySeed,
                    NULL,
                    0,
                    WRITE_DAC,
                    &hKeySecurityAdjust
                    );


    if( lRet != ERROR_SUCCESS )
        goto cleanup;

    if(!InitializeSecurityDescriptor( &sd, SECURITY_DESCRIPTOR_REVISION ))
        goto cleanup;

    if(!AllocateAndInitializeSid(
        &siaWorldAuthority,
        1,
        SECURITY_WORLD_RID,
        0, 0, 0, 0, 0, 0, 0,
        &psidEveryone
        )) {
        goto cleanup;
    }


    if(!AllocateAndInitializeSid(
            &siaNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &psidAdministrators
            )) {
        goto cleanup;
    }


    cbDacl = sizeof(ACL) +
            2 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
            GetLengthSid(psidEveryone) +
            GetLengthSid(psidAdministrators) ;


    if( cbDacl > sizeof( FastBuffer ) )
        goto cleanup;

    pDacl = (PACL)FastBuffer;


    if(!InitializeAcl( pDacl, cbDacl, ACL_REVISION ))
        goto cleanup;


    if(!AddAccessAllowedAce(
        pDacl,
        ACL_REVISION,
        KEY_QUERY_VALUE,
        psidEveryone
        )) {
        goto cleanup;
    }


    if(!AddAccessAllowedAce(
        pDacl,
        ACL_REVISION,
        KEY_ALL_ACCESS,
        psidAdministrators
        )) {
        goto cleanup;
    }

    if(!SetSecurityDescriptorDacl( &sd, TRUE, pDacl, FALSE ))
        goto cleanup;


    lRet = RegSetKeySecurity(
                    hKeySecurityAdjust,
                    DACL_SECURITY_INFORMATION,
                    &sd
                    );

    if( lRet != ERROR_SUCCESS)
        goto cleanup;


    fSuccess = TRUE;

cleanup:

    if( hKeySecurityAdjust )
        REGCLOSEKEY( hKeySecurityAdjust );

    if( psidAdministrators )
        FreeSid( psidAdministrators );

    if( psidEveryone )
        FreeSid( psidEveryone );

    return fSuccess;
}
#endif

#endif // !KMODE_RNG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\randlib\sources.inc ===
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES= $(DS_INC_PATH)\crypto;  \
          $(BASE_INC_PATH); \
	  $(IFSKIT_INC_PATH); \
          ..\..\inc

SOURCES= ..\randlib.c  \
         ..\vlhash.c   \
         ..\circhash.c \
         ..\cpu.c      \
         ..\seed.c     \
         ..\rc4safe.c  \
         ..\umkm.c

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\randlib\randlib.c ===
/*++

Copyright (c) 1993, 1998  Microsoft Corporation

Module Name:

    randlib.c

Abstract:

    This module implements the core cryptographic random number generator
    for use by system components.

    The #define KMODE_RNG affects whether the file is built in a way
    suitable for kernel mode usage.  if KMODE_RNG is not defined, the file
    is built in a way suitable for user mode usage.

Author:

    Scott Field (sfield)    27-Nov-96
    Jeff Spelman (jeffspel) 14-Oct-96

--*/

#ifndef KMODE_RNG

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#else

#include <ntosp.h>
#include <windef.h>

#ifdef USE_HW_RNG
#ifdef _M_IX86
#include <io.h>
#include "deftypes.h"   //ISD typedefs and constants
#include "ioctldef.h"   //ISD ioctl definitions
#endif  // _M_IX86
#endif  // USE_HW_RNG

#endif  // KMODE_RNG

#include <zwapi.h>

#include <winioctl.h>
#include <lmcons.h>

#include <rc4.h>
#include <sha.h>
#include <md4.h>

#include <ntddksec.h>   // IOCTL_
#include <randlib.h>

#include "vlhash.h"
#include "circhash.h"
#include "cpu.h"
#include "seed.h"


#ifdef KMODE_RNG
//#include <ntos.h>
#ifdef USE_HW_RNG
#ifdef _M_IX86
static DWORD g_dwHWDriver = 0;
static PFILE_OBJECT   g_pFileObject = NULL;
static PDEVICE_OBJECT g_pDeviceObject = NULL;
#endif  // _M_IX86
#endif  // USE_HW_RNG
#endif  // KMODE_RNG


#include "umkm.h"

//
// note: RAND_CTXT_LEN dictates the maximum input quantity for re-seed entropy
// is.  We make this fairly large, so that we can take all the entropy generated
// during the GatherRandomBits().  Since the lifetime of the RandContext structure
// is very short, and it lives on the stack, this larger than necessary size
// is ok.  The last few items processed during GatherRandomBits() are of
// variable size, up to a maximum of of UNLEN for the username.
//

#define RAND_CTXT_LEN           (256)
#define RC4_REKEY_PARAM_NT      (16384) // rekey less often on NT

#ifndef KMODE_RNG
#define RC4_REKEY_PARAM_DEFAULT (512)   // rekey every 512 bytes by default
#else
#define RC4_REKEY_PARAM_DEFAULT RC4_REKEY_PARAM_NT
#endif


static unsigned int     g_dwRC4RekeyParam = RC4_REKEY_PARAM_DEFAULT;

static CircularHash     g_CircularHashCtx;

#ifndef WINNT_RNG
static BYTE             g_VeryLargeHash[A_SHA_DIGEST_LEN*4];
#endif

static void *           g_RC4SafeCtx;

#ifndef KMODE_RNG

typedef NTSYSAPI NTSTATUS (NTAPI *NTQUERYSYSTEMINFORMATION) (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

typedef NTSYSAPI NTSTATUS (NTAPI *NTOPENFILE) (
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );

typedef NTSYSAPI VOID (NTAPI *RTLINITUNICODESTRING) (
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );

typedef BOOL (WINAPI *GETCURSORPOS)(
    LPPOINT lpPoint
    );

typedef LONG (WINAPI *GETMESSAGETIME)(
    VOID
    );



GETCURSORPOS                ___GetCursorPosRNG = NULL;
GETMESSAGETIME              ___GetMessageTimeRNG = NULL;


#define _GetCursorPos               ___GetCursorPosRNG
#define _GetMessageTime             ___GetMessageTimeRNG


#ifndef WINNT_RNG

NTQUERYSYSTEMINFORMATION            ___NtQuerySystemInformationRNG = NULL;
NTOPENFILE                          ___NtOpenFileRNG = NULL;
RTLINITUNICODESTRING                ___RtlInitUnicodeStringRNG = NULL;

#define _NtQuerySystemInformation   ___NtQuerySystemInformationRNG
#define _NtOpenFile                 ___NtOpenFileRNG
#define _RtlInitUnicodeString       ___RtlInitUnicodeStringRNG

#else

#define _NtQuerySystemInformation   NtQuerySystemInformation
#define _NtOpenFile                 NtOpenFile
#define _RtlInitUnicodeString       RtlInitUnicodeString

#endif


#ifndef WINNT_RNG
HANDLE g_hKsecDD = NULL;
#else
extern HANDLE g_hKsecDD;
#endif

#else

#define _NtQuerySystemInformation ZwQuerySystemInformation

#endif // !KMODE_RNG

/// TODO: cache hKeySeed later.
///extern HKEY g_hKeySeed;



//
// private function prototypes.
//


BOOL
GenRandom (
    IN      PVOID           hUID,
        OUT BYTE            *pbBuffer,
    IN      size_t          dwLength
    );


BOOL
RandomFillBuffer(
        OUT BYTE            *pbBuffer,
    IN      DWORD           *pdwLength
    );

BOOL
GatherRandomKey(
    IN      BYTE            *pbUserSeed,
    IN      DWORD           cbUserSeed,
    IN  OUT BYTE            *pbRandomKey,
    IN  OUT DWORD           *pcbRandomKey
    );

BOOL
GatherRandomKeyFastUserMode(
    IN      BYTE            *pbUserSeed,
    IN      DWORD           cbUserSeed,
    IN  OUT BYTE            *pbRandomKey,
    IN  OUT DWORD           *pcbRandomKey
    );


BOOL
IsRNGWinNT(
    VOID
    );


#ifdef _M_IX86
unsigned int
QueryForHWRandomBits(
    IN      DWORD *pdwRandom,
    IN  OUT DWORD cdwRandom
    );
#endif //_M_IX86


#ifdef KMODE_RNG

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NewGenRandom)
#pragma alloc_text(PAGE, NewGenRandomEx)
#pragma alloc_text(PAGE, GenRandom)
#pragma alloc_text(PAGE, RandomFillBuffer)
#pragma alloc_text(PAGE, InitializeRNG)
#pragma alloc_text(PAGE, ShutdownRNG)
#ifdef _M_IX86
#pragma alloc_text(PAGE, QueryForHWRandomBits)
#endif //_M_IX86
#pragma alloc_text(PAGE, GatherRandomKey)

#endif  // ALLOC_PRAGMA
#endif  // KMODE_RNG



/************************************************************************/
/* NewGenRandom generates a specified number of random bytes and places */
/* them into the specified buffer.                                      */
/************************************************************************/
/*                                                                      */
/* Pseudocode logic flow:                                               */
/*                                                                      */
/* if (bits streamed >= threshold)                                      */
/* {                                                                    */
/*  Gather_Bits()                                                       */
/*  SHAMix_Bits(User, Gathered, Static -> Static)                       */
/*  RC4Key(Static -> newRC4Key)                                         */
/*  SaveToRegistry(Static)                                              */
/* }                                                                    */
/* else                                                                 */
/* {                                                                    */
/*  Mix_Bits(User, Static -> Static)                                    */
/* }                                                                    */
/*                                                                      */
/* RC4(newRC4Key -> outbuf)                                             */
/* bits streamed += sizeof(outbuf)                                      */
/*                                                                      */
/************************************************************************/


unsigned int
RSA32API
NewGenRandomEx(
    IN      RNG_CONTEXT *pRNGContext,
    IN  OUT unsigned char *pbRandBuffer,
    IN      unsigned long cbRandBuffer
    )
{
    unsigned char **ppbRandSeed;
    unsigned long *pcbRandSeed;
    unsigned int fRet;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    fRet = TRUE;

    if( pRNGContext->cbSize != sizeof( RNG_CONTEXT ) )
        return FALSE;

    if( pRNGContext->pbRandSeed && pRNGContext->cbRandSeed ) {

        ppbRandSeed = &pRNGContext->pbRandSeed;
        pcbRandSeed = &pRNGContext->cbRandSeed;

    } else {

        ppbRandSeed = NULL;
        pcbRandSeed = NULL;
    }

    if(!InitializeRNG( NULL ))
    {
        return FALSE;
    }

    InitRand( ppbRandSeed, pcbRandSeed );

    if( pRNGContext->Flags & RNG_FLAG_REKEY_ONLY ) {

        //
        // caller wants REKEY only.
        //

        fRet = GatherRandomKey( NULL, 0, pbRandBuffer, &cbRandBuffer );

    } else {

        //
        // standard RNG request.
        //

        fRet = GenRandom(0, pbRandBuffer, cbRandBuffer);
    }

    if( ppbRandSeed && pcbRandSeed ) {
        DeInitRand( *ppbRandSeed, *pcbRandSeed);
    }

    return fRet;
}

unsigned int
RSA32API
NewGenRandom (
    IN  OUT unsigned char **ppbRandSeed,
    IN      unsigned long *pcbRandSeed,
    IN  OUT unsigned char *pbBuffer,
    IN      unsigned long dwLength
    )
{
    RNG_CONTEXT RNGContext;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG


    RtlZeroMemory( &RNGContext, sizeof(RNGContext) );
    RNGContext.cbSize = sizeof(RNGContext);

    if( ppbRandSeed && pcbRandSeed ) {
        BOOL fRet;

        RNGContext.pbRandSeed = *ppbRandSeed;
        RNGContext.cbRandSeed = *pcbRandSeed;

        fRet = NewGenRandomEx( &RNGContext, pbBuffer, dwLength );
        *pcbRandSeed = RNGContext.cbRandSeed;

        return fRet;
    }

    return NewGenRandomEx( &RNGContext, pbBuffer, dwLength );
}

unsigned int
RSA32API
InitRand(
    IN  OUT unsigned char **ppbRandSeed,
    IN      unsigned long *pcbRandSeed
    )
{

    static BOOL fInitialized = FALSE;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    if( !fInitialized ) {

        InitCircularHash(
                    &g_CircularHashCtx,
                    7,
                    CH_ALG_MD4,
                    0   // CH_MODE_FEEDBACK
                    );

#ifndef WINNT_RNG
        //
        // get prior seed.
        //

        ReadSeed( g_VeryLargeHash, sizeof( g_VeryLargeHash ) );
#endif

        fInitialized = TRUE;
    }

    if( ppbRandSeed != NULL && pcbRandSeed != NULL && *pcbRandSeed != 0 )
        UpdateCircularHash( &g_CircularHashCtx, *ppbRandSeed, *pcbRandSeed );

    return TRUE;
}

unsigned int
RSA32API
DeInitRand(
    IN  OUT unsigned char *pbRandSeed,
    IN      unsigned long cbRandSeed
    )
{
    PBYTE       pbCircularHash;
    DWORD       cbCircularHash;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    if( pbRandSeed == NULL || cbRandSeed == 0 )
        return TRUE;

    if(GetCircularHashValue( &g_CircularHashCtx, &pbCircularHash, &cbCircularHash )) {

        unsigned long cbToCopy;

        if( cbRandSeed > cbCircularHash ) {
            cbToCopy = cbCircularHash;
        } else {
            cbToCopy = cbRandSeed;
        }

        memcpy(pbRandSeed, pbCircularHash, cbToCopy);
    }

    return TRUE;
}

unsigned int
RSA32API
InitializeRNG(
    VOID *pvReserved
    )
{
    void *pvCtx;
    void *pvOldCtx;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    if( g_RC4SafeCtx ) {
        return TRUE;
    }

    if(!rc4_safe_startup( &pvCtx )) {
        return FALSE;
    }

    pvOldCtx = INTERLOCKEDCOMPAREEXCHANGEPOINTER( &g_RC4SafeCtx, pvCtx, NULL );

    if( pvOldCtx ) {

        //
        // race condition occured during init.
        //

        rc4_safe_shutdown( pvCtx );
    }

    return TRUE;
}

void
RSA32API
ShutdownRNG(
    VOID *pvReserved
    )
{
    void *pvCtx;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    pvCtx = InterlockedExchangePointer( &g_RC4SafeCtx, NULL );

    if( pvCtx ) {
        rc4_safe_shutdown( pvCtx );
    }

#ifndef KMODE_RNG
#ifndef WINNT_RNG
{
    HANDLE hFile;
    hFile = InterlockedExchangePointer( &g_hKsecDD, NULL );

    if( hFile ) {
        CloseHandle( hFile );
    }
}
#endif
#endif

#if 0
    // TODO later: finish logic for caching registry key.
    hKey = InterlockedExchangePointer( &g_hKeySeed, NULL );

    if( hKey ) {
        REGCLOSEKEY( hKey );
    }
#endif

}

BOOL
GenRandom (
    IN      PVOID hUID,
        OUT BYTE *pbBuffer,
    IN      size_t dwLength
    )
{
    DWORD           dwBytesThisPass;
    DWORD           dwFilledBytes;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    dwFilledBytes = 0;

    // break request into chunks that we rekey between
    while(dwFilledBytes < dwLength)
    {
        dwBytesThisPass = dwLength - dwFilledBytes;

        if(!RandomFillBuffer(
                pbBuffer + dwFilledBytes,
                &dwBytesThisPass
                )) {

            return FALSE;
        }

        dwFilledBytes += dwBytesThisPass;
    }

    return TRUE;
}


BOOL
RandomFillBuffer(
        OUT BYTE *pbBuffer,
    IN      DWORD *pdwLength
    )
{
    unsigned int RC4BytesUsed;
    unsigned int KeyId;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG


    //
    // update circular hash with user supplied bits.
    //

    if(!UpdateCircularHash( &g_CircularHashCtx, pbBuffer, *pdwLength ))
        return FALSE;


    //
    // select key.
    //

    rc4_safe_select( g_RC4SafeCtx, &KeyId, &RC4BytesUsed );


    //
    // check if re-key required.
    //

    if ( RC4BytesUsed >= g_dwRC4RekeyParam )
    {
        PBYTE       pbCircularHash;
        DWORD       cbCircularHash;
        BYTE        pbRandomKey[ 256 ];
        DWORD       cbRandomKey = sizeof(pbRandomKey);

        RC4BytesUsed = g_dwRC4RekeyParam;

        if(!GetCircularHashValue(
                &g_CircularHashCtx,
                &pbCircularHash,
                &cbCircularHash
                )) {

            return FALSE;
        }

        if(!GatherRandomKey( pbCircularHash, cbCircularHash, pbRandomKey, &cbRandomKey ))
            return FALSE;

        //
        // Create RC4 key
        //

        rc4_safe_key(
                g_RC4SafeCtx,
                KeyId,
                cbRandomKey,
                pbRandomKey
                );

        RtlZeroMemory( pbRandomKey, sizeof(pbRandomKey) );
    }


    //
    // only use RC4_REKEY_PARAM bytes from each RC4 key
    //

    {
        DWORD dwMaxPossibleBytes = g_dwRC4RekeyParam - RC4BytesUsed;

        if (*pdwLength > dwMaxPossibleBytes)
            *pdwLength = dwMaxPossibleBytes;
    }

    rc4_safe( g_RC4SafeCtx, KeyId, *pdwLength, pbBuffer );

    return TRUE;
}


#ifdef KMODE_RNG
#ifdef USE_HW_RNG
#ifdef _M_IX86
#define NUM_HW_DWORDS_TO_GATHER     4
#define INTEL_DRIVER_NAME           L"\\Device\\ISECDRV"

unsigned int
QueryForHWRandomBits(
    IN      DWORD *pdwRandom,
    IN  OUT DWORD cdwRandom
    )
{
    UNICODE_STRING ObjectName;
    IO_STATUS_BLOCK StatusBlock;
    KEVENT Event;
    PIRP pIrp = NULL;
    ISD_Capability ISD_Cap;                //in/out for GetCapability
    ISD_RandomNumber ISD_Random;           //in/out for GetRandomNumber
    PDEVICE_OBJECT pDeviceObject = NULL;
    DWORD i = 0;
    unsigned int Status = ERROR_SUCCESS;

    PAGED_CODE();

    if (1 == g_dwHWDriver)
    {
        Status = STATUS_ACCESS_DENIED;
        goto Ret;
    }

    RtlZeroMemory( &ObjectName, sizeof(ObjectName) );
    RtlZeroMemory( &StatusBlock, sizeof(StatusBlock) );
    RtlZeroMemory(&ISD_Cap, sizeof(ISD_Cap));


    if (NULL == g_pDeviceObject)
    {
        ObjectName.Length = sizeof(INTEL_DRIVER_NAME) - sizeof(WCHAR);
        ObjectName.MaximumLength = sizeof(INTEL_DRIVER_NAME);
        ObjectName.Buffer = INTEL_DRIVER_NAME;
        Status = IoGetDeviceObjectPointer(&ObjectName,
                                          FILE_ALL_ACCESS,
                                          &g_pFileObject,
                                          &pDeviceObject);

        if ( !NT_SUCCESS(Status) )
        {
            g_dwHWDriver = 1;
            goto Ret;
        }

        if (NULL == g_pDeviceObject)
        {
            InterlockedExchangePointer(&g_pDeviceObject, pDeviceObject);
        }
    }

    //
    // If this fails then it is because there is no such device
    // which signals completion.
    //


    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    ISD_Cap.uiIndex = ISD_RNG_ENABLED;  //Set input member
    pIrp = IoBuildDeviceIoControlRequest(
        IOCTL_ISD_GetCapability,
        g_pDeviceObject,
        &ISD_Cap,
        sizeof(ISD_Cap),
        &ISD_Cap,
        sizeof(ISD_Cap),
        FALSE,
        &Event,
        &StatusBlock);

    if (pIrp == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Ret;
    }

    Status = IoCallDriver(g_pDeviceObject, pIrp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
        Status = StatusBlock.Status;
    }

    if (ISD_Cap.iStatus != ISD_EOK) {
        Status = STATUS_NOT_IMPLEMENTED;
        goto Ret;
    }

    // now get the random bits
    for (i = 0; i < cdwRandom; i++) {
        RtlZeroMemory(&ISD_Random, sizeof(ISD_Random));
        KeInitializeEvent(&Event, NotificationEvent, FALSE);

        pIrp = IoBuildDeviceIoControlRequest(
            IOCTL_ISD_GetRandomNumber,
            g_pDeviceObject,
            &ISD_Random,
            sizeof(ISD_Random),
            &ISD_Random,
            sizeof(ISD_Random),
            FALSE,
            &Event,
            &StatusBlock);

        if (pIrp == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Ret;
        }

        Status = IoCallDriver(g_pDeviceObject, pIrp);

        if (Status == STATUS_PENDING) {
            KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
            Status = StatusBlock.Status;
        }

        if (ISD_Random.iStatus != ISD_EOK) {
            Status = STATUS_NOT_IMPLEMENTED;
            goto Ret;
        }

        pdwRandom[i] = pdwRandom[i] ^ ISD_Random.uiRandomNum;
    }
Ret:
    return Status;
}
#endif // _M_IX86
#endif // USE_HW_RNG
#endif // KMODE_RNG

BOOL
GatherRandomKey(
    IN      BYTE            *pbUserSeed,
    IN      DWORD           cbUserSeed,
    IN  OUT BYTE            *pbRandomKey,
    IN  OUT DWORD           *pcbRandomKey
    )
{

    LPBYTE  pbWorkingBuffer = NULL;
    DWORD   cbWorkingBuffer;
    DWORD   cbBufferRemaining;
    BYTE    *pbCurrentBuffer;
    DWORD   *pdwTmp;
    BOOL    fRet;

#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG




    //
    // in NT Usermode, try to re-seed by calling the Kernelmode RNG.
    //

#ifndef KMODE_RNG
#ifdef WINNT_RNG
    return GatherRandomKeyFastUserMode(
                    pbUserSeed,
                    cbUserSeed,
                    pbRandomKey,
                    pcbRandomKey
                    );
#else
    if(GatherRandomKeyFastUserMode(
                    pbUserSeed,
                    cbUserSeed,
                    pbRandomKey,
                    pcbRandomKey
                    ))
    {
        return TRUE;
    }
#endif
#endif


#ifndef WINNT_RNG

//
// verify current working buffer has space for candidate data.
//

#define VERIFY_BUFFER( size ) {                                         \
    if( cbBufferRemaining < size )                                      \
        goto finished;                                                  \
    }

//
// update working buffer and increment to next QWORD aligned boundary.
//

#define UPDATE_BUFFER( size ) {                                         \
    DWORD dwSizeRounded;                                                \
    dwSizeRounded = (size + sizeof(ULONG64)) & ~(sizeof(ULONG64)-1);    \
    if(dwSizeRounded > cbBufferRemaining)                               \
        goto finished;                                                  \
    pbCurrentBuffer += dwSizeRounded;                                   \
    cbBufferRemaining -= dwSizeRounded;                                 \
    }


    cbWorkingBuffer = 3584;
    pbWorkingBuffer = (PBYTE)ALLOC( cbWorkingBuffer );
    if( pbWorkingBuffer == NULL ) {
        return FALSE;
    }

    cbBufferRemaining = cbWorkingBuffer;
    pbCurrentBuffer = pbWorkingBuffer;

    //
    // pickup user supplied bits.
    //

    VERIFY_BUFFER( cbUserSeed );
    RtlCopyMemory( pbCurrentBuffer, pbUserSeed, cbUserSeed );
    UPDATE_BUFFER( cbUserSeed );

    //
    // ** indicates US DoD's specific recommendations for password generation
    //


    //
    // process id
    //


#ifndef KMODE_RNG
    pdwTmp = (PDWORD)pbCurrentBuffer;
    *pdwTmp = GetCurrentProcessId();
    UPDATE_BUFFER( sizeof(DWORD) );
#else
    {
    PHANDLE hTmp = (PHANDLE)pbCurrentBuffer;
    VERIFY_BUFFER( sizeof(HANDLE) );
    *hTmp = PsGetCurrentProcessId();
    UPDATE_BUFFER( sizeof(HANDLE) );
    }
#endif


    //
    // thread id
    //


#ifndef KMODE_RNG
    pdwTmp = (PDWORD)pbCurrentBuffer;
    *pdwTmp = GetCurrentThreadId();
    UPDATE_BUFFER( sizeof(DWORD) );
#else
    {
    PHANDLE hTmp = (PHANDLE)pbCurrentBuffer;
    VERIFY_BUFFER( sizeof(HANDLE) );
    *hTmp = PsGetCurrentThreadId();
    UPDATE_BUFFER( sizeof(HANDLE) );
    }
#endif



    //
    // ** ticks since boot (system clock)
    //


#ifndef KMODE_RNG
    pdwTmp = (PDWORD)pbCurrentBuffer;
    *pdwTmp = GetTickCount();
    UPDATE_BUFFER( sizeof(DWORD) );
#else
    {
    PLARGE_INTEGER Tick = (PLARGE_INTEGER)pbCurrentBuffer;

    VERIFY_BUFFER( sizeof(LARGE_INTEGER) );
    KeQueryTickCount( Tick );
    UPDATE_BUFFER( sizeof(LARGE_INTEGER) );
    }
#endif  // !KMODE_RNG



    //
    // ** system time, in ms, sec, min (date & time)
    //

#ifndef KMODE_RNG
    {
        PSYSTEMTIME psysTime = (PSYSTEMTIME)pbCurrentBuffer;

        VERIFY_BUFFER( sizeof( *psysTime ) );
        GetLocalTime(psysTime);
        UPDATE_BUFFER( sizeof( *psysTime ) );
    }
#else
    {

        PSYSTEM_TIMEOFDAY_INFORMATION pTimeOfDay;
        ULONG cbSystemInfo;

        pTimeOfDay = (PSYSTEM_TIMEOFDAY_INFORMATION)pbCurrentBuffer;

        VERIFY_BUFFER( sizeof(*pTimeOfDay) );

        _NtQuerySystemInformation(
                    SystemTimeOfDayInformation,
                    pTimeOfDay,
                    sizeof(*pTimeOfDay),
                    &cbSystemInfo
                    );

        UPDATE_BUFFER(  cbSystemInfo );
    }

#endif  // !KMODE_RNG

    //
    // ** hi-res performance counter (system counters)
    //

    {
        LARGE_INTEGER   *pliPerfCount = (PLARGE_INTEGER)pbCurrentBuffer;

        VERIFY_BUFFER( sizeof(*pliPerfCount) );
#ifndef KMODE_RNG
        QueryPerformanceCounter(pliPerfCount);
#else
///        ZwQueryPerformanceCounter(pliPerfCount, NULL);
//      Defined in zwapi.h, but not exported by ntoskrnl.exe ???
#endif  // !KMODE_RNG
        UPDATE_BUFFER( sizeof(*pliPerfCount) );
    }



#ifndef KMODE_RNG

    //
    // memory status
    //

    {
        MEMORYSTATUS *pmstMemStat = (MEMORYSTATUS *)pbCurrentBuffer;

        VERIFY_BUFFER( sizeof(*pmstMemStat) );

        pmstMemStat->dwLength = sizeof(MEMORYSTATUS);
        GlobalMemoryStatus( pmstMemStat );

        UPDATE_BUFFER( sizeof(*pmstMemStat) );
    }

#endif  // !KMODE_RNG


    //
    // free disk clusters
    //

#ifndef KMODE_RNG

    {
        PDWORD pdwDiskInfo = (PDWORD)pbCurrentBuffer;

        VERIFY_BUFFER( (sizeof(DWORD) * 4) );

        GetDiskFreeSpace(
                    NULL,
                    &pdwDiskInfo[0],    // sectors per cluster
                    &pdwDiskInfo[1],    // bytes per sector
                    &pdwDiskInfo[2],    // number of free clusters
                    &pdwDiskInfo[3]     // total number of clusters
                    );

        UPDATE_BUFFER( (sizeof(DWORD) * 4) );
    }
#endif  // !KMODE_RNG


#ifndef KMODE_RNG
    {

        //
        // hash the entire user environment block.
        // we do this instead of GetUserName & GetComputerName,
        // as the environment block contains these values, plus additional
        // values.
        //

        static BOOL fHashedEnv;
        static BYTE HashEnv[ MD4_LEN ];

        if( !fHashedEnv ) {

            LPVOID lpEnvBlock;
            BOOL fAnsi = FALSE;

            //
            // try the Unicode version first, as, on WinNT, this returns us
            // a pointer to the existing Unicode environment block, rather
            // than an allocated copy.  Fallback to ANSI if this fails (eg: Win9x)
            //

            lpEnvBlock = GetEnvironmentStringsW();
            if( lpEnvBlock == NULL )
            {
                lpEnvBlock = GetEnvironmentStringsA();
                fAnsi = TRUE;
            }


            if( lpEnvBlock != NULL ) {

                ULONG cbEntry;
                PBYTE pbEntry;
                MD4_CTX MD4Ctx;


                MD4Init( &MD4Ctx );

                pbEntry = (PBYTE)lpEnvBlock;
                cbEntry = 0;

                do {

                    if( !fAnsi ) {
                        pbEntry += (cbEntry + sizeof(WCHAR));
                        cbEntry = lstrlenW( (LPWSTR)pbEntry ) * sizeof(WCHAR);
                    } else {
                        pbEntry += (cbEntry + sizeof(CHAR));
                        cbEntry = lstrlenA( (LPSTR)pbEntry ) * sizeof(CHAR);
                    }

                    MD4Update(
                        &MD4Ctx,
                        (unsigned char *)pbEntry,
                        (unsigned int)cbEntry
                        );

                } while( cbEntry );


                MD4Final( &MD4Ctx );

                CopyMemory( HashEnv, MD4Ctx.digest, sizeof(HashEnv) );

                if( !fAnsi ) {
                    FreeEnvironmentStringsW( lpEnvBlock );
                } else {
                    FreeEnvironmentStringsA( lpEnvBlock );
                }
            }

            //
            // only try this once.  if it failed once, it will likely never
            // succeed.
            //

            fHashedEnv = TRUE;
        }

        VERIFY_BUFFER( (sizeof(HashEnv)) );
        CopyMemory( pbCurrentBuffer, HashEnv, sizeof(HashEnv) );
        UPDATE_BUFFER( (sizeof(HashEnv)) );
    }
#endif  // !KMODE_RNG

    //
    // this code path has been moved to the end so that our CombineRand()
    // operation on NT mixes in with everything slammed into the
    // rand context buffer.
    //

#ifndef KMODE_RNG
    if(!IsRNGWinNT()) {

        //
        // only user info if we are not running on NT.
        // this prevents deadlocks on WinNT when the RNG is called from CSRSS
        //

        POINT   *ppoint;
        LONG    *plTime;

        //
        // cursor position
        //

        ppoint = (POINT*)pbCurrentBuffer;

        VERIFY_BUFFER( sizeof(*ppoint) );
        _GetCursorPos(ppoint);
        UPDATE_BUFFER( sizeof(*ppoint) );

        //
        // last messages' timestamp
        //

        plTime = (LONG*)pbCurrentBuffer;

        VERIFY_BUFFER( sizeof(*plTime) );
        *plTime = _GetMessageTime();
        UPDATE_BUFFER( sizeof(*plTime) );


    } else
#endif  // !KMODE_RNG
    {
        unsigned char *pbCounterState = (unsigned char*)pbCurrentBuffer;
        unsigned long cbCounterState = 64;

        VERIFY_BUFFER(cbCounterState);

        if(GatherCPUSpecificCounters( pbCounterState, &cbCounterState )) {
            UPDATE_BUFFER( cbCounterState );
        }


        //
        // call NtQuerySystemInformation on NT if available.
        //

        if( (void*)_NtQuerySystemInformation ) {

            PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION pSystemProcessorPerformanceInfo;
            PSYSTEM_PERFORMANCE_INFORMATION pSystemPerformanceInfo;
            PSYSTEM_EXCEPTION_INFORMATION pSystemExceptionInfo;
            PSYSTEM_LOOKASIDE_INFORMATION pSystemLookasideInfo;
            PSYSTEM_INTERRUPT_INFORMATION pSystemInterruptInfo;
            PSYSTEM_PROCESS_INFORMATION pSystemProcessInfo;
            ULONG cbSystemInfo;
            NTSTATUS Status;

            //
            // fixed length system info calls.
            //

            pSystemProcessorPerformanceInfo = (PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION)pbCurrentBuffer;

            VERIFY_BUFFER( sizeof(*pSystemProcessorPerformanceInfo) );

            Status = _NtQuerySystemInformation(
                        SystemProcessorPerformanceInformation,
                        pSystemProcessorPerformanceInfo,
                        sizeof(*pSystemProcessorPerformanceInfo),
                        &cbSystemInfo
                        );

            if ( NT_SUCCESS(Status) ) {
                UPDATE_BUFFER( cbSystemInfo );
            }

            pSystemPerformanceInfo = (PSYSTEM_PERFORMANCE_INFORMATION)pbCurrentBuffer;

            VERIFY_BUFFER( sizeof(*pSystemPerformanceInfo) );

            Status = _NtQuerySystemInformation(
                        SystemPerformanceInformation,
                        pSystemPerformanceInfo,
                        sizeof(*pSystemPerformanceInfo),
                        &cbSystemInfo
                        );

            if ( NT_SUCCESS(Status) ) {
                UPDATE_BUFFER(  cbSystemInfo );
            }

            pSystemExceptionInfo = (PSYSTEM_EXCEPTION_INFORMATION)pbCurrentBuffer;

            VERIFY_BUFFER( sizeof(*pSystemExceptionInfo) );

            Status = _NtQuerySystemInformation(
                        SystemExceptionInformation,
                        pSystemExceptionInfo,
                        sizeof(*pSystemExceptionInfo),
                        &cbSystemInfo
                        );

            if ( NT_SUCCESS(Status) ) {
                UPDATE_BUFFER( cbSystemInfo );
            }

            pSystemLookasideInfo = (PSYSTEM_LOOKASIDE_INFORMATION)pbCurrentBuffer;

            VERIFY_BUFFER( sizeof(*pSystemLookasideInfo) );

            Status = _NtQuerySystemInformation(
                        SystemLookasideInformation,
                        pSystemLookasideInfo,
                        sizeof(*pSystemLookasideInfo),
                        &cbSystemInfo
                        );

            if ( NT_SUCCESS(Status) ) {
                UPDATE_BUFFER( cbSystemInfo );
            }

            //
            // variable length system info calls.
            //

            pSystemInterruptInfo = (PSYSTEM_INTERRUPT_INFORMATION)pbCurrentBuffer;
            cbSystemInfo = cbBufferRemaining;

            Status = _NtQuerySystemInformation(
                        SystemInterruptInformation,
                        pSystemInterruptInfo,
                        cbSystemInfo,
                        &cbSystemInfo
                        );

            if ( NT_SUCCESS(Status) ) {
                UPDATE_BUFFER( cbSystemInfo );
            }

            pSystemProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pbCurrentBuffer;
            cbSystemInfo = cbBufferRemaining;

            Status = _NtQuerySystemInformation(
                        SystemProcessInformation,
                        pSystemProcessInfo,
                        cbSystemInfo,
                        &cbSystemInfo
                        );

            if ( NT_SUCCESS(Status) ) {
                UPDATE_BUFFER( cbSystemInfo );
            }

        } // _NtQuerySystemInformation
    }

#ifdef KMODE_RNG
#ifdef USE_HW_RNG
#ifdef _M_IX86
    // attempt to get bits from the INTEL HW RNG
    {
        DWORD rgdwHWRandom[NUM_HW_DWORDS_TO_GATHER];
        NTSTATUS Status;


        VERIFY_BUFFER( sizeof(rgdwHWRandom) );

        Status = QueryForHWRandomBits(
                    rgdwHWRandom,
                    NUM_HW_DWORDS_TO_GATHER
                    );

        if ( NT_SUCCESS(Status) ) {
            UPDATE_BUFFER( sizeof(rgdwHWRandom) );
        }

    }
#endif // _M_IX86
#endif // USE_HW_RNG
#endif // KMODE_RNG

finished:

    {
        RC4_KEYSTRUCT rc4Key;
        BYTE NewSeed[ sizeof(g_VeryLargeHash) ];
        BYTE LocalHash[ sizeof( g_VeryLargeHash ) ];
        DWORD cbBufferSize;

        RtlCopyMemory( LocalHash, g_VeryLargeHash, sizeof(g_VeryLargeHash) );

        rc4_key( &rc4Key, sizeof(LocalHash), LocalHash );

        cbBufferSize = cbWorkingBuffer - cbBufferRemaining;
        if( cbBufferSize > cbWorkingBuffer )
            cbBufferSize = cbWorkingBuffer;

        fRet = VeryLargeHashUpdate(
                    pbWorkingBuffer,                    // buffer to hash
                    cbBufferSize,
                    LocalHash
                    );

        RtlCopyMemory( NewSeed, LocalHash, sizeof(LocalHash) );
        RtlCopyMemory( g_VeryLargeHash, LocalHash, sizeof(LocalHash) );
        rc4( &rc4Key, sizeof( NewSeed ), NewSeed );

        //
        // write seed out.
        //

        WriteSeed( NewSeed, sizeof(NewSeed) );
        RtlZeroMemory( NewSeed, sizeof(NewSeed) );

        rc4_key( &rc4Key, sizeof(LocalHash), LocalHash );
        RtlZeroMemory( LocalHash, sizeof(LocalHash) );

        rc4( &rc4Key, *pcbRandomKey, pbRandomKey );
        RtlZeroMemory( &rc4Key, sizeof(rc4Key) );


        if( pbWorkingBuffer ) {
            FREE( pbWorkingBuffer );
        }
    }

    return fRet;

#endif // WINNT_RNG

}



#ifndef KMODE_RNG

BOOL
GatherRandomKeyFastUserMode(
    IN      BYTE            *pbUserSeed,
    IN      DWORD           cbUserSeed,
    IN  OUT BYTE            *pbRandomKey,
    IN  OUT DWORD           *pcbRandomKey
    )
/*++

    This routine attempts to gather RNG re-seed material for usermode callers
    from the Kernel mode version of the RNG.  This is accomplished by making
    a device IOCTL into the ksecdd.sys device driver.

--*/
{
    HANDLE hFile;
    NTSTATUS Status;

    if(!IsRNGWinNT())
        return FALSE;

    hFile = g_hKsecDD;

    if( hFile == NULL ) {

        UNICODE_STRING DriverName;
        OBJECT_ATTRIBUTES ObjA;
        IO_STATUS_BLOCK IOSB;
        HANDLE hPreviousValue;

        //
        // call via the ksecdd.sys device driver to get the random bits.
        //

        if( _NtOpenFile == NULL || _RtlInitUnicodeString == NULL ) {
            return FALSE;
        }

        //
        // have to use the Nt flavor of the file open call because it's a base
        // device not aliased to \DosDevices
        //

        _RtlInitUnicodeString( &DriverName, DD_KSEC_DEVICE_NAME_U );
        InitializeObjectAttributes(
                    &ObjA,
                    &DriverName,
                    OBJ_CASE_INSENSITIVE,
                    0,
                    0
                    );

        Status = _NtOpenFile(
                    &hFile,
                    SYNCHRONIZE | FILE_READ_DATA,
                    &ObjA,
                    &IOSB,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_SYNCHRONOUS_IO_ALERT
                    );


        if( !NT_SUCCESS(Status) )
            return FALSE;

        hPreviousValue = INTERLOCKEDCOMPAREEXCHANGEPOINTER(
                                        &g_hKsecDD,
                                        hFile,
                                        NULL
                                        );

        if( hPreviousValue != NULL ) {

            //
            // race condition, set current value to previously initialized version.
            //

            CloseHandle( hFile );
            hFile = hPreviousValue;
        }
    }

    return DeviceIoControl(
                hFile,
                IOCTL_KSEC_RNG_REKEY,   // indicate a RNG rekey
                pbUserSeed,             // input buffer (existing material)
                cbUserSeed,             // input buffer size
                pbRandomKey,            // output buffer
                *pcbRandomKey,          // output buffer size
                pcbRandomKey,           // bytes written to output buffer
                NULL
                );
}


BOOL
IsRNGWinNT(
    VOID
    )
/*++

    This function determines if we are running on Windows NT and furthermore,
    if it is appropriate to make use of certain user operations where the
    code is running.

    If the function returns TRUE, the caller cannot make calls to user
    based function and should use an alternative approach such as
    NtQuerySystemInformation.

    If the function returns FALSE, the caller can safely call user based
    functions to gather random material.

--*/
{
    static BOOL fIKnow = FALSE;

    // we assume WinNT in case of error.
    static BOOL fIsWinNT = TRUE;

    OSVERSIONINFO osVer;

    if(fIKnow)
        return(fIsWinNT);

    RtlZeroMemory(&osVer, sizeof(osVer));
    osVer.dwOSVersionInfoSize = sizeof(osVer);

    if( GetVersionEx(&osVer) ) {
        fIsWinNT = (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT);

        if( fIsWinNT ) {
#ifndef WINNT_RNG
            //
            // if we're on NT, collect entry point address.
            //
            HMODULE hNTDll = GetModuleHandleW( L"ntdll.dll" );

            if( hNTDll ) {
                _NtQuerySystemInformation = (NTQUERYSYSTEMINFORMATION)GetProcAddress(
                                hNTDll,
                                "NtQuerySystemInformation"
                                );

                //
                // On WinNT, adjust the rekey param to be a much larger value
                // because we have more entropy to key from.
                //

                if( _NtQuerySystemInformation )
                    g_dwRC4RekeyParam = RC4_REKEY_PARAM_NT;

                _NtOpenFile = (NTOPENFILE)GetProcAddress(
                                hNTDll,
                                "NtOpenFile"
                                );

                _RtlInitUnicodeString = (RTLINITUNICODESTRING)GetProcAddress(
                                hNTDll,
                                "RtlInitUnicodeString"
                                );
            }
#else
            g_dwRC4RekeyParam = RC4_REKEY_PARAM_NT;
#endif
        } else {
            //
            // collect entry point addresses for Win95
            //
            HMODULE hUser32 = LoadLibraryA("user32.dll");

            if( hUser32 ) {
                _GetCursorPos = (GETCURSORPOS)GetProcAddress(
                                hUser32,
                                "GetCursorPos"
                                );

                _GetMessageTime = (GETMESSAGETIME)GetProcAddress(
                                hUser32,
                                "GetMessageTime"
                                );
            }

        }
    }

    // even on an error, this is as good as it gets
    fIKnow = TRUE;

    return fIsWinNT;
}

#endif  // !KMODE_RNG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\randlib\umkm.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    umkm.c

Abstract:

    Macros to simplify usermode & kernelmode shared code.

Author:

    Scott Field (sfield)    19-Sep-99

--*/

#ifndef KMODE_RNG

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <zwapi.h>

#else

#include <ntosp.h>
#include <windef.h>

#endif  // KMODE_RNG

#include "umkm.h"


#ifdef WIN95_RNG

PVOID
InterlockedCompareExchangePointerWin95(
    PVOID *Destination,
    PVOID Exchange,
    PVOID Comperand
    )
/*++

    routine to allow Win95 to work.  Isn't atomic, but Win95 doesn't support
    multiple processors.  The worst case is we leak resources as a result,
    since we only use CompareExchange for initialization purposes.

--*/
{
    PVOID InitialValue;

    typedef PVOID INTERLOCKEDCOMPAREEXCHANGE(PVOID*, PVOID, PVOID);
    static BOOL fKnown;
    static INTERLOCKEDCOMPAREEXCHANGE *pilock;

    if( !fKnown ) {

        //
        // hacky code to bring in InterlockedCompareExchange, since
        // Win95 doesn't export it.
        //

        HMODULE hMod = LoadLibraryA( "kernel32.dll" );

        if( hMod  ) {
            pilock = (INTERLOCKEDCOMPAREEXCHANGE*)GetProcAddress( hMod, "InterlockedCompareExchange" );
        }

        fKnown = TRUE;
    }

    if( pilock != NULL ) {
        return pilock( Destination, Exchange, Comperand );
    }


    InitialValue = *Destination;

    if ( InitialValue == Comperand ) {
        *Destination = Exchange;
    }

    return InitialValue;
}

#endif  // WIN95_RNG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\randlib\vlhash.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Abstract:

    Build up a "Very Large Hash" based on arbitrary sized input data
    of size cbData specified by the pvData buffer.

    This implementation updates a 640bit hash, which is internally based on
    multiple invocations of a modified SHA-1 which doesn't implement endian
    conversion internally.

Author:

    Scott Field (sfield)    24-Sep-98

--*/

#ifndef KMODE_RNG

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#else

#include <ntifs.h>
#include <windef.h>

#endif  // KMODE_RNG

#include <sha.h>

#include "vlhash.h"

#ifdef KMODE_RNG
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, VeryLargeHashUpdate)
#endif  // ALLOC_PRAGMA
#endif  // KMODE_RNG


BOOL
VeryLargeHashUpdate(
    IN      VOID *pvData,   // data from perfcounters, user supplied, etc.
    IN      DWORD cbData,
    IN  OUT BYTE VeryLargeHash[A_SHA_DIGEST_LEN * 4]
    )
{
    //
    // pointers to 1/4 size chunks of seed pointed to by VeryLargeHash
    //

    DWORD cbSeedChunk;
    PBYTE pSeed1;
    PBYTE pSeed2;
    PBYTE pSeed3;
    PBYTE pSeed4;

    //
    // pointers to 1/4 size chunks of data pointed to by pData
    //

    DWORD cbDataChunk;
    PBYTE pData1;
    PBYTE pData2;
    PBYTE pData3;
    PBYTE pData4;

    //
    // pointers to individual intermediate hash within IntermediateHashes
    //

    PBYTE IHash1;
    PBYTE IHash2;
    PBYTE IHash3;
    PBYTE IHash4;
    BYTE IntermediateHashes[ A_SHA_DIGEST_LEN * 4 ];

    //
    // pointer to output hash within VeryLargeHash buffer.
    //

    PBYTE OutputHash;

    A_SHA_CTX shaContext;


#ifdef KMODE_RNG
    PAGED_CODE();
#endif  // KMODE_RNG

    //
    // check parameters
    //


    if( VeryLargeHash == NULL || pvData == NULL )
        return FALSE;

    //
    // break up input blocks into 1/4 size chunks.
    //


    cbSeedChunk = A_SHA_DIGEST_LEN;
    cbDataChunk = cbData / 4;

    if( cbDataChunk == 0 )
        return FALSE;


    pSeed1 = VeryLargeHash;
    pSeed2 = pSeed1 + cbSeedChunk;

    pData1 = (PBYTE)pvData;
    pData2 = pData1 + cbDataChunk;

    IHash1 = IntermediateHashes;
    IHash2 = IHash1 + A_SHA_DIGEST_LEN;

    //
    // round 1
    //

    A_SHAInit( &shaContext );
    A_SHAUpdateNS( &shaContext, pSeed1, cbSeedChunk );
    A_SHAUpdateNS( &shaContext, pData1, cbDataChunk );
    A_SHAUpdateNS( &shaContext, pSeed2, cbSeedChunk );
    A_SHAUpdateNS( &shaContext, pData2, cbDataChunk );
    A_SHAFinalNS( &shaContext, IHash1 );

    //
    // round 2
    //

    A_SHAInit( &shaContext );
    A_SHAUpdateNS( &shaContext, pSeed2, cbSeedChunk );
    A_SHAUpdateNS( &shaContext, pData2, cbDataChunk );
    A_SHAUpdateNS( &shaContext, pSeed1, cbSeedChunk );
    A_SHAUpdateNS( &shaContext, pData1, cbDataChunk );
    A_SHAFinalNS( &shaContext, IHash2 );


    pSeed3 = pSeed2 + cbSeedChunk;
    pSeed4 = pSeed3 + cbSeedChunk;

    pData3 = pData2 + cbDataChunk;
    pData4 = pData3 + cbDataChunk;

    IHash3 = IHash2 + A_SHA_DIGEST_LEN;
    IHash4 = IHash3 + A_SHA_DIGEST_LEN;

    //
    // round 3
    //

    A_SHAInit( &shaContext );
    A_SHAUpdateNS( &shaContext, pSeed3, cbSeedChunk );
    A_SHAUpdateNS( &shaContext, pData3, cbDataChunk );
    A_SHAUpdateNS( &shaContext, pSeed4, cbSeedChunk );
    A_SHAUpdateNS( &shaContext, pData4, cbDataChunk );
    A_SHAFinalNS( &shaContext, IHash3 );

    //
    // round 4
    //

    A_SHAInit( &shaContext );
    A_SHAUpdateNS( &shaContext, pSeed4, cbSeedChunk );
    A_SHAUpdateNS( &shaContext, pData4, cbDataChunk );
    A_SHAUpdateNS( &shaContext, pSeed3, cbSeedChunk );
    A_SHAUpdateNS( &shaContext, pData3, cbDataChunk );
    A_SHAFinalNS( &shaContext, IHash4 );



    //
    // round 5
    //

    OutputHash = VeryLargeHash;

    A_SHAInit( &shaContext );
    A_SHAUpdateNS( &shaContext, IHash1, A_SHA_DIGEST_LEN );
    A_SHAUpdateNS( &shaContext, IHash3, A_SHA_DIGEST_LEN );
    A_SHAFinalNS( &shaContext, OutputHash );

    //
    // round 6
    //

    OutputHash += A_SHA_DIGEST_LEN;

    A_SHAInit( &shaContext );
    A_SHAUpdateNS( &shaContext, IHash2, A_SHA_DIGEST_LEN );
    A_SHAUpdateNS( &shaContext, IHash4, A_SHA_DIGEST_LEN );
    A_SHAFinalNS( &shaContext, OutputHash );

    //
    // round 7
    //

    OutputHash += A_SHA_DIGEST_LEN;

    A_SHAInit( &shaContext );
    A_SHAUpdateNS( &shaContext, IHash3, A_SHA_DIGEST_LEN );
    A_SHAUpdateNS( &shaContext, IHash1, A_SHA_DIGEST_LEN );
    A_SHAFinalNS( &shaContext, OutputHash );

    //
    // round 8
    //

    OutputHash += A_SHA_DIGEST_LEN;

    A_SHAInit( &shaContext );
    A_SHAUpdateNS( &shaContext, IHash4, A_SHA_DIGEST_LEN );
    A_SHAUpdateNS( &shaContext, IHash2, A_SHA_DIGEST_LEN );
    A_SHAFinalNS( &shaContext, OutputHash );


    RtlZeroMemory( &shaContext, sizeof(shaContext) );
    RtlZeroMemory( IntermediateHashes, sizeof(IntermediateHashes) );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\randlib\umkm.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    umkm.h

Abstract:

    Macros to simplify usermode & kernelmode shared code.

Author:

    Scott Field (sfield)    19-Sep-99

--*/

#ifndef __UMKM_H__
#define __UMKM_H__



#ifndef KMODE_RNG



#define __LOCK_TYPE     CRITICAL_SECTION

#define INIT_LOCK(x)    InitializeCriticalSection(x)
//#define INIT_LOCK(x)    InitializeCriticalSectionAndSpinCount(x, 0x333)
#define DELETE_LOCK(x)  DeleteCriticalSection(x)
#define ENTER_LOCK(x)   EnterCriticalSection(x)
#define LEAVE_LOCK(x)   LeaveCriticalSection(x)
#define ALLOC(cb)       HeapAlloc(GetProcessHeap(), 0, cb)
#define ALLOC_NP(cb)    ALLOC(cb)
#define FREE(pv)        HeapFree(GetProcessHeap(), 0, pv)

#define REGCLOSEKEY(x)  RegCloseKey( x )

#ifdef WIN95_RNG

PVOID
InterlockedCompareExchangePointerWin95(
    PVOID *Destination,
    PVOID Exchange,
    PVOID Comperand
    );

#define INTERLOCKEDCOMPAREEXCHANGEPOINTER(x,y,z)    InterlockedCompareExchangePointerWin95(x,y,z)
#else
#define INTERLOCKEDCOMPAREEXCHANGEPOINTER(x,y,z)    InterlockedCompareExchangePointer(x,y,z)
#endif  // WIN95_RNG


#else

//#define __LOCK_TYPE     KSPIN_LOCK
#define __LOCK_TYPE     ERESOURCE

#define RNG_TAG 'cesK'

//#define INIT_LOCK(x)    KeInitializeSpinLock( x )
//#define DELETE_LOCK(x)
//#define ENTER_LOCK(x)   ExAcquireSpinLock( x, &OldIrql )
//#define LEAVE_LOCK(x)   ExReleaseSpinLock( x, OldIrql )
#define ALLOC(cb)       ExAllocatePoolWithTag(PagedPool, cb, RNG_TAG)
#define ALLOC_NP(cb)    ExAllocatePoolWithTag(NonPagedPool, cb, RNG_TAG)
#define FREE(pv)        ExFreePool(pv)


#define INIT_LOCK(x)    ExInitializeResourceLite( x )
#define DELETE_LOCK(x)  ExDeleteResourceLite( x )
#define ENTER_LOCK(x)   KeEnterCriticalRegion(); ExAcquireResourceExclusiveLite( x, TRUE )
#define LEAVE_LOCK(x)   ExReleaseResourceLite( x ); KeLeaveCriticalRegion()

#define REGCLOSEKEY(x)  ZwClose( x )

#define INTERLOCKEDCOMPAREEXCHANGEPOINTER(x,y,z)    InterlockedCompareExchangePointer(x,y,z)

#endif


#endif  // __UMKM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\randlib\vlhash.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Abstract:

    Build up a "Very Large Hash" based on arbitrary sized input data
    of size cbData specified by the pvData buffer.

    This implementation updates a 640bit hash, which is internally based on
    multiple invocations of a modified SHA-1 which doesn't implement endian
    conversion internally.

Author:

    Scott Field (sfield)    24-Sep-98

--*/

#ifndef __VLHASH_H__
#define __VLHASH_H__

BOOL
VeryLargeHashUpdate(
    IN      VOID *pvData,   // data from perfcounters, user supplied, etc.
    IN      DWORD cbData,
    IN  OUT BYTE VeryLargeHash[A_SHA_DIGEST_LEN * 4]
    );

#endif  // __VLHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\rsaaes\des3.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : des3.c                                                 //
//  DESCRIPTION   : Crypto CP interfaces:                                  //
//                  CPEncrypt                                              //
//                  CPDecrypt                                              //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Sep 13 1996 jeffspel Created                                       //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

//#include <wtypes.h>
#include "precomp.h"
#include "nt_rsa.h"
#include "des3.h"

static BYTE l_ParityTable[] = {0x00,0x01,0x01,0x02,0x01,0x02,0x02,0x03,
                               0x01,0x02,0x02,0x03,0x02,0x03,0x03,0x04};


// In des2key.c:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 2 * DES_BLOCKLEN
//   bytes of key.
//
//

void
des2key(
    PDES3TABLE pDES3Table,
    PBYTE pbKey)
{
    deskey(&pDES3Table->keytab1, pbKey);
    deskey(&pDES3Table->keytab2, pbKey+DES_KEYSIZE);
    CopyMemory(&pDES3Table->keytab3, &pDES3Table->keytab1, DES_TABLESIZE);
}


// In des3key.c:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 3 * DES_BLOCKLEN
//   bytes of key.
//
//

void
des3key(
    PDES3TABLE pDES3Table,
    PBYTE pbKey)
{
    deskey(&pDES3Table->keytab1, pbKey);
    deskey(&pDES3Table->keytab2, pbKey+DES_KEYSIZE);
    deskey(&pDES3Table->keytab3, pbKey+2*DES_KEYSIZE);
}


//
//   Encrypt or decrypt with the key in DES3Table
//

void
des3(
    PBYTE pbOut,
    PBYTE pbIn,
    void *pKey,
    int op)
{
    PDES3TABLE  pDES3Table = (PDES3TABLE)pKey;
    BYTE        rgbEnc1[DES_BLOCKLEN];
    BYTE        rgbEnc2[DES_BLOCKLEN];

    if (ENCRYPT == op)      // encrypt case
    {
        des(rgbEnc1, pbIn, &pDES3Table->keytab1, ENCRYPT);
        des(rgbEnc2, rgbEnc1, &pDES3Table->keytab2, DECRYPT);
        memset(rgbEnc1, 0xFF, DES_BLOCKLEN);
        des(pbOut, rgbEnc2, &pDES3Table->keytab3, ENCRYPT);
        memset(rgbEnc2, 0xFF, DES_BLOCKLEN);
    }
    else                    // decrypt case
    {
        des(rgbEnc1, pbIn, &pDES3Table->keytab3, DECRYPT);
        des(rgbEnc2, rgbEnc1, &pDES3Table->keytab2, ENCRYPT);
        memset(rgbEnc1, 0xFF, DES_BLOCKLEN);
        des(pbOut, rgbEnc2, &pDES3Table->keytab1, DECRYPT);
        memset(rgbEnc2, 0xFF, DES_BLOCKLEN);
    }
}


//
// set the parity on the DES key to be odd
//

void
desparity(
    PBYTE pbKey,
    DWORD cbKey)
{
    DWORD i;

    for (i=0;i<cbKey;i++)
    {
        if (!((l_ParityTable[pbKey[i]>>4] + l_ParityTable[pbKey[i]&0x0F]) % 2))
            pbKey[i] = (BYTE)(pbKey[i] ^ 0x01);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\rsaaes\manage.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : manage.c                                               //
//  DESCRIPTION   : Misc list/memory management routines.                  //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//  Jan 25 1995 larrys  Changed from Nametag                               //
//      Feb 23 1995 larrys  Changed NTag_SetLastError to SetLastError      //
//      Apr 19 1995 larrys  Cleanup                                        //
//      Sep 11 1995 Jeffspel/ramas  Merge STT into default CSP             //
//      Oct 27 1995 rajeshk  RandSeed Stuff added hUID to PKCS2Encrypt     //
//      Nov  3 1995 larrys  Merge for NT checkin                           //
//      Nov 13 1995 larrys  Fixed memory leak                              //
//      Dec 11 1995 larrys  Added WIN95 password cache                     //
//      Dec 13 1995 larrys  Remove MTS stuff                               //
//      May 15 1996 larrys  Remove old cert stuff                          //
//      May 28 1996 larrys  Added Win95 registry install stuff             //
//      Jun 12 1996 larrys  Encrypted public keys                          //
//      Jun 26 1996 larrys  Put rsabase.sig into a resource for regsrv32   //
//      Sep 16 1996 mattt   Added Strong provider type in #define          //
//      Oct 14 1996 jeffspel Changed GenRandom to NewGenRandom             //
//      May 23 1997 jeffspel Added provider type checking                  //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "resource.h"
#include "nt_rsa.h"
#include "randlib.h"
#include "protstor.h"
#include "ole2.h"
#include "swnt_pk.h"
#include "sgccheck.h"
#include "swnt_pk.h"
#include <delayimp.h>

#define MAXITER     0xFFFF

#define RSAFULL_TYPE_STRING "Type 001"
#define RSA_SCH_TYPE_STRING "Type 012"
#define RSAAES_TYPE_STRING  "Type 024"

#define MS_RSA_TYPE         "RSA Full (Signature and Key Exchange)"
#define MS_RSA_SCH_TYPE     "RSA SChannel"
#define MS_RSAAES_TYPE      "RSA Full and AES"

#define PROVPATH            "SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider\\"
#define PROVPATH_LEN        sizeof(PROVPATH)

#define TYPEPATH            "SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider Types\\"
#define TYPEPATH_LEN        sizeof(TYPEPATH)

HINSTANCE g_hInstance;

extern DWORD SelfMACCheck(IN LPSTR pszImage);

static CHAR l_szImagePath[MAX_PATH];

#define KEYSIZE1024 0x88

#if 0
struct _mskey
{
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} MSKEY = {
    {
        0x2bad85ae,
        0x883adacc,
        0xb32ebd68,
        0xa7ec8b06,
        0x58dbeb81,
    },
    {
        0x42, 0x34, 0xb7, 0xab, 0x45, 0x0f, 0x60, 0xcd,
            0x8f, 0x77, 0xb5, 0xd1, 0x79, 0x18, 0x34, 0xbe,
            0x66, 0xcb, 0x5c, 0x66, 0x4a, 0x9f, 0x03, 0x18,
            0x13, 0x36, 0x8e, 0x88, 0x21, 0x78, 0xb1, 0x94,
            0xa1, 0xd5, 0x8f, 0x8c, 0xa5, 0xd3, 0x9f, 0x86,
            0x43, 0x89, 0x05, 0xa0, 0xe3, 0xee, 0xe2, 0xd0,
            0xe5, 0x1d, 0x5f, 0xaf, 0xff, 0x85, 0x71, 0x7a,
            0x0a, 0xdb, 0x2e, 0xd8, 0xc3, 0x5f, 0x2f, 0xb1,
            0xf0, 0x53, 0x98, 0x3b, 0x44, 0xee, 0x7f, 0xc9,
            0x54, 0x26, 0xdb, 0xdd, 0xfe, 0x1f, 0xd0, 0xda,
            0x96, 0x89, 0xc8, 0x9e, 0x2b, 0x5d, 0x96, 0xd1,
            0xf7, 0x52, 0x14, 0x04, 0xfb, 0xf8, 0xee, 0x4d,
            0x92, 0xd1, 0xb6, 0x37, 0x6a, 0xe0, 0xaf, 0xde,
            0xc7, 0x41, 0x06, 0x7a, 0xe5, 0x6e, 0xb1, 0x8c,
            0x8f, 0x17, 0xf0, 0x63, 0x8d, 0xaf, 0x63, 0xfd,
            0x22, 0xc5, 0xad, 0x1a, 0xb1, 0xe4, 0x7a, 0x6b,
            0x1e, 0x0e, 0xea, 0x60, 0x56, 0xbd, 0x49, 0xd0,
    }
};

struct _key
{
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} KEY = {
    {
        0x3fcbf1a9,
        0x08f597db,
        0xe4aecab4,
        0x75360f90,
        0x9d6c0f00,
    },
    {
        0x85, 0xdd, 0x9b, 0xf4, 0x4d, 0x0b, 0xc4, 0x96,
            0x3e, 0x79, 0x86, 0x30, 0x6d, 0x27, 0x31, 0xee,
            0x4a, 0x85, 0xf5, 0xff, 0xbb, 0xa9, 0xbd, 0x81,
            0x86, 0xf2, 0x4f, 0x87, 0x6c, 0x57, 0x55, 0x19,
            0xe4, 0xf4, 0x49, 0xa3, 0x19, 0x27, 0x08, 0x82,
            0x9e, 0xf9, 0x8a, 0x8e, 0x41, 0xd6, 0x91, 0x71,
            0x47, 0x48, 0xee, 0xd6, 0x24, 0x2d, 0xdd, 0x22,
            0x72, 0x08, 0xc6, 0xa7, 0x34, 0x6f, 0x93, 0xd2,
            0xe7, 0x72, 0x57, 0x78, 0x7a, 0x96, 0xc1, 0xe1,
            0x47, 0x38, 0x78, 0x43, 0x53, 0xea, 0xf3, 0x88,
            0x82, 0x66, 0x41, 0x43, 0xd4, 0x62, 0x44, 0x01,
            0x7d, 0xb2, 0x16, 0xb3, 0x50, 0x89, 0xdb, 0x0a,
            0x93, 0x17, 0x02, 0x02, 0x46, 0x49, 0x79, 0x76,
            0x59, 0xb6, 0xb1, 0x2b, 0xfc, 0xb0, 0x9a, 0x21,
            0xe6, 0xfa, 0x2d, 0x56, 0x07, 0x36, 0xbc, 0x13,
            0x7f, 0x1c, 0xde, 0x55, 0xfb, 0x0d, 0x67, 0x0f,
            0xc2, 0x17, 0x45, 0x8a, 0x14, 0x2b, 0xba, 0x55,
    }
};
#endif

#if 0
NTVersion(
    void)
{
    static BOOL dwVersion = 0;

    OSVERSIONINFO osVer;

    memset(&osVer, 0, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if(!GetVersionEx(&osVer) )
        goto ErrorExit;

    dwVersion = osVer.dwMajorVersion;
ErrorExit:
    return dwVersion;
}
#endif


/*static*/ DWORD
SetCSPInfo(
    LPSTR pszProvider,
    LPSTR pszImagePath,
    BYTE *pbSig,
    DWORD cbSig,
    DWORD dwProvType,
    LPSTR pszType,
    LPSTR pszTypeName,
    BOOL fSigInFile,
    BOOL fMakeDefault)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD   dwIgn;
    HKEY    hKey = 0;
    HKEY    hTypeKey = 0;
    DWORD   cbProv;
    BYTE    *pszProv = NULL;
    DWORD   cbTypePath;
    BYTE    *pszTypePath = NULL;
    DWORD   dwVal = 0;
    DWORD   dwSts;

    cbProv = PROVPATH_LEN + strlen(pszProvider);
    pszProv = _nt_malloc(cbProv);
    if (NULL == pszProv)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    strcpy((LPSTR)pszProv, PROVPATH);
    strcat((LPSTR)pszProv, pszProvider);

    //
    // Create or open in local machine for provider:
    //
    dwSts = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           (const char *)pszProv,
                           0L, "", REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS, NULL, &hKey,
                           &dwIgn);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    //
    // Set Image path to: scp.dll
    //
    dwSts = RegSetValueEx(hKey, "Image Path", 0L, REG_SZ,
                          (LPBYTE)pszImagePath,
                          strlen(pszImagePath) + 1);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    //
    // Set Type to: Type 003
    //
    dwSts = RegSetValueEx(hKey, "Type", 0L, REG_DWORD,
                          (LPBYTE)&dwProvType,
                          sizeof(DWORD));
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (fSigInFile)
    {
        //
        // Place signature in file value
        //
        dwSts = RegSetValueEx(hKey, "SigInFile", 0L,
                              REG_DWORD, (LPBYTE)&dwVal,
                              sizeof(DWORD));
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }
    else
    {
        //
        // Place signature
        //
        dwSts = RegSetValueEx(hKey, "Signature", 0L,
                              REG_BINARY, pbSig, cbSig);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    //
    // Create or open in local machine for provider type:
    //

    cbTypePath = TYPEPATH_LEN + strlen(pszType) + 1;
    pszTypePath = _nt_malloc(cbTypePath);
    if (NULL == pszTypePath)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    strcpy((LPSTR)pszTypePath, TYPEPATH);
    strcat((LPSTR)pszTypePath, pszType);

    dwSts = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           (LPSTR)pszTypePath,
                           0L, "", REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS, NULL, &hTypeKey,
                           &dwIgn);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if ((REG_CREATED_NEW_KEY == dwIgn) || fMakeDefault)
    {
        dwSts = RegSetValueEx(hTypeKey, "Name", 0L,
                              REG_SZ, (LPBYTE)pszProvider,
                              strlen(pszProvider) + 1);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwSts = RegSetValueEx(hTypeKey, "TypeName", 0L,
                              REG_SZ, (LPBYTE)pszTypeName,
                              strlen(pszTypeName) + 1);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (hKey)
        RegCloseKey(hKey);
    if (hTypeKey)
        RegCloseKey(hTypeKey);
    if (pszProv)
        _nt_free(pszProv, 0);
    if (pszTypePath)
        _nt_free(pszTypePath, 0);
    return dwReturn;
}


// See if a handle of the given type is in the list.
// If it is, return the data that the item holds.
void *
NTLCheckList(
    HNTAG hThisThing,
    BYTE bTypeValue)
{
    HTABLE *pTable;

    pTable = (HTABLE*)(hThisThing ^ HANDLE_MASK);

    if ((BYTE)pTable->dwType != bTypeValue)
        return NULL;

    return (void*)pTable->pItem;
}

// Find & validate the passed list item against the user and type.

DWORD
NTLValidate(
    HNTAG hItem,
    HCRYPTPROV hUID,
    BYTE bTypeValue,
    LPVOID *ppvRet)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    void        *pTmpVal;

    // check to see if the key is in the key list
    pTmpVal = NTLCheckList(hItem, bTypeValue);
    if (pTmpVal == NULL)
    {
        dwReturn = (DWORD)NTE_FAIL;     // converted by caller
        goto ErrorExit;
    }

    // check to make sure there is a key value
    if ((bTypeValue == KEY_HANDLE) &&
        (((PNTAGKeyList)pTmpVal)->pKeyValue == NULL))
    {
        ASSERT(((PNTAGKeyList)pTmpVal)->cbKeyLen == 0);
        dwReturn = (DWORD)NTE_BAD_KEY;
        goto ErrorExit;
    }

    // make sure the UIDs are the same
    if (((PNTAGKeyList)pTmpVal)->hUID != hUID)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    *ppvRet = pTmpVal;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}

// Make a new list item of the given type, and assign the data to it.

DWORD
NTLMakeItem(
    HNTAG *phItem,
    BYTE bTypeValue,
    void *NewData)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    HTABLE  *NewMember;

    NewMember = (HTABLE *)_nt_malloc(sizeof(HTABLE));
    if (NULL == NewMember)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    NewMember->pItem = NewData;
    NewMember->dwType = bTypeValue;

    *phItem = (HNTAG)((HNTAG)NewMember ^ HANDLE_MASK);
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}

// Remove the handle.  Assumes that any memory used by the handle data has
// been freed.

void
NTLDelete(
    HNTAG hItem)
{
    HTABLE  *pTable;

    pTable = (HTABLE*)(hItem ^ HANDLE_MASK);
    _nt_free(pTable, sizeof(HTABLE));
}

/****************************************************************/
/* FreeUserRec frees the dynamically allocated memory for the   */
/* appropriate fields of the UserRec structure.                 */
/*                                                              */
/* MTS: we assume that pUser has only one reference (no         */
/* MTS: multiple logon's for the same user name).               */
/****************************************************************/

void
FreeUserRec(
    PNTAGUserList pUser)
{
    if (pUser != NULL)
    {
        // No need to zero lengths, since entire struct is going away
        if (pUser->pExchPrivKey)
        {
            memnuke(pUser->pExchPrivKey, pUser->ExchPrivLen);
            _nt_free (pUser->pExchPrivKey, 0);
        }

        if (pUser->pSigPrivKey)
        {
            memnuke(pUser->pSigPrivKey, pUser->SigPrivLen);
            _nt_free (pUser->pSigPrivKey, 0);
        }

        if (pUser->pUser)
        {
            _nt_free(pUser->pUser, 0);
        }

        if (NULL != pUser->szProviderName)
        {
            _nt_free(pUser->szProviderName, 0);
        }

        if (pUser->pCachePW)
        {
            memnuke(pUser->pCachePW, STORAGE_RC4_KEYLEN);
            _nt_free(pUser->pCachePW, 0);
        }

        if (pUser->pPStore)
        {
            FreePSInfo(pUser->pPStore);
        }

#ifdef USE_SGC
        // free the SGC key info
        SGCDeletePubKeyValues(&pUser->pbSGCKeyMod,
                              &pUser->cbSGCKeyMod,
                              &pUser->dwSGCKeyExpo);
#endif

        FreeContainerInfo(&pUser->ContInfo);

        FreeOffloadInfo(pUser->pOffloadInfo);

        DeleteCriticalSection(&pUser->CritSec);

        ZeroMemory(pUser, sizeof(NTAGUserList));
        _nt_free (pUser, 0);
    }
}

// RSA private key in PRIVATEKEYBLOB format
static BYTE l_rgbRSAPriv[] =
{
    0x52, 0x53, 0x41, 0x32, 0x48, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x00, 0xEF, 0x4C, 0x0D, 0x34,
    0xCF, 0x44, 0x0F, 0xB1, 0x73, 0xAC, 0xD4, 0x9B,
    0xBE, 0xCC, 0x2D, 0x11, 0x2A, 0x2B, 0xBD, 0x21,
    0x04, 0x8E, 0xAC, 0xAD, 0xD5, 0xFC, 0xD2, 0x50,
    0x14, 0x35, 0x1B, 0x43, 0x15, 0x62, 0x67, 0x8F,
    0x5E, 0x00, 0xB9, 0x25, 0x1B, 0xE2, 0x4F, 0xBE,
    0xA1, 0x50, 0xA1, 0x44, 0x3B, 0x17, 0xD8, 0x91,
    0xF5, 0x28, 0xF9, 0xFA, 0xAE, 0xE7, 0xC0, 0xFD,
    0xB9, 0xCD, 0x76, 0x4F, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xE9, 0xBB, 0x38, 0x52,
    0xD9, 0x0D, 0x56, 0xD7, 0x36, 0xBA, 0xDC, 0xE8,
    0xB5, 0x57, 0x56, 0x13, 0x1A, 0x3A, 0x43, 0x30,
    0xDE, 0x7D, 0x76, 0x6F, 0xBB, 0x71, 0x3B, 0x0A,
    0x92, 0xBA, 0x60, 0x94, 0x00, 0x00, 0x00, 0x00,
    0x17, 0x33, 0x3D, 0xB5, 0xEF, 0xD8, 0x2B, 0xDE,
    0xCD, 0xA6, 0x6A, 0x94, 0x17, 0xC3, 0x57, 0xE9,
    0x2E, 0x1C, 0x9F, 0x35, 0xDA, 0xA4, 0xBD, 0x02,
    0x5B, 0x9D, 0xD1, 0x38, 0x4C, 0xF2, 0x19, 0x89,
    0x00, 0x00, 0x00, 0x00, 0x89, 0x21, 0xCB, 0x3F,
    0x0C, 0xA7, 0x71, 0xBC, 0xF6, 0xA1, 0x87, 0xDF,
    0x00, 0x2D, 0x27, 0x64, 0x4A, 0xD4, 0x93, 0x9F,
    0x58, 0x93, 0x4B, 0x83, 0x1E, 0xAB, 0xD8, 0x5D,
    0xBC, 0x0E, 0x58, 0x03, 0x00, 0x00, 0x00, 0x00,
    0xAB, 0x09, 0xD7, 0x21, 0xBA, 0x6F, 0x55, 0x08,
    0x12, 0xEE, 0x5B, 0x47, 0x6B, 0x9F, 0x3F, 0xD3,
    0xFC, 0xEA, 0xB5, 0x25, 0x19, 0xB7, 0x9E, 0xBD,
    0xDF, 0x6F, 0x7F, 0x96, 0x00, 0x88, 0xC6, 0x7B,
    0x00, 0x00, 0x00, 0x00, 0x95, 0x0B, 0x23, 0xC5,
    0x72, 0x98, 0x9D, 0x49, 0x7A, 0x46, 0x4E, 0xE1,
    0xE6, 0x2F, 0xC6, 0x63, 0x21, 0x8F, 0x66, 0xDC,
    0x9B, 0xCC, 0xE2, 0x27, 0x03, 0x27, 0x85, 0xF0,
    0x3A, 0x02, 0xFB, 0x40, 0x00, 0x00, 0x00, 0x00,
    0x51, 0x74, 0xF6, 0xF2, 0x23, 0xEC, 0xA1, 0x76,
    0x55, 0x58, 0x07, 0x71, 0xBF, 0x7F, 0x0A, 0x1E,
    0x6B, 0x48, 0x48, 0xBB, 0x92, 0xB6, 0x2A, 0xB1,
    0x07, 0xA4, 0x21, 0xD1, 0xC6, 0xCB, 0x5F, 0x40,
    0xCE, 0xDD, 0xBA, 0xDB, 0xFC, 0x17, 0xFB, 0xA7,
    0xBD, 0xE1, 0xF4, 0x63, 0xD8, 0x9E, 0x89, 0xE2,
    0xDD, 0x7A, 0xEC, 0x11, 0xD6, 0xA9, 0x9C, 0xBA,
    0xC7, 0x5E, 0x35, 0x96, 0xA6, 0x6F, 0x7F, 0x2C,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// RSA private key in PUBLICKEYBLOB format
static BYTE l_rgbRSAPub[] =
{
    0x52, 0x53, 0x41, 0x31, 0x48, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x00, 0xEF, 0x4C, 0x0D, 0x34,
    0xCF, 0x44, 0x0F, 0xB1, 0x73, 0xAC, 0xD4, 0x9B,
    0xBE, 0xCC, 0x2D, 0x11, 0x2A, 0x2B, 0xBD, 0x21,
    0x04, 0x8E, 0xAC, 0xAD, 0xD5, 0xFC, 0xD2, 0x50,
    0x14, 0x35, 0x1B, 0x43, 0x15, 0x62, 0x67, 0x8F,
    0x5E, 0x00, 0xB9, 0x25, 0x1B, 0xE2, 0x4F, 0xBE,
    0xA1, 0x50, 0xA1, 0x44, 0x3B, 0x17, 0xD8, 0x91,
    0xF5, 0x28, 0xF9, 0xFA, 0xAE, 0xE7, 0xC0, 0xFD,
    0xB9, 0xCD, 0x76, 0x4F, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00
};

// known result of an MD5 hash on the above buffer
static BYTE l_rgbKnownMD5[] =
{
    0xb8, 0x2f, 0x6b, 0x11, 0x31, 0xc8, 0xec, 0xf4,
    0xfe, 0x0b, 0xf0, 0x6d, 0x2a, 0xda, 0x3f, 0xc3
};

// known result of an SHA-1 hash on the above buffer
static BYTE l_rgbKnownSHA1[] =
{
    0xe8, 0x96, 0x82, 0x85, 0xeb, 0xae, 0x01, 0x14,
    0x73, 0xf9, 0x08, 0x45, 0xc0, 0x6a, 0x6d, 0x3e,
    0x69, 0x80, 0x6a, 0x0c
};

// known key, plaintext, and ciphertext for RC4
static BYTE l_rgbRC4Key[] = {0x61, 0x8a, 0x63, 0xd2, 0xfb};
static BYTE l_rgbRC4KnownPlaintext[] = {0xDC, 0xEE, 0x4C, 0xF9, 0x2C};
static BYTE l_rgbRC4KnownCiphertext[] = {0xF1, 0x38, 0x29, 0xC9, 0xDE};

// IV for all block ciphers
BYTE l_rgbIV[] = {0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF};

// known key, plaintext, and ciphertext for RC2
BYTE l_rgbRC2Key[] = {0x59, 0x45, 0x9a, 0xf9, 0x27, 0x84, 0x74, 0xCA};
BYTE l_rgbRC2KnownPlaintext[] = {0xD5, 0x58, 0x75, 0x12, 0xCE, 0xEF, 0x77, 0x93};
BYTE l_rgbRC2KnownCiphertext[] = {0x7b, 0x98, 0xdf, 0x9d, 0xa2, 0xdc, 0x7b, 0x7a};
BYTE l_rgbRC2CBCCiphertext[] = {0x9d, 0x93, 0x8e, 0xf6, 0x7c, 0x01, 0x5e, 0xeb};

// known key, plaintext, and ciphertext for DES40 (CALG_CYLINK_MEK)
BYTE l_rgbDES40Key[] = {0x01, 0x23, 0x04, 0x67, 0x08, 0xab, 0x0d, 0xef};
BYTE l_rgbDES40KnownPlaintext[] = {0x4E, 0x6F, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74};
BYTE l_rgbDES40KnownCiphertext[] = {0xac, 0x97, 0x4d, 0xd9, 0x02, 0x13, 0x88, 0x2c};
BYTE l_rgbDES40CBCCiphertext[] = {0x47, 0xdc, 0xf0, 0x13, 0x7f, 0xa5, 0xd6, 0x32};

// known key, plaintext, and ciphertext for DES
BYTE l_rgbDESKey[] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef};
BYTE l_rgbDESKnownPlaintext[] = {0x4E, 0x6F, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74};
BYTE l_rgbDESKnownCiphertext[] = {0x3F, 0xA4, 0x0E, 0x8A, 0x98, 0x4D, 0x48, 0x15};
BYTE l_rgbDESCBCCiphertext[] = {0xE5, 0xC7, 0xCD, 0xDE, 0x87, 0x2B, 0xF2, 0x7C};

// known key, plaintext, and ciphertext for 3 key 3DES
BYTE l_rgb3DESKey[] =
{
    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,
    0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23
};
BYTE l_rgb3DESKnownPlaintext[] = {0x4E, 0x6F, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74};
BYTE l_rgb3DESKnownCiphertext[] = {0x31, 0x4F, 0x83, 0x27, 0xFA, 0x7A, 0x09, 0xA8};
BYTE l_rgb3DESCBCCiphertext[] = {0xf3, 0xc0, 0xff, 0x02, 0x6c, 0x02, 0x30, 0x89};

// known key, plaintext, and ciphertext for 2 key 3DES
BYTE l_rgb3DES112Key[] =
{
    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01
};
BYTE l_rgb3DES112KnownPlaintext[] = {0x4E, 0x6F, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74};
BYTE l_rgb3DES112KnownCiphertext[] = {0xb7, 0x83, 0x57, 0x79, 0xee, 0x26, 0xac, 0xb7};
BYTE l_rgb3DES112CBCCiphertext[] = {0x13, 0x4b, 0x98, 0xf8, 0xee, 0xb3, 0xf6, 0x07};

//
// AES vectors are from NIST web site
//
// known key, plaintext, and ciphertext for 128 bit AES
BYTE l_rgbAES128Key[] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
};
BYTE l_rgbAES128KnownPlaintext[] = 
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
};
BYTE l_rgbAES128KnownCiphertext[] =
{
    0x0A, 0x94, 0x0B, 0xB5, 0x41, 0x6E, 0xF0, 0x45, 
    0xF1, 0xC3, 0x94, 0x58, 0xC6, 0x53, 0xEA, 0x5A
};

// known key, plaintext, and ciphertext for 192 bit AES
BYTE l_rgbAES192Key[] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17
};
BYTE l_rgbAES192KnownPlaintext[] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
};
BYTE l_rgbAES192KnownCiphertext[] =
{
    0x00, 0x60, 0xBF, 0xFE, 0x46, 0x83, 0x4B, 0xB8, 
    0xDA, 0x5C, 0xF9, 0xA6, 0x1F, 0xF2, 0x20, 0xAE
};

// known key, plaintext, and ciphertext for 256 bit AES
BYTE l_rgbAES256Key[] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 
    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F
};
BYTE l_rgbAES256KnownPlaintext[] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
};
BYTE l_rgbAES256KnownCiphertext[] =
{
    0x5A, 0x6E, 0x04, 0x57, 0x08, 0xFB, 0x71, 0x96, 
    0xF0, 0x2E, 0x55, 0x3D, 0x02, 0xC3, 0xA6, 0x92
};

// **********************************************************************
// AlgorithmCheck performs known answer tests using the algorithms
// supported by the provider.
// **********************************************************************
/*static*/ DWORD
AlgorithmCheck(
    void)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    BYTE        rgbMD5[MD5DIGESTLEN];
    BYTE        rgbSHA1[A_SHA_DIGEST_LEN];
    DWORD       dwSts;

    memset(rgbMD5, 0, sizeof(rgbMD5));
    memset(rgbSHA1, 0, sizeof(rgbSHA1));

    // check if RSA is working properly
    dwSts = EncryptAndDecryptWithRSAKey(l_rgbRSAPub, l_rgbRSAPriv, TRUE, TRUE);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // check if RSA is working properly
    dwSts = EncryptAndDecryptWithRSAKey(l_rgbRSAPub, l_rgbRSAPriv, FALSE, TRUE);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

#ifdef CSP_USE_MD5
    // known answer test with MD5 (this function is found in hash.c)
    if (!TestMD5((LPBYTE)"HashThis", 8, rgbMD5))
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }
    if (memcmp(rgbMD5, l_rgbKnownMD5, sizeof(rgbMD5)))
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }
#endif // CSP_USE_MD5

#ifdef CSP_USE_SHA1
    // known answer test with SHA-1  (this function is found in hash.c)
    if (!TestSHA1((LPBYTE)"HashThis", 8, rgbSHA1))
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }
    if (memcmp(rgbSHA1, l_rgbKnownSHA1, sizeof(rgbSHA1)))
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }
#endif // CSP_USE_SHA1

#ifdef CSP_USE_RC4
    // known answer test with RC4
    dwSts = TestSymmetricAlgorithm(CALG_RC4,
                                   l_rgbRC4Key,
                                   sizeof(l_rgbRC4Key),
                                   l_rgbRC4KnownPlaintext,
                                   sizeof(l_rgbRC4KnownPlaintext),
                                   l_rgbRC4KnownCiphertext, NULL);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }
#endif // CSP_USE_RC4

#ifdef CSP_USE_RC2
    // known answer test with RC2 - ECB
    dwSts = TestSymmetricAlgorithm(CALG_RC2,
                                   l_rgbRC2Key,
                                   sizeof(l_rgbRC2Key),
                                   l_rgbRC2KnownPlaintext,
                                   sizeof(l_rgbRC2KnownPlaintext),
                                   l_rgbRC2KnownCiphertext,
                                   NULL);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // known answer test with RC2 - CBC
    dwSts = TestSymmetricAlgorithm(CALG_RC2,
                                   l_rgbRC2Key,
                                   sizeof(l_rgbRC2Key),
                                   l_rgbRC2KnownPlaintext,
                                   sizeof(l_rgbRC2KnownPlaintext),
                                   l_rgbRC2CBCCiphertext,
                                   l_rgbIV);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

#endif // CSP_USE_RC2

#ifdef CSP_USE_DES
    // known answer test with DES - ECB
    dwSts = TestSymmetricAlgorithm(CALG_DES,
                                   l_rgbDESKey,
                                   sizeof(l_rgbDESKey),
                                   l_rgbDESKnownPlaintext,
                                   sizeof(l_rgbDESKnownPlaintext),
                                   l_rgbDESKnownCiphertext,
                                   NULL);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // known answer test with DES - CBC
    dwSts = TestSymmetricAlgorithm(CALG_DES,
                                   l_rgbDESKey,
                                   sizeof(l_rgbDESKey),
                                   l_rgbDESKnownPlaintext,
                                   sizeof(l_rgbDESKnownPlaintext),
                                   l_rgbDESCBCCiphertext,
                                   l_rgbIV);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }
#endif // CSP_USE_DES

#ifdef CSP_USE_3DES
    // known answer test with 3DES - ECB
    dwSts = TestSymmetricAlgorithm(CALG_3DES,
                                   l_rgb3DESKey,
                                   sizeof(l_rgb3DESKey),
                                   l_rgb3DESKnownPlaintext,
                                   sizeof(l_rgb3DESKnownPlaintext),
                                   l_rgb3DESKnownCiphertext,
                                   NULL);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // known answer test with 3DES - CBC
    dwSts = TestSymmetricAlgorithm(CALG_3DES,
                                   l_rgb3DESKey,
                                   sizeof(l_rgb3DESKey),
                                   l_rgb3DESKnownPlaintext,
                                   sizeof(l_rgb3DESKnownPlaintext),
                                   l_rgb3DESCBCCiphertext,
                                   l_rgbIV);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // known answer test with 3DES 112 - ECB
    dwSts = TestSymmetricAlgorithm(CALG_3DES_112,
                                   l_rgb3DES112Key,
                                   sizeof(l_rgb3DES112Key),
                                   l_rgb3DES112KnownPlaintext,
                                   sizeof(l_rgb3DES112KnownPlaintext),
                                   l_rgb3DES112KnownCiphertext,
                                   NULL);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }
    dwSts = TestSymmetricAlgorithm(CALG_3DES_112,
                                   l_rgb3DES112Key,
                                   sizeof(l_rgb3DES112Key),
                                   l_rgb3DES112KnownPlaintext,
                                   sizeof(l_rgb3DES112KnownPlaintext),
                                   l_rgb3DES112CBCCiphertext,
                                   l_rgbIV);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }
#endif // CSP_USE_3DES

#ifdef CSP_USE_AES
    // known answer test with AES 128 - ECB
    dwSts = TestSymmetricAlgorithm(CALG_AES_128,
                                   l_rgbAES128Key,
                                   sizeof(l_rgbAES128Key),
                                   l_rgbAES128KnownPlaintext,
                                   sizeof(l_rgbAES128KnownPlaintext),
                                   l_rgbAES128KnownCiphertext,
                                   NULL);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // known answer test with AES 192 - ECB
    dwSts = TestSymmetricAlgorithm(CALG_AES_192,
                                   l_rgbAES192Key,
                                   sizeof(l_rgbAES192Key),
                                   l_rgbAES192KnownPlaintext,
                                   sizeof(l_rgbAES192KnownPlaintext),
                                   l_rgbAES192KnownCiphertext,
                                   NULL);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // known answer test with AES 256 - ECB
    dwSts = TestSymmetricAlgorithm(CALG_AES_256,
                                   l_rgbAES256Key,
                                   sizeof(l_rgbAES256Key),
                                   l_rgbAES256KnownPlaintext,
                                   sizeof(l_rgbAES256KnownPlaintext),
                                   l_rgbAES256KnownCiphertext,
                                   NULL);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }
#endif

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


BOOL WINAPI
DllInitialize(
    IN PVOID hmod,
    IN ULONG Reason,
    IN PCONTEXT Context)    // Unused parameter
{
    g_hInstance = (HINSTANCE) hmod;

    if (Reason == DLL_PROCESS_ATTACH)
    {
        DWORD dwLen;

        DisableThreadLibraryCalls(hmod);

        // Get our image name.
        dwLen = GetModuleFileName(hmod, l_szImagePath,
                                  sizeof(l_szImagePath) / sizeof(CHAR));
        if (0 == dwLen)
            return FALSE;

        // load strings from csprc.dll
        if (ERROR_SUCCESS != LoadStrings())
            return FALSE;

        // Verify this image hasn't been modified.
        if (ERROR_SUCCESS != SelfMACCheck(l_szImagePath))
            return FALSE;

        // do a start up check on all supported algorithms to make sure they
        // are working correctly
        if (ERROR_SUCCESS != AlgorithmCheck())
            return FALSE;
    }
    else if (Reason == DLL_PROCESS_DETACH)
    {
        // free the strings loaded from csprc.dll
        UnloadStrings();
    }

    return TRUE;
}


STDAPI
DllRegisterServer(
    void)
{
    return ERROR_SUCCESS;
}

STDAPI
DllUnregisterServer(
    void)
{
    return S_OK;
}

//
// Delayload stubs
//
BOOL RsaenhGetProfileTypeStub(
    DWORD dwFlags)
{
    return FALSE;
}

HRESULT RsaenhSHGetFolderPathWStub(
    HWND hwndOwner,
    int nFolder,
    HANDLE hToken,
    DWORD dwFlags,
    LPWSTR pwszPath)
{
    return E_FAIL;
}

void RsaenhCoTaskMemFreeStub(
    void *pv)
{
    return;
}

BOOL WINAPI RsaenhCryptUnprotectDataStub(
    DATA_BLOB *pDataIn,                        
    LPWSTR *ppszDataDescr,                   
    DATA_BLOB *pOptionalEntropy,              
    PVOID pvReserved,                          
    CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, 
    DWORD dwFlags,                             
    DATA_BLOB *pDataOut)
{
    return FALSE;
}

BOOL WINAPI RsaenhCryptProtectDataStub(
    DATA_BLOB *pDataIn,                       
    LPCWSTR szDataDescr,                      
    DATA_BLOB *pOptionalEntropy,      
    PVOID pvReserved,                         
    CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, 
    DWORD dwFlags,                            
    DATA_BLOB *pDataOut)
{
    return FALSE;
}

RPC_STATUS RPC_ENTRY RsaenhUuidCreateStub(
    UUID *Uuid)
{
    return E_FAIL;
}

RPC_STATUS RPC_ENTRY RsaenhUuidToStringAStub(
    UUID *Uuid,
    unsigned char **StringUuid)
{
    return E_FAIL;
}

RPC_STATUS RPC_ENTRY RsaenhRpcStringFreeAStub(
    unsigned char **String)
{
    return E_FAIL;
}

HRESULT __stdcall RsaenhPStoreCreateInstance(
    IPStore __RPC_FAR *__RPC_FAR *ppProvider,
    PST_PROVIDERID __RPC_FAR *pProviderID,
    void __RPC_FAR *pReserved,
    DWORD dwFlags)
{
    return E_FAIL;
}

//
// Delayload failure and notification hook 
//
BOOL RsaenhLookupModule(LPCSTR pszDll)
{
    unsigned u;

    for (u = 0; u < g_cRsaenhDelayLoadStubs; u++) {
        if (0 == _stricmp(pszDll, g_RsaenhDelayLoadStubs[u].pszDll))
            return TRUE;
    }
    return FALSE;
}

FARPROC RsaenhLookupExport(DelayLoadProc *pdlp)
{
    unsigned u;
    FARPROC fpResult = NULL;

    if (! pdlp->fImportByName)
        goto Return;

    // could alphabetize and use binary search instead
    for (u = 0; u < g_cRsaenhDelayLoadStubs; u++) {
        if (0 == _stricmp(pdlp->szProcName, g_RsaenhDelayLoadStubs[u].pszExport)) {
            fpResult = g_RsaenhDelayLoadStubs[u].fpStub;
            goto Return;
        }
    }

Return:
    return fpResult;
}

FARPROC WINAPI RsaenhDelayLoadHook(unsigned uReason, PDelayLoadInfo pdli)
{
    FARPROC fpResult = NULL;

    switch (uReason) {
        case dliFailLoadLib:
            if (RsaenhLookupModule(pdli->szDll))
                fpResult = (FARPROC) -1;
            break;

        case dliNotePreGetProcAddress:
            if ((HINSTANCE) -1 == pdli->hmodCur) {
                SetLastError(ERROR_MOD_NOT_FOUND);
                fpResult = RsaenhLookupExport(&pdli->dlp);
            }
            break;

        case dliFailGetProc:
            if ((HINSTANCE) -1 == pdli->hmodCur) {
                SetLastError(ERROR_PROC_NOT_FOUND);
                fpResult = RsaenhLookupExport(&pdli->dlp);
            }   
            break;         
    }

    return fpResult;
}        

PfnDliHook __pfnDliFailureHook2 = RsaenhDelayLoadHook;
PfnDliHook __pfnDliNotifyHook = RsaenhDelayLoadHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\rsaaes\locpolicy.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    locpolicy

Abstract:

    This module provides the local policy tables used for algorithm strength
    control in this CSP.

Author:

    Doug Barlow (dbarlow) 8/11/2000

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <wincrypt.h>
#include <cspdk.h>
#include <scp.h>
#include <contman.h>
#include <ntagimp1.h>
#include <sha.h>
#include <nt_rsa.h>
#include <md4.h>
#include <md5.h>
#include <policy.h>

#define SUPPORTED_PROTOCOLS \
        CRYPT_FLAG_PCT1 | CRYPT_FLAG_SSL2 | CRYPT_FLAG_SSL3 | CRYPT_FLAG_TLS1
#define AlgNm(alg) (sizeof(alg) / sizeof(TCHAR)), TEXT(alg)

#define MD2LEN      (MD2DIGESTLEN * 8)
#define MD4LEN      (MD4DIGESTLEN * 8)
#define MD5LEN      (MD5DIGESTLEN * 8)
#define SHALEN      (A_SHA_DIGEST_LEN * 8)
#define SHAMD5LEN   ((MD5DIGESTLEN + A_SHA_DIGEST_LEN) * 8)
#ifndef MAXHASHLEN
#define MAXHASHLEN  SHAMD5LEN
#endif

#define MAC_MIN_LEN         0
#define MAC_WEAK_LEN        0
#define MAC_WEAK_MAX        0
#define MAC_STRONG_LEN      0
#define MAC_MAX_LEN         0

#define HMAC_MIN_LEN        0
#define HMAC_WEAK_LEN       0
#define HMAC_WEAK_MAX       0
#define HMAC_STRONG_LEN     0
#define HMAC_MAX_LEN        0

#define RC2_MIN_LEN        40
#define RC2_WEAK_LEN       40
#define RC2_WEAK_MAX       56
#define RC2_STRONG_LEN    128
#define RC2_MAX_LEN       128

#define RC4_MIN_LEN        40
#define RC4_WEAK_LEN       40
#define RC4_WEAK_MAX       56
#define RC4_STRONG_LEN    128
#define RC4_MAX_LEN       128

#define DES_MIN_LEN        56
#define DES_WEAK_LEN       56
#define DES_WEAK_MAX       56
#define DES_STRONG_LEN     56
#define DES_MAX_LEN        56

#define RSAS_MIN_LEN      384
#define RSAS_WEAK_LEN     512
#define RSAS_WEAK_MAX   16384
#define RSAS_STRONG_LEN  1024
#define RSAS_MAX_LEN    16384

#define RSAX_MIN_LEN      384
#define RSAX_WEAK_LEN     512
#define RSAX_WEAK_MAX    1024
#define RSAX_STRONG_LEN  1024
#define RSAX_MAX_LEN    16384

#ifndef TLS1_MASTER_KEYSIZE
#define TLS1_MASTER_KEYSIZE SSL3_MASTER_KEYSIZE
#endif

#define PCT1_MASTER_MIN_LEN PCT1_MASTER_KEYSIZE * 8
#define PCT1_MASTER_DEF_LEN PCT1_MASTER_KEYSIZE * 8
#define PCT1_MASTER_MAX_LEN PCT1_MASTER_KEYSIZE * 8

#define SSL2_MASTER_MIN_LEN 40
#define SSL2_MASTER_DEF_LEN SSL2_MASTER_KEYSIZE * 8
#define SSL2_MASTER_MAX_LEN SSL2_MAX_MASTER_KEYSIZE * 8

#define SSL3_MASTER_MIN_LEN SSL3_MASTER_KEYSIZE * 8
#define SSL3_MASTER_DEF_LEN SSL3_MASTER_KEYSIZE * 8
#define SSL3_MASTER_MAX_LEN SSL3_MASTER_KEYSIZE * 8

#define TLS1_MASTER_MIN_LEN TLS1_MASTER_KEYSIZE * 8
#define TLS1_MASTER_DEF_LEN TLS1_MASTER_KEYSIZE * 8
#define TLS1_MASTER_MAX_LEN TLS1_MASTER_KEYSIZE * 8


// check for the maximum hash length greater than the mod length
#if RSAS_MIN_LEN < MAXHASHLEN
#error  "RSAS_MIN_LEN must be greater than or equal to MAXHASHLEN"
#endif

//
/////////////////////////////////////////////////////////////////////////////
//
//  The following tables define the minimum, default, and maximum key lengths
//  supported by the CSP.  There are four tables, representing each
//  incarnation of the CSP:
//
//      * Microsoft Base Cryptographic Provider v1.0
//      * Microsoft Strong Cryptographic Provider
//      * Microsoft Enhanced Cryptographic Provider v1.0
//      * Microsoft RSA SChannel Cryptographic Provider
//      * A yet unnamed Signature Only CSP
//
//  Tables are built from the PROV_ENUMALGS_EX structure defined in
//  wincrypt.h.
//

PROV_ENUMALGS_EX g_RsaBasePolicy[] = {
//  Algorithm   Default         Minimum         Maximum         Supported
//     Id       Length          Length          Length          Protocols
//  ---------   -------         -------         -------         ---------
//  Simple                      Long
//  Name                        Name
//  ---------                   -------
#ifdef CSP_USE_RC2
  { CALG_RC2,   RC2_WEAK_LEN,   RC2_MIN_LEN,    RC2_WEAK_MAX,   0,
    AlgNm("RC2"),               AlgNm("RSA Data Security's RC2") },
#endif
#ifdef CSP_USE_RC4
  { CALG_RC4,   RC4_WEAK_LEN,   RC4_MIN_LEN,    RC4_WEAK_MAX,   0,
    AlgNm("RC4"),               AlgNm("RSA Data Security's RC4") },
#endif
#ifdef CSP_USE_DES
  { CALG_DES,   DES_WEAK_LEN,   DES_MIN_LEN,    DES_WEAK_MAX,   0,
    AlgNm("DES"),               AlgNm("Data Encryption Standard (DES)") },
#endif
#ifdef CSP_USE_SHA
  { CALG_SHA,   SHALEN,         SHALEN,         SHALEN,         CRYPT_FLAG_SIGNING,
    AlgNm("SHA-1"),             AlgNm("Secure Hash Algorithm (SHA-1)") },
#endif
#ifdef CSP_USE_MD2
  { CALG_MD2,   MD2LEN,         MD2LEN,         MD2LEN,         CRYPT_FLAG_SIGNING,
    AlgNm("MD2"),               AlgNm("Message Digest 2 (MD2)") },
#endif
#ifdef CSP_USE_MD4
  { CALG_MD4,   MD4LEN,         MD4LEN,         MD4LEN,         CRYPT_FLAG_SIGNING,
    AlgNm("MD4"),               AlgNm("Message Digest 4 (MD4)") },
#endif
#ifdef CSP_USE_MD5
  { CALG_MD5,   MD5LEN,         MD5LEN,         MD5LEN,         CRYPT_FLAG_SIGNING,
    AlgNm("MD5"),               AlgNm("Message Digest 5 (MD5)") },
#endif
  { CALG_SSL3_SHAMD5,
                SHAMD5LEN,      SHAMD5LEN,      SHAMD5LEN,      0,
    AlgNm("SSL3 SHAMD5"),       AlgNm("SSL3 SHAMD5") },
#ifdef CSP_USE_MAC
  { CALG_MAC,   MAC_WEAK_LEN,   MAC_MIN_LEN,    MAC_WEAK_MAX,   0,
    AlgNm("MAC"),               AlgNm("Message Authentication Code") },
#endif
  { CALG_RSA_SIGN,
                RSAS_WEAK_LEN,  RSAS_MIN_LEN,   RSAS_WEAK_MAX,  CRYPT_FLAG_IPSEC | CRYPT_FLAG_SIGNING,
    AlgNm("RSA_SIGN"),          AlgNm("RSA Signature") },
  { CALG_RSA_KEYX,
                RSAX_WEAK_LEN,  RSAX_MIN_LEN,   RSAX_WEAK_MAX,  CRYPT_FLAG_IPSEC | CRYPT_FLAG_SIGNING,
    AlgNm("RSA_KEYX"),          AlgNm("RSA Key Exchange") },
  { CALG_HMAC,  HMAC_WEAK_LEN,  HMAC_MIN_LEN,   HMAC_WEAK_MAX,  0,
    AlgNm("HMAC"),              AlgNm("Hugo's MAC (HMAC)") },
//      List Terminator
  { 0,          0,              0,              0,              0,
    0, 0,                       0, 0 } };


PROV_ENUMALGS_EX g_RsaStrongPolicy[] = {
//  Algorithm   Default         Minimum         Maximum         Supported
//     Id       Length          Length          Length          Protocols
//  ---------   -------         -------         -------         ---------
//  Simple                      Long
//  Name                        Name
//  ---------                   -------
#ifdef CSP_USE_RC2
  { CALG_RC2,   RC2_MAX_LEN,    RC2_MIN_LEN,    RC2_MAX_LEN,    0,
    AlgNm("RC2"),               AlgNm("RSA Data Security's RC2") },
#endif
#ifdef CSP_USE_RC4
  { CALG_RC4,   RC4_MAX_LEN,    RC4_MIN_LEN,    RC4_MAX_LEN,    0,
    AlgNm("RC4"),               AlgNm("RSA Data Security's RC4") },
#endif
#ifdef CSP_USE_DES
  { CALG_DES,   DES_WEAK_LEN,   DES_MIN_LEN,    DES_MAX_LEN,    0,
    AlgNm("DES"),               AlgNm("Data Encryption Standard (DES)") },
#endif
#ifdef CSP_USE_3DES
  { CALG_3DES_112,
                DES_WEAK_LEN * 2,
                                DES_MIN_LEN * 2,
                                                DES_MAX_LEN * 2,
                                                                0,
    AlgNm("3DES TWO KEY"),      AlgNm("Two Key Triple DES") },
  { CALG_3DES,  DES_WEAK_LEN * 3,
                                DES_MIN_LEN * 3,
                                                168,
                                                                0,
    AlgNm("3DES"),              AlgNm("Three Key Triple DES") },
#endif
#ifdef CSP_USE_SHA
  { CALG_SHA,   SHALEN,         SHALEN,         SHALEN,         CRYPT_FLAG_SIGNING,
    AlgNm("SHA-1"),             AlgNm("Secure Hash Algorithm (SHA-1)") },
#endif
#ifdef CSP_USE_MD2
  { CALG_MD2,   MD2LEN,         MD2LEN,         MD2LEN,         CRYPT_FLAG_SIGNING,
    AlgNm("MD2"),               AlgNm("Message Digest 2 (MD2)") },
#endif
#ifdef CSP_USE_MD4
  { CALG_MD4,   MD4LEN,         MD4LEN,         MD4LEN,         CRYPT_FLAG_SIGNING,
    AlgNm("MD4"),               AlgNm("Message Digest 4 (MD4)") },
#endif
#ifdef CSP_USE_MD5
  { CALG_MD5,   MD5LEN,         MD5LEN,         MD5LEN,         CRYPT_FLAG_SIGNING,
    AlgNm("MD5"),               AlgNm("Message Digest 5 (MD5)") },
#endif
  { CALG_SSL3_SHAMD5,
                SHAMD5LEN,      SHAMD5LEN,      SHAMD5LEN,      0,
    AlgNm("SSL3 SHAMD5"),       AlgNm("SSL3 SHAMD5") },
#ifdef CSP_USE_MAC
  { CALG_MAC,   MAC_WEAK_LEN,   MAC_MIN_LEN,    MAC_MAX_LEN,    0,
    AlgNm("MAC"),               AlgNm("Message Authentication Code") },
#endif
  { CALG_RSA_SIGN,
                RSAS_STRONG_LEN,  RSAS_MIN_LEN,   RSAS_MAX_LEN,   CRYPT_FLAG_IPSEC | CRYPT_FLAG_SIGNING,
    AlgNm("RSA_SIGN"),          AlgNm("RSA Signature") },
  { CALG_RSA_KEYX,
                RSAX_STRONG_LEN,  RSAX_MIN_LEN,   RSAX_MAX_LEN,   CRYPT_FLAG_IPSEC | CRYPT_FLAG_SIGNING,
    AlgNm("RSA_KEYX"),          AlgNm("RSA Key Exchange") },
  { CALG_HMAC,  HMAC_WEAK_LEN,  HMAC_MIN_LEN,   HMAC_MAX_LEN,   0,
    AlgNm("HMAC"),              AlgNm("Hugo's MAC (HMAC)") },
//      List Terminator
  { 0,          0,              0,              0,              0,
    0, 0,                       0, 0 } };


PROV_ENUMALGS_EX g_RsaEnhPolicy[] = {
//  Algorithm   Default         Minimum         Maximum         Supported
//     Id       Length          Length          Length          Protocols
//  ---------   -------         -------         -------         ---------
//  Simple                      Long
//  Name                        Name
//  ---------                   -------
#ifdef CSP_USE_RC2
  { CALG_RC2,   RC2_STRONG_LEN, RC2_MIN_LEN,    RC2_MAX_LEN,    0,
    AlgNm("RC2"),               AlgNm("RSA Data Security's RC2") },
#endif
#ifdef CSP_USE_RC4
  { CALG_RC4,   RC4_STRONG_LEN, RC2_MIN_LEN,    RC4_MAX_LEN,    0,
    AlgNm("RC4"),               AlgNm("RSA Data Security's RC4") },
#endif
#ifdef CSP_USE_DES
  { CALG_DES,   DES_STRONG_LEN, DES_MIN_LEN,    DES_MAX_LEN,    0,
    AlgNm("DES"),               AlgNm("Data Encryption Standard (DES)") },
#endif
#ifdef CSP_USE_3DES
  { CALG_3DES_112,
                DES_STRONG_LEN * 2,
                                DES_MIN_LEN * 2,
                                                DES_MAX_LEN * 2,
                                                                0,
    AlgNm("3DES TWO KEY"),      AlgNm("Two Key Triple DES") },
  { CALG_3DES,
                DES_STRONG_LEN * 3,
                                DES_MIN_LEN * 3,
                                                DES_MAX_LEN * 3,
                                                                0,
    AlgNm("3DES"),              AlgNm("Three Key Triple DES") },
#endif
#ifdef CSP_USE_SHA
  { CALG_SHA,   SHALEN,         SHALEN,         SHALEN,         CRYPT_FLAG_SIGNING,
    AlgNm("SHA-1"),             AlgNm("Secure Hash Algorithm (SHA-1)") },
#endif
#ifdef CSP_USE_MD2
  { CALG_MD2,   MD2LEN,         MD2LEN,         MD2LEN,         CRYPT_FLAG_SIGNING,
    AlgNm("MD2"),               AlgNm("Message Digest 2 (MD2)") },
#endif
#ifdef CSP_USE_MD4
  { CALG_MD4,   MD4LEN,         MD4LEN,         MD4LEN,         CRYPT_FLAG_SIGNING,
    AlgNm("MD4"),               AlgNm("Message Digest 4 (MD4)") },
#endif
#ifdef CSP_USE_MD5
  { CALG_MD5,   MD5LEN,         MD5LEN,         MD5LEN,         CRYPT_FLAG_SIGNING,
    AlgNm("MD5"),               AlgNm("Message Digest 5 (MD5)") },
#endif
  { CALG_SSL3_SHAMD5,
                SHAMD5LEN,      SHAMD5LEN,      SHAMD5LEN,      0,
    AlgNm("SSL3 SHAMD5"),       AlgNm("SSL3 SHAMD5") },
#ifdef CSP_USE_MAC
  { CALG_MAC,   MAC_STRONG_LEN, MAC_MIN_LEN,    MAC_MAX_LEN,    0,
    AlgNm("MAC"),               AlgNm("Message Authentication Code") },
#endif
  { CALG_RSA_SIGN,
                RSAS_STRONG_LEN,
                                RSAS_MIN_LEN,   RSAS_MAX_LEN,   CRYPT_FLAG_IPSEC | CRYPT_FLAG_SIGNING,
    AlgNm("RSA_SIGN"),          AlgNm("RSA Signature") },
  { CALG_RSA_KEYX,
                RSAX_STRONG_LEN,
                                RSAX_MIN_LEN,   RSAX_MAX_LEN,   CRYPT_FLAG_IPSEC | CRYPT_FLAG_SIGNING,
    AlgNm("RSA_KEYX"),          AlgNm("RSA Key Exchange") },
  { CALG_HMAC,  HMAC_STRONG_LEN,
                                HMAC_MIN_LEN,   HMAC_MAX_LEN,   0,
    AlgNm("HMAC"),              AlgNm("Hugo's MAC (HMAC)") },
//      List Terminator
  { 0,          0,              0,              0,              0,
    0, 0,                       0, 0 } };

PROV_ENUMALGS_EX g_RsaAesPolicy[] = {
//  Algorithm   Default         Minimum         Maximum         Supported
//     Id       Length          Length          Length          Protocols
//  ---------   -------         -------         -------         ---------
//  Simple                      Long
//  Name                        Name
//  ---------                   -------
#ifdef CSP_USE_RC2
  { CALG_RC2,   RC2_STRONG_LEN, RC2_MIN_LEN,    RC2_MAX_LEN,    0,
    AlgNm("RC2"),               AlgNm("RSA Data Security's RC2") },
#endif
#ifdef CSP_USE_RC4
  { CALG_RC4,   RC4_STRONG_LEN, RC2_MIN_LEN,    RC4_MAX_LEN,    0,
    AlgNm("RC4"),               AlgNm("RSA Data Security's RC4") },
#endif
#ifdef CSP_USE_DES
  { CALG_DES,   DES_STRONG_LEN, DES_MIN_LEN,    DES_MAX_LEN,    0,
    AlgNm("DES"),               AlgNm("Data Encryption Standard (DES)") },
#endif
#ifdef CSP_USE_3DES
  { CALG_3DES_112,
                DES_STRONG_LEN * 2,
                                DES_MIN_LEN * 2,
                                                DES_MAX_LEN * 2,
                                                                0,
    AlgNm("3DES TWO KEY"),      AlgNm("Two Key Triple DES") },
  { CALG_3DES,
                DES_STRONG_LEN * 3,
                                DES_MIN_LEN * 3,
                                                DES_MAX_LEN * 3,
                                                                0,
    AlgNm("3DES"),              AlgNm("Three Key Triple DES") },
#endif
#ifdef CSP_USE_SHA
  { CALG_SHA,   SHALEN,         SHALEN,         SHALEN,         CRYPT_FLAG_SIGNING,
    AlgNm("SHA-1"),             AlgNm("Secure Hash Algorithm (SHA-1)") },
#endif
#ifdef CSP_USE_MD2
  { CALG_MD2,   MD2LEN,         MD2LEN,         MD2LEN,         CRYPT_FLAG_SIGNING,
    AlgNm("MD2"),               AlgNm("Message Digest 2 (MD2)") },
#endif
#ifdef CSP_USE_MD4
  { CALG_MD4,   MD4LEN,         MD4LEN,         MD4LEN,         CRYPT_FLAG_SIGNING,
    AlgNm("MD4"),               AlgNm("Message Digest 4 (MD4)") },
#endif
#ifdef CSP_USE_MD5
  { CALG_MD5,   MD5LEN,         MD5LEN,         MD5LEN,         CRYPT_FLAG_SIGNING,
    AlgNm("MD5"),               AlgNm("Message Digest 5 (MD5)") },
#endif
  { CALG_SSL3_SHAMD5,
                SHAMD5LEN,      SHAMD5LEN,      SHAMD5LEN,      0,
    AlgNm("SSL3 SHAMD5"),       AlgNm("SSL3 SHAMD5") },
#ifdef CSP_USE_MAC
  { CALG_MAC,   MAC_STRONG_LEN, MAC_MIN_LEN,    MAC_MAX_LEN,    0,
    AlgNm("MAC"),               AlgNm("Message Authentication Code") },
#endif
  { CALG_RSA_SIGN,
                RSAS_STRONG_LEN,
                                RSAS_MIN_LEN,   RSAS_MAX_LEN,   CRYPT_FLAG_IPSEC | CRYPT_FLAG_SIGNING,
    AlgNm("RSA_SIGN"),          AlgNm("RSA Signature") },
  { CALG_RSA_KEYX,
                RSAX_STRONG_LEN,
                                RSAX_MIN_LEN,   RSAX_MAX_LEN,   CRYPT_FLAG_IPSEC | CRYPT_FLAG_SIGNING,
    AlgNm("RSA_KEYX"),          AlgNm("RSA Key Exchange") },
  { CALG_HMAC,  HMAC_STRONG_LEN,
                                HMAC_MIN_LEN,   HMAC_MAX_LEN,   0,
    AlgNm("HMAC"),              AlgNm("Hugo's MAC (HMAC)") },
#ifdef CSP_USE_AES
  { CALG_AES_128,
                128,            128,            128,            0,
    AlgNm("AES 128"),           AlgNm("American Encryption Standard 128-bit") },
  { CALG_AES_192,
                192,            192,            192,            0,
    AlgNm("AES 192"),           AlgNm("American Encryption Standard 192-bit") },
  { CALG_AES_256,
                256,            256,            256,            0,
    AlgNm("AES 256"),           AlgNm("American Encryption Standard 256-bit") },
#endif
//      List Terminator
  { 0,          0,              0,              0,              0,
    0, 0,                       0, 0 } };

PROV_ENUMALGS_EX g_RsaSchPolicy[] = {
//  Algorithm   Default         Minimum         Maximum         Supported
//     Id       Length          Length          Length          Protocols
//  ---------   -------         -------         -------         ---------
//  Simple                      Long
//  Name                        Name
//  ---------                   -------
#ifdef CSP_USE_RC2
  { CALG_RC2,   RC2_STRONG_LEN, RC2_MIN_LEN,    RC2_MAX_LEN,    SUPPORTED_PROTOCOLS,
    AlgNm("RC2"),               AlgNm("RSA Data Security's RC2") },
#endif
#ifdef CSP_USE_RC4
  { CALG_RC4,   RC4_STRONG_LEN, RC4_MIN_LEN,    RC4_MAX_LEN,    SUPPORTED_PROTOCOLS,
    AlgNm("RC4"),               AlgNm("RSA Data Security's RC4") },
#endif
#ifdef CSP_USE_DES
  { CALG_DES,   DES_STRONG_LEN, DES_MIN_LEN,    DES_MAX_LEN,    SUPPORTED_PROTOCOLS,
    AlgNm("DES"),               AlgNm("Data Encryption Standard (DES)") },
#endif
#ifdef CSP_USE_3DES
  { CALG_3DES_112,
                DES_STRONG_LEN * 2,
                                DES_MIN_LEN * 2,
                                                DES_MAX_LEN * 2,
                                                                SUPPORTED_PROTOCOLS,
    AlgNm("3DES TWO KEY"),      AlgNm("Two Key Triple DES") },
  { CALG_3DES,
                DES_STRONG_LEN * 3,
                                DES_MIN_LEN * 3,
                                                DES_MAX_LEN * 3,
                                                                SUPPORTED_PROTOCOLS,
    AlgNm("3DES"),              AlgNm("Three Key Triple DES") },
#endif
#ifdef CSP_USE_SHA
  { CALG_SHA,   SHALEN,         SHALEN,         SHALEN,         SUPPORTED_PROTOCOLS | CRYPT_FLAG_SIGNING,
    AlgNm("SHA-1"),             AlgNm("Secure Hash Algorithm (SHA-1)") },
#endif
#ifdef CSP_USE_MD5
  { CALG_MD5,   MD5LEN,         MD5LEN,         MD5LEN,         SUPPORTED_PROTOCOLS | CRYPT_FLAG_SIGNING,
    AlgNm("MD5"),               AlgNm("Message Digest 5 (MD5)") },
#endif
  { CALG_SSL3_SHAMD5,
                SHAMD5LEN,      SHAMD5LEN,      SHAMD5LEN,      0,
    AlgNm("SSL3 SHAMD5"),       AlgNm("SSL3 SHAMD5") },
#ifdef CSP_USE_MAC
  { CALG_MAC,   MAC_STRONG_LEN, MAC_MIN_LEN,    MAC_MAX_LEN,    0,
    AlgNm("MAC"),               AlgNm("Message Authentication Code") },
#endif
  { CALG_RSA_SIGN,
                RSAS_STRONG_LEN,
                                RSAS_MIN_LEN,   RSAS_MAX_LEN,   SUPPORTED_PROTOCOLS | CRYPT_FLAG_SIGNING,
    AlgNm("RSA_SIGN"),          AlgNm("RSA Signature") },
  { CALG_RSA_KEYX,
                RSAX_STRONG_LEN,
                                RSAX_MIN_LEN,   RSAX_MAX_LEN,   SUPPORTED_PROTOCOLS | CRYPT_FLAG_SIGNING,
    AlgNm("RSA_KEYX"),          AlgNm("RSA Key Exchange") },
  { CALG_HMAC,  HMAC_STRONG_LEN,
                                HMAC_MIN_LEN,   HMAC_MAX_LEN,   0,
    AlgNm("HMAC"),              AlgNm("Hugo's MAC (HMAC)") },
  { CALG_PCT1_MASTER,
                PCT1_MASTER_DEF_LEN,
                                PCT1_MASTER_MIN_LEN,
                                                PCT1_MASTER_MAX_LEN,
                                                                CRYPT_FLAG_PCT1,
    AlgNm("PCT1 MASTER"),       AlgNm("PCT1 Master") },
  { CALG_SSL2_MASTER,
                SSL2_MASTER_DEF_LEN,
                                SSL2_MASTER_MIN_LEN,
                                                SSL2_MASTER_MAX_LEN,
                                                                CRYPT_FLAG_SSL2,
    AlgNm("SSL2 MASTER"),       AlgNm("SSL2 Master") },
  { CALG_SSL3_MASTER,
                SSL3_MASTER_DEF_LEN,
                                SSL3_MASTER_MIN_LEN,
                                                SSL3_MASTER_MAX_LEN,
                                                                CRYPT_FLAG_SSL3,
    AlgNm("SSL3 MASTER"),       AlgNm("SSL3 Master") },
  { CALG_TLS1_MASTER,
                TLS1_MASTER_DEF_LEN,
                                TLS1_MASTER_MIN_LEN,
                                                TLS1_MASTER_MAX_LEN,
                                                                CRYPT_FLAG_TLS1,
    AlgNm("TLS1 MASTER"),       AlgNm("TLS1 Master") },
  { CALG_SCHANNEL_MASTER_HASH,
                0,              0,              (DWORD)(-1),    0,
    AlgNm("SCH MASTER HASH"),               AlgNm("SChannel Master Hash") },
  { CALG_SCHANNEL_MAC_KEY,
                0,              0,              (DWORD)(-1),    0,
    AlgNm("SCH MAC KEY"),               AlgNm("SChannel MAC Key") },
  { CALG_SCHANNEL_ENC_KEY,
                0,              0,              (DWORD)(-1),    0,
    AlgNm("SCH ENC KEY"),               AlgNm("SChannel Encryption Key") },
//      List Terminator
  { 0,          0,              0,              0,              0,
    0, 0,                       0, 0 } };


PROV_ENUMALGS_EX g_RsaSigPolicy[] = {
//  Algorithm   Default         Minimum         Maximum         Supported
//     Id       Length          Length          Length          Protocols
//  ---------   -------         -------         -------         ---------
//  Simple                      Long
//  Name                        Name
//  ---------                   -------
#ifdef CSP_USE_SHA
  { CALG_SHA,   SHALEN,         SHALEN,         SHALEN,         CRYPT_FLAG_SIGNING,
    AlgNm("SHA-1"),             AlgNm("Secure Hash Algorithm (SHA-1)") },
#endif
#ifdef CSP_USE_MD2
  { CALG_MD2,   MD2LEN,         MD2LEN,         MD2LEN,         CRYPT_FLAG_SIGNING,
    AlgNm("MD2"),               AlgNm("Message Digest 2 (MD2)") },
#endif
#ifdef CSP_USE_MD4
  { CALG_MD4,   MD4LEN,         MD4LEN,         MD4LEN,         CRYPT_FLAG_SIGNING,
    AlgNm("MD4"),               AlgNm("Message Digest 4 (MD4)") },
#endif
#ifdef CSP_USE_MD5
  { CALG_MD5,   MD5LEN,         MD5LEN,         MD5LEN,         CRYPT_FLAG_SIGNING,
    AlgNm("MD5"),               AlgNm("Message Digest 5 (MD5)") },
#endif
  { CALG_SSL3_SHAMD5,
                SHAMD5LEN,      SHAMD5LEN,      SHAMD5LEN,      0,
    AlgNm("SSL3 SHAMD5"),       AlgNm("SSL3 SHAMD5") },
  { CALG_RSA_SIGN,
                RSAS_STRONG_LEN,
                                RSAS_MIN_LEN,   RSAS_MAX_LEN,   CRYPT_FLAG_SIGNING,
    AlgNm("RSA_SIGN"),          AlgNm("RSA Signature") },
//      List Terminator
  { 0,          0,              0,              0,              0,
    0, 0,                       0, 0 } };


//
// The list of tables.
//

PROV_ENUMALGS_EX *g_AlgTables[] = {
    g_RsaBasePolicy,    // Key length table for PROV_MS_DEF
    g_RsaStrongPolicy,  // Key length table for PROV_MS_STRONG
    g_RsaEnhPolicy,     // Key length table for PROV_MS_ENHANCED
    g_RsaSchPolicy,     // Key length table for PROV_MS_SCHANNEL
    g_RsaSigPolicy,     // Key length table for undefined signature only CSP
    g_RsaAesPolicy };   // Key length table for MS_ENH_RSA_AES_PROV
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\rsaaes\makefile.inc ===
CRYPTOBIN=..\programs\bin\$(TARGET_DIRECTORY)

sign:	$(CRYPTOBIN)\sign.exe
	$(CRYPTOBIN)\sign s $(CRYPTOBIN)\rsabase.dll $(CRYPTOBIN)\cpsign
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\rsaaes\ntagum.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ntagum.c                                               //
//  DESCRIPTION   : Crypto CP interfaces:                                  //
//                  CPAcquireContext                                       //
//                  CPReleaseContext                                       //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//  Jan 25 1995 larrys  Changed from Nametag                               //
//      Feb 16 1995 larrys  Fix problem for 944 build                      //
//      Feb 23 1995 larrys  Changed NTag_SetLastError to SetLastError      //
//      Mar 23 1995 larrys  Added variable key length                      //
//      Apr 19 1995 larrys  Cleanup                                        //
//      May  9 1995 larrys  Removed warnings                               //
//      May 10 1995 larrys  added private api calls                        //
//      Jul 19 1995 larrys  Changed registry location                      //
//      Aug 09 1995 larrys  Changed error code                             //
//      Aug 31 1995 larrys  Fixed bug 27 CryptAcquireContext               //
//      Sep 12 1995 Jeffspel/ramas  Merged STT code into scp               //
//      Oct 02 1995 larrys  Fixed bug 27 return error NTE_BAD_KEYSET       //
//      Oct 13 1995 larrys  Added verify only context                      //
//      Oct 23 1995 larrys  Added GetProvParam stuff                       //
//      Nov  2 1995 larrys  Fixed bug 41                                   //
//      Oct 27 1995 rajeshk Added RandSeed stuff                           //
//      Nov  3 1995 larrys  Merged for NT checkin                          //
//      Nov  8 1995 larrys  Fixed SUR bug 10769                            //
//      Nov 13 1995 larrys  Fixed memory leak                              //
//      Nov 30 1995 larrys  Bug fix                                        //
//      Dec 11 1995 larrys  Added WIN96 password cache                     //
//      Dec 13 1995 larrys  Changed random number update                   //
//      Mar 01 1996 rajeshk Fixed the stomp bug                            //
//      May 15 1996 larrys  Added private key export                       //
//      May 28 1996 larrys  Fix bug in cache code                          //
//      Jun 11 1996 larrys  Added NT encryption of registry keys           //
//      Sep 13 1996 mattt   Varlen salt, 40-bit RC4 key storage, interop   //
//      Oct 14 1996 jeffspel Changed GenRandom to NewGenRandom             //
//      May 23 1997 jeffspel Added provider type checking                  //
//      Jun 18 1997 jeffspel Check if process is LocalSystem               //
//      Apr  7 2000 dbarlow Move CP* definitions to cspdk.h                //
//      May  5 2000 dbarlow Rework return code handling                    //
//                                                                         //
//  Copyright (C) 1993-2000, Microsoft Corporation                         //
//  All Rights Reserved                                                    //
/////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include "precomp.h"
#include "shacomm.h"
#include "nt_rsa.h"
#include <winreg.h>
#include "randlib.h"
#include "ntagum.h"
#include "protstor.h"
#include "ntagimp1.h"
#include "contman.h"
#include "swnt_pk.h"
#include "sha.h" // defines A_SHA_DIGEST_LEN

extern void FreeUserRec(PNTAGUserList pUser);
extern CSP_STRINGS g_Strings;

#define NTAG_DEF_MACH_CONT_NAME     "DefaultKeys"
#define NTAG_DEF_MACH_CONT_NAME_LEN sizeof(NTAG_DEF_MACH_CONT_NAME)
#define PSKEYS                      "PSKEYS"

extern DWORD
MakeNewKey(
    ALG_ID       aiKeyAlg,
    DWORD        dwRights,
    DWORD        dwKeyLen,
    HCRYPTPROV   hUID,
    BYTE         *pbKeyData,
    BOOL         fUsePassedKeyBuffer,
    BOOL         fPreserveExactKey,
    PNTAGKeyList *ppKeyList);

void
FreeNewKey(
    PNTAGKeyList pOldKey);

DWORD
ReadRegValue(
    HKEY hLoc,
    char *pszName,
    BYTE **ppbData,
    DWORD *pcbLen,
    BOOL fAlloc)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    DWORD dwSts;

    if (fAlloc)
    {
        *pcbLen = 0;
        *ppbData = NULL;

        // Need to get the size of the value first
        dwSts = RegQueryValueEx(hLoc, pszName, 0, NULL, NULL, pcbLen);
        if (ERROR_SUCCESS != dwSts)
        {
            // ?BUGBUG? Is this error handling sufficient?
            dwReturn = ERROR_SUCCESS;
            goto ErrorExit;
        }

        if (*pcbLen == 0)
        {
            dwReturn = ERROR_SUCCESS;
            goto ErrorExit;
        }

        *ppbData = (BYTE *)_nt_malloc(*pcbLen);
        if (NULL == *ppbData)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }
    }

    // Now get the key
    dwSts = RegQueryValueEx(hLoc, pszName, 0, NULL,
                            (BYTE *)*ppbData, pcbLen);
    if (ERROR_SUCCESS != dwSts)
    {
        // ?BUGBUG? Is this error handling sufficient?
        dwReturn = (DWORD)NTE_SYS_ERR;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (ERROR_SUCCESS != dwReturn)
    {
        if (fAlloc)
        {
            if (NULL != *ppbData)
                _nt_free(*ppbData, *pcbLen);
            *ppbData = NULL;
        }
    }
    return dwReturn;
}


/*static*/ void
CheckForStorageType(
    HKEY hRegKey,
    DWORD *pdwProtStor)
{
    BYTE    **ppb = (BYTE**)(&pdwProtStor);
    DWORD   cb = sizeof(DWORD);
    DWORD   dwSts;

    if (hRegKey)
    {
        dwSts= ReadRegValue(hRegKey, PSKEYS, ppb, &cb, FALSE);
        if (ERROR_SUCCESS != dwSts)
        {
            // ?BUGBUG? Is this error handling sufficient?
            *pdwProtStor = 0;
        }

        // This is done because the value of PROTECTION_API_KEYS was
        // mistakenly also used in IE 5 on Win9x for a key format in the
        // registry where the public keys were not encrypted.
        if (PROTECTION_API_KEYS == *pdwProtStor)
        {
            *pdwProtStor = PROTECTED_STORAGE_KEYS;
        }
    }
    else
    {
        *pdwProtStor = PROTECTION_API_KEYS;
    }
}


/*static*/ DWORD
OpenUserReg(
    LPSTR pszUserName,
    DWORD dwProvType,
    DWORD dwFlags,
    BOOL fUserKeys,
    HKEY *phRegKey,
    DWORD *pdwOldKeyFlags)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    HKEY    hTopRegKey = 0;
    TCHAR   *pszLocbuf = NULL;
    DWORD   cbLocBuf;
    BOOL    fLeaveOldKeys = FALSE;
    DWORD   dwSts;

    dwSts = AllocAndSetLocationBuff(dwFlags & CRYPT_MACHINE_KEYSET,
                                    dwProvType, pszUserName, &hTopRegKey,
                                    &pszLocbuf, fUserKeys, &fLeaveOldKeys,
                                    &cbLocBuf);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (fLeaveOldKeys)
        *pdwOldKeyFlags |= LEAVE_OLD_KEYS;

    // try to open the old storage location
    dwSts = OpenRegKeyWithTokenPriviledges(hTopRegKey, pszLocbuf, phRegKey,
                                           pdwOldKeyFlags);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (dwFlags & CRYPT_NEWKEYSET)
    {
        RegCloseKey(*phRegKey);
        *phRegKey = 0;
        dwReturn = (DWORD)NTE_EXISTS;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (hTopRegKey && (HKEY_CURRENT_USER != hTopRegKey) &&
        (HKEY_LOCAL_MACHINE != hTopRegKey))
    {
        RegCloseKey(hTopRegKey);
    }
    if (pszLocbuf)
        _nt_free(pszLocbuf, cbLocBuf);
    return dwReturn;
}


DWORD
OpenUserKeyGroup(
    PNTAGUserList pTmpUser,
    LPSTR szUserName,
    DWORD dwFlags)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BOOL    fMachineKeyset;
    DWORD   dwSts;

    fMachineKeyset = dwFlags & CRYPT_MACHINE_KEYSET;
    dwSts = ReadContainerInfo(pTmpUser->dwProvType,
                              szUserName,
                              fMachineKeyset,
                              dwFlags,
                              &pTmpUser->ContInfo);
    if (0 != (CRYPT_NEWKEYSET & dwFlags))
    {
        if (NTE_BAD_KEYSET != dwSts)
        {
            if (ERROR_SUCCESS == dwSts)
                dwReturn = (DWORD)NTE_EXISTS;
            else
                dwReturn = dwSts;
            goto ErrorExit;
        }
        else
        {
            // allocate space for the container/user name
            dwSts = SetContainerUserName(szUserName, &pTmpUser->ContInfo);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            dwSts = OpenUserReg(pTmpUser->ContInfo.pszUserName,
                                pTmpUser->dwProvType,dwFlags,
                                FALSE,
                                &pTmpUser->hKeys,
                                &pTmpUser->dwOldKeyFlags);
            if ((DWORD)NTE_BAD_KEYSET != dwSts)
            {
                dwReturn = (DWORD)NTE_EXISTS;
                goto ErrorExit;
            }

            // no key set so create one
            if (0 == pTmpUser->hKeys)
            {
                // if the is for user key then make sure that Data Protection
                // API works so a container isn't created which can't be used
                // to store keys
                if (!fMachineKeyset)
                {
                    dwSts = TryDPAPI();
                    if (ERROR_SUCCESS != dwSts)
                    {
                        dwReturn = dwSts;
                        goto ErrorExit;
                    }
                }

                pTmpUser->dwKeyStorageType = PROTECTION_API_KEYS;
                dwSts = WriteContainerInfo(pTmpUser->dwProvType,
                                           pTmpUser->ContInfo.rgwszFileName,
                                           fMachineKeyset,
                                           &pTmpUser->ContInfo);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }
            }
        }
    }
    else
    {
        if (ERROR_SUCCESS == dwSts)
        {
            pTmpUser->dwKeyStorageType = PROTECTION_API_KEYS;
        }
        else
        {
            dwSts = OpenUserReg(szUserName,
                                pTmpUser->dwProvType,
                                dwFlags,
                                FALSE,
                                &pTmpUser->hKeys,
                                &pTmpUser->dwOldKeyFlags);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            // migrating keys need to set the user name
            dwSts = SetContainerUserName(szUserName,
                                         &pTmpUser->ContInfo);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*static*/ DWORD
DeleteOldUserKeyGroup(
    CONST char *pszUserID,
    DWORD dwProvType,
    DWORD dwFlags)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    HKEY        hTopRegKey = 0;
    TCHAR       *locbuf = NULL;
    DWORD       dwLocBuffLen;
    HKEY        hRegKey = 0;
    BOOL        fMachineKeySet = FALSE;
    DWORD       dwStorageType;
    BOOL        fLeaveOldKeys = FALSE;
    DWORD       dwSts;

    // Copy the location of the key groups, append the userID to it
    if (dwFlags & CRYPT_MACHINE_KEYSET)
        fMachineKeySet = TRUE;

    dwSts = AllocAndSetLocationBuff(fMachineKeySet, dwProvType, pszUserID,
                                    &hTopRegKey, &locbuf, FALSE,
                                    &fLeaveOldKeys, &dwLocBuffLen);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // open it for all access so we can save later, if necessary
    dwSts = MyRegOpenKeyEx(hTopRegKey, locbuf, 0, KEY_ALL_ACCESS, &hRegKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    CheckForStorageType(hRegKey, &dwStorageType);

    if (PROTECTED_STORAGE_KEYS == dwStorageType)
    {
        dwSts = DeleteFromProtectedStorage(pszUserID, &g_Strings, hRegKey,
                                           fMachineKeySet);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    dwSts = MyRegDeleteKey(hTopRegKey, locbuf);
    if (ERROR_SUCCESS != dwSts)
    {
        if (ERROR_FILE_NOT_FOUND == dwSts)
            dwReturn = (DWORD)NTE_BAD_KEYSET;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (hTopRegKey
        && (HKEY_CURRENT_USER != hTopRegKey)
        && (HKEY_LOCAL_MACHINE != hTopRegKey))
    {
        RegCloseKey(hTopRegKey);
    }
    if (hRegKey)
        RegCloseKey(hRegKey);
    if (locbuf)
        _nt_free(locbuf, dwLocBuffLen);
    return dwReturn;
}


/*static*/ DWORD
DeleteUserKeyGroup(
    LPSTR pszUserName,
    DWORD dwProvType,
    DWORD dwFlags)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD   dwSts;

    dwSts = DeleteContainerInfo(dwProvType,
                                pszUserName,
                                dwFlags & CRYPT_MACHINE_KEYSET);
    if (ERROR_SUCCESS != dwSts)
    {
        dwSts = DeleteOldUserKeyGroup(pszUserName, dwProvType, dwFlags);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


// read the exportability flag for the private key from the registry

/*static*/ void
ReadPrivateKeyExportability(
    IN PNTAGUserList pUser,
    IN BOOL fExchange)
{
    DWORD dwType;
    DWORD cb = 1;
    BYTE b;
    BOOL *pf;
    DWORD   dwSts;

    if (fExchange)
    {
        pf = &pUser->ContInfo.fExchExportable;
        dwSts = RegQueryValueEx(pUser->hKeys, "EExport", NULL,
                                &dwType, &b, &cb);
        if (ERROR_SUCCESS != dwSts)
            return;
    }
    else
    {
        pf = &pUser->ContInfo.fSigExportable;
        dwSts = RegQueryValueEx(pUser->hKeys, "SExport", NULL,
                                &dwType, &b, &cb);
        if (ERROR_SUCCESS != dwSts)
            return;
    }

    if ((sizeof(b) == cb) && (0x01 == b))
        *pf = TRUE;
}


DWORD
ReadKey(
    HKEY hLoc,
    char *pszName,
    BYTE **ppbData,
    DWORD *pcbLen,
    PNTAGUserList pUser,
    HCRYPTKEY hKey,
    BOOL *pfPrivKey,
    BOOL fKeyExKey,
    BOOL fLastKey)
{
    DWORD                       dwReturn = ERROR_INTERNAL_ERROR;
    DWORD                       dwTemp;
    CHAR                        *pch;
    CRYPTPROTECT_PROMPTSTRUCT   PromptStruct;
    CRYPT_DATA_BLOB             DataIn;
    CRYPT_DATA_BLOB             DataOut;
    DWORD                       dwSts;

    memset(&DataIn, 0, sizeof(DataIn));
    memset(&DataOut, 0, sizeof(DataOut));
    memset(&PromptStruct, 0, sizeof(PromptStruct));

    dwSts = ReadRegValue(hLoc, pszName, ppbData, pcbLen, TRUE);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (*ppbData)
    {
        if ((REG_KEYS == pUser->dwKeyStorageType) && *pfPrivKey)
            ReadPrivateKeyExportability(pUser, fKeyExKey);

        if ((REG_KEYS == pUser->dwKeyStorageType)
            || (PROTECTED_STORAGE_KEYS == pUser->dwKeyStorageType))
        {
            if (hKey != 0)
            {
                dwTemp = *pcbLen;
                dwSts = LocalDecrypt(pUser->hUID, hKey, 0, fLastKey, 0,
                                     *ppbData, &dwTemp, FALSE);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }
            }
        }

        pch = (CHAR *)*ppbData;
        if ((strcmp(pszName, "RandSeed") != 0) &&
            (pch[0] != 'R' ||
             pch[1] != 'S' ||
             pch[2] != 'A'))
        {
            if (!*pfPrivKey)  // this may be a Win9x public key
                *pfPrivKey = TRUE;
            else
            {
                dwReturn = (DWORD)NTE_KEYSET_ENTRY_BAD;
                goto ErrorExit;
            }
        }
    }
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    // free the DataOut struct if necessary
    if (DataOut.pbData)
        LocalFree(DataOut.pbData);
    return dwReturn;
}


//
// Routine : MigrateProtectedStorageKeys
//
// Description : Try and retrieve both the sig and exch private keys and
//               migrate them to the protection APIs and then delete the keys
//               from the protected storage.  The fSigPubKey and fExchPubKey
//               parameters indicate the public keys should be derived from
//               the private keys.
//

/*static*/ DWORD
MigrateProtectedStorageKeys(
    IN PNTAGUserList pUser,
    IN LPWSTR szPrompt,
    IN BOOL fSigPubKey,
    IN BOOL fExchPubKey)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BOOL    fMachineKeySet = FALSE;
    DWORD   dwFlags = 0;
    DWORD   dwSigFlags = 0;
    DWORD   dwExchFlags = 0;
    BOOL    fUIOnSigKey = FALSE;
    BOOL    fUIOnExchKey = FALSE;
    DWORD   dwSts;

    __try
    {
        if (CRYPT_MACHINE_KEYSET & pUser->Rights)
            fMachineKeySet = TRUE;

        // NOTE - the appropriate exportable flag is set by
        // RestoreKeysetFromProtectedStorage
        if (pUser->ContInfo.ContLens.cbSigPub || fSigPubKey)
        {
            dwSts = RestoreKeysetFromProtectedStorage(
                        pUser, szPrompt, &pUser->pSigPrivKey,
                        &pUser->SigPrivLen, TRUE, fMachineKeySet,
                        &fUIOnSigKey);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            // check if the sig key is there and the public key is supposed to
            // be derived from it
            if (fSigPubKey)
            {
                dwSts = DerivePublicFromPrivate(pUser, TRUE);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }
            }
        }

        // open the other key (sig or exch) and store
        if (pUser->ContInfo.ContLens.cbExchPub || fExchPubKey)
        {
            dwSts = RestoreKeysetFromProtectedStorage(
                        pUser, szPrompt, &pUser->pExchPrivKey,
                        &pUser->ExchPrivLen, FALSE, fMachineKeySet,
                        &fUIOnExchKey);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            // check if the sig key is there and the public key is supposed to
            // be derived from it
            if (fExchPubKey)
            {
                dwSts = DerivePublicFromPrivate(pUser, FALSE);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }
            }
        }

        // set UI flags if necessary
        if (fUIOnSigKey)
            dwSigFlags = CRYPT_USER_PROTECTED;
        if (fUIOnExchKey)
            dwExchFlags = CRYPT_USER_PROTECTED;
        if ((NULL == pUser->pSigPrivKey)
            && (NULL == pUser->pExchPrivKey))
        {
            pUser->dwKeyStorageType = PROTECTION_API_KEYS;
            dwSts = WriteContainerInfo(pUser->dwProvType,
                                       pUser->ContInfo.rgwszFileName,
                                       fMachineKeySet,
                                       &pUser->ContInfo);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }
        else
        {
            // migrate the keys to the protection APIs
            if (pUser->pSigPrivKey)
            {
                dwSts = ProtectPrivKey(pUser, g_Strings.pwszMigrKeys,
                                       dwSigFlags, TRUE);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }

                // delete the sig key from the protected storage
                dwSts = DeleteKeyFromProtectedStorage(
                            pUser, &g_Strings, AT_SIGNATURE,
                            fMachineKeySet, TRUE);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }
            }
            if (pUser->pExchPrivKey)
            {
                dwSts = ProtectPrivKey(pUser, g_Strings.pwszMigrKeys,
                                       dwExchFlags, FALSE);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }

                // delete the key exchange key from the protected storage
                dwSts = DeleteKeyFromProtectedStorage(
                            pUser, &g_Strings, AT_KEYEXCHANGE,
                            fMachineKeySet, TRUE);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }
            }
        }

        pUser->dwKeyStorageType = PROTECTION_API_KEYS;
        RegCloseKey(pUser->hKeys);
        pUser->hKeys = 0;

        if (pUser->Rights & CRYPT_MACHINE_KEYSET)
            dwFlags = CRYPT_MACHINE_KEYSET;

        // delete the registry key
        dwSts = DeleteOldUserKeyGroup(pUser->ContInfo.pszUserName,
                                      pUser->dwProvType,
                                      dwFlags);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwReturn = ERROR_SUCCESS;
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwReturn = ERROR_INVALID_PARAMETER;
    }

ErrorExit:
    return dwReturn;
}


//
// Routine : ProtectPrivKey
//
// Description : Encrypts the private key and persistently stores it.
//

DWORD
ProtectPrivKey(
    IN OUT PNTAGUserList pTmpUser,
    IN LPWSTR szPrompt,
    IN DWORD dwFlags,
    IN BOOL fSigKey)
{
    DWORD                       dwReturn = ERROR_INTERNAL_ERROR;
    BYTE                        **ppbEncKey;
    DWORD                       *pcbEncKey;
    BYTE                        *pbTmpEncKey = NULL;
    CRYPT_DATA_BLOB             DataIn;
    CRYPT_DATA_BLOB             DataOut;
    CRYPTPROTECT_PROMPTSTRUCT   PromptStruct;
    DWORD                       dwProtectFlags = 0;
    DWORD                       dwSts;

    memset(&DataIn, 0, sizeof(DataIn));
    memset(&DataOut, 0, sizeof(DataOut));
    memset(&PromptStruct, 0, sizeof(PromptStruct));

    // wrap with a try since there is a critical sections in here
    __try
    {
        EnterCriticalSection(&pTmpUser->CritSec);

        if (fSigKey)
        {
            DataIn.cbData = pTmpUser->SigPrivLen;
            DataIn.pbData = pTmpUser->pSigPrivKey;
            ppbEncKey = &(pTmpUser->ContInfo.pbSigEncPriv);
            pcbEncKey = &(pTmpUser->ContInfo.ContLens.cbSigEncPriv);
        }
        else
        {
            DataIn.cbData = pTmpUser->ExchPrivLen;
            DataIn.pbData = pTmpUser->pExchPrivKey;
            ppbEncKey = &(pTmpUser->ContInfo.pbExchEncPriv);
            pcbEncKey = &(pTmpUser->ContInfo.ContLens.cbExchEncPriv);
        }


        //
        // Two checks (needed for FIPS) before offloading to the offload
        // module.
        //
        // First check is if the user protected flag was requested so
        // that UI is attached to the decryption of the key.
        //
        // Second check is if this is a user key or a machine key.
        //

        // protect the key with the data protection API
        PromptStruct.cbSize = sizeof(PromptStruct);
        if (CRYPT_USER_PROTECTED & dwFlags)
        {
            if (pTmpUser->ContInfo.fCryptSilent)
            {
                dwReturn = (DWORD)NTE_SILENT_CONTEXT;
                goto ErrorExit;
            }

            if (fSigKey)
                pTmpUser->ContInfo.ContLens.dwUIOnKey |= AT_SIGNATURE;
            else
                pTmpUser->ContInfo.ContLens.dwUIOnKey |= AT_KEYEXCHANGE;
            PromptStruct.dwPromptFlags = CRYPTPROTECT_PROMPT_ON_UNPROTECT
                                         | CRYPTPROTECT_PROMPT_ON_PROTECT;
        }
        if (szPrompt)
        {
            PromptStruct.hwndApp = pTmpUser->hWnd;
            if (pTmpUser->pwszPrompt)
                PromptStruct.szPrompt = pTmpUser->pwszPrompt;
            else
                PromptStruct.szPrompt = szPrompt;
        }

        // protect as machine data if necessary
        if (pTmpUser->Rights & CRYPT_MACHINE_KEYSET)
            dwProtectFlags = CRYPTPROTECT_LOCAL_MACHINE;

        dwSts = MyCryptProtectData(&DataIn, L"", NULL, NULL,
                                   &PromptStruct, dwProtectFlags, &DataOut);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        pbTmpEncKey = _nt_malloc(DataOut.cbData);
        if (NULL == pbTmpEncKey)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        memcpy(pbTmpEncKey, DataOut.pbData, DataOut.cbData);
        if (NULL != *ppbEncKey)
            _nt_free(*ppbEncKey, *pcbEncKey);
        *pcbEncKey = DataOut.cbData;
        *ppbEncKey = pbTmpEncKey;

        // write out the key to the file
        dwSts = WriteContainerInfo(pTmpUser->dwProvType,
                                   pTmpUser->ContInfo.rgwszFileName,
                                   pTmpUser->Rights & CRYPT_MACHINE_KEYSET,
                                   &pTmpUser->ContInfo);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    LeaveCriticalSection(&pTmpUser->CritSec);
    // free the DataOut struct if necessary
    if (DataOut.pbData)
        LocalFree(DataOut.pbData);
    return dwReturn;
}


//
// Routine : UnprotectPrivKey
//
// Description : Decrypts the private key.  If the fAlwaysDecrypt flag is set
//               then it checks if the private key is already in the buffer
//               and if so then it does not decrypt.
//

DWORD
UnprotectPrivKey(
    IN OUT PNTAGUserList pTmpUser,
    IN LPWSTR szPrompt,
    IN BOOL fSigKey,
    IN BOOL fAlwaysDecrypt)
{
    DWORD                       dwReturn = ERROR_INTERNAL_ERROR;
    DWORD                       dwSts;
    BYTE                        **ppbKey;
    DWORD                       *pcbKey;
    BYTE                        *pbEncKey;
    DWORD                       cbEncKey;
    BYTE                        *pbTmpKey = NULL;
    CRYPTPROTECT_PROMPTSTRUCT   PromptStruct;
    CRYPT_DATA_BLOB             DataIn;
    CRYPT_DATA_BLOB             DataOut;
    CHAR                        *pch;
    DWORD                       dwProtectFlags = 0;
    BOOL                        fInCritSec = FALSE;
    DWORD                       dwReprotectFlags;

    memset(&DataOut, 0, sizeof(DataOut));
    if (!fAlwaysDecrypt)
    {

        //
        // avoid taking critical section if we aren't forced to cause
        // a re-decrypt (which is necessary when UI is forced).
        //

        if (fSigKey)
            ppbKey = &(pTmpUser->pSigPrivKey);
        else
            ppbKey = &(pTmpUser->pExchPrivKey);
        if (NULL != *ppbKey)
        {
            dwReturn = ERROR_SUCCESS;
            goto ErrorExit;
        }
    }

    // wrap with a try since there is a critical sections in here
    __try
    {

        //
        // take critical section around reads and writes to the context
        // when it hasn't been initialized.  Also, the critical section is
        // taken when fAlwaysDecrypt is specified which prevents multiple
        // outstanding UI requests.
        //

        EnterCriticalSection(&pTmpUser->CritSec);
        fInCritSec = TRUE;

        if (fSigKey)
        {
            pcbKey = &(pTmpUser->SigPrivLen);
            ppbKey = &(pTmpUser->pSigPrivKey);
            pbEncKey = pTmpUser->ContInfo.pbSigEncPriv;
            cbEncKey = pTmpUser->ContInfo.ContLens.cbSigEncPriv;
        }
        else
        {
            pcbKey = &(pTmpUser->ExchPrivLen);
            ppbKey = &(pTmpUser->pExchPrivKey);
            pbEncKey = pTmpUser->ContInfo.pbExchEncPriv;
            cbEncKey = pTmpUser->ContInfo.ContLens.cbExchEncPriv;
        }

        if ((NULL == *ppbKey) || fAlwaysDecrypt)
        {
            memset(&DataIn, 0, sizeof(DataIn));
            memset(&PromptStruct, 0, sizeof(PromptStruct));

            if (pTmpUser->Rights & CRYPT_MACHINE_KEYSET)
                dwProtectFlags = CRYPTPROTECT_LOCAL_MACHINE;

            //  set up the prompt structure
            PromptStruct.cbSize = sizeof(PromptStruct);
            PromptStruct.hwndApp = pTmpUser->hWnd;
            PromptStruct.szPrompt = szPrompt;

            DataIn.cbData = cbEncKey;
            DataIn.pbData = pbEncKey;
            dwSts = MyCryptUnprotectData(&DataIn, NULL, NULL, NULL,
                                         &PromptStruct, dwProtectFlags,
                                         &DataOut, &dwReprotectFlags);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts; // NTE_KEYSET_ENTRY_BAD
                goto ErrorExit;
            }

            pch = (CHAR *)DataOut.pbData;
            if ((sizeof(DWORD) > DataOut.cbData) || pch[0] != 'R' ||
                pch[1] != 'S' || pch[2] != 'A')
            {
                dwReturn = (DWORD)NTE_KEYSET_ENTRY_BAD;
                goto ErrorExit;
            }

            if (NULL == *ppbKey)
            {
                pbTmpKey = (BYTE*)_nt_malloc(DataOut.cbData);
                if (NULL == pbTmpKey)
                {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorExit;
                }

                memcpy(pbTmpKey, DataOut.pbData, DataOut.cbData);

                // move the new key into the context
                if (*ppbKey)
                    _nt_free(*ppbKey, *pcbKey);
                *pcbKey = DataOut.cbData;
                *ppbKey = pbTmpKey;
            }

            if (0 != (dwReprotectFlags & CRYPT_UPDATE_KEY))
            {
                dwSts = ProtectPrivKey(pTmpUser,
                                       g_Strings.pwszMigrKeys,
                                       dwReprotectFlags,    // Only CRYPT_USER_PROTECTED used.
                                       fSigKey);
                // Do we care if (it fails?)
            }
        }

        dwReturn = ERROR_SUCCESS;
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwReturn = ERROR_INVALID_PARAMETER;
    }

ErrorExit:
    if (fInCritSec)
        LeaveCriticalSection(&pTmpUser->CritSec);

    // free the DataOut struct if necessary
    if (DataOut.pbData)
    {
        ZeroMemory(DataOut.pbData, DataOut.cbData);
        LocalFree(DataOut.pbData);
    }

    return dwReturn;
}


/*static*/ DWORD
LoadWin96Cache(
    PNTAGUserList pTmpUser,
    LPSTR szUserName,
    DWORD dwFlags,
    BOOL fLowerUserName)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    HANDLE          handle = NULL;
    char            *szResource = NULL;
    char            *szLowerUserName = NULL;
    WORD            wcbRandom;
    DWORD           cbsize;
    FARPROC         CachePW;
    FARPROC         GetCachePW;
    BYTE            rgbRandom[STORAGE_RC4_KEYLEN];
    DWORD           rc;
    BOOL            fKey = FALSE;
    HCRYPTHASH      hHash;
    DWORD           dwDataLen = MD5DIGESTLEN;
    PNTAGHashList   pTmpHash;
    DWORD           dwSts;
    BYTE            HashData[MD5DIGESTLEN] = { 0x70, 0xf2, 0x85, 0x1e,
                                               0x4e, 0x00, 0x00, 0x00,
                                               0x00, 0x00, 0x00, 0x00,
                                               0x00, 0x00, 0x00, 0x00 };

#define PREFIX "crypt_"
#define CACHE "WNetCachePassword"
#define GET_CACHE "WNetGetCachedPassword"

    cbsize = strlen(szUserName) + strlen(PREFIX);

#ifndef _WIN64
    if (!FIsWinNT())
    {
        // Try to load MPR.DLL for WIN96 password cache
        handle = LoadLibrary("MPR.DLL");
        if (NULL != handle)
        {
            CachePW = GetProcAddress(handle, CACHE);
            GetCachePW = GetProcAddress(handle, GET_CACHE);
            if ((0 == (dwFlags & CRYPT_MACHINE_KEYSET))
                && (NULL != CachePW)
                && (NULL != GetCachePW))
            {
                szResource = (char *)_nt_malloc(cbsize + 1);
                if (NULL == szResource)
                {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorExit;
                }

                strcpy(szResource, PREFIX);
                strcat(szResource, szUserName);

                wcbRandom = STORAGE_RC4_KEYLEN;
                rc = GetCachePW(szResource, cbsize, rgbRandom, &wcbRandom, 6);
                if ((rc != NO_ERROR) || (wcbRandom != STORAGE_RC4_KEYLEN))
                {
                    if (rc == ERROR_NOT_SUPPORTED)
                        goto no_cache;

                    dwSts = FIPS186GenRandom(&pTmpUser->hRNGDriver,
                                             &pTmpUser->ContInfo.pbRandom,
                                             &pTmpUser->ContInfo.ContLens.cbRandom,
                                             rgbRandom,
                                             STORAGE_RC4_KEYLEN);
                    if (ERROR_SUCCESS != dwSts)
                    {
                        dwReturn = dwSts;    // NTE_FAIL
                        goto ErrorExit;
                    }

                    CachePW(szResource, cbsize, rgbRandom, STORAGE_RC4_KEYLEN,
                            6, 0);
                }

                fKey = TRUE;

                pTmpUser->pCachePW = _nt_malloc(STORAGE_RC4_KEYLEN);
                if (NULL == pTmpUser->pCachePW)
                {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorExit;
                }

                memcpy(pTmpUser->pCachePW, rgbRandom, STORAGE_RC4_KEYLEN);
            }
        }
    }

no_cache:
#endif // _WIN64

    if (!fKey)
    {
        if (!CPCreateHash(pTmpUser->hUID, CALG_MD5, 0, 0, &hHash))
        {
            dwReturn = GetLastError();  // NTE_FAIL
            goto ErrorExit;
        }

        if (!CPSetHashParam(pTmpUser->hUID, hHash, HP_HASHVAL, HashData, 0))
        {
            dwReturn = GetLastError();  // NTE_FAIL
            goto ErrorExit;
        }

        dwSts = NTLValidate(hHash, pTmpUser->hUID, HASH_HANDLE, &pTmpHash);
        if (ERROR_SUCCESS != dwSts)
        {
            if (NTE_FAIL == dwSts)
                dwReturn = (DWORD)NTE_BAD_HASH;
            else
                dwReturn = dwSts;
            goto ErrorExit;
        }

        pTmpHash->HashFlags &= ~HF_VALUE_SET;

        // make the user name lower case
        cbsize = lstrlen(szUserName) + sizeof(CHAR);
        szLowerUserName = (char *)_nt_malloc(cbsize);
        if (NULL == szLowerUserName)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        lstrcpy(szLowerUserName, szUserName);
        if (fLowerUserName)
            _strlwr(szLowerUserName);

        if (!CPHashData(pTmpUser->hUID, hHash, (LPBYTE)szLowerUserName,
                        lstrlen(szLowerUserName) + sizeof(CHAR), 0))
        {
            dwReturn = GetLastError();  // NTE_FAIL
            goto ErrorExit;
        }

        if (!CPGetHashParam(pTmpUser->hUID, hHash, HP_HASHVAL, HashData,
                            &dwDataLen, 0))
        {
            dwReturn = GetLastError();  // NTE_FAIL
            goto ErrorExit;
        }

        if (!CPDestroyHash(pTmpUser->hUID, hHash))
        {
            dwReturn = GetLastError();  // NTE_FAIL
            goto ErrorExit;
        }

        pTmpUser->pCachePW = _nt_malloc(STORAGE_RC4_KEYLEN);
        if (NULL == pTmpUser->pCachePW)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        memcpy(pTmpUser->pCachePW, HashData, STORAGE_RC4_KEYLEN);
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (szLowerUserName)
        _nt_free(szLowerUserName, cbsize);
    if (szResource)
        _nt_free(szResource, cbsize);
    if (handle)
        FreeLibrary(handle);
    return dwReturn;
}


/*
 * Retrieve the security descriptor for a registry key
 */

/*static*/ DWORD
GetRegKeySecDescr(
    PNTAGUserList pUser,
    HKEY hRegKey,
    BYTE **ppbSecDescr,
    DWORD *pcbSecDescr,
    DWORD *pdwSecDescrFlags)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD   cb = 0;
    DWORD   dwSts;

    *ppbSecDescr = NULL;
    if (pUser->dwOldKeyFlags & PRIVILEDGE_FOR_SACL)
    {
        *pdwSecDescrFlags = SACL_SECURITY_INFORMATION
                            | GROUP_SECURITY_INFORMATION
                            | DACL_SECURITY_INFORMATION;
    }
    else
    {
        *pdwSecDescrFlags = GROUP_SECURITY_INFORMATION
                            | DACL_SECURITY_INFORMATION;
    }

    // get the security descriptor for the hKey of the keyset
    dwSts = RegGetKeySecurity(hRegKey,
                              (SECURITY_INFORMATION)*pdwSecDescrFlags,
                              &cb, &cb);
    if ((ERROR_SUCCESS != dwSts)
        && (ERROR_INSUFFICIENT_BUFFER != dwSts))
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    *ppbSecDescr = (BYTE*)_nt_malloc(cb);
    if (NULL == *ppbSecDescr)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    dwSts = RegGetKeySecurity(hRegKey,
                              (SECURITY_INFORMATION)*pdwSecDescrFlags,
                              (PSECURITY_DESCRIPTOR)*ppbSecDescr,
                              &cb);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    *pcbSecDescr = cb;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if ((ERROR_SUCCESS != dwReturn) && (NULL != *ppbSecDescr))
    {
        _nt_free(*ppbSecDescr, cb);
        *ppbSecDescr = NULL;
    }
    return dwReturn;
}


/*
 * Retrieve the keys from persistant storage
 *
 * NOTE: caller must have zeroed out pUser to allow for non-existent keys
 */
// MTS: Assumes the registry won't change between ReadKey calls.

/*static*/ DWORD
RestoreUserKeys(
    HKEY hKeys,
    PNTAGUserList pUser)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGKeyList        pTmpKey;
    HCRYPTKEY           hKey = 0;
    BYTE                rgbKeyBuffer[STORAGE_RC4_TOTALLEN];
    CRYPT_DATA_BLOB     sSaltData;
    DWORD               dwFlags = 0;
    BOOL                fMachineKeyset = FALSE;
    BYTE                *pbSecDescr = NULL;
    DWORD               cbSecDescr;
    DWORD               dwSecDescrFlags = 0;
    BOOL                fPrivKey;
    BOOL                fEPbk = FALSE;
    BOOL                fSPbk = FALSE;
    DWORD               dwSts;

    if (pUser->pCachePW != NULL)
    {
        ZeroMemory(rgbKeyBuffer, STORAGE_RC4_TOTALLEN);
        CopyMemory(rgbKeyBuffer, pUser->pCachePW, STORAGE_RC4_KEYLEN);

        dwSts = MakeNewKey(CALG_RC4, 0, STORAGE_RC4_KEYLEN, pUser->hUID,
                           rgbKeyBuffer, FALSE, FALSE, &pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        else
        {
            dwSts = NTLMakeItem(&hKey, KEY_HANDLE, (void *)pTmpKey);
            if (ERROR_SUCCESS != dwSts)
            {
                FreeNewKey(pTmpKey);
                hKey = 0;
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }

        // set zeroized salt for RSABase compatibility
        sSaltData.pbData = rgbKeyBuffer + STORAGE_RC4_KEYLEN;
        sSaltData.cbData = STORAGE_RC4_TOTALLEN - STORAGE_RC4_KEYLEN;
        if (!CPSetKeyParam(pUser->hUID, hKey, KP_SALT_EX,
                           (PBYTE)&sSaltData, 0))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }
    }

    dwSts = ReadKey(hKeys, "EPbK", &pUser->ContInfo.pbExchPub,
                    &pUser->ContInfo.ContLens.cbExchPub, pUser, hKey,
                    &fEPbk, TRUE, FALSE);
    if (ERROR_SUCCESS != dwSts)
    {
        if (ERROR_FILE_NOT_FOUND == dwSts)
            dwReturn = (DWORD)NTE_BAD_KEYSET;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    if (REG_KEYS == pUser->dwKeyStorageType)
    {
        fPrivKey = TRUE;
        dwSts = ReadKey(hKeys, "EPvK", &pUser->pExchPrivKey,
                        &pUser->ExchPrivLen, pUser, hKey,
                        &fPrivKey, TRUE, FALSE);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

#ifndef BBN
        fPrivKey = TRUE;
        dwSts = ReadKey(hKeys, "SPvK", &pUser->pSigPrivKey,
                        &pUser->SigPrivLen, pUser, hKey,
                        &fPrivKey, FALSE, FALSE);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
#endif
    }

    dwSts = ReadKey(hKeys, "SPbK", &pUser->ContInfo.pbSigPub,
                    &pUser->ContInfo.ContLens.cbSigPub, pUser, hKey,
                    &fSPbk, FALSE, TRUE);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // get the security descriptor for the old keyset
    dwSts = GetRegKeySecDescr(pUser, hKeys, &pbSecDescr, &cbSecDescr,
                              &dwSecDescrFlags);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (CRYPT_MACHINE_KEYSET & pUser->Rights)
        fMachineKeyset = TRUE;

    // if keys are in the protected storage then migrate them
    if (PROTECTED_STORAGE_KEYS == pUser->dwKeyStorageType)
    {
        // migrate the keys from the protected storage
        dwSts = MigrateProtectedStorageKeys(pUser, g_Strings.pwszMigrKeys,
                                            fSPbk, fEPbk);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }
    else if (!(pUser->dwOldKeyFlags & LEAVE_OLD_KEYS))
    {
        if ((NULL == pUser->pSigPrivKey) &&
            (NULL == pUser->pExchPrivKey))
        {
            pUser->dwKeyStorageType = PROTECTION_API_KEYS;
            dwSts = WriteContainerInfo(pUser->dwProvType,
                                       pUser->ContInfo.rgwszFileName,
                                       fMachineKeyset,
                                       &pUser->ContInfo);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }
        else
        {
            // migrate the keys to use protection APIs
            if (pUser->pSigPrivKey)
            {
                dwSts = ProtectPrivKey(pUser, NULL, 0, TRUE);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }
            }
            if (pUser->pExchPrivKey)
            {
                dwSts = ProtectPrivKey(pUser, NULL, 0, FALSE);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }
            }
        }

        RegCloseKey(pUser->hKeys);
        pUser->hKeys = 0;

        if (pUser->Rights & CRYPT_MACHINE_KEYSET)
            dwFlags = CRYPT_MACHINE_KEYSET;

        // delete the registry key
        dwSts = DeleteOldUserKeyGroup(pUser->ContInfo.pszUserName,
                                      pUser->dwProvType,
                                      dwFlags);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }
    else
    {
        // not migrating the keys so just leave things as is and
        // return success
        dwReturn = ERROR_SUCCESS;
        goto ErrorExit;
    }

    // set the security descriptor on the container
    if (NULL != pbSecDescr)
    {
        // set the security descriptor for the hKey of the keyset
        dwSts = SetSecurityOnContainerWithTokenPriviledges(
                    pUser->dwOldKeyFlags,
                    pUser->ContInfo.rgwszFileName,
                    pUser->dwProvType,
                    fMachineKeyset,
                    (SECURITY_INFORMATION)dwSecDescrFlags,
                    (PSECURITY_DESCRIPTOR)pbSecDescr);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pbSecDescr)
        _nt_free(pbSecDescr, cbSecDescr);
    if (hKey != 0)
        CPDestroyKey(pUser->hUID, hKey);
    return dwReturn;
}


// This function is for a bug fix and trys to decrypt and re-encrypt the
// keyset

/*static*/ DWORD
MixedCaseKeysetBugCheck(
    HKEY hKeySetRegKey,
    PNTAGUserList pTmpUser,
    char *szUserName1,
    DWORD dwFlags)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    char        *szUserName2 = NULL;
    char        *szKeyName1 = NULL;
    char        *szKeyName2 = NULL;
    DWORD       cbUserName = 0;
    DWORD       cbKeyName1;
    DWORD       cbKeyName2;
    FILETIME    ft;
    HKEY        hRegKey = 0;
    DWORD       i;
    DWORD       cSubKeys;
    DWORD       cchMaxClass;
    DWORD       cValues;
    DWORD       cchMaxValueName;
    DWORD       cbMaxValueData;
    DWORD       cbSecurityDesriptor;
    DWORD       dwSts;

    dwSts = OpenUserReg(szUserName1, pTmpUser->dwProvType, dwFlags,
                        TRUE, &hRegKey, &pTmpUser->dwOldKeyFlags);
    if (ERROR_SUCCESS != dwSts)
    {
        if (ERROR_FILE_NOT_FOUND == dwSts)
            dwReturn = (DWORD)NTE_BAD_KEYSET;
        else
            dwReturn = dwSts;
        goto ErrorExit;
    }

    cbUserName = lstrlen(szUserName1) + sizeof(char);
    szUserName2 = _nt_malloc(cbUserName);
    if (NULL == szUserName2)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    strcpy(szUserName2, szUserName1);
    _strlwr(szUserName2);

    dwSts = RegQueryInfoKey(hRegKey, NULL, NULL, NULL, &cSubKeys,
                            &cbKeyName1, &cchMaxClass, &cValues,
                            &cchMaxValueName, &cbMaxValueData,
                            &cbSecurityDesriptor, &ft);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    szKeyName1 = _nt_malloc(cbKeyName1 + 2);
    szKeyName2 = _nt_malloc(cbKeyName1 + 2);
    if ((NULL == szKeyName1) || (NULL == szKeyName2))
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    for (i=0; i < cSubKeys; i++)
    {
        cbKeyName2 = cbKeyName1 + 2;
        dwSts = RegEnumKeyEx(hRegKey, i, szKeyName1, &cbKeyName2,
                             NULL, NULL, NULL, &ft);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        lstrcpy(szKeyName2, szKeyName1);
        _strlwr(szKeyName1);
        if (0 == lstrcmp(szKeyName1, szUserName2))
        {
            _nt_free(pTmpUser->pCachePW, STORAGE_RC4_KEYLEN);
            pTmpUser->pCachePW = NULL;
            dwSts = LoadWin96Cache(pTmpUser, szKeyName2, dwFlags, FALSE);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            dwSts = RestoreUserKeys(hKeySetRegKey, pTmpUser);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            break;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (hRegKey)
        RegCloseKey(hRegKey);
    if (szUserName2)
        _nt_free(szUserName2, cbUserName);
    if (szKeyName1)
        _nt_free(szKeyName1, cbKeyName1 + 2);
    if (szKeyName2)
        _nt_free(szKeyName2, cbKeyName1 + 2);
    return dwReturn;
}


/*static*/ PNTAGUserList
InitUser(
    void)
{
    PNTAGUserList pTmpUser = NULL;

    pTmpUser = (PNTAGUserList)_nt_malloc(sizeof(NTAGUserList));
    if (NULL != pTmpUser)
    {
        InitializeCriticalSection(&pTmpUser->CritSec);

        // initialize the mod expo offload information
        InitExpOffloadInfo(&pTmpUser->pOffloadInfo);

        pTmpUser->dwEnumalgs = 0xFFFFFFFF;
        pTmpUser->dwEnumalgsEx = 0xFFFFFFFF;
        pTmpUser->hRNGDriver = INVALID_HANDLE_VALUE;
    }

    return pTmpUser;
}


/************************************************************************/
/* LogonUser validates a user and returns the package-specific info for */
/* that user.                                                           */
/************************************************************************/

DWORD
NTagLogonUser(
    LPCSTR pszUserID,
    DWORD dwFlags,
    void **UserInfo,
    HCRYPTPROV *phUID,
    DWORD dwProvType,
    LPSTR pszProvName)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGUserList   pTmpUser = NULL;
    DWORD           dwUserLen = 0;
    DWORD           dwProvLen = 0;
    char            *szUserName = NULL;
    char            *szProvName = NULL;
    DWORD           dwTemp;
    HKEY            hRegKey;
    char            random[10];
    DWORD           dwSts;

    // load the resource strings if this is a static lib
#ifdef STATIC_BUILD
    dwSts = LoadStrings();
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }
#endif // STATIC_BUILD

    SetMachineGUID();

    // Check for Invalid flags
    if (dwFlags & ~(CRYPT_NEWKEYSET
                    | CRYPT_DELETEKEYSET
                    | CRYPT_VERIFYCONTEXT
                    | CRYPT_MACHINE_KEYSET
                    | CRYPT_SILENT))
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    if (((dwFlags & CRYPT_VERIFYCONTEXT) == CRYPT_VERIFYCONTEXT)
        && (NULL != pszUserID) && (0x00 != *pszUserID))
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    // Check that user provided pointer is valid
    if (IsBadWritePtr(phUID, sizeof(HCRYPTPROV)))
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    // If the user didn't supply a name, then we need to get it
    if (pszUserID != NULL
        && *pszUserID == '\0'
        || (pszUserID == NULL
            && ((dwFlags & CRYPT_VERIFYCONTEXT) != CRYPT_VERIFYCONTEXT)))
    {
        dwUserLen = MAXUIDLEN;
        szUserName = (char *)_nt_malloc(dwUserLen);
        if (NULL == szUserName)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        if (dwFlags & CRYPT_MACHINE_KEYSET)
        {
            strcpy(szUserName, NTAG_DEF_MACH_CONT_NAME);
            dwTemp = NTAG_DEF_MACH_CONT_NAME_LEN;
        }
        else
        {
            dwTemp = dwUserLen;

            if (!GetUserName(szUserName, &dwTemp))
            {
                dwTemp = sizeof("*Default*");
                memcpy(szUserName, "*Default*", dwTemp);
            }
        }
    }
    else if (pszUserID != NULL)
    {
        dwUserLen = strlen(pszUserID) + sizeof(CHAR);
        if ((dwFlags & CRYPT_NEWKEYSET)
            && (dwUserLen > MAX_PATH + 1))
        {
            dwReturn = (DWORD)NTE_BAD_KEYSET_PARAM;
            goto ErrorExit;
        }

        szUserName = (char *)_nt_malloc(dwUserLen);
        if (NULL == szUserName)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        strcpy(szUserName, pszUserID);
    }

    if (dwFlags & CRYPT_DELETEKEYSET)
    {
        dwSts = DeleteUserKeyGroup(szUserName, dwProvType, dwFlags);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwReturn = ERROR_SUCCESS;
        goto ErrorExit;
    }

    // Zero to ensure valid fields for non-existent keys
    pTmpUser = InitUser();
    if (NULL == pTmpUser)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    pTmpUser->dwProvType = dwProvType;
    dwProvLen = strlen(pszProvName) + 1;
    szProvName = _nt_malloc(dwProvLen);
    if (NULL == szProvName)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }
    memcpy(szProvName, pszProvName, dwProvLen);
    pTmpUser->szProviderName = szProvName;
    szProvName = NULL;

    switch (dwProvType)
    {
    case PROV_RSA_SCHANNEL:
        pTmpUser->dwCspTypeId = POLICY_MS_SCHANNEL;
        if (NULL == pTmpUser->szProviderName)
            pTmpUser->szProviderName = MS_DEF_RSA_SCHANNEL_PROV;
        break;
    case PROV_RSA_SIG:
        pTmpUser->dwCspTypeId = POLICY_MS_SIGONLY;
        if (NULL == pTmpUser->szProviderName)
            pTmpUser->szProviderName = MS_DEF_RSA_SIG_PROV;
        break;
    case PROV_RSA_FULL:
        if (NULL == pTmpUser->szProviderName)
        {
            pTmpUser->dwCspTypeId = POLICY_MS_ENHANCED;
            pTmpUser->szProviderName = MS_ENHANCED_PROV;
        }
        else
        {
            if (0 == lstrcmpi(MS_DEF_PROV, pszProvName))
                pTmpUser->dwCspTypeId = POLICY_MS_DEF;
            else if (0 == lstrcmpi(MS_STRONG_PROV, pszProvName))
                pTmpUser->dwCspTypeId = POLICY_MS_STRONG;
            else
                pTmpUser->dwCspTypeId = POLICY_MS_ENHANCED;
        }
        break;
    case PROV_RSA_AES:
        pTmpUser->dwCspTypeId = POLICY_MS_RSAAES;
        if (NULL == pTmpUser->szProviderName)
            pTmpUser->szProviderName = MS_ENH_RSA_AES_PROV;
        break;
    default:
        dwReturn = (DWORD)NTE_BAD_PROV_TYPE;
        goto ErrorExit;
    }

    // check if local machine keys
    if ((dwFlags & CRYPT_SILENT) || (dwFlags & CRYPT_VERIFYCONTEXT))
        pTmpUser->ContInfo.fCryptSilent = TRUE;
    if ((dwFlags & CRYPT_VERIFYCONTEXT) != CRYPT_VERIFYCONTEXT)
    {
        dwSts = OpenUserKeyGroup(pTmpUser, szUserName, dwFlags);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    // check if local machine keys
    if (dwFlags & CRYPT_MACHINE_KEYSET)
        pTmpUser->Rights |= CRYPT_MACHINE_KEYSET;

    dwSts = IsLocalSystem(&pTmpUser->fIsLocalSystem);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwSts = NTLMakeItem(phUID, USER_HANDLE, (void *)pTmpUser);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    pTmpUser->hUID = *phUID;

    if (((dwFlags & CRYPT_VERIFYCONTEXT) != CRYPT_VERIFYCONTEXT)
        && (PROTECTION_API_KEYS != pTmpUser->dwKeyStorageType)
        && (!(CRYPT_NEWKEYSET & dwFlags)))
    {
        CheckForStorageType(pTmpUser->hKeys, &pTmpUser->dwKeyStorageType);
        if (PROTECTED_STORAGE_KEYS == pTmpUser->dwKeyStorageType)
        {
            // check for PStore availability and use it if its there
            pTmpUser->pPStore = (PSTORE_INFO*)_nt_malloc(sizeof(PSTORE_INFO));
            if (NULL == pTmpUser->pPStore)
            {
                dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorExit;
            }

            // check if PStore is available
            if (!CheckPStoreAvailability(pTmpUser->pPStore))
            {
                dwReturn = (DWORD)NTE_KEYSET_ENTRY_BAD;
                goto ErrorExit;
            }

            dwSts = GetKeysetTypeAndSubType(pTmpUser);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }

        // migrate old keys
        if ((REG_KEYS == pTmpUser->dwKeyStorageType)
            || (PROTECTED_STORAGE_KEYS == pTmpUser->dwKeyStorageType))
        {
            dwSts = LoadWin96Cache(pTmpUser,
                                   pTmpUser->ContInfo.pszUserName,
                                   dwFlags,
                                   TRUE);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            dwSts = RestoreUserKeys(pTmpUser->hKeys, pTmpUser);
            if (ERROR_SUCCESS != dwSts)
            {
                if ((DWORD)NTE_BAD_KEYSET == dwSts)
                {
                    dwSts = MixedCaseKeysetBugCheck(pTmpUser->hKeys,
                                                    pTmpUser,
                                                    szUserName,
                                                    dwFlags);
                    if (ERROR_SUCCESS != dwSts)
                    {
                        dwReturn = dwSts;    // NTE_BAD_KEYSET
                        goto ErrorExit;
                    }
                }
                else
                {
                    dwReturn = dwSts;    // NTE_BAD_KEYSET
                    goto ErrorExit;
                }
            }
        }
        else
        {
            dwReturn = (DWORD)NTE_BAD_KEYSET;
            goto ErrorExit;
        }
    }

    if ((0 != pTmpUser->ContInfo.ContLens.cbExchPub)
        && (NULL != pTmpUser->ContInfo.pbExchPub))
    {
        BSAFE_PUB_KEY *pPubKey
            = (BSAFE_PUB_KEY *)pTmpUser->ContInfo.pbExchPub;

        if (!IsLegalLength(g_AlgTables[pTmpUser->dwCspTypeId],
                           CALG_RSA_KEYX,
                           pPubKey->bitlen,
                           NULL))
        {
            dwReturn = (DWORD)NTE_KEYSET_ENTRY_BAD;
            goto ErrorExit;
        }
    }

#ifdef TEST_HW_RNG
    // checks if the HWRNG is to be used
    SetupHWRNGIfRegistered(&pTmpUser->hRNGDriver);
#endif

    // allocate random seed buffer, if necessary
    if (NULL == pTmpUser->ContInfo.pbRandom)
    {
        pTmpUser->ContInfo.pbRandom = _nt_malloc(A_SHA_DIGEST_LEN);
        if (NULL == pTmpUser->ContInfo.pbRandom)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }
        pTmpUser->ContInfo.ContLens.cbRandom = A_SHA_DIGEST_LEN;
    }

    dwSts = FIPS186GenRandom(&pTmpUser->hRNGDriver,
                             &pTmpUser->ContInfo.pbRandom,
                             &pTmpUser->ContInfo.ContLens.cbRandom,
                             (LPBYTE)random, sizeof(random));
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (!(POLICY_MS_STRONG == pTmpUser->dwCspTypeId))
    {
        dwSts = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                              "Software\\Microsoft\\Cryptography\\DESHashSessionKeyBackward",
                              0, KEY_READ, &hRegKey);
        if (ERROR_SUCCESS == dwSts)
        {
            pTmpUser->Rights |= CRYPT_DES_HASHKEY_BACKWARDS;
            RegCloseKey(hRegKey);
            hRegKey = 0;
        }
    }

    if (dwFlags & CRYPT_VERIFYCONTEXT)
        pTmpUser->Rights |= CRYPT_VERIFYCONTEXT;
    *UserInfo = pTmpUser;
    pTmpUser = NULL;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != szUserName)
        _nt_free(szUserName, dwUserLen);
    if (NULL != szProvName)
        _nt_free(szProvName, dwProvLen);
    if (NULL != pTmpUser)
        FreeUserRec(pTmpUser);
    return dwReturn;
}


/************************************************************************/
/* LogoffUser removes a user from the user list.  The handle to that    */
/* will therefore no longer be valid.                   */
/************************************************************************/

void
LogoffUser(
    void *UserInfo)
{
    PNTAGUserList   pTmpUser = (PNTAGUserList)UserInfo;
    HKEY                hKeys;

    hKeys = pTmpUser->hKeys;
    FreeUserRec(pTmpUser);
    if (NULL != hKeys)
        RegCloseKey(hKeys);
}


/*
 -  CPAcquireContext
 -
 *  Purpose:
 *               The CPAcquireContext function is used to acquire a context
 *               handle to a cryptograghic service provider (CSP).
 *
 *
 *  Parameters:
 *               OUT phUID         -  Handle to a CSP
 *               IN  pUserID       -  Pointer to a string which is the
 *                                    identity of the logged on user
 *               IN  dwFlags       -  Flags values
 *               IN  pVTable       -  Pointer to table of function pointers
 *
 *  Returns:
 */

BOOL WINAPI
CPAcquireContext(
    OUT HCRYPTPROV *phUID,
    IN CONST CHAR *pUserID,
    IN DWORD dwFlags,
    IN PVTableProvStruc pVTable)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    void            *UserData;
    PNTAGUserList   pTmpUser;
    DWORD           dwProvType = PROV_RSA_FULL;
    LPSTR           pszProvName = NULL;
    BOOL            fRet;
    DWORD           dwSts;

    EntryPoint
    if (pVTable->Version >= 2)
        dwProvType = pVTable->dwProvType;

    if (pVTable->Version >= 3)
        pszProvName = pVTable->pszProvName;

    dwSts = NTagLogonUser(pUserID, dwFlags, &UserData,
                          phUID, dwProvType, pszProvName);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (0 == (dwFlags & CRYPT_DELETEKEYSET))
    {
        pTmpUser = (PNTAGUserList)UserData;
        pTmpUser->hPrivuid = 0;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (!fRet)
        SetLastError(dwReturn);
    return fRet;
}


/*
 -      CPReleaseContext
 -
 *      Purpose:
 *               The CPReleaseContext function is used to release a
 *               context created by CrytAcquireContext.
 *
 *     Parameters:
 *               IN  hUID          -  Handle to a CSP
 *               IN  dwFlags       -  Flags values
 *
 *  Returns:
 */

BOOL WINAPI
CPReleaseContext(
    IN HCRYPTPROV hUID,
    IN DWORD dwFlags)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BOOL    fRet;
    void    *UserData = NULL;

    EntryPoint
    // check to see if this is a valid user handle
    // ## MTS: No user structure locking
    UserData = NTLCheckList(hUID, USER_HANDLE);
    if (NULL == UserData)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    //
    // From here on out, we close the context, even if there is
    // another error detected.
    dwReturn = ERROR_SUCCESS;

    // Check for Invalid flags
    if (dwFlags != 0)
        dwReturn = (DWORD)NTE_BAD_FLAGS;

    LogoffUser(UserData);

    // Remove from internal list first so others
    // can't get to it, then logoff the current user
    NTLDelete(hUID);

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (!fRet)
        SetLastError(dwReturn);
    return fRet;
}


#if 0
DWORD
RemovePublicKeyExportability(
    IN PNTAGUserList pUser,
    IN BOOL fExchange)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    DWORD dwType;
    DWORD cb;
    DWORD dwSts;

    if (fExchange)
    {
        dwSts = RegQueryValueEx(pUser->hKeys, "EExport", NULL,
                                &dwType, NULL, &cb);
        if (ERROR_SUCCESS == dwSts)
        {
            dwSts = RegDeleteValue(pUser->hKeys, "EExport");
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }
    }
    else
    {
        dwSts = RegQueryValueEx(pUser->hKeys, "SExport", NULL,
                                &dwType, NULL, &cb);
        if (ERROR_SUCCESS == dwSts)
        {
            dwSts = RegDeleteValue(pUser->hKeys, "SExport");
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


DWORD
MakePublicKeyExportable(
    IN PNTAGUserList pUser,
    IN BOOL fExchange)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    BYTE b = 0x01;
    DWORD dwSts;

    if (fExchange)
    {
        dwSts = RegSetValueEx(pUser->hKeys, "EExport", 0,
                              REG_BINARY, &b, sizeof(b));
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }
    else
    {
        dwSts = RegSetValueEx(pUser->hKeys, "SExport", 0,
                              REG_BINARY, &b, sizeof(b));
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


DWORD
CheckPublicKeyExportability(
    IN PNTAGUserList pUser,
    IN BOOL fExchange)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    DWORD dwType;
    DWORD cb = 1;
    BYTE b;
    DWORD dwSts;

    if (fExchange)
    {
        dwSts = RegQueryValueEx(pUser->hKeys, "EExport", NULL,
                                &dwType, &b, &cb);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }
    else
    {
        dwSts = RegQueryValueEx(pUser->hKeys, "SExport", NULL,
                                &dwType, &b, &cb);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    if ((sizeof(b) != cb) || (0x01 != b))
    {
        dwReturn = (DWORD)NTE_PERM;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\rsaaes\nt_crypt.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : nt_crypt.c                                             //
//  DESCRIPTION   : Crypto CP interfaces:                                  //
//                  CPEncrypt                                              //
//                  CPDecrypt                                              //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Jan 25 1995 larrys  Changed from Nametag                           //
//      Jan 30 1995 larrys  Cleanup code                                   //
//      Feb 23 1995 larrys  Changed NTag_SetLastError to SetLastError      //
//      Apr 10 1995 larrys  Added freeing of RC4 key data on final flag    //
//      May  8 1995 larrys  Changes for MAC hashing                        //
//      May  9 1995 larrys  Added check for double encryption              //
//      May 10 1995 larrys  added private api calls                        //
//      Jul 13 1995 larrys  Changed MAC stuff                              //
//      Aug 16 1995 larrys  Removed exchange key stuff                     //
//      Oct 05 1995 larrys  Fixed bugs 50 & 51                             //
//      Nov  8 1995 larrys  Fixed SUR bug 10769                            //
//      May 15 1996 larrys  Changed NTE_NO_MEMORY to ERROR_NOT_ENOUGH...   //
//      May  3 2000 dbarlow Fix return codes                               //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "nt_rsa.h"
#include "mac.h"
#include "tripldes.h"
#include "swnt_pk.h"
#include "protstor.h"
#include "ntagum.h"
#include "aes.h"

#define DE_BLOCKLEN             8       // size of double encrypt block

BYTE        dbDEncrypt[DE_BLOCKLEN];    // First 8 bytes of last encrypt
BOOL        fDEncrypt = FALSE;          // Flag for Double encrypt
BYTE        dbDDecrypt[DE_BLOCKLEN];    // First 8 bytes of last Decrypt
DWORD       fDDecrypt = FALSE;          // Flag for Double Decrypt

extern CSP_STRINGS g_Strings;

extern BOOL
FIsLegalKey(
    PNTAGUserList pTmpUser,
    PNTAGKeyList pKey,
    BOOL fRC2BigKeyOK);

extern DWORD
InflateKey(
    IN PNTAGKeyList pTmpKey);


/* BlockEncrypt -

        Run a block cipher over a block of size *pdwDataLen.

*/

DWORD
BlockEncrypt(
    void EncFun(BYTE *In, BYTE *Out, void *key, int op),
    PNTAGKeyList pKey,
    int BlockLen,
    BOOL Final,
    BYTE  *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    DWORD cbPartial, dwPadVal, dwDataLen;
    BYTE  *pbBuf;

    dwDataLen = *pdwDataLen;

    // Check to see if we are encrypting something already

    if (pKey->InProgress == FALSE)
    {
        pKey->InProgress = TRUE;
        if (pKey->Mode == CRYPT_MODE_CBC || pKey->Mode == CRYPT_MODE_CFB)
            memcpy(pKey->FeedBack, pKey->IV, BlockLen);
    }

    // check length of the buffer and calculate the pad
    // (if multiple of blocklen, do a full block of pad)

    cbPartial = (dwDataLen % BlockLen);
    if (Final)
    {
        dwPadVal = BlockLen - cbPartial;
        if (pbData == NULL || dwBufLen < dwDataLen + dwPadVal)
        {
            // set what we need
            *pdwDataLen = dwDataLen + dwPadVal;
            dwReturn = (NULL == pbData) ? ERROR_SUCCESS : ERROR_MORE_DATA;
            goto ErrorExit;
        }
        else
        {
            // Clear encryption flag
            pKey->InProgress = FALSE;
        }
    }
    else
    {
        if (pbData == NULL)
        {
            *pdwDataLen = dwDataLen;
            dwReturn = ERROR_SUCCESS;
            goto ErrorExit;
        }

        // Non-Final make multiple of the blocklen
        if (cbPartial)
        {
            // set what we need
            *pdwDataLen = dwDataLen + cbPartial;
            ASSERT((*pdwDataLen % BlockLen) == 0);
            dwReturn = (DWORD)NTE_BAD_DATA;
            goto ErrorExit;
        }
        dwPadVal = 0;
    }

    // allocate memory for a temporary buffer
    if ((pbBuf = (BYTE *)_nt_malloc(BlockLen)) == NULL)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    if (dwPadVal)
    {
        // Fill the pad with a value equal to the
        // length of the padding, so decrypt will
        // know the length of the original data
        // and as a simple integrity check.

        memset(pbData + dwDataLen, (int)dwPadVal, (size_t)dwPadVal);
    }

    dwDataLen += dwPadVal;
    *pdwDataLen = dwDataLen;

    ASSERT((dwDataLen % BlockLen) == 0);

    // pump the full blocks of data through
    while (dwDataLen)
    {
        ASSERT(dwDataLen >= (DWORD)BlockLen);

        // put the plaintext into a temporary
        // buffer, then encrypt the data
        // back into the caller's buffer

        memcpy(pbBuf, pbData, BlockLen);

        switch (pKey->Mode)
        {
        case CRYPT_MODE_CBC:
            CBC(EncFun, BlockLen, pbData, pbBuf, pKey->pData,
                ENCRYPT, pKey->FeedBack);
            break;

        case CRYPT_MODE_ECB:
            EncFun(pbData, pbBuf, pKey->pData, ENCRYPT);
            break;

        case CRYPT_MODE_CFB:
            CFB(EncFun, BlockLen, pbData, pbBuf, pKey->pData,
                ENCRYPT, pKey->FeedBack);
            break;

        default:
            _nt_free(pbBuf, BlockLen);
            dwReturn = (DWORD) NTE_BAD_ALGID;
            goto ErrorExit;
        }
        pbData += BlockLen;
        dwDataLen -= BlockLen;
    }

    _nt_free(pbBuf, BlockLen);
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}

DWORD
BlockDecrypt(
    void DecFun(BYTE *In, BYTE *Out, void *key, int op),
    PNTAGKeyList pKey,
    int BlockLen,
    BOOL Final,
    BYTE  *pbData,
    DWORD *pdwDataLen)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BYTE    *pbBuf;
    DWORD   dwDataLen, BytePos, dwPadVal, i;

    dwDataLen = *pdwDataLen;

    // Check to see if we are decrypting something already

    if (pKey->InProgress == FALSE)
    {
        pKey->InProgress = TRUE;
        if (pKey->Mode == CRYPT_MODE_CBC ||
            pKey->Mode == CRYPT_MODE_CFB)
        {
            memcpy(pKey->FeedBack, pKey->IV, BlockLen);
        }
    }

    // The data length must be a multiple of the algorithm
    // pad size.
    if (dwDataLen % BlockLen)
    {
        dwReturn = (DWORD)NTE_BAD_DATA;
        goto ErrorExit;
    }

    // allocate memory for a temporary buffer
    if ((pbBuf = (BYTE *)_nt_malloc(BlockLen)) == NULL)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    // pump the data through the decryption, including padding
    // NOTE: the total length is a multiple of BlockLen

    for (BytePos = 0; (BytePos + BlockLen) <= dwDataLen; BytePos += BlockLen)
    {
        // put the encrypted text into a temp buffer
        memcpy (pbBuf, pbData + BytePos, BlockLen);

        switch (pKey->Mode)
        {
        case CRYPT_MODE_CBC:
            CBC(DecFun, BlockLen, pbData + BytePos, pbBuf, pKey->pData,
                DECRYPT, pKey->FeedBack);
            break;

        case CRYPT_MODE_ECB:
            DecFun(pbData + BytePos, pbBuf, pKey->pData, DECRYPT);
            break;

        case CRYPT_MODE_CFB:
            CFB(DecFun, BlockLen, pbData + BytePos, pbBuf, pKey->pData,
                DECRYPT, pKey->FeedBack);
            break;

        default:
            _nt_free(pbBuf, BlockLen);
            dwReturn = (DWORD)NTE_BAD_ALGID;
            goto ErrorExit;
        }
    }

    _nt_free(pbBuf, BlockLen);

    // if this is the final block of data then
    // verify the padding and remove the pad size
    // from the data length. NOTE: The padding is
    // filled with a value equal to the length
    // of the padding and we are guaranteed >= 1
    // byte of pad.
    // ## NOTE: if the pad is wrong, the user's
    // buffer is hosed, because
    // ## we've decrypted into the user's
    // buffer -- can we re-encrypt it?

    if (Final)
    {
        pKey->InProgress = FALSE;

        dwPadVal = (DWORD)*(pbData + dwDataLen - 1);
        if (dwPadVal == 0 || dwPadVal > (DWORD) BlockLen)
        {
            dwReturn = (DWORD)NTE_BAD_DATA;
            goto ErrorExit;
        }

        // Make sure all the (rest of the) pad bytes are correct.
        for (i=1; i<dwPadVal; i++)
        {
            if (pbData[dwDataLen - (i + 1)] != dwPadVal)
            {
                dwReturn = (DWORD)NTE_BAD_DATA;
                goto ErrorExit;
            }
        }

        // Only need to update the length on final
        *pdwDataLen -= dwPadVal;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*
 -      SymEncrypt
 -
 *      Purpose:
 *                Encrypt data with symmetric algorithms.  This function is used
 *                by the LocalEncrypt function as well as the WrapSymKey (nt_key.c)
 *                function.
 *
 *      Parameters:
 *               IN  pKey          -  Handle to the key
 *               IN  fFinal        -  Boolean indicating if this is the final
 *                                    block of plaintext
 *               IN OUT pbData     -  Data to be encrypted
 *               IN OUT pcbData    -  Pointer to the length of the data to be
 *                                    encrypted
 *               IN cbBuf          -  Size of Data buffer
 *
 *      Returns:
 */

DWORD
SymEncrypt(
    IN PNTAGKeyList pKey,
    IN BOOL fFinal,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pcbData,
    IN DWORD cbBuf)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    DWORD dwSts;

    // determine which algorithm is to be used
    switch (pKey->Algid)
    {
#ifdef CSP_USE_RC2
    case CALG_RC2:
        dwSts = BlockEncrypt(RC2, pKey, RC2_BLOCKLEN, fFinal, pbData,
                             pcbData, cbBuf);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;
#endif

#ifdef CSP_USE_DES
    case CALG_DES:
        dwSts = BlockEncrypt(des, pKey, DES_BLOCKLEN, fFinal, pbData,
                             pcbData, cbBuf);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;
#endif

#ifdef CSP_USE_3DES
    case CALG_3DES_112:
    case CALG_3DES:
        dwSts = BlockEncrypt(tripledes, pKey, DES_BLOCKLEN, fFinal, pbData,
                             pcbData, cbBuf);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;
#endif

#ifdef CSP_USE_RC4

    case CALG_RC4:
        if (pbData == NULL)
        {
            dwReturn = ERROR_SUCCESS;
            goto ErrorExit;
        }
        if (*pcbData > cbBuf)
        {
            dwReturn = ERROR_MORE_DATA;
            goto ErrorExit;
        }
        rc4((struct RC4_KEYSTRUCT *)pKey->pData, *pcbData, pbData);

        if (fFinal)
        {
            if (pKey->pData)
                _nt_free (pKey->pData, pKey->cbDataLen);
            pKey->pData = 0;
            pKey->cbDataLen = 0;
        }

        break;
#endif

#ifdef CSP_USE_AES
    case CALG_AES_128:
    case CALG_AES_192:
    case CALG_AES_256:
        dwSts = BlockEncrypt(aes, pKey, pKey->dwBlockLen, fFinal, pbData,
                             pcbData, cbBuf);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;
#endif

    default:
        dwReturn = (DWORD)NTE_BAD_ALGID;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*
 -      LocalEncrypt
 -
 *      Purpose:
 *                Encrypt data
 *
 *
 *      Parameters:
 *               IN  hUID          -  Handle to the CSP user
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of plaintext
 *               IN OUT pbData     -  Data to be encrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    encrypted
 *               IN dwBufLen       -  Size of Data buffer
 *               IN fIsExternal    -  Flag to tell if the call is for internal
 *                                    CSP use or external caller
 *
 *      Returns:
 */

DWORD
LocalEncrypt(
    IN HCRYPTPROV hUID,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwBufSize,
    IN BOOL fIsExternal)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    DWORD               dwDataLen;
    PNTAGUserList       pTmpUser;
    PNTAGKeyList        pTmpKey;
    PNTAGKeyList        pTmpKey2;
    PNTAGHashList       pTmpHash;
    DWORD               dwLen;
    MACstate            *pMAC;
    BSAFE_PUB_KEY       *pBsafePubKey;
    BYTE                *pbOutput = NULL;
    DWORD               dwSts;

    if (0 != (dwFlags & ~CRYPT_OAEP))
    //  && (0x9C580000 != dwFlags))
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    dwDataLen = *pdwDataLen;

    if ((Final == FALSE) && (dwDataLen == 0))
    {
        // If no data to encrypt and this isn't the last block,
        // then we're done. (if Final, we need to pad)
        dwReturn = ERROR_SUCCESS;
        goto ErrorExit;
    }

    pTmpUser = (PNTAGUserList)NTLCheckList(hUID, USER_HANDLE);
    if (NULL == pTmpUser)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }


    //
    // Check if encryption allowed
    //

    if (fIsExternal &&
        (PROV_RSA_SCHANNEL != pTmpUser->dwProvType) &&
        ((pTmpUser->Rights & CRYPT_DISABLE_CRYPT) == CRYPT_DISABLE_CRYPT))
    {
        dwReturn = (DWORD)NTE_PERM;
        goto ErrorExit;
    }

    dwSts = NTLValidate(hKey, hUID, KEY_HANDLE, &pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwSts= NTLValidate(hKey, hUID, EXCHPUBKEY_HANDLE, &pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            // NTLValidate doesn't know what error to set
            // so it set NTE_FAIL -- fix it up.
            dwReturn = (NTE_FAIL == dwSts) ? (DWORD)NTE_BAD_KEY : dwSts;
            goto ErrorExit;
        }
    }

    if ((pTmpKey->Algid != CALG_RSA_KEYX) &&
        (!FIsLegalKey(pTmpUser, pTmpKey, FALSE)))
    {
        dwReturn = (DWORD)NTE_BAD_KEY;
        goto ErrorExit;
    }

    if ((Final == FALSE) && (pTmpKey->Algid != CALG_RC4))
    {
        if (dwDataLen < pTmpKey->dwBlockLen)
        {
            *pdwDataLen = pTmpKey->dwBlockLen;
            dwReturn = (DWORD)NTE_BAD_DATA;
            goto ErrorExit;
        }
    }

    if ((POLICY_MS_DEF == pTmpUser->dwCspTypeId)
        && (fDEncrypt && pbData != NULL && *pdwDataLen != 0))
    {
        if (memcmp(dbDEncrypt, pbData, DE_BLOCKLEN) == 0)
        {
            dwReturn = (DWORD)NTE_DOUBLE_ENCRYPT;
            goto ErrorExit;
        }
    }

    // Check if we should do an auto-inflate
    if ((pTmpKey->pData == NULL) && (pTmpKey->Algid != CALG_RSA_KEYX))
    {
        dwSts = InflateKey(pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    if ((hHash != 0) && (NULL != pbData))
    {
        dwSts = NTLValidate(hHash, hUID, HASH_HANDLE, &pTmpHash);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = (NTE_FAIL == dwSts) ? (DWORD)NTE_BAD_HASH : dwSts;
            goto ErrorExit;
        }

        if (pTmpHash->Algid == CALG_MAC)
        {
            // Check if we should do an auto-inflate
            pMAC = pTmpHash->pHashData;
            dwSts = NTLValidate(pTmpHash->hKey, hUID, KEY_HANDLE, &pTmpKey2);
            if (ERROR_SUCCESS != dwSts)
            {
                // NTLValidate doesn't know what error to set
                // so it set NTE_FAIL -- fix it up.
                dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_KEY : dwSts;
                goto ErrorExit;
            }
            if (pTmpKey2->pData == NULL)
            {
                dwSts = InflateKey(pTmpKey2);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }
            }
        }

        if (!CPHashData(hUID, hHash, pbData, *pdwDataLen, 0))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }
    }

    // determine which algorithm is to be used
    switch (pTmpKey->Algid)
    {
    case CALG_RSA_KEYX:
        pBsafePubKey = (BSAFE_PUB_KEY *) pTmpKey->pKeyValue;
        if (pBsafePubKey == NULL)
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        // compute length of resulting data
        dwLen = (pBsafePubKey->bitlen + 7) / 8;
        if (!CheckDataLenForRSAEncrypt(dwLen, *pdwDataLen, dwFlags))
        {
            dwReturn = (DWORD)NTE_BAD_LEN;
            goto ErrorExit;
        }

        if (pbData == NULL || dwBufSize < dwLen)
        {
            *pdwDataLen = dwLen;    // set what we need
            dwReturn = (pbData == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
            goto ErrorExit;
        }

        pbOutput = (BYTE*)_nt_malloc(dwLen);
        if (NULL == pbOutput)
        {
            dwReturn =ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        // perform the RSA encryption
        dwSts = RSAEncrypt(pTmpUser, pBsafePubKey, pbData, *pdwDataLen,
                           pTmpKey->pbParams, pTmpKey->cbParams, dwFlags,
                           pbOutput);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        *pdwDataLen = dwLen;
        memcpy(pbData, pbOutput, *pdwDataLen);

        break;

    default:
        dwSts = SymEncrypt(pTmpKey, Final, pbData, pdwDataLen, dwBufSize);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    if ((POLICY_MS_DEF == pTmpUser->dwCspTypeId)
        && (pbData != NULL && *pdwDataLen >= DE_BLOCKLEN))
    {
        memcpy(dbDEncrypt, pbData, DE_BLOCKLEN);
        fDEncrypt = TRUE;
    }
    else
    {
        fDEncrypt = FALSE;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pbOutput)
        _nt_free(pbOutput, dwLen);
    return dwReturn;
}


/*
 -      CPEncrypt
 -
 *      Purpose:
 *                Encrypt data
 *
 *
 *      Parameters:
 *               IN  hUID          -  Handle to the CSP user
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of plaintext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be encrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    encrypted
 *               IN dwBufLen       -  Size of Data buffer
 *
 *      Returns:
 */

BOOL WINAPI
CPEncrypt(
    IN HCRYPTPROV hUID,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwBufSize)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD   dwSts;
    DWORD   fRet;

    EntryPoint
    dwSts = LocalEncrypt(hUID, hKey, hHash, Final, dwFlags,
                         pbData, pdwDataLen, dwBufSize, TRUE);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (!fRet)
        SetLastError(dwReturn);
    return fRet;
}


/*
 -      SymDecrypt
 -
 *      Purpose:
 *                Decrypt data with symmetric algorithms.  This function is used
 *                by the LocalDecrypt function as well as the UnWrapSymKey (nt_key.c)
 *                function.
 *
 *      Parameters:
 *               IN  pKey          -  Handle to the key
 *               IN  pHash         -  Handle to a hash if needed
 *               IN  fFinal        -  Boolean indicating if this is the final
 *                                    block of plaintext
 *               IN OUT pbData     -  Data to be decrypted
 *               IN OUT pcbData    -  Pointer to the length of the data to be
 *                                    decrypted
 *
 *      Returns:
 */

DWORD
SymDecrypt(
    IN PNTAGKeyList pKey,
    IN PNTAGHashList pHash,
    IN BOOL fFinal,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pcbData)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    MACstate    *pMAC;
    DWORD       dwSts;

    // determine which algorithm is to be used
    switch (pKey->Algid)
    {
#ifdef CSP_USE_RC2

    // the decryption is to be done with the RC2 algorithm
    case CALG_RC2:
        dwSts = BlockDecrypt(RC2, pKey, RC2_BLOCKLEN, fFinal, pbData,
                             pcbData);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        if ((fFinal) && (NULL != pHash) && (pHash->Algid == CALG_MAC) &&
            (pKey->Mode == CRYPT_MODE_CBC))
        {
            pMAC = (MACstate *)pHash->pHashData;
            memcpy(pMAC->Feedback, pKey->FeedBack, RC2_BLOCKLEN);
            pHash->dwHashState |= DATA_IN_HASH;
        }

        break;
#endif

#ifdef CSP_USE_DES

        // the decryption is to be done with DES
    case CALG_DES:
        dwSts = BlockDecrypt(des, pKey, DES_BLOCKLEN, fFinal, pbData,
                             pcbData);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        if ((fFinal) && (NULL != pHash) &&  (pHash->Algid == CALG_MAC) &&
            (pKey->Mode == CRYPT_MODE_CBC))
        {
            pMAC = (MACstate *)pHash->pHashData;
            memcpy(pMAC->Feedback, pKey->FeedBack, DES_BLOCKLEN);
            pHash->dwHashState |= DATA_IN_HASH;
        }
        break;
#endif

#ifdef CSP_USE_3DES

        // the decryption is to be done with the triple DES
    case CALG_3DES_112:
    case CALG_3DES:
        dwSts = BlockDecrypt(tripledes, pKey, DES_BLOCKLEN, fFinal, pbData,
                             pcbData);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        if ((fFinal) && (NULL != pHash) &&  (pHash->Algid == CALG_MAC) &&
            (pKey->Mode == CRYPT_MODE_CBC))
        {
            pMAC = (MACstate *)pHash->pHashData;
            memcpy(pMAC->Feedback, pKey->FeedBack, DES_BLOCKLEN);
            pHash->dwHashState |= DATA_IN_HASH;
        }
        break;
#endif

#ifdef CSP_USE_RC4
    case CALG_RC4:
        rc4((struct RC4_KEYSTRUCT *)pKey->pData, *pcbData, pbData);
        if (fFinal)
        {
            _nt_free (pKey->pData, pKey->cbDataLen);
            pKey->pData = 0;
            pKey->cbDataLen = 0;
        }

        break;
#endif

#ifdef CSP_USE_AES
    case CALG_AES_128:
    case CALG_AES_192:
    case CALG_AES_256:
        dwSts = BlockDecrypt(aes, pKey, pKey->dwBlockLen, fFinal, pbData,
                             pcbData);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        if ((fFinal) && (NULL != pHash) &&  (pHash->Algid == CALG_MAC) &&
            (pKey->Mode == CRYPT_MODE_CBC))
        {
            pMAC = (MACstate *)pHash->pHashData;
            memcpy(pMAC->Feedback, pKey->FeedBack, pKey->dwBlockLen);
            pHash->dwHashState |= DATA_IN_HASH;
        }
        break;
#endif

    default:
        dwReturn = (DWORD)NTE_BAD_ALGID;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*
 -      LocalDecrypt
 -
 *      Purpose:
 *                Decrypt data
 *
 *
 *      Parameters:
 *               IN  hUID          -  Handle to the CSP user
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of ciphertext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be decrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    decrypted
 *               IN fIsExternal    -  Flag to tell if the call is for internal
 *                                    CSP use or external caller
 *
 *      Returns:
 */

DWORD
LocalDecrypt(
    IN HCRYPTPROV hUID,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN BOOL fIsExternal)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGUserList       pTmpUser;
    PNTAGKeyList        pTmpKey;
    PNTAGKeyList        pTmpKey2;
    MACstate            *pMAC;
    PNTAGHashList       pTmpHash = NULL;
    BSAFE_PRV_KEY       *pBsafePrvKey = NULL;
    BYTE                *pbNewData = NULL;
    DWORD               cbNewData;
    DWORD               dwSts;

    if (0 != (dwFlags & ~CRYPT_OAEP))
    // && (0x9C580000 != dwFlags))
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    // We're done if decrypting 0 bytes.
    if (*pdwDataLen == 0)
    {
        dwReturn = (Final == TRUE) ? (DWORD)NTE_BAD_LEN : ERROR_SUCCESS;
        goto ErrorExit;
    }

    pTmpUser = (PNTAGUserList)NTLCheckList(hUID, USER_HANDLE);
    if (NULL == pTmpUser)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    //
    // Check if decryption allowed
    //

    if (fIsExternal &&
        (PROV_RSA_SCHANNEL != pTmpUser->dwProvType) &&
        ((pTmpUser->Rights & CRYPT_DISABLE_CRYPT) == CRYPT_DISABLE_CRYPT))
    {
        dwReturn = (DWORD)NTE_PERM;
        goto ErrorExit;
    }

    // Check the key against the user.
    dwSts = NTLValidate(hKey, hUID, KEY_HANDLE, &pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwSts = NTLValidate(hKey, hUID, EXCHPUBKEY_HANDLE, &pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            // NTLValidate doesn't know what error to set
            // so it set NTE_FAIL -- fix it up.
            dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_KEY : dwSts;
            goto ErrorExit;
        }
    }

    if ((POLICY_MS_DEF == pTmpUser->dwCspTypeId)
        && fDDecrypt)
    {
        if (memcmp(dbDDecrypt, pbData, DE_BLOCKLEN) == 0)
        {
            dwReturn = (DWORD)NTE_DOUBLE_ENCRYPT;
            goto ErrorExit;
        }
    }

    if ((pTmpKey->Algid != CALG_RSA_KEYX) &&
        (!FIsLegalKey(pTmpUser, pTmpKey, TRUE)))
    {
        dwReturn = (DWORD)NTE_BAD_KEY;
        goto ErrorExit;
    }

    // Check if we should do an auto-inflate
    if ((pTmpKey->pData == NULL) && (pTmpKey->Algid != CALG_RSA_KEYX))
    {
        dwSts = InflateKey(pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    // determine which algorithm is to be used
    switch (pTmpKey->Algid)
    {
    case CALG_RSA_KEYX:
        // check if the public key matches the private key
        if (pTmpUser->ContInfo.pbExchPub == NULL)
        {
            dwReturn = (DWORD)NTE_NO_KEY;
            goto ErrorExit;
        }

        if ((pTmpUser->ContInfo.ContLens.cbExchPub != pTmpKey->cbKeyLen) ||
            memcmp(pTmpUser->ContInfo.pbExchPub, pTmpKey->pKeyValue,
                   pTmpUser->ContInfo.ContLens.cbExchPub))
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        // if using protected store then load the key now
        dwSts = UnprotectPrivKey(pTmpUser, g_Strings.pwszImportSimple,
                                 FALSE, FALSE);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;   // NTE_BAD_KEYSET
            goto ErrorExit;
        }
        pBsafePrvKey = (BSAFE_PRV_KEY *)pTmpUser->pExchPrivKey;

        if (NULL == pBsafePrvKey)
        {
            dwReturn = (DWORD)NTE_NO_KEY;
            goto ErrorExit;
        }

        // perform the RSA decryption
        dwSts= RSADecrypt(pTmpUser, pBsafePrvKey, pbData, *pdwDataLen,
                          pTmpKey->pbParams, pTmpKey->cbParams,
                          dwFlags, &pbNewData, &cbNewData);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        *pdwDataLen = cbNewData;
        memcpy(pbData, pbNewData, *pdwDataLen);
        break;

    default:
        dwSts = SymDecrypt(pTmpKey, NULL, Final, pbData, pdwDataLen);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    if (hHash != 0)
    {
        dwSts = NTLValidate(hHash, hUID, HASH_HANDLE, &pTmpHash);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = (NTE_FAIL == dwSts) ? (DWORD)NTE_BAD_HASH : dwSts;
            goto ErrorExit;
        }

        if (pTmpHash->Algid == CALG_MAC)
        {
            // Check if we should do an auto-inflate
            pMAC = pTmpHash->pHashData;
            dwSts = NTLValidate(pTmpHash->hKey, hUID, KEY_HANDLE, &pTmpKey2);
            if (ERROR_SUCCESS != dwSts)
            {
                // NTLValidate doesn't know what error to set
                // so it set NTE_FAIL -- fix it up.
                dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_KEY : dwSts;
                goto ErrorExit;
            }
            if (pTmpKey2->pData == NULL)
            {
                dwSts = InflateKey(pTmpKey2);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }
            }
        }

        if (!CPHashData(hUID, hHash, pbData, *pdwDataLen, 0))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }
    }

    if ((POLICY_MS_DEF == pTmpUser->dwCspTypeId)
        && (*pdwDataLen >= DE_BLOCKLEN))
    {
        memcpy(dbDDecrypt, pbData, DE_BLOCKLEN);
        fDDecrypt = TRUE;
    }
    else
    {
        fDDecrypt = FALSE;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pbNewData)
        _nt_free(pbNewData, cbNewData);
    return dwReturn;
}


/*
 -      CPDecrypt
 -
 *      Purpose:
 *                Decrypt data
 *
 *
 *      Parameters:
 *               IN  hUID          -  Handle to the CSP user
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of ciphertext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be decrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    decrypted
 *
 *      Returns:
 */

BOOL WINAPI
CPDecrypt(
    IN HCRYPTPROV hUID,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BOOL    fRet;
    DWORD   dwSts;

    EntryPoint
    dwSts = LocalDecrypt(hUID, hKey, hHash, Final,
                        dwFlags, pbData, pdwDataLen, TRUE);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (!fRet)
        SetLastError(dwReturn);
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\rsaaes\ntagimp1.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ntagimp1.c                                             //
//  DESCRIPTION   : Contains routines for internal consumption             //
//                                                                         //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//  Jan 25 1995 larrys  Changed from Nametag                               //
//  Mar 23 1995 larrys  Added variable key length                          //
//  Jul  6 1995 larrys  Memory leak fix                                    //
//  Oct 27 1995 rajeshk RandSeed Stuff                                     //
//  Nov  3 1995 larrys  Merge for NT checkin                               //
//  Dec 11 1995 larrys  Added WIN96 password cache                         //
//  Dec 13 1995 larrys  Removed MTS stuff                                  //
//  May 15 1996 larrys  Changed NTE_NO_MEMORY to ERROR_NOT_ENOUGH...       //
//  May  5 2000 dbarlow Repaired error return mechanism                    //
//                                                                         //
//  Copyright (C) 1993 - 2000, Microsoft Corporation                       //
//  All Rights Reserved                                                    //
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
// #include "nt_rsa.h"
// #include "nt_blobs.h"
// #include "winperf.h"

#if 0
/*  Internal functions.  The following hash and sign routines are
    for use ONLY in internal consistency and protocol checks. */

static void *
IntBeginHash(
    void)
{
    MD5_CTX     *IntHash;

    if ((IntHash = (MD5_CTX *) _nt_malloc(sizeof(MD5_CTX))) == NULL)
        return NULL;

    MD5Init(IntHash);
    return(void *)IntHash;
}


static void *
IntUpdateHash(
    void *pHashCtx,
    BYTE *pData,
    DWORD dwDataLen)
{
    MD5Update((MD5_CTX *)pHashCtx, pData, dwDataLen);
    return pHashCtx;
}

static void
IntFinishHash(
    void *pHashCtx,
    BYTE *HashData)
{
    MD5Final((MD5_CTX *)pHashCtx);
    memcpy(HashData, ((MD5_CTX *)pHashCtx)->digest, NT_HASH_BYTES);
    _nt_free(pHashCtx, sizeof(MD5_CTX));
    return;
}
#endif

void
memnuke(
    volatile BYTE *pData,
    DWORD dwLen)
{
    DWORD   i;

    for (i=0; i < dwLen; i++)
    {
        pData[i] = 0x00;
        pData[i] = 0xff;
        pData[i] = 0x00;
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\rsaaes\nt_hash.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : nt_hash.c                                              //
//  DESCRIPTION   : Crypto CP interfaces:                                  //
//                  CPBeginHash                                            //
//                  CPUpdateHash                                           //
//                  CPDestroyHash                                          //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Jan 25 1995 larrys  Changed from Nametag                           //
//      Feb 23 1995 larrys  Changed NTag_SetLastError to SetLastError      //
//      May  8 1995 larrys  Changes for MAC hashing                        //
//      May 10 1995 larrys  added private api calls                        //
//      Jul 13 1995 larrys  Changed MAC stuff                              //
//      Aug 07 1995 larrys  Added Auto-Inflate to CryptBeginHash           //
//      Aug 30 1995 larrys  Removed RETURNASHVALUE from CryptGetHashValue  //
//      Sep 19 1995 larrys  changed USERDATA to CRYPT_USERDATA             //
//      Oct 03 1995 larrys  check for 0 on Createhash for hKey             //
//      Oct 05 1995 larrys  Changed HashSessionKey to hash key material    //
//      Oct 13 1995 larrys  Removed CPGetHashValue                         //
//      Oct 17 1995 larrys  Added MD2                                      //
//      Nov  3 1995 larrys  Merge for NT checkin                           //
//      Nov 14 1995 larrys  Fixed memory leak                              //
//      Mar 01 1996 rajeshk Added check for Hash Values                    //
//      May 15 1996 larrys  Changed NTE_NO_MEMORY to ERROR_NOT_ENOUGHT...  //
//      Jun  6 1996 a-johnb Added support for SSL 3.0 signatures           //
//      Apr 25 1997 jeffspel Fix for Bug 76393, GPF on pbData = NULL       //
//      May 23 1997 jeffspel Added provider type checking                  //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "nt_rsa.h"
#include "tripldes.h"
#include "mac.h"
#include "ssl3.h"
#include "aes.h"

extern BOOL
FIsLegalKey(
    PNTAGUserList pTmpUser,
    PNTAGKeyList pKey,
    BOOL fRC2BigKeyOK);

extern DWORD
InflateKey(
    IN PNTAGKeyList pTmpKey);

extern DWORD
BlockEncrypt(
    void EncFun(BYTE *In, BYTE *Out, void *key, int op),
    PNTAGKeyList pKey,
    int BlockLen,
    BOOL Final,
    BYTE  *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen);

extern DWORD
LocalGetHashVal(
    IN ALG_ID Algid,
    IN DWORD dwHashFlags,
    IN OUT BYTE *pbHashData,
    OUT BYTE *pbHashVal,
    OUT DWORD *pcbHashVal);

#ifdef CSP_USE_MD5
//
// Function : TestMD5
//
// Description : This function hashes the passed in message with the MD5 hash
//               algorithm and returns the resulting hash value.
//

BOOL
TestMD5(
    BYTE *pbMsg,
    DWORD cbMsg,
    BYTE *pbHash)
{
    MD5_CTX MD5;
    BOOL    fRet = FALSE;

    // Check length for input data
    if (0 == cbMsg)
        goto ErrorExit;

    // Initialize MD5
    MD5Init(&MD5);

    // Compute MD5
    MD5Update(&MD5, pbMsg, cbMsg);

    MD5Final(&MD5);
    memcpy(pbHash, MD5.digest, MD5DIGESTLEN);

    fRet = TRUE;

ErrorExit:
    return fRet;
}
#endif // CSP_USE_MD5

#ifdef CSP_USE_SHA1
//
// Function : TestSHA1
//
// Description : This function hashes the passed in message with the SHA1 hash
//               algorithm and returns the resulting hash value.
//

BOOL
TestSHA1(
    BYTE *pbMsg,
    DWORD cbMsg,
    BYTE *pbHash)
{
    A_SHA_CTX   HashContext;
    BOOL        fRet = FALSE;

    // Check length for input data
    if (0 == cbMsg)
        goto ErrorExit;

    // Initialize SHA
    A_SHAInit(&HashContext);

    // Compute SHA
    A_SHAUpdate(&HashContext, pbMsg, cbMsg);

    A_SHAFinal(&HashContext, pbHash);

    fRet = TRUE;

ErrorExit:
    return fRet;
}
#endif // CSP_USE_SHA1

BOOL
ValidHashAlgid(
    PNTAGUserList pTmpUser,
    ALG_ID Algid)
{
    if ((PROV_RSA_SCHANNEL == pTmpUser->dwProvType) &&
        ((CALG_MD2 == Algid) || (CALG_MD4 == Algid)))
        return FALSE;
    else
        return TRUE;
}

// local function for creating hashes
DWORD
LocalCreateHash(
    IN ALG_ID Algid,
    OUT BYTE **ppbHashData,
    OUT DWORD *pcbHashData)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;

    switch (Algid)
    {
#ifdef CSP_USE_MD2
    case CALG_MD2:
    {
        MD2_object *pMD2Hash;

        pMD2Hash = (MD2_object *)_nt_malloc(sizeof(MD2_object));
        if (NULL == pMD2Hash)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        // Set up the Initial MD2 Hash State
        memset ((BYTE *)pMD2Hash, 0, sizeof(MD2_object));
        pMD2Hash->FinishFlag = FALSE;

        *pcbHashData = sizeof(MD2_object);
        *ppbHashData = (LPBYTE)pMD2Hash;
        break;
    }
#endif

#ifdef CSP_USE_MD4
    case CALG_MD4:
    {
        MD4_object *pMD4Hash;

        pMD4Hash = (MD4_object *)_nt_malloc(sizeof(MD4_object));
        if (NULL == pMD4Hash)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        // Set up the Initial MD4 Hash State
        memset ((BYTE *)pMD4Hash, 0, sizeof(MD4_object));
        pMD4Hash->FinishFlag = FALSE;
        MDbegin(&pMD4Hash->MD);

        *pcbHashData = sizeof(MD4_object);
        *ppbHashData = (BYTE*)pMD4Hash;
        break;
    }
#endif

#ifdef CSP_USE_MD5
    case CALG_MD5:
    {
        MD5_object *pMD5Hash;

        pMD5Hash = (MD5_object *)_nt_malloc(sizeof(MD5_object));
        if (NULL == pMD5Hash)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        // Set up the our state
        pMD5Hash->FinishFlag = FALSE;
        MD5Init(pMD5Hash);

        *ppbHashData = (BYTE*)pMD5Hash;
        *pcbHashData = sizeof(MD5_object);
        break;
    }
#endif

#ifdef CSP_USE_SHA
    case CALG_SHA:
    {
        A_SHA_CTX *pSHAHash;

        pSHAHash = (A_SHA_CTX *)_nt_malloc(sizeof(A_SHA_CTX));
        if (NULL == pSHAHash)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        // Set up our state
        A_SHAInit(pSHAHash);
        pSHAHash->FinishFlag = FALSE;

        *ppbHashData = (BYTE*)pSHAHash;
        *pcbHashData = sizeof(A_SHA_CTX);
        break;
    }
#endif

    default:
        dwReturn = (DWORD)NTE_BAD_ALGID;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*
 -  CPBeginHash
 -
 *  Purpose:
 *                initate the hashing of a stream of data
 *
 *
 *  Parameters:
 *               IN  hUID    -  Handle to the user identifcation
 *               IN  Algid   -  Algorithm identifier of the hash algorithm
 *                              to be used
 *               IN  hKey    -  Optional key for MAC algorithms
 *               IN  dwFlags -  Flags values
 *               OUT pHash   -  Handle to hash object
 *
 *  Returns:
 */

BOOL WINAPI
CPCreateHash(
    IN HCRYPTPROV hUID,
    IN ALG_ID Algid,
    IN HCRYPTKEY hKey,
    IN DWORD dwFlags,
    OUT HCRYPTHASH *phHash)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGUserList   pTmpUser;
    PNTAGHashList   pCurrentHash = NULL;
    PNTAGKeyList    pTmpKey;
#ifdef CSP_USE_SSL3
    PSCH_HASH       pSChHash;
#endif // CSP_USE_SSL3
    BOOL            fRet;
    DWORD           dwSts;

    EntryPoint
    if (dwFlags != 0)
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    // check if the user handle is valid
    pTmpUser = NTLCheckList(hUID, USER_HANDLE);
    if (NULL == pTmpUser)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    if (!ValidHashAlgid(pTmpUser, Algid))
    {
        dwReturn = (DWORD)NTE_BAD_ALGID;
        goto ErrorExit;
    }

    // Prepare the structure to be used as the hash handle
    pCurrentHash = (PNTAGHashList)_nt_malloc(sizeof(NTAGHashList));
    if (NULL == pCurrentHash)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    memset(pCurrentHash, 0, sizeof(NTAGHashList));
    pCurrentHash->Algid = Algid;
    pCurrentHash->hUID = hUID;

    // determine which hash algorithm is to be used
    switch (Algid)
    {
#ifdef CSP_USE_MAC
    case CALG_MAC:
    {
        MACstate *pMACVal;

        if (hKey == 0)
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        dwSts = NTLValidate(hKey, hUID, KEY_HANDLE, &pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_KEY : dwSts;
            goto ErrorExit;
        }

        if (pTmpKey->Mode != CRYPT_MODE_CBC)
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        // Check if we should do an auto-inflate
        if (pTmpKey->pData == NULL)
        {
            dwSts = InflateKey(pTmpKey);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }

        pMACVal = (MACstate *)_nt_malloc(sizeof(MACstate));
        if (NULL == pMACVal)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        pCurrentHash->pHashData = pMACVal;
        pCurrentHash->dwDataLen = sizeof(MACstate);
        pCurrentHash->hKey = hKey;
        pMACVal->dwBufLen = 0;
        pMACVal->FinishFlag = FALSE;
        break;
    }
#endif

    case CALG_HMAC:
    {
        if (hKey == 0)
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        dwSts = NTLValidate(hKey, hUID, KEY_HANDLE, &pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = (NTE_FAIL == dwSts) ? (DWORD)NTE_BAD_KEY : dwSts;
            goto ErrorExit;
        }

        pCurrentHash->hKey = hKey;
        break;
    }

#ifdef CSP_USE_SSL3SHAMD5
    case CALG_SSL3_SHAMD5:
    {
        pCurrentHash->pHashData = _nt_malloc(SSL3_SHAMD5_LEN);
        if (NULL == pCurrentHash->pHashData)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        pCurrentHash->dwDataLen = SSL3_SHAMD5_LEN;
        break;
    }
#endif

#ifdef CSP_USE_SSL3
    case CALG_SCHANNEL_MASTER_HASH:
    {
        if (0 == hKey)
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        dwSts = NTLValidate(hKey, hUID, KEY_HANDLE, &pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_KEY : dwSts;
            goto ErrorExit;
        }

        if ((CALG_SSL3_MASTER != pTmpKey->Algid) &&
            (CALG_PCT1_MASTER != pTmpKey->Algid) &&
            (pTmpKey->cbKeyLen > MAX_PREMASTER_LEN))
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        pCurrentHash->dwDataLen = sizeof(SCH_HASH);
        pCurrentHash->pHashData = (BYTE *)_nt_malloc(pCurrentHash->dwDataLen);
        if (NULL == pCurrentHash->pHashData)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }
        memset(pCurrentHash->pHashData, 0, pCurrentHash->dwDataLen);
        pSChHash = (PSCH_HASH)pCurrentHash->pHashData;
        pSChHash->ProtocolAlgid = pTmpKey->Algid;

        dwSts = SChGenMasterKey(pTmpKey, pSChHash);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;
    }

    case CALG_TLS1PRF:
    {
        PRF_HASH    *pPRFHash;
        PSCH_KEY    pSChKey;

        if (0 == hKey)
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        dwSts = NTLValidate(hKey, hUID, KEY_HANDLE, &pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_KEY : dwSts;
            goto ErrorExit;
        }

        if (CALG_TLS1_MASTER != pTmpKey->Algid)
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        // check if the master key is finished
        pSChKey = (PSCH_KEY)pTmpKey->pData;
        if ((!pSChKey->fFinished) || (TLS_MASTER_LEN != pTmpKey->cbKeyLen))
        {
            dwReturn = (DWORD)NTE_BAD_KEY_STATE;
            goto ErrorExit;
        }

        pCurrentHash->dwDataLen = sizeof(PRF_HASH);
        pCurrentHash->pHashData = (BYTE *)_nt_malloc(pCurrentHash->dwDataLen);
        if (NULL == pCurrentHash->pHashData)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }
        memset(pCurrentHash->pHashData, 0, pCurrentHash->dwDataLen);
        pPRFHash = (PRF_HASH*)pCurrentHash->pHashData;
        memcpy(pPRFHash->rgbMasterKey, pTmpKey->pKeyValue, TLS_MASTER_LEN);
        break;
    }
#endif // CSP_USE_SSL3

    default:
        if (hKey != 0)
        {
            dwReturn = NTE_BAD_KEY;
            goto ErrorExit;
        }

        dwSts = LocalCreateHash(Algid, (BYTE**)&pCurrentHash->pHashData,
                                &pCurrentHash->dwDataLen);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    dwSts = NTLMakeItem(phHash, HASH_HANDLE, pCurrentHash);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (!fRet)
    {
        if (NULL != pCurrentHash)
        {
            if (pCurrentHash->pHashData)
                _nt_free(pCurrentHash->pHashData, pCurrentHash->dwDataLen);
            _nt_free(pCurrentHash, sizeof(NTAGHashList));
        }
        SetLastError(dwReturn);
    }
    return fRet;
}

DWORD
LocalHashData(
    IN ALG_ID Algid,
    IN OUT BYTE *pbHashData,
    IN BYTE *pbData,
    IN DWORD cbData)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BYTE    *ptmp;
    DWORD   BytePos;

    switch (Algid)
    {
#ifdef CSP_USE_MD2
    case CALG_MD2:
    {
        MD2_object *pMD2Hash;

        // make sure the hash is updatable
        pMD2Hash = (MD2_object *)pbHashData;
        if (pMD2Hash->FinishFlag)
        {
            dwReturn = (DWORD)NTE_BAD_HASH_STATE;
            goto ErrorExit;
        }

        if (0 != MD2Update(&pMD2Hash->MD, pbData, cbData))
        {
            // This is a reasonable return code, since currently
            // the only value MD2Update returns is zero.
            dwReturn = (DWORD)NTE_FAIL;
            goto ErrorExit;
        }

        break;
    }
#endif

#ifdef CSP_USE_MD4
    case CALG_MD4:
    {
        MD4_object *pMD4Hash;
        int nSts;

        pMD4Hash = (MD4_object *)pbHashData;

        // make sure the hash is updatable
        if (pMD4Hash->FinishFlag)
        {
            dwReturn = (DWORD)NTE_BAD_HASH_STATE;
            goto ErrorExit;
        }

        // MD4 hashes when the size == MD4BLOCKSIZE and finishes the
        // hash when the given size is < MD4BLOCKSIZE.
        // So, ensure that the user always gives a full block here --
        // when NTagFinishHash is called, we'll send the last bit and
        // that'll finish off the hash.

        ptmp = (BYTE *)pbData;
        for (;;)
        {
            // check if there's plenty of room in the buffer
            if (cbData < (MD4BLOCKSIZE - pMD4Hash->BufLen))
            {
                // just append to whatever's already
                memcpy(pMD4Hash->Buf + pMD4Hash->BufLen, ptmp, cbData);

                // set of the trailing buffer length field
                pMD4Hash->BufLen += (BYTE)cbData;
                break;
            }

            // determine what we need to fill the buffer, then do it.
            BytePos = MD4BLOCKSIZE - pMD4Hash->BufLen;
            ASSERT(BytePos <= dwTmpLen);
            memcpy(pMD4Hash->Buf + pMD4Hash->BufLen, ptmp, BytePos);

            // The buffer is now full, process it.
            nSts = MDupdate(&pMD4Hash->MD, pMD4Hash->Buf,
                            MD4BYTESTOBITS(MD4BLOCKSIZE));
            if (MD4_SUCCESS != nSts)
            {
                dwReturn = (DWORD)NTE_FAIL;
                goto ErrorExit;
            }

            // now it's empty.
            pMD4Hash->BufLen = 0;

            // we processed some bytes, so reflect that and try again
            cbData -= BytePos;
            ptmp += BytePos;

            if (cbData == 0)
                break;
        }
        break;
    }
#endif

#ifdef CSP_USE_MD5
    case CALG_MD5:
    {
        MD5_object *pMD5Hash;

        // make sure the hash is updatable
        pMD5Hash = (MD5_object *)pbHashData;
        if (pMD5Hash->FinishFlag)
        {
            dwReturn = (DWORD)NTE_BAD_HASH_STATE;
            goto ErrorExit;
        }

        MD5Update(pMD5Hash, pbData, cbData);
        break;
    }
#endif

#ifdef CSP_USE_SHA
    case CALG_SHA:
    {
        A_SHA_CTX *pSHAHash;

        // make sure the hash is updatable
        pSHAHash = (A_SHA_CTX *)pbHashData;
        if (pSHAHash->FinishFlag)
        {
            dwReturn = (DWORD) NTE_BAD_HASH_STATE;
            goto ErrorExit;
        }

        A_SHAUpdate(pSHAHash, pbData, cbData);
        break;
    }
#endif

    default:
        dwReturn = (DWORD)NTE_BAD_ALGID;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}

/*static*/ DWORD
LocalMACData(
    IN HCRYPTPROV hUID,
    IN PNTAGHashList pTmpHash,
    IN CONST BYTE *pbData,
    IN DWORD cbData)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    MACstate        *pMAC;
    PNTAGKeyList    pTmpKey;
    BYTE            *pbTmp;
    DWORD           dwTmpLen;
    BYTE            *pb = NULL;
    DWORD           cb;
    DWORD           i;
    BYTE            *pbJunk = NULL;
    DWORD           dwBufSlop;
    DWORD           dwEncLen;
    DWORD           dwSts;
    PBYTE           pbKeyHash = NULL;
    DWORD           cbKeyHash = 0;
    
    dwTmpLen = cbData;
    pbTmp = (BYTE *) pbData;

    switch (pTmpHash->Algid)
    {
#ifdef CSP_USE_MAC
    case CALG_MAC:
    {
        pMAC = (MACstate *)pTmpHash->pHashData;

        // make sure the hash is updatable
        if (pMAC->FinishFlag)
        {
            dwReturn = (DWORD)NTE_BAD_HASH_STATE;
            goto ErrorExit;
        }

        dwSts = NTLValidate(pTmpHash->hKey, hUID, KEY_HANDLE, &pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_KEY : dwSts;
            goto ErrorExit;
        }

        if (pMAC->dwBufLen + dwTmpLen <= pTmpKey->dwBlockLen)
        {
            memcpy(pMAC->Buffer + pMAC->dwBufLen, pbTmp, dwTmpLen);
            pMAC->dwBufLen += dwTmpLen;
            dwReturn = ERROR_SUCCESS;
            goto ErrorExit;
        }

        memcpy(pMAC->Buffer+pMAC->dwBufLen, pbTmp,
               (pTmpKey->dwBlockLen - pMAC->dwBufLen));

        dwTmpLen -= (pTmpKey->dwBlockLen - pMAC->dwBufLen);
        pbTmp += (pTmpKey->dwBlockLen - pMAC->dwBufLen);

        pMAC->dwBufLen = pTmpKey->dwBlockLen;

        switch (pTmpKey->Algid)
        {
        case CALG_RC2:
            dwSts = BlockEncrypt(RC2, pTmpKey, RC2_BLOCKLEN, FALSE,
                                 pMAC->Buffer,  &pMAC->dwBufLen,
                                 MAX_BLOCKLEN);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
            break;

        case CALG_DES:
            dwSts = BlockEncrypt(des, pTmpKey, DES_BLOCKLEN, FALSE,
                                 pMAC->Buffer,  &pMAC->dwBufLen,
                                 MAX_BLOCKLEN);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
            break;

#ifdef CSP_USE_3DES
        case CALG_3DES_112:
        case CALG_3DES:
            dwSts = BlockEncrypt(tripledes, pTmpKey, DES_BLOCKLEN,
                                 FALSE, pMAC->Buffer, &pMAC->dwBufLen,
                                 MAX_BLOCKLEN);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
            break;
#endif
#ifdef CSP_USE_AES
        case CALG_AES_128:
        case CALG_AES_192:
        case CALG_AES_256:
            dwSts = BlockEncrypt(aes, pTmpKey, pTmpKey->dwBlockLen,
                                 FALSE, pMAC->Buffer, &pMAC->dwBufLen,
                                 MAX_BLOCKLEN);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
            break;
#endif
        }

        pMAC->dwBufLen = 0;

        dwBufSlop = dwTmpLen % pTmpKey->dwBlockLen;
        if (dwBufSlop == 0)
        {
            dwBufSlop = pTmpKey->dwBlockLen;
        }

        pbJunk = _nt_malloc(dwTmpLen);
        if (NULL == pbJunk)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        memcpy(pbJunk, pbTmp, dwTmpLen - dwBufSlop);
        dwEncLen = dwTmpLen - dwBufSlop;

        switch (pTmpKey->Algid)
        {
        case CALG_RC2:
            dwSts = BlockEncrypt(RC2, pTmpKey, RC2_BLOCKLEN, FALSE,
                                 pbJunk,  &dwEncLen, dwTmpLen);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
            break;

        case CALG_DES:
            dwSts = BlockEncrypt(des, pTmpKey, DES_BLOCKLEN, FALSE,
                                 pbJunk,  &dwEncLen, dwTmpLen);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
            break;

#ifdef CSP_USE_3DES
        case CALG_3DES_112:
        case CALG_3DES:
            dwSts = BlockEncrypt(tripledes, pTmpKey, DES_BLOCKLEN,
                                 FALSE, pbJunk,  &dwEncLen, dwTmpLen);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
            break;
#endif

#ifdef CSP_USE_AES
        case CALG_AES_128:
        case CALG_AES_192:
        case CALG_AES_256:
            dwSts = BlockEncrypt(aes, pTmpKey, pTmpKey->dwBlockLen,
                                 FALSE, pbJunk,  &dwEncLen, dwTmpLen);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
            break;
#endif
        }

        memcpy(pMAC->Buffer, pbTmp + dwEncLen, dwBufSlop);
        pMAC->dwBufLen = dwBufSlop;
        break;
    }
#endif

    case CALG_HMAC:
    {
        if (!(pTmpHash->HMACState & HMAC_STARTED))
        {
            dwSts = NTLValidate(pTmpHash->hKey, hUID,
                                KEY_HANDLE, &pTmpKey);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_KEY : dwSts;
                goto ErrorExit;
            }

            // If key is longer than block length, hash the key 
            // data first
            if (pTmpKey->cbKeyLen > HMAC_DEFAULT_STRING_LEN)
            {
                dwSts = LocalCreateHash(pTmpHash->HMACAlgid, &pbKeyHash, &cbKeyHash);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }

                dwSts = LocalHashData(pTmpHash->HMACAlgid, pbKeyHash, pTmpKey->pKeyValue, 
                                      pTmpKey->cbKeyLen);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }
                
                pb = (BYTE *)_nt_malloc(HMAC_DEFAULT_STRING_LEN);
                if (NULL == pb)
                {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorExit;
                }

                cb = HMAC_DEFAULT_STRING_LEN;
                dwSts = LocalGetHashVal(pTmpHash->HMACAlgid, 0, pbKeyHash, pb, &cb);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }

                for (i = 0; i < HMAC_DEFAULT_STRING_LEN; i++)
                    pb[i] ^= (pTmpHash->pbHMACInner)[i];

                cb = HMAC_DEFAULT_STRING_LEN;
            }
            else
            {         
                if (pTmpKey->cbKeyLen < pTmpHash->cbHMACInner)
                    cb = pTmpHash->cbHMACInner;
                else
                    cb = pTmpKey->cbKeyLen;
    
                pb = (BYTE *)_nt_malloc(cb);
                if (NULL == pb)
                {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorExit;
                }
                memcpy(pb, pTmpHash->pbHMACInner, pTmpHash->cbHMACInner);
    
                // currently no support for byte reversed keys with HMAC
                for (i=0;i<pTmpKey->cbKeyLen;i++)
                    pb[i] ^= (pTmpKey->pKeyValue)[i];
            }

            dwSts = LocalHashData(pTmpHash->HMACAlgid, pTmpHash->pHashData,
                                  pb, cb);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            pTmpHash->HMACState |= HMAC_STARTED;
            memnuke(pb, cb);
            memnuke(pbKeyHash, cbKeyHash);
        }

        dwSts = LocalHashData(pTmpHash->HMACAlgid, pTmpHash->pHashData,
                              (BYTE*)pbData, cbData);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        break;
    }

    default:
        dwReturn = (DWORD)NTE_BAD_ALGID;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pbJunk)
        _nt_free(pbJunk, dwTmpLen);
    if (pb)
        _nt_free(pb, cb);
    if (pbKeyHash)
        _nt_free(pbKeyHash, cbKeyHash);
    return dwReturn;
}


/*
 -  CPHashData
 -
 *  Purpose:
 *                Compute the cryptograghic hash on a stream of data
 *
 *
 *  Parameters:
 *               IN  hUID      -  Handle to the user identifcation
 *               IN  hHash     -  Handle to hash object
 *               IN  pbData    -  Pointer to data to be hashed
 *               IN  dwDataLen -  Length of the data to be hashed
 *               IN  dwFlags   -  Flags values
 *
 *  Returns:
 */

BOOL WINAPI
CPHashData(
    IN HCRYPTPROV hUID,
    IN HCRYPTHASH hHash,
    IN CONST BYTE *pbData,
    IN DWORD dwDataLen,
    IN DWORD dwFlags)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGHashList   pTmpHash;
    PNTAGUserList   pUser;
    BOOL            fRet;
    DWORD           dwSts;

    EntryPoint
    if (0 != (dwFlags & ~(CRYPT_USERDATA)))
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    pUser = (PNTAGUserList)NTLCheckList(hUID, USER_HANDLE);
    if (NULL == pUser)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    if (0 == dwDataLen)
    {
        dwReturn = ERROR_SUCCESS;
        goto ErrorExit;
    }

    if (NULL == pbData)
    {
        dwReturn = (DWORD)NTE_BAD_DATA;
        goto ErrorExit;
    }

    dwSts = NTLValidate(hHash, hUID, HASH_HANDLE, &pTmpHash);
    if (ERROR_SUCCESS != dwSts)
    {
        // NTLValidate doesn't know what error to set
        // so it set NTE_FAIL -- fix it up.
        dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_HASH : dwSts;
        goto ErrorExit;
    }

    if (pTmpHash->HashFlags & HF_VALUE_SET)
    {
        dwReturn = (DWORD)NTE_BAD_HASH_STATE;
        goto ErrorExit;
    }

    switch (pTmpHash->Algid)
    {
#ifdef CSP_USE_MAC
    case CALG_MAC:
#endif // CSP_USE_MAC
    case CALG_HMAC:
        dwSts = LocalMACData(hUID, pTmpHash, pbData, dwDataLen);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;

    default:
        dwSts = LocalHashData(pTmpHash->Algid, pTmpHash->pHashData,
                              (BYTE*)pbData, dwDataLen);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    pTmpHash->dwHashState |= DATA_IN_HASH;

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (!fRet)
        SetLastError(dwReturn);
    return fRet;
}

/*static*/ DWORD
SetupKeyToBeHashed(
    PNTAGKeyList pKey,
    BYTE **ppbData,
    DWORD *pcbData,
    DWORD dwFlags)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD   cb;
    DWORD   i;

    *ppbData = NULL;
    cb = pKey->cbKeyLen;

    *ppbData = (BYTE *)_nt_malloc(cb);
    if (NULL == *ppbData)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    if (CRYPT_LITTLE_ENDIAN & dwFlags)
    {
        memcpy(*ppbData, pKey->pKeyValue, cb);
    }
    else
    {
        // Reverse the session key bytes
        for (i = 0; i < cb; i++)
            (*ppbData)[i] = (pKey->pKeyValue)[cb - i - 1];
    }

    *pcbData = cb;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*
 -      CPHashSessionKey
 -
 *      Purpose:
 *                Compute the cryptograghic hash on a key object.
 *
 *
 *      Parameters:
 *               IN  hUID      -  Handle to the user identifcation
 *               IN  hHash     -  Handle to hash object
 *               IN  hKey      -  Handle to a key object
 *               IN  dwFlags   -  Flags values
 *
 *      Returns:
 *               CRYPT_FAILED
 *               CRYPT_SUCCEED
 */

BOOL WINAPI
CPHashSessionKey(
    IN HCRYPTPROV hUID,
    IN HCRYPTHASH hHash,
    IN HCRYPTKEY hKey,
    IN DWORD dwFlags)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGHashList   pTmpHash;
    PNTAGKeyList    pTmpKey;
    PNTAGUserList   pTmpUser;
    DWORD           dwDataLen;
    BYTE            *pbData = NULL;
    DWORD           BytePos;
#ifdef CSP_USE_SSL3
    PSCH_KEY        pSChKey;
#endif // CSP_USE_SSL3
    BOOL                fRet;
    DWORD               dwSts;

    EntryPoint
    if (dwFlags & ~(CRYPT_LITTLE_ENDIAN))
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    // check the user identification
    pTmpUser = (PNTAGUserList)NTLCheckList(hUID, USER_HANDLE);
    if (NULL == pTmpUser)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    dwSts = NTLValidate(hHash, hUID, HASH_HANDLE, &pTmpHash);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_HASH : dwSts;
        goto ErrorExit;
    }

    if (pTmpHash->HashFlags & HF_VALUE_SET)
    {
        dwReturn = (DWORD)NTE_BAD_HASH_STATE;
        goto ErrorExit;
    }

    dwSts = NTLValidate((HNTAG)hKey, hUID, KEY_HANDLE, &pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_KEY : dwSts;
        goto ErrorExit;
    }

    if (!FIsLegalKey(pTmpUser, pTmpKey, FALSE))
    {
        dwReturn = (DWORD)NTE_BAD_KEY;
        goto ErrorExit;
    }

#ifdef CSP_USE_SSL3
    if ((CALG_SSL3_MASTER == pTmpKey->Algid) ||
        (CALG_TLS1_MASTER == pTmpKey->Algid) ||
        (CALG_PCT1_MASTER == pTmpKey->Algid))
    {
        if (NULL == pTmpKey->pData)
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }
        pSChKey = (PSCH_KEY)pTmpKey->pData;
        if (!pSChKey->fFinished)
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }
    }
#endif // CSP_USE_SSL3

#if 0
    // Check if we should do an auto-inflate
    if (pTmpKey->pData == NULL)
    {
        if (NTAG_FAILED(CPInflateKey(pTmpKey)))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }
    }
#endif

    if ((CALG_DES == pTmpKey->Algid)
        || (CALG_3DES == pTmpKey->Algid)
        || (CALG_3DES_112 == pTmpKey->Algid))
    {
        if (PROV_RSA_SCHANNEL != pTmpUser->dwProvType)
        {
            if ((POLICY_MS_STRONG == pTmpUser->dwCspTypeId) ||
                (!(pTmpUser->Rights & CRYPT_DES_HASHKEY_BACKWARDS)))
            {
                desparityonkey(pTmpKey->pKeyValue, pTmpKey->cbKeyLen);
            }
        }
    }

    dwSts = SetupKeyToBeHashed(pTmpKey, &pbData,
                               &dwDataLen, dwFlags);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    switch (pTmpHash->Algid)
    {
#ifdef CSP_USE_MD2
    case CALG_MD2:
    {
        MD2_object *pMD2Hash;

        pMD2Hash = (MD2_object *)pTmpHash->pHashData;

        // make sure the hash is updatable
        if (pMD2Hash->FinishFlag)
        {
            dwReturn = (DWORD)NTE_BAD_HASH_STATE;
            goto ErrorExit;
        }

        if (0 != MD2Update(&pMD2Hash->MD, pbData, dwDataLen))
        {
            // This is reasonable, since MD2Update only returns zero.
            dwReturn = (DWORD)NTE_FAIL;
            goto ErrorExit;
        }
        break;
    }
#endif

#ifdef CSP_USE_MD4
    case CALG_MD4:
    {
        MD4_object *pMD4Hash;
        int nSts;

        pMD4Hash = (MD4_object *)pTmpHash->pHashData;

        // make sure the hash is updatable
        if (pMD4Hash->FinishFlag)
        {
            dwReturn = (DWORD)NTE_BAD_HASH_STATE;
            goto ErrorExit;
        }

        for (;;)
        {
            // check if there's plenty of room in the buffer
            if ((pMD4Hash->BufLen + dwDataLen) < MD4BLOCKSIZE)
            {
                // just append to whatever's already
                memcpy(pMD4Hash->Buf + pMD4Hash->BufLen, pbData, dwDataLen);

                // set of the trailing buffer length field
                pMD4Hash->BufLen += (BYTE)dwDataLen;
                break;
            }

            // determine what we need to fill the buffer, then do it.
            BytePos = MD4BLOCKSIZE - pMD4Hash->BufLen;
            memcpy(pMD4Hash->Buf + pMD4Hash->BufLen, pbData, BytePos);

            // The buffer is now full, process it.
            nSts = MDupdate(&pMD4Hash->MD, pMD4Hash->Buf,
                            MD4BYTESTOBITS(MD4BLOCKSIZE));
            if (MD4_SUCCESS != nSts)
            {
                dwReturn = (DWORD)NTE_FAIL;
                goto ErrorExit;
            }

            // now it's empty.
            pMD4Hash->BufLen = 0;

            // we processed some bytes, so reflect that and try again
            dwDataLen -= BytePos;
            if (dwDataLen == 0)
                break;
        }
        break;
    }
#endif

#ifdef CSP_USE_MD5
    case CALG_MD5:
    {
        MD5_object *pMD5Hash;

        pMD5Hash = (MD5_object *)pTmpHash->pHashData;

        // make sure the hash is updatable
        if (pMD5Hash->FinishFlag)
        {
            dwReturn = (DWORD)NTE_BAD_HASH_STATE;
            goto ErrorExit;
        }

        MD5Update(pMD5Hash, pbData, dwDataLen);
        break;
    }
#endif

#ifdef CSP_USE_SHA
    case CALG_SHA:
    {
        A_SHA_CTX *pSHAHash;

        pSHAHash = (A_SHA_CTX *)pTmpHash->pHashData;

        // make sure the hash is updatable
        if (pSHAHash->FinishFlag)
        {
            dwReturn = (DWORD)NTE_BAD_HASH_STATE;
            goto ErrorExit;
        }

        A_SHAUpdate(pSHAHash, (BYTE *)pbData, dwDataLen);
        break;
    }
#endif

#ifdef CSP_USE_MAC
    case CALG_MAC:
#endif // CSP_USE_MAC
    case CALG_HMAC:
        dwSts = LocalMACData(hUID, pTmpHash, pbData, dwDataLen);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;

    default:
        dwReturn = (DWORD)NTE_BAD_ALGID;
        goto ErrorExit;
    }

    pTmpHash->dwHashState |= DATA_IN_HASH;

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (pbData)
        _nt_free(pbData, dwDataLen);
    if (!fRet)
        SetLastError(dwReturn);
    return fRet;
}


/*static*/ void
FreeHash(
    IN PNTAGHashList pHash)
{
    if (pHash)
    {
        if (pHash->pHashData)
            _nt_free(pHash->pHashData, pHash->dwDataLen);
        if (pHash->pbHMACInner)
            _nt_free(pHash->pbHMACInner, pHash->cbHMACInner);
        if (pHash->pbHMACOuter)
            _nt_free(pHash->pbHMACOuter, pHash->cbHMACOuter);
        if (pHash->fTempKey)
            CPDestroyKey(pHash->hUID, pHash->hKey);
        _nt_free(pHash, sizeof(NTAGHashList));
    }
}


/*
-   CPDestroyHash
-
*   Purpose:
*                Destory the hash object
*
*
*   Parameters:
*               IN  hUID      -  Handle to the user identifcation
*               IN  hHash     -  Handle to hash object
*
*   Returns:
*/

BOOL WINAPI
CPDestroyHash(
    IN HCRYPTPROV hUID,
    IN HCRYPTHASH hHash)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGHashList   pTmpHash;
    BOOL            fRet;
    DWORD           dwSts;

    EntryPoint
    // check the user identification
    if (NULL == NTLCheckList(hUID, USER_HANDLE))
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    dwSts = NTLValidate(hHash, hUID, HASH_HANDLE, &pTmpHash);
    if (ERROR_SUCCESS != dwSts)
    {
        // NTLValidate doesn't know what error to set
        // so it set NTE_FAIL -- fix it up.
        dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_HASH : dwSts;
        goto ErrorExit;
    }

    switch (pTmpHash->Algid)
    {
#ifdef CSP_USE_MD2
    case CALG_MD2:
#endif
#ifdef CSP_USE_MD4
    case CALG_MD4:
#endif
#ifdef CSP_USE_MD5
    case CALG_MD5:
#endif
#ifdef CSP_USE_SHA
    case CALG_SHA:
#endif
#ifdef CSP_USE_SSL3SHAMD5
    case CALG_SSL3_SHAMD5:
#endif
#ifdef CSP_USE_MAC
    case CALG_MAC:
    case CALG_HMAC:
#endif
#ifdef CSP_USE_SSL3
    case CALG_SCHANNEL_MASTER_HASH:
    case CALG_TLS1PRF:
#endif
        if (CALG_SCHANNEL_MASTER_HASH == pTmpHash->Algid)
        {
            FreeSChHash((PSCH_HASH)pTmpHash->pHashData);
        }
        memnuke(pTmpHash->pHashData, pTmpHash->dwDataLen);
        break;

    default:
        dwReturn = (DWORD)NTE_BAD_ALGID;
        goto ErrorExit;
    }

    // Remove from internal list first so others can't get to it, then free.
    NTLDelete(hHash);
    FreeHash(pTmpHash);

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (!fRet)
        SetLastError(dwReturn);
    return fRet;
}

/*static*/ DWORD
CopyHash(
    IN PNTAGHashList pOldHash,
    OUT PNTAGHashList *ppNewHash)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGHashList   pNewHash;
    BOOL            fSts;

    pNewHash = (PNTAGHashList)_nt_malloc(sizeof(NTAGHashList));
    if (NULL == pNewHash)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    memcpy(pNewHash, pOldHash, sizeof(NTAGHashList));
    pNewHash->fTempKey = FALSE;
    pNewHash->hKey = 0;
    pNewHash->dwDataLen = 0;
    pNewHash->pHashData = NULL;
    pNewHash->cbHMACInner = 0;
    pNewHash->pbHMACInner = NULL;
    pNewHash->cbHMACOuter = 0;
    pNewHash->pbHMACOuter = NULL;


    //
    // Duplicate the associated key.
    //

    if (0 != pOldHash->hKey)
    {
        fSts = CPDuplicateKey(pNewHash->hUID, pOldHash->hKey, NULL, 0,
                              &pNewHash->hKey);
        if (!fSts)
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        pNewHash->fTempKey = TRUE;
    }


    //
    // Duplicate the hash data.
    //

    if (0 < pOldHash->dwDataLen)
    {
        pNewHash->pHashData = (BYTE*)_nt_malloc(pOldHash->dwDataLen);
        if (NULL == pNewHash->pHashData)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        pNewHash->dwDataLen = pOldHash->dwDataLen;
        memcpy(pNewHash->pHashData, pOldHash->pHashData, pOldHash->dwDataLen);
    }


    //
    // Duplicate HMAC Inner.
    //

    if (0 < pOldHash->cbHMACInner)
    {
        pNewHash->pbHMACInner = (LPBYTE)_nt_malloc(pOldHash->cbHMACInner);
        if (NULL == pNewHash->pbHMACInner)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        pNewHash->cbHMACInner = pOldHash->cbHMACInner;
        memcpy(pNewHash->pbHMACInner, pOldHash->pbHMACInner, pOldHash->cbHMACInner);
    }


    //
    // Duplicate HMAC Outer.
    //

    if (0 < pOldHash->cbHMACOuter)
    {
        pNewHash->pbHMACOuter = (LPBYTE)_nt_malloc(pOldHash->cbHMACOuter);
        if (NULL == pNewHash->pbHMACOuter)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        pNewHash->cbHMACOuter = pOldHash->cbHMACOuter;
        memcpy(pNewHash->pbHMACOuter, pOldHash->pbHMACOuter, pOldHash->cbHMACOuter);
    }


    //
    // Return to the caller.
    //

    *ppNewHash = pNewHash;
    return ERROR_SUCCESS;

ErrorExit:
    FreeHash(pNewHash);
    return dwReturn;
}


/*
 -  CPDuplicateHash
 -
 *  Purpose:
 *                Duplicates the state of a hash and returns a handle to it
 *
 *  Parameters:
 *               IN      hUID           -  Handle to a CSP
 *               IN      hHash          -  Handle to a hash
 *               IN      pdwReserved    -  Reserved
 *               IN      dwFlags        -  Flags
 *               IN      phHash         -  Handle to the new hash
 *
 *  Returns:
 */

BOOL WINAPI
CPDuplicateHash(
    IN HCRYPTPROV hUID,
    IN HCRYPTHASH hHash,
    IN DWORD *pdwReserved,
    IN DWORD dwFlags,
    IN HCRYPTHASH *phHash)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGHashList   pTmpHash;
    PNTAGHashList   pNewHash = NULL;
    BOOL            fRet;
    DWORD           dwSts;

    EntryPoint
    if (NULL != pdwReserved)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    if (0 != dwFlags)
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    dwSts = NTLValidate((HNTAG)hHash, hUID, HASH_HANDLE, &pTmpHash);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = (NTE_FAIL == dwSts) ? (DWORD)NTE_BAD_HASH : dwSts;
        goto ErrorExit;
    }

    dwSts = CopyHash(pTmpHash, &pNewHash);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwSts = NTLMakeItem(phHash, HASH_HANDLE, (void *)pNewHash);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (!fRet)
    {
        FreeHash(pNewHash);
        SetLastError(dwReturn);
    }
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\rsaaes\nt_key.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : nt_key.c                                               //
//  DESCRIPTION   : Crypto CP interfaces:                                  //
//                  CPGenKey                                               //
//                  CPDeriveKey                                            //
//                  CPExportKey                                            //
//                  CPImportKey                                            //
//                  CPDestroyKey                                           //
//                  CPGetUserKey                                           //
//                  CPSetKeyParam                                          //
//                  CPGetKeyParam                                          //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//  Jan 25 1995 larrys  Changed from Nametag                               //
//  Feb 16 1995 larrys  Fix problem for 944 build                          //
//  Feb 21 1995 larrys  Added SPECIAL_KEY                                  //
//  Feb 23 1995 larrys  Changed NTag_SetLastError to SetLastError          //
//  Mar 08 1995 larrys  Fixed a few problems                               //
//  Mar 23 1995 larrys  Added variable key length                          //
//  Apr  7 1995 larrys  Removed CryptConfigure                             //
//  Apr 17 1995 larrys  Added 1024 key gen                                 //
//  Apr 19 1995 larrys  Changed CRYPT_EXCH_PUB to AT_KEYEXCHANGE           //
//  May 10 1995 larrys  added private api calls                            //
//  May 17 1995 larrys  added key data for DES test                        //
//  Jul 20 1995 larrys  Changed export of PUBLICKEYBLOB                    //
//  Jul 21 1995 larrys  Fixed Export of AUTHENTICATEDBLOB                  //
//  Aug 03 1995 larrys  Allow CryptG(S)etKeyParam for Public keys &        //
//                      Removed CPTranslate                                //
//  Aug 10 1995 larrys  Fixed a few problems in CryptGetKeyParam           //
//  Aug 11 1995 larrys  Return no key for CryptGetUserKey                  //
//  Aug 14 1995 larrys  Removed key exchange stuff                         //
//  Aug 17 1995 larrys  Removed a error                                    //
//  Aug 18 1995 larrys  Changed NTE_BAD_LEN to ERROR_MORE_DATA             //
//  Aug 30 1995 larrys  Removed RETURNASHVALUE from CryptGetHashValue      //
//  Aug 31 1995 larrys  Fixed CryptExportKey if pbData == NULL             //
//  Sep 05 1995 larrys  Fixed bug # 30                                     //
//  Sep 05 1995 larrys  Fixed bug # 31                                     //
//  Sep 11 1995 larrys  Fixed bug # 34                                     //
//  Sep 12 1995 larrys  Removed 2 DWORDS from exported keys                //
//  Sep 14 1995 Jeffspel/ramas  Merged STT onto CSP                        //
//  Sep 18 1995 larrys  Changed def KP_PERMISSIONS to 0xffffffff           //
//  Oct 02 1995 larrys  Fixed bug 43 return error for importkey on hPubkey //
//  Oct 03 1995 larrys  Fixed bug 37 call InflateKey from SetKeyParam      //
//  Oct 03 1995 larrys  Fixed bug 36, removed OFB from SetKeyParam         //
//  Oct 03 1995 larrys  Fixed bug 38, check key type in SetKeyParam        //
//  Oct 13 1995 larrys  Added CPG/setProv/HashParam                        //
//  Oct 13 1995 larrys  Added code for CryptSetHashValue                   //
//  Oct 16 1995 larrys  Changes for CryptGetHashParam                      //
//  Oct 23 1995 larrys  Added code for GetProvParam PP_CONTAINER           //
//  Oct 27 1995 rajeshk RandSeed Stuff added hUID to PKCS2Encrypt+ others  //
//  Nov  3 1995 larrys  Merge changes for NT checkin                       //
//  Nov  9 1995 larrys  Bug fix 10686                                      //
//  Nov 30 1995 larrys  Bug fix                                            //
//  Dec 11 1995 larrys  Added WIN96 password cache                         //
//  Feb 29 1996 rajeshk Added Check for SetHashParam for HASHVALUE         //
//  May 15 1996 larrys  Added private key export                           //
//  May 28 1996 larrys  Fix bug 88                                         //
//  Jun  6 1996 a-johnb Added support for SSL 3.0 signatures               //
//  Aug 28 1996 mattt   Changed enum to calculate size from #defined sizes //
//  Sep 13 1996 mattt   Compat w/RSABase 88-bit 0 salt, FIsLegalKey()      //
//  Sep 16 1996 mattt   Added KP_KEYLEN ability                            //
//  Sep 16 1996 jeffspel Added triple DES functionality                    //
//  Oct 14 1996 jeffspel Changed GenRandoms to NewGenRandoms               //
//  Apr 29 1997 jeffspel Key storage ability GetProvParam, PStore support  //
//  Apr 29 1997 jeffspel Added EnumAlgsEx tp GetProvParam                  //
//  May 23 1997 jeffspel Added provider type checking                      //
//  Jul 15 1997 jeffspel Added ability to decrypt with large RC2 keys      //
//  Jul 28 1997 jeffspel Added ability to delete a persisted key           //
//  Sep 09 1997 jeffspel Added PP_KEYSET_TYPE to CPGetProvParam            //
//  Sep 12 1997 jeffspel Added Opaque blob support                         //
//  May  4 2000 dbarlow Error code return cleanup                          //
//                                                                         //
//  Copyright (C) 1993 - 2000 Microsoft Corporation                        //
//  All Rights Reserved                                                    //
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "nt_rsa.h"
#include "nt_blobs.h"
#include "swnt_pk.h"
#include "mac.h"
#include "ntagimp1.h"
#include "tripldes.h"
#include "ntagum.h"
#include "randlib.h"
#ifdef CSP_USE_SSL3
#include "ssl3.h"
#endif
#include "protstor.h"
#include "sgccheck.h"
#include "aes.h"

extern CSP_STRINGS g_Strings;

#ifndef CSP_USE_AES
#define UnsupportedSymKey(pKey) ((CALG_RC4 != pKey->Algid) && \
                                 (CALG_RC2 != pKey->Algid) && \
                                 (CALG_DES != pKey->Algid) && \
                                 (CALG_3DES != pKey->Algid) && \
                                 (CALG_3DES_112 != pKey->Algid))
#else
#define UnsupportedSymKey(pKey) ((CALG_RC4 != pKey->Algid) && \
                                 (CALG_RC2 != pKey->Algid) && \
                                 (CALG_DES != pKey->Algid) && \
                                 (CALG_3DES != pKey->Algid) && \
                                 (CALG_3DES_112 != pKey->Algid) && \
                                 (CALG_AES_128 != pKey->Algid) && \
                                 (CALG_AES_192 != pKey->Algid) && \
                                 (CALG_AES_256 != pKey->Algid))
#endif

#define NTAG_REG_KEY_LOC      "Software\\Microsoft\\Cryptography\\UserKeys"
#define NTAG_MACH_REG_KEY_LOC "Software\\Microsoft\\Cryptography\\MachineKeys"

extern DWORD
InflateKey(
    IN PNTAGKeyList pTmpKey);

/*static*/ DWORD
CopyKey(
    IN PNTAGKeyList pOldKey,
    OUT PNTAGKeyList *ppNewKey);

extern DWORD
SymEncrypt(
    IN PNTAGKeyList pKey,
    IN BOOL fFinal,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pcbData,
    IN DWORD cbBuf);

extern DWORD
SymDecrypt(
    IN PNTAGKeyList pKey,
    IN PNTAGHashList pHash,
    IN BOOL fFinal,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pcbData);

extern DWORD
BlockEncrypt(
    void EncFun(BYTE *In, BYTE *Out, void *key, int op),
    PNTAGKeyList pKey,
    int BlockLen,
    BOOL Final,
    BYTE  *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen);

static BYTE rgbSymmetricKeyWrapIV[8]
    = {0x4a, 0xdd, 0xa2, 0x2c, 0x79, 0xe8, 0x21, 0x05};


//
// Set the permissions on the key
//

/*static*/ void
SetInitialKeyPermissions(
    PNTAGKeyList pKey)
{
    if (CRYPT_EXPORTABLE == pKey->Rights)
    {
        pKey->Permissions |= CRYPT_EXPORT;
    }

    // UNDONE - set the appopropriate permission with the appropriate
    //          algorithm
    pKey->Permissions |= CRYPT_ENCRYPT | CRYPT_DECRYPT| CRYPT_READ |
                         CRYPT_WRITE | CRYPT_MAC;
}


/* MakeNewKey
 *
 *  Helper routine for ImportKey, GenKey
 *
 *  Allocate a new key record, fill in the data and copy in the key
 *  bytes.
 */

DWORD
MakeNewKey(
    ALG_ID       aiKeyAlg,
    DWORD        dwRights,
    DWORD        dwKeyLen,
    HCRYPTPROV   hUID,
    BYTE         *pbKeyData,
    BOOL         fUsePassedKeyBuffer,
    BOOL         fPreserveExactKey,
    PNTAGKeyList *ppKeyList)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGKeyList    pKey = NULL;

    *ppKeyList = NULL;

    // allocate space for the key record
    pKey = (PNTAGKeyList)_nt_malloc(sizeof(NTAGKeyList));
    if (NULL == pKey)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    if (!fUsePassedKeyBuffer)
    {
        pKey->pKeyValue = (BYTE *)_nt_malloc((size_t)dwKeyLen);
        if (NULL == pKey->pKeyValue)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }
    }

    pKey->Algid = aiKeyAlg;
    pKey->Rights = dwRights;
    pKey->cbDataLen = 0;
    pKey->pData = NULL;
    pKey->hUID = hUID;
    memset(pKey->IV, 0, MAX_BLOCKLEN);
    memset(pKey->FeedBack, 0, MAX_BLOCKLEN);
    pKey->InProgress = FALSE;
    pKey->cbSaltLen = 0;
    pKey->Padding = PKCS5_PADDING;
    pKey->Mode = CRYPT_MODE_CBC;
    pKey->ModeBits = 0;

    SetInitialKeyPermissions(pKey);

    pKey->cbKeyLen = dwKeyLen;
    if (pbKeyData != NULL)
    {
        if (fUsePassedKeyBuffer)
            pKey->pKeyValue = pbKeyData;
        else
            memcpy(pKey->pKeyValue, pbKeyData, (size_t)dwKeyLen);
    }

    // Handle special cases
    switch (aiKeyAlg)
    {
    case CALG_RC2:
        // for RC2 set a default effective key length
        pKey->EffectiveKeyLen = RC2_DEFAULT_EFFECTIVE_KEYLEN;
        pKey->dwBlockLen = RC2_BLOCKLEN;
        break;
    case CALG_DES:
        if (DES_KEYSIZE != pKey->cbKeyLen)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }
        if (!fPreserveExactKey)
            desparityonkey(pKey->pKeyValue, pKey->cbKeyLen);
        pKey->dwBlockLen = DES_BLOCKLEN;
        break;
    case CALG_3DES_112:
        if (DES_KEYSIZE * 2 != pKey->cbKeyLen)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }
        if (!fPreserveExactKey)
            desparityonkey(pKey->pKeyValue, pKey->cbKeyLen);
        pKey->dwBlockLen = DES_BLOCKLEN;
        break;
    case CALG_3DES:
        if (DES_KEYSIZE * 3 != pKey->cbKeyLen)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }
        if (!fPreserveExactKey)
            desparityonkey(pKey->pKeyValue, pKey->cbKeyLen);
        pKey->dwBlockLen = DES_BLOCKLEN;
        break;
#ifdef CSP_USE_AES
    case CALG_AES_128:
        pKey->dwBlockLen = CRYPT_AES128_BLKLEN;
        break;
    case CALG_AES_192:
        pKey->dwBlockLen = CRYPT_AES192_BLKLEN;
        break;
    case CALG_AES_256:
        pKey->dwBlockLen = CRYPT_AES256_BLKLEN;
        break;
#endif
    default:
        pKey->dwBlockLen = 0;
    }

    *ppKeyList = pKey;
    return ERROR_SUCCESS;

ErrorExit:
    if (NULL != pKey)
        _nt_free (pKey, sizeof(NTAGKeyList));
    return dwReturn;
}


/* FreeNewKey
 *
 *      Use for cleanup on abort of key build operations.
 *
 */

void
FreeNewKey(
    PNTAGKeyList pOldKey)
{
    if (pOldKey->pKeyValue)
        _nt_free(pOldKey->pKeyValue, pOldKey->cbKeyLen);
    if (pOldKey->pData)
        _nt_free(pOldKey->pData, pOldKey->cbDataLen);
    _nt_free(pOldKey, sizeof(NTAGKeyList));
}


/* FIsLegalKeySize
 *
 *      Check that the length of the key is legal (essentially
 *      complies with export).
 *
 */

BOOL
FIsLegalKeySize(
    IN DWORD  dwCspTypeId,
    IN ALG_ID Algid,
    IN DWORD cbKey,
    IN BOOL fRC2BigKeyOK,
    OUT BOOL *pfPubKey)
{
    BOOL fRet = FALSE;

    *pfPubKey = FALSE;

    switch (Algid)
    {
#ifdef CSP_USE_RC2
    case CALG_RC2:
        if (!fRC2BigKeyOK)
        {
            if (!IsLegalLength(g_AlgTables[dwCspTypeId], Algid,
                               cbKey * 8, NULL))
                goto ErrorExit;
        }
        break;
#endif
#ifdef CSP_USE_DES
    case CALG_DES:
        if ((DES_KEYSIZE != cbKey) && ((DES_KEYSIZE - 1) != cbKey))
            goto ErrorExit;
        break;
#endif
#ifdef CSP_USE_3DES
    case CALG_3DES_112:
        if ((DES2_KEYSIZE != cbKey) && ((DES2_KEYSIZE - 2) != cbKey))
            goto ErrorExit;
        break;
    case CALG_3DES:
        if ((DES3_KEYSIZE != cbKey) && ((DES3_KEYSIZE - 3) != cbKey))
            goto ErrorExit;
        break;
#endif
    case CALG_RSA_SIGN:
    case CALG_RSA_KEYX:
        *pfPubKey = TRUE;
        // Fall through intentionally.
    default:
        if (!IsLegalLength(g_AlgTables[dwCspTypeId], Algid, cbKey * 8, NULL))
            goto ErrorExit;
    }

    fRet = TRUE;

ErrorExit:
    // not of regulation size
    return fRet;
}


#ifdef USE_SGC
/* FIsLegalSGCKeySize
 *
 *      Check that the length of the key is SGC legal (essentially
 *      complies with export).
 *
 */

BOOL
FIsLegalSGCKeySize(
    IN ALG_ID Algid,
    IN DWORD cbKey,
    IN BOOL fRC2BigKeyOK,
    IN BOOL fGenKey,
    OUT BOOL *pfPubKey)
{
    BOOL fSts = FALSE;

    if (!fGenKey)
    {
        if (!FIsLegalKeySize(POLICY_MS_SCHANNEL, Algid, cbKey, fRC2BigKeyOK,
                             pfPubKey))
            goto ErrorExit;
    }
    else
    {
        switch (Algid)
        {
#ifdef CSP_USE_RC2
        case CALG_RC2:
            if (!fRC2BigKeyOK)
                goto ErrorExit;
            break;
#endif
#ifdef CSP_USE_SSL3
        case CALG_SSL3_MASTER:
        case CALG_TLS1_MASTER:
        case CALG_PCT1_MASTER:
        case CALG_SSL2_MASTER:
            if (!FIsLegalKeySize(POLICY_MS_SCHANNEL, Algid, cbKey,
                                 fRC2BigKeyOK, pfPubKey))
                goto ErrorExit;
            break;
        case CALG_SCHANNEL_MAC_KEY:
            break;
#endif
        case CALG_RSA_KEYX:
            if (!FIsLegalKeySize(POLICY_MS_SCHANNEL, Algid, cbKey,
                                 fRC2BigKeyOK, pfPubKey))
                goto ErrorExit;
            break;
        default:
            goto ErrorExit;
        }
    }

    fSts = TRUE;

ErrorExit:
    return fSts;
}
#endif

/* FIsLegalKey
 *
 *      Check that the length of the key is legal (essentially
 *      complies with export).
 *
 */

BOOL
FIsLegalKey(
    IN PNTAGUserList pTmpUser,
    IN PNTAGKeyList pKey,
    IN BOOL fRC2BigKeyOK)
{
    BOOL    fPubKey;
    BOOL    fRet = FALSE;

    if (pKey == NULL)
        goto ErrorExit;

#ifdef USE_SGC
    // check if the provider is an SChannel provider and if so if the
    // SGC flag is set then use the FIsLegalSGCKeySize function
    if ((PROV_RSA_SCHANNEL == pTmpUser->dwProvType)
        && (0 != pTmpUser->dwSGCFlags))
    {
        if (!FIsLegalSGCKeySize(pKey->Algid, pKey->cbKeyLen,
                                fRC2BigKeyOK, FALSE, &fPubKey))
        {
            goto ErrorExit;
        }
    }
    else
#endif
    {
        // 4th parameter, dwFlags, is used for SGC Exch keys so just
        // pass zero in this case
        if (!FIsLegalKeySize(pTmpUser->dwCspTypeId,
                             pKey->Algid, pKey->cbKeyLen,
                             fRC2BigKeyOK, &fPubKey))
        {
            goto ErrorExit;
        }
    }

    fRet = TRUE;

ErrorExit:
    return fRet;
}

/* FIsLegalImportSymKey
 *
 *      Verify that imported symmetric keys meet the size restrictions
 *      of the CSP in use.  In addition, require all DES-variant
 *      keys to be of the full required size, including parity bits.
 */
BOOL
FIsLegalImportSymKey(
    IN PNTAGUserList pTmpUser,
    IN PNTAGKeyList pKey,
    IN BOOL fRC2BigKeyOK)
{
    BOOL fRet = FALSE;

    switch (pKey->Algid)
    {
#ifdef CSP_USE_RC2
    case CALG_RC2:
        if (!fRC2BigKeyOK)
        {
            if (!IsLegalLength(g_AlgTables[pTmpUser->dwCspTypeId], pKey->Algid,
                               pKey->cbKeyLen * 8, NULL))
                goto ErrorExit;
        }
        break;
#endif
#ifdef CSP_USE_DES
    case CALG_DES:
        if (DES_KEYSIZE != pKey->cbKeyLen)
            goto ErrorExit;
        break;
#endif
#ifdef CSP_USE_3DES
    case CALG_3DES_112:
        if (DES2_KEYSIZE != pKey->cbKeyLen)
            goto ErrorExit;
        break;
    case CALG_3DES:
        if (DES3_KEYSIZE != pKey->cbKeyLen) 
            goto ErrorExit;
        break;
#endif
    case CALG_RSA_SIGN:
    case CALG_RSA_KEYX:
        goto ErrorExit;

    default:
        if (!IsLegalLength(g_AlgTables[pTmpUser->dwCspTypeId], pKey->Algid, 
                           pKey->cbKeyLen * 8, NULL))
            goto ErrorExit;
    }

    fRet = TRUE;

ErrorExit:
    return fRet;
}         

/*static*/ DWORD
MakeKeyRSABaseCompatible(
    HCRYPTPROV hUID,
    HCRYPTKEY  hKey)
{
    CRYPT_DATA_BLOB sSaltData;
    BYTE            rgbZeroSalt[11];
    BOOL            fSts;

    ZeroMemory(rgbZeroSalt, 11);

    sSaltData.pbData = rgbZeroSalt;
    sSaltData.cbData = sizeof(rgbZeroSalt);
    fSts = CPSetKeyParam(hUID, hKey, KP_SALT_EX, (PBYTE)&sSaltData, 0);
    if (!fSts)
        return GetLastError();
    return ERROR_SUCCESS;
}


typedef struct
{
    DWORD       magic;                  /* Should always be RSA2 */
    DWORD       bitlen;                 // bit size of key
    DWORD       pubexp;                 // public exponent
} EXPORT_PRV_KEY, FAR *PEXPORT_PRV_KEY;


/* GetLengthOfPrivateKeyForExport
 *
 *      Get the length of the private key
 *      blob from the public key.
 *
 */

/*static*/ void
GetLengthOfPrivateKeyForExport(
    IN BSAFE_PUB_KEY *pPubKey,
    OUT PDWORD pcbBlob)
{
    DWORD cbHalfModLen;

    cbHalfModLen = (pPubKey->bitlen + 15) / 16;
    *pcbBlob = sizeof(EXPORT_PRV_KEY) + 9 * cbHalfModLen;
}


/* PreparePrivateKeyForExport
 *
 *      Massage the key from the registry
 *      into an exportable format.
 *
 */

/*static*/ BOOL
PreparePrivateKeyForExport(
    IN BSAFE_PRV_KEY *pPrvKey,
    OUT PBYTE pbBlob,
    IN OUT PDWORD pcbBlob)
{
    PEXPORT_PRV_KEY pExportKey;
    DWORD           cbHalfModLen;
    DWORD           cbBlobLen;
    DWORD           cbTmpLen;
    DWORD           cbHalfTmpLen;
    PBYTE           pbIn;
    PBYTE           pbOut;

    cbHalfModLen = (pPrvKey->bitlen + 15) / 16;
    cbBlobLen = sizeof(EXPORT_PRV_KEY) + 9 * cbHalfModLen;

    // figure out the number of overflow bytes which are in the private
    // key structure
    cbTmpLen = (sizeof(DWORD) * 2)
               - (((pPrvKey->bitlen + 7) / 8) % (sizeof(DWORD) * 2));
    if ((sizeof(DWORD) * 2) != cbTmpLen)
        cbTmpLen += sizeof(DWORD) * 2;
    cbHalfTmpLen = cbTmpLen / 2;

    if (NULL == pbBlob)
    {
        *pcbBlob = cbBlobLen;
        return TRUE;
    }

    if (*pcbBlob < cbBlobLen)
    {
        *pcbBlob = cbBlobLen;
        return FALSE;
    }

    // take most of the header info
    pExportKey = (PEXPORT_PRV_KEY)pbBlob;
    pExportKey->magic = pPrvKey->magic;
    pExportKey->bitlen = pPrvKey->bitlen;
    pExportKey->pubexp = pPrvKey->pubexp;

    pbIn = (PBYTE)pPrvKey + sizeof(BSAFE_PRV_KEY);
    pbOut = pbBlob + sizeof(EXPORT_PRV_KEY);

    // copy all the private key info
    CopyMemory(pbOut, pbIn, pExportKey->bitlen / 8);
    pbIn += pExportKey->bitlen / 8 + cbTmpLen;
    pbOut += pExportKey->bitlen / 8;
    CopyMemory(pbOut, pbIn, cbHalfModLen);
    pbIn += cbHalfModLen + cbHalfTmpLen;
    pbOut += cbHalfModLen;
    CopyMemory(pbOut, pbIn, cbHalfModLen);
    pbIn += cbHalfModLen + cbHalfTmpLen;
    pbOut += cbHalfModLen;
    CopyMemory(pbOut, pbIn, cbHalfModLen);
    pbIn += cbHalfModLen + cbHalfTmpLen;
    pbOut += cbHalfModLen;
    CopyMemory(pbOut, pbIn, cbHalfModLen);
    pbIn += cbHalfModLen + cbHalfTmpLen;
    pbOut += cbHalfModLen;
    CopyMemory(pbOut, pbIn, cbHalfModLen);
    pbIn += cbHalfModLen + cbHalfTmpLen;
    pbOut += cbHalfModLen;
    CopyMemory(pbOut, pbIn, pExportKey->bitlen / 8);

    *pcbBlob = cbBlobLen;
    return TRUE;
}


/* PreparePrivateKeyForImport
 *
 *      Massage the incoming into a form acceptable for
 *      the registry.
 *
 */

/*static*/ BOOL
PreparePrivateKeyForImport(
    IN PBYTE pbBlob,
    OUT BSAFE_PRV_KEY *pPrvKey,
    IN OUT PDWORD pPrvKeyLen,
    OUT BSAFE_PUB_KEY *pPubKey,
    IN OUT PDWORD pPubKeyLen)
{
    PEXPORT_PRV_KEY pExportKey = (PEXPORT_PRV_KEY)pbBlob;
    DWORD           cbHalfModLen;
    DWORD           cbPub;
    DWORD           cbPrv;
    PBYTE           pbIn;
    PBYTE           pbOut;
    DWORD           cbTmpLen;
    DWORD           cbHalfTmpLen;

    if (RSA2 != pExportKey->magic)
        return FALSE;

    // figure out the number of overflow bytes which are in the private
    // key structure
    cbTmpLen = (sizeof(DWORD) * 2)
               - (((pExportKey->bitlen + 7) / 8) % (sizeof(DWORD) * 2));
    if ((sizeof(DWORD) * 2) != cbTmpLen)
        cbTmpLen += sizeof(DWORD) * 2;
    cbHalfTmpLen = cbTmpLen / 2;
    cbHalfModLen = (pExportKey->bitlen + 15) / 16;

    cbPub = sizeof(BSAFE_PUB_KEY) + (pExportKey->bitlen / 8) + cbTmpLen;
    cbPrv = sizeof(BSAFE_PRV_KEY) + (cbHalfModLen + cbHalfTmpLen) * 10;
    if ((NULL == pPrvKey) || (NULL == pPubKey))
    {
        *pPubKeyLen = cbPub;
        *pPrvKeyLen = cbPrv;
        return TRUE;
    }

    if ((*pPubKeyLen < cbPub) || (*pPrvKeyLen < cbPrv))
    {
        *pPubKeyLen = cbPub;
        *pPrvKeyLen = cbPrv;
        return FALSE;
    }

    // form the public key
    ZeroMemory(pPubKey, *pPubKeyLen);
    pPubKey->magic = RSA1;
    pPubKey->bitlen = pExportKey->bitlen;
    pPubKey->keylen = (pExportKey->bitlen / 8) + cbTmpLen;
    pPubKey->datalen = (pExportKey->bitlen+7)/8 - 1;
    pPubKey->pubexp = pExportKey->pubexp;

    pbIn = pbBlob + sizeof(EXPORT_PRV_KEY);
    pbOut = (PBYTE)pPubKey + sizeof(BSAFE_PUB_KEY);

    CopyMemory(pbOut, pbIn, pExportKey->bitlen / 8);

    // form the private key
    ZeroMemory(pPrvKey, *pPrvKeyLen);
    pPrvKey->magic = pExportKey->magic;
    pPrvKey->keylen = pPubKey->keylen;
    pPrvKey->bitlen = pExportKey->bitlen;
    pPrvKey->datalen = pPubKey->datalen;
    pPrvKey->pubexp = pExportKey->pubexp;

    pbOut = (PBYTE)pPrvKey + sizeof(BSAFE_PRV_KEY);

    CopyMemory(pbOut, pbIn, pExportKey->bitlen / 8);
    pbOut += pExportKey->bitlen / 8 + cbTmpLen;
    pbIn += pExportKey->bitlen / 8;
    CopyMemory(pbOut, pbIn, cbHalfModLen);
    pbOut += cbHalfModLen + cbHalfTmpLen;
    pbIn += cbHalfModLen;
    CopyMemory(pbOut, pbIn, cbHalfModLen);
    pbOut += cbHalfModLen + cbHalfTmpLen;
    pbIn += cbHalfModLen;
    CopyMemory(pbOut, pbIn, cbHalfModLen);
    pbOut += cbHalfModLen + cbHalfTmpLen;
    pbIn += cbHalfModLen;
    CopyMemory(pbOut, pbIn, cbHalfModLen);
    pbOut += cbHalfModLen + cbHalfTmpLen;
    pbIn += cbHalfModLen;
    CopyMemory(pbOut, pbIn, cbHalfModLen);
    pbOut += cbHalfModLen + cbHalfTmpLen;
    pbIn += cbHalfModLen;
    CopyMemory(pbOut, pbIn, pExportKey->bitlen / 8);

    *pPubKeyLen = cbPub;
    *pPrvKeyLen = cbPrv;

    return TRUE;
}


/*static*/ BOOL
ValidKeyAlgid(
    PNTAGUserList pTmpUser,
    ALG_ID Algid)
{
    if (ALG_CLASS_HASH == GET_ALG_CLASS(Algid))
        return FALSE;
        
    return IsLegalAlgorithm(g_AlgTables[pTmpUser->dwCspTypeId],
                            Algid, NULL);
}


#ifdef USE_SGC
/*
 -  GetSGCDefaultKeyLength
 -
 *  Purpose:
 *                Returns the default key size in pcbKey.
 *
 *  Parameters:
 *               IN      Algid   -  For the key to be created
 *               OUT     pcbKey  -  Size of the key in bytes to generate
 *               OUT     pfPubKey-  TRUE if the Algid is a pub key
 *
 *  Returns:  TRUE on success, FALSE on failure.
 */

/*static*/ BOOL
GetSGCDefaultKeyLength(
    IN ALG_ID Algid,
    OUT DWORD *pcbKey,
    OUT BOOL *pfPubKey)
{
    BOOL    fRet = FALSE;

    *pfPubKey = FALSE;

    // determine which crypt algorithm is to be used
    switch (Algid)
    {
#ifdef CSP_USE_SSL3
    case CALG_SSL3_MASTER:
    case CALG_TLS1_MASTER:
        *pcbKey = SSL3_MASTER_KEYSIZE;
        break;

    case CALG_PCT1_MASTER:
        *pcbKey = PCT1_MASTER_KEYSIZE;
        break;

    case CALG_SSL2_MASTER:
        *pcbKey = SSL2_MASTER_KEYSIZE;
        break;
#endif

    case CALG_RSA_KEYX:
        *pcbKey = SGC_RSA_DEF_EXCH_MODLEN;
        *pfPubKey = TRUE;
        break;

    default:
        goto ErrorExit;
    }

    fRet = TRUE;

ErrorExit:
    return fRet;
}
#endif


/*
 -  GetDefaultKeyLength
 -
 *  Purpose:
 *                Returns the default key size in pcbKey.
 *
 *  Parameters:
 *               IN      pTmpUser-  The context info
 *               IN      Algid   -  For the key to be created
 *               OUT     pcbKey  -  Size of the key in bytes to generate
 *               OUT     pfPubKey-  TRUE if the Algid is a pub key
 *
 *  Returns:  TRUE on success, FALSE on failure.
 */

/*static*/ BOOL
GetDefaultKeyLength(
    IN PNTAGUserList pTmpUser,
    IN ALG_ID Algid,
    OUT DWORD *pcbKey,
    OUT BOOL *pfPubKey)
{
    BOOL    fRet = FALSE;
    DWORD   cbits;

    *pfPubKey = FALSE;

    // determine which crypt algorithm is to be used
    switch (Algid)
    {
#ifdef CSP_USE_SSL3
    case CALG_SSL3_MASTER:
    case CALG_TLS1_MASTER:
        *pcbKey = SSL3_MASTER_KEYSIZE;
        break;

    case CALG_PCT1_MASTER:
        *pcbKey = PCT1_MASTER_KEYSIZE;
        break;

    case CALG_SSL2_MASTER:
        *pcbKey = SSL2_MASTER_KEYSIZE;
        break;
#endif

    case CALG_RSA_KEYX:
    case CALG_RSA_SIGN:
        *pfPubKey = TRUE;
        // Fall through intentionally.

    default:
        if (!GetDefaultLength(g_AlgTables[pTmpUser->dwCspTypeId],
                              Algid, NULL, &cbits))
            goto ErrorExit;
        *pcbKey = cbits / 8;
    }

    fRet = TRUE;

ErrorExit:
    return fRet;
}


/*
 -  CheckKeyLength
 -
 *  Purpose:
 *                Checks the settable key length and if it is OK then
 *                returns that as the size of key to use (pcbKey).  If
 *                no key length is in dwFlags then the default key size
 *                is returned (pcbKey).  If a settable key size is
 *                specified but is not legal then a failure occurs.
 *
 *  Parameters:
 *               IN      Algid   -  For the key to be created
 *               IN      dwFlags -  Flag value with possible key size
 *               OUT     pcbKey  -  Size of the key in bytes to generate
 *               OUT     pfPubKey-  TRUE if the Algid is a pub key
 *
 *  Returns:  A DWORD status code.
 */

/*static*/ DWORD
CheckKeyLength(
    IN PNTAGUserList pTmpUser,
    IN ALG_ID Algid,
    IN DWORD dwFlags,
    OUT DWORD *pcbKey,
    OUT BOOL *pfPubKey)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD   cBits;
    DWORD   cbKey = 0;

    cBits = dwFlags >> 16;
    if (cBits)
    {
        // settable key sizes must be divisible by 8 (by bytes)
        if (0 != (cBits % 8))
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        // check if requested size is legal
        cbKey = cBits / 8;
#ifdef USE_SGC
        if ((PROV_RSA_SCHANNEL == pTmpUser->dwProvType) &&
            (0 != pTmpUser->dwSGCFlags))
        {
            if (!FIsLegalSGCKeySize(Algid, cbKey,
                                    FALSE, TRUE, pfPubKey))
            {
                dwReturn = (DWORD)NTE_BAD_FLAGS;
                goto ErrorExit;
            }
        }
        else
#endif
        {
            if (!FIsLegalKeySize(pTmpUser->dwCspTypeId,
                                 Algid, cbKey,
                                 FALSE, pfPubKey))
            {
                dwReturn = (DWORD)NTE_BAD_FLAGS;
                goto ErrorExit;
            }
        }
        *pcbKey = cbKey;
    }
    else
    {
#ifdef USE_SGC
        if ((PROV_RSA_SCHANNEL == pTmpUser->dwProvType) &&
            (0 != pTmpUser->dwSGCFlags))
        {
            if (!GetSGCDefaultKeyLength(Algid, pcbKey, pfPubKey))
            {
                dwReturn = (DWORD)NTE_BAD_ALGID;
                goto ErrorExit;
            }
        }
        else
#endif
        {
            if (!GetDefaultKeyLength(pTmpUser, Algid, pcbKey, pfPubKey))
            {
                dwReturn = (DWORD)NTE_BAD_ALGID;
                goto ErrorExit;
            }
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}

#ifdef USE_SGC
/*
 -  CheckSGCSimpleForExport
 -
 *  Purpose:
 *                Check if the SGC key values in the context against the
 *                passed in values to see if an simple blob export with
 *                this key is allowed.
 *
 *
 *  Parameters:
 *               IN      hUID    -  Handle to a CSP
 *               IN      Algid   -  Algorithm identifier
 *               IN      dwFlags -  Flags values
 *               OUT     phKey   -  Handle to a generated key
 *
 *  Returns:
 */

/*static*/ BOOL
CheckSGCSimpleForExport(
    IN PNTAGUserList pTmpUser,
    IN BSAFE_PUB_KEY *pBsafePubKey)
{
    BOOL    fRet = FALSE;
    BYTE    *pb;

    pb = ((BYTE*)pBsafePubKey) + sizeof(BSAFE_PUB_KEY);
    if (((pBsafePubKey->bitlen / 8) != pTmpUser->cbSGCKeyMod)
        || (pBsafePubKey->pubexp != pTmpUser->dwSGCKeyExpo)
        || (0 != memcmp(pb, pTmpUser->pbSGCKeyMod, pTmpUser->cbSGCKeyMod)))
    {
        goto ErrorExit;
    }

    fRet = TRUE;

ErrorExit:
    return fRet;
}
#endif


/*
 -  CPGenKey
 -
 *  Purpose:
 *                Generate cryptographic keys
 *
 *
 *  Parameters:
 *               IN      hUID    -  Handle to a CSP
 *               IN      Algid   -  Algorithm identifier
 *               IN      dwFlags -  Flags values
 *               OUT     phKey   -  Handle to a generated key
 *
 *  Returns:
 */

BOOL WINAPI
CPGenKey(
    IN HCRYPTPROV hUID,
    IN ALG_ID Algid,
    IN DWORD dwFlags,
    OUT HCRYPTKEY * phKey)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGUserList   pTmpUser;
    PNTAGKeyList    pTmpKey = NULL;
    DWORD           dwRights = 0;
    BYTE            rgbRandom[MAX_KEY_SIZE];
    int             localAlgid;
    DWORD           cbKey;
    BOOL            fPubKey = FALSE;
    BOOL            fRet;
    DWORD           dwSts;

    EntryPoint
    if ((dwFlags & ~(CRYPT_EXPORTABLE | CRYPT_USER_PROTECTED |
                     CRYPT_CREATE_SALT | CRYPT_NO_SALT |
                     KEY_LENGTH_MASK | CRYPT_SGCKEY | CRYPT_ARCHIVABLE)) != 0)
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    switch (Algid)
    {
    case AT_KEYEXCHANGE:
        localAlgid = CALG_RSA_KEYX;
        break;

    case AT_SIGNATURE:
        localAlgid = CALG_RSA_SIGN;
        break;

    default:
        if (0 != (dwFlags & CRYPT_ARCHIVABLE))
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }
        localAlgid = Algid;
        break;
    }

    pTmpUser = (PNTAGUserList)NTLCheckList(hUID, USER_HANDLE);
    if (NULL == pTmpUser)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    if ((CRYPT_USER_PROTECTED & dwFlags) && (CRYPT_VERIFYCONTEXT & pTmpUser->Rights))
    {
        dwReturn = (DWORD)NTE_SILENT_CONTEXT;
        goto ErrorExit;
    }

    if (!ValidKeyAlgid(pTmpUser, localAlgid))
    {
        dwReturn = (DWORD)NTE_BAD_ALGID;
        goto ErrorExit;
    }

    // check if the size of the key is set in the dwFlags parameter
    dwSts = CheckKeyLength(pTmpUser, localAlgid, dwFlags, &cbKey, &fPubKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (fPubKey)
    {
        dwSts = ReGenKey(hUID,
                         dwFlags,
                         (localAlgid == CALG_RSA_KEYX)
                              ? NTPK_USE_EXCH
                              : NTPK_USE_SIG,
                         phKey,
                         cbKey * 8);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }
    else
    {
        // Force the full key lengths on DES algorithms.
        if (CALG_DES == localAlgid)
            cbKey = DES_KEYSIZE;
        else if (CALG_3DES_112 == localAlgid)
            cbKey = DES2_KEYSIZE;
        else if (CALG_3DES == localAlgid)
            cbKey = DES3_KEYSIZE;

        // generate the random key
        dwSts = FIPS186GenRandom(&pTmpUser->hRNGDriver,
                                 &pTmpUser->ContInfo.pbRandom,
                                 &pTmpUser->ContInfo.ContLens.cbRandom,
                                 rgbRandom, cbKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;   // NTE_FAIL
            goto ErrorExit;
        }

        if ((CALG_DES == localAlgid) || (CALG_3DES_112 == localAlgid) ||
            (CALG_3DES == localAlgid))
        {
            if (dwFlags & CRYPT_CREATE_SALT)
            {
                dwReturn = (DWORD)NTE_BAD_FLAGS;
                goto ErrorExit;
            }
        }
#ifdef CSP_USE_SSL3
        else if (CALG_SSL3_MASTER == localAlgid)
        {
            // set the first byte to 0x03 and the second to 0x00
            rgbRandom[0] = 0x03;
            rgbRandom[1] = 0x00;
        }
        else if (CALG_TLS1_MASTER == localAlgid)
        {
            // set the first byte to 0x03 and the second to 0x01
            rgbRandom[0] = 0x03;
            rgbRandom[1] = 0x01;
        }
#endif
        // check if the key is CRYPT_EXPORTABLE
        if (dwFlags & CRYPT_EXPORTABLE)
            dwRights = CRYPT_EXPORTABLE;

        dwSts = MakeNewKey(localAlgid, dwRights, cbKey, hUID, rgbRandom,
                           FALSE, FALSE, &pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        if (dwFlags & CRYPT_CREATE_SALT)
        {
            if ((POLICY_MS_DEF == pTmpUser->dwCspTypeId)
                || (POLICY_MS_STRONG == pTmpUser->dwCspTypeId))
            {
                pTmpKey->cbSaltLen = DEFAULT_WEAK_SALT_LENGTH;
            }
            else
            {
                pTmpKey->cbSaltLen = DEFAULT_STRONG_SALT_LENGTH;
            }

            dwSts = FIPS186GenRandom(&pTmpUser->hRNGDriver,
                                     &pTmpUser->ContInfo.pbRandom,
                                     &pTmpUser->ContInfo.ContLens.cbRandom,
                                     pTmpKey->rgbSalt, pTmpKey->cbSaltLen);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;   // NTE_FAIL
                goto ErrorExit;
            }
        }

        dwSts = NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        // if 40bit key + no mention of salt, set zeroized salt for RSABase compatibility
        if ((5 == cbKey) && (!(dwFlags & CRYPT_NO_SALT)) &&
            (!(dwFlags & CRYPT_CREATE_SALT)) &&
            (CALG_SSL3_MASTER != Algid) && (CALG_TLS1_MASTER != Algid) &&
            (CALG_PCT1_MASTER != Algid) && (CALG_SSL2_MASTER != Algid))
        {
            dwSts = MakeKeyRSABaseCompatible(hUID, *phKey);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (!fRet)
    {
        if (pTmpKey)
            FreeNewKey(pTmpKey);
        SetLastError(dwReturn);
    }
    return fRet;
}


/*
 -  CPDeriveKey
 -
 *  Purpose:
 *                Derive cryptographic keys from base data
 *
 *
 *  Parameters:
 *               IN      hUID       -  Handle to a CSP
 *               IN      Algid      -  Algorithm identifier
 *               IN      hBaseData  -  Handle to hash of base data
 *               IN      dwFlags    -  Flags values
 *               OUT     phKey      -  Handle to a generated key
 *
 *  Returns:
 */

BOOL WINAPI
CPDeriveKey(
    IN HCRYPTPROV hUID,
    IN ALG_ID Algid,
    IN HCRYPTHASH hBaseData,
    IN DWORD dwFlags,
    OUT HCRYPTKEY * phKey)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGUserList   pTmpUser = NULL;
    PNTAGKeyList    pTmpKey = NULL;
    DWORD           dwRights = 0;
    BYTE            rgbRandom[MAX_KEY_SIZE];
    BYTE            rgbBaseVal[MAX_KEY_SIZE];
    HCRYPTHASH      h1 = 0;
    HCRYPTHASH      h2 = 0;
    BYTE            rgbBuff1[64];
    BYTE            rgbBuff2[64];
    BYTE            rgbHash1[NT_HASH_BYTES];
    BYTE            rgbHash2[NT_HASH_BYTES];
    DWORD           cb1;
    DWORD           cb2;
    DWORD           i;
    PNTAGHashList   pTmpHash;
    DWORD           temp;
    BOOL            fPubKey = FALSE;
    DWORD           cbKey;
    BOOL            fRet;
    DWORD           dwSts;

    EntryPoint
    if ((dwFlags & ~(CRYPT_EXPORTABLE | 
                     CRYPT_CREATE_SALT | CRYPT_NO_SALT | CRYPT_SERVER |
                     KEY_LENGTH_MASK)) != 0)
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    pTmpUser = (PNTAGUserList)NTLCheckList(hUID, USER_HANDLE);
    if (NULL == pTmpUser)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    if (!ValidKeyAlgid(pTmpUser, Algid))
    {
        dwReturn = (DWORD)NTE_BAD_ALGID;
        goto ErrorExit;
    }

    dwSts = NTLValidate(hBaseData, hUID, HASH_HANDLE, &pTmpHash);
    if (ERROR_SUCCESS != dwSts)
    {
        // NTLValidate doesn't know what error to set
        // so it set NTE_FAIL -- fix it up.
        dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_HASH : dwSts;
        goto ErrorExit;
    }

#ifdef CSP_USE_SSL3
    // if the hash is for secure channel usage then go to that derive function
    if (CALG_SCHANNEL_MASTER_HASH == pTmpHash->Algid)
    {
        dwReturn = SecureChannelDeriveKey(pTmpUser, pTmpHash, Algid,
                                          dwFlags, phKey);
        goto ErrorExit;
    }
#endif // CSP_USE_SSL3

    // check if the size of the key is set in the dwFlags parameter
    dwSts = CheckKeyLength(pTmpUser, Algid, dwFlags, &cbKey, &fPubKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // Force the full key lengths on DES algorithms.
    if (CALG_DES == Algid)
        cbKey = DES_KEYSIZE;
    else if (CALG_3DES_112 == Algid)
        cbKey = DES2_KEYSIZE;
    else if (CALG_3DES == Algid)
        cbKey = DES3_KEYSIZE;

    if (fPubKey)
    {
        dwReturn = (DWORD)NTE_BAD_ALGID;
        goto ErrorExit;
    }

    if (pTmpHash->HashFlags & HF_VALUE_SET)
    {
        dwReturn = (DWORD)NTE_BAD_HASH;
        goto ErrorExit;
    }

    memset(rgbBaseVal, 0, MAX_KEY_SIZE);
    temp = MAX_KEY_SIZE;
    if (!CPGetHashParam(hUID, hBaseData, HP_HASHVAL, rgbBaseVal, &temp, 0))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

#ifdef CSP_USE_3DES
    if (CALG_3DES == Algid)
    {
        // the hash value is not long enough so we must expand it
        if (!CPCreateHash(hUID, pTmpHash->Algid, 0, 0, &h1))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }
        if (!CPCreateHash(hUID, pTmpHash->Algid, 0, 0, &h2))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        // set up the two buffers to be hashed
        memset(rgbBuff1, 0x36, sizeof(rgbBuff1));
        memset(rgbBuff2, 0x5C, sizeof(rgbBuff2));
        for (i=0;i<temp;i++)
        {
            rgbBuff1[i] ^= rgbBaseVal[i];
            rgbBuff2[i] ^= rgbBaseVal[i];
        }

        // hash the two buffers
        if (!CPHashData(hUID, h1, rgbBuff1, sizeof(rgbBuff1), 0))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }
        if (!CPHashData(hUID, h2, rgbBuff2, sizeof(rgbBuff2), 0))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        // finish the hashes and copy them into BaseVal
        memset(rgbHash1, 0, sizeof(rgbHash1));
        cb1 = sizeof(rgbHash1);
        if (!CPGetHashParam(hUID, h1, HP_HASHVAL, rgbHash1, &cb1, 0))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }
        memcpy(rgbBaseVal, rgbHash1, cb1);

        memset(rgbHash2, 0, sizeof(rgbHash2));
        cb2 = sizeof(rgbHash2);
        if (!CPGetHashParam(hUID, h2, HP_HASHVAL, rgbHash2, &cb2, 0))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }
        memcpy(rgbBaseVal + cb1, rgbHash2, cb2);
    }
#endif

    memcpy(rgbRandom, rgbBaseVal, cbKey);

    // check if the key is CRYPT_EXPORTABLE
    if (dwFlags & CRYPT_EXPORTABLE)
        dwRights = CRYPT_EXPORTABLE;

    dwSts = MakeNewKey(Algid, dwRights, cbKey, hUID, rgbRandom,
                       FALSE, FALSE, &pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (dwFlags & CRYPT_CREATE_SALT)
    {
        if ((POLICY_MS_DEF == pTmpUser->dwCspTypeId)
            || (POLICY_MS_STRONG == pTmpUser->dwCspTypeId))
        {
            pTmpKey->cbSaltLen = DEFAULT_WEAK_SALT_LENGTH;
        }
        else
        {
            pTmpKey->cbSaltLen = DEFAULT_STRONG_SALT_LENGTH;
        }

        memcpy(pTmpKey->rgbSalt, rgbBaseVal+cbKey, pTmpKey->cbSaltLen);
    }

    dwSts = NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // if 40bit key + no mention of salt, set zeroized salt for RSABase
    // compatibility
    if ((5 == cbKey) && (!(dwFlags & CRYPT_NO_SALT)) &&
        (!(dwFlags & CRYPT_CREATE_SALT)))
    {
        dwSts = MakeKeyRSABaseCompatible(hUID, *phKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (pTmpUser && h1)
        CPDestroyHash(hUID, h1);
    if (pTmpUser && h2)
        CPDestroyHash(hUID, h2);
    if (!fRet)
    {
        if (NULL != pTmpKey)
            FreeNewKey(pTmpKey);
        SetLastError(dwReturn);
    }
    return fRet;
}


/*static*/ DWORD
ExportOpaqueBlob(
    PNTAGKeyList pKey,
    BYTE *pbData,
    DWORD *pcbData)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    DWORD cb = 0;
    PNTAGPackedKeyList pPackedKey;

    // make sure the key is a symmetric key
    if ((CALG_RSA_SIGN == pKey->Algid) || (CALG_RSA_KEYX == pKey->Algid))
    {
        dwReturn = (DWORD)NTE_BAD_KEY;
        goto ErrorExit;
    }

    // calculate the length of the blob
    cb = sizeof(BLOBHEADER) +
         sizeof(NTAGPackedKeyList) +
         pKey->cbKeyLen +
         pKey->cbDataLen;

    if (pbData == NULL || *pcbData < cb)
    {
        *pcbData = cb;
        if (pbData == NULL)
            dwReturn = ERROR_SUCCESS;
        else
            dwReturn = ERROR_MORE_DATA;
        goto ErrorExit;
    }

    // set up the blob
    pPackedKey = (PNTAGPackedKeyList)(pbData + sizeof(BLOBHEADER));

    memset(pPackedKey, 0, sizeof(NTAGPackedKeyList));

    pPackedKey->Algid           = pKey->Algid;
    pPackedKey->Rights          = pKey->Rights;
    memcpy(pPackedKey->IV, pKey->IV, sizeof(pKey->IV));
    memcpy(pPackedKey->FeedBack, pKey->FeedBack, sizeof(pKey->FeedBack));
    pPackedKey->InProgress      = pKey->InProgress;
    pPackedKey->cbSaltLen       = pKey->cbSaltLen;
    memcpy(pPackedKey->rgbSalt, pKey->rgbSalt, sizeof(pKey->rgbSalt));
    pPackedKey->Padding         = pKey->Padding;
    pPackedKey->Mode            = pKey->Mode;
    pPackedKey->ModeBits        = pKey->ModeBits;
    pPackedKey->Permissions     = pKey->Permissions;
    pPackedKey->EffectiveKeyLen = pKey->EffectiveKeyLen;
    pPackedKey->dwBlockLen      = pKey->dwBlockLen;

    if (pKey->pKeyValue)
    {
        memcpy((PBYTE)pPackedKey + sizeof(NTAGPackedKeyList),
               pKey->pKeyValue,
               pKey->cbKeyLen);

        pPackedKey->cbKeyLen = pKey->cbKeyLen;
    }

    if(pKey->pData)
    {
        memcpy((PBYTE)pPackedKey + sizeof(NTAGPackedKeyList) + pPackedKey->cbKeyLen,
               pKey->pData,
               pKey->cbDataLen);

        pPackedKey->cbDataLen = pKey->cbDataLen;
    }

    *pcbData = cb;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*
 -  GetRC4KeyForSymWrap
 -
 *  Purpose:
 *            RC4 or more precisely stream ciphers are not supported by the CMS spec
 *            on symmetric key wrapping so we had to do something proprietary since
 *            we want to support RC4 for applications other than SMIME
 *
 *
 *  Parameters:
 *               IN  pTmpUser   - Pointer to the context
 *               IN  pbSalt     - Pointer to the 8 byte salt buffer
 *               IN  pKey       - Pointer to the orignial key
 *               OUT ppNewKey   - Pointer to a pointer to the new key
 */

/*static*/ DWORD
GetRC4KeyForSymWrap(
    IN BYTE *pbSalt,
    IN PNTAGKeyList pKey,
    OUT PNTAGKeyList *ppNewKey)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    DWORD dwSts;

    // duplicate the key
    dwSts = CopyKey(pKey, ppNewKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // set the value as salt + current salt
    (*ppNewKey)->cbSaltLen += 8;
    memcpy((*ppNewKey)->rgbSalt + ((*ppNewKey)->cbSaltLen - 8), pbSalt, 8);
    dwSts = InflateKey(*ppNewKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*
 -  GetSymmetricKeyChecksum
 -
 *  Purpose:
 *                Calculates the checksum for a symmetric key which is to be
 *                wrapped with another symmetric key.  This should meet the
 *                CMS specification
 *
 *
 *  Parameters:
 *               IN  pKey       - Pointer to the key
 *               OUT pbChecksum - Pointer to the 8 byte checksum
 */

/*static*/ void
GetSymmetricKeyChecksum(
    IN BYTE *pbKey,
    IN DWORD cbKey,
    OUT BYTE *pbChecksum)
{
    A_SHA_CTX   SHACtx;
    BYTE        rgb[A_SHA_DIGEST_LEN];

    A_SHAInit(&SHACtx);
    A_SHAUpdate(&SHACtx, pbKey, cbKey);
    A_SHAFinal(&SHACtx, rgb);

    memcpy(pbChecksum, rgb, 8);
}


/*
 -  WrapSymKey
 -
 *  Purpose:
 *          Wrap a symmetric key with another symmetric key.  This should
 *          meet the CMS specification for symmetric key wrapping.
 *
 *  Parameters:
 *               IN  pTmpUser   - Pointer to the user context
 *               IN  pKey       - Pointer to the key to be wrapped
 *               IN  pWrapKey   - Pointer to the key to be used for wrapping
 *               IN OUT pbBlob  - Pointer to the resulting blob (may be NULL
 *                                to get the length)
 *               IN OUT pcbBlob - Pointer to the length of the blob buffer
 */

/*static*/ DWORD
WrapSymKey(
    IN PNTAGUserList pTmpUser,
    IN PNTAGKeyList pKey,
    IN PNTAGKeyList pWrapKey,
    IN OUT BYTE *pbBlob,
    IN OUT DWORD *pcbBlob)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    DWORD           cb = 0;
    DWORD           cbIndex = 0;
    DWORD           cbPad = 0;
    BLOBHEADER      *pBlobHdr;
    ALG_ID          *pAlgid;
    BYTE            rgbTmp1[49]; // 1 length + 8 padding + 8 checksum + 8 IV + 24 max key
    BYTE            rgbTmp2[49]; // 1 length + 8 padding + 8 checksum + 8 IV + 24 max key
    BYTE            rgbIV[8];
    PNTAGKeyList    pLocalWrapKey = NULL;
    BOOL            fAlloc = FALSE;
    DWORD           i;
    DWORD           dwSts;

    memset(rgbTmp1, 0, sizeof(rgbTmp1));
    memset(rgbTmp2, 0, sizeof(rgbTmp2));
    memset(rgbIV, 0, sizeof(rgbIV));

    // both keys must be supported symmetric keys
    if (UnsupportedSymKey(pKey) || UnsupportedSymKey(pWrapKey))
    {
        dwReturn = (DWORD)NTE_BAD_KEY;
        goto ErrorExit;
    }

#ifdef CSP_USE_AES
    // For now, punt on supporting AES algs in this scenario
    if (CALG_AES_128 == pWrapKey->Algid ||
        CALG_AES_192 == pWrapKey->Algid ||
        CALG_AES_256 == pWrapKey->Algid ||
        CALG_AES_128 == pKey->Algid ||
        CALG_AES_192 == pKey->Algid ||
        CALG_AES_256 == pKey->Algid)
    {
        dwReturn = (DWORD)NTE_BAD_KEY;
        goto ErrorExit;
    }
#endif

    if ((!FIsLegalKey(pTmpUser, pKey, FALSE)) ||
        (!FIsLegalKey(pTmpUser, pWrapKey, FALSE)))
    {
        dwReturn = (DWORD)NTE_BAD_KEY;
        goto ErrorExit;
    }

    // Check if we should do an auto-inflate
    if (pWrapKey->pData == NULL)
    {
        dwSts = InflateKey(pWrapKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    // calculate how long the encrypted data is going to be.
    if ((CALG_RC4 == pKey->Algid) || (CALG_RC2 == pKey->Algid)) // variable key lengths
    {
        // 1 byte for length, up to 8 bytes for pad and 8 bytes
        // for the checksum and 8 bytes for the IV
        cbPad = 8 - ((pKey->cbKeyLen + 1) % 8);
        cb += pKey->cbKeyLen + 9 + cbPad + 8;

        // place the length in the buffer
        rgbTmp1[0] = (BYTE)pKey->cbKeyLen;
        cbIndex += 1;
    }
    else
    {
        // up to 8 bytes for salt and 8 bytes for the checksum and 8 bytes
        // for the IV
        cb += pKey->cbKeyLen + 16;
    }

    // check if just looking for a length
    if (NULL == pbBlob)
    {
        *pcbBlob = cb + sizeof(BLOBHEADER) + sizeof(ALG_ID);
        dwReturn = ERROR_SUCCESS;
        goto ErrorExit;
    }
    else if (*pcbBlob < (cb + sizeof(BLOBHEADER) + sizeof(ALG_ID)))
    {
        *pcbBlob = cb + sizeof(BLOBHEADER) + sizeof(ALG_ID);
        dwReturn = ERROR_MORE_DATA;
        goto ErrorExit;
    }

    // copy the key data
    memcpy(rgbTmp1 + cbIndex, pKey->pKeyValue, pKey->cbKeyLen);
    cbIndex += pKey->cbKeyLen;

    // generate random pad
    if (cbPad)
    {
        dwSts = FIPS186GenRandom(&pTmpUser->hRNGDriver,
                                 &pTmpUser->ContInfo.pbRandom,
                                 &pTmpUser->ContInfo.ContLens.cbRandom,
                                 rgbTmp1 + cbIndex, cbPad);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        cbIndex += cbPad;
    }

    // get the checksum
    GetSymmetricKeyChecksum(rgbTmp1, cbIndex, rgbTmp1 + cbIndex);
    cbIndex += 8;

    dwSts = FIPS186GenRandom(&pTmpUser->hRNGDriver,
                             &pTmpUser->ContInfo.pbRandom,
                             &pTmpUser->ContInfo.ContLens.cbRandom,
                             rgbIV, 8);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // set the IV if the algorithm is not RC4
    if (CALG_RC4 != pWrapKey->Algid)
    {
        memcpy(pWrapKey->IV, rgbIV, 8);
        pWrapKey->InProgress = FALSE;
        pLocalWrapKey = pWrapKey;
    }
    else
    {
        // RC4 ()or more precisely stream ciphers) are not supported by the
        // CMS spec for symmetric key wrapping.  Therefore we had to do
        // something proprietary to support RC4 for applications other
        // than SMIME.
        dwSts = GetRC4KeyForSymWrap(rgbIV,
                                    pWrapKey,
                                    &pLocalWrapKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        fAlloc = TRUE;
    }

    // encrypt the key blob data
    dwSts = SymEncrypt(pLocalWrapKey, FALSE, rgbTmp1, &cbIndex, cbIndex);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // concatenate the initial ciphertext with the IV
    memcpy(rgbTmp2, rgbIV, 8);
    memcpy(rgbTmp2 + 8, rgbTmp1, cbIndex);
    cbIndex += 8;

    // byte reverse the ciphertext + IV buffer
    for (i = 0; i < cbIndex; i++)
        rgbTmp1[i] = rgbTmp2[cbIndex - (i + 1)];

    // encrypt the key blob data again with the hardcoded IV
    if (CALG_RC4 != pWrapKey->Algid)
    {
        memcpy(pWrapKey->IV, rgbSymmetricKeyWrapIV, 8);
        pWrapKey->InProgress = FALSE;
    }
    else
    {
        if (fAlloc && pLocalWrapKey)
        {
            FreeNewKey(pLocalWrapKey);
            pLocalWrapKey = NULL;
            fAlloc = FALSE;
        }

        // RC4 (or more precisely stream ciphers) are not supported by the
        // CMS spec for symmetric key wrapping.  Therefore we had to do
        // something proprietary to support RC4 for applications other
        // than SMIME
        dwSts = GetRC4KeyForSymWrap(rgbSymmetricKeyWrapIV,
                                    pWrapKey,
                                    &pLocalWrapKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        fAlloc = TRUE;
    }

    dwSts = SymEncrypt(pLocalWrapKey, FALSE, rgbTmp1, &cbIndex, cbIndex);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // set the header info
    pBlobHdr = (BLOBHEADER*)pbBlob;
    pBlobHdr->aiKeyAlg = pKey->Algid;

    pAlgid = (ALG_ID*)(pbBlob + sizeof(BLOBHEADER));
    *pAlgid = pWrapKey->Algid;

    memcpy(pbBlob + sizeof(BLOBHEADER) + sizeof(ALG_ID),
           rgbTmp1, cbIndex);

    *pcbBlob = cbIndex + sizeof(BLOBHEADER) + sizeof(ALG_ID);
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (fAlloc && pLocalWrapKey)
        FreeNewKey(pLocalWrapKey);
    memset(rgbTmp1, 0, sizeof(rgbTmp1));
    memset(rgbTmp2, 0, sizeof(rgbTmp2));
    memset(rgbIV, 0, sizeof(rgbIV));
    return dwReturn;
}


/*
 -  UnWrapSymKey
 -
 *  Purpose:
 *          Unwrap a symmetric key with another symmetric key.  This should
 *          meet the CMS specification for symmetric key wrapping.
 *
 *  Parameters:
 *               IN  pTmpUser   - Pointer to the user context
 *               IN  pWrapKey   - Pointer to the key to be used for unwrapping
 *               IN  pbBlob     - Pointer to the blob to be unwrapped
 *               IN  cbBlob     - The length of the blob buffer
 *               OUT phKey      - Handle to the unwrapped key
 */

/*static*/ DWORD
UnWrapSymKey(
    IN HCRYPTPROV hUID,
    IN PNTAGUserList pTmpUser,
    IN PNTAGKeyList pWrapKey,
    IN BYTE *pbBlob,
    IN DWORD cbBlob,
    IN DWORD dwFlags,
    OUT HCRYPTKEY *phKey)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    DWORD           cb = 0;
    DWORD           cbIndex = 0;
    DWORD           cbKey = 0;
    BYTE            rgbChecksum[8];
    BLOBHEADER      *pBlobHdr = (BLOBHEADER*)pbBlob;
    ALG_ID          *pAlgid;
    BYTE            rgbTmp1[49];  // 1 length + 8 padding + 8 checksum + 8 IV + 24 max key
    BYTE            rgbTmp2[49];  // 1 length + 8 padding + 8 checksum + 8 IV + 24 max key
    DWORD           dwRights = 0;
    PNTAGKeyList    pTmpKey = NULL;
    PNTAGKeyList    pLocalWrapKey = NULL;
    BOOL            fAlloc = FALSE;
    DWORD           i;
    BOOL            fPubKey;
    DWORD           dwSts;

    memset(rgbTmp1, 0, sizeof(rgbTmp1));
    memset(rgbTmp2, 0, sizeof(rgbTmp2));

    cb = cbBlob - (sizeof(BLOBHEADER) + sizeof(ALG_ID));
    if ((sizeof(rgbTmp1) < cb) || (0 != (cb % 8)))
    {
        dwReturn = (DWORD)NTE_BAD_DATA;
        goto ErrorExit;
    }

    // both keys must be supported symmetric keys
    if (UnsupportedSymKey(pWrapKey) || UnsupportedSymKey(pWrapKey))
    {
        dwReturn = (DWORD)NTE_BAD_KEY;
        goto ErrorExit;
    }

#ifdef CSP_USE_AES
    // For now, punt on supporting AES algs in this scenario
    if (CALG_AES_128 == pWrapKey->Algid ||
        CALG_AES_192 == pWrapKey->Algid ||
        CALG_AES_256 == pWrapKey->Algid)
    {
        dwReturn = (DWORD)NTE_BAD_KEY;
        goto ErrorExit;
    }
#endif

    if (!FIsLegalKey(pTmpUser, pWrapKey, FALSE))
    {
        dwReturn = (DWORD)NTE_BAD_KEY;
        goto ErrorExit;
    }

    // check the wrapping key ALG_ID
    pAlgid = (ALG_ID*)(pbBlob + sizeof(BLOBHEADER));
    if (pWrapKey->Algid != *pAlgid)
    {
        dwReturn = (DWORD)NTE_BAD_KEY;
        goto ErrorExit;
    }

    // Check if we should do an auto-inflate
    if (pWrapKey->pData == NULL)
    {
        dwSts = InflateKey(pWrapKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    // set the hardcoded IV
    if (CALG_RC4 != pWrapKey->Algid)
    {
        memcpy(pWrapKey->IV, rgbSymmetricKeyWrapIV, 8);
        pWrapKey->InProgress = FALSE;
        pLocalWrapKey = pWrapKey;
    }
    else
    {
        // RC4 (or more precisely, stream ciphers) are not supported by the
        // CMS spec for symmetric key wrapping.  Therefore we had to do
        // something proprietary to support RC4 for applications other
        // than SMIME.
        dwSts = GetRC4KeyForSymWrap(rgbSymmetricKeyWrapIV,
                                    pWrapKey,
                                    &pLocalWrapKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        fAlloc = TRUE;
    }

    memcpy(rgbTmp1, pbBlob + sizeof(BLOBHEADER) + sizeof(ALG_ID), cb);

    // decrypt the key blob data
    dwSts = SymDecrypt(pLocalWrapKey, 0, FALSE, rgbTmp1, &cb);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // byte reverse the plaintext + IV buffer
    for (i = 0; i < cb; i++)
        rgbTmp2[i] = rgbTmp1[cb - (i + 1)];

    // set the IV if the algorithm is not RC4
    cb -= 8;
    if (CALG_RC4 != pWrapKey->Algid)
    {
        memcpy(pWrapKey->IV, rgbTmp2, 8);
        pWrapKey->InProgress = FALSE;
    }
    else
    {
        if (fAlloc && pLocalWrapKey)
        {
            FreeNewKey(pLocalWrapKey);
            pLocalWrapKey = NULL;
            fAlloc = FALSE;
        }

        // RC4 (or more precisely, stream ciphers) are not supported by the
        // CMS spec for symmetric key wrapping.  Therefore we had to do
        // something proprietary to support RC4 for applications other
        // than SMIME.
        dwSts = GetRC4KeyForSymWrap(rgbTmp2, pWrapKey, &pLocalWrapKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        fAlloc = TRUE;
    }

    // decrypt the key blob data again
    dwSts = SymDecrypt(pLocalWrapKey, 0, FALSE, rgbTmp2 + 8, &cb);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // check the length of the key
    switch (pBlobHdr->aiKeyAlg)
    {
    case CALG_RC2:  // variable key lengths
    case CALG_RC4:
        cbKey = (DWORD)rgbTmp2[8];
        cbIndex += 1;
        break;

    case CALG_DES:  // Ignore the default length, and use the full DES length.
    case CALG_DESX:
    case CALG_CYLINK_MEK:
        cbKey = DES_KEYSIZE;
        break;
    case CALG_3DES_112:
        cbKey = DES_KEYSIZE * 2;
        break;
    case CALG_3DES:
        cbKey = DES_KEYSIZE * 3;
        break;

    default:
        if (!GetDefaultKeyLength(pTmpUser, pBlobHdr->aiKeyAlg,
                                 &cbKey, &fPubKey))
        {
            dwReturn = (DWORD)NTE_BAD_ALGID;
            goto ErrorExit;
        }
    }

    // get the checksum and make sure it matches
    cb -= 8;
    GetSymmetricKeyChecksum(rgbTmp2 + 8, cb, rgbChecksum);
    if (0 != memcmp(rgbChecksum, rgbTmp2 + 8 + cb, sizeof(rgbChecksum)))
    {
        dwReturn = (DWORD)NTE_BAD_DATA;
        goto ErrorExit;
    }

    // check if the key is to be exportable
    if (dwFlags & CRYPT_EXPORTABLE)
        dwRights = CRYPT_EXPORTABLE;

    dwSts = MakeNewKey(pBlobHdr->aiKeyAlg, dwRights, cbKey, hUID,
                       rgbTmp2 + cbIndex + 8, FALSE, TRUE, &pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // check keylength...
    if (!FIsLegalKey(pTmpUser, pTmpKey, TRUE))
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    dwSts = NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // if 40 bit key + no mention of salt, set zeroized salt for
    // RSABase compatibility
    if ((5 == pTmpKey->cbKeyLen) && (0 == (dwFlags & CRYPT_NO_SALT)))
    {
        dwSts = MakeKeyRSABaseCompatible(hUID, *phKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    pTmpKey = NULL;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (fAlloc && pLocalWrapKey)
        FreeNewKey(pLocalWrapKey);
    memset(rgbTmp1, 0, sizeof(rgbTmp1));
    memset(rgbTmp2, 0, sizeof(rgbTmp2));
    if (NULL != pTmpKey)
        FreeNewKey(pTmpKey);
    return dwReturn;
}


/*
 -  CPExportKey
 -
 *  Purpose:
 *                Export cryptographic keys out of a CSP in a secure manner
 *
 *
 *  Parameters:
 *               IN  hUID       - Handle to the CSP user
 *               IN  hKey       - Handle to the key to export
 *               IN  hPubKey    - Handle to the exchange public key value of
 *                                the destination user
 *               IN  dwBlobType - Type of key blob to be exported
 *               IN  dwFlags -    Flags values
 *               OUT pbData -     Key blob data
 *               OUT pdwDataLen - Length of key blob in bytes
 *
 *  Returns:
 */

BOOL WINAPI
CPExportKey(
    IN  HCRYPTPROV hUID,
    IN  HCRYPTKEY hKey,
    IN  HCRYPTKEY hPubKey,
    IN  DWORD dwBlobType,
    IN  DWORD dwFlags,
    OUT BYTE *pbData,
    OUT DWORD *pdwDataLen)
{
    // return codes
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    BOOL            fRet;

    // miscellaneous variables
    DWORD           dwLen;
    NTSimpleBlob    *pSimpleHeader;
    BLOBHEADER      *pPreHeader;
    BLOBHEADER      shScratch;
    RSAPUBKEY       *pExpPubKey;
    BSAFE_PUB_KEY   *pBsafePubKey;
    BSAFE_PUB_KEY   *pPublicKey;
    DWORD           PubKeyLen;
    BSAFE_PRV_KEY   *pPrvKey = NULL;
    DWORD           PrvKeyLen = 0;
    DWORD           cbPrivateBlob = 0;
    PBYTE           pbPrivateBlob = NULL;
    DWORD           cb = 0;
    BOOL            fExportable = FALSE;
    DWORD           dwSts;

    // temporary variables for pointing to user and key records
    PNTAGKeyList    pTmpKey;
    PNTAGKeyList    pPubKey;
    PNTAGUserList   pTmpUser;

    EntryPoint
    if (0 != (dwFlags & ~(CRYPT_SSL2_FALLBACK
                          | CRYPT_DESTROYKEY
                          | CRYPT_OAEP)))
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    if (pdwDataLen == NULL)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    if (((PUBLICKEYBLOB == dwBlobType) || (OPAQUEKEYBLOB == dwBlobType)
        || (PLAINTEXTKEYBLOB == dwBlobType))
        && (0 != hPubKey))
    {
        dwReturn = (DWORD)NTE_BAD_PUBLIC_KEY;
        goto ErrorExit;
    }

    // check the user identification
    pTmpUser = (PNTAGUserList)NTLCheckList(hUID, USER_HANDLE);
    if (NULL == pTmpUser)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    // check if the user is just looking for a length.  If so,
    // use a scratchpad to construct a pseudoblob.

    if ((pbData != NULL) && (*pdwDataLen > sizeof(BLOBHEADER)))
        pPreHeader = (BLOBHEADER *)pbData;
    else
        pPreHeader = &shScratch;

    pPreHeader->bType = (BYTE)(dwBlobType & 0xff);
    pPreHeader->bVersion = CUR_BLOB_VERSION;
    pPreHeader->reserved = 0;

    dwSts = NTLValidate((HNTAG)hKey, hUID, HNTAG_TO_HTYPE(hKey), &pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = (NTE_FAIL == dwSts) ? (DWORD)NTE_BAD_KEY : dwSts;
        goto ErrorExit;
    }

    if ((dwBlobType != PUBLICKEYBLOB) &&
        (0 == (pTmpKey->Rights & (CRYPT_EXPORTABLE | CRYPT_ARCHIVABLE))))
    {
        dwReturn = (DWORD)NTE_BAD_KEY_STATE;
        goto ErrorExit;
    }

    pPreHeader->aiKeyAlg = pTmpKey->Algid;

    switch (dwBlobType)
    {
    case PUBLICKEYBLOB:
    {
        if ((HNTAG_TO_HTYPE(hKey) != SIGPUBKEY_HANDLE) &&
            (HNTAG_TO_HTYPE(hKey) != EXCHPUBKEY_HANDLE))
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        pBsafePubKey = (BSAFE_PUB_KEY *) pTmpKey->pKeyValue;

        if (pBsafePubKey == NULL)
        {
            dwReturn = (DWORD)NTE_NO_KEY;
            goto ErrorExit;
        }

        //
        // Subtract off 2 extra DWORD needed by RSA code
        //
        dwLen = sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) +
                ((pBsafePubKey->bitlen + 7) / 8);

        // Check user buffer size
        if (pbData == NULL || *pdwDataLen < dwLen)
        {
            *pdwDataLen = dwLen;
            if (pbData == NULL)
                dwReturn = ERROR_SUCCESS;
            else
                dwReturn = ERROR_MORE_DATA;
            goto ErrorExit;
        }

        pExpPubKey = (RSAPUBKEY *) (pbData + sizeof(BLOBHEADER));
        pExpPubKey->magic = pBsafePubKey->magic;
        pExpPubKey->bitlen = pBsafePubKey->bitlen;
        pExpPubKey->pubexp = pBsafePubKey->pubexp;

        memcpy((BYTE *) pbData + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY),
               (BYTE *) pBsafePubKey + sizeof(BSAFE_PUB_KEY),
               ((pBsafePubKey->bitlen + 7) / 8));
        break;
    }

    case PRIVATEKEYBLOB:
    {
        DWORD   dwBlockLen = 0;
        BOOL    fSigKey;
        LPWSTR  szPrompt;

        cb = sizeof(DWORD);
        if (HNTAG_TO_HTYPE(hKey) == SIGPUBKEY_HANDLE)
        {
            fSigKey = TRUE;
            szPrompt = g_Strings.pwszExportPrivSig;
            pPublicKey = (BSAFE_PUB_KEY*)pTmpUser->ContInfo.pbSigPub;
            PubKeyLen = pTmpUser->ContInfo.ContLens.cbSigPub;
        }
        else if (HNTAG_TO_HTYPE(hKey) == EXCHPUBKEY_HANDLE)
        {
            fSigKey = FALSE;
            szPrompt = g_Strings.pwszExportPrivExch;
            pPublicKey = (BSAFE_PUB_KEY*)pTmpUser->ContInfo.pbExchPub;
            PubKeyLen = pTmpUser->ContInfo.ContLens.cbExchPub;
        }
        else
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        // make sure the public key is available and appropriate
        if ((pPublicKey == NULL)
            || (PubKeyLen != pTmpKey->cbKeyLen)
            || (0 != memcmp((PBYTE)pPublicKey, pTmpKey->pKeyValue, PubKeyLen)))
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        GetLengthOfPrivateKeyForExport(pPublicKey, &cbPrivateBlob);

        if (hPubKey)
        {
            if (!CPGetKeyParam(hUID, hPubKey, KP_BLOCKLEN,
                               (PBYTE)&dwBlockLen, &cb, 0))
            {
                dwReturn = (DWORD)NTE_BAD_KEY;
                goto ErrorExit;
            }

            // convert to byte count
            dwBlockLen /= 8;
        }

        // Check user buffer size
        if (pbData == NULL)
        {
            *pdwDataLen = sizeof(BLOBHEADER) + cbPrivateBlob + dwBlockLen;
            dwReturn = ERROR_SUCCESS;
            goto ErrorExit;
        }
        else if (*pdwDataLen < (sizeof(BLOBHEADER)
                                + cbPrivateBlob + dwBlockLen))
        {
            *pdwDataLen = sizeof(BLOBHEADER) + cbPrivateBlob + dwBlockLen;
            dwReturn = ERROR_MORE_DATA;
            goto ErrorExit;
        }

        // if the context being used is a Verify context then the key is not
        // in persisted storage and therefore is in memory
        if (0 == (pTmpUser->Rights & CRYPT_VERIFYCONTEXT))
        {
            // always read the private key from storage when exporting
            dwSts= UnprotectPrivKey(pTmpUser, szPrompt, fSigKey, TRUE);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts; // NTE_BAD_KEYSET
                goto ErrorExit;
            }
        }

        if (fSigKey)
        {
            PrvKeyLen = pTmpUser->SigPrivLen;
            pPrvKey = (BSAFE_PRV_KEY*)pTmpUser->pSigPrivKey;
            fExportable = pTmpUser->ContInfo.fSigExportable;
        }
        else
        {
            PrvKeyLen = pTmpUser->ExchPrivLen;
            pPrvKey = (BSAFE_PRV_KEY*)pTmpUser->pExchPrivKey;
            fExportable = pTmpUser->ContInfo.fExchExportable;
        }

        if (pPrvKey == NULL)
        {
            dwReturn = (DWORD)NTE_NO_KEY;
            goto ErrorExit;
        }

        if (!fExportable && (0 == (CRYPT_ARCHIVABLE & pTmpKey->Rights)))
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        if (!PreparePrivateKeyForExport(pPrvKey, NULL, &cbPrivateBlob))
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        // allocate memory for the private key blob
        cb = cbPrivateBlob + dwBlockLen;
        pbPrivateBlob = _nt_malloc(cb);
        if (NULL == pbPrivateBlob)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        if (!PreparePrivateKeyForExport(pPrvKey,
                                        pbPrivateBlob, &cbPrivateBlob))
        {
            // ?BUGBUG? Fix this
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        if (hPubKey)
        {
            dwSts = LocalEncrypt(hUID, hPubKey, 0, TRUE, 0, pbPrivateBlob,
                                 &cbPrivateBlob, cb, FALSE);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }

        dwLen = sizeof(BLOBHEADER) + cbPrivateBlob;
        CopyMemory(pbData + sizeof(BLOBHEADER), pbPrivateBlob, cbPrivateBlob);
        break;
    }

    case SIMPLEBLOB:
    {
        if (HNTAG_TO_HTYPE(hKey) != KEY_HANDLE)
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        if (0 == hPubKey)
        {
            dwReturn = (DWORD)NTE_NO_KEY;
            goto ErrorExit;
        }

        if (!FIsLegalKey(pTmpUser, pTmpKey, FALSE))
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

#ifdef CSP_USE_SSL3
        // if the SSL2_FALLBACK flag is set then make sure the key
        // is an SSL2 master key
        if (CRYPT_SSL2_FALLBACK & dwFlags)
        {
            if (CALG_SSL2_MASTER != pTmpKey->Algid)
            {
                dwReturn = (DWORD)NTE_BAD_KEY;
                goto ErrorExit;
            }
        }
#endif

        dwSts = NTLValidate((HNTAG)hPubKey, hUID, EXCHPUBKEY_HANDLE,
                            &pPubKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = (NTE_FAIL == dwSts) ? (DWORD)NTE_BAD_KEY : dwSts;
            goto ErrorExit;
        }

        pBsafePubKey = (BSAFE_PUB_KEY *) pPubKey->pKeyValue;
        if (pBsafePubKey == NULL)
        {
            dwReturn = (DWORD)NTE_NO_KEY;
            goto ErrorExit;
        }

        //
        // Subtract off 8 bytes for 2 extra DWORD needed by RSA code
        dwLen = sizeof(BLOBHEADER) + sizeof(NTSimpleBlob) +
                (pBsafePubKey->bitlen + 7) / 8;

        if (pbData == NULL || *pdwDataLen < dwLen)
        {
            *pdwDataLen = dwLen;    // set what we need
            if (pbData == NULL)
                dwReturn = ERROR_SUCCESS;
            else
                dwReturn = ERROR_MORE_DATA;
            goto ErrorExit;
        }

        pSimpleHeader = (NTSimpleBlob *) (pbData + sizeof(BLOBHEADER));
        pSimpleHeader->aiEncAlg = CALG_RSA_KEYX;

#ifdef USE_SGC
        // if this is the schannel provider and we are a verify context and
        // the SGC flags are set and the key is large then make sure the
        // key is the same as the SGC key
        if ((PROV_RSA_SCHANNEL == pTmpUser->dwProvType) &&
            (0 != pTmpUser->dwSGCFlags) &&
            (pTmpUser->Rights & CRYPT_VERIFYCONTEXT) &&
            (pBsafePubKey->bitlen > 1024))
        {
            if (!CheckSGCSimpleForExport(pTmpUser, pBsafePubKey))
            {
                dwReturn = (DWORD)NTE_BAD_KEY;
                goto ErrorExit;
            }
        }
#endif

        // perform the RSA encryption.
        dwSts = RSAEncrypt(pTmpUser, pBsafePubKey, pTmpKey->pKeyValue,
                           pTmpKey->cbKeyLen, pTmpKey->pbParams,
                           pTmpKey->cbParams, dwFlags,
                           pbData + sizeof(BLOBHEADER) + sizeof(NTSimpleBlob));
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;
    }

    case OPAQUEKEYBLOB:
    {
        dwLen = *pdwDataLen;
        dwSts = ExportOpaqueBlob(pTmpKey, pbData, &dwLen);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        // if the destroy key flag is set then destroy the key
        if (CRYPT_DESTROYKEY & dwFlags)
        {
            if (!CPDestroyKey(hUID, hKey))
            {
                dwReturn = GetLastError();
                goto ErrorExit;
            }
        }

        break;
    }

    case SYMMETRICWRAPKEYBLOB:
    {
        // get a pointer to the symmetric key to wrap with (the variable
        // name pPubKey is a misnomer)
        dwSts = NTLValidate((HNTAG)hPubKey,
                            hUID,
                            HNTAG_TO_HTYPE(hKey),
                            &pPubKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = (NTE_FAIL == dwSts) ? (DWORD)NTE_BAD_KEY : dwSts;
            goto ErrorExit;
        }

        dwSts = WrapSymKey(pTmpUser, pTmpKey, pPubKey, pbData, pdwDataLen);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        dwLen = *pdwDataLen;
        break;
    }

    case PLAINTEXTKEYBLOB:
    {
        if (HNTAG_TO_HTYPE(hKey) != KEY_HANDLE)
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        if (! FIsLegalKey(pTmpUser, pTmpKey, FALSE))
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        dwLen = sizeof(BLOBHEADER) + sizeof(DWORD) + pTmpKey->cbKeyLen;
        
        if (NULL == pbData || *pdwDataLen < dwLen)
        {
            *pdwDataLen = dwLen;
            if (NULL == pbData)
                dwReturn = ERROR_SUCCESS;
            else
                dwReturn = ERROR_MORE_DATA;
            goto ErrorExit;
        }

        pbData += sizeof(BLOBHEADER);
        *((DWORD*)pbData) = pTmpKey->cbKeyLen;
        pbData += sizeof(DWORD);
        memcpy(pbData, pTmpKey->pKeyValue, pTmpKey->cbKeyLen);
        *pdwDataLen = dwLen;
        break;
    }

    default:
        dwReturn = (DWORD)NTE_BAD_TYPE;
        goto ErrorExit;
    }

    // set the size of the key blob
    *pdwDataLen = dwLen;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (pbPrivateBlob)
        _nt_free(pbPrivateBlob, cb);
    if (!fRet)
        SetLastError(dwReturn);
    return fRet;
}


/*static*/ DWORD
ImportOpaqueBlob(
    HCRYPTPROV hUID,
    CONST BYTE *pbData,
    DWORD cbData,
    HCRYPTKEY *phKey)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGKeyList    pTmpKey = NULL;
    PNTAGPackedKeyList pPackedKey;
    DWORD           cbRequired;
    DWORD           dwSts;

    *phKey = 0;

    // allocate a temporary key structure
    pTmpKey = (PNTAGKeyList)_nt_malloc(sizeof(NTAGKeyList));
    if (NULL == pTmpKey)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    // make sure we have enough data
    cbRequired = sizeof(BLOBHEADER) +
                 sizeof(NTAGPackedKeyList);

    if (cbData < cbRequired)
    {
        dwReturn = (DWORD)NTE_BAD_DATA;
        goto ErrorExit;
    }

    // build key structure from packed key structure
    pPackedKey = (PNTAGPackedKeyList)(pbData + sizeof(BLOBHEADER));

    pTmpKey->hUID               = hUID;
    pTmpKey->Algid              = pPackedKey->Algid;
    pTmpKey->Rights             = pPackedKey->Rights;
    pTmpKey->cbKeyLen           = pPackedKey->cbKeyLen;
    pTmpKey->cbDataLen          = pPackedKey->cbDataLen;
    memcpy(pTmpKey->IV, pPackedKey->IV, sizeof(pTmpKey->IV));
    memcpy(pTmpKey->FeedBack, pPackedKey->FeedBack, sizeof(pTmpKey->FeedBack));
    pTmpKey->InProgress         = pPackedKey->InProgress;
    pTmpKey->cbSaltLen          = pPackedKey->cbSaltLen;
    memcpy(pTmpKey->rgbSalt, pPackedKey->rgbSalt, sizeof(pTmpKey->rgbSalt));
    pTmpKey->Padding            = pPackedKey->Padding;
    pTmpKey->Mode               = pPackedKey->Mode;
    pTmpKey->ModeBits           = pPackedKey->ModeBits;
    pTmpKey->Permissions        = pPackedKey->Permissions;
    pTmpKey->EffectiveKeyLen    = pPackedKey->EffectiveKeyLen;
    pTmpKey->dwBlockLen         = pPackedKey->dwBlockLen;

    // make sure we still have enough data
    cbRequired += pTmpKey->cbKeyLen +
                  pTmpKey->cbDataLen;

    if (cbData < cbRequired)
    {
        dwReturn = (DWORD)NTE_BAD_DATA;
        goto ErrorExit;
    }

    // allocate memory and copy the key value
    if (0 < pTmpKey->cbKeyLen)
    {
        pTmpKey->pKeyValue = _nt_malloc(pTmpKey->cbKeyLen);
        if (NULL == pTmpKey->pKeyValue)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        memcpy(pTmpKey->pKeyValue,
               (PBYTE)pPackedKey + sizeof(NTAGPackedKeyList),
               pTmpKey->cbKeyLen);
    }

    // allocate memory and copy the key data
    if (0 < pTmpKey->cbDataLen)
    {
        pTmpKey->pData = _nt_malloc(pTmpKey->cbDataLen);
        if (NULL == pTmpKey->pData)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        memcpy(pTmpKey->pData,
               (PBYTE)pPackedKey + sizeof(NTAGPackedKeyList) + pTmpKey->cbKeyLen,
               pTmpKey->cbDataLen);
    }

    dwSts = NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    pTmpKey = NULL;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pTmpKey)
        FreeNewKey(pTmpKey);
    return dwReturn;
}


/*
 -  CPImportKey
 -
 *  Purpose:
 *                Import cryptographic keys
 *
 *
 *  Parameters:
 *               IN  hUID      -  Handle to the CSP user
 *               IN  pbData    -  Key blob data
 *               IN  dwDataLen -  Length of the key blob data
 *               IN  hPubKey   -  Handle to the exchange public key value of
 *                                the destination user
 *               IN  dwFlags   -  Flags values
 *               OUT phKey     -  Pointer to the handle to the key which was
 *                                Imported
 *
 *  Returns:
 */

BOOL WINAPI
CPImportKey(
    IN HCRYPTPROV hUID,
    IN CONST BYTE *pbData,
    IN DWORD dwDataLen,
    IN HCRYPTKEY hPubKey,
    IN DWORD dwFlags,
    OUT HCRYPTKEY *phKey)
{
    // Status return variables
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    BOOL            fRet;

    // miscellaneous variables
    DWORD           KeyBufLen;
    CONST BYTE      *pbEncPortion;
    BLOBHEADER      *ThisStdHeader = (BLOBHEADER *)pbData;
    BSAFE_PRV_KEY   *pBsafePrvKey = NULL;
    BYTE            *pKeyBuf = NULL;
    DWORD           dwRights = 0;
    DWORD           cbTmpLen;
    DWORD           dwSts;

    // temporary variables for pointing to user and key records
    PNTAGUserList   pTmpUser = NULL;
    PNTAGKeyList    pTmpKey = NULL;
    LPWSTR          szPrompt;
    BLOBHEADER      *pPublic;
    RSAPUBKEY       *pImpPubKey;
    BSAFE_PUB_KEY   *pBsafePubKey;
    PBYTE           pbData2 = NULL;
    DWORD           cb;
    DWORD           *pcbPub;
    BYTE            **ppbPub;
    DWORD           *pcbPrv;
    BYTE            **ppbPrv;
    BOOL            *pfExportable;
    BOOL            fExch;
    PEXPORT_PRV_KEY pExportKey;
    BOOL            fPubKey = FALSE;
    NTSimpleBlob    *ThisSB;
    PNTAGKeyList    pExPubKey = NULL;
    BOOL            fInCritSec = FALSE;
    BYTE            *pbParams = NULL;
    DWORD           cbParams = 0;
    BOOL            fAllowBigRC2Key = FALSE;

    EntryPoint
    // Validate user pointer
    //    count = *phKey;

    if ((dwFlags & ~(CRYPT_USER_PROTECTED | CRYPT_EXPORTABLE |
                     CRYPT_NO_SALT | CRYPT_SGCKEY | CRYPT_OAEP |
                     CRYPT_IPSEC_HMAC_KEY)) != 0)
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    if ((PUBLICKEYBLOB == ThisStdHeader->bType) && (0 != hPubKey))
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    // check the user identification
    pTmpUser = (PNTAGUserList)NTLCheckList((HNTAG)hUID, USER_HANDLE);
    if (NULL == pTmpUser)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    if (ThisStdHeader->bVersion != CUR_BLOB_VERSION)
    {
        dwReturn = (DWORD)NTE_BAD_VER;
        goto ErrorExit;
    }

    // Handy pointer for decrypting the blob...
    pbEncPortion = pbData + sizeof(BLOBHEADER) + sizeof(NTSimpleBlob);

    // determine which key blob is being imported
    switch (ThisStdHeader->bType)
    {
    case PUBLICKEYBLOB:
        pPublic = (BLOBHEADER *) pbData;
        pImpPubKey = (RSAPUBKEY *)(pbData+sizeof(BLOBHEADER));

        if ((pPublic->aiKeyAlg != CALG_RSA_KEYX) &&
            (pPublic->aiKeyAlg != CALG_RSA_SIGN))
        {
            dwReturn =(DWORD)NTE_BAD_DATA;
            goto ErrorExit;
        }

        cbTmpLen = (sizeof(DWORD) * 2) -
                   (((pImpPubKey->bitlen + 7) / 8) % (sizeof(DWORD) * 2));
        if ((sizeof(DWORD) * 2) != cbTmpLen)
            cbTmpLen += sizeof(DWORD) * 2;
        dwSts = MakeNewKey(pPublic->aiKeyAlg,
                           0,
                           sizeof(BSAFE_PUB_KEY)
                               + (pImpPubKey->bitlen / 8)
                               + cbTmpLen,
                           hUID,
                           0,
                           FALSE,
                           TRUE,
                           &pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        pBsafePubKey = (BSAFE_PUB_KEY *)pTmpKey->pKeyValue;
        pBsafePubKey->magic = pImpPubKey->magic;
        pBsafePubKey->keylen = (pImpPubKey->bitlen / 8) + cbTmpLen;
        pBsafePubKey->bitlen = pImpPubKey->bitlen;
        pBsafePubKey->datalen = (pImpPubKey->bitlen+7)/8 - 1;
        pBsafePubKey->pubexp = pImpPubKey->pubexp;

        memset((BYTE *) pBsafePubKey + sizeof(BSAFE_PUB_KEY),
               '\0', pBsafePubKey->keylen);

        memcpy((BYTE *) pBsafePubKey + sizeof(BSAFE_PUB_KEY),
               (BYTE *) pPublic + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY),
               (pImpPubKey->bitlen+7)/8);

        dwSts = NTLMakeItem(phKey,
                            (BYTE) (pPublic->aiKeyAlg == CALG_RSA_KEYX
                                    ? EXCHPUBKEY_HANDLE
                                    : SIGPUBKEY_HANDLE),
                            (void *)pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;

    case PRIVATEKEYBLOB:
        // wrap with a try since there is a critical section in here
        __try
        {
            EnterCriticalSection(&pTmpUser->CritSec);
            fInCritSec = TRUE;

            pPublic = (BLOBHEADER *) pbData;
            cb = dwDataLen - sizeof(BLOBHEADER);
            pbData2 = _nt_malloc(cb);
            if (NULL == pbData2)
            {
                dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorExit;
            }

            CopyMemory(pbData2, pbData + sizeof(BLOBHEADER), cb);
            if (hPubKey)
            {
                dwSts = LocalDecrypt(hUID, hPubKey, 0, TRUE, 0,
                                     pbData2, &cb, FALSE);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }
            }

            if (pPublic->aiKeyAlg == CALG_RSA_KEYX)
            {
                if (PROV_RSA_SIG == pTmpUser->dwProvType)
                {
                    dwReturn = (DWORD)NTE_BAD_DATA;
                    goto ErrorExit;
                }
                pcbPub = &pTmpUser->ContInfo.ContLens.cbExchPub;
                ppbPub = &pTmpUser->ContInfo.pbExchPub;
                pcbPrv = &pTmpUser->ExchPrivLen;
                ppbPrv = &pTmpUser->pExchPrivKey;
                pfExportable = &pTmpUser->ContInfo.fExchExportable;
                fExch = TRUE;
                szPrompt = g_Strings.pwszImportPrivExch;
            }
            else if (pPublic->aiKeyAlg == CALG_RSA_SIGN)
            {
                if (PROV_RSA_SCHANNEL == pTmpUser->dwProvType)
                {
                    dwReturn = (DWORD)NTE_BAD_DATA;
                    goto ErrorExit;
                }
                pcbPub = &pTmpUser->ContInfo.ContLens.cbSigPub;
                ppbPub = &pTmpUser->ContInfo.pbSigPub;
                pcbPrv = &pTmpUser->SigPrivLen;
                ppbPrv = &pTmpUser->pSigPrivKey;
                fExch = FALSE;
                pfExportable = &pTmpUser->ContInfo.fSigExportable;
                szPrompt = g_Strings.pwszImportPrivSig;
            }
            else
            {
                dwReturn = (DWORD)NTE_BAD_DATA;
                goto ErrorExit;
            }

            // check the length of the key exchange key
            pExportKey = (PEXPORT_PRV_KEY)pbData2;

#ifdef USE_SGC
            // check if the provider is an SChannel provider and if so if the
            // SGC flag is set then use the FIsLegalSGCKeySize function
            if ((PROV_RSA_SCHANNEL == pTmpUser->dwProvType)
                && (!(pTmpUser->Rights & CRYPT_VERIFYCONTEXT))
                && (0 != pTmpUser->dwSGCFlags)) // make sure this is server side
            {
                if (!FIsLegalSGCKeySize(pPublic->aiKeyAlg,
                                        pExportKey->bitlen / 8,
                                        FALSE, FALSE, &fPubKey))
                {
                    dwReturn = (DWORD)NTE_BAD_DATA;
                    goto ErrorExit;
                }
            }
            else
#endif
            {
                if (!FIsLegalKeySize(pTmpUser->dwCspTypeId,
                                     pPublic->aiKeyAlg,
                                     pExportKey->bitlen / 8,
                                     FALSE, &fPubKey))
                {
                    dwReturn = (DWORD)NTE_BAD_DATA;
                    goto ErrorExit;
                }
            }

            if (!fPubKey)
            {
                dwReturn = (DWORD)NTE_BAD_DATA;
                goto ErrorExit;
            }

            if (*ppbPub)
            {
                ASSERT(*pcbPub);
                ASSERT(*pcbPrv);
                ASSERT(*ppbPrv);

                _nt_free(*ppbPub, *pcbPub);
                *ppbPub = NULL;
                *pcbPub = 0;

                _nt_free(*ppbPrv, *pcbPrv);
                *ppbPrv = NULL;
                *pcbPrv = 0;
            }

            if (!PreparePrivateKeyForImport(pbData2, NULL, pcbPrv,
                                            NULL, pcbPub))
            {
                dwReturn = (DWORD)NTE_BAD_DATA;
                goto ErrorExit;
            }

            *ppbPub = _nt_malloc(*pcbPub);
            if (NULL == *ppbPub)
            {
                dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorExit;
            }

            *ppbPrv = _nt_malloc(*pcbPrv);
            if (NULL == *ppbPrv)
            {
                dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorExit;
            }

            if (!PreparePrivateKeyForImport(pbData2,
                                            (LPBSAFE_PRV_KEY)*ppbPrv,
                                            pcbPrv,
                                            (LPBSAFE_PUB_KEY)*ppbPub,
                                            pcbPub))
            {
                dwReturn = (DWORD)NTE_BAD_DATA;
                goto ErrorExit;
            }

            if (dwFlags & CRYPT_EXPORTABLE)
                *pfExportable = TRUE;
            else
                *pfExportable = FALSE;

            // test the RSA key to make sure it works
            dwSts = EncryptAndDecryptWithRSAKey(*ppbPub, *ppbPrv,
                                                TRUE, FALSE);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;   // NTE_BAD_DATA
                goto ErrorExit;
            }

            dwSts = EncryptAndDecryptWithRSAKey(*ppbPub, *ppbPrv,
                                                FALSE, FALSE);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;   // NTE_BAD_DATA
                goto ErrorExit;
            }

            // if the context being used is a Verify Context then the key
            // is not persisted to storage
            if (0 == (pTmpUser->Rights & CRYPT_VERIFYCONTEXT))
            {
                // write the new keys to the user storage file
                dwSts = ProtectPrivKey(pTmpUser, szPrompt, dwFlags, (!fExch));
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }
            }

            if (!CPGetUserKey(hUID,
                              (fExch ? AT_KEYEXCHANGE : AT_SIGNATURE),
                              phKey))
            {
                dwReturn = GetLastError();
                goto ErrorExit;
            }
        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            // ?BUGBUG? No it's not!
            dwReturn = ERROR_INVALID_PARAMETER;
            goto ErrorExit;
        }
        break;

    case SIMPLEBLOB:
        ThisSB = (NTSimpleBlob *) (pbData + sizeof(BLOBHEADER));

        if (!ValidKeyAlgid(pTmpUser, ThisStdHeader->aiKeyAlg))
        {
            dwReturn = (DWORD)NTE_BAD_TYPE;
            goto ErrorExit;
        }

        if (ThisSB->aiEncAlg != CALG_RSA_KEYX)
        {
            dwReturn = (DWORD)NTE_BAD_ALGID;
            goto ErrorExit;
        }

        // if the import key handle is not zero make sure it is the
        if (0 != hPubKey)
        {
            dwSts = NTLValidate((HNTAG)hPubKey,
                                hUID,
                                HNTAG_TO_HTYPE((HNTAG)hPubKey),
                                &pExPubKey);
            if (ERROR_SUCCESS != dwSts)
            {
                // NTLValidate doesn't know what error to set
                // so it set NTE_FAIL -- fix it up.
                dwReturn = (dwSts == NTE_FAIL) ?(DWORD)NTE_BAD_KEY : dwSts;
                goto ErrorExit;
            }

            if ((pTmpUser->ContInfo.ContLens.cbExchPub != pExPubKey->cbKeyLen)
                || (0 != memcmp((PBYTE)pExPubKey->pKeyValue,
                                pTmpUser->ContInfo.pbExchPub,
                                pExPubKey->cbKeyLen)))
            {
                dwReturn = (DWORD)NTE_BAD_KEY;
                goto ErrorExit;
            }

            pbParams = pExPubKey->pbParams;
            cbParams = pExPubKey->cbParams;
        }

        pBsafePubKey = (BSAFE_PUB_KEY *)pTmpUser->ContInfo.pbExchPub;
        if (NULL == pBsafePubKey)
        {
            dwReturn = (DWORD)NTE_NO_KEY;
            goto ErrorExit;
        }

#ifdef USE_SGC
        // check if the provider is an SChannel provider and if so if the
        // SGC flag is set then use the FIsLegalSGCKeySize function
        if ((PROV_RSA_SCHANNEL == pTmpUser->dwProvType)
            && (!(pTmpUser->Rights & CRYPT_VERIFYCONTEXT))
            && (0 != pTmpUser->dwSGCFlags)) // make sure this is server side
        {
            if (!FIsLegalSGCKeySize(CALG_RSA_KEYX,
                                    pBsafePubKey->bitlen / 8,
                                    FALSE, FALSE, &fPubKey))
            {
                dwReturn = (DWORD)NTE_BAD_DATA;
                goto ErrorExit;
            }
        }
        else
#endif
        {
            if (!FIsLegalKeySize(pTmpUser->dwCspTypeId,
                                 CALG_RSA_KEYX,
                                 pBsafePubKey->bitlen / 8,
                                 FALSE, &fPubKey))
            {
                dwReturn = (DWORD)NTE_BAD_DATA;
                goto ErrorExit;
            }
        }

        // get the key to use
        dwSts = UnprotectPrivKey(pTmpUser, g_Strings.pwszImportSimple,
                                 FALSE, FALSE);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;   // NTE_NO_KEY
            goto ErrorExit;
        }

        pBsafePrvKey = (BSAFE_PRV_KEY *)pTmpUser->pExchPrivKey;
        if (NULL == pBsafePrvKey)
        {
            dwReturn = (DWORD)NTE_NO_KEY;
            goto ErrorExit;
        }

        // Check the input data length
        if ((dwDataLen - (sizeof(BLOBHEADER) + sizeof(NTSimpleBlob)))
            < ((pBsafePrvKey->bitlen + 7) / 8))
        {
            dwReturn = (DWORD)NTE_BAD_DATA;
            goto ErrorExit;
        }

        // perform the RSA decryption
        dwSts = RSADecrypt(pTmpUser, pBsafePrvKey,
                           pbData + sizeof(BLOBHEADER) + sizeof(NTSimpleBlob),
                           dwDataLen - (sizeof(BLOBHEADER) + sizeof(NTSimpleBlob)),
                           pbParams, cbParams, dwFlags,
                           &pKeyBuf, &KeyBufLen);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        // check if the key is CRYPT_EXPORTABLE
        if (dwFlags & CRYPT_EXPORTABLE)
            dwRights = CRYPT_EXPORTABLE;

#ifdef CSP_USE_SSL3
        // if SSL3 or TLS1 master key then check the version
        if (CALG_SSL3_MASTER == ThisStdHeader->aiKeyAlg ||
            CALG_TLS1_MASTER == ThisStdHeader->aiKeyAlg)
        {
            if (MAKEWORD(pKeyBuf[1], pKeyBuf[0]) < 0x300)
            {
                dwReturn = (DWORD)NTE_BAD_DATA;
                goto ErrorExit;
            }
        }
#endif // CSP_USE_SSL3

        dwSts = MakeNewKey(ThisStdHeader->aiKeyAlg, dwRights, KeyBufLen,
                           hUID, pKeyBuf, TRUE, TRUE, &pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        pKeyBuf = NULL;

        // check keylength...
        if (!FIsLegalImportSymKey(pTmpUser, pTmpKey, TRUE))
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        dwSts = NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        // if 40 bit key + no mention of salt, set zeroized salt for
        // RSABase compatibility
        if ((5 == KeyBufLen)
            && (0 == (dwFlags & CRYPT_NO_SALT))
            && (CALG_SSL2_MASTER != ThisStdHeader->aiKeyAlg))
        {
            dwSts = MakeKeyRSABaseCompatible(hUID, *phKey);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }
        break;

    case OPAQUEKEYBLOB:
        dwSts = ImportOpaqueBlob(hUID, pbData, dwDataLen, phKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;

    case SYMMETRICWRAPKEYBLOB:
        // get a pointer to the symmetric key to unwrap with (the variable
        // name pExPubKey is a misnomer)
        dwSts = NTLValidate((HNTAG)hPubKey, hUID,
                            HNTAG_TO_HTYPE((HNTAG)hPubKey),
                            &pExPubKey);
        if (ERROR_SUCCESS != dwSts)
        {
            // NTLValidate doesn't know what error to set
            // so it set NTE_FAIL -- fix it up.
            dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_KEY : dwSts;
            goto ErrorExit;
        }

        dwSts = UnWrapSymKey(hUID, pTmpUser, pExPubKey, (BYTE*)pbData,
                             dwDataLen, dwFlags, phKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        break;

    case PLAINTEXTKEYBLOB:
        if (! ValidKeyAlgid(pTmpUser, ThisStdHeader->aiKeyAlg))
        {
            dwReturn = (DWORD)NTE_BAD_ALGID;
            goto ErrorExit;
        }

        // check if the key is CRYPT_EXPORTABLE
        if (dwFlags & CRYPT_EXPORTABLE)
            dwRights = CRYPT_EXPORTABLE;

        KeyBufLen = *((DWORD*)(pbData + sizeof(BLOBHEADER)));
        dwSts = MakeNewKey( ThisStdHeader->aiKeyAlg, dwRights, 
                            KeyBufLen, hUID, 
                            (BYTE *) (pbData + sizeof(BLOBHEADER) + sizeof(DWORD)),
                            FALSE, TRUE, &pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        if (CRYPT_IPSEC_HMAC_KEY & dwFlags)
            fAllowBigRC2Key = TRUE;

        if (! FIsLegalImportSymKey(pTmpUser, pTmpKey, fAllowBigRC2Key))
        {
            dwReturn = (DWORD)NTE_BAD_DATA;
            goto ErrorExit;
        }
        
        dwSts = NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        
        // if 40 bit key + no mention of salt, set zeroized salt for
        // RSABase compatibility
        if ((5 == KeyBufLen)
            && (0 == (dwFlags & CRYPT_NO_SALT))
            && (CALG_SSL2_MASTER != ThisStdHeader->aiKeyAlg))
        {
            dwSts = MakeKeyRSABaseCompatible(hUID, *phKey);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }
        break;

    default:
        dwReturn = (DWORD)NTE_BAD_TYPE;
        goto ErrorExit;
    }

    pTmpKey = NULL;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (fInCritSec)
        LeaveCriticalSection(&pTmpUser->CritSec);
    if (pKeyBuf)
        _nt_free(pKeyBuf, KeyBufLen);
    if (pbData2)
        _nt_free(pbData2, dwDataLen - sizeof(BLOBHEADER));
    if (NULL != pTmpKey)
        FreeNewKey(pTmpKey);
    if (!fRet)
        SetLastError(dwReturn);
    return fRet;
}


/*
 -  CPInflateKey
 -
 *  Purpose:
 *                Use to "inflate" (expand) a cryptographic key for use with
 *                the CryptEncrypt and CryptDecrypt functions
 *
 *  Parameters:
 *               IN      hUID    -  Handle to a CSP
 *               IN      hKey    -  Handle to a key
 *               IN      dwFlags -  Flags values
 *
 *  Returns:
 */

DWORD
InflateKey(
    IN PNTAGKeyList pTmpKey)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BYTE    *pbRealKey = NULL;

    // if space for the key table has been allocated previously
    // then free it
    if (pTmpKey->pData != NULL)
    {
        ASSERT(0 != pTmpKey->cbDataLen);
        _nt_free(pTmpKey->pData, pTmpKey->cbDataLen);
        pTmpKey->cbDataLen = 0;
    }
    else
    {
        ASSERT(pTmpKey->cbDataLen == 0);
    }

    // determine the algorithm to be used
    switch (pTmpKey->Algid)
    {
#ifdef CSP_USE_RC2
    case CALG_RC2:
        pTmpKey->pData = (BYTE *)_nt_malloc(RC2_TABLESIZE);
        if (NULL == pTmpKey->pData)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            return NTF_FAILED;
        }

        pbRealKey = (BYTE *)_nt_malloc(pTmpKey->cbKeyLen
                                       + pTmpKey->cbSaltLen);
        if (NULL == pbRealKey)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        memcpy(pbRealKey, pTmpKey->pKeyValue, pTmpKey->cbKeyLen);
        memcpy(pbRealKey+pTmpKey->cbKeyLen, pTmpKey->rgbSalt,
               pTmpKey->cbSaltLen);
        pTmpKey->cbDataLen = RC2_TABLESIZE;

        RC2KeyEx((WORD *)pTmpKey->pData,
                 pbRealKey,
                 pTmpKey->cbKeyLen + pTmpKey->cbSaltLen,
                 pTmpKey->EffectiveKeyLen);
        break;
#endif

#ifdef CSP_USE_RC4
    case CALG_RC4:
        pTmpKey->pData = (BYTE *)_nt_malloc(sizeof(RC4_KEYSTRUCT));
        if (NULL == pTmpKey->pData)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        pbRealKey = (BYTE *)_nt_malloc(pTmpKey->cbKeyLen
                                       + pTmpKey->cbSaltLen);
        if (NULL == pbRealKey)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        memcpy(pbRealKey, pTmpKey->pKeyValue, pTmpKey->cbKeyLen);
        memcpy(pbRealKey+pTmpKey->cbKeyLen, pTmpKey->rgbSalt,
               pTmpKey->cbSaltLen);
        pTmpKey->cbDataLen = sizeof(RC4_KEYSTRUCT);
        rc4_key((struct RC4_KEYSTRUCT *)pTmpKey->pData,
                pTmpKey->cbKeyLen+pTmpKey->cbSaltLen,
                pbRealKey);
        break;
#endif

#ifdef CSP_USE_DES
    case CALG_DES:
        pTmpKey->pData = (BYTE *)_nt_malloc(DES_TABLESIZE);
        if (NULL == pTmpKey->pData)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        pTmpKey->cbDataLen = DES_TABLESIZE;
        deskey((DESTable *)pTmpKey->pData, pTmpKey->pKeyValue);
        break;
#endif

#ifdef CSP_USE_3DES
    case CALG_3DES_112:
        pTmpKey->pData = (BYTE *)_nt_malloc(DES3_TABLESIZE);
        if (NULL == pTmpKey->pData)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        pTmpKey->cbDataLen = DES3_TABLESIZE;
        tripledes2key((PDES3TABLE)pTmpKey->pData, pTmpKey->pKeyValue);
        break;

    case CALG_3DES:
        pTmpKey->pData = (BYTE *)_nt_malloc(DES3_TABLESIZE);
        if (NULL == pTmpKey->pData)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        pTmpKey->cbDataLen = DES3_TABLESIZE;
        tripledes3key((PDES3TABLE)pTmpKey->pData, pTmpKey->pKeyValue);
        break;
#endif

#ifdef CSP_USE_SSL3
    case CALG_SSL3_MASTER:
    case CALG_PCT1_MASTER:
    case CALG_SCHANNEL_MAC_KEY:
        break;
#endif

#ifdef CSP_USE_AES
    case CALG_AES_128:
        pTmpKey->pData = (BYTE *)_nt_malloc(AES_TABLESIZE);
        if (NULL == pTmpKey->pData)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        pTmpKey->cbDataLen = AES_TABLESIZE;
        aeskey((AESTable *)pTmpKey->pData, pTmpKey->pKeyValue, CRYPT_AES128_ROUNDS);
        break;
    
    case CALG_AES_192:
        pTmpKey->pData = (BYTE *)_nt_malloc(AES_TABLESIZE);
        if (NULL == pTmpKey->pData)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        pTmpKey->cbDataLen = AES_TABLESIZE;
        aeskey((AESTable *)pTmpKey->pData, pTmpKey->pKeyValue, CRYPT_AES192_ROUNDS);
        break;
    
    case CALG_AES_256:
        pTmpKey->pData = (BYTE *)_nt_malloc(AES_TABLESIZE);
        if (NULL == pTmpKey->pData)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        pTmpKey->cbDataLen = AES_TABLESIZE;
        aeskey((AESTable *)pTmpKey->pData, pTmpKey->pKeyValue, CRYPT_AES256_ROUNDS);
        break;
#endif

    default:
        dwReturn = (DWORD)NTE_BAD_TYPE;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pbRealKey)
        _nt_free(pbRealKey, pTmpKey->cbKeyLen + pTmpKey->cbSaltLen);
    return dwReturn;
}


/*
 -  CPDestroyKey
 -
 *  Purpose:
 *                Destroys the cryptographic key that is being referenced
 *                with the hKey parameter
 *
 *
 *  Parameters:
 *               IN      hUID   -  Handle to a CSP
 *               IN      hKey   -  Handle to a key
 *
 *  Returns:
 */

BOOL WINAPI
CPDestroyKey(
    IN HCRYPTPROV hUID,
    IN HCRYPTKEY hKey)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGKeyList    pTmpKey;
    BOOL            fRet;
    DWORD           dwSts;

    EntryPoint
    // check the user identification
    if (NULL == NTLCheckList((HNTAG)hUID, USER_HANDLE))
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    dwSts = NTLValidate((HNTAG)hKey, hUID, SIGPUBKEY_HANDLE, &pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwSts = NTLValidate((HNTAG)hKey, hUID, EXCHPUBKEY_HANDLE, &pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwSts = NTLValidate((HNTAG)hKey, hUID, KEY_HANDLE, &pTmpKey);
            if (ERROR_SUCCESS != dwSts)
            {
                // NTLValidate doesn't know what error to set
                // so it set NTE_FAIL -- fix it up.
                dwReturn = (dwSts == NTE_FAIL)
                           ? (DWORD)NTE_BAD_KEY
                           : dwSts;
                goto ErrorExit;
            }
        }
    }

    // Remove from internal list first so others can't get to it, then free.
    NTLDelete((HNTAG)hKey);

    // scrub the memory where the key information was held
    if (pTmpKey->pKeyValue)
    {
        ASSERT(pTmpKey->cbKeyLen);
        memnuke(pTmpKey->pKeyValue, pTmpKey->cbKeyLen);
        _nt_free(pTmpKey->pKeyValue, pTmpKey->cbKeyLen);
    }
    if (pTmpKey->pbParams)
        _nt_free(pTmpKey->pbParams, pTmpKey->cbParams);
    if (pTmpKey->pData)
    {
        ASSERT(pTmpKey->cbDataLen);
        if ((CALG_SSL3_MASTER == pTmpKey->Algid) ||
            (CALG_PCT1_MASTER == pTmpKey->Algid))
        {
            FreeSChKey((PSCH_KEY)pTmpKey->pData);
        }
        memnuke(pTmpKey->pData, pTmpKey->cbDataLen);
        _nt_free(pTmpKey->pData, pTmpKey->cbDataLen);
    }
    _nt_free(pTmpKey, sizeof(NTAGKeyList));

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (!fRet)
        SetLastError(dwReturn);
    return fRet;
}


/*
 -  CPGetUserKey
 -
 *  Purpose:
 *                Gets a handle to a permanent user key
 *
 *
 *  Parameters:
 *               IN  hUID       -  Handle to the user identifcation
 *               IN  dwWhichKey -  Specification of the key to retrieve
 *               OUT phKey      -  Pointer to key handle of retrieved key
 *
 *  Returns:
 */

BOOL WINAPI
CPGetUserKey(
    IN HCRYPTPROV hUID,
    IN DWORD dwWhichKey,
    OUT HCRYPTKEY *phKey)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGUserList   pUser;
    PNTAGKeyList    pTmpKey;
    ALG_ID          Algid;
    DWORD           cb;
    BYTE            *pb;
    BYTE            bType;
    DWORD           dwExportability = 0;
    BOOL            fRet;
    DWORD           dwSts;

    EntryPoint
    // check the user identification
    pUser = (PNTAGUserList)NTLCheckList(hUID, USER_HANDLE);
    if (NULL == pUser)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    switch (dwWhichKey)
    {
    case AT_KEYEXCHANGE:
        Algid = CALG_RSA_KEYX;
        cb = pUser->ContInfo.ContLens.cbExchPub;
        pb = pUser->ContInfo.pbExchPub;
        if (pUser->ContInfo.fExchExportable)
            dwExportability = CRYPT_EXPORTABLE;
        bType = EXCHPUBKEY_HANDLE;
        break;

    case AT_SIGNATURE:
        Algid = CALG_RSA_SIGN;
        cb = pUser->ContInfo.ContLens.cbSigPub;
        pb = pUser->ContInfo.pbSigPub;
        if (pUser->ContInfo.fSigExportable)
            dwExportability = CRYPT_EXPORTABLE;
        bType = SIGPUBKEY_HANDLE;
        break;

    default:
        dwReturn = (DWORD)NTE_BAD_KEY;
        goto ErrorExit;
    }

    if (!ValidKeyAlgid(pUser, Algid))
    {
        dwReturn = (DWORD)NTE_BAD_TYPE;
        goto ErrorExit;
    }

    if (0 == cb)
    {
        dwReturn = (DWORD)NTE_NO_KEY;
        goto ErrorExit;
    }

    dwSts = MakeNewKey(Algid, dwExportability, cb, hUID, pb, FALSE, FALSE,
                       &pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwSts = NTLMakeItem(phKey, bType, (void *)pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (!fRet)
        SetLastError(dwReturn);
    return fRet;
}


/*
 -  CPSetKeyParam
 -
 *  Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a key
 *
 *  Parameters:
 *               IN      hUID    -  Handle to a CSP
 *               IN      hKey    -  Handle to a key
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *  Returns:
 */

BOOL WINAPI
CPSetKeyParam(
    IN HCRYPTPROV hUID,
   IN HCRYPTKEY hKey,
   IN DWORD dwParam,
   IN CONST BYTE *pbData,
   IN DWORD dwFlags)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGUserList       pTmpUser;
    PNTAGKeyList        pTmpKey;
    PCRYPT_DATA_BLOB    psData;
    DWORD               *pdw;
    DWORD               dw;
    BOOL                fRet;
    DWORD               dwSts;

    EntryPoint
    if ((dwFlags & ~CRYPT_SERVER) != 0)
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    // check the user identification
    pTmpUser = (PNTAGUserList)NTLCheckList(hUID, USER_HANDLE);
    if (NULL == pTmpUser)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    dwSts = NTLValidate((HNTAG)hKey, hUID, KEY_HANDLE, &pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwSts = NTLValidate((HNTAG)hKey, hUID, SIGPUBKEY_HANDLE, &pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwSts = NTLValidate((HNTAG)hKey, hUID,
                                EXCHPUBKEY_HANDLE, &pTmpKey);
            if (ERROR_SUCCESS != dwSts)
            {
                // NTLValidate doesn't know what error to set
                // so it set NTE_FAIL -- fix it up.
                dwReturn = (dwSts == NTE_FAIL)
                           ? (DWORD)NTE_BAD_KEY
                           : dwSts;
                goto ErrorExit;
            }
        }
    }

    switch (dwParam)
    {
    case KP_IV:
        memcpy(pTmpKey->IV, pbData, RC2_BLOCKLEN);
        break;

    case KP_SALT:
        if ((CALG_RC2 != pTmpKey->Algid) && (CALG_RC4 != pTmpKey->Algid))
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        if (pbData == NULL)
        {
            dwReturn = ERROR_INVALID_PARAMETER;
            goto ErrorExit;
        }

        if ((POLICY_MS_DEF == pTmpUser->dwCspTypeId)
            || (POLICY_MS_STRONG == pTmpUser->dwCspTypeId))
        {
            pTmpKey->cbSaltLen = DEFAULT_WEAK_SALT_LENGTH;
        }
        else
        {
            pTmpKey->cbSaltLen = DEFAULT_STRONG_SALT_LENGTH;
        }

        if (pTmpKey->cbSaltLen)
            CopyMemory(pTmpKey->rgbSalt, pbData, pTmpKey->cbSaltLen);

        dwSts = InflateKey(pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;

    case KP_SALT_EX:
        if ((CALG_RC2 != pTmpKey->Algid) && (CALG_RC4 != pTmpKey->Algid))
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        psData = (PCRYPT_DATA_BLOB)pbData;
        if (pbData == NULL)
        {
            dwReturn = ERROR_INVALID_PARAMETER;
            goto ErrorExit;
        }

        if (psData->cbData > MAX_SALT_LEN)
        {
            dwReturn = NTE_BAD_DATA;
            goto ErrorExit;
        }

        pTmpKey->cbSaltLen = psData->cbData;
        CopyMemory(pTmpKey->rgbSalt, psData->pbData, pTmpKey->cbSaltLen);

        dwSts = InflateKey(pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;

    case KP_PADDING:
        if (*((DWORD *) pbData) != PKCS5_PADDING)
        {
            dwReturn = (DWORD)NTE_BAD_DATA;
            goto ErrorExit;
        }
        break;

    case KP_MODE:
        if ((CALG_RSA_SIGN == pTmpKey->Algid) ||
            (CALG_RSA_KEYX == pTmpKey->Algid))
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        if (*pbData != CRYPT_MODE_CBC &&
            *pbData != CRYPT_MODE_ECB &&
            *pbData != CRYPT_MODE_CFB &&
            *pbData != CRYPT_MODE_OFB)
        {
            dwReturn = (DWORD)NTE_BAD_DATA;
            goto ErrorExit;
        }

        pTmpKey->Mode = *((DWORD *) pbData);
        break;

    case KP_MODE_BITS:
        dw = *((DWORD *) pbData);
        if ((dw == 0) || (dw > 64)) // if 0 or larger than the blocklength
        {
            dwReturn = (DWORD)NTE_BAD_DATA;
            goto ErrorExit;
        }

        pTmpKey->ModeBits = dw;
        break;

    case KP_PERMISSIONS:
    {
        DWORD dwPerm = *(LPDWORD)pbData;

        if (0 != (dwPerm & ~(CRYPT_ENCRYPT|CRYPT_DECRYPT|CRYPT_EXPORT|
                             CRYPT_READ|CRYPT_WRITE|CRYPT_MAC|CRYPT_ARCHIVE)))
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        // the exportability of a key may not be changed, but it may be ignored.
        if (0 != (dwPerm & CRYPT_EXPORT)
            && 0 == (pTmpKey->Permissions & CRYPT_EXPORT))
        {
                dwReturn = (DWORD)NTE_BAD_DATA;
                goto ErrorExit;
            }
        if (0 != (dwPerm & CRYPT_ARCHIVE)
            && 0 == (pTmpKey->Permissions & CRYPT_ARCHIVE))
        {
                dwReturn = (DWORD)NTE_BAD_DATA;
                goto ErrorExit;
            }

        dwPerm &= ~(CRYPT_ARCHIVE | CRYPT_EXPORT);
        dwPerm |= pTmpKey->Permissions & (CRYPT_ARCHIVE | CRYPT_EXPORT);
        pTmpKey->Permissions = dwPerm;
        break;
    }

    case KP_EFFECTIVE_KEYLEN:
        if (CALG_RC2 != pTmpKey->Algid)
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        pdw = (DWORD*)pbData;
        if (*pdw < RC2_MIN_EFFECTIVE_KEYLEN)
        {
            dwReturn = (DWORD)NTE_BAD_DATA;
            goto ErrorExit;
        }
        if (POLICY_MS_DEF == pTmpUser->dwCspTypeId)
        {
            if (*pdw > RC2_MAX_WEAK_EFFECTIVE_KEYLEN)
            {
                dwReturn = (DWORD)NTE_BAD_DATA;
                goto ErrorExit;
            }
        }
        else
        {
            if (*pdw > RC2_MAX_STRONG_EFFECTIVE_KEYLEN)
            {
                dwReturn = (DWORD)NTE_BAD_DATA;
                goto ErrorExit;
            }
        }

        pTmpKey->EffectiveKeyLen = *pdw;

        dwSts = InflateKey(pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;

#ifdef CSP_USE_SSL3
    case KP_CLIENT_RANDOM:
    case KP_SERVER_RANDOM:
    case KP_CERTIFICATE:
    case KP_CLEAR_KEY:
    case KP_SCHANNEL_ALG:
        if (PROV_RSA_SCHANNEL != pTmpUser->dwProvType)
        {
            dwReturn = (DWORD)NTE_BAD_TYPE;
            goto ErrorExit;
        }

        dwSts = SCHSetKeyParam(pTmpUser, pTmpKey, dwParam, pbData);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;
#endif // CSP_USE_SSL3

    case KP_OAEP_PARAMS:
        if (CALG_RSA_KEYX != pTmpKey->Algid)
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        psData = (PCRYPT_DATA_BLOB)pbData;
        if (pbData == NULL)
        {
            dwReturn = ERROR_INVALID_PARAMETER;
            goto ErrorExit;
        }

        // free salt if it already exists
        if (NULL != pTmpKey->pbParams)
        {
            _nt_free(pTmpKey->pbParams, pTmpKey->cbParams);
            pTmpKey->pbParams = NULL;
        }
        pTmpKey->cbParams = psData->cbData;

        // alloc variable size
        pTmpKey->pbParams = (BYTE *)_nt_malloc(pTmpKey->cbParams);
        if (NULL == pTmpKey->pbParams)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            pTmpKey->cbParams = 0;
            goto ErrorExit;
        }

        CopyMemory(pTmpKey->pbParams, psData->pbData, pTmpKey->cbParams);
        break;

#ifdef CSP_USE_SSL3
    case KP_HIGHEST_VERSION:
        if ((CALG_SSL3_MASTER != pTmpKey->Algid) &&
            (CALG_TLS1_MASTER != pTmpKey->Algid))
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        if (pbData == NULL)
        {
            dwReturn = ERROR_INVALID_PARAMETER;
            goto ErrorExit;
        }

        if (dwFlags & CRYPT_SERVER)
        {
            if ((CALG_SSL3_MASTER == pTmpKey->Algid)
                && (*(DWORD *)pbData >= 0x301))
            {
                // We're a server doing SSL3, and we also support TLS1.
                // If the pre_master_secret contains a version number
                // greater than or equal to TLS1, then abort the connection.
                if (MAKEWORD(pTmpKey->pKeyValue[1], pTmpKey->pKeyValue[0]) >= 0x301)
                {
                    dwReturn = (DWORD)NTE_BAD_VER;
                    goto ErrorExit;
                }
            }
        }
        else
        {
            pTmpKey->pKeyValue[0] = HIBYTE(*(DWORD *)pbData);
            pTmpKey->pKeyValue[1] = LOBYTE(*(DWORD *)pbData);
        }
        break;
#endif // CSP_USE_SSL3

    default:
        dwReturn = (DWORD)NTE_BAD_TYPE;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (!fRet)
        SetLastError(dwReturn);
    return fRet;
}


/*
 -  CPGetKeyParam
 -
 *  Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a key
 *
 *  Parameters:
 *               IN      hUID       -  Handle to a CSP
 *               IN      hKey       -  Handle to a key
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *  Returns:
 */

BOOL WINAPI
CPGetKeyParam(
    IN HCRYPTPROV hUID,
    IN HCRYPTKEY hKey,
    IN DWORD dwParam,
    IN BYTE *pbData,
    IN DWORD *pwDataLen,
    IN DWORD dwFlags)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGUserList   pTmpUser;
    PNTAGKeyList    pTmpKey;
    BSAFE_PUB_KEY   *pBsafePubKey;
    DWORD           *pdw;
    BOOL            fRet;
    DWORD           dwSts;

    EntryPoint
    if (dwFlags != 0)
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    // check the user identification
    pTmpUser = NTLCheckList((HNTAG)hUID, USER_HANDLE);
    if (NULL == pTmpUser)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    dwSts = NTLValidate((HNTAG)hKey, hUID, KEY_HANDLE, &pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwSts = NTLValidate((HNTAG)hKey, hUID, SIGPUBKEY_HANDLE, &pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwSts = NTLValidate((HNTAG)hKey, hUID,
                                EXCHPUBKEY_HANDLE, &pTmpKey);
            if (ERROR_SUCCESS != dwSts)
            {
                // NTLValidate doesn't know what error to set
                // so it set NTE_FAIL -- fix it up.
                dwReturn = (dwSts == NTE_FAIL)
                           ? (DWORD)NTE_BAD_KEY
                           : dwSts;
                goto ErrorExit;
            }
        }
    }

    if (pwDataLen == NULL)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    switch (dwParam)
    {
    case KP_IV:
        if (pbData == NULL || *pwDataLen < RC2_BLOCKLEN)
        {
            *pwDataLen = RC2_BLOCKLEN;
            if (pbData == NULL)
                dwReturn = ERROR_SUCCESS;
            else
                dwReturn = ERROR_MORE_DATA;
            goto ErrorExit;
        }
        memcpy(pbData, pTmpKey->IV, RC2_BLOCKLEN);
        *pwDataLen = RC2_BLOCKLEN;
        break;

    case KP_SALT:
        if ((CALG_RC2 != pTmpKey->Algid) && (CALG_RC4 != pTmpKey->Algid))
        {
            if ((CALG_DES == pTmpKey->Algid)
                || (CALG_3DES == pTmpKey->Algid)
                || (CALG_3DES_112 == pTmpKey->Algid))
            {
                *pwDataLen = 0;
                dwReturn = ERROR_SUCCESS;
                goto ErrorExit;
            }
            else
            {
                dwReturn = (DWORD)NTE_BAD_KEY;
                goto ErrorExit;
            }
        }

        if (pbData == NULL || (*pwDataLen < pTmpKey->cbSaltLen))
        {
            *pwDataLen = pTmpKey->cbSaltLen;
            if (pbData == NULL)
                dwReturn = ERROR_SUCCESS;
            else
                dwReturn = ERROR_MORE_DATA;
            goto ErrorExit;
        }

        CopyMemory(pbData, pTmpKey->rgbSalt, pTmpKey->cbSaltLen);
        *pwDataLen = pTmpKey->cbSaltLen;
        break;

    case KP_PADDING:
        if (pbData == NULL || *pwDataLen < sizeof(DWORD))
        {
            *pwDataLen = sizeof(DWORD);

            if (pbData == NULL)
                dwReturn = ERROR_SUCCESS;
            else
                dwReturn = ERROR_MORE_DATA;
            goto ErrorExit;
        }
        *((DWORD *) pbData) = PKCS5_PADDING;
        *pwDataLen = sizeof(DWORD);
        break;

    case KP_MODE:
        if (pbData == NULL || *pwDataLen < sizeof(DWORD))
        {
            *pwDataLen = sizeof(DWORD);
            if (pbData == NULL)
                dwReturn = ERROR_SUCCESS;
            else
                dwReturn = ERROR_MORE_DATA;
            goto ErrorExit;
        }
        *((DWORD *) pbData) = pTmpKey->Mode;
        *pwDataLen = sizeof(DWORD);
        break;

    case KP_MODE_BITS:
        if (pbData == NULL || *pwDataLen < sizeof(DWORD))
        {
            *pwDataLen = sizeof(DWORD);
            if (pbData == NULL)
                dwReturn = ERROR_SUCCESS;
            else
                dwReturn = ERROR_MORE_DATA;
            goto ErrorExit;
        }
        *((DWORD *)pbData) = pTmpKey->ModeBits;
        *pwDataLen = sizeof(DWORD);
        break;

    case KP_PERMISSIONS:
        if (pbData == NULL || *pwDataLen < sizeof(DWORD))
        {
            *pwDataLen = sizeof(DWORD);
            if (pbData == NULL)
                dwReturn = ERROR_SUCCESS;
            else
                dwReturn = ERROR_MORE_DATA;
            goto ErrorExit;
        }
        *((DWORD *) pbData) = pTmpKey->Permissions;
        *pwDataLen = sizeof(DWORD);
        break;

    case KP_ALGID:
        if (pbData == NULL || *pwDataLen < sizeof(ALG_ID))
        {
            *pwDataLen = sizeof(ALG_ID);
            if (pbData == NULL)
                dwReturn = ERROR_SUCCESS;
            else
                dwReturn = ERROR_MORE_DATA;
            goto ErrorExit;
        }
        *((ALG_ID *) pbData) = pTmpKey->Algid;
        *pwDataLen = sizeof(ALG_ID);
        break;

    case KP_KEYLEN:
        if (pbData == NULL || *pwDataLen < sizeof(DWORD))
        {
            *pwDataLen = sizeof(DWORD);
            if (pbData == NULL)
                dwReturn = ERROR_SUCCESS;
            else
                dwReturn = ERROR_MORE_DATA;
            goto ErrorExit;
        }

        // ALWAYS report keylen in BITS
        if ((HNTAG_TO_HTYPE(hKey) == SIGPUBKEY_HANDLE) ||
            (HNTAG_TO_HTYPE(hKey) == EXCHPUBKEY_HANDLE))
        {
            pBsafePubKey = (BSAFE_PUB_KEY *) pTmpKey->pKeyValue;
            if (pBsafePubKey == NULL)
            {
                dwReturn = (DWORD)NTE_NO_KEY;
                goto ErrorExit;
            }
            *((DWORD *) pbData) = pBsafePubKey->bitlen;
        }
        else
        {
            switch (pTmpKey->Algid)
            {
#ifdef CSP_USE_DES
            case CALG_DES:
                *((DWORD *) pbData) = (DES_KEYSIZE) * 8;
                break;
#endif
#ifdef CSP_USE_3DES
            case CALG_3DES_112:
                *((DWORD *) pbData) = (DES2_KEYSIZE) * 8;
                break;
            case CALG_3DES:
                *((DWORD *) pbData) = (DES3_KEYSIZE) * 8;
                break;
#endif
            default:
                *((DWORD *) pbData) = pTmpKey->cbKeyLen * 8;
            }
        }
        *pwDataLen = sizeof(DWORD);
        break;

    case KP_BLOCKLEN:
        if (pbData == NULL || *pwDataLen < sizeof(DWORD))
        {
            *pwDataLen = sizeof(DWORD);
            if (pbData == NULL)
                dwReturn = ERROR_SUCCESS;
            else
                dwReturn = ERROR_MORE_DATA;
            goto ErrorExit;
        }

        if ((HNTAG_TO_HTYPE(hKey) == SIGPUBKEY_HANDLE) ||
            (HNTAG_TO_HTYPE(hKey) == EXCHPUBKEY_HANDLE))
        {
            pBsafePubKey = (BSAFE_PUB_KEY *) pTmpKey->pKeyValue;
            if (pBsafePubKey == NULL)
            {
                dwReturn = (DWORD)NTE_NO_KEY;
                goto ErrorExit;
            }
            *(DWORD *)pbData = pBsafePubKey->bitlen;
            *pwDataLen = sizeof(DWORD);
        }
        else
        {
            switch (pTmpKey->Algid)
            {
#ifdef CSP_USE_RC2
            case CALG_RC2:
                *((DWORD *) pbData) = RC2_BLOCKLEN * 8;
                *pwDataLen = sizeof(DWORD);
                break;
#endif
#ifdef CSP_USE_DES
            case CALG_DES:
                *((DWORD *) pbData) = DES_BLOCKLEN * 8;
                *pwDataLen = sizeof(DWORD);
                break;
#endif
#ifdef CSP_USE_3DES
            case CALG_3DES_112:
            case CALG_3DES:
                *((DWORD *) pbData) = DES_BLOCKLEN * 8;
                *pwDataLen = sizeof(DWORD);
                break;
#endif
#ifdef CSP_USE_AES
            case CALG_AES_128:
            case CALG_AES_192:
            case CALG_AES_256:
                *((DWORD *) pbData) = pTmpKey->dwBlockLen * 8;
                *pwDataLen = sizeof(DWORD);
                break;
#endif
            default:
                *((DWORD *) pbData) = 0;
                *pwDataLen = sizeof(DWORD);
            }
        }
        break;

    case KP_EFFECTIVE_KEYLEN:
        if (CALG_RC2 != pTmpKey->Algid &&
            CALG_DES != pTmpKey->Algid &&
            CALG_3DES != pTmpKey->Algid &&
            CALG_3DES_112 != pTmpKey->Algid)
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        if (pbData == NULL || *pwDataLen < sizeof(DWORD))
        {
            *pwDataLen = sizeof(DWORD);
            if (pbData == NULL)
                dwReturn = ERROR_SUCCESS;
            else
                dwReturn = ERROR_MORE_DATA;
            goto ErrorExit;
        }

        *pwDataLen = sizeof(DWORD);
        pdw = (DWORD*)pbData;
        
        switch (pTmpKey->Algid)
        {
        case CALG_RC2:
            *pdw = pTmpKey->EffectiveKeyLen;
            break;
        case CALG_DES:
            *pdw = (DES_KEYSIZE - 1) * 8;
            break;
        case CALG_3DES_112:
            *pdw = (DES2_KEYSIZE - 2) * 8;
            break;
        case CALG_3DES:
            *pdw = (DES3_KEYSIZE - 3) * 8;
            break;
        }
        
        break;

    default:
        dwReturn = (DWORD)NTE_BAD_TYPE;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (!fRet)
        SetLastError(dwReturn);
    return fRet;
}


/*static*/ DWORD
DeletePersistedKey(
    PNTAGUserList pTmpUser,
    DWORD dwKeySpec)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    CHAR        *pszExport;
    CHAR        *pszPrivKey;
    CHAR        *pszPubKey;
    BOOL        fMachineKeySet = FALSE;
    DWORD       dwSts;

    if (pTmpUser->Rights & CRYPT_MACHINE_KEYSET)
        fMachineKeySet = TRUE;

    if (AT_SIGNATURE == dwKeySpec)
    {
        pszExport = "SExport";
        pszPrivKey = "SPvK";
        pszPubKey = "SPbK";
    }
    else if (AT_KEYEXCHANGE == dwKeySpec)
    {
        pszExport = "EExport";
        pszPrivKey = "EPvK";
        pszPubKey = "EPbK";
    }
    else
    {
        dwReturn = (DWORD)NTE_BAD_DATA;
        goto ErrorExit;
    }

    // if protected store is available then delete the key from there
    if (pTmpUser->pPStore)
    {
        dwSts = DeleteKeyFromProtectedStorage(
                    pTmpUser, &g_Strings, dwKeySpec,
                    fMachineKeySet, FALSE);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    // delete stuff from the registry
    RegDeleteValue(pTmpUser->hKeys, pszPrivKey);
    RegDeleteValue(pTmpUser->hKeys, pszPubKey);
    RegDeleteValue(pTmpUser->hKeys, pszExport);

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


#ifdef USE_SGC
//
// Function to bring all the SGC checking together
//

/*static*/ DWORD
SetSGCInfo(
    PNTAGUserList pTmpUser,
    CONST BYTE *pbData)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PCCERT_CONTEXT  pCertContext = (PCCERT_CONTEXT)pbData;
    BSAFE_PUB_KEY   *pPubKey;
    BYTE            *pbMod;
    DWORD           dwSts;

    // make sure the root certs are loaded
    dwSts = LoadSGCRoots(&pTmpUser->CritSec);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // verify context means that you are on the client side
    if (pTmpUser->Rights & CRYPT_VERIFYCONTEXT)
    {
        dwSts = SPQueryCFLevel(pCertContext, NULL, 0, 0,
                               (LPDWORD)&pTmpUser->dwSGCFlags);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        // set the modulus of the SGC cert so it may be checked later
        // when exporting the pre-master secret
        dwSts = SGCAssignPubKey(pCertContext,
                                &pTmpUser->pbSGCKeyMod,
                                &pTmpUser->cbSGCKeyMod,
                                &pTmpUser->dwSGCKeyExpo);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }
    else
    {
        // get a pointer to the exchange public key
        if ((0 == pTmpUser->ContInfo.ContLens.cbExchPub)
            || (NULL == pTmpUser->ContInfo.pbExchPub))
        {
            dwReturn = (DWORD)NTE_FAIL;
            goto ErrorExit;
        }

        pPubKey = (BSAFE_PUB_KEY*)pTmpUser->ContInfo.pbExchPub;
        pbMod = (BYTE*)pPubKey + sizeof(BSAFE_PUB_KEY);

        dwSts = SPQueryCFLevel(pCertContext, pbMod, pPubKey->bitlen / 8,
                               pPubKey->pubexp,
                               (LPDWORD)&pTmpUser->dwSGCFlags);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    if (0 == pTmpUser->dwSGCFlags)
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}
#endif


/*
 -  CPSetProvParam
 -
 *  Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a provider
 *
 *  Parameters:
 *               IN      hUID    -  Handle to a CSP
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *  Returns:
 */

BOOL WINAPI
CPSetProvParam(
    IN HCRYPTPROV hUID,
    IN DWORD dwParam,
    IN CONST BYTE *pbData,
    IN DWORD dwFlags)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGUserList   pTmpUser;
    HCRYPTKEY       hKey = 0;
    BOOL            fRet;
    DWORD           dwSts;

    EntryPoint
    pTmpUser = (PNTAGUserList)NTLCheckList(hUID, USER_HANDLE);
    if (NULL == pTmpUser)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    switch (dwParam)
    {
    case PP_KEYSET_SEC_DESCR:
        if (0 != (dwFlags & ~(OWNER_SECURITY_INFORMATION
                              | GROUP_SECURITY_INFORMATION
                              | DACL_SECURITY_INFORMATION
                              | SACL_SECURITY_INFORMATION)))
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        if (!(dwFlags & OWNER_SECURITY_INFORMATION) &&
            !(dwFlags & GROUP_SECURITY_INFORMATION) &&
            !(dwFlags & DACL_SECURITY_INFORMATION) &&
            !(dwFlags & SACL_SECURITY_INFORMATION))
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        // set the security descriptor for the hKey of the keyset
        dwSts = SetSecurityOnContainer(pTmpUser->ContInfo.rgwszFileName,
                                       pTmpUser->dwProvType,
                                       pTmpUser->Rights & CRYPT_MACHINE_KEYSET,
                                       (SECURITY_INFORMATION)dwFlags,
                                       (PSECURITY_DESCRIPTOR)pbData);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;

    case PP_KEY_TYPE_SUBTYPE:
        if (dwFlags != 0)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }
        break;

    case PP_UI_PROMPT:
        if (dwFlags != 0)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        if (pTmpUser->pPStore)
        {
            dwSts = SetUIPrompt(pTmpUser, (LPWSTR)pbData);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }
        else
        {
            dwReturn = (DWORD)NTE_BAD_TYPE;
            goto ErrorExit;
        }
        break;

    case PP_DELETEKEY:
        if (dwFlags != 0)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        // check if it is a verify context
        if (pTmpUser->Rights & CRYPT_VERIFYCONTEXT)
        {
            dwReturn = (DWORD)NTE_BAD_UID;
            goto ErrorExit;
        }

        // check if the keys exists
        if (!CPGetUserKey(hUID, *((DWORD*)pbData), &hKey))
        {
            dwReturn = GetLastError();  // (DWORD)NTE_NO_KEY
            goto ErrorExit;
        }

        // destroy the key handle right away
        if (!CPDestroyKey(hUID, hKey))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        // delete the key
        dwSts = DeletePersistedKey(pTmpUser, *(DWORD*)pbData);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;

    case PP_SGC_INFO:
        if (dwFlags != 0)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        // check if it is an SChannel provider
        if (PROV_RSA_SCHANNEL != pTmpUser->dwProvType)
        {
            dwReturn = (DWORD)NTE_BAD_TYPE;
            goto ErrorExit;
        }

#ifdef USE_SGC
        // check if the SGC Info (cert) is good
        dwSts = SetSGCInfo(pTmpUser, pbData);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;   // (DWORD)NTE_FAIL
            goto ErrorExit;
        }
#endif
        break;

#ifdef USE_HW_RNG
#ifdef _M_IX86
    case PP_USE_HARDWARE_RNG:
        if (dwFlags != 0)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        dwSts = GetRNGDriverHandle(&(pTmpUser->hRNGDriver));
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;
#endif // _M_IX86
#endif // USE_HW_RNG

    default:
        dwReturn = (DWORD)NTE_BAD_TYPE;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (!fRet)
        SetLastError(dwReturn);
    return fRet;
}


/*
 -  CPGetProvParam
 -
 *  Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a provider
 *
 *  Parameters:
 *               IN      hUID       -  Handle to a CSP
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *  Returns:
 */

BOOL WINAPI
CPGetProvParam(
    IN HCRYPTPROV hUID,
    IN DWORD dwParam,
    IN BYTE *pbData,
    IN DWORD *pwDataLen,
    IN DWORD dwFlags)
{
    DWORD             dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGUserList     pTmpUser;
    PROV_ENUMALGS    *pEnum = NULL;
    PROV_ENUMALGS_EX *pEnumEx = NULL;
    DWORD             cbName = 0;
    LPSTR             pszName;
    DWORD             cbTmpData;
    BOOL              fRet;
    DWORD             dwSts;

    EntryPoint
    pTmpUser = (PNTAGUserList)NTLCheckList(hUID, USER_HANDLE);
    if (NULL == pTmpUser)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    if (pwDataLen == NULL)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    switch (dwParam)
    {
    case PP_ENUMALGS:
        if (PROV_RSA_SCHANNEL == pTmpUser->dwProvType)
        {
            if ((dwFlags & ~(CRYPT_FIRST | CRYPT_NEXT | CRYPT_SGC_ENUM)) != 0)
            {
                dwReturn = (DWORD)NTE_BAD_FLAGS;
                goto ErrorExit;
            }
        }
        else
        {
            if ((dwFlags & ~(CRYPT_FIRST | CRYPT_NEXT)) != 0)
            {
                dwReturn = (DWORD)NTE_BAD_FLAGS;
                goto ErrorExit;
            }
        }

        pEnumEx = g_AlgTables[pTmpUser->dwCspTypeId];

        if (dwFlags & CRYPT_FIRST)
            pTmpUser->dwEnumalgs = 0;
        else if (0xFFFFFFFF == pTmpUser->dwEnumalgs)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        if (pEnumEx[pTmpUser->dwEnumalgs].aiAlgid == 0)
        {
            dwReturn = ERROR_NO_MORE_ITEMS;
            goto ErrorExit;
        }

        if (pbData == NULL || *pwDataLen < sizeof(PROV_ENUMALGS))
        {
            *pwDataLen = sizeof(PROV_ENUMALGS);
            dwReturn = (pbData == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
            goto ErrorExit;
        }

        // each entry in ENUMALGS is of fixed size
        pEnum = (PROV_ENUMALGS *)pbData;
        pEnum->aiAlgid = pEnumEx[pTmpUser->dwEnumalgs].aiAlgid;
        pEnum->dwBitLen = pEnumEx[pTmpUser->dwEnumalgs].dwDefaultLen;
        pEnum->dwNameLen = pEnumEx[pTmpUser->dwEnumalgs].dwNameLen;
        memcpy(pEnum->szName, pEnumEx[pTmpUser->dwEnumalgs].szName,
               sizeof(pEnum->szName));
        *pwDataLen = sizeof(PROV_ENUMALGS);

        pTmpUser->dwEnumalgs++;
        break;

    case PP_ENUMALGS_EX:
        if (PROV_RSA_SCHANNEL == pTmpUser->dwProvType)
        {
            if ((dwFlags & ~(CRYPT_FIRST | CRYPT_NEXT | CRYPT_SGC_ENUM)) != 0)
            {
                dwReturn = (DWORD)NTE_BAD_FLAGS;
                goto ErrorExit;
            }
        }
        else
        {
            if ((dwFlags & ~(CRYPT_FIRST | CRYPT_NEXT)) != 0)
            {
                dwReturn = (DWORD)NTE_BAD_FLAGS;
                goto ErrorExit;
            }
        }

        pEnumEx = g_AlgTables[pTmpUser->dwCspTypeId];

        if (dwFlags & CRYPT_FIRST)
            pTmpUser->dwEnumalgsEx = 0;
        else if (0xFFFFFFFF == pTmpUser->dwEnumalgsEx)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        if (pEnumEx[pTmpUser->dwEnumalgsEx].aiAlgid == 0)
        {
            dwReturn = ERROR_NO_MORE_ITEMS;
            goto ErrorExit;
        }

        if (pbData == NULL || *pwDataLen < sizeof(pEnumEx[0]))
        {
            *pwDataLen = sizeof(pEnumEx[0]);
            dwReturn = (pbData == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
            goto ErrorExit;
        }

        // each entry in ENUMALGSEX is of fixed size
        memcpy(pbData, &pEnumEx[pTmpUser->dwEnumalgsEx], sizeof(pEnumEx[0]));
        *pwDataLen = sizeof(pEnumEx[0]);

        pTmpUser->dwEnumalgsEx++;
        break;

    case PP_ENUMCONTAINERS:
    {
        BOOL fMachineKeySet = pTmpUser->Rights & CRYPT_MACHINE_KEYSET;

        if ((dwFlags & ~(CRYPT_FIRST | CRYPT_NEXT)) != 0)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        if (dwFlags & CRYPT_FIRST)
        {
            if (0 != pTmpUser->ContInfo.hFind)
            {
                FindClose(pTmpUser->ContInfo.hFind);
                pTmpUser->ContInfo.hFind = 0;
            }
            FreeEnumOldMachKeyEntries(&pTmpUser->ContInfo);
            FreeEnumRegEntries(&pTmpUser->ContInfo);

            pTmpUser->ContInfo.fCryptFirst = TRUE;
            pTmpUser->ContInfo.fNoMoreFiles = FALSE;
        }
        else if (!pTmpUser->ContInfo.fCryptFirst)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        dwSts = ERROR_SUCCESS;
        if (!pTmpUser->ContInfo.fNoMoreFiles)
        {
            dwSts = GetNextContainer(pTmpUser->dwProvType,
                                     fMachineKeySet,
                                     dwFlags,
                                     (LPSTR)pbData,
                                     pwDataLen,
                                     &pTmpUser->ContInfo.hFind);
        }

        // ?BUGBUG?  This logic needs desperate cleaning!
        if ((ERROR_SUCCESS != dwSts) || pTmpUser->ContInfo.fNoMoreFiles)
        {
            if ((ERROR_SUCCESS != dwSts) && (ERROR_NO_MORE_ITEMS != dwSts))
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            pTmpUser->ContInfo.fNoMoreFiles = TRUE;

            if (fMachineKeySet)
            {
                dwSts = EnumOldMachineKeys(pTmpUser->dwProvType,
                                           &pTmpUser->ContInfo);
                if (ERROR_SUCCESS != dwSts)
                {
                    if (ERROR_NO_MORE_ITEMS != dwSts)
                    {
                        dwReturn = dwSts;
                        goto ErrorExit;
                    }
                }
            }
            dwSts = EnumRegKeys(&pTmpUser->ContInfo,
                                fMachineKeySet,
                                pTmpUser->dwProvType,
                                pbData,
                                pwDataLen);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            cbTmpData = *pwDataLen;
            if ((!fMachineKeySet)
                || (0 != (dwSts = GetNextEnumedOldMachKeys(&pTmpUser->ContInfo,
                                                           fMachineKeySet,
                                                           pbData,
                                                           &cbTmpData))))
            {
                if (0 != (dwSts = GetNextEnumedRegKeys(&pTmpUser->ContInfo,
                                                       pbData,
                                                       pwDataLen)))
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }
            }
            else
                *pwDataLen = cbTmpData;
        }
        break;
    }

    case PP_IMPTYPE:
        if (0 != dwFlags)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        if (pbData == NULL || *pwDataLen < sizeof(DWORD))
        {
            *pwDataLen = sizeof(DWORD);
            dwReturn = (pbData == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
            goto ErrorExit;
        }

        *pwDataLen = sizeof(DWORD);
        *((DWORD *) pbData) = CRYPT_IMPL_SOFTWARE;
        break;

    case PP_NAME:
        if (0 != dwFlags)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        ASSERT(NULL != pTmpUser->szProviderName);
        if (NULL != pTmpUser->szProviderName)
            cbName = (lstrlen(pTmpUser->szProviderName) + 1) * sizeof(CHAR);
        else
            cbName = 0;

        if (pbData == NULL || *pwDataLen < cbName)
        {
            *pwDataLen = cbName;
            dwReturn = (pbData == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
            goto ErrorExit;
        }

        *pwDataLen = cbName;
        memcpy(pbData, pTmpUser->szProviderName, cbName);
        break;

    case PP_VERSION:
        if (dwFlags != 0)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        if (pbData == NULL || *pwDataLen < sizeof(DWORD))
        {
            *pwDataLen = sizeof(DWORD);
            dwReturn = (pbData == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
            goto ErrorExit;
        }

        *pwDataLen = sizeof(DWORD);
        *((DWORD *) pbData) = 0x200;    // ?BUGBUG? Symbolic?
        break;

    case PP_CONTAINER:
        if (0 != dwFlags)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        pszName = pTmpUser->ContInfo.pszUserName;
        if (pbData == NULL || *pwDataLen < (strlen(pszName) + 1))
        {
            *pwDataLen = strlen(pszName) + 1;
            dwReturn = (pbData == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
            goto ErrorExit;
        }

        *pwDataLen = strlen(pszName) + 1;
        strcpy((LPSTR)pbData, pszName);
        break;

    case PP_UNIQUE_CONTAINER:
        if (0 != dwFlags)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        dwSts = GetUniqueContainerName(&pTmpUser->ContInfo,
                                       pbData, pwDataLen);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;

    case PP_KEYSET_SEC_DESCR:
        if (0 != (dwFlags & ~(OWNER_SECURITY_INFORMATION
                              | GROUP_SECURITY_INFORMATION
                              | DACL_SECURITY_INFORMATION
                              | SACL_SECURITY_INFORMATION)))
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        if (!(dwFlags & OWNER_SECURITY_INFORMATION) &&
            !(dwFlags & GROUP_SECURITY_INFORMATION) &&
            !(dwFlags & DACL_SECURITY_INFORMATION) &&
            !(dwFlags & SACL_SECURITY_INFORMATION))
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        dwSts = GetSecurityOnContainer(pTmpUser->ContInfo.rgwszFileName,
                                       pTmpUser->dwProvType,
                                       pTmpUser->Rights & CRYPT_MACHINE_KEYSET,
                                       (SECURITY_INFORMATION)dwFlags,
                                       (PSECURITY_DESCRIPTOR)pbData,
                                       pwDataLen);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;

    case PP_KEYSTORAGE:
        if (dwFlags != 0)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        if (pbData == NULL || *pwDataLen < sizeof(DWORD))
        {
            *pwDataLen = sizeof(DWORD);
            dwReturn = (pbData == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
            goto ErrorExit;
        }

        *pwDataLen = sizeof(DWORD);
        if (pTmpUser->pPStore)
            *((DWORD*)pbData) = CRYPT_PSTORE
                                | CRYPT_UI_PROMPT
                                | CRYPT_SEC_DESCR;
        else
            *((DWORD*)pbData) = CRYPT_SEC_DESCR;
        break;

    case PP_PROVTYPE:
        if (dwFlags != 0)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        if (pbData == NULL || *pwDataLen < sizeof(DWORD))
        {
            *pwDataLen = sizeof(DWORD);
            dwReturn = (pbData == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
            goto ErrorExit;
        }

        *pwDataLen = sizeof(DWORD);
        *((DWORD*)pbData) = pTmpUser->dwProvType;
        break;

    case PP_KEYSET_TYPE:
        if (dwFlags != 0)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        if (pbData == NULL || *pwDataLen < sizeof(DWORD))
        {
            *pwDataLen = sizeof(DWORD);
            dwReturn = (pbData == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
            goto ErrorExit;
        }

        *pwDataLen = sizeof(DWORD);
        if (pTmpUser->Rights & CRYPT_MACHINE_KEYSET)
            *(DWORD*)pbData = CRYPT_MACHINE_KEYSET;
        else
            *(DWORD*)pbData = 0;
        break;

    case PP_SIG_KEYSIZE_INC:
    case PP_KEYX_KEYSIZE_INC:
        if (dwFlags != 0)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        if (pbData == NULL || *pwDataLen < sizeof(DWORD))
        {
            *pwDataLen = sizeof(DWORD);
            dwReturn = (pbData == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
            goto ErrorExit;
        }

        *pwDataLen = sizeof(DWORD);
        *((DWORD*)pbData) = RSA_KEYSIZE_INC;
        break;

    case PP_SGC_INFO:
        if (dwFlags != 0)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        // check if it is an SChannel provider
        if (PROV_RSA_SCHANNEL != pTmpUser->dwProvType)
        {
            dwReturn = (DWORD)NTE_BAD_TYPE;
            goto ErrorExit;
        }

        if (pbData == NULL || *pwDataLen < sizeof(DWORD))
        {
            *pwDataLen = sizeof(DWORD);
            dwReturn = (pbData == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
            goto ErrorExit;
        }

        *pwDataLen = sizeof(DWORD);
        // return the SGC Flags
#ifdef USE_SGC
        *((DWORD*)pbData) = pTmpUser->dwSGCFlags;
#else
        *((DWORD*)pbData) = 0;
#endif
        break;

#ifdef USE_HW_RNG
#ifdef _M_IX86
    case PP_USE_HARDWARE_RNG:
        if (dwFlags != 0)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        *pwDataLen = 0;

        // check if the hardware RNG is available for use
        dwSts = CheckIfRNGAvailable();
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;
#endif // _M_IX86
#endif // USE_HW_RNG

    case PP_KEYSPEC:
        if (dwFlags != 0)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        if (pbData == NULL || *pwDataLen < sizeof(DWORD))
        {
            *pwDataLen = sizeof(DWORD);
            dwReturn = (pbData == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
            goto ErrorExit;
        }

        *pwDataLen = sizeof(DWORD);
        if (PROV_RSA_SIG == pTmpUser->dwProvType)
            *((DWORD*)pbData) = AT_SIGNATURE;
        else if (PROV_RSA_FULL == pTmpUser->dwProvType)
            *((DWORD*)pbData) = AT_SIGNATURE | AT_KEYEXCHANGE;
        else if (PROV_RSA_SCHANNEL == pTmpUser->dwProvType)
            *((DWORD*)pbData) = AT_KEYEXCHANGE;
        break;

    case PP_ENUMEX_SIGNING_PROT:
        if (0 != dwFlags)
        {
            dwReturn = (DWORD)NTE_BAD_FLAGS;
            goto ErrorExit;
        }

        *pwDataLen = 0;
        break;

    default:
        dwReturn = (DWORD)NTE_BAD_TYPE;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (!fRet)
        SetLastError(dwReturn);
    return fRet;
}


/*
 -  CPSetHashParam
 -
 *  Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a hash
 *
 *  Parameters:
 *               IN      hUID    -  Handle to a CSP
 *               IN      hHash   -  Handle to a hash
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *  Returns:
 */

BOOL WINAPI
CPSetHashParam(
    IN HCRYPTPROV hUID,
    IN HCRYPTHASH hHash,
    IN DWORD dwParam,
    IN CONST BYTE *pbData,
    IN DWORD dwFlags)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGHashList       pTmpHash;
    PNTAGKeyList        pTmpKey;
    MD4_object          *pMD4Hash;
    MD5_object          *pMD5Hash;
    A_SHA_CTX           *pSHAHash;
    MACstate            *pMAC;
    PHMAC_INFO          pHMACInfo;
    BYTE                *pb;
    BOOL                fRet;
    DWORD               dwSts;

    EntryPoint
    if (dwFlags != 0)
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    // check the user identification
    if (NTLCheckList((HNTAG)hUID, USER_HANDLE) == NULL)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    dwSts = NTLValidate(hHash, hUID, HASH_HANDLE, &pTmpHash);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_HASH : dwSts;
        goto ErrorExit;
    }

    switch (dwParam)
    {
    case HP_HASHVAL:
        switch (pTmpHash->Algid)
        {
#ifdef CSP_USE_MD2
        case CALG_MD2:
        {
            MD2_object      *pMD2Hash;

            pMD2Hash = (MD2_object *) pTmpHash->pHashData;
            if (pMD2Hash->FinishFlag == TRUE)
            {
                dwReturn = (DWORD)NTE_BAD_HASH_STATE;
                goto ErrorExit;
            }

            memcpy(&pMD2Hash->MD.state, pbData, MD2DIGESTLEN);
            break;
        }
#endif
#ifdef CSP_USE_MD4
        case CALG_MD4:
            pMD4Hash = (MD4_object *) pTmpHash->pHashData;
            if (pMD4Hash->FinishFlag == TRUE)
            {
                dwReturn = (DWORD)NTE_BAD_HASH_STATE;
                goto ErrorExit;
            }

            memcpy (&pMD4Hash->MD, pbData, MD4DIGESTLEN);
            break;
#endif
#ifdef CSP_USE_MD5
        case CALG_MD5:
            pMD5Hash = (MD5_object *) pTmpHash->pHashData;
            if (pMD5Hash->FinishFlag == TRUE)
            {
                dwReturn = (DWORD)NTE_BAD_HASH_STATE;
                goto ErrorExit;
            }

            memcpy (pMD5Hash->digest, pbData, MD5DIGESTLEN);
            break;
#endif
#ifdef CSP_USE_SHA
        case CALG_SHA:
            pSHAHash = (A_SHA_CTX *) pTmpHash->pHashData;
            if (pSHAHash->FinishFlag == TRUE)
            {
                dwReturn = (DWORD)NTE_BAD_HASH_STATE;
                goto ErrorExit;
            }

            memcpy (pSHAHash->HashVal, pbData, A_SHA_DIGEST_LEN);
            break;
#endif
#ifdef CSP_USE_SSL3SHAMD5
        case CALG_SSL3_SHAMD5:
            memcpy (pTmpHash->pHashData, pbData, SSL3_SHAMD5_LEN);
            break;
#endif
#ifdef CSP_USE_MAC
        case CALG_MAC:
            pMAC = (MACstate *)pTmpHash->pHashData;
            dwSts = NTLValidate(pTmpHash->hKey, hUID, KEY_HANDLE, &pTmpKey);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_KEY : dwSts;
                goto ErrorExit;
            }

            if (pMAC->FinishFlag == TRUE)
            {
                dwReturn = (DWORD)NTE_BAD_HASH_STATE;
                goto ErrorExit;
            }

            memcpy(pTmpKey->FeedBack, pbData, pTmpKey->dwBlockLen);
            break;
#endif
        default:
            dwReturn = (DWORD)NTE_BAD_ALGID;
            goto ErrorExit;
        }
        pTmpHash->dwHashState |= DATA_IN_HASH;
        break;

    case HP_HMAC_INFO:
        if (CALG_HMAC != pTmpHash->Algid)
        {
            dwReturn = (DWORD)NTE_BAD_TYPE;
            goto ErrorExit;
        }

        pHMACInfo = (PHMAC_INFO)pbData;
        pTmpHash->HMACAlgid = pHMACInfo->HashAlgid;

        // now that we know the type of hash we can create it
        dwSts = LocalCreateHash(pTmpHash->HMACAlgid,
                                (BYTE**)&pTmpHash->pHashData,
                                &pTmpHash->dwDataLen);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        // if the length of the inner string is 0 then use the default string
        if (0 == pHMACInfo->cbInnerString)
            pTmpHash->cbHMACInner = HMAC_DEFAULT_STRING_LEN;
        else
            pTmpHash->cbHMACInner = pHMACInfo->cbInnerString;

        pb = _nt_malloc(pTmpHash->cbHMACInner);
        if (NULL == pb)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        if (0 == pHMACInfo->cbInnerString)
            memset(pb, 0x36, pTmpHash->cbHMACInner);
        else
            memcpy(pb, pHMACInfo->pbInnerString, pTmpHash->cbHMACInner);

        if (pTmpHash->pbHMACInner)
            _nt_free(pTmpHash->pbHMACInner, pTmpHash->cbHMACInner);
        pTmpHash->pbHMACInner = pb;

        // if the length of the outer string is 0 then use the default string
        if (0 == pHMACInfo->cbOuterString)
            pTmpHash->cbHMACOuter = HMAC_DEFAULT_STRING_LEN;
        else
            pTmpHash->cbHMACOuter = pHMACInfo->cbOuterString;

        pb = _nt_malloc(pTmpHash->cbHMACOuter);
        if (NULL == pb)
        {
            _nt_free(pTmpHash->pbHMACInner, pTmpHash->cbHMACInner);
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        if (0 == pHMACInfo->cbOuterString)
            memset(pb, 0x5C, pTmpHash->cbHMACOuter);
        else
            memcpy(pb, pHMACInfo->pbOuterString, pTmpHash->cbHMACOuter);
        if (pTmpHash->pbHMACOuter)
            _nt_free(pTmpHash->pbHMACOuter, pTmpHash->cbHMACOuter);
        pTmpHash->pbHMACOuter = pb;
        break;

#ifdef CSP_USE_SSL3
    case HP_TLS1PRF_LABEL:
    case HP_TLS1PRF_SEED:
    {
        if (CALG_TLS1PRF != pTmpHash->Algid)
        {
            dwReturn = (DWORD)NTE_BAD_HASH;
            goto ErrorExit;
        }

        dwSts = SetPRFHashParam((PRF_HASH*)pTmpHash->pHashData,
                                dwParam, pbData);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        pTmpHash->dwHashState |= DATA_IN_HASH;
        break;
    }
#endif

    default:
        dwReturn = (DWORD)NTE_BAD_TYPE;
        goto ErrorExit;
    }

    if (dwParam == HP_HASHVAL)
        pTmpHash->HashFlags |= HF_VALUE_SET;

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (!fRet)
        SetLastError(dwReturn);
    return fRet;
}


/*static*/ DWORD
LocalGetHashVal(
    IN ALG_ID Algid,
    IN DWORD dwHashFlags,
    IN OUT BYTE *pbHashData,
    OUT BYTE *pbHashVal,
    OUT DWORD *pcbHashVal)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    MD2_object  *pMD2Hash;
    MD4_object  *pMD4Hash;
    MD5_object  *pMD5Hash;
    A_SHA_CTX   *pSHAHash;

    switch (Algid)
    {
#ifdef CSP_USE_MD2
    case CALG_MD2:
        // make sure there's enough room.
        if (pbHashVal == NULL || *pcbHashVal < MD2DIGESTLEN)
        {
            *pcbHashVal = MD2DIGESTLEN;
            dwReturn = (pbHashVal == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
            goto ErrorExit;
        }

        pMD2Hash = (MD2_object *)pbHashData;
        if ((dwHashFlags & HF_VALUE_SET) == 0)
        {
            if (pMD2Hash->FinishFlag == TRUE)
            {
                *pcbHashVal = MD2DIGESTLEN;
                memcpy(pbHashVal, pMD2Hash->MD.state, MD2DIGESTLEN);
                break;
            }

            // set the finish flag on the hash and
            // process what's left in the buffer.
            pMD2Hash->FinishFlag = TRUE;

            // Finish offthe hash
            MD2Final(&pMD2Hash->MD);
        }

        *pcbHashVal = MD2DIGESTLEN;
        memcpy (pbHashVal, pMD2Hash->MD.state, MD2DIGESTLEN);
        break;
#endif

#ifdef CSP_USE_MD4
    case CALG_MD4:
        // make sure there's enough room.
        if (pbHashVal == NULL || *pcbHashVal < MD4DIGESTLEN)
        {
            *pcbHashVal = MD4DIGESTLEN;
            dwReturn = (pbHashVal == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
            goto ErrorExit;
        }

        pMD4Hash = (MD4_object *)pbHashData;
        if ((dwHashFlags & HF_VALUE_SET) == 0)
        {
            if (pMD4Hash->FinishFlag == TRUE)
            {
                *pcbHashVal = MD4DIGESTLEN;
                memcpy(pbHashVal, &pMD4Hash->MD, *pcbHashVal);
                break;
            }

            // set the finish flag on the hash and
            // process what's left in the buffer.
            pMD4Hash->FinishFlag = TRUE;
            if (MD4_SUCCESS != MDupdate(&pMD4Hash->MD, pMD4Hash->Buf,
                                        MD4BYTESTOBITS(pMD4Hash->BufLen)))
            {
                dwReturn = (DWORD)NTE_FAIL;
                goto ErrorExit;
            }
        }

        *pcbHashVal = MD4DIGESTLEN;
        memcpy(pbHashVal, &pMD4Hash->MD, *pcbHashVal);
        break;
#endif

#ifdef CSP_USE_MD5
    case CALG_MD5:
        // make sure there's enough room.
        if (pbHashVal == NULL || *pcbHashVal < MD5DIGESTLEN)
        {
            *pcbHashVal = MD5DIGESTLEN;
            dwReturn = (pbHashVal == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
            goto ErrorExit;
        }

        pMD5Hash = (MD5_object *)pbHashData;
        if ((dwHashFlags & HF_VALUE_SET) == 0)
        {
            if (pMD5Hash->FinishFlag == TRUE)
            {
                *pcbHashVal = MD5DIGESTLEN;
                memcpy (pbHashVal, pMD5Hash->digest, MD5DIGESTLEN);
                break;
            }

            // set the finish flag on the hash and
            // process what's left in the buffer.
            pMD5Hash->FinishFlag = TRUE;

            // Finish offthe hash
            MD5Final(pMD5Hash);
        }

        *pcbHashVal = MD5DIGESTLEN;
        memcpy (pbHashVal, pMD5Hash->digest, MD5DIGESTLEN);
        break;
#endif

#ifdef CSP_USE_SHA
    case CALG_SHA:
        // make sure there's enough room.
        if (pbHashVal == NULL || *pcbHashVal < A_SHA_DIGEST_LEN)
        {
            *pcbHashVal = A_SHA_DIGEST_LEN;
            dwReturn = (pbHashVal == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
            goto ErrorExit;
        }

        pSHAHash = (A_SHA_CTX *)pbHashData;
        if ((dwHashFlags & HF_VALUE_SET) == 0)
        {
            if (pSHAHash->FinishFlag == TRUE)
            {
                *pcbHashVal = A_SHA_DIGEST_LEN;
                memcpy (pbHashVal, pSHAHash->HashVal, A_SHA_DIGEST_LEN);
                break;
            }

            // set the finish flag on the hash and
            // process what's left in the buffer.
            pSHAHash->FinishFlag = TRUE;

            // Finish off the hash
            A_SHAFinal(pSHAHash, pSHAHash->HashVal);
        }

        *pcbHashVal = A_SHA_DIGEST_LEN;
        memcpy (pbHashVal, pSHAHash->HashVal, A_SHA_DIGEST_LEN);
        break;
#endif

    default:
        dwReturn = (DWORD)NTE_BAD_ALGID;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*static*/ DWORD
GetHashLength(
    IN ALG_ID Algid)
{
    DWORD cbLen;

    switch (Algid)
    {
#ifdef CSP_USE_MD2
    case CALG_MD2:
        cbLen = MD2DIGESTLEN;
        break;
#endif
#ifdef CSP_USE_MD4
    case CALG_MD4:
        cbLen = MD4DIGESTLEN;
        break;
#endif
#ifdef CSP_USE_MD5
    case CALG_MD5:
        cbLen = MD5DIGESTLEN;
        break;
#endif
#ifdef CSP_USE_SHA
    case CALG_SHA:
        cbLen = A_SHA_DIGEST_LEN;
        break;
#endif
    default:
        ASSERT(FALSE);
        cbLen = 0;
    }

    return cbLen;
}


/*
 -  CPGetHashParam
 -
 *  Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a key
 *
 *  Parameters:
 *               IN      hUID       -  Handle to a CSP
 *               IN      hHash      -  Handle to a hash
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *  Returns:
 */

BOOL WINAPI
CPGetHashParam(
    IN HCRYPTPROV hUID,
    IN HCRYPTHASH hHash,
    IN DWORD dwParam,
    IN BYTE *pbData,
    IN DWORD *pwDataLen,
    IN DWORD dwFlags)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGHashList   pTmpHash;
    MACstate        *pMAC;
    BYTE            MACbuf[2*MAX_BLOCKLEN];
    PNTAGKeyList    pTmpKey;
    BYTE            rgbFinalHash[A_SHA_DIGEST_LEN];
    DWORD           cbFinalHash;
    DWORD           cb;
    BYTE            *pb = NULL;
    DWORD           cbHashData;
    BYTE            *pbHashData = NULL;
    DWORD           i;
    BOOL            fRet;
    DWORD           dwSts;

    EntryPoint
    if (dwFlags != 0)
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    // check the user identification
    if (NTLCheckList ((HNTAG)hUID, USER_HANDLE) == NULL)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    if (pwDataLen == NULL)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    dwSts = NTLValidate(hHash, hUID, HASH_HANDLE, &pTmpHash);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_HASH : dwSts;
        goto ErrorExit;
    }

    switch (dwParam)
    {
    case HP_ALGID:
        if (pbData == NULL || *pwDataLen < sizeof(DWORD))
        {
            *pwDataLen = sizeof(DWORD);
            dwReturn = (pbData == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
            goto ErrorExit;
        }

        *((DWORD *) pbData) = pTmpHash->Algid;
        *pwDataLen = sizeof(DWORD);
        break;

    case HP_HASHSIZE:
        if (pbData == NULL || *pwDataLen < sizeof(DWORD))
        {
            *pwDataLen = sizeof(DWORD);
            dwReturn = (pbData == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
            goto ErrorExit;
        }

        switch (pTmpHash->Algid)
        {
        case CALG_MD2:
        case CALG_MD4:
        case CALG_MD5:
        case CALG_SHA:
            *(DWORD *)pbData = GetHashLength(pTmpHash->Algid);
            break;
#ifdef CSP_USE_MAC
        case CALG_MAC:
            *(DWORD *)pbData = MAX_BLOCKLEN;
            break;
#endif // CSP_USE_MAC
        case CALG_HMAC:
            *(DWORD *)pbData = GetHashLength(pTmpHash->HMACAlgid);
            break;
#ifdef CSP_USE_SSL3SHAMD5
        case CALG_SSL3_SHAMD5:
            *((DWORD *) pbData) = SSL3_SHAMD5_LEN;
            break;
#endif
        default:
            dwReturn = (DWORD)NTE_BAD_ALGID;
            goto ErrorExit;
        }

        *pwDataLen = sizeof(DWORD);
        break;

    case HP_HASHVAL:
        switch (pTmpHash->Algid)
        {
#ifdef CSP_USE_SSL3SHAMD5
        case CALG_SSL3_SHAMD5:
            // make sure there's enough room.
            if (pbData == NULL || *pwDataLen < SSL3_SHAMD5_LEN)
            {
                *pwDataLen = SSL3_SHAMD5_LEN;
                dwReturn = (pbData == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
                goto ErrorExit;
            }

            // Hash value must have already been set.
            if ((pTmpHash->HashFlags & HF_VALUE_SET) == 0)
            {
                dwReturn = (DWORD)NTE_BAD_HASH_STATE;
                goto ErrorExit;
            }

            *pwDataLen = SSL3_SHAMD5_LEN;
            memcpy (pbData, pTmpHash->pHashData, SSL3_SHAMD5_LEN);
            break;
#endif
#ifdef CSP_USE_MAC
        case CALG_MAC:
            pMAC = (MACstate *)pTmpHash->pHashData;
            dwSts = NTLValidate(pTmpHash->hKey, hUID, KEY_HANDLE, &pTmpKey);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_KEY : dwSts;
                goto ErrorExit;
            }

            // make sure there is enough room.
            if (pbData == NULL || (*pwDataLen < pTmpKey->dwBlockLen))
            {
                *pwDataLen = pTmpKey->dwBlockLen;
                dwReturn = (pbData == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
                goto ErrorExit;
            }

            if (pMAC->FinishFlag == TRUE)
            {
                *pwDataLen = pTmpKey->dwBlockLen;
                memcpy(pbData, pTmpKey->FeedBack, pTmpKey->dwBlockLen);
                break;
            }

            // set the finish flag on the hash and
            // process what's left in the buffer.
            pMAC->FinishFlag = TRUE;

            if (pMAC->dwBufLen)
            {
                memset(MACbuf, 0, 2*MAX_BLOCKLEN);
                memcpy(MACbuf, pMAC->Buffer, pMAC->dwBufLen);

                switch (pTmpKey->Algid)
                {
                case CALG_RC2:
                    dwSts = BlockEncrypt(RC2, pTmpKey, RC2_BLOCKLEN, TRUE,
                                         MACbuf, &pMAC->dwBufLen,
                                         2*MAX_BLOCKLEN);
                    if (ERROR_SUCCESS != dwSts)
                    {
                        dwReturn = dwSts;
                        goto ErrorExit;
                    }
                    break;

                case CALG_DES:
                    dwSts = BlockEncrypt(des, pTmpKey, DES_BLOCKLEN, TRUE,
                                         MACbuf, &pMAC->dwBufLen,
                                         2*MAX_BLOCKLEN);
                    if (ERROR_SUCCESS != dwSts)
                    {
                        dwReturn = dwSts;
                        goto ErrorExit;
                    }
                    break;
#ifdef CSP_USE_3DES
                case CALG_3DES_112:
                case CALG_3DES:
                    dwSts = BlockEncrypt(tripledes, pTmpKey, DES_BLOCKLEN,
                                         TRUE, MACbuf, &pMAC->dwBufLen,
                                         2*MAX_BLOCKLEN);
                    if (ERROR_SUCCESS != dwSts)
                    {
                        dwReturn = dwSts;
                        goto ErrorExit;
                    }
                    break;
#endif
#ifdef CSP_USE_AES
                case CALG_AES_128:
                case CALG_AES_192:
                case CALG_AES_256:
                    dwSts = BlockEncrypt(aes, pTmpKey, pTmpKey->dwBlockLen,
                                         TRUE, MACbuf, &pMAC->dwBufLen,
                                         2*MAX_BLOCKLEN);
                    if (ERROR_SUCCESS != dwSts)
                    {
                        dwReturn = dwSts;
                        goto ErrorExit;
                    }
                    break;
#endif
                // default: It's not a block cipher.
                }
            }

            *pwDataLen = pTmpKey->dwBlockLen;
            memcpy(pbData, pTmpKey->FeedBack, pTmpKey->dwBlockLen);
            break;
#endif
        case CALG_HMAC:
            if (!(pTmpHash->HMACState & HMAC_FINISHED))
            {
                cbFinalHash = sizeof(rgbFinalHash);
                dwSts = LocalGetHashVal(pTmpHash->HMACAlgid,
                                        pTmpHash->HashFlags,
                                        pTmpHash->pHashData,
                                        rgbFinalHash,
                                        &cbFinalHash);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }

                // now XOR the outer string with the key and hash
                // over this and the inner hash
                dwSts = NTLValidate(pTmpHash->hKey, hUID,
                                    KEY_HANDLE, &pTmpKey);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = (dwSts == NTE_FAIL)
                               ? (DWORD)NTE_BAD_KEY
                               : dwSts;
                    goto ErrorExit;
                }

                if (pTmpKey->cbKeyLen < pTmpHash->cbHMACOuter)
                    cb = pTmpHash->cbHMACOuter;
                else
                    cb = pTmpKey->cbKeyLen;

                pb = (BYTE *)_nt_malloc(cb);
                if (NULL == pb)
                {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorExit;
                }

                memcpy(pb, pTmpHash->pbHMACOuter, pTmpHash->cbHMACOuter);

                // currently no support for byte reversed keys with HMAC
                for (i=0;i<pTmpKey->cbKeyLen;i++)
                    pb[i] ^= (pTmpKey->pKeyValue)[i];

                dwSts = LocalCreateHash(pTmpHash->HMACAlgid,
                                        &pbHashData,
                                        &cbHashData);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }

                dwSts = LocalHashData(pTmpHash->HMACAlgid, pbHashData,
                                      pb, cb);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }

                dwSts = LocalHashData(pTmpHash->HMACAlgid, pbHashData,
                                      rgbFinalHash, cbFinalHash);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }

                _nt_free(pTmpHash->pHashData, pTmpHash->dwDataLen);
                pTmpHash->dwDataLen = cbHashData;
                pTmpHash->pHashData = pbHashData;
                pbHashData = NULL;
                pTmpHash->HMACState |= HMAC_FINISHED;
            }

            dwSts = LocalGetHashVal(pTmpHash->HMACAlgid, pTmpHash->HashFlags,
                                    pTmpHash->pHashData, pbData, pwDataLen);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
            break;
#ifdef CSP_USE_SSL3
        case CALG_TLS1PRF:
        {
            dwSts = CalculatePRF((PRF_HASH*)pTmpHash->pHashData,
                                 pbData, pwDataLen);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
            break;
        }
#endif
        default:
            dwSts = LocalGetHashVal(pTmpHash->Algid, pTmpHash->HashFlags,
                                    pTmpHash->pHashData, pbData, pwDataLen);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }
        break;

    default:
        dwReturn = (DWORD)NTE_BAD_TYPE;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (pb)
        _nt_free(pb, cb);
    if (pbHashData)
        _nt_free(pbHashData, cbHashData);
    if (!fRet)
        SetLastError(dwReturn);
    return fRet;
}


/*static*/ DWORD
CopyKey(
    IN PNTAGKeyList pOldKey,
    OUT PNTAGKeyList *ppNewKey)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGKeyList    pNewKey;

    pNewKey = (PNTAGKeyList)_nt_malloc(sizeof(NTAGKeyList));
    if (NULL == pNewKey)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    memcpy(pNewKey, pOldKey, sizeof(NTAGKeyList));
    pNewKey->Rights &= ~CRYPT_ARCHIVABLE;
    pNewKey->Permissions &= ~CRYPT_ARCHIVE;
    pNewKey->pKeyValue = NULL;
    pNewKey->cbDataLen = 0;
    pNewKey->pData = NULL;
    pNewKey->cbSaltLen = 0;

    pNewKey->cbKeyLen = pOldKey->cbKeyLen;
    if (pNewKey->cbKeyLen)
    {
        pNewKey->pKeyValue = (BYTE*)_nt_malloc(pNewKey->cbKeyLen);
        if (NULL == pNewKey->pKeyValue)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }
    }

    memcpy(pNewKey->pKeyValue, pOldKey->pKeyValue, pNewKey->cbKeyLen);
    pNewKey->cbDataLen = pOldKey->cbDataLen;
    if (pNewKey->cbDataLen)
    {
        pNewKey->pData = (BYTE*)_nt_malloc(pNewKey->cbDataLen);
        if (NULL == pNewKey->pData)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }
    }

    memcpy(pNewKey->pData, pOldKey->pData, pNewKey->cbDataLen);
    if (pOldKey->Algid == CALG_PCT1_MASTER)
    {
        // This is a PCT master key, and so it might have some certificate
        // data attached to it. If this is the case, then make a copy
        // of the certificate data and attach it to the new key.
        if (pOldKey->cbDataLen == sizeof(SCH_KEY))
        {
            PSCH_KEY pOldSChKey = (PSCH_KEY)pOldKey->pData;
            PSCH_KEY pNewSChKey = (PSCH_KEY)pNewKey->pData;

            if (pOldSChKey->pbCertData && pOldSChKey->cbCertData)
            {
                pNewSChKey->pbCertData = (BYTE*)_nt_malloc(pOldSChKey->cbCertData);
                if (NULL == pNewSChKey->pbCertData)
                {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                    goto ErrorExit;
                }

                memcpy(pNewSChKey->pbCertData,
                       pOldSChKey->pbCertData,
                       pOldSChKey->cbCertData);
            }
        }
    }

    pNewKey->cbSaltLen = pOldKey->cbSaltLen;
    memcpy(pNewKey->rgbSalt, pOldKey->rgbSalt, pNewKey->cbSaltLen);

    *ppNewKey = pNewKey;
    pNewKey = NULL;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pNewKey)
        FreeNewKey(pNewKey);
    return dwReturn;
}


/*
 -  CPDuplicateKey
 -
 *  Purpose:
 *                Duplicates the state of a key and returns a handle to it
 *
 *  Parameters:
 *               IN      hUID           -  Handle to a CSP
 *               IN      hKey           -  Handle to a key
 *               IN      pdwReserved    -  Reserved
 *               IN      dwFlags        -  Flags
 *               IN      phKey          -  Handle to the new key
 *
 *  Returns:
 */

BOOL WINAPI
CPDuplicateKey(
    IN HCRYPTPROV hUID,
    IN HCRYPTKEY hKey,
    IN DWORD *pdwReserved,
    IN DWORD dwFlags,
    IN HCRYPTKEY *phKey)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGKeyList    pTmpKey;
    PNTAGKeyList    pNewKey = NULL;
    BYTE            bType = KEY_HANDLE;
    BOOL            fRet;
    DWORD           dwSts;

    EntryPoint
    if (NULL != pdwReserved)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    if (0 != dwFlags)
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    dwSts = NTLValidate((HNTAG)hKey, hUID, bType, &pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        bType = SIGPUBKEY_HANDLE;
        dwSts = NTLValidate((HNTAG)hKey, hUID, bType, &pTmpKey);
        if (ERROR_SUCCESS != dwSts)
        {
            bType = EXCHPUBKEY_HANDLE;
            dwSts = NTLValidate((HNTAG)hKey, hUID, bType, &pTmpKey);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = (NTE_FAIL == dwSts)
                           ? (DWORD)NTE_BAD_KEY
                           : dwSts;
                goto ErrorExit;
            }
        }
    }

    dwSts = CopyKey(pTmpKey, &pNewKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }


    dwSts = NTLMakeItem(phKey, bType, (void *)pNewKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (!fRet)
    {
        if (NULL != pNewKey)
            FreeNewKey(pNewKey);
        SetLastError(dwReturn);
    }
    return fRet;
}


//
// Function : TestEncDec
//
// Description : This function expands the passed in key buffer for the
//               appropriate algorithm, and then either encryption or
//               decryption is performed.  A comparison is then made to see
//               if the ciphertext or plaintext matches the expected value.
//               The function only uses ECB mode for block ciphers and the
//               plaintext buffer must be the same length as the ciphertext
//               buffer.  The length of the plaintext must be either the
//               block length of the cipher if it is a block cipher or less
//               than MAX_BLOCKLEN if a stream cipher is being used.
//

/*static*/ DWORD
TestEncDec(
    IN ALG_ID Algid,
    IN BYTE *pbKey,
    IN DWORD cbKey,
    IN BYTE *pbPlaintext,
    IN DWORD cbPlaintext,
    IN BYTE *pbCiphertext,
    IN BYTE *pbIV,
    IN int iOperation)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BYTE    *pbExpandedKey = NULL;
    BYTE    rgbBuffIn[MAX_BLOCKLEN];
    BYTE    rgbBuffOut[MAX_BLOCKLEN];
    DWORD   i;

    memset(rgbBuffIn, 0, sizeof(rgbBuffIn));
    memset(rgbBuffOut, 0, sizeof(rgbBuffOut));

    // length of data to encrypt must be < MAX_BLOCKLEN
    if (cbPlaintext > MAX_BLOCKLEN)
    {
        dwReturn = (DWORD)NTE_BAD_LEN;
        goto ErrorExit;
    }

    // alloc for and expand the key
    switch (Algid)
    {
#ifdef CSP_USE_RC4
    case (CALG_RC4):
        pbExpandedKey = _nt_malloc(sizeof(RC4_KEYSTRUCT));
        if (NULL == pbExpandedKey)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        rc4_key((RC4_KEYSTRUCT*)pbExpandedKey, cbKey, pbKey);
        break;
#endif // CSP_USE_RC4

#ifdef CSP_USE_RC2
    case (CALG_RC2):
        pbExpandedKey = _nt_malloc(RC2_TABLESIZE);
        if (NULL == pbExpandedKey)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        RC2KeyEx((WORD*)pbExpandedKey, pbKey, cbKey, cbKey * 8);
        break;
#endif // CSP_USE_RC2

#ifdef CSP_USE_DES40
    case (CALG_DES40):
        pbExpandedKey = _nt_malloc(DES_TABLESIZE);
        if (NULL == pbExpandedKey)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        pbKey[0] &= 0x0F;    // set 4 leftmost bits of first byte to zero
        pbKey[2] &= 0x0F;    // set 4 leftmost bits of third byte to zero
        pbKey[4] &= 0x0F;    // set 4 leftmost bits of fifth byte to zero
        pbKey[6] &= 0x0F;    // set 4 leftmost bits of seventh byte to zero
        desparityonkey(pbKey, cbKey);
        deskey((DESTable*)pbExpandedKey, pbKey);
        break;
#endif // CSP_USE_DES40

#ifdef CSP_USE_DES
    case (CALG_DES):
        pbExpandedKey = _nt_malloc(DES_TABLESIZE);
        if (NULL == pbExpandedKey)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        desparityonkey(pbKey, cbKey);
        deskey((DESTable*)pbExpandedKey, pbKey);
        break;
#endif // CSP_USE_DES

#ifdef CSP_USE_3DES
    case (CALG_3DES):
        pbExpandedKey = _nt_malloc(DES3_TABLESIZE);
        if (NULL == pbExpandedKey)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        desparityonkey(pbKey, cbKey);
        tripledes3key((PDES3TABLE)pbExpandedKey, pbKey);
        break;

    case (CALG_3DES_112):
        pbExpandedKey = _nt_malloc(DES3_TABLESIZE);
        if (NULL == pbExpandedKey)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        desparityonkey(pbKey, cbKey);
        tripledes2key((PDES3TABLE)pbExpandedKey, pbKey);
        break;
#endif // CSP_USE_3DES

#ifdef CSP_USE_AES
    case CALG_AES_128:
        pbExpandedKey = _nt_malloc(AES_TABLESIZE);
        if (NULL == pbExpandedKey)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        aeskey((AESTable *) pbExpandedKey, pbKey, CRYPT_AES128_ROUNDS);
        break;

    case CALG_AES_192:
        pbExpandedKey = _nt_malloc(AES_TABLESIZE);
        if (NULL == pbExpandedKey)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        aeskey((AESTable *) pbExpandedKey, pbKey, CRYPT_AES192_ROUNDS);
        break;

    case CALG_AES_256:
        pbExpandedKey = _nt_malloc(AES_TABLESIZE);
        if (NULL == pbExpandedKey)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        aeskey((AESTable *) pbExpandedKey, pbKey, CRYPT_AES256_ROUNDS);
        break;
#endif

    default:
        dwReturn = (DWORD)NTE_BAD_ALGID;
        goto ErrorExit;
    }

    // if encrypting and there is an IV then use it
    if ((ENCRYPT == iOperation) && (CALG_RC4 != Algid))
    {
        memcpy(rgbBuffIn, pbPlaintext, cbPlaintext);

        if (NULL != pbIV)
        {
            for (i = 0; i < cbPlaintext; i++)
                rgbBuffIn[i] = (BYTE)(rgbBuffIn[i] ^ pbIV[i]);
        }
    }

    // encrypt the plaintext
    switch (Algid)
    {
#ifdef CSP_USE_RC4
    case (CALG_RC4):
        if (ENCRYPT == iOperation)
            memcpy(rgbBuffOut, pbPlaintext, cbPlaintext);
        else
            memcpy(rgbBuffOut, pbCiphertext, cbPlaintext);
        rc4((RC4_KEYSTRUCT*)pbExpandedKey, cbPlaintext, rgbBuffOut);
        break;
#endif // CSP_USE_RC4

#ifdef CSP_USE_RC2
    case (CALG_RC2):
        if (ENCRYPT == iOperation)
            RC2(rgbBuffOut, rgbBuffIn, pbExpandedKey, ENCRYPT);
        else
            RC2(rgbBuffOut, pbCiphertext, pbExpandedKey, DECRYPT);
        break;
#endif // CSP_USE_RC2

#ifdef CSP_USE_DES40
    case (CALG_DES40):
        if (ENCRYPT == iOperation)
            des(rgbBuffOut, rgbBuffIn, pbExpandedKey, ENCRYPT);
        else
            des(rgbBuffOut, pbCiphertext, pbExpandedKey, DECRYPT);
        break;
#endif // CSP_USE_DES40

#ifdef CSP_USE_DES
    case (CALG_DES):
        if (ENCRYPT == iOperation)
            des(rgbBuffOut, rgbBuffIn, pbExpandedKey, ENCRYPT);
        else
            des(rgbBuffOut, pbCiphertext, pbExpandedKey, DECRYPT);
        break;
#endif // CSP_USE_DES

#ifdef CSP_USE_3DES
    case (CALG_3DES):
    case (CALG_3DES_112):
        if (ENCRYPT == iOperation)
            tripledes(rgbBuffOut, rgbBuffIn, pbExpandedKey, ENCRYPT);
        else
            tripledes(rgbBuffOut, pbCiphertext, pbExpandedKey, DECRYPT);
        break;
#endif // CSP_USE_3DES

#ifdef CSP_USE_AES
    case CALG_AES_128:
    case CALG_AES_192:
    case CALG_AES_256:
        if (ENCRYPT == iOperation)
            aes(rgbBuffOut, rgbBuffIn, pbExpandedKey, ENCRYPT);
        else
            aes(rgbBuffOut, pbCiphertext, pbExpandedKey, DECRYPT);
        break;
#endif

    default:
        dwReturn = (DWORD)NTE_BAD_ALGID;
        goto ErrorExit;
    }

    if (ENCRYPT == iOperation)
    {
        // compare the encrypted plaintext with the passed in ciphertext
        if (0 != memcmp(pbCiphertext, rgbBuffOut, cbPlaintext))
        {
            dwReturn = (DWORD)NTE_FAIL;
            goto ErrorExit;
        }
    }
    else
    {
        // if there is an IV then use it
        if (NULL != pbIV)
        {
            for (i = 0; i < cbPlaintext; i++)
                rgbBuffOut[i] = (BYTE)(rgbBuffOut[i] ^ pbIV[i]);
        }

        // compare the decrypted ciphertext with the passed in plaintext
        if (0 != memcmp(pbPlaintext, rgbBuffOut, cbPlaintext))
        {
            dwReturn = (DWORD)NTE_FAIL;
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pbExpandedKey)
        _nt_free(pbExpandedKey, 0);
    return dwReturn;
}


//
// Function : TestSymmetricAlgorithm
//
// Description : This function expands the passed in key buffer for the
//               appropriate algorithm, encrypts the plaintext buffer with the
//               same algorithm and key, and the compares the passed in
//               expected ciphertext with the calculated ciphertext to make
//               sure they are the same.  The opposite is then done with
//               decryption.
//
//               The function only uses ECB mode for block ciphers and the
//               plaintext buffer must be the same length as the ciphertext
//               buffer.  The length of the plaintext must be either the block
//               length of the cipher if it is a block cipher or less than
//               MAX_BLOCKLEN if a stream cipher is being used.
//

DWORD
TestSymmetricAlgorithm(
    IN ALG_ID Algid,
    IN BYTE *pbKey,
    IN DWORD cbKey,
    IN BYTE *pbPlaintext,
    IN DWORD cbPlaintext,
    IN BYTE *pbCiphertext,
    IN BYTE *pbIV)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD   dwSts;

    dwSts = TestEncDec(Algid, pbKey, cbKey, pbPlaintext, cbPlaintext,
                       pbCiphertext, pbIV, ENCRYPT);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }
    dwSts = TestEncDec(Algid, pbKey, cbKey, pbPlaintext, cbPlaintext,
                       pbCiphertext, pbIV, DECRYPT);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\rsaaes\protstor.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : protstor.c                                             //
//  DESCRIPTION   : Code for storing keys in the protected store:          //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Dec  4 1996 jeffspel Created                                       //
//      Apr 21 1997 jeffspel  Changes for NT 5 tree                        //
//      Jul 28 1997 jeffspel Added ability to delete a persisted key       //
//      May  5 2000 dbarlow Modify error return handling                   //
//                                                                         //
//  Copyright (C) 1996 - 2000, Microsoft Corporation                       //
//  All Rights Reserved                                                    //
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "wincrypt.h"
#include "pstore.h"
#include "protstor.h"
#include "ntagum.h"

#define CRYPTO_KEY_TYPE_STRING       L"Cryptographic Keys"
static GUID l_DefTypeGuid
    = { 0x4d1fa410, 0x6fd9, 0x11d0,
        { 0x8C, 0x58, 0x00, 0xC0, 0x4F, 0xD9, 0x12, 0x6B } };

#define CRYPTO_SIG_SUBTYPE_STRING    L"RSA Signature Keys"
static GUID l_DefSigGuid
    = { 0x4d1fa411, 0x6fd9, 0x11D0,
        { 0x8C, 0x58, 0x00, 0xC0, 0x4F, 0xD9, 0x12, 0x6B } };

#define CRYPTO_EXCH_SUBTYPE_STRING   L"RSA Exchange Keys"
static GUID l_DefExchGuid
    = { 0x4d1fa412, 0x6fd9, 0x11D0,
        { 0x8C, 0x58, 0x00, 0xC0, 0x4F, 0xD9, 0x12, 0x6B } };

static GUID l_SysProv = MS_BASE_PSTPROVIDER_ID;


void
FreePSInfo(
    PSTORE_INFO *pPStore)
{
    IPStore *pIPS;

    if (NULL != pPStore)
    {
        pIPS = (IPStore*)pPStore->pProv;
        if (NULL != pIPS)
            pIPS->Release();
        if (NULL != pPStore->hInst)
            FreeLibrary(pPStore->hInst);
        if (NULL != pPStore->szPrompt)
            _nt_free(pPStore->szPrompt, pPStore->cbPrompt);
        _nt_free(pPStore, sizeof(PSTORE_INFO));
    }
}


BOOL
CheckPStoreAvailability(
    PSTORE_INFO *pPStore)
{
    BOOL            fRet = FALSE;

    if (S_OK != PStoreCreateInstance((IPStore**)(&pPStore->pProv),
                                  &l_SysProv, NULL, 0))
        goto ErrorExit;

    memcpy(&pPStore->SigType, &l_DefTypeGuid, sizeof(GUID));
    memcpy(&pPStore->SigSubtype, &l_DefSigGuid, sizeof(GUID));
    memcpy(&pPStore->ExchType, &l_DefTypeGuid, sizeof(GUID));
    memcpy(&pPStore->ExchSubtype, &l_DefExchGuid, sizeof(GUID));
    fRet = TRUE;

ErrorExit:
    return fRet;
}


DWORD
CreateNewPSKeyset(
    PSTORE_INFO *pPStore,
    DWORD dwFlags)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    PST_ACCESSRULE      rgRules[2];
    PST_ACCESSRULESET   Rules;
    PST_TYPEINFO        Info;
    PST_PROMPTINFO      PromptInfo = {NULL, NULL};
    HRESULT             hr;
    IPStore             *pIPS = (IPStore*)pPStore->pProv;
    DWORD               dwRegLoc = PST_KEY_CURRENT_USER;

    if (dwFlags & CRYPT_MACHINE_KEYSET)
        dwRegLoc = PST_KEY_LOCAL_MACHINE;

    // if type is not available the create it
    memset(&Info, 0, sizeof(Info));
    Info.cbSize = sizeof(PST_TYPEINFO);
    Info.szDisplayName = CRYPTO_KEY_TYPE_STRING;
    hr = pIPS->CreateType(dwRegLoc, &pPStore->SigType, &Info, 0);
    if ((S_OK != hr) && (PST_E_TYPE_EXISTS != hr))
    {
        dwReturn = (DWORD)hr;
        goto ErrorExit;
    }

    // make same rules for read, write access
    rgRules[0].cbSize = sizeof(PST_ACCESSRULE);
    rgRules[0].AccessModeFlags = PST_READ;
    rgRules[0].cClauses = 0;
    rgRules[0].rgClauses = NULL;
    rgRules[1].cbSize = sizeof(PST_ACCESSRULE);
    rgRules[1].AccessModeFlags = PST_WRITE;
    rgRules[1].cClauses = 0;
    rgRules[1].rgClauses = NULL;

    Rules.cbSize = sizeof(PST_ACCESSRULESET);
    Rules.cRules = 2;
    Rules.rgRules = rgRules;

    // create the signature subtype
    Info.szDisplayName = CRYPTO_SIG_SUBTYPE_STRING;
    PromptInfo.szPrompt = L"";
    hr = pIPS->CreateSubtype(dwRegLoc, &pPStore->SigType,
                             &pPStore->SigSubtype, &Info, &Rules, 0);
    if ((S_OK != hr) && (PST_E_TYPE_EXISTS != hr))
    {
        dwReturn = (DWORD)hr;
        goto ErrorExit;
    }

    // create the exchange subtype
    Info.szDisplayName = CRYPTO_EXCH_SUBTYPE_STRING;
    hr = pIPS->CreateSubtype(dwRegLoc, &pPStore->SigType,
                             &pPStore->ExchSubtype, &Info, &Rules, 0);
    if ((S_OK != hr) && (PST_E_TYPE_EXISTS != hr))
    {
        dwReturn = (DWORD)hr;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


DWORD
GetKeysetTypeAndSubType(
    PNTAGUserList pUser)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BYTE    *pb1 = NULL;
    DWORD   cb1;
    BYTE    *pb2 = NULL;
    DWORD   cb2;
    DWORD   dwSts;

    memcpy(&pUser->pPStore->SigType, &l_DefTypeGuid, sizeof(GUID));
    memcpy(&pUser->pPStore->SigSubtype, &l_DefSigGuid, sizeof(GUID));
    memcpy(&pUser->pPStore->ExchType, &l_DefTypeGuid, sizeof(GUID));
    memcpy(&pUser->pPStore->ExchSubtype, &l_DefExchGuid, sizeof(GUID));

    // look in registry and see if the type and subtype Guids are there
    dwSts = ReadRegValue(pUser->hKeys, "SigTypeSubtype", &pb1, &cb1, TRUE);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwSts = ReadRegValue(pUser->hKeys, "ExchTypeSubtype", &pb2, &cb2, TRUE);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (pb1)
    {
        memcpy(&pUser->pPStore->SigType, pb1, sizeof(GUID));
        memcpy(&pUser->pPStore->SigSubtype, pb1 + sizeof(GUID), sizeof(GUID));
    }

    if (pb2)
    {
        memcpy(&pUser->pPStore->ExchType, pb2, sizeof(GUID));
        memcpy(&pUser->pPStore->ExchSubtype, pb2 + sizeof(GUID), sizeof(GUID));
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pb1)
        _nt_free(pb1, cb1);
    if (pb2)
        _nt_free(pb2, cb2);
    return dwReturn;
}


DWORD
SetUIPrompt(
    PNTAGUserList pUser,
    LPWSTR szPrompt)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD   cb = 0;
    LPWSTR  sz = NULL;

    // check if sig or exch keys are loaded and if so error
    if (NULL == pUser->pPStore)
    {
        dwReturn = (DWORD)NTE_BAD_KEYSET;
        goto ErrorExit;
    }

    if (NULL != szPrompt)
    {
        cb = (lstrlenW(szPrompt) + 1) * sizeof(WCHAR);

        sz = (LPWSTR)_nt_malloc(cb);
        if (NULL == sz)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        lstrcpyW(sz, szPrompt);
    }

    if (pUser->pPStore->szPrompt)
        _nt_free(pUser->pPStore->szPrompt, pUser->pPStore->cbPrompt);

    pUser->pPStore->cbPrompt = cb;
    pUser->pPStore->szPrompt = sz;

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*static*/ DWORD
PickleKey(
    BOOL fExportable,
    size_t cbPriv,
    PBYTE pbPriv,
    PBYTE *ppbData,
    PDWORD pcbData)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;

    if (NULL != pbPriv)
    {
        // alloc the appropriate amount of space
        *pcbData = cbPriv + sizeof(DWORD) + sizeof(BOOL);
        *ppbData = (PBYTE)_nt_malloc(*pcbData);
        if (NULL == *ppbData)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        // copy exportable info into buffer
        memcpy(*ppbData, &fExportable, sizeof(BOOL));

        // copy length of keying material into buffer
        memcpy(*ppbData + sizeof(BOOL), &cbPriv, sizeof(DWORD));

        // copy keying material into buffer
        memcpy(*ppbData + sizeof(DWORD) + sizeof(BOOL), pbPriv, cbPriv);
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*static*/ DWORD
UnpickleKey(
    PBYTE pbData,
    BOOL *pfExportable,
    DWORD *pcbPriv,
    PBYTE *ppbPriv)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;

    if (NULL != pbData)
    {
        // pull out the exportable info
        memcpy(pfExportable, pbData, sizeof(BOOL));

        // pull out the length of the key material
        memcpy(pcbPriv, pbData + sizeof(BOOL), sizeof(DWORD));

        // free the current key material memory
        if (NULL != *ppbPriv)
            _nt_free(*ppbPriv, *pcbPriv);

        // alloc new memory for the key material
        *ppbPriv = (PBYTE)_nt_malloc(*pcbPriv);
        if (NULL == *ppbPriv)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        // copy key material
        memcpy(*ppbPriv, pbData + sizeof(DWORD) + sizeof(BOOL), *pcbPriv);
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*static*/ DWORD
RestoreKeyFromProtectedStorage(
    PNTAGUserList pUser,
    LPWSTR szKeyName,
    BYTE **ppbKey,
    DWORD *pcbKey,
    LPWSTR szPrompt,
    BOOL fSigKey,
    BOOL fMachineKeySet,
    BOOL *pfUIOnKey)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    HRESULT         hr;
    DWORD           cb;
    BYTE            *pb = NULL;
    GUID            *pType;
    GUID            *pSubtype;
    BOOL            *pf;
    PST_PROMPTINFO  PromptInfo;
    IPStore         *pIPS = (IPStore*)(pUser->pPStore->pProv);
    DWORD           dwRegLoc = PST_KEY_CURRENT_USER;
    DWORD           dwSts;

    *pfUIOnKey = FALSE;

    if (fMachineKeySet)
        dwRegLoc = PST_KEY_LOCAL_MACHINE;

    memset(&PromptInfo, 0, sizeof(PromptInfo));
    PromptInfo.cbSize = sizeof(PST_PROMPTINFO);
    if (fSigKey)
    {
        if (0 == pUser->ContInfo.ContLens.cbSigPub)
        {
            dwReturn = ERROR_SUCCESS;
            goto ErrorExit;
        }

        pType = &pUser->pPStore->SigType;
        pSubtype = &pUser->pPStore->SigSubtype;
        pf = &pUser->ContInfo.fSigExportable;
    }
    else
    {
        if (0 == pUser->ContInfo.ContLens.cbExchPub)
        {
            dwReturn = ERROR_SUCCESS;
            goto ErrorExit;
        }

        pType = &pUser->pPStore->ExchType;
        pSubtype = &pUser->pPStore->ExchSubtype;
        pf = &pUser->ContInfo.fExchExportable;
    }

    // read the item from secure storage
    PromptInfo.hwndApp = NULL;
    if (NULL == pUser->pPStore->szPrompt)
        PromptInfo.szPrompt = szPrompt;
    else
        PromptInfo.szPrompt = pUser->pPStore->szPrompt;

    hr = pIPS->ReadItem(dwRegLoc, pType, pSubtype, szKeyName, &cb,
                                     &pb, &PromptInfo,
                                     PST_PROMPT_QUERY | PST_NO_UI_MIGRATION);
    if (S_OK != hr)
    {
        // this function returns PST_E_ITEM_EXISTS if there is UI on the item
        if (PST_E_ITEM_EXISTS == hr)
            *pfUIOnKey = TRUE;
        else
        {
            dwReturn = (DWORD)hr;
            goto ErrorExit;
        }
    }

    dwSts = UnpickleKey(pb, pf, pcbKey, ppbKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pb)
        CoTaskMemFree(pb);
    return dwReturn;
}


/*static*/ DWORD
MakeUnicodeKeysetName(
    BYTE *pszName,
    LPWSTR *ppszWName)
{
    // ?BUGBUG? -- We don't really do this, do we?
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    long    i;
    DWORD   cb;

    cb = (DWORD)lstrlenA((LPSTR)pszName);
    *ppszWName = (LPWSTR)_nt_malloc((cb + 1) * sizeof(WCHAR));
    if (NULL == *ppszWName)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    for (i=0;i<(long)cb;i++)
        (*ppszWName)[i] = (WCHAR)(pszName[i]);

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


DWORD
RestoreKeysetFromProtectedStorage(
    PNTAGUserList pUser,
    LPWSTR szPrompt,
    BYTE **ppbKey,
    DWORD *pcbKey,
    BOOL fSigKey,
    BOOL fMachineKeySet,
    BOOL *pfUIOnKey)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    LPWSTR  pszWName = NULL;
    DWORD   dwSts;

    // convert the keyset name to unicode
    dwSts = MakeUnicodeKeysetName((BYTE*)pUser->ContInfo.pszUserName,
                                  &pszWName);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // restore the signature key
    dwSts = RestoreKeyFromProtectedStorage(pUser, pszWName, ppbKey, pcbKey,
                                           szPrompt, fSigKey, fMachineKeySet,
                                           pfUIOnKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pszWName)
        _nt_free(pszWName, (wcslen(pszWName) + 1) * sizeof(WCHAR));
    return dwReturn;
}


void
RemoveKeysetFromMemory(
    PNTAGUserList pUser)
{
    pUser->ContInfo.fSigExportable = FALSE;
    if (pUser->pSigPrivKey)
    {
        _nt_free(pUser->pSigPrivKey, pUser->SigPrivLen);
        pUser->SigPrivLen = 0;
        pUser->pSigPrivKey = NULL;
    }

    pUser->ContInfo.fExchExportable = FALSE;
    if (pUser->pExchPrivKey)
    {
        _nt_free(pUser->pExchPrivKey, pUser->ExchPrivLen);
        pUser->ExchPrivLen = 0;
        pUser->pExchPrivKey = NULL;
    }
}


DWORD
SaveKeyToProtectedStorage(
    PNTAGUserList pUser,
    DWORD dwFlags,
    LPWSTR szPrompt,
    BOOL fSigKey,
    BOOL fMachineKeySet)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    HRESULT         hr;
    PBYTE           pb = NULL;
    DWORD           cb;
    GUID            *pType;
    GUID            *pSubtype;
    BOOL            f;
    BYTE            *pbKey = NULL;
    size_t          cbKey;
    LPWSTR          pszWName = NULL;
    LPSTR           szKeyName;
    PST_PROMPTINFO  PromptInfo;
    IPStore         *pIPS = (IPStore*)(pUser->pPStore->pProv);
    DWORD           dwRegLoc = PST_KEY_CURRENT_USER;
    DWORD           dwConfirm = PST_CF_NONE;
    DWORD           dwSts;

    if (fMachineKeySet)
        dwRegLoc = PST_KEY_LOCAL_MACHINE;

    memset(&PromptInfo, 0, sizeof(PromptInfo));
    PromptInfo.cbSize = sizeof(PST_PROMPTINFO);
    if (fSigKey)
    {
        pType = &pUser->pPStore->SigType;
        pSubtype = &pUser->pPStore->SigSubtype;
        f = pUser->ContInfo.fSigExportable;
        cbKey = pUser->SigPrivLen;
        pbKey = pUser->pSigPrivKey;
        szKeyName = "SPbK";
        if (dwFlags & CRYPT_USER_PROTECTED)
            dwConfirm = PST_CF_DEFAULT;
    }
    else
    {
        pType = &pUser->pPStore->ExchType;
        pSubtype = &pUser->pPStore->ExchSubtype;
        f = pUser->ContInfo.fExchExportable;
        cbKey = pUser->ExchPrivLen;
        pbKey = pUser->pExchPrivKey;
        szKeyName = "EPbK";
        if (dwFlags & CRYPT_USER_PROTECTED)
            dwConfirm = PST_CF_DEFAULT;
    }

    // format the signature key and exportable info
    dwSts = PickleKey(f, cbKey, pbKey, &pb, &cb);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (pb)
    {
        // make a unicode version of the keyset name
        dwSts = MakeUnicodeKeysetName((BYTE*)pUser->ContInfo.pszUserName,
                                      &pszWName);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        PromptInfo.hwndApp = NULL;
        if (NULL == pUser->pPStore->szPrompt)
            PromptInfo.szPrompt = szPrompt;
        else
            PromptInfo.szPrompt = pUser->pPStore->szPrompt;

        hr = pIPS->WriteItem(dwRegLoc, pType, pSubtype, pszWName,
                             cb, pb, &PromptInfo, dwConfirm, 0);
        if (S_OK != hr)
        {
            dwReturn = (DWORD)hr;
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pb)
        _nt_free(pb, cb);
    if (pszWName)
        _nt_free(pszWName, (wcslen(pszWName) + 1) * sizeof(WCHAR));
    return dwReturn;
}


DWORD
DeleteKeyFromProtectedStorage(
    NTAGUserList *pUser,
    PCSP_STRINGS pStrings,
    DWORD dwKeySpec,
    BOOL fMachineKeySet,
    BOOL fMigration)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    LPWSTR          szWUserName = NULL;
    PST_PROMPTINFO  PromptInfo;
    IPStore         *pIPS;
    DWORD           dwRegLoc = PST_KEY_CURRENT_USER;
    DWORD           dwSts;

    memset(&PromptInfo, 0, sizeof(PromptInfo));
    PromptInfo.cbSize = sizeof(PST_PROMPTINFO);
    PromptInfo.hwndApp = NULL;

    if (fMachineKeySet)
        dwRegLoc = PST_KEY_LOCAL_MACHINE;

    // make a unicode name
    dwSts = MakeUnicodeKeysetName((BYTE*)pUser->ContInfo.pszUserName,
                                  &szWUserName);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    pIPS = (IPStore*)(pUser->pPStore->pProv);

    if (AT_SIGNATURE == dwKeySpec)
    {
        if (fMigration)
            PromptInfo.szPrompt = pStrings->pwszDeleteMigrSig;
        else
            PromptInfo.szPrompt = pStrings->pwszDeleteSig;
        pIPS->DeleteItem(dwRegLoc,
                         &pUser->pPStore->SigType,
                         &pUser->pPStore->SigSubtype,
                         szWUserName,
                         &PromptInfo,
                         PST_NO_UI_MIGRATION);
    }
    else
    {
        if (fMigration)
            PromptInfo.szPrompt = pStrings->pwszDeleteMigrExch;
        else
            PromptInfo.szPrompt = pStrings->pwszDeleteExch;
        pIPS->DeleteItem(dwRegLoc,
                         &pUser->pPStore->ExchType,
                         &pUser->pPStore->ExchSubtype,
                         szWUserName,
                         &PromptInfo,
                         PST_NO_UI_MIGRATION);
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (szWUserName)
        _nt_free(szWUserName, (wcslen(szWUserName) + 1) * sizeof(WCHAR));
    return dwReturn;
}


DWORD
DeleteFromProtectedStorage(
    CONST char *pszUserID,
    PCSP_STRINGS pStrings,
    HKEY hRegKey,
    BOOL fMachineKeySet)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    NTAGUserList    User;
    DWORD           dwSts;

    // set up the User List structure
    memset(&User, 0, sizeof(User));
    User.ContInfo.pszUserName = (LPSTR)pszUserID;
    User.hKeys = hRegKey;

    User.pPStore = (PSTORE_INFO*)_nt_malloc(sizeof(PSTORE_INFO));
    if (NULL == User.pPStore)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    if (!CheckPStoreAvailability(User.pPStore))
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    // get type and subtypes
    dwSts = GetKeysetTypeAndSubType(&User);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // delete each key
    dwSts = DeleteKeyFromProtectedStorage(&User, pStrings, AT_SIGNATURE,
                                          fMachineKeySet, FALSE);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }
    dwSts = DeleteKeyFromProtectedStorage(&User, pStrings, AT_KEYEXCHANGE,
                                          fMachineKeySet, FALSE);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (User.pPStore)
        FreePSInfo(User.pPStore);
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\rsaaes\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rsabase.rc
//
#define IDS_NOSIG                       1
#define IDS_SIZEFILE                    2
#define IDS_MEMORY                      3
#define IDS_READFILE                    4
#define IDS_OPENREGISTRY                5
#define IDS_WRITEREGISTRY               6
#define IDS_OPENDLL                     7
#define IDS_SIZEDLL                     8
#define IDS_READDLL                     9
#define IDS_REINSTALL                   10
#define IDS_READREGISTRY                11
#define IDS_BADINSTALL                  12
#define IDS_NORES                       13
#define IDS_BADRES                      14
#define IDS_ALLOW_CHKBOX_TEXT           15
#define IDS_PASSWORD_PROMPT             18
#define IDS_CONFIRM_PASSWORD_PROMPT     19
#define IDS_OLD_PASSWORD_PROMPT         20
#define IDS_GENKEY_BOXTEXT              21
#define IDS_GENKEY_OW_BOXTEXT           22
#define IDS_IMPORT_PRIVATE_BOXTEXT      23
#define IDS_IMPORT_PRIVATE_OW_BOXTEXT   24
#define IDS_SIGN_BOXTEXT                25
#define IDS_EXPORT_PRIVATE_BOXTEXT      27
#define IDS_IMPORT_SIMPLE_BOXTEXT       28
#define IDS_CHANGEPASS_BOXTEXT          29
#define IDS_NEW_PASSWORD_TITLE          30
#define IDS_SOLICIT_PASSWORD_TITLE      31
#define IDS_OVERWRITE_PASSWORD_TITLE    32
#define IDS_AT_SIGNATURE                33
#define IDS_AT_KEYEXCHANGE              34
#define IDD_NEW_PASSWORD                101
#define IDD_SOLICIT_PASSWORD            102
#define IDD_OVERWRITE_PASSWORD          103
#define IDC_EDIT1                       1000
#define IDC_EDIT2                       1001
#define IDC_PASSWORD_STATICTEXT         1002
#define IDC_CONFIRM_PASSWORD_STATICTEXT 1003
#define IDC_EDIT3                       1005
#define IDC_OLD_PASSWORD_STATICTEXT     1006
#define IDC_CHECK_NOASK                 1007
#define IDC_BOXTEXT                     1008

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\rsaaes\swnt_pk.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : swnt_pk.c                                              //
//  DESCRIPTION   :                                                        //
//  Software nametag public key management functions.  These functions     //
//  isolate the peculiarities of public key management without a token     //
//                                                                         //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//  Jan 25 1995 larrys   Changed from Nametag                              //
//  Mar 01 1995 terences Fixed key pair handle creation                    //
//  Mar 08 1995 larrys   Fixed warning                                     //
//  Mar 23 1995 larrys   Added variable key length                         //
//  Apr 17 1995 larrys   Added 1024 key gen                                //
//  Apr 19 1995 larrys   Changed CRYPT_EXCH_PUB to AT_KEYEXCHANGE          //
//  Aug 16 1995 larrys   Removed exchange key stuff                        //
//  Sep 12 1995 larrys   Removed 2 DWORDS from exported keys               //
//  Sep 28 1995 larrys   Changed format of PKCS                            //
//  Oct 04 1995 larrys   Fixed problem with PKCS format                    //
//  Oct 27 1995 rajeshk  RandSeed Stuff added hUID to PKCS2Encrypt         //
//  Nov  3 1995 larrys   Merge for NT checkin                              //
//  Dec 11 1995 larrys   Added check for error return from RSA routine     //
//  May 15 1996 larrys  Changed NTE_NO_MEMORY to ERROR_NOT_ENOUGHT...      //
//  Oct 14 1996 jeffspel Changed GenRandoms to NewGenRandoms               //
//  May  8 2000 dbarlow Reworked status return codes                       //
//                                                                         //
//  Copyright (C) 1993 - 2000, Microsoft Corporation                       //
//  All Rights Reserved                                                    //
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "randlib.h"
#include "ntagum.h"
#include "swnt_pk.h"
#include "protstor.h"
#include "sha.h"

#define GetNextAlignedValue(c, alignment)   ((c + alignment) & ~(alignment - 1))

extern CSP_STRINGS g_Strings;

extern void
FIPS186GenRandomWithException(
    IN HANDLE *phRNGDriver,
    IN BYTE **ppbContextSeed,
    IN DWORD *pcbContextSeed,
    IN OUT BYTE *pb,
    IN DWORD cb);


// do the modular exponentiation calculation M^PubKey mod N

DWORD
RSAPublicEncrypt(
    IN PEXPO_OFFLOAD_STRUCT pOffloadInfo,
    IN BSAFE_PUB_KEY *pBSPubKey,
    IN BYTE *pbInput,
    IN BYTE *pbOutput)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BOOL    fOffloadSuccess = FALSE;
    DWORD   cbMod;

    //
    // Two checks (needed for FIPS) before offloading to the offload
    // module.
    //
    // First check is if there is an offload module, this
    // will only be the case if the pOffloadInfo is not NULL.
    //
    // Second check is if this public key is OK, by checking
    // the magic value in the key struct.
    //
    if (NULL != pOffloadInfo)
    {
        if (RSA1 != pBSPubKey->magic)
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        cbMod = (pBSPubKey->bitlen + 7) / 8;
        fOffloadSuccess = ModularExpOffload(pOffloadInfo,
                                            pbInput,
                                            (BYTE*)&(pBSPubKey->pubexp),
                                            sizeof(pBSPubKey->pubexp),
                                            (BYTE*)pBSPubKey +
                                            sizeof(BSAFE_PUB_KEY),
                                            cbMod, pbOutput, NULL, 0);
    }

    if (!fOffloadSuccess)
    {
        if (!BSafeEncPublic(pBSPubKey, pbInput, pbOutput))
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;  // ?Really?
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


// do the modular exponentiation calculation M^PrivKey Exponent mod N

DWORD
RSAPrivateDecrypt(
    IN PEXPO_OFFLOAD_STRUCT pOffloadInfo,
    IN BSAFE_PRV_KEY *pBSPrivKey,
    IN BYTE *pbInput,
    IN BYTE *pbOutput)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BOOL    fOffloadSuccess = FALSE;
    DWORD   cbMod;
    DWORD   cbHalfKeylen;
    OFFLOAD_PRIVATE_KEY OffloadPrivateKey;

    //
    // Two checks (needed for FIPS) before offloading to the offload
    // module.
    //
    // First check is if there is an offload module, this
    // will only be the case if the pOffloadInfo is not NULL.
    //
    // Second check is if this private key is OK, by checking
    // the magic value in the key struct.
    //

    if (NULL != pOffloadInfo)
    {
        if (RSA2 != pBSPrivKey->magic)
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }

        cbMod = (pBSPrivKey->bitlen + 7) / 8;
        cbHalfKeylen = (pBSPrivKey->keylen + 1) / 2;

        OffloadPrivateKey.dwVersion = CUR_OFFLOAD_VERSION;
        OffloadPrivateKey.pbPrime1 = 
            (BYTE*)pBSPrivKey + sizeof(BSAFE_PRV_KEY) + cbHalfKeylen * 2;
        OffloadPrivateKey.cbPrime1 = cbHalfKeylen;
        OffloadPrivateKey.pbPrime2 = 
            (BYTE*)pBSPrivKey + sizeof(BSAFE_PRV_KEY) + cbHalfKeylen * 3;
        OffloadPrivateKey.cbPrime2 = cbHalfKeylen;

        fOffloadSuccess = ModularExpOffload(pOffloadInfo,
                                            pbInput,
                                            (BYTE*)pBSPrivKey + sizeof(BSAFE_PUB_KEY)
                                            + cbHalfKeylen * 7,
                                            cbMod,
                                            (BYTE*)pBSPrivKey + sizeof(BSAFE_PUB_KEY),
                                            cbMod, pbOutput, (PVOID) &OffloadPrivateKey, 0);
    }

    if (!fOffloadSuccess)
    {
        if (!BSafeDecPrivate(pBSPrivKey, pbInput, pbOutput))
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY; // ?Really?
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


BOOL
CheckDataLenForRSAEncrypt(
    IN DWORD cbMod,   // length of the modulus
    IN DWORD cbData,  // length of the data
    IN DWORD dwFlags) // flags
{
    BOOL    fRet = FALSE;

    if (dwFlags & CRYPT_OAEP)
    {
        // if the OAEP flag is set then check for that length
        if (cbMod < (cbData + A_SHA_DIGEST_LEN * 2 + 1))
            goto ErrorExit;
    }
    else
    {
        // Check for PKCS 1 type 2 padding
        // one byte for the top zero byte, one byte for the type,
        // and one byte for the low zero byte,
        // plus a minimum padding string is 8 bytes
        if (cbMod < (cbData + 11))
            goto ErrorExit;
    }

    fRet = TRUE;

ErrorExit:
    return fRet;
}


/************************************************************************/
/* MaskGeneration generates a mask for OAEP based on the SHA1 hash      */
/* function.                                                            */
/* NULL for the ppbMask parameter indicates the buffer is to be alloced.*/
/************************************************************************/

/*static*/ DWORD
MaskGeneration(
    IN BYTE *pbSeed,
    IN DWORD cbSeed,
    IN DWORD cbMask,
    OUT BYTE **ppbMask,
    IN BOOL fAlloc)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    DWORD       dwCount;
    BYTE        rgbCount[sizeof(DWORD)];
    BYTE        *pbCount;
    A_SHA_CTX   SHA1Ctxt;
    DWORD       cb = cbMask;
    BYTE        *pb;
    DWORD       i;
    DWORD       j;

    // NULL for *ppbMask indicates the buffer is to be alloced
    if (fAlloc)
    {
        *ppbMask = (BYTE*)_nt_malloc(cbMask);
        if (NULL == *ppbMask)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }
    }
    pb = *ppbMask;

    dwCount = (cbMask + (A_SHA_DIGEST_LEN - 1)) / A_SHA_DIGEST_LEN;

    for (i = 0; i < dwCount; i++)
    {
        // clear the hash context
        memset(&SHA1Ctxt, 0, sizeof(SHA1Ctxt));

        // hash the seed and the count
        A_SHAInit(&SHA1Ctxt);
        A_SHAUpdate(&SHA1Ctxt, pbSeed, cbSeed);
        // Reverse the count bytes
        pbCount = (BYTE*)&i;
        for (j = 0; j < sizeof(DWORD); j++)
            rgbCount[j] = pbCount[sizeof(DWORD) - j - 1];
        A_SHAUpdate(&SHA1Ctxt, rgbCount, sizeof(DWORD));
        A_SHAFinal(&SHA1Ctxt, SHA1Ctxt.HashVal);

        // copy the bytes from this hash into the mask buffer
        if (cb >= A_SHA_DIGEST_LEN)
            memcpy(pb, SHA1Ctxt.HashVal, A_SHA_DIGEST_LEN);
        else
        {
            memcpy(pb, SHA1Ctxt.HashVal, cb);
            break;
        }
        cb -= A_SHA_DIGEST_LEN;
        pb += A_SHA_DIGEST_LEN;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/************************************************************************/
/* ApplyPadding applies OAEP (Bellare-Rogoway) padding to a RSA key     */
/* blob.  The function does the seed generation, MGF and masking.       */
/************************************************************************/

/*static*/ DWORD
ApplyPadding(
    IN PNTAGUserList pTmpUser,
    IN OUT BYTE* pb,            // buffer
    IN DWORD cb)                // length of the data to mask not including seed
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BYTE    rgbSeed[A_SHA_DIGEST_LEN];
    BYTE    *pbMask = NULL;
    BYTE    rgbSeedMask[A_SHA_DIGEST_LEN];
    BYTE    *pbSeedMask;
    DWORD   i;
    DWORD   dwSts;

    // generate the random seed
    dwSts = FIPS186GenRandom(&pTmpUser->hRNGDriver,
                             &pTmpUser->ContInfo.pbRandom,
                             &pTmpUser->ContInfo.ContLens.cbRandom,
                             rgbSeed, A_SHA_DIGEST_LEN);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;    // NTE_FAIL
        goto ErrorExit;
    }

    // generate the data mask from the seed
    dwSts = MaskGeneration(rgbSeed, sizeof(rgbSeed), cb, &pbMask, TRUE);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // XOR the data mask with the data
    for (i = 0; i < cb; i++)
        pb[i + A_SHA_DIGEST_LEN + 1] = (BYTE)(pb[i + A_SHA_DIGEST_LEN + 1] ^ pbMask[i]);

    // generate the seed mask from the masked data
    pbSeedMask = rgbSeedMask;
    dwSts = MaskGeneration(pb + A_SHA_DIGEST_LEN + 1, cb,
                           A_SHA_DIGEST_LEN, &pbSeedMask, FALSE);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // XOR the seed mask with the seed and put that into the
    // pb buffer
    for (i = 0; i < A_SHA_DIGEST_LEN; i++)
        pb[i + 1] = (BYTE)(rgbSeed[i] ^ rgbSeedMask[i]);

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pbMask)
        _nt_free(pbMask, cb);
    return dwReturn;
}


/************************************************************************/
/* RemovePadding checks OAEP (Bellare-Rogoway) padding on a RSA decrypt */
/* blob.                                                                */
/************************************************************************/

/*static*/ DWORD
RemovePadding(
    IN OUT BYTE* pb,
    IN DWORD cb)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BYTE    rgbSeedMask[A_SHA_DIGEST_LEN];
    BYTE    *pbSeedMask;
    BYTE    *pbMask = NULL;
    DWORD   i;
    DWORD   dwSts;

    memset(rgbSeedMask, 0, A_SHA_DIGEST_LEN);

    // check the most significant byte is 0x00
    if (0x00 != pb[0])
    {
        dwReturn = (DWORD)NTE_BAD_DATA;
        goto ErrorExit;
    }

    // generate the seed mask from the masked data
    pbSeedMask = rgbSeedMask;
    dwSts = MaskGeneration(pb + A_SHA_DIGEST_LEN + 1, cb - (A_SHA_DIGEST_LEN + 1),
                           A_SHA_DIGEST_LEN, &pbSeedMask, FALSE);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // XOR the seed mask with the seed and put that into the
    // pb buffer
    for (i = 0; i < A_SHA_DIGEST_LEN; i++)
        pb[i + 1] = (BYTE)(pb[i + 1] ^ rgbSeedMask[i]);

    // generate the data mask from the seed
    dwSts = MaskGeneration(pb + 1, A_SHA_DIGEST_LEN,
                           cb - (A_SHA_DIGEST_LEN + 1), &pbMask, TRUE);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // XOR the data mask with the data
    for (i = 0; i < cb - (A_SHA_DIGEST_LEN + 1); i++)
    {
        pb[i + A_SHA_DIGEST_LEN + 1] =
            (BYTE)(pb[i + A_SHA_DIGEST_LEN + 1] ^ pbMask[i]);
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pbMask)
        _nt_free(pbMask, cb - (A_SHA_DIGEST_LEN + 1));
    return dwReturn;
}


/************************************************************************/
/* OAEPEncrypt performs a RSA encryption using OAEP (Bellare-Rogoway)   */
/* as the padding scheme.  The current implementation uses SHA1 as the  */
/* hash function.                                                       */
/************************************************************************/

/*static*/ DWORD
OAEPEncrypt(
    IN PNTAGUserList pTmpUser,
    IN BSAFE_PUB_KEY *pBSPubKey,
    IN BYTE *pbPlaintext,
    IN DWORD cbPlaintext,
    IN BYTE *pbParams,
    IN DWORD cbParams,
    OUT BYTE *pbOut)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    BYTE        *pbInput = NULL;
    BYTE        *pbOutput = NULL;
    BYTE        *pbReverse = NULL;
    A_SHA_CTX   SHA1Ctxt;
    DWORD       i;
    DWORD       cb;
    DWORD       dwSts;

    memset(&SHA1Ctxt, 0, sizeof(SHA1Ctxt));

    // start off by hashing the Encoding parameters (pbParams)
    A_SHAInit(&SHA1Ctxt);
    if (0 != cbParams)
        A_SHAUpdate(&SHA1Ctxt, pbParams, cbParams);
    A_SHAFinal(&SHA1Ctxt, SHA1Ctxt.HashVal);

    // alloc space for an internal buffer
    pbInput = (BYTE *)_nt_malloc(pBSPubKey->keylen * 2
                                 + ((pBSPubKey->bitlen + 7) / 8));
    if (NULL == pbInput)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    pbOutput = pbInput + pBSPubKey->keylen;
    pbReverse = pbInput + pBSPubKey->keylen * 2;

    // add the pHash
    memcpy(pbReverse + A_SHA_DIGEST_LEN + 1, SHA1Ctxt.HashVal,
           A_SHA_DIGEST_LEN);

    // figure the length of PS,

    // put the 0x01 byte in, skipping past the PS,
    // note that the PS is zero bytes so it is just there
    cb = ((pBSPubKey->bitlen + 7) / 8) - (1 + cbPlaintext);
    pbReverse[cb] = 0x01;
    cb++;

    // copy in the message bytes
    memcpy(pbReverse + cb, pbPlaintext, cbPlaintext);

    // do the seed generation, MGF and masking
    cb = ((pBSPubKey->bitlen + 7) / 8) - (A_SHA_DIGEST_LEN + 1);
    dwSts = ApplyPadding(pTmpUser, pbReverse, cb);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // byte reverse the whole thing before RSA encrypting
    for (i = 0; i < (pBSPubKey->bitlen + 7) / 8; i++)
        pbInput[i] = pbReverse[((pBSPubKey->bitlen + 7) / 8) - i - 1];

    // RSA encrypt this
    dwSts = RSAPublicEncrypt(pTmpUser->pOffloadInfo, pBSPubKey,
                             pbInput, pbOutput);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;    // NTE_FAIL
        goto ErrorExit;
    }

    memcpy(pbOut, pbOutput, (pBSPubKey->bitlen + 7) / 8);

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pbInput)
    {
        memset(pbInput, 0, pBSPubKey->keylen * 2 + (pBSPubKey->bitlen + 7) / 8);
        _nt_free(pbInput, pBSPubKey->keylen * 2 + (pBSPubKey->bitlen + 7) / 8);
    }
    return dwReturn;
}


/************************************************************************/
/* OAEPDecrypt performs a RSA decryption checking that OAEP             */
/* (Bellare-Rogoway) is the padding scheme.  The current implementation */
/* uses SHA1 as the hash function.                                      */
/************************************************************************/

/*static*/ DWORD
OAEPDecrypt(
    IN PNTAGUserList pTmpUser,
    IN BSAFE_PRV_KEY *pBSPrivKey,
    IN CONST BYTE *pbBlob,
    IN DWORD cbBlob,
    IN BYTE *pbParams,
    IN DWORD cbParams,
    OUT BYTE **ppbPlaintext,
    OUT DWORD *pcbPlaintext)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    BYTE*       pbOutput = NULL;
    BYTE*       pbInput = NULL;
    BYTE*       pbReverse = NULL;
    A_SHA_CTX   SHA1Ctxt;
    DWORD       cb;
    DWORD       i;
    DWORD       dwSts;
    DWORD       dwAlignedBufLen = 0;

    memset(&SHA1Ctxt, 0, sizeof(SHA1Ctxt));

    cb = (pBSPrivKey->bitlen + 7) / 8;
    if (cbBlob > cb)
    {
        dwReturn = (DWORD)NTE_BAD_DATA;
        goto ErrorExit;
    }

    dwAlignedBufLen = GetNextAlignedValue(pBSPrivKey->keylen + 2, sizeof(DWORD));
    pbOutput = (BYTE *)_nt_malloc(dwAlignedBufLen * 2 + cb);
    if (NULL == pbOutput)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    pbInput = pbOutput + dwAlignedBufLen;
    pbReverse = pbOutput + dwAlignedBufLen * 2;

    // perform the RSA decryption
    memcpy(pbInput, pbBlob, cb);
    dwSts = RSAPrivateDecrypt(pTmpUser->pOffloadInfo, pBSPrivKey,
                              pbInput, pbOutput);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;    // NTE_FAIL
        goto ErrorExit;
    }

    for (i = 0; i < cb; i++)
        pbReverse[i] = pbOutput[cb - i - 1];

    // remove OAEP (Bellare-Rogoway) padding
    dwSts = RemovePadding(pbReverse, cb);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;    // NTE_FAIL
        goto ErrorExit;
    }

    // hash the Encoding parameters (pbParams)
    A_SHAInit(&SHA1Ctxt);
    if (0 != cbParams)
        A_SHAUpdate(&SHA1Ctxt, pbParams, cbParams);
    A_SHAFinal(&SHA1Ctxt, SHA1Ctxt.HashVal);

    // check the hash of the encoding parameters against the message
    if (0 != memcmp(SHA1Ctxt.HashVal, pbReverse + A_SHA_DIGEST_LEN + 1,
                    A_SHA_DIGEST_LEN))
    {
        dwReturn = (DWORD)NTE_BAD_DATA;
        goto ErrorExit;
    }

    // check the zero bytes and check the 0x01 byte
    for (i = A_SHA_DIGEST_LEN * 2 + 1; i < cb; i++)
    {
        if (0x01 == pbReverse[i])
        {
            i++;
            break;
        }
        else if (0x00 != pbReverse[i])
        {
            dwReturn = (DWORD)NTE_BAD_DATA;
            goto ErrorExit;
        }
    }

    *pcbPlaintext = cb - i;
    *ppbPlaintext = (BYTE*)_nt_malloc(*pcbPlaintext);
    if (NULL == *ppbPlaintext)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    memcpy(*ppbPlaintext, pbReverse + i, *pcbPlaintext);

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    // scrub the output buffer
    if (pbOutput)
    {
        memset(pbOutput, 0, dwAlignedBufLen * 2 + cb);
        _nt_free(pbOutput, dwAlignedBufLen * 2 + cb);
    }
    return dwReturn;
}


/*static*/ DWORD
PKCS2Encrypt(
    PNTAGUserList pTmpUser,
    DWORD dwFlags,
    BSAFE_PUB_KEY *pKey,
    BYTE *InBuf,
    DWORD InBufLen,
    BYTE *OutBuf)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BYTE    *pScratch = NULL;
    BYTE    *pScratch2 = NULL;
    BYTE    *pLocal;
    DWORD   temp;
    DWORD   z;
    DWORD   dwSts;

    pScratch = (BYTE *)_nt_malloc(pKey->keylen);
    if (NULL == pScratch)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    pScratch2 = (BYTE *)_nt_malloc(pKey->keylen);
    if (NULL == pScratch2)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    memset(pScratch, 0, pKey->keylen);

    pScratch[pKey->datalen - 1] = PKCS_BLOCKTYPE_2;
    dwSts = FIPS186GenRandom(&pTmpUser->hRNGDriver,
                             &pTmpUser->ContInfo.pbRandom,
                             &pTmpUser->ContInfo.ContLens.cbRandom,
                             pScratch+InBufLen+1,
                             (pKey->datalen)-InBufLen-2);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;    // NTE_FAIL
        goto ErrorExit;
    }

    pLocal = pScratch + InBufLen + 1;

    // Need to insure that none of the padding bytes are zero.
    temp = pKey->datalen - InBufLen - 2;
    while (temp)
    {
        if (*pLocal == 0)
        {
            dwSts = FIPS186GenRandom(&pTmpUser->hRNGDriver,
                                     &pTmpUser->ContInfo.pbRandom,
                                     &pTmpUser->ContInfo.ContLens.cbRandom,
                                     pLocal, 1);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;    // NTE_FAIL
                goto ErrorExit;
            }
        }
        else
        {
            pLocal++;
            temp--;
        }
    }

#ifdef CSP_USE_SSL3
    // if SSL2_FALLBACK has been specified then put threes in the 8
    // least significant bytes of the random padding
    if (CRYPT_SSL2_FALLBACK & dwFlags)
        memset(pScratch + InBufLen + 1, 0x03, 8);
#endif

    // Reverse the session key bytes
    for (z = 0; z < InBufLen; ++z)
        pScratch[z] = InBuf[InBufLen - z - 1];

    dwSts = RSAPublicEncrypt(pTmpUser->pOffloadInfo,
                             pKey, pScratch, pScratch2);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    memcpy(OutBuf, pScratch2, (pKey->bitlen + 7) / 8);
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pScratch)
        _nt_free(pScratch, pKey->keylen);
    if (pScratch2)
        _nt_free(pScratch2, pKey->keylen);
    return dwReturn;
}


/*static*/ DWORD
PKCS2Decrypt(
    IN PNTAGUserList pTmpUser,
    IN BSAFE_PRV_KEY *pKey,
    IN DWORD dwFlags,
    IN CONST BYTE *InBuf,
    OUT BYTE **ppbOutBuf,
    OUT DWORD *pcbOutBuf)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD   i;
    BYTE    *pScratch = NULL;
    BYTE    *pScratch2 = NULL;
    DWORD   z;
    DWORD   dwSts;

    pScratch = (BYTE *)_nt_malloc(pKey->keylen * 2);
    if (NULL == pScratch)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    pScratch2 = pScratch + pKey->keylen;
    memcpy(pScratch2, InBuf, (pKey->bitlen + 7) / 8);

    dwSts = RSAPrivateDecrypt(pTmpUser->pOffloadInfo, pKey,
                              pScratch2, pScratch);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;    // NTE_FAIL
        goto ErrorExit;
    }

    if ((pScratch[pKey->datalen - 1] != PKCS_BLOCKTYPE_2) ||
        (pScratch[pKey->datalen] != 0))
    {
        dwReturn = (DWORD) NTE_BAD_DATA;
        goto ErrorExit;
    }

    i = pKey->datalen - 2;

    while ((i > 0) && (pScratch[i]))
        i--;

    *ppbOutBuf = (BYTE *)_nt_malloc(i);
    if (NULL == *ppbOutBuf)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    *pcbOutBuf = i;

#ifdef CSP_USE_SSL3

    // if SSL2_FALLBACK has been specified then check if threes
    // are in the 8  least significant bytes of the random padding
    if (CRYPT_SSL2_FALLBACK & dwFlags)
    {
        BOOL fFallbackError = TRUE;

        for (z = i + 1; z < i + 9; z++)
        {
            if (0x03 != pScratch[z])
            {
                fFallbackError = FALSE;
                break;
            }
        }
        if (fFallbackError)
        {
            dwReturn = (DWORD)NTE_BAD_VER;
            goto ErrorExit;
        }
    }
#endif

    // Reverse the session key bytes
    for (z = 0; z < i; ++z)
        (*ppbOutBuf)[z] = pScratch[i - z - 1];

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pScratch)
        _nt_free(pScratch, pKey->keylen);
    return dwReturn;
}


/************************************************************************/
/* RSAEncrypt performs a RSA encryption.                                */
/************************************************************************/

DWORD
RSAEncrypt(
    IN PNTAGUserList pTmpUser,
    IN BSAFE_PUB_KEY *pBSPubKey,
    IN BYTE *pbPlaintext,
    IN DWORD cbPlaintext,
    IN BYTE *pbParams,
    IN DWORD cbParams,
    IN DWORD dwFlags,
    OUT BYTE *pbOut)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    DWORD dwSts;

    // check the length of the data
    if (!CheckDataLenForRSAEncrypt((pBSPubKey->bitlen + 7) / 8,
                                   cbPlaintext, dwFlags))
    {
        dwReturn = (DWORD)NTE_BAD_LEN;
        goto ErrorExit;
    }

    // use OAEP if the flag is set
    if (dwFlags & CRYPT_OAEP)
    {
        // use OAEP if the flag is set
        dwSts = OAEPEncrypt(pTmpUser, pBSPubKey, pbPlaintext,
                            cbPlaintext, pbParams, cbParams, pbOut);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }
    else
    {
        // use PKCS #1 Type 2
        dwSts = PKCS2Encrypt(pTmpUser, dwFlags, pBSPubKey,
                             pbPlaintext, cbPlaintext, pbOut);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/************************************************************************/
/* RSADecrypt performs a RSA decryption.                                */
/************************************************************************/

DWORD
RSADecrypt(
    IN PNTAGUserList pTmpUser,
    IN BSAFE_PRV_KEY *pBSPrivKey,
    IN CONST BYTE *pbBlob,
    IN DWORD cbBlob,
    IN BYTE *pbParams,
    IN DWORD cbParams,
    IN DWORD dwFlags,
    OUT BYTE **ppbPlaintext,
    OUT DWORD *pcbPlaintext)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD   dwSts;

    // use OAEP if the flag is set
    if (dwFlags & CRYPT_OAEP)
    {
        // use OAEP if the flag is set
        dwSts = OAEPDecrypt(pTmpUser, pBSPrivKey, pbBlob, cbBlob, pbParams,
                            cbParams, ppbPlaintext, pcbPlaintext);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }
    else
    {
        // use PKCS #1 Type 2
        dwSts = PKCS2Decrypt(pTmpUser, pBSPrivKey, dwFlags, pbBlob,
                             ppbPlaintext, pcbPlaintext);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


//
// Function : EncryptAndDecryptWithRSAKey
//
// Description : This function creates a buffer and then encrypts that with
//               the passed in private key and decrypts with the passed in
//               public key.  The function is used for FIPS 140-1 compliance
//               to make sure that newly generated/imported keys work and
//               in the self test during DLL initialization.
//

DWORD
EncryptAndDecryptWithRSAKey(
    IN BYTE *pbRSAPub,
    IN BYTE *pbRSAPriv,
    IN BOOL fSigKey,
    IN BOOL fEncryptCheck)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    BSAFE_PRV_KEY   *pBSafePriv = (BSAFE_PRV_KEY*)pbRSAPriv;
    BYTE            *pb = NULL;
    DWORD           cb;
    DWORD           cbKey;
    DWORD           i;

    // alloc space for the plaintext and ciphertext
    cb = pBSafePriv->keylen;
    cbKey = pBSafePriv->bitlen / 8;
    pb = _nt_malloc(cb * 3);
    if (NULL == pb)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    // reverse the hash so it is in little endian
    for (i = 0; i < 16; i++)
        pb[i] = (BYTE)(i + 1);
    memset(pb + 17, 0xFF, cbKey - 18);

    if (fSigKey)
    {
        // encrypt with the private key
        if (!BSafeDecPrivate(pBSafePriv, pb, pb + cb))
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }
    }
    else
    {
        // encrypt with the public key
        if (!BSafeEncPublic((BSAFE_PUB_KEY*)pbRSAPub, pb, pb + cb))
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }
    }

    // we can't do this check when importing private keys since many
    // applications use private keys with exponent of 1 to import
    // plaintext symmetric keys
    if (fEncryptCheck)
    {
        if (0 == (memcmp(pb, pb + cb, cb)))
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }
    }

    if (fSigKey)
    {
        // decrypt with the public key
        if (!BSafeEncPublic((BSAFE_PUB_KEY*)pbRSAPub, pb + cb, pb + (cb * 2)))
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }
    }
    else
    {
        // encrypt with the private key
        if (!BSafeDecPrivate(pBSafePriv, pb + cb, pb + (cb * 2)))
        {
            dwReturn = (DWORD)NTE_BAD_KEY;
            goto ErrorExit;
        }
    }

    // compare to the plaintext and the decrypted text
    if (memcmp(pb, pb + cb * 2, cbKey))
    {
        dwReturn = (DWORD)NTE_BAD_KEY;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pb)
        _nt_free(pb, cbB * 3);
    return dwReturn;
}


DWORD
ReGenKey(
    HCRYPTPROV hUser,
    DWORD dwFlags,
    DWORD dwWhichKey,
    HCRYPTKEY *phKey,
    DWORD bits)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    BYTE                **ThisPubKey, **ThisPrivKey;
    DWORD               *pThisPubLen, *pThisPrivLen;
    BYTE                *pNewPubKey = NULL;
    BYTE                *pNewPrivKey = NULL;
    DWORD               PrivateKeySize, PublicKeySize;
    DWORD               localbits;
    PNTAGUserList       pOurUser;
    BOOL                fSigKey;
    LPWSTR              szPrompt;
    BOOL                *pfExportable;
    BOOL                fAlloc = FALSE;
    BOOL                fInCritSec = FALSE;
    BSAFE_OTHER_INFO    OtherInfo;
    BSAFE_OTHER_INFO    *pOtherInfo = NULL;
    DWORD               dwSts;
    PNTAGKeyList        pTmpKey = NULL;

    memset(&OtherInfo, 0, sizeof(OtherInfo));

    // ## MTS: No user structure locking
    pOurUser = (PNTAGUserList) NTLCheckList(hUser, USER_HANDLE);
    if (NULL == pOurUser)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    // wrap with a try since there is a critical sections in here
    __try
    {
        EnterCriticalSection(&pOurUser->CritSec);
        fInCritSec = TRUE;

        localbits = bits;

        if (!BSafeComputeKeySizes(&PublicKeySize, &PrivateKeySize,
                                  &localbits))
        {
            dwReturn = (DWORD)NTE_FAIL;
            goto ErrorExit;
        }

        pNewPubKey = (BYTE *)_nt_malloc(PublicKeySize);
        if (NULL == pNewPubKey)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }
        fAlloc = TRUE;

        // allocate space for the new key exchange public key
        pNewPrivKey = (BYTE *)_nt_malloc(PrivateKeySize);
        if (NULL == pNewPrivKey)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        // generate the key exchange key pair
        if (INVALID_HANDLE_VALUE != pOurUser->hRNGDriver)
        {
            OtherInfo.pRNGInfo = &pOurUser->hRNGDriver;
            OtherInfo.pFuncRNG = FIPS186GenRandomWithException;
            pOtherInfo = &OtherInfo;
        }

        // ?Note? -- Shouldn't this be in a try/except?
        if (!BSafeMakeKeyPairEx2(pOtherInfo,
                                 (BSAFE_PUB_KEY *) pNewPubKey,
                                 (BSAFE_PRV_KEY *) pNewPrivKey,
                                 bits,
                                 0x10001))
        {
            dwReturn = (DWORD)NTE_FAIL;
            goto ErrorExit;
        }

        // test the RSA key to make sure it works
        dwSts = EncryptAndDecryptWithRSAKey(pNewPubKey, pNewPrivKey,
                                            TRUE, TRUE);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        // test the RSA key to make sure it works
        dwSts = EncryptAndDecryptWithRSAKey(pNewPubKey, pNewPrivKey,
                                            FALSE, TRUE);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        if (dwWhichKey == NTPK_USE_SIG)
        {
            ThisPubKey = &pOurUser->ContInfo.pbSigPub;
            ThisPrivKey = &pOurUser->pSigPrivKey;
            pThisPubLen = &pOurUser->ContInfo.ContLens.cbSigPub;
            pThisPrivLen = &pOurUser->SigPrivLen;
            pfExportable = &pOurUser->ContInfo.fSigExportable;
            fSigKey = TRUE;
            szPrompt = g_Strings.pwszCreateRSASig;
        }
        else
        {
            ThisPubKey = &pOurUser->ContInfo.pbExchPub;
            ThisPrivKey = &pOurUser->pExchPrivKey;
            pThisPubLen = &pOurUser->ContInfo.ContLens.cbExchPub;
            pThisPrivLen = &pOurUser->ExchPrivLen;
            pfExportable = &pOurUser->ContInfo.fExchExportable;
            fSigKey = FALSE;
            szPrompt = g_Strings.pwszCreateRSAExch;
        }

        if (*ThisPubKey)
        {
            ASSERT(*pThisPubLen);
            ASSERT(*pThisPrivLen);
            ASSERT(*ThisPrivKey);

            _nt_free (*ThisPubKey, *pThisPubLen);
            _nt_free (*ThisPrivKey, *pThisPrivLen);
        }
#ifdef NTAGDEBUG
        else
        {
            ASSERT(*pThisPrivLen == 0);
            ASSERT(*pThisPubLen == 0);
            ASSERT(*ThisPrivKey == 0);
            ASSERT(*ThisPubKey == 0);
        }
#endif

        fAlloc = FALSE;

        *pThisPrivLen = PrivateKeySize;
        *pThisPubLen = PublicKeySize;
        *ThisPrivKey = pNewPrivKey;
        *ThisPubKey = pNewPubKey;

        if (dwFlags & CRYPT_EXPORTABLE)
            *pfExportable = TRUE;
        else
            *pfExportable = FALSE;

        // if the context being used is a Verify Context then the key is not
        // persisted to storage
        if (!(pOurUser->Rights & CRYPT_VERIFYCONTEXT))
        {
            // write the new keys to the user storage file
            dwSts = ProtectPrivKey(pOurUser, szPrompt, dwFlags, fSigKey);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }

        if (dwWhichKey == NTPK_USE_SIG)
        {
            if (!CPGetUserKey(hUser, AT_SIGNATURE, phKey))
            {
                dwReturn = GetLastError();
                goto ErrorExit;
            }

            dwSts = NTLValidate(*phKey, hUser, SIGPUBKEY_HANDLE, &pTmpKey);
            if (ERROR_SUCCESS != dwSts)
            {
                // NTLValidate doesn't know what error to set
                // so it set NTE_FAIL -- fix it up.
                dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_KEY : dwSts;
                goto ErrorExit;
            }
        }
        else
        {
            if (!CPGetUserKey(hUser, AT_KEYEXCHANGE, phKey))
            {
                dwReturn = GetLastError();
                goto ErrorExit;
            }

            dwSts = NTLValidate(*phKey, hUser, EXCHPUBKEY_HANDLE, &pTmpKey);
            if (ERROR_SUCCESS != dwSts)
            {
                // NTLValidate doesn't know what error to set
                // so it set NTE_FAIL -- fix it up.
                dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_KEY : dwSts;
                goto ErrorExit;
            }
        }


        //
        // Fix-up archivability.
        //

        if (0 != (CRYPT_ARCHIVABLE & dwFlags))
        {
            pTmpKey->Rights |= CRYPT_ARCHIVABLE;
            pTmpKey->Permissions |= CRYPT_ARCHIVE;
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (fInCritSec)
        LeaveCriticalSection(&pOurUser->CritSec);
    if (fAlloc)
    {
        if (pNewPrivKey)
            _nt_free(pNewPrivKey, PrivateKeySize);
        if (pNewPubKey)
            _nt_free(pNewPubKey, PublicKeySize);
    }
    return dwReturn;
}


//
// Routine : DerivePublicFromPrivate
//
// Description : Derive the public RSA key from the private RSA key.  This is
//               done and the resulting public key is placed in the appropriate
//               place in the context pointer (pTmpUser).
//

DWORD
DerivePublicFromPrivate(
    IN PNTAGUserList pUser,
    IN BOOL fSigKey)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    DWORD           *pcbPubKey;
    BYTE            **ppbPubKey = NULL;
    BSAFE_PUB_KEY   *pBSafePubKey;
    BSAFE_PRV_KEY   *pBSafePrivKey;
    DWORD           cb;

    // variable assignments depending on if its sig or exch
    if (fSigKey)
    {
        pcbPubKey = &pUser->ContInfo.ContLens.cbSigPub;
        ppbPubKey = &pUser->ContInfo.pbSigPub;
        pBSafePrivKey = (BSAFE_PRV_KEY*)pUser->pSigPrivKey;
    }
    else
    {
        pcbPubKey = &pUser->ContInfo.ContLens.cbExchPub;
        ppbPubKey = &pUser->ContInfo.pbExchPub;
        pBSafePrivKey = (BSAFE_PRV_KEY*)pUser->pExchPrivKey;
    }

    // figure out how much space is needed for the public key
    cb = ((((pBSafePrivKey->bitlen >> 1) + 63) / 32) * 8); // 8 = 2 * DIGIT_BYTES (rsa_fast.h)
    cb += sizeof(BSAFE_PUB_KEY);

    // check if space has been alloced for the public key and if
    // so is it large enough
    if (cb > *pcbPubKey)
    {
        _nt_free(*ppbPubKey, *pcbPubKey);
        *pcbPubKey = cb;

        *ppbPubKey = _nt_malloc(*pcbPubKey);
        if (NULL == *ppbPubKey)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }
    }

    // copy over the public key components
    pBSafePubKey = (BSAFE_PUB_KEY*)*ppbPubKey;
    pBSafePubKey->magic = RSA1;
    pBSafePubKey->keylen = pBSafePrivKey->keylen;
    pBSafePubKey->bitlen = pBSafePrivKey->bitlen;
    pBSafePubKey->datalen = pBSafePrivKey->datalen;
    pBSafePubKey->pubexp = pBSafePrivKey->pubexp;
    memcpy(*ppbPubKey + sizeof(BSAFE_PUB_KEY),
           (BYTE*)pBSafePrivKey + sizeof(BSAFE_PRV_KEY),
           cb - sizeof(BSAFE_PUB_KEY));

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\sadvapi\sadvapi.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : cryptapi.c                                             //
//  DESCRIPTION   : Crypto API interface                                   //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Dec  6 1994 larrys  New                                            //
//      Nov 13 1995 philh   Lean & mean version for the STB                //
//      Aug 18 1996 mattt   sadvapi chgs from ecm tree                     //
//      Oct 23 1997 jeffspel Checkin for SChannel use                      //
//      Feb 08 1999 sfield  avoid critical section, add exception handling //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <wincrypt.h>
#include "swincryp.h"
#include "scp.h"

typedef struct _VTableStruc {
    HCRYPTPROV  hProv;                          // Handle to provider
    LONG Inuse;
} VTableStruc, *PVTableStruc;

typedef struct _VKeyStruc {
    PVTableStruc pVTable;                       // pointer to provider
    HCRYPTKEY    hKey;                          // Handle to key
} VKeyStruc, *PVKeyStruc;

typedef struct _VHashStruc {
    PVTableStruc pVTable;                       // pointer to provider
    HCRYPTHASH  hHash;                          // Handle to hash
} VHashStruc, *PVHashStruc;


void __inline EnterProviderCritSec(IN PVTableStruc pVTable);
LONG __inline LeaveProviderCritSec(IN PVTableStruc pVTable);

PVKeyStruc BuildVKey(IN PVTableStruc pVTable);
PVHashStruc BuildVHash(IN PVTableStruc pVTable);

/*
 -  CryptAcquireContextW
 -
 *  Purpose:
 *               The CryptAcquireContext function is used to acquire a context
 *               handle to a cryptograghic service provider (CSP).
 *
 *
 *  Parameters:
 *               OUT    phProv      -  Handle to a CSP
 *               IN OUT pszIdentity -  Pointer to the name of the context's
 *                                     keyset.
 *               IN OUT pszProvider -  Pointer to the name of the provider.
 *               IN     dwProvType   -  Requested CSP type
 *               IN     dwFlags     -  Flags values
 *
 *  Returns:
 */
BOOL
WINAPI SCryptAcquireContextW(OUT    HCRYPTPROV *phProv,
                            IN OUT LPCWSTR pwszIdentity,
                            IN OUT LPCWSTR pwszProvider,
                            IN     DWORD dwProvType,
                            IN     DWORD dwFlags)
{
    CHAR    *pszIdentity = NULL;
    CHAR    *pszProvider = NULL;
    long    c = 0;
    long    i;
    BOOL    fRet = FALSE;

    if (pwszIdentity)
    {
        c = wcslen(pwszIdentity);
        if (NULL == (pszIdentity = (CHAR*)LocalAlloc(LMEM_ZEROINIT,
                                                     (c+1) * sizeof(CHAR))))
            goto Ret;
        for (i=0;i<c;i++)
            pszIdentity[i] = (CHAR)pwszIdentity[i];
        pszIdentity[i] = 0;
    }

    if (pwszProvider)
    {
        c = wcslen(pwszProvider);
        if (NULL == (pszProvider = (CHAR*)LocalAlloc(LMEM_ZEROINIT,
                                                     (c+1) * sizeof(CHAR))))
            goto Ret;
        for (i=0;i<c;i++)
            pszProvider[i] = (CHAR)pwszProvider[i];
        pszProvider[i] = 0;
    }

    fRet = SCryptAcquireContextA(
                            phProv,
                            pszIdentity,
                            pszProvider,
                            dwProvType,
                            dwFlags
                            );

Ret:
    if (pszIdentity)
        LocalFree(pszIdentity);
    if (pszProvider)
        LocalFree(pszProvider);
    return fRet;
}

BOOL
WINAPI SCryptAcquireContextA(OUT    HCRYPTPROV *phProv,
                            IN OUT LPCSTR pszIdentity,
                            IN OUT LPCSTR pszProvider,  // ignored
                            IN     DWORD dwProvType,    // ignored
                            IN     DWORD dwFlags)
{
    PVTableStruc        pVTable = NULL;
    VTableProvStruc     TableForProvider;
    BOOL                fRet = FALSE;


    pVTable = (PVTableStruc)LocalAlloc(
                                    LMEM_ZEROINIT,
                                    sizeof(VTableStruc)
                                    );

    if( pVTable == NULL ) {
        *phProv = 0;
        return FALSE;
    }

    memset(&TableForProvider, 0, sizeof(TableForProvider));
    TableForProvider.Version = 2;
    TableForProvider.FuncVerifyImage = NULL;
    TableForProvider.FuncReturnhWnd = 0;
    TableForProvider.dwProvType = dwProvType;
    TableForProvider.pbContextInfo = NULL;
    TableForProvider.cbContextInfo = 0;

    __try {

        fRet = CPAcquireContext(
                            &pVTable->hProv,
                            (LPSTR)pszIdentity,
                            dwFlags,
                            &TableForProvider
                            );
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        fRet = FALSE;
        ASSERT( fRet );
    }


    if(!fRet)
    {
        LocalFree(pVTable);
        pVTable = NULL;
    }
    else
    {
        if (dwFlags & CRYPT_DELETEKEYSET)
        {
            LocalFree(pVTable);
            pVTable = NULL;
        } else {
            pVTable->Inuse = 1;
        }

    }

    *phProv = (HCRYPTPROV)pVTable;

    return fRet;
}


/*
 -  CryptReleaseContext
 -
 *  Purpose:
 *               The CryptReleaseContext function is used to release a
 *               context created by CryptAcquireContext.
 *
 *  Parameters:
 *               IN  phProv        -  Handle to a CSP
 *               IN  dwFlags       -  Flags values
 *
 *  Returns:
 */
BOOL
WINAPI SCryptReleaseContext(IN HCRYPTPROV hProv,
                           IN DWORD dwFlags)
{
    PVTableStruc pVTable = (PVTableStruc) hProv;
    LONG         ContextRefCount;
    BOOL         fRet = FALSE;

    ContextRefCount = LeaveProviderCritSec( pVTable );

    __try {


        //
        // for debug builds, catch fools leaking state.
        //

        ASSERT( ContextRefCount == 0 );

        if( ContextRefCount != 0 ) {
            SetLastError(ERROR_BUSY);
            return FALSE;
        }

        fRet = CPReleaseContext(pVTable->hProv, dwFlags);

    } __except ( EXCEPTION_EXECUTE_HANDLER ) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    LocalFree(pVTable);

    return fRet;
}

/*
 -  CryptGenKey
 -
 *  Purpose:
 *                Generate cryptographic keys
 *
 *
 *  Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      Algid   -  Algorithm identifier
 *               IN      dwFlags -  Flags values
 *               OUT     phKey   -  Handle to a generated key
 *
 *  Returns:
 */
BOOL
WINAPI SCryptGenKey(IN HCRYPTPROV hProv,
                   IN ALG_ID Algid,
                   IN DWORD dwFlags,
                   OUT HCRYPTKEY * phKey)
{
    PVTableStruc    pVTable = (PVTableStruc) hProv;
    PVKeyStruc      pVKey;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;

    __try {
        *phKey = 0;
        pVKey = BuildVKey(pVTable);

        if( pVKey == NULL )
            return FALSE;

        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPGenKey(pVTable->hProv, Algid, dwFlags, &pVKey->hKey);
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }


    if( fRet ) {
        *phKey = (HCRYPTKEY) pVKey;
        return TRUE;
    }

    if (pVKey)
        LocalFree(pVKey);

    __try {
        *phKey = 0;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ; // gulp
    }

    return FALSE;
}

/*
 -      CryptDuplicateKey
 -
 *      Purpose:
 *                Duplicate a cryptographic key
 *
 *
 *      Parameters:
 *               IN      hKey           -  Handle to the key to be duplicated
 *               IN      pdwReserved    -  Reserved for later use
 *               IN      dwFlags        -  Flags values
 *               OUT     phKey          -  Handle to the new duplicate key
 *
 *      Returns:
 */
BOOL
WINAPI SCryptDuplicateKey(
                         IN HCRYPTKEY hKey,
                         IN DWORD *pdwReserved,
                         IN DWORD dwFlags,
                         OUT HCRYPTKEY * phKey
                         )
{
    PVKeyStruc      pVKey = (PVKeyStruc) hKey;
    PVTableStruc    pVTable;
    PVKeyStruc      pVNewKey;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;


    __try {
        *phKey = 0;
        pVTable = pVKey->pVTable;

        pVNewKey = BuildVKey(pVTable);

        if( pVNewKey == NULL ) {
            return FALSE;
        }

        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPDuplicateKey(
                        pVTable->hProv,
                        pVKey->hKey,
                        pdwReserved,
                        dwFlags,
                        &pVNewKey->hKey
                        );
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        fRet = FALSE;
        ASSERT( fRet );
    }


    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    if( fRet ) {
        *phKey = (HCRYPTKEY) pVNewKey;
        return TRUE;
    }

    if (pVNewKey)
        LocalFree(pVNewKey);

    __try {
        *phKey = 0;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ; // gulp
    }

    return FALSE;
}

/*
 -  CryptDeriveKey
 -
 *  Purpose:
 *                Derive cryptographic keys from base data
 *
 *
 *  Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      Algid      -  Algorithm identifier
 *               IN      hHash      -  Handle to hash of base data
 *               IN      dwFlags    -  Flags values
 *               OUT     phKey      -  Handle to a generated key
 *
 *  Returns:
 */
BOOL
WINAPI SCryptDeriveKey(IN HCRYPTPROV hProv,
                      IN ALG_ID Algid,
                      IN HCRYPTHASH hHash,
                      IN DWORD dwFlags,
                      OUT HCRYPTKEY * phKey)
{
    PVTableStruc    pVTable = (PVTableStruc) hProv;
    PVHashStruc     pVHash = (PVHashStruc) hHash;
    PVKeyStruc      pVKey;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;


    __try {

        *phKey = 0;
        if (pVHash->pVTable != pVTable)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        pVKey = BuildVKey(pVTable);
        if( pVKey == NULL )
            return FALSE;

        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPDeriveKey(
                        pVTable->hProv,
                        Algid,
                        pVHash->hHash,
                        dwFlags,
                        &pVKey->hKey
                        );
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    if( fRet ) {
        *phKey = (HCRYPTKEY) pVKey;
        return TRUE;
    }

    if (pVKey)
        LocalFree(pVKey);

    __try {
        *phKey = 0;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ; // gulp
    }

    return FALSE;
}


/*
 -  CryptDestroyKey
 -
 *  Purpose:
 *                Destroys the cryptographic key that is being referenced
 *                with the hKey parameter
 *
 *
 *  Parameters:
 *               IN      hKey   -  Handle to a key
 *
 *  Returns:
 */
BOOL
WINAPI SCryptDestroyKey(IN HCRYPTKEY hKey)
{
    PVKeyStruc      pVKey = (PVKeyStruc) hKey;
    PVTableStruc    pVTable;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;

    __try {
        pVTable = pVKey->pVTable;

        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPDestroyKey(pVTable->hProv, pVKey->hKey);
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    LocalFree(pVKey);

    return fRet;
}


/*
 -  CryptSetKeyParam
 -
 *  Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a key
 *
 *  Parameters:
 *               IN      hKey    -  Handle to a key
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *  Returns:
 */
BOOL
WINAPI SCryptSetKeyParam(IN HCRYPTKEY hKey,
                        IN DWORD dwParam,
                        IN BYTE *pbData,
                        IN DWORD dwFlags)
{
    PVKeyStruc      pVKey = (PVKeyStruc) hKey;
    PVTableStruc    pVTable;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;

    __try {
        pVTable = pVKey->pVTable;

        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPSetKeyParam(
                            pVTable->hProv,
                            pVKey->hKey,
                            dwParam,
                            pbData,
                            dwFlags
                            );
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec )
        LeaveProviderCritSec(pVTable);

    return fRet;
}


/*
 -  CryptGetKeyParam
 -
 *  Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a key
 *
 *  Parameters:
 *               IN      hKey       -  Handle to a key
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *  Returns:
 */
BOOL
WINAPI SCryptGetKeyParam(IN HCRYPTKEY hKey,
                        IN DWORD dwParam,
                        IN BYTE *pbData,
                        IN DWORD *pdwDataLen,
                        IN DWORD dwFlags)
{
    PVKeyStruc      pVKey = (PVKeyStruc) hKey;
    PVTableStruc    pVTable;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;

    __try {
        pVTable = pVKey->pVTable;

        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPGetKeyParam(
                        pVTable->hProv,
                        pVKey->hKey,
                        dwParam,
                        pbData,
                        pdwDataLen,
                        dwFlags
                        );
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    return fRet;
}


/*
 -  CryptGenRandom
 -
 *  Purpose:
 *                Used to fill a buffer with random bytes
 *
 *
 *  Parameters:
 *               IN  hProv      -  Handle to the user identifcation
 *               IN  dwLen      -  Number of bytes of random data requested
 *               OUT pbBuffer   -  Pointer to the buffer where the random
 *                                 bytes are to be placed
 *
 *  Returns:
 */
BOOL
WINAPI SCryptGenRandom(IN HCRYPTPROV hProv,
                      IN DWORD dwLen,
                      OUT BYTE *pbBuffer)

{
    PVTableStruc    pVTable = (PVTableStruc) hProv;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;

    __try {
        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPGenRandom(pVTable->hProv, dwLen, pbBuffer);
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    return fRet;
}

/*
 -  CryptGetUserKey
 -
 *  Purpose:
 *                Gets a handle to a permanent user key
 *
 *
 *  Parameters:
 *               IN  hProv      -  Handle to the user identifcation
 *               IN  dwKeySpec  -  Specification of the key to retrieve
 *               OUT phUserKey  -  Pointer to key handle of retrieved key
 *
 *  Returns:
 */
BOOL
WINAPI SCryptGetUserKey(IN HCRYPTPROV hProv,
                       IN DWORD dwKeySpec,
                       OUT HCRYPTKEY *phUserKey)
{
    PVTableStruc    pVTable = (PVTableStruc) hProv;
    PVKeyStruc      pVKey;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;


    __try {
        *phUserKey = 0;
        pVKey = BuildVKey(pVTable);

        if( pVKey == NULL ) {
            return FALSE;
        }

        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPGetUserKey(pVTable->hProv, dwKeySpec, &pVKey->hKey);
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    if( fRet ) {
        *phUserKey = (HCRYPTKEY) pVKey;
        return TRUE;
    }

    if (pVKey)
        LocalFree(pVKey);

    __try {
        *phUserKey = 0;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        ; // gulp
    }

    return FALSE;
}



/*
 -  CryptExportKey
 -
 *  Purpose:
 *                Export cryptographic keys out of a CSP in a secure manner
 *
 *
 *  Parameters:
 *               IN  hKey       - Handle to the key to export
 *               IN  hPubKey    - Handle to the exchange public key value of
 *                                the destination user
 *               IN  dwBlobType - Type of key blob to be exported
 *               IN  dwFlags -    Flags values
 *               OUT pbData -     Key blob data
 *               OUT pdwDataLen - Length of key blob in bytes
 *
 *  Returns:
 */
BOOL
WINAPI SCryptExportKey(IN HCRYPTKEY hKey,
                      IN HCRYPTKEY hPubKey,
                      IN DWORD dwBlobType,
                      IN DWORD dwFlags,
                      OUT BYTE *pbData,
                      OUT DWORD *pdwDataLen)
{
    PVKeyStruc      pVKey = (PVKeyStruc) hKey;
    PVTableStruc    pVTable;
    PVKeyStruc      pVPublicKey = (PVKeyStruc) hPubKey;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;


    __try {
        // Note: the SCP requires that the hPubKey has the same hProv as
        // the hKey. This is a problem for the MITV implementation where the
        // signature and exchange keys always have a different provider.

        pVTable = pVKey->pVTable;

        if (pVPublicKey && pVPublicKey->pVTable != pVTable)
        {
            *pdwDataLen = 0;
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPExportKey(
                        pVTable->hProv,
                        pVKey->hKey,
                        (pVPublicKey == NULL ? 0 : pVPublicKey->hKey),
                        dwBlobType,
                        dwFlags,
                        pbData,
                        pdwDataLen
                        );
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    return fRet;
}


/*
 -  CryptImportKey
 -
 *  Purpose:
 *                Import cryptographic keys
 *
 *
 *  Parameters:
 *               IN  hProv     -  Handle to the CSP user
 *               IN  pbData    -  Key blob data
 *               IN  dwDataLen -  Length of the key blob data
 *               IN  hPubKey   -  Handle to the exchange public key value of
 *                                the destination user
 *               IN  dwFlags   -  Flags values
 *               OUT phKey     -  Pointer to the handle to the key which was
 *                                Imported
 *
 *  Returns:
 */
BOOL
WINAPI SCryptImportKey(IN HCRYPTPROV hProv,
                      IN CONST BYTE *pbData,
                      IN DWORD dwDataLen,
                      IN HCRYPTKEY hPubKey,
                      IN DWORD dwFlags,
                      OUT HCRYPTKEY *phKey)
{
    PVTableStruc    pVTable = (PVTableStruc) hProv;
    PVKeyStruc      pVKey;
    PVKeyStruc      pVPublicKey = (PVKeyStruc) hPubKey;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;

    __try {

        *phKey = 0;

        if (pVPublicKey && pVPublicKey->pVTable != pVTable)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        pVKey = BuildVKey(pVTable);

        if( pVKey == NULL )
            return FALSE;

        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPImportKey(
                        pVTable->hProv,
                        pbData,
                        dwDataLen,
                        (pVPublicKey == NULL ? 0 : pVPublicKey->hKey),
                        dwFlags,
                        &pVKey->hKey
                        );
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    if( fRet ) {
        *phKey = (HCRYPTKEY) pVKey;
        return TRUE;
    }

    if (pVKey)
        LocalFree(pVKey);

    __try {
        *phKey = 0;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        ; // gulp
    }

    return FALSE;
}


/*
 -  CryptEncrypt
 -
 *  Purpose:
 *                Encrypt data
 *
 *
 *  Parameters:
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of plaintext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be encrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    encrypted
 *               IN dwBufLen       -  Size of Data buffer
 *
 *  Returns:
 */
BOOL
WINAPI SCryptEncrypt(IN HCRYPTKEY hKey,
                    IN HCRYPTHASH hHash,
                    IN BOOL Final,
                    IN DWORD dwFlags,
                    IN OUT BYTE *pbData,
                    IN OUT DWORD *pdwDataLen,
                    IN DWORD dwBufLen)
{
    PVKeyStruc      pVKey = (PVKeyStruc) hKey;
    PVTableStruc    pVTable;
    PVHashStruc     pVHash = (PVHashStruc) hHash;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;


    __try {

        pVTable = pVKey->pVTable;

        if (pVHash && pVHash->pVTable != pVTable)
        {
            *pdwDataLen = 0;
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPEncrypt(
                        pVTable->hProv,
                        pVKey->hKey,
                        (pVHash == NULL ? 0 : pVHash->hHash),
                        Final,
                        dwFlags,
                        pbData,
                        pdwDataLen,
                        dwBufLen
                        );
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    return fRet;
}


/*
 -  CryptDecrypt
 -
 *  Purpose:
 *                Decrypt data
 *
 *
 *  Parameters:
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of ciphertext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be decrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    decrypted
 *
 *  Returns:
 */
BOOL
WINAPI SCryptDecrypt(IN HCRYPTKEY hKey,
                    IN HCRYPTHASH hHash,
                    IN BOOL Final,
                    IN DWORD dwFlags,
                    IN OUT BYTE *pbData,
                    IN OUT DWORD *pdwDataLen)

{
    PVKeyStruc      pVKey = (PVKeyStruc) hKey;
    PVTableStruc    pVTable;
    PVHashStruc     pVHash = (PVHashStruc) hHash;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;

    __try {
        pVTable = pVKey->pVTable;

        if (pVHash && pVHash->pVTable != pVTable)
        {
            *pdwDataLen = 0;
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPDecrypt(
                        pVTable->hProv,
                        pVKey->hKey,
                        (pVHash == NULL ? 0 : pVHash->hHash),
                        Final,
                        dwFlags,
                        pbData,
                        pdwDataLen
                        );
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    return fRet;
}


/*
 -  CryptCreateHash
 -
 *  Purpose:
 *                initate the hashing of a stream of data
 *
 *
 *  Parameters:
 *               IN  hProv   -  Handle to the user identifcation
 *               IN  Algid   -  Algorithm identifier of the hash algorithm
 *                              to be used
 *               IN  hKey    -  Optional key for MAC algorithms
 *               IN  dwFlags -  Flags values
 *               OUT pHash   -  Handle to hash object
 *
 *  Returns:
 */
BOOL
WINAPI SCryptCreateHash(IN HCRYPTPROV hProv,
                       IN ALG_ID Algid,
                       IN HCRYPTKEY hKey,
                       IN DWORD dwFlags,
                       OUT HCRYPTHASH *phHash)
{
    PVTableStruc    pVTable = (PVTableStruc) hProv;
    PVKeyStruc      pVKey = (PVKeyStruc) hKey;
    PVHashStruc     pVHash;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;

    __try {
        *phHash = 0;

        if (pVKey && pVKey->pVTable != pVTable)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        pVHash = BuildVHash(pVTable);
        if( pVHash == NULL )
            return FALSE;

        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPCreateHash(
                        pVTable->hProv,
                        Algid,
                        (pVKey == NULL ? 0 : pVKey->hKey),
                        dwFlags,
                        &pVHash->hHash
                        );
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    if( fRet ) {
        *phHash = (HCRYPTHASH) pVHash;
        return TRUE;
    }

    if (pVHash)
        LocalFree(pVHash);

    __try {
        *phHash = 0;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        ; // gulp
    }

    return FALSE;
}

/*
 -      CryptDuplicateHash
 -
 *      Purpose:
 *                Duplicate a cryptographic hash
 *
 *
 *      Parameters:
 *               IN      hHash          -  Handle to the hash to be duplicated
 *               IN      pdwReserved    -  Reserved for later use
 *               IN      dwFlags        -  Flags values
 *               OUT     phHash         -  Handle to the new duplicate hash
 *
 *      Returns:
 */
BOOL
WINAPI SCryptDuplicateHash(
                         IN HCRYPTHASH hHash,
                         IN DWORD *pdwReserved,
                         IN DWORD dwFlags,
                         OUT HCRYPTHASH * phHash
                         )
{
    PVHashStruc     pVHash = (PVHashStruc) hHash;
    PVTableStruc    pVTable;
    PVHashStruc     pVNewHash;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;


    __try {
        *phHash = 0;
        pVTable = pVHash->pVTable;

        pVNewHash = BuildVHash(pVTable);
        if( pVNewHash == NULL ) {
            return FALSE;
        }

        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPDuplicateHash(
                        pVTable->hProv,
                        pVHash->hHash,
                        pdwReserved,
                        dwFlags,
                        &pVNewHash->hHash
                        );
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    if( fRet ) {
        *phHash = (HCRYPTHASH) pVNewHash;
        return TRUE;
    }

    if (pVNewHash)
        LocalFree(pVNewHash);

    __try {
        *phHash = 0;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        ; // gulp
    }

    return FALSE;

}

/*
 -  CryptHashData
 -
 *  Purpose:
 *                Compute the cryptograghic hash on a stream of data
 *
 *
 *  Parameters:
 *               IN  hHash     -  Handle to hash object
 *               IN  pbData    -  Pointer to data to be hashed
 *               IN  dwDataLen -  Length of the data to be hashed
 *               IN  dwFlags   -  Flags values
 *
 *
 *  Returns:
 */
BOOL
WINAPI SCryptHashData(IN HCRYPTHASH hHash,
                     IN CONST BYTE *pbData,
                     IN DWORD dwDataLen,
                     IN DWORD dwFlags)
{
    PVHashStruc     pVHash = (PVHashStruc) hHash;
    PVTableStruc    pVTable;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;


    __try {
        pVTable = pVHash->pVTable;

        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPHashData(
                        pVTable->hProv,
                        pVHash->hHash,
                        pbData,
                        dwDataLen,
                        dwFlags
                        );

    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    return fRet;
}

/*
 -  CryptHashSessionKey
 -
 *  Purpose:
 *                Compute the cryptograghic hash on a key object
 *
 *
 *  Parameters:
 *               IN  hHash     -  Handle to hash object
 *               IN  hKey      -  Handle to a key object
 *               IN  dwFlags   -  Flags values
 *
 *  Returns:
 *               CRYPT_FAILED
 *               CRYPT_SUCCEED
 */
BOOL
WINAPI SCryptHashSessionKey(IN HCRYPTHASH hHash,
                           IN HCRYPTKEY hKey,
                           IN DWORD dwFlags)
{
    PVHashStruc     pVHash = (PVHashStruc) hHash;
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey = (PVKeyStruc) hKey;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;


    __try {
        pVTable = pVHash->pVTable;

        if (pVKey->pVTable != pVTable)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPHashSessionKey(
                        pVTable->hProv,
                        pVHash->hHash,
                        pVKey->hKey,
                        dwFlags
                        );
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    return fRet;
}


/*
 -  CryptDestoyHash
 -
 *  Purpose:
 *                Destory the hash object
 *
 *
 *  Parameters:
 *               IN  hHash     -  Handle to hash object
 *
 *  Returns:
 */
BOOL
WINAPI SCryptDestroyHash(IN HCRYPTHASH hHash)
{
    PVHashStruc     pVHash = (PVHashStruc) hHash;
    PVTableStruc    pVTable;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;


    __try {
        pVTable = pVHash->pVTable;

        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPDestroyHash(pVTable->hProv, pVHash->hHash);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    LocalFree(pVHash);

    return fRet;
}


/*
 -      CryptSignHashW
 -
 *      Purpose:
 *                Create a digital signature from a hash
 *
 *
 *      Parameters:
 *               IN  hHash        -  Handle to hash object
 *               IN  dwKeySpec    -  Key pair that is used to sign with
 *                                   algorithm to be used
 *               IN  sDescription -  Description of data to be signed
 *               IN  dwFlags      -  Flags values
 *               OUT pbSignture   -  Pointer to signature data
 *               OUT pdwSigLen    -  Pointer to the len of the signature data
 *
 *      Returns:
 */
BOOL
WINAPI SCryptSignHashW(IN  HCRYPTHASH hHash,
              IN  DWORD dwKeySpec,
              IN  LPCWSTR sDescription,
              IN  DWORD dwFlags,
              OUT BYTE *pbSignature,
              OUT DWORD *pdwSigLen)
{
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}

BOOL
WINAPI SCryptSignHashA(IN  HCRYPTHASH hHash,
              IN  DWORD dwKeySpec,
              IN  LPCSTR sDescription,
              IN  DWORD dwFlags,
              OUT BYTE *pbSignature,
              OUT DWORD *pdwSigLen)
{
    PVHashStruc     pVHash = (PVHashStruc) hHash;
    PVTableStruc    pVTable;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;

    __try {
        pVTable = pVHash->pVTable;

        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPSignHash(
                        pVTable->hProv,
                        pVHash->hHash,
                        dwKeySpec,
                        NULL,
                        dwFlags,
                        pbSignature,
                        pdwSigLen
                        );
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    return fRet;
}

/*
 -      CryptVerifySignatureW
 -
 *      Purpose:
 *                Used to verify a signature against a hash object
 *
 *
 *      Parameters:
 *               IN  hHash        -  Handle to hash object
 *               IN  pbSignture   -  Pointer to signature data
 *               IN  dwSigLen     -  Length of the signature data
 *               IN  hPubKey      -  Handle to the public key for verifying
 *                                   the signature
 *               IN  sDescription -  String describing the signed data
 *               IN  dwFlags      -  Flags values
 *
 *      Returns:
 */
BOOL
WINAPI SCryptVerifySignatureW(IN HCRYPTHASH hHash,
                 IN CONST BYTE *pbSignature,
                 IN DWORD dwSigLen,
                 IN HCRYPTKEY hPubKey,
                 IN LPCWSTR sDescription,
                 IN DWORD dwFlags)
{
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}

BOOL
WINAPI SCryptVerifySignatureA(IN HCRYPTHASH hHash,
                 IN CONST BYTE *pbSignature,
                 IN DWORD dwSigLen,
                 IN HCRYPTKEY hPubKey,
                 IN LPCSTR sDescription,
                 IN DWORD dwFlags)
{
    PVHashStruc     pVHash = (PVHashStruc) hHash;
    PVTableStruc    pVTable;
    PVKeyStruc      pVPubKey = (PVKeyStruc) hPubKey;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;


    __try {
        pVTable = pVHash->pVTable;

        if (pVPubKey && pVPubKey->pVTable != pVTable)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPVerifySignature(
                            pVTable->hProv,
                            pVHash->hHash,
                            pbSignature,
                            dwSigLen,
                            (pVPubKey == NULL ? 0 : pVPubKey->hKey),
                            NULL,
                            dwFlags
                            );
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    return fRet;
}

/*
 -      CryptSetProvParam
 -
 *      Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a provider
 *
 *      Parameters:
 *               IN      hProv   -  Handle to a provider
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *      Returns:
 */
BOOL
WINAPI SCryptSetProvParam(IN HCRYPTPROV hProv,
             IN DWORD dwParam,
             IN BYTE *pbData,
             IN DWORD dwFlags)
{
    PVTableStruc    pVTable = (PVTableStruc) hProv;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;

    __try {
        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPSetProvParam(pVTable->hProv, dwParam, pbData, dwFlags);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    return fRet;
}


/*
 -      CryptGetProvParam
 -
 *      Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a provider
 *
 *      Parameters:
 *               IN      hProv      -  Handle to a proivder
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *      Returns:
 */
BOOL
WINAPI SCryptGetProvParam(IN HCRYPTPROV hProv,
             IN DWORD dwParam,
             IN BYTE *pbData,
             IN DWORD *pdwDataLen,
             IN DWORD dwFlags)
{
    PVTableStruc    pVTable = (PVTableStruc) hProv;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;

    __try {
        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPGetProvParam(
                        pVTable->hProv,
                        dwParam,
                        pbData,
                        pdwDataLen,
                        dwFlags
                        );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    return fRet;
}


/*
 -      CryptSetHashParam
 -
 *      Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a hash
 *
 *      Parameters:
 *               IN      hHash   -  Handle to a hash
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *      Returns:
 */
BOOL
WINAPI SCryptSetHashParam(IN HCRYPTHASH hHash,
             IN DWORD dwParam,
             IN BYTE *pbData,
             IN DWORD dwFlags)
{
    PVHashStruc     pVHash = (PVHashStruc) hHash;
    PVTableStruc    pVTable;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;


    __try {

        pVTable = pVHash->pVTable;

        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPSetHashParam(
                        pVTable->hProv,
                        pVHash->hHash,
                        dwParam,
                        pbData,
                        dwFlags
                        );
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    return fRet;
}


/*
 -      CryptGetHashParam
 -
 *      Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a hash
 *
 *      Parameters:
 *               IN      hHash      -  Handle to a hash
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *      Returns:
 */
BOOL
WINAPI SCryptGetHashParam(IN HCRYPTKEY hHash,
             IN DWORD dwParam,
             IN BYTE *pbData,
             IN DWORD *pdwDataLen,
             IN DWORD dwFlags)
{
    PVHashStruc     pVHash = (PVHashStruc) hHash;
    PVTableStruc    pVTable;
    BOOL            fCritSec = FALSE;
    BOOL            fRet = FALSE;

    __try {
        pVTable = pVHash->pVTable;

        EnterProviderCritSec(pVTable);
        fCritSec = TRUE;

        fRet = CPGetHashParam(
                        pVTable->hProv,
                        pVHash->hHash,
                        dwParam,
                        pbData,
                        pdwDataLen,
                        dwFlags
                        );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        fRet = FALSE;
        ASSERT( fRet );
    }

    if( fCritSec ) {
        LeaveProviderCritSec(pVTable);
    }

    return fRet;
}

void __inline EnterProviderCritSec(IN PVTableStruc pVTable)
{
    InterlockedIncrement(&pVTable->Inuse);
}


LONG __inline LeaveProviderCritSec(IN PVTableStruc pVTable)
{
    __try {
        return InterlockedDecrement(&pVTable->Inuse);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        return -1;
    }
}

PVKeyStruc BuildVKey(IN PVTableStruc pVTable)
{
    PVKeyStruc      pVKey;

    pVKey = (PVKeyStruc)LocalAlloc(LMEM_ZEROINIT, sizeof(VKeyStruc));
    if( pVKey == NULL )
        return NULL;

    pVKey->pVTable = pVTable;

    return pVKey;
}

PVHashStruc BuildVHash(IN PVTableStruc pVTable)
{
    PVHashStruc     pVHash;

    pVHash = (PVHashStruc)LocalAlloc(LMEM_ZEROINIT, sizeof(VHashStruc));
    if( pVHash == NULL )
        return NULL;

    pVHash->pVTable = pVTable;

    return pVHash;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\rsaaes\nt_sign.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : nt_sign.c                                              //
//  DESCRIPTION   : Crypto CP interfaces:                                  //
//                  CPSignHash                                             //
//                  CPVerifySignature                                      //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Jan 25 1995 larrys  Changed from Nametag                           //
//      Feb 23 1995 larrys  Changed NTag_SetLastError to SetLastError      //
//      Mar 23 1995 larrys  Added variable key length                      //
//      May 10 1995 larrys  added private api calls                        //
//      Aug 03 1995 larrys  Fix for bug 10                                 //
//      Aug 22 1995 larrys  Added descriptions to sign and verify hash     //
//      Aug 30 1995 larrys  Changed Algid to dwKeySpec                     //
//      Aug 30 1995 larrys  Removed RETURNASHVALUE from CryptGetHashValue  //
//      Aug 31 1995 larrys  Fixed CryptSignHash for pbSignature == NULL    //
//      Aug 31 1995 larrys  Fix for Bug 28                                 //
//      Sep 12 1995 Jeffspel/ramas  Merged STT onto SCP                    //
//      Sep 12 1995 Jeffspel/ramas  BUGS FIXED PKCS#1 Padding.             //
//      Sep 18 1995 larrys  Removed flag fro CryptSignHash                 //
//      Oct 13 1995 larrys  Changed GetHashValue to GetHashParam           //
//      Oct 23 1995 larrys  Added MD2                                      //
//      Oct 25 1995 larrys  Change length of sDescription string           //
//      Nov 10 1995 DBarlow Bug #61                                        //
//      Dec 11 1995 larrys  Added error return check                       //
//      May 15 1996 larrys  Changed NTE_NO_MEMORY to ERROR_NOT_ENOUGHT...  //
//      May 29 1996 larrys  Bug 101                                        //
//      Jun  6 1996 a-johnb Added support for SSL 3.0 signatures           //
//      May 23 1997 jeffspel Added provider type checking                  //
//      May  5 2000 dbarlow Clean up error return codes                    //
//                                                                         //
//  Copyright (C) 1993 - 2000, Microsoft Corporation                       //
//  All Rights Reserved                                                    //
/////////////////////////////////////////////////////////////////////////////

//#include <wtypes.h>
#include "precomp.h"
#include "ntagum.h"
#include "nt_rsa.h"
#include "protstor.h"
#include "swnt_pk.h"

extern CSP_STRINGS g_Strings;


//
// Reverse ASN.1 Encodings of possible hash identifiers.  The leading byte is
// the length of the remaining byte string.  The lists of possible identifiers
// is terminated with a '\x00' entry.
//

static const BYTE
#ifdef CSP_USE_MD2
    *md2Encodings[]
//                        1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
    = { (CONST BYTE *)"\x12\x10\x04\x00\x05\x02\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0c\x30\x20\x30",
        (CONST BYTE *)"\x10\x10\x04\x02\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0a\x30\x1e\x30",
        (CONST BYTE *)"\x00" },
#endif
#ifdef CSP_USE_MD4
    *md4Encodings[]
    = { (CONST BYTE *)"\x12\x10\x04\x00\x05\x04\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0c\x30\x20\x30",
        (CONST BYTE *)"\x10\x10\x04\x04\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0a\x30\x1e\x30",
        (CONST BYTE *)"\x00" },
#endif
#ifdef CSP_USE_MD5
    *md5Encodings[]
    = { (CONST BYTE *)"\x12\x10\x04\x00\x05\x05\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0c\x30\x20\x30",
        (CONST BYTE *)"\x10\x10\x04\x05\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0a\x30\x1e\x30",
        (CONST BYTE *)"\x00" },
#endif
#ifdef CSP_USE_SHA
    *shaEncodings[]
    = { (CONST BYTE *)"\x0f\x14\x04\x00\x05\x1a\x02\x03\x0e\x2b\x05\x06\x09\x30\x21\x30",
        (CONST BYTE *)"\x0d\x14\x04\x1a\x02\x03\x0e\x2b\x05\x06\x07\x30\x1f\x30",
        (CONST BYTE *)"\x00"},
#endif
    *endEncodings[]
    = { (CONST BYTE *)"\x00" };


/*
 -      ApplyPKCS1SigningFormat
 -
 *      Purpose:
 *                Format a buffer with PKCS 1 for signing
 *
 */

/*static*/ DWORD
ApplyPKCS1SigningFormat(
    IN  BSAFE_PUB_KEY *pPubKey,
    IN  ALG_ID HashAlgid,
    IN  BYTE *pbHash,
    IN  DWORD cbHash,
    IN  DWORD dwFlags,
    OUT BYTE *pbPKCS1Format)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BYTE    *pbStart;
    BYTE    *pbEnd;
    BYTE    bTmp;
    DWORD   i;

    // insert the block type
    pbPKCS1Format[pPubKey->datalen - 1] = 0x01;

    // insert the type I padding
    memset(pbPKCS1Format, 0xff, pPubKey->datalen-1);

    // Reverse it
    for (i = 0; i < cbHash; i++)
        pbPKCS1Format[i] = pbHash[cbHash - (i + 1)];

    if ( 0 == (CRYPT_NOHASHOID & dwFlags))
    {
        switch (HashAlgid)
        {
#ifdef CSP_USE_MD2
        case CALG_MD2:
            // PKCS delimit the hash value
            pbEnd = (LPBYTE)md2Encodings[0];
            pbStart = pbPKCS1Format + cbHash;
            bTmp = *pbEnd++;
            while (0 < bTmp--)
                *pbStart++ = *pbEnd++;
            *pbStart++ = 0;
            break;
#endif

#ifdef CSP_USE_MD4
        case CALG_MD4:
            // PKCS delimit the hash value
            pbEnd = (LPBYTE)md4Encodings[0];
            pbStart = pbPKCS1Format + cbHash;
            bTmp = *pbEnd++;
            while (0 < bTmp--)
                *pbStart++ = *pbEnd++;
            *pbStart++ = 0;
            break;
#endif

#ifdef CSP_USE_MD5
        case CALG_MD5:
            // PKCS delimit the hash value
            pbEnd = (LPBYTE)md5Encodings[0];
            pbStart = pbPKCS1Format + cbHash;
            bTmp = *pbEnd++;
            while (0 < bTmp--)
                *pbStart++ = *pbEnd++;
            *pbStart++ = 0;
            break;
#endif

#ifdef CSP_USE_SHA
        case CALG_SHA:
            // PKCS delimit the hash value
            pbEnd = (LPBYTE)shaEncodings[0];
            pbStart = pbPKCS1Format + cbHash;
            bTmp = *pbEnd++;
            while (0 < bTmp--)
                *pbStart++ = *pbEnd++;
            *pbStart++ = 0;
            break;
#endif

#ifdef CSP_USE_SSL3SHAMD5
        case CALG_SSL3_SHAMD5:
            // Don't put in any PKCS crud
            pbStart = pbPKCS1Format + cbHash;
            *pbStart++ = 0;
            break;
#endif

        default:
            dwReturn = (DWORD)NTE_BAD_ALGID;
            goto ErrorExit;
        }
    }
    else
    {
        pbPKCS1Format[cbHash] = 0x00;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*
 -      ApplyX931SigningFormat
 -
 *      Purpose:
 *                Format a buffer with X.9.31 for signing, assumes
 *                the buffer to be formatted is at least the length
 *                of the signature (cbSig).
 *
 */

/*static*/ void
ApplyX931SigningFormat(
    IN  DWORD cbSig,
    IN  BYTE *pbHash,
    IN  DWORD cbHash,
    IN  BOOL fDataInHash,
    OUT BYTE *pbFormatted)
{
    DWORD   i;

    // insert P3
    pbFormatted[0] = 0xcc;
    pbFormatted[1] = 0x33;

    // Reverse it
    for (i = 0; i < cbHash; i++)
        pbFormatted[i + 2] = pbHash[cbHash - (i + 1)];
    pbFormatted[22] = 0xba;

    // insert P2
    memset(pbFormatted + 23, 0xbb, cbSig - 24);

    // insert P1
    if (fDataInHash)
        pbFormatted[cbSig - 1] = 0x6b;
    else
        pbFormatted[cbSig - 1] = 0x4b;
}


/*
 -      CPSignHash
 -
 *      Purpose:
 *                Create a digital signature from a hash
 *
 *
 *      Parameters:
 *               IN  hUID         -  Handle to the user identifcation
 *               IN  hHash        -  Handle to hash object
 *               IN  dwKeySpec    -  Key pair that is used to sign with
 *                                   algorithm to be used
 *               IN  sDescription -  Description of data to be signed
 *               IN  dwFlags      -  Flags values
 *               OUT pbSignture   -  Pointer to signature data
 *               OUT dwHashLen    -  Pointer to the len of the signature data
 *
 *      Returns:
 */

BOOL WINAPI
CPSignHash(
    IN  HCRYPTPROV hUID,
    IN  HCRYPTHASH hHash,
    IN  DWORD dwKeySpec,
    IN  LPCWSTR sDescription,
    IN  DWORD dwFlags,
    OUT BYTE *pbSignature,
    OUT DWORD *pdwSigLen)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGUserList   pTmpUser = NULL;
    PNTAGHashList   pTmpHash;
    BSAFE_PRV_KEY   *pPrivKey = NULL;
    MD2_object      *pMD2Hash;
    MD4_object      *pMD4Hash;
    MD5_object      *pMD5Hash;
    A_SHA_CTX       *pSHAHash;
    BYTE            rgbTmpHash[SSL3_SHAMD5_LEN];
    DWORD           cbTmpHash = SSL3_SHAMD5_LEN;
    BYTE            *pbInput = NULL;
    BYTE            *pbSigT = NULL;
    DWORD           cbSigLen;
    BOOL            fSigKey;
    BSAFE_PUB_KEY   *pPubKey;
    LPWSTR          szPrompt;
    BOOL            fDataInHash = FALSE;
    BOOL            fRet;
    DWORD           dwSts;

    EntryPoint
    if ((dwFlags & ~(CRYPT_NOHASHOID | CRYPT_X931_FORMAT)) != 0)
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    pTmpUser = (PNTAGUserList)NTLCheckList(hUID, USER_HANDLE);
    if (NULL == pTmpUser)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    // get the user's public key
    if (dwKeySpec == AT_KEYEXCHANGE)
    {
        fSigKey = FALSE;
        pPubKey = (BSAFE_PUB_KEY *)pTmpUser->ContInfo.pbExchPub;
        szPrompt = g_Strings.pwszSignWExch;
    }
    else if (dwKeySpec == AT_SIGNATURE)
    {
        if (PROV_RSA_SCHANNEL == pTmpUser->dwProvType)
        {
            dwReturn = (DWORD)NTE_BAD_ALGID;
            goto ErrorExit;
        }

        fSigKey = TRUE;
        pPubKey = (BSAFE_PUB_KEY *)pTmpUser->ContInfo.pbSigPub;
        szPrompt = g_Strings.pwszSigning;
    }
    else
    {
        dwReturn = (DWORD)NTE_BAD_ALGID;
        goto ErrorExit;
    }

    // check to make sure the key exists
    if (NULL == pPubKey)
    {
        dwReturn = (DWORD)NTE_BAD_KEYSET;
        goto ErrorExit;
    }

    cbSigLen = (pPubKey->bitlen + 7) / 8;
    if (pbSignature == NULL || *pdwSigLen < cbSigLen)
    {
        *pdwSigLen = cbSigLen;
        dwReturn = (pbSignature == NULL) ? ERROR_SUCCESS : ERROR_MORE_DATA;
        goto ErrorExit;
    }

    // check to see if the hash is in the hash list
    dwSts = NTLValidate(hHash, hUID, HASH_HANDLE, &pTmpHash);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = (dwSts == NTF_FAILED) ? (DWORD)NTE_BAD_HASH : dwSts;
        goto ErrorExit;
    }

    // zero the output buffer
    memset (pbSignature, 0, cbSigLen);

    switch (pTmpHash->Algid)
    {
#ifdef CSP_USE_MD2
    case CALG_MD2:
        pMD2Hash = (MD2_object *)pTmpHash->pHashData;
        break;
#endif

#ifdef CSP_USE_MD4
    case CALG_MD4:
        pMD4Hash = (MD4_object *)pTmpHash->pHashData;
        break;
#endif

#ifdef CSP_USE_MD5
    case CALG_MD5:
        pMD5Hash = (MD5_object *)pTmpHash->pHashData;
        break;
#endif

#ifdef CSP_USE_SHA
    case CALG_SHA:
        pSHAHash = (A_SHA_CTX *)pTmpHash->pHashData;
        break;
#endif

#ifdef CSP_USE_SSL3SHAMD5
    case CALG_SSL3_SHAMD5:
// Hash value must have already been set.
        if ((pTmpHash->HashFlags & HF_VALUE_SET) == 0)
        {
            dwReturn = (DWORD)NTE_BAD_HASH_STATE;
            goto ErrorExit;
        }
        break;
#endif

    default:
        dwReturn = (DWORD)NTE_BAD_ALGID;
        goto ErrorExit;
    }

    // WARNING: due to vulnerabilities sDescription field is should NO longer
    //          be used
    if (sDescription != NULL)
    {
        if (!CPHashData(hUID, hHash, (LPBYTE) sDescription,
                        lstrlenW(sDescription) * sizeof(WCHAR), 0))
        {
            dwReturn = GetLastError();  // NTE_BAD_HASH
            goto ErrorExit;
        }
    }

    // check if this is a NULL hash (no data hashed) for X.9.31 format
    if (pTmpHash->dwHashState & DATA_IN_HASH)
        fDataInHash = TRUE;

    // now copy the hash into the input buffer
    cbTmpHash = pPubKey->keylen;
    if (!CPGetHashParam(hUID, hHash, HP_HASHVAL, rgbTmpHash, &cbTmpHash, 0))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    pbInput = (BYTE *)_nt_malloc(pPubKey->keylen);
    if (pbInput == NULL)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    if (dwFlags & CRYPT_X931_FORMAT)
    {
        // use X.9.31 padding for FIPS certification
        if (pTmpHash->Algid != CALG_SHA1)
        {
            dwReturn = (DWORD)NTE_BAD_ALGID;
            goto ErrorExit;
        }

        ApplyX931SigningFormat(cbSigLen,
                               rgbTmpHash,
                               cbTmpHash,
                               fDataInHash,
                               pbInput);
    }
    else
    {
        // use PKCS #1 padding
        dwSts = ApplyPKCS1SigningFormat(pPubKey, pTmpHash->Algid, rgbTmpHash,
                                     cbTmpHash, dwFlags, pbInput);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    // encrypt the hash value in input
    pbSigT = (BYTE *)_nt_malloc(pPubKey->keylen);
    if (NULL == pbSigT)
    {
        dwReturn  = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    // load the appropriate key if necessary
    dwSts = UnprotectPrivKey(pTmpUser, szPrompt, fSigKey, FALSE);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;   // NTE_BAD_KEYSET
        goto ErrorExit;
    }

    // get the user's private key
    if (fSigKey)
        pPrivKey = (BSAFE_PRV_KEY *)pTmpUser->pSigPrivKey;
    else
        pPrivKey = (BSAFE_PRV_KEY *)pTmpUser->pExchPrivKey;

    if (pPrivKey == NULL)
    {
        dwReturn = (DWORD)NTE_NO_KEY;
        goto ErrorExit;
    }

    if (pPubKey->keylen != pPrivKey->keylen)
    {
        dwReturn = (DWORD)NTE_KEYSET_ENTRY_BAD;
        goto ErrorExit;
    }

    dwSts = RSAPrivateDecrypt(pTmpUser->pOffloadInfo, pPrivKey, pbInput,
                              pbSigT);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    memcpy(pbSignature, pbSigT, cbSigLen);
    *pdwSigLen = cbSigLen;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (pbSigT)
        _nt_free (pbSigT, pPubKey->keylen);
    if (pbInput)
        _nt_free(pbInput, pPubKey->keylen);
    if (!fRet)
        SetLastError(dwReturn);
    return fRet;
}


/*
 -      VerifyPKCS1SigningFormat
 -
 *      Purpose:
 *                Check the format on a buffer to make sure the PKCS 1
 *                formatting is correct.
 *
 */

/*static*/ DWORD
VerifyPKCS1SigningFormat(
    IN  BSAFE_PUB_KEY *pKey,
    IN  PNTAGHashList pTmpHash,
    IN  BYTE *pbHash,
    IN  DWORD cbHash,
    IN  DWORD dwFlags,
    OUT BYTE *pbPKCS1Format)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    MD2_object  *pMD2Hash;
    MD4_object  *pMD4Hash;
    MD5_object  *pMD5Hash;
    A_SHA_CTX   *pSHAHash;
    BYTE        *pbTmp;
    const BYTE  **rgEncOptions;
    BYTE        rgbTmpHash[SSL3_SHAMD5_LEN];
    DWORD       i;
    DWORD       cb;
    BYTE        *pbStart;
    DWORD       cbTmp;

    switch (pTmpHash->Algid)
    {
#ifdef CSP_USE_MD2
    case CALG_MD2:
        pMD2Hash = (MD2_object *)pTmpHash->pHashData;
        pbTmp = (BYTE *) &(pMD2Hash->MD);
        rgEncOptions = md2Encodings;
        break;
#endif

#ifdef CSP_USE_MD4
    case CALG_MD4:
        pMD4Hash = (MD4_object *)pTmpHash->pHashData;
        pbTmp = (BYTE *) &(pMD4Hash->MD);
        rgEncOptions = md4Encodings;
        break;
#endif

#ifdef CSP_USE_MD5
    case CALG_MD5:
        pMD5Hash = (MD5_object *)pTmpHash->pHashData;
        pbTmp = (BYTE *)pMD5Hash->digest;
        rgEncOptions = md5Encodings;
        break;
#endif

#ifdef CSP_USE_SHA
    case CALG_SHA:
        pSHAHash = (A_SHA_CTX *)pTmpHash->pHashData;
        pbTmp = (BYTE *)pSHAHash->HashVal;
        rgEncOptions = shaEncodings;
        break;
#endif

#ifdef CSP_USE_SSL3SHAMD5
    case CALG_SSL3_SHAMD5:
        // Hash value must have already been set.
        if ((pTmpHash->HashFlags & HF_VALUE_SET) == 0)
        {
            dwReturn = (DWORD)NTE_BAD_HASH;
            goto ErrorExit;
        }
        pbTmp = pTmpHash->pHashData;
        rgEncOptions = NULL;
        break;
#endif

    default:
        dwReturn = (DWORD)NTE_BAD_HASH;
        goto ErrorExit;
    }

    // Reverse the hash to match the signature.
    for (i = 0; i < cbHash; i++)
        rgbTmpHash[i] = pbHash[cbHash - (i + 1)];

    // See if it matches.
    if (0 != memcmp(rgbTmpHash, pbPKCS1Format, cbHash))
    {
        dwReturn = (DWORD)NTE_BAD_SIGNATURE;
        goto ErrorExit;
    }

    cb = cbHash;
    if (!(CRYPT_NOHASHOID & dwFlags))
    {
        // Check for any signature type identifiers
        if (rgEncOptions != NULL)
        {
            for (i = 0; 0 != *rgEncOptions[i]; i += 1)
            {
                pbStart = (LPBYTE)rgEncOptions[i];
                cbTmp = *pbStart++;
                if (0 == memcmp(&pbPKCS1Format[cb], pbStart, cbTmp))
                {
                    cb += cbTmp;   // Adjust the end of the hash data.
                    break;
                }
            }
        }
    }

    // check to make sure the rest of the PKCS #1 padding is correct
    if ((0x00 != pbPKCS1Format[cb])
        || (0x00 != pbPKCS1Format[pKey->datalen])
        || (0x1 != pbPKCS1Format[pKey->datalen - 1]))
    {
        dwReturn = (DWORD)NTE_BAD_SIGNATURE;
        goto ErrorExit;
    }

    for (i = cb + 1; i < (DWORD)pKey->datalen - 1; i++)
    {
        if (0xff != pbPKCS1Format[i])
        {
            dwReturn = (DWORD)NTE_BAD_SIGNATURE;
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*
 -      VerifyX931SigningFormat
 -
 *      Purpose:
 *                Check the format on a buffer to make sure the X.9.31
 *                formatting is correct.
 *
 */

/*static*/ DWORD
VerifyX931SigningFormat(
    IN  BYTE *pbHash,
    IN  DWORD cbHash,
    IN  BOOL fDataInHash,
    IN  BYTE *pbFormatted,
    IN  DWORD cbFormatted)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BYTE    rgbTmpHash[SSL3_SHAMD5_LEN];
    DWORD   i;

    // check P3
    if ((0xcc != pbFormatted[0]) || (0x33 != pbFormatted[1]) ||
        (0xba != pbFormatted[cbHash + 2]))
    {
        dwReturn = (DWORD)NTE_BAD_SIGNATURE;
        goto ErrorExit;
    }

    // Reverse the hash to match the signature and check if it matches.
    for (i = 0; i < cbHash; i++)
        rgbTmpHash[i] = pbHash[cbHash - (i + 1)];
    if (0 != memcmp(rgbTmpHash, pbFormatted + 2, cbHash))
    {
        dwReturn = (DWORD)NTE_BAD_SIGNATURE;
        goto ErrorExit;
    }

    // check P2
    for (i = 23; i < (cbFormatted - 24); i++)
    {
        if (0xbb != pbFormatted[i])
        {
            dwReturn = (DWORD)NTE_BAD_SIGNATURE;
            goto ErrorExit;
        }
    }

    // check P1
    if (fDataInHash)
    {
        if (0x6b != pbFormatted[cbFormatted - 1])
        {
            dwReturn = (DWORD)NTE_BAD_SIGNATURE;
            goto ErrorExit;
        }
    }
    else
    {
        if (0x4b != pbFormatted[cbFormatted - 1])
        {
            dwReturn = (DWORD)NTE_BAD_SIGNATURE;
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*
 -      CPVerifySignature
 -
 *      Purpose:
 *                Used to verify a signature against a hash object
 *
 *
 *      Parameters:
 *               IN  hUID         -  Handle to the user identifcation
 *               IN  hHash        -  Handle to hash object
 *               IN  pbSignture   -  Pointer to signature data
 *               IN  dwSigLen     -  Length of the signature data
 *               IN  hPubKey      -  Handle to the public key for verifying
 *                                   the signature
 *               IN  Algid        -  Algorithm identifier of the signature
 *                                   algorithm to be used
 *               IN  sDescription -  String describing the signed data
 *               IN  dwFlags      -  Flags values
 *
 *      Returns:
 */

BOOL WINAPI
CPVerifySignature(
    IN HCRYPTPROV hUID,
    IN HCRYPTHASH hHash,
    IN CONST BYTE *pbSignature,
    IN DWORD dwSigLen,
    IN HCRYPTKEY hPubKey,
    IN LPCWSTR sDescription,
    IN DWORD dwFlags)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGUserList   pTmpUser;
    PNTAGHashList   pTmpHash;
    PNTAGKeyList    pPubKey;
    BSAFE_PUB_KEY   *pKey;
    BYTE            *pOutput = NULL;
    BSAFE_PUB_KEY   *pBsafePubKey;
    BYTE            *pbSigT = NULL;
    BYTE            rgbTmpHash[SSL3_SHAMD5_LEN];
    DWORD           cbTmpHash = SSL3_SHAMD5_LEN;
    DWORD           cbLocalSigLen;
    BOOL            fDataInHash = FALSE;
    BOOL            fRet;
    DWORD           dwSts;

    EntryPoint
    if ((dwFlags & ~(CRYPT_NOHASHOID | CRYPT_X931_FORMAT)) != 0)
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    // check the user identification
    pTmpUser = (PNTAGUserList)NTLCheckList(hUID, USER_HANDLE);
    if (NULL == pTmpUser)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    // check to see if the hash is in the hash list
    dwSts = NTLValidate(hHash, hUID, HASH_HANDLE, &pTmpHash);
    if (ERROR_SUCCESS != dwSts)
    {
        // NTLValidate doesn't know what error to set
        // so it set NTE_FAIL -- fix it up.
        dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_HASH : dwSts;
        goto ErrorExit;
    }

    if ((CALG_MD2 != pTmpHash->Algid) &&
        (CALG_MD4 != pTmpHash->Algid) &&
        (CALG_MD5 != pTmpHash->Algid) &&
        (CALG_SHA != pTmpHash->Algid) &&
        (CALG_SSL3_SHAMD5 != pTmpHash->Algid))
    {
        dwReturn = (DWORD)NTE_BAD_HASH;
        goto ErrorExit;
    }

    switch (HNTAG_TO_HTYPE((HNTAG)hPubKey))
    {
    case SIGPUBKEY_HANDLE:
    case EXCHPUBKEY_HANDLE:
        dwSts = NTLValidate((HNTAG)hPubKey,
                            hUID, HNTAG_TO_HTYPE((HNTAG)hPubKey),
                            &pPubKey);
        if (ERROR_SUCCESS != dwSts)
        {
            // NTLValidate doesn't know what error to set
            // so it set NTE_FAIL -- fix it up.
            dwReturn = (dwSts == NTE_FAIL) ? (DWORD)NTE_BAD_KEY : dwSts;
            goto ErrorExit;
        }
        break;
    default:
        dwReturn = (DWORD)NTE_BAD_KEY;
        goto ErrorExit;
    }

    pKey = (BSAFE_PUB_KEY *)pPubKey->pKeyValue;
    pBsafePubKey = (BSAFE_PUB_KEY *) pKey;
    cbLocalSigLen = (pBsafePubKey->bitlen+7)/8;
    if (dwSigLen != cbLocalSigLen)
    {
        dwReturn = (DWORD)NTE_BAD_SIGNATURE;
        goto ErrorExit;
    }

    pOutput = (BYTE *)_nt_malloc(pBsafePubKey->keylen);
    if (NULL == pOutput)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    // encrypt the hash value in output
    pbSigT = (BYTE *)_nt_malloc(pBsafePubKey->keylen);
    if (NULL == pbSigT)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    memset(pbSigT, 0, pBsafePubKey->keylen);
    memcpy(pbSigT, pbSignature, cbLocalSigLen);
    dwSts = RSAPublicEncrypt(pTmpUser->pOffloadInfo, pBsafePubKey,
                             pbSigT, pOutput);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts; // NTE_BAD_SIGNATURE
        goto ErrorExit;
    }

    // WARNING: due to vulnerabilities sDescription field is should NO longer
    //          be used
    if (sDescription != NULL)
    {
        if (!CPHashData(hUID, hHash, (LPBYTE) sDescription,
                        lstrlenW(sDescription) * sizeof(WCHAR), 0))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }
    }

    // check if this is a NULL hash (no data hashed) for X.9.31 format
    if (pTmpHash->dwHashState & DATA_IN_HASH)
        fDataInHash = TRUE;

    if (!CPGetHashParam(hUID, hHash, HP_HASHVAL, rgbTmpHash, &cbTmpHash, 0))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (dwFlags & CRYPT_X931_FORMAT)
    {
        // use X.9.31 padding for FIPS certification
        dwSts = VerifyX931SigningFormat(rgbTmpHash, cbTmpHash,
                                        fDataInHash, pOutput,
                                        (pBsafePubKey->bitlen + 7) / 8);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }
    else
    {
        // use PKCS #1 padding
        dwSts = VerifyPKCS1SigningFormat(pKey, pTmpHash, rgbTmpHash,
                                         cbTmpHash, dwFlags, pOutput);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (pbSigT)
        _nt_free(pbSigT, pBsafePubKey->keylen);
    if (pOutput)
        _nt_free(pOutput, pBsafePubKey->keylen);
    if (!fRet)
        SetLastError(dwReturn);
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\rsaaes\nt_rand.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : nt_rand.c                                              //
//  DESCRIPTION   : Crypto CP interfaces:                                  //
//                  CPGenRandom                                            //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//  Jan 25 1995 larrys  Changed from Nametag                               //
//      Feb 23 1995 larrys  Changed NTag_SetLastError to SetLastError      //
//      Apr 10 1995 larrys  Fix comments                                   //
//      Oct 27 1995 rajeshk Added provider parameter to GenRandom call     //
//      Nov  3 1995 larrys  Merge for NT checkin                           //
//      Oct 14 1996 jeffspel Changed GenRandom to NewGenRandom             //
//      May  5 2000 dbarlow Clean up error return codes                    //
//                                                                         //
//  Copyright (C) 1993 - 2000, Microsoft Corporation                       //
//  All Rights Reserved                                                    //
/////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <crypt.h>

#include "precomp.h"
#include "sha.h"
#include "rsa_fast.h"
#include "rsa_math.h"
#include "randlib.h"

static CONST BYTE DSSPRIVATEKEYINIT[] =
  { 0x67, 0x45, 0x23, 0x01, 0xef, 0xcd, 0xab, 0x89,
    0x98, 0xba, 0xdc, 0xfe, 0x10, 0x32, 0x54, 0x76,
    0xc3, 0xd2, 0xe1, 0xf0 };

static CONST BYTE DSSPERMSGINIT[] =
  { 0xef, 0xcd, 0xab, 0x89, 0x98, 0xba, 0xdc, 0xfe,
    0x10, 0x32, 0x54, 0x76, 0xc3, 0xd2, 0xe1, 0xf0,
    0x67, 0x45, 0x23, 0x01 };

static CONST BYTE MODULUS[] =
  { 0xf5, 0xc1, 0x56, 0xb1, 0xd5, 0x48, 0x42, 0x2e,
    0xbd, 0xa5, 0x44, 0x41, 0xc7, 0x1c, 0x24, 0x08,
    0x3f, 0x80, 0x3c, 0x90 };

static BYTE l_rgbRNGState[A_SHA_DIGEST_LEN];


//
// Function : AddSeeds
//
// Description : This function adds the 160 bit seeds pointed to by pdwSeed1
//               and pdwSeed2, it also adds 1 to this sum and mods the sum by
//               2^160.
//

/*static*/ void
AddSeeds(
    IN CONST DWORD *pdwSeed1,
    IN OUT DWORD *pdwSeed2)
{
    DWORD   dwTmp;
    DWORD   dwOverflow = 1;
    DWORD   i;

    for (i = 0; i < 5; i++)
    {
        dwTmp = dwOverflow + pdwSeed1[i];
        dwOverflow = (dwOverflow > dwTmp);
        pdwSeed2[i] = pdwSeed2[i] + dwTmp;
        dwOverflow = ((dwTmp > pdwSeed2[i]) || dwOverflow);
    }
}


/*
    Given SHA(message), compute SHA(message) mod qdigit.
    Output is in the interval [0, qdigit-1].
    Although SHA(message) may exceed qdigit,
    it cannot exceed 2*qdigit since the leftmost bit
    of qdigit is 1.
*/

/*static*/ void
SHA_mod_q(
    CONST BYTE *pbHash,              // In
    CONST BYTE *pbQ,                 // In
    BYTE       *pbNewHash)           // Out
{
    BYTE    rgbHash[A_SHA_DIGEST_LEN];

    if (-1 != Compare((DWORD*)rgbHash,  // hash is greater so subtract
                      (DWORD*)pbQ,
                      A_SHA_DIGEST_LEN / sizeof(DWORD)))
    {
        Sub((DWORD*)pbNewHash,
            (DWORD*)rgbHash,
            (DWORD*)pbQ,
            A_SHA_DIGEST_LEN / sizeof(DWORD));
    }
    else
        memcpy(pbNewHash, pbHash, A_SHA_DIGEST_LEN / sizeof(DWORD));
} /* SHA_mod_q */


//
// Function : RNG16BitStateCheck
//
// Description : This function compares each 160 bits of the buffer with
//               the next 160 bits and if they are the same the function
//               errors out.  The IN buffer is expected to be A_SHA_DIGEST_LEN
//               bytes long.  The function fails if the RNG is gets the same
//               input buffer of 160 bits twice in a row.
//

/*static*/ BOOL
RNG16BitStateCheck(
    IN OUT DWORD *pdwOut,
    IN DWORD *pdwIn,
    IN DWORD cbNeeded)
{
    BOOL    fRet = FALSE;

    if (0 == memcmp(l_rgbRNGState, pdwIn, A_SHA_DIGEST_LEN))
    {
        memcpy(l_rgbRNGState, (BYTE*)pdwIn, A_SHA_DIGEST_LEN);
        goto ErrorExit;
    }

    memcpy(l_rgbRNGState, (BYTE*)pdwIn, A_SHA_DIGEST_LEN);
    memcpy((BYTE*)pdwOut, (BYTE*)pdwIn, cbNeeded);
    fRet = TRUE;

ErrorExit:
    return fRet;
}


//
// Function : FIPS186Gen
//
// Description : FIPS 186 RNG, the seed is generated by calling NewGenRandom.
//

/*static*/ DWORD
FIPS186Gen(
    IN HANDLE hRNGDriver,
    IN BYTE **ppbContextSeed,
    IN DWORD *pcbContextSeed,
    IN CONST BYTE *pbInitValue, // this is t, must be 20 bytes
    IN CONST BYTE *pbModulus,   // this must be a 20 byte prime
    IN OUT BYTE *pb,
    IN DWORD cb)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    DWORD       rgdwSeed[A_SHA_DIGEST_LEN/sizeof(DWORD)];    // 160 bits
    DWORD       rgdwNewSeed[A_SHA_DIGEST_LEN/sizeof(DWORD)]; // 160 bits
    A_SHA_CTX   SHACtxt;
    BYTE        rgbBuf[A_SHA_DIGEST_LEN];
    DWORD       cbBuf;
    BYTE        *pbTmp = pb;
    DWORD       cbTmp = cb;
    DWORD       i;
    DWORD       dwSts;
    DWORD       cbContextSeed = 0;

    if (ppbContextSeed && pcbContextSeed)
        cbContextSeed = *pcbContextSeed;

    while (cbTmp)
    {
#ifdef USE_HW_RNG
#ifdef _M_IX86
        // get a 160 bit random seed
        if (INVALID_HANDLE_VALUE != hRNGDriver)
        {
            dwSts = HWRNGGenRandom(hRNGDriver,
                                   (BYTE*)rgdwNewSeed,
                                   sizeof(rgdwNewSeed));
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }
        else
#endif // _M_IX86
#endif // USE_HW_RNG
        {
            // get a 160 bit random seed
            if (!NewGenRandom(ppbContextSeed, pcbContextSeed,
                              (BYTE*)rgdwNewSeed, sizeof(rgdwNewSeed)))
            {
                dwReturn = (DWORD)NTE_FAIL; // NewGenRandom doesn't set LastError.
                goto ErrorExit;
            }
        }

        for (i = 0; i < A_SHA_DIGEST_LEN/sizeof(DWORD); i++)
            rgdwSeed[i] ^= rgdwNewSeed[i];

        A_SHAInit (&SHACtxt);
        memcpy(SHACtxt.state, pbInitValue, A_SHA_DIGEST_LEN);

        // perform the one way function
        A_SHAUpdate(&SHACtxt, (BYTE*)rgdwSeed, sizeof(rgdwSeed));
        if (cbContextSeed)
            A_SHAUpdate(&SHACtxt, *ppbContextSeed, cbContextSeed);
        A_SHAFinal(&SHACtxt, rgbBuf);

        for (i = 0; i < cbContextSeed && i < A_SHA_DIGEST_LEN; i++)
            (*ppbContextSeed)[i] ^= rgbBuf[i];

        // continuous 16 bit state check
        if (A_SHA_DIGEST_LEN < cbTmp)
            cbBuf = A_SHA_DIGEST_LEN;
        else
            cbBuf = cbTmp;

        if (!RNG16BitStateCheck((DWORD*)pbTmp, (DWORD*)rgbBuf, cbBuf))
        {
            dwReturn = (DWORD)NTE_FAIL;
            goto ErrorExit;
        }

        pbTmp += cbBuf;
        cbTmp -= cbBuf;
        if (0 == cbTmp)
            break;

        // modular reduction with modulus Q
        SHA_mod_q(rgbBuf, pbModulus, (BYTE*)rgdwNewSeed);

        // (1 + previous seed + new random) mod 2^160
        AddSeeds(rgdwNewSeed, rgdwSeed);
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


DWORD
FIPS186GenRandom(
    IN HANDLE *phRNGDriver,
    IN BYTE **ppbContextSeed,
    IN DWORD *pcbContextSeed,
    IN OUT BYTE *pb,
    IN DWORD cb)
{
    return FIPS186Gen(*phRNGDriver, ppbContextSeed, pcbContextSeed,
                      DSSPRIVATEKEYINIT, MODULUS, pb, cb);
}


void
FIPS186GenRandomWithException(
    IN HANDLE *phRNGDriver,
    IN BYTE **ppbContextSeed,
    IN DWORD *pcbContextSeed,
    IN OUT BYTE *pb,
    IN DWORD cb)
{
    DWORD dwSts;

    dwSts = FIPS186Gen(*phRNGDriver, ppbContextSeed, pcbContextSeed,
                       DSSPRIVATEKEYINIT, MODULUS, pb, cb);
    if (ERROR_SUCCESS != dwSts)
    {
        // nasty way to cause an error but need either this
        // or redo rsa32.lib
        RaiseException((DWORD)NTE_FAIL, 0, 0, 0);
    }
}


/*
 -  CPGenRandom
 -
 *  Purpose:
 *                Used to fill a buffer with random bytes
 *
 *
 *  Parameters:
 *               IN  hUID       -  Handle to the user identifcation
 *               IN  dwLen      -  Number of bytes of random data requested
 *               OUT pbBuffer   -  Pointer to the buffer where the random
 *                                 bytes are to be placed
 *
 *  Returns:
 */

BOOL WINAPI
CPGenRandom(
    IN HCRYPTPROV hUID,
    IN DWORD dwLen,
    OUT BYTE *pbBuffer)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PNTAGUserList   pTmpUser;
    BOOL            fRet;
    DWORD           dwSts;

    EntryPoint
    // check the user identification
    pTmpUser = NTLCheckList(hUID, USER_HANDLE);
    if (NULL == pTmpUser)
    {
        dwReturn = (DWORD)NTE_BAD_UID;
        goto ErrorExit;
    }

    dwSts = FIPS186Gen(pTmpUser->hRNGDriver,
                       &pTmpUser->ContInfo.pbRandom,
                       &pTmpUser->ContInfo.ContLens.cbRandom,
                       DSSPRIVATEKEYINIT,
                       MODULUS,
                       pbBuffer,
                       dwLen);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    fRet = (ERROR_SUCCESS == dwReturn);
    if (!fRet)
        SetLastError(dwReturn);
    return fRet;
}

//
// Function:    NewGenRandom
//
// Description: Stub to eliminate the need to link with
//              randlib.lib.  Now using RtlGenRandom() instead.
//
// Returns:     True for success.  False for failure.
//
unsigned int
RSA32API
NewGenRandom(
    IN  OUT unsigned char **ppbRandSeed /*unused*/,
    IN      unsigned long *pcbRandSeed /*unused*/,
    IN  OUT unsigned char *pbBuffer,
    IN      unsigned long dwLength
    )
{
    return (unsigned int)RtlGenRandom( pbBuffer, dwLength );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\rsaaes\ssl3.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ssl3.c                                               //
//  DESCRIPTION   : Code for performing the SSL3 protocol:                 //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//  Dec  2 1996 jeffspel Created                                           //
//  Apr 8 1997  jeffspel Added PCT1 support
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "nt_rsa.h"
#include "nt_blobs.h"
#include "manage.h"
#include "ssl3.h"
#ifdef CSP_USE_3DES
#include "tripldes.h"
#endif

#define HMAC_K_PADSIZE              64

#ifdef USE_SGC
extern BOOL
FIsLegalSGCKeySize(
    IN  ALG_ID Algid,
    IN  DWORD cbKey,
    IN  BOOL fRC2BigKeyOK,
    IN  BOOL fGenKey,
    OUT BOOL *pfPubKey);
#endif

extern BOOL
FIsLegalKeySize(
    IN  DWORD  dwCspTypeId,
    IN  ALG_ID Algid,
    IN  DWORD  cbKey,
    IN  BOOL   fRC2BigKeyOK,
    OUT BOOL  *pfPubKey);

extern BOOL
FIsLegalKey(
    PNTAGUserList pTmpUser,
    PNTAGKeyList pKey,
    BOOL fRC2BigKeyOK);

extern void
FreeNewKey(
    PNTAGKeyList pOldKey);

extern DWORD
MakeNewKey(
    ALG_ID       aiKeyAlg,
    DWORD        dwRights,
    DWORD        dwKeyLen,
    HCRYPTPROV   hUID,
    BYTE         *pbKeyData,
    BOOL         fUsePassedKeyBuffer,
    BOOL         fPreserveExactKey,
    PNTAGKeyList *ppKeyList);


/*static*/ BOOL
MyPrimitiveSHA(
    PBYTE       pbData,
    DWORD       cbData,
    BYTE        rgbHash[A_SHA_DIGEST_LEN])
{
    BOOL fRet = FALSE;
    A_SHA_CTX   sSHAHash;

    A_SHAInit(&sSHAHash);
    A_SHAUpdate(&sSHAHash, (BYTE *) pbData, cbData);
    A_SHAFinal(&sSHAHash, rgbHash);

    fRet = TRUE;
    return fRet;
}


/*static*/ BOOL
MyPrimitiveMD5(
    PBYTE       pbData,
    DWORD       cbData,
    BYTE        rgbHash[MD5DIGESTLEN])
{
    BOOL fRet = FALSE;
    MD5_CTX   sMD5Hash;

    MD5Init(&sMD5Hash);
    MD5Update(&sMD5Hash, (BYTE *) pbData, cbData);
    MD5Final(&sMD5Hash);
    memcpy(rgbHash, sMD5Hash.digest, MD5DIGESTLEN);

    fRet = TRUE;
    return fRet;
}


/*static*/ BOOL
MyPrimitiveHMACParam(
    PBYTE       pbKeyMaterial,
    DWORD       cbKeyMaterial,
    PBYTE       pbData,
    DWORD       cbData,
    ALG_ID      Algid,
    BYTE        rgbHMAC[A_SHA_DIGEST_LEN])
{
    BYTE    rgbHMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    BOOL    fRet = FALSE;
    BYTE    rgbKipad[HMAC_K_PADSIZE];
    BYTE    rgbKopad[HMAC_K_PADSIZE];
    DWORD   dwBlock;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    ZeroMemory(rgbKipad, HMAC_K_PADSIZE);
    CopyMemory(rgbKipad, pbKeyMaterial, cbKeyMaterial);

    ZeroMemory(rgbKopad, HMAC_K_PADSIZE);
    CopyMemory(rgbKopad, pbKeyMaterial, cbKeyMaterial);

    // Kipad, Kopad are padded sMacKey. Now XOR across...
    for (dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)rgbKipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)rgbKopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    // prepend Kipad to data, Hash to get H1
    if (CALG_SHA1 == Algid)
    {
        // do this inline since it would require data copy
        A_SHA_CTX   sSHAHash;

        A_SHAInit(&sSHAHash);
        A_SHAUpdate(&sSHAHash, rgbKipad, HMAC_K_PADSIZE);
        A_SHAUpdate(&sSHAHash, pbData, cbData);

        // Finish off the hash
        A_SHAFinal(&sSHAHash, sSHAHash.HashVal);

        // prepend Kopad to H1, hash to get HMAC
        CopyMemory(rgbHMACTmp, rgbKopad, HMAC_K_PADSIZE);
        CopyMemory(rgbHMACTmp+HMAC_K_PADSIZE, sSHAHash.HashVal, A_SHA_DIGEST_LEN);

        if (!MyPrimitiveSHA(
                           rgbHMACTmp,
                           HMAC_K_PADSIZE + A_SHA_DIGEST_LEN,
                           rgbHMAC))
            goto ErrorExit;
    }
    else
    {
        // do this inline since it would require data copy
        MD5_CTX   sMD5Hash;

        MD5Init(&sMD5Hash);
        MD5Update(&sMD5Hash, rgbKipad, HMAC_K_PADSIZE);
        MD5Update(&sMD5Hash, pbData, cbData);
        MD5Final(&sMD5Hash);

        // prepend Kopad to H1, hash to get HMAC
        CopyMemory(rgbHMACTmp, rgbKopad, HMAC_K_PADSIZE);
        CopyMemory(rgbHMACTmp+HMAC_K_PADSIZE, sMD5Hash.digest, MD5DIGESTLEN);

        if (!MyPrimitiveMD5(
                           rgbHMACTmp,
                           HMAC_K_PADSIZE + MD5DIGESTLEN,
                           rgbHMAC))
            goto ErrorExit;
    }

    fRet = TRUE;
ErrorExit:

    return fRet;
}


//+ ---------------------------------------------------------------------
// the P_Hash algorithm from TLS
/*static*/ DWORD
P_Hash(
    PBYTE  pbSecret,
    DWORD  cbSecret,
    PBYTE  pbSeed,
    DWORD  cbSeed,
    ALG_ID Algid,
    PBYTE  pbKeyOut, //Buffer to copy the result...
    DWORD  cbKeyOut) //# of bytes of key length they want as output.
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BYTE    rgbDigest[A_SHA_DIGEST_LEN];
    DWORD   iKey;
    DWORD   cbHash;

    PBYTE   pbAofiDigest = NULL;

    pbAofiDigest = (BYTE*)_nt_malloc(cbSeed + A_SHA_DIGEST_LEN);
    if (NULL == pbAofiDigest)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    if (CALG_SHA1 == Algid)
        cbHash = A_SHA_DIGEST_LEN;
    else
        cbHash = MD5DIGESTLEN;

    //   First, we define a data expansion function, P_hash(secret, data)
    //   which uses a single hash function to expand a secret and seed into
    //   an arbitrary quantity of output:

    //       P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
    //                              HMAC_hash(secret, A(2) + seed) +
    //                              HMAC_hash(secret, A(3) + seed) + ...

    //   Where + indicates concatenation.

    //   A() is defined as:
    //       A(0) = seed
    //       A(i) = HMAC_hash(secret, A(i-1))


    // build A(1)
    if (!MyPrimitiveHMACParam(pbSecret, cbSecret, pbSeed, cbSeed,
                              Algid, pbAofiDigest))
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    // create Aofi: (  A(i) | seed )
    CopyMemory(&pbAofiDigest[cbHash], pbSeed, cbSeed);

    for (iKey=0; cbKeyOut; iKey++)
    {
        // build Digest = HMAC(key | A(i) | seed);
        if (!MyPrimitiveHMACParam(pbSecret, cbSecret, pbAofiDigest,
                                  cbSeed + cbHash, Algid, rgbDigest))
        {
            dwReturn = (DWORD)NTE_FAIL;
            goto ErrorExit;
        }

        // append to pbKeyOut
        if (cbKeyOut < cbHash)
        {
            CopyMemory(pbKeyOut, rgbDigest, cbKeyOut);
            break;
        }
        else
        {
            CopyMemory(pbKeyOut, rgbDigest, cbHash);
            pbKeyOut += cbHash;
        }

        cbKeyOut -= cbHash;

        // build A(i) = HMAC(key, A(i-1))
        if (!MyPrimitiveHMACParam(pbSecret, cbSecret, pbAofiDigest, cbHash,
                                  Algid, pbAofiDigest))
        {
            dwReturn = (DWORD)NTE_FAIL;
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pbAofiDigest)
        _nt_free(pbAofiDigest, cbSeed + A_SHA_DIGEST_LEN);
    return dwReturn;
}


/*static*/ DWORD
PRF(
    PBYTE  pbSecret,
    DWORD  cbSecret,
    PBYTE  pbLabel,
    DWORD  cbLabel,
    PBYTE  pbSeed,
    DWORD  cbSeed,
    PBYTE  pbKeyOut, //Buffer to copy the result...
    DWORD  cbKeyOut) //# of bytes of key length they want as output.
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BYTE    *pbBuff = NULL;
    BYTE    *pbLabelAndSeed = NULL;
    DWORD   cbLabelAndSeed;
    DWORD   cbOdd;
    DWORD   cbHalfSecret;
    DWORD   i;
    DWORD   dwSts;

    cbOdd = cbSecret % 2;
    cbHalfSecret = cbSecret / 2;

    cbLabelAndSeed = cbLabel + cbSeed;
    pbLabelAndSeed = (BYTE*)_nt_malloc(cbLabelAndSeed);
    if (NULL == pbLabelAndSeed)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    pbBuff = (BYTE*)_nt_malloc(cbKeyOut);
    if (NULL == pbBuff)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }


    // copy label and seed into one buffer
    memcpy(pbLabelAndSeed, pbLabel, cbLabel);
    memcpy(pbLabelAndSeed + cbLabel, pbSeed, cbSeed);

    // Use P_hash to calculate MD5 half
    dwSts = P_Hash(pbSecret, cbHalfSecret + cbOdd, pbLabelAndSeed,
                   cbLabelAndSeed, CALG_MD5, pbKeyOut, cbKeyOut);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // Use P_hash to calculate SHA half
    dwSts = P_Hash(pbSecret + cbHalfSecret, cbHalfSecret + cbOdd,
                   pbLabelAndSeed, cbLabelAndSeed, CALG_SHA1,
                   pbBuff, cbKeyOut);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // XOR the two halves
    for (i=0;i<cbKeyOut;i++)
        pbKeyOut[i] = (BYTE)(pbKeyOut[i] ^ pbBuff[i]);

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pbBuff)
        _nt_free(pbBuff, cbKeyOut);
    if (pbLabelAndSeed)
        _nt_free(pbLabelAndSeed, cbLabelAndSeed);
    return dwReturn;
}


void
FreeSChHash(
    PSCH_HASH pSChHash)
{
    if (NULL != pSChHash->pbCertData)
        _nt_free(pSChHash->pbCertData, pSChHash->cbCertData);
}


void FreeSChKey(
    PSCH_KEY pSChKey)
{
    if (NULL != pSChKey->pbCertData)
        _nt_free(pSChKey->pbCertData, pSChKey->cbCertData);
}


DWORD
SCHSetKeyParam(
    IN PNTAGUserList pTmpUser,
    IN OUT PNTAGKeyList pKey,
    IN DWORD dwParam,
    IN CONST BYTE *pbData)
{
    DWORD               dwReturn = ERROR_INTERNAL_ERROR;
    PCRYPT_DATA_BLOB    pDataBlob = (PCRYPT_DATA_BLOB)pbData;
    PSCH_KEY            pSChKey;
    PSCHANNEL_ALG       pSChAlg;
    BOOL                fPubKey = FALSE;

    if ((CALG_SSL3_MASTER != pKey->Algid) &&
        (CALG_PCT1_MASTER != pKey->Algid) &&
        (CALG_TLS1_MASTER != pKey->Algid) &&
        (CALG_SSL2_MASTER != pKey->Algid))
    {
        dwReturn = (DWORD)NTE_BAD_TYPE;
        goto ErrorExit;
    }

    if (NULL == pKey->pData)
    {
        pKey->pData = (BYTE*)_nt_malloc(sizeof(SCH_KEY));
        if (NULL == pKey->pData)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        memset(pKey->pData, 0, sizeof(SCH_KEY));
        pKey->cbDataLen = sizeof(SCH_KEY);
    }

    pSChKey = (PSCH_KEY)pKey->pData;

    if (KP_SCHANNEL_ALG == dwParam)
    {
        pSChAlg = (PSCHANNEL_ALG)pbData;
        pSChKey->dwFlags = pSChAlg->dwFlags;   // set the international version indicator

        switch (pSChAlg->dwUse)
        {
        case SCHANNEL_MAC_KEY:
            switch (pSChAlg->Algid)
            {
            case CALG_MD5:
                if (CALG_PCT1_MASTER == pKey->Algid)
                {
                    pSChKey->cbHash = MD5DIGESTLEN;
                    pSChKey->cbEncMac = pSChAlg->cBits / 8;
                }
                else
                {
                    if (pSChAlg->cBits != (MD5DIGESTLEN * 8))
                    {
                        dwReturn = (DWORD)NTE_BAD_DATA;
                        goto ErrorExit;
                    }
                    pSChKey->cbEncMac = MD5DIGESTLEN;
                }
                break;

            case CALG_SHA1:
                if (CALG_PCT1_MASTER == pKey->Algid)
                {
                    pSChKey->cbHash = A_SHA_DIGEST_LEN;
                    pSChKey->cbEncMac = pSChAlg->cBits / 8;
                }
                else
                {
                    if (pSChAlg->cBits != (A_SHA_DIGEST_LEN * 8))
                    {
                        dwReturn = (DWORD)NTE_BAD_DATA;
                        goto ErrorExit;
                    }
                    pSChKey->cbEncMac = A_SHA_DIGEST_LEN;
                }
                break;

            default:
                dwReturn = (DWORD)NTE_BAD_DATA;
                goto ErrorExit;
            }
            pSChKey->HashAlgid = pSChAlg->Algid;
            break;

        case SCHANNEL_ENC_KEY:
            if (pSChAlg->cBits % 8)
            {
                dwReturn = (DWORD)NTE_BAD_DATA;
                goto ErrorExit;
            }

#ifdef USE_SGC
            if ((PROV_RSA_SCHANNEL == pTmpUser->dwProvType) &&
                (0 != pTmpUser->dwSGCFlags))
            {
                if (!FIsLegalSGCKeySize(pSChAlg->Algid, pSChAlg->cBits / 8,
                                        FALSE, FALSE, &fPubKey))
                {
                    dwReturn = (DWORD)NTE_BAD_FLAGS;
                    goto ErrorExit;
                }
            }
            else
#endif
            {
                if (!FIsLegalKeySize(pTmpUser->dwCspTypeId,
                                     pSChAlg->Algid, pSChAlg->cBits / 8,
                                     FALSE, &fPubKey))
                {
                    dwReturn = (DWORD)NTE_BAD_FLAGS;
                    goto ErrorExit;
                }
            }

            switch (pSChAlg->Algid)
            {
#ifdef CSP_USE_RC4
            case CALG_RC4:
                pSChKey->cbIV = 0;
                break;
#endif
#ifdef CSP_USE_RC2
            case CALG_RC2:
                pSChKey->cbIV = RC2_BLOCKLEN;
                break;
#endif
#ifdef CSP_USE_DES
            case CALG_DES:
                pSChKey->cbIV = DES_BLOCKLEN;
                break;
#endif
#ifdef CSP_USE_3DES
            case CALG_3DES_112:
                pSChKey->cbIV = DES_BLOCKLEN;
                break;
            case CALG_3DES:
                pSChKey->cbIV = DES_BLOCKLEN;
                break;
#endif
            default:
                dwReturn = (DWORD)NTE_BAD_DATA;
                goto ErrorExit;
            }

            // For SSL2 check that the length of the master key matches the
            // the requested encryption length
            if ((CALG_SSL2_MASTER == pKey->Algid) &&
                ((pSChAlg->cBits / 8) != pKey->cbKeyLen))
            {
                dwReturn = (DWORD)NTE_BAD_KEY;
                goto ErrorExit;
            }

            pSChKey->cbEnc = (pSChAlg->cBits / 8);
            pSChKey->EncAlgid = pSChAlg->Algid;
            break;

        default:
            dwReturn = (DWORD)NTE_BAD_DATA;
            goto ErrorExit;
        }
    }
    else
    {
        switch (dwParam)
        {
        case KP_CLIENT_RANDOM:
            if (pDataBlob->cbData > MAX_RANDOM_LEN)
            {
                dwReturn = (DWORD)NTE_BAD_DATA;
                goto ErrorExit;
            }

            pSChKey->cbClientRandom = pDataBlob->cbData;
            memcpy(pSChKey->rgbClientRandom,
                   pDataBlob->pbData,
                   pDataBlob->cbData);
            break;

        case KP_SERVER_RANDOM:
            if (pDataBlob->cbData > MAX_RANDOM_LEN)
            {
                dwReturn = (DWORD)NTE_BAD_DATA;
                goto ErrorExit;
            }

            pSChKey->cbServerRandom = pDataBlob->cbData;
            memcpy(pSChKey->rgbServerRandom,
                   pDataBlob->pbData,
                   pDataBlob->cbData);
            break;

        case KP_CERTIFICATE:
            if (CALG_PCT1_MASTER != pKey->Algid)
            {
                dwReturn = (DWORD)NTE_BAD_TYPE;
                goto ErrorExit;
            }

            if (pSChKey->pbCertData)
                _nt_free(pSChKey->pbCertData, pSChKey->cbCertData);
            pSChKey->cbCertData = pDataBlob->cbData;
            pSChKey->pbCertData = (BYTE*)_nt_malloc(pSChKey->cbCertData);
            if (NULL == pSChKey->pbCertData)
            {
                dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorExit;
            }

            memcpy(pSChKey->pbCertData, pDataBlob->pbData, pDataBlob->cbData);
            break;

        case KP_CLEAR_KEY:
            if (pDataBlob->cbData > MAX_RANDOM_LEN)
            {
                dwReturn = (DWORD)NTE_BAD_DATA;
                goto ErrorExit;
            }

            if ((CALG_PCT1_MASTER != pKey->Algid) &&
                (CALG_SSL2_MASTER != pKey->Algid))
            {
                dwReturn = (DWORD)NTE_BAD_TYPE;
                goto ErrorExit;
            }

            pSChKey->cbClearData = pDataBlob->cbData;
            memcpy(pSChKey->rgbClearData,
                   pDataBlob->pbData,
                   pDataBlob->cbData);
            break;

        default:
            dwReturn = (DWORD)NTE_BAD_TYPE;
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*static*/ DWORD
SSL3SingleHash(
    HCRYPTPROV hUID,
    PBYTE pbString,
    DWORD cbString,
    PBYTE pbSecret,
    DWORD cbSecret,
    PBYTE pbRand1,
    DWORD cbRand1,
    PBYTE pbRand2,
    DWORD cbRand2,
    PBYTE pbResult)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    HCRYPTHASH  hHashSHA = 0;
    HCRYPTHASH  hHashMD5 = 0;
    BYTE        rgb[A_SHA_DIGEST_LEN];
    DWORD       cb;

    // perform the SHA hashing
    if (!CPCreateHash(hUID, CALG_SHA1, 0, 0, &hHashSHA))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (!CPHashData(hUID, hHashSHA, pbString, cbString, 0))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (!CPHashData(hUID, hHashSHA, pbSecret, cbSecret, 0))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (!CPHashData(hUID, hHashSHA, pbRand1, cbRand1, 0))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (!CPHashData(hUID, hHashSHA, pbRand2, cbRand2, 0))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    cb = A_SHA_DIGEST_LEN;
    if (!CPGetHashParam(hUID, hHashSHA, HP_HASHVAL, rgb, &cb, 0))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    // perform the MD5 hashing
    if (!CPCreateHash(hUID, CALG_MD5, 0, 0, &hHashMD5))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (!CPHashData(hUID, hHashMD5, pbSecret, cbSecret, 0))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (!CPHashData(hUID, hHashMD5, rgb, A_SHA_DIGEST_LEN, 0))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    cb = MD5DIGESTLEN;
    if (!CPGetHashParam(hUID, hHashMD5, HP_HASHVAL, pbResult, &cb, 0))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (hHashSHA)
        CPDestroyHash(hUID, hHashSHA);
    if (hHashMD5)
        CPDestroyHash(hUID, hHashMD5);
    return dwReturn;
}


/*static*/ DWORD
SSL3HashPreMaster(
    HCRYPTPROV hUID,
    PBYTE pbSecret,
    DWORD cbSecret,
    PBYTE pbRand1,
    DWORD cbRand1,
    PBYTE pbRand2,
    DWORD cbRand2,
    PBYTE pbFinal,
    DWORD cbFinal)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BYTE    rgbString[17];   // know max length from MAX_RANDOM_LEN
    DWORD   cLimit;
    DWORD   cbIndex = 0;
    long    i;
    DWORD   dwSts;

    if ((cbFinal > MAX_RANDOM_LEN) || ((cbFinal % MD5DIGESTLEN) != 0))
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    cLimit = cbFinal / MD5DIGESTLEN;

    for (i=0;i<(long)cLimit;i++)
    {
        memset(rgbString, 0x41 + i, i + 1);
        dwSts = SSL3SingleHash(hUID, rgbString, i + 1, pbSecret,
                               cbSecret, pbRand1, cbRand1,
                               pbRand2, cbRand2, pbFinal + cbIndex);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        cbIndex += MD5DIGESTLEN;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


DWORD
SChGenMasterKey(
    PNTAGKeyList pKey,
    PSCH_HASH pSChHash)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    PSCH_KEY    pSChKey;
    DWORD       cb;
    BYTE        *pbClientAndServer = NULL;
    DWORD       cbClientAndServer;
    DWORD       dwSts;

    pSChKey = (PSCH_KEY)pKey->pData;
    pSChHash->dwFlags = pSChKey->dwFlags;   // set the international flag
                                            // from the key

    switch (pKey->Algid)
    {
    case CALG_SSL3_MASTER:
        if (!pSChKey->fFinished)
        {
            // copy the premaster secret
            pSChKey->cbPremaster = pKey->cbKeyLen;
            memcpy(pSChKey->rgbPremaster,
                   pKey->pKeyValue,
                   pSChKey->cbPremaster);

            // hash the pre-master secret
            dwSts = SSL3HashPreMaster(pKey->hUID,
                                      pSChKey->rgbPremaster,
                                      pSChKey->cbPremaster,
                                      pSChKey->rgbClientRandom,
                                      pSChKey->cbClientRandom,
                                      pSChKey->rgbServerRandom,
                                      pSChKey->cbServerRandom,
                                      pKey->pKeyValue,
                                      pKey->cbKeyLen);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }

        // copy the necessary information to the hash
        pSChHash->EncAlgid = pSChKey->EncAlgid;
        pSChHash->cbEnc = pSChKey->cbEnc;
        pSChHash->cbEncMac = pSChKey->cbEncMac;
        pSChHash->cbIV = pSChKey->cbIV;
        pSChHash->cbClientRandom = pSChKey->cbClientRandom;
        memcpy(pSChHash->rgbClientRandom,
               pSChKey->rgbClientRandom,
               pSChHash->cbClientRandom);
        pSChHash->cbServerRandom = pSChKey->cbServerRandom;
        memcpy(pSChHash->rgbServerRandom,
               pSChKey->rgbServerRandom,
               pSChHash->cbServerRandom);

        cb = pSChHash->cbEnc * 2
             + pSChHash->cbEncMac * 2
             + pSChHash->cbIV * 2;
        pSChHash->cbFinal = (cb / MD5DIGESTLEN) * MD5DIGESTLEN;
        if (cb % MD5DIGESTLEN)
            pSChHash->cbFinal += MD5DIGESTLEN;

        // hash the master secret
        dwSts = SSL3HashPreMaster(pKey->hUID,
                                  pKey->pKeyValue,
                                  pKey->cbKeyLen,
                                  pSChKey->rgbServerRandom,
                                  pSChKey->cbServerRandom,
                                  pSChKey->rgbClientRandom,
                                  pSChKey->cbClientRandom,
                                  pSChHash->rgbFinal,
                                  pSChHash->cbFinal);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        pSChKey->fFinished = TRUE;
        break;

    case CALG_TLS1_MASTER:
        cbClientAndServer = pSChKey->cbClientRandom
                            + pSChKey->cbServerRandom;
        pbClientAndServer = (BYTE*)_nt_malloc(cbClientAndServer);
        if (NULL == pbClientAndServer)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        if (!pSChKey->fFinished)
        {
            // copy the premaster secret
            pSChKey->cbPremaster = pKey->cbKeyLen;
            memcpy(pSChKey->rgbPremaster,
                   pKey->pKeyValue,
                   pSChKey->cbPremaster);

            // concatenate the client random and server random
            memcpy(pbClientAndServer,
                   pSChKey->rgbClientRandom,
                   pSChKey->cbClientRandom);
            memcpy(pbClientAndServer + pSChKey->cbClientRandom,
                   pSChKey->rgbServerRandom,
                   pSChKey->cbServerRandom);

            // hash the pre-master secret
            dwSts = PRF(pSChKey->rgbPremaster, pSChKey->cbPremaster,
                        (LPBYTE)"master secret", 13,
                        pbClientAndServer, cbClientAndServer,
                        pKey->pKeyValue, TLS_MASTER_LEN);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }

        // copy the necessary information to the hash
        pSChHash->EncAlgid = pSChKey->EncAlgid;
        pSChHash->cbEnc = pSChKey->cbEnc;
        pSChHash->cbEncMac = pSChKey->cbEncMac;
        pSChHash->cbIV = pSChKey->cbIV;
        pSChHash->cbClientRandom = pSChKey->cbClientRandom;
        memcpy(pSChHash->rgbClientRandom,
               pSChKey->rgbClientRandom,
               pSChHash->cbClientRandom);
        pSChHash->cbServerRandom = pSChKey->cbServerRandom;
        memcpy(pSChHash->rgbServerRandom,
               pSChKey->rgbServerRandom,
               pSChHash->cbServerRandom);

        pSChHash->cbFinal = pSChHash->cbEnc * 2
                            + pSChHash->cbEncMac * 2
                            + pSChHash->cbIV * 2;

        // concatenate the server random and client random
        memcpy(pbClientAndServer,
               pSChKey->rgbServerRandom,
               pSChKey->cbServerRandom);
        memcpy(pbClientAndServer + pSChKey->cbServerRandom,
               pSChKey->rgbClientRandom,
               pSChKey->cbClientRandom);

        // hash the master secret
        dwSts = PRF(pKey->pKeyValue, pKey->cbKeyLen,
                    (LPBYTE)"key expansion", 13,
                    pbClientAndServer, cbClientAndServer,
                    pSChHash->rgbFinal, pSChHash->cbFinal);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        pSChKey->fFinished = TRUE;
        break;

    case CALG_PCT1_MASTER:
        pSChHash->cbFinal = pKey->cbKeyLen;
        memcpy(pSChHash->rgbFinal, pKey->pKeyValue, pSChHash->cbFinal);

        // copy the necessary information to the hash
        pSChHash->EncAlgid = pSChKey->EncAlgid;
        pSChHash->HashAlgid = pSChKey->HashAlgid;
        pSChHash->cbEnc = pSChKey->cbEnc;
        pSChHash->cbEncMac = pSChKey->cbEncMac;
        pSChHash->cbHash = pSChKey->cbHash;
        pSChHash->cbIV = pSChKey->cbIV;
        pSChHash->cbClientRandom = pSChKey->cbClientRandom;
        memcpy(pSChHash->rgbClientRandom,
               pSChKey->rgbClientRandom,
               pSChHash->cbClientRandom);
        pSChHash->cbServerRandom = pSChKey->cbServerRandom;
        memcpy(pSChHash->rgbServerRandom,
               pSChKey->rgbServerRandom,
               pSChHash->cbServerRandom);

        pSChHash->cbCertData = pSChKey->cbCertData;
        pSChHash->pbCertData = (BYTE*)_nt_malloc(pSChHash->cbCertData);
        if (NULL == pSChHash->pbCertData)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        memcpy(pSChHash->pbCertData,
               pSChKey->pbCertData,
               pSChHash->cbCertData);
        pSChHash->cbClearData = pSChKey->cbClearData;
        memcpy(pSChHash->rgbClearData,
               pSChKey->rgbClearData,
               pSChHash->cbClearData);
        break;

    case CALG_SSL2_MASTER:
        pSChHash->cbFinal = pKey->cbKeyLen;
        memcpy(pSChHash->rgbFinal, pKey->pKeyValue, pSChHash->cbFinal);

        // copy the necessary information to the hash
        pSChHash->EncAlgid = pSChKey->EncAlgid;
        pSChHash->HashAlgid = pSChKey->HashAlgid;
        pSChHash->cbEnc = pSChKey->cbEnc;
        pSChHash->cbEncMac = pSChKey->cbEncMac;
        pSChHash->cbHash = pSChKey->cbHash;
        pSChHash->cbIV = pSChKey->cbIV;
        pSChHash->cbClientRandom = pSChKey->cbClientRandom;
        memcpy(pSChHash->rgbClientRandom,
               pSChKey->rgbClientRandom,
               pSChHash->cbClientRandom);
        pSChHash->cbServerRandom = pSChKey->cbServerRandom;
        memcpy(pSChHash->rgbServerRandom,
               pSChKey->rgbServerRandom,
               pSChHash->cbServerRandom);
        pSChHash->cbClearData = pSChKey->cbClearData;
        memcpy(pSChHash->rgbClearData,
               pSChKey->rgbClearData,
               pSChHash->cbClearData);
        break;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pbClientAndServer)
        _nt_free(pbClientAndServer, cbClientAndServer);
    return dwReturn;
}


/*static*/ DWORD
HelperHash(
    HCRYPTPROV hProv,
    BYTE *pb,
    DWORD cb,
    ALG_ID Algid,
    BYTE **ppbHash,
    DWORD *pcbHash,
    BOOL fAlloc)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    HCRYPTHASH  hHash = 0;

    if (fAlloc)
        *ppbHash = NULL;

    // hash the key and stuff into a usable key
    if (!CPCreateHash(hProv, Algid, 0, 0, &hHash))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (!CPHashData(hProv, hHash, pb, cb, 0))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    if (fAlloc)
    {
        if (!CPGetHashParam(hProv, hHash, HP_HASHVAL, NULL, pcbHash, 0))
        {
            dwReturn = GetLastError();
            goto ErrorExit;
        }

        *ppbHash = (BYTE*)_nt_malloc(*pcbHash);
        if (NULL == *ppbHash)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }
    }

    if (!CPGetHashParam(hProv, hHash, HP_HASHVAL, *ppbHash, pcbHash, 0))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (hHash)
        CPDestroyHash(hProv, hHash);
    if ((ERROR_SUCCESS != dwReturn) && fAlloc && *ppbHash)
    {
        _nt_free(*ppbHash, *pcbHash);
        *ppbHash = NULL;
    }
    return dwReturn;
}


/*static*/ DWORD
SSL3DeriveWriteKey(
    PNTAGUserList pTmpUser,
    PNTAGHashList pHash,
    DWORD dwFlags,
    HCRYPTKEY *phKey)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PSCH_HASH       pSChHash;
    DWORD           cbOffset;
    BYTE            *pbIV = NULL;
    DWORD           cbIV;
    BOOL            fUseIV = FALSE;
    BYTE            *pbKey = NULL;
    DWORD           cbKey;
    PNTAGKeyList    pTmpKey = NULL;
    BYTE            rgbBuff[MAX_RANDOM_LEN * 2 + MAX_PREMASTER_LEN];
    DWORD           cbBuff;
    DWORD           dwRights = 0;
    DWORD           dwSts;

    pSChHash = (PSCH_HASH)pHash->pHashData;
    cbOffset = 2 * pSChHash->cbEncMac;

    // get the IV
    if (CALG_RC4 != pSChHash->EncAlgid)
        fUseIV = TRUE;

    // if not flagged as a server key then default is client
    if (pSChHash->dwFlags & INTERNATIONAL_USAGE)
    {
        if (CRYPT_SERVER & dwFlags)
        {
            cbBuff = pSChHash->cbEnc
                     + pSChHash->cbServerRandom
                     + pSChHash->cbClientRandom;
            if (cbBuff > sizeof(rgbBuff))
            {
                dwReturn = (DWORD)NTE_FAIL;
                goto ErrorExit;
            }

            memcpy(rgbBuff, pSChHash->rgbFinal + cbOffset + pSChHash->cbEnc, pSChHash->cbEnc);
            memcpy(rgbBuff + pSChHash->cbEnc, pSChHash->rgbServerRandom, pSChHash->cbServerRandom);
            memcpy(rgbBuff + pSChHash->cbEnc + pSChHash->cbServerRandom,
                   pSChHash->rgbClientRandom, pSChHash->cbClientRandom);
            dwSts = HelperHash(pHash->hUID, rgbBuff, cbBuff, CALG_MD5,
                               &pbKey, &cbKey, TRUE);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }

            if (fUseIV)
            {
                cbBuff = pSChHash->cbServerRandom + pSChHash->cbClientRandom;
                memcpy(rgbBuff,
                       pSChHash->rgbServerRandom,
                       pSChHash->cbServerRandom);
                memcpy(rgbBuff + pSChHash->cbServerRandom,
                       pSChHash->rgbClientRandom,
                       pSChHash->cbClientRandom);
                dwSts = HelperHash(pHash->hUID, rgbBuff, cbBuff, CALG_MD5,
                                   &pbIV, &cbIV, TRUE);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }
            }
        }
        else
        {
            cbBuff = pSChHash->cbEnc
                     + pSChHash->cbServerRandom
                     + pSChHash->cbClientRandom;
            if (cbBuff > sizeof(rgbBuff))
            {
                dwReturn = (DWORD)NTE_FAIL;
                goto ErrorExit;
            }

            memcpy(rgbBuff,
                   pSChHash->rgbFinal + cbOffset,
                   pSChHash->cbEnc);
            memcpy(rgbBuff + pSChHash->cbEnc,
                   pSChHash->rgbClientRandom,
                   pSChHash->cbClientRandom);
            memcpy(rgbBuff + pSChHash->cbEnc + pSChHash->cbClientRandom,
                   pSChHash->rgbServerRandom,
                   pSChHash->cbServerRandom);
            dwSts = HelperHash(pHash->hUID, rgbBuff, cbBuff, CALG_MD5,
                               &pbKey, &cbKey, TRUE);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            if (fUseIV)
            {
                cbBuff = pSChHash->cbServerRandom
                         + pSChHash->cbClientRandom;
                memcpy(rgbBuff,
                       pSChHash->rgbClientRandom,
                       pSChHash->cbClientRandom);
                memcpy(rgbBuff + pSChHash->cbClientRandom,
                       pSChHash->rgbServerRandom,
                       pSChHash->cbServerRandom);
                dwSts = HelperHash(pHash->hUID, rgbBuff, cbBuff, CALG_MD5,
                                   &pbIV, &cbIV, TRUE);
                if (ERROR_SUCCESS != dwSts)
                {
                    dwReturn = dwSts;
                    goto ErrorExit;
                }
            }
        }
    }
    else
    {
        cbKey = pSChHash->cbEnc;
        pbKey = (BYTE*)_nt_malloc(cbKey);
        if (NULL == pbKey)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        cbIV = pSChHash->cbIV;
        pbIV = (BYTE*)_nt_malloc(cbIV);
        if (NULL == pbIV)
        {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto ErrorExit;
        }

        if (CRYPT_SERVER & dwFlags)
        {
            memcpy(pbKey,
                   pSChHash->rgbFinal + cbOffset + pSChHash->cbEnc,
                   pSChHash->cbEnc);
            memcpy(pbIV,
                   pSChHash->rgbFinal
                   + cbOffset
                   + pSChHash->cbEnc * 2
                   + pSChHash->cbIV,
                   pSChHash->cbIV);
        }
        else
        {
            memcpy(pbKey,
                   pSChHash->rgbFinal + cbOffset,
                   pSChHash->cbEnc);
            memcpy(pbIV,
                   pSChHash->rgbFinal + cbOffset + pSChHash->cbEnc * 2,
                   pSChHash->cbIV);
        }
    }

    // check if the key is CRYPT_EXPORTABLE
    if (dwFlags & CRYPT_EXPORTABLE)
        dwRights = CRYPT_EXPORTABLE;

    // make the new key
    dwSts = MakeNewKey(pSChHash->EncAlgid,
                       dwRights,
                       pSChHash->cbEnc,
                       pHash->hUID,
                       pbKey,
                       FALSE,
                       TRUE,
                       &pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (CALG_RC2 == pSChHash->EncAlgid)
        pTmpKey->EffectiveKeyLen = RC2_SCHANNEL_DEFAULT_EFFECTIVE_KEYLEN;
    if ((pSChHash->dwFlags & INTERNATIONAL_USAGE)
        && ((CALG_RC2 == pSChHash->EncAlgid)
            || (CALG_RC4 == pSChHash->EncAlgid)))
    {
        pTmpKey->cbSaltLen = RC_KEYLEN - pSChHash->cbEnc;
        memcpy(pTmpKey->rgbSalt,
               pbKey + pSChHash->cbEnc,
               pTmpKey->cbSaltLen);
    }

    // check keylength...
    if (!FIsLegalKey(pTmpUser, pTmpKey, FALSE))
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    // set the IV if necessary
    if (fUseIV)
    {
        // set the mode to CBC
        pTmpKey->Mode = CRYPT_MODE_CBC;

        // set the IV
        memcpy(pTmpKey->IV, pbIV, CRYPT_BLKLEN);    // Initialization vector
    }

    dwSts = NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    pTmpKey = NULL;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pbKey)
        _nt_free(pbKey, cbKey);
    if (pbIV)
        _nt_free(pbIV, cbIV);
    return dwReturn;
}


/*static*/ DWORD
PCT1MakeKeyHash(
    PNTAGHashList pHash,
    DWORD c,
    DWORD dwFlags,
    BOOL fWriteKey,
    BYTE *pbBuff,
    DWORD *pcbBuff)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    BYTE        *pb = NULL;
    DWORD       cb = 0;
    DWORD       cbIndex;
    PSCH_HASH   pSChHash;
    BYTE        *pbStr;
    DWORD       cbStr;
    DWORD       i;
    BYTE        *pbHash = NULL;
    DWORD       cbHash;
    DWORD       dwSts;

    pSChHash = (PSCH_HASH)pHash->pHashData;

    // For reasons of backward compatibility, use the formula:
    //     hash( i, "foo"^i, MASTER_KEY, ...
    // rather than:
    //     hash( i, "foo", MASTER_KEY, ...
    // when deriving encryption keys.

    if (fWriteKey)
    {
        if (CRYPT_SERVER & dwFlags)
        {
            pbStr = (LPBYTE)PCT1_S_WRT;
            cbStr = PCT1_S_WRT_LEN;
            cb = cbStr * c;
        }
        else
        {
            pbStr = (LPBYTE)PCT1_C_WRT;
            cbStr = PCT1_C_WRT_LEN;
            cb = pSChHash->cbCertData + cbStr * c * 2;
        }
    }
    else
    {
        if (CRYPT_SERVER & dwFlags)
        {
            pbStr = (LPBYTE)PCT1_S_MAC;
            cbStr = PCT1_S_MAC_LEN;
        }
        else
        {
            pbStr = (LPBYTE)PCT1_C_MAC;
            cbStr = PCT1_C_MAC_LEN;
            cb = pSChHash->cbCertData + cbStr * c;
        }
    }

    cb += 1 + (3 * cbStr * c) + pSChHash->cbFinal +
          + pSChHash->cbClientRandom  + pSChHash->cbServerRandom;

    pb = (BYTE*)_nt_malloc(cb);
    if (NULL == pb)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    // form the buffer to be hashed
    pb[0] = (BYTE)c;
    cbIndex = 1;

    if (fWriteKey)
    {
        for (i=0;i<c;i++)
        {
            memcpy(pb + cbIndex, pbStr, cbStr);
            cbIndex += cbStr;
        }
    }

    memcpy(pb + cbIndex, pSChHash->rgbFinal, pSChHash->cbFinal);
    cbIndex += pSChHash->cbFinal;
    for (i=0;i<c;i++)
    {
        memcpy(pb + cbIndex, pbStr, cbStr);
        cbIndex += cbStr;
    }
    memcpy(pb + cbIndex, pSChHash->rgbServerRandom, pSChHash->cbServerRandom);
    cbIndex += pSChHash->cbServerRandom;
    for (i=0;i<c;i++)
    {
        memcpy(pb + cbIndex, pbStr, cbStr);
        cbIndex += cbStr;
    }

    if (!(CRYPT_SERVER & dwFlags))
    {
        memcpy(pb + cbIndex, pSChHash->pbCertData, pSChHash->cbCertData);
        cbIndex += pSChHash->cbCertData;
        for (i=0;i<c;i++)
        {
            memcpy(pb + cbIndex, pbStr, cbStr);
            cbIndex += cbStr;
        }
    }

    memcpy(pb + cbIndex, pSChHash->rgbClientRandom, pSChHash->cbClientRandom);
    cbIndex += pSChHash->cbClientRandom;
    for (i=0;i<c;i++)
    {
        memcpy(pb + cbIndex, pbStr, cbStr);
        cbIndex += cbStr;
    }

    dwSts = HelperHash(pHash->hUID, pb, cb, pSChHash->HashAlgid,
                       &pbHash, &cbHash, TRUE);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    *pcbBuff = cbHash;
    memcpy(pbBuff, pbHash, *pcbBuff);

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pb)
        _nt_free(pb, cb);
    if (pbHash)
        _nt_free(pbHash, cbHash);
    return dwReturn;
}


/*static*/ DWORD
PCT1MakeExportableWriteKey(
    PNTAGHashList pHash,
    BYTE *pbBuff,
    DWORD *pcbBuff)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    BYTE        *pb = NULL;
    DWORD       cb;
    BYTE        *pbHash = NULL;
    DWORD       cbHash;
    PSCH_HASH   pSChHash;
    DWORD       dwSts;

    pSChHash = (PSCH_HASH)pHash->pHashData;

    // assumption is made that exportable keys are 16 bytes in length (RC4 & RC2)
    cb = 5 + *pcbBuff + pSChHash->cbClearData;

    pb = (BYTE*)_nt_malloc(cb);
    if (NULL == pb)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    // form the buffer to be hashed
    pb[0] = 1;
    memcpy(pb + 1, "sl", 2);
    memcpy(pb + 3, pbBuff, *pcbBuff);
    memcpy(pb + 3 + *pcbBuff, "sl", 2);
    memcpy(pb + 5 + *pcbBuff, pSChHash->rgbClearData, pSChHash->cbClearData);

    dwSts = HelperHash(pHash->hUID, pb, cb, pSChHash->HashAlgid,
                       &pbHash, &cbHash, TRUE);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    *pcbBuff = cbHash;
    memcpy(pbBuff, pbHash, *pcbBuff);

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pb)
        _nt_free(pb, cb);
    if (pbHash)
        _nt_free(pbHash, cbHash);
    return dwReturn;
}


/*static*/ DWORD
PCT1DeriveKey(
    PNTAGUserList pTmpUser,
    ALG_ID Algid,
    PNTAGHashList pHash,
    DWORD dwFlags,
    HCRYPTKEY *phKey)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    BYTE            rgbHashBuff[A_SHA_DIGEST_LEN * 2];  // SHA is largest hash and max is two concatenated
    DWORD           cbHashBuff = 0;
    DWORD           cb;
    DWORD           cbKey;
    PNTAGKeyList    pTmpKey = NULL;
    DWORD           i;
    DWORD           cHashes;
    ALG_ID          KeyAlgid;
    BOOL            fWriteKey = FALSE;
    PSCH_HASH       pSChHash;
    BYTE            rgbSalt[MAX_SALT_LEN];
    DWORD           cbSalt = 0;
    DWORD           dwRights = 0;
    DWORD           dwSts;

    memset(rgbSalt, 0, sizeof(rgbSalt));
    pSChHash = (PSCH_HASH)pHash->pHashData;

    switch (Algid)
    {
    case CALG_SCHANNEL_MAC_KEY:
        cbKey = pSChHash->cbEncMac;
        KeyAlgid = Algid;
        break;

    case CALG_SCHANNEL_ENC_KEY:
        fWriteKey = TRUE;
        cbKey = pSChHash->cbEnc;
        KeyAlgid = pSChHash->EncAlgid;
        break;

    default:
        dwReturn = (DWORD)NTE_BAD_ALGID;
        goto ErrorExit;
    }

    cHashes = (cbKey + (pSChHash->cbHash - 1)) / pSChHash->cbHash;
    if (cHashes > 2)
    {
        dwReturn = (DWORD)NTE_FAIL;
        goto ErrorExit;
    }

    for (i=0;i<cHashes;i++)
    {
        dwSts = PCT1MakeKeyHash(pHash, i + 1, dwFlags, fWriteKey,
                                rgbHashBuff + cbHashBuff, &cb);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        cbHashBuff += cb;
    }

    if ((CALG_SCHANNEL_ENC_KEY == Algid) &&
        (EXPORTABLE_KEYLEN == pSChHash->cbEnc))
    {
        cbHashBuff = cbKey;
        dwSts = PCT1MakeExportableWriteKey(pHash, rgbHashBuff, &cbHashBuff);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        cbSalt = EXPORTABLE_SALTLEN;
        memcpy(rgbSalt, rgbHashBuff + pSChHash->cbEnc, cbSalt);
    }

    // check if the key is CRYPT_EXPORTABLE
    if (dwFlags & CRYPT_EXPORTABLE)
        dwRights = CRYPT_EXPORTABLE;

    // make the new key
    dwSts = MakeNewKey(KeyAlgid, dwRights, cbKey,
                       pHash->hUID, rgbHashBuff,
                       FALSE, TRUE, &pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (CALG_RC2 == KeyAlgid)
        pTmpKey->EffectiveKeyLen = RC2_SCHANNEL_DEFAULT_EFFECTIVE_KEYLEN;

    if ((CALG_SCHANNEL_ENC_KEY == Algid) &&
        (EXPORTABLE_KEYLEN == pSChHash->cbEnc))
    {
        pTmpKey->cbSaltLen = cbSalt;
        memcpy(pTmpKey->rgbSalt, rgbSalt, cbSalt);
    }

    // check keylength...
    if (!FIsLegalKey(pTmpUser, pTmpKey, FALSE))
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    dwSts = NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    pTmpKey = NULL;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pTmpKey)
        FreeNewKey(pTmpKey);
    return dwReturn;
}


/*static*/ DWORD
TLSDeriveExportableRCKey(
    PSCH_HASH pSChHash,
    BYTE *pbClientAndServer,
    DWORD cbClientAndServer,
    BYTE **ppbKey,
    DWORD *pcbKey,
    BYTE *pbSalt,
    DWORD *pcbSalt,
    DWORD dwFlags)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD   dwSts;

    // use key length 16 because this should only occur with RC2 and RC4
    // and those key lengths should be 16
    if ((CALG_RC2 == pSChHash->EncAlgid)
        || (CALG_RC4 == pSChHash->EncAlgid))
    {
        *pcbKey = RC_KEYLEN;
        *pcbSalt = RC_KEYLEN - pSChHash->cbEnc;
    }
    else
    {
        *pcbKey = pSChHash->cbEnc;
    }

    *ppbKey = (BYTE*)_nt_malloc(*pcbKey);
    if (NULL == *ppbKey)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    // check if it is a server key or client key
    if (dwFlags & CRYPT_SERVER)
    {
        dwSts = PRF(pSChHash->rgbFinal
                    + pSChHash->cbEncMac * 2
                    + pSChHash->cbEnc,
                    pSChHash->cbEnc,
                    (LPBYTE)"server write key",
                    16,
                    pbClientAndServer,
                    cbClientAndServer,
                    *ppbKey,
                    *pcbKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }
    else
    {
        dwSts = PRF(pSChHash->rgbFinal + pSChHash->cbEncMac * 2,
                    pSChHash->cbEnc, (LPBYTE)"client write key", 16,
                    pbClientAndServer, cbClientAndServer,
                    *ppbKey, *pcbKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    if (0 != *pcbSalt)
        memcpy(pbSalt, (*ppbKey) + pSChHash->cbEnc, *pcbSalt);

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}

/*static*/ DWORD
TLSDeriveExportableEncKey(
    PSCH_HASH pSChHash,
    BYTE **ppbKey,
    DWORD *pcbKey,
    BYTE **ppbRealKey,
    BYTE *pbSalt,
    DWORD *pcbSalt,
    BYTE *pbIV,
    DWORD dwFlags)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BYTE    *pbClientAndServer = NULL;
    DWORD   cbClientAndServer;
    BYTE    *pbIVBlock = NULL;
    DWORD   dwSts;

    cbClientAndServer = pSChHash->cbClientRandom + pSChHash->cbServerRandom;
    pbClientAndServer = (BYTE*)_nt_malloc(cbClientAndServer);
    if (NULL == pbClientAndServer)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    pbIVBlock = (BYTE*)_nt_malloc(pSChHash->cbIV * 2);
    if (NULL == pbIVBlock)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    // concatenate the server random and client random
    memcpy(pbClientAndServer, pSChHash->rgbClientRandom,
           pSChHash->cbClientRandom);
    memcpy(pbClientAndServer + pSChHash->cbClientRandom,
           pSChHash->rgbServerRandom, pSChHash->cbServerRandom);

    // calculate the IV block
    if (pSChHash->cbIV)
    {
        dwSts = PRF(NULL, 0, (LPBYTE)"IV block", 8, pbClientAndServer,
                    cbClientAndServer, pbIVBlock, pSChHash->cbIV * 2);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        if (dwFlags & CRYPT_SERVER)
            memcpy(pbIV, pbIVBlock + pSChHash->cbIV, pSChHash->cbIV);
        else
            memcpy(pbIV, pbIVBlock, pSChHash->cbIV);
    }

    // check if it is a server key or client key
    dwSts = TLSDeriveExportableRCKey(pSChHash,
                                     pbClientAndServer,
                                     cbClientAndServer,
                                     ppbKey,
                                     pcbKey,
                                     pbSalt,
                                     pcbSalt,
                                     dwFlags);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    *ppbRealKey = *ppbKey;

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pbIVBlock)
        _nt_free(pbIVBlock, pSChHash->cbIV * 2);
    if (pbClientAndServer)
        _nt_free(pbClientAndServer, cbClientAndServer);
    return dwReturn;
}


/*static*/ DWORD
TLSDeriveKey(
    PNTAGUserList pTmpUser,
    ALG_ID Algid,
    PNTAGHashList pHash,
    DWORD dwFlags,
    HCRYPTKEY *phKey)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PSCH_HASH       pSChHash;
    PNTAGKeyList    pTmpKey = NULL;
    BYTE            *pbKey;
    DWORD           cbKey;
    BYTE            rgbSalt[MAX_SALT_LEN];
    DWORD           cbSalt = 0;
    BYTE            rgbIV[CRYPT_BLKLEN];
    DWORD           cbIVIndex = 0;
    ALG_ID          KeyAlgid;
    BYTE            *pbAllocKey = NULL;
    DWORD           cbAllocKey;
    DWORD           dwRights = 0;
    DWORD           dwSts;

    memset(rgbIV, 0, sizeof(rgbIV));
    memset(rgbSalt, 0, sizeof(rgbSalt));
    pSChHash = (PSCH_HASH)pHash->pHashData;

    switch (Algid)
    {
    case CALG_SCHANNEL_MAC_KEY:
        cbKey = pSChHash->cbEncMac;
        KeyAlgid = Algid;

        // check if it is a server key or client key
        if (dwFlags & CRYPT_SERVER)
            pbKey = pSChHash->rgbFinal + pSChHash->cbEncMac;
        else
            pbKey = pSChHash->rgbFinal;
        break;

    case CALG_SCHANNEL_ENC_KEY:
        cbKey = pSChHash->cbEnc;
        KeyAlgid = pSChHash->EncAlgid;

        // if in exportable situation then call the exportable routine
        if (pSChHash->dwFlags & INTERNATIONAL_USAGE)
        {
            dwSts = TLSDeriveExportableEncKey(pSChHash, &pbAllocKey,
                                              &cbAllocKey, &pbKey, rgbSalt,
                                              &cbSalt, rgbIV, dwFlags);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
        }
        else
        {
            if (dwFlags & CRYPT_SERVER)
            {
                pbKey = pSChHash->rgbFinal + pSChHash->cbEncMac * 2 +
                        pSChHash->cbEnc;

                if (pSChHash->cbIV)
                {
                    cbIVIndex = pSChHash->cbEncMac * 2 +
                                pSChHash->cbEnc * 2 + pSChHash->cbIV;
                }
            }
            else
            {
                pbKey = pSChHash->rgbFinal + pSChHash->cbEncMac * 2;

                if (pSChHash->cbIV)
                {
                    cbIVIndex = pSChHash->cbEncMac * 2 +
                                pSChHash->cbEnc * 2;
                }
            }
            memcpy(rgbIV, pSChHash->rgbFinal + cbIVIndex,
                   pSChHash->cbIV);
        }
        break;

    default:
        dwReturn = (DWORD)NTE_BAD_ALGID;
        goto ErrorExit;
    }

    // check if the key is CRYPT_EXPORTABLE
    if (dwFlags & CRYPT_EXPORTABLE)
        dwRights = CRYPT_EXPORTABLE;

    // make the new key
    dwSts = MakeNewKey(KeyAlgid, dwRights, cbKey,
                       pHash->hUID, pbKey,
                       FALSE, TRUE, &pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (CALG_RC2 == KeyAlgid)
        pTmpKey->EffectiveKeyLen = RC2_SCHANNEL_DEFAULT_EFFECTIVE_KEYLEN;

    // set up the salt
    memcpy(pTmpKey->rgbSalt, rgbSalt, cbSalt);
    pTmpKey->cbSaltLen = cbSalt;

    // copy IV if necessary
    if (pSChHash->cbIV)
        memcpy(pTmpKey->IV, rgbIV, pSChHash->cbIV);

    // check keylength...
    if (!FIsLegalKey(pTmpUser, pTmpKey, FALSE))
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    dwSts = NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    pTmpKey = NULL;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (NULL != pbAllocKey)
        _nt_free(pbAllocKey, cbAllocKey);
    if (NULL != pTmpKey)
        FreeNewKey(pTmpKey);
    return dwReturn;
}


/*static*/ DWORD
SSL2DeriveKey(
    PNTAGUserList pTmpUser,
    ALG_ID Algid,
    PNTAGHashList pHash,
    DWORD dwFlags,
    HCRYPTKEY *phKey)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PSCH_HASH       pSChHash;
    BYTE            rgbHash[2 * MD5DIGESTLEN];
    BYTE            *pbHash;
    DWORD           cbHash = 2 * MD5DIGESTLEN;
    BYTE            *pbTmp = NULL;
    DWORD           cbTmp;
    BYTE            *pbKey = NULL;
    DWORD           cbKey = 0;
    BYTE            rgbSalt[MAX_SALT_LEN];
    DWORD           cbSalt = 0;
    DWORD           cbIndex;
    DWORD           cbChangeByte;
    PNTAGKeyList    pTmpKey = NULL;
    DWORD           dwRights = 0;
    DWORD           dwSts;

    memset(rgbSalt, 0, sizeof(rgbSalt));

    if (CALG_SCHANNEL_ENC_KEY != Algid)
    {
        dwReturn = (DWORD)NTE_BAD_ALGID;
        goto ErrorExit;
    }

    pbHash = rgbHash;
    pSChHash = (PSCH_HASH)pHash->pHashData;

    // set up the buffer to be hashed
    cbTmp = pSChHash->cbFinal + pSChHash->cbClearData +
            pSChHash->cbClientRandom + pSChHash->cbServerRandom + 1;

    pbTmp = (BYTE*)_nt_malloc(cbTmp);
    if (NULL == pbTmp)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    memcpy(pbTmp, pSChHash->rgbClearData,
           pSChHash->cbClearData);
    cbIndex = pSChHash->cbClearData;

    // exportability check
    memcpy(pbTmp + cbIndex, pSChHash->rgbFinal, pSChHash->cbFinal);
    cbIndex += pSChHash->cbFinal;

    cbChangeByte = cbIndex;
    cbIndex++;

    memcpy(pbTmp + cbIndex, pSChHash->rgbClientRandom,
           pSChHash->cbClientRandom);
    cbIndex += pSChHash->cbClientRandom;
    memcpy(pbTmp + cbIndex, pSChHash->rgbServerRandom,
           pSChHash->cbServerRandom);
    cbIndex += pSChHash->cbServerRandom;

    switch (pSChHash->EncAlgid)
    {
#ifdef CSP_USE_RC2
    case CALG_RC2:
#endif
#ifdef CSP_USE_RC4
    case CALG_RC4:
#endif
        if (CRYPT_SERVER & dwFlags)
            pbTmp[cbChangeByte] = 0x30;
        else
            pbTmp[cbChangeByte] = 0x31;

        // hash the data to get the key
        dwSts = HelperHash(pHash->hUID, pbTmp, cbTmp, CALG_MD5,
                           &pbHash, &cbHash, FALSE);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        pbKey = pbHash;

        // check for export
        if (pSChHash->cbClearData)
        {
            cbKey = 5;
            cbSalt = 11;
            memcpy(rgbSalt, pbKey + cbKey, cbSalt);
        }
        else
            cbKey = 16;
        break;

#ifdef CSP_USE_DES
    case CALG_DES:
        pbTmp[cbChangeByte] = 0x30;
        // hash the data to get the key
        dwSts = HelperHash(pHash->hUID, pbTmp, cbTmp,
                           CALG_MD5, &pbHash, &cbHash, FALSE);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }

        if (CRYPT_SERVER & dwFlags)
            pbKey = pbHash;
        else
            pbKey = pbHash + DES_KEYSIZE;
        cbKey = DES_KEYSIZE;
        break;
#endif

#ifdef CSP_USE_3DES
    case CALG_3DES:
        if (CRYPT_SERVER & dwFlags)
        {
            pbTmp[cbChangeByte] = 0x30;
            // hash the data to get the key
            dwSts = HelperHash(pHash->hUID, pbTmp, cbTmp,
                               CALG_MD5, &pbHash, &cbHash, FALSE);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            pbTmp[cbChangeByte] = 0x31;
            pbHash = rgbHash + MD5DIGESTLEN;
            // hash the data to get the key
            dwSts = HelperHash(pHash->hUID, pbTmp, cbTmp, CALG_MD5,
                               &pbHash, &cbHash, FALSE);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            pbKey = rgbHash;
        }
        else
        {
            pbTmp[cbChangeByte] = 0x31;
            // hash the data to get the key
            dwSts = HelperHash(pHash->hUID, pbTmp, cbTmp,
                               CALG_MD5, &pbHash, &cbHash, FALSE);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            pbTmp[cbChangeByte] = 0x32;
            pbHash = rgbHash + MD5DIGESTLEN;
            // hash the data to get the key
            dwSts = HelperHash(pHash->hUID, pbTmp, cbTmp, CALG_MD5,
                               &pbHash, &cbHash, FALSE);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            pbKey = rgbHash + DES_KEYSIZE;
        }
        cbKey = DES3_KEYSIZE;
        break;
#endif
    }

    // check if the key is CRYPT_EXPORTABLE
    if (dwFlags & CRYPT_EXPORTABLE)
        dwRights = CRYPT_EXPORTABLE;

    // make the new key
    dwSts = MakeNewKey(pSChHash->EncAlgid,
                       dwRights,
                       cbKey,
                       pHash->hUID,
                       pbKey,
                       FALSE,
                       TRUE,
                       &pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    if (CALG_RC2 == pSChHash->EncAlgid)
        pTmpKey->EffectiveKeyLen = RC2_SCHANNEL_DEFAULT_EFFECTIVE_KEYLEN;
    pTmpKey->cbSaltLen = cbSalt;
    memcpy(pTmpKey->rgbSalt, rgbSalt, cbSalt);

    // check keylength...
    if (!FIsLegalKey(pTmpUser, pTmpKey, FALSE))
    {
        dwReturn = (DWORD)NTE_BAD_FLAGS;
        goto ErrorExit;
    }

    dwSts = NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    pTmpKey = NULL;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pbTmp)
        _nt_free(pbTmp, cbTmp);
    if (pTmpKey)
        FreeNewKey(pTmpKey);
    return dwReturn;
}


DWORD
SecureChannelDeriveKey(
    PNTAGUserList pTmpUser,
    PNTAGHashList pHash,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    PSCH_HASH       pSChHash;
    BYTE            *pbKey = NULL;
    DWORD           cbKey;
    PNTAGKeyList    pTmpKey = NULL;
    DWORD           dwRights = 0;
    DWORD           dwSts;

    pSChHash = (PSCH_HASH)pHash->pHashData;

    switch (pSChHash->ProtocolAlgid)
    {
    case CALG_SSL3_MASTER:
        switch (Algid)
        {
        case CALG_SCHANNEL_MAC_KEY:
            cbKey = pSChHash->cbEncMac;
            pbKey = (BYTE*)_nt_malloc(cbKey);
            if (NULL == pbKey)
            {
                dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorExit;
            }

            // if not flagged as a server key then default is client
            if (CRYPT_SERVER & dwFlags)
                memcpy(pbKey, pSChHash->rgbFinal + cbKey, cbKey);
            else
                memcpy(pbKey, pSChHash->rgbFinal, cbKey);

            // check if the key is CRYPT_EXPORTABLE
            if (dwFlags & CRYPT_EXPORTABLE)
                dwRights = CRYPT_EXPORTABLE;

            // make the new key
            dwSts = MakeNewKey(Algid, dwRights, cbKey, pHash->hUID,
                               pbKey, TRUE, TRUE, &pTmpKey);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            pbKey = NULL;

            // check keylength...
            if (!FIsLegalKey(pTmpUser, pTmpKey, FALSE))
            {
                dwReturn = (DWORD)NTE_BAD_FLAGS;
                goto ErrorExit;
            }

            dwSts = NTLMakeItem(phKey, KEY_HANDLE, (void *)pTmpKey);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }

            break;

        case CALG_SCHANNEL_ENC_KEY:
            // derive the write keys
            dwSts = SSL3DeriveWriteKey(pTmpUser, pHash, dwFlags, phKey);
            if (ERROR_SUCCESS != dwSts)
            {
                dwReturn = dwSts;
                goto ErrorExit;
            }
            break;

        default:
            dwReturn = (DWORD)NTE_BAD_ALGID;
            goto ErrorExit;
        }
        break;

    case CALG_PCT1_MASTER:
        // derive the PCT1 key
        dwSts = PCT1DeriveKey(pTmpUser, Algid, pHash, dwFlags, phKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;

    case CALG_TLS1_MASTER:
        // derive the PCT1 key
        dwSts = TLSDeriveKey(pTmpUser, Algid, pHash, dwFlags, phKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;

    case CALG_SSL2_MASTER:
        // derive the PCT1 key
        dwSts = SSL2DeriveKey(pTmpUser, Algid, pHash, dwFlags, phKey);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
        break;
    }

    pTmpKey = NULL;
    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pbKey)
        _nt_free(pbKey, cbKey);
    if (NULL != pTmpKey)
        FreeNewKey(pTmpKey);
    return dwReturn;
}


DWORD
SetPRFHashParam(
    PRF_HASH *pPRFHash,
    DWORD dwParam,
    CONST BYTE *pbData)
{
    DWORD           dwReturn = ERROR_INTERNAL_ERROR;
    CRYPT_DATA_BLOB *pBlob;

    pBlob = (CRYPT_DATA_BLOB*)pbData;

    if (HP_TLS1PRF_LABEL == dwParam)
    {
        if (pBlob->cbData > sizeof(pPRFHash->rgbLabel))
        {
            dwReturn = (DWORD)NTE_BAD_DATA;
            goto ErrorExit;
        }

        pPRFHash->cbLabel = pBlob->cbData;
        memcpy(pPRFHash->rgbLabel, pBlob->pbData, pBlob->cbData);
    }
    else
    {
        if (pBlob->cbData > sizeof(pPRFHash->rgbSeed))
        {
            dwReturn = (DWORD)NTE_BAD_DATA;
            goto ErrorExit;
        }

        pPRFHash->cbSeed = pBlob->cbData;
        memcpy(pPRFHash->rgbSeed, pBlob->pbData, pBlob->cbData);
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


DWORD
CalculatePRF(
    PRF_HASH *pPRFHash,
    BYTE *pbData,
    DWORD *pcbData)
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD   dwSts;

    if (NULL == pbData)
    {
        *pcbData = 0;
    }
    else
    {
        if ((0 == pPRFHash->cbSeed) || (0 == pPRFHash->cbLabel))
        {
            dwReturn = (DWORD)NTE_BAD_HASH_STATE;
            goto ErrorExit;
        }

        dwSts = PRF(pPRFHash->rgbMasterKey,  sizeof(pPRFHash->rgbMasterKey),
                    pPRFHash->rgbLabel, pPRFHash->cbLabel,
                    pPRFHash->rgbSeed, pPRFHash->cbSeed, pbData, *pcbData);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\sgc\sgccheck.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : sgccheck.c                                             //
//  DESCRIPTION   : Code to check if SGC is enabled                        //
//  AUTHOR        : jeffspel                                               //
//  HISTORY       :                                                        //
//  Jun 16 1998 jeffspel  Create                                           //
//  Nov 16 1998 jbanes    Pluggable SGC roots.                             //
//                                                                         //
//  Copyright (C) 1998 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <windef.h>
#include <wincrypt.h>
#include <sgccheck.h>

#define SGCAlloc(cb)    LocalAlloc(LMEM_ZEROINIT, cb)
#define SGCFree(pb)     LocalFree(pb)


//#define SGC_TEST_KEY    // COMMENT OUT THIS LINE BEFORE CHECKING IN!!!
#ifdef SGC_TEST_KEY
#pragma message ("WARNING -- Building with SGC Test Key enabled.")
#endif

#define SGC_VERIFICATION_FLAGS  (CERT_STORE_SIGNATURE_FLAG | CERT_STORE_TIME_VALIDITY_FLAG)


// Geneva SGC Root
static CONST BYTE GenevaSGCRoot[] =
  { 0x30, 0x82, 0x03, 0x0a, 0x30, 0x82, 0x01, 0xf2,     // 0...0...
    0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x0a, 0x20,     // .......
    0x9d, 0x11, 0xd1, 0x0e, 0x7f, 0x7b, 0x85, 0x74,     // .....{.t
    0x80, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,     // .0...*.H
    0x86, 0xf7, 0x0d, 0x01, 0x01, 0x04, 0x05, 0x00,     // ........
    0x30, 0x1d, 0x31, 0x1b, 0x30, 0x19, 0x06, 0x03,     // 0.1.0...
    0x55, 0x04, 0x03, 0x13, 0x12, 0x52, 0x6f, 0x6f,     // U....Roo
    0x74, 0x20, 0x53, 0x47, 0x43, 0x20, 0x41, 0x75,     // t SGC Au
    0x74, 0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x30,     // thority0
    0x1e, 0x17, 0x0d, 0x39, 0x37, 0x30, 0x38, 0x30,     // ...97080
    0x36, 0x31, 0x37, 0x31, 0x34, 0x34, 0x37, 0x5a,     // 6171447Z
    0x17, 0x0d, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31,     // ..100101
    0x30, 0x37, 0x30, 0x30, 0x30, 0x30, 0x5a, 0x30,     // 070000Z0
    0x1d, 0x31, 0x1b, 0x30, 0x19, 0x06, 0x03, 0x55,     // .1.0...U
    0x04, 0x03, 0x13, 0x12, 0x52, 0x6f, 0x6f, 0x74,     // ....Root
    0x20, 0x53, 0x47, 0x43, 0x20, 0x41, 0x75, 0x74,     //  SGC Aut
    0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x30, 0x82,     // hority0.
    0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86,     // ."0...*.
    0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05,     // H.......
    0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82,     // ......0.
    0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xec,     // ........
    0x55, 0x5d, 0x0f, 0xaf, 0x6c, 0x5b, 0xa5, 0x21,     // U]..l[.!
    0xe5, 0x81, 0xbc, 0x0d, 0x96, 0xee, 0xb4, 0x63,     // .......c
    0xbc, 0x4c, 0x14, 0x68, 0x6d, 0xfe, 0xd7, 0x64,     // .L.hm..d
    0x2d, 0xe7, 0x59, 0x9d, 0x8e, 0x20, 0x9c, 0x1c,     // -.Y.. ..
    0xb1, 0x18, 0x39, 0x38, 0x80, 0xc6, 0x08, 0xa6,     // ..98....
    0x65, 0x39, 0x6c, 0x0a, 0x86, 0x6c, 0x8b, 0x6a,     // e9l..l.j
    0xaa, 0x4a, 0x7a, 0xb4, 0xe5, 0x23, 0x7b, 0x9c,     // .Jz..#{.
    0xa2, 0x88, 0x81, 0xa5, 0x2c, 0x9f, 0x2e, 0xce,     // ....,...
    0x56, 0xd8, 0x69, 0xc7, 0xd7, 0x54, 0xf8, 0xdd,     // V.i..T..
    0xab, 0x9b, 0xc7, 0xba, 0x8e, 0xe7, 0x60, 0x1c,     // ......`.
    0x45, 0x20, 0x09, 0x9d, 0x00, 0x25, 0x16, 0x15,     // E ...%..
    0xe0, 0x40, 0x2c, 0xf2, 0xac, 0xfa, 0x1f, 0xf8,     // .@,.....
    0x6d, 0x5e, 0xda, 0xbb, 0x14, 0xaf, 0x4c, 0x82,     // m^....L.
    0xf3, 0x5d, 0x81, 0xcb, 0xef, 0xcd, 0xa8, 0x0f,     // .]......
    0xf1, 0xec, 0xa5, 0xa3, 0x44, 0x94, 0x69, 0x7a,     // ....D.iz
    0x88, 0xec, 0xa9, 0x18, 0xf3, 0xac, 0x38, 0xe6,     // ......8.
    0xe7, 0xe0, 0xe1, 0x11, 0xa8, 0xa5, 0x5f, 0x18,     // ......_.
    0x00, 0x72, 0xd0, 0x00, 0x9e, 0x12, 0x89, 0x50,     // .r.....P
    0x96, 0x20, 0xdb, 0xcd, 0x63, 0xe7, 0xb3, 0xc0,     // . ..c...
    0xfa, 0x54, 0xa1, 0xe7, 0x4a, 0x74, 0x5d, 0xcd,     // .T..Jt].
    0x4a, 0x2f, 0x4c, 0x44, 0xa3, 0xdc, 0x40, 0xad,     // J/LD..@.
    0xe7, 0xdc, 0x4d, 0x9b, 0x2a, 0x55, 0x13, 0x0b,     // ..M.*U..
    0x4d, 0x4f, 0x3d, 0xc3, 0x02, 0xac, 0xd2, 0x03,     // MO=.....
    0x70, 0x0a, 0x48, 0xa9, 0x96, 0x5b, 0x04, 0x57,     // p.H..[.W
    0xb9, 0xe2, 0x5a, 0x04, 0x5e, 0xcf, 0x6f, 0x4e,     // ..Z.^.oN
    0x4c, 0xf3, 0x8e, 0xa2, 0xd0, 0xd9, 0xcb, 0x01,     // L.......
    0xbc, 0x8c, 0x14, 0xd5, 0x08, 0xfc, 0x18, 0x08,     // ........
    0xc1, 0x65, 0x83, 0x3f, 0x0e, 0xa4, 0x17, 0x1c,     // .e.?....
    0x6e, 0x45, 0x0a, 0xef, 0x1d, 0x40, 0xc4, 0x7b,     // nE...@.{
    0x6a, 0x7e, 0x5d, 0xa6, 0xde, 0x97, 0x22, 0x7b,     // j~]..."{
    0x67, 0xbf, 0xc0, 0xa2, 0x83, 0x39, 0xb6, 0xf6,     // g....9..
    0x15, 0x16, 0xc6, 0x6f, 0x09, 0x61, 0xb1, 0x02,     // ...o.a..
    0x03, 0x01, 0x00, 0x01, 0xa3, 0x4c, 0x30, 0x4a,     // .....L0J
    0x30, 0x48, 0x06, 0x03, 0x55, 0x1d, 0x01, 0x04,     // 0H..U...
    0x41, 0x30, 0x3f, 0x80, 0x10, 0x0d, 0x27, 0x29,     // A0?...')
    0xe4, 0x05, 0x2a, 0x97, 0xb4, 0x77, 0x58, 0x35,     // ..*..wX5
    0x47, 0x93, 0x2d, 0x06, 0xb8, 0xa1, 0x1f, 0x30,     // G.-....0
    0x1d, 0x31, 0x1b, 0x30, 0x19, 0x06, 0x03, 0x55,     // .1.0...U
    0x04, 0x03, 0x13, 0x12, 0x52, 0x6f, 0x6f, 0x74,     // ....Root
    0x20, 0x53, 0x47, 0x43, 0x20, 0x41, 0x75, 0x74,     //  SGC Aut
    0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x82, 0x0a,     // hority..
    0x20, 0x9d, 0x11, 0xd1, 0x0e, 0x7f, 0x7b, 0x85,     //  .....{.
    0x74, 0x80, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86,     // t.0...*.
    0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x04, 0x05,     // H.......
    0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x2b, 0x02,     // ......+.
    0x2b, 0x37, 0x66, 0xa5, 0xd1, 0x8c, 0x3e, 0x20,     // +7f...>
    0x08, 0x1a, 0x0c, 0xb7, 0xf5, 0x63, 0xcb, 0xc6,     // .....c..
    0xdd, 0x9b, 0x62, 0x52, 0x32, 0xbc, 0x33, 0x74,     // ..bR2.3t
    0x7a, 0xde, 0xb0, 0x80, 0x05, 0xfa, 0xe5, 0xb5,     // z.......
    0xe4, 0xf7, 0xf1, 0xd7, 0xa0, 0x95, 0x5c, 0x6c,     // .......l
    0x05, 0x9b, 0x2f, 0x03, 0x4b, 0xb7, 0x8a, 0x95,     // ../.K...
    0x0e, 0xb0, 0x06, 0x80, 0xa0, 0x2a, 0x1b, 0xa4,     // .....*..
    0x09, 0x58, 0xbd, 0x87, 0xd4, 0x38, 0x44, 0xb4,     // .X...8D.
    0x71, 0x7b, 0xfb, 0x74, 0xa2, 0x89, 0x48, 0xe6,     // q{.t..H.
    0x5f, 0xab, 0x9a, 0xa4, 0x0a, 0x38, 0xcc, 0x57,     // _....8.W
    0xa1, 0x14, 0x2c, 0x5c, 0xee, 0xc2, 0x13, 0x81,     // ..,.....
    0x00, 0xc3, 0x2d, 0xb1, 0x70, 0xde, 0x9f, 0xb1,     // ..-.p...
    0x70, 0x43, 0x7e, 0x22, 0xa0, 0x77, 0x96, 0xc8,     // pC~".w..
    0xdf, 0x99, 0xdc, 0xa6, 0x4e, 0xb3, 0xb5, 0x74,     // ....N..t
    0x34, 0x13, 0x12, 0x24, 0xa2, 0x6b, 0x95, 0x80,     // 4..$.k..
    0xcf, 0xaa, 0x4a, 0x68, 0xb1, 0x77, 0x27, 0x98,     // ..Jh.w'.
    0xef, 0xaa, 0x62, 0xd3, 0x22, 0x81, 0x33, 0x2b,     // ..b.".3+
    0x12, 0x50, 0xef, 0x16, 0x86, 0xe6, 0x9a, 0x5a,     // .P.....Z
    0x73, 0x89, 0x6d, 0x83, 0xf2, 0x08, 0xa3, 0x13,     // s.m.....
    0xab, 0x05, 0xd5, 0x6e, 0x68, 0xf6, 0x90, 0xa4,     // ...nh...
    0x4a, 0x9f, 0x7c, 0x4c, 0x5d, 0x8f, 0x58, 0xf3,     // J.|L].X.
    0x11, 0x4c, 0xc7, 0x08, 0x51, 0xea, 0x76, 0xd1,     // .L..Q.v.
    0xb5, 0x55, 0x32, 0x3f, 0xff, 0x67, 0xef, 0x35,     // .U2?.g.5
    0x8c, 0x89, 0xd3, 0xc6, 0x75, 0x15, 0x68, 0x9f,     // ....u.h.
    0x67, 0x46, 0x9c, 0x94, 0x41, 0xf5, 0x76, 0x51,     // gF..A.vQ
    0x86, 0xac, 0x91, 0x75, 0xec, 0xb6, 0xf7, 0x00,     // ...u....
    0x40, 0x5b, 0xfe, 0x61, 0xd8, 0x33, 0x2d, 0x37,     // @[.a.3-7
    0x65, 0x8b, 0x94, 0xd9, 0x97, 0x21, 0x15, 0x2c,     // e....!.,
    0x13, 0x49, 0xff, 0xde, 0xb7, 0x83, 0xd9, 0xae,     // .I......
    0xc4, 0xce, 0x24, 0xb2, 0x50, 0xdf, 0x75, 0x14,     // ..$.P.u.
    0x12, 0x8c, 0x46, 0xa4, 0xac, 0xef, 0x4c, 0x72,     // ..F...Lr
    0x00, 0x00, 0xe1, 0x4c, 0x8e, 0xee };               // ...L..

// Versign Class 3 SGC Root
static CONST BYTE VSCLASS3ROOT[] =
  { 0x30, 0x82, 0x02, 0x31, 0x30, 0x82, 0x01, 0x9a,
    0x02, 0x05, 0x02, 0xa1, 0x00, 0x00, 0x01, 0x30,
    0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
    0x0d, 0x01, 0x01, 0x02, 0x05, 0x00, 0x30, 0x5f,
    0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04,
    0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x17, 0x30,
    0x15, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x0e,
    0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6e,
    0x2c, 0x20, 0x49, 0x6e, 0x63, 0x2e, 0x31, 0x37,
    0x30, 0x35, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13,
    0x2e, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x20, 0x33,
    0x20, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20,
    0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x20,
    0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x41, 0x75,
    0x74, 0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x30,
    0x1e, 0x17, 0x0d, 0x39, 0x36, 0x30, 0x31, 0x32,
    0x39, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5a,
    0x17, 0x0d, 0x39, 0x39, 0x31, 0x32, 0x33, 0x31,
    0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5a, 0x30,
    0x5f, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,
    0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x17,
    0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13,
    0x0e, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67,
    0x6e, 0x2c, 0x20, 0x49, 0x6e, 0x63, 0x2e, 0x31,
    0x37, 0x30, 0x35, 0x06, 0x03, 0x55, 0x04, 0x0b,
    0x13, 0x2e, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x20,
    0x33, 0x20, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63,
    0x20, 0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79,
    0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69,
    0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x41,
    0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x74, 0x79,
    0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09, 0x2a,
    0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01,
    0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30, 0x81,
    0x89, 0x02, 0x81, 0x81, 0x00, 0xc9, 0x5c, 0x59,
    0x9e, 0xf2, 0x1b, 0x8a, 0x01, 0x14, 0xb4, 0x10,
    0xdf, 0x04, 0x40, 0xdb, 0xe3, 0x57, 0xaf, 0x6a,
    0x45, 0x40, 0x8f, 0x84, 0x0c, 0x0b, 0xd1, 0x33,
    0xd9, 0xd9, 0x11, 0xcf, 0xee, 0x02, 0x58, 0x1f,
    0x25, 0xf7, 0x2a, 0xa8, 0x44, 0x05, 0xaa, 0xec,
    0x03, 0x1f, 0x78, 0x7f, 0x9e, 0x93, 0xb9, 0x9a,
    0x00, 0xaa, 0x23, 0x7d, 0xd6, 0xac, 0x85, 0xa2,
    0x63, 0x45, 0xc7, 0x72, 0x27, 0xcc, 0xf4, 0x4c,
    0xc6, 0x75, 0x71, 0xd2, 0x39, 0xef, 0x4f, 0x42,
    0xf0, 0x75, 0xdf, 0x0a, 0x90, 0xc6, 0x8e, 0x20,
    0x6f, 0x98, 0x0f, 0xf8, 0xac, 0x23, 0x5f, 0x70,
    0x29, 0x36, 0xa4, 0xc9, 0x86, 0xe7, 0xb1, 0x9a,
    0x20, 0xcb, 0x53, 0xa5, 0x85, 0xe7, 0x3d, 0xbe,
    0x7d, 0x9a, 0xfe, 0x24, 0x45, 0x33, 0xdc, 0x76,
    0x15, 0xed, 0x0f, 0xa2, 0x71, 0x64, 0x4c, 0x65,
    0x2e, 0x81, 0x68, 0x45, 0xa7, 0x02, 0x03, 0x01,
    0x00, 0x01, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86,
    0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x02, 0x05,
    0x00, 0x03, 0x81, 0x81, 0x00, 0x75, 0x66, 0x6c,
    0x3e, 0xd1, 0xcd, 0x81, 0xdb, 0xb5, 0xf8, 0x2f,
    0x36, 0x51, 0xb6, 0xf7, 0x42, 0xbc, 0xcd, 0x42,
    0xaf, 0xdc, 0x0e, 0xfa, 0x15, 0x6c, 0xf8, 0x67,
    0x93, 0x57, 0x3a, 0xeb, 0xb6, 0x92, 0xe8, 0xb6,
    0x01, 0xca, 0x8c, 0xb7, 0x8e, 0x43, 0xb4, 0x49,
    0x65, 0xf9, 0x3e, 0xee, 0xbd, 0x75, 0x46, 0x2e,
    0xc9, 0xfc, 0x25, 0x5d, 0xa8, 0xc7, 0x2f, 0x8b,
    0x9b, 0x8f, 0x68, 0xcf, 0xb4, 0x9c, 0x97, 0x18,
    0xc0, 0x4d, 0xef, 0x1f, 0xd9, 0xaf, 0x82, 0xb3,
    0xe6, 0x64, 0xb8, 0x84, 0x5c, 0x8a, 0x9a, 0x07,
    0x52, 0x43, 0x61, 0xfb, 0x74, 0x9e, 0x5b, 0x3a,
    0x36, 0xfc, 0x4c, 0xb2, 0xfc, 0x1a, 0x3f, 0x15,
    0x2e, 0xa5, 0x5b, 0x3c, 0x1b, 0x90, 0xec, 0x88,
    0x29, 0xe4, 0x59, 0x16, 0xf9, 0xce, 0x07, 0xad,
    0xec, 0xe9, 0xdd, 0xda, 0xd2, 0x31, 0x8a, 0x4f,
    0xd6, 0xd8, 0xef, 0x17, 0x8d };

// SGC Test Root
#ifdef SGC_TEST_KEY
static CONST BYTE TestSGCRoot[] =
  { 0x30, 0x82, 0x01, 0xda, 0x30, 0x82, 0x01, 0x84,     // 0...0...
    0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x46,     // .......F
    0xeb, 0x72, 0x4f, 0xc0, 0x00, 0x78, 0xab, 0x11,     // .rO..x..
    0xd2, 0x84, 0xb0, 0x35, 0xb8, 0xe0, 0xb1, 0x30,     // ...5...0
    0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,     // ...*.H..
    0x0d, 0x01, 0x01, 0x04, 0x05, 0x00, 0x30, 0x26,     // ......0&
    0x31, 0x24, 0x30, 0x22, 0x06, 0x03, 0x55, 0x04,     // 1$0"..U.
    0x03, 0x13, 0x1b, 0x53, 0x63, 0x68, 0x61, 0x6e,     // ...Schan
    0x6e, 0x65, 0x6c, 0x20, 0x54, 0x65, 0x73, 0x74,     // nel Test
    0x20, 0x53, 0x47, 0x43, 0x20, 0x41, 0x75, 0x74,     //  SGC Aut
    0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x30, 0x1e,     // hority0.
    0x17, 0x0d, 0x39, 0x38, 0x31, 0x31, 0x32, 0x35,     // ..981125
    0x32, 0x31, 0x34, 0x35, 0x35, 0x34, 0x5a, 0x17,     // 214554Z.
    0x0d, 0x33, 0x39, 0x31, 0x32, 0x33, 0x31, 0x32,     // .3912312
    0x33, 0x35, 0x39, 0x35, 0x39, 0x5a, 0x30, 0x26,     // 35959Z0&
    0x31, 0x24, 0x30, 0x22, 0x06, 0x03, 0x55, 0x04,     // 1$0"..U.
    0x03, 0x13, 0x1b, 0x53, 0x63, 0x68, 0x61, 0x6e,     // ...Schan
    0x6e, 0x65, 0x6c, 0x20, 0x54, 0x65, 0x73, 0x74,     // nel Test
    0x20, 0x53, 0x47, 0x43, 0x20, 0x41, 0x75, 0x74,     //  SGC Aut
    0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x30, 0x5c,     // hority0.
    0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,     // 0...*.H.
    0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03,     // ........
    0x4b, 0x00, 0x30, 0x48, 0x02, 0x41, 0x00, 0xd1,     // K.0H.A..
    0x95, 0x8e, 0x14, 0xc9, 0x8b, 0x28, 0x00, 0xd4,     // .....(..
    0xed, 0x40, 0xb5, 0xd4, 0xec, 0x1f, 0x67, 0xb1,     // .@....g.
    0xa2, 0xb3, 0x18, 0xca, 0x6b, 0x48, 0x6c, 0x54,     // ....kHlT
    0xaf, 0xc4, 0x70, 0x3c, 0x6e, 0xee, 0x15, 0xba,     // ..p<n...
    0x4b, 0xf7, 0x40, 0x93, 0xd3, 0x35, 0x1d, 0x17,     // K.@..5..
    0x6c, 0xe8, 0x1d, 0x62, 0xec, 0x74, 0x96, 0x48,     // l..b.t.H
    0x4f, 0x1e, 0xcf, 0xf0, 0x54, 0x2b, 0x30, 0x0b,     // O...T+0.
    0x66, 0x3a, 0x83, 0x1c, 0x32, 0xda, 0x3d, 0x02,     // f:..2.=.
    0x03, 0x01, 0x00, 0x01, 0xa3, 0x81, 0x8d, 0x30,     // .......0
    0x81, 0x8a, 0x30, 0x0d, 0x06, 0x03, 0x55, 0x1d,     // ..0...U.
    0x0a, 0x04, 0x06, 0x30, 0x04, 0x03, 0x02, 0x07,     // ...0....
    0x80, 0x30, 0x20, 0x06, 0x03, 0x55, 0x1d, 0x25,     // .0 ..U.%
    0x04, 0x19, 0x30, 0x17, 0x06, 0x0a, 0x2b, 0x06,     // ..0...+.
    0x01, 0x04, 0x01, 0x82, 0x37, 0x0a, 0x03, 0x03,     // ....7...
    0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x86, 0xf8,     // ..`.H...
    0x42, 0x04, 0x01, 0x30, 0x57, 0x06, 0x03, 0x55,     // B..0W..U
    0x1d, 0x01, 0x04, 0x50, 0x30, 0x4e, 0x80, 0x10,     // ...P0N..
    0x35, 0x2f, 0x90, 0xa8, 0x13, 0xd6, 0x82, 0x32,     // 5......2
    0x85, 0x1a, 0x5d, 0x0f, 0xdc, 0x83, 0xe3, 0x28,     // ..]....(
    0xa1, 0x28, 0x30, 0x26, 0x31, 0x24, 0x30, 0x22,     // .(0&1$0"
    0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1b, 0x53,     // ..U....S
    0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x20,     // channel
    0x54, 0x65, 0x73, 0x74, 0x20, 0x53, 0x47, 0x43,     // Test SGC
    0x20, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69,     //  Authori
    0x74, 0x79, 0x82, 0x10, 0x46, 0xeb, 0x72, 0x4f,     // ty..F.rO
    0xc0, 0x00, 0x78, 0xab, 0x11, 0xd2, 0x84, 0xb0,     // ..x.....
    0x35, 0xb8, 0xe0, 0xb1, 0x30, 0x0d, 0x06, 0x09,     // 5...0...
    0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,     // *.H.....
    0x04, 0x05, 0x00, 0x03, 0x41, 0x00, 0x65, 0x35,     // ....A.e5
    0x80, 0xaf, 0xa3, 0xba, 0x5d, 0x13, 0xcd, 0x86,     // ....]...
    0xad, 0xda, 0x06, 0xb6, 0xb3, 0x51, 0xf4, 0x71,     // .....Q.q
    0x4a, 0x0b, 0xd2, 0xc1, 0x91, 0x13, 0xc3, 0x0c,     // J.......
    0xd7, 0xb7, 0x9f, 0xa6, 0x3c, 0x04, 0xfa, 0xb7,     // ....<...
    0x97, 0x94, 0x64, 0xf0, 0x5b, 0xab, 0x65, 0x3b,     // ..d.[.e;
    0x88, 0x95, 0x59, 0x4c, 0x18, 0x11, 0xc4, 0xac,     // ..YL....
    0x5c, 0x6e, 0x31, 0xf0, 0xdd, 0x74, 0xc1, 0x55,     // .n1..t.U
    0x7e, 0x7f, 0x66, 0xf4, 0x8a, 0x57 };               // ~.f..W
#endif // SGC_TEST_KEY


typedef struct SGC_ROOT
{
    CONST BYTE *    pbCert;
    DWORD           cbCert;
    PCCERT_CONTEXT  pCertContext;
} SGC_ROOT, *PSGC_ROOT;


static SGC_ROOT SGCRoots[] = {
    { GenevaSGCRoot,    sizeof(GenevaSGCRoot),  NULL },
    { VSCLASS3ROOT,     sizeof(VSCLASS3ROOT),   NULL },
#ifdef SGC_TEST_KEY
    { TestSGCRoot,      sizeof(TestSGCRoot),    NULL }
#endif // SGC_TEST_KEY
};

static CONST DWORD SGCRootCount = sizeof(SGCRoots) / sizeof(SGC_ROOT);

static CONST LPCSTR rgSGCExtensions[]
    = { szOID_SGC_NETSCAPE,
        szOID_SERVER_GATED_CRYPTO };

static CONST CERT_ENHKEY_USAGE SGCExtensions
    = { sizeof(rgSGCExtensions)/sizeof(LPSTR),
        (LPSTR *)rgSGCExtensions };


//
// Load root certs
//

DWORD
LoadSGCRoots(
    IN CRITICAL_SECTION *pCritSec)  // must be initialized
{
    DWORD   dwReturn = ERROR_INTERNAL_ERROR;
    BOOL    fInCritSec = FALSE;
    BOOL    fLoadRoots = FALSE;
    DWORD   i;

    // check if the Roots are already loaded
    for (i = 0; i < SGCRootCount; i++)
    {
        if (SGCRoots[i].pCertContext == NULL)
        {
            fLoadRoots = TRUE;
            break;
        }
    }
    if (!fLoadRoots)
    {
        dwReturn = ERROR_SUCCESS;
        goto ErrorExit;
    }

    // wrap with a try since there is a critical sections in here
    __try
    {
        // take the critical section
        EnterCriticalSection(pCritSec);
        fInCritSec = TRUE;

        for (i = 0; i < SGCRootCount; i++)
        {
            if (SGCRoots[i].pCertContext == NULL)
            {

                SGCRoots[i].pCertContext = CertCreateCertificateContext(
                                                X509_ASN_ENCODING,
                                                SGCRoots[i].pbCert,
                                                SGCRoots[i].cbCert);
                if (NULL == SGCRoots[i].pCertContext)
                {
                    dwReturn = GetLastError();
                    goto ErrorExit;
                }
            }
        }

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        // ?BUGBUG? Could be resource exhaustion
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (fInCritSec)
        LeaveCriticalSection(pCritSec);
    return dwReturn;
}


//
// delete the public key values
//

void
SGCDeletePubKeyValues(
    IN OUT BYTE **ppbKeyMod,
    IN OUT DWORD *pcbKeyMod,
    IN OUT DWORD *pdwKeyExpo)
{
    if (*ppbKeyMod)
        SGCFree(*ppbKeyMod);
    *ppbKeyMod = NULL;
    *pcbKeyMod = 0;
    *pdwKeyExpo = 0;
}


//
// get the public key form the cert context and assign it to the
// passed in parameters
//

DWORD
SGCAssignPubKey(
    IN PCCERT_CONTEXT pCertContext,
    IN OUT BYTE **ppbKeyMod,
    IN OUT DWORD *pcbKeyMod,
    IN OUT DWORD *pdwKeyExpo)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    BLOBHEADER  *pBlob = NULL;
    DWORD       cbBlob = 0;
    RSAPUBKEY   *pRSAPubKey;
    BYTE        *pb;

    // decode the public key from the cert into a PUBLICKEYBLOB
    if (!CryptDecodeObject(X509_ASN_ENCODING,
                           RSA_CSP_PUBLICKEYBLOB,
                           pCertContext->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                           pCertContext->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData,
                           0,
                           NULL,
                           &cbBlob))
    {
        dwReturn = (DWORD)NTE_BAD_DATA; // ?BUGBUG? Always?
        goto ErrorExit;
    }

    pBlob = (BLOBHEADER*)SGCAlloc(cbBlob);
    if (NULL == pBlob)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    if (!CryptDecodeObject(X509_ASN_ENCODING,
                           RSA_CSP_PUBLICKEYBLOB,
                           pCertContext->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                           pCertContext->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData,
                           0,
                           pBlob,
                           &cbBlob))
    {
        dwReturn = (DWORD)NTE_BAD_DATA; // ?BUGBUG? Always?
        goto ErrorExit;
    }

    pRSAPubKey = (RSAPUBKEY*)((BYTE*)pBlob + sizeof(BLOBHEADER));

    // delete any old public key info
    SGCDeletePubKeyValues(ppbKeyMod, pcbKeyMod, pdwKeyExpo);

    // assign public key values
    *pdwKeyExpo = pRSAPubKey->pubexp;
    *pcbKeyMod = pRSAPubKey->bitlen / 8;
    *ppbKeyMod = (BYTE*)SGCAlloc(*pcbKeyMod);
    if (NULL == *ppbKeyMod)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    pb = (BYTE*)pRSAPubKey + sizeof(RSAPUBKEY);
    memcpy(*ppbKeyMod, pb, *pcbKeyMod);

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pBlob)
        SGCFree(pBlob);
    return dwReturn;
}


//
// check if the passed in public key matches the one in the cert
//

static DWORD
SamePublicKey(
    IN PCCERT_CONTEXT pCertContext,
    IN BYTE *pbExchKeyMod,
    IN DWORD cbExchKeyMod,
    IN DWORD dwExchKeyExpo)
{
    DWORD       dwReturn = ERROR_INTERNAL_ERROR;
    BLOBHEADER  *pBlob = NULL;
    DWORD       cbBlob = 0;
    RSAPUBKEY   *pRSAPubKey;
    BYTE        *pb;

    // decode the public key from the cert into a PUBLICKEYBLOB
    if (!CryptDecodeObject(X509_ASN_ENCODING,
                           RSA_CSP_PUBLICKEYBLOB,
                           pCertContext->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                           pCertContext->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData,
                           0,
                           NULL,
                           &cbBlob))
    {
        dwReturn = (DWORD)NTE_BAD_DATA; // ?BUGBUG? Always?
        goto ErrorExit;
    }

    pBlob = (BLOBHEADER*)SGCAlloc(cbBlob);
    if (NULL == pBlob)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    if (!CryptDecodeObject(X509_ASN_ENCODING,
                           RSA_CSP_PUBLICKEYBLOB,
                           pCertContext->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                           pCertContext->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData,
                           0,
                           pBlob,
                           &cbBlob))
    {
        dwReturn = (DWORD)NTE_BAD_DATA; // ?BUGBUG? Always?
        goto ErrorExit;
    }

    pRSAPubKey = (RSAPUBKEY*)((BYTE*)pBlob + sizeof(BLOBHEADER));

    // check the length of the modulus and the exponent
    if (((pRSAPubKey->bitlen / 8) != cbExchKeyMod) ||
        (pRSAPubKey->pubexp != dwExchKeyExpo))
    {
        dwReturn = (DWORD)NTE_BAD_DATA;
        goto ErrorExit;
    }

    // check that the modulus values match
    pb = (BYTE*)pRSAPubKey + sizeof(RSAPUBKEY);
    if (0 != memcmp(pbExchKeyMod, pb, cbExchKeyMod))
    {
        dwReturn = (DWORD)NTE_BAD_DATA;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:
    if (pBlob)
        SGCFree(pBlob);
    return dwReturn;
}


static DWORD
ReadSgcExtensions(
    PCCERT_CONTEXT pCertContext)
{
    PCERT_EXTENSION pExt;
    PCTL_USAGE      pUsage = NULL;
    DWORD           cbUsage;
    DWORD           dwSGCFlags = 0;
    DWORD           i;

    pExt = CertFindExtension(szOID_ENHANCED_KEY_USAGE,
                             pCertContext->pCertInfo->cExtension,
                             pCertContext->pCertInfo->rgExtension);
    if (pExt == NULL)
        goto cleanup;

    if (!CryptDecodeObject(X509_ASN_ENCODING,
                           X509_ENHANCED_KEY_USAGE,
                           pExt->Value.pbData,
                           pExt->Value.cbData,
                           0,
                           NULL,
                           &cbUsage))
    {
        goto cleanup;
    }

    pUsage = (PCTL_USAGE)SGCAlloc(cbUsage);
    if (pUsage == NULL)
        goto cleanup;

    if (!CryptDecodeObject(X509_ASN_ENCODING,
                           X509_ENHANCED_KEY_USAGE,
                           pExt->Value.pbData,
                           pExt->Value.cbData,
                           0,
                           pUsage,
                           &cbUsage))
    {
        goto cleanup;
    }

    for (i = 0; i < pUsage->cUsageIdentifier; i++)
    {
        if (0 == strcmp(pUsage->rgpszUsageIdentifier[i],
                        szOID_SGC_NETSCAPE))
        {
            dwSGCFlags |= CRYPT_SGC;
        }
        else if (0 == strcmp(pUsage->rgpszUsageIdentifier[i],
                             szOID_SERVER_GATED_CRYPTO))
        {
            dwSGCFlags |= CRYPT_FASTSGC | CRYPT_SGC;
        }
    }

cleanup:
    if (pUsage)
        SGCFree(pUsage);
    return dwSGCFlags;
}


//+---------------------------------------------------------------------------
//
//  Function:   FindBridgeCertificate
//
//  Synopsis:   Search the specified certificate store for a valid SGC
//              bridge certificate.
//
//  Arguments:  [hCAStore]      --  Certificate store to search. This is
//                                  typically the CA store.
//
//              [pChainContext] --  Certificate chain for which we are finding
//                                  a bridge certificate. The bridge cert
//                                  may branch off of any certificate in the
//                                  chain.
//
//              [pRootContext]  --  Handle to baked-in SGC root certificate
//                                  (typically Geneva).
//
//  History:    11-16-98   jbanes   Created
//
//  Notes:      An SGC bridge certificate is defined as a certificate with a
//              SUBJECT equal to the ISSUER in one of the 'pChainContext'
//              certificates. To be valid, the bridge certificate must
//              contain at least one SGC EKU and it must chain up to a
//              baked-in SGC root certificate.
//
//  Returns:    TRUE if a valid SGC bridge cert was found, and FALSE
//              otherwise.
//
//----------------------------------------------------------------------------

static BOOL
FindBridgeCertificate(
    IN HCERTSTORE           hCAStore,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCCERT_CONTEXT       pRootContext)
{
    PCERT_SIMPLE_CHAIN      pSimpleChain;
    PCCERT_CONTEXT          pCurrent = NULL;
    PCCERT_CONTEXT          pCurrentCA = NULL;
    PCCERT_CHAIN_CONTEXT    pCAChainContext = NULL;
    CERT_CHAIN_PARA         ChainPara;
    CERT_TRUST_STATUS       TrustStatus;
    BOOL                    fFound;
    DWORD                   i;
    BOOL                    fRet = FALSE;
    DWORD                   dwFlags;

    //
    // Enumerate all of the certificates in the CA store that contain
    // one of the SGC extensions.
    //

    pCurrent = NULL;

    for (;;)
    {
        // Find an SGC intermediate certificate.
        pCurrentCA = CertFindCertificateInStore(
                           hCAStore,
                           X509_ASN_ENCODING,
                           CERT_FIND_OR_ENHKEY_USAGE_FLAG,
                           CERT_COMPARE_ENHKEY_USAGE,
                           &SGCExtensions,
                           pCurrentCA);
        if (pCurrentCA == NULL)
            break;


        //
        // Is this CA certificate a bridge for any of the certificates in the
        // passed in certificate chain?
        //

        fFound = FALSE;
        pSimpleChain = pChainContext->rgpChain[0];

        for (i = 0; i < pSimpleChain->cElement; i++)
        {
            pCurrent = pSimpleChain->rgpElement[i]->pCertContext;

            if (ReadSgcExtensions(pCurrent) == 0)
            {
                // This certificate doesn't contain any SGC certificate
                // extensions, so skip the rest of this chain.
                break;
            }

            if (CertCompareCertificateName(X509_ASN_ENCODING,
                                           &pCurrentCA->pCertInfo->Subject,
                                           &pCurrent->pCertInfo->Issuer))
            {
                // The names match. Now check the signature.
                dwFlags = SGC_VERIFICATION_FLAGS;

                if (!CertVerifySubjectCertificateContext(pCurrent,
                                                         pCurrentCA,
                                                         &dwFlags))
                {
                    // Error checking signature.
                    continue;
                }
                if (dwFlags & SGC_VERIFICATION_FLAGS)
                {
                    // Signature did not verify or certificate expired.
                    continue;
                }

                fFound = TRUE;
                break;
            }
        }
        if (!fFound)
            continue;


        //
        // Does this CA certificate chain up to Geneva?
        //

        ZeroMemory(&ChainPara, sizeof(ChainPara));
        ChainPara.cbSize = sizeof(ChainPara);

        if (!CertGetCertificateChain(NULL,
                                     pCurrentCA,
                                     NULL,
                                     hCAStore,
                                     &ChainPara,
                                     0,
                                     NULL,
                                     &pCAChainContext))
        {
            // Error building chain.
            continue;
        }

        pSimpleChain = pCAChainContext->rgpChain[0];

        for (i = 0; i < pSimpleChain->cElement; i++)
        {
            pCurrent = pSimpleChain->rgpElement[i]->pCertContext;

            // Determine if certificate is signed correctly.
            TrustStatus = pSimpleChain->rgpElement[i]->TrustStatus;
            if (0 != (TrustStatus.dwErrorStatus
                      & CERT_TRUST_IS_NOT_SIGNATURE_VALID))
            {
                break;
            }

            // Is issuer Geneva?
            if (CertCompareCertificateName(pCurrent->dwCertEncodingType,
                                           &pCurrent->pCertInfo->Issuer,
                                           &pRootContext->pCertInfo->Subject))
            {
                // Verify the signature of the current certificate using the
                // validated root certificate from the schannel resource.
                dwFlags = SGC_VERIFICATION_FLAGS;
                if (!CertVerifySubjectCertificateContext(pCurrent,
                                                         pRootContext,
                                                         &dwFlags))
                {
                    break;
                }
                if (dwFlags & SGC_VERIFICATION_FLAGS)
                    break;

                fRet = TRUE;
                goto ErrorExit;
            }
        }
    }

ErrorExit:
    if (pCurrentCA)
        CertFreeCertificateContext(pCurrentCA);
    if (pCAChainContext)
        CertFreeCertificateChain(pCAChainContext);
    return fRet;
}


//
// check if the context may be SGC enabled
//

DWORD
SPQueryCFLevel(
    IN PCCERT_CONTEXT pCertContext,
    IN BYTE *pbExchKeyMod,
    IN DWORD cbExchKeyMod,
    IN DWORD dwExchKeyExpo,
    OUT DWORD *pdwSGCFlags)
{
    DWORD                   dwReturn = ERROR_INTERNAL_ERROR;
    DWORD                   i, j;

    PCCERT_CHAIN_CONTEXT    pChainContext = NULL;
    CERT_CHAIN_PARA         ChainPara;
    PCERT_SIMPLE_CHAIN      pSimpleChain;
    CERT_TRUST_STATUS       TrustStatus;
    HCERTSTORE              hCAStore = NULL;

    PCCERT_CONTEXT          pCurrent = NULL;
    PCCERT_CONTEXT          pIssuer = NULL;
    DWORD                   dwFlags;
    DWORD                   dwSgcFlags;
    DWORD                   dwSts;


    *pdwSGCFlags = 0;


    //
    // check if the passed in public key matches the one in the cert
    //

    if (pbExchKeyMod)
    {
        dwSts = SamePublicKey(pCertContext, pbExchKeyMod,
                              cbExchKeyMod, dwExchKeyExpo);
        if (ERROR_SUCCESS != dwSts)
        {
            dwReturn = dwSts;
            goto ErrorExit;
        }
    }


    //
    // Does the leaf certificate contain any SGC extensions?
    //

    dwSgcFlags = ReadSgcExtensions(pCertContext);

    if (dwSgcFlags == 0)
    {
        // No SGC extensions found.
        dwReturn = ERROR_SUCCESS;
        goto ErrorExit;
    }


    //
    // Build a certificate chain.
    //

    ZeroMemory(&ChainPara, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);

    *pdwSGCFlags = 0;

    if (!CertGetCertificateChain(
                                NULL,
                                pCertContext,
                                NULL,
                                pCertContext->hCertStore,
                                &ChainPara,
                                0,
                                NULL,
                                &pChainContext))
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }


    //
    // Does the leaf chain directly up to the Geneva root?
    //

    pSimpleChain = pChainContext->rgpChain[0];
    for (i = 0; i < pSimpleChain->cElement; i++)
    {
        pCurrent = pSimpleChain->rgpElement[i]->pCertContext;

        if (ReadSgcExtensions(pCurrent) == 0)
        {
            // This certificate doesn't contain any SGC certificate
            // extensions, so skip the rest of this chain.
            break;
        }

        TrustStatus = pSimpleChain->rgpElement[i]->TrustStatus;
        if (0 != (TrustStatus.dwErrorStatus
                  & CERT_TRUST_IS_NOT_SIGNATURE_VALID))
        {
            // Certificate is not signed correctly.
            dwReturn = (DWORD)NTE_BAD_SIGNATURE;
            goto ErrorExit;
        }

        // Is Geneva issuer of "pCurrent"?
        for (j = 0; j < SGCRootCount; j++)
        {
            dwFlags = SGC_VERIFICATION_FLAGS;
            if (!CertVerifySubjectCertificateContext(
                                                    pCurrent,
                                                    SGCRoots[j].pCertContext,
                                                    &dwFlags))
            {
                continue;
            }

            if (dwFlags & SGC_VERIFICATION_FLAGS)
            {
                continue;
            }

            // We made it, so set the SGC flags as appropriate.
            *pdwSGCFlags |= dwSgcFlags;
            dwReturn = ERROR_SUCCESS;
            goto ErrorExit;
        }
    }


    //
    // Search for bridge certificate.
    //

    hCAStore = CertOpenSystemStore(0, "CA");
    if (NULL == hCAStore)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    for (i = 0; i < SGCRootCount; i++)
    {
        if (SGCRoots[i].pCertContext != NULL)
        {
            if (FindBridgeCertificate(hCAStore,
                                      pChainContext,
                                      SGCRoots[i].pCertContext))
            {
                // We made it, so set the SGC flags as appropriate.
                *pdwSGCFlags |= dwSgcFlags;
                dwReturn = ERROR_SUCCESS;
                goto ErrorExit;
            }
        }
    }

    dwReturn = (DWORD)NTE_FAIL;

ErrorExit:
    if (pIssuer)
        CertFreeCertificateContext(pIssuer);
    if (pChainContext)
        CertFreeCertificateChain(pChainContext);
    if (hCAStore)
        CertCloseStore(hCAStore, 0);
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\test\offload\offload.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : csp.c                                                  //
//  DESCRIPTION   : Crypto API interface                                   //
//					Global Stuff for CSP
//  AUTHOR        : Amit Kapoor											   //
/////////////////////////////////////////////////////////////////////////////

#undef UNICODE
#include <windows.h>
#include <fxupbn.h>

#ifdef __cplusplus
extern "C" {
#endif


// Needed for DLL
BOOLEAN DllInitialize (IN PVOID hmod,IN ULONG Reason,IN PCONTEXT Context)
{
    LoadLibrary("offload.dll");
    return( TRUE );
}

BOOL WINAPI OffloadModExpo(
                           IN BYTE *pbBase,
                           IN BYTE *pbExpo,
                           IN DWORD cbExpo,
                           IN BYTE *pbMod,
                           IN DWORD cbMod,
                           IN BYTE *pbResult,
                           IN void *pReserved,
                           IN DWORD dwFlags
                           )
{
    mp_modulus_t    *pModularMod = NULL;
    digit_t         *pbModularBase = NULL;
    digit_t         *pbModularResult = NULL;
    DWORD           dwModularLen = (cbMod + (RADIX_BYTES - 1)) / RADIX_BYTES; // dwLen is length in bytes
    BYTE            *pbTmpExpo = NULL;
    BOOL            fAlloc = FALSE;
    BOOL            fRet = FALSE;

    if (cbExpo < cbMod)
    {
        if (NULL == (pbTmpExpo = (BYTE*)LocalAlloc(LMEM_ZEROINIT, dwModularLen * RADIX_BYTES)))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }
        fAlloc = TRUE;
        memcpy(pbTmpExpo, pbExpo, cbExpo);
    }
    else
    {
        pbTmpExpo = pbExpo;
    }

    if (NULL == (pModularMod = (mp_modulus_t*)LocalAlloc(LMEM_ZEROINIT,
                                                       sizeof(mp_modulus_t))))
    {
        goto Ret;
    }
    if (NULL == (pbModularBase = (digit_t*)LocalAlloc(LMEM_ZEROINIT,
                                                MP_LONGEST * sizeof(digit_t))))
    {
        goto Ret;
    }
    if (NULL == (pbModularResult = (digit_t*)LocalAlloc(LMEM_ZEROINIT,
                                                MP_LONGEST * sizeof(digit_t))))
    {
        goto Ret;
    }

    // change values into modular form
    create_modulus((digit_tc*)pbMod, dwModularLen, FROM_RIGHT, pModularMod);
    to_modular((digit_tc*)pbBase, dwModularLen, pbModularBase, pModularMod);
    mod_exp(pbModularBase, (digit_tc*)pbTmpExpo, dwModularLen,
            pbModularResult, pModularMod);
    from_modular(pbModularResult, (digit_t*)pbResult, pModularMod);

    fRet = TRUE;
Ret:
    if (pModularMod)
        LocalFree(pModularMod);
    if (pbModularBase)
        LocalFree(pbModularBase);
    if (pbModularResult)
        LocalFree(pbModularResult);
    if (fAlloc && pbTmpExpo)
        LocalFree(pbTmpExpo);

    return fRet;
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\test\stress\strestst.c ===
// *****************************************************************************
//
//  Purpose : Multithreaded stress test 
//              
//      Created : arunm 03/20/96
//      Modified: dangriff 11/6/00
// 
// *****************************************************************************

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <wincrypt.h>
#include "strestst.h"
#include <pincache.h>

//  ===========================================================================
int Usage(void)
{
    printf("%s -c <CSP Index> [options]\n", APP_NAME) ;
    printf(" -?:                         This message\n") ;
    printf(" -n <N>:                     # of threads to create (Def: %d)\n", StressGetDefaultThreadCount());
    printf(" -t <N>:                     End test in N minutes (Def: never end)\n");
    printf(" -e:                         Ephemeral keys\n");
    printf(" -u:                         User-protected keys (cannot be used with -e)\n");
    printf(" -r:                         Run regression tests\n");
    printf(" -d:                         Delete all key containers\n");
    printf(" -a<Flags> <Container>:      Call CryptAcquireContext with Flags\n");

    printf("\nCryptAcquireContext Flags:\n");
    printf(" v - CRYPT_VERIFYCONTEXT (don't specify <Container>)\n");
    printf(" n - CRYPT_NEWKEYSET\n");
    printf(" l - CRYPT_MACHINE_KEYSET\n");
    printf(" d - CRYPT_DELETEKEYSET\n");
    printf(" q - CRYPT_SILENT\n");
    printf(" x - create a Key Exchange keyset\n");
    printf(" s - create a Signature keyset\n");
    printf(" u - request keyset to be User Protected\n");
    
    return 1;
}

//
// Function: StressGetDefaultThreadCount
// 
DWORD StressGetDefaultThreadCount(void)
{
    SYSTEM_INFO SystemInfo;

    ZeroMemory(&SystemInfo, sizeof(SystemInfo));
    GetSystemInfo(&SystemInfo);

    return 
        SystemInfo.dwNumberOfProcessors == 1 ? 
        STRESS_DEFAULT_THREAD_COUNT : 
        SystemInfo.dwNumberOfProcessors;
}

//
// Function: MyAlloc
//
LPVOID MyAlloc(SIZE_T dwBytes)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBytes);
}

//
// Function: MyFree
//
BOOL MyFree(LPVOID lpMem)
{
    return HeapFree(GetProcessHeap(), 0, lpMem);
}

//
// Function: PrintBytes
//
#define CROW 8
void PrintBytes(LPSTR pszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;
    CHAR rgsz[1024];

    printf("\n  %s, %d bytes ::\n", pszHdr, cbSize);

    while (cbSize > 0)
    {
        // Start every row with an extra space
        printf(" ");

        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i < cb; i++)
            printf(" %02x", pb[i]);
        for (i = cb; i < CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i < cb; i++)
        {
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                printf("%c", pb[i]);
            else
                printf(".");
        }
        printf("\n");
        pb += cb;
    }
}

//
// Function: UnalignedImportExportRegression
//
DWORD UnalignedImportExportRegression(PTHREAD_DATA pThreadData)
{
    DWORD dwError               = ERROR_SUCCESS;
    BYTE rgbKeyBuf[2000];
    DWORD cbKeyBuf              = sizeof(rgbKeyBuf);
    PBYTE pbKeyBuf              = NULL;
    HCRYPTKEY hKey              = 0;
    HCRYPTKEY hWrapKey          = 0;
    BOOL fSuccess               = FALSE;

    if (! CryptGenKey(
        pThreadData->hProv, CALG_RC2, 0, &hWrapKey))
    {
        printf("CryptGenKey CALG_RC2 ");
        goto Ret;
    }

    //
    // 1a) Exchange key pair PRIVATEKEYBLOB
    //

    // Unalign the output buffer
    pbKeyBuf = rgbKeyBuf + 1;
    cbKeyBuf = sizeof(rgbKeyBuf) - 1;

    if (! CryptExportKey(
        pThreadData->hExchangeKey, 0, PRIVATEKEYBLOB, 0, pbKeyBuf, &cbKeyBuf)) 
    {
        printf("CryptExportKey KeyEx PRIVATEKEYBLOB ");
        goto Ret;
    }

    if (! CryptImportKey(
        pThreadData->hProv, pbKeyBuf, cbKeyBuf, 0, CRYPT_EXPORTABLE, &hKey))
    {
        printf("CryptImportKey KeyEx PRIVATEKEYBLOB ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey)) 
    {
        printf("CryptDestroyKey KeyEx PRIVATEKEYBLOB ");
        goto Ret;
    }

    //
    // 1b) Exchange key pair PRIVATEKEYBLOB, encrypted
    //

    // Unalign the output buffer
    pbKeyBuf = rgbKeyBuf + 1;
    cbKeyBuf = sizeof(rgbKeyBuf) - 1;

    if (! CryptExportKey(
        pThreadData->hExchangeKey, 
        hWrapKey, 
        PRIVATEKEYBLOB, 
        0, 
        pbKeyBuf, 
        &cbKeyBuf)) 
    {
        printf("CryptExportKey KeyEx PRIVATEKEYBLOB b ");
        goto Ret;
    }

    if (! CryptImportKey(
        pThreadData->hProv, 
        pbKeyBuf, 
        cbKeyBuf, 
        hWrapKey, 
        CRYPT_EXPORTABLE, 
        &hKey))
    {
        printf("CryptImportKey KeyEx PRIVATEKEYBLOB b ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey)) 
    {
        printf("CryptDestroyKey KeyEx PRIVATEKEYBLOB b ");
        goto Ret;
    }

    //
    // 2) Exchange key pair PUBLICKEYBLOB
    //

    // Unalign the output buffer
    pbKeyBuf = rgbKeyBuf + 1;
    cbKeyBuf = sizeof(rgbKeyBuf) - 1;

    if (! CryptExportKey(
        pThreadData->hExchangeKey, 0, PUBLICKEYBLOB, 0, pbKeyBuf, &cbKeyBuf)) 
    {
        printf("CryptExportKey KeyEx PUBLICKEYBLOB ");
        goto Ret;
    }

    if (! CryptImportKey(
        pThreadData->hProv, 
        pbKeyBuf, 
        cbKeyBuf, 
        pThreadData->dwProvType == PROV_DSS_DH ? pThreadData->hExchangeKey : 0,
        0, 
        &hKey))
    {
        printf("CryptImportKey KeyEx PUBLICKEYBLOB ");
        goto Ret;
    }    

    if (! CryptDestroyKey(hKey)) 
    {
        printf("CryptDestroyKey KeyEx PUBLICKEYBLOB ");
        goto Ret;
    }

    //
    // 3a) Signature key pair PRIVATEKEYBLOB
    //

    // Unalign the output buffer
    pbKeyBuf = rgbKeyBuf + 1;
    cbKeyBuf = sizeof(rgbKeyBuf) - 1;

    if (! CryptExportKey(
        pThreadData->hSignatureKey, 0, PRIVATEKEYBLOB, 0, pbKeyBuf, &cbKeyBuf)) 
    {
        printf("CryptExportKey Sig PRIVATEKEYBLOB ");
        goto Ret;
    }

    if (! CryptImportKey(
        pThreadData->hProv, pbKeyBuf, cbKeyBuf, 0, CRYPT_EXPORTABLE, &hKey))
    {
        printf("CryptImportKey Sig PRIVATEKEYBLOB ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey)) 
    {
        printf("CryptDestroyKey Sig PRIVATEKEYBLOB ");
        goto Ret;
    }

    //
    // 3b) Signature key pair PRIVATEKEYBLOB, encrypted
    //

    // Unalign the output buffer
    pbKeyBuf = rgbKeyBuf + 1;
    cbKeyBuf = sizeof(rgbKeyBuf) - 1;

    if (! CryptExportKey(
        pThreadData->hSignatureKey, 
        hWrapKey, 
        PRIVATEKEYBLOB, 
        0, 
        pbKeyBuf, 
        &cbKeyBuf)) 
    {
        printf("CryptExportKey Sig PRIVATEKEYBLOB b ");
        goto Ret;
    }

    if (! CryptImportKey(
        pThreadData->hProv, 
        pbKeyBuf, 
        cbKeyBuf, 
        hWrapKey, 
        CRYPT_EXPORTABLE, 
        &hKey))
    {
        printf("CryptImportKey Sig PRIVATEKEYBLOB b ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey)) 
    {
        printf("CryptDestroyKey Sig PRIVATEKEYBLOB b ");
        goto Ret;
    }

    if (! CryptDestroyKey(hWrapKey))
    {
        printf("CryptDestroyKey CALG_RC2 ");
        goto Ret;
    }

    //
    // 4) Signature key pair PUBLICKEYBLOB
    //

    // Unalign the output buffer
    pbKeyBuf = rgbKeyBuf + 1;
    cbKeyBuf = sizeof(rgbKeyBuf) - 1;

    if (! CryptExportKey(
        pThreadData->hSignatureKey, 0, PUBLICKEYBLOB, 0, pbKeyBuf, &cbKeyBuf)) 
    {
        printf("CryptExportKey Sig PUBLICKEYBLOB ");
        goto Ret;
    }

    if (! CryptImportKey(
        pThreadData->hProv, pbKeyBuf, cbKeyBuf, 0, 0, &hKey))
    {
        printf("CryptImportKey Sig PUBLICKEYBLOB ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey)) 
    {
        printf("CryptDestroyKey Sig PUBLICKEYBLOB ");
        goto Ret;
    }

    //
    // 5) SIMPLEBLOB
    //

    if (pThreadData->dwProvType != PROV_DSS_DH &&
        pThreadData->dwProvType != PROV_DSS)
    {
        if (! CryptGenKey(
            pThreadData->hProv, CALG_RC2, CRYPT_EXPORTABLE, &hKey))
        {
            printf("CryptGenKey CALG_RC2 SIMPLEBLOB ");
            goto Ret;
        }
    
        // Unalign the output buffer
        pbKeyBuf = rgbKeyBuf + 1;
        cbKeyBuf = sizeof(rgbKeyBuf) - 1;
    
        if (! CryptExportKey(
            hKey, pThreadData->hExchangeKey, SIMPLEBLOB, 0, pbKeyBuf, &cbKeyBuf)) 
        {
            printf("CryptExportKey SIMPLEBLOB ");
            goto Ret;
        }
    
        if (! CryptDestroyKey(hKey)) 
        {
            printf("CryptDestroyKey CALG_RC2 A SIMPLEBLOB ");
            goto Ret;
        }
    
        if (! CryptImportKey(
            pThreadData->hProv, pbKeyBuf, cbKeyBuf, pThreadData->hExchangeKey, 0, &hKey))
        {
            printf("CryptImportKey SIMPLEBLOB ");
            goto Ret;
        }
    
        if (! CryptDestroyKey(hKey)) 
        {
            printf("CryptDestroyKey CALG_RC2 B SIMPLEBLOB ");
            goto Ret;
        }
    }

    //
    // 6) SYMMETRICWRAPKEYBLOB
    //

    if (! CryptGenKey(
        pThreadData->hProv, CALG_RC2, CRYPT_EXPORTABLE, &hKey))
    {
        printf("CryptGenKey CALG_RC2 SYMMETRICWRAPKEYBLOB A ");
        goto Ret;
    }

    if (! CryptGenKey(
        pThreadData->hProv, CALG_RC2, CRYPT_EXPORTABLE, &hWrapKey))
    {
        printf("CryptGenKey CALG_RC2 SYMMETRICWRAPKEYBLOB B ");
        goto Ret;
    }

    // Unalign the output buffer
    pbKeyBuf = rgbKeyBuf + 1;
    cbKeyBuf = sizeof(rgbKeyBuf) - 1;

    if (! CryptExportKey(
        hKey, hWrapKey, SYMMETRICWRAPKEYBLOB, 0, pbKeyBuf, &cbKeyBuf)) 
    {
        printf("CryptExportKey SYMMETRICWRAPKEYBLOB ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey)) 
    {
        printf("CryptDestroyKey CALG_RC2 A SYMMETRICWRAPKEYBLOB ");
        goto Ret;
    }

    if (! CryptImportKey(
        pThreadData->hProv, pbKeyBuf, cbKeyBuf, hWrapKey, 0, &hKey))
    {
        printf("CryptImportKey SYMMETRICWRAPKEYBLOB ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey)) 
    {
        printf("CryptDestroyKey CALG_RC2 B SYMMETRICWRAPKEYBLOB ");
        goto Ret;
    }

    if (! CryptDestroyKey(hWrapKey)) 
    {
        printf("CryptDestroyKey CALG_RC2 C SYMMETRICWRAPKEYBLOB ");
        goto Ret;
    }

    //
    // 7) PLAINTEXTKEYBLOB
    //

    if (! CryptGenKey(
        pThreadData->hProv, CALG_RC2, CRYPT_EXPORTABLE, &hKey))
    {
        printf("CryptGenKey CALG_RC2 PLAINTEXTKEYBLOB ");
        goto Ret;
    }

    // Unalign the output buffer
    pbKeyBuf = rgbKeyBuf + 1;
    cbKeyBuf = sizeof(rgbKeyBuf) - 1;

    if (! CryptExportKey(
        hKey, 0, PLAINTEXTKEYBLOB, 0, pbKeyBuf, &cbKeyBuf)) 
    {
        printf("CryptExportKey PLAINTEXTKEYBLOB ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey)) 
    {
        printf("CryptDestroyKey CALG_RC2 A PLAINTEXTKEYBLOB ");
        goto Ret;
    }

    if (! CryptImportKey(
        pThreadData->hProv, pbKeyBuf, cbKeyBuf, 0, 0, &hKey))
    {
        printf("CryptImportKey PLAINTEXTKEYBLOB ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey)) 
    {
        printf("CryptDestroyKey CALG_RC2 B PLAINTEXTKEYBLOB ");
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
        printf("- error 0x%x\n", dwError = GetLastError());
    
    return dwError;
}

static BYTE rgbPrivateKeyWithExponentOfOne[] =
{
   0x07, 0x02, 0x00, 0x00, 0x00, 0xA4, 0x00, 0x00,
   0x52, 0x53, 0x41, 0x32, 0x00, 0x02, 0x00, 0x00,
   0x01, 0x00, 0x00, 0x00, 0xAB, 0xEF, 0xFA, 0xC6,
   0x7D, 0xE8, 0xDE, 0xFB, 0x68, 0x38, 0x09, 0x92,
   0xD9, 0x42, 0x7E, 0x6B, 0x89, 0x9E, 0x21, 0xD7,
   0x52, 0x1C, 0x99, 0x3C, 0x17, 0x48, 0x4E, 0x3A,
   0x44, 0x02, 0xF2, 0xFA, 0x74, 0x57, 0xDA, 0xE4,
   0xD3, 0xC0, 0x35, 0x67, 0xFA, 0x6E, 0xDF, 0x78,
   0x4C, 0x75, 0x35, 0x1C, 0xA0, 0x74, 0x49, 0xE3,
   0x20, 0x13, 0x71, 0x35, 0x65, 0xDF, 0x12, 0x20,
   0xF5, 0xF5, 0xF5, 0xC1, 0xED, 0x5C, 0x91, 0x36,
   0x75, 0xB0, 0xA9, 0x9C, 0x04, 0xDB, 0x0C, 0x8C,
   0xBF, 0x99, 0x75, 0x13, 0x7E, 0x87, 0x80, 0x4B,
   0x71, 0x94, 0xB8, 0x00, 0xA0, 0x7D, 0xB7, 0x53,
   0xDD, 0x20, 0x63, 0xEE, 0xF7, 0x83, 0x41, 0xFE,
   0x16, 0xA7, 0x6E, 0xDF, 0x21, 0x7D, 0x76, 0xC0,
   0x85, 0xD5, 0x65, 0x7F, 0x00, 0x23, 0x57, 0x45,
   0x52, 0x02, 0x9D, 0xEA, 0x69, 0xAC, 0x1F, 0xFD,
   0x3F, 0x8C, 0x4A, 0xD0,

   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

   0x64, 0xD5, 0xAA, 0xB1,
   0xA6, 0x03, 0x18, 0x92, 0x03, 0xAA, 0x31, 0x2E,
   0x48, 0x4B, 0x65, 0x20, 0x99, 0xCD, 0xC6, 0x0C,
   0x15, 0x0C, 0xBF, 0x3E, 0xFF, 0x78, 0x95, 0x67,
   0xB1, 0x74, 0x5B, 0x60,

   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// 
// 64-bit and 56-bit DES SIMPLEBLOB's exported with 
// above public key.  These keys are functionally
// equivalent on Windows 2000 due to a buffer overrun
// bug.
//
static BYTE g_rgbDes56BitKeyBlob[] = 
{
    0x01, 0x02, 0x00, 0x00, 0x01, 0x66, 0x00, 0x00,
    0x00, 0xa4, 0x00, 0x00, 0x29, 0x32, 0xc4, 0xd0,
    0x75, 0x25, 0xa4, 0x00, 0xa8, 0x6f, 0x02, 0x35,
    0x0e, 0x53, 0x75, 0xaa, 0xad, 0x8d, 0x21, 0x67,
    0xf6, 0x8a, 0x93, 0x78, 0x12, 0x27, 0x5c, 0xd1,
    0xa2, 0x13, 0x0f, 0xab, 0xe4, 0x68, 0x8e, 0x28,
    0xcc, 0x3e, 0xf1, 0xa5, 0x52, 0xe4, 0xf7, 0xa4,
    0x57, 0xaa, 0x86, 0x93, 0xc8, 0x73, 0xb1, 0x9f,
    0x77, 0xc8, 0x84, 0x97, 0xe4, 0xad, 0x63, 0xad,
    0x5d, 0x76, 0x02, 0x00
};
static BYTE g_rgbDes64BitKeyBlob[] = 
{
    0x01, 0x02, 0x00, 0x00, 0x01, 0x66, 0x00, 0x00,
    0x00, 0xa4, 0x00, 0x00, 0x00, 0x29, 0x32, 0xc4, 
    0xd0, 0x75, 0x25, 0xa4, 0x00, 0xa8, 0x6f, 0x02, 
    0x0e, 0x53, 0x75, 0xaa, 0xad, 0x8d, 0x21, 0x67,
    0xf6, 0x8a, 0x93, 0x78, 0x12, 0x27, 0x5c, 0xd1,
    0xa2, 0x13, 0x0f, 0xab, 0xe4, 0x68, 0x8e, 0x28,
    0xcc, 0x3e, 0xf1, 0xa5, 0x52, 0xe4, 0xf7, 0xa4,
    0x57, 0xaa, 0x86, 0x93, 0xc8, 0x73, 0xb1, 0x9f,
    0x77, 0xc8, 0x84, 0x97, 0xe4, 0xad, 0x63, 0xad,
    0x5d, 0x76, 0x02, 0x00
};
static BYTE g_rgbDesPlainText[] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
};
static BYTE g_rgbDesCipherText[] =
{
    0x3b, 0xd9, 0x09, 0xfb, 0xd6, 0xa7, 0x9c, 0x37,
    0xf6, 0x5d, 0xe1, 0x50, 0x6d, 0x39, 0xb0, 0x0c
};

//
// 112 and 128 bit "equivalent" 3Des-2Key blobs
//
static BYTE g_rgbDes112BitKeyBlob[] = 
{
    0x01, 0x02, 0x00, 0x00, 0x09, 0x66, 0x00, 0x00,
    0x00, 0xa4, 0x00, 0x00, 0x29, 0x32, 0xc4, 0xd0,
    0x75, 0x25, 0xa4, 0x75, 0xa8, 0x6f, 0x02, 0x35,
    0x0e, 0x53, 0x00, 0xaa, 0xad, 0x8d, 0x21, 0x67,
    0xf6, 0x8a, 0x93, 0x78, 0x12, 0x27, 0x5c, 0xd1,
    0xa2, 0x13, 0x0f, 0xab, 0xe4, 0x68, 0x8e, 0x28,
    0xcc, 0x3e, 0xf1, 0xa5, 0x52, 0xe4, 0xf7, 0xa4,
    0x57, 0xaa, 0x86, 0x93, 0xc8, 0x73, 0xb1, 0x9f,
    0x77, 0xc8, 0x84, 0x97, 0xe4, 0xad, 0x63, 0xad,
    0x5d, 0x76, 0x02, 0x00
};
static BYTE g_rgbDes128BitKeyBlob[] = 
{
    0x01, 0x02, 0x00, 0x00, 0x09, 0x66, 0x00, 0x00,
    0x00, 0xa4, 0x00, 0x00, 0x00, 0x00, 0x29, 0x32, 
    0xc4, 0xd0, 0x75, 0x25, 0xa4, 0x75, 0xa8, 0x6f, 
    0x02, 0x35, 0x0e, 0x53, 0x00, 0xaa, 0xad, 0x8d, 
    0xf6, 0x8a, 0x93, 0x78, 0x12, 0x27, 0x5c, 0xd1,
    0xa2, 0x13, 0x0f, 0xab, 0xe4, 0x68, 0x8e, 0x28,
    0xcc, 0x3e, 0xf1, 0xa5, 0x52, 0xe4, 0xf7, 0xa4,
    0x57, 0xaa, 0x86, 0x93, 0xc8, 0x73, 0xb1, 0x9f,
    0x77, 0xc8, 0x84, 0x97, 0xe4, 0xad, 0x63, 0xad,
    0x5d, 0x76, 0x02, 0x00
};
static BYTE g_rgb2DesCipherText[] =
{
    0x56, 0x03, 0xdf, 0x55, 0xeb, 0xfb, 0x76, 0x1f,
    0x93, 0x38, 0xd7, 0xef, 0x8f, 0x38, 0x76, 0x49
};

//
// 168 and 192 bit "equivalent" 3Des blobs
//
static BYTE g_rgbDes168BitKeyBlob[] = 
{
    0x01, 0x02, 0x00, 0x00, 0x03, 0x66, 0x00, 0x00,
    0x00, 0xa4, 0x00, 0x00, 0x29, 0x32, 0xc4, 0xd0,
    0x75, 0x25, 0xa4, 0x8a, 0xa8, 0x6f, 0x02, 0x35,
    0x0e, 0x53, 0x75, 0xaa, 0xad, 0x8d, 0x21, 0x67,
    0xf6, 0x00, 0x93, 0x78, 0x12, 0x27, 0x5c, 0xd1,
    0xa2, 0x13, 0x0f, 0xab, 0xe4, 0x68, 0x8e, 0x28,
    0xcc, 0x3e, 0xf1, 0xa5, 0x52, 0xe4, 0xf7, 0xa4,
    0x57, 0xaa, 0x86, 0x93, 0xc8, 0x73, 0xb1, 0x9f,
    0x77, 0xc8, 0x84, 0x97, 0xe4, 0xad, 0x63, 0xad,
    0x5d, 0x76, 0x02, 0x00
};
static BYTE g_rgbDes192BitKeyBlob[] = 
{
    0x01, 0x02, 0x00, 0x00, 0x03, 0x66, 0x00, 0x00,
    0x00, 0xa4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 
    0x32, 0xc4, 0xd0, 0x75, 0x25, 0xa4, 0x8a, 0xa8, 
    0x6f, 0x02, 0x35, 0x0e, 0x53, 0x75, 0xaa, 0xad, 
    0x8d, 0x21, 0x67, 0xf6, 0x00, 0x93, 0x78, 0x12, 
    0xa2, 0x13, 0x0f, 0xab, 0xe4, 0x68, 0x8e, 0x28,
    0xcc, 0x3e, 0xf1, 0xa5, 0x52, 0xe4, 0xf7, 0xa4,
    0x57, 0xaa, 0x86, 0x93, 0xc8, 0x73, 0xb1, 0x9f,
    0x77, 0xc8, 0x84, 0x97, 0xe4, 0xad, 0x63, 0xad,
    0x5d, 0x76, 0x02, 0x00
};
static BYTE g_rgb3DesCipherText[] =
{
    0x25, 0x25, 0x14, 0x94, 0x6b, 0xe0, 0x69, 0x21,
    0xea, 0x3d, 0xb5, 0xa6, 0x5b, 0xaa, 0x6c, 0x87
};

// 
// Function: DesImportEquivalenceTest
// Purpose: Verify that the provided des key correctly 
// encrypts the above rgbDesPlainText.
// 
DWORD DesImportEquivalenceTest(
    PTHREAD_DATA pThreadData,
    PBYTE pbDesKey,
    DWORD cbDesKey,
    PBYTE pbDesShortKey,
    DWORD cbDesShortKey,
    PBYTE pbCipherText,
    DWORD cbCipherText)
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fSuccess = FALSE;
    HCRYPTKEY hPubKey = 0;
    HCRYPTKEY hDesKey = 0;
    PBYTE pb = NULL;
    DWORD cb = 0;
    BYTE rgbPlain[sizeof(g_rgbDesPlainText) * 2];
    DWORD cbPlain = sizeof(rgbPlain);
    BOOL fBlobError = FALSE;
    PBYTE p1 = NULL, p2 = NULL, p3 = NULL;

    if (! CryptImportKey(
        pThreadData->hVerifyCtx, rgbPrivateKeyWithExponentOfOne, 
        sizeof(rgbPrivateKeyWithExponentOfOne), 0, 0, &hPubKey))
    {
        printf("CryptImportKey privatekeywithexponentofone ");
        goto Ret;
    }

    // Try to import the short key; should fail
    if (CryptImportKey(
        pThreadData->hVerifyCtx, pbDesShortKey, cbDesShortKey,
        hPubKey, 0, &hDesKey))
    {
        printf("CryptImportKey ShortDesKey should've failed ");
        goto Ret;
    }

    PrintBytes("Testing this des key SIMPLEBLOB", pbDesKey, cbDesKey);

    if (! CryptImportKey(
        pThreadData->hVerifyCtx, pbDesKey, cbDesKey,
        hPubKey, CRYPT_EXPORTABLE, &hDesKey))
    {
        printf("CryptImportKey deskeyblob ");
        goto Ret;
    }

    cb = sizeof(g_rgbDesPlainText);
    memcpy(rgbPlain, g_rgbDesPlainText, cb);
    
    if (! CryptEncrypt(
        hDesKey, 0, TRUE, 0, rgbPlain, &cb, cbPlain))
    {
        printf("CryptEncrypt ");
        goto Ret;
    }

    if (0 != memcmp(rgbPlain, pbCipherText, cbCipherText))
    {
        printf("Cipher text doesn't match\n");
        PrintBytes("Expected cipher text", pbCipherText, cbCipherText);
        PrintBytes("Actual cipher text", rgbPlain, sizeof(rgbPlain));
        fBlobError = TRUE;
    }

    if (! CryptExportKey(
        hDesKey, hPubKey, SIMPLEBLOB, 0, NULL, &cb))
    {
        printf("CryptExportKey size ");
        goto Ret;
    }

    if (NULL == (pb = (PBYTE) MyAlloc(cb)))
        return ERROR_NOT_ENOUGH_MEMORY;

    if (! CryptExportKey(
        hDesKey, hPubKey, SIMPLEBLOB, 0, pb, &cb))
    {
        printf("CryptExportKey ");
        goto Ret;
    }

    if (0 != memcmp(
        pb, pbDesKey, 
        sizeof(SIMPLEBLOB) + sizeof(ALG_ID) + 8))
    {
        printf("Header + key portion of blob doesn't match\n");
        PrintBytes("Expected key blob", pbDesKey, cbDesKey);
        PrintBytes("Actual key blob", pb, cb);
        fBlobError = TRUE;
    }

    fSuccess = TRUE;
Ret:
    if (fBlobError)
        dwError = -1;
    if (! fSuccess)
        printf("- error 0x%x\n", dwError = GetLastError());
    if (hDesKey)
        CryptDestroyKey(hDesKey);
    if (hPubKey)
        CryptDestroyKey(hPubKey);
    if (pb)
        MyFree(pb);

    return dwError;
}

//
// Function: DesImportRegression
//
DWORD DesImportRegression(PTHREAD_DATA pThreadData)
{
    DWORD dwSts;
    DWORD dwError = ERROR_SUCCESS;

    if (ERROR_SUCCESS != (dwSts = 
        DesImportEquivalenceTest(
            pThreadData,
            g_rgbDes64BitKeyBlob,
            sizeof(g_rgbDes64BitKeyBlob),
            g_rgbDes56BitKeyBlob,
            sizeof(g_rgbDes56BitKeyBlob),
            g_rgbDesCipherText,
            sizeof(g_rgbDesCipherText))))
        dwError = dwSts;

    if (ERROR_SUCCESS != (dwSts = 
        DesImportEquivalenceTest(
            pThreadData,
            g_rgbDes128BitKeyBlob,
            sizeof(g_rgbDes128BitKeyBlob),
            g_rgbDes112BitKeyBlob,
            sizeof(g_rgbDes112BitKeyBlob),
            g_rgb2DesCipherText,
            sizeof(g_rgb2DesCipherText))))
        dwError = dwSts;

    if (ERROR_SUCCESS != (dwSts = 
        DesImportEquivalenceTest(
            pThreadData,
            g_rgbDes192BitKeyBlob,
            sizeof(g_rgbDes192BitKeyBlob),
            g_rgbDes168BitKeyBlob,
            sizeof(g_rgbDes168BitKeyBlob),
            g_rgb3DesCipherText,
            sizeof(g_rgb3DesCipherText))))
        dwError = dwSts;

    return dwError;
}

static BYTE rgbPlainText[] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
};
static BYTE rgbIV[] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
};

BYTE rgbRC2PlainTextKey [] = {
    0x08, 0x02, 0x00, 0x00, 0x02, 0x66, 0x00, 0x00, 
        0x10, 0x00, 0x00, 0x00, 0x10, 0x62, 0x0a, 0x8a, 
        0x6b, 0x0d, 0x60, 0xbe, 0xf3, 0x94, 0x99, 0x12, 
        0xef, 0x39, 0xbf, 0x4f
};

BYTE rgbRC2CipherText [] = {
    0xfd, 0x25, 0x3e, 0x7a, 0xff, 0xb5, 0xc2, 0x6e, 
        0x13, 0xcf, 0x52, 0xf1, 0xba, 0xa3, 0x9a, 0xef, 
        0x1c, 0xfb, 0x91, 0x88, 0x9d, 0xf7, 0xe5, 0x12 
};

BYTE rgbDESPlainTextKey [] = {
    0x08, 0x02, 0x00, 0x00, 0x01, 0x66, 0x00, 0x00, 
        0x08, 0x00, 0x00, 0x00, 0xef, 0x8f, 0x10, 0xec, 
        0xea, 0x7a, 0x2c, 0x01
};

BYTE rgbDESCipherText [] = {
    0x13, 0x68, 0x16, 0xc5, 0x15, 0x3d, 0x59, 0x1f, 
        0x8e, 0x9c, 0x9c, 0x4f, 0x03, 0x7b, 0xb2, 0x12, 
        0x24, 0xa7, 0x81, 0x5e, 0x68, 0xb1, 0x58, 0xaa
};

BYTE rgb3DES112PlainTextKey [] = {
    0x08, 0x02, 0x00, 0x00, 0x09, 0x66, 0x00, 0x00, 
        0x10, 0x00, 0x00, 0x00, 0x6d, 0x07, 0xcd, 0xe9, 
        0xa4, 0x23, 0xc7, 0x97, 0x4a, 0x4f, 0x5b, 0x2f, 
        0x34, 0x92, 0xb5, 0x92
};

BYTE rgb3DES112CipherText [] = {
    0xf4, 0xfd, 0xde, 0x15, 0xfd, 0x50, 0xaa, 0x3c, 
        0x02, 0xb1, 0x07, 0x3b, 0x0f, 0x0f, 0x93, 0x23, 
        0xc2, 0x23, 0xda, 0x1f, 0x65, 0x81, 0x59, 0x24
};

BYTE rgb3DESCipherText [] = {
    0xa6, 0xae, 0xa2, 0x97, 0xc4, 0x85, 0xda, 0xa7, 
        0x43, 0xc8, 0x5d, 0xf4, 0x97, 0xb4, 0xbc, 0x03, 
        0x96, 0xf9, 0xa2, 0x66, 0x9e, 0x18, 0x91, 0x4a
};

BYTE rgb3DESPlainTextKey [] = {
    0x08, 0x02, 0x00, 0x00, 0x03, 0x66, 0x00, 0x00, 
        0x18, 0x00, 0x00, 0x00, 0xdc, 0x0d, 0x20, 0xf2, 
        0xcb, 0xa8, 0xb6, 0x15, 0x3e, 0x23, 0x38, 0xb6, 
        0x31, 0x62, 0x4a, 0x16, 0xa4, 0x49, 0xe5, 0xe5, 
        0x61, 0x76, 0x75, 0x23
};

BYTE rgbAES128PlainTextKey [] = {
    0x08, 0x02, 0x00, 0x00, 0x0e, 0x66, 0x00, 0x00, 
        0x10, 0x00, 0x00, 0x00, 0x7d, 0xda, 0x8c, 0x7f, 
        0xac, 0x2e, 0xe7, 0xa6, 0x6f, 0x4c, 0x3b, 0x98, 
        0x2b, 0xe6, 0xff, 0xc9
};

BYTE rgbAES128CipherText [] = {
    0xd7, 0xb4, 0x60, 0x15, 0x39, 0xac, 0x42, 0x8c, 
        0x67, 0x09, 0x0d, 0x3f, 0x45, 0xa0, 0x4e, 0xf5, 
        0x6b, 0x7d, 0x6d, 0x21, 0x28, 0xd7, 0x93, 0x13, 
        0xd8, 0x5a, 0x7a, 0x92, 0x34, 0x98, 0xfe, 0x73
};

BYTE rgbAES192PlainTextKey [] = {
    0x08, 0x02, 0x00, 0x00, 0x0f, 0x66, 0x00, 0x00, 
        0x18, 0x00, 0x00, 0x00, 0x09, 0x38, 0x0e, 0xfd, 
        0x49, 0x16, 0x95, 0x95, 0x01, 0x6e, 0x8b, 0xfd, 
        0x3a, 0x34, 0x24, 0x62, 0x23, 0xd6, 0xd4, 0x01, 
        0x38, 0x97, 0x96, 0x48
};

BYTE rgbAES192CipherText [] = {
    0xa6, 0x57, 0x36, 0xbb, 0xb2, 0x4f, 0x22, 0xee, 
        0x2b, 0xb8, 0x0b, 0x65, 0xf3, 0xc1, 0x82, 0x93, 
        0x92, 0xcc, 0xcc, 0x0a, 0xf3, 0x4e, 0x3b, 0x28, 
        0xb7, 0x6d, 0x89, 0xd3, 0x9a, 0x0c, 0xa0, 0x95
};

BYTE rgbAES256PlainTextKey [] = {
    0x08, 0x02, 0x00, 0x00, 0x10, 0x66, 0x00, 0x00, 
        0x20, 0x00, 0x00, 0x00, 0xb5, 0xe8, 0xa8, 0xb3, 
        0x1b, 0x0b, 0x9c, 0x14, 0x9e, 0x27, 0xe8, 0x99, 
        0x58, 0xce, 0x89, 0x57, 0x34, 0x2f, 0x1a, 0x41, 
        0x29, 0x4e, 0xfe, 0x64, 0xc3, 0xe9, 0xe9, 0x2b, 
        0x63, 0x47, 0x58, 0x54
};

BYTE rgbAES256CipherText [] = {
    0x51, 0xf2, 0x8d, 0x49, 0x7d, 0x10, 0xd4, 0x66, 
        0xe8, 0xc2, 0x70, 0xf3, 0xff, 0x19, 0xa2, 0x7e, 
        0xe7, 0x89, 0x1d, 0x11, 0xe7, 0x25, 0xd7, 0x42, 
        0x75, 0xe2, 0x72, 0x78, 0x38, 0x52, 0x30, 0xc9
};

typedef struct _KnownBlockCipherResult {
    ALG_ID ai;
    BYTE *pbKey;
    DWORD cbKey;
    BYTE *pbCipherText;
    DWORD cbCipherText;
} KnownBlockCipherResult, *pKnownBlockCipherResult;

KnownBlockCipherResult g_rgKnownBlockCipherResults [] = {
    { CALG_RC2, rgbRC2PlainTextKey, sizeof(rgbRC2PlainTextKey),
        rgbRC2CipherText, sizeof(rgbRC2CipherText) },
    { CALG_DES, rgbDESPlainTextKey, sizeof(rgbDESPlainTextKey),
        rgbDESCipherText, sizeof(rgbDESCipherText) },
    { CALG_3DES_112, rgb3DES112PlainTextKey, sizeof(rgb3DES112PlainTextKey),
        rgb3DES112CipherText, sizeof(rgb3DES112CipherText) },
    { CALG_3DES, rgb3DESPlainTextKey, sizeof(rgb3DESPlainTextKey),
        rgb3DESCipherText, sizeof(rgb3DESCipherText) },
    { CALG_AES_128, rgbAES128PlainTextKey, sizeof(rgbAES128PlainTextKey),
        rgbAES128CipherText, sizeof(rgbAES128CipherText) },
    { CALG_AES_192, rgbAES192PlainTextKey, sizeof(rgbAES192PlainTextKey),
        rgbAES192CipherText, sizeof(rgbAES192CipherText) },
    { CALG_AES_256, rgbAES256PlainTextKey, sizeof(rgbAES256PlainTextKey),
        rgbAES256CipherText, sizeof(rgbAES256CipherText) }
};

static const unsigned g_cKnownBlockCipherResults = 
    sizeof(g_rgKnownBlockCipherResults) / sizeof(KnownBlockCipherResult);

//
// Function: KnownSymKeyRegression
//
DWORD KnownBlockCipherKeyRegression(PTHREAD_DATA pThreadData)
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fSuccess = FALSE;
    BOOL fBlobError = FALSE;
    HCRYPTKEY hPubKey = 0;
    HCRYPTKEY hSymKey = 0;
    PALGNODE pAlgNode = NULL;
    PBYTE pb = NULL;
    DWORD cb = 0;
    DWORD cbBuf = 0;
    DWORD dw = 0;
    CHAR rgsz[1024];
    unsigned u;

    for (   pAlgNode = pThreadData->pAlgList; 
            pAlgNode != NULL; 
            pAlgNode = pAlgNode->pNext)
    {
        if ((ALG_CLASS_DATA_ENCRYPT != GET_ALG_CLASS(pAlgNode->EnumalgsEx.aiAlgid)) 
            || (ALG_TYPE_BLOCK != GET_ALG_TYPE(pAlgNode->EnumalgsEx.aiAlgid)))
            continue;

        for (   u = 0; 
                u < g_cKnownBlockCipherResults && 
                    pAlgNode->EnumalgsEx.aiAlgid != g_rgKnownBlockCipherResults[u].ai;
                u++);

        // CYLINK_MEK is not supported with PLAINTEXTKEYBLOB's
        if (CALG_CYLINK_MEK == pAlgNode->EnumalgsEx.aiAlgid)
            continue;

        sprintf(
            rgsz, 
            "Importing 0x%x blob for CSP alg %s (0x%x)", 
            g_rgKnownBlockCipherResults[u].ai,
            pAlgNode->EnumalgsEx.szName,
            pAlgNode->EnumalgsEx.aiAlgid);

        PrintBytes(
            rgsz,
            g_rgKnownBlockCipherResults[u].pbKey,
            g_rgKnownBlockCipherResults[u].cbKey);

        if (! CryptImportKey(
            pThreadData->hProv, 
            g_rgKnownBlockCipherResults[u].pbKey,
            g_rgKnownBlockCipherResults[u].cbKey,
            0, 0, &hSymKey))
        {
            printf("CryptImportKey ");
            goto Ret;
        }

        if (! CryptSetKeyParam(hSymKey, KP_IV, rgbIV, 0))
        {
            printf("CryptSetKeyParam ");
            goto Ret;
        }

        dw = CRYPT_MODE_CBC;
        if (! CryptSetKeyParam(hSymKey, KP_MODE, (PBYTE) &dw, 0))
        {
            printf("CryptSetKeyParam ");
            goto Ret;
        }

        cb = sizeof(rgbPlainText);
        if (! CryptEncrypt(hSymKey, 0, TRUE, 0, NULL, &cb, 0))
        {
            printf("CryptEncrypt ");
            goto Ret;
        }

        if (NULL == (pb = (PBYTE) MyAlloc(cb)))
            return ERROR_NOT_ENOUGH_MEMORY;

        cbBuf = cb;
        cb = sizeof(rgbPlainText);
        memcpy(pb, rgbPlainText, cb);

        if (! CryptEncrypt(hSymKey, 0, TRUE, 0, pb, &cb, cbBuf))
        {
            printf("CryptEncrypt ");
            goto Ret;
        }

        if (0 != memcmp(pb, g_rgKnownBlockCipherResults[u].pbCipherText, cb)
            || 0 == cb)
        {
            printf(
                "Ciphertext is wrong for alg %s\n", 
                pAlgNode->EnumalgsEx.szName);                
            PrintBytes(
                "Expected ciphertext", 
                g_rgKnownBlockCipherResults[u].pbCipherText,
                cb);
            PrintBytes(
                "Actual ciphertext", 
                pb, cb);
            fBlobError = TRUE;
        }
    }

    fSuccess = TRUE;
Ret:
    if (fBlobError)
        dwError = -1;
    if ((! fSuccess) && (! fBlobError))
        printf("- error 0x%x\n", dwError = GetLastError());

    return dwError;
}

typedef struct _HMAC_TEST
{
    PBYTE pbKey;
    DWORD cbKey;
    PBYTE pbData;
    DWORD cbData;
    PBYTE pbData2;
    DWORD cbData2;
    PBYTE pbHmac;
    DWORD cbHmac;
    ALG_ID aiHash;
} HMAC_TEST, *PHMAC_TEST;

//
// Function: DoHmacTestCase
//
DWORD DoHmacTestCase(
    IN PTHREAD_DATA pThreadData,
    IN PHMAC_TEST pHmac)
{
    HCRYPTKEY hKey      = 0;
    HCRYPTHASH hHash    = 0;
    DWORD cb            = 0;
    BLOBHEADER *pHeader = NULL;
    BOOL fSuccess       = FALSE;
    DWORD dwError       = ERROR_SUCCESS;
    BYTE rgBuf[1024];
    HMAC_INFO HmacInfo;

    ZeroMemory(rgBuf, sizeof(rgBuf));
    ZeroMemory(&HmacInfo, sizeof(HmacInfo));

    pHeader = (BLOBHEADER *) rgBuf;
    pHeader->bType = PLAINTEXTKEYBLOB;
    pHeader->bVersion = CUR_BLOB_VERSION;
    pHeader->aiKeyAlg = CALG_RC2;

    *(DWORD*)(rgBuf + sizeof(BLOBHEADER)) = pHmac->cbKey;
    memcpy(
        rgBuf + sizeof(BLOBHEADER) + sizeof(DWORD), 
        pHmac->pbKey, pHmac->cbKey);

    if (! CryptImportKey(
            pThreadData->hProv, rgBuf,
            sizeof(BLOBHEADER) + sizeof(DWORD) + pHmac->cbKey,
            0, CRYPT_IPSEC_HMAC_KEY, &hKey))
    {
        printf("CryptImportKey");
        goto Ret;
    }

    if (! CryptCreateHash(
            pThreadData->hProv, CALG_HMAC, hKey, 0, &hHash))
    {
        printf("CryptCreateHash");
        goto Ret;
    }

    HmacInfo.HashAlgid = pHmac->aiHash;
    if (! CryptSetHashParam(
            hHash, HP_HMAC_INFO, (PBYTE) &HmacInfo, 0))
    {
        printf("CryptSetHashParam");
        goto Ret;
    }

    if (! CryptHashData(
            hHash, pHmac->pbData, pHmac->cbData, 0))
    {
        printf("CryptHashData");
        goto Ret;
    }

    if (pHmac->cbData2)
    {
        if (! CryptHashData(
                hHash, pHmac->pbData2, pHmac->cbData2, 0))
        {
            printf("CryptHashData 2");
            goto Ret;
        }
    }

    cb = sizeof(rgBuf);
    ZeroMemory(rgBuf, sizeof(rgBuf));
    if (! CryptGetHashParam(
            hHash, HP_HASHVAL, rgBuf, &cb, 0))
    {
        printf("CryptGetHashParam");
        goto Ret;
    }

    PrintBytes("Expected Hmac", pHmac->pbHmac, pHmac->cbHmac);
    PrintBytes("Actual Hmac", rgBuf, cb);

    if (    0 != memcmp(rgBuf, pHmac->pbHmac, cb) 
            || cb != pHmac->cbHmac)
        goto Ret;

    if (! CryptDestroyKey(hKey))
    {
        printf("CryptDestroyKey");
        goto Ret;
    }

    if (! CryptDestroyHash(hHash))
    {
        printf("CryptDestroyHash");
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
    {
        dwError = GetLastError();
        printf(" error - 0x%x\n", dwError);
        if (0 == dwError)
            dwError = -1;
    }
    
    return dwError;
}

//
// Function: HmacRegression
//
DWORD HmacRegression(PTHREAD_DATA pThreadData)
{
    BOOL fSuccess       = FALSE;
    DWORD dwError       = ERROR_SUCCESS;
    HMAC_TEST Hmac;
    
    // SHA Test case 1
    BYTE rgKey1 []      = {
        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
        0x0b, 0x0b, 0x0b, 0x0b, 0x0b
    };
    LPSTR pszData1      = "Hi There";
    BYTE rgHmac1 []     = {
        0xb6, 0x17, 0x31, 0x86, 0x55, 
        0x05, 0x72, 0x64, 0xe2, 0x8b, 
        0xc0, 0xb6, 0xfb, 0x37, 0x8c,
        0x8e, 0xf1, 0x46, 0xbe, 0x00
    };

    // SHA Test case 2
    BYTE rgKey2 []      = {
        0x01, 0x02, 0x03, 0x04, 0x05,
        0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14,
        0x15, 0x16, 0x17, 0x18, 0x19
    };
    BYTE rgData2 [50];
    BYTE rgHmac2 []     = {
        0x4c, 0x90, 0x07, 0xf4, 0x02,
        0x62, 0x50, 0xc6, 0xbc, 0x84,
        0x14, 0xf9, 0xbf, 0x50, 0xc8,
        0x6c, 0x2d, 0x72, 0x35, 0xda
    };

    // SHA Test case 3
    BYTE rgKey3 [80];
    LPSTR pszData3      = "Test Using Larger Than Block-Size Key - Hash Key First";
    BYTE rgHmac3 []     = {
        0xaa, 0x4a, 0xe5, 0xe1, 0x52,
        0x72, 0xd0, 0x0e, 0x95, 0x70,
        0x56, 0x37, 0xce, 0x8a, 0x3b,
        0x55, 0xed, 0x40, 0x21, 0x12
    };

    // MD5 Test case 1
    // use rgKey1 (16 bytes only) and pszData1
    BYTE rgHmacMD1 []   = {
        0x92, 0x94, 0x72, 0x7a, 
        0x36, 0x38, 0xbb, 0x1c, 
        0x13, 0xf4, 0x8e, 0xf8, 
        0x15, 0x8b, 0xfc, 0x9d
    };

    // MD5 Test case 2
    // use rgKey3 (full length) and pszData3
    BYTE rgHmacMD2 []   = {
        0x6b, 0x1a, 0xb7, 0xfe,
        0x4b, 0xd7, 0xbf, 0x8f,
        0x0b, 0x62, 0xe6, 0xce,
        0x61, 0xb9, 0xd0, 0xcd
    };

    // IPSec MD5 vectors
    BYTE rgKeyIpsec [] = {
         0x66, 0x6f, 0x6f
    };
    BYTE rgDataIpsecA [] = {
        0x38, 0x8e, 0x5e, 0x8a, 
        0xb0, 0x79, 0x16, 0x47,
        0x29, 0x1b, 0xf0, 0x02,
        0x78, 0x5e, 0x38, 0xe5,
        0x82, 0x3c, 0x17, 0x0d
    };
    BYTE rgDataIpsecB [] = {
        0x34, 0xdd, 0xdb, 0x22,
        0x9e, 0x21, 0x75, 0x28,
        0x5e, 0x4d, 0x7d, 0xdf,
        0xea, 0x35, 0xc5, 0xfc,
        0x44, 0xdb, 0x62, 0xad
    };
    BYTE rgHmacIpsec [] = {
        0x52, 0x07, 0x38, 0x15,
        0xef, 0xb0, 0x68, 0x43,
        0x89, 0x8e, 0x0b, 0xdc,
        0x58, 0xc0, 0x70, 0xc0      
    };

    memset(rgData2, 0xcd, sizeof(rgData2));
    memset(rgKey3, 0xaa, sizeof(rgKey3));

    // SHA 1
    ZeroMemory(&Hmac, sizeof(HMAC_TEST));
    Hmac.cbData = strlen(pszData1) * sizeof(CHAR);
    Hmac.pbData = (PBYTE) pszData1;
    Hmac.cbHmac = sizeof(rgHmac1);
    Hmac.pbHmac = rgHmac1;
    Hmac.cbKey = sizeof(rgKey1);
    Hmac.pbKey = rgKey1;
    Hmac.aiHash = CALG_SHA1;

    if (ERROR_SUCCESS != (dwError = DoHmacTestCase(pThreadData, &Hmac)))
    {
        printf("ERROR: DoHmacTestCase SHA 1\n");
        return dwError;      
    }

    // SHA 2
    ZeroMemory(&Hmac, sizeof(HMAC_TEST));
    Hmac.cbData = sizeof(rgData2);
    Hmac.pbData = rgData2;
    Hmac.cbHmac = sizeof(rgHmac2);
    Hmac.pbHmac = rgHmac2;
    Hmac.cbKey = sizeof(rgKey2);
    Hmac.pbKey = rgKey2;
    Hmac.aiHash = CALG_SHA1;

    if (ERROR_SUCCESS != (dwError = DoHmacTestCase(pThreadData, &Hmac)))
    {
        printf("ERROR: DoHmacTestCase SHA 2\n");
        return dwError;      
    }

    // SHA 3
    ZeroMemory(&Hmac, sizeof(HMAC_TEST));
    Hmac.cbData = strlen(pszData3) * sizeof(CHAR);
    Hmac.pbData = (PBYTE) pszData3;
    Hmac.cbHmac = sizeof(rgHmac3);
    Hmac.pbHmac = rgHmac3;
    Hmac.cbKey = sizeof(rgKey3);
    Hmac.pbKey = rgKey3;
    Hmac.aiHash = CALG_SHA1;

    if (ERROR_SUCCESS != (dwError = DoHmacTestCase(pThreadData, &Hmac)))
    {
        printf("ERROR: DoHmacTestCase SHA 3\n");
        return dwError;      
    }

    // MD5 1
    ZeroMemory(&Hmac, sizeof(HMAC_TEST));
    Hmac.cbData = strlen(pszData1) * sizeof(CHAR);
    Hmac.pbData = (PBYTE) pszData1;
    Hmac.cbHmac = sizeof(rgHmacMD1);
    Hmac.pbHmac = rgHmacMD1;
    Hmac.cbKey = 16; // only 16-byte key for this one
    Hmac.pbKey = rgKey1;
    Hmac.aiHash = CALG_MD5;

    if (ERROR_SUCCESS != (dwError = DoHmacTestCase(pThreadData, &Hmac)))
    {
        printf("ERROR: DoHmacTestCase MD5 1\n");
        return dwError;      
    }

    // MD5 2
    ZeroMemory(&Hmac, sizeof(HMAC_TEST));
    Hmac.cbData = strlen(pszData3) * sizeof(CHAR);
    Hmac.pbData = (PBYTE) pszData3;
    Hmac.cbHmac = sizeof(rgHmacMD2);
    Hmac.pbHmac = rgHmacMD2;
    Hmac.cbKey = sizeof(rgKey3);
    Hmac.pbKey = rgKey3;
    Hmac.aiHash = CALG_MD5;

    if (ERROR_SUCCESS != (dwError = DoHmacTestCase(pThreadData, &Hmac)))
    {
        printf("ERROR: DoHmacTestCase MD5 2\n");
        return dwError;      
    }

    // MD5 Ipsec vector
    ZeroMemory(&Hmac, sizeof(HMAC_TEST));
    Hmac.cbData = sizeof(rgDataIpsecA);
    Hmac.pbData = rgDataIpsecA;
    Hmac.cbData2 = sizeof(rgDataIpsecB);
    Hmac.pbData2 = rgDataIpsecB;
    Hmac.cbHmac = sizeof(rgHmacIpsec);
    Hmac.pbHmac = rgHmacIpsec;
    Hmac.cbKey = sizeof(rgKeyIpsec);
    Hmac.pbKey = rgKeyIpsec;
    Hmac.aiHash = CALG_MD5;

    if (ERROR_SUCCESS != (dwError = DoHmacTestCase(pThreadData, &Hmac)))
    {
        printf("ERROR: DoHmacTestCase MD5 Ipsec\n");
        return dwError;      
    }

    return ERROR_SUCCESS;
}

//
// Function: KeyArchiveRegression
//
// Not thread safe
//
DWORD KeyArchiveRegression(PTHREAD_DATA pThreadData)
{
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hKey = 0;
    DWORD dwError = 0;
    LPSTR pszContainer = "KeyArchiveRegression";
    BYTE rgbKey[2048];
    DWORD cbKey;
    DWORD dwData;
    DWORD cbData;
    BOOL fSuccess = FALSE;

    CryptAcquireContext(
        &hProv, 
        pszContainer, 
        pThreadData->rgszProvName,
        pThreadData->dwProvType,
        CRYPT_DELETEKEYSET);

    if (! CryptAcquireContext(
        &hProv, 
        pszContainer, 
        pThreadData->rgszProvName,
        pThreadData->dwProvType,
        CRYPT_NEWKEYSET))
    {
        printf("CryptAcquireContext newkeyset ");
        goto Ret;
    }

    if (! CryptGenKey(
        hProv,
        AT_SIGNATURE,
        CRYPT_ARCHIVABLE,
        &hKey))
    {
        printf("CryptGenKey archivable ");
        goto Ret;
    }

    cbData = sizeof(dwData);
    if (! CryptGetKeyParam(
        hKey, KP_PERMISSIONS, (PBYTE) &dwData, &cbData, 0))
    {
        printf("CryptGetKeyParam ");
        goto Ret;
    }

    if (! ((CRYPT_ARCHIVE & dwData) && (! (CRYPT_EXPORT & dwData))))
    {
        printf("incorrect KP_PERMISSIONS ");
        goto Ret;
    }

    cbKey = sizeof(rgbKey);
    if (! CryptExportKey(
        hKey,
        0,
        PRIVATEKEYBLOB,
        0,
        rgbKey,
        &cbKey))
    {
        printf("CryptExportKey privatekeyblob ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey))
    {
        printf("CryptDestroyKey ");
        goto Ret;
    }

    if (! CryptReleaseContext(hProv, 0))
    {
        printf("CryptReleaseContext ");
        goto Ret;
    }

    if (! CryptAcquireContext(
        &hProv, 
        pszContainer, 
        pThreadData->rgszProvName,
        pThreadData->dwProvType,
        0))
    {
        printf("CryptAcquireContext ");
        goto Ret;
    }

    if (! CryptGetUserKey(hProv, AT_SIGNATURE, &hKey))
    {
        printf("CryptGetUserKey ");
        goto Ret;
    }

    // try to set the key export/archive perms; should fail
    cbData = sizeof(dwData);
    if (! CryptGetKeyParam(
        hKey, KP_PERMISSIONS, (PBYTE) &dwData, &cbData, 0))
    {
        printf("CryptGetKeyParam ");
        goto Ret;
    }

    dwData |= CRYPT_EXPORT | CRYPT_ARCHIVE;

    // should fail 
    if (CryptSetKeyParam(hKey, KP_PERMISSIONS, (PBYTE) &dwData, 0))
    {
        printf("CryptSetKeyParam should have failed ");
        goto Ret;
    }
    
    // should fail
    cbKey = sizeof(rgbKey);
    if (CryptExportKey(
        hKey,
        0,
        PRIVATEKEYBLOB,
        0,
        rgbKey, 
        &cbKey))
    {
        printf("CryptExportKey should have failed ");
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
        printf("- error 0x%x\n", dwError = GetLastError());
    if (hKey)
        CryptDestroyKey(hKey);
    if (hProv)
        CryptReleaseContext(hProv, 0);

    return dwError;
}

// 
// Function: PlaintextBlobRegression
//
DWORD PlaintextBlobRegression(PTHREAD_DATA pThreadData)
{
    HCRYPTKEY hKey = 0;
    DWORD cbKey = 0;
    PBYTE pbKey = NULL;
    PALGNODE pAlgNode = NULL;
    BLOBHEADER *header = NULL;
    PBYTE pbTemp = NULL;
    DWORD cbData, cb;
    BYTE rgbData[1024];
    BOOL fSuccess = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    DWORD cbKeySize = 0;

    // try an invalid key type
    if (CryptExportKey(
        pThreadData->hSignatureKey,
        0,
        PLAINTEXTKEYBLOB,
        0,
        NULL,
        &cbKey))
    {
        printf("CryptExportKey plaintextkeyblob should have failed ");
        goto Ret;
    }

    // try all the valid key types
    for (pAlgNode = pThreadData->pAlgList; pAlgNode != NULL; pAlgNode = pAlgNode->pNext)
    {
        if (ALG_CLASS_DATA_ENCRYPT != GET_ALG_CLASS(pAlgNode->EnumalgsEx.aiAlgid) 
            || (ALG_TYPE_BLOCK != GET_ALG_TYPE(pAlgNode->EnumalgsEx.aiAlgid)
                && ALG_TYPE_STREAM != GET_ALG_TYPE(pAlgNode->EnumalgsEx.aiAlgid)))
            continue;

        // Plaintext import not supported for CYLINK_MEK
        if (CALG_CYLINK_MEK == pAlgNode->EnumalgsEx.aiAlgid)
            continue;

        /*
        if (PROV_DSS == pThreadData->dwProvType
            || PROV_DSS_DH == pThreadData->dwProvType)
        {
            cbKeySize = pAlgNode->EnumalgsEx.dwMaxLen / 8;
        }
        else
        {
        */
            switch (pAlgNode->EnumalgsEx.aiAlgid)
            {
            case CALG_DES:
                cbKeySize = pAlgNode->EnumalgsEx.dwMaxLen / 8 + 1;
                break;
            case CALG_3DES_112:
                cbKeySize = pAlgNode->EnumalgsEx.dwMaxLen / 8 + 2;
                break;
            case CALG_3DES:
                cbKeySize = pAlgNode->EnumalgsEx.dwMaxLen / 8 + 3;
                break;
            default:
                cbKeySize = pAlgNode->EnumalgsEx.dwMaxLen / 8;
            }
        /*
        }
        */

        printf(
            "Importing Alg: %xh (%s), Size: %d bits\n", 
            pAlgNode->EnumalgsEx.aiAlgid, 
            pAlgNode->EnumalgsEx.szName,
            cbKeySize * 8);

        cbKey = sizeof(BLOBHEADER) + sizeof(DWORD) + cbKeySize;
        if (NULL == (pbKey = (PBYTE) MyAlloc(cbKey)))
            return ERROR_NOT_ENOUGH_MEMORY;

        header = (BLOBHEADER *) pbKey;
        header->aiKeyAlg = pAlgNode->EnumalgsEx.aiAlgid;
        header->bType = PLAINTEXTKEYBLOB;
        header->bVersion = CUR_BLOB_VERSION;
        header->reserved = 0;

        pbTemp = pbKey + sizeof(BLOBHEADER);
        *((DWORD*)pbTemp) = cbKeySize;
        pbTemp += sizeof(DWORD);

        // create some key data
        if (! CryptGenRandom(
            pThreadData->hProv, 
            cbKeySize,
            pbTemp))
        {
            printf("CryptGenRandom ");
            goto Ret;
        }

        if (! CryptImportKey(
            pThreadData->hProv,
            pbKey, cbKey, 0, CRYPT_EXPORTABLE, &hKey))
        {
            printf("CryptImportKey ");
            goto Ret;
        }

        MyFree(pbKey);

        // create some data to encrypt
        if (! CryptGenRandom(
            pThreadData->hProv,
            sizeof(rgbData),
            rgbData))
        {
            printf("CryptGenRandom ");
            goto Ret;
        }

        cbData = sizeof(rgbData);
        cb = cbData / 2;
        if (! CryptEncrypt(
            hKey, 0, TRUE, 0, rgbData, &cb, cbData))
        {
            printf("CryptEncrypt ");
            goto Ret;
        }

        if (! CryptExportKey(
            hKey, 0, PLAINTEXTKEYBLOB, 0, NULL, &cbKey))
        {
            printf("CryptExportKey size ");
            goto Ret;
        }

        if (NULL == (pbKey = (PBYTE) MyAlloc(cbKey)))
            return ERROR_NOT_ENOUGH_MEMORY;

        if (! CryptExportKey(
            hKey, 0, PLAINTEXTKEYBLOB, 0, pbKey, &cbKey))
        {
            printf("CryptExportKey ");
            goto Ret;
        }

        // check the blob
        header = (BLOBHEADER *) pbKey;
        if (pAlgNode->EnumalgsEx.aiAlgid != header->aiKeyAlg)
        {
            printf("header->aiKeyAlg is wrong ");
            goto Ret;
        }
        if (CUR_BLOB_VERSION != header->bVersion)
        {
            printf("header->bVersion is wrong ");
            goto Ret;
        }
        if (0 != header->reserved)
        {
            printf("header->reserved is wrong ");
            goto Ret;
        }
        if (PLAINTEXTKEYBLOB != header->bType)
        {
            printf("header->bType is wrong ");
            goto Ret;
        }

        pbTemp = pbKey + sizeof(BLOBHEADER);
        if (cbKeySize != *((DWORD*)pbTemp))
        {
            printf(
                "blob key size is %d, but should be %d ",
                *((DWORD*)pbTemp),
                cbKeySize);
            goto Ret;
        }

        MyFree(pbKey);
        if (! CryptDestroyKey(hKey))
        {
            printf("CryptDestroyKey ");
            goto Ret;
        }
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
        printf("- error 0x%x\n", dwError = GetLastError());
    if (hKey)
        CryptDestroyKey(hKey);

    return dwError;
}

//
// Function: LoadAesCspRegression
//
DWORD LoadAesCspRegression(PTHREAD_DATA pThreadData)
{
    DWORD dwError = 0;
    BOOL fSuccess = FALSE;
    HMODULE hMod = NULL;

    if (NULL == (hMod = LoadLibraryEx(RSA_AES_CSP, NULL, 0)))
    {
        printf("LoadLibraryEx %s ", RSA_AES_CSP);
        goto Ret;
    }

    if (! FreeLibrary(hMod))
    {
        printf("FreeLibrary %s ", RSA_AES_CSP);
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
        printf("- error 0x%x\n", dwError = GetLastError());

    return dwError;
}

DWORD VerifyPinCallback(PPINCACHE_PINS pPins, PVOID pvData)
{
    DWORD dwReturn = *(DWORD*)pvData;

    PrintBytes(
        "VerifyPinCallback current pin", 
        pPins->pbCurrentPin, pPins->cbCurrentPin);
    
    PrintBytes(
        "VerifyPinCallback new pin",
        pPins->pbNewPin, pPins->cbNewPin);

    return dwReturn;
}

static USHORT l_uTestLogonID;

void SetLogonID(USHORT uLogon)
{
    l_uTestLogonID = uLogon;   
}

void GetLogonID(LUID *pLuid)
{
    memset(pLuid, l_uTestLogonID, sizeof(LUID));
}

BOOL MyGetTokenInformation(
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    LPVOID TokenInformation,
    DWORD TokenInformationLength,
    PDWORD ReturnLength)
{
    NTSTATUS status = NtQueryInformationToken(
                        TokenHandle, TokenInformationClass,
                        TokenInformation, TokenInformationLength,
                        ReturnLength);

    if (TokenStatistics == TokenInformationClass)
    {
        printf("MyGetTokenInformation: intercepted TokenStatistics call\n");
        GetLogonID(&((TOKEN_STATISTICS*) TokenInformation)->AuthenticationId);
    }

    return (S_OK == status);
}

//
// Function: PinCacheRegression
//
DWORD PinCacheRegression(PTHREAD_DATA pThreadData)
{
    DWORD dwError = 0;
    BOOL fSuccess = FALSE;
    PINCACHE_HANDLE hCache = NULL;
    BYTE rgPin[] = { 1, 2, 3, 4 };
    DWORD cbPin = sizeof(rgPin);
    BYTE rgPin2[] = { 5, 6, 7, 8, 9 };
    BYTE *pbPin = NULL;
    PFN_VERIFYPIN_CALLBACK pfnVerifyPin = VerifyPinCallback;
    DWORD dwCallbackReturn;
    PINCACHE_PINS Pins;

    ZeroMemory(&Pins, sizeof(PINCACHE_PINS));

    Pins.cbCurrentPin = sizeof(rgPin);
    Pins.pbCurrentPin = rgPin;

    dwCallbackReturn = 0x7070;
    if (0x7070 != (dwError =
            PinCacheAdd(&hCache, &Pins,
                        pfnVerifyPin, (PVOID) &dwCallbackReturn)))
    {
        printf("PinCacheAdd with callback fail ");
        goto Ret;
    }

    //
    // (0)
    // Cache uninitialized
    //
    SetLogonID(1);
    dwCallbackReturn = ERROR_SUCCESS;
    if (ERROR_SUCCESS != (dwError = 
            PinCacheAdd(&hCache, &Pins,
                        pfnVerifyPin, (PVOID) &dwCallbackReturn)))
    {
        printf("PinCacheAdd ");
        goto Ret;
    }

    if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, NULL, &cbPin)))
    {
        printf("PinCacheQuery NULL for size ");
        goto Ret;
    }

    if (NULL == (pbPin = (PBYTE) MyAlloc(cbPin)))
        return ERROR_NOT_ENOUGH_MEMORY;

    cbPin--;
    if (ERROR_SUCCESS == (dwError = PinCacheQuery(hCache, pbPin, &cbPin)))
    {
        printf("PinCacheQuery insufficient size succeeded ");
        goto Ret;      
    }

    if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, pbPin, &cbPin)))
    {
        printf("PinCacheQuery ");
        goto Ret;
    }

    if (sizeof(rgPin) != RtlCompareMemory(pbPin, rgPin, cbPin))
    {
        PrintBytes("Actual cache", pbPin, cbPin);
        PrintBytes("Expected cache", rgPin, sizeof(rgPin));
        printf("Cache is incorrect ");
        goto Ret;
    }

    PinCacheFlush(&hCache);

    if (NULL != hCache)
    {
        printf("PinCacheFlush should set hCache=NULL ");
        goto Ret;
    }

    // Re-initialize to continue tests
    if (ERROR_SUCCESS != (dwError = 
            PinCacheAdd(&hCache, &Pins,
                        pfnVerifyPin, (PVOID) &dwCallbackReturn)))
    {
        printf("PinCacheAdd ");
        goto Ret;
    }

    //
    // (1)
    // Same LogonID, same Pin
    //
    if (ERROR_SUCCESS != (dwError = 
            PinCacheAdd(&hCache, &Pins, 
                        pfnVerifyPin, (PVOID) &dwCallbackReturn)))
    {
        printf("PinCacheAdd 1 ");
        goto Ret;
    }
    
    cbPin = sizeof(rgPin);
    if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, pbPin, &cbPin)))
    {
        printf("PinCacheQuery 1 ");
        goto Ret;
    }

    if (sizeof(rgPin) != RtlCompareMemory(pbPin, rgPin, cbPin))
    {
        PrintBytes("Actual cache", pbPin, cbPin);
        PrintBytes("Expected cache", rgPin, sizeof(rgPin));
        printf("Cache is incorrect 1 ");
        goto Ret;
    }
    
    // Try a pin change 
    Pins.cbNewPin = sizeof(rgPin2);
    Pins.pbNewPin = rgPin2;

    if (ERROR_SUCCESS != (dwError = 
            PinCacheAdd(&hCache, &Pins, 
                        pfnVerifyPin, (PVOID) &dwCallbackReturn)))
    {
        printf("PinCacheAdd 1 change ");
        goto Ret;
    }
    
    if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, NULL, &cbPin)))
    {
        printf("PinCacheQuery 1 change query ");
        goto Ret;
    }

    MyFree(pbPin);
    pbPin = NULL;
    if (NULL == (pbPin = (PBYTE) MyAlloc(cbPin)))
        return ERROR_NOT_ENOUGH_MEMORY;

    if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, pbPin, &cbPin)))
    {
        printf("PinCacheQuery 1 change ");
        goto Ret;
    }

    if (sizeof(rgPin2) != RtlCompareMemory(pbPin, rgPin2, cbPin))
    {
        PrintBytes("Actual cache", pbPin, cbPin);
        PrintBytes("Expected cache", rgPin, sizeof(rgPin));
        printf("Cache is incorrect 1 change ");
        goto Ret;
    }

    // Try a failed pin change
    Pins.cbCurrentPin = sizeof(rgPin2);
    Pins.pbCurrentPin = rgPin2;
    Pins.cbNewPin = sizeof(rgPin);
    Pins.pbNewPin = rgPin;
    dwCallbackReturn = -1;

    if (-1 != (dwError = 
            PinCacheAdd(&hCache, &Pins, 
                        pfnVerifyPin, (PVOID) &dwCallbackReturn)))
    {
        printf("PinCacheAdd 1 change-fail ");
        goto Ret;
    }

    // Cache should have been preserved
    cbPin = sizeof(rgPin2);
    ZeroMemory(pbPin, sizeof(rgPin2));

    if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, pbPin, &cbPin)))
    {
        printf("PinCacheQuery 1 change-fail ");
        goto Ret;
    }

    if (sizeof(rgPin2) != RtlCompareMemory(pbPin, rgPin2, cbPin))
    {
        PrintBytes("Actual cache", pbPin, cbPin);
        PrintBytes("Expected cache", rgPin2, sizeof(rgPin2));
        printf("Cache is incorrect 1 change-fail ");
        goto Ret;
    }

    //
    // (2)
    // Different LogonID, different Pin
    //
    SetLogonID(2);
    Pins.cbCurrentPin -= 1;
    Pins.cbNewPin = 0;
    Pins.pbNewPin = NULL;
    dwCallbackReturn = ERROR_SUCCESS;
    if (SCARD_W_WRONG_CHV != (dwError = 
            PinCacheAdd(&hCache, &Pins,
                        pfnVerifyPin, (PVOID) &dwCallbackReturn)))
    {
        printf("PinCacheAdd 2 ");
        goto Ret;
    }

    SetLogonID(1);
    cbPin = sizeof(rgPin2);
    if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, pbPin, &cbPin)))
    {
        printf("PinCacheQuery 2 ");
        goto Ret;
    }

    if (sizeof(rgPin2) != RtlCompareMemory(pbPin, rgPin2, cbPin))
    {
        PrintBytes("Actual cache", pbPin, cbPin);
        PrintBytes("Expected cache", rgPin2, sizeof(rgPin2));
        printf("Cache is incorrect 2 ");
        goto Ret;
    }

    //
    // (3)
    // Different LogonID, same Pin
    //
    SetLogonID(2);
    Pins.cbCurrentPin = sizeof(rgPin2);
    if (ERROR_SUCCESS != (dwError = 
            PinCacheAdd(&hCache, &Pins, 
                        pfnVerifyPin, (PVOID) &dwCallbackReturn)))
    {
        printf("PinCacheAdd 3 ");
        goto Ret;
    }

    cbPin = sizeof(rgPin2);
    if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, pbPin, &cbPin)))
    {
        printf("PinCacheQuery 3 ");
        goto Ret;
    }

    if (sizeof(rgPin2) != RtlCompareMemory(pbPin, rgPin2, cbPin))
    {
        PrintBytes("Actual cache", pbPin, cbPin);
        PrintBytes("Expected cache", rgPin2, sizeof(rgPin2));
        printf("Cache is incorrect 3 ");
        goto Ret;
    }

    SetLogonID(1);
    if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, pbPin, &cbPin)))
    {
        printf("PinCacheQuery 3,1 ");
        goto Ret;
    }

    if (0 != cbPin)
    {
        printf("PinCacheQuery 3,1 should have returned NULL pin ");
        goto Ret;
    }

    //
    // (4)
    // Same LogonID, different Pin
    //
    SetLogonID(2);
    Pins.cbCurrentPin -= 1;
    if (SCARD_W_WRONG_CHV != (dwError = 
            PinCacheAdd(&hCache, &Pins, 
                        pfnVerifyPin, (PVOID) &dwCallbackReturn)))
    {
        printf("PinCacheAdd 4 ");
        goto Ret;
    }

    // cache should have been left intact
    cbPin = sizeof(rgPin2);
    if (ERROR_SUCCESS != (dwError = PinCacheQuery(hCache, pbPin, &cbPin)))
    {
        printf("PinCacheQuery 4 ");
        goto Ret;
    }

    if (sizeof(rgPin2) != RtlCompareMemory(pbPin, rgPin2, cbPin))
    {
        PrintBytes("Actual cache", pbPin, cbPin);
        PrintBytes("Expected cache", rgPin2, sizeof(rgPin2));
        printf("Cache is incorrect 4 ");
        goto Ret;
    }

    dwError = ERROR_SUCCESS;
    fSuccess = TRUE;
Ret:
    if (pbPin)
        MyFree(pbPin);

    if (! fSuccess)
    {
        printf("- error 0x%x\n", dwError);
        if (0 == dwError)
            return -1;
    }

    return dwError;
}

//
// Function: VerifyDesKeyParams
//
DWORD VerifyDesKeyParams(
    IN HCRYPTKEY hKey, 
    IN DWORD dwExpectedKeyLen,
    IN DWORD dwExpectedEffectiveKeyLen)
{
    DWORD dwError = 0;
    DWORD dwParam = 0;
    DWORD cb = sizeof(dwParam);
    BOOL fSuccess = FALSE;

    if (! CryptGetKeyParam(hKey, KP_KEYLEN, (PBYTE) &dwParam, &cb, 0))
    {
        dwError = GetLastError();
        printf("CryptGetKeyParam KP_KEYLEN ");
        goto Ret;
    }

    if (dwExpectedKeyLen != dwParam)
    {
        printf(
            "FAIL: VerifyDesKeyParams expected KP_KEYLEN=%d, actual=%d\n",
            dwExpectedKeyLen, dwParam);
        goto Ret;
    }

    if (! CryptGetKeyParam(hKey, KP_EFFECTIVE_KEYLEN, (PBYTE) &dwParam, &cb, 0))
    {
        dwError = GetLastError();
        printf("CryptGetKeyParam KP_EFFECTIVE_KEYLEN ");
        goto Ret;
    }

    if (dwExpectedEffectiveKeyLen != dwParam)
    {
        printf(
            "FAIL: VerifyDesKeyParams expected KP_EFFECTIVE_KEYLEN=%d, actual=%d\n",
            dwExpectedEffectiveKeyLen, dwParam);
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
    {
        printf(" - error 0x%x\n", dwError);
        if (0 == dwError)
            dwError = -1;
    }

    return dwError;
}

//
// Function: DesGetKeyParamRegression
//
DWORD DesGetKeyParamRegression(PTHREAD_DATA pThreadData)
{
    DWORD dwError                   = ERROR_SUCCESS;
    BOOL fSuccess                   = FALSE;
    HCRYPTKEY hKey                  = 0;

    if (! CryptGenKey(pThreadData->hProv, CALG_DES, 0, &hKey))
    {
        dwError = GetLastError();
        printf("CryptGenKey des ");
        goto Ret;
    }

    if (ERROR_SUCCESS != (dwError = VerifyDesKeyParams(hKey, 64, 56)))
    {
        printf("VerifyDesKeyParams des ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey))
    {
        dwError = GetLastError();
        printf("CryptDestroyKey des ");
        goto Ret;
    }
    hKey = 0;

    if (! CryptGenKey(pThreadData->hProv, CALG_3DES_112, 0, &hKey))
    {
        dwError = GetLastError();
        printf("CryptGenKey 3des_112 ");
        goto Ret;
    }

    if (ERROR_SUCCESS != (dwError =  VerifyDesKeyParams(hKey, 128, 112)))
    {
        printf("VerifyDesKeyParams 3des_112 ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey))
    {
        dwError = GetLastError();
        printf("CryptDestroyKey 3des_112 ");
        goto Ret;
    }
    hKey = 0;

    if (! CryptGenKey(pThreadData->hProv, CALG_3DES, 0, &hKey))
    {
        dwError = GetLastError();
        printf("CryptGenKey 3des ");
        goto Ret;
    }

    if (ERROR_SUCCESS != (dwError = VerifyDesKeyParams(hKey, 192, 168)))
    {
        printf("VerifyDesKeyParams 3des ");
        goto Ret;
    }

    if (! CryptDestroyKey(hKey))
    {
        dwError = GetLastError();
        printf("CryptDestroyKey 3des ");
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
    {
        printf("- error 0x%x\n", dwError);
        if (0 == dwError)
            return -1;
    }

    return dwError;
}

//
// Function: MacEncryptRegression
//
DWORD MacEncryptRegression(
    IN PTHREAD_DATA pThreadData)
{
    DWORD dwError                   = ERROR_SUCCESS;
    BOOL fSuccess                   = FALSE;
    HCRYPTKEY hSymKey               = 0;
    HCRYPTKEY hMacKey               = 0;
    HCRYPTKEY hMacKey2              = 0;
    HCRYPTHASH hMac                 = 0;
    BYTE rgPlaintext[31];
    DWORD cb                        = sizeof(rgPlaintext);
    DWORD cbBuf                     = 0;
    PBYTE pbMac                     = NULL;
    DWORD cbMac                     = 0;
    PBYTE pb                        = NULL;

    if (! CryptGenKey(pThreadData->hProv, CALG_RC2, 0, &hSymKey))
    {
        printf("CryptGenKey rc2");
        goto Ret;
    }

    if (! CryptGenKey(pThreadData->hProv, CALG_RC2, 0, &hMacKey))
    {
        printf("CryptGenKey rc2 2");
        goto Ret;
    }

    if (! CryptDuplicateKey(hMacKey, NULL, 0, &hMacKey2))
    {
        printf("CryptDuplicateKey");
        goto Ret;
    }

    if (! CryptCreateHash(pThreadData->hProv, CALG_MAC, hMacKey, 0, &hMac))
    {
        printf("CryptCreateHash");
        goto Ret;
    }

    while (cb--)
        rgPlaintext[cb] = (BYTE) cb;

    cb = sizeof(rgPlaintext);
    if (! CryptEncrypt(hSymKey, 0, TRUE, 0, NULL, &cb, 0))
    {
        printf("CryptEncrypt size");
        goto Ret;
    }

    if (NULL == (pb = (PBYTE) MyAlloc(cb)))
        return ERROR_NOT_ENOUGH_MEMORY;

    cbBuf = cb;
    cb = sizeof(rgPlaintext);
    if (! CryptEncrypt(hSymKey, hMac, TRUE, 0, pb, &cb, cbBuf))
    {
        printf("CryptEncrypt");
        goto Ret;
    }

    if (! CryptGetHashParam(hMac, HP_HASHVAL, NULL, &cbMac, 0))
    {
        printf("CryptGetHashParam size");
        goto Ret;
    }

    if (NULL == (pbMac = (PBYTE) MyAlloc(cbMac)))
        return ERROR_NOT_ENOUGH_MEMORY;

    if (! CryptGetHashParam(hMac, HP_HASHVAL, pbMac, &cbMac, 0))
    {
        printf("CryptGetHashParam");
        goto Ret;
    }

    if (! CryptDestroyHash(hMac))
    {
        printf("CryptDestroyHash");
        goto Ret;
    }
    hMac = 0;

    if (! CryptCreateHash(pThreadData->hProv, CALG_MAC, hMacKey2, 0, &hMac))
    {
        printf("CryptCreateHash 2");
        goto Ret;
    }

    if (! CryptDecrypt(hSymKey, hMac, TRUE, 0, pb, &cb))
    {
        printf("CryptDecrypt");
        goto Ret;
    }

    MyFree(pb);
    pb = NULL;

    if (! CryptGetHashParam(hMac, HP_HASHVAL, NULL, &cb, 0))
    {
        printf("CryptGetHashParam size");
        goto Ret;
    }

    if (NULL == (pb = (PBYTE) MyAlloc(cb)))
        return ERROR_NOT_ENOUGH_MEMORY;

    if (! CryptGetHashParam(hMac, HP_HASHVAL, pb, &cb, 0))
    {
        printf("CryptGetHashParam");
        goto Ret;
    }

    PrintBytes("Expected Mac result", pbMac, cbMac);
    PrintBytes("Actual Mac result", pb, cb);

    if (0 != memcmp(pb, pbMac, cb) 
        || 0 == cb
        || cb != cbMac)
    {
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
    {
        dwError = GetLastError();
        printf(" - error 0x%x\n", dwError);
        if (0 == dwError)
            dwError = -1;
    }

    if (pb)
        MyFree(pb);
    if (pbMac)
        MyFree(pbMac);
    if (hSymKey)
        CryptDestroyKey(hSymKey);
    if (hMacKey)
        CryptDestroyKey(hMacKey);
    if (hMacKey2)
        CryptDestroyKey(hMacKey2);
    if (hMac)
        CryptDestroyHash(hMac);
    
    return dwError;
}

//
// Function: StressEncryptionTest
//
DWORD StressEncryptionTest(
    IN HCRYPTPROV hProv,
    IN PENCRYPTION_TEST_DATA pTestData)
{
    HCRYPTKEY hEncryptionKey        = 0;
    HCRYPTKEY hHashKey1             = 0;
    HCRYPTKEY hHashKey2             = 0;
    HCRYPTHASH hHash                = 0;
    PBYTE pbData                    = 0;
    DWORD dwData                    = 0;
    DWORD cbData                    = 0;
    DWORD cbPlainText               = 0;
    DWORD cbCipherText              = 0;
    DWORD cbProcessed               = 0;
    DWORD dwKeyAlg                  = 0;
    DWORD dwBlockLen                = 0;
    BOOL fFinal                     = FALSE;
    DWORD dwError                   = 0;
    BOOL fSuccess                   = FALSE;
    BYTE rgbHashVal1[200];
    BYTE rgbHashVal2[200];

    ZeroMemory(rgbHashVal1, 200);
    ZeroMemory(rgbHashVal2, 200);

    if (! CryptGenKey(
        hProv,
        pTestData->aiEncryptionKey,
        0,
        &hEncryptionKey))
    {
        goto Cleanup;
    }

    //
    // Check for requested simultaneous encryption/hashing
    //
    if (pTestData->aiHash)
    {
        // 
        // Is this a keyed hash?
        //
        if (pTestData->aiHashKey)
        {
            if (! CryptGenKey(
                hProv,
                pTestData->aiHashKey,
                0,
                &hHashKey1))
            {
                goto Cleanup;
            }

            //
            // To verify the result of hashing the same data in two 
            // separate keyed hashes, the key must first be duplicated,
            // since its state changes once it's used.
            //
            if (! CryptDuplicateKey(
                hHashKey1,
                NULL,
                0,
                &hHashKey2))
            {
                goto Cleanup;
            }
        }

        if (! CryptCreateHash(
            hProv,
            pTestData->aiHash,
            hHashKey1,
            0,
            &hHash))
        {
            goto Cleanup;
        }
    }

    //
    // Is this a block encryption alg?
    //
    if (ALG_TYPE_BLOCK & pTestData->aiEncryptionKey)
    {
        //
        // Get the block size of this encryption alg
        //
        cbData = sizeof(dwBlockLen);
        if (! CryptGetKeyParam(
            hEncryptionKey,
            KP_BLOCKLEN,
            (PBYTE) &dwBlockLen,
            &cbData,
            0))
        {
            goto Cleanup;
        }

        //
        // Choose an "interesting" plaintext length, based on the block length
        // of this alg.  
        //
        cbPlainText = 2 * dwBlockLen + 1;
    }
    else
    {
        // 
        // Plaintext length for a stream encryption alg
        //
        cbPlainText = 500;
    }

    cbCipherText = cbPlainText; 

    //
    // Determine size of ciphertext
    //
    if (! CryptEncrypt(
        hEncryptionKey,
        0,
        TRUE,
        0,
        NULL,
        &cbCipherText,
        0))
    {
        goto Cleanup;
    }

    if (NULL == (pbData = (PBYTE) MyAlloc(cbCipherText)))
    {
        goto Cleanup;
    }

    //
    // Initialize the plaintext
    //
    memset(pbData, 0xDA, cbPlainText);
    memset(pbData + cbPlainText, 0, cbCipherText - cbPlainText);

    // 
    // Encrypt
    //
    cbProcessed = 0;
    while (! fFinal)
    {
        if (0 == dwBlockLen)
        {
            cbData = cbPlainText;
            fFinal = TRUE;
        }
        else
        {           
            if (cbPlainText - cbProcessed > dwBlockLen)
            {
                cbData = dwBlockLen;
            }
            else
            {
                cbData = cbPlainText % dwBlockLen;
                fFinal = TRUE;
            }
        }

        if (! CryptEncrypt(
            hEncryptionKey,
            hHash,
            fFinal,
            0,
            pbData + cbProcessed,
            &cbData,
            cbCipherText))
        {
            goto Cleanup;
        }

        cbProcessed += cbData;
    }

    if (cbProcessed != cbCipherText)
    {
        goto Cleanup;
    }

    if (0 != hHash)
    {
        //
        // Get hash result from encryption
        //
        cbData = sizeof(rgbHashVal1);
        if (! CryptGetHashParam(
            hHash,
            HP_HASHVAL,
            rgbHashVal1,
            &cbData,
            0))
        {
            goto Cleanup;
        }

        if (! CryptDestroyHash(hHash))
        {
            goto Cleanup;
        }

        if (! CryptCreateHash(
            hProv,
            pTestData->aiHash,
            hHashKey2,
            0,
            &hHash))
        {
            goto Cleanup;
        }
    }

    //
    // Decrypt
    //
    cbProcessed = 0;
    fFinal = FALSE;
    while (! fFinal)
    {
        if (0 == dwBlockLen)
        {
            cbData = cbCipherText;
            fFinal = TRUE;
        }
        else
        {
            if (cbCipherText - cbProcessed > dwBlockLen)
            {
                cbData = dwBlockLen;
            }
            else
            {
                cbData = cbCipherText - cbProcessed;
                fFinal = TRUE;
            }
        }

        if (! CryptDecrypt(
            hEncryptionKey,
            hHash,
            fFinal,
            0,
            pbData + cbProcessed,
            &cbData))
        {
            goto Cleanup;
        }

        cbProcessed += cbData;
    }

    if (cbProcessed != cbPlainText)
    {
        goto Cleanup;
    }

    while (cbPlainText)
    {
        if (0xDA != pbData[cbPlainText - 1])
        {
            goto Cleanup;
        }
        cbPlainText--;
    }

    if (0 != hHash)
    {
        //
        // Get hash result from decryption
        //
        cbData = sizeof(rgbHashVal2);
        if (! CryptGetHashParam(
            hHash,
            HP_HASHVAL,
            rgbHashVal2,
            &cbData,
            0))
        {
            goto Cleanup;
        }

        if (0 != memcmp(rgbHashVal1, rgbHashVal2, cbData))
        {
            goto Cleanup;
        }
    }

    fSuccess = TRUE;
Cleanup:
    if (! fSuccess)
    {
        if (0 == (dwError = GetLastError()))
        {
            dwError = -1;
        }
    }
    if (hEncryptionKey)
    {
        CryptDestroyKey(hEncryptionKey);
    }
    if (hHashKey1)
    {
        CryptDestroyKey(hHashKey1);
    }
    if (hHashKey2)
    {
        CryptDestroyKey(hHashKey2);
    }
    if (hHash)
    {
        CryptDestroyHash(hHash);
    }
    if (pbData)
    {
        MyFree(pbData);
    }

    return dwError;
}

//
// Function: StressTestAllEncryptionAlgs
//
DWORD StressTestAllEncryptionAlgs(
    PTHREAD_DATA pThreadData,
    BOOL fContinueOnMacError,
    BOOL *pfMacErrorOccurred)
{
    DWORD dwError = 0;
    ENCRYPTION_TEST_DATA TestData;
    PALGNODE pEncryptionAlg, pHashAlg, pBlockEncryptionAlg;

    ZeroMemory(&TestData, sizeof(TestData));

    for (   pEncryptionAlg = pThreadData->pAlgList; 
            NULL != pEncryptionAlg;
            pEncryptionAlg = pEncryptionAlg->pNext)
    {
        if (! (pEncryptionAlg->EnumalgsEx.aiAlgid & ALG_CLASS_DATA_ENCRYPT))
            continue;

        TestData.aiEncryptionKey = pEncryptionAlg->EnumalgsEx.aiAlgid;

        for (   pHashAlg = pThreadData->pAlgList;
                NULL != pHashAlg;
                pHashAlg = pHashAlg->pNext)
        {
            if (    (! (pHashAlg->EnumalgsEx.aiAlgid & ALG_CLASS_HASH &&
                        pHashAlg->EnumalgsEx.aiAlgid & ALG_TYPE_ANY)) ||
                    CALG_SSL3_SHAMD5 == pHashAlg->EnumalgsEx.aiAlgid ||
                    CALG_TLS1PRF == pHashAlg->EnumalgsEx.aiAlgid)
                continue;

            TestData.aiHash = pHashAlg->EnumalgsEx.aiAlgid;

            if (CALG_MAC == pHashAlg->EnumalgsEx.aiAlgid)
            {
                for (   pBlockEncryptionAlg = pThreadData->pAlgList;
                        NULL != pBlockEncryptionAlg;
                        pBlockEncryptionAlg = pBlockEncryptionAlg->pNext)
                {
                    if (! ( pBlockEncryptionAlg->EnumalgsEx.aiAlgid & ALG_CLASS_DATA_ENCRYPT &&
                            pBlockEncryptionAlg->EnumalgsEx.aiAlgid & ALG_TYPE_BLOCK))
                        continue;

                    TestData.aiHashKey = pBlockEncryptionAlg->EnumalgsEx.aiAlgid;

                    if (ERROR_SUCCESS != (dwError = StressEncryptionTest(pThreadData->hProv, &TestData)))
                    {
                        if (fContinueOnMacError)
                            *pfMacErrorOccurred = TRUE;
                        else
                            return dwError;
                    }
                }
            }
            else
            {
                if (ERROR_SUCCESS != (dwError = StressEncryptionTest(pThreadData->hProv, &TestData)))
                    return dwError;
            }
        }
    }

    return dwError;
}

//+ ===========================================================================
//- ===========================================================================
void L_ErrorBox(LPSTR pszMsg, DWORD dwThreadNum)
{
    char szErrorMsg[256] ;
    sprintf(szErrorMsg, "Thread %d: %s in L_ErrorBox", dwThreadNum, pszMsg) ;
    MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
}


//+ ===========================================================================
//- ===========================================================================
void L_LastErrorBox(LPSTR pszMsg, DWORD dwThreadNum)
{
    char szErrorMsg[256] ;
    sprintf(szErrorMsg, "Thread %d: %s 0x%x in L_LastErrorBox", dwThreadNum, pszMsg, GetLastError()) ;
    MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
}



//+ =================================================================================
//
//  L_GetKeyAlg
//  Local function that given a key handle, returns the key Alg.
//  
//- =================================================================================
DWORD   L_GetKeyAlg(HCRYPTKEY hKey)
{
    DWORD   dwData = 0;
    DWORD   cbData=0 ;
    char szErrorMsg[256];

    cbData = sizeof(dwData) ;
    
    if (!CryptGetKeyParam(
        hKey,
        KP_ALGID,
        (PBYTE) &dwData,
        &cbData,
        0))
    {
        GENERIC_FAIL(CryptGetKeyParam) ;
    }

ErrorReturn:
    return dwData;
}



//+ =================================================================================
//
//  L_GetKeySize
//  Local function that given a key handle, returns the key length.
//  
//- =================================================================================
DWORD   L_GetKeySize(HCRYPTKEY hKey)
{
    DWORD   dwData = 0;
    DWORD   cbData=0 ;
    char szErrorMsg[256];
 
    cbData = sizeof(dwData) ;
 
    if (!CryptGetKeyParam(
        hKey,
        KP_KEYLEN,
        (PBYTE) &dwData,
        &cbData,
        0))
    {
        GENERIC_FAIL(CryptGetKeyParam) ;
    }

ErrorReturn:
    return dwData;
}

//+ ==============================================================================
//- ==============================================================================
DWORD   Hlp_GetKeyAlgId(HCRYPTKEY hKey)
{
    DWORD   dwRetVal=0 ;
    PBYTE   pbData=NULL ;
    DWORD   cbData=sizeof(DWORD) ;
    char    szErrorMsg[256] ; 
    DWORD   dwAlgId=0 ;

    if (!CryptGetKeyParam(
                    hKey,
                    KP_ALGID,
                    (PBYTE)&dwAlgId,
                    &cbData,
                    0))
        GENERIC_FAIL(CryptGetKeyParam) ;


    dwRetVal=dwAlgId ;
    
    ErrorReturn :
    return dwRetVal ;
}




//+ =================================================================================
//
//  L_GetKeyParam
//  Local function that given a key handle, retrieves the specified Key Param.
//  The Key param is not of too much interest in this case. In a multithread scenario,
//  we just care to see if the call succeeds. 
//  
//- =================================================================================
DWORD   L_GetKeyParam(HCRYPTKEY hKey, DWORD dwParam)
{
    DWORD   dwRetVal=0 ;
    PBYTE   pbData=NULL ;
    DWORD   cbData=0 ;
    char    szErrorMsg[256] ; 
    DWORD   dwAlgId=0 ;
    DWORD   dwError=0 ;

    if (!CryptGetKeyParam(  hKey,
                            dwParam,
                            NULL,
                            &cbData,
                            0))
        GENERIC_FAIL(CryptGetKeyParam) ;

    if (NULL == (pbData = (PBYTE) MyAlloc(cbData)))
        ALLOC_FAIL(pbData);

    if (!CryptGetKeyParam(  hKey,
                            dwParam,
                            pbData,
                            &cbData,
                            0))
        GENERIC_FAIL(CryptGetKeyParam) ;

    dwRetVal=1 ;
    
    ErrorReturn :
    MyFree(pbData) ;
    return dwRetVal ;
}




//+ ======================================================================================
//  ProgramInit
//  Acquire context
//  Generate Keys that will be used by all the threads. (AT_SIGNATURE and AT_KEYEXCHANGE)
//- ======================================================================================
DWORD ProgramInit(PTHREAD_DATA pThreadData)
{
    DWORD   dwRetVal                = 0;
    char    szErrorMsg[256];        //  defined for GENERIC_FAIL
    LPSTR   pszContainer            = NULL;
    DWORD   dwContextFlags          = 0;
    DWORD   dwKeyFlags              = CRYPT_EXPORTABLE;

    if (pThreadData->fEphemeralKeys)
    {
        dwContextFlags = CRYPT_VERIFYCONTEXT;
    }
    else
    {
        pszContainer = KEY_CONTAINER_NAME;
        dwContextFlags = CRYPT_NEWKEYSET;

        CryptAcquireContext(
            &pThreadData->hProv,
            pszContainer,
            pThreadData->rgszProvName,
            pThreadData->dwProvType,
            CRYPT_DELETEKEYSET);

        // Create a Verify Context for some of the sub-tests to use
        if (! CryptAcquireContext(
            &pThreadData->hVerifyCtx, 
            NULL, 
            pThreadData->rgszProvName, 
            pThreadData->dwProvType, 
            CRYPT_VERIFYCONTEXT))
        {
            pThreadData->hVerifyCtx = 0;
            GENERIC_FAIL(CryptAcquireContext_VERIFYCONTEXT);
        }
    }

    if (pThreadData->fUserProtectedKeys)
        dwKeyFlags |= CRYPT_USER_PROTECTED;
    
    if (!CryptAcquireContext(
        &pThreadData->hProv,
        pszContainer, 
        pThreadData->rgszProvName,
        pThreadData->dwProvType, 
        dwContextFlags))
    {
        pThreadData->hProv = 0;
        GENERIC_FAIL(CryptAcquireContext_Init);
    }
    
    //  Generate a sign and exchange key
    if (!CryptGenKey(
        pThreadData->hProv,
        AT_SIGNATURE, 
        dwKeyFlags, 
        &pThreadData->hSignatureKey))
    {
        GENERIC_FAIL(CryptGenKey_AT_SIGNATURE);
        CryptReleaseContext(pThreadData->hProv, 0);
        pThreadData->hProv = 0;
        pThreadData->hSignatureKey = 0;              
    }
    
    if (PROV_RSA_FULL == pThreadData->dwProvType ||
        PROV_DSS_DH == pThreadData->dwProvType)
    {
        if (!CryptGenKey(
            pThreadData->hProv,
            AT_KEYEXCHANGE, 
            dwKeyFlags, 
            &pThreadData->hExchangeKey))
        {
            GENERIC_FAIL(CryptGenKey_AT_KEYEXCHANGE);
            CryptReleaseContext(pThreadData->hProv, 0);
            pThreadData->hProv = 0;
            pThreadData->hExchangeKey = 0;                    
        }
    }

    dwRetVal=1;

ErrorReturn:
    return dwRetVal;
}

// ======================================================================================
//  Terminates all the threads after the specified amount of time has elapsed (-t option)
//  This thread sleeps for the specified amount of time and them then turns off the 
//  g_dwLoopSwitch.
// ======================================================================================
void WINAPI KillProgramTimer(LPVOID pvThreadData)
{
    DWORD   dwSleepTime=0;
    PTHREAD_DATA pThreadData = (PTHREAD_DATA) pvThreadData;
    
    if (pThreadData->dwProgramMins)
    {
        dwSleepTime = pThreadData->dwProgramMins * 60 * 1000;

        SleepEx(dwSleepTime, FALSE);

        if (! SetEvent(pThreadData->hEndTestEvent))
        {
            printf("SetEvent() failed, 0x%x\n", GetLastError());
            exit(1);
        }

        printf("All threads should be shutting down now....\n");
    }
}


// ======================================================================================
//  Prints the status of all the threads
//  The status is represented in iteration count in ThreadStatus[i][0]
// ======================================================================================
void WINAPI PrintThreadStatus(LPVOID pvThreadData)
{
    DWORD thread;
    PTHREAD_DATA pThreadData = (PTHREAD_DATA) pvThreadData;
    char rgStatus[256] ;

    printf("\n\n\n") ;
    while (WAIT_TIMEOUT == WaitForSingleObject(pThreadData->hEndTestEvent, 0))
    {
        Sleep(10000);
        ZeroMemory(rgStatus, sizeof(rgStatus));

        for (thread = 0; thread < pThreadData->dwThreadCount; thread++)
        {
            sprintf(
                rgStatus + strlen(rgStatus),
                " %4x",
                pThreadData->rgdwThreadStatus[thread]);
        }

        printf("%s\n", rgStatus);
    }
}

//+ ========================================================================
//
//      Function    :   L_GetAllKeyParams
//      Purpose     :   Gets all the key params and does nothing with it
//
//- ========================================================================
DWORD   L_GetAllKeyParams(HCRYPTKEY hKey, DWORD dwThreadNum) 
{
    char        szErrorMsg[256] ; 
    ALG_ID      AlgId=0 ;
    DWORD       dwRetVal=0 ;

    AlgId = (ALG_ID)Hlp_GetKeyAlgId(hKey) ;
    
    //  Get Keys Length
    if (!L_GetKeyParam(hKey, KP_KEYLEN))
    {
        sprintf(szErrorMsg, "Thread %d: L_GetKeyParam KP_KEYLEN error 0x%x", 
                            dwThreadNum, GetLastError()) ;
        MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
        goto ErrorReturn ;
    }

    //  Get ALGID
    if (!L_GetKeyParam(hKey, KP_ALGID))
    {
        sprintf(szErrorMsg, "Thread %d: L_GetKeyParam KP_ALGID  error 0x%x", 
                            dwThreadNum, GetLastError()) ;
        MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
        goto ErrorReturn ;
    }
    

    //  Get KP_BLOCKLEN
    //  Although this is meaningful only for block cipher keys, it will not fail 
    //  for RSA Keys. It'll just return 0 as the block len (which we don't care 
    //  about for multi tests.
    if (!L_GetKeyParam(hKey, KP_BLOCKLEN))
    {
        sprintf(szErrorMsg, "Thread %d: L_GetKeyParam KP_BLOCKLEN  error 0x%x", 
                            dwThreadNum, GetLastError()) ;
        MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
        goto ErrorReturn ;
    }

    /*
    if (! (ALG_CLASS_SIGNATURE == GET_ALG_CLASS(AlgId) 
            || ALG_CLASS_KEY_EXCHANGE == GET_ALG_CLASS(AlgId)))
    {
        if (!L_GetKeyParam(hKey, KP_SALT))
        {
            sprintf(szErrorMsg, "Thread %d: L_GetKeyParam KP_SALT error 0x%x", 
                                dwThreadNum, GetLastError()) ;
            MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
            goto ErrorReturn ;
        }
    }
    */

    //  Get KP_PERMISSIONS
    if (!L_GetKeyParam(hKey, KP_PERMISSIONS))
    {
        sprintf(szErrorMsg, "Thread %d: L_GetKeyParam KP_PERMISSION  error 0x%x", 
                            dwThreadNum, GetLastError()) ;
        MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
        goto ErrorReturn ;
    }



    //  Effective KeyLen can be queried only for RC2 key
    if (CALG_RC2 == AlgId)
    {
        //  Get KP_EFFECTIVE_KEYLEN
        if (!L_GetKeyParam(hKey, KP_EFFECTIVE_KEYLEN))
        {
            sprintf(szErrorMsg, "Thread %d: L_GetKeyParam KP_EFFECTIVE_KEYLEN  error 0x%x", 
                                dwThreadNum, GetLastError()) ;
            MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
            goto ErrorReturn ;
        }
    }


    //  These Key Params are good only for Block Cipher Keys
    if (ALG_TYPE_BLOCK == GET_ALG_TYPE(AlgId) 
        && ALG_CLASS_DATA_ENCRYPT == GET_ALG_CLASS(AlgId))
    {
        //  Get KP_IV
        if (!L_GetKeyParam(hKey, KP_IV))
        {
            sprintf(szErrorMsg, "Thread %d: L_GetKeyParam KP_IV  error 0x%x", 
                                dwThreadNum, GetLastError()) ;
            MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
            goto ErrorReturn ;
        }

        //  Get KP_PADDING
        if (!L_GetKeyParam(hKey, KP_PADDING))
        {
            sprintf(szErrorMsg, "Thread %d: L_GetKeyParam KP_PADDING  error 0x%x", 
                                dwThreadNum, GetLastError()) ;
            MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
            goto ErrorReturn ;
        }

        //  Get KP_MODE
        if (!L_GetKeyParam(hKey, KP_MODE))
        {
            sprintf(szErrorMsg, "Thread %d: L_GetKeyParam KP_MODE  error 0x%x", 
                                dwThreadNum, GetLastError()) ;
            MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
            goto ErrorReturn ;
        }

        //  Get KP_MODE_BITS
        if (!L_GetKeyParam(hKey, KP_MODE_BITS))
        {
            sprintf(szErrorMsg, "Thread %d: L_GetKeyParam KP_MODE_BITS  error 0x%x", 
                                dwThreadNum, GetLastError()) ;
            MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
            goto ErrorReturn ;
        }
    }

        
    dwRetVal=1 ;
    
    ErrorReturn :
    return dwRetVal ;
}


/*
    L_ProvParam2Text

    dangriff -- Modifying this function so that caller must free the psz 
            return value.
*/
char *L_ProvParam2Text(DWORD dwParam)
{
    LPSTR pszProvParamText = NULL;

    if (NULL == (pszProvParamText = (LPSTR) MyAlloc(PROV_PARAM_BUFFER_SIZE)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    switch(dwParam)
    {
        case PP_ENUMALGS :
            strcpy(pszProvParamText, "PP_ENUMALGS") ;
        break ;
        case PP_ENUMCONTAINERS :
            strcpy(pszProvParamText, "PP_ENUMCONTAINERS") ;
        break ;
        case PP_IMPTYPE :
            strcpy(pszProvParamText, "PP_IMPTYPE") ;
        break ;
        case PP_NAME :
            strcpy(pszProvParamText, "PP_NAME") ;
        break ;
        case PP_VERSION :
            strcpy(pszProvParamText, "PP_VERSION") ;
        break ;
        case PP_CONTAINER :
            strcpy(pszProvParamText, "PP_CONTAINER") ;
        break ;
        case PP_CHANGE_PASSWORD :
            strcpy(pszProvParamText, "PP_CHANGE_PASSWORD") ;
        break ;
        case PP_KEYSET_SEC_DESCR :
            strcpy(pszProvParamText, "PP_KEYSET_SEC_DESCR") ;
        break ;
        case PP_CERTCHAIN :
            strcpy(pszProvParamText, "PP_CERTCHAIN") ;
        break ;
        case PP_KEY_TYPE_SUBTYPE :
            strcpy(pszProvParamText, "PP_KEY_TYPE_SUBTYPE") ;
        break ;
        case PP_PROVTYPE :
            strcpy(pszProvParamText, "PP_PROVTYPE") ;
        break ;
        case PP_KEYSTORAGE :
            strcpy(pszProvParamText, "PP_KEYSTORAGE") ;
        break ;
        case PP_APPLI_CERT :
            strcpy(pszProvParamText, "PP_APPLI_CERT") ;
        break ;
        case PP_SYM_KEYSIZE :
            strcpy(pszProvParamText, "PP_SYM_KEYSIZE") ;
        break ;
        case PP_SESSION_KEYSIZE :
            strcpy(pszProvParamText, "PP_SESSION_KEYSIZE") ;
        break ;
        case PP_UI_PROMPT :
            strcpy(pszProvParamText, "PP_UI_PROMPT") ;
        break ;
        case PP_ENUMALGS_EX :
            strcpy(pszProvParamText, "PP_ENUMALGS_EX") ;
        break ;
        case PP_ENUMMANDROOTS :
            strcpy(pszProvParamText, "PP_ENUMMANDROOTS") ;
        break ;
        case PP_ENUMELECTROOTS :
            strcpy(pszProvParamText, "PP_ENUMELECTROOTS") ;
        break ;
        case PP_KEYSET_TYPE :
            strcpy(pszProvParamText, "PP_KEYSET_TYPE") ;
        break ;
        case PP_ADMIN_PIN :
            strcpy(pszProvParamText, "PP_ADMIN_PIN") ;
        break ;
        case PP_KEYEXCHANGE_PIN :
            strcpy(pszProvParamText, "PP_KEYEXCHANGE_PIN") ;
        break ;
        case PP_SIGNATURE_PIN :
            strcpy(pszProvParamText, "PP_SIGNATURE_PIN") ;
        break ;
        case PP_SIG_KEYSIZE_INC :
            strcpy(pszProvParamText, "PP_SIG_KEYSIZE_INC") ;
        break ;
        case PP_KEYX_KEYSIZE_INC :
            strcpy(pszProvParamText, "PP_KEYX_KEYSIZE_INC") ;
        break ;
        case PP_UNIQUE_CONTAINER :
            strcpy(pszProvParamText, "PP_UNIQUE_CONTAINER") ;
        break ;
        case PP_SGC_INFO :
            strcpy(pszProvParamText, "PP_SGC_INFO") ;
        break ;
        case PP_USE_HARDWARE_RNG :
            strcpy(pszProvParamText, "PP_USE_HARDWARE_RNG") ;
        break ;
        case PP_KEYSPEC :
            strcpy(pszProvParamText, "PP_KEYSPEC") ;
        break ;
        case PP_ENUMEX_SIGNING_PROT :
            strcpy(pszProvParamText, "PP_ENUMEX_SIGNING_PROT") ;
        break ;
    }
    return pszProvParamText ;
}



//+ ==================================================================
//      
//      Function    :   L_GetProvParam
//      Purpose     :   Gets the requested Prov Param
//                      Does nothing with the ProvParam
//                      Has special logic for all enumeration params
//
//- ==================================================================
DWORD L_GetProvParam(HCRYPTPROV hProv, DWORD dwParam, DWORD dwThreadNum)
{
    PBYTE   pbProvData=NULL ;
    DWORD   cbProvData=0 ;
    DWORD   dwFlags=0 ;
    DWORD   dwEnumFlag=0 ;
    char    szErrorMsg[256] ;
    DWORD   dwRetVal=0 ;
    LPSTR pszProvParamText = NULL;
    DWORD   dwError = 0;

    if ((PP_ENUMALGS == dwParam) ||
        (PP_ENUMALGS_EX == dwParam) ||
        (PP_ENUMCONTAINERS == dwParam))
    {
        dwEnumFlag = 1 ;
        dwFlags = CRYPT_FIRST ;
    }


    //  dwFlags needs to be set in the case of PP_KEYSET_SECR_DECR
    if (PP_KEYSET_SEC_DESCR == dwParam)
    {
        dwFlags = SACL_SECURITY_INFORMATION ;
    }


    if (!CryptGetProvParam( hProv,
                            dwParam,
                            NULL,
                            &cbProvData,
                            dwFlags))
    {
        if ((ERROR_PRIVILEGE_NOT_HELD == (dwError = GetLastError())) &&
            (PP_KEYSET_SEC_DESCR == dwParam))
        {
            //  At this point the test has done it's job. The call is an expected failure call
            //  so we aren't going to try and make any more. 
            //  This call with fail with that expected LastError.
            dwRetVal=1 ;
            goto ErrorReturn ;
        }
        else
        {
            pszProvParamText = L_ProvParam2Text(dwParam);
            sprintf(szErrorMsg, "Thread %d: CryptGetProvParam 1 %s error 0x%x", 
                                dwThreadNum, pszProvParamText, dwError) ;
            MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
            MyFree(pszProvParamText);
            goto ErrorReturn ;
        }
    }

    if (NULL == (pbProvData = (PBYTE) MyAlloc(cbProvData)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }
    
    //  If this is an enumeration, keep calling the function until 
    //  the enumeration reaches the end.
    do
    {
        if (!CryptGetProvParam( hProv,
                                dwParam,
                                pbProvData,
                                &cbProvData,
                                dwFlags))
        {
            //  Have we reached the end of the enumeration ? If yes, flag it.
            if (ERROR_NO_MORE_ITEMS == (dwError = GetLastError()))
            {
                dwEnumFlag=0 ;
            }
            else
            {
                pszProvParamText = L_ProvParam2Text(dwParam);
                sprintf(szErrorMsg, "Thread %d: CryptGetProvParam 2 %s error 0x%x", 
                                    dwThreadNum, pszProvParamText, dwError) ;
                MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
                MyFree(pszProvParamText);
                goto ErrorReturn ;
            }
        }
        dwFlags=0 ;
    } while (dwEnumFlag)  ;

    dwRetVal=1 ;
    ErrorReturn :
    MyFree(pbProvData) ;
    return dwRetVal ;
}


//+ =================================================================================
//- =================================================================================
/*
DWORD L_GetAllProvParams(HCRYPTPROV hProv, DWORD dwThreadNum)
{
    DWORD   dwRetVal=0 ;

    EnterCriticalSection(&g_CSEnumParam);

    if (!L_GetProvParam(hProv, PP_ENUMALGS, dwThreadNum))
    {
        LeaveCriticalSection(&g_CSEnumParam);
        goto ErrorReturn;
    }

    LeaveCriticalSection(&g_CSEnumParam);

    if (!L_CheckHeap(dwThreadNum, "after L_GetProvParam PP_ENUMALGS"))
            goto ErrorReturn ;

    EnterCriticalSection(&g_CSEnumParam);

    if (!L_GetProvParam(hProv, PP_ENUMALGS, dwThreadNum))
    {
        LeaveCriticalSection(&g_CSEnumParam);
        goto ErrorReturn ;
    }

    LeaveCriticalSection(&g_CSEnumParam);

    if (!L_CheckHeap(dwThreadNum, "after L_GetProvParam PP_ENUMALGS"))
        goto ErrorReturn ;

    EnterCriticalSection(&g_CSEnumParam);
    
    if (!L_GetProvParam(hProv, PP_ENUMCONTAINERS, dwThreadNum))
    {
        LeaveCriticalSection(&g_CSEnumParam);
        goto ErrorReturn ;
    }

    LeaveCriticalSection(&g_CSEnumParam);

    if (!L_GetProvParam(hProv, PP_NAME, dwThreadNum))
        goto ErrorReturn ;

    if (!L_CheckHeap(dwThreadNum, "after L_GetProvParam PP_NAME"))
            goto ErrorReturn ;

    if (!L_GetProvParam(hProv, PP_CONTAINER, dwThreadNum))
        goto ErrorReturn ;

    if (!L_CheckHeap(dwThreadNum, "after L_GetProvParam PP_CONTAINER"))
            goto ErrorReturn ;

    if (!L_GetProvParam(hProv, PP_IMPTYPE, dwThreadNum))
        goto ErrorReturn ;

    if (!L_CheckHeap(dwThreadNum, "after L_GetProvParam PP_IMPTYPE"))
            goto ErrorReturn ;

    if (!L_GetProvParam(hProv, PP_VERSION, dwThreadNum))
        goto ErrorReturn ;

    if (!L_CheckHeap(dwThreadNum, "after L_GetProvParam PP_VERSION"))
            goto ErrorReturn ;

    if (!L_GetProvParam(hProv, PP_KEYSET_SEC_DESCR, dwThreadNum))
        goto ErrorReturn ;
    
    if (!L_CheckHeap(dwThreadNum, "after L_GetProvParam PP_KEYSET_SEC_DESCR"))
            goto ErrorReturn ;

    if (!L_GetProvParam(hProv, PP_UNIQUE_CONTAINER, dwThreadNum))
        goto ErrorReturn ;

    if (!L_CheckHeap(dwThreadNum, "after L_GetProvParam PP_UNIQUE_CONTAINER"))
            goto ErrorReturn ;

    if (!L_GetProvParam(hProv, PP_PROVTYPE, dwThreadNum))
        goto ErrorReturn ;

    if (!L_CheckHeap(dwThreadNum, "after L_GetProvParam PP_PROVTYPE"))
            goto ErrorReturn ;

    if (!L_GetProvParam(hProv, PP_SIG_KEYSIZE_INC, dwThreadNum))
        goto ErrorReturn ;

    if (!L_CheckHeap(dwThreadNum, "after L_GetProvParam PP_SIG_KEYSIZE_INC"))
            goto ErrorReturn ;

    if (!L_GetProvParam(hProv, PP_KEYX_KEYSIZE_INC, dwThreadNum))
        goto ErrorReturn ;
        

    dwRetVal=1 ;
    ErrorReturn :
    return dwRetVal ;
}
*/


//+ ======================================================================
//- ======================================================================
DWORD L_ImportAndCheckSessionKeys(  HCRYPTPROV    hProv, 
                                    HCRYPTKEY     hKeyExch,
                                    PBYTE         pbRCx_KeyBlob,
                                    DWORD         cbRCx_KeyBlob,
                                    PBYTE         pbRCx_CipherText,
                                    DWORD         cbRCx_CipherText,
                                    PBYTE       pbPlainText,
                                    DWORD       cbPlainText,
                                    DWORD       dwThreadNum)
{
    DWORD  dwRetVal=0 ;
    HCRYPTKEY   hRCxKey=0 ;

    if (!CryptImportKey(hProv,
                        pbRCx_KeyBlob,
                        cbRCx_KeyBlob,
                        hKeyExch,
                        0,
                        &hRCxKey))
        L_LastErrorBox("Failed to import session Key", dwThreadNum) ;

    if (!CryptDecrypt(hRCxKey,
                        0,
                        TRUE,
                        0,
                        pbRCx_CipherText, 
                        &cbRCx_CipherText))
        L_LastErrorBox("Failed CryptDecrypt", dwThreadNum) ;

    if (memcmp(pbRCx_CipherText, pbPlainText, cbPlainText))
        L_ErrorBox("Ciphertext does not match plaintext after decrypting", dwThreadNum) ;

    //ErrorReturn :
    if (!CryptDestroyKey(hRCxKey))
        L_LastErrorBox("Failed CryptDestroyKey sessionKey", dwThreadNum) ;
        
    dwRetVal=1 ;
    return dwRetVal ;
}



//+ ======================================================================
//- ======================================================================
DWORD L_TestContextAddRef(HCRYPTPROV hProv, DWORD dwThreadNum)
{
    DWORD   dwRetVal=0 ;
    DWORD   i=0 ;
    DWORD   dwCount=50 ;

    for (i=0; i<dwCount ; i++)
    {
        if (!CryptContextAddRef(hProv, NULL, 0))
        {
            L_LastErrorBox("Failed CryptContextAddRef", dwThreadNum) ;
            goto ErrorReturn ;
        }
    }

    for (i=0; i<dwCount ; i++)
    {
        if (!CryptReleaseContext(hProv, 0))
        {
            L_LastErrorBox("Failed CryptReleaseContext (AddRef Test)", dwThreadNum) ;
            goto ErrorReturn ;
        }
    }

    dwRetVal=1 ;
    ErrorReturn :
    return dwRetVal ;
}




//+ ===========================================================================
//      L_ExportKey
//
//      Exports a session key, given the exchange key
//      Mem Allocated here needs to be freed by the calling funtion.
//- ===========================================================================
DWORD L_ExportKey(  HCRYPTKEY hRC_Key,
                            HCRYPTKEY hKeyExch,
                            DWORD dwType,
                            DWORD   dwMustBeZero,
                            PBYTE *ppbRC_KeyBlob,
                            DWORD *pcbRC_KeyBlob)
{
    DWORD   dwRetVal=0 ;
    char    szErrorMsg[256] ;

    if (!CryptExportKey(hRC_Key,
                        hKeyExch,
                        dwType,
                        0,
                        NULL,
                        pcbRC_KeyBlob))
        GENERIC_FAIL(CryptExportKey_RC) ;
        
    if (NULL == (*ppbRC_KeyBlob = (PBYTE) MyAlloc(*pcbRC_KeyBlob)))
        return 0;
    memset(*ppbRC_KeyBlob, 33, *pcbRC_KeyBlob) ;

    if (!CryptExportKey(hRC_Key,
                        hKeyExch,
                        SIMPLEBLOB,
                        0,
                        *ppbRC_KeyBlob,
                        pcbRC_KeyBlob))
        GENERIC_FAIL(CryptExportKey_RC) ;

    dwRetVal=1 ;
    ErrorReturn :
    return dwRetVal ;
}




//+ ==========================================================================
//  
//  
//- ==========================================================================
DWORD   L_GetHashParam(HCRYPTHASH hHash, DWORD dwParam)
{
    DWORD   dwRetVal=0 ;
    char    szErrorMsg[256] ;
    PBYTE   pbData=NULL ;
    DWORD   cbData=0 ;

    if (!CryptGetHashParam( hHash, 
                            dwParam,
                            NULL,
                            &cbData,
                            0))
        GENERIC_FAIL(CryptGetHashParam) ;

    if (NULL == (pbData = (PBYTE) MyAlloc(cbData)))
        return 0;

    if (!CryptGetHashParam( hHash, 
                            dwParam,
                            pbData,
                            &cbData,
                            0))
        GENERIC_FAIL(CryptGetHashParam) ;

    dwRetVal=1 ;
    ErrorReturn :
    MyFree(pbData) ;
    return dwRetVal ;
}




//+ ==========================================================================
//  
//  
//- ==========================================================================
DWORD   L_GetAllHashParams(HCRYPTHASH hHash, DWORD dwThreadNum)
{
    DWORD   dwRetVal=0 ;
    char szErrorMsg[256] ;

    if (!L_GetHashParam(hHash, HP_ALGID))
        goto ErrorReturn ;

    if (!L_GetHashParam(hHash, HP_HASHSIZE))
        goto ErrorReturn ;

    if (!L_GetHashParam(hHash, HP_HASHVAL))
        goto ErrorReturn ;

    dwRetVal=1 ;
    ErrorReturn :
    return dwRetVal ;
}

//
// Function: ThreadAcquireContextTest
//
DWORD ThreadAcquireContextTest(PTHREAD_DATA pThreadData, DWORD dwThreadNum)
{
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hKey = 0;
    DWORD dwError = 0;
    CHAR rgsz[100];

    ZeroMemory(rgsz, sizeof(rgsz));
    sprintf(rgsz, "%s_%d", "ThreadContainer", dwThreadNum);

    if (! CryptAcquireContext(
            &hProv, rgsz, pThreadData->rgszProvName,
            pThreadData->dwProvType, 0))
    {
        dwError = GetLastError();
        printf("CryptAcquireContext: %s, %d, 0x%x\n", rgsz, dwThreadNum, dwError);

        if (NTE_BAD_KEYSET == dwError)
        {
            if (! CryptAcquireContext(
                    &hProv, rgsz, pThreadData->rgszProvName,
                    pThreadData->dwProvType, CRYPT_NEWKEYSET))
            {
                dwError = GetLastError();
                printf("CryptAcquireContext CRYPT_NEWKEYSET: %s, %d, 0x%x\n", rgsz, dwThreadNum, dwError);
                goto Ret;
            }
        }
        else
            goto Ret;
    }

    if (! CryptGetUserKey(hProv, AT_SIGNATURE, &hKey))
    {
        if (NTE_NO_KEY == (dwError = GetLastError()))
        {
            if (! CryptGenKey(hProv, AT_SIGNATURE, 0, &hKey))
            {
                dwError = GetLastError();
                goto Ret;
            }
        }
        else 
            goto Ret;
    }

    if (! CryptDestroyKey(hKey))
    {
        dwError = GetLastError();
        goto Ret;
    }

    if (! CryptReleaseContext(hProv, 0))
    {
        dwError = GetLastError();
        goto Ret;
    }

    dwError = 0;
Ret:
    return dwError;
}

//
// Function: ThreadHashingTest
//
DWORD ThreadHashingTest(PTHREAD_DATA pThreadData, PBYTE pbData, DWORD cbData)
{
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hKey = 0;
    BYTE rgHash[100];
    DWORD cb = 0;
    DWORD dwError = 0;   
    PALGNODE pHashAlg;

    for (   pHashAlg = pThreadData->pAlgList;
            NULL != pHashAlg;
            pHashAlg = pHashAlg->pNext)
    {
        if (CALG_SHA1 != pHashAlg->EnumalgsEx.aiAlgid &&
            CALG_MD5 != pHashAlg->EnumalgsEx.aiAlgid)
            continue;

        if (! CryptCreateHash(pThreadData->hProv, pHashAlg->EnumalgsEx.aiAlgid, 0, 0, &hHash))
        {
            dwError = GetLastError();
            goto Ret;
        }

        if (! CryptHashData(hHash, pbData, cbData, 0))
        {
            dwError = GetLastError();
            goto Ret;
        }

        if (! CryptHashData(hHash, pbData, cbData, 0))
        {
            dwError = GetLastError();
            goto Ret;
        }

        cb = sizeof(rgHash);
        if (! CryptGetHashParam(hHash, HP_HASHVAL, rgHash, &cb, 0))
        {
            dwError = GetLastError();
            goto Ret;
        }

        if (! CryptDestroyHash(hHash))
        {
            dwError = GetLastError();
            goto Ret;
        }
        hHash = 0;
    }

    //dwError = HmacRegression(pThreadData);

Ret:
    return dwError;
}

//
// Function: ThreadSignatureTest
//
DWORD ThreadSignatureTest(PTHREAD_DATA pThreadData)
{
    HCRYPTHASH hHash = 0;
    PBYTE pbData = NULL;
    DWORD cbData = 0;
    PBYTE pbSignature = NULL;
    DWORD cbSignature = 0;
    DWORD dwError = 0;
    PALGNODE pHashAlg = NULL;
    
    if (! CryptCreateHash(
        pThreadData->hProv, CALG_SHA1, 0, 0, &hHash))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    cbData = SIGN_DATA_SIZE;
    if (NULL == (pbData = (PBYTE) MyAlloc(cbData)))
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    
    if (! CryptGenRandom(
        pThreadData->hProv, cbData, pbData))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    if (! CryptHashData(
        hHash, pbData, cbData, 0))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    if (! CryptSignHash(
        hHash, AT_SIGNATURE, NULL, 0, NULL, &cbSignature))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    if (NULL == (pbSignature = (PBYTE) MyAlloc(cbSignature)))
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    
    if (! CryptSignHash(
        hHash, AT_SIGNATURE, NULL, 0, pbSignature, &cbSignature))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    if (! CryptVerifySignature(
        hHash, pbSignature, cbSignature, 
        pThreadData->hSignatureKey, NULL, 0))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    if (! CryptDestroyHash(hHash))
    {
        dwError = GetLastError();
        goto Ret;
    }
    
    MyFree(pbData);
    MyFree(pbSignature);

Ret:
    return dwError;
}

// ======================================================================================
//  MULTITHREADED routine
// ======================================================================================
void WINAPI ThreadRoutine(LPVOID pvThreadData)
{
    DWORD       dwThreadNum = 0;
    DWORD       dwError = 0;
    BOOL        fMacErrorOccurred = FALSE;
    PTHREAD_DATA pThreadData = (PTHREAD_DATA) pvThreadData;
    CHAR        szErrorMsg[256];
    BYTE        rgbData[HASH_DATA_SIZE];
    
    // Get identifier for this thread
    EnterCriticalSection(&pThreadData->CSThreadData);
    dwThreadNum = pThreadData->dwThreadID;
    pThreadData->dwThreadID++;
    LeaveCriticalSection(&pThreadData->CSThreadData);

    if (! CryptGenRandom(pThreadData->hProv, sizeof(rgbData), rgbData))
    {
        dwError = GetLastError();
        goto ErrorReturn;
    }
    
    do 
    {
        if (RUN_THREAD_SIGNATURE_TEST & pThreadData->dwTestsToRun)
        {
            if (ERROR_SUCCESS != (dwError = ThreadSignatureTest(pThreadData)))
            {
                sprintf(
                    szErrorMsg, 
                    "Thread %d: ThreadSignatureTest error 0x%x", 
                    dwThreadNum, 
                    dwError);
                MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR);
                goto ErrorReturn;
            }
        }

        if (RUN_STRESS_TEST_ALL_ENCRYPTION_ALGS & pThreadData->dwTestsToRun)
        {
            //
            // Call new shared encryption stress tests
            //
            if (ERROR_SUCCESS != (dwError = 
                StressTestAllEncryptionAlgs(pThreadData, TRUE, &fMacErrorOccurred)))
            {
                sprintf(
                    szErrorMsg, 
                    "Thread %d: StressTestAllEncryptionAlgs error 0x%x", 
                    dwThreadNum, 
                    dwError);
                MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR);
                goto ErrorReturn;
            }
        }

        if (RUN_THREAD_HASHING_TEST & pThreadData->dwTestsToRun)
        {      
            if (ERROR_SUCCESS != (dwError = ThreadHashingTest(pThreadData, rgbData, sizeof(rgbData))))
            {
                sprintf(
                    szErrorMsg, 
                    "Thread %d: ThreadHashingTest error 0x%x", 
                    dwThreadNum, 
                    dwError);
                MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR);
                goto ErrorReturn;
            }         
        }

        if (RUN_THREAD_ACQUIRE_CONTEXT_TEST & pThreadData->dwTestsToRun)
        {
            if (ERROR_SUCCESS != (dwError = ThreadAcquireContextTest(pThreadData, dwThreadNum)))
            {
                sprintf(
                    szErrorMsg, 
                    "Thread %d: ThreadAcquireContextTest error 0x%x", 
                    dwThreadNum, 
                    dwError);
                MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR);
                goto ErrorReturn;
            }         
        }

        pThreadData->rgdwThreadStatus[dwThreadNum]++;
    }   
    while (WAIT_TIMEOUT == WaitForSingleObject(pThreadData->hEndTestEvent, 0));
    
ErrorReturn:

    if (fMacErrorOccurred)
    {
        printf("ERROR: Mac bug 189368 is not fixed!\n");
    }

    return;
}

//
// Function: GetNextRegisteredCSP
//
DWORD GetNextRegisteredCSP(
    LPSTR pszCsp,
    PDWORD pcbCsp,
    PDWORD pdwProvType,
    DWORD dwRequestedIndex)
{
    static DWORD dwNextEnumIndex    = 0;
    DWORD dwActualIndex             = 0;
    DWORD dwError                   = 0;

    dwActualIndex =
        (ENUMERATE_REGISTERED_CSP == dwRequestedIndex) ? 
        dwNextEnumIndex : 
        dwRequestedIndex;

    if (! CryptEnumProviders(
        dwActualIndex,
        NULL,
        0,
        pdwProvType,
        pszCsp,
        pcbCsp))
    {
        dwError = GetLastError();

        switch (dwError)
        {
        case ERROR_NO_MORE_ITEMS:
            dwNextEnumIndex = 0;
            break;
        }
    }
    else
    {
        if (ENUMERATE_REGISTERED_CSP == dwRequestedIndex)
        {
            dwNextEnumIndex++;
        }
    }

    return dwError;
}

//
// Function: InitializeAlgList
// Purpose: Create a list of algorithms supported by this CSP
//
DWORD InitializeAlgList(PTHREAD_DATA pThreadData)
{
    PALGNODE pAlgNode = NULL, pPrevNode = NULL;
    DWORD dwError = 0;
    DWORD cbData = sizeof(ALGNODE);
    DWORD dwFlags = CRYPT_FIRST;

    if (NULL == (pThreadData->pAlgList = (PALGNODE) MyAlloc(sizeof(ALGNODE))))
        return ERROR_NOT_ENOUGH_MEMORY;

    pAlgNode = pThreadData->pAlgList;

    while (CryptGetProvParam(
        pThreadData->hProv, 
        PP_ENUMALGS_EX, 
        (PBYTE) &pAlgNode->EnumalgsEx,
        &cbData,
        dwFlags))
    {
        dwFlags = 0;

        if (NULL == (pAlgNode->pNext = (PALGNODE) MyAlloc(sizeof(ALGNODE))))
            return ERROR_NOT_ENOUGH_MEMORY;

        pPrevNode = pAlgNode;
        pAlgNode = pAlgNode->pNext;
    }

    if (ERROR_NO_MORE_ITEMS != (dwError = GetLastError()))
        return dwError;
    
    MyFree(pAlgNode);
    pPrevNode->pNext = NULL;
    
    return ERROR_SUCCESS;
}

//
// Function: RunRegressionTests
//
BOOL RunRegressionTests(PTHREAD_DATA pThreadData)
{
    DWORD dwError = ERROR_SUCCESS;
    unsigned u;
    BOOL fAllPassed = TRUE;

    for (u = 0; u < g_cRegressTests; u++)
    {
        if (pThreadData->dwProvType & g_rgRegressTests[u].dwExclude)
        {
            printf(
                "Skipping %s\n\n", g_rgRegressTests[u].pszDescription);
            continue;
        }

        if (ERROR_SUCCESS != 
            (dwError = (g_rgRegressTests[u].pfTest)(pThreadData)))
        {
            printf(
                "FAIL: %s, 0x%x\n\n", 
                g_rgRegressTests[u].pszDescription,
                dwError);
            fAllPassed = FALSE;
        }
        else
            printf("PASS: %s\n\n", g_rgRegressTests[u].pszDescription);
    }

    return fAllPassed;
}

//
// Function: CallCryptAcquireContext
//
BOOL CallCryptAcquireContext(
    IN PTHREAD_DATA pThreadData,
    IN LPSTR pszOptions,
    IN LPSTR pszContainer)
{
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hKey = 0;
    DWORD dwFlags = 0;
    unsigned uLen = strlen(pszOptions);
    ALG_ID ai = 0;
    DWORD dwKeyFlags = 0;
    BOOL fSuccess = TRUE;

    printf(" pszContainer = %s\n", pszContainer);
    printf(" dwFlags =");
    
    while (uLen)
    {
        switch (pszOptions[uLen - 1])
        {
        case 'l':
            dwFlags |= CRYPT_MACHINE_KEYSET;
            printf(" CRYPT_MACHINE_KEYSET");
            break;
        case 'v':
            dwFlags |= CRYPT_VERIFYCONTEXT;
            printf(" CRYPT_VERIFYCONTEXT");
            break;
        case 'n':
            dwFlags |= CRYPT_NEWKEYSET;
            printf(" CRYPT_NEWKEYSET");
            break;
        case 'd':
            dwFlags |= CRYPT_DELETEKEYSET;
            printf(" CRYPT_DELETEKEYSET");
            break;
        case 'q':
            dwFlags |= CRYPT_SILENT;
            printf(" CRYPT_SILENT");
            break;
        case 'x':
            ai = AT_KEYEXCHANGE;
            break;
        case 's':
            ai = AT_SIGNATURE;
            break;
        case 'u':
            dwKeyFlags = CRYPT_USER_PROTECTED;
            break;
        default:
            printf(" Invalid!\n");
            return FALSE;
        }
        uLen--;
    }
    printf("\n");

    if (CryptAcquireContext(
            &hProv, pszContainer, pThreadData->rgszProvName,
            pThreadData->dwProvType, dwFlags))
    {
        printf("Success\n");

        if (0 != ai)
        {
            printf("\nCalling CryptGenKey ...\n");
            if (AT_KEYEXCHANGE == ai)
                printf(" Algid = AT_KEYEXCHANGE\n");
            else
                printf(" Algid = AT_SIGNATURE\n");

            if (dwKeyFlags & CRYPT_USER_PROTECTED)
                printf(" dwFlags = CRYPT_USER_PROTECTED\n");
            else
                printf(" dwFlags =\n");

            if (CryptGenKey(
                    hProv, ai, dwKeyFlags, &hKey))
            {
                printf("Success\n");
            }
            else
            {
                printf("ERROR: CryptGenKey failed - 0x%x\n", GetLastError());
                fSuccess = FALSE;
            }
        }
    }
    else
    {
        printf("ERROR: CryptAcquireContext failed - 0x%x\n", GetLastError());
        fSuccess = FALSE;
    }

    if (hKey)
    {
        if (! CryptDestroyKey(hKey))
        {
            printf("ERROR: CryptDestroyKey failed - 0x%x\n", GetLastError());
            fSuccess = FALSE;
        }
    }
    if (hProv)
    {
        if ((! dwFlags & CRYPT_DELETEKEYSET) && 
            FALSE == CryptReleaseContext(hProv, 0))
        {
            printf("ERROR: CryptReleaseContext failed - 0x%x\n", GetLastError());
            fSuccess = FALSE;
        }
    }

    return fSuccess;
}

//
// Function: DeleteAllContainers
//
BOOL DeleteAllContainers(THREAD_DATA *pThreadData)
{
    HCRYPTPROV hDefProv                 = 0;
    HCRYPTPROV hProv                    = 0;
    CHAR rgszContainer[MAX_PATH];
    CHAR rgszDefCont[MAX_PATH];
    DWORD cbContainer                   = MAX_PATH;
    DWORD dwFlags                       = CRYPT_FIRST;

    if (! CryptAcquireContext(
            &hDefProv, NULL, pThreadData->rgszProvName, 
            pThreadData->dwProvType, 0))
    {
        printf("CryptAcquireContext default keyset failed - 0x%x\n", GetLastError());
        return FALSE;
    }

    if (! CryptGetProvParam(
            hDefProv, PP_CONTAINER, (PBYTE) rgszDefCont,
            &cbContainer, 0))
    {
        printf("CryptGetProvParam PP_CONTAINER failed - 0x%x\n", GetLastError());
        return FALSE;
    }

    cbContainer = MAX_PATH;
    while (CryptGetProvParam(
        hDefProv, PP_ENUMCONTAINERS, (PBYTE) rgszContainer,
        &cbContainer, dwFlags))
    {
        if (dwFlags)
            dwFlags = 0;

        // If the enumerated container is the same as the default
        // container, skip it for now
        if (0 == strcmp(rgszContainer, rgszDefCont))
            continue;

        printf("\"%s\" - ", rgszContainer);
        
        if (! CryptAcquireContext(
                &hProv, rgszContainer, pThreadData->rgszProvName,
                pThreadData->dwProvType, CRYPT_DELETEKEYSET))
            printf("CryptAcquireContext CRYPT_DELETEKEYSET failed - 0x%x\n", GetLastError());
        else
            printf("Deleted\n");

        cbContainer = MAX_PATH;
    }  

    if (! CryptReleaseContext(hDefProv, 0))
    {
        printf("CryptReleaseContext failed - 0x%x\n", GetLastError());
        return FALSE;
    }

    // Now try to delete default keyset
    printf("\"%s\" - ", rgszDefCont);
    if (! CryptAcquireContext(
            &hProv, rgszDefCont, pThreadData->rgszProvName,
            pThreadData->dwProvType, CRYPT_DELETEKEYSET))
        printf("CryptAcquireContext CRYPT_DELETEKEYSET failed - 0x%x\n", GetLastError());
    else
        printf("Deleted\n");

    return TRUE;  
}

//*****************************************************
//
int _cdecl main(int argc, char * argv[])
{
    HANDLE              rghThread[MAX_THREADS];
    DWORD               rgdwThreadID[MAX_THREADS];
    DWORD               threadID=0;
    DWORD               thread_number=0;
    DWORD               dwErr=0;
    DWORD               dwArg = 0;
    DWORD               cbCspName = 0;
    DWORD               dwFreeHandle=0;
    DWORD               i = 0 ;
    DWORD               tick_StartTime=0;
    char                szErrorMsg[256] ;
    THREAD_DATA         ThreadData;
    BOOL                fInvalidArgs = FALSE;
    PALGNODE            pAlgNode = NULL;
    BOOL                fRunRegressions = FALSE;
    BOOL                fAcquireContext = FALSE;
    LPSTR               pszOptions = NULL;
    LPSTR               pszContainer = NULL;
    BOOL                fDeleteContainers = FALSE;

    // Set high-order bit on dwSpinCount param so that the event used
    // by EnterCriticalSection() will be pre-allocated by 
    // InitializeCriticalSectionAndSpinCount()
    DWORD               dwSpinCount = 0x8000;
    
    ZeroMemory(&ThreadData, sizeof(ThreadData));

    __try
    {
        InitializeCriticalSectionAndSpinCount(&ThreadData.CSThreadData, dwSpinCount);
    }
    __except (STATUS_NO_MEMORY == GetExceptionCode() ?
                EXCEPTION_EXECUTE_HANDLER :
                EXCEPTION_CONTINUE_SEARCH )
    {
        printf("InitializeCriticalSectionAndSpinCount failed: STATUS_NO_MEMORY exception\n");
        exit(1);    
    }

    // Setting all the defaults
    ThreadData.dwThreadCount = StressGetDefaultThreadCount();
    ThreadData.dwTestsToRun = RUN_ALL_TESTS;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'n':
                argv++; 
                argc--;
                if (0 == argc || 0 == (dwArg = atoi(argv[0])))
                {
                    fInvalidArgs = TRUE;
                    goto Ret;
                }
                ThreadData.dwThreadCount = dwArg;
                break;

            case 't':
                argv++; 
                argc--;
                if (0 == argc || 0 == (dwArg = atoi(argv[0])))
                {
                    fInvalidArgs = TRUE;
                    goto Ret;
                }
                ThreadData.dwProgramMins = dwArg;
                break;

            case 'c':
                argv++;
                argc--;
                if (0 == argc)
                {
                    fInvalidArgs = TRUE;
                    goto Ret;
                }

                cbCspName = MAX_PATH;
                dwErr = GetNextRegisteredCSP(
                    ThreadData.rgszProvName,
                    &cbCspName,
                    &ThreadData.dwProvType,
                    atoi(*argv));
                if (ERROR_SUCCESS != dwErr)
                {
                    fInvalidArgs = TRUE;
                    goto Ret;
                }
                break;
                
            case 'e':
                ThreadData.fEphemeralKeys = TRUE;
                break;

            case 'u':
                ThreadData.fUserProtectedKeys = TRUE;
                break;

            case 'r':
                fRunRegressions = TRUE;
                break;

            case '?':
                fInvalidArgs = TRUE;
                goto Ret;

            case 'a':
                fAcquireContext = TRUE;
                pszOptions = argv[0] + 2;
                
                if (NULL == strchr(pszOptions, 'v'))
                {
                    argv++;
                    argc--;
                    pszContainer = *argv;
                }
                break;

            case 'd':
                fDeleteContainers = TRUE;
                break;

            case 'T':
                argv++; 
                argc--;
                if (0 == argc || 0 == (dwArg = atoi(argv[0])))
                {
                    fInvalidArgs = TRUE;
                    goto Ret;
                }
                ThreadData.dwTestsToRun = dwArg;
                break; 

            default:
                fInvalidArgs = TRUE;
                goto Ret;
            }
        }
    }

    //
    // Check arg validity
    //
    if (    0 != argc || 
            0 == ThreadData.dwProvType ||
            (ThreadData.fEphemeralKeys && ThreadData.fUserProtectedKeys) ||
            (fRunRegressions && fAcquireContext))
    {
        fInvalidArgs = TRUE;
        goto Ret;
    }

    printf("Provider: %s, Type: %d\n\n", ThreadData.rgszProvName, ThreadData.dwProvType);

    if (fDeleteContainers)
    {
        printf("Deleting all key containers ...\n");
        if (! DeleteAllContainers(&ThreadData))
            exit(1);
        goto Ret;
    }
    if (fAcquireContext)
    {
        printf("Calling CryptAcquireContext ...\n");
        if (! CallCryptAcquireContext(
                &ThreadData, pszOptions, pszContainer))
            exit(1);
        goto Ret;
    }

    if (!ProgramInit(&ThreadData))
    {
        printf("ProgramInit() failed\n");
        exit(1) ;
    }

    //
    // Initialize list of supported algorithms
    //
    if (ERROR_SUCCESS != (dwErr = InitializeAlgList(&ThreadData)))
    {
        printf("InitializeAlgList failed, 0x%x\n", dwErr);
        exit(1);
    }

    if (fRunRegressions)
    {
        printf("Running regression tests ...\n");
        if (! RunRegressionTests(&ThreadData))
            exit(1);
        goto Ret;
    }

    //
    // Summarize user options
    //
    printf("Number of threads: %d\n", ThreadData.dwThreadCount);
    if (ThreadData.dwProgramMins)
        printf(" - Timeout in %d minute(s)\n", ThreadData.dwProgramMins);
    if (ThreadData.fEphemeralKeys)
        printf(" - Using ephemeral keys\n");
    if (ThreadData.fUserProtectedKeys)
        printf(" - Using user-protected keys\n");

    // Create event that can be used by the timer thread to stop
    // the worker threads.
    if ((ThreadData.hEndTestEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL)
    {
        printf("CreateEvent() failed, 0x%x\n", GetLastError());
        exit(1);
    }        

    // Create the threads
    tick_StartTime = GetTickCount() ;
    for (thread_number = 0; thread_number < ThreadData.dwThreadCount; thread_number++)
    {
        if ((rghThread[thread_number] = 
            CreateThread(
                NULL, 
                0, 
                (LPTHREAD_START_ROUTINE) ThreadRoutine, 
                &ThreadData, 
                0, 
                &threadID)) != NULL)
        {
            rgdwThreadID[thread_number] = threadID ;
        }
        else
        {
            sprintf(szErrorMsg, "\n\nERROR creating thread number 0x%x. Error 0x%x", 
                    thread_number, GetLastError()) ;
            MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
            exit(0) ;
        }
    }

    //  Spawn PrintThreadStatus
    rghThread[thread_number++] = CreateThread(
                        NULL, 0, 
                        (LPTHREAD_START_ROUTINE)PrintThreadStatus, 
                        &ThreadData, 
                        0, &threadID);
                    
    //  Spawn KillProgramTimer (This will shut down all the threads and kill the program)
    rghThread[thread_number++] = CreateThread(
                        NULL, 0, 
                        (LPTHREAD_START_ROUTINE)KillProgramTimer, 
                        &ThreadData, 
                        0, &threadID);

    // Done Creating all threads

    // End multithreading
    dwErr = WaitForMultipleObjects(thread_number, rghThread, TRUE, INFINITE) ;  
    if (dwErr == WAIT_FAILED)
        printf("WaitForMultipleObjects() failed, 0x%x\n", GetLastError());

    if (! CryptDestroyKey(ThreadData.hSignatureKey))
    {
        sprintf(szErrorMsg, "FAILED CryptDestroyKey SIG error 0x%x\n", GetLastError()) ;
        MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
    }
    if (ThreadData.hExchangeKey && (! CryptDestroyKey(ThreadData.hExchangeKey)))
    {
        sprintf(szErrorMsg, "FAILED CryptDestroyKey KEYX error 0x%x\n", GetLastError()) ;
        MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
    }
    if (! CryptReleaseContext(ThreadData.hVerifyCtx, 0))
    {
        sprintf(szErrorMsg, "FAILED CryptReleaseContext 1 error 0x%x\n", GetLastError());
        MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR);
    }
    if (! CryptReleaseContext(ThreadData.hProv, 0))
    {
        sprintf(szErrorMsg, "FAILED CryptReleaseContext 2 error 0x%x\n", GetLastError()) ;
        MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR) ;
    }
        
    DeleteCriticalSection(&ThreadData.CSThreadData);
    CloseHandle(ThreadData.hEndTestEvent);

    while (thread_number--)
        CloseHandle(rghThread[thread_number]);

Ret:
    while (ThreadData.pAlgList)
    {
        pAlgNode = ThreadData.pAlgList->pNext;
        MyFree(ThreadData.pAlgList);
        ThreadData.pAlgList = pAlgNode;
    }

    if (fInvalidArgs)
    {
        Usage();
        
        printf("\nRegistered CSP's:\n");
        
        cbCspName = MAX_PATH;
        for (   i = 0;
                ERROR_SUCCESS == GetNextRegisteredCSP(
                    ThreadData.rgszProvName,
                    &cbCspName,
                    &ThreadData.dwProvType,
                    ENUMERATE_REGISTERED_CSP);
                i++, cbCspName = MAX_PATH)
        {
            printf(" %d: %s, Type %d\n", i, ThreadData.rgszProvName, ThreadData.dwProvType);
        }
        
        exit(1);
    }

    return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\test\stress\strestst.h ===
#ifndef __STRESTST__H__
#define __STRESTST__H__

#include <windows.h>
#include <wincrypt.h>

#define APP_NAME                        "cspstres"
#define KEY_CONTAINER_NAME              "CspStressKey"
#define ERROR_CAPTION                   "ERROR : cspstres " 
#define STRESS_DEFAULT_THREAD_COUNT     8
#define MAX_THREADS                     MAXIMUM_WAIT_OBJECTS
#define PLAIN_BUFFER_SIZE               30000
#define HASH_DATA_SIZE                  14999
#define SIGN_DATA_SIZE                  999
#define PROV_PARAM_BUFFER_SIZE          256
#define RSA_AES_CSP                     "rsaaes.dll"

#define ENUMERATE_REGISTERED_CSP        -1

#define GENERIC_FAIL(X)                 { \
    sprintf(szErrorMsg, "%s error 0x%x\n", #X, GetLastError()); \
    MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR); \
    goto ErrorReturn ; \
}

#define ALLOC_FAIL(X)                   { \
    sprintf(szErrorMsg, "%s alloc error 0x%x\n", #X, GetLastError()); \
    MessageBox(NULL, szErrorMsg, ERROR_CAPTION, MB_OK | MB_ICONERROR); \
    goto ErrorReturn; \
}

#define DW_INUSE                        0
#define DW_HASH_ALGID                   1
#define DW_END_CERT_INDEX               2

//
// Struct: ALGNODE
// Purpose: A linked list of CSP algorithms
//
typedef struct _ALGNODE
{
    struct _ALGNODE *pNext;
    PROV_ENUMALGS_EX EnumalgsEx;
} ALGNODE, *PALGNODE;

//
// Struct: THREAD_DATA
// Purpose: This is the data passed to the entry point
// shared by each of the worker/test threads.
//
typedef struct _THREAD_DATA
{
    DWORD rgdwThreadStatus[MAX_THREADS];
    DWORD dwThreadCount;
    DWORD dwProgramMins;
    PALGNODE pAlgList;
    CHAR rgszProvName[MAX_PATH];
    DWORD dwProvType;
    BOOL fEphemeralKeys;
    BOOL fUserProtectedKeys;
    HCRYPTPROV hProv;
    HCRYPTPROV hVerifyCtx;
    HCRYPTKEY hExchangeKey;
    HCRYPTKEY hSignatureKey;
    HANDLE hEndTestEvent;

    CRITICAL_SECTION CSThreadData;
    DWORD dwThreadID; // Not thread safe
    DWORD dwTestsToRun;
} THREAD_DATA, *PTHREAD_DATA;

// ************
// Stress Tests
// ************

#define RUN_THREAD_SIGNATURE_TEST                   0x00000001
#define RUN_STRESS_TEST_ALL_ENCRYPTION_ALGS         0x00000002
#define RUN_THREAD_HASHING_TEST                     0x00000004
#define RUN_THREAD_ACQUIRE_CONTEXT_TEST             0x00000008
#define RUN_ALL_TESTS                               0xffffffff

//
// Function: StressGetDefaultThreadCount
// Purpose: Return the default number of worker/test threads to be 
// created by a stress test.  This will be equal to the number
// of processors on the host system, unless there's only one, in
// which case the value returned will be STRESS_DEFAULT_THREAD_COUNT.
// 
DWORD StressGetDefaultThreadCount(void);

// *****************
// Memory management
// *****************

//
// Function: MyAlloc
// Purpose: Wrapper for calling thread-safe HeapAlloc 
// with default params.
//
LPVOID MyAlloc(SIZE_T);

//
// Function: MyFree
// Purpose: Wrapper for calling thread-safe HeapFree
// with default params.
//
BOOL MyFree(LPVOID);

//
// Function: PrintBytes
//
void PrintBytes(LPSTR pszHdr, BYTE *pb, DWORD cbSize);

// ***************
// Encryption Test
// ***************

//
// Struct: ENCRYPTION_TEST_DATA
// Purpose: Parameters for the StressEncryptionTest function.
//
typedef struct _ENCRYPTION_TEST_DATA
{
    ALG_ID aiEncryptionKey;

    ALG_ID aiHash;
    ALG_ID aiHashKey;
} ENCRYPTION_TEST_DATA, *PENCRYPTION_TEST_DATA;

// ****************
// Regression Tests
// ****************

typedef DWORD (*PREGRESSION_TEST)(PTHREAD_DATA);

typedef struct _REGRESS_TEST_TABLE_ENTRY
{
    PREGRESSION_TEST pfTest;
    DWORD dwExclude;
    LPSTR pszDescription;
} REGRESS_TEST_TABLE_ENTRY, *PREGRESS_TEST_TABLE_ENTRY;

DWORD KeyArchiveRegression(PTHREAD_DATA pThreadData);
DWORD PlaintextBlobRegression(PTHREAD_DATA pThreadData);
DWORD LoadAesCspRegression(PTHREAD_DATA pThreadData);
DWORD DesImportRegression(PTHREAD_DATA pThreadData);
DWORD KnownBlockCipherKeyRegression(PTHREAD_DATA pThreadData);
DWORD PinCacheRegression(PTHREAD_DATA pThreadData);
DWORD DesGetKeyParamRegression(PTHREAD_DATA pThreadData);
DWORD MacEncryptRegression(IN PTHREAD_DATA pThreadData);
DWORD HmacRegression(PTHREAD_DATA pThreadData);
DWORD UnalignedImportExportRegression(PTHREAD_DATA pThreadData);

static const REGRESS_TEST_TABLE_ENTRY g_rgRegressTests [] = {
    { KeyArchiveRegression,             0,  "KeyArchiveRegression for CRYPT_ARCHIVABLE flag" },
    { PlaintextBlobRegression,          0,  "PlaintextBlobRegression for PLAINTEXTKEYBLOB blob type" },
    { LoadAesCspRegression,             0,  "LoadAesCspRegression for DllInitialize" },
    { DesImportRegression,              0,  "DesImportRegression for parity and non-parity key sizes" },
    { KnownBlockCipherKeyRegression,    0,  "KnownBlockCipherKeyRegression for CSP compatibility"},
    { PinCacheRegression,               0,  "PinCacheRegression for smart-card pin caching lib"},
    { DesGetKeyParamRegression,         0,  "DesGetKeyParamRegression for des KP_KEYLEN and KP_EFFECTIVE_KEYLEN" },
    { MacEncryptRegression,             0,  "MacEncryptRegression for simultaneous encrypt/decrypt and MAC" },
    { HmacRegression,                   0,  "HmacRegression for CRYPT_IPSEC_HMAC_KEY processing" },
    { UnalignedImportExportRegression,  0,  "UnalignedImportExportRegression for key blob alignment" }
};

static const unsigned g_cRegressTests = 
    sizeof(g_rgRegressTests) / sizeof(REGRESS_TEST_TABLE_ENTRY);
 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\test\testsuit\csptestsuite.h ===
/*

  CSPTestSuite.h

  This file contains typedef's and function prototypes for the CSP Test Suite.

  6/16/00 dangriff created

*/

#ifndef __CSPTESTSUITE__H__
#define __CSPTESTSUITE__H__

#include <windows.h>
#include <wincrypt.h>
#include "logging.h"
#include "cspstruc.h"
#include "utils.h"

#define TESTVER_MAJOR_VERSION						5
#define TESTVER_MINOR_VERSION						0

#define TEST_APP_NAME								L"CSPTestSuite"
#define MINIMUM_ARGC								3

#define CSP_TYPE_INVALID							0
#define CSP_TYPE_RSA								1
#define CSP_TYPE_DSS								2
#define CSP_TYPE_ELIPTIC_CURVE						3
#define CSP_TYPE_AES                                4

#define CLASS_INVALID								0x0
#define CLASS_SIG_ONLY								0x00000001
#define CLASS_SIG_KEYX								0x00000002
#define CLASS_FULL									0x00000004
#define CLASS_SCHANNEL								0x00000008
#define CLASS_OPTIONAL								0x00000010

static DWORD g_rgCspClasses [] = { 
	CLASS_SIG_ONLY, CLASS_SIG_KEYX, CLASS_FULL, CLASS_OPTIONAL 
};

#define TEST_LEVEL_CSP								0x1
#define TEST_LEVEL_PROV								0x2
#define TEST_LEVEL_HASH								0x4
#define TEST_LEVEL_KEY								0x8
#define TEST_LEVEL_CONTAINER						0x10

static DWORD g_rgTestLevels [] = { 
	TEST_LEVEL_CSP, TEST_LEVEL_PROV, TEST_LEVEL_HASH, TEST_LEVEL_KEY, TEST_LEVEL_CONTAINER 
};

// 
// Parameters used by the test cases
//
#define BUFFER_SIZE									2048
#define TEST_MAX_RSA_KEYSIZE						1024
#define TEST_INVALID_FLAG							-1
#define TEST_INVALID_HANDLE							-1
#define TEST_INVALID_POINTER						-1
#define GENRANDOM_BYTE_COUNT						1000
#define TEST_HASH_DATA								L"Test hash data"
#define TEST_DECRYPT_DATA							L"Test decrypt data"
#define HASH_LENGTH_SHA1							20
#define HASH_LENGTH_MD5								16
#define TEST_CIPHER_LENGTH_RC4						256
#define TEST_RC2_DATA_LEN							8
#define TEST_RC2_BUFFER_LEN							16
#define TEST_CRYPTACQUIRECONTEXT_CONTAINER			L"TestingCAC"
#define TEST_CONTAINER								L"TestSuiteContainer"
#define TEST_CONTAINER_2							L"TestSuiteContainer2"
#define TEST_SALT_BYTE								0xcd
#define TEST_IV_BYTE								0xcd
#define TEST_SALT_LEN								20
#define TEST_EFFECTIVE_KEYLEN						56
#define TEST_MODE_BITS								16


//
// ------------------------
// Known Error Lookup Table
// ------------------------
//
static KNOWN_ERROR_INFO g_KnownErrorTable[] =
{
	//
	// Known errors in Positive test cases
	//
	/*
		KnownErrorID					Maj		Min	SP	SP				Actual Error Level
										Rev		Rev	Maj	Min
	*/
	{ KNOWN_CRYPTGETPROVPARAM_MAC,			5,	0,	0,	0,			CSP_ERROR_WARNING },
	{ KNOWN_CRYPTGETPROVPARAM_PPNAME,		5,	1,	0,	0,			CSP_ERROR_WARNING },
	{ KNOWN_CRYPTSETKEYPARAM_EXPORT,		5,	1,	0,	0,			CSP_ERROR_WARNING },
	{ KNOWN_CRYPTGETKEYPARAM_SALT,			5,	0,	0,	0,			CSP_ERROR_WARNING },
	{ KNOWN_CRYPTGENKEY_SALTDES,			5,	1,	0,	0,			CSP_ERROR_WARNING },

	// 
	// Known errors in Negative test cases
	//
	{ KNOWN_CRYPTACQUIRECONTEXT_NULLPHPROV, 5,	1,	0,	0,			CSP_ERROR_WARNING },
	{ KNOWN_CRYPTACQUIRECONTEXT_BADFLAGS,	5,	1,	0,	0,			CSP_ERROR_WARNING },
	{ KNOWN_ERRORINVALIDHANDLE,				5,	1,	0,	0,			CSP_ERROR_WARNING },
	{ KNOWN_CRYPTGETPROVPARAM_MOREDATA,		5,	1,	0,	0,			CSP_ERROR_WARNING },
	{ KNOWN_CRYPTSETPROVPARAM_RNG,			5,	1,	0,	0,			CSP_ERROR_WARNING },
	{ KNOWN_CRYPTSETPROVPARAM_BADFLAGS,		5,	1,	0,	0,			CSP_ERROR_WARNING },
	{ KNOWN_CRYPTCREATEHASH_BADKEY,			5,	1,	0,	0,			CSP_ERROR_WARNING },
	{ KNOWN_CRYPTIMPORTKEY_BADFLAGS,		5,	1,	0,	0,			CSP_ERROR_WARNING },
	{ KNOWN_CRYPTIMPORTKEY_BADALGID,		5,	1,	0,	0,			CSP_ERROR_WARNING },
	{ KNOWN_NTEBADKEY,						5,	1,	0,	0,			CSP_ERROR_WARNING },
	{ KNOWN_NTEBADHASH,						5,	1,	0,	0,			CSP_ERROR_WARNING },
	{ KNOWN_CRYPTGENKEY_SILENTCONTEXT,		5,	0,	0,	0,			CSP_ERROR_WARNING },

	//
	// Known errors in Scenario test cases
	//
	{ KNOWN_TESTDECRYPTPROC_3DES112,		5,	0,	0,	0,			CSP_ERROR_WARNING }
};

//
// Function: GetKnownErrorValue
// Purpose: Lookup a known error in the g_KnownErrorTable.  The return value
// is the actual error value that should be applied to the current error.
// 1) If the error is not in the table, return the dwCurrentErrorLevel param
// 2) If the error is found in the table, get the error level that should be 
// applied to that error from the table.  
//
// If the version information for 
// the known error matches that of this NT system, return the error level as 
// is.  Otherwise, increment the error level, since it is expected to have
// been fixed by now.
//
DWORD GetKnownErrorValue(
		IN KNOWN_ERROR_ID KnownErrorID,
		IN DWORD dwCurrentErrorLevel);

//
// Struct: CSPTYPEMAP
// Purpose: This struct is used to map external provider types (a subset of those 
// defined in wincrypt.h) to internal provider classes.
//
typedef struct _CSPTYPEMAP
{
	DWORD dwExternalProvType;
	DWORD dwProvType;
	DWORD dwCSPClass;
	LPWSTR pwszExternalProvType;
} CSPTYPEMAP, *PCSPTYPEMAP;

static CSPTYPEMAP g_CspTypeTable [] =
{
	/*
		ExternalProvType	InternalProvType	InternalCSPClass	External Type Description
	*/
	{ PROV_RSA_FULL,		CSP_TYPE_RSA,		CLASS_FULL,			L"PROV_RSA_FULL" },
	{ PROV_RSA_SIG,			CSP_TYPE_RSA,		CLASS_SIG_ONLY,		L"PROV_RSA_SIG" },
	{ PROV_DSS,				CSP_TYPE_DSS,		CLASS_SIG_ONLY,		L"PROV_DSS" },
	{ PROV_DSS_DH,			CSP_TYPE_DSS,		CLASS_FULL,			L"PROV_DSS_DH" },
    { PROV_RSA_AES,         CSP_TYPE_AES,       CLASS_FULL,         L"PROV_RSA_AES" }
};

typedef struct _ALGID_TABLE
{
	DWORD dwCSPClass;
	ALG_ID ai;
} ALGID_TABLE, *PALGID_TABLE;

static ALGID_TABLE g_RequiredAlgs_RSA[] = 
{
	{ CLASS_SIG_ONLY | CLASS_SIG_KEYX | CLASS_FULL,		CALG_RSA_SIGN },
	{ CLASS_SIG_ONLY | CLASS_SIG_KEYX | CLASS_FULL,		CALG_SHA1 },
	{ CLASS_SIG_ONLY | CLASS_SIG_KEYX | CLASS_FULL,		CALG_MD5 },
	{ CLASS_SIG_KEYX | CLASS_FULL,						CALG_RSA_KEYX },
	{ CLASS_FULL,										CALG_RC2 },
	{ CLASS_FULL,										CALG_RC4 }
};

static ALGID_TABLE g_OtherKnownAlgs_RSA[] = 
{ 
	{ CLASS_SIG_ONLY | CLASS_SIG_KEYX | CLASS_FULL,		CALG_MD2 },
	{ CLASS_SIG_ONLY | CLASS_SIG_KEYX | CLASS_FULL,		CALG_MD4 },
	{ CLASS_FULL,										CALG_MAC },
	{ CLASS_FULL,										CALG_HMAC },
	{ CLASS_FULL,										CALG_DES },
	{ CLASS_FULL,										CALG_3DES_112 }, 
	{ CLASS_FULL,										CALG_3DES }
};

static ALGID_TABLE g_RequiredAlgs_AES[] = 
{
	{ CLASS_SIG_ONLY | CLASS_SIG_KEYX | CLASS_FULL,		CALG_RSA_SIGN },
	{ CLASS_SIG_ONLY | CLASS_SIG_KEYX | CLASS_FULL,		CALG_SHA1 },
	{ CLASS_SIG_ONLY | CLASS_SIG_KEYX | CLASS_FULL,		CALG_MD5 },
	{ CLASS_SIG_KEYX | CLASS_FULL,						CALG_RSA_KEYX },
	{ CLASS_FULL,										CALG_RC2 },
	{ CLASS_FULL,										CALG_RC4 },
    { CLASS_FULL,                                       CALG_AES_128 },
    { CLASS_FULL,                                       CALG_AES_192 },
    { CLASS_FULL,                                       CALG_AES_256 }
};

static ALGID_TABLE g_OtherKnownAlgs_AES[] = 
{ 
	{ CLASS_SIG_ONLY | CLASS_SIG_KEYX | CLASS_FULL,		CALG_MD2 },
	{ CLASS_SIG_ONLY | CLASS_SIG_KEYX | CLASS_FULL,		CALG_MD4 },
	{ CLASS_FULL,										CALG_MAC },
	{ CLASS_FULL,										CALG_HMAC },
	{ CLASS_FULL,										CALG_DES },
	{ CLASS_FULL,										CALG_3DES_112 }, 
	{ CLASS_FULL,										CALG_3DES }
};

//
// Function: IsRequiredAlg
// Purpose: Search the RequiredAlgs array for the specified algorithm, ai.
// If ai is found, return TRUE, otherwise return FALSE.
//
BOOL IsRequiredAlg(ALG_ID ai, DWORD dwInternalProvType);

// 
// Function: IsKnownAlg
// Purpose: Search the OtherKnownAlgs array for the specified algorithm, ai.
// If ai is found, return TRUE, otherwise return FALSE.
//
BOOL IsKnownAlg(ALG_ID ai, DWORD dwInternalProvType);

//
// ------------------
// CSP Test Functions
// ------------------
//
BOOL TestBuildAlgList(PCSPINFO pCSPInfo);

BOOL PositiveAcquireContextTests(PCSPINFO pCSPInfo);
BOOL NegativeAcquireContextTests(PCSPINFO pCSPInfo);
BOOL PositiveGetProvParamTests(PCSPINFO pCSPInfo);
BOOL NegativeGetProvParamTests(PCSPINFO pCSPInfo);
BOOL PositiveSetProvParamTests(PCSPINFO pCSPInfo);
BOOL NegativeSetProvParamTests(PCSPINFO pCSPInfo);
BOOL PositiveReleaseContextTests(PCSPINFO pCSPInfo);
BOOL NegativeReleaseContextTests(PCSPINFO pCSPInfo);

BOOL PositiveGenRandomTests(PCSPINFO pCSPInfo);
BOOL NegativeGenRandomTests(PCSPINFO pCSPInfo);

BOOL PositiveCreateHashTests(PCSPINFO pCSPInfo);
BOOL NegativeCreateHashTests(PCSPINFO pCSPInfo);
BOOL PositiveDestroyHashTests(PCSPINFO pCSPInfo);
BOOL NegativeDestroyHashTests(PCSPINFO pCSPInfo);
BOOL PositiveGetHashParamTests(PCSPINFO pCSPInfo);
BOOL NegativeGetHashParamTests(PCSPINFO pCSPInfo);
BOOL PositiveHashDataTests(PCSPINFO pCSPInfo);
BOOL NegativeHashDataTests(PCSPINFO pCSPInfo);
BOOL PositiveSetHashParamTests(PCSPINFO pCSPInfo);
BOOL NegativeSetHashParamTests(PCSPINFO pCSPInfo);

BOOL PositiveDestroyKeyTests(PCSPINFO pCSPInfo);
BOOL NegativeDestroyKeyTests(PCSPINFO pCSPInfo);
BOOL PositiveGetKeyParamTests(PCSPINFO pCSPInfo);
BOOL NegativeGetKeyParamTests(PCSPINFO pCSPInfo);
BOOL PositiveSetKeyParamTests(PCSPINFO pCSPInfo);
BOOL NegativeSetKeyParamTests(PCSPINFO pCSPInfo);
BOOL PositiveDecryptTests(PCSPINFO pCSPInfo);
BOOL NegativeDecryptTests(PCSPINFO pCSPInfo);
BOOL PositiveEncryptTests(PCSPINFO pCSPInfo);
BOOL NegativeEncryptTests(PCSPINFO pCSPInfo);
BOOL PositiveGenKeyTests(PCSPINFO pCSPInfo);
BOOL NegativeGenKeyTests(PCSPINFO pCSPInfo);
BOOL PositiveDeriveKeyTests(PCSPINFO pCSPInfo);
BOOL NegativeDeriveKeyTests(PCSPINFO pCSPInfo);
BOOL PositiveHashSessionKeyTests(PCSPINFO pCSPInfo);
BOOL NegativeHashSessionKeyTests(PCSPINFO pCSPInfo);

BOOL PositiveExportKeyTests(PCSPINFO pCSPInfo);
BOOL NegativeExportKeyTests(PCSPINFO pCSPInfo);
BOOL PositiveGetUserKeyTests(PCSPINFO pCSPInfo);
BOOL NegativeGetUserKeyTests(PCSPINFO pCSPInfo);
BOOL PositiveImportKeyTests(PCSPINFO pCSPInfo);
BOOL NegativeImportKeyTests(PCSPINFO pCSPInfo);
BOOL PositiveSignHashTests(PCSPINFO pCSPInfo);
BOOL NegativeSignHashTests(PCSPINFO pCSPInfo);
BOOL PositiveVerifySignatureTests(PCSPINFO pCSPInfo);
BOOL NegativeVerifySignatureTests(PCSPINFO pCSPInfo);

BOOL ScenarioDecryptTests(PCSPINFO pCSPInfo);
BOOL ScenarioImportKeyTests(PCSPINFO pCSPInfo);
BOOL ScenarioVerifySignatureTests(PCSPINFO pCSPInfo);
BOOL ScenarioKeyExchangeTests(PCSPINFO pCSPInfo);

BOOL InteropHashDataTests(PCSPINFO pCSPInfo);
BOOL InteropDecryptTests(PCSPINFO pCSPInfo);
BOOL InteropDeriveKeyTests(PCSPINFO pCSPInfo);
BOOL InteropHashSessionKeyTests(PCSPINFO pCSPInfo);
BOOL InteropKeyExchangeTests(PCSPINFO pCSPInfo);

//
// --------------------------
// CSP Test Function Matrices
// --------------------------
//

//
// Struct: TESTTABLEENTRY
// Purpose: This struct will be used to store the static table below, which
// will map test functions that should be called for each relevant 
// [ Test Class , Test Level ] combination.
//

typedef struct _TESTTABLEENTRY
{
	PFN_CSPTEST pTestFunc;
	DWORD dwClassSigOnly;
	DWORD dwClassSigKeyX;
	DWORD dwClassFull;
	DWORD dwClassOptional;
	API_NAME ApiName;
	DWORD dwTestType;
} TESTTABLEENTRY, *PTESTTABLEENTRY;

//
// A table of test functions and the 
// CSP Classes and Test Levels to which each function applies.
//
static TESTTABLEENTRY g_TestFunctionMappings[] = 
{
	/*
		Function-					CLASS_SIG_ONLY			CLASS_SIG_KEYX		CLASS_FULL		CLASS_OPTIONAL		dwAPI				dwTestType
		name
	*/

	// TEST_LEVEL_CSP major group
	{	PositiveAcquireContextTests, TEST_LEVEL_CSP | TEST_LEVEL_CONTAINER,	0,	0,				0, API_CRYPTACQUIRECONTEXT, TEST_CASES_POSITIVE },
	{	NegativeAcquireContextTests, TEST_LEVEL_CSP | TEST_LEVEL_CONTAINER, 0,	0,				0,	API_CRYPTACQUIRECONTEXT, TEST_CASES_NEGATIVE },
	{	PositiveGetProvParamTests,	TEST_LEVEL_CSP,			0,					0,				0, API_CRYPTGETPROVPARAM, TEST_CASES_POSITIVE },
	{	NegativeGetProvParamTests,	TEST_LEVEL_CSP,			0,					0,				0, API_CRYPTGETPROVPARAM, TEST_CASES_NEGATIVE },
	{	PositiveSetProvParamTests,	TEST_LEVEL_CSP,			0,					0,				0, API_CRYPTSETPROVPARAM, TEST_CASES_POSITIVE },
	{	NegativeSetProvParamTests,	TEST_LEVEL_CSP,			0,					0,				0, API_CRYPTSETPROVPARAM, TEST_CASES_NEGATIVE },
	{	PositiveReleaseContextTests, TEST_LEVEL_CSP,		0,					0,				0, API_CRYPTRELEASECONTEXT, TEST_CASES_POSITIVE },
	{	NegativeReleaseContextTests, TEST_LEVEL_CSP,		0,					0,				0, API_CRYPTRELEASECONTEXT, TEST_CASES_NEGATIVE },

	// TEST_LEVEL_PROV major group
	{	PositiveGenRandomTests,		0,						0,					0,				TEST_LEVEL_PROV, API_CRYPTGENRANDOM, TEST_CASES_POSITIVE },
	{	NegativeGenRandomTests,		0,						0,					0,				TEST_LEVEL_PROV, API_CRYPTGENRANDOM, TEST_CASES_NEGATIVE },

	// TEST_LEVEL_HASH major group
	{	PositiveCreateHashTests,	TEST_LEVEL_HASH,		0,					0,				TEST_LEVEL_HASH, API_CRYPTCREATEHASH, TEST_CASES_POSITIVE },
	{	NegativeCreateHashTests,	TEST_LEVEL_HASH,		0,					0,				TEST_LEVEL_HASH, API_CRYPTCREATEHASH, TEST_CASES_NEGATIVE },
	{	PositiveDestroyHashTests,	TEST_LEVEL_HASH,		0,					0,				0, API_CRYPTDESTROYHASH, TEST_CASES_POSITIVE },
	{	NegativeDestroyHashTests,	TEST_LEVEL_HASH,		0,					0,				0, API_CRYPTDESTROYHASH, TEST_CASES_NEGATIVE },
	{	PositiveGetHashParamTests,	TEST_LEVEL_HASH,		0,					0,				0, API_CRYPTGETHASHPARAM, TEST_CASES_POSITIVE },
	{	NegativeGetHashParamTests,	TEST_LEVEL_HASH,		0,					0,				0, API_CRYPTGETHASHPARAM, TEST_CASES_NEGATIVE },
	{	PositiveHashDataTests,		TEST_LEVEL_HASH,		0,					0,				0, API_CRYPTHASHDATA, TEST_CASES_POSITIVE },
	{	NegativeHashDataTests,		TEST_LEVEL_HASH,		0,					0,				0, API_CRYPTHASHDATA, TEST_CASES_NEGATIVE },
	{	PositiveSetHashParamTests,	TEST_LEVEL_HASH,		0,					0,				0, API_CRYPTSETHASHPARAM, TEST_CASES_POSITIVE },
	{	NegativeSetHashParamTests,	TEST_LEVEL_HASH,		0,					0,				0, API_CRYPTSETHASHPARAM, TEST_CASES_NEGATIVE },

	// TEST_LEVEL_KEY major group
	{	PositiveDestroyKeyTests,	TEST_LEVEL_KEY,			0,					0,				0, API_CRYPTDESTROYKEY, TEST_CASES_POSITIVE },
	{	NegativeDestroyKeyTests,	TEST_LEVEL_KEY,			0,					0,				0, API_CRYPTDESTROYKEY, TEST_CASES_NEGATIVE },
	{	PositiveGetKeyParamTests,	TEST_LEVEL_KEY,			0,					0,				0, API_CRYPTGETKEYPARAM, TEST_CASES_POSITIVE },
	{	NegativeGetKeyParamTests,	TEST_LEVEL_KEY,			0,					0,				0, API_CRYPTGETKEYPARAM, TEST_CASES_NEGATIVE },
	{	PositiveSetKeyParamTests,	TEST_LEVEL_KEY,			0,					0,				0, API_CRYPTSETKEYPARAM, TEST_CASES_POSITIVE },
	{	NegativeSetKeyParamTests,	TEST_LEVEL_KEY,			0,					0,				0, API_CRYPTSETKEYPARAM, TEST_CASES_NEGATIVE },
	{	PositiveDecryptTests,		0,						0,					TEST_LEVEL_KEY, 0, API_CRYPTDECRYPT, TEST_CASES_POSITIVE },
	{	NegativeDecryptTests,		0,						0,					TEST_LEVEL_KEY, 0, API_CRYPTDECRYPT, TEST_CASES_NEGATIVE },
	{	PositiveEncryptTests,		0,						0,					TEST_LEVEL_KEY, 0, API_CRYPTENCRYPT, TEST_CASES_POSITIVE },
	{	NegativeEncryptTests,		0,						0,					TEST_LEVEL_KEY, 0, API_CRYPTENCRYPT, TEST_CASES_NEGATIVE },
	{	PositiveGenKeyTests,		TEST_LEVEL_CONTAINER,	TEST_LEVEL_CONTAINER, TEST_LEVEL_KEY, TEST_LEVEL_KEY | TEST_LEVEL_CONTAINER, API_CRYPTGENKEY, TEST_CASES_POSITIVE },
	{	NegativeGenKeyTests,		TEST_LEVEL_CONTAINER,	0,					TEST_LEVEL_KEY, 0, API_CRYPTGENKEY, TEST_CASES_NEGATIVE },
	{	PositiveDeriveKeyTests,		0,						0,					0,				TEST_LEVEL_KEY | TEST_LEVEL_CONTAINER, API_CRYPTDERIVEKEY, TEST_CASES_POSITIVE },
	{	NegativeDeriveKeyTests,		0,						0,					0,				TEST_LEVEL_KEY, API_CRYPTDERIVEKEY, TEST_CASES_NEGATIVE },
	{	PositiveHashSessionKeyTests, 0,						0,					0,				TEST_LEVEL_KEY, API_CRYPTHASHSESSIONKEY, TEST_CASES_POSITIVE },
	{	NegativeHashSessionKeyTests, 0,						0,					0,				TEST_LEVEL_KEY, API_CRYPTHASHSESSIONKEY, TEST_CASES_NEGATIVE },

	// TEST_LEVEL_CONTAINER major group
	{	PositiveExportKeyTests,		TEST_LEVEL_CONTAINER,	TEST_LEVEL_CONTAINER, 0,			0, API_CRYPTEXPORTKEY, TEST_CASES_POSITIVE },
	{	NegativeExportKeyTests,		TEST_LEVEL_CONTAINER,	TEST_LEVEL_CONTAINER, 0,			0, API_CRYPTEXPORTKEY, TEST_CASES_NEGATIVE },
	{	PositiveGetUserKeyTests,	TEST_LEVEL_CONTAINER,	TEST_LEVEL_CONTAINER, 0,			0, API_CRYPTGETUSERKEY, TEST_CASES_POSITIVE },
	{	NegativeGetUserKeyTests,	TEST_LEVEL_CONTAINER,	TEST_LEVEL_CONTAINER, 0,			0, API_CRYPTGETUSERKEY, TEST_CASES_NEGATIVE },
	{	PositiveImportKeyTests,		TEST_LEVEL_CONTAINER,	TEST_LEVEL_CONTAINER, 0,				0, API_CRYPTIMPORTKEY, TEST_CASES_POSITIVE },
	{	NegativeImportKeyTests,		TEST_LEVEL_CONTAINER,	TEST_LEVEL_CONTAINER, 0,				0, API_CRYPTIMPORTKEY, TEST_CASES_NEGATIVE },
	{	PositiveSignHashTests,		TEST_LEVEL_CONTAINER,	TEST_LEVEL_CONTAINER, 0,				0, API_CRYPTSIGNHASH, TEST_CASES_POSITIVE },
	{	NegativeSignHashTests,		TEST_LEVEL_CONTAINER,	0,					0,				0, API_CRYPTSIGNHASH, TEST_CASES_NEGATIVE },
	{	PositiveVerifySignatureTests, TEST_LEVEL_CONTAINER, TEST_LEVEL_CONTAINER, 0,			0, API_CRYPTVERIFYSIGNATURE, TEST_CASES_POSITIVE },
	{	NegativeVerifySignatureTests, TEST_LEVEL_CONTAINER,	0,					0,				0, API_CRYPTVERIFYSIGNATURE, TEST_CASES_NEGATIVE }
};

typedef struct _BASIC_TEST_TABLE
{
	PFN_CSPTEST pTestFunc;
	LPWSTR pwszDescription;
} BASIC_TEST_TABLE, *PBASIC_TEST_TABLE;

//
// A table of Scenario Test functions
//
static BASIC_TEST_TABLE g_ScenarioTestTable [] = 
{
	{ TestBuildAlgList,				L"Build a list a supported algorithms" },
	{ ScenarioDecryptTests,			L"Decryption/encryption test scenario" },
	{ ScenarioImportKeyTests,		L"Key import/export test scenario" },
	{ ScenarioVerifySignatureTests, L"Data signature/verification test scenario" },
	{ ScenarioKeyExchangeTests,		L"RSA Key exchange test scenario" }
};

//
// A table of Interop Test functions
//
static BASIC_TEST_TABLE g_InteropTestTable [] =
{
	{ TestBuildAlgList,				L"Build a list a supported algorithms" },
	{ InteropHashDataTests,			L"Hashed data interop test" },
	{ InteropDecryptTests,			L"Decryption/encryption interop test" },
	{ InteropDeriveKeyTests,		L"Key derivation interop test" },
	{ InteropHashSessionKeyTests,	L"Hashed session key interop test" },
	{ InteropKeyExchangeTests,		L"RSA Key exchange interop test" }
};

//
// ----------------
// General Routines
// ----------------
//

//
// Function: GetNextRegisteredCSP
// Purpose: In successive calls, enumerates all of the registered CSP's
// on the system, if the ENUMERATE_REGISTERED_CSP flag is specified in 
// dwRequestedIndex.  Otherwise, the provider at index dwRequestedIndex
// is returned.
//
// Note: Do not mix enumerating all CSP's with a call using the 
// ENUMERATE_REGISTERED_CSP flag, or some of the CSP's may not 
// be enumerated.
//
#define ENUMERATE_REGISTERED_CSP		-1

DWORD GetNextRegisteredCSP(
		OUT LPWSTR pwszCsp, 
		IN OUT PDWORD cbCsp,
		OUT PDWORD pdwProvType,
		IN DWORD dwRequestedIndex);

//
// -------------------------------
// API Test Helpers
// Struct's and Callback functions
// -------------------------------
//

//
// Function: TAcquire
// Purpose: Call CryptAcquireContext with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TAcquire(
		HCRYPTPROV *phProv, 
		LPWSTR pszContainer, 
		LPWSTR pszProvider, 
		DWORD dwProvType, 
		DWORD dwFlags, 
		PTESTCASE ptc);

//
// Function: TGetProv
// Purpose: Call CryptGetProvParam with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TGetProv(
		HCRYPTPROV hProv,
		DWORD dwParam,
		BYTE *pbData,
		DWORD *pdwDataLen,
		DWORD dwFlags,
		PTESTCASE ptc);

//
// Function: TSetProv
// Purpose: Call CryptSetProvParam with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TSetProv(
		HCRYPTPROV hProv,
		DWORD dwParam,
		BYTE *pbData,
		DWORD dwFlags,
		PTESTCASE ptc);

//
// Function: TRelease
// Purpose: Call CryptReleaseContext with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TRelease(
		HCRYPTPROV hProv,
		DWORD dwFlags,
		PTESTCASE ptc);

//
// Function: TGenRand
// Purpose: Call CryptGenRandom with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TGenRand(
		HCRYPTPROV hProv,
		DWORD dwLen,
		BYTE *pbBuffer,
		PTESTCASE ptc);

//
// Function: TCreateHash
// Purpose: Call CryptCreateHash with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TCreateHash(
		HCRYPTPROV hProv,
		ALG_ID Algid,
		HCRYPTKEY hKey,
		DWORD dwFlags,
		HCRYPTHASH *phHash,
		PTESTCASE ptc);

//
// Function: TDestroyHash
// Purpose: Call CryptDestroyHash with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TDestroyHash(
		HCRYPTHASH hHash,
		PTESTCASE ptc);

//
// Function: TDuplicateHash
// Purpose: Call CryptDuplicateHash with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TDuplicateHash(
		HCRYPTHASH hHash,
		DWORD *pdwReserved,
		DWORD dwFlags,
		HCRYPTHASH *phHash,
		PTESTCASE ptc);

//
// Function: TGetHash
// Purpose: Call CryptGetHashParam with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TGetHash(
		HCRYPTHASH hHash,
		DWORD dwParam,
		BYTE *pbData,
		DWORD *pdwDataLen,
		DWORD dwFlags,
		PTESTCASE ptc);

//
// Function: THashData
// Purpose: Call CryptHashData with the supplied parameters and pass
// the result to the logging routine.
//
BOOL THashData(
		HCRYPTHASH hHash,
		BYTE *pbData,
		DWORD dwDataLen,
		DWORD dwFlags,
		PTESTCASE ptc);

//
// Function: TSetHash
// Purpose: Call CryptSetHashParam with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TSetHash(
		HCRYPTHASH hHash,
		DWORD dwParam,
		BYTE *pbData,
		DWORD dwFlags,
		PTESTCASE ptc);

//
// Function: TDecrypt
// Purpose: Call CryptDecrypt with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TDecrypt(
		HCRYPTKEY hKey,
		HCRYPTHASH hHash,
		BOOL Final,
		DWORD dwFlags,
		BYTE *pbData,
		DWORD *pdwDataLen,
		PTESTCASE ptc);

//
// Function: TDeriveKey
// Purpose: Call CryptDeriveKey with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TDeriveKey(
		HCRYPTPROV hProv,
		ALG_ID Algid,
		HCRYPTHASH hBaseData,
		DWORD dwFlags,
		HCRYPTKEY *phKey,
		PTESTCASE ptc);

//
// Function: TDestroyKey
// Purpose: Call CryptDestroyKey with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TDestroyKey(
		HCRYPTKEY hKey,
		PTESTCASE ptc);

//
// Function: TEncrypt
// Purpose: Call CryptEncrypt with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TEncrypt(
		HCRYPTKEY hKey,
		HCRYPTHASH hHash, 
		BOOL Final,
		DWORD dwFlags,
		BYTE *pbData,
		DWORD *pdwDataLen,
		DWORD dwBufLen,
		PTESTCASE ptc);

//
// Function: TGenKey
// Purpose: Call CryptGenKey with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TGenKey(
		HCRYPTPROV hProv,
		ALG_ID Algid,
		DWORD dwFlags,
		HCRYPTKEY *phKey,
		PTESTCASE ptc);

//
// Function: TGetKey
// Purpose: Call CryptGetKeyParam with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TGetKey(
		HCRYPTKEY hKey,
		DWORD dwParam,
		BYTE *pbData,
		DWORD *pdwDataLen,
		DWORD dwFlags,
		PTESTCASE ptc);

//
// Function: THashSession
// Purpose: Call CryptHashSessionKey with the supplied parameters and pass
// the result to the logging routine.
//
BOOL THashSession(
		HCRYPTHASH hHash,
		HCRYPTKEY hKey,
		DWORD dwFlags,
		PTESTCASE ptc);

//
// Function: TSetKey
// Purpose: Call CryptSetKeyParam with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TSetKey(
		HCRYPTKEY hKey,
		DWORD dwParam,
		BYTE *pbData,
		DWORD dwFlags,
		PTESTCASE ptc);

//
// Function: TExportKey
// Purpose: Call CryptExportKey with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TExportKey(
		HCRYPTKEY hKey,
		HCRYPTKEY hExpKey,
		DWORD dwBlobType,
		DWORD dwFlags,
		BYTE *pbData,
		DWORD *pdwDataLen,
		PTESTCASE ptc);

//
// Function: TGetUser
// Purpose: Call CryptGetUserKey with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TGetUser(
		HCRYPTPROV hProv,
		DWORD dwKeySpec,
		HCRYPTKEY *phUserKey,
		PTESTCASE ptc);

//
// Function: TImportKey
// Purpose: Call CryptImportKey with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TImportKey(
		HCRYPTPROV hProv,
		BYTE *pbData,
		DWORD dwDataLen,
		HCRYPTKEY hPubKey,
		DWORD dwFlags,
		HCRYPTKEY *phKey,
		PTESTCASE ptc);

//
// Function: TSignHash
// Purpose: Call CryptSignHash with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TSignHash(
		HCRYPTHASH hHash,
		DWORD dwKeySpec,
		LPWSTR sDescription,
		DWORD dwFlags,
		BYTE *pbSignature,
		DWORD *pdwSigLen,
		PTESTCASE ptc);

//
// Function: TVerifySign
// Purpose: Call CryptVerifySign with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TVerifySign(
		HCRYPTHASH hHash,
		BYTE *pbSignature,
		DWORD dwSigLen,
		HCRYPTKEY hPubKey,
		LPWSTR sDescription,
		DWORD dwFlags,
		PTESTCASE ptc);

//
// Struct: TEST_CREATE_HASH_INFO
// Purpose: Store data for calls to TestCreateHashProc
//
typedef struct _TEST_CREATE_HASH_INFO
{
	HCRYPTPROV hProv;
	HCRYPTKEY hBlockCipherKey;
} TEST_CREATE_HASH_INFO, *PTEST_CREATE_HASH_INFO;

//
// Struct: TEST_HASH_DATA_INFO
// Purpose: Store data that will be common to all calls to TestHashDataProc
//
typedef struct _TEST_HASH_DATA_INFO
{
	HCRYPTPROV hProv;
	HCRYPTPROV hInteropProv;
	DATA_BLOB dbBaseData;

	//
	// These parameters are only used when this structure
	// is passed to TestMacDataProc
	//
	PALGNODE pAlgList;
	HMAC_INFO HmacInfo;
	ALG_ID aiMac;
} TEST_HASH_DATA_INFO, *PTEST_HASH_DATA_INFO;

//
// Function: TestHashDataProc
// Purpose: Create a hash context of the algorithm supplied in the
// pAlgNode parameter.  Hash some test data.  Verify that the hash result
// is the same as what is reported by the interop CSP
//
BOOL TestHashDataProc(
		PALGNODE pAlgNode, 
		PTESTCASE ptc, 
		PVOID pvTestHashDataInfo);

//
// Struct: TEST_DECRYPT_INFO
// Purpose: Store data to be passed to TestDecryptProc via 
// AlgListIterate.
//
typedef struct _TEST_DECRYPT_INFO
{
	HCRYPTPROV hProv;
	HCRYPTPROV hInteropProv;

	//
	// fDecrypt
	// If False, test CryptEncrypt
	// If True, test CryptDecrypt
	//
	BOOL fDecrypt;
} 
TEST_DECRYPT_INFO, *PTEST_DECRYPT_INFO;

//
// Function: TestDecryptProc
// Purpose: A callback function for AlgListIterate.  For each 
// encryption algorithm supported by the CSP under test, this
// function will be called to test decryption functionality.
//
BOOL TestDecryptProc(
		PALGNODE pAlgNode,
		PTESTCASE ptc,
		PVOID pvTestDecryptInfo);

//
// Struct: TEST_DERIVE_KEY_INFO
// Purpose: Store data to be passed to TestDeriveKeyProc via 
// AlgListIterate.
//
typedef struct _TEST_DERIVE_KEY_INFO
{
	HCRYPTPROV hProv;
	HCRYPTPROV hInteropProv;
} TEST_DERIVE_KEY_INFO, *PTEST_DERIVE_KEY_INFO;

//
// Function: TestDeriveKeyProc
// Purpose: Callback function for testing CryptDeriveKey using
// AlgListIterate.  For each session key algorithm supported by the
// target CSP, this function will be called to test CryptDeriveKey
// functionality.
//
BOOL TestDeriveKeyProc(
		PALGNODE pAlgNode,
		PTESTCASE ptc,
		PVOID pvTestDeriveKeyInfo);

//
// Struct: TEST_GEN_KEY_INFO
// Purpose: Data that must be provided to the TestGenKeyProc function.
//
typedef struct _TEST_GEN_KEY_INFO
{
	HCRYPTPROV hProv;
	HCRYPTPROV hNotSilentProv;
	PCSPINFO pCSPInfo;
} TEST_GEN_KEY_INFO, *PTEST_GEN_KEY_INFO;

//
// Function: TestGenKeyProc
// Purpose: Callback function for testing CryptGenKey using
// AlgListIterate.  For each key algorithm supported by the target
// CSP, this function will be called.
//
BOOL TestGenKeyProc(
		PALGNODE pAlgNode,
		PTESTCASE ptc,
		PVOID pvhProv);

//
// Struct: TEST_HASH_SESSION_KEY
// Purpose: Data that must be provided to the TestHashSessionKeyProc function.
//
typedef struct _TEST_HASH_SESSION_KEY
{
	HCRYPTPROV hProv;
	HCRYPTPROV hInteropProv;
	ALG_ID aiHash;
} TEST_HASH_SESSION_KEY, *PTEST_HASH_SESSION_KEY;

//
// Function: TestHashSessionKeyProc
// Purpose: Callback function for testing CryptHashSessionKey
// using AlgListIterate.  For each session key algorithm 
// supported by the target CSP, this function will be called.
//
BOOL TestHashSessionKeyProc(
		PALGNODE pAlgNode,
		PTESTCASE ptc,
		PVOID pvTestHashSessionKey);

//
// -----------------------------------------
// Defines for testing key Import and Export
// -----------------------------------------
//
typedef struct _KEY_EXPORT_INFO
{
	HCRYPTPROV hProv;
	ALG_ID aiKey;
	DWORD dwKeySize;
	DWORD dwExportFlags;
	PALGNODE pAlgList;

	//
	// For PRIVATEKEYBLOB scenarios, the use of an encryption key
	// is optional, since exporting unencrypted PRIVATEKEYBLOB's is 
	// supported.
	//
	BOOL fUseEncryptKey;
	ALG_ID aiEncryptKey;
	DWORD dwEncryptKeySize;
} KEY_EXPORT_INFO, *PKEY_EXPORT_INFO;

//
// Function: TestPrivateKeyBlobProc
// Purpose: Create a public/private key pair.  Export the public key as a PRIVATEKEYBLOB
// structure.  Verify that the key blob can be successfully re-imported.
//
BOOL TestPrivateKeyBlobProc(
		PALGNODE pAlgNode,
		PTESTCASE ptc,
		PVOID pvKeyExportInfo);

//
// Function: TestSymmetricWrapKeyBlobProc
// Purpose: Create a session key.  Export the session key encrypted
// with another session key.  Verify that the first session key can
// be re-imported.
//
BOOL TestSymmetricWrapKeyBlobProc(
		PALGNODE pAlgNode,
		PTESTCASE ptc,
		PVOID pvKeyExportInfo);

//
// -----------------------------------------
// Defines for testing key Import and Export
// -----------------------------------------
//

//
// Struct: SIGN_HASH_INFO
// Purpose: Test case data for creating and signing a hash
//
typedef struct _SIGN_HASH_INFO
{
	HCRYPTPROV hProv;
	HCRYPTKEY hSigKey;
	HCRYPTKEY hExchKey;
	DATA_BLOB dbBaseData;
} SIGN_HASH_INFO, *PSIGN_HASH_INFO;

//
// Function: SignAndVerifySignatureProc
// Purpose: Create a hash of the requested type and hash some test data.
// Sign and verify the signature of the hash with both the Signature and
// Key Exchange key pairs.
//
BOOL SignAndVerifySignatureProc(
		PALGNODE pAlgNode,
		PTESTCASE ptc,
		PVOID pvSignHashInfo);

//
// -------------------------------------------
// Defines for testing a Key Exchange scenario
// -------------------------------------------
//
typedef struct _EXCHANGE_PROC_INFO
{
	HCRYPTPROV hProv;
	HCRYPTPROV hInteropProv;
	ALG_ID aiHashAlg;
	DWORD dwPublicKeySize;
	DATA_BLOB dbPlainText;
} EXCHANGE_PROC_INFO, *PEXCHANGE_PROC_INFO;

//
// Function: TestKeyExchangeProc
// Purpose: Simulate a key/data exchange scenario for the specified
// encryption alg.
//
BOOL TestKeyExchangeProc(
		PALGNODE pAlgNode,
		PTESTCASE ptc,
		PVOID pvExchangeProcInfo);

//
// ------------------
// Known Hash Vectors
// ------------------
//

// 8 bytes of test data
#define KNOWN_HASH_DATA						"HashThis"
#define KNOWN_HASH_DATALEN					8

// known result of an MD5 hash on the above buffer
static BYTE g_rgbKnownMD5[] =
{
    0xb8, 0x2f, 0x6b, 0x11, 0x31, 0xc8, 0xec, 0xf4,
    0xfe, 0x0b, 0xf0, 0x6d, 0x2a, 0xda, 0x3f, 0xc3
};

// known result of an SHA-1 hash on the above buffer
static BYTE g_rgbKnownSHA1[] =
{
    0xe8, 0x96, 0x82, 0x85, 0xeb, 0xae, 0x01, 0x14,
    0x73, 0xf9, 0x08, 0x45, 0xc0, 0x6a, 0x6d, 0x3e,
    0x69, 0x80, 0x6a, 0x0c
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\test\testsuit\csptestsuite.c ===
/*

  CSPTestSuite.c

  4/23/00 dangriff created

  ---Introduction---

  This is the framework code for the Cryptographic Service Provider Test Suite.  
  External CSP types (such as PROV_RSA_SIG, defined in wincrypt.h) are internally assigned 
  both a CSP_TYPE and a CLASS value (defined below).  This combination of values determines
  which test cases and algorithms will be used to exercise a given CSP.

  ---Sample Test Execution---

  For a sample PROV_RSA_FULL CSP called "MyCSP", the test suite would be run with the following
  options:
  
    csptestsuite -n MyCSP -t 1

  The flow of the test in this example would be:

    * Lookup the test suite mappings for PROV_RSA_FULL.  They are CSP_TYPE_RSA and 
        CLASS_SIG_ONLY | CLASS_SIG_KEYX | CLASS_FULL.
        
        * Begin running all tests for CLASS_SIG_ONLY
            * Begin running all TEST_LEVEL_CSP tests for this class.  For example, this test level 
                consists of the API's CryptAcquireContext (partial; some CryptAcquireContext tests
                are TEST_LEVEL_CONTAINER), CryptGetProvParam, CryptSetProvParam, and CryptReleaseContext.
                Note that some TEST_LEVEL test case sets may be empty for a given class.
            * Begin running all TEST_LEVEL_PROV tests for this class
            * Begin running all TEST_LEVEL_HASH tests for this class
            * Begin running all TEST_LEVEL_KEY tests for this class
            * Begin running all TEST_LEVEL_CONTAINER tests for this class
        
        * Begin running all tests for CLASS_SIG_KEYX
            * Begin running all TEST_LEVEL_CSP tests for this class.  Note that each TEST_LEVEL set of 
                test cases for a given CLASS is unique.  No individual test case will be run twice.
            * Similarly for TEST_LEVEL_PROV, TEST_LEVEL_HASH, TEST_LEVEL_KEY, and TEST_LEVEL_CONTAINER.

        * Begin running all tests for CLASS_FULL
            * As above for TEST_LEVEL_CSP, TEST_LEVEL_PROV, TEST_LEVEL_HASH, TEST_LEVEL_KEY,
                and TEST_LEVEL_CONTAINER.
    
    * End.  Report the test results.

  ---Supported CSP Types---

  PROV_RSA_SIG
  PROV_RSA_FULL

*/

#include <windows.h>
#include <wincrypt.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "csptestsuite.h"
#include "logging.h"
#include "interop.h"
#include "utils.h"

//
// Function: Usage
// Purpose: Display list of command line options to console
//
void Usage()
{
    WCHAR rgwsz [BUFFER_SIZE];

    wprintf(
        L"Usage: %s -c <CSP> [ -t <Test> ] [ -i <Interop CSP> ]\n", 
        TEST_APP_NAME);
    
    wprintf(L"\n<Test> options:\n");
    
    TestCaseTypeToString(TEST_CASES_POSITIVE, rgwsz);
    wprintf(
        L" %d: %s (default)\n", 
        TEST_CASES_POSITIVE,
        rgwsz);

    TestCaseTypeToString(TEST_CASES_NEGATIVE, rgwsz);
    wprintf(
        L" %d: %s\n", 
        TEST_CASES_NEGATIVE,
        rgwsz);

    TestCaseTypeToString(TEST_CASES_SCENARIO, rgwsz);
    wprintf(
        L" %d: %s\n", 
        TEST_CASES_SCENARIO,
        rgwsz);

    TestCaseTypeToString(TEST_CASES_INTEROP, rgwsz);
    wprintf(
        L" %d: %s\n", 
        TEST_CASES_INTEROP,
        rgwsz);

    wprintf(L"\nLog file is %s in the current directory.\n", LOGFILE);
}

//
// Function: IsVersionCorrect
//
//
BOOL IsVersionCorrect(
    IN DWORD dwMajorVersion,
    IN DWORD dwMinorVersion,
    IN DWORD dwServicePackMajor,
    IN DWORD dwServicePackMinor)
{
    DWORDLONG dwlConditionMask = 0;
    OSVERSIONINFOEX OsviEx;
    
    memset(&OsviEx, 0, sizeof(OsviEx));
    
    OsviEx.dwOSVersionInfoSize = sizeof(OsviEx);
    OsviEx.dwMajorVersion = dwMajorVersion;
    OsviEx.dwMinorVersion = dwMinorVersion;
    OsviEx.wServicePackMajor = (WORD) dwServicePackMajor;
    OsviEx.wServicePackMinor = (WORD) dwServicePackMinor;
    
    //
    // We want to check that the system has a less than
    // or equal Rev to the caller parameters.
    //
    dwlConditionMask = 
        VerSetConditionMask(0, VER_MAJORVERSION, VER_LESS_EQUAL);
    dwlConditionMask = 
        VerSetConditionMask(dwlConditionMask, VER_MINORVERSION, VER_LESS_EQUAL);
    dwlConditionMask = 
        VerSetConditionMask(dwlConditionMask, VER_SERVICEPACKMAJOR, VER_LESS_EQUAL);
    dwlConditionMask = 
        VerSetConditionMask(dwlConditionMask, VER_SERVICEPACKMINOR, VER_LESS_EQUAL);
    
    return VerifyVersionInfo(
        &OsviEx,
        VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
        dwlConditionMask);
}

//
// Function: GetNextRegisteredCSP
//
DWORD GetNextRegisteredCSP(
        OUT LPWSTR pwszCsp, 
        IN OUT PDWORD pcbCsp,
        OUT PDWORD pdwProvType,
        IN DWORD dwRequestedIndex)
{
    static DWORD dwNextEnumIndex    = 0;
    DWORD dwActualIndex             = 0;
    DWORD dwError                   = 0;
    
    dwActualIndex = 
        (ENUMERATE_REGISTERED_CSP == dwRequestedIndex) ? dwNextEnumIndex : dwRequestedIndex;
    
    if (! CryptEnumProviders(
        dwActualIndex,
        NULL,
        0,
        pdwProvType,
        pwszCsp,
        pcbCsp))
    {
        dwError = GetLastError();
        
        switch (dwError)
        {
        case ERROR_NO_MORE_ITEMS:
            dwNextEnumIndex = 0;
            break;
        }
    }
    else
    {
        if (ENUMERATE_REGISTERED_CSP == dwRequestedIndex)
        {
            dwNextEnumIndex++;
        }
    }

    return dwError;
}

//
// -----------------
// Utility functions
// -----------------
//

//
// Function: IsRequiredAlg
//
BOOL IsRequiredAlg(
        IN ALG_ID ai, 
        IN DWORD dwInternalProvType)
{
    DWORD cItems            = 0;
    PALGID_TABLE pTable     = NULL;

    switch (dwInternalProvType)
    {
    case CSP_TYPE_RSA:
        {
            cItems = sizeof(g_RequiredAlgs_RSA) / sizeof(ALGID_TABLE);
            pTable = g_RequiredAlgs_RSA;

            break;
        }

    case CSP_TYPE_AES:
        {
            cItems = sizeof(g_RequiredAlgs_AES) / sizeof(ALGID_TABLE);
            pTable = g_RequiredAlgs_AES;

            break;
        }

    default:
        {
            return FALSE;
        }
    }

    while (cItems > 0)
    {
        if (ai == pTable[cItems - 1].ai)
        {
            return TRUE;
        }
        else
        {
            cItems--;
        }
    }

    return FALSE;
}

// 
// Function: IsKnownAlg
//
BOOL IsKnownAlg(ALG_ID ai, DWORD dwInternalProvType)
{
    DWORD cItems            = 0;
    PALGID_TABLE pTable     = NULL;

    switch (dwInternalProvType)
    {
    case CSP_TYPE_RSA:
        {
            cItems = sizeof(g_OtherKnownAlgs_RSA) / sizeof(ALGID_TABLE);
            pTable = g_OtherKnownAlgs_RSA;

            break;
        }

    case CSP_TYPE_AES:
        {
            cItems = sizeof(g_OtherKnownAlgs_AES) / sizeof(ALGID_TABLE);
            pTable = g_OtherKnownAlgs_AES;

            break;
        }

    default:
        {
            return FALSE;
        }
    }

    while (cItems > 0)
    {
        if (ai == pTable[cItems - 1].ai)
        {
            return TRUE;
        }
        else
        {
            cItems--;
        }
    }

    return FALSE;
}


//
// -------------------
// Crypto API wrappers
// -------------------
//

//
// Function: TAcquire
// Purpose: Call CryptAcquireContext with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TAcquire(
        HCRYPTPROV *phProv, 
        LPWSTR pszContainer, 
        LPWSTR pszProvider, 
        DWORD dwProvType, 
        DWORD dwFlags, 
        PTESTCASE ptc)
{
    BOOL fApiSuccessful             = FALSE;
    //BOOL fUnexpected              = TRUE;
    BOOL fContinue                  = FALSE;
    DWORD cbData                    = sizeof(HCRYPTPROV);
    API_PARAM_INFO ParamInfo []     = {
        { L"phProv",        Pointer,    0,          NULL,   TRUE,   &cbData, NULL },
        { L"pszContainer",  String,     0,          NULL,   FALSE,  NULL, NULL },
        { L"pszProvider",   String,     0,          NULL,   FALSE,  NULL, NULL },
        { L"dwProvType",    Dword,      dwProvType, NULL,   FALSE,  NULL, NULL },
        { L"dwFlags",       Dword,      dwFlags,    AcquireContextFlagToString, FALSE, NULL, NULL }
    };

    ParamInfo[0].pbParam = (PBYTE) phProv;
    ParamInfo[1].pwszParam = pszContainer;
    ParamInfo[2].pwszParam = pszProvider;
    
    if (NULL == phProv)
    {
        fApiSuccessful = 
            CryptAcquireContext(
            NULL, 
            pszContainer, 
            pszProvider, 
            dwProvType, 
            dwFlags);
    }
    else
    {
        fApiSuccessful = 
            CryptAcquireContext(
            phProv, 
            pszContainer, 
            pszProvider, 
            dwProvType, 
            dwFlags);
    }

    fContinue = CheckAndLogStatus(
        API_CRYPTACQUIRECONTEXT,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));

    return fContinue;
}

//
// Function: TGetProv
// Purpose: Call CryptGetProvParam with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TGetProv(
              HCRYPTPROV hProv,
              DWORD dwParam,
              BYTE *pbData,
              DWORD *pdwDataLen,
              DWORD dwFlags,
              PTESTCASE ptc)
{
    BOOL fApiSuccessful                 = FALSE;
    //BOOL fUnexpected                  = TRUE;
    BOOL fContinue                      = FALSE;
    DWORD cbData                        = sizeof(DWORD);
    API_PARAM_INFO ParamInfo []         = {
        { L"hProv",         Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"dwParam",       Dword,      dwParam,    GetProvParamToString, FALSE, NULL, NULL },
        { L"pbData",        Pointer,    0,          NULL,   TRUE,   pdwDataLen, NULL },
        { L"pdwDataLen",    Pointer,    0,          NULL,   TRUE,   &cbData, NULL },
        { L"dwFlags",       Dword,      dwFlags,    NULL,   FALSE,  NULL, NULL }
    };

    ParamInfo[0].pulParam = hProv;
    ParamInfo[2].pbParam = pbData;
    ParamInfo[3].pbParam = (PBYTE) pdwDataLen;

    switch (dwParam)
    {
    case PP_ENUMALGS:
    case PP_ENUMALGS_EX:
    case PP_ENUMCONTAINERS:
        {
            ParamInfo[4].pfnFlagToString = ProvParamEnumFlagToString;
            break;
        }       
    case PP_KEYSET_SEC_DESCR:
        {
            ParamInfo[4].pfnFlagToString = ProvParamSecDescrFlagToString;
            break;
        }       
    case PP_IMPTYPE:
        {
            ParamInfo[4].pfnFlagToString = ProvParamImpTypeToString;
            break;
        }
    }

    if (! ptc->fEnumerating)
    {
        if (! LogInitParamInfo(
            ParamInfo,
            APIPARAMINFO_SIZE(ParamInfo),
            ptc))
        {
            return FALSE;
        }
    }

    fApiSuccessful = CryptGetProvParam(hProv, dwParam, pbData, pdwDataLen, dwFlags);
        
    if (ptc->fEnumerating)
    {
        return fApiSuccessful;
    }
    
    fContinue = CheckAndLogStatus(
        API_CRYPTGETPROVPARAM,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));

    LogCleanupParamInfo(ParamInfo, APIPARAMINFO_SIZE(ParamInfo));

    return fContinue;
}

//
// Function: TSetProv
// Purpose: Call CryptSetProvParam with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TSetProv(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags,
    PTESTCASE ptc)
{
    BOOL fApiSuccessful                 = FALSE;
    //BOOL fUnexpected                  = TRUE;
    BOOL fContinue                      = FALSE;
    API_PARAM_INFO ParamInfo []         = {
        { L"hProv",         Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"dwParam",       Dword,      dwParam,    SetProvParamToString, FALSE, NULL, NULL },
        { L"pbData",        Pointer,    0,          NULL,   FALSE,  NULL, NULL },
        { L"dwFlags",       Dword,      dwFlags,    NULL,   FALSE,  NULL, NULL }
    };

    ParamInfo[0].pulParam = hProv;
    ParamInfo[2].pbParam = pbData;

    switch (dwParam)
    {
    case PP_KEYSET_SEC_DESCR:
        {
            ParamInfo[3].pfnFlagToString = ProvParamSecDescrFlagToString;
            break;
        }       
    case PP_IMPTYPE:
        {
            ParamInfo[3].pfnFlagToString = ProvParamImpTypeToString;
            break;
        }
    }
    
    fApiSuccessful = CryptSetProvParam(hProv, dwParam, pbData, dwFlags);
    
    fContinue = CheckAndLogStatus(
        API_CRYPTSETPROVPARAM,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));

    return fContinue;
}

//
// Function: TRelease
// Purpose: Call CryptReleaseContext with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TRelease(
              HCRYPTPROV hProv,
              DWORD dwFlags,
              PTESTCASE ptc)
{
    BOOL fApiSuccessful                 = FALSE;
    //BOOL fUnexpected                  = TRUE;
    BOOL fContinue                      = FALSE;
    BOOL fSavedExpectSuccess            = ptc->fExpectSuccess;
    API_PARAM_INFO ParamInfo []         = {
        { L"hProv",         Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"dwFlags",       Dword,      dwFlags,    NULL,   FALSE,  NULL, NULL }
    };
    
    ParamInfo[0].pulParam = hProv;

    if (! ptc->fTestingReleaseContext)
    {
        ptc->fExpectSuccess = TRUE;
    }
    
    fApiSuccessful = CryptReleaseContext(hProv, dwFlags);

    fContinue = CheckAndLogStatus(
        API_CRYPTRELEASECONTEXT,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));
    
    ptc->fExpectSuccess = fSavedExpectSuccess;
    
    return fContinue;
}

//
// Function: TGenRand
// Purpose: Call CryptGenRandom with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TGenRand(
              HCRYPTPROV hProv,
              DWORD dwLen,
              BYTE *pbBuffer,
              PTESTCASE ptc)
{
    BOOL fApiSuccessful                 = FALSE;
    //BOOL fUnexpected                  = TRUE;
    BOOL fContinue                      = FALSE;
    API_PARAM_INFO ParamInfo []         = {
        { L"hProv",         Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"dwLen",         Dword,      dwLen,      NULL,   FALSE,  NULL, NULL },
        { L"pbBuffer",      Pointer,    0,          NULL,   FALSE,  NULL, NULL }
    };

    ParamInfo[0].pulParam = hProv;
    ParamInfo[2].pbParam = pbBuffer;
    
    fApiSuccessful = CryptGenRandom(hProv, dwLen, pbBuffer);

    fContinue = CheckAndLogStatus(
        API_CRYPTGENRANDOM,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));

    return fContinue;
}

//
// Function: TCreateHash
// Purpose: Call CryptCreateHash with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TCreateHash(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash,
    PTESTCASE ptc)
{
    BOOL fApiSuccessful                 = FALSE;
    //BOOL fUnexpected                  = TRUE;
    BOOL fContinue                      = FALSE;
    DWORD cbData                        = sizeof(HCRYPTHASH);
    API_PARAM_INFO ParamInfo []         = {
        { L"hProv",         Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"Algid",         Dword,      Algid,      AlgidToString, FALSE, NULL, NULL },
        { L"hKey",          Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"dwFlags",       Dword,      dwFlags,    NULL,   FALSE,  NULL, NULL },
        { L"phHash",        Pointer,    0,          NULL,   TRUE,   &cbData, NULL }
    };

    ParamInfo[0].pulParam = hProv;
    ParamInfo[2].pulParam = hKey;
    ParamInfo[4].pbParam = (PBYTE) phHash;
    
    fApiSuccessful = CryptCreateHash(hProv, Algid, hKey, dwFlags, phHash);
        
    fContinue = CheckAndLogStatus(
        API_CRYPTCREATEHASH,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));

    return fContinue;
}

//
// Function: TDestroyHash
// Purpose: Call CryptDestroyHash with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TDestroyHash(
                  HCRYPTHASH hHash,
                  PTESTCASE ptc)
{
    BOOL fApiSuccessful             = FALSE;
    //BOOL fUnexpected              = TRUE;
    BOOL fContinue                  = FALSE;
    BOOL fSavedExpectSuccess        = ptc->fExpectSuccess;
    API_PARAM_INFO ParamInfo []     = {
        { L"hHash",         Handle,     0,      NULL,   FALSE,  NULL, NULL }
    };
    
    ParamInfo[0].pulParam = hHash;

    if (! ptc->fTestingDestroyHash)
    {
        ptc->fExpectSuccess = TRUE;
    }
    
    fApiSuccessful = CryptDestroyHash(hHash);
    
    fContinue = CheckAndLogStatus(
        API_CRYPTDESTROYHASH,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));

    ptc->fExpectSuccess = fSavedExpectSuccess;
    
    return fContinue;
}

//
// Function: TDuplicateHash
// Purpose: Call CryptDuplicateHash with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TDuplicateHash(
                    HCRYPTHASH hHash,
                    DWORD *pdwReserved,
                    DWORD dwFlags,
                    HCRYPTHASH *phHash,
                    PTESTCASE ptc)
{
    BOOL fApiSuccessful                 = FALSE;
    //BOOL fUnexpected                  = TRUE;
    BOOL fContinue                      = FALSE;
    API_PARAM_INFO ParamInfo []         = {
        { L"hHash",         Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"pdwReserved",   Pointer,    0,          NULL,   FALSE,  NULL, NULL },
        { L"dwFlags",       Dword,      dwFlags,    NULL,   FALSE,  NULL, NULL },
        { L"phHash",        Pointer,    0,          NULL,   FALSE,  NULL, NULL }
    };

    ParamInfo[0].pulParam = hHash;
    ParamInfo[1].pbParam = (PBYTE) pdwReserved;
    ParamInfo[3].pbParam = (PBYTE) phHash;
    
    fApiSuccessful = CryptDuplicateHash(hHash, pdwReserved, dwFlags, phHash);
        
    fContinue = CheckAndLogStatus(
        API_CRYPTDUPLICATEHASH,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));
    
    return fContinue;
}

//
// Function: TGetHash
// Purpose: Call CryptGetHashParam with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TGetHash(
              HCRYPTHASH hHash,
              DWORD dwParam,
              BYTE *pbData,
              DWORD *pdwDataLen,
              DWORD dwFlags,
              PTESTCASE ptc)
{
    BOOL fApiSuccessful                 = FALSE;
    //BOOL fUnexpected                  = TRUE;
    BOOL fContinue                      = FALSE;
    DWORD cbData                        = sizeof(DWORD);
    API_PARAM_INFO ParamInfo []         = {
        { L"hHash",         Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"dwParam",       Dword,      dwParam,    HashParamToString, FALSE, NULL, NULL },
        { L"pbData",        Pointer,    0,          NULL,   TRUE,   pdwDataLen, NULL },
        { L"pdwDataLen",    Pointer,    0,          NULL,   TRUE,   &cbData, NULL },
        { L"dwFlags",       Dword,      dwFlags,    NULL,   FALSE,  NULL, NULL }
    };

    ParamInfo[0].pulParam = hHash;
    ParamInfo[2].pbParam = pbData;
    ParamInfo[3].pbParam = (PBYTE) pdwDataLen;
    
    if (! LogInitParamInfo(
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo),
        ptc))
    {
        return FALSE;
    }

    fApiSuccessful = CryptGetHashParam(hHash, dwParam, pbData, pdwDataLen, dwFlags);
        
    fContinue = CheckAndLogStatus(
        API_CRYPTGETHASHPARAM,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));

    LogCleanupParamInfo(
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));

    return fContinue;
}

//
// Function: THashData
// Purpose: Call CryptHashData with the supplied parameters and pass
// the result to the logging routine.
//
BOOL THashData(
               HCRYPTHASH hHash,
               BYTE *pbData,
               DWORD dwDataLen,
               DWORD dwFlags,
               PTESTCASE ptc)
{
    BOOL fApiSuccessful                 = FALSE;
    //BOOL fUnexpected                  = TRUE;
    BOOL fContinue                      = FALSE;
    API_PARAM_INFO ParamInfo []         = {
        { L"hHash",         Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"pbData",        Pointer,    0,          NULL,   TRUE,   &dwDataLen, NULL },
        { L"dwDataLen",     Dword,      dwDataLen,  NULL,   FALSE,  NULL, NULL },
        { L"dwFlags",       Dword,      dwFlags,    HashDataFlagToString,   FALSE,  NULL, NULL }
    };
    
    ParamInfo[0].pulParam = hHash;
    ParamInfo[1].pbParam = pbData;

    if (! LogInitParamInfo(
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo),
        ptc))
    {
        return FALSE;
    }

    fApiSuccessful = CryptHashData(hHash, pbData, dwDataLen, dwFlags);

    fContinue = CheckAndLogStatus(
        API_CRYPTHASHDATA,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));

    LogCleanupParamInfo(
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));
    
    return fContinue;
}

//
// Function: TSetHash
// Purpose: Call CryptSetHashParam with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TSetHash(
              HCRYPTHASH hHash,
              DWORD dwParam,
              BYTE *pbData,
              DWORD dwFlags,
              PTESTCASE ptc)
{
    BOOL fApiSuccessful = FALSE;
    //BOOL fUnexpected = TRUE;
    BOOL fContinue = FALSE;
    API_PARAM_INFO ParamInfo []         = {
        { L"hHash",         Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"dwParam",       Dword,      dwParam,    HashParamToString, FALSE, NULL, NULL },
        { L"pbData",        Pointer,    0,          NULL,   FALSE,  NULL, NULL },
        { L"dwFlags",       Dword,      dwFlags,    NULL,   FALSE,  NULL, NULL }
    };
    
    ParamInfo[0].pulParam = hHash;
    ParamInfo[2].pbParam = pbData;

    fApiSuccessful = CryptSetHashParam(hHash, dwParam, pbData, dwFlags);
    
    fContinue = CheckAndLogStatus(
        API_CRYPTSETHASHPARAM,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));
    
    return fContinue;
}

//
// Function: TDecrypt
// Purpose: Call CryptDecrypt with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    PTESTCASE ptc)
{
    BOOL fApiSuccessful                 = FALSE;
    //BOOL fUnexpected                  = TRUE;
    BOOL fContinue                      = FALSE;
    DWORD cbData                        = sizeof(DWORD);
    API_PARAM_INFO ParamInfo []         = {
        { L"hKey",          Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"hHash",         Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"Final",         Boolean,    0,          NULL,   FALSE,  NULL, NULL },
        { L"dwFlags",       Dword,      dwFlags,    EncryptFlagToString, FALSE, NULL, NULL },
        { L"pbData",        Pointer,    0,          NULL,   TRUE,   pdwDataLen, NULL },
        { L"pdwDataLen",    Pointer,    0,          NULL,   TRUE,   &cbData, NULL },
    };

    ParamInfo[0].pulParam = hKey;
    ParamInfo[1].pulParam = hHash;
    ParamInfo[2].fParam = Final;
    ParamInfo[4].pbParam = pbData;
    ParamInfo[5].pbParam = (PBYTE) pdwDataLen;
    
    if (! LogInitParamInfo(
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo),
        ptc))
    {
        return FALSE;
    }

    fApiSuccessful = CryptDecrypt(hKey, hHash, Final, dwFlags, pbData, pdwDataLen);

    fContinue = CheckAndLogStatus(
        API_CRYPTDECRYPT,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));

    LogCleanupParamInfo(ParamInfo, APIPARAMINFO_SIZE(ParamInfo));
    
    return fContinue;
}

//
// Function: TDeriveKey
// Purpose: Call CryptDeriveKey with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TDeriveKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTHASH hBaseData,
    DWORD dwFlags,
    HCRYPTKEY *phKey,
    PTESTCASE ptc)
{
    BOOL fApiSuccessful                 = FALSE;
    //BOOL fUnexpected                  = TRUE;
    BOOL fContinue                      = FALSE;
    API_PARAM_INFO ParamInfo []         = {
        { L"hProv",         Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"Algid",         Dword,      Algid,      AlgidToString, FALSE, NULL, NULL },
        { L"hBaseData",     Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"dwFlags",       Dword,      dwFlags,    DeriveKeyFlagToString,FALSE,    NULL, NULL },
        { L"phKey",         Pointer,    0,          NULL,   FALSE,  NULL, NULL}     
    };

    ParamInfo[0].pulParam = hProv;
    ParamInfo[2].pulParam = hBaseData;
    ParamInfo[4].pbParam = (PBYTE) phKey;
    
    fApiSuccessful = CryptDeriveKey(hProv, Algid, hBaseData, dwFlags, phKey);
        
    fContinue = CheckAndLogStatus(
        API_CRYPTDERIVEKEY,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));
    
    return fContinue;
}

//
// Function: TDestroyKey
// Purpose: Call CryptDestroyKey with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TDestroyKey(
                 HCRYPTKEY hKey,
                 PTESTCASE ptc)
{
    BOOL fApiSuccessful                 = FALSE;
    //BOOL fUnexpected                  = TRUE;
    BOOL fContinue                      = FALSE;
    BOOL fSavedExpectSuccess            = ptc->fExpectSuccess;
    API_PARAM_INFO ParamInfo []         = {
        { L"hKey",          Handle,     0,      NULL,   FALSE,  NULL, NULL }
    };
    
    ParamInfo[0].pulParam = hKey;

    if (! ptc->fTestingDestroyKey)
    {
        ptc->fExpectSuccess = TRUE;
    }
    
    fApiSuccessful = CryptDestroyKey(hKey);
    
    fContinue = CheckAndLogStatus(
        API_CRYPTDESTROYKEY,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));

    ptc->fExpectSuccess = fSavedExpectSuccess;
    
    return fContinue;
}

//
// Function: TEncrypt
// Purpose: Call CryptEncrypt with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash, 
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen,
    PTESTCASE ptc)
{
    BOOL fApiSuccessful                     = FALSE;
    //BOOL fUnexpected                      = TRUE;
    BOOL fContinue                          = FALSE;
    DWORD cbData                            = sizeof(DWORD);
    API_PARAM_INFO ParamInfo []             = {
        { L"hKey",          Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"hHash",         Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"Final",         Boolean,    0,          NULL,   FALSE,  NULL, NULL },
        { L"dwFlags",       Dword,      dwFlags,    EncryptFlagToString,FALSE,  NULL, NULL },
        { L"pbData",        Pointer,    0,          NULL,   TRUE,   pdwDataLen, NULL },
        { L"pdwDataLen",    Pointer,    0,          NULL,   TRUE,   &cbData, NULL },
        { L"dwBufLen",      Dword,      dwBufLen,   NULL, FALSE, NULL, NULL}        
    };

    ParamInfo[0].pulParam = hKey;
    ParamInfo[1].pulParam = hHash;
    ParamInfo[2].fParam = Final;
    ParamInfo[4].pbParam = pbData;
    ParamInfo[5].pbParam = (PBYTE) pdwDataLen;
    
    if (! LogInitParamInfo(
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo),
        ptc))
    {
        return FALSE;
    }

    fApiSuccessful = CryptEncrypt(hKey, hHash, Final, dwFlags, pbData, pdwDataLen, dwBufLen);
        
    fContinue = CheckAndLogStatus(
        API_CRYPTENCRYPT,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));

    LogCleanupParamInfo(ParamInfo, APIPARAMINFO_SIZE(ParamInfo));

    return fContinue;
}

//
// Function: TGenKey
// Purpose: Call CryptGenKey with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TGenKey(
             HCRYPTPROV hProv,
             ALG_ID Algid,
             DWORD dwFlags,
             HCRYPTKEY *phKey,
             PTESTCASE ptc)
{
    BOOL fApiSuccessful                 = FALSE;
    //BOOL fUnexpected                  = TRUE;
    BOOL fContinue                      = FALSE;
    DWORD cbData                        = sizeof(HCRYPTKEY);
    API_PARAM_INFO ParamInfo []         = {
        { L"hProv",         Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"Algid",         Dword,      Algid,      AlgidToString, FALSE, NULL, NULL },
        { L"dwFlags",       Dword,      dwFlags,    GenKeyFlagToString, FALSE,  NULL, NULL },
        { L"phKey",         Pointer,    0,          NULL,   TRUE,   &cbData, NULL }
    };

    ParamInfo[0].pulParam = hProv;
    ParamInfo[3].pbParam = (PBYTE) phKey;
    
    //
    // Prompt the user of the test suite when a user protected 
    // key is being created, UNLESS this is a negative test case.
    //
    if (    (CRYPT_USER_PROTECTED & dwFlags) &&
            ptc->fExpectSuccess)
    {
        LogCreatingUserProtectedKey();
        //LogInfo(L"Creating a User Protected key.  You should now see UI.");
    }
    
    fApiSuccessful = CryptGenKey(hProv, Algid, dwFlags, phKey);
            
    fContinue = CheckAndLogStatus(
        API_CRYPTGENKEY,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));

    return fContinue;
}

//
// Function: TGetKey
// Purpose: Call CryptGetKeyParam with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TGetKey(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags,
    PTESTCASE ptc)
{
    BOOL fApiSuccessful                 = FALSE;
    //BOOL fUnexpected                  = TRUE;
    BOOL fContinue                      = FALSE;
    DWORD cbData                        = sizeof(DWORD);
    API_PARAM_INFO ParamInfo []         = {
        { L"hKey",          Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"dwParam",       Dword,      dwParam,    KeyParamToString, FALSE, NULL, NULL },
        { L"pbData",        Pointer,    0,          NULL,   TRUE,   pdwDataLen, NULL },
        { L"pdwDataLen",    Pointer,    0,          NULL,   TRUE,   &cbData, NULL },
        { L"dwFlags",       Dword,      dwFlags,    NULL,   FALSE,  NULL, NULL }
    };
    
    ParamInfo[0].pulParam = hKey;
    ParamInfo[2].pbParam = pbData;
    ParamInfo[3].pbParam = (PBYTE) pdwDataLen;

    switch (dwParam)
    {
    case KP_MODE:
        {
            ParamInfo[4].pfnFlagToString = KeyParamModeToString;
            break;
        }   
    case KP_PERMISSIONS:
        {
            ParamInfo[4].pfnFlagToString = KeyParamPermissionToString;
            break;
        }
    }

    if (! LogInitParamInfo(
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo),
        ptc))
    {
        return FALSE;
    }
    
    fApiSuccessful = CryptGetKeyParam(hKey, dwParam, pbData, pdwDataLen, dwFlags);
        
    fContinue = CheckAndLogStatus(
        API_CRYPTGETKEYPARAM,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));

    LogCleanupParamInfo(ParamInfo, APIPARAMINFO_SIZE(ParamInfo));

    return fContinue;
}

//
// Function: THashSession
// Purpose: Call CryptHashSessionKey with the supplied parameters and pass
// the result to the logging routine.
//
BOOL THashSession(
                  HCRYPTHASH hHash,
                  HCRYPTKEY hKey,
                  DWORD dwFlags,
                  PTESTCASE ptc)
{
    BOOL fApiSuccessful                 = FALSE;
    //BOOL fUnexpected                  = TRUE;
    BOOL fContinue                      = FALSE;
    API_PARAM_INFO ParamInfo []         = {
        { L"hHash",         Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"hKey",          Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"dwFlags",       Dword,      dwFlags,    HashSessionKeyFlagToString, FALSE,  NULL, NULL }
    };
    
    ParamInfo[0].pulParam = hHash;
    ParamInfo[1].pulParam = hKey;

    fApiSuccessful = CryptHashSessionKey(hHash, hKey, dwFlags);
        
    fContinue = CheckAndLogStatus(
        API_CRYPTHASHSESSIONKEY,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));
    
    return fContinue;
}

//
// Function: TSetKey
// Purpose: Call CryptSetKeyParam with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TSetKey(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags,
    PTESTCASE ptc)
{
    BOOL fApiSuccessful                 = FALSE;
    //BOOL fUnexpected                  = TRUE;
    BOOL fContinue                      = FALSE;
    DWORD cbData                        = 0;
    DWORD cbParam                       = 0;
    API_PARAM_INFO ParamInfo []         = {
        { L"hKey",          Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"dwParam",       Dword,      dwParam,    KeyParamToString, FALSE, NULL, NULL },
        { L"pbData",        Pointer,    0,          NULL,   FALSE,  NULL, NULL },
        { L"dwFlags",       Dword,      dwFlags,    NULL,   FALSE,  NULL, NULL }
    };
    
    ParamInfo[0].pulParam = hKey;
    ParamInfo[2].pbParam = pbData;
    
    switch (dwParam)
    {
    case KP_IV:
        {
            // Try to determine how long the IV buffer should be
            cbData = 0;
            if (CryptGetKeyParam(hKey, KP_IV, NULL, &cbData, 0) && cbData)
            {
                ParamInfo[2].fPrintBytes = TRUE;
                ParamInfo[2].pcbBytes = &cbData;
            }
            break;
        }
    case KP_SALT:
        {
            // Try to determine how long the salt buffer should be
            cbParam = sizeof(cbData);
            if (CryptGetKeyParam(hKey, KP_SALT, (PBYTE) &cbData, &cbParam, 0) && cbData)
            {
                ParamInfo[2].fPrintBytes = TRUE;
                ParamInfo[2].pcbBytes = &cbData;
            }
            break;
        }
    case KP_SALT_EX:
        {
            if (pbData != NULL && pbData != (PBYTE) TEST_INVALID_POINTER)
            {
                cbData = sizeof(DWORD) + ((PDATA_BLOB) pbData)->cbData;
                ParamInfo[2].fPrintBytes = TRUE;
                ParamInfo[2].pcbBytes = &cbData;
            }
            break;
        }
    case KP_PERMISSIONS:
        {
            ParamInfo[3].pfnFlagToString = KeyParamPermissionToString;
            // fall through
        }
    case KP_ALGID:
    case KP_EFFECTIVE_KEYLEN:
    case KP_PADDING:
    case KP_MODE_BITS:
        {
            cbData = sizeof(DWORD);
            ParamInfo[2].fPrintBytes = TRUE;
            ParamInfo[2].pcbBytes = &cbData;
            break;
        }
    case KP_MODE:
        {
            cbData = sizeof(DWORD);
            ParamInfo[2].fPrintBytes = TRUE;
            ParamInfo[2].pcbBytes = &cbData;
            ParamInfo[3].pfnFlagToString = KeyParamModeToString;
            break;
        }   

    }

    if (! LogInitParamInfo(
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo),
        ptc))
    {
        return FALSE;
    }
    
    fApiSuccessful = CryptSetKeyParam(hKey, dwParam, pbData, dwFlags);
        
    fContinue = CheckAndLogStatus(
        API_CRYPTSETKEYPARAM,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));

    LogCleanupParamInfo(ParamInfo, APIPARAMINFO_SIZE(ParamInfo));

    return fContinue;
}

//
// Function: TExportKey
// Purpose: Call CryptExportKey with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    PTESTCASE ptc)
{
    BOOL fApiSuccessful                 = FALSE;
    //BOOL fUnexpected                  = TRUE;
    BOOL fContinue                      = FALSE;
    DWORD cbData                        = sizeof(DWORD);
    API_PARAM_INFO ParamInfo []         = {
        { L"hKey",          Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"hExpKey",       Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"dwBlobType",    Dword,      dwBlobType, ExportKeyBlobTypeToString, FALSE, NULL, NULL },
        { L"dwFlags",       Dword,      dwFlags,    ExportKeyFlagToString, FALSE, NULL, NULL },
        { L"pbData",        Pointer,    0,          NULL,   TRUE,   pdwDataLen, NULL },
        { L"pdwDataLen",    Pointer,    0,          NULL,   TRUE,   &cbData, NULL }
    };
        
    ParamInfo[0].pulParam = hKey;
    ParamInfo[1].pulParam = hExpKey;
    ParamInfo[4].pbParam = pbData;
    ParamInfo[5].pbParam = (PBYTE) pdwDataLen;

    if (! LogInitParamInfo(
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo),
        ptc))
    {
        return FALSE;
    }

    fApiSuccessful = CryptExportKey(hKey, hExpKey, dwBlobType, dwFlags, pbData, pdwDataLen);
    
    fContinue = CheckAndLogStatus(
        API_CRYPTEXPORTKEY,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));

    LogCleanupParamInfo(ParamInfo, APIPARAMINFO_SIZE(ParamInfo));

    return fContinue;
}

//
// Function: TGetUser
// Purpose: Call CryptGetUserKey with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TGetUser(
    HCRYPTPROV hProv,
    DWORD dwKeySpec,
    HCRYPTKEY *phUserKey,
    PTESTCASE ptc)
{
    BOOL fApiSuccessful                 = FALSE;
    //BOOL fUnexpected                  = TRUE;
    BOOL fContinue                      = FALSE;
    API_PARAM_INFO ParamInfo []         = {
        { L"hProv",         Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"dwKeySpec",     Dword,      dwKeySpec,  AlgidToString, FALSE, NULL, NULL },
        { L"phUserKey",     Pointer,    0,          NULL,   FALSE,  NULL, NULL }
    };

    ParamInfo[0].pulParam = hProv;
    ParamInfo[2].pbParam = (PBYTE) phUserKey;
    
    fApiSuccessful = CryptGetUserKey(hProv, dwKeySpec, phUserKey);
        
    fContinue = CheckAndLogStatus(
        API_CRYPTGETUSERKEY,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));

    return fContinue;
}

//
// Function: TImportKey
// Purpose: Call CryptImportKey with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TImportKey(
    HCRYPTPROV hProv,
    BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey,
    PTESTCASE ptc)
{
    BOOL fApiSuccessful                 = FALSE;
    //BOOL fUnexpected                  = TRUE;
    BOOL fContinue                      = FALSE;
    DWORD cbData                        = sizeof(HCRYPTKEY);
    API_PARAM_INFO ParamInfo []         = {
        { L"hProv",         Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"pbData",        Pointer,    0,          NULL,   TRUE,   &dwDataLen, NULL },
        { L"dwDataLen",     Dword,      dwDataLen,  NULL,   FALSE,  NULL, NULL },
        { L"hPubKey",       Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"dwFlags",       Dword,      dwFlags,    ImportKeyFlagToString,FALSE,NULL, NULL },
        { L"phKey",         Pointer,    0,          NULL,   TRUE,   &cbData, NULL }
    };
    
    ParamInfo[0].pulParam = hProv;
    ParamInfo[1].pbParam = pbData;
    ParamInfo[3].pulParam = hPubKey;
    ParamInfo[5].pbParam = (PBYTE) phKey;

    if (! LogInitParamInfo(
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo),
        ptc))
    {
        return FALSE;
    }
    
    fApiSuccessful = CryptImportKey(hProv, pbData, dwDataLen, hPubKey, dwFlags, phKey);
        
    fContinue = CheckAndLogStatus(
        API_CRYPTIMPORTKEY,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));

    LogCleanupParamInfo(ParamInfo, APIPARAMINFO_SIZE(ParamInfo));
    
    return fContinue;
}

//
// Function: TSignHash
// Purpose: Call CryptSignHash with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TSignHash(
               HCRYPTHASH hHash,
               DWORD dwKeySpec,
               LPWSTR sDescription,
               DWORD dwFlags,
               BYTE *pbSignature,
               DWORD *pdwSigLen,
               PTESTCASE ptc)
{
    BOOL fApiSuccessful                 = FALSE;
    //BOOL fUnexpected                  = TRUE;
    BOOL fContinue                      = FALSE;
    DWORD cbData                        = sizeof(DWORD);
    API_PARAM_INFO ParamInfo []         = {
        { L"hHash",         Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"dwKeySpec",     Dword,      dwKeySpec,  AlgidToString, FALSE, NULL, NULL },
        { L"sDescription",  String,     0,          NULL,   FALSE,  NULL, NULL },
        { L"dwFlags",       Dword,      dwFlags,    SignHashFlagToString,FALSE, NULL, NULL },
        { L"pbData",        Pointer,    0,          NULL,   TRUE,   pdwSigLen, NULL},
        { L"pdwSigLen",     Pointer,    0,          NULL,   TRUE,   &cbData, NULL}      
    };

    ParamInfo[0].pulParam = hHash;
    ParamInfo[2].pwszParam = sDescription;
    ParamInfo[4].pbParam = pbSignature;
    ParamInfo[5].pbParam = (PBYTE) pdwSigLen;

    if (! LogInitParamInfo(
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo),
        ptc))
    {
        return FALSE;
    }
    
    fApiSuccessful = CryptSignHash(hHash, dwKeySpec, sDescription, dwFlags, pbSignature, pdwSigLen);
    
    fContinue = CheckAndLogStatus(
        API_CRYPTSIGNHASH,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));

    LogCleanupParamInfo(ParamInfo, APIPARAMINFO_SIZE(ParamInfo));

    return fContinue;
}

//
// Function: TVerifySign
// Purpose: Call CryptVerifySign with the supplied parameters and pass
// the result to the logging routine.
//
BOOL TVerifySign(
    HCRYPTHASH hHash,
    BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPWSTR sDescription,
    DWORD dwFlags,
    PTESTCASE ptc)
{
    BOOL fApiSuccessful                 = FALSE;
    //BOOL fUnexpected                  = TRUE;
    BOOL fContinue                      = FALSE;
    API_PARAM_INFO ParamInfo []         = {
        { L"hHash",         Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"pbSignature",   Pointer,    0,          NULL,   TRUE,   &dwSigLen, NULL},
        { L"dwSigLen",      Dword,      dwSigLen,   NULL,   FALSE, NULL, NULL },
        { L"hPubKey",       Handle,     0,          NULL,   FALSE,  NULL, NULL },
        { L"sDescription",  String,     0,          NULL,   FALSE,  NULL, NULL },
        { L"dwFlags",       Dword,      dwFlags,    SignHashFlagToString,FALSE, NULL, NULL }
    };
    
    ParamInfo[0].pulParam = hHash;
    ParamInfo[1].pbParam = pbSignature;
    ParamInfo[3].pulParam = hPubKey;
    ParamInfo[4].pwszParam = sDescription;

    if (! LogInitParamInfo(
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo),
        ptc))
    {
        return FALSE;
    }
    
    fApiSuccessful = CryptVerifySignature(hHash, pbSignature, dwSigLen, hPubKey, sDescription, dwFlags);

    fContinue = CheckAndLogStatus(
        API_CRYPTVERIFYSIGNATURE,
        fApiSuccessful,
        ptc,
        ParamInfo,
        APIPARAMINFO_SIZE(ParamInfo));

    LogCleanupParamInfo(ParamInfo, APIPARAMINFO_SIZE(ParamInfo));

    return fContinue;
}

// -------------
// Test Routines
// -------------

// 
// Function: PositiveAcquireContextTests
// Purpose: Run the appropriate set of positive CryptAcquireContext test cases for 
// the passed in dwCSPClass.
//
BOOL PositiveAcquireContextTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    HCRYPTPROV hProv            = 0;
    DWORD dwProvType            = LogGetProvType();
    LPWSTR pwszProvName         = LogGetProvName();
    LPWSTR pwszContainer        = TEST_CONTAINER;
    //LPWSTR pwszContainer2     = TEST_CONTAINER_2;
    //DWORD dwFlags             = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    
    switch (ptc->dwTestLevel)
    {
    case TEST_LEVEL_CSP:
        {
            //
            // Group 1A
            //
            
            //
            // Do CSP-level positive CryptAcquireContext tests
            //
            LOG_TRY(TAcquire(&hProv, NULL, pwszProvName, dwProvType, CRYPT_VERIFYCONTEXT, ptc));
            
            break;
        }
        
    case TEST_LEVEL_CONTAINER:
        {
            // 
            // Group 5A
            //
            
            //
            // Do Container-level positive CryptAcquireContext tests
            //          
            LOG_TRY(CreateNewContext(&hProv, pwszContainer, CRYPT_NEWKEYSET, ptc));

            LOG_TRY(TRelease(hProv, 0, ptc));
            hProv = 0;

            LOG_TRY(TAcquire(&hProv, pwszContainer, pwszProvName, dwProvType, CRYPT_SILENT, ptc));

            LOG_TRY(TRelease(hProv, 0, ptc));

            LOG_TRY(CreateNewContext(
                &hProv, 
                pwszContainer, 
                CRYPT_MACHINE_KEYSET | CRYPT_NEWKEYSET,
                ptc));

            LOG_TRY(TRelease(hProv, 0, ptc));
            hProv = 0;

            LOG_TRY(TAcquire(
                &hProv, 
                pwszContainer, 
                pwszProvName, 
                dwProvType, 
                CRYPT_MACHINE_KEYSET | CRYPT_SILENT, 
                ptc));          

            break;
        }       
    }
    
    fSuccess = TRUE;
Cleanup:

    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: NegativeAcquireContextTests
// Purpose: Run the appropriate set of negative CryptAcquireContext test cases
// based on the dwTestLevel parameter.
//
BOOL NegativeAcquireContextTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    HCRYPTPROV hProv            = 0;
    DWORD dwProvType            = LogGetProvType();
    LPWSTR pwszProvName         = LogGetProvName();
    LPWSTR pwszContainer        = TEST_CONTAINER;
    DWORD dwFlags               = 0;
    DWORD dwSavedErrorLevel     = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    switch (ptc->dwTestLevel)
    {
    case TEST_LEVEL_CSP:
        {
            //
            // Do CSP-level negative CryptAcquireContext tests
            //
            dwFlags = CRYPT_VERIFYCONTEXT;
            
            //
            // This fails on Win2K because the VTable is constructed correctly, but
            // the NULL phProv causes an AV.  The bug is that the API returns True
            // anyway.
            //
            // 7/20/00 -- Whistler status for this issue is unknown.
            //
            ptc->pwszErrorHelp = L"CryptAcquireContext should fail when phProv is NULL";
            ptc->KnownErrorID = KNOWN_CRYPTACQUIRECONTEXT_NULLPHPROV;
            
            ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
            LOG_TRY(TAcquire(NULL, NULL, pwszProvName, dwProvType, dwFlags, ptc));
            
            ptc->pwszErrorHelp = NULL;
            ptc->KnownErrorID = KNOWN_ERROR_UNKNOWN;
            
            ptc->dwErrorCode = NTE_BAD_FLAGS;
            LOG_TRY(TAcquire(&hProv, pwszContainer, pwszProvName, dwProvType, dwFlags, ptc));
            
            //
            // This fails on Win2K because the VERIFYCONTEXT flag is caught first.  The API
            // succeeds unexpectedly.
            //
            // 7/20/00 -- Whistler status for this issue is unknown.
            //
            ptc->pwszErrorHelp = L"This is an invalid combination of dwFlags values";
            ptc->KnownErrorID = KNOWN_CRYPTACQUIRECONTEXT_BADFLAGS;
            
            ptc->dwErrorCode = NTE_BAD_FLAGS;
            LOG_TRY(TAcquire(&hProv, NULL, pwszProvName, dwProvType, CRYPT_VERIFYCONTEXT | CRYPT_NEWKEYSET, ptc));
            
            ptc->pwszErrorHelp = NULL;
            ptc->KnownErrorID = KNOWN_ERROR_UNKNOWN;
            
            break;
        }
    case TEST_LEVEL_CONTAINER:
        {
            //
            // Do Container-level negative CryptAcquireContext tests
            //
            ptc->dwErrorCode = NTE_BAD_KEYSET;
            LOG_TRY(TAcquire(
                &hProv, 
                TEST_CRYPTACQUIRECONTEXT_CONTAINER, 
                pwszProvName, 
                dwProvType, 
                0, 
                ptc));

            //
            // Test for risky characters in a container name
            //
            dwSavedErrorLevel = ptc->dwErrorLevel;
            ptc->dwErrorLevel = CSP_ERROR_WARNING;
            ptc->pwszErrorHelp = L"Some CSP's may not support container names with backslashes";

            ptc->dwErrorCode = NTE_BAD_KEYSET_PARAM;

            // Make sure this container doesn't already exist
            CryptAcquireContext(&hProv, L"FOO\\BAR", pwszProvName, dwProvType, CRYPT_DELETEKEYSET);
            LOG_TRY(TAcquire(&hProv, L"FOO\\BAR", pwszProvName, dwProvType, CRYPT_NEWKEYSET, ptc));

            ptc->dwErrorLevel = dwSavedErrorLevel;
            ptc->pwszErrorHelp = NULL;
            
            // Create the keyset 
            LOG_TRY(CreateNewContext(&hProv, pwszContainer, CRYPT_NEWKEYSET, ptc));
            
            // Try to create the keyset again
            ptc->dwErrorCode = NTE_EXISTS;
            LOG_TRY(TAcquire(&hProv, pwszContainer, pwszProvName, dwProvType, CRYPT_NEWKEYSET, ptc));
            
            break;
        }
    }

    fSuccess = TRUE;
Cleanup:

    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: TestBuildAlgList
// Purpose: A wrapper for the BuildAlgList function
//
BOOL TestBuildAlgList(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    HCRYPTPROV hProv            = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    LOG_TRY(BuildAlgList(hProv, pCSPInfo));

    fSuccess = TRUE;
Cleanup:

    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: CheckEnumalgs
// Purpose: Call CryptGetProvParam with the PP_ENUMALGS flag to enumerate
// all the CSP's supported algorithms.  Compare the results of this enumeration
// to the results of the PP_ENUMALGS_EX enumeration contained in the pAlgList
// param.
//
BOOL CheckEnumalgs(
        IN HCRYPTPROV hProv, 
        IN PALGNODE pAlgList, 
        IN PTESTCASE ptc)
{
    BOOL fContinue          = TRUE;
    //PBYTE pbData          = NULL;
    DWORD cbData            = 0;
    DWORD dwFlags           = CRYPT_FIRST;
    PROV_ENUMALGS ProvEnumalgs;
    DWORD dw                = 0;
    //DWORD dwWinError      = 0;
    //DWORD dwErrorType     = 0;
    WCHAR rgwszError [ BUFFER_SIZE ];

    memset(&ProvEnumalgs, 0, sizeof(ProvEnumalgs));
    cbData = sizeof(ProvEnumalgs);

    ptc->fEnumerating = TRUE;

    LogTestCaseSeparator(FALSE); // Log a blank line first
    LogInfo(L"CryptGetProvParam PP_ENUMALGS: enumerating supported algorithms");

    while( TGetProv(
        hProv,
        PP_ENUMALGS,
        (PBYTE) &ProvEnumalgs,
        &cbData,
        dwFlags,
        ptc))
    {
        // Increment the test case counter for every enumerated alg
        ++ptc->dwTestCaseID;

        if (NULL == pAlgList)
        {
            ptc->pwszErrorHelp = L"PP_ENUMALGS_EX enumerated fewer algorithms than PP_ENUMALGS";
            LOG_TRY(LogApiFailure(
                API_CRYPTGETPROVPARAM,
                ERROR_LIST_TOO_SHORT,
                ptc));
            ptc->pwszErrorHelp = NULL;
        }
        
        if (    ProvEnumalgs.aiAlgid != pAlgList->ProvEnumalgsEx.aiAlgid ||
                ProvEnumalgs.dwBitLen != pAlgList->ProvEnumalgsEx.dwDefaultLen ||
                ProvEnumalgs.dwNameLen != pAlgList->ProvEnumalgsEx.dwNameLen ||
                0 != strcmp(ProvEnumalgs.szName, pAlgList->ProvEnumalgsEx.szName) )
        {
            if (CALG_MAC == ProvEnumalgs.aiAlgid)
            {
                ptc->KnownErrorID = KNOWN_CRYPTGETPROVPARAM_MAC;
            }

            wsprintf(
                rgwszError,
                L"%s: %s",
                L"PP_ENUMALGS data doesn't match PP_ENUMALGS_EX data for the following algorithm",
                ProvEnumalgs.szName);

            ptc->pwszErrorHelp = rgwszError;
                
            LOG_TRY(LogApiFailure(
                API_CRYPTGETPROVPARAM,
                ERROR_BAD_DATA,
                ptc));
            ptc->pwszErrorHelp = NULL;
            ptc->KnownErrorID = KNOWN_ERROR_UNKNOWN;
        }
        
        pAlgList = pAlgList->pAlgNodeNext;
        
        if (CRYPT_FIRST == dwFlags)
        {
            dwFlags = 0;
        }

        LogProvEnumalgs(&ProvEnumalgs);
    }
    
    if (ERROR_NO_MORE_ITEMS != (dw = GetLastError()))
    {
        ptc->pwszErrorHelp = L"PP_ENUMALGS failed unexpectedly";
        ptc->dwErrorCode = ERROR_NO_MORE_ITEMS;
        ptc->fExpectSuccess = FALSE;
        LOG_TRY(LogApiFailure(
            API_CRYPTGETPROVPARAM,
            ERROR_WRONG_ERROR_CODE,
            ptc));
    }

    ptc->fEnumerating = FALSE;
    fContinue = TRUE;
Cleanup:

    ptc->KnownErrorID = KNOWN_ERROR_UNKNOWN;
    ptc->pwszErrorHelp = NULL;
    
    return fContinue;
}

//
// Function: CheckRequiredAlgs
// Purpose: Verify that all of the required algorithms
// for CSP's of this type are supported by this CSP.
//
BOOL CheckRequiredAlgs(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    DWORD dwCSPClass            = pCSPInfo->dwCSPInternalClass;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    PALGNODE pAlgList           = pCSPInfo->pAlgList;
    PALGNODE pAlgNode           = NULL;
    DWORD iTable                = 0;
    BOOL fFound                 = FALSE;
    WCHAR rgsz[BUFFER_SIZE];

    //
    // For each required alg for dwCSPClass, verify
    // that the alg is listed in pAlgList.  If it's not,
    // assume that this CSP doesn't support that alg
    // and flag an error.
    //
    LogTestCaseSeparator(FALSE); // Log a blank line first
    LogInfo(L"List of Required algorithms for this CSP type");
    for (
        iTable = 0; 
        iTable < sizeof(g_RequiredAlgs_RSA) / sizeof(ALGID_TABLE);
        iTable++)
    {
        if (! (dwCSPClass & g_RequiredAlgs_RSA[iTable].dwCSPClass))
        {
            continue;
        }

        fFound = FALSE;

        AlgidToString(g_RequiredAlgs_RSA[iTable].ai, rgsz);
        LogInfo(rgsz);

        //
        // Search pAlgList for the current ALG_ID
        //
        for (
            pAlgNode = pAlgList;
            pAlgNode != NULL && (! fFound);
            pAlgNode = pAlgNode->pAlgNodeNext)
        {
            if (g_RequiredAlgs_RSA[iTable].ai == pAlgNode->ProvEnumalgsEx.aiAlgid)
            {
                fFound = TRUE;
            }
        }

        if (! fFound)
        {
            LOG_TRY(LogApiFailure(
                API_CRYPTGETPROVPARAM,
                ERROR_REQUIRED_ALG,
                ptc));
        }
    }

    fSuccess = TRUE;

Cleanup:
    return fSuccess;
}

//
// Function: PositiveGetProvParamTests
// Purpose: Run the test cases for CryptGetProvParam
//
BOOL PositiveGetProvParamTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    HCRYPTPROV hProv            = 0;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    PBYTE pbData                = NULL;
    DWORD dwData                = 0;
    DWORD dwFlags               = CRYPT_FIRST;
    DWORD cbData                = 0;
    DWORD dwError               = 0;
    DWORD dwSavedErrorLevel     = 0;
    LPWSTR pwsz                 = NULL;     
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    switch (ptc->dwTestLevel)
    {
    case TEST_LEVEL_CSP:
        {
    
            // 
            // Group 1B
            //
            
            //
            // Do CryptGetProvParam positive test cases
            //
            LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));
            
            LOG_TRY(BuildAlgList(hProv, pCSPInfo));
            
            LOG_TRY(CheckEnumalgs(hProv, pCSPInfo->pAlgList, ptc));

            ptc->fExpectSuccess = TRUE;

            LOG_TRY(CheckRequiredAlgs(pCSPInfo));

            //
            // Test PP_IMPTYPE
            //
            cbData = sizeof(dwData);
            LOG_TRY(TGetProv(
                        hProv,
                        PP_IMPTYPE,
                        (PBYTE) &dwData,
                        &cbData,
                        0,
                        ptc));

            if (CRYPT_IMPL_SOFTWARE != dwData)
            {
                // Set the expected behavior for a non-software-only
                // CSP.
                pCSPInfo->fSmartCardCSP = TRUE;
            }

            //
            // Test PP_NAME
            //
            LOG_TRY(TGetProv(
                        hProv,
                        PP_NAME,
                        NULL,
                        &cbData,
                        0,
                        ptc));

            LOG_TRY(TestAlloc(&pbData, cbData, ptc));

            LOG_TRY(TGetProv(
                        hProv,
                        PP_NAME,
                        pbData,
                        &cbData,
                        0,
                        ptc));

            ptc->KnownErrorID = KNOWN_CRYPTGETPROVPARAM_PPNAME;
            if (0 != wcscmp(
                        (LPWSTR) pbData,
                        pCSPInfo->pwszCSPName))
            {
                ptc->pwszErrorHelp = L"CryptGetProvParam PP_NAME is not Unicode";
                LOG_TRY(LogApiFailure(
                    API_CRYPTGETPROVPARAM,
                    ERROR_BAD_DATA,
                    ptc));
                ptc->pwszErrorHelp = NULL;
            }
            ptc->KnownErrorID = KNOWN_ERROR_UNKNOWN;

            free(pbData);
            pbData = NULL;

            //
            // Test PP_VERSION
            //
            cbData = sizeof(dwData);
            LOG_TRY(TGetProv(
                        hProv,
                        PP_VERSION,
                        (PBYTE) &dwData,
                        &cbData,
                        0,
                        ptc));

            //
            // Test PP_SIG_KEYSIZE_INC
            //
            cbData = sizeof(dwData);
            LOG_TRY(TGetProv(
                        hProv,
                        PP_SIG_KEYSIZE_INC,
                        (PBYTE) &dwData,
                        &cbData,
                        0,
                        ptc));

            pCSPInfo->dwSigKeysizeInc = dwData;

            //
            // Test PP_KEYX_KEYSIZE_INC
            //
            cbData = sizeof(dwData);
            LOG_TRY(TGetProv(
                        hProv,
                        PP_KEYX_KEYSIZE_INC,
                        (PBYTE) &dwData,
                        &cbData,
                        0,
                        ptc));

            pCSPInfo->dwKeyXKeysizeInc = dwData;

            //
            // Test PP_PROVTYPE
            //
            cbData = sizeof(dwData);
            LOG_TRY(TGetProv(
                        hProv,
                        PP_PROVTYPE,
                        (PBYTE) &dwData,
                        &cbData,
                        0,
                        ptc));

            if (dwData != pCSPInfo->dwExternalProvType)
            {
                ptc->pwszErrorHelp = L"CryptGetProvParam PP_PROVTYPE is incorrect";
                LOG_TRY(LogApiFailure(
                    API_CRYPTGETPROVPARAM,
                    ERROR_BAD_DATA,
                    ptc));
                ptc->pwszErrorHelp = NULL;
            }

            //
            // Test PP_USE_HARDWARE_RNG
            //
            // TODO - dumb down the error level of this test case, since most
            // CSP's will probably return FALSE
            //
            dwSavedErrorLevel = ptc->dwErrorLevel;
            ptc->dwErrorLevel = CSP_ERROR_WARNING;
            ptc->pwszErrorHelp = 
                L"CryptGetProvParam reports that this system has no hardware Random Number Generator configured";

            cbData = 0;
            LOG_TRY(TGetProv(
                        hProv,
                        PP_USE_HARDWARE_RNG,
                        NULL,
                        &cbData,
                        0,
                        ptc));

            ptc->dwErrorLevel = dwSavedErrorLevel;
            ptc->pwszErrorHelp = NULL;

            //
            // Test PP_KEYSPEC
            //
            cbData = sizeof(dwData);
            LOG_TRY(TGetProv(
                        hProv,
                        PP_KEYSPEC,
                        (PBYTE) &dwData,
                        &cbData,
                        0,
                        ptc));

            pCSPInfo->dwKeySpec = dwData;

            break;
        }
    case TEST_LEVEL_CONTAINER:
        {
            LOG_TRY(CreateNewContext(&hProv, pwszContainer, CRYPT_NEWKEYSET, ptc));

            // 
            // Do PP_ENUMCONTAINERS enumeration
            //
            dwFlags = CRYPT_FIRST;
            ptc->fEnumerating = TRUE;
            
            LogInfo(L"PP_ENUMCONTAINERS: enumerating user containers");
            
            while (TEST_INVALID_FLAG != dwFlags)
            {
                while(  TGetProv(
                    hProv,
                    PP_ENUMCONTAINERS,
                    NULL,
                    &cbData,
                    dwFlags,
                    ptc))
                {
                    if (NULL != pbData)
                    {
                        free(pbData);
                    }
                    
                    LOG_TRY(TestAlloc(&pbData, cbData, ptc));
                    
                    LOG_TRY(TGetProv(
                        hProv,
                        PP_ENUMCONTAINERS,
                        pbData,
                        &cbData,
                        dwFlags,
                        ptc));
                    
                    pwsz = MkWStr((LPSTR) pbData);
                    if (pwsz)
                    {
                        LogInfo(pwsz);
                        free(pwsz);
                    }
                    
                    if (CRYPT_FIRST & dwFlags)
                    {
                        dwFlags ^= CRYPT_FIRST;
                    }
                }
                
                if (ERROR_NO_MORE_ITEMS != (dwError = GetLastError()))
                {   
                    ptc->fExpectSuccess = FALSE;
                    ptc->dwErrorCode = ERROR_NO_MORE_ITEMS;
                    ptc->pwszErrorHelp = L"PP_ENUMCONTAINERS failed unexpectedly";
                    LOG_TRY(LogApiFailure(
                        API_CRYPTGETPROVPARAM,
                        ERROR_WRONG_ERROR_CODE,
                        ptc));
                    ptc->pwszErrorHelp = NULL;
                }

                if (CRYPT_MACHINE_KEYSET != dwFlags)
                {
                    dwFlags = CRYPT_MACHINE_KEYSET | CRYPT_FIRST;
                    LogInfo(L"PP_ENUMCONTAINERS: enumerating local machine containers");
                }
                else
                {
                    dwFlags = TEST_INVALID_FLAG;
                }
            }
            
            ptc->fEnumerating = FALSE;
            ptc->fExpectSuccess = TRUE;

            //
            // Test PP_KEYSET_SEC_DESCR
            //
            cbData = sizeof(dwData);
            LOG_TRY(TGetProv(
                        hProv,
                        PP_KEYSET_SEC_DESCR,
                        (PBYTE) &dwData,
                        &cbData,
                        OWNER_SECURITY_INFORMATION,
                        ptc));

            cbData = sizeof(dwData);
            LOG_TRY(TGetProv(
                        hProv,
                        PP_KEYSET_SEC_DESCR,
                        (PBYTE) &dwData,
                        &cbData,
                        GROUP_SECURITY_INFORMATION,
                        ptc));

            cbData = sizeof(dwData);
            LOG_TRY(TGetProv(
                        hProv,
                        PP_KEYSET_SEC_DESCR,
                        (PBYTE) &dwData,
                        &cbData,
                        DACL_SECURITY_INFORMATION,
                        ptc));

            cbData = sizeof(dwData);
            LOG_TRY(TGetProv(
                        hProv,
                        PP_KEYSET_SEC_DESCR,
                        (PBYTE) &dwData,
                        &cbData,
                        SACL_SECURITY_INFORMATION,
                        ptc));

            //
            // Test PP_UNIQUE_CONTAINER
            //
            LOG_TRY(TGetProv(
                        hProv, 
                        PP_UNIQUE_CONTAINER,
                        NULL,
                        &cbData,
                        0,
                        ptc));

            LOG_TRY(TestAlloc(&pbData, cbData, ptc));

            LOG_TRY(TGetProv(
                        hProv,
                        PP_UNIQUE_CONTAINER,
                        pbData,
                        &cbData,
                        0,
                        ptc));

            free(pbData);
            pbData = NULL;

            break;
        }
    }
            
    fSuccess = TRUE;
Cleanup:

    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }
    if (pbData)
    {
        free(pbData);
    }

    return fSuccess;    
}

//
// Function: NegativeGetProvParamTests
// Purpose: Run the negative test cases for CryptGetProvParam
//
BOOL NegativeGetProvParamTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    HCRYPTPROV hProv            = 0;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    //PBYTE pbData              = NULL;
    DWORD dwData                = 0;
    DWORD cbData                = 0;
    PROV_ENUMALGS_EX ProvEnumalgsEx;
    
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    //
    // Do CryptGetProvParam negative test cases
    //
    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TGetProv(0, PP_ENUMALGS_EX, (PBYTE) &ProvEnumalgsEx, &cbData, 0, ptc));

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TGetProv(TEST_INVALID_HANDLE, PP_ENUMALGS_EX, (PBYTE) &ProvEnumalgsEx, &cbData, 0, ptc));

    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
    LOG_TRY(TGetProv(hProv, PP_VERSION, (PBYTE) &dwData, NULL, 0, ptc));

    ptc->KnownErrorID = KNOWN_CRYPTGETPROVPARAM_MOREDATA;
    cbData = 1;
    ptc->dwErrorCode = ERROR_MORE_DATA;
    LOG_TRY(TGetProv(hProv, PP_CONTAINER, (PBYTE) &dwData, &cbData, 0, ptc));
    ptc->KnownErrorID = KNOWN_ERROR_UNKNOWN;

    cbData = sizeof(ProvEnumalgsEx);
    ptc->dwErrorCode = NTE_BAD_FLAGS;
    LOG_TRY(TGetProv(hProv, PP_ENUMALGS_EX, (PBYTE) &ProvEnumalgsEx, &cbData, TEST_INVALID_FLAG, ptc));

    ptc->dwErrorCode = NTE_BAD_TYPE;
    LOG_TRY(TGetProv(hProv, TEST_INVALID_FLAG, (PBYTE) &ProvEnumalgsEx, &cbData, 0, ptc));

    fSuccess = TRUE;
Cleanup:

    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;    
}

//
// Function: PositiveSetProvParamTests
// Purpose: Run the test cases for CryptSetProvParam
//
BOOL PositiveSetProvParamTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    HCRYPTPROV hProv            = 0;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    DWORD cbData                = 0;
    DWORD dwData                = 0;
    HWND hWnd                   = 0;
    DWORD dwSavedErrorLevel     = 0;
    SECURITY_DESCRIPTOR SecurityDescriptor;
        
    PTESTCASE ptc = &(pCSPInfo->TestCase);

    memset(&SecurityDescriptor, 0, sizeof(SecurityDescriptor));

    switch (ptc->dwTestLevel)
    {
    case TEST_LEVEL_CSP:
        {
            LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

            // 
            // Group 1C
            //
            
            //
            // Do CryptSetProvParam positive test cases
            //

            
            //
            // Test PP_CLIENT_HWND
            //
            if (NULL == (hWnd = GetDesktopWindow()))
            {
                LOG_TRY(LogApiFailure(
                    API_GETDESKTOPWINDOW, 
                    ERROR_API_FAILED,
                    ptc));
                //LOG_TRY(LogWin32Fail(ptc->dwErrorLevel, ptc->dwTestCaseID));
            }
            
            cbData = sizeof(hWnd);
            LOG_TRY(TSetProv(
                0,
                PP_CLIENT_HWND,
                (PBYTE) &hWnd,
                0,
                ptc));

            //
            // Test PP_USE_HARDWARE_RNG
            //
            // TODO: Dumb down the error level of this test case since
            // some CSP's will not support it.  
            //
            // TODO: What effect does this flag have on systems that don't actually
            // have a hardware RNG?
            //
            dwSavedErrorLevel = ptc->dwErrorLevel;
            ptc->dwErrorLevel = CSP_ERROR_WARNING;
            ptc->pwszErrorHelp = 
                L"CryptSetProvParam reports that this system has no hardware Random Number Generator";

            LOG_TRY(TSetProv(
                        hProv,
                        PP_USE_HARDWARE_RNG,
                        NULL,
                        0,
                        ptc));

            ptc->dwErrorLevel = dwSavedErrorLevel;
            ptc->pwszErrorHelp = NULL;

            break;
        }

    case TEST_LEVEL_CONTAINER:
        {
            LOG_TRY(CreateNewContext(&hProv, pwszContainer, CRYPT_NEWKEYSET, ptc));

            //
            // Test PP_KEYSET_SEC_DESCR
            //
            cbData = sizeof(dwData);
            LOG_TRY(TGetProv(
                        hProv,
                        PP_KEYSET_SEC_DESCR,
                        (PBYTE) &dwData,
                        &cbData,
                        OWNER_SECURITY_INFORMATION,
                        ptc));

            LOG_TRY(TSetProv(
                        hProv,
                        PP_KEYSET_SEC_DESCR,
                        (PBYTE) &dwData,
                        OWNER_SECURITY_INFORMATION,
                        ptc));

            cbData = sizeof(dwData);
            LOG_TRY(TGetProv(
                        hProv,
                        PP_KEYSET_SEC_DESCR,
                        (PBYTE) &dwData,
                        &cbData,
                        GROUP_SECURITY_INFORMATION,
                        ptc));

            LOG_TRY(TSetProv(
                        hProv,
                        PP_KEYSET_SEC_DESCR,
                        (PBYTE) &dwData,
                        GROUP_SECURITY_INFORMATION,
                        ptc));

            cbData = sizeof(dwData);
            LOG_TRY(TGetProv(
                        hProv,
                        PP_KEYSET_SEC_DESCR,
                        (PBYTE) &dwData,
                        &cbData,
                        DACL_SECURITY_INFORMATION,
                        ptc));

            LOG_TRY(TSetProv(
                        hProv,
                        PP_KEYSET_SEC_DESCR,
                        (PBYTE) &dwData,
                        DACL_SECURITY_INFORMATION,
                        ptc));

            cbData = sizeof(dwData);
            LOG_TRY(TGetProv(
                        hProv,
                        PP_KEYSET_SEC_DESCR,
                        (PBYTE) &dwData,
                        &cbData,
                        SACL_SECURITY_INFORMATION,
                        ptc));

            LOG_TRY(TSetProv(
                        hProv,
                        PP_KEYSET_SEC_DESCR,
                        (PBYTE) &dwData,
                        SACL_SECURITY_INFORMATION,
                        ptc));

            break;
        }
    }

    fSuccess = TRUE;
Cleanup:

    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: NegativeSetProvParamTests
// Purpose: Run the negative test cases for CryptSetProvParam
//
BOOL NegativeSetProvParamTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    HCRYPTPROV hProv            = 0;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    DWORD dwData                = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    SECURITY_DESCRIPTOR SecurityDescriptor;

    memset(&SecurityDescriptor, 0, sizeof(SecurityDescriptor));

    // 
    // Group 1C
    //

    //
    // Do CryptSetProvParam negative test cases
    //

    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TSetProv(hProv, PP_CLIENT_HWND, (PBYTE) TEST_INVALID_HANDLE, 0, ptc));

    ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
    LOG_TRY(TSetProv(hProv, PP_KEYSET_SEC_DESCR, NULL, OWNER_SECURITY_INFORMATION, ptc));

    ptc->pwszErrorHelp = 
        L"The pbData parameter must be NULL when calling CryptSetProvParam PP_USE_HARDWARE_RNG";
    ptc->KnownErrorID = KNOWN_CRYPTSETPROVPARAM_RNG;
    ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
    LOG_TRY(TSetProv(hProv, PP_USE_HARDWARE_RNG, (PBYTE) &dwData, 0, ptc));
    ptc->pwszErrorHelp = NULL;
    ptc->KnownErrorID = KNOWN_ERROR_UNKNOWN;

    ptc->pwszErrorHelp = 
        L"The dwFlags parameter must be zero when calling CryptSetProvParam PP_USE_HARDWARE_RNG";
    ptc->KnownErrorID = KNOWN_CRYPTSETPROVPARAM_BADFLAGS;
    ptc->dwErrorCode = NTE_BAD_FLAGS;
    LOG_TRY(TSetProv(hProv, PP_USE_HARDWARE_RNG, NULL, 1, ptc));
    ptc->pwszErrorHelp = NULL;
    ptc->KnownErrorID = KNOWN_ERROR_UNKNOWN;

    //
    // 7/25/00 -- This test case is too specific to the Microsoft CSP's.
    //
    /*
    ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
    LOG_TRY(TSetProv(hProv, PP_KEYSET_SEC_DESCR, (PBYTE) &SecurityDescriptor, OWNER_SECURITY_INFORMATION, ptc));
    */

    ptc->dwErrorCode = NTE_BAD_TYPE;
    LOG_TRY(TSetProv(hProv, TEST_INVALID_FLAG, (PBYTE) &dwData, 0, ptc));

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TSetProv(0, PP_USE_HARDWARE_RNG, NULL, 0, ptc));

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TSetProv(TEST_INVALID_HANDLE, PP_USE_HARDWARE_RNG, NULL, 0, ptc));

    fSuccess = TRUE;
Cleanup:

    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

// 
// Function: PositiveReleaseContextTests
// Purpose: Run the test cases for CryptReleaseContext
//
BOOL PositiveReleaseContextTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    HCRYPTPROV hProv            = 0;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    //
    // Group 1D
    //

    //
    // Do CryptReleaseContext positive test cases
    //
    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    if (! CryptContextAddRef(hProv, NULL, 0))
    {
        LOG_TRY(LogApiFailure(
            API_CRYPTCONTEXTADDREF,
            ERROR_API_FAILED,
            ptc));
        //LOG_TRY(LogWin32Fail(ptc->dwErrorLevel, ptc->dwTestCaseID));
    }

    LOG_TRY(TRelease(hProv, 0, ptc));

    LOG_TRY(TRelease(hProv, 0, ptc));

    fSuccess = TRUE;
Cleanup:

    return fSuccess;
}

// 
// Function: NegativeReleaseContextTests
// Purpose: Run the negative test cases for CryptReleaseContext
//
BOOL NegativeReleaseContextTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    HCRYPTPROV hProv            = 0;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    //
    // Group 1D
    //

    //
    // Do CryptReleaseContext negative test cases
    //
    ptc->fTestingReleaseContext = TRUE;

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TRelease(0, 0, ptc));

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TRelease(TEST_INVALID_HANDLE, 0, ptc));

    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    ptc->dwErrorCode = NTE_BAD_FLAGS;
    LOG_TRY(TRelease(hProv, 1, ptc));

    fSuccess = TRUE;
Cleanup:

    ptc->fTestingReleaseContext = FALSE;

    return fSuccess;
}

//
// Function: PositiveGenRandomTests
// Purpose: Run the test cases for CryptGenRandom
//
BOOL PositiveGenRandomTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    DWORD cb                    = GENRANDOM_BYTE_COUNT;
    BYTE rgBuffer[GENRANDOM_BYTE_COUNT];

    PTESTCASE ptc = &(pCSPInfo->TestCase);

    // 
    // Group 2A
    //

    //
    // Do CryptGenRandom positive test cases
    //
    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    LOG_TRY(TGenRand(hProv, cb, rgBuffer, ptc));

    fSuccess = TRUE;
Cleanup:

    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: NegativeGenRandomTests
// Purpose: Run the negative test cases for CryptGenRandom
//
BOOL NegativeGenRandomTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    //DWORD dw                  = 0;
    PBYTE pb                    = NULL;     
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    // 
    // Group 2A
    //

    //
    // Do CryptGenRandom negative test cases
    //

    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
    LOG_TRY(TGenRand(hProv, 1, NULL, ptc));

    LOG_TRY(TestAlloc(&pb, GENRANDOM_BYTE_COUNT, ptc));

    ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
    LOG_TRY(TGenRand(hProv, 2 * GENRANDOM_BYTE_COUNT, pb, ptc));

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TGenRand(0, GENRANDOM_BYTE_COUNT, pb, ptc));

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TGenRand(TEST_INVALID_HANDLE, GENRANDOM_BYTE_COUNT, pb, ptc));


    fSuccess = TRUE;
Cleanup:

    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }
    if (pb)
    {
        free(pb);
    }

    return fSuccess;
}

//
// Function: TestCreateHashProc
// Purpose: This function verifies that CryptCreateHash is successful
// for the hash algorithm specified in the pAlgNode parameter.
//
// For known MAC algorithms (ALG_SID_MAC and ALG_SIG_HMAC), a block
// cipher key (provided via pvTestCreateHashInfo) is provided when creating
// the hash handle.  
//
// For other, non-keyed, hash algorithms, the cipher key will not 
// be used.
//
BOOL TestCreateHashProc(
        PALGNODE pAlgNode,
        PTESTCASE ptc,
        PVOID pvTestCreateHashInfo)
{
    BOOL fSuccess                               = FALSE;
    HCRYPTHASH hHash                            = 0;
    DWORD dwSavedErrorLevel                     = ptc->dwErrorLevel;
    PTEST_CREATE_HASH_INFO pTestCreateHashInfo  = (PTEST_CREATE_HASH_INFO) pvTestCreateHashInfo;

    if (pAlgNode->fIsRequiredAlg)
    {
        ptc->dwErrorLevel = CSP_ERROR_CONTINUE;
    }
    else
    {
        ptc->dwErrorLevel = CSP_ERROR_WARNING;
    }

            
    if (MacAlgFilter(pAlgNode))
    {
        LOG_TRY(TCreateHash(
            pTestCreateHashInfo->hProv,
            pAlgNode->ProvEnumalgsEx.aiAlgid,
            pTestCreateHashInfo->hBlockCipherKey,
            0,
            &hHash,
            ptc));
    }
    else
    {
        LOG_TRY(TCreateHash(
            pTestCreateHashInfo->hProv,
            pAlgNode->ProvEnumalgsEx.aiAlgid,
            0,
            0,
            &hHash,
            ptc));
    }
        
    fSuccess = TRUE;
Cleanup:

    ptc->dwErrorLevel = dwSavedErrorLevel;

    if (hHash)
    {
        TDestroyHash(hHash, ptc);
    }

    return fSuccess;
}


//
// Function: PositiveCreateHashTests
// Purpose: Run the test cases for CryptCreateHash based on the CSP class being tested
// as specified in the dwCSPClass parameter.
//
BOOL PositiveCreateHashTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    TEST_CREATE_HASH_INFO TestCreateHashInfo;

    memset(&TestCreateHashInfo, 0, sizeof(TestCreateHashInfo));
    
    LOG_TRY(CreateNewContext(
        &(TestCreateHashInfo.hProv),
        NULL, 
        CRYPT_VERIFYCONTEXT, 
        ptc));

    //
    // Create an RC2 key for testing keyed-hashes (MAC).  RC2 is a required algorithm,
    // but if this fails, and the CSP does support one or more MAC algs, the creation
    // of the MAC hash handles (see TestCreateHashProc) may fail as well.
    //
    /*
    LOG_TRY(CreateNewKey(
        TestCreateHashInfo.hProv,
        CALG_RC2,
        0,
        &(TestCreateHashInfo.hBlockCipherKey),
        ptc));
    */

    //
    // Group 3A
    //

    //
    // Do CryptCreateHash positive test cases
    //

    //
    // Iterate through the ENUMALGS_EX structs stored in the ALGNODE list.
    // Create a hash of each type supported by this CSP.
    //
    LOG_TRY(AlgListIterate(
        pCSPInfo->pAlgList,
        HashAlgFilter,
        TestCreateHashProc,
        (PVOID) &TestCreateHashInfo,
        ptc));

    // This test case set probably doesn't belong here, since
    // symmetric keys haven't been tested at this point.
    /*
    LOG_TRY(AlgListIterate(
        pCSPInfo->pAlgList,
        MacAlgFilter,
        TestCreateHashProc,
        (PVOID) &TestCreateHashInfo,
        ptc));
    */

    fSuccess = TRUE;

Cleanup:
    if (TestCreateHashInfo.hBlockCipherKey)
    {
        TDestroyKey(TestCreateHashInfo.hBlockCipherKey, ptc);
    }
    if (TestCreateHashInfo.hProv)
    {
        TRelease(TestCreateHashInfo.hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: NegativeCreateHashTests
// Purpose: Run the test cases for CryptCreateHash based on the CSP class being tested
// as specified in the dwCSPClass parameter.
//
BOOL NegativeCreateHashTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    HCRYPTPROV hProv            = 0;
    HCRYPTHASH  hHash           = 0;
    HCRYPTKEY hKey              = 0;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    //
    // Group 3A
    //

    //
    // Do CryptGenRandom negative test cases
    //

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TCreateHash(0, CALG_SHA1, 0, 0, &hHash, ptc));

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TCreateHash(TEST_INVALID_HANDLE, CALG_SHA1, 0, 0, &hHash, ptc));

    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    ptc->dwErrorCode = NTE_BAD_FLAGS;
    LOG_TRY(TCreateHash(hProv, CALG_SHA1, 0, TEST_INVALID_FLAG, &hHash, ptc));
    
    ptc->dwErrorCode = NTE_BAD_KEY;
    LOG_TRY(TCreateHash(hProv, CALG_HMAC, 0, 0, &hHash, ptc));

    // HMAC requires a block cipher, so use a stream cipher and expect failure
    LOG_TRY(CreateNewKey(hProv, CALG_RC4, 0, &hKey, ptc));

    ptc->pwszErrorHelp = 
        L"CryptCreateHash CALG_HMAC should fail when not using a block cipher key";
    ptc->KnownErrorID = KNOWN_CRYPTCREATEHASH_BADKEY;
    ptc->dwErrorCode = NTE_BAD_KEY;
    LOG_TRY(TCreateHash(hProv, CALG_HMAC, hKey, 0, &hHash, ptc));
    ptc->pwszErrorHelp = NULL;
    ptc->KnownErrorID = KNOWN_ERROR_UNKNOWN;

    ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
    LOG_TRY(TCreateHash(hProv, CALG_SHA1, 0, 0, NULL, ptc));

    ptc->dwErrorCode = NTE_BAD_ALGID;
    LOG_TRY(TCreateHash(hProv, CALG_RC4, 0, 0, &hHash, ptc));


    fSuccess = TRUE;

Cleanup:

    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: PositiveDestroyHashTests
// Purpose: Run the test cases for CryptDestroyHash
//
BOOL PositiveDestroyHashTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTHASH hHash            = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    
    //
    // Group 3B
    //

    //
    // Do CryptDestroyHash positive test cases
    //

    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    LOG_TRY(CreateNewHash(hProv, CALG_SHA1, &hHash, ptc));

    LOG_TRY(TDestroyHash(hHash, ptc));
    hHash = 0;

    fSuccess = TRUE;

Cleanup:
    if (hHash)
    {
        TDestroyHash(hHash, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: NegativeDestroyHashTests
// Purpose: Run the test cases for CryptDestroyHash
//
BOOL NegativeDestroyHashTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTHASH hHash            = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    //
    // Group 3B
    //

    //
    // Do CryptDestroyHash negative test cases
    //
    ptc->fTestingDestroyHash = TRUE;

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TDestroyHash(0, ptc));

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TDestroyHash(TEST_INVALID_HANDLE, ptc));

    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    LOG_TRY(CreateNewHash(hProv, CALG_SHA1, &hHash, ptc));

    /*
    LOG_TRY(TRelease(hProv, 0, ptc));
    hProv = 0;

    // Provider handle used to create hHash is now invalid
    ptc->dwErrorCode = NTE_BAD_UID;
    LOG_TRY(TDestroyHash(hHash, ptc));
    */


    fSuccess = TRUE;

Cleanup:

    ptc->fTestingDestroyHash = FALSE;

    if (hHash)
    {
        TDestroyHash(hHash, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: PositiveGetHashParamTests
// Purpose: Run the test cases for CryptGetHashParam
//
BOOL PositiveGetHashParamTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTHASH hHash            = 0;
    DWORD dwData                = 0;
    DWORD cbData                = 0;        
    PBYTE pbData                = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    
    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    //
    // Group 3D
    //

    //
    // Do CryptGetHashParam positive test cases
    //

    //
    // Test HP_ALGID
    //
    LOG_TRY(CreateNewHash(hProv, CALG_SHA1, &hHash, ptc));

    cbData = sizeof(dwData);
    LOG_TRY(TGetHash(
                hHash, 
                HP_ALGID,
                (PBYTE) &dwData,
                &cbData,
                0,
                ptc));

    if (CALG_SHA1 != dwData)
    {
        ptc->pwszErrorHelp = L"CryptGetHashParam HP_ALGID returned incorrect ALG_ID";
        LOG_TRY(LogApiFailure(
            API_CRYPTGETHASHPARAM,
            ERROR_BAD_DATA,
            ptc));
        ptc->pwszErrorHelp = NULL;
    }

    //
    // Test HP_HASHSIZE
    //
    cbData = sizeof(dwData);
    LOG_TRY(TGetHash(
                hHash,
                HP_HASHSIZE,
                (PBYTE) &dwData,
                &cbData,
                0,
                ptc));

    if (HASH_LENGTH_SHA1 != dwData)
    {
        ptc->pwszErrorHelp = L"CryptGetHashParam HP_HASHSIZE returned incorrect length";
        LOG_TRY(LogApiFailure(
            API_CRYPTGETHASHPARAM,
            ERROR_WRONG_SIZE,
            ptc));
        ptc->pwszErrorHelp = NULL;
    }

    //
    // Test HP_HASHVAL
    //
    cbData = HASH_LENGTH_SHA1;
    LOG_TRY(TestAlloc(&pbData, cbData, ptc));

    LOG_TRY(TGetHash(
                hHash,
                HP_HASHVAL,
                pbData,
                &cbData,
                0,
                ptc));

    fSuccess = TRUE;

Cleanup:
    if (hHash)
    {
        TDestroyHash(hHash, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }
    if (pbData)
    {
        free(pbData);
    }

    return fSuccess;
}

//
// Function: NegativeGetHashParamTests
// Purpose: Run the negative test cases for CryptGetHashParam
//
BOOL NegativeGetHashParamTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTHASH hHash            = 0;
    DWORD dw                    = 0;
    DWORD cb                    = 0;        
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    
    //
    // Group 3D
    //

    //
    // Do CryptGetHashParam negative test cases
    //

    cb = sizeof(dw);
    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TGetHash(0, HP_HASHSIZE, (PBYTE) &dw, &cb, 0, ptc));

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TGetHash(TEST_INVALID_HANDLE, HP_HASHSIZE, (PBYTE) &dw, &cb, 0, ptc));

    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    LOG_TRY(CreateNewHash(hProv, CALG_SHA1, &hHash, ptc));

    ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
    LOG_TRY(TGetHash(hHash, HP_HASHSIZE, (PBYTE) &dw, NULL, 0, ptc));

    //
    // This corrupts memory since it doesn't immediately AV
    //
    /*
    cb = HASH_LENGTH_SHA1;
    ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
    LOG_TRY(TGetHash(hHash, HP_HASHVAL, (PBYTE) &dw, &cb, 0, ptc));
    */

    cb = HASH_LENGTH_SHA1 - 1;
    ptc->dwErrorCode = ERROR_MORE_DATA;
    LOG_TRY(TGetHash(hHash, HP_HASHVAL, (PBYTE) &dw, &cb, 0, ptc));

    cb = sizeof(dw);
    ptc->dwErrorCode = NTE_BAD_FLAGS;
    LOG_TRY(TGetHash(hHash, HP_HASHSIZE, (PBYTE) &dw, &cb, TEST_INVALID_FLAG, ptc));

    ptc->dwErrorCode = NTE_BAD_TYPE;
    LOG_TRY(TGetHash(hHash, TEST_INVALID_FLAG, (PBYTE) &dw, &cb, 0, ptc));

    /*
    LOG_TRY(TRelease(hProv, 0, ptc));
    hProv = 0;

    // Provider handle used to create hHash is now invalid
    ptc->dwErrorCode = NTE_BAD_UID;
    LOG_TRY(TGetHash(hHash, HP_HASHSIZE, (PBYTE) &dw, &cb, 0, ptc));
    */

    fSuccess = TRUE;

Cleanup:

    if (hHash)
    {
        TDestroyHash(hHash, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}



//
// Function: TestMacDataWithKeyProc
// Purpose: This function tests MAC functionality.  First, a session key
// is created of the block-cipher algorithm indicated in pAlgNode.
// Then a keyed hash is created using that key and the hash algorithm
// specified in pvTestHashDataInfo.
//
// After the base data (in pvTestHashDataInfo) is hashed, the result is
// passed to CheckHashedData to verify that the same result is attained
// with a second, separate CSP.
//
BOOL TestMacDataWithKeyProc(
        PALGNODE pAlgNode,
        PTESTCASE ptc,
        PVOID pvTestHashDataInfo)
{
    BOOL fSuccess                               = FALSE;
    PTEST_HASH_DATA_INFO pTestHashDataInfo      = (PTEST_HASH_DATA_INFO) pvTestHashDataInfo;
    HCRYPTHASH  hHash                           = 0;
    HCRYPTKEY hKey                              = 0;
    HASH_INFO HashInfo;
    TEST_MAC_INFO MacInfo;

    memset(&HashInfo, 0, sizeof(HashInfo));
    memset(&MacInfo, 0, sizeof(MacInfo));

    HashInfo.aiHash = pTestHashDataInfo->aiMac;
    HashInfo.dbBaseData.cbData = pTestHashDataInfo->dbBaseData.cbData;
    HashInfo.dbBaseData.pbData = pTestHashDataInfo->dbBaseData.pbData;

    LOG_TRY(TGenKey(
                pTestHashDataInfo->hProv, 
                pAlgNode->ProvEnumalgsEx.aiAlgid, 
                CRYPT_EXPORTABLE, 
                &hKey, 
                ptc));

    LOG_TRY(ExportPlaintextSessionKey(
                hKey,
                pTestHashDataInfo->hProv,
                &(MacInfo.dbKey), 
                ptc));

    memcpy(&(MacInfo.HmacInfo), &(pTestHashDataInfo->HmacInfo), sizeof(HMAC_INFO));

    LOG_TRY(CreateHashAndAddData(
                pTestHashDataInfo->hProv,
                &hHash,
                &HashInfo,
                ptc,
                hKey,
                &(MacInfo.HmacInfo)));
    
    LOG_TRY(TGetHash(
                hHash,
                HP_HASHVAL,
                NULL,
                &(HashInfo.dbHashValue.cbData),
                0,
                ptc));
    
    LOG_TRY(TestAlloc(
                &(HashInfo.dbHashValue.pbData), 
                HashInfo.dbHashValue.cbData, 
                ptc));
    
    LOG_TRY(TGetHash(
                hHash,
                HP_HASHVAL,
                HashInfo.dbHashValue.pbData,
                &(HashInfo.dbHashValue.cbData),
                0,
                ptc));
    
    LOG_TRY(CheckHashedData(
                &HashInfo,
                pTestHashDataInfo->hInteropProv,
                ptc, 
                &MacInfo));

    fSuccess = TRUE;
Cleanup:

    if (MacInfo.dbKey.pbData)
    {
        free(MacInfo.dbKey.pbData);
    }
    if (HashInfo.dbHashValue.pbData)
    {
        free(HashInfo.dbHashValue.pbData);
    }
    if (hHash)
    {
        TDestroyHash(hHash, ptc);
    }
    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }

    return fSuccess;
}



//
// Function: TestMacDataProc
//
BOOL TestMacDataProc(
        PALGNODE pAlgNode,
        PTESTCASE ptc,
        PVOID pvTestHashDataInfo)
{
    //
    // Because of the filter used before calling this function,
    // we know that pAlgNode contains a ProvEnumalgsEx structure that
    // corresponds to a MAC'ing algorithm.  Save the ALG_ID for the current
    // MAC algorithm and pass it through to the TestMacDataWithKeyProc, which
    // will do the real work of creating the keyed hash.
    //
    ((PTEST_HASH_DATA_INFO) pvTestHashDataInfo)->aiMac = pAlgNode->ProvEnumalgsEx.aiAlgid;

    return AlgListIterate(
            ((PTEST_HASH_DATA_INFO) pvTestHashDataInfo)->pAlgList,
            BlockCipherFilter,
            TestMacDataWithKeyProc,
            pvTestHashDataInfo,
            ptc);
}

//
// Function: TestHashDataProc
//
BOOL TestHashDataProc(
        PALGNODE pAlgNode, 
        PTESTCASE ptc, 
        PVOID pvTestHashDataInfo)
{
    HCRYPTHASH hHash        = 0;
    BOOL fSuccess           = FALSE;
    DWORD dwSavedErrorLevel = ptc->dwErrorLevel;
    HASH_INFO HashInfo;
    PTEST_HASH_DATA_INFO pTestHashDataInfo = (PTEST_HASH_DATA_INFO) pvTestHashDataInfo;
    
    memset(&HashInfo, 0, sizeof(HashInfo));
    
    if (! pAlgNode->fIsRequiredAlg)
    {
        ptc->dwErrorLevel = CSP_ERROR_WARNING;
    }
    
    HashInfo.aiHash = pAlgNode->ProvEnumalgsEx.aiAlgid;
    HashInfo.dbBaseData.cbData = pTestHashDataInfo->dbBaseData.cbData;
    HashInfo.dbBaseData.pbData = pTestHashDataInfo->dbBaseData.pbData;
    
    //
    // Call CreateHashAndAddData with the required parameters
    // for a non-keyed hash alg.
    //
    LOG_TRY(CreateHashAndAddData(
        pTestHashDataInfo->hProv,
        &hHash,
        &HashInfo,
        ptc,
        0, NULL));
    
    LOG_TRY(TGetHash(
        hHash,
        HP_HASHVAL,
        NULL,
        &(HashInfo.dbHashValue.cbData),
        0,
        ptc));
    
    LOG_TRY(TestAlloc(
        &(HashInfo.dbHashValue.pbData), 
        HashInfo.dbHashValue.cbData, 
        ptc));
    
    LOG_TRY(TGetHash(
        hHash,
        HP_HASHVAL,
        HashInfo.dbHashValue.pbData,
        &(HashInfo.dbHashValue.cbData),
        0,
        ptc));
    
    //
    // Call CheckHashedData with the required information
    // for a non-keyed hash.
    //
    LOG_TRY(CheckHashedData(
        &HashInfo,
        pTestHashDataInfo->hInteropProv,
        ptc,
        NULL));
    
    fSuccess = TRUE;
Cleanup:
    ptc->dwErrorLevel = dwSavedErrorLevel;

    if (HashInfo.dbHashValue.pbData)
    {
        free(HashInfo.dbHashValue.pbData);
    }
    if (hHash)
    {
        TDestroyHash(hHash, ptc);
    }

    return fSuccess;
}

//
// Function: InteropHashDataTests
// Purpose: Run the interop test scenarios for CryptHashData
//
BOOL InteropHashDataTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    PALGNODE pAlgList           = pCSPInfo->pAlgList;
    TEST_HASH_DATA_INFO TestHashDataInfo;

    memset(&TestHashDataInfo, 0, sizeof(TestHashDataInfo));
    
    LOG_TRY(CreateNewContext(
                &(TestHashDataInfo.hProv),
                NULL,
                CRYPT_VERIFYCONTEXT,
                ptc));

    LOG_TRY(CreateNewInteropContext(
                &(TestHashDataInfo.hInteropProv),
                NULL,
                CRYPT_VERIFYCONTEXT,
                ptc));
    
    // 
    // Initialize the test data to be hashed
    //
    TestHashDataInfo.dbBaseData.cbData = wcslen(TEST_HASH_DATA) * sizeof(WCHAR);
    LOG_TRY(TestAlloc(
        &(TestHashDataInfo.dbBaseData.pbData), 
        TestHashDataInfo.dbBaseData.cbData, 
        ptc));
    
    memcpy(
        TestHashDataInfo.dbBaseData.pbData, 
        TEST_HASH_DATA, 
        TestHashDataInfo.dbBaseData.cbData);
    
    //
    // Non-keyed Hashes
    //
    // Iterate through the ENUMALGS_EX structs stored in the ALGNODE list.
    // Create a hash of each type supported by this CSP.
    //
    LOG_TRY(AlgListIterate(
        pAlgList,
        HashAlgFilter,
        TestHashDataProc,
        (PVOID) (&TestHashDataInfo),
        ptc));
    
    //
    // Keyed Hashes
    //
    // TODO: Currently using SHA1 as the only HMAC test case.  Is
    // there a problem with that?  The alternative would be 
    // to make the below AlgListIterate loop longer.
    //
    TestHashDataInfo.HmacInfo.HashAlgid = CALG_SHA1;
    
    //
    // Iterate through all required hash algorithms and all
    // required block cipher algorithms.
    //
    TestHashDataInfo.pAlgList = pCSPInfo->pAlgList;
    
    LOG_TRY(AlgListIterate(
        pAlgList,
        MacAlgFilter,
        TestMacDataProc,
        (PVOID) (&TestHashDataInfo),
        ptc));

    fSuccess = TRUE;
Cleanup:

    if (TestHashDataInfo.hProv)
    {
        TRelease(TestHashDataInfo.hProv, 0, ptc);
    }
    if (TestHashDataInfo.dbBaseData.pbData)
    {
        free(TestHashDataInfo.dbBaseData.pbData);
    }
    if (TestHashDataInfo.hInteropProv)
    {
        TRelease(TestHashDataInfo.hInteropProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: PositiveHashDataTests
// Purpose: Run the test cases for CryptHashData
//
BOOL PositiveHashDataTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    HCRYPTHASH hHash            = 0;
    HCRYPTPROV hProv            = 0;
    DWORD cb                    = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    BYTE rgbHashSha[HASH_LENGTH_SHA1];
    BYTE rgbHashMD5[HASH_LENGTH_MD5];

    memset(rgbHashSha, 0, HASH_LENGTH_SHA1);
    memset(rgbHashMD5, 0, HASH_LENGTH_MD5);
    
    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    LOG_TRY(CreateNewHash(hProv, CALG_SHA1, &hHash, ptc));

    LOG_TRY(THashData(hHash, KNOWN_HASH_DATA, KNOWN_HASH_DATALEN, 0, ptc));

    cb = HASH_LENGTH_SHA1;
    LOG_TRY(TGetHash(hHash, HP_HASHVAL, rgbHashSha, &cb, 0, ptc));

    if (0 != memcmp(rgbHashSha, g_rgbKnownSHA1, HASH_LENGTH_SHA1))
    {
        LOG_TRY(LogBadParam(
            API_CRYPTHASHDATA,
            L"Incorrect SHA1 hash value", 
            ptc));
    }

    LOG_TRY(TDestroyHash(hHash, ptc));
    hHash = 0;

    LOG_TRY(CreateNewHash(hProv, CALG_MD5, &hHash, ptc));

    LOG_TRY(THashData(hHash, KNOWN_HASH_DATA, KNOWN_HASH_DATALEN, 0, ptc));

    cb = HASH_LENGTH_MD5;
    LOG_TRY(TGetHash(hHash, HP_HASHVAL, rgbHashMD5, &cb, 0, ptc));

    if (0 != memcmp(rgbHashMD5, g_rgbKnownMD5, HASH_LENGTH_MD5))
    {
        LOG_TRY(LogBadParam(
            API_CRYPTHASHDATA,
            L"Incorrect MD5 hash value", 
            ptc));
    }

    LOG_TRY(TDestroyHash(hHash, ptc));
    hHash = 0;

    fSuccess = TRUE;
Cleanup:

    if (hHash)
    {
        TDestroyHash(hHash, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }   

    return fSuccess;
}

//
// Function: NegativeHashDataTests
// Purpose: Run the negative test cases for CryptHashData
//
BOOL NegativeHashDataTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTHASH hHash            = 0;
    PBYTE pb                    = NULL;
    DWORD cb                    = 0;        
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    DWORD dwSavedErrorLevel     = 0;
    
    //
    // Group 3E
    //

    //
    // Do CryptHashData negative test cases
    //

    pb = (PBYTE) TEST_HASH_DATA;

    // Not hashing terminating Null
    cb = wcslen(TEST_HASH_DATA) * sizeof(WCHAR);

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(THashData(0, pb, cb, 0, ptc));

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(THashData(TEST_INVALID_HANDLE, pb, cb, 0, ptc));

    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    LOG_TRY(CreateNewHash(hProv, CALG_SHA1, &hHash, ptc));

    ptc->dwErrorCode = NTE_BAD_DATA;
    LOG_TRY(THashData(hHash, NULL, cb, 0, ptc));

    //
    // 7/25/00 -- leaving this test case out, since the current
    // behavior seems friendlier.
    //
    /*
    ptc->dwErrorCode = NTE_BAD_LEN;
    LOG_TRY(THashData(hHash, pb, 0, 0, ptc));
    */

    ptc->dwErrorCode = NTE_BAD_FLAGS;
    LOG_TRY(THashData(hHash, pb, cb, TEST_INVALID_FLAG, ptc));

    // For CSP's that support CRYPT_USERDATA, cbData must be zero, or error
    dwSavedErrorLevel = ptc->dwErrorLevel;
    ptc->dwErrorLevel = CSP_ERROR_WARNING;
    ptc->pwszErrorHelp = 
        L"CryptHashData CRYPT_USERDATA should fail when dwDataLen is not zero (optional)";  
    ptc->dwErrorCode = NTE_BAD_LEN;
    LOG_TRY(THashData(hHash, pb, 1, CRYPT_USERDATA, ptc));
    ptc->dwErrorLevel = dwSavedErrorLevel;
    ptc->pwszErrorHelp = NULL;

    /*
    LOG_TRY(TRelease(hProv, 0, ptc));
    hProv = 0;

    // Provider handle used to create hHash is now invalid
    ptc->dwErrorCode = NTE_BAD_UID;
    LOG_TRY(THashData(hHash, pb, cb, 0, ptc));
    */


    fSuccess = TRUE;
Cleanup:

    if (hHash)
    {
        TDestroyHash(hHash, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: PositiveSetHashParamTests
// Purpose: Run the test cases for CryptSetHashParam
//
BOOL PositiveSetHashParamTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTHASH hHash            = 0;
    BYTE rgHashVal[HASH_LENGTH_SHA1];
    PTESTCASE ptc = &(pCSPInfo->TestCase);

    memset(rgHashVal, 0, sizeof(rgHashVal));
    
    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    LOG_TRY(CreateNewHash(hProv, CALG_SHA1, &hHash, ptc));

    //
    // Group 3F
    //

    //
    // Do CryptSetHashParam positive test cases
    //

    //
    // Skip testing HP_HMAC_INFO here.  It's only an interesting test
    // if the CSP supports a MAC alg.  This is already covered in the 
    // CryptHashData tests.
    //

    //
    // Test HP_HASHVAL
    //
    LOG_TRY(TSetHash(
                hHash,
                HP_HASHVAL,
                rgHashVal,
                0,
                ptc));

    fSuccess = TRUE;

Cleanup:

    if (hHash)
    {
        TDestroyHash(hHash, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: NegativeSetHashParamTests
// Purpose: Run the negative test cases for CryptSetHashParam
//
BOOL NegativeSetHashParamTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTHASH hHash            = 0;
    DWORD dw                    = 0;
    //DWORD cb                  = 0;
    BYTE rgHashVal[HASH_LENGTH_SHA1];   
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    
    memset(rgHashVal, 0, sizeof(rgHashVal));
    
    //
    // Group 3F
    //

    //
    // Do CryptSetHashParam negative test cases
    //

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TSetHash(0, HP_HASHVAL, rgHashVal, 0, ptc));

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TSetHash(TEST_INVALID_HANDLE, HP_HASHVAL, rgHashVal, 0, ptc));

    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    LOG_TRY(CreateNewHash(hProv, CALG_SHA1, &hHash, ptc));
    
    ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
    LOG_TRY(TSetHash(hHash, HP_HASHVAL, NULL, 0, ptc));

    // Hash value buffer is too short
    /*
    ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
    LOG_TRY(TSetHash(hHash, HP_HASHVAL, (PBYTE) &dw, 0, ptc));
    */

    ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
    LOG_TRY(TSetHash(hHash, HP_HASHVAL, (PBYTE) TEST_INVALID_POINTER, 0, ptc));

    ptc->dwErrorCode = NTE_BAD_TYPE;
    LOG_TRY(TSetHash(hHash, HP_HMAC_INFO, (PBYTE) &dw, 0, ptc));

    ptc->dwErrorCode = NTE_BAD_FLAGS;
    LOG_TRY(TSetHash(hHash, HP_HASHVAL, rgHashVal, TEST_INVALID_FLAG, ptc));

    ptc->dwErrorCode = NTE_BAD_TYPE;
    LOG_TRY(TSetHash(hHash, TEST_INVALID_FLAG, rgHashVal, 0, ptc));

    /*
    LOG_TRY(TRelease(hProv, 0, ptc));
    hProv = 0;

    // Provider handle used to create hHash is now invalid
    ptc->dwErrorCode = NTE_BAD_UID;
    LOG_TRY(TSetHash(hHash, HP_HASHVAL, rgHashVal, 0, ptc));
    */

    fSuccess = TRUE;

Cleanup:

    if (hHash)
    {
        TDestroyHash(hHash, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}


//
// Function: TestDecryptProc
//
BOOL TestDecryptProc(
        PALGNODE pAlgNode,
        PTESTCASE ptc,
        PVOID pvTestDecryptInfo)
{
    BOOL fSuccess                           = FALSE;
    PTEST_DECRYPT_INFO pTestDecryptInfo     = (PTEST_DECRYPT_INFO) pvTestDecryptInfo;
    TEST_ENCRYPT_INFO TestEncryptInfo;
    
    memset(&TestEncryptInfo, 0, sizeof(TestEncryptInfo));

    //
    // TODO: There are a lot more permutations possible when calling
    // ProcessCipherData.
    //
    // 1) Modulate key sizes
    // 2) Switch cipher modes
    // 3) Use salt
    // 4) Use IV's
    //
    TestEncryptInfo.aiKeyAlg = pAlgNode->ProvEnumalgsEx.aiAlgid;
    TestEncryptInfo.dwKeySize = pAlgNode->ProvEnumalgsEx.dwMaxLen;
    TestEncryptInfo.Operation = pTestDecryptInfo->fDecrypt ? OP_Decrypt : OP_Encrypt;

    LOG_TRY(ProcessCipherData(
        pTestDecryptInfo->hProv,
        &TestEncryptInfo,
        ptc));

    LOG_TRY(VerifyCipherData(
        pTestDecryptInfo->hInteropProv,
        &TestEncryptInfo,
        ptc));

    fSuccess = TRUE;
Cleanup:

    return fSuccess;
}

//
// Function: ScenarioDecryptTests
// Purpose: Run decrypt/encryption scenarios for this CSP
//
BOOL ScenarioDecryptTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    LPWSTR pwszContainer2       = TEST_CONTAINER_2;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    TEST_DECRYPT_INFO TestDecryptInfo;
    
    memset(&TestDecryptInfo, 0, sizeof(TestDecryptInfo));
    
    LOG_TRY(CreateNewContext(
        &(TestDecryptInfo.hProv),
        pwszContainer,
        CRYPT_NEWKEYSET,
        ptc));
    
    LOG_TRY(CreateNewContext(
        &(TestDecryptInfo.hInteropProv),
        pwszContainer2,
        CRYPT_NEWKEYSET,
        ptc));

    LOG_TRY(AlgListIterate(
        pCSPInfo->pAlgList,
        DataEncryptFilter,
        TestDecryptProc,
        (PVOID) (&TestDecryptInfo),
        ptc));
    
    fSuccess = TRUE;

Cleanup:

    if (TestDecryptInfo.hProv)
    {
        TRelease(TestDecryptInfo.hProv, 0, ptc);
    }
    if (TestDecryptInfo.hInteropProv)
    {
        TRelease(TestDecryptInfo.hInteropProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: InteropDecryptTests
// Purpose: Run decrypt/encryption interop scenarios for this 
// and a second CSP.
//
BOOL InteropDecryptTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    LPWSTR pwszInteropContainer = TEST_CONTAINER_2;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    TEST_DECRYPT_INFO TestDecryptInfo;
    
    memset(&TestDecryptInfo, 0, sizeof(TestDecryptInfo));
    
    LOG_TRY(CreateNewContext(
        &(TestDecryptInfo.hProv),
        pwszContainer,
        CRYPT_NEWKEYSET,
        ptc));
    
    LOG_TRY(CreateNewInteropContext(
        &(TestDecryptInfo.hInteropProv),
        pwszInteropContainer,
        CRYPT_NEWKEYSET,
        ptc));

    LOG_TRY(AlgListIterate(
        pCSPInfo->pAlgList,
        DataEncryptFilter,
        TestDecryptProc,
        (PVOID) (&TestDecryptInfo),
        ptc));

    fSuccess = TRUE;

Cleanup:

    if (TestDecryptInfo.hProv)
    {
        TRelease(TestDecryptInfo.hProv, 0, ptc);
    }
    if (TestDecryptInfo.hInteropProv)
    {
        TRelease(TestDecryptInfo.hInteropProv, 0, ptc);
    }

    return fSuccess;
}

//
// RSA Key-exchange private key blob.  Used
// by PositiveDecryptTests, below.
//
BYTE g_rgbRSAPrivateKeyXBlob [] =
{
0x07, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00,
0x52, 0x53, 0x41, 0x32, 0x00, 0x02, 0x00, 0x00,
0x01, 0x00, 0x01, 0x00, 0x13, 0x98, 0xf3, 0x0d,
0x08, 0x86, 0x14, 0x94, 0xc8, 0x7b, 0x29, 0x71,
0xa4, 0x5f, 0xdf, 0xf4, 0xf4, 0x8f, 0x29, 0x00,
0x07, 0xfa, 0xb0, 0x39, 0xe2, 0x36, 0x09, 0x7e,
0xff, 0x89, 0xea, 0xb9, 0xac, 0xcd, 0xdd, 0xc6,
0xce, 0x14, 0x21, 0x42, 0x85, 0x93, 0x7a, 0x63,
0x79, 0xdc, 0x21, 0xf3, 0x8c, 0x42, 0x5e, 0xdb,
0xe1, 0x72, 0x42, 0x81, 0xdb, 0xc6, 0xc9, 0x1e,
0xd5, 0x45, 0x2a, 0xb9, 0x91, 0x0a, 0xaa, 0x2c,
0x9f, 0x41, 0xde, 0x0e, 0x31, 0x0a, 0xee, 0x17,
0x24, 0xb9, 0xe6, 0x61, 0x88, 0x15, 0x69, 0x1e,
0x24, 0xea, 0x54, 0x1d, 0xbe, 0xc9, 0x6f, 0x1d,
0x74, 0xf8, 0xa7, 0xe4, 0x63, 0x62, 0xc6, 0x44,
0x2e, 0xfa, 0x19, 0x89, 0xdf, 0x1d, 0x97, 0x70,
0x4a, 0x7a, 0xef, 0x92, 0x22, 0xff, 0xcc, 0xae,
0x4e, 0x58, 0x77, 0xff, 0x78, 0xcb, 0x03, 0x6e,
0xc3, 0xe0, 0x4e, 0xcf, 0x21, 0xdf, 0x91, 0x35,
0x3e, 0xf3, 0xa0, 0x92, 0xc5, 0x3f, 0xd9, 0xa1,
0x00, 0x1a, 0x3e, 0x72, 0xbe, 0x22, 0x10, 0xe5,
0xb3, 0xda, 0xa0, 0x95, 0x45, 0xc7, 0x92, 0x99,
0x87, 0xa4, 0x8d, 0x43, 0x55, 0xca, 0xa5, 0x8d,
0x80, 0xec, 0xb5, 0xe2, 0x1f, 0xc8, 0x9c, 0x54,
0x07, 0xfa, 0x7a, 0x4c, 0xfe, 0xf9, 0x9f, 0xe5,
0x2b, 0xb8, 0x85, 0x3c, 0x0f, 0xe9, 0x41, 0xb1,
0x74, 0x8f, 0x48, 0x99, 0x7c, 0x70, 0x40, 0x05,
0xe1, 0xb2, 0x75, 0x9a, 0xb7, 0x70, 0x40, 0xd2,
0x2e, 0xc1, 0xbb, 0xc1, 0x63, 0xbf, 0x5a, 0x59,
0x4d, 0xcf, 0xec, 0x05, 0xfb, 0x1d, 0xab, 0x5d,
0x45, 0x1c, 0x69, 0x14, 0x21, 0x56, 0x31, 0xd6,
0x86, 0x99, 0x32, 0x59, 0xd6, 0x88, 0x53, 0x12,
0x54, 0xe3, 0xe5, 0x07, 0x5b, 0xcc, 0x5e, 0xbd,
0x83, 0xea, 0x38, 0x56, 0x45, 0x74, 0x39, 0x0b,
0x30, 0xf6, 0xe2, 0x56, 0x4d, 0xae, 0x69, 0xf5,
0xb4, 0xf6, 0x35, 0x6f, 0xa8, 0x6f, 0x87, 0xb0,
0x52, 0x5b, 0x33, 0xea, 0xdc, 0xd8, 0x83, 0xa3,
0xec, 0xda, 0x2c, 0xdd, 0xb5, 0x0a, 0xea, 0x15,
0x1c, 0x68, 0xaa, 0x8b
};

//
// Cipher text encrypted with the g_rgbRSAPrivateKeyXBlob
// above.  Used by PositiveDecryptTests.
//
BYTE g_rgbRSACipherText [] =
{
0xd8, 0x9f, 0xcd, 0xd2, 0x77, 0x45, 0x76, 0x77,
0x66, 0x32, 0x4c, 0x88, 0x2d, 0xcf, 0xdc, 0xfd,
0xe5, 0x03, 0xfc, 0x4e, 0x65, 0xd1, 0x77, 0xd5,
0x90, 0x3d, 0x71, 0x88, 0x1e, 0xff, 0x3b, 0x27,
0xff, 0x4c, 0xb9, 0xc5, 0x6b, 0x6b, 0x4d, 0xd9,
0x9e, 0x11, 0x88, 0xcb, 0xb8, 0xbb, 0x48, 0xc8,
0xc3, 0x7e, 0xb0, 0xd5, 0x0d, 0x1a, 0x2e, 0xed,
0x6a, 0x4a, 0x45, 0xb1, 0xdc, 0x6e, 0x65, 0x42
};

//
// Function: PositiveDecryptTests
// Purpose: Run the test cases for CryptDecrypt
//
BOOL PositiveDecryptTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    HCRYPTPROV hProv            = 0;
    HCRYPTKEY hKey              = 0;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    PBYTE pbData                = NULL;
    DWORD cbData                = 0;
    //DWORD dw                  = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    //
    // Group 4A
    //

    //
    // Do CryptDecrypt positive test cases
    //
    
    switch( pCSPInfo->TestCase.dwTestLevel )
    {
    case TEST_LEVEL_KEY:
        {
            LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));
            
            //
            // Run some basic decryption tests for a stream cipher
            //
            LOG_TRY(CreateNewKey(hProv, CALG_RC4, 0, &hKey, ptc));
            
            cbData = wcslen(TEST_DECRYPT_DATA) * sizeof(WCHAR);
            
            LOG_TRY(TestAlloc(&pbData, cbData, ptc));
            
            memcpy(pbData, TEST_DECRYPT_DATA, cbData);
            
            LOG_TRY(TDecrypt(hKey, 0, TRUE, 0, pbData, &cbData, ptc));
            
            break;
        }
        
    case TEST_LEVEL_CONTAINER:
        {
            LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_NEWKEYSET, ptc));

            //
            // Import a known RSA key-exchange key pair.
            //
            LOG_TRY(TImportKey(
                hProv,
                g_rgbRSAPrivateKeyXBlob,
                sizeof(g_rgbRSAPrivateKeyXBlob),
                0,
                0,
                &hKey,
                ptc));

            cbData = sizeof(g_rgbRSACipherText);

            LOG_TRY(TDecrypt(
                hKey,
                0,
                TRUE,
                0,
                g_rgbRSACipherText,
                &cbData,
                ptc));
            
            break;
        }
        
    default:
        {
            goto Cleanup;
        }
    }
    
    fSuccess = TRUE;

Cleanup:

    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: NegativeDecryptTests
// Purpose: Run the negative test cases for CryptDecrypt
//
BOOL NegativeDecryptTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTKEY hKey              = 0;
    DWORD cb                    = 0;
    //DWORD dw                  = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    DWORD dwSavedErrorLevel     = 0;
    BYTE rgCipherText[TEST_CIPHER_LENGTH_RC4];
    BYTE rgRC2CipherText[TEST_RC2_BUFFER_LEN];
    

    memset(rgCipherText, 0, sizeof(rgCipherText));
    memset(rgRC2CipherText, 0, sizeof(rgRC2CipherText));
        
    //
    // Group 4A
    //

    //
    // Do CryptDecrypt negative test cases
    //

    cb = sizeof(rgCipherText);
    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TDecrypt(0, 0, TRUE, 0, rgCipherText, &cb, ptc));

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TDecrypt(TEST_INVALID_HANDLE, 0, TRUE, 0, rgCipherText, &cb, ptc));

    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    LOG_TRY(CreateNewKey(hProv, CALG_RC4, 0, &hKey, ptc));

    ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
    LOG_TRY(TDecrypt(hKey, 0, TRUE, 0, (PBYTE) TEST_INVALID_POINTER, &cb, ptc));

    cb = sizeof(rgCipherText);
    ptc->dwErrorCode = NTE_BAD_FLAGS;
    LOG_TRY(TDecrypt(hKey, 0, TRUE, TEST_INVALID_FLAG, rgCipherText, &cb, ptc));

    ptc->dwErrorCode = NTE_BAD_HASH;
    LOG_TRY(TDecrypt(hKey, TEST_INVALID_HANDLE, TRUE, 0, rgCipherText, &cb, ptc));

    cb = 0;
    ptc->dwErrorCode = NTE_BAD_LEN;
    LOG_TRY(TDecrypt(hKey, 0, TRUE, 0, rgCipherText, &cb, ptc));

    ptc->fExpectSuccess = TRUE;
    cb = sizeof(rgCipherText);
    LOG_TRY(TDecrypt(hKey, 0, TRUE, 0, rgCipherText, &cb, ptc));
    ptc->fExpectSuccess = FALSE;

    // This will only fail on no-export CSP's
    dwSavedErrorLevel = ptc->dwErrorLevel;
    ptc->dwErrorLevel = CSP_ERROR_WARNING;
    ptc->pwszErrorHelp = L"This CSP supports double-decryption";
    
    ptc->dwErrorCode = NTE_DOUBLE_ENCRYPT;
    LOG_TRY(TDecrypt(hKey, 0, TRUE, 0, rgCipherText, &cb, ptc));
    
    ptc->dwErrorLevel = dwSavedErrorLevel;
    ptc->pwszErrorHelp = NULL;

    //
    // Test block cipher issues with an RC2 key
    //
    LOG_TRY(TDestroyKey(hKey, ptc));
    hKey = 0;

    LOG_TRY(CreateNewKey(hProv, CALG_RC2, 0, &hKey, ptc));

    cb = TEST_RC2_DATA_LEN;
    ptc->fExpectSuccess = TRUE;
    LOG_TRY(TEncrypt(
        hKey, 
        0, 
        TRUE, 
        0, 
        rgRC2CipherText, 
        &cb, 
        sizeof(rgRC2CipherText), 
        ptc));
    ptc->fExpectSuccess = FALSE;

    cb--;
    ptc->dwErrorCode = NTE_BAD_DATA;
    LOG_TRY(TDecrypt(hKey, 0, TRUE, 0, rgRC2CipherText, &cb, ptc));

    /*
    LOG_TRY(TRelease(hProv, 0, ptc));
    hProv = 0;

    cb = sizeof(rgCipherText);
    memset(rgCipherText, 0, cb);

    ptc->dwErrorCode = NTE_BAD_UID;
    LOG_TRY(TDecrypt(hKey, 0, TRUE, 0, rgCipherText, &cb, ptc));
    */
    

    fSuccess = TRUE;

Cleanup:

    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: TestDeriveKeyProc
//
BOOL TestDeriveKeyProc(
        PALGNODE pAlgNode,
        PTESTCASE ptc,
        PVOID pvTestDeriveKeyInfo)
{
    BOOL fSuccess           = FALSE;
    HCRYPTHASH hHash        = 0;
    HCRYPTKEY hKey          = 0;
    DERIVED_KEY_INFO DerivedKeyInfo;
    PTEST_DERIVE_KEY_INFO pTestDeriveKeyInfo = (PTEST_DERIVE_KEY_INFO) pvTestDeriveKeyInfo;

    memset(&DerivedKeyInfo, 0, sizeof(DerivedKeyInfo));

    //
    // Initialize base hash information
    //
    DerivedKeyInfo.HashInfo.aiHash = CALG_SHA1;
    DerivedKeyInfo.HashInfo.dbBaseData.pbData = (PBYTE) TEST_HASH_DATA;
    DerivedKeyInfo.HashInfo.dbBaseData.cbData = wcslen(TEST_HASH_DATA) * sizeof(WCHAR);

    LOG_TRY(CreateHashAndAddData(
        pTestDeriveKeyInfo->hProv,
        &hHash,
        &(DerivedKeyInfo.HashInfo),
        ptc,
        0, NULL));

    // Debugging
    /*
    DerivedKeyInfo.cbHA = sizeof(DerivedKeyInfo.rgbHashValA);
    LOG_TRY(CryptGetHashParam(hHash, HP_HASHVAL, DerivedKeyInfo.rgbHashValA, &(DerivedKeyInfo.cbHA), 0));
    */

    //
    // Initialize the key information in DerivedKeyInfo and create the 
    // derived key.
    //
    DerivedKeyInfo.aiKey = pAlgNode->ProvEnumalgsEx.aiAlgid;
    DerivedKeyInfo.dwKeySize = pAlgNode->ProvEnumalgsEx.dwDefaultLen;

    LOG_TRY(TDeriveKey(
        pTestDeriveKeyInfo->hProv,
        DerivedKeyInfo.aiKey,
        hHash,
        CRYPT_EXPORTABLE | (DerivedKeyInfo.dwKeySize) << 16,
        &hKey,
        ptc));

    // Debug
    /*
    DerivedKeyInfo.cbCA = 10;
    LOG_TRY(CryptEncrypt(hKey, 0, TRUE, 0, DerivedKeyInfo.rgbCipherA, &(DerivedKeyInfo.cbCA), sizeof(DerivedKeyInfo.rgbCipherA)));
    */

    //
    // Export the derived key in plaintext and verify the resulting key 
    // against a second CSP.
    //
    LOG_TRY(ExportPlaintextSessionKey(
        hKey,
        pTestDeriveKeyInfo->hProv,
        &(DerivedKeyInfo.dbKey),
        ptc));

    LOG_TRY(CheckDerivedKey(
        &DerivedKeyInfo,
        pTestDeriveKeyInfo->hInteropProv,
        ptc));

    fSuccess = TRUE;

Cleanup:

    if (hHash)
    {
        TDestroyHash(hHash, ptc);
    }
    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (DerivedKeyInfo.HashInfo.dbHashValue.pbData)
    {
        free(DerivedKeyInfo.HashInfo.dbHashValue.pbData);
    }
    if (DerivedKeyInfo.dbKey.pbData)
    {
        free(DerivedKeyInfo.dbKey.pbData);
    }

    return fSuccess;
}

//
// Function: InteropDeriveKeyTests
// Purpose: Run TestDeriveKeyProc for each session key algorithm
// supported by this CSP.  A second CSP is used to verify
// that the key has been derived correctly.
//
BOOL InteropDeriveKeyTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    //LPWSTR pwszInteropContainer   = TEST_CONTAINER_2;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    TEST_DERIVE_KEY_INFO TestDeriveKeyInfo; 

    memset(&TestDeriveKeyInfo, 0, sizeof(TestDeriveKeyInfo));

    LOG_TRY(CreateNewContext(
        &(TestDeriveKeyInfo.hProv),
        NULL,
        CRYPT_VERIFYCONTEXT,
        ptc));

    LOG_TRY(CreateNewInteropContext(
        &(TestDeriveKeyInfo.hInteropProv),
        NULL,
        CRYPT_VERIFYCONTEXT,
        ptc));

    //
    // TestDeriveKeyProc will create, export, and verify a derived 
    // key for each session key algorithm supported by the CSP 
    // under test.  Use of the CRYPT_EXPORTABLE flag is covered
    // by that routine.
    //
    LOG_TRY(AlgListIterate(
        pCSPInfo->pAlgList,
        DataEncryptFilter,
        TestDeriveKeyProc,
        (PVOID) (&TestDeriveKeyInfo),
        ptc));

    fSuccess = TRUE;

Cleanup:

    if (TestDeriveKeyInfo.hProv)
    {
        TRelease(TestDeriveKeyInfo.hProv, 0, ptc);
    }
    if (TestDeriveKeyInfo.hInteropProv)
    {
        TRelease(TestDeriveKeyInfo.hInteropProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: PositiveDeriveKeyTests
// Purpose: Run the test cases for CryptDeriveKey.  The set of positive test cases 
// to be executed depends on the dwCSPClass and dwTestLevel parameters.
//
// Note: Since the Microsoft RSA CSP only supports derived session keys and not
// derived public keys, the PositiveDeriveKeyTests() belong in TEST_LEVEL_KEY
// only.  
//
BOOL PositiveDeriveKeyTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTHASH hHash            = 0;
    HCRYPTKEY hKey              = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    HASH_INFO HashInfo;

    memset(&HashInfo, 0, sizeof(HashInfo));

    //
    // Group 4B
    //

    //
    // Do CryptDeriveKey positive test cases
    //

    LOG_TRY(CreateNewContext(
        &hProv,
        NULL,
        CRYPT_VERIFYCONTEXT,
        ptc));

    //
    // Tests for basic use of CryptDeriveKey, then the flags CRYPT_CREATE_SALT, 
    // CRYPT_NO_SALT, and 
    // CRYPT_UPDATE_KEY (the latter is currently not supported by the Microsoft
    // CSP's) follow.  Create a simple hash from which the derived keys will be
    // generated.
    //
    HashInfo.aiHash = CALG_SHA1;
    HashInfo.dbBaseData.pbData = (PBYTE) TEST_HASH_DATA;
    HashInfo.dbBaseData.cbData = wcslen(TEST_HASH_DATA) * sizeof(WCHAR);

    LOG_TRY(CreateHashAndAddData(
        hProv,
        &hHash,
        &HashInfo,
        ptc,
        0, NULL));

    //
    // Base test
    //
    LOG_TRY(TDeriveKey(
        hProv,
        CALG_RC4,
        hHash,
        0,
        &hKey,
        ptc));

    LOG_TRY(TDestroyKey(hKey, ptc));
    hKey = 0;

    //
    // Test CRYPT_CREATE_SALT
    //
    // Derive a 40 bit RC4 key.  Specifying a small key size is interesting
    // because the Microsoft CSP's will not, by default, add any salt
    // to a 128 bit key.
    //
    LOG_TRY(TDeriveKey(
        hProv,
        CALG_RC4,
        hHash,
        CRYPT_CREATE_SALT | (0x28 << 16),
        &hKey,
        ptc));

    LOG_TRY(TDestroyKey(hKey, ptc));
    hKey = 0;

    //
    // Test CRYPT_NO_SALT
    //
    LOG_TRY(TDeriveKey(
        hProv,
        CALG_RC4,
        hHash,
        CRYPT_NO_SALT | (0x28 << 16),
        &hKey,
        ptc));

    LOG_TRY(TDestroyKey(hKey, ptc));
    hKey = 0;

    //
    // Test CRYPT_UPDATE_KEY
    //
    LOG_TRY(TDeriveKey(
        hProv,
        CALG_RC4,
        hHash,
        0,
        &hKey,
        ptc));

    //
    // Using the key handle just created, attempt to update the key 
    // data with the same hash data.  The Microsoft CSP currently ignores 
    // this flag.
    //
    LOG_TRY(TDeriveKey(
        hProv,
        CALG_RC4,
        hHash,
        CRYPT_UPDATE_KEY,
        &hKey,
        ptc));
    
    fSuccess = TRUE;
Cleanup:

    if (hHash)
    {
        TDestroyHash(hHash, ptc);
    }
    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }   

    return fSuccess;
}

//
// Function: NegativeDeriveKeyTests
// Purpose: Run the negative test cases for CryptDeriveKey.  These test cases
// will only execute for TEST_LEVEL_KEY, based on the dwTestLevel parameter.
//
BOOL NegativeDeriveKeyTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    //LPWSTR pwszContainer2     = TEST_CONTAINER_2;
    HCRYPTPROV hProv            = 0;
    HCRYPTPROV hProv2           = 0;
    HCRYPTKEY hKey              = 0;
    HCRYPTHASH hHash            = 0;
    HCRYPTHASH hHash2           = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    //
    // Group 4B
    //

    // Only run the negative test cases for TEST_LEVEL_KEY.  This ensures that the same cases won't be
    // re-run for TEST_LEVEL_CONTAINER.  Only the positive cases are different.
    if (TEST_LEVEL_KEY == ptc->dwTestLevel)
    {
        //
        // Do CryptDeriveKey negative test cases
        //
        
        LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));
        
        LOG_TRY(CreateNewHash(hProv, CALG_SHA1, &hHash, ptc));
        
        ptc->dwErrorCode = ERROR_INVALID_HANDLE;
        LOG_TRY(TDeriveKey(0, CALG_RC4, hHash, 0, &hKey, ptc));
        
        ptc->dwErrorCode = ERROR_INVALID_HANDLE;
        LOG_TRY(TDeriveKey(TEST_INVALID_HANDLE, CALG_RC4, hHash, 0, &hKey, ptc));
        
        ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
        LOG_TRY(TDeriveKey(hProv, CALG_RC4, hHash, 0, NULL, ptc));
        
        ptc->dwErrorCode = NTE_BAD_ALGID;
        LOG_TRY(TDeriveKey(hProv, CALG_MD5, hHash, 0, &hKey, ptc));
        
        ptc->dwErrorCode = NTE_BAD_FLAGS;
        LOG_TRY(TDeriveKey(hProv, CALG_RC4, hHash, TEST_INVALID_FLAG, &hKey, ptc));
        
        ptc->dwErrorCode = NTE_BAD_HASH;
        LOG_TRY(TDeriveKey(hProv, CALG_RC4, TEST_INVALID_HANDLE, 0, &hKey, ptc));
        
        ptc->dwErrorCode = NTE_SILENT_CONTEXT;
        LOG_TRY(TDeriveKey(hProv, CALG_RC4, hHash, CRYPT_USER_PROTECTED, &hKey, ptc));
        
        LOG_TRY(CreateNewContext(&hProv2, NULL, CRYPT_VERIFYCONTEXT, ptc));
        
        LOG_TRY(CreateNewHash(hProv2, CALG_SHA1, &hHash2, ptc));
        
        // Hash handle not created from same context as hProv
        ptc->dwErrorCode = NTE_BAD_HASH;
        LOG_TRY(TDeriveKey(hProv, CALG_RC4, hHash2, 0, &hKey, ptc));
    }
    
    fSuccess = TRUE;
Cleanup:

    if (hHash)
    {
        TDestroyHash(hHash, ptc);
    }
    if (hHash2)
    {
        TDestroyHash(hHash2, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }
    if (hProv2)
    {
        TRelease(hProv2, 0, ptc);
    }

    return fSuccess;
}

//
// Function: PositiveDestroyKeyTests
// Purpose: Run the test cases for CryptDestroyKey
//
BOOL PositiveDestroyKeyTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTKEY hKey              = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    //
    // Group 4C
    //

    //
    // Do CryptDestroyKey positive test cases
    //

    switch (pCSPInfo->TestCase.dwTestLevel)
    {
    case TEST_LEVEL_KEY:
        {
            LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

            LOG_TRY(CreateNewKey(hProv, CALG_RC4, 0, &hKey, ptc));

            LOG_TRY(TDestroyKey(hKey, ptc));
            hKey = 0;

            break;
        }

    case TEST_LEVEL_CONTAINER:
        {
            LOG_TRY(CreateNewContext(&hProv, pwszContainer, CRYPT_NEWKEYSET, ptc));

            LOG_TRY(CreateNewKey(hProv, AT_SIGNATURE, 0, &hKey, ptc));

            LOG_TRY(TDestroyKey(hKey, ptc));
            hKey = 0;

            break;
        }

    default:
        {
            goto Cleanup;
        }
    }

    fSuccess = TRUE;

Cleanup:

    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: NegativeDestroyKeyTests
// Purpose: Run the negative test cases for CryptDestroyKey
//
BOOL NegativeDestroyKeyTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTKEY hKey              = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    //
    // Group 4C
    //

    //
    // Do CryptDestroyKey negative test cases
    //
    ptc->fTestingDestroyKey = TRUE;
        
    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TDestroyKey(0, ptc));
    
    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TDestroyKey(TEST_INVALID_HANDLE, ptc));

    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    LOG_TRY(CreateNewKey(hProv, CALG_RC4, 0, &hKey, ptc));

    /*
    LOG_TRY(TRelease(hProv, 0, ptc));
    hProv = 0;

    // Provider handle used to create hKey is now invalid
    ptc->dwErrorCode = NTE_BAD_UID;
    LOG_TRY(TDestroyKey(hKey, ptc));
    */

    fSuccess = TRUE;

Cleanup:

    ptc->fTestingDestroyKey = FALSE;

    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

// 
// Function: PositiveEncryptTests
// Purpose: Run the test cases for CryptEncrypt
//
BOOL PositiveEncryptTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    HCRYPTPROV hProv            = 0;
    HCRYPTKEY hKey              = 0;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    DWORD cbData                = 0;
    PBYTE pbData                = NULL;
    DWORD dw                    = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    BYTE rgb [] = { 
        0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00
    };
    
    //
    // Group 4E
    //
    
    //
    // Do CryptEncrypt positive test cases
    //
    
    switch( pCSPInfo->TestCase.dwTestLevel )
    {
    case TEST_LEVEL_KEY:
        {
            LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));
            //
            // Try a simple stream cipher encryption
            //
            LOG_TRY(CreateNewKey(hProv, CALG_RC4, 0, &hKey, ptc));
            
            cbData = wcslen(TEST_DECRYPT_DATA) * sizeof(WCHAR);
            dw = cbData;
            
            LOG_TRY(TestAlloc(&pbData, cbData, ptc));
            
            memcpy(pbData, TEST_DECRYPT_DATA, cbData);
            
            LOG_TRY(TEncrypt(hKey, 0, TRUE, 0, pbData, &cbData, dw, ptc));

            //
            // Verify that ciphertext is not same as plaintext
            //
            if (0 == memcmp(pbData, TEST_DECRYPT_DATA, dw))
            {
                ptc->pwszErrorHelp = L"CryptEncrypt ciphertext matches original plaintext";
                LOG_TRY(LogApiFailure(
                    API_CRYPTENCRYPT,
                    ERROR_BAD_DATA,
                    ptc));
                ptc->pwszErrorHelp = NULL;
            }
            
            LOG_TRY(TDestroyKey(hKey, ptc));
            hKey = 0;
            
            //
            // Try a simple block cipher encryption
            //
            LOG_TRY(CreateNewKey(hProv, CALG_RC2, 0, &hKey, ptc));
            
            cbData = sizeof(rgb) / 2;
            dw = sizeof(rgb);
            
            LOG_TRY(TEncrypt(hKey, 0, TRUE, 0, rgb, &cbData, dw, ptc));

            //
            // Verify that ciphertext is not still zeros
            //
            while (dw-- && (0 == rgb[dw - 1]));

            if (0 == dw)
            {
                ptc->pwszErrorHelp = L"CryptEncrypt ciphertext matches original plaintext";
                LOG_TRY(LogApiFailure(
                    API_CRYPTENCRYPT,
                    ERROR_BAD_DATA,
                    ptc));
                ptc->pwszErrorHelp = NULL;
            }
            
            break;
        }
        
    case TEST_LEVEL_CONTAINER:
        {
            LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_NEWKEYSET, ptc));
            
            // 
            // Test direct direct RSA encryption using an key-exchange public key.
            //
            // Not all CSP's will support this, so the error level may need to 
            // be adjusted.
            //
            LOG_TRY(CreateNewKey(hProv, AT_KEYEXCHANGE, 0, &hKey, ptc));

            cbData = wcslen(TEST_DECRYPT_DATA) * sizeof(WCHAR);
            dw = cbData;

            LOG_TRY(TEncrypt(hKey, 0, TRUE, 0, NULL, &dw, 0, ptc));
            
            LOG_TRY(TestAlloc(&pbData, dw, ptc));
            
            memcpy(pbData, TEST_DECRYPT_DATA, cbData);

            LOG_TRY(TEncrypt(hKey, 0, TRUE, 0, pbData, &cbData, dw, ptc));
            
            //
            // Verify that ciphertext is not same as plaintext
            //
            if (0 == memcmp(pbData, TEST_DECRYPT_DATA, dw))
            {
                ptc->pwszErrorHelp = L"CryptEncrypt ciphertext matches original plaintext";
                LOG_TRY(LogApiFailure(
                    API_CRYPTENCRYPT,
                    ERROR_BAD_DATA,
                    ptc));
                ptc->pwszErrorHelp = NULL;
            }
            
            break;
        }

    default:
        {
            goto Cleanup;
        }
    }
    
    fSuccess = TRUE;
    
Cleanup:
    
    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }
    
    return fSuccess;
}

// 
// Function: NegativeEncryptTests
// Purpose: Run the negative test cases for CryptEncrypt
//
BOOL NegativeEncryptTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    //LPWSTR pwszContainer2     = TEST_CONTAINER_2;
    HCRYPTPROV hProv            = 0;
    HCRYPTPROV hProv2           = 0;
    HCRYPTKEY hKey              = 0;
    HCRYPTHASH hHash            = 0;
    DWORD cb                    = 0;    
    DWORD dw                    = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    DWORD dwSavedErrorLevel     = 0;
    BYTE rgPlainText[TEST_CIPHER_LENGTH_RC4];
    BYTE rgRC2PlainText[TEST_RC2_BUFFER_LEN];
    BYTE rgHashVal[HASH_LENGTH_SHA1];

    memset(rgHashVal, 0, sizeof(rgHashVal));
    memset(rgPlainText, 0, sizeof(rgPlainText));
    memset(rgRC2PlainText, 0, sizeof(rgRC2PlainText));


    //
    // Group 4E
    //

    //
    // Do CryptEncrypt negative test cases
    //
    cb = sizeof(rgPlainText);

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TEncrypt(0, 0, TRUE, 0, rgPlainText, &cb, cb, ptc));

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TEncrypt(TEST_INVALID_HANDLE, 0, TRUE, 0, rgPlainText, &cb, cb, ptc));

    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    //
    // Create a block encryption key to test invalid buffer 
    // lengths.
    //
    LOG_TRY(CreateNewKey(hProv, CALG_RC2, 0, &hKey, ptc));

    dw = cb = TEST_RC2_DATA_LEN;

    ptc->fExpectSuccess = TRUE;
    LOG_TRY(TEncrypt(hKey, 0, TRUE, 0, NULL, &cb, 0, ptc));
    ptc->fExpectSuccess = FALSE;

    cb--;

    // dwBufLen param is now too short
    ptc->dwErrorCode = ERROR_MORE_DATA;
    LOG_TRY(TEncrypt(hKey, 0, TRUE, 0, rgRC2PlainText, &dw, cb, ptc));

    // Done with block cipher key
    LOG_TRY(TDestroyKey(hKey, ptc));
    hKey = 0;

    //
    // Continue tests using a stream cipher key
    //
    cb = sizeof(rgPlainText);

    LOG_TRY(CreateNewKey(hProv, CALG_RC4, 0, &hKey, ptc));

    // pbData buffer is too short and will AV
    ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
    LOG_TRY(TEncrypt(hKey, 0, TRUE, 0, (PBYTE) TEST_INVALID_POINTER, &cb, cb, ptc));

    // Invalid flag
    ptc->dwErrorCode = NTE_BAD_FLAGS;
    LOG_TRY(TEncrypt(hKey, 0, TRUE, TEST_INVALID_FLAG, rgPlainText, &cb, cb, ptc));

    ptc->fExpectSuccess = TRUE;
    LOG_TRY(TEncrypt(hKey, 0, TRUE, 0, rgPlainText, &cb, cb, ptc)); 
    ptc->fExpectSuccess = FALSE;

    // Not all providers prohibit double-encryption
    dwSavedErrorLevel = ptc->dwErrorLevel;
    ptc->dwErrorLevel = CSP_ERROR_WARNING;
    ptc->pwszErrorHelp = L"This CSP supports double-encryption";

    ptc->dwErrorCode = NTE_DOUBLE_ENCRYPT;
    LOG_TRY(TEncrypt(hKey, 0, TRUE, 0, rgPlainText, &cb, cb, ptc));

    ptc->dwErrorLevel = dwSavedErrorLevel;
    ptc->pwszErrorHelp = NULL;

    memset(rgPlainText, 0, cb);

    // Invalid, non-zero, hash handle
    ptc->dwErrorCode = NTE_BAD_HASH;
    LOG_TRY(TEncrypt(hKey, TEST_INVALID_HANDLE, TRUE, 0, rgPlainText, &cb, cb, ptc));
    
    LOG_TRY(CreateNewHash(hProv, CALG_SHA1, &hHash, ptc));

    ptc->fExpectSuccess = TRUE;
    cb = sizeof(rgHashVal);
    LOG_TRY(TGetHash(hHash, HP_HASHVAL, rgHashVal, &cb, 0, ptc)); 
    ptc->fExpectSuccess = FALSE;

    cb = sizeof(rgPlainText);
    ptc->dwErrorCode = NTE_BAD_HASH_STATE;
    LOG_TRY(TEncrypt(hKey, hHash, TRUE, 0, rgPlainText, &cb, cb, ptc));

    TDestroyHash(hHash, ptc);
    hHash = 0;

    LOG_TRY(CreateNewContext(&hProv2, NULL, CRYPT_VERIFYCONTEXT, ptc));

    // Create a new hash from a different cryptographic context
    LOG_TRY(CreateNewHash(hProv2, CALG_SHA1, &hHash, ptc));

    // API should not allow hKey and hHash from two different contexts
    ptc->dwErrorCode = NTE_BAD_HASH;
    LOG_TRY(TEncrypt(hKey, hHash, TRUE, 0, rgPlainText, &cb, cb, ptc));

    // Delete the original context, hKey derived from it should now be unusable
    /*
    LOG_TRY(TRelease(hProv, 0, ptc));
    hProv = 0;

    ptc->dwErrorCode = NTE_BAD_UID;
    LOG_TRY(TEncrypt(hKey, 0, TRUE, 0, rgPlainText, &cb, cb, ptc));
    */

    fSuccess = TRUE;

Cleanup:

    if (hHash)
    {
        TDestroyHash(hHash, ptc);
    }
    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }
    if (hProv2)
    {
        TRelease(hProv2, 0, ptc);
    }

    return fSuccess;
}



//
// Function: TestGenKeyProc
//
BOOL TestGenKeyProc(
        PALGNODE pAlgNode,
        PTESTCASE ptc,
        PVOID pvTestGenKeyInfo)
{
    HCRYPTKEY hKey          = 0;
    BOOL fSuccess           = FALSE;
    DWORD dwSize            = 0;
    DWORD dwFlags           = 0;
    HCRYPTPROV hTestProv    = 0;
    DWORD dwSavedErrorLevel = ptc->dwErrorLevel;
    PTEST_GEN_KEY_INFO pTestGenKeyInfo = (PTEST_GEN_KEY_INFO) pvTestGenKeyInfo;

    if (pAlgNode->fIsRequiredAlg)
    {
        ptc->dwErrorLevel = CSP_ERROR_CONTINUE;
    }
    else
    {
        ptc->dwErrorLevel = CSP_ERROR_WARNING;
    }

    //
    // Create four different keys for the specified alg:
    //
    // 1) Minimum key size, with the CRYPT_NO_SALT flag.
    // 2) Minimum key size, with the CRYPT_CREATE_SALT flag.
    // 3) (Public keys only) Minimum key size + incremental key size
    // 4) Default key size, with the CRYPT_EXPORTABLE flag
    // 5) Maximum key size (Session keys only.  Otherwise, use a
    // reasonably large key size for public key pairs.), with the 
    // CRYPT_USER_PROTECTED flag set.
    //

    // 1
    dwSize = pAlgNode->ProvEnumalgsEx.dwMinLen;
    LOG_TRY(TGenKey(
        pTestGenKeyInfo->hProv,
        pAlgNode->ProvEnumalgsEx.aiAlgid,
        CRYPT_NO_SALT | (dwSize << 16),
        &hKey,
        ptc));

    LOG_TRY(TDestroyKey(hKey, ptc));
    hKey = 0;

    //
    // The Microsoft CSP's do not permit salting DES
    // keys.
    //

    // 2
    if (    CALG_DES == pAlgNode->ProvEnumalgsEx.aiAlgid ||
            CALG_3DES == pAlgNode->ProvEnumalgsEx.aiAlgid ||
            CALG_3DES_112 == pAlgNode->ProvEnumalgsEx.aiAlgid)
    {
        ptc->KnownErrorID = KNOWN_CRYPTGENKEY_SALTDES;
    }

    LOG_TRY(TGenKey(
        pTestGenKeyInfo->hProv,
        pAlgNode->ProvEnumalgsEx.aiAlgid,
        CRYPT_CREATE_SALT | (dwSize << 16),
        &hKey,
        ptc));

    LOG_TRY(TDestroyKey(hKey, ptc));
    hKey = 0;

    ptc->KnownErrorID = KNOWN_ERROR_UNKNOWN;

    //
    // Is this a public key alg?
    //
    if (RSAAlgFilter(pAlgNode))
    {
        switch (pAlgNode->ProvEnumalgsEx.aiAlgid)
        {
        case CALG_RSA_SIGN:
            {
                dwSize = pAlgNode->ProvEnumalgsEx.dwMinLen + pTestGenKeyInfo->pCSPInfo->dwSigKeysizeInc;
                break;
            }
        case CALG_RSA_KEYX:
            {
                dwSize = pAlgNode->ProvEnumalgsEx.dwMinLen + pTestGenKeyInfo->pCSPInfo->dwSigKeysizeInc;
                break;
            }
        default:
            {
                goto Cleanup;
            }
        }

        // 3
        LOG_TRY(TGenKey(
            pTestGenKeyInfo->hProv,
            pAlgNode->ProvEnumalgsEx.aiAlgid,
            dwSize << 16,
            &hKey,
            ptc));

        LOG_TRY(TDestroyKey(hKey, ptc));
        hKey = 0;
    }

    // 4
    LOG_TRY(TGenKey(
        pTestGenKeyInfo->hProv,
        pAlgNode->ProvEnumalgsEx.aiAlgid,
        CRYPT_EXPORTABLE,
        &hKey,
        ptc));

    LOG_TRY(TDestroyKey(hKey, ptc));
    hKey = 0;

    // 5
    if (RSAAlgFilter(pAlgNode))
    {
        dwFlags = CRYPT_USER_PROTECTED;
        dwSize = (pAlgNode->ProvEnumalgsEx.dwMaxLen >= TEST_MAX_RSA_KEYSIZE) ? TEST_MAX_RSA_KEYSIZE : pAlgNode->ProvEnumalgsEx.dwMaxLen;
        hTestProv = pTestGenKeyInfo->hNotSilentProv;
    }
    else
    {
        dwSize = pAlgNode->ProvEnumalgsEx.dwMaxLen;
        hTestProv = pTestGenKeyInfo->hProv;
    }

    LOG_TRY(TGenKey(
        hTestProv,
        pAlgNode->ProvEnumalgsEx.aiAlgid,
        dwFlags | (dwSize << 16),
        &hKey,
        ptc));

    fSuccess = TRUE;

Cleanup:
    ptc->dwErrorLevel = dwSavedErrorLevel;

    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }

    return fSuccess;
}

//
// Function: PositiveGenKeyTests
// Purpose: Run the test cases for CryptGenKey.  The set of positive 
// test cases executed depends on the dwCSPClass and dwTestLevel parameters.
//
BOOL PositiveGenKeyTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    LPWSTR pwszContainer2       = TEST_CONTAINER_2;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    HCRYPTKEY hKey              = 0;
    //PALGNODE pAlgNode         = NULL;
    TEST_GEN_KEY_INFO TestGenKeyInfo;

    memset(&TestGenKeyInfo, 0, sizeof(TestGenKeyInfo));

    TestGenKeyInfo.pCSPInfo = pCSPInfo;

    //
    // Do CryptGenKey positive test cases
    //
    switch (pCSPInfo->TestCase.dwTestLevel)
    {
    case TEST_LEVEL_KEY:
        {
            //
            // Run the TestGenKeyProc test for each session key alg
            // supported by this CSP.
            //
            LOG_TRY(CreateNewContext(&(TestGenKeyInfo.hProv), NULL, CRYPT_VERIFYCONTEXT, ptc));

            LOG_TRY(AlgListIterate(
                pCSPInfo->pAlgList,
                DataEncryptFilter,
                TestGenKeyProc,
                (PVOID) &TestGenKeyInfo,
                ptc));

            //
            // Test that a signature public key pair can be created from a 
            // VERIFYCONTEXT provider handle.  The key will not be persisted.
            //
            LOG_TRY(TGenKey(
                TestGenKeyInfo.hProv, 
                AT_SIGNATURE, 
                0, 
                &hKey, 
                ptc));
            
            break;
        }

    case TEST_LEVEL_CONTAINER:
        {
            LOG_TRY(CreateNewContext(
                &(TestGenKeyInfo.hProv), 
                pwszContainer, 
                CRYPT_NEWKEYSET, 
                ptc));
                    
            // We are not currently supporting multiple containers
            // on a single smartcard, so the following test case can't 
            // use two different context handles for Smartcard scenario.
            if (pCSPInfo->fSmartCardCSP)
            {
                TestGenKeyInfo.hNotSilentProv = TestGenKeyInfo.hProv;
            }
            else
            {
                //
                // Set the flag so that CreateNewContext will not create a CRYPT_SILENT context
                // handle.
                //
                ptc->fTestingUserProtected = TRUE;
                LOG_TRY(CreateNewContext(
                    &(TestGenKeyInfo.hNotSilentProv), 
                    pwszContainer2, 
                    CRYPT_NEWKEYSET, 
                    ptc));
                ptc->fTestingUserProtected = FALSE;
            }

            if (CLASS_SIG_ONLY == pCSPInfo->TestCase.dwCSPClass)
            {
                LOG_TRY(TGenKey(
                    TestGenKeyInfo.hProv,
                    AT_SIGNATURE,
                    0,
                    &hKey,
                    ptc));
            }
            else
            {
                LOG_TRY(TGenKey(
                    TestGenKeyInfo.hProv,
                    AT_KEYEXCHANGE,
                    0,
                    &hKey,
                    ptc));

                LOG_TRY(AlgListIterate(
                    pCSPInfo->pAlgList,
                    RSAAlgFilter,
                    TestGenKeyProc,
                    (PVOID) &TestGenKeyInfo,
                    ptc));
            }

            if (pCSPInfo->fSmartCardCSP)
            {
                TestGenKeyInfo.hProv = 0;
            }

            break;
        }

    default:
        {
            goto Cleanup;
        }
    }

    fSuccess = TRUE;

Cleanup:

    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (TestGenKeyInfo.hProv)
    {
        TRelease(TestGenKeyInfo.hProv, 0, ptc);
    }
    if (TestGenKeyInfo.hNotSilentProv)
    {
        TRelease(TestGenKeyInfo.hNotSilentProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: NegativeGenKeyTests
// Purpose: Run the negative test cases for CryptGenKey.  The set of  
// test cases executed depends on the dwTestLevel parameter.
//
BOOL NegativeGenKeyTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTKEY hKey              = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    // The appropriate set of negative test cases to run depends on the current Test Level
    switch (ptc->dwTestLevel)
    {
    case TEST_LEVEL_KEY:
        {
            //
            // Group 4F (negative)
            //

            //
            // Do CryptGenKey TEST_LEVEL_KEY negative test cases
            //
            
            ptc->dwErrorCode = ERROR_INVALID_HANDLE;
            LOG_TRY(TGenKey(0, CALG_RC4, 0, &hKey, ptc));
            
            ptc->dwErrorCode = ERROR_INVALID_HANDLE;
            LOG_TRY(TGenKey(TEST_INVALID_HANDLE, CALG_RC4, 0, &hKey, ptc));
            
            LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));
            
            ptc->dwErrorCode = NTE_BAD_ALGID;
            LOG_TRY(TGenKey(hProv, CALG_SHA1, 0, &hKey, ptc));
            
            ptc->dwErrorCode = NTE_BAD_FLAGS;
            LOG_TRY(TGenKey(hProv, CALG_RC4, TEST_INVALID_FLAG, &hKey, ptc));

            break;
        }
    case TEST_LEVEL_CONTAINER:
        {
            // 
            // Group 5D (negative)
            //

            // 
            // Do CryptGenKey TEST_LEVEL_CONTAINER negative test cases
            //

            //
            // Test that CRYPT_USER_PROTECTED fails with a CRYPT_SILENT context
            //
            LOG_TRY(CreateNewContext(&hProv, pwszContainer, CRYPT_NEWKEYSET | CRYPT_SILENT, ptc));

            ptc->dwErrorCode = NTE_SILENT_CONTEXT;
            LOG_TRY(TGenKey(hProv, AT_SIGNATURE, CRYPT_USER_PROTECTED, &hKey, ptc));

            LOG_TRY(TRelease(hProv, 0, ptc));
            hProv = 0;

            //
            // Test that CRYPT_USER_PROTECTED fails with a CRYPT_VERIFYCONTEXT context
            //
            LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

            //
            // In Windows 2000, the Microsoft CSP's ignore the USER_PROTECTED flag
            // because the VERIFYCONTEXT flag is set.  Therefore the following
            // call succeeds unexpectedly.  That usage should be flagged as an 
            // error.
            //
            ptc->KnownErrorID = KNOWN_CRYPTGENKEY_SILENTCONTEXT;
            ptc->pwszErrorHelp = 
                L"The CRYPT_USER_PROTECTED flag should fail when a VERIFYCONTEXT provider handle is used";

            ptc->dwErrorCode = NTE_SILENT_CONTEXT;
            LOG_TRY(TGenKey(hProv, AT_SIGNATURE, CRYPT_USER_PROTECTED, &hKey, ptc));
            ptc->KnownErrorID = KNOWN_ERROR_UNKNOWN;

            break;
        }
    }       

    fSuccess = TRUE;

Cleanup:

    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}



//
// Function: PositiveGetKeyParamTests
// Purpose: Run the test cases for CryptGetKeyParam
//
BOOL PositiveGetKeyParamTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    HCRYPTPROV hProv            = 0;
    HCRYPTKEY hKey              = 0;
    DWORD dw                    = 0;
    DWORD cb                    = 0;
    PBYTE pb                    = NULL;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    DWORD dwSavedErrorLevel     = 0;

    //
    // Group 4G
    //

    //
    // Do CryptGetKeyParam positive test cases
    //
    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    //
    // Test CryptGetKeyParam for a stream cipher key
    //
    LOG_TRY(CreateNewKey(
        hProv, 
        CALG_RC4, 
        CRYPT_CREATE_SALT | CRYPT_EXPORTABLE | (40 << 16), 
        &hKey, 
        ptc));

    // KP_ALGID
    cb = sizeof(dw);
    LOG_TRY(TGetKey(
        hKey,
        KP_ALGID,
        (PBYTE) &dw,
        &cb,
        0,
        ptc));

    if (CALG_RC4 != dw)
    {
        LOG_TRY(LogBadParam(
            API_CRYPTGETKEYPARAM,
            L"CryptGetKeyParam KP_ALGID doesn't match", 
            ptc));
    }

    // KP_BLOCKLEN
    cb = sizeof(dw);
    LOG_TRY(TGetKey(
        hKey,
        KP_BLOCKLEN,
        (PBYTE) &dw,
        &cb,
        0,
        ptc));

    if (0 != dw)
    {
        LOG_TRY(LogBadParam(
            API_CRYPTGETKEYPARAM,
            L"CryptGetKeyParam KP_BLOCKLEN should be zero", 
            ptc));
    }

    // KP_KEYLEN
    cb = sizeof(dw);
    LOG_TRY(TGetKey(
        hKey,
        KP_KEYLEN,
        (PBYTE) &dw,
        &cb,
        0,
        ptc));

    // TODO: Determine the best way to verify KP_KEYLEN.  CSP's will return
    // the effective KEYLEN, including parity bits.

    // KP_SALT
    cb = 0;
    LOG_TRY(TGetKey(
        hKey,
        KP_SALT,
        NULL,
        &cb,
        0,
        ptc));

    //
    // The MS_ENHANCED_PROV will use salt length zero for any key size even 
    // when CRYPT_CREATE_SALT has been specified.  
    //
    // The MS_BASE_PROV will exhibit one of the following behaviors:
    // 1) Default - use 11 bytes of zeroed salt
    // 2) CRYPT_CREATE_SALT - use 11 bytes of random salt
    // 3) CRYPT_NO_SALT - use no salt
    //
    // For this reason, various valid-looking salting behaviors
    // should not be considered errors.
    //
    dwSavedErrorLevel = ptc->dwErrorLevel;
    ptc->dwErrorLevel = CSP_ERROR_WARNING;
    if (0 == cb)
    {
        LOG_TRY(LogBadParam(
            API_CRYPTGETKEYPARAM,
            L"CryptGetKeyParam KP_SALT has zero length after CryptGenKey CRYPT_CREATE_SALT", 
            ptc));
    }

    LOG_TRY(TestAlloc(&pb, cb, ptc));

    LOG_TRY(TGetKey(
        hKey,
        KP_SALT,
        pb,
        &cb,
        0,
        ptc));

    // Verify that salt is not completely zero
    while (cb && (0 == pb[cb - 1]))
        cb--;

    if (0 == cb)
    {
        LOG_TRY(LogBadParam(
            API_CRYPTGETKEYPARAM,
            L"CryptGetKeyParam KP_SALT should not be zeroized after CryptGenKey CRYPT_CREATE_SALT", 
            ptc));
    }

    free(pb);
    pb = NULL;
    ptc->dwErrorLevel = dwSavedErrorLevel;

    // KP_PERMISSIONS
    cb = sizeof(dw);
    LOG_TRY(TGetKey(
        hKey,
        KP_PERMISSIONS,
        (PBYTE) &dw,
        &cb,
        0,
        ptc));

    if (! (CRYPT_EXPORT & dw))
    {
        LOG_TRY(LogBadParam(
            API_CRYPTGETKEYPARAM,
            L"CryptGetKeyParam KP_PERMISSIONS, CRYPT_EXPORT should be set", 
            ptc));
    }

    LOG_TRY(TDestroyKey(hKey, ptc));
    hKey = 0;

    //
    // Test CryptGetKeyParam with a block cipher key
    //
    LOG_TRY(CreateNewKey(hProv, CALG_RC2, CRYPT_EXPORTABLE, &hKey, ptc));

    // KP_BLOCKLEN
    cb = sizeof(dw);
    LOG_TRY(TGetKey(
        hKey,
        KP_BLOCKLEN,
        (PBYTE) &dw,
        &cb,
        0,
        ptc));

    if (0 == dw)
    {
        LOG_TRY(LogBadParam(
            API_CRYPTGETKEYPARAM,
            L"CryptGetKeyParam KP_BLOCKLEN should not be zero for CALG_RC2 key", 
            ptc));
    }

    // KP_EFFECTIVE_KEYLEN
    cb = sizeof(dw);
    LOG_TRY(TGetKey(
        hKey,
        KP_EFFECTIVE_KEYLEN,
        (PBYTE) &dw,
        &cb,
        0,
        ptc));

    // TODO: In general, how should the effective key length
    // be determined?

    // KP_IV
    cb = 0;
    LOG_TRY(TGetKey(
        hKey,
        KP_IV,
        NULL,
        &cb,
        0,
        ptc));

    LOG_TRY(TestAlloc(&pb, cb, ptc));

    LOG_TRY(TGetKey(
        hKey,
        KP_IV,
        pb,
        &cb,
        0,
        ptc));

    // Verify that IV is zero
    while (cb && (! pb[cb - 1]))
        cb--;

    if (0 != cb)
    {
        LOG_TRY(LogBadParam(
            API_CRYPTGETKEYPARAM,
            L"CryptGetKeyParam KP_IV should be zero", 
            ptc));
    }

    free(pb);
    pb = NULL;

    // KP_PADDING
    cb = sizeof(dw);
    LOG_TRY(TGetKey(
        hKey,
        KP_PADDING,
        (PBYTE) &dw,
        &cb,
        0,
        ptc));

    if (PKCS5_PADDING != dw)
    {
        LOG_TRY(LogBadParam(
            API_CRYPTGETKEYPARAM,
            L"CryptGetKeyParam KP_PADDING should be PKCS5_PADDING", 
            ptc));
    }

    // KP_MODE
    cb = sizeof(dw);
    LOG_TRY(TGetKey(
        hKey,
        KP_MODE,
        (PBYTE) &dw,
        &cb,
        0,
        ptc));

    if (CRYPT_MODE_CBC != dw)
    {
        LOG_TRY(LogBadParam(
            API_CRYPTGETKEYPARAM,
            L"CryptGetKeyParam KP_MODE should be CRYPT_MODE_CBC", 
            ptc));
    }

    // KP_MODE_BITS
    cb = sizeof(dw);
    LOG_TRY(TGetKey(
        hKey,
        KP_MODE_BITS,
        (PBYTE) &dw,
        &cb,
        0,
        ptc));

    // TODO: Looks like this should always be initialized to zero.  Is that true?
    if (0 != dw)
    {
        LOG_TRY(LogBadParam(
            API_CRYPTGETKEYPARAM,
            L"CryptGetKeyParam KP_MODE_BITS should be zero", 
            ptc));
    }

    fSuccess = TRUE;

Cleanup:

    if (pb)
    {
        free(pb);
    }
    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: NegativeGetKeyParamTests
// Purpose: Run the negative test cases for CryptGetKeyParam
//
BOOL NegativeGetKeyParamTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTKEY hKey              = 0;
    DWORD dw                    = 0;
    DWORD cb                    = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    //
    // Group 4G
    //

    //
    // Do CryptGetKeyParam negative test cases
    //

    cb = sizeof(dw);
    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TGetKey(0, KP_KEYLEN, (PBYTE) &dw, &cb, 0, ptc));
            
    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TGetKey(TEST_INVALID_HANDLE, KP_KEYLEN, (PBYTE) &dw, &cb, 0, ptc));

    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    LOG_TRY(CreateNewKey(hProv, CALG_RC4, 0, &hKey, ptc));

    /*
    ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
    LOG_TRY(TGetKey(hKey, KP_KEYLEN, NULL, &cb, 0, ptc));
    */

    ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
    LOG_TRY(TGetKey(hKey, KP_KEYLEN, (PBYTE) TEST_INVALID_POINTER, NULL, 0, ptc));

    cb = 1;
    ptc->dwErrorCode = ERROR_MORE_DATA;
    LOG_TRY(TGetKey(hKey, KP_KEYLEN, (PBYTE) &dw, &cb, 0, ptc));

    ptc->dwErrorCode = NTE_BAD_FLAGS;
    LOG_TRY(TGetKey(hKey, KP_KEYLEN, (PBYTE) &dw, &cb, TEST_INVALID_FLAG, ptc));

    ptc->dwErrorCode = NTE_BAD_TYPE;
    LOG_TRY(TGetKey(hKey, TEST_INVALID_FLAG, (PBYTE) &dw, &cb, 0, ptc));
    
    /*
    LOG_TRY(TRelease(hProv, 0, ptc));
    hProv = 0;

    // Provider handle used to create hKey is now invalid
    ptc->dwErrorCode = NTE_BAD_UID;
    LOG_TRY(TGetKey(hKey, KP_KEYLEN, (PBYTE) &dw, &cb, 0, ptc));
    */


    fSuccess = TRUE;

Cleanup:

    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: TestHashSessionKeyProc
// Purpose: Callback function for testing CryptHashSessionKey
// using AlgListIterate.  For each session key algorithm 
// supported by the target CSP, this function will be called.
//
BOOL TestHashSessionKeyProc(
        PALGNODE pAlgNode,
        PTESTCASE ptc,
        PVOID pvTestHashSessionKey)
{
    BOOL fSuccess               = FALSE;
    DWORD dwFlags               = 0;
    HASH_SESSION_INFO HashSessionInfo;
    PTEST_HASH_SESSION_KEY pTestHashSessionKey = (PTEST_HASH_SESSION_KEY) pvTestHashSessionKey;

    //
    // Run the HashSessionKey scenario twice:
    // 1) dwFlags = 0 --> hash is Big Endian
    // 2) dwFlags = CRYPT_LITTLE_ENDIAN
    //
    while (TEST_INVALID_FLAG != dwFlags)
    {
        memset(&HashSessionInfo, 0, sizeof(HashSessionInfo));
        
        HashSessionInfo.aiHash = pTestHashSessionKey->aiHash;
        HashSessionInfo.aiKey = pAlgNode->ProvEnumalgsEx.aiAlgid;
        HashSessionInfo.dwKeySize = pAlgNode->ProvEnumalgsEx.dwMaxLen;
        HashSessionInfo.dwFlags = dwFlags;
        
        LOG_TRY(CreateHashedSessionKey(
            pTestHashSessionKey->hProv,
            &HashSessionInfo,
            ptc));
        
        LOG_TRY(VerifyHashedSessionKey(
            pTestHashSessionKey->hInteropProv,
            &HashSessionInfo,
            ptc));

        if (CRYPT_LITTLE_ENDIAN == dwFlags)
        {
            dwFlags = TEST_INVALID_FLAG;
        }
        else
        {
            dwFlags = CRYPT_LITTLE_ENDIAN;
        }
    }
            
    fSuccess = TRUE;
Cleanup:

    return fSuccess;
}

//
// Function: InteropHashSessionKeyTests
// Purpose: Run the interoperability test cases for CryptHashSessionKey
// between the CSP under test and a second CSP.  
//
BOOL InteropHashSessionKeyTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    TEST_HASH_SESSION_KEY TestHashSessionKey;

    memset(&TestHashSessionKey, 0, sizeof(TestHashSessionKey));

    TestHashSessionKey.aiHash = CALG_SHA1;

    LOG_TRY(CreateNewContext(
        &(TestHashSessionKey.hProv),
        NULL,
        CRYPT_VERIFYCONTEXT,
        ptc));

    LOG_TRY(CreateNewInteropContext(
        &(TestHashSessionKey.hInteropProv),
        NULL,
        CRYPT_VERIFYCONTEXT,
        ptc));

    LOG_TRY(AlgListIterate(
        pCSPInfo->pAlgList,
        DataEncryptFilter,
        TestHashSessionKeyProc,
        (PVOID) &TestHashSessionKey,
        ptc));

    fSuccess = TRUE;

Cleanup:
    
    if (TestHashSessionKey.hProv)
    {
        TRelease(TestHashSessionKey.hProv, 0, ptc);
    }
    if (TestHashSessionKey.hInteropProv)
    {
        TRelease(TestHashSessionKey.hInteropProv, 0, ptc);
    }

    return fSuccess;    
}

//
// Function: PositiveHashSessionKeyTests
// Purpose: Run the test cases for CryptHashSessionKey
//
BOOL PositiveHashSessionKeyTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTKEY hKey              = 0;
    HCRYPTHASH hHash            = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    
    LOG_TRY(CreateNewContext(
        &hProv,
        NULL,
        CRYPT_VERIFYCONTEXT,
        ptc));

    //
    // Group 4H
    //

    //
    // Do CryptHashSessionKey test cases
    //

    //
    // Hash a stream cipher key
    //
    LOG_TRY(CreateNewHash(hProv, CALG_SHA1, &hHash, ptc));

    LOG_TRY(CreateNewKey(hProv, CALG_RC4, 0, &hKey, ptc));

    LOG_TRY(THashSession(hHash, hKey, 0, ptc));

    //
    // Hash the key again with the CRYPT_LITTLE_ENDIAN flag
    //
    LOG_TRY(THashSession(hHash, hKey, CRYPT_LITTLE_ENDIAN, ptc));

    fSuccess = TRUE;

Cleanup:
    
    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hHash)
    {
        TDestroyHash(hHash, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;    
}

//
// Function: NegativeHashSessionKeyTests
// Purpose: Run the negative test cases for CryptHashSessionKey
//
BOOL NegativeHashSessionKeyTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTKEY hKey              = 0;
    HCRYPTKEY hHash             = 0;
    DWORD cb                    = 0;
    BYTE rgHashVal[HASH_LENGTH_SHA1];
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    //
    // Group 4H
    //

    //
    // Do CryptHashSessionKey negative test cases
    //

    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    LOG_TRY(CreateNewKey(hProv, CALG_RC4, 0, &hKey, ptc));

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(THashSession(0, hKey, 0, ptc));
            
    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(THashSession(TEST_INVALID_HANDLE, hKey, 0, ptc));

    LOG_TRY(CreateNewHash(hProv, CALG_SHA1, &hHash, ptc));

    ptc->dwErrorCode = NTE_BAD_FLAGS;
    LOG_TRY(THashSession(hHash, hKey, TEST_INVALID_FLAG, ptc));

    ptc->dwErrorCode = NTE_BAD_KEY;
    LOG_TRY(THashSession(hHash, TEST_INVALID_HANDLE, 0, ptc));

    cb = sizeof(rgHashVal);
    LOG_TRY(TGetHash(hHash, HP_HASHVAL, rgHashVal, &cb, 0, ptc));

    // Hash is now finished, so any attempt to hash data should fail
    ptc->dwErrorCode = NTE_BAD_HASH_STATE;
    LOG_TRY(THashSession(hHash, hKey, 0, ptc));

    /*
    LOG_TRY(TRelease(hProv, 0, ptc));
    hProv = 0;

    // Provider handle used to create hHash is now invalid
    ptc->dwErrorCode = NTE_BAD_UID;
    LOG_TRY(THashSession(hHash, hKey, 0, ptc));
    */
    

    fSuccess = TRUE;

Cleanup:
    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hHash)
    {
        TDestroyHash(hHash, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;    
}

//
// Function: PositiveSetKeyParamTests
// Purpose: Run the test cases for CryptSetKeyParam
//
BOOL PositiveSetKeyParamTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTKEY hKey              = 0;
    PBYTE pbData                = NULL;
    DWORD cbData                = 0;
    DWORD dw                    = 0;        
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    DATA_BLOB db;

    memset(&db, 0, sizeof(db));

    LOG_TRY(CreateNewContext(
        &hProv,
        NULL,
        CRYPT_VERIFYCONTEXT,
        ptc));

    //
    // Create a block cipher key for testing SetKeyParam
    //
    LOG_TRY(CreateNewKey(hProv, CALG_RC2, (40 << 16) | CRYPT_CREATE_SALT, &hKey, ptc));

    //
    // Group 4I
    //

    //
    // Do CryptSetKeyParam test cases
    //

    //
    // Test KP_SALT
    //
    LOG_TRY(TGetKey(hKey, KP_SALT, NULL, &cbData, 0, ptc));

    LOG_TRY(TestAlloc(&pbData, cbData, ptc));

    memset(pbData, TEST_SALT_BYTE, cbData);

    // Set key's salt to a known value
    LOG_TRY(TSetKey(hKey, KP_SALT, pbData, 0, ptc));

    // Retrieve the salt value from the CSP for verification
    LOG_TRY(TGetKey(hKey, KP_SALT, pbData, &cbData, 0, ptc));

    while (cbData && (pbData[cbData - 1] == TEST_SALT_BYTE))
    {
        cbData--;
    }

    if (0 != cbData)
    {
        LOG_TRY(LogBadParam(
            API_CRYPTSETKEYPARAM,
            L"CryptSetKeyParam KP_SALT bytes have incorrect value", 
            ptc));
    }

    free(pbData);
    pbData = NULL;

    //
    // Test KP_SALT_EX
    //
    db.cbData = TEST_SALT_LEN;

    LOG_TRY(TestAlloc(&(db.pbData), TEST_SALT_LEN, ptc));

    memset(db.pbData, TEST_SALT_BYTE, TEST_SALT_LEN);

    LOG_TRY(TSetKey(hKey, KP_SALT_EX, (PBYTE) &db, 0, ptc));

    // TODO: Not sure how to verify KP_SALT_EX values

    //
    // Test KP_PERMISSIONS
    //
    dw = CRYPT_EXPORT;

    //
    // The Microsoft CSP's do not allow the exportability of a key
    // to be changed.
    //
    ptc->KnownErrorID = KNOWN_CRYPTSETKEYPARAM_EXPORT;
    ptc->pwszErrorHelp = L"Attempt to change key to exportable";
    LOG_TRY(TSetKey(hKey, KP_PERMISSIONS, (PBYTE) &dw, 0, ptc));
    ptc->pwszErrorHelp = NULL;
    
    dw = 0;
    cbData = sizeof(dw);
    LOG_TRY(TGetKey(hKey, KP_PERMISSIONS, (PBYTE) &dw, &cbData, 0, ptc));

    if (! (CRYPT_EXPORT & dw))
    {
        LOG_TRY(LogBadParam(
            API_CRYPTSETKEYPARAM,
            L"CryptGetKeyParam KP_PERMISSIONS should now include CRYPT_EXPORT", 
            ptc));
    }
    ptc->KnownErrorID = KNOWN_ERROR_UNKNOWN;

    //
    // Test KP_EFFECTIVE_KEYLEN
    //
    dw = TEST_EFFECTIVE_KEYLEN;
    LOG_TRY(TSetKey(hKey, KP_EFFECTIVE_KEYLEN, (PBYTE) &dw, 0, ptc));

    dw = 0;
    cbData = sizeof(dw);
    LOG_TRY(TGetKey(hKey, KP_EFFECTIVE_KEYLEN, (PBYTE) &dw, &cbData, 0, ptc));

    if (TEST_EFFECTIVE_KEYLEN != dw)
    {
        LOG_TRY(LogBadParam(
            API_CRYPTSETKEYPARAM,
            L"CryptSetKeyParam KP_EFFECTIVE_KEYLEN failed", 
            ptc));
    }

    //
    // KP_IV
    //
    LOG_TRY(TGetKey(hKey, KP_IV, NULL, &cbData, 0, ptc));

    LOG_TRY(TestAlloc(&pbData, cbData, ptc));

    memset(pbData, TEST_IV_BYTE, cbData);

    LOG_TRY(TSetKey(hKey, KP_IV, pbData, 0, ptc));

    memset(pbData, 0x00, cbData);

    LOG_TRY(TGetKey(hKey, KP_IV, pbData, &cbData, 0, ptc));

    while (cbData && (TEST_IV_BYTE == pbData[cbData - 1]))
    {
        cbData--;
    }

    if (0 != cbData)
    {
        LOG_TRY(LogBadParam(
            API_CRYPTSETKEYPARAM,
            L"CryptSetKeyParam TEST_IV_BYTE contains incorrect data", 
            ptc));
    }

    free(pbData);
    pbData = NULL;

    //
    // KP_PADDING
    //
    dw = PKCS5_PADDING;
    LOG_TRY(TSetKey(hKey, KP_PADDING, (PBYTE) &dw, 0, ptc));

    dw = 0;
    cbData = sizeof(dw);
    LOG_TRY(TGetKey(hKey, KP_PADDING, (PBYTE) &dw, &cbData, 0, ptc));

    if (PKCS5_PADDING != dw)
    {
        LOG_TRY(LogBadParam(
            API_CRYPTSETKEYPARAM,
            L"CryptSetKeyParam KP_PADDING has incorrect value", 
            ptc));
    }

    //
    // KP_MODE
    //
    dw = CRYPT_MODE_ECB;
    LOG_TRY(TSetKey(hKey, KP_MODE, (PBYTE) &dw, 0, ptc));

    dw = 0;
    cbData = sizeof(dw);
    LOG_TRY(TGetKey(hKey, KP_MODE, (PBYTE) &dw, &cbData, 0, ptc));

    if (CRYPT_MODE_ECB != dw)
    {
        LOG_TRY(LogBadParam(
            API_CRYPTSETKEYPARAM,
            L"CryptSetKeyParam KP_MODE has incorrect value", 
            ptc));
    }

    //
    // KP_MODE_BITS
    //
    dw = TEST_MODE_BITS;
    LOG_TRY(TSetKey(hKey, KP_MODE_BITS, (PBYTE) &dw, 0, ptc));

    dw = 0;
    cbData = sizeof(dw);
    LOG_TRY(TGetKey(hKey, KP_MODE_BITS, (PBYTE) &dw, &cbData, 0, ptc));

    if (TEST_MODE_BITS != dw)
    {
        LOG_TRY(LogBadParam(
            API_CRYPTSETKEYPARAM,
            L"CryptSetKeyParam KP_MODE_BITS contains incorrect value", 
            ptc));
    }   

    fSuccess = TRUE;

Cleanup:

    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: NegativeSetKeyParamTests
// Purpose: Run the negative test cases for CryptSetKeyParam
//
BOOL NegativeSetKeyParamTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    //LPWSTR pwszContainer      = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTKEY hKey              = 0;
    DWORD dw                    = 0;        
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    //
    // Group 4I
    //

    //
    // Do CryptSetKeyParam negative test cases
    //

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TSetKey(0, KP_PERMISSIONS, (PBYTE) &dw, 0, ptc));
            
    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TSetKey(TEST_INVALID_HANDLE, KP_PERMISSIONS, (PBYTE) &dw, 0, ptc));

    LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

    LOG_TRY(CreateNewKey(hProv, CALG_RC4, 0, &hKey, ptc));

    ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
    LOG_TRY(TSetKey(hKey, KP_PERMISSIONS, NULL, 0, ptc));

    ptc->dwErrorCode = NTE_BAD_FLAGS;
    LOG_TRY(TSetKey(hKey, KP_PERMISSIONS, (PBYTE) &dw, TEST_INVALID_FLAG, ptc));

    ptc->dwErrorCode = NTE_BAD_TYPE;
    LOG_TRY(TSetKey(hKey, TEST_INVALID_FLAG, (PBYTE) &dw, 0, ptc));

    fSuccess = TRUE;

Cleanup:

    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: PositiveExportKeyTests
// Purpose: Run the test cases for CryptExportKey.  The set of test cases depends on the current
// CSP class being tested, as specified in the dwCSPClass parameter.
//
BOOL PositiveExportKeyTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTKEY hKey              = 0;
    HCRYPTKEY hEncryptKey       = 0;
    PBYTE pbKey                 = NULL;
    DWORD cbKey                 = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    
    LOG_TRY(CreateNewContext(&hProv, pwszContainer, CRYPT_NEWKEYSET, ptc));
    
    //
    // Group 5C
    //
    
    //
    // Do CryptExportKey test cases
    //
    switch (pCSPInfo->TestCase.dwCSPClass)
    {
        case CLASS_SIG_ONLY:
        {
            LOG_TRY(CreateNewKey(hProv, AT_SIGNATURE, CRYPT_EXPORTABLE, &hKey, ptc));
                
            LOG_TRY(CreateNewKey(hProv, CALG_RC4, 0, &hEncryptKey, ptc));

            //
            // Export a PRIVATEKEYBLOB
            //          
            // Private key export is not permitted on Smart Cards
            if (! pCSPInfo->fSmartCardCSP)
            {         
                LOG_TRY(TExportKey(hKey, hEncryptKey, PRIVATEKEYBLOB, 0, NULL, &cbKey, ptc));
                
                LOG_TRY(TestAlloc(&pbKey, cbKey, ptc));
                
                LOG_TRY(TExportKey(hKey, hEncryptKey, PRIVATEKEYBLOB, 0, pbKey, &cbKey, ptc));
                
                free(pbKey);
                pbKey = NULL;
            }
            
            //
            // Export a PUBLICKEYBLOB
            //
            cbKey = 0;
            LOG_TRY(TExportKey(hKey, 0, PUBLICKEYBLOB, 0, NULL, &cbKey, ptc));
            
            LOG_TRY(TestAlloc(&pbKey, cbKey, ptc));
            
            LOG_TRY(TExportKey(hKey, 0, PUBLICKEYBLOB, 0, pbKey, &cbKey, ptc));
            
            free(pbKey);
            pbKey = NULL;
            
            LOG_TRY(TDestroyKey(hKey, ptc));
            hKey = 0;
            
            //
            // Export a SYMMETRICWRAPKEYBLOB
            //
            LOG_TRY(CreateNewKey(hProv, CALG_RC4, CRYPT_EXPORTABLE, &hKey, ptc));
            
            cbKey = 0;
            LOG_TRY(TExportKey(hKey, hEncryptKey, SYMMETRICWRAPKEYBLOB, 0, NULL, &cbKey, ptc));
            
            LOG_TRY(TestAlloc(&pbKey, cbKey, ptc));
            
            LOG_TRY(TExportKey(hKey, hEncryptKey, SYMMETRICWRAPKEYBLOB, 0, pbKey, &cbKey, ptc));
            
            break;
        }
        
        case CLASS_SIG_KEYX:
        {
            //
            // Export a SIMPLEBLOB
            //
            LOG_TRY(CreateNewKey(hProv, CALG_RC4, CRYPT_EXPORTABLE, &hKey, ptc));

            LOG_TRY(CreateNewKey(hProv, AT_KEYEXCHANGE, 0, &hEncryptKey, ptc));
            
            cbKey = 0;
            LOG_TRY(TExportKey(hKey, hEncryptKey, SIMPLEBLOB, 0, NULL, &cbKey, ptc));
            
            LOG_TRY(TestAlloc(&pbKey, cbKey, ptc));
                
            LOG_TRY(TExportKey(hKey, hEncryptKey, SIMPLEBLOB, 0, pbKey, &cbKey, ptc));
                
            free(pbKey);
            pbKey = NULL;
                
            //
            // Export a SIMPLEBLOB with the CRYPT_OAEP flag
            //
            cbKey = 0;
            LOG_TRY(TExportKey(hKey, hEncryptKey, SIMPLEBLOB, CRYPT_OAEP, NULL, &cbKey, ptc));
            
            LOG_TRY(TestAlloc(&pbKey, cbKey, ptc));
                
            LOG_TRY(TExportKey(hKey, hEncryptKey, SIMPLEBLOB, CRYPT_OAEP, pbKey, &cbKey, ptc));
                
            break;
        }
            
        default:
        {
            goto Cleanup;
        }
    }
    fSuccess = TRUE;
    
Cleanup:
    
    if (pbKey)
    {
        free(pbKey);
    }
    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hEncryptKey)
    {
        TDestroyKey(hEncryptKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }
    
    return fSuccess;
}

//
// Function: NegativeExportKeyTests
// Purpose: Run the negative test cases for CryptExportKey.  The set of test cases depends on the current
// CSP class being tested, as specified in the dwCSPClass parameter.
//
BOOL NegativeExportKeyTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    LPWSTR pwszContainer2       = TEST_CONTAINER_2;
    HCRYPTPROV hProv            = 0;
    HCRYPTPROV hProv2           = 0;
    HCRYPTKEY hKey              = 0;
    HCRYPTKEY hKeyExch          = 0;
    HCRYPTKEY hEncryptKey       = 0;
    DWORD dw                    = 0;
    DWORD cb                    = 0;
    PBYTE pb                    = NULL;     
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    //
    // Group 5C
    //

    //
    // Run only the negative test cases appropriate for the current CSP class
    //
    switch (ptc->dwCSPClass)
    {
    case CLASS_SIG_ONLY:
        {
            //
            // Do CryptExportKey CLASS_SIG_ONLY negative test cases
            //
            
            ptc->dwErrorCode = ERROR_INVALID_HANDLE;
            LOG_TRY(TExportKey(0, 0, PUBLICKEYBLOB, 0, (PBYTE) &dw, &cb, ptc));
            
            ptc->dwErrorCode = ERROR_INVALID_HANDLE;
            LOG_TRY(TExportKey(TEST_INVALID_HANDLE, 0, PUBLICKEYBLOB, 0, (PBYTE) &dw, &cb, ptc));
            
            // The TEST_LEVEL_CONTAINER CryptAcquireContext tests should be run before
            // other Container level tests to ensure that this works.
            LOG_TRY(CreateNewContext(&hProv, pwszContainer, CRYPT_NEWKEYSET, ptc));
            
            // Create an exportable signature key pair
            LOG_TRY(CreateNewKey(hProv, AT_SIGNATURE, CRYPT_EXPORTABLE, &hKey, ptc));
            
            ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
            LOG_TRY(TExportKey(hKey, 0, PUBLICKEYBLOB, 0, (PBYTE) TEST_INVALID_POINTER, NULL, ptc));
            
            // Indicate a buffer length that is too small
            cb = 1;
            ptc->dwErrorCode = ERROR_MORE_DATA;
            LOG_TRY(TExportKey(hKey, 0, PUBLICKEYBLOB, 0, (PBYTE) &dw, &cb, ptc));
            
            // cb should contain the actual required buffer size to export
            
            // try to export to buffer that's too small, will AV
            ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
            LOG_TRY(TExportKey(hKey, 0, PUBLICKEYBLOB, 0, (PBYTE) TEST_INVALID_POINTER, &cb, ptc));
            
            // invalid flags
            ptc->dwErrorCode = NTE_BAD_FLAGS;
            LOG_TRY(TExportKey(hKey, 0, PUBLICKEYBLOB, TEST_INVALID_FLAG, (PBYTE) &dw, &cb, ptc));
            
            // invalid blob type
            ptc->dwErrorCode = NTE_BAD_TYPE;
            LOG_TRY(TExportKey(hKey, 0, TEST_INVALID_FLAG, 0, NULL, &cb, ptc));

            // Private key export is not permitted on Smart Cards
            if (pCSPInfo->fSmartCardCSP)
            {         
                LOG_TRY(CreateNewKey(hProv, CALG_RC4, 0, &hEncryptKey, ptc));

                ptc->dwErrorCode = NTE_BAD_TYPE;
                LOG_TRY(TExportKey(hKey, hEncryptKey, PRIVATEKEYBLOB, 0, NULL, &cb, ptc));
            }
            else
            {         
                LOG_TRY(TDestroyKey(hKey, ptc));
                hKey = 0;
                            
                // Create a new non-exportable signature key pair
                LOG_TRY(CreateNewKey(hProv, AT_SIGNATURE, 0, &hKey, ptc));

                // Try to export non-exportable key
                ptc->dwErrorCode = NTE_BAD_KEY_STATE;
                LOG_TRY(TExportKey(hKey, 0, PRIVATEKEYBLOB, 0, (PBYTE) &dw, &cb, ptc));
            }
                                              
            break;
        }
        
    case CLASS_SIG_KEYX:
        {
            //
            // Do CryptExportKey CLASS_SIG_KEYX negative test cases
            //

            // Create context and key handle for signature pair
            LOG_TRY(CreateNewContext(&hProv, pwszContainer, CRYPT_NEWKEYSET, ptc));
            
            LOG_TRY(CreateNewKey(hProv, AT_SIGNATURE, CRYPT_EXPORTABLE, &hKey, ptc));

            // Create key handle for exchange pair
            LOG_TRY(CreateNewKey(hProv, AT_KEYEXCHANGE, 0, &hKeyExch, ptc));

            // Should not be able to export PUBLICKEYBLOB with exchange key specified
            ptc->dwErrorCode = NTE_BAD_PUBLIC_KEY;
            LOG_TRY(TExportKey(hKey, hKeyExch, PUBLICKEYBLOB, 0, (PBYTE) &dw, &cb, ptc));

            // Destroy signature key
            LOG_TRY(TDestroyKey(hKey, ptc));
            hKey = 0;

            // Create symmetric key
            LOG_TRY(CreateNewKey(hProv, CALG_RC4, CRYPT_EXPORTABLE, &hKey, ptc));

            ptc->dwErrorCode = NTE_BAD_KEY;
            LOG_TRY(TExportKey(hKey, TEST_INVALID_HANDLE, SIMPLEBLOB, 0, (PBYTE) &dw, &cb, ptc));

            // Destroy the key exchange pair handle
            LOG_TRY(TDestroyKey(hKeyExch, ptc));
            hKeyExch = 0;

            // Create separate cryptographic context
            LOG_TRY(CreateNewContext(&hProv2, pwszContainer2, CRYPT_NEWKEYSET, ptc));

            // Create new key exchange pair in new context
            LOG_TRY(CreateNewKey(hProv, AT_KEYEXCHANGE, 0, &hKeyExch, ptc));

            // Should not be able to export using keys from separate contexts
            ptc->dwErrorCode = NTE_BAD_KEY;
            LOG_TRY(TExportKey(hKey, hKeyExch, PRIVATEKEYBLOB, 0, (PBYTE) &dw, &cb, ptc));

            break;
        }
    }   

    fSuccess = TRUE;

Cleanup:

    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hKeyExch)
    {
        TDestroyKey(hKeyExch, ptc);
    }
    if (hEncryptKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }
    if (hProv2)
    {
        TRelease(hProv2, 0, ptc);
    }

    return fSuccess;
}

//
// Function: PositiveGetUserKeyTests
// Purpose: Run the test cases for CryptGetUserKey
//
BOOL PositiveGetUserKeyTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTKEY hKey              = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    LOG_TRY(CreateNewContext(&hProv, pwszContainer, CRYPT_NEWKEYSET, ptc));

    //
    // Group 5E
    //

    //
    // Do CryptGetUserKey test cases
    //
    switch(ptc->dwCSPClass)
    {
    case CLASS_SIG_ONLY:
        {
            LOG_TRY(CreateNewKey(hProv, AT_SIGNATURE, 0, &hKey, ptc));

            LOG_TRY(TDestroyKey(hKey, ptc));

            LOG_TRY(TGetUser(hProv, AT_SIGNATURE, &hKey, ptc));

            break;
        }
        
    case CLASS_SIG_KEYX:
        {
            LOG_TRY(CreateNewKey(hProv, AT_KEYEXCHANGE, 0, &hKey, ptc));

            LOG_TRY(TDestroyKey(hKey, ptc));

            LOG_TRY(TGetUser(hProv, AT_KEYEXCHANGE, &hKey, ptc));

            break;
        }
    default:
        {
            goto Cleanup;
        }
    }   

    fSuccess = TRUE;

Cleanup:

    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: NegativeGetUserKeyTests
// Purpose: Run the negative test cases for CryptGetUserKey
//
BOOL NegativeGetUserKeyTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTKEY hKey              = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    //
    // Group 5E
    //
    
    switch (ptc->dwCSPClass)
    {
    case CLASS_SIG_ONLY:
        {
            //
            // Do CryptGetUserKey negative test cases
            //
            
            ptc->dwErrorCode = ERROR_INVALID_HANDLE;
            LOG_TRY(TGetUser(0, AT_SIGNATURE, &hKey, ptc));
            
            ptc->dwErrorCode = ERROR_INVALID_HANDLE;
            LOG_TRY(TGetUser(TEST_INVALID_HANDLE, AT_SIGNATURE, &hKey, ptc));
            
            //
            // Use context with no container access
            //
            LOG_TRY(CreateNewContext(&hProv, NULL, CRYPT_VERIFYCONTEXT, ptc));

            //
            // Create a non-persisted key pair.
            //
            /*
            LOG_TRY(CreateNewKey(hProv, AT_SIGNATURE, 0, &hKey, ptc));

            LOG_TRY(TDestroyKey(hKey, ptc));
            */
            
            // Not sure what expected error code should be here
            ptc->dwErrorCode = NTE_NO_KEY;
            LOG_TRY(TGetUser(hProv, AT_SIGNATURE, &hKey, ptc));
            
            LOG_TRY(TRelease(hProv, 0, ptc));
            hProv = 0;
            
            // Create new context but no key
            LOG_TRY(CreateNewContext(&hProv, pwszContainer, CRYPT_NEWKEYSET, ptc));
            
            ptc->dwErrorCode = NTE_BAD_KEY;
            LOG_TRY(TGetUser(hProv, TEST_INVALID_FLAG, &hKey, ptc));
            
            ptc->dwErrorCode = NTE_NO_KEY;
            LOG_TRY(TGetUser(hProv, AT_SIGNATURE, &hKey, ptc));
            
            break;
        }
        
    case CLASS_SIG_KEYX:
        {
            // Create new context and signature key pair
            LOG_TRY(CreateNewContext(&hProv, pwszContainer, CRYPT_NEWKEYSET, ptc));
            
            LOG_TRY(CreateNewKey(hProv, AT_SIGNATURE, 0, &hKey, ptc));

            // Request key exchange key pair, should fail since it hasn't been created
            ptc->dwErrorCode = NTE_NO_KEY;
            LOG_TRY(TGetUser(hProv, AT_KEYEXCHANGE, &hKey, ptc));

            break;
        }
    }

    fSuccess = TRUE;

Cleanup:

    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: TestPrivateKeyBlobProc
//
BOOL TestPrivateKeyBlobProc(
        PALGNODE pAlgNode,
        PTESTCASE ptc,
        PVOID pvKeyExportInfo)
{
    BOOL fSuccess                       = FALSE;
    HCRYPTKEY hKey                      = 0;
    HCRYPTKEY hEncryptKey               = 0;
    PBYTE pbKey                         = NULL;
    DWORD cbKey                         = 0;
    PKEY_EXPORT_INFO pKeyExportInfo     = (PKEY_EXPORT_INFO) pvKeyExportInfo;
    
    LOG_TRY(CreateNewKey(
        pKeyExportInfo->hProv,
        pKeyExportInfo->aiKey,
        CRYPT_EXPORTABLE | (pKeyExportInfo->dwKeySize << 16),
        &hKey,
        ptc));

    if (pKeyExportInfo->fUseEncryptKey)
    {
        LOG_TRY(CreateNewKey(
            pKeyExportInfo->hProv,
            pAlgNode->ProvEnumalgsEx.aiAlgid,
            pKeyExportInfo->dwEncryptKeySize << 16,
            &hEncryptKey,
            ptc));
    }

    LOG_TRY(TExportKey(
        hKey,
        hEncryptKey,
        PRIVATEKEYBLOB,
        pKeyExportInfo->dwExportFlags,
        NULL,
        &cbKey,
        ptc));

    LOG_TRY(TestAlloc(&pbKey, cbKey, ptc));

    LOG_TRY(TExportKey(
        hKey,
        hEncryptKey,
        PRIVATEKEYBLOB,
        pKeyExportInfo->dwExportFlags,
        pbKey,
        &cbKey,
        ptc));

    LOG_TRY(TDestroyKey(hKey, ptc));
    hKey = 0;

    LOG_TRY(TImportKey(
        pKeyExportInfo->hProv,
        pbKey,
        cbKey,
        hEncryptKey,
        pKeyExportInfo->dwExportFlags,
        &hKey,
        ptc));

    fSuccess = TRUE;

Cleanup:

    if (pbKey)
    {
        free(pbKey);
    }
    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hEncryptKey)
    {
        TDestroyKey(hEncryptKey, ptc);
    }

    return fSuccess;
}

//
// Function: TestSymmetricWrapKeyBlobProc
//
BOOL TestSymmetricWrapKeyBlobProc(
        PALGNODE pAlgNode,
        PTESTCASE ptc,
        PVOID pvKeyExportInfo)
{
    BOOL fSuccess                       = FALSE;
    HCRYPTKEY hKey                      = 0;
    HCRYPTKEY hEncryptKey               = 0;
    PBYTE pbKey                         = NULL;
    DWORD cbKey                         = 0;
    PKEY_EXPORT_INFO pKeyExportInfo     = (PKEY_EXPORT_INFO) pvKeyExportInfo;
    
    //
    // Create the key to be exported
    //
    LOG_TRY(CreateNewKey(
        pKeyExportInfo->hProv,
        pAlgNode->ProvEnumalgsEx.aiAlgid,
        CRYPT_EXPORTABLE | (pKeyExportInfo->dwKeySize << 16),
        &hKey,
        ptc));

    if (! pKeyExportInfo->fUseEncryptKey)
    {
        return FALSE;
    }

    //
    // Create the encryption key 
    //
    LOG_TRY(CreateNewKey(
        pKeyExportInfo->hProv,
        pKeyExportInfo->aiEncryptKey,
        pKeyExportInfo->dwEncryptKeySize << 16,
        &hEncryptKey,
        ptc));
    
    LOG_TRY(TExportKey(
        hKey,
        hEncryptKey,
        SYMMETRICWRAPKEYBLOB,
        pKeyExportInfo->dwExportFlags,
        NULL,
        &cbKey,
        ptc));

    LOG_TRY(TestAlloc(&pbKey, cbKey, ptc));

    LOG_TRY(TExportKey(
        hKey,
        hEncryptKey,
        SYMMETRICWRAPKEYBLOB,
        pKeyExportInfo->dwExportFlags,
        pbKey,
        &cbKey,
        ptc));

    LOG_TRY(TDestroyKey(hKey, ptc));
    hKey = 0;

    LOG_TRY(TImportKey(
        pKeyExportInfo->hProv,
        pbKey,
        cbKey,
        hEncryptKey,
        pKeyExportInfo->dwExportFlags,
        &hKey,
        ptc));

    fSuccess = TRUE;

Cleanup:

    if (pbKey)
    {
        free(pbKey);
    }
    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hEncryptKey)
    {
        TDestroyKey(hEncryptKey, ptc);
    }

    return fSuccess;
}

//
// Function: TestSymmetricWrapperProc
// Purpose: Test all possible combinations of wrapping one symmetric
// key algorithm with another.  This function will be called once for 
// each encryption key alg, and this function will use AlgListIterate
// to call TestSymmetricWrapKeyBlobProc once for each encryption
// key alg.
//
BOOL TestSymmetricWrapperProc(
        PALGNODE pAlgNode,
        PTESTCASE ptc,
        PVOID pvKeyExportInfo)
{
    BOOL fSuccess               = FALSE;
    
    ((PKEY_EXPORT_INFO) pvKeyExportInfo)->aiEncryptKey = pAlgNode->ProvEnumalgsEx.aiAlgid;

    LOG_TRY(AlgListIterate(
        ((PKEY_EXPORT_INFO) pvKeyExportInfo)->pAlgList,
        DataEncryptFilter,
        TestSymmetricWrapKeyBlobProc,
        pvKeyExportInfo,
        ptc));

    fSuccess = TRUE;

Cleanup:
    return fSuccess;
}       

//
// Function: ScenarioImportKeyTests
// Purpose: Test CryptImportKey and CryptExportKey for PRIVATEKEYBLOB and
// SYMMETRICWRAPKEYBLOB scenarios.  Repeat for all supported encryption
// algorithms.
//
BOOL ScenarioImportKeyTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    PALGNODE pAlgList           = pCSPInfo->pAlgList;
    KEY_EXPORT_INFO KeyExportInfo;

    memset(&KeyExportInfo, 0, sizeof(KeyExportInfo));

    LOG_TRY(CreateNewContext(
        &(KeyExportInfo.hProv), 
        pwszContainer, 
        CRYPT_NEWKEYSET, 
        ptc));

    //
    // Run the PRIVATEKEYBLOB variations
    //
    KeyExportInfo.aiKey = AT_KEYEXCHANGE;
    KeyExportInfo.fUseEncryptKey = TRUE;
    
    LOG_TRY(AlgListIterate(
        pAlgList,
        DataEncryptFilter,
        TestPrivateKeyBlobProc,
        (PVOID) &KeyExportInfo,
        ptc));

    //
    // Run the SYMMETRICWRAPKEYBLOB variations
    //
    KeyExportInfo.aiKey = 0;
    KeyExportInfo.pAlgList = pAlgList;

    LOG_TRY(AlgListIterate(
        pAlgList,
        DataEncryptFilter,
        TestSymmetricWrapperProc,
        (PVOID) &KeyExportInfo,
        ptc));

    fSuccess = TRUE;

Cleanup:

    if (KeyExportInfo.hProv)
    {
        TRelease(KeyExportInfo.hProv, 0, ptc);
    }

    return fSuccess;
}

//
// RSA Signature PRIVATEKEYBLOB
//
BYTE rgbPrivateKeyBlob [] = 
{
0x07, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00,
0x52, 0x53, 0x41, 0x32, 0x00, 0x02, 0x00, 0x00,
0x01, 0x00, 0x01, 0x00, 0xf3, 0xd8, 0x26, 0xb9,
0xbc, 0x43, 0xe4, 0x7c, 0x73, 0x36, 0xf6, 0xc3,
0x92, 0x1e, 0x2d, 0x69, 0x8d, 0x17, 0x78, 0xdf,
0x49, 0x9d, 0x1c, 0x5d, 0xbd, 0x9d, 0xf9, 0x66,
0xd8, 0x27, 0xa2, 0x5f, 0x40, 0x95, 0x20, 0xe1,
0xbf, 0xd4, 0x0b, 0x0d, 0xd7, 0xb6, 0x2d, 0x8b,
0x05, 0x06, 0x9d, 0x9f, 0x4d, 0x17, 0x9e, 0x82,
0x5e, 0x48, 0x74, 0xcf, 0x73, 0x1d, 0x60, 0xea,
0x62, 0x7f, 0xfe, 0xeb, 0x37, 0x3e, 0x03, 0x3b,
0x2b, 0x50, 0xc6, 0x28, 0x4a, 0x7d, 0xd9, 0x08,
0xb3, 0x2e, 0x3c, 0x61, 0x61, 0x78, 0xf7, 0xd8,
0xfd, 0x50, 0x05, 0x87, 0xfe, 0x6a, 0x68, 0x6e,
0x15, 0xa8, 0x99, 0xfd, 0x25, 0x7d, 0x22, 0xef,
0x9f, 0x70, 0x1c, 0xa7, 0x38, 0xa5, 0x18, 0x31,
0x82, 0x72, 0x71, 0x72, 0x95, 0x01, 0x70, 0x12,
0x04, 0xc8, 0xb9, 0xa0, 0xa1, 0xde, 0x8f, 0xef,
0xc3, 0x30, 0x3a, 0xee, 0xc1, 0x57, 0xf3, 0x63,
0xef, 0xb5, 0x78, 0x12, 0xb7, 0x69, 0x55, 0x45,
0x57, 0x45, 0x51, 0x65, 0x01, 0x6e, 0x77, 0xad,
0xe1, 0x0c, 0xa0, 0x02, 0x20, 0x91, 0x2c, 0x36,
0x42, 0xad, 0x81, 0xdf, 0x21, 0x60, 0x5c, 0x06,
0x0f, 0x4b, 0x26, 0xb4, 0x58, 0x1a, 0xda, 0x19,
0x6c, 0x5b, 0x7c, 0x9a, 0x80, 0xcb, 0x15, 0x2d,
0xb3, 0xde, 0x2b, 0xb2, 0xf8, 0xb8, 0x9d, 0xc8,
0x38, 0x41, 0x93, 0xa3, 0xb1, 0x8d, 0x3e, 0x7e,
0x3c, 0x78, 0xd7, 0x6f, 0xfd, 0xea, 0xc4, 0xf8,
0xbb, 0x44, 0xb8, 0x1e, 0x3f, 0x70, 0x98, 0x38,
0x4e, 0x4c, 0x2f, 0x95, 0xb8, 0xef, 0x21, 0x2e,
0x12, 0x95, 0x0e, 0x3f, 0xb9, 0xdd, 0xa1, 0x97,
0xdb, 0xcf, 0xdb, 0xcc, 0x86, 0xfe, 0x54, 0xae,
0x59, 0xe6, 0xa7, 0x83, 0xd3, 0x7d, 0x5f, 0x5c,
0xd1, 0xf6, 0x5a, 0xf0, 0xc1, 0xe2, 0xf8, 0xb8,
0xc0, 0x7c, 0xd8, 0x2a, 0xcd, 0xc4, 0x31, 0xd5,
0xe5, 0xc2, 0xa9, 0xa3, 0xe9, 0x70, 0x64, 0x28,
0xf0, 0xb8, 0x31, 0x52, 0x6c, 0x8a, 0x3c, 0xae,
0x43, 0xc4, 0xa5, 0x93, 0x1b, 0x86, 0x0f, 0x71,
0xd1, 0x27, 0xb4, 0xe2
};

//
// RSA Signature PUBLICKEYBLOB
//
BYTE rgbPublicKeyBlob [] =
{
0x06, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00,
0x52, 0x53, 0x41, 0x31, 0x00, 0x02, 0x00, 0x00,
0x01, 0x00, 0x01, 0x00, 0xd7, 0x90, 0x56, 0x7a,
0x9e, 0x87, 0x53, 0x90, 0x94, 0x37, 0x46, 0x4e,
0x99, 0xe7, 0xee, 0xc5, 0xa8, 0x24, 0x10, 0x5c,
0xd3, 0xc9, 0x22, 0x15, 0xab, 0xfa, 0xa5, 0x2f,
0x4e, 0x51, 0x73, 0x83, 0xef, 0x4c, 0x87, 0xe7,
0x79, 0x83, 0xd0, 0xf0, 0xb7, 0x34, 0xf1, 0xe8,
0x76, 0xb2, 0x6a, 0x0b, 0x13, 0x82, 0x9c, 0x89,
0xeb, 0x57, 0xf1, 0x6b, 0x9c, 0x47, 0x99, 0xd2,
0x26, 0x9d, 0x75, 0xc4
};

//
// Function: PositiveImportKeyTests
// Purpose: Run the test cases for CryptImportKey.  The set of test cases to be run
// depends on the current CSP class being tested, as specified in the dwCSPClass 
// parameter.
//
BOOL PositiveImportKeyTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    HCRYPTKEY hKey              = 0;
    HCRYPTKEY hEncryptKey       = 0;
    HCRYPTPROV hProv            = 0;
    PBYTE pbKey                 = NULL;
    DWORD cbKey                 = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    LOG_TRY(CreateNewContext(&hProv, pwszContainer, CRYPT_NEWKEYSET, ptc));
        
    //
    // Group 5F
    //
    
    //
    // Do CryptImportKey positive test cases
    //
    switch (pCSPInfo->TestCase.dwCSPClass)
    {
        case CLASS_SIG_ONLY:
        {
            //
            // Import a previously generated unencrypted PRIVATEKEYBLOB
            //
            LOG_TRY(TImportKey(
                hProv,
                rgbPrivateKeyBlob,
                sizeof(rgbPrivateKeyBlob),
                0,
                0,
                &hKey,
                ptc));
            
            LOG_TRY(TDestroyKey(hKey, ptc));
            hKey = 0;
            
            //
            // Import a encrypted PRIVATEKEYBLOB generated from this CSP
            //
            LOG_TRY(CreateNewKey(hProv, AT_SIGNATURE, CRYPT_EXPORTABLE, &hKey, ptc));
            
            LOG_TRY(CreateNewKey(hProv, CALG_RC4, 0, &hEncryptKey, ptc));
            
            LOG_TRY(TExportKey(hKey, hEncryptKey, PRIVATEKEYBLOB, 0, NULL, &cbKey, ptc));
            
            LOG_TRY(TestAlloc(&pbKey, cbKey, ptc));
            
            LOG_TRY(TExportKey(hKey, hEncryptKey, PRIVATEKEYBLOB, 0, pbKey, &cbKey, ptc));
            
            LOG_TRY(TDestroyKey(hKey, ptc));
            hKey = 0;
            
            LOG_TRY(TImportKey(hProv, pbKey, cbKey, hEncryptKey, 0, &hKey, ptc));
            
            LOG_TRY(TDestroyKey(hKey, ptc));
            hKey = 0;
            
            free(pbKey);
            pbKey = NULL;
            
            //
            // Import a previously generated PUBLICKEYBLOB
            //
            LOG_TRY(TImportKey(
                hProv, 
                rgbPublicKeyBlob,
                sizeof(rgbPublicKeyBlob),
                0,
                0,
                &hKey,
                ptc));
            
            LOG_TRY(TDestroyKey(hKey, ptc));
            hKey = 0;
            
            //
            // Import a SYMMETRICWRAPKEYBLOB
            //
            LOG_TRY(CreateNewKey(hProv, CALG_RC4, CRYPT_EXPORTABLE, &hKey, ptc));
            
            cbKey = 0;
            LOG_TRY(TExportKey(hKey, hEncryptKey, SYMMETRICWRAPKEYBLOB, 0, NULL, &cbKey, ptc));
            
            LOG_TRY(TestAlloc(&pbKey, cbKey, ptc));
            
            LOG_TRY(TExportKey(hKey, hEncryptKey, SYMMETRICWRAPKEYBLOB, 0, pbKey, &cbKey, ptc));
            
            LOG_TRY(TDestroyKey(hKey, ptc));
            hKey = 0;
            
            LOG_TRY(TImportKey(hProv, pbKey, cbKey, hEncryptKey, 0, &hKey, ptc));
            
            break;
        }
        case CLASS_SIG_KEYX:
        {
            //
            // Import a SIMPLEBLOB
            //
            LOG_TRY(CreateNewKey(hProv, AT_KEYEXCHANGE, 0, &hEncryptKey, ptc));
                
            LOG_TRY(CreateNewKey(hProv, CALG_RC4, CRYPT_EXPORTABLE, &hKey, ptc));
            
            cbKey = 0;
            LOG_TRY(TExportKey(hKey, hEncryptKey, SIMPLEBLOB, 0, NULL, &cbKey, ptc));
            
            LOG_TRY(TestAlloc(&pbKey, cbKey, ptc));
            
            LOG_TRY(TExportKey(hKey, hEncryptKey, SIMPLEBLOB, 0, pbKey, &cbKey, ptc));
            
            LOG_TRY(TDestroyKey(hKey, ptc));
            hKey = 0;
            
            LOG_TRY(TImportKey(hProv, pbKey, cbKey, hEncryptKey, 0, &hKey, ptc));
            
            LOG_TRY(TDestroyKey(hKey, ptc));
            hKey = 0;
            
            free(pbKey);
            pbKey = NULL;
            
            //
            // Import a SIMPLEBLOB with the CRYPT_OAEP flag
            //
            LOG_TRY(CreateNewKey(hProv, CALG_RC4, CRYPT_EXPORTABLE, &hKey, ptc));
            
            cbKey = 0;
            LOG_TRY(TExportKey(hKey, hEncryptKey, SIMPLEBLOB, CRYPT_OAEP, NULL, &cbKey, ptc));
            
            LOG_TRY(TestAlloc(&pbKey, cbKey, ptc));
            
            LOG_TRY(TExportKey(hKey, hEncryptKey, SIMPLEBLOB, CRYPT_OAEP, pbKey, &cbKey, ptc));
            
            LOG_TRY(TDestroyKey(hKey, ptc));
            hKey = 0;
            
            LOG_TRY(TImportKey(hProv, pbKey, cbKey, hEncryptKey, CRYPT_OAEP, &hKey, ptc));
            
            break;
        }

        default:
        {
            goto Cleanup;
        }
    }
    
    fSuccess = TRUE;

Cleanup:

    if (pbKey)
    {
        free(pbKey);
    }
    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hEncryptKey)
    {
        TDestroyKey(hEncryptKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: NegativeImportKeyTests
// Purpose: Run the negative test cases for CryptImportKey.  The set of test cases to be run
// depends on the current CSP class being tested, as specified in the dwCSPClass 
// parameter.
//
BOOL NegativeImportKeyTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTKEY hKey              = 0;
    HCRYPTKEY hKeyExch          = 0;
    HCRYPTKEY hKeySig           = 0;
    HCRYPTKEY hKeyEncr          = 0;
    DWORD dw                    = 0;
    DWORD cb                    = 0;
    PBYTE pbKey                 = NULL;
    BLOBHEADER *pBlobHeader     = NULL;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
        
    // Acquire context with key container access
    LOG_TRY(CreateNewContext(&hProv, pwszContainer, CRYPT_NEWKEYSET, ptc));

    //
    // Group 5F
    //

    switch (ptc->dwCSPClass)
    {
    case CLASS_SIG_ONLY:
        {
            //
            // Do CryptImportKey negative test cases for CSP CLASS_SIG_ONLY
            //
            cb = sizeof(dw);
            ptc->dwErrorCode = ERROR_INVALID_HANDLE;
            LOG_TRY(TImportKey(0, (PBYTE) &dw, cb, 0, PUBLICKEYBLOB, &hKey, ptc));
            
            ptc->dwErrorCode = ERROR_INVALID_HANDLE;
            LOG_TRY(TImportKey(TEST_INVALID_HANDLE, (PBYTE) &dw, cb, 0, PUBLICKEYBLOB, &hKey, ptc));
                        
            // Create a key signature key pair
            LOG_TRY(CreateNewKey(hProv, AT_SIGNATURE, CRYPT_EXPORTABLE, &hKey, ptc));
            
            // Get correct blob size for signature key public blob
            ptc->fExpectSuccess = TRUE;
            LOG_TRY(TExportKey(hKey, 0, PUBLICKEYBLOB, 0, NULL, &cb, ptc));
            
            LOG_TRY(TestAlloc(&pbKey, cb, ptc));
            
            // Export the key 
            LOG_TRY(TExportKey(hKey, 0, PUBLICKEYBLOB, 0, pbKey, &cb, ptc));
            
            // Destroy the key handle
            LOG_TRY(TDestroyKey(hKey, ptc));
            hKey = 0;
            ptc->fExpectSuccess = FALSE;
            
            // Invalid flag value
            ptc->KnownErrorID = KNOWN_CRYPTIMPORTKEY_BADFLAGS;
            ptc->dwErrorCode = NTE_BAD_FLAGS;
            LOG_TRY(TImportKey(hProv, pbKey, cb, 0, TEST_INVALID_FLAG, &hKey, ptc));
            ptc->KnownErrorID = KNOWN_ERROR_UNKNOWN;

            // Pass in too short buffer
            ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
            LOG_TRY(TImportKey(hProv, (PBYTE) TEST_INVALID_POINTER, cb, 0, 0, &hKey, ptc));
                        
            break;
        }
    case CLASS_SIG_KEYX:
        {
            //
            // Do CryptImportKey negative test cases for CSP CLASS_SIG_KEYX
            //

            // Create a key signature key pair
            LOG_TRY(CreateNewKey(hProv, AT_SIGNATURE, CRYPT_EXPORTABLE, &hKeySig, ptc));

            // Create a key exchange key pair
            LOG_TRY(CreateNewKey(hProv, AT_KEYEXCHANGE, 0, &hKeyExch, ptc));
            
            // Get correct blob size for signature key public blob
            ptc->fExpectSuccess = TRUE;
            LOG_TRY(TExportKey(hKeySig, 0, PUBLICKEYBLOB, 0, NULL, &cb, ptc));
            ptc->fExpectSuccess = FALSE;
            
            // Attempt to import an unencrypted key blob using a key-exchange key
            ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
            LOG_TRY(TImportKey(hProv, (PBYTE) TEST_INVALID_POINTER, cb, hKeyExch, 0, &hKey, ptc));

            // Get correct blob size for encrypted signature key blob
            /*
            ptc->fExpectSuccess = TRUE;
            LOG_TRY(TExportKey(hKeySig, hKeyExch, PRIVATEKEYBLOB, 0, NULL, &cb, ptc));

            LOG_TRY(TestAlloc(&pbKey, cb, ptc));

            // Export the encrypted signature key
            LOG_TRY(TExportKey(hKeySig, hKeyExch, PRIVATEKEYBLOB, 0, pbKey, &cb, ptc));
            ptc->fExpectSuccess = FALSE;

            // Attempt to import encrypted key blob with invalid key-exchange handle
            ptc->dwErrorCode = NTE_BAD_KEY;
            LOG_TRY(TImportKey(hProv, pbKey, cb, TEST_INVALID_HANDLE, 0, &hKey, ptc));

            // Free the key blob memory
            free(pbKey);
            */

            // Create a new encryption key
            LOG_TRY(CreateNewKey(hProv, CALG_RC4, CRYPT_EXPORTABLE, &hKeyEncr, ptc));

            // Get blob size for exporting encrypted symmetric key
            ptc->fExpectSuccess = TRUE;
            LOG_TRY(TExportKey(hKeyEncr, hKeyExch, SIMPLEBLOB, 0, NULL, &cb, ptc));

            LOG_TRY(TestAlloc(&pbKey, cb, ptc));

            // Export encrypted symmetric key
            LOG_TRY(TExportKey(hKeyEncr, hKeyExch, SIMPLEBLOB, 0, pbKey, &cb, ptc));
            ptc->fExpectSuccess = FALSE;

            // Attempt to import encrypted key blob with invalid key-exchange handle
            ptc->dwErrorCode = NTE_BAD_KEY;
            LOG_TRY(TImportKey(hProv, pbKey, cb, TEST_INVALID_HANDLE, 0, &hKey, ptc));

            pBlobHeader = (BLOBHEADER *) pbKey;

            // Save header encryption alg
            dw = pBlobHeader->aiKeyAlg;

            // Clear header encryption alg field
            pBlobHeader->aiKeyAlg = 0;

            ptc->pwszErrorHelp = 
                L"The blob header encryption algorithm is missing";
            ptc->KnownErrorID = KNOWN_CRYPTIMPORTKEY_BADALGID;
            ptc->dwErrorCode = NTE_BAD_ALGID;
            LOG_TRY(TImportKey(hProv, pbKey, cb, hKeyExch, 0, &hKey, ptc));
            ptc->pwszErrorHelp = NULL;
            ptc->KnownErrorID = KNOWN_ERROR_UNKNOWN;

            // Restore header encryption alg
            pBlobHeader->aiKeyAlg = dw;

            // Save blob type header field
            dw = pBlobHeader->bType;

            // Clear blob type header field
            pBlobHeader->bType = 0;

            ptc->dwErrorCode = NTE_BAD_TYPE;
            LOG_TRY(TImportKey(hProv, pbKey, cb, hKeyExch, 0, &hKey, ptc));

            // Restore blob type header field
            pBlobHeader->bType = (BYTE) dw;

            // Save blob version header field
            dw = pBlobHeader->bVersion;

            // Clear blob version header field
            pBlobHeader->bVersion = 0;

            ptc->dwErrorCode = NTE_BAD_VER;
            LOG_TRY(TImportKey(hProv, pbKey, cb, hKeyExch, 0, &hKey, ptc));
            
            break;
        }
    }

    fSuccess = TRUE;

Cleanup:

    if (pbKey)
    {
        free(pbKey);
    }
    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hKeySig)
    {
        TDestroyKey(hKeySig, ptc);
    }
    if (hKeyExch)
    {
        TDestroyKey(hKeyExch, ptc);
    }
    if (hKeyEncr)
    {
        TDestroyKey(hKeyEncr, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

// 
// Function: PositiveSignHashTests
// Purpose: Run the test cases for CryptSignHash.  The set of positive test cases to be run depends on the
// current CSP class being tested, as specified in the dwCSPClass parameter.  
//
BOOL PositiveSignHashTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTKEY hKey              = 0;
    HCRYPTHASH hHash            = 0;
    PBYTE pbSignature           = NULL;
    DWORD cbSignature           = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    LOG_TRY(CreateNewContext(&hProv, pwszContainer, CRYPT_NEWKEYSET, ptc));

    //
    // Group 5G
    //

    //
    // Do CryptSignHash positive test cases
    //
    switch(ptc->dwCSPClass)
    {
    case CLASS_SIG_ONLY:
        {
            //
            // Sign a hash with a signature key pair
            //
            LOG_TRY(CreateNewKey(hProv, AT_SIGNATURE, 0, &hKey, ptc));

            LOG_TRY(CreateNewHash(hProv, CALG_SHA1, &hHash, ptc));

            LOG_TRY(TSignHash(hHash, AT_SIGNATURE, NULL, 0, NULL, &cbSignature, ptc));

            LOG_TRY(TestAlloc(&pbSignature, cbSignature, ptc));

            LOG_TRY(TSignHash(hHash, AT_SIGNATURE, NULL, 0, pbSignature, &cbSignature, ptc));

            free(pbSignature);
            pbSignature = NULL;

            //
            // Sign with the CRYPT_NOHASHOID flag
            //
            LOG_TRY(TSignHash(
                hHash, 
                AT_SIGNATURE, 
                NULL, 
                CRYPT_NOHASHOID, 
                NULL, 
                &cbSignature, 
                ptc));

            LOG_TRY(TestAlloc(&pbSignature, cbSignature, ptc));

            LOG_TRY(TSignHash(
                hHash, 
                AT_SIGNATURE, 
                NULL, 
                CRYPT_NOHASHOID, 
                pbSignature, 
                &cbSignature, 
                ptc));

            break;
        }
    case CLASS_SIG_KEYX:
        {
            //
            // Sign a hash with a key exchange key pair
            //
            LOG_TRY(CreateNewKey(hProv, AT_KEYEXCHANGE, 0, &hKey, ptc));

            LOG_TRY(CreateNewHash(hProv, CALG_SHA1, &hHash, ptc));

            LOG_TRY(TSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, NULL, &cbSignature, ptc));

            LOG_TRY(TestAlloc(&pbSignature, cbSignature, ptc));

            LOG_TRY(TSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, pbSignature, &cbSignature, ptc));

            free(pbSignature);
            pbSignature = NULL;

            //
            // Sign with the CRYPT_NOHASHOID flag
            //
            LOG_TRY(TSignHash(
                hHash, 
                AT_KEYEXCHANGE, 
                NULL, 
                CRYPT_NOHASHOID, 
                NULL, 
                &cbSignature, 
                ptc));

            LOG_TRY(TestAlloc(&pbSignature, cbSignature, ptc));

            LOG_TRY(TSignHash(
                hHash, 
                AT_KEYEXCHANGE, 
                NULL, 
                CRYPT_NOHASHOID, 
                pbSignature, 
                &cbSignature, 
                ptc));

            break;
        }
    default:
        {
            goto Cleanup;
        }
    }

    fSuccess = TRUE;

Cleanup:

    if (pbSignature)
    {
        free(pbSignature);
    }
    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

// 
// Function: NegativeSignHashTests
// Purpose: Run the negative test cases for CryptSignHash.  
//
BOOL NegativeSignHashTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTKEY hKey              = 0;
    HCRYPTHASH hHash            = 0;
    DWORD dw                    = 0;
    DWORD cb                    = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    //
    // Group 5G
    //

    //
    // Do CryptSignHash negative test cases
    //

    // Create provider handle with key container access
    LOG_TRY(CreateNewContext(&hProv, pwszContainer, CRYPT_NEWKEYSET, ptc));
    
    // Create hash
    LOG_TRY(CreateNewHash(hProv, CALG_SHA1, &hHash, ptc));

    // Attempt to sign with a keyset that doesn't exist
    ptc->dwErrorCode = NTE_BAD_KEYSET;
    LOG_TRY(TSignHash(hHash, AT_SIGNATURE, NULL, 0, (PBYTE) &dw, &cb, ptc));

    // Create signature key pair
    LOG_TRY(CreateNewKey(hProv, AT_SIGNATURE, 0, &hKey, ptc));

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TSignHash(0, AT_SIGNATURE, NULL, 0, (PBYTE) &dw, &cb, ptc));

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TSignHash(TEST_INVALID_HANDLE, AT_SIGNATURE, NULL, 0, (PBYTE) &dw, &cb, ptc));

    cb = 1;
    ptc->dwErrorCode = ERROR_MORE_DATA;
    LOG_TRY(TSignHash(hHash, AT_SIGNATURE, NULL, 0, (PBYTE) &dw, &cb, ptc));

    ptc->dwErrorCode = NTE_BAD_ALGID;
    LOG_TRY(TSignHash(hHash, TEST_INVALID_FLAG, NULL, 0, (PBYTE) &dw, &cb, ptc));

    ptc->dwErrorCode = NTE_BAD_FLAGS;
    LOG_TRY(TSignHash(hHash, AT_SIGNATURE, NULL, TEST_INVALID_FLAG, (PBYTE) &dw, &cb, ptc));


    // Release the provider handle
    /*
    LOG_TRY(TRelease(hProv, 0, ptc));
    hProv = 0;

    // Provider handle used to create hHash is now invalid
    ptc->dwErrorCode = NTE_BAD_UID;
    LOG_TRY(TSignHash(hHash, AT_SIGNATURE, NULL, 0, (PBYTE) &dw, &cb, ptc));
    */

    fSuccess = TRUE;

Cleanup:

    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hHash)
    {
        TDestroyHash(hHash, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: SignAndVerifySignatureProc
//
BOOL SignAndVerifySignatureProc(
        PALGNODE pAlgNode,
        PTESTCASE ptc,
        PVOID pvSignHashInfo)
{
    BOOL fSuccess               = FALSE;
    HCRYPTHASH hHash            = 0;
    PBYTE pbSignature           = NULL;
    DWORD cbSignature           = 0;
    PSIGN_HASH_INFO pSignHashInfo = (PSIGN_HASH_INFO) pvSignHashInfo;

    LOG_TRY(CreateNewHash(
        pSignHashInfo->hProv,
        pAlgNode->ProvEnumalgsEx.aiAlgid,
        &hHash,
        ptc));

    LOG_TRY(THashData(
        hHash,
        pSignHashInfo->dbBaseData.pbData,
        pSignHashInfo->dbBaseData.cbData,
        0,
        ptc));

    //
    // Sign the hash with the Signature key pair and verify 
    // the signature.
    //
    LOG_TRY(TSignHash(
        hHash, 
        AT_SIGNATURE, 
        NULL, 
        0, 
        NULL,
        &cbSignature,
        ptc));

    LOG_TRY(TestAlloc(&pbSignature, cbSignature, ptc));

    LOG_TRY(TSignHash(
        hHash, 
        AT_SIGNATURE, 
        NULL, 
        0, 
        pbSignature,
        &cbSignature,
        ptc));

    LOG_TRY(TVerifySign(
        hHash,
        pbSignature,
        cbSignature,
        pSignHashInfo->hSigKey,
        NULL,
        0,
        ptc));

    free(pbSignature);
    pbSignature = NULL;

    //
    // Sign the hash with the Key Exchange key pair and 
    // verify the signature.
    //
    LOG_TRY(TSignHash(
        hHash, 
        AT_KEYEXCHANGE, 
        NULL, 
        0, 
        NULL,
        &cbSignature,
        ptc));

    LOG_TRY(TestAlloc(&pbSignature, cbSignature, ptc));

    LOG_TRY(TSignHash(
        hHash, 
        AT_KEYEXCHANGE, 
        NULL, 
        0, 
        pbSignature,
        &cbSignature,
        ptc));

    LOG_TRY(TVerifySign(
        hHash,
        pbSignature,
        cbSignature,
        pSignHashInfo->hExchKey,
        NULL,
        0,
        ptc));

    fSuccess = TRUE;

Cleanup:

    if (pbSignature)
    {
        free(pbSignature);
    }
    if (hHash)
    {
        TDestroyHash(hHash, ptc);
    }

    return fSuccess;
}

//
// Function: ScenarioVerifySignatureTests
// Purpose: For each supported hash algorithm, call 
// SignAndVerifySignatureProc.
//
BOOL ScenarioVerifySignatureTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    PALGNODE pAlgList           = pCSPInfo->pAlgList;
    SIGN_HASH_INFO SignHashInfo;

    memset(&SignHashInfo, 0, sizeof(SignHashInfo));

    LOG_TRY(CreateNewContext(
        &(SignHashInfo.hProv),
        pwszContainer, 
        CRYPT_NEWKEYSET, 
        ptc));

    LOG_TRY(CreateNewKey(
        SignHashInfo.hProv,
        AT_SIGNATURE,
        0,
        &(SignHashInfo.hSigKey),
        ptc));

    LOG_TRY(CreateNewKey(
        SignHashInfo.hProv,
        AT_KEYEXCHANGE,
        0,
        &(SignHashInfo.hExchKey),
        ptc));

    SignHashInfo.dbBaseData.cbData = wcslen(TEST_HASH_DATA) * sizeof(WCHAR);

    LOG_TRY(TestAlloc(
        &(SignHashInfo.dbBaseData.pbData),
        SignHashInfo.dbBaseData.cbData,
        ptc));

    memcpy(
        SignHashInfo.dbBaseData.pbData, 
        TEST_HASH_DATA,
        SignHashInfo.dbBaseData.cbData);

    //
    // The SignAndVerifySignatureProc isn't meant to work with 
    // MAC algorithms, so filter those out.
    //
    LOG_TRY(AlgListIterate(
        pAlgList,
        HashAlgFilter,
        SignAndVerifySignatureProc,
        (PVOID) &SignHashInfo,
        ptc));

    fSuccess = TRUE;

Cleanup:

    if (SignHashInfo.dbBaseData.pbData)
    {
        free(SignHashInfo.dbBaseData.pbData);
    }
    if (SignHashInfo.hExchKey)
    {
        TDestroyKey(SignHashInfo.hExchKey, ptc);
    }
    if (SignHashInfo.hSigKey)
    {
        TDestroyKey(SignHashInfo.hSigKey, ptc);
    }
    if (SignHashInfo.hProv)
    {
        TRelease(SignHashInfo.hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: PositiveVerifySignatureTests
// Purpose: Run the test cases for CryptVerifySignature
//
BOOL PositiveVerifySignatureTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTKEY hKey              = 0;
    HCRYPTHASH hHash            = 0;
    PBYTE pbSignature           = NULL;
    DWORD cbSignature           = 0;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    LOG_TRY(CreateNewContext(&hProv, pwszContainer, CRYPT_NEWKEYSET, ptc));

    //
    // Group 5H
    //

    //
    // Do CryptVerifySignature positive test cases
    //
    switch(ptc->dwCSPClass)
    {
    case CLASS_SIG_ONLY:
        {
            //
            // Sign and verify a hash using a signature key pair
            //
            LOG_TRY(CreateNewKey(hProv, AT_SIGNATURE, 0, &hKey, ptc));

            LOG_TRY(CreateNewHash(hProv, CALG_SHA1, &hHash, ptc));

            LOG_TRY(TSignHash(hHash, AT_SIGNATURE, NULL, 0, NULL, &cbSignature, ptc));

            LOG_TRY(TestAlloc(&pbSignature, cbSignature, ptc));

            LOG_TRY(TSignHash(hHash, AT_SIGNATURE, NULL, 0, pbSignature, &cbSignature, ptc));

            LOG_TRY(TVerifySign(
                hHash,
                pbSignature,
                cbSignature,
                hKey,
                NULL,
                0,
                ptc));

            free(pbSignature);
            pbSignature = NULL;

            //
            // Sign and verify using the CRYPT_NOHASHOID flag
            //
            LOG_TRY(TSignHash(
                hHash, 
                AT_SIGNATURE, 
                NULL, 
                CRYPT_NOHASHOID, 
                NULL, 
                &cbSignature, 
                ptc));

            LOG_TRY(TestAlloc(&pbSignature, cbSignature, ptc));

            LOG_TRY(TSignHash(
                hHash, 
                AT_SIGNATURE, 
                NULL, 
                CRYPT_NOHASHOID, 
                pbSignature, 
                &cbSignature, 
                ptc));

            LOG_TRY(TVerifySign(
                hHash,
                pbSignature,
                cbSignature,
                hKey,
                NULL,
                CRYPT_NOHASHOID,
                ptc));

            break;
        }
    case CLASS_SIG_KEYX:
        {
            //
            // Sign and verify a hash with a key exchange key pair
            //
            LOG_TRY(CreateNewKey(hProv, AT_KEYEXCHANGE, 0, &hKey, ptc));

            LOG_TRY(CreateNewHash(hProv, CALG_SHA1, &hHash, ptc));

            LOG_TRY(TSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, NULL, &cbSignature, ptc));

            LOG_TRY(TestAlloc(&pbSignature, cbSignature, ptc));

            LOG_TRY(TSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, pbSignature, &cbSignature, ptc));

            LOG_TRY(TVerifySign(
                hHash,
                pbSignature,
                cbSignature,
                hKey,
                NULL,
                0,
                ptc));

            free(pbSignature);
            pbSignature = NULL;

            //
            // Sign and verify using the CRYPT_NOHASHOID flag
            //
            LOG_TRY(TSignHash(
                hHash, 
                AT_KEYEXCHANGE, 
                NULL, 
                CRYPT_NOHASHOID, 
                NULL, 
                &cbSignature, 
                ptc));

            LOG_TRY(TestAlloc(&pbSignature, cbSignature, ptc));

            LOG_TRY(TSignHash(
                hHash, 
                AT_KEYEXCHANGE, 
                NULL, 
                CRYPT_NOHASHOID, 
                pbSignature, 
                &cbSignature, 
                ptc));

            LOG_TRY(TVerifySign(
                hHash,
                pbSignature,
                cbSignature,
                hKey,
                NULL,
                CRYPT_NOHASHOID,
                ptc));

            break;
        }
    default:
        {
            goto Cleanup;
        }
    }

    fSuccess = TRUE;

Cleanup:

    if (pbSignature)
    {
        free(pbSignature);
    }
    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: NegativeVerifySignatureTests
// Purpose: Run the negative test cases for CryptVerifySignature
//
BOOL NegativeVerifySignatureTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    HCRYPTPROV hProv            = 0;
    HCRYPTKEY hKey              = 0;
    HCRYPTHASH hHash            = 0;
    //DWORD dw                  = 0;
    DWORD cb                    = 0;
    PBYTE pb                    = NULL; 
    PTESTCASE ptc               = &(pCSPInfo->TestCase);

    //
    // Group 5H
    //

    //
    // Do CryptVerifySignature negative test cases
    //

    // Create new context with key container access
    LOG_TRY(CreateNewContext(&hProv, pwszContainer, CRYPT_NEWKEYSET, ptc));

    // Create new signature key pair
    LOG_TRY(CreateNewKey(hProv, AT_SIGNATURE, 0, &hKey, ptc));

    // Create new hash
    LOG_TRY(CreateNewHash(hProv, CALG_SHA1, &hHash, ptc));

    // Sign the hash
    ptc->fExpectSuccess = TRUE;
    LOG_TRY(TSignHash(hHash, AT_SIGNATURE, NULL, 0, NULL, &cb, ptc));

    LOG_TRY(TestAlloc(&pb, cb, ptc));

    LOG_TRY(TSignHash(hHash, AT_SIGNATURE, NULL, 0, pb, &cb, ptc));
    ptc->fExpectSuccess = FALSE;

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TVerifySign(0, pb, cb, hKey, NULL, 0, ptc));

    ptc->dwErrorCode = ERROR_INVALID_HANDLE;
    LOG_TRY(TVerifySign(TEST_INVALID_HANDLE, pb, cb, hKey, NULL, 0, ptc));

    ptc->dwErrorCode = ERROR_INVALID_PARAMETER;
    LOG_TRY(TVerifySign(hHash, NULL, cb, hKey, NULL, 0, ptc));

    ptc->dwErrorCode = NTE_BAD_FLAGS;
    LOG_TRY(TVerifySign(hHash, pb, cb, hKey, NULL, TEST_INVALID_FLAG, ptc));

    // Use invalid signature key handle
    ptc->dwErrorCode = NTE_BAD_KEY;
    LOG_TRY(TVerifySign(hHash, pb, cb, TEST_INVALID_HANDLE, NULL, 0, ptc));

    // Indicate a too-short buffer length
    ptc->dwErrorCode = NTE_BAD_SIGNATURE;
    LOG_TRY(TVerifySign(hHash, pb, cb - 1, hKey, NULL, 0, ptc));

    // Flip the bits in the last byte of the signature blob
    pb[cb - 1] = ~(pb[cb - 1]);

    ptc->dwErrorCode = NTE_BAD_SIGNATURE;
    LOG_TRY(TVerifySign(hHash, pb, cb, hKey, NULL, 0, ptc));

    /*
    // Release the context used to create hHash
    LOG_TRY(TRelease(hProv, 0, ptc));
    hProv = 0;

    // Provider handle used to create hHash is now invalid
    ptc->dwErrorCode = NTE_BAD_UID;
    LOG_TRY(TVerifySign(hHash, pb, cb, hKey, NULL, 0, ptc));
    */

    fSuccess = TRUE;

Cleanup:

    if (hHash)
    {
        TDestroyHash(hHash, ptc);
    }
    if (hKey)
    {
        TDestroyKey(hKey, ptc);
    }
    if (hProv)
    {
        TRelease(hProv, 0, ptc);
    }
    if (pb)
    {
        free(pb);
    }

    return fSuccess;
}

//
// Function: TestKeyExchangeProc
// Purpose: Simulate a key/data exchange scenario for the specified
// encryption alg.
//
BOOL TestKeyExchangeProc(
        PALGNODE pAlgNode,
        PTESTCASE ptc,
        PVOID pvExchangeProcInfo)
{
    BOOL fSuccess                       = FALSE;
    PEXCHANGE_PROC_INFO pExchangeProcInfo = (PEXCHANGE_PROC_INFO) pvExchangeProcInfo;
    KEYEXCHANGE_INFO KeyExchangeInfo;
    KEYEXCHANGE_STATE KeyExchangeState;

    memset(&KeyExchangeInfo, 0, sizeof(KeyExchangeInfo));
    memset(&KeyExchangeState, 0, sizeof(KeyExchangeState));

    KeyExchangeInfo.aiHash = pExchangeProcInfo->aiHashAlg;
    KeyExchangeInfo.aiSessionKey = pAlgNode->ProvEnumalgsEx.aiAlgid;
    KeyExchangeInfo.dbPlainText.pbData = pExchangeProcInfo->dbPlainText.pbData;
    KeyExchangeInfo.dbPlainText.cbData = pExchangeProcInfo->dbPlainText.cbData;
    KeyExchangeInfo.dwPubKeySize = pExchangeProcInfo->dwPublicKeySize;

    LOG_TRY(RSA1_CreateKeyPair(
        pExchangeProcInfo->hProv,
        &KeyExchangeInfo,
        &KeyExchangeState,
        ptc));

    LOG_TRY(RSA2_EncryptPlainText(
        pExchangeProcInfo->hInteropProv,
        &KeyExchangeInfo,
        &KeyExchangeState,
        ptc));

    LOG_TRY(RSA3_DecryptAndCheck(
        pExchangeProcInfo->hProv,
        &KeyExchangeInfo,
        &KeyExchangeState,
        ptc));

    fSuccess = TRUE;

Cleanup:

    return fSuccess;
}

//
// Function: InteropKeyExchangeTests
// Purpose: Run the TestKeyExchangeProc for each encryption algorithm
// supported by this CSP.  Cryptographic context A will be from the CSP
// under test.  Context B will be from the interop context specified
// by the user.
//
BOOL InteropKeyExchangeTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    LPWSTR pwszInteropContainer = TEST_CONTAINER_2;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    PALGNODE pAlgList           = pCSPInfo->pAlgList;
    EXCHANGE_PROC_INFO ExchangeProcInfo;

    memset(&ExchangeProcInfo, 0, sizeof(ExchangeProcInfo));

    LOG_TRY(CreateNewContext(
        &(ExchangeProcInfo.hProv),
        pwszContainer,
        CRYPT_NEWKEYSET,
        ptc));

    LOG_TRY(CreateNewInteropContext(
        &(ExchangeProcInfo.hInteropProv),
        pwszInteropContainer,
        CRYPT_NEWKEYSET,
        ptc));

    //
    // Note: Using the following hard-coded information for this
    // test.  
    //
    ExchangeProcInfo.aiHashAlg = CALG_SHA1;
    ExchangeProcInfo.dbPlainText.cbData = wcslen(TEST_HASH_DATA) * sizeof(WCHAR);

    LOG_TRY(TestAlloc(
        &(ExchangeProcInfo.dbPlainText.pbData),
        ExchangeProcInfo.dbPlainText.cbData,
        ptc));

    memcpy(
        ExchangeProcInfo.dbPlainText.pbData,
        TEST_DECRYPT_DATA,
        ExchangeProcInfo.dbPlainText.cbData);

    LOG_TRY(AlgListIterate(
        pAlgList,
        DataEncryptFilter,
        TestKeyExchangeProc,
        (PVOID) &ExchangeProcInfo,
        ptc));

    fSuccess = TRUE;

Cleanup:

    if (ExchangeProcInfo.dbPlainText.pbData)
    {
        free(ExchangeProcInfo.dbPlainText.pbData);
    }
    if (ExchangeProcInfo.hProv)
    {
        TRelease(ExchangeProcInfo.hProv, 0, ptc);
    }
    if (ExchangeProcInfo.hInteropProv)
    {
        TRelease(ExchangeProcInfo.hInteropProv, 0, ptc);
    }

    return fSuccess;
}   

//
// Function: ScenarioKeyExchangeTests
// Purpose: Run the TestKeyExchangeProc for each encryption algorithm
// supported by this CSP.  Both of the cryptographic contexts in the 
// scenario will be from the CSP under test.
//
BOOL ScenarioKeyExchangeTests(PCSPINFO pCSPInfo)
{
    BOOL fSuccess               = FALSE;
    LPWSTR pwszContainer        = TEST_CONTAINER;
    LPWSTR pwszContainer2       = TEST_CONTAINER_2;
    PTESTCASE ptc               = &(pCSPInfo->TestCase);
    PALGNODE pAlgList           = pCSPInfo->pAlgList;
    EXCHANGE_PROC_INFO ExchangeProcInfo;

    memset(&ExchangeProcInfo, 0, sizeof(ExchangeProcInfo));

    LOG_TRY(CreateNewContext(
        &(ExchangeProcInfo.hProv),
        pwszContainer,
        CRYPT_NEWKEYSET,
        ptc));

    LOG_TRY(CreateNewContext(
        &(ExchangeProcInfo.hInteropProv),
        pwszContainer2,
        CRYPT_NEWKEYSET,
        ptc));

    //
    // Note: Using the following hard-coded information for this
    // test.  
    //
    ExchangeProcInfo.aiHashAlg = CALG_SHA1;
    ExchangeProcInfo.dbPlainText.cbData = wcslen(TEST_HASH_DATA) * sizeof(WCHAR);

    LOG_TRY(TestAlloc(
        &(ExchangeProcInfo.dbPlainText.pbData),
        ExchangeProcInfo.dbPlainText.cbData,
        ptc));

    memcpy(
        ExchangeProcInfo.dbPlainText.pbData,
        (PVOID) TEST_DECRYPT_DATA,
        ExchangeProcInfo.dbPlainText.cbData);

    LOG_TRY(AlgListIterate(
        pAlgList,
        DataEncryptFilter,
        TestKeyExchangeProc,
        (PVOID) &ExchangeProcInfo,
        ptc));

    fSuccess = TRUE;

Cleanup:

    if (ExchangeProcInfo.dbPlainText.pbData)
    {
        free(ExchangeProcInfo.dbPlainText.pbData);
    }
    if (ExchangeProcInfo.hProv)
    {
        TRelease(ExchangeProcInfo.hProv, 0, ptc);
    }
    if (ExchangeProcInfo.hInteropProv)
    {
        TRelease(ExchangeProcInfo.hInteropProv, 0, ptc);
    }

    return fSuccess;
}

//
// Function: GetKnownErrorValue
//
DWORD GetKnownErrorValue(
        IN KNOWN_ERROR_ID KnownErrorID,
        IN DWORD dwCurrentErrorLevel)
{
    DWORD dwActualErrorLevel            = dwCurrentErrorLevel;
    int iErrorTable                     = 0;

    //
    // Search the g_KnownErrorTable for KnownErrorID
    //
    for (
        iErrorTable = 0; 
        iErrorTable < (sizeof(g_KnownErrorTable) / sizeof(KNOWN_ERROR_INFO)); 
        iErrorTable++)
    {
        if (KnownErrorID == g_KnownErrorTable[iErrorTable].KnownErrorID)
        {
            //
            // This is a known error.  Get the error level that should be 
            // applied.
            //
            dwActualErrorLevel = g_KnownErrorTable[iErrorTable].dwErrorLevel;

            //
            // Check the version information for this error
            //
            if (! IsVersionCorrect(
                    g_KnownErrorTable[iErrorTable].dwMajorVersion,
                    g_KnownErrorTable[iErrorTable].dwMinorVersion,
                    g_KnownErrorTable[iErrorTable].dwServicePackMajor,
                    g_KnownErrorTable[iErrorTable].dwServicePackMinor))
            {
                //
                // This error is old.  Increase the error level.
                //
                dwActualErrorLevel = IncrementErrorLevel(dwActualErrorLevel);
            }
        }
    }

    return dwActualErrorLevel;
}

//
// Function: IsAPIRelevant
// Purpose: Determine if the test case supplied in the pTableEntry parameter
// is appropriate for the supplied dwCSPClass and dwTestLevel.
//
BOOL IsAPIRelevant(
        IN DWORD dwCSPClass, 
        IN DWORD dwTestLevel, 
        IN DWORD dwTestType,
        IN PTESTTABLEENTRY pTableEntry)
{
    DWORD dwAPITestLevels = 0;

    switch (dwCSPClass)
    {
    case CLASS_SIG_ONLY:
        {
            dwAPITestLevels = pTableEntry->dwClassSigOnly;
            break;
        }
    case CLASS_SIG_KEYX:
        {
            dwAPITestLevels = pTableEntry->dwClassSigKeyX;
            break;
        }
    case CLASS_FULL:
        {
            dwAPITestLevels = pTableEntry->dwClassFull;
            break;
        }
    case CLASS_OPTIONAL:
        {
            dwAPITestLevels = pTableEntry->dwClassOptional;
            break;
        }
    default:
        {
            return FALSE;
        }
    }

    if ((dwTestType == pTableEntry->dwTestType) &&
        (dwAPITestLevels & dwTestLevel))
    {
        return TRUE;
    }

    return FALSE;
}

//
// Function: InitTestCase
// Purpose: Initialize a TESTCASE structure with the most typical default 
// values.
//
void InitTestCase(PTESTCASE pTestCase)
{
    //
    // Initialize the TESTCASE structure for this API test
    //
    memset(pTestCase, 0, sizeof(TESTCASE));
    
    //
    // For now, set a low-enough error level so that the test will 
    // continue after most failed test cases.
    //
    // The pTestCase->dwErrorLevel is where most of the control of the flow of the
    // test (with respect to error handling) is afforded.  The flags used here should
    // be a function of the environment in which the test is being run, and should
    // be optionally controllable by command-line.
    //
    pTestCase->dwErrorLevel = CSP_ERROR_CONTINUE;
    pTestCase->KnownErrorID = KNOWN_ERROR_UNKNOWN;
}

//
// Function: RunTestsByClassAndLevel
// Purpose: For a given CSP Class and Test Level, run the appropriate set
// of API tests, per the test mappings in the 
// g_TestFunctionMappings table.
//
BOOL RunTestsByClassAndLevel(
        IN DWORD dwCSPClass, 
        IN DWORD dwTestLevel, 
        IN DWORD dwTestType,
        PCSPINFO pCspInfo)
{
    BOOL fErrorOccurred         = FALSE;
    int iAPI                    = 0;

    //
    // For each (CSP_CLASS, TEST_LEVEL) combination, run through 
    // each of the entries in the test table above.
    //
    for (   
        iAPI = 0; 
        iAPI < (sizeof(g_TestFunctionMappings) / sizeof(TESTTABLEENTRY));
        ++iAPI)
    {
        //
        // Determine if the current TESTTABLEENTRY in TestFunctionMappings is
        // applicable for the current (dwCSPClass, dwTestLevel) combination.
        //
        if (IsAPIRelevant(
                dwCSPClass, 
                dwTestLevel,
                dwTestType,
                &(g_TestFunctionMappings[iAPI])))
        {
            if (LogBeginAPI(
                g_TestFunctionMappings[iAPI].ApiName, 
                dwTestType))
            {
                //
                // Initialize the test TESTCASE member of the CSPINFO struct
                // to typical values.
                //
                InitTestCase(&(pCspInfo->TestCase));
                
                pCspInfo->TestCase.dwTestLevel = dwTestLevel;
                pCspInfo->TestCase.dwCSPClass = dwCSPClass;
                pCspInfo->TestCase.fSmartCardCSP = pCspInfo->fSmartCardCSP;
                
                if (TEST_CASES_POSITIVE == dwTestType)
                {
                    pCspInfo->TestCase.fExpectSuccess = TRUE;
                }
                
                //
                // Run the current test case
                //
                if (! (*(g_TestFunctionMappings[iAPI].pTestFunc))(pCspInfo))
                {
                    fErrorOccurred = TRUE;
                }
                
                LogEndAPI(
                    g_TestFunctionMappings[iAPI].ApiName, 
                    dwTestType);
            }
        }
    }

    return ! fErrorOccurred;
}

//
// Function: RunStandardTests
// Purpose: Iterate through the [CSP_CLASS, TEST_LEVEL] combinations for each
// test listed in the g_TestFunctionMappings table.
//
BOOL RunStandardTests(
        IN DWORD dwTargetCSPClass, 
        IN DWORD dwTestType,
        PCSPINFO pCspInfo)
{
    BOOL fErrorOccurred             = FALSE;
    DWORD dwCSPClass                = 0;
    DWORD dwTestLevel               = 0;
    int iCSPClass                   = 0;
    int iTestLevel                  = 0;
    
    dwCSPClass = g_rgCspClasses[iCSPClass];

    //
    // Run through each possible CSP_CLASS but stop after the CSP_CLASS
    // specified by the dwTargetCSPClass parameter.
    //
    while ( LogBeginCSPClass(dwCSPClass))
    {
        //
        // Run through each TEST_LEVEL for the current CSP_CLASS
        //
        for (   iTestLevel = 0;
                iTestLevel < (sizeof(g_rgTestLevels) / sizeof(dwTestLevel));
                ++iTestLevel)
        {
            dwTestLevel = g_rgTestLevels[iTestLevel];

            if (LogBeginTestLevel(dwTestLevel))
            {
                if (! RunTestsByClassAndLevel(
                        dwCSPClass,
                        dwTestLevel,
                        dwTestType,
                        pCspInfo))
                {
                    fErrorOccurred = TRUE;
                }
                
                LogEndTestLevel(dwTestLevel);
            }           
        }

        LogEndCSPClass(dwCSPClass);

        if (dwCSPClass == dwTargetCSPClass)
        {
            break;
        }
        else
        {
            iCSPClass++;
            dwCSPClass = g_rgCspClasses[iCSPClass];
        }
    }   

    return ! fErrorOccurred;
}

//
// Function: RunPositiveTests
// Purpose: Run all of the positive test cases for a CSP of the 
// specified class.
//
BOOL RunPositiveTests(DWORD dwTargetCSPClass, PCSPINFO pCSPInfo)
{
    return RunStandardTests(dwTargetCSPClass, TEST_CASES_POSITIVE, pCSPInfo);
}

//
// Function: RunNegativeTests
// Purpose: Run all of the negative test cases for a CSP of the 
// specified class.
//
BOOL RunNegativeTests(DWORD dwTargetCSPClass, PCSPINFO pCSPInfo)
{
    return RunStandardTests(dwTargetCSPClass, TEST_CASES_NEGATIVE, pCSPInfo);
}

//
// Function: RunScenarioTests
// Purpose: Run all of the CSP Test Suite Scenario tests.
//
BOOL RunScenarioTests(PCSPINFO pCSPInfo)
{
    BOOL fErrorOccurred             = FALSE;
    int iScenarioTable              = 0;
    
    for (
        iScenarioTable = 0;
        iScenarioTable < (sizeof(g_ScenarioTestTable) / sizeof(BASIC_TEST_TABLE));
        iScenarioTable++)
    {
        InitTestCase(&(pCSPInfo->TestCase));
        pCSPInfo->TestCase.fExpectSuccess = TRUE;
        pCSPInfo->TestCase.dwErrorLevel = CSP_ERROR_API;

        LogBeginScenarioTest(g_ScenarioTestTable[iScenarioTable].pwszDescription);

        //
        // Run the current test case
        //
        if (! (*(g_ScenarioTestTable[iScenarioTable].pTestFunc))(pCSPInfo))
        {
            fErrorOccurred = TRUE;
        }

        LogEndScenarioTest();
    }   

    return ! fErrorOccurred;
}

//
// Function: RunInteropTests
// Purpose: Run all of the CSP Test Suite Interoperability tests.
//
BOOL RunInteropTests(PCSPINFO pCSPInfo)
{
    BOOL fErrorOccurred             = FALSE;
    int iInteropTable               = 0;

    for (
        iInteropTable = 0;
        iInteropTable < (sizeof(g_InteropTestTable) / sizeof(BASIC_TEST_TABLE));
        iInteropTable++)
    {
        InitTestCase(&(pCSPInfo->TestCase));
        pCSPInfo->TestCase.fExpectSuccess = TRUE;
        pCSPInfo->TestCase.dwErrorLevel = CSP_ERROR_API;

        LogBeginInteropTest(g_InteropTestTable[iInteropTable].pwszDescription);

        //
        // Run the current test case
        //
        if (! (*(g_InteropTestTable[iInteropTable].pTestFunc))(pCSPInfo))
        {
            fErrorOccurred = TRUE;
        }

        LogEndInteropTest();
    }   

    return ! fErrorOccurred;
}

//
// Function: CleanupCspInfo
// Purpose: Perform any cleanup or memory-freeing necessary for the 
// CSPINFO struct.
//
void CleanupCspInfo(PCSPINFO pCSPInfo)
{
    PALGNODE pAlgNode = NULL;

    if (pCSPInfo->pwszCSPName)
    {
        free(pCSPInfo->pwszCSPName);
    }
    
    //
    // Free the linked ALGNODE list
    //
    while (pCSPInfo->pAlgList)
    {
        pAlgNode = pCSPInfo->pAlgList->pAlgNodeNext;
        free(pCSPInfo->pAlgList);
        pCSPInfo->pAlgList = pAlgNode;
    }
}

//
// Function: GetProviderType
// Purpose: Given the name of the CSP under test, call CryptEnumProviders
// until that CSP is found.  Return the type for that CSP to the caller.
//
BOOL GetProviderType(
        IN LPWSTR pwszProvName,
        OUT PDWORD pdwProvType)
{
    WCHAR rgProvName [MAX_PATH * sizeof(WCHAR)];
    DWORD cb = sizeof(rgProvName);
    DWORD dwIndex = 0;

    memset(rgProvName, 0, sizeof(rgProvName));

    while (CryptEnumProviders(
            dwIndex,
            NULL,
            0,
            pdwProvType,
            rgProvName,
            &cb))
    {
        if (0 == wcscmp(rgProvName, pwszProvName))
        {
            return TRUE;
        }
        else
        {
            dwIndex++;
            cb = sizeof(rgProvName);
        }
    }

    return FALSE;
}

//
// Function: DeleteDefaultContainer
// Purpose: Delete the default key container for the CSP
// under test.
//
BOOL DeleteDefaultContainer(PCSPINFO pCSPInfo)
{
    HCRYPTPROV hProv = 0;

    return CryptAcquireContext(
        &hProv,
        NULL,
        pCSPInfo->pwszCSPName,
        pCSPInfo->dwExternalProvType,
        CRYPT_DELETEKEYSET);
}

//
// Function: DeleteAllContainers
// Purpose: Delete all key containers for the CSP
// under test.
//
BOOL DeleteAllContainers(PCSPINFO pCSPInfo)
{
    HCRYPTPROV hDefProv                 = 0;
    HCRYPTPROV hProv                    = 0;
    CHAR rgszContainer[MAX_PATH];
    LPWSTR pwszContainer                = NULL;
    DWORD cbContainer                   = MAX_PATH;
    BOOL fCreatedDefaultKeyset          = FALSE;
    DWORD dwFlags                       = CRYPT_FIRST;

    if (! CryptAcquireContext(
        &hDefProv, NULL, pCSPInfo->pwszCSPName, 
        pCSPInfo->dwExternalProvType, 0))
    {
        return FALSE;
    }

    while (CryptGetProvParam(
        hDefProv, PP_ENUMCONTAINERS, (PBYTE) rgszContainer,
        &cbContainer, dwFlags))
    {
        if (dwFlags)
        {
            dwFlags = 0;
        }

        pwszContainer = MkWStr(rgszContainer);

        if (! CryptAcquireContext(
            &hProv, pwszContainer, pCSPInfo->pwszCSPName,
            pCSPInfo->dwExternalProvType, CRYPT_DELETEKEYSET))
        {
            return FALSE;
        }

        cbContainer = sizeof(rgszContainer);
        free(pwszContainer);
    }                                       

    if (! CryptReleaseContext(hDefProv, 0))
    {
        return FALSE;
    }
    
    return TRUE;   
}

//
// Function: main
// Purpose: Test entry function
//
int __cdecl wmain(int argc, WCHAR *wargv[])
{
    BOOL fInvalidArgs                   = FALSE;
    int iCspTypeTable                   = 0;
    DWORD dwTestsToRun                  = TEST_CASES_POSITIVE;
    BOOL fDeleteDefaultContainer        = FALSE;
    int iCsp                            = 0;
    DWORD dwProvType                    = 0;
    DWORD cbCspName                     = 0;
    DWORD dwError                       = 0;
    WCHAR rgwszCsp[ MAX_PATH ];
    WCHAR rgwszOption[ MAX_PATH ];
    WCHAR rgwsz[BUFFER_SIZE];
    CSPINFO CspInfo;
    LOGINIT_INFO LogInitInfo;
    BOOL fDeleteAllContainers           = FALSE;

    memset(&CspInfo, 0, sizeof(CspInfo));
    memset(&LogInitInfo, 0, sizeof(LogInitInfo));

    if (argc < MINIMUM_ARGC)
    {
        fInvalidArgs = TRUE;
        goto Ret;
    }

    argc--;
    wargv++;
    while (argc)
    {
        if (L'-' != wargv[0][0])
        {
            fInvalidArgs = TRUE;
            goto Ret;
        }

        switch (wargv[0][1])
        {
            case L't':
            {
                // Assign which test to run
                --argc;
                ++wargv;
                dwTestsToRun = _wtoi(*wargv);
                break;
            }
            case L'c':
            {
                // Assign CSP Name
                --argc;
                ++wargv;

                cbCspName = 0;
                GetNextRegisteredCSP(
                    NULL, 
                    &cbCspName, 
                    &(CspInfo.dwExternalProvType), 
                    _wtoi(*wargv));

                if (NULL == (CspInfo.pwszCSPName = (LPWSTR) malloc(cbCspName)))
                {
                    wprintf(L"Insufficient memory\n");
                    goto Ret;
                }

                dwError = GetNextRegisteredCSP(
                    CspInfo.pwszCSPName, 
                    &cbCspName,
                    &(CspInfo.dwExternalProvType),
                    _wtoi(*wargv));

                if (ERROR_SUCCESS != dwError)
                {
                    fInvalidArgs = TRUE;
                    goto Ret;
                }
                break;
            }
            case L'i':
            {
                // Assign interop CSP name
                --argc;
                ++wargv;
                
                cbCspName = 0;
                GetNextRegisteredCSP(
                    NULL, 
                    &cbCspName, 
                    &(LogInitInfo.dwInteropCSPExternalType), 
                    _wtoi(*wargv));

                if (NULL == (LogInitInfo.pwszInteropCSPName = (LPWSTR) malloc(cbCspName)))
                {
                    wprintf(L"Insufficient memory\n");
                    goto Ret;
                }

                dwError = GetNextRegisteredCSP(
                    LogInitInfo.pwszInteropCSPName, 
                    &cbCspName,
                    &(LogInitInfo.dwInteropCSPExternalType),
                    _wtoi(*wargv));

                if (ERROR_SUCCESS != dwError)
                {
                    fInvalidArgs = TRUE;
                    goto Ret;
                }
                break;
            }

            case L'd':
            {
                // Option to delete the default container
                fDeleteDefaultContainer = TRUE;
                break;
            }

            case L'a':
            {
                // Option to delete all containers
                fDeleteAllContainers = TRUE;
                break;
            }

            default:
            {
                fInvalidArgs = TRUE;
                goto Ret;
            }
        }

        argc--;
        wargv++;
    }

    if (    (0 != argc) ||
            (NULL == CspInfo.pwszCSPName))
    {
        // Bad combination of args
        fInvalidArgs = TRUE;
        goto Ret;
    }

    //
    // If no interop CSP was specified, look for a default
    //
    if (    TEST_CASES_INTEROP == dwTestsToRun &&
            NULL == LogInitInfo.pwszInteropCSPName)
    {
        if (! CryptGetDefaultProvider(
            CspInfo.dwExternalProvType,
            NULL,
            CRYPT_MACHINE_DEFAULT,
            NULL,
            &cbCspName))
        {
            printf("No default interop provider found for this CSP type\n");
            fInvalidArgs = TRUE;
            goto Ret;
        }

        if (NULL == (LogInitInfo.pwszInteropCSPName = (LPWSTR) malloc(cbCspName)))
        {
            wprintf(L"Insufficient memory\n");
            goto Ret;
        }

        if (! CryptGetDefaultProvider(
            CspInfo.dwExternalProvType,
            NULL,
            CRYPT_MACHINE_DEFAULT,
            LogInitInfo.pwszInteropCSPName,
            &cbCspName))
        {
            printf("No default interop provider found for this CSP type\n");
            fInvalidArgs = TRUE;
            goto Ret;
        }
        LogInitInfo.dwInteropCSPExternalType = CspInfo.dwExternalProvType;
    }

    //
    // Search for an entry for the external CSP type in the test suite
    // CspTypeTable.  The table provides mappings from external types to 
    // internal types used by the test.
    //
    while ( iCspTypeTable < (sizeof(g_CspTypeTable) / sizeof(CSPTYPEMAP)) &&
            g_CspTypeTable[iCspTypeTable].dwExternalProvType != CspInfo.dwExternalProvType)
    {
        iCspTypeTable++;
    }
                
    //
    // Check that the CSP type was found in the g_CspTypeTable
    //
    if (iCspTypeTable == (sizeof(g_CspTypeTable) / sizeof(CSPTYPEMAP)))
    {
        fInvalidArgs = TRUE;
        goto Ret;
    }

    CspInfo.dwInternalProvType = g_CspTypeTable[iCspTypeTable].dwProvType;
    CspInfo.dwCSPInternalClass = g_CspTypeTable[iCspTypeTable].dwCSPClass;

    LogInitInfo.dwCSPExternalType = CspInfo.dwExternalProvType;
    LogInitInfo.dwCSPInternalClass = g_CspTypeTable[iCspTypeTable].dwCSPClass;
    LogInitInfo.dwCSPInternalType = g_CspTypeTable[iCspTypeTable].dwProvType;
    LogInitInfo.pwszCSPName = CspInfo.pwszCSPName;

    // Initialize logging routines
    LogInit(&LogInitInfo);

    //
    // Log the settings being used (including command-line
    // options that were specified).
    //
    swprintf(
        rgwszOption, 
        L"CSP under test: %s",
        CspInfo.pwszCSPName);
    LogUserOption(rgwszOption);

    swprintf(
        rgwszOption,
        L"CSP type: %s",
        g_CspTypeTable[iCspTypeTable].pwszExternalProvType);
    LogUserOption(rgwszOption);

    if (TEST_CASES_INTEROP == dwTestsToRun)
    {
        swprintf(
            rgwszOption,
            L"Interop CSP: %s",
            LogInitInfo.pwszInteropCSPName);
        LogUserOption(rgwszOption);
    }

    TestCaseTypeToString(dwTestsToRun, rgwsz);
    swprintf(
        rgwszOption,
        L"Test case set: %s",
        rgwsz);
    LogUserOption(rgwszOption);

    //
    // Delete default container, if requested
    //
    if (fDeleteDefaultContainer)
    {
        LogInfo(L"Deleting default container...");
        if (DeleteDefaultContainer(&CspInfo))
        {
            LogInfo(L"...Success");
        }
        else
        {
            swprintf(
                rgwszOption,
                L"...Failed 0x%x",
                GetLastError());
            LogInfo(rgwszOption);
        }
        LogClose();
        goto Ret;
    }

    //
    // Delete all containers, if requested
    //
    if (fDeleteAllContainers)
    {
        LogInfo(L"Deleting all containers...");
        if (DeleteAllContainers(&CspInfo))
        {
            LogInfo(L"...Success");
        }
        else
        {
            swprintf(
                rgwszOption,
                L"...Failed 0x%x",
                GetLastError());
            LogInfo(rgwszOption);
        }
        LogClose();
        goto Ret;
    }

    //
    // Run the set of tests requested by the user
    //
    switch (dwTestsToRun)
    {
    case TEST_CASES_POSITIVE:
        {
            RunPositiveTests(
                g_CspTypeTable[iCspTypeTable].dwCSPClass, 
                &CspInfo);

            break;
        }
    case TEST_CASES_NEGATIVE:
        {
            RunNegativeTests(
                g_CspTypeTable[iCspTypeTable].dwCSPClass, 
                &CspInfo);

            break;
        }
    case TEST_CASES_SCENARIO:
        {
            RunScenarioTests(&CspInfo);

            break;
        }
    case TEST_CASES_INTEROP:
        {
            RunInteropTests(&CspInfo);

            break;
        }
    }

    LogClose();
Ret:
    CleanupCspInfo(&CspInfo);

    if (LogInitInfo.pwszInteropCSPName)
    {
        free(LogInitInfo.pwszInteropCSPName);
    }

    if (fInvalidArgs)
    {
        Usage();

        wprintf(L"\nRegistered CSP's:\n");

        cbCspName = MAX_PATH;
        for (   iCsp = 0; 
                ERROR_SUCCESS == GetNextRegisteredCSP(
                    rgwszCsp,
                    &cbCspName,
                    &dwProvType,
                    ENUMERATE_REGISTERED_CSP);
                iCsp++)
        {
            wprintf(L" %d: %s, Type %d\n", iCsp, rgwszCsp, dwProvType);
        }
        
        exit(1);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\test\testsuit\cspstruc.h ===
//
// CSPStruc.h
// 
// 7/17/00  dangriff    created
//

#ifndef __CSPSTRUC__H__
#define __CSPSTRUC__H__

#include <windows.h>
#include <wincrypt.h>

#define LOG_TRY(X) { if (! X) { goto Cleanup; } }

typedef enum _KNOWN_ERROR_ID
{
    KNOWN_ERROR_UNKNOWN,
    
    //
    // Positive test cases
    //
    KNOWN_CRYPTGETPROVPARAM_MAC,
    KNOWN_CRYPTGETPROVPARAM_PPNAME,
    KNOWN_CRYPTSETKEYPARAM_EXPORT,
    KNOWN_CRYPTGETKEYPARAM_SALT,
    KNOWN_CRYPTGENKEY_SALTDES,
    
    //
    // Negative test cases
    //
    KNOWN_CRYPTACQUIRECONTEXT_NULLPHPROV,
    KNOWN_CRYPTACQUIRECONTEXT_BADFLAGS,
    KNOWN_ERRORINVALIDHANDLE,
    KNOWN_CRYPTGETPROVPARAM_MOREDATA,
    KNOWN_CRYPTSETPROVPARAM_RNG,
    KNOWN_CRYPTSETPROVPARAM_BADFLAGS,
    KNOWN_CRYPTCREATEHASH_BADKEY,
    KNOWN_CRYPTIMPORTKEY_BADFLAGS,
    KNOWN_CRYPTIMPORTKEY_BADALGID,
    KNOWN_NTEBADKEY,
    KNOWN_NTEBADHASH,
    KNOWN_CRYPTGENKEY_SILENTCONTEXT,

    //
    // Scenario test cases
    //
    KNOWN_TESTDECRYPTPROC_3DES112

} KNOWN_ERROR_ID;

//
// Struct: TESTCASE 
// Purpose: Contains test case state data that is passed to
// the API wrappers for logging and setting result expectation.
//
typedef struct _TESTCASE
{
    DWORD dwErrorLevel;
    DWORD dwTestCaseID;
    KNOWN_ERROR_ID KnownErrorID;
    BOOL fExpectSuccess;
    DWORD dwErrorCode;
    DWORD dwTestLevel;
    DWORD dwCSPClass;
    BOOL fSmartCardCSP;
    
    //
    // If fEnumerating is TRUE, calls to TGetProv will directly return
    // what CryptGetProvParam returned.
    //
    // If fEnumerating is FALSE, TGetProv will return the result
    // of CheckContinueStatus.
    //
    BOOL fEnumerating;

    //
    // If fTestingReleaseContext is TRUE, TRelease will check fExpectSuccess
    // to determine the expected return value of the call to CryptReleaseContext.
    //
    // If fTestingReleaseContext if FALSE, TRelease will always expect 
    // CryptReleaseContext to succeed.  If it doesn't succeed, an error
    // will be logged.
    //
    BOOL fTestingReleaseContext;

    //
    // Use of fTestingDestroyKey is similar to fTestingReleaseContext above.
    //
    BOOL fTestingDestroyKey;

    //
    // Use of fTestingDestroyHash is similar to fTestingReleaseContext above.
    //
    BOOL fTestingDestroyHash;

    //
    // If fTestingUserProtected is FALSE, CreateNewContext will acquire a 
    // CRYPT_SILENT context handle regardless of the dwFlags parameter.
    //
    // If fTestingUserProtected is TRUE, CreateNewContext will not OR in
    // the CRYPT_SILENT flag.
    //
    BOOL fTestingUserProtected;

    //
    // Optional.  If pwszErrorHelp is non-null when a test case fails, the string
    // will be part of the logging output.
    //
    LPWSTR pwszErrorHelp;
} TESTCASE, *PTESTCASE;

//
// Struct: KNOWN_ERROR_INFO
// Purpose: Data regarding a known error in the Microsoft CSP's
//
typedef struct _KNOWN_ERROR_INFO
{
    KNOWN_ERROR_ID KnownErrorID;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwServicePackMajor;
    DWORD dwServicePackMinor;
    DWORD dwErrorLevel;
} KNOWN_ERROR_INFO, *PKNOWN_ERROR_INFO;

//
// Struct: ALGNODE
// Purpose: A list-node structure that stores information about each algorithm
// supported by the CSP under test.  
//
typedef struct _ALGNODE
{
    PROV_ENUMALGS_EX ProvEnumalgsEx;
    BOOL fIsRequiredAlg;
    BOOL fIsKnownAlg;
    struct _ALGNODE *pAlgNodeNext;
} ALGNODE, *PALGNODE;

//
// Struct: CSPINFO
// Purpose: This struct is used to pass data that has been gathered about
// the CSP under test through the testing routines.
// 
typedef struct _CSPINFO 
{
    PALGNODE pAlgList;
    LPWSTR pwszCSPName;
    DWORD dwCSPInternalClass;
    DWORD dwExternalProvType;
    DWORD dwInternalProvType;
    DWORD dwSigKeysizeInc;
    DWORD dwKeyXKeysizeInc;
    DWORD dwKeySpec;
    TESTCASE TestCase;

    //
    // This flag is set to true if the CSP under test is a 
    // Smart Card CSP.
    //
    BOOL fSmartCardCSP;

    //
    // For SmartCard CSP's, this flag will be set to true after the execution
    // of the first CSP entry point that is expected to have resulted in 
    // the user being prompted to enter the card PIN.  For software CSP's
    // this field is ignored.
    //
    BOOL fPinEntered;

} CSPINFO, *PCSPINFO;

typedef BOOL (*PFN_CSPTEST)(PCSPINFO pCspInfo);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\test\testsuit\interop.c ===
/*

  interop.c

  6/23/00	dangriff	created

*/

#include <windows.h>
#include <wincrypt.h>
#include "interop.h"
#include "cspstruc.h"
#include "csptestsuite.h"

//
// Function: IsDataEqual
//
BOOL IsDataEqual(
		IN PDATA_BLOB pdb1,
		IN PDATA_BLOB pdb2,
		IN PTESTCASE ptc)
{
	/*
	LOGFAILINFO LogFailInfo;
	InitFailInfoFromTestCase(ptc, &LogFailInfo);
	*/
	
	if (pdb1->cbData != pdb2->cbData)
	{
		/*
		LogFailInfo.dwErrorType = ERROR_WRONG_SIZE;
		LogFail(&LogFailInfo);
		*/
		LogApiFailure(
			API_DATACOMPARE,
			ERROR_WRONG_SIZE,
			ptc);

		return FALSE;
	}

	if (0 != memcmp(pdb1->pbData, pdb2->pbData, pdb1->cbData))
	{
		/*
		LogFailInfo.dwErrorType = ERROR_BAD_DATA;
		LogFail(&LogFailInfo);
		*/
		LogApiFailure(
			API_DATACOMPARE,
			ERROR_BAD_DATA,
			ptc);

		return FALSE;
	}

	return TRUE;
}

//
// Function: ExportPublicKey
//
BOOL ExportPublicKey(IN HCRYPTKEY hSourceKey, OUT PDATA_BLOB pdbKey, IN PTESTCASE ptc)
{
	BOOL fSuccess = FALSE;
	
	//
	// Export the public key blob from the key handle
	//
	LOG_TRY(TExportKey(
				hSourceKey, 
				0, 
				PUBLICKEYBLOB, 
				0, 
				NULL, 
				&(pdbKey->cbData),
				ptc));

	LOG_TRY(TestAlloc(&(pdbKey->pbData), pdbKey->cbData, ptc));

	LOG_TRY(TExportKey(
				hSourceKey, 
				0, 
				PUBLICKEYBLOB, 
				0, 
				pdbKey->pbData, 
				&(pdbKey->cbData),
				ptc));

	fSuccess = TRUE;
Cleanup:

	return fSuccess;
}

//
// Function: CreateHashAndAddData
//
BOOL CreateHashAndAddData(
		IN HCRYPTPROV hProv,
		OUT HCRYPTHASH *phHash,
		IN PHASH_INFO pHashInfo,
		IN PTESTCASE ptc,
		IN HCRYPTKEY hKey /* should be 0 when not doing MAC or HMAC */,
		IN PHMAC_INFO pHmacInfo /* should be NULL when not doing HMAC */)
{
	BOOL fSuccess = FALSE;

	LOG_TRY(TCreateHash(
				hProv, 
				pHashInfo->aiHash,
				hKey,
				0,
				phHash,
				ptc));

	//
	// This step only applies to the HMAC algorithm.  
	//
	if (	(NULL != pHmacInfo) &&
			(CALG_HMAC == pHashInfo->aiHash))
	{
		LOG_TRY(TSetHash(
					*phHash,
					HP_HMAC_INFO,
					(PBYTE) pHmacInfo,
					0,
					ptc));
	}

	LOG_TRY(THashData(
				*phHash,
				pHashInfo->dbBaseData.pbData,
				pHashInfo->dbBaseData.cbData,
				0,
				ptc));

	fSuccess = TRUE;
Cleanup:

	return fSuccess;
}

//
// Function: ExportPlaintextSessionKey
//
BOOL ExportPlaintextSessionKey(
		IN HCRYPTKEY hKey,
		IN HCRYPTPROV hProv,
		OUT PDATA_BLOB pdbKey,
		IN PTESTCASE ptc)
{
	BOOL fSuccess = FALSE;
	HCRYPTKEY hExchangeKey = 0;

	//
	// First import the private RSA key with 
	// exponent of one.
	//
	LOG_TRY(TImportKey(
				hProv, 
				PrivateKeyWithExponentOfOne, 
				sizeof(PrivateKeyWithExponentOfOne), 
				0, 
				0, 
				&hExchangeKey, 
				ptc));

	//
	// Now export "encrypted" session key
	//
	LOG_TRY(TExportKey(
				hKey,
				hExchangeKey,
				SIMPLEBLOB,
				0,
				NULL,
				&(pdbKey->cbData),
				ptc));

	LOG_TRY(TestAlloc(&(pdbKey->pbData), pdbKey->cbData, ptc));

	LOG_TRY(TExportKey(
				hKey,
				hExchangeKey,
				SIMPLEBLOB,
				0,
				pdbKey->pbData,
				&(pdbKey->cbData),
				ptc));

	fSuccess = TRUE;
Cleanup:

	if (hExchangeKey)
	{
		TDestroyKey(hExchangeKey, ptc);
	}

	return fSuccess;
}

//
// Function: ImportPlaintextSessionKey
//
BOOL ImportPlaintextSessionKey(
		IN PDATA_BLOB pdbKey,
		OUT HCRYPTKEY *phKey,
		IN HCRYPTPROV hProv,
		IN PTESTCASE ptc)
{
	BOOL fSuccess = FALSE;
	HCRYPTKEY hExchangeKey = 0;

	//
	// First import the private RSA key with 
	// exponent of one.
	//
	LOG_TRY(TImportKey(
				hProv, 
				PrivateKeyWithExponentOfOne, 
				sizeof(PrivateKeyWithExponentOfOne), 
				0, 
				0, 
				&hExchangeKey, 
				ptc));

	// 
	// Next import the "encrypted" session key
	//
	LOG_TRY(TImportKey(
				hProv,
				pdbKey->pbData,
				pdbKey->cbData,
				hExchangeKey,
				0,
				phKey,
				ptc));

	fSuccess = TRUE;
Cleanup:

	if (hExchangeKey)
	{
		TDestroyKey(hExchangeKey, ptc);
	}

	return fSuccess;
}

//
// Function: CheckHashedData
//
BOOL CheckHashedData(
		IN PHASH_INFO pHashInfo,
		IN HCRYPTPROV hProv,
		IN PTESTCASE ptc,
		IN PTEST_MAC_INFO pTestMacInfo /* Should be NULL when not using MAC alg */)
{
	HCRYPTKEY hKey			= 0;
	BOOL fSuccess			= FALSE;
	BOOL fUsingMac			= FALSE;
	HCRYPTHASH hHash		= 0;
	DATA_BLOB dbHash;

	memset(&dbHash, 0, sizeof(dbHash));

	if (NULL != pTestMacInfo)
	{
		fUsingMac = TRUE;

		LOG_TRY(ImportPlaintextSessionKey(
			&(pTestMacInfo->dbKey),
			&hKey,
			hProv,
			ptc));
	}

	//
	// Create a new hash object of the specified type
	// and add the requested data.
	//
	LOG_TRY(TCreateHash(
		hProv,
		pHashInfo->aiHash,
		hKey,
		0,
		&hHash,
		ptc));

	if (	fUsingMac && 
			(CALG_HMAC == pHashInfo->aiHash))
	{
		LOG_TRY(TSetHash(
			hHash,
			HP_HMAC_INFO,
			(PBYTE) &(pTestMacInfo->HmacInfo),
			0,
			ptc));
	}			

	LOG_TRY(THashData(
		hHash,
		pHashInfo->dbBaseData.pbData,
		pHashInfo->dbBaseData.cbData,
		0,
		ptc));

	//
	// Get the resulting hash value and compare it to the 
	// expected result.
	//
	LOG_TRY(TGetHash(
		hHash,
		HP_HASHVAL,
		NULL,
		&(dbHash.cbData),
		0,
		ptc));

	LOG_TRY(TestAlloc(&(dbHash.pbData), dbHash.cbData, ptc));

	LOG_TRY(TGetHash(
		hHash,
		HP_HASHVAL,
		dbHash.pbData ,
		&(dbHash.cbData),
		0,
		ptc));

	LOG_TRY(IsDataEqual(
		&dbHash,
		&(pHashInfo->dbHashValue),
		ptc));

	fSuccess = TRUE;
Cleanup:

	if (dbHash.pbData)
	{
		free(dbHash.pbData);
	}
	if (hKey)
	{
		TDestroyKey(hKey, ptc);
	}
	if (hHash)
	{
		TDestroyHash(hHash, ptc);
	}

	return fSuccess;
}

//
// Function: CheckDerivedKey
//
BOOL CheckDerivedKey(
		IN PDERIVED_KEY_INFO pDerivedKeyInfo,
		IN HCRYPTPROV hProv,
		IN PTESTCASE ptc)
{
	BOOL fSuccess				= FALSE;
	HCRYPTKEY hSessionKey		= 0;
	HCRYPTHASH hHash			= 0;
	DWORD cbValidData			= 0;
	DATA_BLOB dbSessionKey;	

	memset(&dbSessionKey, 0, sizeof(dbSessionKey));

	//
	// Create a hash and hash the provided data
	//
	LOG_TRY(CreateHashAndAddData(
		hProv,
		&hHash,
		&(pDerivedKeyInfo->HashInfo),
		ptc, 
		0, NULL));

	// Debugging
	/*
	pDerivedKeyInfo->cbHB = sizeof(pDerivedKeyInfo->rgbHashValB);
	LOG_TRY(CryptGetHashParam(hHash, HP_HASHVAL, pDerivedKeyInfo->rgbHashValB, &(pDerivedKeyInfo->cbHB), 0));
	*/


	//
	// Derive a session key from the resulting hash object
	//
	LOG_TRY(TDeriveKey(
		hProv,
		pDerivedKeyInfo->aiKey,
		hHash,
		CRYPT_EXPORTABLE | (pDerivedKeyInfo->dwKeySize) << 16,
		&hSessionKey,
		ptc));

	// Debug
	/*
	pDerivedKeyInfo->cbCB = 10;
	LOG_TRY(CryptEncrypt(hSessionKey, 0, TRUE, 0, pDerivedKeyInfo->rgbCipherB, &(pDerivedKeyInfo->cbCB), sizeof(pDerivedKeyInfo->rgbCipherA)));
	*/


	//
	// Export the session key in plaintext form
	//
	LOG_TRY(ExportPlaintextSessionKey(hSessionKey, hProv, &dbSessionKey, ptc));

	// Debug
	/*
	PrintBytes(L"SessionA", pDerivedKeyInfo->dbKey.pbData, pDerivedKeyInfo->dbKey.cbData);
	PrintBytes(L"SessionB", dbSessionKey.pbData, dbSessionKey.cbData);	
	*/

	//
	// Fudge the data comparison slightly since the RSA cipher text blob
	// actually contains mostly random padding in this case (having
	// used ExportPlaintextSessionKey(), only the first <key length>
	// bytes of the cipher data are interesting).
	//
	// Therefor, compare the following number of bytes in the blobs.  The 
	// rest of it won't match.
	//
	// sizeof(BLOBHEADER) + sizeof(ALG_ID) + dwKeySize / 8
	//
	cbValidData = sizeof(BLOBHEADER) + sizeof(ALG_ID) + pDerivedKeyInfo->dwKeySize / 8;
	dbSessionKey.cbData = cbValidData;
	pDerivedKeyInfo->dbKey.cbData = cbValidData;

	LOG_TRY(IsDataEqual(
		&dbSessionKey,
		&(pDerivedKeyInfo->dbKey),
		ptc));
	
	fSuccess = TRUE;
Cleanup:

	if (hSessionKey)
	{
		TDestroyKey(hSessionKey, ptc);
	}
	if (hHash)
	{
		TDestroyHash(hHash, ptc);
	}
	if (dbSessionKey.pbData)
	{
		free(dbSessionKey.pbData);
	}

	return fSuccess;
}

//
// Function: CheckSignedData
//
BOOL CheckSignedData(
		IN PSIGNED_DATA_INFO pSignedDataInfo,
		IN HCRYPTPROV hProv,
		IN PTESTCASE ptc)
{
	BOOL fSuccess = FALSE;
	HCRYPTHASH hHash = 0;
	HCRYPTKEY hPubKey = 0;

	//
	// Create a hash and hash the provided data
	//
	if (! CreateHashAndAddData(
			hProv,
			&hHash,
			&(pSignedDataInfo->HashInfo),
			ptc, 
			0, NULL))
	{
		goto Cleanup;
	}

	//
	// Import the public key corresponding to the private key
	// that was used to sign the hashed data.
	//
	LOG_TRY(TImportKey(
				hProv,
				pSignedDataInfo->dbPublicKey.pbData,
				pSignedDataInfo->dbPublicKey.cbData,
				0,
				0,
				&hPubKey,
				ptc));

	LOG_TRY(TVerifySign(
				hHash,
				pSignedDataInfo->dbSignature.pbData,
				pSignedDataInfo->dbSignature.cbData,
				hPubKey,
				NULL,
				0,
				ptc));

	fSuccess = TRUE;
Cleanup:

	if (hHash)
	{
		TDestroyHash(hHash, ptc);
	}
	if (hPubKey)
	{
		TDestroyKey(hPubKey, ptc);
	}

	return fSuccess;
}

//
// Function: PrepareCipherBuffer
// Purpose: Allocate a buffer to receive encrypted data based 
// on the size of the data to encrypt, and based on whether
// the cipher is block or stream.
//
BOOL PrepareCipherBuffer(
		OUT PDATA_BLOB pdbTargetBuffer,
		IN PDATA_BLOB pdbSourceBuffer,
		IN DWORD cbBlockLen,
		IN BOOL fIsBlockCipher,
		IN PTESTCASE ptc)
{
	BOOL fSuccess = FALSE;

	if (fIsBlockCipher)
	{
		//
		// Determine the maximum length of the cipher text for 
		// this block cipher.  The length of the cipher text is 
		// up to block length more than the length of the plaintext.
		//
		pdbTargetBuffer->cbData = 
			pdbSourceBuffer->cbData + cbBlockLen - (pdbSourceBuffer->cbData % cbBlockLen);
	}
	else
	{
		pdbTargetBuffer->cbData = pdbSourceBuffer->cbData;
	}

	LOG_TRY(TestAlloc(
				&(pdbTargetBuffer->pbData),
				pdbTargetBuffer->cbData,
				ptc));

	memcpy(
		pdbTargetBuffer->pbData, 
		pdbSourceBuffer->pbData, 
		pdbSourceBuffer->cbData);

	fSuccess = TRUE;
Cleanup:
	return fSuccess;
}

// 
// Function: DoBlockCipherOperation
// Purpose: Perform the block cipher operation indicated in the Op parameter
// on the data stored in the pdbSource parameter.  The processed data
// will be in pdbTarget.
//
BOOL DoBlockCipherOperation(
		IN HCRYPTKEY hKey,
		OUT PDATA_BLOB pdbTarget,
		IN PDATA_BLOB pdbSource,
		IN DWORD cbBlockLen,
		IN CIPHER_OP Op,
		IN PTESTCASE ptc)
{
	BOOL fSuccess			= FALSE;
	DWORD cbCurrent			= CIPHER_BLOCKS_PER_ROUND * cbBlockLen;
	DWORD cbProcessed		= 0;
	BOOL fFinal				= FALSE;
	DWORD dwKeyAlg			= 0;
	DWORD cb				= 0;

	switch ( Op )
	{
	case OP_Encrypt:
		{
			LOG_TRY(PrepareCipherBuffer(
				pdbTarget,
				pdbSource,
				cbBlockLen,
				TRUE,
				ptc));			

			while (cbCurrent < pdbSource->cbData)
			{
				LOG_TRY(TEncrypt(
					hKey, 
					0, 
					fFinal, 
					0, 
					pdbTarget->pbData + cbProcessed, 
					&cbCurrent, 
					pdbTarget->cbData - cbProcessed,
					ptc));
				
				if (fFinal)
				{
					break;
				}
				
				cbProcessed += cbCurrent;
				
				if ((cbProcessed + cbCurrent) >= pdbSource->cbData)
				{
					cbCurrent = pdbSource->cbData - cbProcessed;
					fFinal = TRUE;
				}
			}

			break;
		}
	case OP_Decrypt:
		{
			//
			// For block decryption, the decrypted data will be no 
			// larger than the cipher text.
			//
			pdbTarget->cbData = pdbSource->cbData;

			LOG_TRY(TestAlloc(
						&(pdbTarget->pbData),
						pdbTarget->cbData,
						ptc));

			memcpy(pdbTarget->pbData, pdbSource->pbData, pdbTarget->cbData);

			//
			// Known 3DES_112 bug in Windows 2000.  Specifying a 112 
			// bit key size, rather than 128 bits, causes the last two
			// bytes of key data to be random.
			//
			cb = sizeof(dwKeyAlg);
			LOG_TRY(TGetKey(
				hKey,
				KP_ALGID,
				(PBYTE) &dwKeyAlg,
				&cb,
				0,
				ptc));

			if (CALG_3DES_112 == dwKeyAlg)
			{
				ptc->KnownErrorID = KNOWN_TESTDECRYPTPROC_3DES112;
				ptc->pwszErrorHelp = L"Inconsistent encryption results when using a 14 byte 3DES_112 key";
			}

			while (cbCurrent < pdbTarget->cbData)
			{
				LOG_TRY(TDecrypt(
							hKey,
							0,
							fFinal,
							0,
							pdbTarget->pbData + cbProcessed,
							&cbCurrent,
							ptc));

				if (fFinal)
				{
					//
					// Set the size of the actual resulting plaintext.
					//
					pdbTarget->cbData = cbProcessed + cbCurrent;
					break;
				}

				cbProcessed += cbCurrent;

				if ((cbProcessed + cbCurrent) >= pdbTarget->cbData)
				{
					cbCurrent = pdbTarget->cbData - cbProcessed;
					fFinal = TRUE;
				}
			}

			ptc->KnownErrorID = KNOWN_ERROR_UNKNOWN;
			ptc->pwszErrorHelp = NULL;

			break;
		}
	}

	fSuccess = TRUE;
Cleanup:

	return fSuccess;
}

//
// Function: DoStreamCipherOperation
// Purpose: Perform the stream cipher operation indicated in the Op parameter
// on the data stored in the pdbSource parameter.  The processed data
// will be in pdbTarget.
//
BOOL DoStreamCipherOperation(
		IN HCRYPTKEY hKey,
		OUT PDATA_BLOB pdbTarget,
		IN PDATA_BLOB pdbSource,
		IN CIPHER_OP Op,
		IN PTESTCASE ptc)
{
	BOOL fSuccess			= FALSE;
	DWORD cbData			= pdbSource->cbData;

	switch ( Op )
	{
	case OP_Encrypt:
		{
			LOG_TRY(PrepareCipherBuffer(
				pdbTarget,
				pdbSource,
				0,
				FALSE,
				ptc));

			LOG_TRY(TEncrypt(
						hKey,
						0,
						TRUE,
						0,
						pdbTarget->pbData,
						&cbData,
						pdbTarget->cbData,
						ptc));

			break;
		}
	case OP_Decrypt:
		{
			pdbTarget->cbData = pdbSource->cbData;

			LOG_TRY(TestAlloc(
						&(pdbTarget->pbData),
						pdbTarget->cbData,
						ptc));

			memcpy(pdbTarget->pbData, pdbSource->pbData, pdbTarget->cbData);

			LOG_TRY(TDecrypt(
						hKey,
						0,
						TRUE,
						0,
						pdbTarget->pbData,
						&cbData,
						ptc));

			break;
		}
	}

	fSuccess = TRUE;
Cleanup:

	return fSuccess;
}

//
// Function: ProcessCipherData
// 
BOOL ProcessCipherData(
		IN HCRYPTPROV hProvA,
		IN OUT PTEST_ENCRYPT_INFO pTestEncryptInfo,
		IN PTESTCASE ptc)
{
	BOOL fSuccess			= FALSE;
	HCRYPTKEY hKey			= 0;
	DWORD cbData			= 0;
	DWORD cbBlockLen		= 0;
	//DWORD cbProcessed		= 0;
	//DWORD cbCurrent			= 0;
	//BOOL fFinal				= FALSE;

	//
	// Create the key
	//
	LOG_TRY(TGenKey(
				hProvA,
				pTestEncryptInfo->aiKeyAlg,
				CRYPT_EXPORTABLE | (pTestEncryptInfo->dwKeySize << 16),
				&hKey,
				ptc));

	//
	// Generate the salt, if requested
	//
	if (pTestEncryptInfo->fUseSalt)
	{
		//
		// Microsoft CSP's have a maximum key + salt length of 
		// 128 bits, but the test will set a long salt value 
		// regardless of the key size to ensure
		// that possible interop issues are exposed.
		//
		LOG_TRY(TestAlloc(
					&(pTestEncryptInfo->dbSalt.pbData),
					DEFAULT_SALT_LEN,
					ptc));
		pTestEncryptInfo->dbSalt.cbData = DEFAULT_SALT_LEN;

		LOG_TRY(TSetKey(
					hKey,
					KP_SALT_EX,
					(PBYTE) &(pTestEncryptInfo->dbSalt),
					0,
					ptc));
	}

	//
	// Set the cipher mode, if requested
	//
	if (pTestEncryptInfo->fSetMode)
	{
		LOG_TRY(TSetKey(
			hKey,
			KP_MODE,
			(PBYTE) &(pTestEncryptInfo->dwMode),
			0,
			ptc));
	}

	//
	// Determine cipher block len, if applicable
	//
	if (ALG_TYPE_BLOCK & pTestEncryptInfo->aiKeyAlg)
	{
		cbData = sizeof(cbBlockLen);
		LOG_TRY(TGetKey(
					hKey,
					KP_BLOCKLEN,
					(PBYTE) &cbBlockLen,
					&cbData,
					0,
					ptc));

		// Block length is returned in bits
		cbBlockLen = cbBlockLen / 8;
		pTestEncryptInfo->cbBlockLen = cbBlockLen;
	}

	//
	// Set the IV, if requested
	//
	// If caller has requested an IV for a stream cipher,
	// these calls may fail.
	//
	if (pTestEncryptInfo->fSetIV)
	{
		//
		// Size of IV must be equal to cipher block length
		//
		LOG_TRY(TestAlloc(
					&(pTestEncryptInfo->pbIV),
					cbBlockLen,
					ptc));
		
		LOG_TRY(TSetKey(
					hKey,
					KP_IV,
					pTestEncryptInfo->pbIV,
					0,
					ptc));
	}

	//
	// Generate the base data
	//
	if (ALG_TYPE_BLOCK & pTestEncryptInfo->aiKeyAlg)
	{
		// 
		// To create a "better" block cipher test scenario,
		// the base data will not be an exact multiple of the 
		// block length.  This will allow an interesting multi-round
		// encryption, with the last round requiring less than a block
		// length of padding.
		//
		// data len = BLOCKS_IN_BASE_DATA * cbBlockLen - 1byte
		//
		pTestEncryptInfo->dbBaseData.cbData = BLOCKS_IN_BASE_DATA * cbBlockLen - 1;
	}
	else
	{
		//
		// Set base data len for a stream cipher
		//
		pTestEncryptInfo->dbBaseData.cbData = STREAM_CIPHER_BASE_DATA_LEN;
	}

	LOG_TRY(TestAlloc(
				&(pTestEncryptInfo->dbBaseData.pbData),
				pTestEncryptInfo->dbBaseData.cbData,
				ptc));

	LOG_TRY(TGenRand(
				hProvA, 
				pTestEncryptInfo->dbBaseData.cbData,
				pTestEncryptInfo->dbBaseData.pbData,
				ptc));

	//
	// Call DoBlockCipherOperation or DoStreamCipherOperation, 
	// depending on the cipher algorithm, to perform the requested
	// operation.
	//
	if (ALG_TYPE_BLOCK & pTestEncryptInfo->aiKeyAlg)
	{
		LOG_TRY(DoBlockCipherOperation(
			hKey,
			&(pTestEncryptInfo->dbProcessedData),
			&(pTestEncryptInfo->dbBaseData),
			cbBlockLen,
			pTestEncryptInfo->Operation,
			ptc));
	}
	else
	{ 
		LOG_TRY(DoStreamCipherOperation(
			hKey,
			&(pTestEncryptInfo->dbProcessedData),
			&(pTestEncryptInfo->dbBaseData),
			pTestEncryptInfo->Operation,
			ptc));
	}

	//
	// Export the session key in plain text
	//
	LOG_TRY(ExportPlaintextSessionKey(
		hKey,
		hProvA,
		&(pTestEncryptInfo->dbKey),
		ptc));

	fSuccess = TRUE;
Cleanup:

	if (hKey)
	{
		TDestroyKey(hKey, ptc);
	}

	return fSuccess;
}

// 
// Function: VerifyCipherData
//
BOOL VerifyCipherData(
		IN HCRYPTPROV hProvB,
		IN PTEST_ENCRYPT_INFO pTestEncryptInfo,
		IN PTESTCASE ptc)
{
	BOOL fSuccess			= FALSE;
	HCRYPTKEY hKey			= 0;
	CIPHER_OP Op;
	DATA_BLOB dbData;

	memset(&dbData, 0, sizeof(dbData));

	//
	// Import the plaintext session key
	//
	LOG_TRY(ImportPlaintextSessionKey(
		&(pTestEncryptInfo->dbKey),
		&hKey,
		hProvB,
		ptc));

	if (pTestEncryptInfo->fUseSalt)
	{
		LOG_TRY(TSetKey(
			hKey,
			KP_SALT_EX,
			(PBYTE) &(pTestEncryptInfo->dbSalt),
			0,
			ptc));
	}

	//
	// Set the salt value, if requested
	//
	if (pTestEncryptInfo->fUseSalt)
	{
		LOG_TRY(TSetKey(
			hKey,
			KP_SALT_EX,
			(PBYTE) &(pTestEncryptInfo->dbSalt),
			0,
			ptc));
	}

	//
	// Set the cipher mode, if requested
	//
	if (pTestEncryptInfo->fSetMode)
	{
		LOG_TRY(TSetKey(
			hKey,
			KP_MODE,
			(PBYTE) &(pTestEncryptInfo->dwMode),
			0,
			ptc));
	}

	//
	// Set the IV, if requested
	//
	if (pTestEncryptInfo->fSetIV)
	{
		LOG_TRY(TSetKey(
			hKey,
			KP_IV,
			pTestEncryptInfo->pbIV,
			0,
			ptc));
	}

	//
	// The verification operation should be the opposite of what
	// the caller initially specified (the opposite of the operation 
	// performed in ProcessCipherData).
	//
	Op = (OP_Encrypt == pTestEncryptInfo->Operation) ? OP_Decrypt : OP_Encrypt;

	//
	// Call DoBlockCipherOperation or DoStreamCipherOperation, 
	// depending on the cipher algorithm, to perform the requested
	// operation.
	//
	if (ALG_TYPE_BLOCK & pTestEncryptInfo->aiKeyAlg)
	{
		LOG_TRY(DoBlockCipherOperation(
			hKey,
			&dbData,
			&(pTestEncryptInfo->dbProcessedData),
			pTestEncryptInfo->cbBlockLen,
			Op,
			ptc));
	}
	else
	{ 
		LOG_TRY(DoStreamCipherOperation(
			hKey,
			&dbData,
			&(pTestEncryptInfo->dbProcessedData),
			Op,
			ptc));
	}

	if (CALG_3DES_112 == pTestEncryptInfo->aiKeyAlg)
	{
		ptc->KnownErrorID = KNOWN_TESTDECRYPTPROC_3DES112;
	}

	LOG_TRY(IsDataEqual(&dbData, &(pTestEncryptInfo->dbBaseData), ptc));

	ptc->KnownErrorID = KNOWN_ERROR_UNKNOWN;

	fSuccess = TRUE;
Cleanup:

	if (hKey)
	{
		TDestroyKey(hKey, ptc);
	}
	if (dbData.pbData)
	{
		free(dbData.pbData);
	}
	if (pTestEncryptInfo->dbBaseData.pbData)
	{
		free(pTestEncryptInfo->dbBaseData.pbData);
	}
	if (pTestEncryptInfo->dbProcessedData.pbData)
	{
		free(pTestEncryptInfo->dbProcessedData.pbData);
	}
	if (pTestEncryptInfo->dbKey.pbData)
	{
		free(pTestEncryptInfo->dbKey.pbData);
	}
	if (pTestEncryptInfo->pbIV)
	{
		free(pTestEncryptInfo->pbIV);
	}
	if (pTestEncryptInfo->dbSalt.pbData)
	{
		free(pTestEncryptInfo->dbSalt.pbData);
	}

	return fSuccess;
}

//
// Function: GetHashVal
// Purpose: Populate a data blob with the hash value from the 
// provided hash handle.
//
BOOL GetHashVal(
		IN HCRYPTHASH hHash,
		OUT PDATA_BLOB pdb,
		IN PTESTCASE ptc)
{
	BOOL fSuccess		= FALSE;

	LOG_TRY(TGetHash(
		hHash,
		HP_HASHVAL,
		NULL,
		&(pdb->cbData),
		0,
		ptc));

	LOG_TRY(TestAlloc(&(pdb->pbData), pdb->cbData, ptc));

	LOG_TRY(TGetHash(
		hHash,
		HP_HASHVAL,
		pdb->pbData,
		&(pdb->cbData),
		0,
		ptc));

	fSuccess = TRUE;
Cleanup:
	return fSuccess;
}

//
// Function: CreateHashedSessionKey
//
BOOL CreateHashedSessionKey(
		IN HCRYPTPROV hProv,
		IN OUT PHASH_SESSION_INFO pHashSessionInfo,
		IN PTESTCASE ptc)
{
	BOOL fSuccess			= FALSE;
	HCRYPTKEY hKey			= 0;
	HCRYPTHASH hHash		= 0;

	LOG_TRY(TGenKey(
		hProv,
		pHashSessionInfo->aiKey,
		CRYPT_EXPORTABLE | (pHashSessionInfo->dwKeySize << 16),
		&hKey,
		ptc));

	LOG_TRY(TCreateHash(
		hProv,
		pHashSessionInfo->aiHash,
		0,
		0,
		&hHash,
		ptc));

	LOG_TRY(THashSession(hHash, hKey, pHashSessionInfo->dwFlags, ptc));

	LOG_TRY(GetHashVal(hHash, &(pHashSessionInfo->dbHash), ptc));

	LOG_TRY(ExportPlaintextSessionKey(
		hKey,
		hProv,
		&(pHashSessionInfo->dbKey),
		ptc));

	fSuccess = TRUE;
Cleanup:

	if (hKey)
	{
		TDestroyKey(hKey, ptc);
	}
	if (hHash)
	{
		TDestroyHash(hHash, ptc);
	}

	return fSuccess;
}

//
// Function: VerifyHashedSessionKey
// Purpose: Import the plaintext session key into a separate CSP.  
// Hash the session key with CryptHashSessionKey.  Verify
// the resulting hash value.
//
BOOL VerifyHashedSessionKey(
		IN HCRYPTPROV hInteropProv,
		IN PHASH_SESSION_INFO pHashSessionInfo,
		IN PTESTCASE ptc)
{
	BOOL fSuccess			= FALSE;
	HCRYPTKEY hKey			= 0;
	HCRYPTHASH hHash		= 0;
	DATA_BLOB dbInteropHash;

	memset(&dbInteropHash, 0, sizeof(dbInteropHash));
	
	LOG_TRY(ImportPlaintextSessionKey(
		&(pHashSessionInfo->dbKey),
		&hKey,
		hInteropProv,
		ptc));

	LOG_TRY(TCreateHash(
		hInteropProv,
		pHashSessionInfo->aiHash,
		0,
		0,
		&hHash,
		ptc));

	LOG_TRY(THashSession(hHash, hKey, pHashSessionInfo->dwFlags, ptc));

	LOG_TRY(GetHashVal(hHash, &dbInteropHash, ptc));

	LOG_TRY(IsDataEqual(&(pHashSessionInfo->dbHash), &dbInteropHash, ptc));

	fSuccess = TRUE;

Cleanup:

	if (hKey)
	{
		TDestroyKey(hKey, ptc);
	}
	if (hHash)
	{
		TDestroyHash(hHash, ptc);
	}
	if (dbInteropHash.pbData)
	{
		free(dbInteropHash.pbData);
	}
	if (pHashSessionInfo->dbHash.pbData)
	{
		free(pHashSessionInfo->dbHash.pbData);
	}
	if (pHashSessionInfo->dbKey.pbData)
	{
		free(pHashSessionInfo->dbKey.pbData);
	}

	return fSuccess;
}

//
// Function: RSA1_CreateKeyPair
//
BOOL RSA1_CreateKeyPair(
		IN HCRYPTPROV hProvA,
		IN PKEYEXCHANGE_INFO pKeyExchangeInfo,
		OUT PKEYEXCHANGE_STATE pKeyExchangeState,
		IN PTESTCASE ptc)
{
	BOOL fSuccess			= FALSE;
	HCRYPTKEY hPubKeyA		= 0;

	//
	// Create an RSA key exchange key pair and export the public 
	// key.
	//
	LOG_TRY(TGenKey(
		hProvA,
		AT_KEYEXCHANGE,
		(pKeyExchangeInfo->dwPubKeySize << 16) | CRYPT_EXPORTABLE,
		&hPubKeyA,
		ptc));

	if (! ExportPublicKey(hPubKeyA, &(pKeyExchangeState->dbPubKeyA), ptc))
	{
		goto Cleanup;
	}

	fSuccess = TRUE;
Cleanup:

	if (hPubKeyA)
	{
		TDestroyKey(hPubKeyA, ptc);
	}

	return fSuccess;
}

//
// Function: RSA2_EncryptPlainText
//
BOOL RSA2_EncryptPlainText(
		IN HCRYPTPROV hProvB,
		IN PKEYEXCHANGE_INFO pKeyExchangeInfo,
		IN OUT PKEYEXCHANGE_STATE pKeyExchangeState,
		IN PTESTCASE ptc)
{
	BOOL fSuccess				= TRUE;
	HCRYPTKEY hSessionKeyB		= 0;
	HCRYPTKEY hPubKeyB			= 0;
	HCRYPTKEY hPubKeyA			= 0;
	HCRYPTHASH hHash			= 0;
	//DWORD cbBuffer				= 0;
	DWORD cbData				= 0;
	
	//
	// User B creates an RSA signature key pair 
	//
	LOG_TRY(TGenKey(
		hProvB,
		AT_SIGNATURE,
		(pKeyExchangeInfo->dwPubKeySize << 16) | CRYPT_EXPORTABLE,
		&hPubKeyB,
		ptc));
	
	//
	// Create hash and session key
	//
	LOG_TRY(TCreateHash(
		hProvB,
		pKeyExchangeInfo->aiHash,
		0,
		0,
		&hHash,
		ptc));
	
	LOG_TRY(TGenKey(
		hProvB,
		pKeyExchangeInfo->aiSessionKey,
		(pKeyExchangeInfo->dwSessionKeySize << 16) | CRYPT_EXPORTABLE,
		&hSessionKeyB,
		ptc));
	
	//
	// Encrypt and hash the data simultaneously
	//
	cbData = pKeyExchangeState->dbCipherTextB.cbData = pKeyExchangeInfo->dbPlainText.cbData;
	
	LOG_TRY(TEncrypt(
		hSessionKeyB,
		0,
		TRUE,
		0,
		NULL,
		&(pKeyExchangeState->dbCipherTextB.cbData),
		0,
		ptc));
	
	LOG_TRY(TestAlloc(
		&(pKeyExchangeState->dbCipherTextB.pbData), 
		pKeyExchangeState->dbCipherTextB.cbData, 
		ptc));

	memcpy(
		pKeyExchangeState->dbCipherTextB.pbData,
		pKeyExchangeInfo->dbPlainText.pbData,
		cbData);
	
	LOG_TRY(TEncrypt(
		hSessionKeyB,
		hHash,
		TRUE,
		0,
		pKeyExchangeState->dbCipherTextB.pbData,
		&cbData,
		pKeyExchangeState->dbCipherTextB.cbData,
		ptc));
	
	//
	// Now sign the hashed plain text
	//
	LOG_TRY(TSignHash(
		hHash,
		AT_SIGNATURE,
		NULL,
		0,
		NULL,
		&(pKeyExchangeState->dbSignatureB.cbData),
		ptc));
	
	LOG_TRY(TestAlloc(
		&(pKeyExchangeState->dbSignatureB.pbData), 
		pKeyExchangeState->dbSignatureB.cbData, 
		ptc));

	LOG_TRY(TSignHash(
		hHash,
		AT_SIGNATURE,
		NULL,
		0,
		pKeyExchangeState->dbSignatureB.pbData,
		&(pKeyExchangeState->dbSignatureB.cbData),
		ptc));
	
	//
	// Import User A's public key.  Then export User B's session key encrypted 
	// with User A's public key.
	//
	LOG_TRY(TImportKey(
		hProvB,
		pKeyExchangeState->dbPubKeyA.pbData,
		pKeyExchangeState->dbPubKeyA.cbData,
		0,
		0,
		&hPubKeyA,
		ptc));
	
	LOG_TRY(TExportKey(
		hSessionKeyB,
		hPubKeyA,
		SIMPLEBLOB,
		0,
		NULL,
		&(pKeyExchangeState->dbEncryptedSessionKeyB.cbData),
		ptc));
	
	LOG_TRY(TestAlloc(
		&(pKeyExchangeState->dbEncryptedSessionKeyB.pbData), 
		pKeyExchangeState->dbEncryptedSessionKeyB.cbData, 
		ptc));
	
	LOG_TRY(TExportKey(
		hSessionKeyB,
		hPubKeyA,
		SIMPLEBLOB,
		0,
		pKeyExchangeState->dbEncryptedSessionKeyB.pbData,
		&(pKeyExchangeState->dbEncryptedSessionKeyB.cbData),
		ptc));
	
	// 
	// Export User B's public key so that User A can verify the signed data
	//
	if (! ExportPublicKey(hPubKeyB, &(pKeyExchangeState->dbPubKeyB), ptc))
	{
		goto Cleanup;
	}
	
	fSuccess = TRUE;
Cleanup:
	
	if (hSessionKeyB)
	{
		TDestroyKey(hSessionKeyB, ptc);
	}
	if (hPubKeyB)
	{
		TDestroyKey(hPubKeyB, ptc);
	}
	if (hPubKeyA)
	{
		TDestroyKey(hPubKeyA, ptc);
	}
	if (hHash)
	{
		TDestroyHash(hHash, ptc);
	}

	return fSuccess;
}

//
// Function: RSA3_DecryptAndCheck
//
BOOL RSA3_DecryptAndCheck(
		IN HCRYPTPROV hProvA,
		IN PKEYEXCHANGE_INFO pKeyExchangeInfo,
		IN PKEYEXCHANGE_STATE pKeyExchangeState,
		IN PTESTCASE ptc)
{
	BOOL fSuccess				= FALSE;
	HCRYPTKEY hPubKeyA			= 0;
	HCRYPTKEY hPubKeyB			= 0;
	HCRYPTKEY hSessionKey		= 0;
	HCRYPTHASH hHash			= 0;
	
	//
	// Get User A's RSA key exchange key handle
	//
	LOG_TRY(TGetUser(
		hProvA,
		AT_KEYEXCHANGE,
		&hPubKeyA,
		ptc));
	
	// 
	// Import and decrypt the session key from User B
	//
	LOG_TRY(TImportKey(
		hProvA,
		pKeyExchangeState->dbEncryptedSessionKeyB.pbData,
		pKeyExchangeState->dbEncryptedSessionKeyB.cbData,
		hPubKeyA,
		0,
		&hSessionKey,
		ptc));
	
	//
	// Create a hash.  Then simultaneously decrypt the cipher text and 
	// hash the resulting plain text.
	//
	LOG_TRY(TCreateHash(
		hProvA,
		pKeyExchangeInfo->aiHash,
		0,
		0,
		&hHash,
		ptc));
	
	LOG_TRY(TDecrypt(
		hSessionKey,
		hHash,
		TRUE,
		0,
		pKeyExchangeState->dbCipherTextB.pbData,
		&(pKeyExchangeState->dbCipherTextB.cbData),
		ptc));
	
	//
	// Import User B's signature public key.
	//
	LOG_TRY(TImportKey(
		hProvA,
		pKeyExchangeState->dbPubKeyB.pbData,
		pKeyExchangeState->dbPubKeyB.cbData,
		0,
		0,
		&hPubKeyB,
		ptc));
	
	//
	// Verify the signature blob
	//
	LOG_TRY(TVerifySign(
		hHash,
		pKeyExchangeState->dbSignatureB.pbData,
		pKeyExchangeState->dbSignatureB.cbData,
		hPubKeyB,
		NULL,
		0,
		ptc));
	
	fSuccess = TRUE;
Cleanup:
	
	if (hSessionKey)
	{
		TDestroyKey(hSessionKey, ptc);
	}
	if (hPubKeyA)
	{
		TDestroyKey(hPubKeyA, ptc);
	}
	if (hPubKeyB)
	{
		TDestroyKey(hPubKeyB, ptc);
	}
	if (hHash)
	{
		TDestroyHash(hHash, ptc);
	}
	if (pKeyExchangeState->dbCipherTextB.pbData)
	{
		free(pKeyExchangeState->dbCipherTextB.pbData);
	}
	if (pKeyExchangeState->dbPubKeyA.pbData)
	{
		free(pKeyExchangeState->dbPubKeyA.pbData);
	}
	if (pKeyExchangeState->dbPubKeyB.pbData)
	{
		free(pKeyExchangeState->dbPubKeyB.pbData);
	}
	if (pKeyExchangeState->dbSignatureB.pbData)
	{
		free(pKeyExchangeState->dbSignatureB.pbData);
	}
	if (pKeyExchangeState->dbEncryptedSessionKeyB.pbData)
	{
		free(pKeyExchangeState->dbEncryptedSessionKeyB.pbData);
	}

	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\test\testsuit\interop.h ===
#ifndef __INTEROP__H__
#define __INTEROP__H__

#include <windows.h>
#include <wincrypt.h>
#include "csptestsuite.h"

//
// Function: ExportAndImportKey
// Purpose: Export the source key into the provided
// data blob.
//
BOOL ExportPublicKey(
		IN HCRYPTKEY hSourceKey, 
		OUT PDATA_BLOB pdbKey, 
		IN PTESTCASE ptc);

//
// Struct: HASH_INFO
// Purpose: Provide information on the data and algorithm used in 
// a hash context.
//
typedef struct _HASH_INFO
{
	ALG_ID aiHash;
	DATA_BLOB dbBaseData;
	DATA_BLOB dbHashValue;
} HASH_INFO, *PHASH_INFO;

//
// Function: CreateHashAndAddData
// Purpose: Using the provided cryptographic context, create 
// a new hash object of the provided hash algorithm.  Add the
// specified data to the hash.
//
BOOL CreateHashAndAddData(
		IN HCRYPTPROV hProv,
		OUT HCRYPTHASH *phHash,
		IN PHASH_INFO pHashInfo,
		IN PTESTCASE ptc,
		IN HCRYPTKEY hKey,
		IN PHMAC_INFO pHmacInfo);

//
// Function: ExportPlaintextSessionKey
// Purpose: Use RSA private key with exponent of one to export the provided
// session key.  This will cause the key to actually be unencrypted.
//
// Method described in MSDN KB article Q228786 (exporting a plain-text 
// session key).
//
BOOL ExportPlaintextSessionKey(
		IN HCRYPTKEY hKey,
		IN HCRYPTPROV hProv,
		OUT PDATA_BLOB pdbKey,
		IN PTESTCASE ptc);

//
// Function: ImportPlaintextSessionKey
// Purpose: Use an RSA private key with exponent of one to import
// the session key in the provided data blob.  Return the resulting
// key context.
//
BOOL ImportPlaintextSessionKey(
		IN PDATA_BLOB pdbKey,
		OUT HCRYPTKEY *phKey,
		IN HCRYPTPROV hProv,
		IN PTESTCASE ptc);

//
// Struct: MAC_INFO
// Purpose: Provide information on the data used to produce a keyed
// hash value (a MAC).
//
typedef struct TEST_MAC_INFO
{
	//
	// Defined in wincrypt.h
	//
	HMAC_INFO HmacInfo;

	DATA_BLOB dbKey;
} TEST_MAC_INFO, *PTEST_MAC_INFO;

//
// Function: CheckHashedData
// Purpose: Use the provided cryptographic context parameter, hProv,
// to reproduce a hash-value based on provided information.
//
BOOL CheckHashedData(
		IN PHASH_INFO pHashInfo,
		IN HCRYPTPROV hProv,
		IN PTESTCASE ptc,
		IN PTEST_MAC_INFO pTestMacInfo);

//
// Struct: DERIVED_KEY_INFO
// Purpose: Provide information on the procedure used to produce a 
// derived session key.
//
typedef struct _DERIVED_KEY_INFO
{
	HASH_INFO HashInfo;
	ALG_ID aiKey;
	DWORD dwKeySize;
	DATA_BLOB dbKey;

	//
	// Debugging
	//
	BYTE rgbHashValA[1024];
	DWORD cbHA;

	BYTE rgbHashValB[1024];
	DWORD cbHB;

	BYTE rgbCipherA[1024];
	DWORD cbCA;

	BYTE rgbCipherB[1024];
	DWORD cbCB;

} DERIVED_KEY_INFO, *PDERIVED_KEY_INFO;

//
// Function: CheckDerivedKey
// Purpose: Use the provided cryptographic context parameter, hProv, to
// attempt to reproduce a derived session key using information provided
// in the pDerivedKeyInfo struct.  Report any failures using data 
// in the ptc parameter.
//
BOOL CheckDerivedKey(
		IN PDERIVED_KEY_INFO pDerivedKeyInfo,
		IN HCRYPTPROV hProv,
		IN PTESTCASE ptc);

//
// Struct: SIGNED_DATA_INFO
// Purpose: Provide information on the procedure used to produce
// hash-based RSA signature.
//
typedef struct _SIGNED_DATA_INFO
{
	HASH_INFO HashInfo;
	DATA_BLOB dbSignature;
	DATA_BLOB dbPublicKey;
} SIGNED_DATA_INFO, *PSIGNED_DATA_INFO;

//
// Function: CheckSignedData
// Purpose: Use the provided cryptographic context, hProv,
// to reproduce an RSA signature based on information 
// provided in the pSignedDataInfo struct.
//
BOOL CheckSignedData(
		IN PSIGNED_DATA_INFO pSignedDataInfo,
		IN HCRYPTPROV hProv,
		IN PTESTCASE ptc);

//
// ------------------------------------------------------- 
// Defines for testing symmetric Encryption and Decryption
// -------------------------------------------------------
//

#define MAXIMUM_SESSION_KEY_LEN				128
#define DEFAULT_SALT_LEN					64
#define CIPHER_BLOCKS_PER_ROUND				2
#define BLOCKS_IN_BASE_DATA					5
#define STREAM_CIPHER_BASE_DATA_LEN			999

typedef enum _CIPHER_OP
{
	OP_Encrypt,
	OP_Decrypt
} CIPHER_OP;

//
// Struct: TEST_ENCRYPT_INFO
// Purpose: Provide information about the data being used to 
// test data encryption/decryption with a session key.
//
typedef struct _TEST_ENCRYPT_INFO
{
	//
	// These parameters must be set by the caller
	//
	ALG_ID aiKeyAlg;
	DWORD dwKeySize;
	BOOL fUseSalt;
	BOOL fSetIV;
	BOOL fSetMode;
	DWORD dwMode;

	//
	// These parameters are set by the ProcessCipherData
	// function.
	//
	DWORD cbBlockLen;
	DATA_BLOB dbSalt;
	PBYTE pbIV;
	DATA_BLOB dbBaseData;
	DATA_BLOB dbProcessedData;
	DATA_BLOB dbKey;
	CIPHER_OP Operation;
} TEST_ENCRYPT_INFO, *PTEST_ENCRYPT_INFO;

//
// Function: ProcessCipherData
// Purpose: Based on the information provided in the 
// pTestEncryptInfo struct, perform the following steps:
//
// 1) generate a symmetric key of the requested size and alg
// 2) set the appropriate key parameters
// 3) generate some random base data to be processed
// 4) perform the encryption or decryption
// 5) export the key in plaintext
// 
BOOL ProcessCipherData(
		IN HCRYPTPROV hProvA,
		IN OUT PTEST_ENCRYPT_INFO pTestEncryptInfo,
		IN PTESTCASE ptc);

// 
// Function: VerifyCipherData
// Purpose: Verify that the data produced by ProcessCipherData
// can be correctly processed using the opposite cryptographic
// operation with a different CSP.  In other words, if the requested
// operation was Encrypt, verify that the data can be correctly decrypted, etc.
//
BOOL VerifyCipherData(
		IN HCRYPTPROV hProvB,
		IN PTEST_ENCRYPT_INFO pTestEncryptInfo,
		IN PTESTCASE ptc);

//
// ---------------------------------------
// Defines for testing hashed session keys
// ---------------------------------------
//

//
// Struct: HASH_SESSION_INFO
// Purpose: Provide data for creating and hashing a session key of the 
// specified type, and verifying the resulting key using a second
// CSP.
//
typedef struct _HASH_SESSION_INFO
{
	ALG_ID aiKey;
	DWORD dwKeySize;
	ALG_ID aiHash;
	DATA_BLOB dbKey;
	DATA_BLOB dbHash;
	DWORD dwFlags;
} HASH_SESSION_INFO, *PHASH_SESSION_INFO;

//
// Function: CreateHashedSessionKey
// Purpose: Create a session key of the specified size and type.
// Hash the session key with CryptHashSessionKey.  Export the 
// key in plaintext.  Export the hash value.
//
BOOL CreateHashedSessionKey(
		IN HCRYPTPROV hProv,
		IN OUT PHASH_SESSION_INFO pHashSessionInfo,
		IN PTESTCASE ptc);

//
// Function: VerifyHashedSessionKey
// Purpose: Import the plaintext session key into a separate CSP.  
// Hash the session key with CryptHashSessionKey.  Verify
// the resulting hash value.
//
BOOL VerifyHashedSessionKey(
		IN HCRYPTPROV hInteropProv,
		IN PHASH_SESSION_INFO pHashSessionInfo,
		IN PTESTCASE ptc);

//
// ---------------------------------------------
// Defines for testing RSA key exchange scenario
// ---------------------------------------------
//

// 
// Struct: KEYEXCHANGE_INFO
// Purpose: Provide static information used for initiating an RSA
// public key-, session key-, and data-exchange scenario involving two
// users.  
//
typedef struct _KEYEXCHANGE_INFO
{
	DATA_BLOB dbPlainText;
	DWORD dwPubKeySize;
	DWORD dwSessionKeySize;
	ALG_ID aiSessionKey;
	ALG_ID aiHash;
} KEYEXCHANGE_INFO, *PKEYEXCHANGE_INFO;

//
// Struct: KEYEXCHANGE_STATE
// Purpose: Provide state information used to track the progress of an
// RSA key and encrypted data exchange scenario involving two users,
// A and B.
//
typedef struct _KEYEXCHANGE_STATE
{
	DATA_BLOB dbPubKeyA;
	DATA_BLOB dbPubKeyB;
	DATA_BLOB dbEncryptedSessionKeyB;
	DATA_BLOB dbSignatureB;
	DATA_BLOB dbCipherTextB;
} KEYEXCHANGE_STATE, *PKEYEXCHANGE_STATE;

//
// Function: RSA1_CreateKeyPair
// Purpose: The first step of the RSA key exchange scenario.
// User A creates a key pair and exports the public key.
//
BOOL RSA1_CreateKeyPair(
		IN HCRYPTPROV hProvA,
		IN PKEYEXCHANGE_INFO pKeyExchangeInfo,
		OUT PKEYEXCHANGE_STATE pKeyExchangeState,
		IN PTESTCASE ptc);

//
// Function: RSA2_EncryptPlainText
// Purpose: The second step of the RSA key exchange scenario.
// User B first creates a signature key pair and signs 
// the plain text message.  User B then
// creates a session key and encrypts the plain text.
// User A's public key is then used to encrypt the session key.
//
BOOL RSA2_EncryptPlainText(
		IN HCRYPTPROV hProvB,
		IN PKEYEXCHANGE_INFO pKeyExchangeInfo,
		IN OUT PKEYEXCHANGE_STATE pKeyExchangeState,
		IN PTESTCASE ptc);

//
// Function: RSA3_DecryptAndCheck
// Purpose: The third and final step of the RSA key exchange scenario.
// User A decrypts the session key from User B.  User A uses the session 
// key to decrypt the cipher text and uses User B's public key to verify
// the signature.
//
BOOL RSA3_DecryptAndCheck(
		IN HCRYPTPROV hProvA,
		IN PKEYEXCHANGE_INFO pKeyExchangeInfo,
		IN PKEYEXCHANGE_STATE pKeyExchangeState,
		IN PTESTCASE ptc);

// 
// Private key with exponent of one.
// 
static BYTE PrivateKeyWithExponentOfOne[] =
{
   0x07, 0x02, 0x00, 0x00, 0x00, 0xA4, 0x00, 0x00,
   0x52, 0x53, 0x41, 0x32, 0x00, 0x02, 0x00, 0x00,
   0x01, 0x00, 0x00, 0x00, 0xAB, 0xEF, 0xFA, 0xC6,
   0x7D, 0xE8, 0xDE, 0xFB, 0x68, 0x38, 0x09, 0x92,
   0xD9, 0x42, 0x7E, 0x6B, 0x89, 0x9E, 0x21, 0xD7,
   0x52, 0x1C, 0x99, 0x3C, 0x17, 0x48, 0x4E, 0x3A,
   0x44, 0x02, 0xF2, 0xFA, 0x74, 0x57, 0xDA, 0xE4,
   0xD3, 0xC0, 0x35, 0x67, 0xFA, 0x6E, 0xDF, 0x78,
   0x4C, 0x75, 0x35, 0x1C, 0xA0, 0x74, 0x49, 0xE3,
   0x20, 0x13, 0x71, 0x35, 0x65, 0xDF, 0x12, 0x20,
   0xF5, 0xF5, 0xF5, 0xC1, 0xED, 0x5C, 0x91, 0x36,
   0x75, 0xB0, 0xA9, 0x9C, 0x04, 0xDB, 0x0C, 0x8C,
   0xBF, 0x99, 0x75, 0x13, 0x7E, 0x87, 0x80, 0x4B,
   0x71, 0x94, 0xB8, 0x00, 0xA0, 0x7D, 0xB7, 0x53,
   0xDD, 0x20, 0x63, 0xEE, 0xF7, 0x83, 0x41, 0xFE,
   0x16, 0xA7, 0x6E, 0xDF, 0x21, 0x7D, 0x76, 0xC0,
   0x85, 0xD5, 0x65, 0x7F, 0x00, 0x23, 0x57, 0x45,
   0x52, 0x02, 0x9D, 0xEA, 0x69, 0xAC, 0x1F, 0xFD,
   0x3F, 0x8C, 0x4A, 0xD0,

   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

   0x64, 0xD5, 0xAA, 0xB1,
   0xA6, 0x03, 0x18, 0x92, 0x03, 0xAA, 0x31, 0x2E,
   0x48, 0x4B, 0x65, 0x20, 0x99, 0xCD, 0xC6, 0x0C,
   0x15, 0x0C, 0xBF, 0x3E, 0xFF, 0x78, 0x95, 0x67,
   0xB1, 0x74, 0x5B, 0x60,

   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\test\testsuit\logging.c ===
/*

  Logging.c

  4/23/00 dangriff created

  This is the output/logging code used by the CSP Test Suite.  Expect that this
  set of wrappers will be modified as the Test Suite evolves.

*/

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "cspstruc.h"
#include "logging.h"
#include "csptestsuite.h"

//
// Logging state variables
//
static BOOL g_fTestSuiteError			= FALSE;
static BOOL g_fCSPClassError			= FALSE;
static BOOL g_fTestLevelError			= FALSE;
static BOOL g_fAPIError					= FALSE;
static BOOL g_fCurrentAPIUnexpected		= FALSE;

static DWORD g_dwCurrentCSPClass		= 0;
static DWORD g_dwCurrentTestLevel		= 0;
static API_NAME g_CurrentAPI;
static DWORD g_dwCurrentAPISubset		= 0; // TEST_CASES_POSITIVE or TEST_CASES_NEGATIVE

// Test case set counter
static DWORD g_dwTestCaseIDMajor		= 0;

//
// User-specified settings
//
//static LOG_VERBOSE g_Verbose			= Terse;

static LPWSTR g_pwszProvName			= NULL;
static DWORD g_dwExternalProvType		= 0;

static LPWSTR g_pwszInteropProvName		= NULL;
static DWORD g_dwInteropProvType		= 0;

//
// Function: LogInfo
//
void LogInfo(IN LPWSTR pwszInfo)
{
	ezLogMsg(LOG_INFO, NULL, NULL, __LINE__, L"%s", pwszInfo);
}

//
// Function: LogUserOption
//
void LogUserOption(IN LPWSTR pwszOption)
{
	ezLogMsg(LOG_USER_OPTION, NULL, NULL, __LINE__, L"%s", pwszOption);
}

//
// Function: LogCreatingUserProtectedKey
//
void LogCreatingUserProtectedKey(void)
{
	LogTestCaseSeparator(TRUE);
	ezLogMsg(
		LOG_USER_PROTECTED_KEY,
		NULL,
		NULL,
		__LINE__,
		L"Creating user protected key.  You should see UI.");
}

//
// Function: FlagToString
//
BOOL FlagToString(
	IN DWORD dwFlag,
	IN FLAGTOSTRING_ITEM rgFlagToString [],
	IN DWORD cFlagToString,
	OUT WCHAR rgwsz [],
	IN FLAG_TYPE FlagType)
{
	BOOL fFound			= FALSE;
	unsigned iString	= 0;
	
	for (iString = 0; iString < cFlagToString; iString++)
	{
		if (	((ExactMatch == FlagType) &&
				(dwFlag == rgFlagToString[iString].dwKey)) ||
				((Maskable == FlagType) &&
				(dwFlag & rgFlagToString[iString].dwKey)))
		{
			if (fFound)
			{
				//
				// One or more flags have already been found, 
				// so print a "|" to delimit multiple strings.
				//
				wsprintf(
					rgwsz += wcslen(rgwsz),
					L" | %s",
					rgFlagToString[iString].pwszString);
			}
			else
			{
				fFound = TRUE;
				wcscpy(
					rgwsz,
					rgFlagToString[iString].pwszString);
			}

			if (ExactMatch == FlagType)
			{
				break;
			}
		}
	}

	return fFound;
}

//
// Function: AcquireContextFlagToString
//
BOOL AcquireContextFlagToString(
								IN DWORD dwFlag, 
								OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM AcquireContextFlagStrings [] = {
		{ CRYPT_VERIFYCONTEXT,			L"CRYPT_VERIFYCONTEXT" },
		{ CRYPT_NEWKEYSET,				L"CRYPT_NEWKEYSET" },
		{ CRYPT_MACHINE_KEYSET,			L"CRYPT_MACHINE_KEYSET" },
		{ CRYPT_DELETEKEYSET,			L"CRYPT_DELETEKEYSET" },
		{ CRYPT_SILENT,					L"CRYPT_SILENT" }
	};
	
	return FlagToString(
		dwFlag,
		AcquireContextFlagStrings,
		FLAGTOSTRING_SIZE(AcquireContextFlagStrings),
		rgwsz,
		Maskable);
}

//
// Function: GetProvParamToString
//
BOOL GetProvParamToString(
	IN DWORD dwFlag,
	OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM GetProvParamStrings [] = {
		{ PP_CONTAINER, L"PP_CONTAINER" },
		{ PP_ENUMALGS, L"PP_ENUMALGS" },
		{ PP_ENUMALGS_EX, L"PP_ENUMALGS_EX" },
		{ PP_ENUMCONTAINERS, L"PP_ENUMCONTAINERS" },
		{ PP_IMPTYPE, L"PP_IMPTYPE" },
		{ PP_NAME, L"PP_NAME" },
		{ PP_VERSION, L"PP_VERSION" },
		{ PP_SIG_KEYSIZE_INC, L"PP_SIG_KEYSIZE_INC" },
		{ PP_KEYX_KEYSIZE_INC, L"PP_KEYX_KEYSIZE_INC" },
		{ PP_KEYSET_SEC_DESCR, L"PP_KEYSET_SEC_DESCR" },
		{ PP_UNIQUE_CONTAINER, L"PP_UNIQUE_CONTAINER" },
		{ PP_PROVTYPE, L"PP_PROVTYPE" },
		{ PP_USE_HARDWARE_RNG, L"PP_USE_HARDWARE_RNG" },
		{ PP_KEYSPEC, L"PP_KEYSPEC" }
	};
	
	return FlagToString(
		dwFlag,
		GetProvParamStrings,
		FLAGTOSTRING_SIZE(GetProvParamStrings),
		rgwsz,
		ExactMatch);
}

//
// Function: SetProvParamToString
//
BOOL SetProvParamToString(
	IN DWORD dwFlag,
	OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM SetProvParamStrings [] = {
		{ PP_CLIENT_HWND, L"PP_CLIENT_HWND" },
		{ PP_KEYSET_SEC_DESCR, L"PP_KEYSET_SEC_DESCR" },
		{ PP_USE_HARDWARE_RNG, L"PP_USE_HARDWARE_RNG" }
	};
	
	return FlagToString(
		dwFlag,
		SetProvParamStrings,
		FLAGTOSTRING_SIZE(SetProvParamStrings),
		rgwsz,
		ExactMatch);
}

//
// Function: AlgidToString
// 
BOOL AlgidToString(
				   IN DWORD dwFlag,
				   OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM AlgidStrings [] = {
		{ AT_SIGNATURE, L"AT_SIGNATURE" },
		{ AT_KEYEXCHANGE, L"AT_KEYEXCHANGE" },
		{ CALG_MD2, L"CALG_MD2" },
		{ CALG_MD4, L"CALG_MD4" },
		{ CALG_MD5, L"CALG_MD5" },
		{ CALG_SHA, L"CALG_SHA" },
		{ CALG_SHA1, L"CALG_SHA1" },
		{ CALG_MAC, L"CALG_MAC" },
		{ CALG_RSA_SIGN, L"CALG_RSA_SIGN" },
		{ CALG_DSS_SIGN, L"CALG_DSS_SIGN" },
		{ CALG_RSA_KEYX, L"CALG_RSA_KEYX" },
		{ CALG_DES, L"CALG_DES" },
		{ CALG_3DES_112, L"CALG_3DES_112" },
		{ CALG_3DES, L"CALG_3DES" },
		{ CALG_DESX, L"CALG_DESX" },
		{ CALG_RC2, L"CALG_RC2" },
		{ CALG_RC4, L"CALG_RC4" },
		{ CALG_SEAL, L"CALG_SEAL" },
		{ CALG_DH_SF, L"CALG_DH_SF" },
		{ CALG_DH_EPHEM, L"CALG_DH_EPHEM" },
		{ CALG_AGREEDKEY_ANY, L"CALG_AGREEDKEY_ANY" },
		{ CALG_KEA_KEYX, L"CALG_KEA_KEYX" },
		{ CALG_HUGHES_MD5, L"CALG_HUGHES_MD5" },
		{ CALG_SKIPJACK, L"CALG_SKIPJACK" },
		{ CALG_TEK, L"CALG_TEK" },
		{ CALG_CYLINK_MEK, L"CALG_CYLINK_MEK" },
		{ CALG_SSL3_SHAMD5, L"CALG_SSL3_SHAMD5" },
		{ CALG_SSL3_MASTER, L"CALG_SSL3_MASTER" },
		{ CALG_SCHANNEL_MASTER_HASH, L"CALG_SCHANNEL_MASTER_HASH" },
		{ CALG_SCHANNEL_MAC_KEY, L"CALG_SCHANNEL_MAC_KEY" },
		{ CALG_SCHANNEL_ENC_KEY, L"CALG_SCHANNEL_ENC_KEY" },
		{ CALG_PCT1_MASTER, L"CALG_PCT1_MASTER" },
		{ CALG_SSL2_MASTER, L"CALG_SSL2_MASTER" },
		{ CALG_TLS1_MASTER, L"CALG_TLS1_MASTER" },
		{ CALG_RC5, L"CALG_RC5" },
		{ CALG_HMAC, L"CALG_HMAC" },
		{ CALG_TLS1PRF, L"CALG_TLS1PRF" },
		{ CALG_HASH_REPLACE_OWF, L"CALG_HASH_REPLACE_OWF" }
	};
	
	return FlagToString(
		dwFlag,
		AlgidStrings,
		FLAGTOSTRING_SIZE(AlgidStrings),
		rgwsz,
		ExactMatch);
}

//
// Function: DeriveKeyFlagToString
// 
BOOL DeriveKeyFlagToString(
						   IN DWORD dwFlag,
						   OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM DeriveKeyFlagStrings [] = {
		{ CRYPT_CREATE_SALT, L"CRYPT_CREATE_SALT" },
		{ CRYPT_EXPORTABLE, L"CRYPT_EXPORTABLE" },
		{ CRYPT_NO_SALT, L"CRYPT_NO_SALT" },
		{ CRYPT_UPDATE_KEY, L"CRYPT_UPDATE_KEY" }
	};
	
	return FlagToString(
		dwFlag,
		DeriveKeyFlagStrings,
		FLAGTOSTRING_SIZE(DeriveKeyFlagStrings),
		rgwsz,
		Maskable);
}

//
// Function: EncryptFlagToString
// 
BOOL EncryptFlagToString(
						 IN DWORD dwFlag,
						 OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM  EncryptFlagStrings [] = {
		{ CRYPT_OAEP, L"CRYPT_OAEP" }
	};
	
	return FlagToString(
		dwFlag,
		EncryptFlagStrings,
		FLAGTOSTRING_SIZE(EncryptFlagStrings),
		rgwsz,
		Maskable);
}

//
// Function: ExportKeyBlobTypeToString
// 
BOOL  ExportKeyBlobTypeToString (
								 IN DWORD dwFlag,
								 OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM  ExportKeyBlobTypeStrings [] = {
		{ OPAQUEKEYBLOB, L"OPAQUEKEYBLOB" },
		{ PRIVATEKEYBLOB, L"PRIVATEKEYBLOB" },
		{ PUBLICKEYBLOB, L"PUBLICKEYBLOB" },
		{ SIMPLEBLOB, L"SIMPLEBLOB" },
		{ SYMMETRICWRAPKEYBLOB, L"SYMMETRICWRAPKEYBLOB" }
	};
	
	return FlagToString(
		dwFlag,
		ExportKeyBlobTypeStrings,
		FLAGTOSTRING_SIZE(ExportKeyBlobTypeStrings),
		rgwsz,
		ExactMatch);
}

//
// Function: ExportKeyFlagToString
// 
BOOL ExportKeyFlagToString (
							IN DWORD dwFlag,
							OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM ExportKeyFlagStrings  [] = {
		{ CRYPT_DESTROYKEY, L"CRYPT_DESTROYKEY" },
		{ CRYPT_SSL2_FALLBACK, L"CRYPT_SSL2_FALLBACK" },
		{ CRYPT_OAEP, L"CRYPT_OAEP" }
	};
	
	return FlagToString(
		dwFlag,
		ExportKeyFlagStrings,
		FLAGTOSTRING_SIZE(ExportKeyFlagStrings),
		rgwsz,
		Maskable);
}

//
// Function: GenKeyFlagToString
// 
BOOL GenKeyFlagToString(
						IN DWORD dwFlag,
						OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM GenKeyFlagStrings  [] = {
		{ CRYPT_CREATE_SALT, L"CRYPT_CREATE_SALT" },
		{ CRYPT_EXPORTABLE, L"CRYPT_EXPORTABLE" },
		{ CRYPT_NO_SALT, L"CRYPT_NO_SALT" },
		{ CRYPT_PREGEN, L"CRYPT_PREGEN" },
		{ CRYPT_USER_PROTECTED, L"CRYPT_USER_PROTECTED" }
	};
	
	return FlagToString(
		dwFlag,
		GenKeyFlagStrings,
		FLAGTOSTRING_SIZE(GenKeyFlagStrings),
		rgwsz,
		Maskable);
}

//
// Function: HashParamToString
// 
BOOL HashParamToString(
					   IN DWORD dwFlag,
					   OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM HashParamStrings  [] = {
		{ HP_ALGID, L"HP_ALGID" },
		{ HP_HASHSIZE, L"HP_HASHSIZE" },
		{ HP_HASHVAL, L"HP_HASHVAL" },
		{ HP_HMAC_INFO, L"HP_HMAC_INFO" }
	};
	
	return FlagToString(
		dwFlag,
		HashParamStrings,
		FLAGTOSTRING_SIZE(HashParamStrings),
		rgwsz,
		ExactMatch);
}

//
// Function: KeyParamToString
// 
BOOL KeyParamToString(
					  IN DWORD dwFlag,
					  OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM KeyParamStrings [] = {
		{ KP_ALGID, L"KP_ALGID" },
		{ KP_BLOCKLEN, L"KP_BLOCKLEN" },
		{ KP_KEYLEN, L"KP_KEYLEN" },
		{ KP_SALT, L"KP_SALT" },
		{ KP_SALT_EX, L"KP_SALT_EX" },
		{ KP_PERMISSIONS, L"KP_PERMISSIONS" },
		{ KP_P, L"KP_P" },
		{ KP_Q, L"KP_Q" },
		{ KP_G, L"KP_G" },
		{ KP_X, L"KP_X" },
		{ KP_EFFECTIVE_KEYLEN, L"KP_EFFECTIVE_KEYLEN" },
		{ KP_IV, L"KP_IV" },
		{ KP_PADDING, L"KP_PADDING" },
		{ KP_MODE, L"KP_MODE" },
		{ KP_MODE_BITS, L"KP_MODE_BITS" },
		{ KP_PUB_PARAMS, L"KP_PUB_PARAMS" }
	};
	
	return FlagToString(
		dwFlag,
		KeyParamStrings,
		FLAGTOSTRING_SIZE(KeyParamStrings),
		rgwsz,
		ExactMatch);
}

//
// Function: KeyParamModeToString
// 
BOOL KeyParamModeToString(
						  IN DWORD dwFlag,
						  OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM KeyParamModeStrings[] = {
		{ CRYPT_MODE_CBC, L"CRYPT_MODE_CBC" },
		{ CRYPT_MODE_CFB, L"CRYPT_MODE_CFB" },
		{ CRYPT_MODE_ECB, L"CRYPT_MODE_ECB" },
		{ CRYPT_MODE_OFB, L"CRYPT_MODE_OFB" }
	};
	
	return FlagToString(
		dwFlag,
		KeyParamModeStrings,
		FLAGTOSTRING_SIZE(KeyParamModeStrings),
		rgwsz,
		ExactMatch);
}

//
// Function: KeyParamPermissionToString
// 
BOOL KeyParamPermissionToString(
								IN DWORD dwFlag,
								OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM KeyParamPermissionStrings[] = {
		{ CRYPT_DECRYPT, L"CRYPT_DECRYPT" },
		{ CRYPT_ENCRYPT, L"CRYPT_ENCRYPT" },
		{ CRYPT_EXPORT, L"CRYPT_EXPORT" },
		{ CRYPT_MAC, L"CRYPT_MAC" },
		{ CRYPT_READ, L"CRYPT_READ" },
		{ CRYPT_WRITE, L"CRYPT_WRITE" }
	};
	
	return FlagToString(
		dwFlag,
		KeyParamPermissionStrings,
		FLAGTOSTRING_SIZE(KeyParamPermissionStrings),
		rgwsz,
		Maskable);
}

//
// Function: ProvParamEnumFlagToString
// 
BOOL ProvParamEnumFlagToString(
							   IN DWORD dwFlag,
							   OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM ProvParamEnumFlagStrings[] = {
		{ CRYPT_FIRST, L"CRYPT_FIRST" },
		{ CRYPT_MACHINE_KEYSET, L"CRYPT_MACHINE_KEYSET" }
	};
	
	return FlagToString(
		dwFlag,
		ProvParamEnumFlagStrings,
		FLAGTOSTRING_SIZE(ProvParamEnumFlagStrings),
		rgwsz,
		Maskable);
}

//
// Function: ProvParamSecDescrFlagToString
// 
BOOL ProvParamSecDescrFlagToString(
								   IN DWORD dwFlag,
								   OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM ProvParamSecDescrFlagStrings[] = {
		{ OWNER_SECURITY_INFORMATION, L"OWNER_SECURITY_INFORMATION" },
		{ GROUP_SECURITY_INFORMATION, L"GROUP_SECURITY_INFORMATION" },
		{ DACL_SECURITY_INFORMATION, L"DACL_SECURITY_INFORMATION" },
		{ SACL_SECURITY_INFORMATION, L"SACL_SECURITY_INFORMATION" }
	};
	
	return FlagToString(
		dwFlag,
		ProvParamSecDescrFlagStrings,
		FLAGTOSTRING_SIZE(ProvParamSecDescrFlagStrings),
		rgwsz,
		Maskable);
}

//
// Function: ProvParamImpTypeToString
// 
BOOL ProvParamImpTypeToString(
							  IN DWORD dwFlag,
							  OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM ProvParamImpTypeStrings[] = {
		{ CRYPT_IMPL_HARDWARE, L"CRYPT_IMPL_HARDWARE" },
		{ CRYPT_IMPL_SOFTWARE, L"CRYPT_IMPL_SOFTWARE" },
		{ CRYPT_IMPL_MIXED, L"CRYPT_IMPL_MIXED" },
		{ CRYPT_IMPL_UNKNOWN, L"CRYPT_IMPL_UNKNOWN" }
	};
	
	return FlagToString(
		dwFlag,
		ProvParamImpTypeStrings,
		FLAGTOSTRING_SIZE(ProvParamImpTypeStrings),
		rgwsz,
		ExactMatch);
}

//
// Function: HashDataFlagToString
// 
BOOL HashDataFlagToString(
						  IN DWORD dwFlag,
						  OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM HashDataFlagStrings[] = {
		{ CRYPT_USERDATA, L"CRYPT_USERDATA" }
	};
	
	return FlagToString(
		dwFlag,
		HashDataFlagStrings,
		FLAGTOSTRING_SIZE(HashDataFlagStrings),
		rgwsz,
		Maskable);
}

//
// Function: HashSessionKeyFlagToString
// 
BOOL HashSessionKeyFlagToString(
								IN DWORD dwFlag,
								OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM HashSessionKeyFlagStrings[] = {
		{ CRYPT_LITTLE_ENDIAN, L"CRYPT_LITTLE_ENDIAN" }
	};
	
	return FlagToString(
		dwFlag,
		HashSessionKeyFlagStrings,
		FLAGTOSTRING_SIZE(HashSessionKeyFlagStrings),
		rgwsz,
		Maskable);
}

//
// Function: ImportKeyFlagToString
// 
BOOL ImportKeyFlagToString(
						   IN DWORD dwFlag,
						   OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM ImportKeyFlagStrings[] = {
		{ CRYPT_EXPORTABLE, L"CRYPT_EXPORTABLE" },
		{ CRYPT_OAEP, L"CRYPT_OAEP" },
		{ CRYPT_NO_SALT, L"CRYPT_NO_SALT" }
	};
	
	return FlagToString(
		dwFlag,
		ImportKeyFlagStrings,
		FLAGTOSTRING_SIZE(ImportKeyFlagStrings),
		rgwsz,
		Maskable);
}

//
// Function: SignHashFlagToString
// 
BOOL SignHashFlagToString(
						  IN DWORD dwFlag,
						  OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM SignHashFlagStrings[] = {
		{ CRYPT_NOHASHOID, L"CRYPT_NOHASHOID" }
	};
	
	return FlagToString(
		dwFlag,
		SignHashFlagStrings,
		FLAGTOSTRING_SIZE(SignHashFlagStrings),
		rgwsz,
		Maskable);
}

//
// Function: TestCaseTypeToString
//
BOOL TestCaseTypeToString(
	IN DWORD dwTestCaseType,
	OUT WCHAR rgwsz [])
{
	FLAGTOSTRING_ITEM TestCaseTypeStrings[] = {
		{ TEST_CASES_POSITIVE,		L"Positive test cases.  API's should return TRUE" },
		{ TEST_CASES_NEGATIVE,		L"Negative test cases.  API's should return FALSE" },
		{ TEST_CASES_SCENARIO,		L"Scenario test cases.  Tests using multiple API's" },
		{ TEST_CASES_INTEROP,		L"Interoperability test cases.  Tests using multiple API's and two CSP's" }
	};

	return FlagToString(
		dwTestCaseType,
		TestCaseTypeStrings,
		FLAGTOSTRING_SIZE(TestCaseTypeStrings),
		rgwsz,
		ExactMatch);
};

//
// Function: 
//
BOOL ApiNameToString(
	API_NAME ApiName,
	OUT WCHAR rgwsz[])
{
	FLAGTOSTRING_ITEM ApiNameStrings [] = {
		{ API_CRYPTACQUIRECONTEXT,		L"CryptAcquireContext" },
		{ API_CRYPTCREATEHASH,			L"CryptCreateHash" },
		{ API_CRYPTDECRYPT,				L"CryptDecrypt" },
		{ API_CRYPTDERIVEKEY,			L"CryptDeriveKey" },
		{ API_CRYPTDESTROYHASH,			L"CryptDestroyHash" },
		{ API_CRYPTDESTROYKEY,			L"CryptDestroyKey" },
		{ API_CRYPTENCRYPT,				L"CryptEncrypt" },
		{ API_CRYPTEXPORTKEY,			L"CryptExportKey" },
		{ API_CRYPTGENKEY,				L"CryptGenKey" },
		{ API_CRYPTGENRANDOM,			L"CryptGenRandom" },
		{ API_CRYPTGETHASHPARAM,		L"CryptGetHashParam" },
		{ API_CRYPTGETKEYPARAM,			L"CryptGetKeyParam" },
		{ API_CRYPTGETPROVPARAM,		L"CryptGetProvParam" },
		{ API_CRYPTGETUSERKEY,			L"CryptGetUserKey" },
		{ API_CRYPTHASHDATA,			L"CryptHashData" },
		{ API_CRYPTHASHSESSIONKEY,		L"CryptHashSessionKey" },
		{ API_CRYPTIMPORTKEY,			L"CryptImportKey" },
		{ API_CRYPTRELEASECONTEXT,		L"CryptReleaseContext" },
		{ API_CRYPTSETHASHPARAM,		L"CryptSetHashParam" },
		{ API_CRYPTSETKEYPARAM,			L"CryptSetKeyParam" },
		{ API_CRYPTSETPROVPARAM,		L"CryptSetProvParam" },
		{ API_CRYPTSIGNHASH,			L"CryptSignHash" },
		{ API_CRYPTVERIFYSIGNATURE,		L"CryptVerifySignature" },
		{ API_CRYPTDUPLICATEHASH,		L"CryptDuplicateHash" },
		{ API_CRYPTDUPLICATEKEY,		L"CryptDuplicateKey" },

		//
		// Advapi32 entry point
		//
		{ API_CRYPTCONTEXTADDREF,		L"CryptContextAddRef" },
		
		//
		// Non-Crypto API functions
		//
		{ API_MEMORY,					L"Memory allocation" },
		{ API_DATACOMPARE,				L"Data comparision (see previous API)" },
		{ API_GETDESKTOPWINDOW,			L"GetDesktopWindow" }
	};

	return FlagToString(
		ApiName,
		ApiNameStrings,
		FLAGTOSTRING_SIZE(ApiNameStrings),
		rgwsz,
		ExactMatch);
}

//
// Function: LogCleanupParamInfo
//
void LogCleanupParamInfo(
	IN OUT PAPI_PARAM_INFO pParamInfo,
	IN DWORD cParamInfo)
{
	unsigned iParam;

	for (iParam = 0; iParam < cParamInfo; iParam++)
	{
		if (pParamInfo[iParam].pbSaved)
			free(pParamInfo[iParam].pbSaved);
	}
}

//
// Function: LogInitParamInfo
//
BOOL LogInitParamInfo(
	IN OUT PAPI_PARAM_INFO pParamInfo,
	IN DWORD cParamInfo,
	IN PTESTCASE ptc)
{
	unsigned iParam;

	for (iParam = 0; iParam < cParamInfo; iParam++)
	{
		if (pParamInfo[iParam].fPrintBytes)
		{
			if (	NULL != pParamInfo[iParam].pbParam &&
					((PBYTE) TEST_INVALID_POINTER) != pParamInfo[iParam].pbParam &&
					NULL != pParamInfo[iParam].pcbBytes && 
					((PDWORD) TEST_INVALID_POINTER) != pParamInfo[iParam].pcbBytes)
			{
				// Save bytes to a second buffer
				if (! TestAlloc(
					&pParamInfo[iParam].pbSaved, 
					*pParamInfo[iParam].pcbBytes,
					ptc))
				{
					return FALSE;
				}

				memcpy(
					pParamInfo[iParam].pbSaved,
					pParamInfo[iParam].pbParam,
					*pParamInfo[iParam].pcbBytes);
			}
		}
	}

	return TRUE;		
}

//
// Function: LogParamInfo
//
void LogParamInfo(
	PAPI_PARAM_INFO pParamInfo,
	DWORD cParamInfo,
	BOOL fLogToConsole)
{
	DWORD dwLogApiParameter = LOG_API_PARAMETER;
	WCHAR rgwsz [ BUFFER_LENGTH ];
	unsigned iParam;

	if (fLogToConsole)
	{
		// Feedback has been to not display parameters with the console 
		// output.  To change this, uncomment the next line.
		
		//dwLogApiParameter = LOG_API_PARAMETER_CONSOLE;
	}

	memset(rgwsz, 0, sizeof(rgwsz));

	for (iParam = 0; iParam < cParamInfo; iParam++)
	{
		switch( pParamInfo[iParam].Type )
		{
		case Handle:
			{
				ezLogMsg(
					dwLogApiParameter, 
					NULL, 
					NULL, 
					__LINE__,
					L" %s: 0x%x",
					pParamInfo[iParam].pwszName,
					pParamInfo[iParam].pulParam);
				break;
			}
		case Pointer:
			{
				ezLogMsg(
					dwLogApiParameter, 
					NULL, 
					NULL, 
					__LINE__, 
					L" %s: 0x%x", 
					pParamInfo[iParam].pwszName,
					pParamInfo[iParam].pbParam);

				if (	pParamInfo[iParam].fPrintBytes &&
						pParamInfo[iParam].pbSaved)
				{
					wsprintf(rgwsz, L"INPUT value", pParamInfo[iParam].pwszName);
					PrintBytes(
						rgwsz,
						pParamInfo[iParam].pbSaved,
						*pParamInfo[iParam].pcbBytes);
					*rgwsz = L'\0';
				}
				if (	pParamInfo[iParam].fPrintBytes &&
						NULL != pParamInfo[iParam].pbParam &&
						(PBYTE) TEST_INVALID_POINTER != pParamInfo[iParam].pbParam &&
						NULL != pParamInfo[iParam].pcbBytes &&
						(PDWORD) TEST_INVALID_POINTER != pParamInfo[iParam].pcbBytes)
				{
					wsprintf(rgwsz, L"OUTPUT value", pParamInfo[iParam].pwszName);
					PrintBytes(
						rgwsz,
						pParamInfo[iParam].pbParam,
						*(pParamInfo[iParam].pcbBytes));
					*rgwsz = L'\0';
				}
				break;
			}
		case Dword:
			{
				//
				// If a pfnFlagToString function has been specified, 
				// attempt to translate the flag(s).
				//
				if (pParamInfo[iParam].pfnFlagToString)
				{
					pParamInfo[iParam].pfnFlagToString(
						pParamInfo[iParam].dwParam,
						rgwsz);

					ezLogMsg(
						dwLogApiParameter,
						NULL,
						NULL,
						__LINE__,
						L" %s: 0x%x (%s)",
						pParamInfo[iParam].pwszName,
						pParamInfo[iParam].dwParam,
						rgwsz);
					rgwsz[0] = L'\0';
				}
				else
				{
					ezLogMsg(
						dwLogApiParameter,
						NULL,
						NULL,
						__LINE__,
						L" %s: 0x%x",
						pParamInfo[iParam].pwszName,
						pParamInfo[iParam].dwParam);
				}			
				break;
			}
		case String:
			{
				ezLogMsg(
					dwLogApiParameter,
					NULL,
					NULL,
					__LINE__,
					L" %s: %s",
					pParamInfo[iParam].pwszName,
					pParamInfo[iParam].pwszParam);
				break;
			}
		case Boolean:
			{
				ezLogMsg(
					dwLogApiParameter,
					NULL,
					NULL,
					__LINE__,
					L" %s: %s",
					pParamInfo[iParam].pwszName,
					pParamInfo[iParam].fParam ? STRING_TRUE : STRING_FALSE);
				break;
			}
		}
	}
}

//
// Function: IncrementErrorLevel
//
DWORD IncrementErrorLevel(DWORD dwErrorLevel)
{
	int iLevel;

	for (
		iLevel = 0; 
		iLevel < (sizeof(g_rgErrorLevels) / sizeof(DWORD) - 1);
		iLevel++) 
	{
		if (dwErrorLevel == g_rgErrorLevels[iLevel])
		{
			return g_rgErrorLevels[iLevel + 1];
		}
	}

	return g_rgErrorLevels[iLevel];
}

//
// Function: LogInit
//
BOOL LogInit(
		IN PLOGINIT_INFO pLogInitInfo)
{
	EZLOG_OPENLOG_DATA EzLogOpenData;	

	g_pwszProvName = pLogInitInfo->pwszCSPName;
	g_dwExternalProvType = pLogInitInfo->dwCSPExternalType;
	g_pwszInteropProvName = pLogInitInfo->pwszInteropCSPName;
	g_dwInteropProvType = pLogInitInfo->dwInteropCSPExternalType;

	//
	// Initialize EZLOG
	//
	memset(&EzLogOpenData, 0, sizeof(EzLogOpenData));

	EzLogOpenData.Version = EZLOG_OPENLOG_DATA_VERSION;
	EzLogOpenData.Flags = EZLOG_OUTPUT_STDOUT | EZLOG_USE_INDENTATION | 
		EZLOG_REPORT_BLOCKCLOSE | EZLOG_USE_ONLY_MY_LEVELS | EZLOG_LEVELS_ARE_MASKABLE;
	EzLogOpenData.LogFileName = LOGFILE;

	//
	// Don't output the block summary table 
	//
	EzLogOpenData.cReportBlockThresh = EZLOG_REPORT_NO_BLOCKS;
	EzLogOpenData.cLevels = sizeof(g_EzLogLevels) / sizeof(EZLOG_LEVEL_INIT_DATA);
	EzLogOpenData.pLevels = g_EzLogLevels;

	if (! ezOpenLogEx(&EzLogOpenData))
	{
		return FALSE;
	}

	return TRUE;
}

// 
// Function: LogClose
// Purpose: Close and cleanup logging
//
BOOL LogClose(void)
{
	//
	// Check for a Test Suite-level error
	//
	if (g_fTestSuiteError)
	{
		ezLogMsg(
			CSP_ERROR_TEST_SUITE, 
			NULL, 
			NULL, 
			__LINE__, 
			L"CSP Test Suite is ending prematurely");
	}

	return ezCloseLog(0);
}

//
// Function: LogBeginCSPClass
// Purpose: Log the beginning of a new class, or major group, of tests.
//
BOOL LogBeginCSPClass(DWORD dwClass)
{
	LPWSTR pwsz = NULL;

	switch (dwClass)
	{
	case CLASS_INVALID:
		{
			pwsz = L"CLASS_INVALID";
			break;
		}
	case CLASS_SIG_ONLY:
		{
			pwsz = L"CLASS_SIG_ONLY";
			break;
		}
	case CLASS_SIG_KEYX:
		{
			pwsz = L"CLASS_SIG_KEYX";
			break;
		}
	case CLASS_FULL:
		{
			pwsz = L"CLASS_FULL";
			break;
		}
	}

	//
	// If there has been a Test Suite-level error, don't allow
	// a new CSP Class set of tests to begin.
	//
	if (g_fTestSuiteError)
	{
		return FALSE;
	}
	else
	{
		g_dwCurrentCSPClass = dwClass;

		return ezStartBlock(
			NULL, 
			NULL, 
			EZBLOCK_OUTCOME_INDEPENDENT /*EZBLOCK_TRACK_SUBBLOCKS*/, 
			CSP_PASS, 
			L"CSP %s", pwsz);
	}
}

//
// Function: LogEndCSPClass
// Purpose: Log the completion of the current class of tests.
//
BOOL LogEndCSPClass(DWORD dwClass)
{
	if (g_dwCurrentCSPClass != dwClass)
	{
		return FALSE;
	}

	//
	// Clear CSP Class-level error flag
	//
	if (g_fCSPClassError)
	{
		ezLogMsg(
			CSP_ERROR_CSP_CLASS, 
			NULL, 
			NULL, 
			__LINE__, 
			L"CSP Class is ending prematurely");
		
		g_fCSPClassError = FALSE;
	}
	
	return ezFinishBlock(0);
}

//
// Function: LogBeginTestLevel
// Purpose: Log the beginning of a new level, or minor group, of tests.
//
BOOL LogBeginTestLevel(DWORD dwLevel)
{
	LPWSTR pwsz = NULL;

	switch (dwLevel)
	{
	case TEST_LEVEL_CSP:
		{
			pwsz = L"TEST_LEVEL_CSP";
			break;
		}
	case TEST_LEVEL_PROV:
		{
			pwsz = L"TEST_LEVEL_PROV";
			break;
		}
	case TEST_LEVEL_HASH:
		{
			pwsz = L"TEST_LEVEL_HASH";
			break;
		}
	case TEST_LEVEL_KEY:
		{
			pwsz = L"TEST_LEVEL_KEY";
			break;
		}
	case TEST_LEVEL_CONTAINER:
		{
			pwsz = L"TEST_LEVEL_CONTAINER";
			break;
		}
	}

	// 
	// If there has been a CSP Class-level error, don't start
	// a new test level until the error has been cleared.
	//
	if (g_fCSPClassError)
	{
		return FALSE;
	}	
	else
	{
		g_dwCurrentTestLevel = dwLevel;

		return ezStartBlock(
			NULL, 
			NULL, 
			EZBLOCK_OUTCOME_INDEPENDENT /*EZBLOCK_TRACK_SUBBLOCKS*/, 
			CSP_PASS, 
			L"%s", pwsz);
	}
}

//
// Function: LogEndTestLevel
// Purpose: Log the completion of the current test level.
//
BOOL LogEndTestLevel(DWORD dwLevel)
{
	if (g_dwCurrentTestLevel != dwLevel)
	{
		return FALSE;
	}

	//
	// Clear Test Level error flag
	//
	if (g_fTestLevelError)
	{
		ezLogMsg(
			CSP_ERROR_TEST_LEVEL, 
			NULL, 
			NULL, 
			__LINE__, 
			L"Test Level is ending prematurely");

		g_fTestLevelError = FALSE;
	}

	return ezFinishBlock(0);
}

//
// Function: LogBeginAPI
// Purpose: Log the beginning of a set of API test cases
//
BOOL LogBeginAPI(API_NAME ApiName, DWORD dwAPISubset)
{
	WCHAR rgwsz[BUFFER_SIZE];

	// 
	// If there has been a Test Level error, don't start a new
	// API set until the error has been cleared.
	//
	if (g_fTestLevelError)
	{
		return FALSE;
	}
	else
	{
		g_dwTestCaseIDMajor++;
		g_CurrentAPI = ApiName;
		g_dwCurrentAPISubset = dwAPISubset;

		ApiNameToString(ApiName, rgwsz);
		wcscpy(rgwsz + wcslen(rgwsz), L", ");
		TestCaseTypeToString(
			dwAPISubset,
			rgwsz + wcslen(rgwsz));

		return ezStartBlock(
			NULL, 
			NULL, 
			EZBLOCK_OUTCOME_INDEPENDENT /*EZBLOCK_TRACK_SUBBLOCKS*/, 
			CSP_PASS, 
			L"API %s", 
			rgwsz);
	}
}

//
// Function: LogEndAPI
// Purpose: Log the completion of a set of API test cases
//
BOOL LogEndAPI(API_NAME ApiName, DWORD dwAPISubset)
{
	if (	(g_CurrentAPI != ApiName) ||
			(g_dwCurrentAPISubset != dwAPISubset))
	{
		return FALSE;
	}

	//
	// Clear API-level error flag
	//
	g_fAPIError = FALSE;	

	return ezFinishBlock(0);
}

//
// Function: LogPass
// Purpose: Log a successful test case
//
BOOL LogPass(DWORD dwTestCaseID)
{
	return ezLogMsg(
		CSP_PASS, 
		NULL, 
		NULL, 
		__LINE__, 
		L"Test case %d.%d: PASS", 
		g_dwTestCaseIDMajor,
		dwTestCaseID);
}

//
// Function: LogBeginScenarioTest
// Purpose: Log the beginning of a Scenario Test.
//
BOOL LogBeginScenarioTest(LPWSTR pwszDescription)
{
	g_dwTestCaseIDMajor++;
	return ezStartBlock(
		NULL, 
		NULL, 
		EZBLOCK_OUTCOME_INDEPENDENT, 
		CSP_PASS, 
		L"Scenario test case - %s",
		pwszDescription);
}

//
// Function: LogEndScenarioTest
// Purpose: Log the end of a Scenario Test 
//
BOOL LogEndScenarioTest(void)
{
	//
	// Clear API-level error flag
	//
	g_fAPIError = FALSE;	

	return ezFinishBlock(0);
}

//
// Function: LogBeginInteropTest
// Purpose: Log the beginning of an Interoperability Test.
//
BOOL LogBeginInteropTest(LPWSTR pwszDescription)
{
	g_dwTestCaseIDMajor++;
	return ezStartBlock(
		NULL, 
		NULL, 
		EZBLOCK_OUTCOME_INDEPENDENT, 
		CSP_PASS, 
		L"Interoperability test case - %s",
		pwszDescription);
}

//
// Function: LogEndInteropTest
// Purpose: Log the end of an Interoperability Test 
//
BOOL LogEndInteropTest(void)
{ 
	//
	// Clear API-level error flag
	//
	g_fAPIError = FALSE;	

	return ezFinishBlock(0);
}

//
// Function: DoError
// Purpose: Perform the operations for handling a test case error
//
BOOL DoError(DWORD dwTestCaseID, DWORD dwReportedErrorLevel)
{
	LPWSTR pwszErrorLevel	= NULL;
	DWORD dwErrorLevel		= dwReportedErrorLevel & (CSP_ERROR_CONTINUE | CSP_ERROR_API);

	switch (dwErrorLevel)
	{
	case CSP_ERROR_CONTINUE:
		pwszErrorLevel = L"ERROR_CONTINUE";
		break;
	case CSP_ERROR_API:
		pwszErrorLevel = L"ERROR_API";
		break;
	}

	//
	// The dwErrorLevel is being masked to limit the scope of the
	// error being reported at this point.  If a test case fails, 
	// only ERROR_CONTINUE and ERROR_API (and ERROR_WARNING) errors
	// will be reported.  If a more severe error has been flagged, 
	// it will be reported when the appropriate Test Level or CSP Class
	// block ends.
	//
	return ezLogMsg(
		dwErrorLevel, 
		NULL, 
		NULL, 
		__LINE__, 
		L"Test case %d.%d: %s", 
		g_dwTestCaseIDMajor,
		dwTestCaseID, 
		pwszErrorLevel);
}

// 
// Function: DoWarning
// Purpose: Perform the operations for handling a test case warning
//
BOOL DoWarning(DWORD dwTestCaseID)
{
	return ezLogMsg(
		CSP_ERROR_WARNING, 
		NULL, 
		NULL, 
		__LINE__, 
		L"Test case %d.%d: WARNING", 
		g_dwTestCaseIDMajor, 
		dwTestCaseID);
}

//
// Function: LogTestCaseSeparator
//
BOOL LogTestCaseSeparator(BOOL fLogToConsole)
{
	if (fLogToConsole)
	{
		return ezLogMsg(
			LOG_SEPARATOR_CONSOLE,
			NULL,
			NULL,
			__LINE__,
			TEST_CASE_SEPARATOR);
	}
	else
	{
		return ezLogMsg(
			LOG_SEPARATOR,
			NULL,
			NULL,
			__LINE__,
			TEST_CASE_SEPARATOR);
	}
}

//
// Function: LogTestCase
//
BOOL LogTestCase(PLOGTESTCASEINFO pLogTestCaseInfo)
{
	BOOL fReturn						= TRUE;
	DWORD dwActualErrorLevel			= pLogTestCaseInfo->dwErrorLevel;
	//LPWSTR pwszExpected					= NULL;
	//LPWSTR pwszActual					= NULL;
	LPWSTR pwsz							= NULL;
	BOOL fLogToConsole					= FALSE;
	DWORD dwLogApiName					= LOG_API_NAME;
	DWORD dwLogInfo						= LOG_INFO;
	WCHAR rgwsz[BUFFER_SIZE];

	if (pLogTestCaseInfo->fPass)
	{
		LogTestCaseSeparator(FALSE);
		LogPass(pLogTestCaseInfo->dwTestCaseID);
		goto Return;
	}
	
	if (KNOWN_ERROR_UNKNOWN != pLogTestCaseInfo->KnownErrorID)
	{
		dwActualErrorLevel = GetKnownErrorValue(
								pLogTestCaseInfo->KnownErrorID,
								dwActualErrorLevel);
	}

	if (dwActualErrorLevel & CSP_ERROR_WARNING)
	{
		//
		// Don't look for other error flags if a warning has been flagged, 
		// just handle the warning and return.
		//
		//fLogToConsole = TRUE;
		LogTestCaseSeparator(fLogToConsole);
		DoWarning(pLogTestCaseInfo->dwTestCaseID);
		
		goto Return;
	}

	if (dwActualErrorLevel & 
		(CSP_ERROR_CONTINUE | CSP_ERROR_API | 
		CSP_ERROR_TEST_LEVEL | CSP_ERROR_CSP_CLASS | 
		CSP_ERROR_TEST_SUITE))
	{
		fLogToConsole = TRUE;
		LogTestCaseSeparator(fLogToConsole);
		DoError(pLogTestCaseInfo->dwTestCaseID, dwActualErrorLevel);
	}

	if (dwActualErrorLevel & CSP_ERROR_API)
	{
		g_fAPIError = TRUE;
		fReturn = FALSE;
	}

	if (dwActualErrorLevel & CSP_ERROR_TEST_LEVEL)
	{
		g_fTestLevelError = TRUE;
	}

	if (dwActualErrorLevel & CSP_ERROR_CSP_CLASS)
	{
		g_fCSPClassError = TRUE;
	}

	if (dwActualErrorLevel & CSP_ERROR_TEST_SUITE)
	{
		g_fTestSuiteError = TRUE;
	}

Return:
	
	if (fLogToConsole)
	{
		dwLogApiName = LOG_API_NAME_CONSOLE;
		dwLogInfo = LOG_INFO_CONSOLE;
	}

	ApiNameToString(pLogTestCaseInfo->ApiName, rgwsz);
	ezLogMsg(
		dwLogApiName,
		NULL,
		NULL,
		__LINE__,
		L"%s", rgwsz);

	ezLogMsg(
		dwLogInfo,
		NULL,
		NULL,
		__LINE__,
		L"Returned: %s", 
		pLogTestCaseInfo->fReturnVal ? STRING_TRUE : STRING_FALSE);

	if (! pLogTestCaseInfo->fPass)
	{
		switch (pLogTestCaseInfo->dwErrorType)
		{
		case ERROR_API_SUCCEEDED:
			pwsz  = L"API succeeded unexpectedly";
			break;
		case ERROR_API_FAILED:
			pwsz = L"API failed unexpectedly";
			break;
		case ERROR_WRONG_ERROR_CODE:
			pwsz = L"API returned an incorrect error code";
			break;
		case ERROR_WIN32_FAILURE:
			pwsz = L"A WIN32 (non-CSP) API failed";
			break;
		case ERROR_WRONG_SIZE:
			pwsz = L"The API returned an incorrect data size";
			break;
		case ERROR_BAD_DATA:
			pwsz = L"The API returned bad data";
			break;
		case ERROR_LIST_TOO_SHORT:
			pwsz = L"The list of algorithms is too short";
			break;
		case ERROR_REQUIRED_ALG:
			pwsz = L"A required algorithm is missing";
			break;
		}

		ezLogMsg(
			dwLogInfo,
			NULL,
			NULL,
			__LINE__,
			L"Error type: %s", pwsz);
		
		//
		// Display details about the known error status here,
		// after the Error/Warning has been processed above.
		//
		ezLogMsg(
			dwLogInfo, 
			NULL, 
			NULL, 
			__LINE__, 
			L"Known error: %s",
			(KNOWN_ERROR_UNKNOWN == pLogTestCaseInfo->KnownErrorID) ? L"No" : L"Yes");
		
		if (ERROR_WRONG_ERROR_CODE == pLogTestCaseInfo->dwErrorType)
		{
			FormatMessage(
				FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_MAX_WIDTH_MASK,
				NULL,
				pLogTestCaseInfo->dwExpectedErrorCode,
				MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
				rgwsz,
				BUFFER_SIZE,
				NULL);

			ezLogMsg(
				dwLogInfo, 
				NULL, 
				NULL, 
				__LINE__, 
				L"Expected error code: 0x%x (%s)", 
				pLogTestCaseInfo->dwExpectedErrorCode,
				rgwsz);
			*rgwsz = L'\0';
		}
		
		if (	FALSE == pLogTestCaseInfo->fReturnVal ||
				ERROR_API_FAILED == pLogTestCaseInfo->dwErrorType ||
				ERROR_WRONG_ERROR_CODE	 == pLogTestCaseInfo->dwErrorType ||
				ERROR_WIN32_FAILURE == pLogTestCaseInfo->dwErrorType)
		{
			// Don't get the error string if the error code is 0
			*rgwsz = L'\0';
			if (0 != pLogTestCaseInfo->dwWinError)
			{
				FormatMessage(
					FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_MAX_WIDTH_MASK,
					NULL,
					pLogTestCaseInfo->dwWinError,
					MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
					rgwsz,
					BUFFER_SIZE,
					NULL);
			}
			ezLogMsg(
				dwLogInfo, 
				NULL, 
				NULL, 
				__LINE__, 
				L"Actual error code: 0x%x (%s)", 
				pLogTestCaseInfo->dwWinError,
				rgwsz);
			*rgwsz = L'\0';
		}
		
		//
		// Log details about this failure
		//
		if (NULL != pLogTestCaseInfo->pwszErrorHelp)
		{
			ezLogMsg(
				dwLogInfo, 
				NULL, 
				NULL, 
				__LINE__, 
				L"Test case description: %s", 
				pLogTestCaseInfo->pwszErrorHelp);
		}
	}

	LogParamInfo(
		pLogTestCaseInfo->pParamInfo, 
		pLogTestCaseInfo->cParamInfo,
		fLogToConsole);

	return fReturn;
}

//
// Function: LogGetInteropProvType
//
DWORD LogGetInteropProvType(void)
{
	return g_dwInteropProvType;
}

//
// Function: LogGetInteropProvName
//
LPWSTR LogGetInteropProvName(void)
{
	return g_pwszInteropProvName;
}

//
// Function: LogGetProvType
// Purpose: Return the provider type for which the CSP under
// test is registered (in the system registry).
//
DWORD LogGetProvType(void)
{
	return g_dwExternalProvType;
}

//
// Function: LogGetProvName
// Purpose: Return the provider name for which the CSP under
// test is registered (in the system registry).
//
LPWSTR LogGetProvName(void)
{
	return g_pwszProvName;
}

//
// Function: LogApiFailure
//
BOOL LogApiFailure(
	IN API_NAME ApiName,
	IN DWORD dwErrorType,
	IN OUT PTESTCASE ptc)
{
	LOGTESTCASEINFO LogTestCaseInfo;

	InitLogTestCaseInfo(ptc, &LogTestCaseInfo);

	LogTestCaseInfo.ApiName = ApiName;
	LogTestCaseInfo.dwErrorType = dwErrorType;
	LogTestCaseInfo.fPass = FALSE;

	return LogTestCase(&LogTestCaseInfo);
}

//
// Function: CheckAndLogStatus
//
BOOL CheckAndLogStatus(
	IN API_NAME ApiName,
	IN BOOL fCallSucceeded, 
	IN OUT PTESTCASE ptc, 
	IN PAPI_PARAM_INFO pParamInfo,
	IN DWORD cParamInfo)
{
	DWORD dwWinError = 0;
	//DWORD dwTestCaseID = 0;
	LOGTESTCASEINFO LogTestCaseInfo;

	InitLogTestCaseInfo(ptc, &LogTestCaseInfo);
	LogTestCaseInfo.fReturnVal = fCallSucceeded;

	if (! fCallSucceeded)
	{
		dwWinError = GetLastError();

		if (ptc->fExpectSuccess)
		{
			//
			// Test was expected to succeed, but it failed
			//
			LogTestCaseInfo.dwErrorType = ERROR_API_FAILED;
			LogTestCaseInfo.dwWinError = dwWinError;
		}
		else
		{
			if (dwWinError != ptc->dwErrorCode)
			{
				//
				// Test failed as expected, but returned the wrong
				// error code.
				//
				LogTestCaseInfo.dwWinError = dwWinError;
				LogTestCaseInfo.dwErrorType = ERROR_WRONG_ERROR_CODE;
			}

			// 
			// Otherwise, the test failed as expected, and it
			// returned the correct error code.
			//
			else
			{
				LogTestCaseInfo.fPass = TRUE;
			}
		}
	}
	else
	{
		if (! ptc->fExpectSuccess)
		{
			// 
			// The test was expected to fail, but it succeeded.
			//
			LogTestCaseInfo.dwErrorType = ERROR_API_SUCCEEDED;
		}

		//
		// Otherwise, the test succeeded as expected.
		//
		else
		{
			LogTestCaseInfo.fPass = TRUE;
		}
	}

	//
	// Now dwErrorType will be non-zero in any of three cases:
	// 1) The API should have succeeded, but failed
	// 2) The API should have failed, but succeeded
	// 3) The API failed as expected, but returned the wrong error code
	//
	if (0 != LogTestCaseInfo.dwErrorType)
	{
		LogTestCaseInfo.dwErrorLevel = ptc->dwErrorLevel;
		LogTestCaseInfo.dwExpectedErrorCode = ptc->dwErrorCode;
		
		//
		// The Microsoft RSA CSP's in Win2K do not return 
		// ERROR_INVALID_HANDLE for most, if not all, of the test cases
		// involving that error code in this test suite.  Therefore,
		// intercept those error here, and flag them as known for that
		// platform.
		//
		if (	(ERROR_WRONG_ERROR_CODE == LogTestCaseInfo.dwErrorType) &&
				(ERROR_INVALID_HANDLE == LogTestCaseInfo.dwExpectedErrorCode))
		{
			LogTestCaseInfo.KnownErrorID = KNOWN_ERRORINVALIDHANDLE;
		}

		//
		// The Microsoft RSA CSP's in Win2K do not return
		// NTE_BAD_KEY for the negative test cases involving that 
		// error code.  Intercept those errors here and flag them as
		// known for that platform.
		//
		if (	(ERROR_WRONG_ERROR_CODE == LogTestCaseInfo.dwErrorType) &&
				(NTE_BAD_KEY == LogTestCaseInfo.dwExpectedErrorCode))
		{
			LogTestCaseInfo.KnownErrorID = KNOWN_NTEBADKEY;
		}

		//
		// The Microsoft RSA CSP's in Win2K do not return NTE_BAD_HASH
		// for the negative test cases involving that error code.  Intercept
		// those errors here and flag them as known for that platform.
		//
		if (	(ERROR_WRONG_ERROR_CODE == LogTestCaseInfo.dwErrorType) &&
				(NTE_BAD_HASH == LogTestCaseInfo.dwExpectedErrorCode))
		{
			LogTestCaseInfo.KnownErrorID = KNOWN_NTEBADHASH;
		}
	}

	// Finally, increment the current test case ID
	++ptc->dwTestCaseID;
	LogTestCaseInfo.dwTestCaseID = ptc->dwTestCaseID;
	LogTestCaseInfo.pParamInfo = pParamInfo;
	LogTestCaseInfo.cParamInfo = cParamInfo;
	LogTestCaseInfo.ApiName = ApiName;
		
	return LogTestCase(&LogTestCaseInfo);
}

//
// Function: InitFailInfo
//
void InitLogTestCaseInfo(
		IN PTESTCASE ptc, 
		OUT PLOGTESTCASEINFO pLogTestCaseInfo)
{
	memset(pLogTestCaseInfo, 0, sizeof(LOGTESTCASEINFO));

	pLogTestCaseInfo->dwErrorLevel = ptc->dwErrorLevel;
	pLogTestCaseInfo->dwExpectedErrorCode = ptc->dwErrorCode;
	pLogTestCaseInfo->dwTestCaseID = ptc->dwTestCaseID;
	pLogTestCaseInfo->KnownErrorID = ptc->KnownErrorID;
	pLogTestCaseInfo->pwszErrorHelp = ptc->pwszErrorHelp;
}

//
// Function: LogBadParam
//
BOOL LogBadParam(
	API_NAME ApiName,
	LPWSTR pwszErrorHelp,
	PTESTCASE ptc)
{
	LOGTESTCASEINFO LogTestCaseInfo;

	++ptc->dwTestCaseID;
	InitLogTestCaseInfo(ptc, &LogTestCaseInfo);

	LogTestCaseInfo.ApiName = ApiName;
	LogTestCaseInfo.dwErrorType = ERROR_BAD_DATA;
	LogTestCaseInfo.pwszErrorHelp = pwszErrorHelp;
	LogTestCaseInfo.fPass = FALSE;

	return LogTestCase(&LogTestCaseInfo);
}

//
// Function: LogProvEnumalgsEx
//
void LogProvEnumalgsEx(PROV_ENUMALGS_EX *pData)
{
	LPWSTR pwszAlgType		= NULL;
	LPWSTR pwszName			= MkWStr(pData->szName);
	LPWSTR pwszLongName		= MkWStr(pData->szLongName);
	
	// Determine the algorithm type.
	switch(GET_ALG_CLASS(pData->aiAlgid)) 
	{
	case ALG_CLASS_DATA_ENCRYPT: pwszAlgType = L"Encrypt  ";
		break;
	case ALG_CLASS_HASH:         pwszAlgType = L"Hash     ";
		break;
	case ALG_CLASS_KEY_EXCHANGE: pwszAlgType = L"Exchange ";
		break;
	case ALG_CLASS_SIGNATURE:    pwszAlgType = L"Signature";
		break;
	default:                     pwszAlgType = L"Unknown  ";
	}
	
	// Print information about the algorithm.
	ezLogMsg(
		LOG_INFO, 
		NULL, 
		NULL, 
		__LINE__, 
		L"Algid:%8.8xh, Bits:%-4d, %-4d - %-4d, Type:%s",
		pData->aiAlgid, 
		pData->dwDefaultLen, 
		pData->dwMinLen, 
		pData->dwMaxLen,
		pwszAlgType);

	ezLogMsg(
		LOG_INFO, 
		NULL, 
		NULL, 
		__LINE__, 
		L"  Name: %s  LongName: %s Protocols: 0x%x",
		pwszName, 
		pwszLongName, 
		pData->dwProtocols);

	free(pwszName);
	free(pwszLongName);
}

//
// Function: LogProvEnumalgs
// Purpose: Log the contents of a PROV_ENUMALGS struct
//
void LogProvEnumalgs(PROV_ENUMALGS *pData)
{
	LPWSTR pwszAlgType		= NULL;
	LPWSTR pwszName			= MkWStr(pData->szName);

	// Determine the algorithm type.
	switch(GET_ALG_CLASS(pData->aiAlgid)) 
	{
	case ALG_CLASS_DATA_ENCRYPT: pwszAlgType = L"Encrypt  ";
		break;
	case ALG_CLASS_HASH:         pwszAlgType = L"Hash     ";
		break;
	case ALG_CLASS_KEY_EXCHANGE: pwszAlgType = L"Exchange ";
		break;
	case ALG_CLASS_SIGNATURE:    pwszAlgType = L"Signature";
		break;
	default:                     pwszAlgType = L"Unknown  ";
	}

	// Print information about the algorithm.
	ezLogMsg(
		LOG_INFO, 
		NULL, 
		NULL, 
		__LINE__, 
		L"Algid:%8.8xh, Bits:%-4d, Type:%s, NameLen:%-2d, Name:%s",
		pData->aiAlgid, 
		pData->dwBitLen, 
		pwszAlgType, 
		pData->dwNameLen,
		pwszName);

	free(pwszName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\test\testsuit\ezlog\ezlog.h ===
/*++

  EZLOG.H

  Logging abstraction API rebuilt from the ground up.  This should be 
  considered a replacement for NTLOG.

  Copyright (C) 1997 Microsoft Corporation, all rights reserved

  Created, 11/08/1997 by DavidCHR

  --*/

#ifndef __INC_EZLOG_H__
#define __INC_EZLOG_H__ 1

#ifdef __cplusplus
#define CPPONLY(x) x
#define EZ_EXTERN_C extern "C"
#else
#define CPPONLY(x) 
#define EZ_EXTERN_C 
#endif

/* All ezlog APIs are extern "C" and __cdecl. */

#define EZLOGAPI EZ_EXTERN_C BOOL __cdecl

/* LOGGING LEVELS (feel free to define your own-- see ezOpenLog):
  
   These we keep manually in sync with NTLOG.H, in case someone decides
   to use this system as a drop-in replacement for NTLOG.

   They are listed in order of precedence-- if a test logs a block, 
   it takes precedence over a PASS or a SEV[x] */

//                                      NTLOG-eq. prec. flags

#define EZLOG_ABORT     0x00000001L  // TLS_ABORT  500 TE_ABORT    
#define EZLOG_BLOCK     0x00000400L  // TLS_BLOCK  400 Attempted
#define EZLOG_SEV1      0x00000002L  // TLS_SEV1   300 Attempted
#define EZLOG_SEV2      0x00000004L  // TLS_SEV2   200 Attempted
#define EZLOG_SEV3      0x00000008L  // TLS_SEV3   100 Attempted
#define EZLOG_WARN      0x00000010L  // TLS_WARN    50 successful, TE_WARN
#define EZLOG_PASS      0x00000020L  // TLS_PASS    10 successful, DEFAULT
#define EZLOG_SKIPPED   0x00004000L  //             1  SKIPPED
#define EZLOG_INFO      0x00002000L  // TLS_INFO      -- nonresultant
#define EZLOG_DEBUG     0x00001000L  // TLS_TESTDEBUG -- nonresultant

// ezOpenLog flags:

#define EZLOG_OPT_APPENDLOG  0x001 /* Append to an existing log--
				      (create if it doesn't exist) */
#define EZLOG_OPT_KEEP_TRACK 0x002 /* keep track of block names and 
				      results.  If you don't specify this,
				      the logging data will just be sent
				      to the log file.

				      It should be noted that this will
				      cause memory to be allocated for each
				      block for which we are keeping track,
				      so if you have thousands and thousands
				      of blocks with really really long names,
				      use of this flag should be discouraged.

				      */
  
#define EZLOG_OUTPUT_STDOUT  0x004 // send output additionally to stdout
#define EZLOG_OUTPUT_STDERR  0x008 // as above, but to stderr (mixable)
#define EZLOG_USE_MY_LEVELS  0x010 /* use specified levels in whatever
				      order: [levelnumber] [levelname]
				      [precedence] [flags] --
				      terminate with zero levelnumber. */

// the logging level flags are (so far):

#define EZLOG_LFLAG_DEBUGBREAK 0x001 // DebugBreak() on invocation

#define EZLOG_LFLAG_RED        0x002 // print logging messages in this color
#define EZLOG_LFLAG_YELLOW     0x004 // print logging messages in this color
#define EZLOG_LFLAG_BLUE       0x008 // print logging messages in this color
#define EZLOG_LFLAG_GREEN      0x010 // print logging messages in this color

/* these loglevel flags deal with the way managers want regressions returned:

   if the logging levels passed to ezOpenLog include at least one invocation
   of these, ezCloseLog will construct a table of %passed/%attempted
   variations.   This table is built according to a variation's output
   logging level-- a failure would have EZLOG_LFLAG_ATTEMPTED only,
   a pass would have ATTEMPTED | SUCCESSFUL, and a BLOCK wouldn't have
   either one. */

#define EZLOG_LFLAG_ATTEMPTED  0x020 
#define EZLOG_LFLAG_SUCCESSFUL 0x040

#define EZLOG_LFLAG_SKIPPED    0x080 /* variations logged with this logging
					level are ignored for the purposes
					of computing percentages for other
					logging levels (e.g.: */

/* for a table with three passes, one failure and two "skipped" blocks,
   we'd see:

Pass:    3/4 (75%)
Failure: 1/4 (25%)
Skipped: 2/6 (33%) NOTE: these were not considered in other results. 

   If there were multiple logging level types with "skipped" flags, they'd
look something like this (although I doubt anyone will need this):

Pass:    3/4 (75%)
Failure: 1/4 (25%)
OneSkip: 2/8 (25%) NOTE: not considered part of the regression
TwoSkip: 2/8 (25%) NOTE: not considered part of the regression

*/

#define EZLOG_LFLAG_NONRESULTANT 0x100 /* Use this to indicate that receipt
					  of a log event at this level does
					  not affect the outcome of a test
					  block.  the NTLOG "SYSTEM", "INFO",
					  and "DEBUG" levels are examples
					  of this.

					  note that precedence is ignored
					  for nonresultant levels.

					  If you're wondering what the point
					  of this flag is, then don't worry
					  about it ;-) */

/* the NOT_CONSOLE / NOT_LOGFILE flags are useful for logging events that
   are VERY prolific (and not useful in case a test fails, for instance,
   so you wouldn't want them on the console), or events that give the test
   status (so you wouldn't need them in the log file). */

#define EZLOG_LFLAG_NOT_CONSOLE 0x200  /* do not send this logging event to
					  the console. */

#define EZLOG_LFLAG_NOT_LOGFILE 0x400  /* do not send it to the logfile */
					  
#define EZLOG_LFLAG_REPORT_INVOCATIONS 0x800 /* if this flag is specified,
						invocations of this logging
						level will be reported on
						even if no variation actually
						has it as a result
						(normally, only variation
						resultant logging levels
						are printed) 
						
						This makes the most sense
						when combined with LFLAG_
						NONRESULTANT.  Otherwise,
						the output may be confusing. */

#define EZLOG_LFLAG_TE_WARN  0x1000 /* For Test-Enterprise.  This specifies
				       that the given logging level should
				       be treated as a warning for TE
				       purposes.

				       If this level is combined with 
				       LFLAG_ATTEMPTED or LFLAG_SUCCESSFUL,
				       TE_WARN takes precedence, since TE
				       doesn't recognize successful warnings.*/

#define EZLOG_LFLAG_TE_ABORT 0x2000 /* Also for TE.  This specifies that
				       the given logging level should be
				       treated as an ABORT for TE purposes.
				       See the TE documentation for what
				       this means. 

				       If this level is combined with 
				       LFLAG_ATTEMPTED or LFLAG_SUCCESSFUL,
				       TE_ABORT takes precedence, since TE
				       doesn't recognize ABORT in conjunction
				       with anything else. */
#define EZLOG_EXIT_ON_FAIL   0x020 /* exit() on failure of any base logging
				      function (except ezCloseLog if you 
				      specify EZCLOSELOG_FAIL_IF... flags).

				      Since most of the functions can only
				      fail when there isn't enough memory or
				      similar critical error, most tests 
				      will probably want this.

				      EXCEPTION: don't do this for stress
				      programs, for obvious reasons. */

#define EZLOG_NO_DEFAULT_LEVELS  0x040 /* ignore default levels--
					  this is useless by itself */
#define EZLOG_USE_ONLY_MY_LEVELS 0x050 /* ignore the default logging level
					  definitions and use only the ones
					  specified on the argument list. */
					 
#define EZLOG_GIVE_ME_A_HANDLE   0x080 /* return a handle to the log, rather
					  than setting the default log--

					  most clients will want this */

#define EZLOG_OPENCLOSE_FILES    0x100 /* leave file descriptors closed
					  when they're not in use.  Open
					  them for the duration of the 
					  logging attempt, then close them
					  afterwards.

					  This is very slow, so don't use
					  it unless you're worried that
					  your tests can crash the system */

#define EZLOG_INCREMENT_FILENAME 0x200 /* if the filename exists, increment
					  it-- if the filename is "ezlog.log"
					  
					  then the log will try:

					  ezlog.log.1
					  ezlog.log.2
					  ...

					  ezlog.log.99999...

					  until it gets a unique filename or
					  gets an error other than that the
					  file already exists. */

#define EZLOG_USE_INDENTATION    0x400  /* causes messages in blocks
					   to be indented one space from
					   the block start/end:

					   block 1
					    block 1.1
					     messages for 1.1
					     block 1.1.1
					      messages for 1.1.1
					     end   1.1.1
					     block 1.1.2
					     end   1.1.2
					    end   1.1
					   end   1
					   */

#define EZLOG_REPORT_BLOCKCLOSE 0x800  /* stylistic determination--
					  causes the ENDS of blocks to
					  be logged as well as the beginning.

					  e.g:

					  Starting MyBlockName
					  MyBlockName completed

					  */

#define EZLOG_DISTINGUISH_ENDPOINTS     0x1000 /* prints newlines or dashes
						  (or something similar, but
						  probably newlines) before
						  and after block-opens 
						  (and block-closes if 
						  EZLOG_REPORT_BLOCKCLOSE
						  is specified). 

						  This keeps people like
						  RuiM from having to manually
						  insert them. */

#define EZLOG_LEVELS_ARE_MASKABLE       0x2000 /* if this is set, then
						  the logging api assume
						  that each bit in a logging
						  mask is unique-- this 
						  is the default unless you
						  use EZLOG_USE_MY_LEVELS.

						  unique/discrete masks
						  are all nonrepeated
						  single-bit values.

						  This isn't yet supported.

						  See the example below */


#define EZLOG_LEVELS_ARE_DISCRETE_MASKS EZLOG_LEVELS_ARE_MASKABLE

                                        /* "Discrete" has different meanings 
					   to different people.
					   So use EZLOG_LEVELS_ARE_MASKABLE 
					   instead. */


#if 0 // EXAMPLE:

/* These levels are nondiscrete because MY_FAIL has more than one bit
   in its mask (0x1 and 0x2).  It also conflicts with both MY_PASS and
   MY_WARN. */

#define MY_PASS 1 // 0001
#define MY_WARN 2 // 0010
#define MY_FAIL 3 // 0011

/* These levels ARE discrete masks, because no mask contains bits from
   any other. */

#define MY_PASS 0x1 // 0001 <-- only one bit is set
#define MY_WARN 0x2 // 0010 <-- only one bit is set
#define MY_FAIL 0x4 // 0100 <-- only one bit is set

#endif

#define EZLOG_FORMAT_BUG_NUMBERS 0x4000 /* adds a string to format the
					   given bug number as an additional
					   line.  This should be a printf
					   format string-- the bug number
					   is a ULONG, so %ld will work
					   to replace it.  The default is
					   just "%ld".  For convenience,
					   we insert the following constant
					   for NT bugs: */

/* We define the following well-known bug strings that can change
   over time-- the idea is that rather than having to recompile your
   code, all you have to do is relink (or grab a new DLL) when the
   URL changes. */

#define EZLOG_WELL_KNOWN_NTBUG_STRING 0x1

#define NTBUG_FMT_STRINGA ((LPSTR)  EZLOG_WELL_KNOWN_NTBUG_STRING )
#define NTBUG_FMT_STRINGW ((LPWSTR) EZLOG_WELL_KNOWN_NTBUG_STRING )

#define EZLOG_LOG_EVERYTHING    0x8000 /* by default, unknown logging levels
					  (other than zero) are ignored.
					  If you specify this flag, ALL levels
					  will be logged, although unknown
					  levels will not be saved as block
					  results. */

#define EZLOG_OUTPUT_RESULTS   0x10000 /* causes the current block result
					  to be printed with the logging
					  output:

   without:

compat.c  4   passing-message
compat.c  22  failing-message
compat.c  29  another failing-message

   with either this:

compat.c 4  PASS -> PASS passing-message
compat.c 22 PASS -> SEV2 failing-message
compat.c 29 SEV2 -> SEV2 another failing-message

   or this: (I haven't decided which yet)

compat.c 4  PASS passing-message
compat.c 22 SEV2 failing-message
compat.c 29 SEV2 another failing-message

   This is on by default when EZLOG_USE_MY_LEVELS is NOT specified and when
   using the NTLOG compatibility APIs.  The reasoning behind this is that
   the default logging levels and the NTLOG logging levels are of a fairly
   tame length, and they're justified based on the maximum string-length.

   e.g. if you add a logging level named "REALLYLONG", the
   above messages would look like this:
      
compat.c 4        PASS ->       PASS passing-message
compat.c 22       PASS ->       SEV2 failing-message
compat.c 29       SEV2 ->       SEV2 another failing-message

   ... because REALLYLONG is so much longer than PASS and SEV2.

*/

#define EZLOG_NO_FILE_OUTPUT   0x20000 /* Do not send ANY output to the 
					  logfile.  This is the equivalent
					  of specifying LFLAG_NOT_LOGFILE
					  to every logging level--

					  this is useful for test apps that
					  have a large base of logging apis
					  that need to be modified for, say,
					  stress operation. */

#define EZLOG_NO_CONSOLE_OUTPUT 0x40000 /* just like NO_FILE_OUTPUT, but 
					   for the console.  This is like
					   specifying LFLAG_NOT_CONSOLE 
					   to every logging level. */

#define EZLOG_BLOCKNAME_IN_MSGS 0x80000 /* include the current blockname
					   in any logging messages.
					   This is useful for tests that
					   perform multiple variations
					   simultaneously, to distinguish
					   messages intended for one 
					   variation from messages intended
					   for another variation. 

					   This flag is useless without
					   EZLOG_KEEP_TRACK. */
					  
#define EZLOG_DONT_TRUNCATE_FILENAMES 0x100000 /* WITHOUT this switch,
						  ezlog will collapse
						  pathnames to filenames:

						  foo\bar\baz.c --> baz.c

						  WITH this switch,
						  ezlog will print

						  foo\bar\baz.c.

						  This is only desireable if
						  you have lots and lots
						  of identical filenames. */

#define EZLOG_ADD_THREAD_ID 0x00200000 /* Add the current threadId to the
					  beginning of each logging message */

#define EZLOG_ADD_TIMESTAMP 0x00400000 /* add the current time to the
					  beginning of each logging message*/

#define EZLOG_NO_IMPLIED_NEWLINES 0x00800000 /* allows the caller to control
						newlines in functions.  This
						is very simplistic.

						If this flag is on, then we
						don't add newlines to every
						logmsg.  Furthermore, if the
						format string does not end 
						explicitly with a newline,
						then we do not decorate further
						logging messages (assuming 
						they don't pass file and line)
						until a newline-terminated
						message is received.

						If this flag is off, then
						all messages are decorated
						and automatically newline-
						terminated if they aren't
						already. */

#define EZLOG_COUNT_ALL_RESULTANT_INVOCATIONS 0x01000000 
/* This is for users who want to use the invocation
   counting system, but don't want to modify the default
   levels.  In effect, it adds LFLAG_REPORT_INVOCATIONS to
   every RESULTANT loglevel. */

#define EZLOG_TRACK_MESSAGE_RESULTS 0x02000000 /* If this flag is specified,
						  ezlog will save the result-
						  setting message for all
						  blocks.  This has no
						  effect for nonresultant
						  invocations. */

#define EZLOG_CONSOLE_IS_RAW        0x04000000 /* If this flag is specified,
						  ezlog will only send the
						  data that the caller passed
						  in to the console (only
						  useful if OUTPUT_STDOUT or
						  OUTPUT_STDERR is supplied).

						  All other information that
						  ezlog adds (timestamp, thread
						  id, loglevel, file/line) will
						  only be sent to the logfile*/

						

/*------------------------------------------------------------
  EZLOG_FAILURE_CALLBACK_ARG/FUNCTION:

  This function can be passed in with an EZOPENLOG_DATA version 3
  or higher.  It lets applications do things if ezlog encounters
  something it can't handle, like an inability to open the logfile,
  memory allocation failure, etc.

  This is an extension of the old EZLOG_EXIT_ON_FAIL (above), because
  it gives applications the ability to terminate on their own, after
  possibly cleaning up any runtime cruft. */
  
#ifndef EZLOG_FAILURE_CALLBACK_ARG_VERSION
#define EZLOG_FAILURE_CALLBACK_ARG_VERSION 1
#endif

#ifndef __INC_EZMSG_H__
typedef ULONG EZLOG_MSGID, *PEZLOG_MSGID;
#endif

typedef struct {

  IN  ULONG Version;         /* ezLog will set this to whatever
				version is current.  Fields will
				only be ADDED to the structure, so
				if the version is in the future,
				ignore the extraneous fields. */
  
  IN  EZLOG_MSGID MessageId; /* What problem caused us to call this
				function.  See ezmsg.h for a list. */

} EZLOG_FAILURE_CALLBACK_ARGS, *PEZLOG_FAILURE_CALLBACK_ARGS;

typedef EZLOG_FAILURE_CALLBACK_FUNCTION( IN PEZLOG_FAILURE_CALLBACK_ARGS );
typedef EZLOG_FAILURE_CALLBACK_FUNCTION *PEZLOG_FAILURE_CALLBACK_FUNCTION;


/* Declare the function data requirements.  This is necessary because
   resdll.h and ezdef.h have circular dependencies. */

struct __ezreport_function_data; // forward.  fleshed out in resdll.h below

typedef VOID (__ezlog_report_function)( IN struct __ezreport_function_data *);
typedef __ezlog_report_function EZLOG_REPORT_FUNCTION, *PEZLOG_REPORT_FUNCTION;

/* ------------------------------------------------------------ */

/* Here, we doubly-include ezdef.h, which includes everything that
   is unicode/ansi sensitive.  We control the means by which
   the ansi and unicode data are selected by defining
   LPEZSTR and EZU( x ).  If you are unfamiliar with how
   the C Preprocessor works, just translate LPEZSTR to LPTSTR
   and assume that EZU( foo ) == foo, and you'll be okay. 

   This keeps me from having to doubly-define the whole mess. */

#define LPEZSTR LPSTR
#define EZU( x ) x ## A

#include ".\ezdef.h"

#undef LPEZSTR
#undef EZU

#define LPEZSTR  LPWSTR
#define EZU( x ) x ## W

#include ".\ezdef.h"

#undef LPEZSTR
#undef EZU

#include ".\resdll.h"

EZLOGAPI
ezRecordBug( IN HANDLE hLog,
	     IN ULONG  ulBugIndex );

// ezCloseLog flags:

#if 0 // not actually supported.
#define EZCLOSELOG_FAIL_IF_RESULT_EXISTS 0x001 /* return FALSE if anything in
						  the next mask was returned.
						  (the next argument should
						  then be a mask comprised of
						  EZLOG_BLOCK | ... type 
						  flags, OR user-defined ones.
						  */
#define EZCLOSELOG_PASS_IF_RESULT_EXISTS 0x002 /* opposite of 0x001.  return
						  FALSE if any value NOT 
						  matching the next argument
						  was ever logged. */
#endif

#define EZCLOSELOG_CLOSE_HANDLE          0x008 /* pass in a handle to the
						  log to close-- otherwise,
						  use the default log */

#define EZCLOSELOG_FULL_FILE_REPORT      0x010 /* This overrides the OpenLog
						  cReportBlockThresh, if 
						  defined, making ezlog
						  dump the full version 
						  of the block tree regardless
						  of how long or wide it is.
						  
						  The idea behind this is to
						  still produce summary output
						  in the file, even though it
						  may not be useful at the
						  console. */

#define EZCLOSELOG_CALLER_IS_THREADSAFE 0x020  /* the caller can guarantee 
						  that no other operations
						  are pending on this log
						  handle, which makes it
						  safe to delete some runtime
						  data.

						  If this is not specified,
						  we will leave around some
						  data, specifically a 
						  critical section to ensure
						  that although further 
						  logging calls won't WORK,
						  they also won't AV. */
						  
#define EZCLOSELOG_WARN_OF_UNCLOSED_BLOCKS 0x040 /* If this flag is specified,
						    ezCloseLog will warn the
						    caller with obnoxious 
						    messages if it encounters
						    blocks that are unclosed.

						    Another way of putting it
						    is that by using this flag,
						    you're sure you closed all
						    the block handles, so if
						    ezLog detects that you 
						    didn't, it'll warn you. */


EZLOGAPI
ezCloseLog( IN OPTIONAL ULONG  flags CPPONLY( = 0 ),
	    
	    /* Result flag */
	    /* handle */
	    ... );


typedef enum {

  ezLevelRes_InvocationCount = 0, // returns a ULONG
  ezLevelRes_ResultCount,

  ezLevelRes_UNDEFINED            // must be last!

} ezLevelResults;

EZLOGAPI
ezGetLevelData( IN  HANDLE         hLog, 
		IN  ULONG          LevelId, 
		IN  ezLevelResults infoType,
		IN  OUT size_t     *psize,
		OUT PVOID          pvData ); // should be ULONG size.

typedef enum { // this is the information available on a block.

  ezBlockRes_Outcome = 0,   /* returns a ULONG indicating the current
			       outcome of the block. */
  ezBlockRes_NameA,         // LPSTR
  ezBlockRes_NameW,         // LPWSTR -- not supported under Win95.
  ezBlockRes_ParentBlock,   // hBlock
  ezBlockRes_nChildBlocks,  // ULONG -- count of the below blocks
  ezBlockRes_ChildBlocks,   // vector of hBlocks
  ezBlockRes_ParentLog,     /* hLog -- useful when using a single
			       logging structure (e.g. NULL) */

  // version 2 adds the following:

  ezBlockRes_CurrentBlock,  /* useful when using null hBlocks and hLogs.
			       returns an hBlock. */

#define ezBlockRes_VERSION 2 // update if you add more.

  ezBlockRes_UNDEFINED      // counter-- MUST BE LAST

} ezBlockResults;

EZLOGAPI
ezGetBlockData( IN     HANDLE          hBlock, // pvBlockId
		IN     ezBlockResults  infoType, 
		IN OUT size_t         *pStructureSize,
		OUT    PVOID           pvStructureData );

/* Notes on ezParseBlockTree:

   if the passed-in function returns FALSE, ezParseBlockTree stops
   and returns FALSE immediately.  It returns TRUE only on successful
   parsing of ALL nodes. 

   Note that the algorithm for hitting all the nodes may change, so
   the subject function must NOT make any assumptions about how and
   when it will be called-- only that it will be called on a valid node.

   Note that if hStartingBlock is the hLog, the entire tree will be parsed.

   */

typedef BOOL (ezBlockParserFunction)( IN HANDLE, // hBlock
				      IN PVOID   /* pvUserData */ );

typedef ezBlockParserFunction *pezBlockParserFunction;

EZLOGAPI
ezParseBlockTree( IN HANDLE                 hStartingBlock,
		  IN pezBlockParserFunction pfParser,
		  IN PVOID                  pvUserData );
		       

// Flags to ezStartBlock (see ezdef.h)

#define EZBLOCK_TRACK_SUBBLOCKS     0x001
#define EZBLOCK_OUTCOME_INDEPENDENT 0x002 /* outcome of this block is 
					     independent of the sub-block's
					     outcome */

EZLOGAPI
ezFinishBlock( IN OPTIONAL HANDLE hBlock );

#define EZ_DEF NULL, TEXT(__FILE__), __LINE__ /* default pvBlockId, file,
						 and line number for 
						 ezLogMsg */

  // backwards compatibility:

#define EZ_DEFAULT NULL, __FILE__, __LINE__ /* default pvBlockId, file,
					       and line number for ezLogMsg */

#ifdef UNICODE
#define ezLogMsg               ezLogMsgW
#define vezLogMsg              vezLogMsgW
#define ezOpenLog              ezOpenLogW
#define ezStartBlock           ezStartBlockW
#define NTBUG_FMT_STRING       NTBUG_FMT_STRINGW
#define ezOpenLogEx            ezOpenLogExW
#define ezBlockRes_Name        ezBlockRes_NameW

typedef EZLOG_OPENLOG_DATAW    EZLOG_OPENLOG_DATA,    *PEZLOG_OPENLOG_DATA;
typedef EZLOG_LEVEL_INIT_DATAW EZLOG_LEVEL_INIT_DATA, *PEZLOG_LEVEL_INIT_DATA;

#else

#define vezLogMsg              vezLogMsgA
#define ezLogMsg               ezLogMsgA
#define ezOpenLog              ezOpenLogA
#define ezStartBlock           ezStartBlockA
#define NTBUG_FMT_STRING       NTBUG_FMT_STRINGA
#define ezOpenLogEx            ezOpenLogExA
#define ezBlockRes_Name        ezBlockRes_NameA

typedef EZLOG_OPENLOG_DATAA    EZLOG_OPENLOG_DATA,    *PEZLOG_OPENLOG_DATA;
typedef EZLOG_LEVEL_INIT_DATAA EZLOG_LEVEL_INIT_DATA, *PEZLOG_LEVEL_INIT_DATA;
#endif

#undef CPPONLY

#endif // multiple-include protection
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\test\testsuit\logging.h ===
#ifndef __LOGGING__H__
#define __LOGGING__H__

#include <windows.h>
#include <ezlog.h>
#include "cspstruc.h"

#define STRING_TRUE									L"True"
#define STRING_FALSE								L"False"
#define TEST_CASE_SEPARATOR							L"----------------------------------------"

#define BUFFER_LENGTH								1024

//
// ------------
// Error Levels
// ------------
//
#define CSP_ERROR_NO_ERROR							0x00000000 
#define CSP_PASS									0x00000001
#define CSP_ERROR_WARNING							0x00000002 
#define CSP_ERROR_CONTINUE							0x00000004
#define CSP_ERROR_API								0x00000008
#define CSP_ERROR_TEST_LEVEL						0x00000010
#define CSP_ERROR_CSP_CLASS							0x00000020
#define CSP_ERROR_TEST_SUITE						0x00000040

#define LOG_API_NAME_CONSOLE						0x00000100
#define LOG_API_PARAMETER_CONSOLE					0x00000200
#define LOG_INFO_CONSOLE							0x00000400
#define LOG_SEPARATOR_CONSOLE						0x00000800

#define LOG_API_NAME								0x00010000
#define LOG_API_PARAMETER							0x00020000
#define LOG_INFO									0x00040000
#define LOG_USER_OPTION								0x00080000
#define LOG_SEPARATOR								0x00100000
#define LOG_USER_PROTECTED_KEY						0x00200000

//
// This array is needed so that error levels can be indexed in order
// of increasing severity.
//
static DWORD g_rgErrorLevels [] =
{
	CSP_ERROR_WARNING,		CSP_ERROR_CONTINUE,
	CSP_ERROR_API,			CSP_ERROR_TEST_LEVEL,
	CSP_ERROR_CSP_CLASS,	CSP_ERROR_TEST_SUITE
};

//
// -----------------
// Defines for EZLOG
// -----------------
//
#define LOGFILE										L"csptestsuite.log"

//
// The EZLog output settings 
//
static EZLOG_LEVEL_INIT_DATA g_EzLogLevels [] = 
{
	{	LOG_API_NAME_CONSOLE,
		L"API",
		0,
		EZLOG_LFLAG_NONRESULTANT
	},
	{	LOG_API_PARAMETER_CONSOLE,
		L"PARA",
		0,
		EZLOG_LFLAG_NONRESULTANT
	},
	{	LOG_INFO_CONSOLE,
		L"INFO",
		0,
		EZLOG_LFLAG_NONRESULTANT
	},
	{	LOG_SEPARATOR_CONSOLE,
		L"----",
		0,
		EZLOG_LFLAG_NONRESULTANT
	},
	{	LOG_API_NAME,
		L"API",
		0,
		EZLOG_LFLAG_NONRESULTANT | EZLOG_LFLAG_NOT_CONSOLE
	},
	{	LOG_API_PARAMETER,
		L"PARA",
		0,
		EZLOG_LFLAG_NONRESULTANT | EZLOG_LFLAG_NOT_CONSOLE
	},
	{	LOG_INFO,
		L"INFO",
		0,
		EZLOG_LFLAG_NONRESULTANT | EZLOG_LFLAG_NOT_CONSOLE
	},
	{	LOG_USER_OPTION,
		L"OPT",
		0,
		EZLOG_LFLAG_NONRESULTANT
	},
	{	LOG_SEPARATOR,
		L"----",
		0,
		EZLOG_LFLAG_NONRESULTANT | EZLOG_LFLAG_NOT_CONSOLE
	},
	{	LOG_USER_PROTECTED_KEY,
		L"KEY",
		0,
		EZLOG_LFLAG_NONRESULTANT
	},
	{	CSP_PASS,
		L"PASS",
		CSP_PASS,
		EZLOG_LFLAG_ATTEMPTED | EZLOG_LFLAG_SUCCESSFUL | EZLOG_LFLAG_NOT_CONSOLE
	},
	{	CSP_ERROR_WARNING,
		L"WARN",
		CSP_ERROR_WARNING,
		EZLOG_LFLAG_ATTEMPTED | EZLOG_LFLAG_SUCCESSFUL | EZLOG_LFLAG_NOT_CONSOLE
	},
	{	CSP_ERROR_CONTINUE,
		L"ERR1",
		CSP_ERROR_CONTINUE,
		EZLOG_LFLAG_ATTEMPTED
	},
	{	CSP_ERROR_API,
		L"ERR2",
		CSP_ERROR_API,
		EZLOG_LFLAG_ATTEMPTED 
	},
	{	CSP_ERROR_TEST_LEVEL,
		L"ERR3",
		CSP_ERROR_TEST_LEVEL,
		EZLOG_LFLAG_NONRESULTANT 
	},
	{	CSP_ERROR_CSP_CLASS,
		L"ERR4",
		CSP_ERROR_CSP_CLASS,
		EZLOG_LFLAG_NONRESULTANT 
	},
	{	CSP_ERROR_TEST_SUITE,
		L"ERR5",
		CSP_ERROR_TEST_SUITE,
		EZLOG_LFLAG_NONRESULTANT 
	},
	{	0, L"", 0, 0 }
};

//
// Function: IncrementErrorLevel
// Purpose: Increase the severity of the specified error level by 
// one step.
//
DWORD IncrementErrorLevel(DWORD dwErrorLevel);

//
// Defines for error results
//
#define ERROR_API_SUCCEEDED							1
#define ERROR_API_FAILED							2
#define ERROR_WRONG_ERROR_CODE						3
#define ERROR_WIN32_FAILURE							4
#define ERROR_WRONG_SIZE							5
#define ERROR_BAD_DATA								6
#define ERROR_LIST_TOO_SHORT						7
#define ERROR_REQUIRED_ALG							8

//
// Defines for the types of test cases
//
#define TEST_CASES_POSITIVE							1
#define TEST_CASES_NEGATIVE							2
#define TEST_CASES_SCENARIO							3
#define TEST_CASES_INTEROP							4

//
// Enum for identifying API's
//
typedef enum _API_NAME
{
	API_CRYPTACQUIRECONTEXT = 1,
	API_CRYPTCREATEHASH,
	API_CRYPTDECRYPT,
	API_CRYPTDERIVEKEY,
	API_CRYPTDESTROYHASH,
	API_CRYPTDESTROYKEY,
	API_CRYPTENCRYPT,
	API_CRYPTEXPORTKEY,
	API_CRYPTGENKEY,
	API_CRYPTGENRANDOM,
	API_CRYPTGETHASHPARAM,
	API_CRYPTGETKEYPARAM,
	API_CRYPTGETPROVPARAM,
	API_CRYPTGETUSERKEY,
	API_CRYPTHASHDATA,
	API_CRYPTHASHSESSIONKEY,
	API_CRYPTIMPORTKEY,
	API_CRYPTRELEASECONTEXT,
	API_CRYPTSETHASHPARAM,
	API_CRYPTSETKEYPARAM,
	API_CRYPTSETPROVPARAM,
	API_CRYPTSIGNHASH,
	API_CRYPTVERIFYSIGNATURE,
	API_CRYPTDUPLICATEHASH,
	API_CRYPTDUPLICATEKEY,
	API_CRYPTCONTEXTADDREF,

	API_MEMORY,
	API_DATACOMPARE,
	API_GETDESKTOPWINDOW
} API_NAME;

//
// ---------------------------
// Defines for logging strings
// ---------------------------
//

//
// Struct: FLAGTOSTRING_ITEM
// Purpose: Associate a key value with a string
//
typedef struct _FLAGTOSTRING_ITEM
{
	DWORD dwKey;
	LPWSTR pwszString;
} FLAGTOSTRING_ITEM, *PFLAGTOSTRING_ITEM;

#define FLAGTOSTRING_SIZE(item)		(sizeof(item) / sizeof(FLAGTOSTRING_ITEM))

//
// Logging API
//

typedef enum _FLAG_TYPE
{
	Maskable = 1,
	ExactMatch
} FLAG_TYPE;

//
// Struct: API_PARAM_INFO
// Purpose: Store parameter data for logging each call to a CSP entry
// point.
//
typedef enum _PARAM_TYPE
{
	Handle = 1,
	Pointer,
	Dword,
	String,
	Boolean
} PARAM_TYPE;

typedef BOOL (*PFN_FLAGTOSTRING)(DWORD, LPWSTR);

typedef struct _API_PARAM_INFO
{
	LPWSTR pwszName;
	PARAM_TYPE Type;

	union Parameter
	{
        DWORD dwParam;
        ULONG_PTR pulParam;
		PBYTE pbParam;
		LPWSTR pwszParam;
		BOOL fParam;
	};

	PFN_FLAGTOSTRING pfnFlagToString;
	BOOL fPrintBytes;
	PDWORD pcbBytes;
	PBYTE pbSaved;
} API_PARAM_INFO, *PAPI_PARAM_INFO;

#define APIPARAMINFO_SIZE(X)		(sizeof(X) / sizeof(API_PARAM_INFO))

//
// Function: FlagToString
// Purpose: Lookup the one or more flag specified by dwFlag in
// rgFlagToString and print the strings to the supplied string
// buffer.
//
BOOL FlagToString(
	IN DWORD dwFlag,
	IN FLAGTOSTRING_ITEM rgFlagToString [],
	IN DWORD cFlagToString,
	OUT WCHAR rgwsz [],
	IN FLAG_TYPE FlagType);

BOOL AcquireContextFlagToString(
	IN DWORD dwFlag, 
	OUT WCHAR rgwsz []);

BOOL GetProvParamToString(
	IN DWORD dwFlag,
	OUT WCHAR rgwsz []);

BOOL SetProvParamToString(
	IN DWORD dwFlag,
	OUT WCHAR rgwsz []);

BOOL AlgidToString(
	IN DWORD dwFlag,
	OUT WCHAR rgwsz []);

BOOL DeriveKeyFlagToString(
	IN DWORD dwFlag,
	OUT WCHAR rgwsz []);

BOOL EncryptFlagToString(
	IN DWORD dwFlag,
	OUT WCHAR rgwsz []);

BOOL  ExportKeyBlobTypeToString (
	IN DWORD dwFlag,
	OUT WCHAR rgwsz []);

BOOL ExportKeyFlagToString (
	IN DWORD dwFlag,
	OUT WCHAR rgwsz []);

BOOL GenKeyFlagToString(
	IN DWORD dwFlag,
	OUT WCHAR rgwsz []);

BOOL HashParamToString(
	IN DWORD dwFlag,
	OUT WCHAR rgwsz []);

BOOL KeyParamToString(
	IN DWORD dwFlag,
	OUT WCHAR rgwsz []);

BOOL KeyParamModeToString(
	IN DWORD dwFlag,
	OUT WCHAR rgwsz []);

BOOL KeyParamPermissionToString(
	IN DWORD dwFlag,
	OUT WCHAR rgwsz []);

BOOL ProvParamEnumFlagToString(
	IN DWORD dwFlag,
	OUT WCHAR rgwsz []);

BOOL ProvParamSecDescrFlagToString(
	IN DWORD dwFlag,
	OUT WCHAR rgwsz []);

BOOL ProvParamImpTypeToString(
	IN DWORD dwFlag,
	OUT WCHAR rgwsz []);

BOOL HashDataFlagToString(
	IN DWORD dwFlag,
	OUT WCHAR rgwsz []);

BOOL HashSessionKeyFlagToString(
	IN DWORD dwFlag,
	OUT WCHAR rgwsz []);

BOOL ImportKeyFlagToString(
	IN DWORD dwFlag,
	OUT WCHAR rgwsz []);

BOOL SignHashFlagToString(
	IN DWORD dwFlag,
	OUT WCHAR rgwsz []);

BOOL TestCaseTypeToString(
	IN DWORD dwTestCaseType,
	OUT WCHAR rgwsz []);

BOOL ApiNameToString(
	API_NAME ApiName,
	OUT WCHAR rgwsz[]);
//
// Function: LogCleanupParamInfo
// Purpose: Free any memory allocated by LogInitParamInfo in the 
// pParamInfo array.
//
void LogCleanupParamInfo(
	IN OUT PAPI_PARAM_INFO pParamInfo,
	IN DWORD cParamInfo);

//
// Function: LogInitParamInfo
// Purpose: Search the pParamInfo array for entries with the 
// fPrintBytes flag set.  For valid entries, the pbParam data member
// is copied to the pbSaved member.
//
BOOL LogInitParamInfo(
	IN OUT PAPI_PARAM_INFO pParamInfo,
	IN DWORD cParamInfo,
	IN PTESTCASE ptc);

//
// Function: LogParamInfo
// Purpose: Parse an array of type API_PARAM_INFO and write its contents
// to the log file.
//
void LogParamInfo(
	PAPI_PARAM_INFO pParamInfo,
	DWORD cParamInfo,
	BOOL fLogToConsole);

//
// Function: LogInfo
// Purpose: Write an informational message to the log.
//
void LogInfo(IN LPWSTR pwszInfo);

//
// Function: LogUserOption
// Purpose: Report a test suite option as it has been 
// selected by the user (or defaulted) to the log.
//
void LogUserOption(IN LPWSTR pwszOption);

//
// Function: LogTestCaseSeparator
// Purpose: Write a blank, separator line to the logfile.
//
BOOL LogTestCaseSeparator(BOOL fLogToConsole);

//
// Function: LogCreatingUserProtectedKey
// Purpose: Write to the console (and log) that the next
// Crypto API call will be CryptGenKey CRYPT_USER_PROTECTED
// and that the operator should expected to see the user 
// protected UI.
//
void LogCreatingUserProtectedKey(void);

//
// Function: LogProvEnumalgsEx
// Purpose: Log the contents of a PROV_ENUMALGS_EX struct
//
void LogProvEnumalgsEx(PROV_ENUMALGS_EX *pProvEnumalgsEx);

//
// Function: LogProvEnumalgs
// Purpose: Log the contents of a PROV_ENUMALGS struct
//
void LogProvEnumalgs(PROV_ENUMALGS *pProvEnumalgs);

//
// Struct: LOGINIT_INFO
// Purpose: This is data that is required by LogInit in order
// to initialize the Test Suite logging routines.
//
typedef struct _LOGINIT_INFO
{
	//
	// Data about the CSP under test
	//
	LPWSTR pwszCSPName;
	DWORD dwCSPExternalType;
	DWORD dwCSPInternalType;
	DWORD dwCSPInternalClass;

	//
	// Data about the CSP to be used for 
	// interoperability testing, if applicable.
	//
	LPWSTR pwszInteropCSPName;
	DWORD dwInteropCSPExternalType;
} LOGINIT_INFO, *PLOGINIT_INFO;

BOOL LogInit(
		IN PLOGINIT_INFO pLogInitInfo);

BOOL LogClose(void);

BOOL LogBeginCSPClass(DWORD dwClass);

BOOL LogEndCSPClass(DWORD dwClass);

BOOL LogBeginTestLevel(DWORD dwLevel);

BOOL LogEndTestLevel(DWORD dwLevel);

BOOL LogBeginAPI(API_NAME ApiName, DWORD dwAPISubset);

BOOL LogEndAPI(API_NAME ApiName, DWORD dwAPISubset);

BOOL LogPass(DWORD dwTestCaseID);

BOOL LogBeginScenarioTest(LPWSTR pwszDescription);

BOOL LogEndScenarioTest(void);

BOOL LogBeginInteropTest(LPWSTR pwszDescription);

BOOL LogEndInteropTest(void);

//
// Struct: LOGTESTCASEINFO
// Purpose: Data required to write information about a test case to the
// log file.
//
typedef struct _LOGTESTCASEINFO
{
	BOOL fPass;
	API_NAME ApiName;
	BOOL fReturnVal;
	DWORD dwErrorType;
	DWORD dwErrorLevel;
	DWORD dwTestCaseID;
	KNOWN_ERROR_ID KnownErrorID;
	DWORD dwWinError;
	DWORD dwExpectedErrorCode;
	LPWSTR pwszErrorHelp;
	
	PAPI_PARAM_INFO pParamInfo;
	DWORD cParamInfo;
} LOGTESTCASEINFO, *PLOGTESTCASEINFO;

//
// Function: LogTestCase
// Purpose: Parse the pLogTestCaseInfo struct and perform the appropriate actions:
//  - Log a Pass, Warning, or Error
//  - Format the test case information and print it to the log.
//
BOOL LogTestCase(PLOGTESTCASEINFO pLogTestCaseInfo);

//
// Function: LogApiFailure
// Purpose: Create a LOGTESTCASEINFO struct based on the function 
// parameters and call LogTestCase.
//
BOOL LogApiFailure(
	IN API_NAME ApiName,
	IN DWORD dwErrorType,
	IN OUT PTESTCASE ptc);

DWORD LogGetInteropProvType(void);

LPWSTR LogGetInteropProvName(void);

DWORD LogGetProvType(void);

LPWSTR LogGetProvName(void);

//
// ----------------
// Logging wrappers
// ----------------
//

//
// Function: CheckAndLogStatus
// Purpose: Calls the appropriate logging routines based on the provided parameters.
//
BOOL CheckAndLogStatus(
	IN API_NAME ApiName,
	IN BOOL fCallSucceeded, 
	IN OUT PTESTCASE ptc, 
	IN PAPI_PARAM_INFO pParamInfo,
	IN DWORD cParamInfo);

//
// Function: InitFailInfo
// Purpose: Populate the fields of the LOGTESTCASEINFO struct 
// from the corresponding fields of the TESTCASE struct.
//
void InitLogTestCaseInfo(
	IN PTESTCASE ptc, 
	OUT PLOGTESTCASEINFO pLogTestCaseInfo);

//
// Function: LogBadParam
// Purpose: Log the failure of a Key/Hash parameter test
// case.
//
BOOL LogBadParam(
	API_NAME ApiName,
	LPWSTR pwszErrorHelp,
	PTESTCASE ptc);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\test\testsuit\utils.c ===
//
// Utils.c
//
// 7/6/00   dangriff    created
//

#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include "utils.h"
#include "cspstruc.h"
#include "csptestsuite.h"
#include "logging.h"

//
// Function: BuildAlgList
//
BOOL BuildAlgList(HCRYPTPROV hProv, PCSPINFO pCSPInfo)
{
    DWORD cb                            = 0;
    DWORD dwFlags                       = 0;
    PALGNODE pAlgNode                   = NULL;
    PTESTCASE ptc                       = &(pCSPInfo->TestCase);
    PROV_ENUMALGS_EX ProvEnumalgsEx;
    
    // Enumerate all supported algs
    dwFlags = CRYPT_FIRST;
    cb = sizeof(ProvEnumalgsEx);
    memset(&ProvEnumalgsEx, 0, cb);

    LogTestCaseSeparator(FALSE); // Log a blank line first
    LogInfo(L"CryptGetProvParam PP_ENUMALGS_EX: enumerating supported algorithms");

    while (CryptGetProvParam(
            hProv, 
            PP_ENUMALGS_EX, 
            (PBYTE) &ProvEnumalgsEx,
            &cb, 
            dwFlags))
    {
        // Increment the test case counter for every enumerated alg
        ++ptc->dwTestCaseID;

        if (NULL == pCSPInfo->pAlgList)
        {
            //
            // Allocate first node at user's pointer
            //
            LOG_TRY(TestAlloc(
                &((PBYTE) pCSPInfo->pAlgList), 
                sizeof(ALGNODE), 
                ptc));

            pAlgNode = pCSPInfo->pAlgList;
        }
        else
        {
            //
            // Add another node to the list
            //
            LOG_TRY(TestAlloc(
                &((PBYTE) pAlgNode->pAlgNodeNext), 
                sizeof(ALGNODE), 
                ptc));

            pAlgNode = pAlgNode->pAlgNodeNext;
        }

        // Zero out the ALGNODE struct
        memset(pAlgNode, 0, sizeof(ALGNODE));

        // Copy the ProvEnumalgsEx data into the ALGNODE struct
        memcpy(&(pAlgNode->ProvEnumalgsEx), &ProvEnumalgsEx, cb);

        // 
        // We just need to know if the current algorithm is considered "known"
        // by the Test Suite.  First, search through the list of REQUIRED algs, 
        // and assume that all REQUIRED algs are also KNOWN.
        //
        if (TRUE == (pAlgNode->fIsRequiredAlg = 
            IsRequiredAlg(
                ProvEnumalgsEx.aiAlgid, 
                pCSPInfo->dwExternalProvType)))
        {
            pAlgNode->fIsKnownAlg = TRUE;
        }
        else
        {
            //
            // Now search through the remaining KNOWN, non-required, algorithms
            //
            pAlgNode->fIsKnownAlg = 
                IsKnownAlg(
                    ProvEnumalgsEx.aiAlgid,
                    pCSPInfo->dwExternalProvType);
        }       
        
        if (CRYPT_FIRST == dwFlags)
        {
            dwFlags = 0;
        }

        LogProvEnumalgsEx(&ProvEnumalgsEx);
    }

    if (ERROR_NO_MORE_ITEMS != GetLastError())
    {
        ptc->dwErrorCode = ERROR_NO_MORE_ITEMS;
        ptc->fExpectSuccess = FALSE;
        ptc->pwszErrorHelp = L"CryptGetProvParam PP_ENUMALGS_EX: Wrong error code returned at end of enumeration";
        
        //
        // Log a FAIL
        //
        return CheckAndLogStatus(
            API_CRYPTGETPROVPARAM,
            FALSE,
            ptc,
            NULL,
            0);
    }
    
    //
    // Log a PASS
    //
    /*
    return CheckAndLogStatus(
        API_CRYPTGETPROVPARAM,
        TRUE,
        ptc,
        NULL,
        0);
    */
    return TRUE;
    
Cleanup:
    return FALSE;
}

//
// Function: CreateNewInteropContext
//
BOOL CreateNewInteropContext(
        OUT HCRYPTPROV *phProv, 
        IN LPWSTR pwszContainer, 
        IN DWORD dwFlags,
        IN PTESTCASE ptc)
{
    BOOL fSuccess               = FALSE;
    //DWORD dwError             = 0;
    DWORD dwProvType            = LogGetInteropProvType();
    LPWSTR pwszProvName         = LogGetInteropProvName();
    BOOL fSavedExpectSuccess    = ptc->fExpectSuccess;
    DWORD dwSavedErrorLevel     = ptc->dwErrorLevel;

    //
    // All calls to CreateNewInteropContext are considered critical, since
    // they are typically followed by additional dependent test code.  Set a high
    // failure rate for this reason.
    //
    ptc->dwErrorLevel = CSP_ERROR_API;
    ptc->fExpectSuccess = TRUE;

    if (CRYPT_VERIFYCONTEXT != (dwFlags & CRYPT_VERIFYCONTEXT))
    {
        TAcquire(
            phProv,
            pwszContainer,
            pwszProvName,
            dwProvType,
            CRYPT_DELETEKEYSET,
            ptc);

        dwFlags &= CRYPT_NEWKEYSET;
    }

    fSuccess = TAcquire(
                phProv,
                pwszContainer,
                pwszProvName, 
                dwProvType,
                dwFlags,
                ptc);

    ptc->dwErrorLevel = dwSavedErrorLevel;
    ptc->fExpectSuccess = fSavedExpectSuccess;

    return fSuccess;
}

//
// Function: CreateNewContext
//
BOOL CreateNewContext(
        OUT HCRYPTPROV *phProv, 
        IN LPWSTR pwszContainer, 
        IN DWORD dwFlags,
        IN PTESTCASE ptc)
{
    BOOL fSuccess               = FALSE;
    //DWORD dwError             = 0;
    DWORD dwProvType            = LogGetProvType();
    LPWSTR pwszProvName         = LogGetProvName();
    BOOL fSavedExpectSuccess    = ptc->fExpectSuccess;
    DWORD dwSavedErrorLevel     = ptc->dwErrorLevel;

    //
    // All calls to CreateNewContext are considered critical, since
    // they are typically followed by additional dependent test code.  Set a high
    // failure rate for this reason.
    //
    ptc->dwErrorLevel = CSP_ERROR_API;
    ptc->fExpectSuccess = TRUE;
    
    if ( ! (dwFlags & CRYPT_VERIFYCONTEXT))
    {
        //
        // Call the CryptAcquireContext API directly (instead of
        // TAcquire) since this key container may not already exist.
        //
        if (dwFlags & CRYPT_MACHINE_KEYSET)
        {
            CryptAcquireContext(
                phProv,
                pwszContainer,
                pwszProvName,
                dwProvType,
                CRYPT_DELETEKEYSET | CRYPT_MACHINE_KEYSET);
        }
        else
        {
            CryptAcquireContext(
                phProv,
                pwszContainer,
                pwszProvName,
                dwProvType,
                CRYPT_DELETEKEYSET);
        }
        
        if (FALSE == ptc->fTestingUserProtected &&
            FALSE == ptc->fSmartCardCSP)
        {
            //
            // Unless the above flag is set, all non-VERIFYCONTEXT context handles 
            // will be created with with the CRYPT_SILENT flag in order to 
            // maximize the test exposure to this flag.
            // 
            dwFlags |= CRYPT_SILENT;
        }
    }

    fSuccess = TAcquire(
        phProv,
        pwszContainer,
        pwszProvName, 
        dwProvType,
        dwFlags,
        ptc);

    ptc->dwErrorLevel = dwSavedErrorLevel;
    ptc->fExpectSuccess = fSavedExpectSuccess;

    return fSuccess;
}

// 
// Function: CreateNewKey
//
BOOL CreateNewKey(
        IN HCRYPTPROV hProv, 
        IN ALG_ID Algid, 
        IN DWORD dwFlags, 
        OUT HCRYPTKEY *phKey,
        IN PTESTCASE ptc)
{
    BOOL fSuccess               = FALSE;
    //DWORD dwError             = 0;
    BOOL fSavedExpectSuccess    = ptc->fExpectSuccess;
    DWORD dwSavedErrorLevel     = ptc->dwErrorLevel;

    //
    // All calls to CreateNewKey are considered critical, since
    // they are typically followed by additional dependent test code.  Set a high
    // failure rate for the next CSP call for this reason.
    //
    ptc->dwErrorLevel = CSP_ERROR_API;
    ptc->fExpectSuccess = TRUE;

    fSuccess = TGenKey(
                hProv, 
                Algid,
                dwFlags,
                phKey, 
                ptc);

    ptc->dwErrorLevel = dwSavedErrorLevel;
    ptc->fExpectSuccess = fSavedExpectSuccess;

    return fSuccess;
}

//
// Function: CreateNewHash
//
BOOL CreateNewHash(
        IN HCRYPTPROV hProv, 
        IN ALG_ID Algid, 
        OUT HCRYPTHASH *phHash,
        IN PTESTCASE ptc)
{
    BOOL fSuccess               = FALSE;
    //DWORD dwError             = 0;
    BOOL fSavedExpectSuccess    = ptc->fExpectSuccess;
    DWORD dwSavedErrorLevel     = ptc->dwErrorLevel;

    //
    // All calls to CreateNewHash are considered critical, since
    // they are typically followed by additional dependent test code.  Set a high
    // failure rate for the next CSP call for this reason.
    //
    ptc->dwErrorLevel = CSP_ERROR_API;
    ptc->fExpectSuccess = TRUE;

    fSuccess = TCreateHash(
                hProv,
                Algid,
                0, // hKey
                0, // dwFlags
                phHash, 
                ptc);

    ptc->dwErrorLevel = dwSavedErrorLevel;
    ptc->fExpectSuccess = fSavedExpectSuccess;

    return fSuccess;
}

//
// Function: TestAlloc
//
BOOL TestAlloc(OUT PBYTE *ppb, IN DWORD cb, PTESTCASE ptc)
{
    if (NULL == (*ppb = (PBYTE) malloc(cb)))
    {
        LogApiFailure(
            API_MEMORY,
            ERROR_API_FAILED,
            ptc);
        
        return FALSE;
    }

    memset(*ppb, 0, cb);

    return TRUE;
}

//
// Function: AlgListIterate
//
BOOL AlgListIterate(
        IN PALGNODE pAlgList,
        IN PFN_ALGNODE_FILTER pfnFilter,
        IN PFN_ALGNODE_PROC pfnProc,
        IN PVOID pvProcData,
        IN PTESTCASE ptc)
{
    BOOL fErrorOccurred = FALSE;
    PALGNODE pAlgNode = NULL;

    for (pAlgNode = pAlgList; pAlgNode != NULL; pAlgNode = pAlgNode->pAlgNodeNext)
    {
        if ( ((*pfnFilter)(pAlgNode)) )
        {
            if (! ((*pfnProc)(pAlgNode, ptc, pvProcData)) )
            {
                fErrorOccurred = TRUE;
            }
        }
    }

    if (fErrorOccurred)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

//
// Function: HashAlgFilter
//
BOOL HashAlgFilter(PALGNODE pAlgNode)
{
    if (    (ALG_CLASS_HASH == GET_ALG_CLASS(pAlgNode->ProvEnumalgsEx.aiAlgid)) &&
            pAlgNode->fIsKnownAlg)
    {
        return ! MacAlgFilter(pAlgNode);
    }

    return FALSE;
}



//
// Function: MacAlgFilter
//
BOOL MacAlgFilter(PALGNODE pAlgNode)
{
    if (    ((CALG_MAC == pAlgNode->ProvEnumalgsEx.aiAlgid) ||
            (CALG_HMAC == pAlgNode->ProvEnumalgsEx.aiAlgid)) &&
            pAlgNode->fIsKnownAlg)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//
// Function: BlockCipherFilter
//
BOOL BlockCipherFilter(PALGNODE pAlgNode)
{
    if (    (ALG_TYPE_BLOCK == GET_ALG_TYPE(pAlgNode->ProvEnumalgsEx.aiAlgid)) &&
            pAlgNode->fIsKnownAlg)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//
// Function: DataEncryptFilter
//
BOOL DataEncryptFilter(PALGNODE pAlgNode)
{
    if (    (ALG_CLASS_DATA_ENCRYPT == GET_ALG_CLASS(pAlgNode->ProvEnumalgsEx.aiAlgid)) &&
            pAlgNode->fIsKnownAlg)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//
// Function: AllEncryptionAlgsFilter
// Purpose: Same algorithm set as DataEncryptFilter above,
// with the addition of the RSA key-exchange alg.
//
BOOL AllEncryptionAlgsFilter(PALGNODE pAlgNode)
{
    return (CALG_RSA_KEYX == pAlgNode->ProvEnumalgsEx.aiAlgid) ||
        DataEncryptFilter(pAlgNode);
}

//
// Function: RSAAlgFilter
//
BOOL RSAAlgFilter(PALGNODE pAlgNode)
{
    return (CALG_RSA_KEYX == pAlgNode->ProvEnumalgsEx.aiAlgid) ||
        (CALG_RSA_SIGN == pAlgNode->ProvEnumalgsEx.aiAlgid);
}

//
// Function: PrintBytes
//
#define CROW 8
void PrintBytes(LPWSTR pwszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;
    WCHAR rgwsz[1024];

    wsprintf(rgwsz, L"  %s, %d bytes ::", pwszHdr, cbSize);
    LogInfo(rgwsz);

    while (cbSize > 0)
    {
        // Start every row with an extra space
        wsprintf(rgwsz, L" ");

        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i < cb; i++)
            wsprintf(rgwsz + wcslen(rgwsz), L" %02x", pb[i]);
        for (i = cb; i < CROW; i++)
            wsprintf(rgwsz + wcslen(rgwsz), L"   ");
        wsprintf(rgwsz + wcslen(rgwsz), L"    '");
        for (i = 0; i < cb; i++)
        {
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                wsprintf(rgwsz + wcslen(rgwsz), L"%c", pb[i]);
            else
                wsprintf(rgwsz + wcslen(rgwsz), L".");
        }
        LogInfo(rgwsz);

        pb += cb;
    }
}

//
// Function: MkWStr
//
LPWSTR MkWStr(LPSTR psz)
{
    int     cWChars = 0;
    LPWSTR   pwsz = NULL;
    
    if (psz == NULL)
    {
        return NULL;
    }
    
    cWChars = MultiByteToWideChar(
        0,
        0,
        psz,
        -1,
        NULL,
        0);
    
    if (NULL == (pwsz = (LPWSTR) malloc(cWChars * sizeof(WCHAR))))
    {
        return NULL;
    }
    
    MultiByteToWideChar(
        0,
        0,
        psz,
        -1,
        pwsz,
        cWChars);
    
    return(pwsz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\test\testsuit\ezlog\ezdef.h ===
/*++

  EZDEF.H

  Copyright (C) 1999 Microsoft Corporation, all rights reserved.

  DESCRIPTION: ezlog unicode/ansi neuter definitions.
  NOTE:        this file has no multi-include protection, because
               it is intended to be included multiple times WITHIN
	       ezlog.h.  Do not include this file directly.

  Created, Sep 3, 1999 by DavidCHR.

--*/  

typedef struct {

  ULONG   MaskId;
  LPEZSTR LevelName;
  ULONG   Precedence;
  ULONG   Flags;

} EZU(EZLOG_LEVEL_INIT_DATA), *EZU(PEZLOG_LEVEL_INIT_DATA);

#ifndef EZLOG_OPENLOG_DATA_VERSION
#define EZLOG_OPENLOG_DATA_VERSION 5
#endif

#ifndef EZLOG_OPENLOG_DATA_REVISION
#define EZLOG_OPENLOG_DATA_REVISION 1
#endif

/* revision 1 ************************************************************
   
   We use "REVISION" not "VERSION" because we can ADD more fields to
   our heart's content, just incrementing the version.  However, once
   we need to eliminate fields, the structure is no longer backwards
   compatible.  

   With any luck, we'll never have to remove fields. 

   *************************************************************/

typedef struct EZU(__ezlog_openlog_data_revision1) {

    // ---------------------- version 1 ------------------------

    IN ULONG                       Version;
    IN LPEZSTR                     LogFileName;
    IN OPTIONAL LPEZSTR            BugFormatString; 
    
    IN ULONG                       cLevels;
    IN EZU(PEZLOG_LEVEL_INIT_DATA) pLevels;
    
    IN ULONG                       Flags; // same as ezOpenLog flags.
    
    IN OUT PHANDLE                 phLog; /* if you want a log handle back,
					     specify this here. */
      
    // ------------------ end of version 1 --------------------
#if EZLOG_OPENLOG_DATA_VERSION >= 2
    // ---------------------- version 2 ------------------------

    IN LONG                        cReportBlockThresh; 

    /* cReportBlockThresh tells ezCloseLog whether to report
       a full-blown statistics table.  Basically, the report table
       is only generated if there are fewer than this number of blocks
       generated by the test.  
       
       Specials include the following: */
    
#ifndef  EZLOG_REPORT_ALL_BLOCKS
# define EZLOG_REPORT_ALL_BLOCKS 0 /* this is the default-- all blocks
				      are reported.  This is what you
				      get if you specify version 1. */
# define EZLOG_REPORT_NO_BLOCKS -1 /* don't ever report any block
				      results. */
#endif

#endif // ------------------ end of version 2 --------------------
#if EZLOG_OPENLOG_DATA_VERSION >= 3
    //     ------------------ version 3 ---------------------------

    OUT HANDLE hOutLog; /* This is set to the logging handle value
			   (which is created regardless of whether
			   you actually want one back).  This is 
			   added for VB callers who apparently 
			   can't pass in a pointer to the handle
			   to receive it, and might be more convenient
			   for some callers regardless. */

    IN LONG    cReportBlockWidthThresh;

    /* cReportBlockWidthThresh is identical to cReportBlockThresh
       (above), except that it applies to the width.  If the block
       table would be more than this wide, we don't show it at all.
       If you want to use this, a good value for it is 80. */

    PEZLOG_FAILURE_CALLBACK_FUNCTION pFailureCallback;

#endif  // ------------------ end of version 3 --------------------
#if EZLOG_OPENLOG_DATA_VERSION >= 4
    //     ------------------ version 4 ---------------------------

    /* These control whether, which, and how often ezlog calls a list of
       user-supplied callback functions to receive the report information.
       This can also be done by specifying a list of DLLs per "resdll.h". */
       
    IN OPTIONAL ULONG                   cPeriodicCallbacks;
    IN OPTIONAL PEZLOG_REPORT_FUNCTION *pPeriodicCallbacks;
    IN OPTIONAL DWORD                   msCallbackPeriod; // in milliseconds
    
    /* These control whether and which callbacks are invoked when the log
       is terminated.  
       This can also be done by specifying a list of DLLs per "resdll.h". */
       
    IN OPTIONAL ULONG                   cExitCallbacks;
    IN OPTIONAL PEZLOG_REPORT_FUNCTION *ppExitCallbacks;

    //     ------------------ end of version 4 --------------------
#endif
#if EZLOG_OPENLOG_DATA_VERSION >= 5
    //     ------------------ version 5 ---------------------------

    IN OPTIONAL LPTSTR                  BlockStartText; // default: "STARTING"
    IN OPTIONAL LPTSTR                  BlockFinishText;// default: "FINISHED"
    
    /* these specify a hint regarding the average precision for a filename
       or line number.  If you specify a file length less than that of your
       BlockStartText or BlockFinishText, the hint will be increased to
       that length.

       If the given hint is less than the actual string length of the given
       string (file or stringized line), we INCREASE the hint for subsequent
       calls, so that filenames/line numbers remain properly aligned in the
       logfile. 

       This behavior obviously does not extend to the below flags */

#ifndef EZLOG_DISABLE_FILE_AND_LINE
#define EZLOG_DISABLE_FILE_AND_LINE ((LONG)(-1)) /* Don't print either value.
						    Effective if either hint
						    is set to this. */

#endif // EZLOG_DISABLE_FILE_AND_LINE

    IN          LONG                    FileLengthHint;
    IN          LONG                    LineLengthHint;

    // ------------------ end of version 5 --------------------
#endif
} EZU(EZLOG_OPENLOG_DATA_REVISION1), *EZU(PEZLOG_OPENLOG_DATA_REVISION1);

typedef EZU(EZLOG_OPENLOG_DATA_REVISION1)
  EZU(EZLOG_OPENLOG_DATA), 
  *EZU(PEZLOG_OPENLOG_DATA);

/* ezOpenLogEx{A|W} is fairly identical to ezOpenLog (it performs
   all the same functions), but the interface is more modular so that
   callers who want to define their own levels, or are paranoid about
   type checking and don't like typeless parameters (like me) can
   have type checking and a less cumbersome level system. */

EZLOGAPI
EZU(ezOpenLogEx)( IN OUT EZU(PEZLOG_OPENLOG_DATA) pData );

EZLOGAPI
EZU(ezOpenLog)( IN           LPEZSTR LogFileName,
		IN  OPTIONAL ULONG   Options,
		
		/* IN  levels */
		/* OUT PHANDLE phLog */
		/* IN  NTBUG_FMT_STRING */
		
		... );



EZLOGAPI
EZU(ezStartBlock)( IN  OPTIONAL HANDLE hParent, /* Must be specified as
						  NULL (default) or a
						  blockid */
		   OUT OPTIONAL PHANDLE phBlockId,
		   IN  OPTIONAL ULONG  flags     ,
		   IN  OPTIONAL ULONG  defOutcome,

		   /* the default outcome, if defOutcome is zero, will be set
		      to the most innocuous level. */

		   IN           LPEZSTR  fmtForBlockName,
		   ... ); 


#ifdef _VA_LIST_DEFINED

/* va_list pointers must be passed in-- va_list may/may not be a structure
   depending on your architecture and/or compiler.  I realize that C
   specs make it valid to pass, but it still generates a compiler warning.
   If you don't need the va_list, pass in NULL-- the functions will do the
   right thing. 

   Get these functions by including <stdarg.h> */

typedef BOOL __cdecl 
EZU(VEZLOGMSG_FN)( IN          ULONG,   // level maskid
		   IN OPTIONAL HANDLE,  // hBlock/hLog
		   IN          LPEZSTR, // __FILE__
		   IN          ULONG,   // __LINE__
		   IN          LPEZSTR, // fmt
		   IN          va_list * ); // pva

#else

/* This function type still needs to be defined if you include "resdll.h",
   so we typedef it to VOID.  This way, ezLog can use function pointers
   that reference vezLogMsg without having to worry about whether the 
   coder who #included this file can understand them-- they'll just be
   PVOID values to that code. */

typedef VOID EZU(VEZLOGMSG_FN);

#endif

typedef EZU(VEZLOGMSG_FN) *EZU(PVEZLOGMSG_FN);

EXTERN_C 
EZU(VEZLOGMSG_FN) EZU(vezLogMsg);

#if 0
EZU(vezLogMsg)( IN          ULONG    level,
		IN OPTIONAL HANDLE   hBlockId, // or hLog-- either works.
		IN          LPEZSTR  file,  // __FILE__
		IN          ULONG    line,  // __LINE__
		IN          LPEZSTR  fmt,
		IN          va_list *pva );
#endif


typedef BOOL __cdecl EZU(EZLOGMSG_FN)( IN          ULONG,   // level maskid
				       IN OPTIONAL HANDLE,  // hBlock/hLog
				       IN          LPEZSTR, // __FILE__
				       IN          ULONG,   // __LINE__
				       IN          LPEZSTR, // fmt
				       ... );

typedef EZU(EZLOGMSG_FN) *EZU(PEZLOGMSG_FN);

EXTERN_C
EZU(EZLOGMSG_FN) EZU(ezLogMsg);

#if 0
EZLOGAPI
EZU(ezLogMsg)( IN          ULONG  level,     /* EZLOG_PASS, etc. or a 
					       user-defined mask */
	       IN OPTIONAL HANDLE  hBlockId, // or hLog
	       IN          LPEZSTR file,  // __FILE__
	       IN          ULONG line,  // __LINE__
	       IN          LPEZSTR fmt, 
	       ... );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\test\testsuit\utils.h ===
//
// Utils.h
// 
// 7/6/00	dangriff	created
//

#ifndef __UTILS__H__
#define __UTILS__H__

#include <windows.h>
#include "cspstruc.h"

//
// Function: TestAlloc
// Purpose: Malloc and zero-ize the requested memory.  Log an error 
// if malloc fails.
//
BOOL TestAlloc(
		OUT PBYTE *ppb, 
		IN DWORD cb, 
		PTESTCASE ptc);

//
// Function: PrintBytes
// Purpose: Display bytes to the console for debugging
//
void PrintBytes(LPWSTR pwszHdr, BYTE *pb, DWORD cbSize);

//
// Function: MkWStr
// Purpose: Convert the psz parameter into a Unicode string.
// Return the Unicode string.
//
LPWSTR MkWStr(LPSTR psz);

//
// -----------------------------
// System/Test Version Utilities
// -----------------------------
//

//
// Function: IsVersionCorrect
// Purpose: Check that the specified version information
// is at least as high a Rev as the system running this process.
//
// If the system is newer than the specified information, return FALSE.  
// Otherwise, return TRUE.
//
/*
BOOL IsVersionCorrect(
		IN DWORD dwMajorVersion,
		IN DWORD dwMinorVersion,
		IN DWORD dwServicePackMajor,
		IN DWORD dwServicePackMinor);
*/

//
// -------------------------------------------------------
// ALGLIST 
// A linked list structure for storing PP_ENUMALGS_EX data
// -------------------------------------------------------
//

//
// Function: BuildAlgList
// Purpose: Using the user-supplied hProv, call CryptGetProvParam repeatedly with 
// the PP_ENUMALGS_EX flag until ERROR_NO_MORE_ITEMS is returned.  For each 
// algorithm returned, add a new ALGNODE to the pCSPInfo->pAlgNode list.
//
// Note that the string pointers in the ProvEnumalgsEx struct in each ALGNODE
// will be valid only until the CSP dll unloads.
//
BOOL BuildAlgList(
		IN HCRYPTPROV hProv, 
		IN OUT PCSPINFO pCSPInfo);

//
// Function: PrintAlgList
// Purpose: Display the list of ALGNODE structs in pretty form.
//
void PrintAlgList(PALGNODE pAlgList);

//
// Function: AlgListIterate
// Purpose: Iterate through each item in pAlgList.  Each list item is passed to the 
// pfnFilter function.  If the function returns true for that item, the item is passed
// to the pfnProc function.
//
// AlgListIterate returns TRUE if pfnProc returns TRUE for every item passed to it.
//

typedef BOOL (*PFN_ALGNODE_FILTER)(PALGNODE pAlgNode);

typedef BOOL (*PFN_ALGNODE_PROC)(PALGNODE pAlgNode, PTESTCASE ptc, PVOID pvProcData);

BOOL AlgListIterate(
		IN PALGNODE pAlgList,
		IN PFN_ALGNODE_FILTER pfnFilter,
		IN PFN_ALGNODE_PROC pfnProc,
		IN PVOID pvProcData,
		IN PTESTCASE ptc);

//
// Function: HashAlgFilter
// Purpose: If pAlgNode represents a known hash algorithm, return
// TRUE, otherwise return FALSE.  Mac algorithms are excluded
// from this set (return FALSE).
//
BOOL HashAlgFilter(PALGNODE pAlgNode);

//
// Function: MacAlgFilter
// Purpose: If pAlgNode represents a known Mac algorithm, return
// TRUE, otherwise return FALSE
//
BOOL MacAlgFilter(PALGNODE pAlgNode);

//
// Function: BlockCipherFilter
// Purpose: If pAlgNode represents a known block cipher algorithm, 
// return TRUE, otherwise return FALSE.
//
BOOL BlockCipherFilter(PALGNODE pAlgNode);

//
// Function: DataEncryptFilter
// Purpose: If pAlgNode represents a known data encryption 
// symmetric key algorithm, return TRUE, otherwise return FALSE.
//
BOOL DataEncryptFilter(PALGNODE pAlgNode);

//
// Function: AllEncryptionAlgsFilter
// Purpose: Same algorithm set as DataEncryptFilter above,
// with the addition of the RSA key-exchange alg.
//
BOOL AllEncryptionAlgsFilter(PALGNODE pAlgNode);

//
// Function: RSAAlgFilter
// Purpose: If pAlgNode represents an RSA algorithm, return
// TRUE, otherwise return FALSE
//
BOOL RSAAlgFilter(PALGNODE pAlgNode);

//
// ------------------------------------------------
// Test wrappers for creating crypto object handles
// ------------------------------------------------
//

//
// Function: CreateNewInteropContext
// Purpose: Create a new cryptographic context with the provided
// parameters.  The context will be for the CSP specified by the 
// user at the command line to be the interoperability-test
// provider.
//
BOOL CreateNewInteropContext(
		OUT HCRYPTPROV *phProv, 
		IN LPWSTR pwszContainer, 
		IN DWORD dwFlags,
		IN PTESTCASE ptc);

//
// Function: CreateNewContext
// Purpose: Call CryptAcquireContext with the provided parameters.  If 
// CRYPT_VERIFYCONTEXT is not specified in dwFlags, any existing
// key container named pwszContainer will be deleted first, and the CRYPT_NEWKEYSET
// flag will be used to re-create the container.
//
BOOL CreateNewContext(
		OUT HCRYPTPROV *phProv, 
		IN LPWSTR pwszContainer, 
		IN DWORD dwFlags,
		IN PTESTCASE ptc);

// 
// Function: CreateNewKey
// Purpose: Call CryptGenKey with the provided parameters.
//
BOOL CreateNewKey(
		IN HCRYPTPROV hProv, 
		IN ALG_ID Algid, 
		IN DWORD dwFlags, 
		OUT HCRYPTKEY *phKey,
		IN PTESTCASE ptc);

//
// Function: CreateNewHash
// Purpose: Call CryptCreateHash with the provided parameters.
//
BOOL CreateNewHash(
		IN HCRYPTPROV hProv, 
		IN ALG_ID Algid, 
		OUT HCRYPTHASH *phHash,
		IN PTESTCASE ptc);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\xpress\xdecode.c ===
/* ------------------------------------------------------------------------ */
/*                                                                          */
/*  Copyright (c) Microsoft Corporation, 2000-2001. All rights reserved.    */
/*  Copyright (c) Andrew Kadatch, 1991-2001. All rights reserved.           */
/*                                                                          */
/*  Microsoft Confidential -- do not redistribute.                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */


#include "xprs.h"

#define ALLOCATE_ON_STACK       1

#define MAGIC_DECODE 0x35DEC0DE

typedef struct
{
  struct
  {
    uchar *end, *beg, *careful, *stop, *last;
  } dst;
  struct
  {
    const uchar *end, *beg, *careful, *end_1, *end_tag, *end_bitmask2, *last;
  }
  src;
  int result;
  int eof;
  int magic;
#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
  uint16 table[(1 << DECODE_BITS) + (HUFF_SIZE << 1)];
#endif
} decode_info;

#if CODING == CODING_BY_BIT
static int bit_to_len_initialized = 0;
static uchar bit_to_len1[1 << (9 - MIN_MATCH)];
static uchar bit_to_len2[1 << (9 - MIN_MATCH)];
static void bit_to_len_init (void)
{
  int i, k;
  if (bit_to_len_initialized) return;
  bit_to_len1[0] = 0;
  bit_to_len2[0] = 9 - MIN_MATCH;
  for (k = 1, i = 1 << (8 - MIN_MATCH); i != 0; i >>= 1, ++k)
  {
    memset (bit_to_len1 + i, k, i);
    memset (bit_to_len2 + i, k - 1, i);
  }
  bit_to_len_initialized = 1;
}
#endif

#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)


static int huffman_decode_create (uint16 *table, const uchar *length)
{
  xint i, j, k, last, freq[16], sum[16];

  /* calculate number of codewords                                      */
  memset (freq, 0, sizeof (freq));
  i = HUFF_SIZE >> 1;
  do
  {
    k = length[--i];
    ++freq[k & 0xf];
    ++freq[k >> 4];
  }
  while (i != 0);

  /* handle special case(s) -- 0 and 1 symbols in alphabet              */
  if (freq[0] == HUFF_SIZE)
    goto ok;
  if (freq[0] == HUFF_SIZE - 1)
    goto bad;
#if 0
  {

    if (freq[1] != 1)
      goto bad;
    i = -1; do ++i; while (length[i] == 0);
    k = i << 1;
    if (length[i] != 1) ++k;
    i = 1 << DECODE_BITS;
    do
      *table++ = (uint16) k;
    while (--i > 0);
    goto ok;
  }
#endif

  /* save frequences                    */
  memcpy (sum, freq, sizeof (sum));

  /* check code correctness             */
  k = 0;
  i = 15;
  do
  {
    if ((k += freq[i]) & 1)
      goto bad;
    k >>= 1;
  }
  while (--i != 0);
  if (k != 1)
    goto bad;

  /* sort symbols               */
  k = 0;
  for (i = 1; i < 16; ++i)
    freq[i] = (k += freq[i]);
  last = freq[15];      /* preserve number of symbols in alphabet       */
  i = HUFF_SIZE << 4;
  do
  {
    i -= 1 << 4;
    k = length[i >> 5] >> 4;
    if (k != 0)
      table[--freq[k]] = (uint16) (k | i);
    i -= 1 << 4;
    k = length[i >> 5] & 0xf;
    if (k != 0)
      table[--freq[k]] = (uint16) (k | i);
  }
  while (i != 0);

  /* now create decoding table  */
  k = i = (1 << DECODE_BITS) + (HUFF_SIZE << 1);

  {
    xint n;
    for (n = 15; n > DECODE_BITS; --n)
    {
      j = i;
      while (k > j)
        table[--i] = (uint16) ((k -= 2) | 0x8000);
      for (k = sum[n]; --k >= 0;)
        table[--i] = table[--last];
      k = j;
    }
  }

  j = i;
  i = 1 << DECODE_BITS;
  while (k > j)
    table[--i] = (uint16) ((k -= 2) | 0x8000);

  while (last > 0)
  {
    k = table[--last];
    j = i - ((1 << DECODE_BITS) >> (k & 15));
    do
      table[--i] = (uint16) k;
    while (i != j);
  }
  assert ((i | last) == 0);

ok:
  return (1);

bad:
  return (0);
}


#endif /* CODING */

#if DEBUG
#define RET_OK do {printf ("OK @ %d\n", __LINE__); goto ret_ok;} while (0)
#define RET_ERR do {printf ("ERR @ %d\n", __LINE__); goto ret_err;} while (0)
#else
#define RET_OK goto ret_ok
#define RET_ERR goto ret_err
#endif


#define GET_UINT16(x,p) x = *(__unaligned uint16 *)(p); p += 2


#define COPY_8_BYTES(dst,src) \
  dst[0] = src[0]; dst[1] = src[1]; dst[2] = src[2]; dst[3] = src[3]; \
  dst[4] = src[4]; dst[5] = src[5]; dst[6] = src[6]; dst[7] = src[7]


/* do not use "memcpy" -- it does not work properly if "dst" and "src" are close (overlap) */
#define COPY_BLOCK_SLOW(dst,src,len) \
  if (len > 8) do \
  { \
    COPY_8_BYTES (dst, src); \
    len -= 8; dst += 8; src += 8; \
  } \
  while (len > 8); \
  do \
    *dst++ = *src++, --len; \
  while (len)


#ifndef i386
#define COPY_BLOCK_FAST_8(dst,src) \
  COPY_8_BYTES (dst, src)
#else
#if 0
#define COPY_BLOCK_FAST_8(dst,src) \
  ((__unaligned uint32 *) dst)[0] = ((__unaligned uint32 *) src)[0]; \
  ((__unaligned uint32 *) dst)[1] = ((__unaligned uint32 *) src)[1]
#else
#define COPY_BLOCK_FAST_8(dst,src) \
  ((__unaligned __int64 *) dst)[0] = ((__unaligned __int64 *) src)[0]
#endif
#endif /* i386 */


#define BIORD(bits) \
  (Mask >> (sizeof (Mask) * 8 - (bits)))

#define CONCAT2(x,y) x##y
#define CONCAT(x,y) CONCAT2(x,y)

#define bits_t signed char

#define BIORD_MORE0(bits)                       \
  if ((Bits = (bits_t) (Bits - (bits))) < 0)    \
  {                                             \
    CAREFUL_ERR_IF (src >= info->src.end_1);    \
    Mask += ((ubitmask4) *(__unaligned ubitmask2 *)src) << (-Bits); \
    src += sizeof (ubitmask2);                      \
    Bits += (bits_t) (sizeof (ubitmask2) * 8);      \
  }


#define BIORD_MORE(bits)                        \
  Mask <<= (bits_t)(bits);                      \
  BIORD_MORE0 (bits)


#define BIORD_WORD(result,bits)         \
  result = 1 << (bits);                 \
  if (bits)                             \
  {                                     \
    result += BIORD (bits);             \
    BIORD_MORE (bits);                  \
  }


#define BIORD_DECODE(result,table) {     \
  bits_t __bits;                         \
  result = ((int16 *)(table))[BIORD (DECODE_BITS)]; \
  if (result < 0)                        \
  {                                      \
    Mask <<= DECODE_BITS;                \
    do                                   \
    {                                    \
      result &= 0x7fff;                  \
      if ((bitmask4) Mask < 0) ++result; \
      result = ((int16 *)(table))[result];          \
      Mask <<= 1;                        \
    }                                    \
    while (result < 0);                  \
    __bits = (bits_t)(result & 15);      \
  }                                      \
  else                                   \
  {                                      \
    __bits = (bits_t)(result & 15);      \
    Mask <<= __bits;                     \
  }                                      \
  result >>= 4;                          \
  Bits = (bits_t) (Bits - __bits);       \
}                                        \
if (Bits < 0)                            \
{                                                         \
  CAREFUL_ERR_IF (src >= info->src.end_1);                \
  if (CODING == CODING_HUFF_ALL)                          \
    {CAREFUL_IF (src >= info->src.careful, rdmore);}      \
  Mask += ((ubitmask4) *(__unaligned ubitmask2 *)src) << (-Bits); \
  src += sizeof (ubitmask2);                              \
  Bits += (bits_t) (sizeof (ubitmask2) * 8);              \
}

#ifdef _MSC_VER
#ifdef _M_IX86
#pragma optimize ("aw", off)
#else
#pragma optimize ("w", off)
#endif /* _M_IX86 */
#endif /* _MSC_VER */

#define CAREFUL 0
#include "xdecode.i"
#define CAREFUL 1
#include "xdecode.i"

#ifdef _MSC_VER
#ifdef _M_IX86
#pragma optimize ("aw", on)
#else
#pragma optimize ("w", on)
#endif /* _M_IX86 */
#endif


int XPRESS_CALL XpressDecode
(
  XpressDecodeStream stream,
  void *orig, int orig_size, int decode_size,
  const void *comp, int comp_size
)
{
  decode_info *info;
  const uchar *src;

#if ALLOCATE_ON_STACK
  decode_info stack_info;
  info = &stack_info;
  info->src.beg = (void *) stream;
#else
  if (stream == 0 || (info = (decode_info *) stream)->magic != MAGIC_DECODE)
    return (-1);
#endif

  if (comp_size == orig_size)
    return (decode_size);

  if (orig_size < comp_size
    || comp_size < 0
    || orig_size <= MIN_SIZE
    || comp_size < MIN_SIZE
  )
    return (-1);

  if (orig_size > BUFF_SIZE || decode_size <= 0)
    return (decode_size);

  src = comp;
  info->dst.beg = orig;
  info->dst.end = (uchar *) orig + orig_size;
  info->dst.stop = (uchar *) orig + decode_size;
  info->src.end = src + comp_size;
  info->src.end_1 = info->src.end - 1;
  info->src.end_tag = info->src.end - (sizeof (tag_t) - 1);
  info->src.end_bitmask2 = info->src.end - (sizeof (bitmask2) - 1);

  // check bounds when we read new mask (at most 8 * sizeof (tag_t)) pointers

  // we may write at most 8 bytes without checks
  #define RESERVE_DST ((8 * 8 + 2) * sizeof (tag_t))
  info->dst.careful = info->dst.beg;
  if (info->dst.stop - info->dst.beg > RESERVE_DST)
    info->dst.careful = info->dst.stop - RESERVE_DST;

  // we may read at most 7 bytes
  #define RESERVE_SRC ((7 * 8 + 2) * sizeof (tag_t))
  info->src.careful = info->src.beg;
  if (info->src.end - info->src.beg > RESERVE_SRC)
    info->src.careful = info->src.end - RESERVE_SRC;

#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
  if (!huffman_decode_create (info->table, src))
    return (-1);
  src += HUFF_SIZE >> 1;
#endif
#if CODING == CODING_BY_BIT
  bit_to_len_init ();
#endif

  info->src.beg = src;
  info->result = 0;
  info->eof = 0;

  do_decode (info);

  if (!info->result || info->dst.last > info->dst.stop || info->src.last > info->src.end
    || (info->dst.stop == info->dst.end && !info->eof)
  )
    return (-1);

  return (decode_size);
}

XpressDecodeStream
XPRESS_CALL
  XpressDecodeCreate
  (
    void *context,                      // user-defined context info (will  be passed to AllocFn)
    XpressAllocFn *AllocFn              // memory allocation callback
  )
{
#if ALLOCATE_ON_STACK
#ifdef _M_IX86
  return ((XpressDecodeStream) 1);
#else
  return ((XpressDecodeStream) (__int64) 1);
#endif
#else
  decode_info *info;
  if (AllocFn == 0 || (info = AllocFn (context, sizeof (*info))) == 0)
    return (0);
  info->magic = MAGIC_DECODE;
  return ((XpressDecodeStream) info);
#endif
}

void
XPRESS_CALL
  XpressDecodeClose
  (
    XpressDecodeStream stream,  // encoder's workspace
    void *context,                      // user-defined context info (will  be passed to FreeFn)
    XpressFreeFn *FreeFn                // callback that releases the memory
  )
{
#if ALLOCATE_ON_STACK
  /* do nothing */
#else
  if (FreeFn != 0 && stream != 0 && ((decode_info *) stream)->magic == MAGIC_DECODE)
  {
    ((decode_info *) stream)->magic = 0;
    FreeFn (context, stream);
  }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\win32\ntcrypto\test\testsuit\ezlog\resdll.h ===
/*++

  RESDLL.H

  Specifications for the RESULTS.DLL method of reporting output.

  This way EZLOG can take an optional DLL with the given input functions,
  and then the caller can determine his own method of summarizing the output.
  
  On the surface, this looks like a frivolous venture.  However, since we
  don't want to force the caller to link with anything special to convert
  from ntLog to ezLog, this is a requirement.  Currently, we force the user
  to link with USER32.LIB, but I couldn't get around that.

  This way, if you want to implement your own stuff, like logging to a 
  separate monitor, or over a TCP connection, you can.

  The DLL is specified by setting the EZLOG_REPORT_DLL variable.  If
  ezlog detects that this environment variable is set, ezReportStats will
  automagically load the DLL and call into it as specified below.

  Copyright (C) 1998 Microsoft Corporation, all rights reserved.

  Created, May 19, 1998 by DavidCHR.

--*/

#ifndef __INC_RESDLL_H__
#define __INC_RESDLL_H__ 1

/*  These two environment variables specify a list of DLLs
    to be called under some circumstances.  The DLL_ENVNAME list
    is called when the log is closed.  The PERIODIC_DLL list is
    called every EZLOG_DLL_PERIOD milliseconds.

    If EZLOG_DLL_PERIOD is not set or zero, the PERIODIC_DLL list
    isn't notified.

    The syntax for the environment variables is:

    list ::= name [, list ]
    name ::= filename [!functionname]

    if !functionname is omitted, EZLOG_DLL_FUNCNAME is assumed.
*/
    

#define EZLOG_DLL_ENVNAME          "EZLOG_REPORT_DLL"
#define EZLOG_PERIODIC_DLL_ENVNAME "EZLOG_PERIODIC_REPORT_DLL"
#define EZLOG_DLL_PERIOD           "EZLOG_DLL_PERIOD"
#define EZLOG_DLL_FUNCNAME         "ezLogUserReport"



typedef struct {

  ULONG Mask;   // e.g. EZLOG_PASS
  ULONG Count;  // number of times this result was recorded.
  
  LPSTR  NameA;
  LPWSTR NameW; // NULL under Win9x.

} EZLOG_RESULT_TYPE, *PEZLOG_RESULT_TYPE;

typedef struct __ezreport_function_data {

  IN ULONG              ulVersionNumber;
  
#define EZLOG_REPORT_VERSION 3

  IN PCHAR               LogFileName;  /* may be NULL if no logfile 
					  was written. */
  IN ULONG               TotalTestBlocks;

  /* These two fields are not currently supported.  Don't use them. */

  IN ULONG               cResults;         
  IN PEZLOG_RESULT_TYPE *ppResults;        
  
  IN ULONG              cAttempted;
  IN ULONG              cSuccessful;

  /* VERSION 2 follows: */

  IN SYSTEMTIME         StartTime, EndTime;

  /* Version 3 follows: */

  IN HANDLE             hLog;       // handle to the logfile.

  /* Note that in order for result-functions to log to the logfile, 
     those DLLs ***MUST*** use the below function pointers, because the 
     file is locked to serialize requests.  If you forget and use the
     standard ezLogMsg functions, a deadlock will occur. */
				       
  IN PEZLOGMSG_FNA      pezLogMsgA;
  IN PEZLOGMSG_FNW      pezLogMsgW;  // NULL on Win9x.
  IN PVEZLOGMSG_FNA     pvezLogMsgA;
  IN PVEZLOGMSG_FNW     pvezLogMsgW; // NULL on Win9x
  
  IN PVOID              pvUserData;  /* This is NULL for DLL-loaded functions,
					but if the caller supplied his own
					callback function, this is the data
					that was passed in. */

} EZLOG_DLL_REPORT, *PEZLOG_DLL_REPORT;


#if 0 // now declared in ezlog.h
/* ezLogUserReport:

   this is the function that the dll must provide.
   ezLog will search for it by name.

   The EZLOG_DLL_REPORT structure will be passed in, fully formed,
   and will be freed when the function returns.

   ezLog is threadsafe, so we will also guarantee that this
   call will never be called by multiple threads simultaneously. */

typedef VOID (__ezlog_report_function)( IN PEZLOG_DLL_REPORT );
typedef __ezlog_report_function EZLOG_REPORT_FUNCTION, *PEZLOG_REPORT_FUNCTION;

#endif

EXTERN_C
EZLOG_REPORT_FUNCTION ezLogUserReport;

#endif // __INC_RESDLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\xpress\xencode.c ===
/* ------------------------------------------------------------------------ */
/*                                                                          */
/*  Copyright (c) Microsoft Corporation, 2000-2001. All rights reserved.    */
/*  Copyright (c) Andrew Kadatch, 1991-2001. All rights reserved.           */
/*                                                                          */
/*  Microsoft Confidential -- do not redistribute.                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */

#include "xprs.h"

#define MAX_CHAIN       9


// Zobrist hashing
#define Z_HASH_SIZE_LOG    (BUFF_SIZE_LOG - 1)
#define Z_HASH_SIZE        (1 << Z_HASH_SIZE_LOG)
#define Z_HASH_SUM(b)      (z_hash_map[0][b[0]] ^ z_hash_map[1][b[1]] ^ z_hash_map[2][b[2]])

// quick hashing
#define Q_HASH_SH1      3
#define Q_HASH_SH2      (Q_HASH_SH1 >> 1)
#define Q_HASH_SUM3(c1,c2,c3) (((c1) << Q_HASH_SH1) + ((c2) << Q_HASH_SH2) + (c3))
#define Q_HASH_SUM(b)   Q_HASH_SUM3 (b[0], b[1], b[2])
#define Q_HASH_SIZE     (Q_HASH_SUM3 (255, 255, 255) + 1)

#define z_hash_t uint16
#define z_index_t uint16

#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
typedef struct huff_node_t huff_node;

struct huff_node_t
{
  huff_node *son[2];
  uxint freq;
  uint16 ch;
  uint16 bits;
};

typedef struct
{
  huff_node buff[2 * HUFF_SIZE], *head[256], **link[256];
} huff_info;
#endif

typedef struct
{
  struct
  {
#if CODING == CODING_BY_BIT
    xint bits;
    uchar *ptr;
#elif CODING & (CODING_DIRECT | CODING_DIRECT2)
    uchar *ptr;
#elif CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
    uxint freq[HUFF_SIZE];
    uxint mask[HUFF_SIZE];
    uchar bits[HUFF_SIZE];
    huff_info info;
    uxint pointers;
    uxint extra;
    uxint masks;
#endif /* CODING */
  } stat;
  xint chain;
  xint max_size;
  struct
  {
    uchar *beg;
    uchar *ptr;
  } comp;
  struct
  {
    z_index_t *hash;
    uchar *beg;
    uchar *ptr;
    uchar *tag_ptr;
    tag_t  tag_mask;
  } temp;
  struct
  {
    xint len;
    xint pos;
  } match;
  struct
  {
    xint   pos;
    xint   size;
    xint   stop;
    xint   progress;
    const uchar *ptr;
    const uchar *end;
    const uchar *end_16;
    const uchar *end_3;
    const uchar *ptr_stop;
  } orig;
} context;


#define v p[-1].c

typedef struct
{
  union
  {
    z_index_t    z_next[16];
    const uchar *q_last[16];
  } x;

  context c;
} prs;

#define MAGIC_ENCODE   0x53E7C0DE

typedef struct
{
  int magic;
  void *memory;
  prs *p;
  uchar *temp;
  unsigned max_size;
  int chain;
} xpress_info;


#if MAX_CHAIN >= 1
static z_hash_t z_hash_map[MIN_MATCH][256];
static int      z_hash_map_initialized = 0;

static void z_hash_map_init (void)
{
  long v1, v2;
  z_hash_t *m;

  if (z_hash_map_initialized)
    return;

  v1 = 0x13579bdfL; v2 = 0x87654321L;
  for (m = z_hash_map[0]; m < z_hash_map[0] + sizeof (z_hash_map) / sizeof (z_hash_map[0][0]); ++m)
  {
    long vv1 = v2, vv2 = v1, d = 0;
    xint i = 32;
    do
    {
      d += 0x9e3779b9L; vv1 += d; vv2 += d;
      v1 += ((v2<<3) + vv1) ^ (v2 + d) ^ ((v2>>5) + vv2);
      v2 += ((v1<<3) + vv2) ^ (v1 + d) ^ ((v1>>5) + vv1);
      --i;
    }
    while (i);
    *m = (z_hash_t) ((v1 += v2) & (Z_HASH_SIZE - 1));
  }

  z_hash_map_initialized = 1;
}

static void z_hash_insert (prs *p)
{
  const uchar *b, *e;
  xint n, h;
  z_index_t *hash = v.temp.hash;

  e = v.orig.end - (MIN_MATCH-1);
  b = v.orig.ptr;
  n = 0;
  for (; b < e; ++b, ++n)
  {
    h = Z_HASH_SUM (b);
    p->x.z_next[n] = hash[h];
    hash[h] = (z_index_t) n;
  }
  e += MIN_MATCH-1;
  for (; b < e; ++b, ++n)
    p->x.z_next[n] = 0;
}
#endif

#if CODING != CODING_BY_BIT

static void tag_write_start (prs *p)
{
  v.temp.tag_ptr = v.temp.ptr;
  v.temp.ptr += sizeof (v.temp.tag_mask);
  v.temp.tag_mask = 1;
}

#if CODING == CODING_HUFF_ALL
#define INC_MASKS ++v.stat.masks
#else
#define INC_MASKS
#endif

#define tag_write(p,ptr,n)                       \
{                                                \
  tag_t __n = n | (v.temp.tag_mask << 1);        \
  if (v.temp.tag_mask < 0)                       \
  {                                              \
    *(__unaligned tag_t *) v.temp.tag_ptr = __n; \
    v.temp.tag_ptr = ptr;                        \
    ptr += sizeof (v.temp.tag_mask);             \
    INC_MASKS;                                   \
    __n = 1;                                     \
  }                                              \
  v.temp.tag_mask = __n;                         \
}

static void tag_write_finish (prs *p)
{
  uchar *ptr = v.temp.ptr;
  do
  {
    tag_write (p, ptr, 1);
  }
  while (ptr == v.temp.ptr);
}

#elif CODING == CODING_BY_BIT

static void tag_write_start (prs *p)
{
  v.temp.tag_ptr = (uchar *) &v.temp.tag_mask;
  v.temp.tag_mask = 0;
  v.stat.bits = 0;
}

#define tag_write(p,ptr,n) do { \
  if (--v.stat.bits < 0) \
  { \
    *(__unaligned tag_t *)v.temp.tag_ptr = v.temp.tag_mask; \
    v.temp.tag_mask = n; \
    v.stat.bits = 8 * sizeof (v.temp.tag_mask) - 1; \
    v.temp.tag_ptr = ptr; \
    ptr += sizeof (v.temp.tag_mask); \
  } \
  v.temp.tag_mask = (v.temp.tag_mask << 1) + (n); \
} while (0)

#define tag_write_mask(p,ptr,n,b) do { \
  if ((v.stat.bits -= (b)) < 0) \
  { \
    *(__unaligned tag_t *)v.temp.tag_ptr = (v.temp.tag_mask << ((b) + v.stat.bits)) \
      + ((n) >> (-v.stat.bits)); \
    v.stat.bits += 8 * sizeof (v.temp.tag_mask); \
    v.temp.tag_mask = (n); \
    v.temp.tag_ptr = ptr; \
    ptr += sizeof (v.temp.tag_mask); \
  } \
  else \
    v.temp.tag_mask = (v.temp.tag_mask << (b)) + (n); \
} while  (0);

static void tag_write_finish (prs *p)
{
  do
    tag_write (p, v.temp.ptr, 1);
  while (v.stat.bits != 0);
  *(__unaligned tag_t *)v.temp.tag_ptr = v.temp.tag_mask;
}

#define write_lit(p,ptr,ch) do {   \
  tag_write (p, ptr, 0);           \
  *ptr++ = (ch);                   \
} while (0)                      

INLINE uchar *write_ptr (prs *p, uchar *ptr, xint offset, xint length)
{
  uxint k;

  --offset;

  k = 2;
  if (offset > 255) k = 3;
  tag_write_mask (p, ptr, k, 2);
  *ptr++ = (uchar) offset;
  if (offset > 255) *ptr++ = (uchar) (offset >>= 8);

  if (length <= 8)
  {
    length -= MIN_MATCH - 1;
    tag_write_mask (p, ptr, 1, length);
  }
  else
  {
    tag_write_mask (p, ptr, 0, (9 - MIN_MATCH));
    if ((length -= 9) < 15)
    {
      if (v.stat.ptr == 0)
      {
        v.stat.ptr = ptr;
        *ptr++ = (uchar) length;
      }
      else
      {
        v.stat.ptr[0] |= length << 4;
        v.stat.ptr = 0;
      }
    }
    else
    {
      length -= 15;
      if (v.stat.ptr == 0)
      {
        v.stat.ptr = ptr;
        *ptr++ = 15;
      }
      else
      {
        v.stat.ptr[0] += 0xf0;
        v.stat.ptr = 0;
      }
      *ptr++ = (uchar) length;
      if (length >= 255)
      {
        ptr[-1] = 255;
        ptr[0] = (uchar) length;
        ptr[1] = (uchar) (length >>= 8);
        ptr += 2;
      }
    }
  }

  return (ptr);
}

#endif

#if CODING & (CODING_DIRECT | CODING_DIRECT2)

#define write_lit(p,ptr,ch) do {   \
  *ptr++ = (ch);                   \
  tag_write (p, ptr, 0);           \
} while (0)

INLINE uchar *write_ptr (prs *p, uchar *ptr, int offset, int length)
{
  length -= MIN_MATCH;
  --offset;

#if CODING == CODING_DIRECT2
  offset <<= DIRECT2_LEN_LOG;
  if (length < DIRECT2_MAX_LEN)
  {
    offset |= length;
    ptr[0] = (uchar) offset;
    ptr[1] = (uchar) (offset >>= 8);
    ptr += 2;
  }
  else
  {
    offset |= DIRECT2_MAX_LEN;
    length -= DIRECT2_MAX_LEN;
    ptr[0] = (uchar) offset;
    ptr[1] = (uchar) (offset >>= 8);
    ptr += 2;
    if (v.stat.ptr == 0)
    {
      v.stat.ptr = ptr;
      *ptr++ = (uchar) (length < 15 ? length : 15);
    }
    else
    {
      v.stat.ptr[0] |= (uchar) ((length < 15 ? length : 15) << 4);
      v.stat.ptr = 0;
    }
    if ((length -= 15) >= 0)
    {
      *ptr++ = (uchar) length;
      if (length >= 255)
      {
        ptr[-1] = 255;
        length += DIRECT2_MAX_LEN + 15;
        ptr[0] = (uchar) length;
        ptr[1] = (uchar) (length >>= 8);
        ptr += 2;
      }
    }
  }
#elif CODING == CODING_DIRECT
  if (v.stat.ptr == 0)
  {
    if (length < 7)
    {
      length <<= 5;
      v.stat.ptr = ptr;
    short_len:
      ptr[0] = (uchar) length;
      ptr[1] = (uchar) offset;
      ptr += 2;
      if (offset > 255)
      {
        ptr[0] = (uchar) (offset >>= 8);
        ptr[-2] = (uchar) (length += 16);
        ptr += 1;
      }
    }
    else if (length < 15 + 7)
    {
      length += (14 << 4) - 7;
      goto short_len;
    }
    else
    {
      if (offset > 255)
        ptr[0] = 0xff;
      else
        ptr[0] = 0xef;
    long_len:
      ptr[1] = (uchar) (length -= (7 + 15));
      ptr += 2;
      if (length >= 255)
      {
        length += 7 + 15;
        ptr[-1] = 255;
        ptr[0] = (uchar) (length);
        ptr[1] = (uchar) (length >>= 8);
        ptr += 2;
      }
      *ptr++ = (uchar) offset;
      if (offset > 255)
        *ptr++ = (uchar) (offset >>= 8);
    }
  }
  else
  {
    if (length < 7)
    {
      length |= v.stat.ptr[0];
      *ptr++ = (uchar) offset;
      if (offset > 255)
      {
        *ptr++ = (uchar) (offset >>= 8);
        length |= 8;
      }
      v.stat.ptr[0] = (uchar) length;
      v.stat.ptr = 0;
    }
    else if (length < 15 + 7)
    {
      length -= 7;
      ptr[1] = (uchar) offset;
      ptr[0] = (uchar) (length <<= 4);
      if (offset > 255)
      {
        v.stat.ptr[0] |= 15;
        v.stat.ptr = ptr;
        ptr[2] = (uchar) (offset >>= 8);
        ptr += 3;
      }
      else
      {
        v.stat.ptr[0] |= 7;
        v.stat.ptr = ptr;
        ptr += 2;
      }
    }
    else
    {
      if (offset > 255)
        v.stat.ptr[0] |= 15;
      else
        v.stat.ptr[0] |= 7;
      v.stat.ptr = ptr;
      ptr[0] = 15 << 4;
      goto long_len;
    }
  }
#endif /* CODING */

  tag_write (p, ptr, 1);

  return (ptr);
}


#elif CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)

#if CODING == CODING_HUFF_ALL
#define write_lit(p,ptr,ch) do {    \
  ++v.stat.freq[*ptr++ = (ch)]; \
  tag_write (p, ptr, 0);            \
} while (0)
#else
#define write_lit(p,ptr,ch) do {   \
  *ptr++ = (ch);                   \
  tag_write (p, ptr, 0);           \
} while (0)
#endif

#define BIOWR(mask,bits) {                                      \
  assert (((mask) >> (bits)) == 0);                             \
  if ((Bits -= (bits)) < 0)                                     \
  {                                                             \
    *(__unaligned bitmask2 *)Ptr1 = (bitmask2) ((Mask << (Bits + (bits))) \
      + ((mask) >> (-Bits)));                                   \
    Mask = (mask);                                              \
    Bits += sizeof (ubitmask2) * 8;                             \
    Ptr1 = Ptr2;                                                \
    Ptr2 = (ubitmask2 *) ptr;                                   \
    ptr += sizeof (ubitmask2);                                  \
  }                                                             \
  else                                                          \
    Mask = (Mask << (bits)) + (mask);                           \
}


#if CODING == CODING_HUFF_LEN

INLINE uchar *write_ptr (prs *p, uchar *ptr, int offset, int length)
{
  xint k;

  ++v.stat.pointers;

  length -= MIN_MATCH;
  --offset;

  k = 0; if (offset > 255) k = 1;

  if (length < MAX_LENGTH - 1)
    ++v.stat.freq[*ptr++ = (uchar) (k |= length << 1)];
  else
  {
    length -= MAX_LENGTH - 1;
    ++v.stat.freq[ptr[0] = (uchar) (k |= (MAX_LENGTH - 1) << 1)];
    ptr[1] = (uchar) length;
    ptr += 2;
    if (length >= 255)
    {
      ptr[-1] = 255;
      length += MAX_LENGTH - 1;
      ptr[0] = (uchar) length;
      ptr[1] = (uchar) (length >>= 8);
      ptr += 2;
    }
  }

  *ptr++ = (uchar) offset;
  if (offset > 255)
    *ptr++ = (uchar) (offset >>= 8);

  tag_write (p, ptr, 1);

  return (ptr);
}

static void encode_pass2 (prs *p)
{
  xint Bits;
  ubitmask4 Mask;
  ubitmask2 *Ptr1, *Ptr2;
  tag_t bmask;
  uchar *src = v.temp.beg;
  uchar *ptr = v.comp.ptr;
  uxint k;

  Ptr1 = (ubitmask2 *) ptr; ptr += sizeof (ubitmask2);
  Ptr2 = (ubitmask2 *) ptr; ptr += sizeof (ubitmask2);
  Mask = 0;
  Bits = 8 * sizeof (ubitmask2);
  bmask = 0;
  goto start;

next:
  if (bmask >= 0)
  {
    bmask <<= 1;
  copy_byte:
    *ptr++ = *src++;
    goto next;
  }

  if ((bmask <<= 1) == 0)
  {
  start:
    *(__unaligned tag_t *)ptr = bmask = *(__unaligned tag_t *)src;
    src += sizeof (tag_t);
    ptr += sizeof (tag_t);
    if (bmask >= 0)
    {
      bmask = (bmask << 1) + 1;
      goto copy_byte;
    }
    bmask = (bmask << 1) + 1;
  }

  if (src >= v.temp.ptr)
    goto done;

  k = *src++;
  assert (k < HUFF_SIZE);
  BIOWR (v.stat.mask[k], v.stat.bits[k]);

  if (k >= ((MAX_LENGTH - 1) << 1))
  {
    if ((*ptr++ = *src++) == 255)
    {
      ptr[0] = src[0];
      ptr[1] = src[1];
      src += 2;
      ptr += 2;
    }
  }

  *ptr++ = *src++;
  if (k & 1) *ptr++ = *src++;
  goto next;

done:
  *Ptr1 = (ubitmask2) (Mask <<= Bits);
  *Ptr2 = 0;
  v.comp.ptr = ptr;
  assert (src == v.temp.ptr);
}

#elif CODING & (CODING_HUFF_PTR | CODING_HUFF_ALL)

#define MAX_BITNO_LOG   8
#define MAX_BITNO       (1 << MAX_BITNO_LOG)

static uchar bitno_table[MAX_BITNO];
static int bitno_table_initialized = 0;

static void bitno_init (void)
{
  int i, k, n;
  if (bitno_table_initialized)
    return;
  bitno_table[0] = 255;
  for (i = 0; i < MAX_BITNO_LOG; ++i)
  {
    for (n = (k = 1<<i) << 1; k < n; ++k)
      bitno_table[k] = (uchar) i;
  }
  bitno_table_initialized = 1;
}

static int bitno (uxint n)
{
  assert (n != 0 && (n >> (MAX_BITNO_LOG*2)) == 0);
  if (n >= MAX_BITNO)
    return (bitno_table[n >> MAX_BITNO_LOG] + MAX_BITNO_LOG);
  return (bitno_table[n]);
}

#if CODING == CODING_HUFF_ALL
#define CODING_ADJUST(n) (256 + (n))
#else
#define CODING_ADJUST(n) (n)
#endif

INLINE uchar *write_ptr (prs *p, uchar *ptr, int offset, int length)
{
  xint k;

  k = bitno (offset);
  length -= MIN_MATCH;
  offset ^= 1 << k;

  v.stat.pointers += 2;
  v.stat.extra += k;

  k <<= MAX_LENGTH_LOG;
  if (length < MAX_LENGTH - 1)
  {
    k |= length;
    *ptr++ = (uchar) k;
    ++v.stat.freq[CODING_ADJUST (k)];
  }
  else
  {
    k |= MAX_LENGTH - 1;
    length -= MAX_LENGTH - 1;
    ptr[0] = (uchar) k;
    ++v.stat.freq[CODING_ADJUST (k)];
    ptr[1] = (uchar) length;
    ptr += 2;
    if (length >= 255)
    {
      length += MAX_LENGTH - 1;
      ptr[-1] = 255;
      ptr[0] = (uchar) length;
      ptr[1] = (uchar) (length >>= 8);
      ptr += 2;
    }
  }

  *ptr++ = (uchar) offset;
  if (k >= (9 << MAX_LENGTH_LOG))
  {
    v.stat.pointers += 1;
    *ptr++ = (uchar) (offset >>= 8);
  }

  tag_write (p, ptr, 1);

  return (ptr);
}

static void encode_pass2 (prs *p)
{
  xint Bits;
  uxint Mask;
  ubitmask2 *Ptr1, *Ptr2;
  tag_t bmask;
  uchar *src = v.temp.beg;
  uchar *ptr = v.comp.ptr;
  uxint k;

  Ptr1 = (ubitmask2 *) ptr; ptr += sizeof (ubitmask2);
  Ptr2 = (ubitmask2 *) ptr; ptr += sizeof (ubitmask2);
  Mask = 0;
  Bits = 8 * sizeof (ubitmask2);
  bmask = 0;
  goto start;

next:
  if (bmask >= 0)
  {
    bmask <<= 1;
  copy_byte:
#if CODING == CODING_HUFF_ALL
    k = *src++;
    BIOWR (v.stat.mask[k], v.stat.bits[k]);
#elif CODING == CODING_HUFF_PTR
    *ptr++ = *src++;
#endif
    goto next;
  }

  if ((bmask <<= 1) == 0)
  {
  start:
    bmask = *(__unaligned tag_t *)src;
    src += sizeof (tag_t);
#if CODING == CODING_HUFF_PTR
    *(__unaligned tag_t *)ptr = bmask;
    ptr += sizeof (tag_t);
#endif
    if (bmask >= 0)
    {
      bmask = (bmask << 1) + 1;
      goto copy_byte;
    }
    bmask = (bmask << 1) + 1;
  }

  if (src >= v.temp.ptr)
    goto done;

  k = *src++;
  assert (k < HUFF_SIZE);
  BIOWR (v.stat.mask[CODING_ADJUST (k)], v.stat.bits[CODING_ADJUST (k)]);

  if ((k & (MAX_LENGTH - 1)) == MAX_LENGTH - 1)
  {
    if ((*ptr++ = *src++) == 255)
    {
      ptr[0] = src[0];
      ptr[1] = src[1];
      src += 2;
      ptr += 2;
    }
  }

  k >>= MAX_LENGTH_LOG;
  {
    uxint m = *src++;
    if (k > 8)
      m += *src++ << 8;
    BIOWR (m, k);
  }
  goto next;

done:
#if CODING == CODING_HUFF_ALL
  BIOWR (v.stat.mask[CODING_ADJUST(0)], v.stat.bits[CODING_ADJUST(0)]);
#endif
  *(__unaligned bitmask2 *)Ptr1 = (ubitmask2) (Mask <<= Bits);
  *(__unaligned bitmask2 *)Ptr2 = 0;
  v.comp.ptr = ptr;
  assert (src == v.temp.ptr);
}

#endif


/* ------------------ Create canonical Huffman code ------------------- */
/*                    -----------------------------                     */

#define MAX_ALPHABET HUFF_SIZE
static void huffman_create_codes (huff_info *info, uxint *freq, xint n, uxint *mask, uchar *length, uxint maxbits, uchar *encoded, uxint *total)
{
  huff_node
    *p, *q, *r,
    *first_sorted, *first_free;
  xint i, k;

  assert ((uxint) (n-1) <= (MAX_ALPHABET-1));

  /* honestly it is easy enough to create Huffman code in-place */
  /* but the use of explicit data structures makes code simpler */

  /* clean everything up                */
  memset (length, 0, sizeof (length[0]) * n);
  memset (encoded, 0, (n + 1) >> 1);

  if (mask != 0 && mask != freq)
    memset (mask, 0, sizeof (mask[0]) * n);

  /* store frequencies */
  p = info->buff;
  for (i = 0; i < n; ++i)
  {
    if ((p->freq = freq[i]) != 0)
    {
      p->son[0] = p+1; p->son[1] = 0;
      p->ch = (uint16) i;
      ++p;
    }
  }

  /* handle simple case         */
  *total = 0;
  if (p <= info->buff + 1)
  {
    if (p == info->buff)        /* if no symbols do nothing */
      return;
    i = p[-1].ch;               /* single symbol code */
    mask[i] = 0;
    encoded[i >> 1] = 0x11;     /* two symbols has 1-bit length */
    return;
  }

  first_free = p;       /* store location of first unused node  */

  p[-1].son[0] = 0;     /* terminate the list                   */
  /* radix sort the list by frequency */
  p = info->buff;             /* head of the list                     */
  /* initialize */
  for (n = 0; n < 256; ++n)
    *(info->link[n] = info->head + n) = 0;
  for (i = 0; i < (BUFF_SIZE_LOG <= 16 ? 16 : 32); i += 8)
  {
    /* link node to the end of respective bucket        */
    do
    {
      n = (p->freq >> i) & 0xff;
      info->link[n][0] = p; info->link[n] = p->son;
    }
    while ((p = p->son[0]) != 0);

    /* merge buckets into single list                   */
    n = 0;
    while (info->head[n] == 0) ++n;
    p = info->head[n]; info->head[k = n] = 0;
    while (++n < 256)
    {
      if (info->head[n] == 0) continue;
      info->link[k][0] = info->head[n]; info->link[k] = info->head + k; info->head[n] = 0;
      k = n;
    }
    info->link[k][0] = 0; info->link[k] = info->head + k;
  }
  first_sorted = p;      /* store head of sorted symbol's list   */

restart:
  assert (p == first_sorted);
  q = first_free;
  r = q - 1;
  while (p != 0 || q != r)
  {
    ++r;

    /* select left subtree      */
    assert (q <= r && (p != 0 || q != r));
    if (p == 0 || (q != r && p->freq > q->freq))
    {
      r->son[0] = q; r->freq = q->freq; ++q;
    }
    else
    {
      r->son[0] = p; r->freq = p->freq; p = p->son[0];
    }

    /* select right subtree     */
    assert (q <= r && (p != 0 || q != r));
    if (p == 0 || (q != r && p->freq > q->freq))
    {
      r->son[1] = q; r->freq += q->freq; ++q;
    }
    else
    {
      r->son[1] = p; r->freq += p->freq; p = p->son[0];
    }
  }

  /* evaluate codewords' length         */
  i = -1;       /* stack pointer        */
  n = 0;        /* current tree depth   */
  p = r;        /* current subtree root */
  for (;;)
  {
    while (p->son[1] != 0)
    {
      /* put right son into stack and set up its depth   */
      (info->head[++i] = p->son[1])->bits = (uint16) (++n);
      (p = p->son[0])->bits = (uint16) n;
    }
    length[p->ch] = (uchar) n;

    if (i < 0) break;   /* nothing's in stack                   */
    n = (p = info->head[i--])->bits;
  }

  p = first_sorted;
#if DEBUG
  for (q = p; (r = q->son[0]) != 0; q = r)
    assert (q->bits >= r->bits);
#endif
  if (p->bits > maxbits)
  {
    assert (p == first_sorted);
    q = p;
    do
      q->freq = (q->freq + 1) >> 1;
    while ((q = q->son[0]) != 0);
    goto restart;
  }

  /* now sort symbols in a stable way by increasing codeword length     */
  /* initialize */
  memset (info->head, 0, sizeof (info->head[0]) * 32);
  for (n = 0; n < 32; ++n)
    info->link[n] = info->head + n;

  /* link node to the end of respective bucket  */
  p = info->buff;
  do
  {
    n = p->bits;
    info->link[n][0] = p; info->link[n] = p->son;
  }
  while (++p != first_free);

  /* merge buckets into single list             */
  n = 0;
  while (info->head[n] == 0) ++n;
  p = info->head[n]; k = n;
  while (++n < 32)
  {
    if (info->head[n] == 0) continue;
    info->link[k][0] = info->head[n];
    k = n;
  }
  info->link[k][0] = 0;

#if DEBUG
  for (q = p; (r = q->son[0]) != 0; q = r)
    assert (r->bits > q->bits || (r->bits == q->bits && r->ch > q->ch));
#endif

  /* set up code masks          */
  if (mask == freq)
    memset (mask, 0, sizeof (mask[0]) * n);

  n = 0;        /* mask         */
  i = 1;        /* bit length   */
  k = 1;        /* first index  */
  do
  {
    /* sum a[i] * b[i] may be evaluated without multiplications */
    /* using O(B) memory and O(N+B) time if 0 <= b[i] < B       */
    *total += freq[p->ch] * p->bits;
    encoded[p->ch >> 1] |= p->bits << (p->ch & 1 ? 4 : 0);
    mask[p->ch] = (n <<= p->bits - i);
    i = p->bits;
    ++n;
  }
  while ((p = p->son[0]) != 0);
}

#endif /* CODING */

#define CHAIN 0
#define encode_pass1 encode0_pass1
#include "xencode.i"

#if MAX_CHAIN >= 1
#define CHAIN 1
#define encode_pass1 encode1_pass1
#define find_match find_match1
#include "xencode.i"
#endif

#if MAX_CHAIN >= 2
#define CHAIN 2
#define encode_pass1 encode2_pass1
#define find_match find_match2
#include "xencode.i"
#endif

#if MAX_CHAIN >= 3
#define CHAIN 3
#define encode_pass1 encodeN_pass1
#define find_match find_matchN
#include "xencode.i"
#endif

typedef void encode_pass1_proc (prs *p);

static void encode_pass1_progress (
  prs *p,
  encode_pass1_proc *encode_pass1,
  XpressProgressFn *ProgressFn,         // NULL or progress callback
  void *ProgressContext,                // user-defined context that will be passed to ProgressFn
  int ProgressSize                      // call ProgressFn each time ProgressSize bytes processed
)
{
  xint stop;

  if (ProgressFn == 0)
  {
    encode_pass1 (p);
    return;
  }

  stop = v.orig.stop;
  for (;;)
  {
    if (v.orig.pos - v.orig.progress >= ProgressSize)
    {
#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
      ProgressFn (ProgressContext, v.orig.pos);
#else
      ProgressFn (ProgressContext, (v.orig.pos * 15) >> 4);
#endif
      v.orig.progress = v.orig.pos;
    }

    v.orig.stop = stop;
    if (v.orig.pos >= stop)
      break;

    if (stop - v.orig.progress > ProgressSize)
      v.orig.stop = v.orig.progress + ProgressSize;
    assert (v.orig.stop > v.orig.pos);

    encode_pass1 (p);
  }
}


int XPRESS_CALL XpressEncode
(
  XpressEncodeStream stream,
  void *comp,
  int comp_size,
  const void *orig,
  int orig_size,
  XpressProgressFn *ProgressFn,         // NULL or progress callback
  void *ProgressContext,                // user-defined context that will be passed to ProgressFn
  int ProgressSize                      // call ProgressFn each time ProgressSize bytes processed
)
{
#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
  uchar huff_buff [HUFF_SIZE >> 1];
  uxint huff_total;
#endif
  uxint c_size;
  prs *p;
  xpress_info *info = (xpress_info *) stream;
  encode_pass1_proc *encode_pass1;

  if (info == 0 || info->magic != MAGIC_ENCODE)
    return (0);

  if ((unsigned) (orig_size-1) > info->max_size
    || orig_size <= MIN_SIZE
    || comp_size < MIN_SIZE
    || comp == 0
    || orig == 0)
  {
    return (orig_size);
  }

  p = info->p;
  memset (&v, 0, sizeof (v));
  v.temp.hash = (z_index_t *) (v.temp.ptr = info->temp);
  v.chain = info->chain;

  v.orig.end = (v.orig.ptr = orig) + (v.orig.size = v.orig.stop = orig_size);
  v.orig.end_16 = v.orig.end - 16;
  v.orig.end_3 = v.orig.end - MIN_MATCH;
  v.comp.ptr = v.comp.beg = comp;
  v.orig.pos = 0;
  v.temp.beg = v.temp.ptr;

  encode_pass1 = encode0_pass1;
  if (v.chain <= 0)
    memset ((void *) (&p->x.q_last[0]), 0, Q_HASH_SIZE * sizeof (p->x.q_last[0]));
#if MAX_CHAIN >= 1
  else if (v.chain == 1)
  {
    encode_pass1 = encode1_pass1;
    memset ((void *) (&p->x.z_next[0]), 0, Z_HASH_SIZE * sizeof (p->x.z_next[0]));
  }
#if MAX_CHAIN >= 2
  else
  {
    encode_pass1 = encode2_pass1;
#if MAX_CHAIN >= 3
    if (v.chain >= 3)
      encode_pass1 = encodeN_pass1;
#endif
    memset (v.temp.hash, 0, sizeof (v.temp.hash[0]) * Z_HASH_SIZE);
    z_hash_insert (p);
  }
#endif
#endif

  if (ProgressSize <= 0 || ProgressSize > orig_size)
    ProgressSize = orig_size;

  if (ProgressFn != 0)
    ProgressFn (ProgressContext, v.orig.progress = 0);

#if CODING & (CODING_DIRECT | CODING_DIRECT2 | CODING_BY_BIT)
  v.temp.beg = v.temp.ptr = v.comp.ptr;
  tag_write_start (p);
  for (;;)
  {
    xint rest = comp_size - (xint) (v.temp.ptr - v.comp.beg) - 2 * sizeof (tag_t);
    rest -= (rest + 7) >> 3;
    if (rest <= (xint) (2 * sizeof (tag_t) + 8))
      goto no_compression;
    if (v.orig.pos >= v.orig.size)
      break;
    v.orig.stop = v.orig.pos + rest;
    if (v.orig.stop > v.orig.size - 8)
    {
      v.orig.stop = v.orig.size - 8;
      if (v.orig.pos >= v.orig.stop)
        break;
    }
    encode_pass1_progress (p, encode_pass1, ProgressFn, ProgressContext, ProgressSize);
  }
#else
  v.orig.stop -= 7;
  tag_write_start (p);
  encode_pass1_progress (p, encode_pass1, ProgressFn, ProgressContext, ProgressSize);
#endif
  while (v.orig.pos < v.orig.size)
  {
    write_lit (p, v.temp.ptr, v.orig.ptr[v.orig.pos]);
    ++v.orig.pos;
  }
  tag_write_finish (p);

#if CODING & (CODING_DIRECT | CODING_DIRECT2 | CODING_BY_BIT)
  c_size = (xint) (v.temp.ptr - v.temp.beg);
#elif CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
  if (v.stat.pointers == 0)
    goto no_compression;
#if CODING == CODING_HUFF_ALL
  ++v.stat.freq[CODING_ADJUST(0)];
#endif
  huffman_create_codes (
    &v.stat.info,
    v.stat.freq, HUFF_SIZE,
    v.stat.mask, v.stat.bits, 15, huff_buff, &huff_total
  );

  c_size = huff_total;
#if CODING & (CODING_HUFF_PTR | CODING_HUFF_ALL)
  c_size += v.stat.extra;
#endif
  if (c_size == 0) c_size = 1;
  c_size = (((c_size - 1) & ~(sizeof (bitmask2) * 8 - 1)) >> 3);
  c_size += (int) (v.temp.ptr - v.temp.beg) - v.stat.pointers + 4 + sizeof (huff_buff);
#if CODING == CODING_HUFF_ALL
  for (huff_total = 0; huff_total < 256; ++huff_total)
    c_size -= v.stat.freq[huff_total];
  c_size -= v.stat.masks * sizeof (tag_t);
#endif
#endif /* CODING */

  if (c_size >= (uxint) comp_size)
  {
  no_compression:
    comp_size = orig_size;
  }
  else
  {
#if CODING & (CODING_HUFF_LEN | CODING_HUFF_PTR | CODING_HUFF_ALL)
    memcpy (v.comp.ptr, huff_buff, sizeof (huff_buff));
    v.comp.ptr += sizeof (huff_buff);
    encode_pass2 (p);
#elif CODING & (CODING_BY_BIT | CODING_DIRECT | CODING_DIRECT2)
    v.comp.ptr += c_size;
#else
#error Unknown CODING
#endif

    comp_size = (int) (v.comp.ptr - v.comp.beg);

#if DEBUG
    if (c_size != (uxint) comp_size)
      printf ("error: c_size = %d, comp_size = %d\n", c_size, comp_size);
#endif
  }

  if (ProgressFn != 0)
    ProgressFn (ProgressContext, orig_size);

  return (comp_size);
}

#define ALIGN   32

XpressEncodeStream XPRESS_CALL XpressEncodeCreate
  (int orig_size, void *context, XpressAllocFn *AllocFn, int chain)
{
  xpress_info *info;
  prs *p;
  uchar *b;
  int temp_size;
  int alloc_size;

  if (AllocFn == 0 || (unsigned) (orig_size-1) > (BUFF_SIZE-1))
    return (0);

#if CODING & (CODING_DIRECT | CODING_DIRECT2 | CODING_BY_BIT)
  temp_size = 0;
#else
  temp_size = orig_size + ((orig_size + 7) >> 3);
#endif

  alloc_size = sizeof (p->x.q_last[0]) * Q_HASH_SIZE;
#if MAX_CHAIN <= 0
  chain = 0;
#else
  if (chain > MAX_CHAIN)
    chain = MAX_CHAIN;
  if (chain >= 1)
  {
    alloc_size = sizeof (p->x.z_next[0]) * Z_HASH_SIZE;
#if MAX_CHAIN >= 2
    if (chain >= 2)
    {
      alloc_size = sizeof (p->x.z_next[0]) * orig_size;
      if (temp_size < sizeof (v.temp.hash[0]) * Z_HASH_SIZE)
        temp_size = sizeof (v.temp.hash[0]) * Z_HASH_SIZE;
    }
#endif
  }
#endif

  temp_size = (temp_size + 256 + sizeof (*p)) & ~(ALIGN-1);
  alloc_size += temp_size + sizeof (*info) + ALIGN;

  b = AllocFn (context, alloc_size);
  if (b == 0)
    return (0);

  info = (xpress_info *) b;
  info->max_size = orig_size - 1;
  info->chain = chain;
  info->magic = MAGIC_ENCODE;
  info->memory = b;

  b = (uchar *) (info + 1);
  b += ALIGN - (((__int64) b) & (ALIGN-1));
  info->p = p = ((prs *) (b + temp_size));
  info->temp = b;

#if MAX_CHAIN >= 1
  z_hash_map_init ();
#endif

#if CODING & (CODING_HUFF_PTR | CODING_HUFF_ALL)
  bitno_init ();
#endif

  return ((XpressEncodeStream) info);
}

void XPRESS_CALL XpressEncodeClose
  (XpressEncodeStream stream, void *context, XpressFreeFn *FreeFn)
{
  xpress_info *info = (xpress_info *) stream;
  if (info != 0 && FreeFn != 0 && info->magic == MAGIC_ENCODE)
  {
    info->magic = 0;
    FreeFn (context, info->memory);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\xpress\xprs.h ===
#ifndef _XPRS_H_
#define _XPRS_H_


/* ------------------------------------------------------------------------ */
/*                                                                          */
/*  Copyright (c) Microsoft Corporation, 2000-2001. All rights reserved.    */
/*  Copyright (c) Andrew Kadatch, 1991-2001. All rights reserved.           */
/*                                                                          */
/*  Microsoft Confidential -- do not redistribute.                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "xpress.h"

#ifdef _MSC_VER
#pragma code_seg ("PAGELK")
#ifdef _M_IX86
#pragma optimize ("tgaw", on)
#else
#pragma optimize ("tgw", on)
#endif /* _M_IX86 */
#endif



/* ------------------------ Configuration ----------------------------- */
/*                          -------------                               */

#ifndef CODING_ALG
#define CODING_ALG      1
#endif

#define CODING_DIRECT2  (1 << 1)
#define CODING_DIRECT   (1 << 2)
#define CODING_BY_BIT   (1 << 3)
#define CODING_HUFF_LEN (1 << 4)
#define CODING_HUFF_PTR (1 << 5)
#define CODING_HUFF_ALL (1 << 6)

#define CODING          (1 << CODING_ALG)

#define SUPPORT_CRC     0

#define BUFF_SIZE_LOG    XPRESS_MAX_BLOCK_LOG
#define BUFF_SIZE        (1<<BUFF_SIZE_LOG)

#if 1
#define MAX_OFFSET      (BUFF_SIZE_LOG > 16 ? 16 : BUFF_SIZE_LOG)
#else
#define MAX_OFFSET      13
#endif

#if CODING == CODING_DIRECT2 && MAX_OFFSET > 13
#undef MAX_OFFSET
#define MAX_OFFSET 13
#define DIRECT2_LEN_LOG (16 - MAX_OFFSET)
#define DIRECT2_MAX_LEN ((1 << DIRECT2_LEN_LOG) - 1)
#endif

#if BUFF_SIZE < XPRESS_MAX_BLOCK
#error BUFF_SIZE should not be less than XPRESS_MAX_BLOCK
#endif

#if CODING == CODING_HUFF_LEN
#define MAX_LENGTH      32
#define HUFF_SIZE       (MAX_LENGTH * 2)
#elif CODING & (CODING_HUFF_PTR | CODING_HUFF_ALL)
#if (256 / MAX_OFFSET) >= 32
#define MAX_LENGTH_LOG  5
#else
#define MAX_LENGTH_LOG  4
#endif
#define MAX_LENGTH      (1 << MAX_LENGTH_LOG)
#if CODING == CODING_HUFF_PTR
#define HUFF_SIZE       ((MAX_LENGTH * MAX_OFFSET + 1) & ~1)
#elif CODING == CODING_HUFF_ALL
#define HUFF_SIZE       (256 + ((MAX_LENGTH * MAX_OFFSET + 1) & ~1))
#endif
#endif

#define MIN_MATCH       3       /* min acceptable match length  */

#if CODING == CODING_HUFF_LEN
#define DECODE_BITS     8
#elif CODING & (CODING_HUFF_PTR | CODING_HUFF_ALL)
#define DECODE_BITS     10
#endif


/* ---------------------- Useful types ------------------------ */
/*                        ------------                          */

#if defined (_M_IX86) && !defined (i386)
#define i386 1                  /* ifdef i386 asm code will be used for some encodings */
#endif

#define uchar unsigned char     /* useful types */
#define schar signed char

#ifdef _M_IX86
#define __unaligned             /* x86 does not have __unaligned keyword    */
#endif

#define int4  int               /* any long enough integral type            */
#define int2  short             /* assert (2*sizeof(int2) == sizeof (int4)) */
#define xint  int               /* any int type >= 32 bits && >= sizeof (bitmask4) */
#define int32 int               /* 32 bit type */
#define int16 short             /* 16 bit type */

#define tag_t    int32

#ifdef i386
#define bitmask4 int32  /* must be 32 bit for i386 */
#define bitmask2 int16
#else
#define bitmask4 int4   /* not important otherwise; shall not exceed xint */
#define bitmask2 int2
#endif


#define uint4     unsigned int4
#define uint2     unsigned int2
#define uxint     unsigned xint
#define uint32    unsigned int32
#define uint16    unsigned int16
#define utag_t    unsigned tag_t
#define ubitmask4 unsigned bitmask4
#define ubitmask2 unsigned bitmask2

#ifdef _MSC_VER
#if _MSC_VER >= 1200
#define INLINE  __forceinline
#else
#define INLINE __inline
#endif
#pragma warning(disable:4127)   /* conditional expression is constant */
#pragma warning(disable:4711)   /* function XXX selected for automatic inline expansion */
#pragma warning(disable:4710)   /* function XXX not expanded */
#pragma warning(disable:4100)   /* unreferenced formal paramter */
#pragma warning(disable:4068)   /* bogus "unknown pragma" */
#endif

#ifndef DEBUG
#define DEBUG 0
#endif

#if !defined (INLINE) || DEBUG
#undef  INLINE
#define INLINE static
#endif

#if !DEBUG
#undef assert
#define assert(x)
#endif

#if CODING & (CODING_DIRECT | CODING_DIRECT2)
#define MIN_SIZE0       8
#elif CODING == CODING_BY_BIT
#define MIN_SIZE0       7
#elif CODING == CODING_HUFF_LEN
#define MIN_SIZE0       44
#elif CODING == CODING_HUFF_PTR
#define MIN_SIZE0       139
#elif CODING == CODING_HUFF_ALL
#define MIN_SIZE0       261
#else
#error wrong CODING
#endif

#define MIN_SIZE        (MIN_SIZE0 + CRC_STAMP_SIZE)


#define CRC32_FIRST     0
#if SUPPORT_CRC
#define CRC_STAMP_SIZE  sizeof (uint32)
#else
#define CRC_STAMP_SIZE  0
#endif

#if DEBUG
extern long xxx[];
#endif

#ifdef _MSC_VER
#pragma warning (disable: 4731) /* frame pointer register 'ebp' modified by inline assembly code */
#endif

#if CODING_ALG != 1 && CODING_ALG != 6
#error CODING_ALGs different from 1 and 6 are not supported anymore
#endif

#endif /* _XPRS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\xpress\xprs-crc.c ===
/* ------------------------------------------------------------------------ */
/*                                                                          */
/*  Copyright (c) Microsoft Corporation, 2000-2001. All rights reserved.    */
/*  Copyright (c) Andrew Kadatch, 1991-2001. All rights reserved.           */
/*                                                                          */
/*  Microsoft Confidential -- do not redistribute.                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */

#include "xpress.h"
#include "xprs.h"

/* ------------------------ CRC-32 ---------------------------- */
/*                          ------                              */

static uint32 crc32_table[256];
static int crc32_initialized = 0;

static void crc32_init (void)
{
  xint i, j;
  uint32 k, m = 0xedb88320L;
  if (crc32_initialized) return;
  for (i = 0; i < 256; ++i)
  {
    k = i;
    j = 8;
    do {
      if ((k&1) == 0)
        k >>= 1;
      else
      {
        k >>= 1;
        k ^= m;
      };
      --j;
    } while (j);
    crc32_table[i] = k;
  }
  crc32_initialized = 1;
}

static uint32 crc32 (const uchar *p, xint n, uint32 k)
{
  uint32 *table;

  if (n <= 0)
    return (k);

  k ^= (uint32) 0xffffffffL;
  table = crc32_table;

#define X(i) k = table[((uchar) k) ^ p[i]] ^ (k >> 8)
  if ((n -= 32) >= 0) do
  {
    X(000); X(001); X(002); X(003); X(004); X(005); X(006); X(007);
    X(010); X(011); X(012); X(013); X(014); X(015); X(016); X(017);
    X(020); X(021); X(022); X(023); X(024); X(025); X(026); X(027);
    X(030); X(031); X(032); X(033); X(034); X(035); X(036); X(037);
    p += 32;
  }
  while ((n -= 32) >= 0);
  if ((n += 32) > 0) do
  {
    X (0);
    ++p;
    --n;
  }
  while (n);
#undef X

  k ^= (uint32) 0xffffffffL;
  return (k);
}

int
XPRESS_CALL
  XpressCrc32
  (
    const void *data,           // beginning of data block
    int bytes,                  // number of bytes
    int crc                     // initial value
  )
{
  if (!crc32_initialized)
    crc32_init ();
  return (crc32 (data, bytes, crc));
}

#if 0
int main (void)
{
  int i = 0;
  crc32_init ();
  printf ("{\n");
  for (;;)
  {
    printf (" 0x%08lx", (unsigned long) crc32_table[i]);
    ++i;
    if (i & 3)
      printf (",");
    else if (i == 256)
      break;
    else printf (",\n");
  }
  printf ("\n}\n");
  return (0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\downlevelclients\makefile.inc ===
PropClientsToBinaries: \
    PropLanman \
    PropLanmanOS2 \
    PropMsCLient \
    PropRas \
    PropSrvTools \
    PropSupport \
    PropTcp32wfw \
    PropUpdateWfw \
    PropWin95

PropLanman:
!ifdef _NTTREE
    xcopy lanman $(_NTTREE)\clients\lanman /s /d /y /i
!endif    

PropLanmanOS2:
!ifdef _NTTREE
    xcopy lanman.os2 $(_NTTREE)\clients\lanman.os2 /s /d /y /i
!endif    

PropMsCLient:
!ifdef _NTTREE
    xcopy msclient $(_NTTREE)\clients\msclient /s /d /y /i
!endif    

PropRas:
!ifdef _NTTREE
    xcopy ras $(_NTTREE)\clients\ras /s /d /y /i
!endif    

PropSrvTools:
!ifdef _NTTREE
    xcopy srvtools $(_NTTREE)\clients\srvtools /s /d /y /i
!endif    

PropSupport:
!ifdef _NTTREE
    xcopy support $(_NTTREE)\clients\support /s /d /y /i
!endif    

PropTcp32wfw:
!ifdef _NTTREE
    xcopy tcp32wfw $(_NTTREE)\clients\tcp32wfw /s /d /y	/i
!endif    

PropUpdateWfw:
!ifdef _NTTREE
    xcopy update.wfw $(_NTTREE)\clients\update.wfw /s /d /y /i
!endif    

PropWin95:
!ifdef _NTTREE
    xcopy win95 $(_NTTREE)\clients\win95 /s /d /y /i
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\mapistub\mapistub\client.h ===
/*
 -  C L I E N T . H
 -
 *  Purpose:
 *      Header file for the sample mail client based on Simple MAPI.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */



/* Resource IDs */

#define ICON_NOMAIL     200
#define ICON_Attach      201

/* Compose Note Control IDs */

#define IDC_SEND        101
#define IDC_RESOLVE     102
#define IDC_ATTACH      103
#define IDC_OPTIONS     104
#define IDC_ADDRBOOK    105
#define IDT_TO          106
#define IDC_TO          107
#define IDT_CC          108
#define IDC_CC          109
#define IDT_SUBJECT     110
#define IDC_SUBJECT     111
#define IDC_NOTE        112
#define IDC_CATTACHMENT	113
#define IDT_CATTACHMENT	114
#define IDC_LINE1       -1
#define IDC_LINE2       -1

#define ID_Frame			222
#define ID_Toolbar			223

#define ID_Font				224
#define ID_FontSize			225

#define ID_Bold				226
#define ID_Italic			227
#define ID_Underline		228

#define ID_Bullet			229
#define ID_Left				230
#define ID_Center			231
#define ID_Right			232
#define ID_Collapse			233
#define ID_Indent			234

#define ID_Color			250
#define ID_ColorAuto		251
#define ID_ColorBlack		252
#define ID_ColorMaroon		253
#define ID_ColorGreen		254
#define ID_ColorOlive		255
#define ID_ColorBlue		256
#define ID_ColorPurple		257
#define ID_ColorTeal		258
#define ID_ColorGray		259
#define ID_ColorSilver		260
#define ID_ColorRed			261
#define ID_ColorLime		262
#define ID_ColorYellow		263
#define ID_ColorNavy		264
#define ID_ColorFuchia		265
#define ID_ColorAqua		266
#define ID_ColorWhite		267

#define ID_SendUp			268
#define ID_SendDown			269

/* Send Properties IDs */

#define SendProperties		500
#define	IDI_SEND			501
#define IDC_CHANGED			502
#define IDC_DELIVERYREC		503
#define IDC_LOW				504
#define IDC_NORMAL			505
#define IDC_HIGH			506
#define IDC_LOCATION		507
#define IDC_READRECEIPT		508
#define IDC_SENDOPTS		509
#define IDC_SENSITIVITY		510
#define IDC_SENTMAIL		511
#define IDG_OPTIONS			512
#define IDC_MSGSIZE			513
#define IDC_TYPE			514
#define IDL_CHANGED			-1
#define IDL_IMPORTANCE		-1
#define IDL_LOCATION		-1
#define IDL_SENSITIVITY		-1
#define IDL_SIZE			-1
#define IDL_TYPE			-1

// Menu defines

#define IDM_SEND				1100
#define	IDM_PROPERTIES			1101
#define IDM_CLOSE				1102
#define IDM_UNDO				1103
#define IDM_CUT					1104
#define IDM_COPY				1105
#define IDM_PASTE				1106
#define IDM_PASTE_SPECIAL		1107
#define IDM_SELECT_ALL			1108
#define IDM_LINK				1109
#define IDM_EDIT_OBJECT			1110
#define IDM_FILE				1111
#define IDM_OBJECT				1112
#define IDM_FONT				1113
#define IDM_PARAGRAPH			1114
#define IDM_ADDRESSBOOK			1115
#define IDM_HELP				1116
#define IDM_ABOUT				1117
#define IDM_CHECKNAMES			1118

// Help.About dialog

#define BMP_AboutMail				800

#define DLG_ABOUT					1309

#define TXT_AboutTitleLine          101
#define TXT_AboutMailCopyright      102
#define TXT_AboutSoftArtSpell1      103
#define TXT_AboutSoftArtSpell2      104
#define TXT_AboutSoftArtSpell3      105
#define TXT_AboutLicenseTo          106
#define TXT_AboutLicenseFrame       107
#define TXT_AboutLicenseName        108
#define TXT_AboutLicenseOrg         109
#define TXT_AboutFrame              110
#define TXT_AboutBigWarning         111
#define PSB_AboutSystemInfo         112
#define STR_MsInfoCmdLine           113
#define TXT_AboutPID                114

// Help.About dialog
#define STR_AboutBigWarning			2519
#define STR_AboutBigWarning2		2520

// paragraph dialog

#define DLG_PARAGRAPH				1307

#define GRP_Alignment				101
#define RDB_Para_Left				102
#define RDB_Para_Center				103
#define RDB_Para_Right				104
#define CHK_Para_Bullet				105

#define cxBulletIndent				(1440 / 4) // $TBD joel's richedit stuff may already define this.

#define PSB_Help					9
#define PSB_OK						IDOK



// property sheet

#define STR_HeaderGeneral			2521
#define STR_HeaderRead				2522
#define STR_HeaderSend				2523
#define STR_HeaderColors			2524
#define STR_HeaderSpelling  		2525
#define STR_PrefPropSheetTitle		2526
#define STR_ServicesPropSheetTitle	2527

// copy disincentive stuff

#define RT_CDDATATYPE	106
#define RES_CDDATANAME	96



// Accelerator keys

#define AccMapiSendNote					2005

#define MNI_AccelFont					20271
#define MNI_AccelSize					20272
#define MNI_AccelSizePlus1				20273
#define MNI_AccelSizeMinus1				20274
#define MNI_AccelBold					20275
#define MNI_AccelItalic					20276
#define MNI_AccelUnderline				20277
#define MNI_AccelLeft					20278
#define MNI_AccelCenter					20279
#define MNI_AccelRight					20280
#define MNI_AccelBullets				20281
#define MNI_AccelDecreaseIndent			20282
#define MNI_AccelIncreaseIndent			20283
#define MNI_AccelColor					20284
#define MNI_AccelNoFormatting			20285

#define MNI_AccelUndo					20288
#define MNI_AccelCut					20289
#define MNI_AccelCopy					20290
#define MNI_AccelPaste					20291
#define MNI_AccelViewWritingMode		20292
#define MNI_EditSelectAll           	20046
#define MNI_ToolsAddressBook			20123
#define MNI_ToolsCheckNames         	20133
#define MNI_FileSend					20012
#define MNI_HelpPressF1					20163
#define MNI_FileProperties				20431
   

/* About Box Control IDs */

#define IDC_VERSION		101


/* String Table IDs */

#define MAPI_ERROR_MAX          5000

#define IDS_E_SEND_FAILURE				(MAPI_ERROR_MAX + 1)
#define IDS_E_NO_RECIPIENTS				(MAPI_ERROR_MAX + 2)
#define IDS_SAVEATTACHERROR				(MAPI_ERROR_MAX + 3)
#define IDS_READFAIL					(MAPI_ERROR_MAX + 4)
#define IDS_E_UNRESOLVED_RECIPS			(MAPI_ERROR_MAX + 5)
#define IDS_DIALOGACTIVE				(MAPI_ERROR_MAX + 6)

#define IDS_SIMPLE_MAPI_SEND			(IDS_DIALOGACTIVE + 1)
#define IDS_GENERAL						(IDS_SIMPLE_MAPI_SEND + 0)
#define IDS_NEW_MESSAGE					(IDS_SIMPLE_MAPI_SEND + 1)
#define IDS_SENSITIVITY_NORMAL			(IDS_SIMPLE_MAPI_SEND + 2)
#define IDS_SENSITIVITY_PERSONAL		(IDS_SIMPLE_MAPI_SEND + 3)
#define IDS_SENSITIVITY_PRIVATE			(IDS_SIMPLE_MAPI_SEND + 4)
#define IDS_SENSITIVITY_CONFIDENTIAL	(IDS_SIMPLE_MAPI_SEND + 5)
#define IDS_SIZE_IN_BYTES				(IDS_SIMPLE_MAPI_SEND + 6)
#define IDS_MESSAGE_OPTIONS_ERR			(IDS_SIMPLE_MAPI_SEND + 7)
#define IDS_EXCHANGE_HDR				(IDS_SIMPLE_MAPI_SEND + 8)

#define IDS_COLOR_AUTO					(IDS_SIMPLE_MAPI_SEND + 10)
#define IDS_COLOR_BLACK					(IDS_SIMPLE_MAPI_SEND + 11)
#define IDS_COLOR_MAROON				(IDS_SIMPLE_MAPI_SEND + 12)
#define IDS_COLOR_GREEN					(IDS_SIMPLE_MAPI_SEND + 13)
#define IDS_COLOR_OLIVE					(IDS_SIMPLE_MAPI_SEND + 14)
#define IDS_COLOR_NAVY					(IDS_SIMPLE_MAPI_SEND + 15)
#define IDS_COLOR_PURPLE				(IDS_SIMPLE_MAPI_SEND + 16)
#define IDS_COLOR_TEAL					(IDS_SIMPLE_MAPI_SEND + 17)
#define IDS_COLOR_GRAY					(IDS_SIMPLE_MAPI_SEND + 18)
#define IDS_COLOR_SILVER				(IDS_SIMPLE_MAPI_SEND + 19)
#define IDS_COLOR_RED					(IDS_SIMPLE_MAPI_SEND + 20)
#define IDS_COLOR_LIME					(IDS_SIMPLE_MAPI_SEND + 21)
#define IDS_COLOR_YELLOW				(IDS_SIMPLE_MAPI_SEND + 22)
#define IDS_COLOR_BLUE					(IDS_SIMPLE_MAPI_SEND + 23)
#define IDS_COLOR_FUCHSIA				(IDS_SIMPLE_MAPI_SEND + 24)
#define IDS_COLOR_AQUA					(IDS_SIMPLE_MAPI_SEND + 25)
#define IDS_COLOR_WHITE					(IDS_SIMPLE_MAPI_SEND + 26)

#define IDS_CM_CUT						(IDS_SIMPLE_MAPI_SEND + 27)
#define IDS_CM_COPY						(IDS_SIMPLE_MAPI_SEND + 28)
#define IDS_CM_PASTE					(IDS_SIMPLE_MAPI_SEND + 29)
#define IDS_CM_SELECT_ALL				(IDS_SIMPLE_MAPI_SEND + 30)
#define IDS_CM_FONT						(IDS_SIMPLE_MAPI_SEND + 31)
#define IDS_CM_PARAGRAPH				(IDS_SIMPLE_MAPI_SEND + 32)
			
#define IDS_DEFAULT_FONT				(IDS_SIMPLE_MAPI_SEND + 39)
			
#define IDS_E_WINHELP_FAILURE			(IDS_SIMPLE_MAPI_SEND + 40)	
#define IDS_E_NO_HELP					(IDS_SIMPLE_MAPI_SEND + 41)	
#define IDS_E_RICHED_UNDO				(IDS_SIMPLE_MAPI_SEND + 42)	
#define IDS_E_REALLY_QUIT				(IDS_SIMPLE_MAPI_SEND + 43)	
#define IDS_E_SAVE_CLIPBOARD			(IDS_SIMPLE_MAPI_SEND + 44)	
#define IDS_E_1_INSTANCE    			(IDS_SIMPLE_MAPI_SEND + 45)	

#define IDS_FILTER						(MAPI_ERROR_MAX + 60)


/* Manifest Constants */

#define ADDR_MAX            128
#define MAXUSERS            10
#define TO_EDIT_MAX         512
#define CC_EDIT_MAX         512
#define SUBJECT_EDIT_MAX    128
#define NOTE_LINE_MAX       1024
#define FILE_ATTACH_MAX     32


/* Virtual key code definitions for accelerators */

#define VK_OEM_LBRACKET				0xDB
#define VK_OEM_RBRACKET				0xDD


/* Message Box styles */

#define MBS_ERROR           (MB_ICONSTOP | MB_OK)
#define MBS_INFO            (MB_ICONINFORMATION | MB_OK)
#define MBS_OOPS            (MB_ICONEXCLAMATION | MB_OK)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\mapistub\fixmapi\fixmapi.c ===
/*
 *	FIXMAPI.C
 *	
 *	MAPI Repair Tool executable for NT5
 */


#include <windows.h>

#ifndef MB_SETFOREGROUND
#define MB_SETFOREGROUND 0
#endif

void	InstallAlert(LPTSTR szErr);

int WINAPI
ModuleEntry()
{
	HINSTANCE hinst;

	hinst = LoadLibrary("mapistub.dll");
	if (!hinst)
	{
		DWORD dw = GetLastError();
		TCHAR sz[MAX_PATH];

		wsprintf(sz, "LoadLibrary: GetLastError = %d", dw);
		InstallAlert(sz);
	}
	else
	{
		FARPROC pfn;

		pfn = GetProcAddress(hinst, "FixMAPI");
		if (!pfn)
		{
			DWORD dw = GetLastError();
			TCHAR sz[MAX_PATH];

			wsprintf(sz, "GetProcAddress: GetLastError = %d", dw);
			InstallAlert(sz);
		}
		else
		{
			(*pfn)();	// Call FixMAPI()
		}
	}
	
	ExitProcess(0);
}

void
InstallAlert(LPTSTR szErr)
{
	MessageBox(NULL, szErr, "MAPI Repair Tool", MB_OK | MB_ICONSTOP | MB_SETFOREGROUND);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\mapistub\mapistub\mapidefs.h ===
/*
 *	M A P I D E F S . H
 *
 *	Definitions used by MAPI clients and service providers.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPIDEFS_H
#define MAPIDEFS_H

#if _MSC_VER > 1000
#pragma once
#endif

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

#if defined (_WIN32) /* Must include WINDOWS.H on Win32 */
#ifndef _WINDOWS_
#define INC_OLE2 /* Get the OLE2 stuff */
#define INC_RPC  /* harmless on Windows NT; Windows 95 needs it */
#define _INC_OLE /* Windows 95 will include OLE1 without this */
#include <windows.h>
#endif

#ifndef _OLEERROR_H_
#include <winerror.h>
#endif
#ifndef _OBJBASE_H_
#include <objbase.h>
#endif
#endif

#if defined (WIN16) || defined (DOS) || defined (DOS16)
#ifndef _COMPOBJ_H_
#include <compobj.h>
#endif
#endif

#ifndef _INC_STDDEF
#include <stddef.h>
#endif

/* Array dimension for structures with variable-sized arrays at the end. */

#ifndef MAPI_DIM
#define MAPI_DIM	1
#endif

/* Provider init type. Force to cdecl always */

#ifndef STDMAPIINITCALLTYPE
#if !defined (_MAC) && defined (_WIN32)
#define STDMAPIINITCALLTYPE		__cdecl
#else
#define STDMAPIINITCALLTYPE		STDMETHODCALLTYPE
#endif
#define	STDINITMETHODIMP		HRESULT STDMAPIINITCALLTYPE
#define STDINITMETHODIMP_(type)	type STDMAPIINITCALLTYPE
#endif


#define MAPI_NT_SERVICE     ((ULONG) 0x00010000)  /* Provider is being loaded in an NT service */


#ifdef	__cplusplus
extern "C" {
#endif

/* Simple data types */

#if !defined (MIDL_PASS) /* MIDL doesn't want to see these */

#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short      WCHAR;
#endif

#ifdef UNICODE
typedef WCHAR				TCHAR;
#else
typedef char				TCHAR;
#endif

typedef WCHAR FAR *			LPWSTR;
typedef const WCHAR FAR *	LPCWSTR;
typedef TCHAR FAR *			LPTSTR;
typedef const TCHAR FAR *	LPCTSTR;
typedef BYTE FAR *			LPBYTE;
#endif /* defined MIDL_PASS */

typedef ULONG FAR *			LPULONG;

#ifndef __LHANDLE
#define __LHANDLE
typedef ULONG_PTR	LHANDLE, FAR * LPLHANDLE;
#endif

#if !defined(_WINBASE_) && !defined(_FILETIME_)
#define _FILETIME_
typedef struct _FILETIME
{
	DWORD dwLowDateTime;
	DWORD dwHighDateTime;
} FILETIME, FAR * LPFILETIME;
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/*
 *	This flag is used in many different MAPI calls to signify that
 *	the object opened by the call should be modifiable (MAPI_MODIFY).
 *  If the flag MAPI_MAX_ACCESS is set, the object returned should be
 *  returned at the maximum access level allowed.  An additional
 *  property available on the object (PR_ACCESS_LEVEL) uses the same
 *  MAPI_MODIFY flag to say just what this new access level is.
 */

#define MAPI_MODIFY				((ULONG) 0x00000001)

/*
 *	The following flags are used to indicate to the client what access
 *	level is permissible in the object. They appear in PR_ACCESS in
 *	message and folder objects as well as in contents and associated
 *	contents tables
 */

#define	MAPI_ACCESS_MODIFY					((ULONG) 0x00000001)
#define	MAPI_ACCESS_READ					((ULONG) 0x00000002)
#define	MAPI_ACCESS_DELETE					((ULONG) 0x00000004)
#define	MAPI_ACCESS_CREATE_HIERARCHY		((ULONG) 0x00000008)
#define	MAPI_ACCESS_CREATE_CONTENTS			((ULONG) 0x00000010)
#define	MAPI_ACCESS_CREATE_ASSOCIATED		((ULONG) 0x00000020)

/*
 *	The MAPI_UNICODE flag is used in many different MAPI calls to signify
 *	that strings passed through the interface are in Unicode (a 16-bit
 *	character set). The default is an 8-bit character set.
 *
 *	The value fMapiUnicode can be used as the 'normal' value for
 *	that bit, given the application's default character set.
 */

#define MAPI_UNICODE			((ULONG) 0x80000000)

#ifdef UNICODE
#define fMapiUnicode			MAPI_UNICODE
#else
#define fMapiUnicode			0
#endif

/* successful HRESULT */
#define hrSuccess				0



/* Recipient types */
#ifndef MAPI_ORIG				/* also defined in mapi.h */
#define MAPI_ORIG   0           /* Recipient is message originator          */
#define MAPI_TO     1           /* Recipient is a primary recipient         */
#define MAPI_CC     2           /* Recipient is a copy recipient            */
#define MAPI_BCC    3           /* Recipient is blind copy recipient        */
#define MAPI_P1		0x10000000	/* Recipient is a P1 resend recipient       */
#define MAPI_SUBMITTED 0x80000000 /* Recipient is already processed         */
/* #define MAPI_AUTHORIZE 4		   recipient is a CMC authorizing user		*/
/*#define MAPI_DISCRETE 0x10000000 Recipient is a P1 resend recipient       */
#endif

/* Bit definitions for abFlags[0] of ENTRYID */
#define MAPI_SHORTTERM			0x80
#define MAPI_NOTRECIP			0x40
#define MAPI_THISSESSION		0x20
#define MAPI_NOW				0x10
#define MAPI_NOTRESERVED		0x08

/* Bit definitions for abFlags[1] of ENTRYID */
#define MAPI_COMPOUND			0x80

/* ENTRYID */
typedef struct
{
	BYTE	abFlags[4];
	BYTE	ab[MAPI_DIM];
} ENTRYID, FAR *LPENTRYID;

#define CbNewENTRYID(_cb)		(offsetof(ENTRYID,ab) + (_cb))
#define CbENTRYID(_cb)			(offsetof(ENTRYID,ab) + (_cb))
#define SizedENTRYID(_cb, _name) \
	struct _ENTRYID_ ## _name \
{ \
	BYTE	abFlags[4]; \
	BYTE	ab[_cb]; \
} _name

/* Byte-order-independent version of GUID (world-unique identifier) */
typedef struct _MAPIUID
{
	BYTE ab[16];
} MAPIUID, FAR * LPMAPIUID;

/* Note:  need to include C run-times (memory.h) to use this macro */

#define IsEqualMAPIUID(lpuid1, lpuid2)	(!memcmp(lpuid1, lpuid2, sizeof(MAPIUID)))

/*
 * Constants for one-off entry ID:
 * The MAPIUID that identifies the one-off provider;
 * the flag that defines whether the embedded strings are Unicode;
 * the flag that specifies whether the recipient gets TNEF or not.
 */

#define MAPI_ONE_OFF_UID { 0x81, 0x2b, 0x1f, 0xa4, 0xbe, 0xa3, 0x10, 0x19, \
						   0x9d, 0x6e, 0x00, 0xdd, 0x01, 0x0f, 0x54, 0x02 }
#define MAPI_ONE_OFF_UNICODE		0x8000
#define MAPI_ONE_OFF_NO_RICH_INFO	0x0001

/* Object type */

#define MAPI_STORE		((ULONG) 0x00000001)	/* Message Store */
#define MAPI_ADDRBOOK	((ULONG) 0x00000002)	/* Address Book */
#define MAPI_FOLDER		((ULONG) 0x00000003)	/* Folder */
#define MAPI_ABCONT		((ULONG) 0x00000004)	/* Address Book Container */
#define MAPI_MESSAGE	((ULONG) 0x00000005)	/* Message */
#define MAPI_MAILUSER	((ULONG) 0x00000006)	/* Individual Recipient */
#define MAPI_ATTACH		((ULONG) 0x00000007)	/* Attachment */
#define MAPI_DISTLIST	((ULONG) 0x00000008)	/* Distribution List Recipient */
#define MAPI_PROFSECT	((ULONG) 0x00000009)	/* Profile Section */
#define MAPI_STATUS		((ULONG) 0x0000000A)	/* Status Object */
#define MAPI_SESSION	((ULONG) 0x0000000B)	/* Session */
#define MAPI_FORMINFO	((ULONG) 0x0000000C)	/* Form Information */


/*
 *	Maximum length of profile names and passwords, not including
 *	the null termination character.
 */
#ifndef cchProfileNameMax
#define cchProfileNameMax	64
#define cchProfilePassMax	64
#endif


/* Property Types */

#define MV_FLAG			0x1000			/* Multi-value flag */

#define PT_UNSPECIFIED	((ULONG)  0)	/* (Reserved for interface use) type doesn't matter to caller */
#define PT_NULL			((ULONG)  1)	/* NULL property value */
#define	PT_I2			((ULONG)  2)	/* Signed 16-bit value */
#define PT_LONG			((ULONG)  3)	/* Signed 32-bit value */
#define	PT_R4			((ULONG)  4)	/* 4-byte floating point */
#define PT_DOUBLE		((ULONG)  5)	/* Floating point double */
#define PT_CURRENCY		((ULONG)  6)	/* Signed 64-bit int (decimal w/	4 digits right of decimal pt) */
#define	PT_APPTIME		((ULONG)  7)	/* Application time */
#define PT_ERROR		((ULONG) 10)	/* 32-bit error value */
#define PT_BOOLEAN		((ULONG) 11)	/* 16-bit boolean (non-zero true) */
#define PT_OBJECT		((ULONG) 13)	/* Embedded object in a property */
#define	PT_I8			((ULONG) 20)	/* 8-byte signed integer */
#define PT_STRING8		((ULONG) 30)	/* Null terminated 8-bit character string */
#define PT_UNICODE		((ULONG) 31)	/* Null terminated Unicode string */
#define PT_SYSTIME		((ULONG) 64)	/* FILETIME 64-bit int w/ number of 100ns periods since Jan 1,1601 */
#define	PT_CLSID		((ULONG) 72)	/* OLE GUID */
#define PT_BINARY		((ULONG) 258)	/* Uninterpreted (counted byte array) */
/* Changes are likely to these numbers, and to their structures. */

/* Alternate property type names for ease of use */
#define	PT_SHORT	PT_I2
#define	PT_I4		PT_LONG
#define	PT_FLOAT	PT_R4
#define	PT_R8		PT_DOUBLE
#define	PT_LONGLONG	PT_I8

/*
 *	The type of a MAPI-defined string property is indirected, so
 *	that it defaults to Unicode string on a Unicode platform and to
 *	String8 on an ANSI or DBCS platform.
 *
 *	Macros are defined here both for the property type, and for the
 *	field of the property value structure which should be
 *	dereferenced to obtain the string pointer.
 */

#ifdef	UNICODE
#define PT_TSTRING			PT_UNICODE
#define PT_MV_TSTRING		(MV_FLAG|PT_UNICODE)
#define LPSZ				lpszW
#define	LPPSZ				lppszW
#define MVSZ				MVszW
#else
#define PT_TSTRING			PT_STRING8
#define PT_MV_TSTRING		(MV_FLAG|PT_STRING8)
#define LPSZ				lpszA
#define	LPPSZ				lppszA
#define MVSZ				MVszA
#endif


/* Property Tags
 *
 * By convention, MAPI never uses 0 or FFFF as a property ID.
 * Use as null values, initializers, sentinels, or what have you.
 */

#define PROP_TYPE_MASK			((ULONG)0x0000FFFF)	/* Mask for Property type */
#define PROP_TYPE(ulPropTag)	(((ULONG)(ulPropTag))&PROP_TYPE_MASK)
#define PROP_ID(ulPropTag)		(((ULONG)(ulPropTag))>>16)
#define PROP_TAG(ulPropType,ulPropID)	((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))
#define PROP_ID_NULL			0
#define PROP_ID_INVALID			0xFFFF
#define PR_NULL					PROP_TAG( PT_NULL, PROP_ID_NULL)
#define CHANGE_PROP_TYPE(ulPropTag, ulPropType)	\
						(((ULONG)0xFFFF0000 & ulPropTag) | ulPropType)


/* Multi-valued Property Types */

#define	PT_MV_I2		(MV_FLAG|PT_I2)
#define PT_MV_LONG		(MV_FLAG|PT_LONG)
#define	PT_MV_R4		(MV_FLAG|PT_R4)
#define PT_MV_DOUBLE	(MV_FLAG|PT_DOUBLE)
#define PT_MV_CURRENCY	(MV_FLAG|PT_CURRENCY)
#define	PT_MV_APPTIME	(MV_FLAG|PT_APPTIME)
#define PT_MV_SYSTIME	(MV_FLAG|PT_SYSTIME)
#define PT_MV_STRING8	(MV_FLAG|PT_STRING8)
#define PT_MV_BINARY	(MV_FLAG|PT_BINARY)
#define PT_MV_UNICODE	(MV_FLAG|PT_UNICODE)
#define	PT_MV_CLSID		(MV_FLAG|PT_CLSID)
#define PT_MV_I8		(MV_FLAG|PT_I8)

/* Alternate property type names for ease of use */
#define	PT_MV_SHORT		PT_MV_I2
#define	PT_MV_I4		PT_MV_LONG
#define	PT_MV_FLOAT		PT_MV_R4
#define	PT_MV_R8		PT_MV_DOUBLE
#define	PT_MV_LONGLONG	PT_MV_I8

/*
 *	Property type reserved bits
 *
 *	MV_INSTANCE is used as a flag in table operations to request
 *	that a multi-valued property be presented as a single-valued
 *	property appearing in multiple rows.
 */

#define MV_INSTANCE		0x2000
#define MVI_FLAG		(MV_FLAG | MV_INSTANCE)
#define MVI_PROP(tag)	((tag) | MVI_FLAG)

/* --------------- */
/* Data Structures */
/* --------------- */

/* Property Tag Array */

typedef struct _SPropTagArray
{
	ULONG	cValues;
	ULONG	aulPropTag[MAPI_DIM];
} SPropTagArray, FAR * LPSPropTagArray;

#define CbNewSPropTagArray(_ctag) \
	(offsetof(SPropTagArray,aulPropTag) + (_ctag)*sizeof(ULONG))
#define CbSPropTagArray(_lparray) \
	(offsetof(SPropTagArray,aulPropTag) + \
	(UINT)((_lparray)->cValues)*sizeof(ULONG))
/*	SPropTagArray */
#define SizedSPropTagArray(_ctag, _name) \
struct _SPropTagArray_ ## _name \
{ \
	ULONG	cValues; \
	ULONG	aulPropTag[_ctag]; \
} _name

/* -------------- */
/* Property Value */
/* -------------- */

typedef struct _SPropValue	SPropValue;


/* 32-bit CURRENCY definition stolen from oaidl.h */
/* 16-bit CURRENCY definition stolen from variant.h */

#ifndef _tagCY_DEFINED
#define _tagCY_DEFINED
#define _CY_DEFINED
#if (defined (WIN16) || defined (DOS)) && !defined (_VARIANT_H_)
typedef struct FARSTRUCT tagCY {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
} CY;
#elif defined (_WIN32)
/* real definition that makes the C++ compiler happy */
typedef union tagCY {
    struct {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
    };
    LONGLONG int64;
} CY;
#endif /* 16-bit vs 32-bit definition */
#endif
			/* size is 8 */
typedef CY CURRENCY;

typedef struct _SBinary
{
	ULONG		cb;
	LPBYTE 		lpb;
} SBinary, FAR *LPSBinary;

typedef	struct _SShortArray
{
	ULONG		cValues;
	short int	FAR *lpi;
} SShortArray;

typedef struct _SGuidArray
{
	ULONG		cValues;
	GUID		FAR *lpguid;
} SGuidArray;

typedef	struct _SRealArray
{
	ULONG		cValues;
	float		FAR *lpflt;
} SRealArray;

typedef struct _SLongArray
{
	ULONG		cValues;
	LONG 		FAR *lpl;
} SLongArray;

typedef struct _SLargeIntegerArray
{
	ULONG		cValues;
	LARGE_INTEGER	FAR *lpli;
} SLargeIntegerArray;

typedef struct _SDateTimeArray
{
	ULONG		cValues;
	FILETIME	FAR *lpft;
} SDateTimeArray;

typedef struct _SAppTimeArray
{
	ULONG		cValues;
	double		FAR *lpat;
} SAppTimeArray;

typedef struct _SCurrencyArray
{
	ULONG		cValues;
	CURRENCY	FAR *lpcur;
} SCurrencyArray;

typedef struct _SBinaryArray
{
	ULONG		cValues;
	SBinary		FAR *lpbin;
} SBinaryArray;

typedef struct _SDoubleArray
{
	ULONG		cValues;
	double		FAR *lpdbl;
} SDoubleArray;

typedef struct _SWStringArray
{
	ULONG		cValues;
	LPWSTR		FAR *lppszW;
} SWStringArray;

typedef struct _SLPSTRArray
{
	ULONG		cValues;
	LPSTR		FAR *lppszA;
} SLPSTRArray;

typedef union _PV
{
	short int			i;			/* case PT_I2 */
	LONG				l;			/* case PT_LONG */
	ULONG				ul;			/* alias for PT_LONG */
	float				flt;		/* case PT_R4 */
	double				dbl;		/* case PT_DOUBLE */
	unsigned short int	b;			/* case PT_BOOLEAN */
	CURRENCY			cur;		/* case PT_CURRENCY */
	double				at;			/* case PT_APPTIME */
	FILETIME			ft;			/* case PT_SYSTIME */
	LPSTR				lpszA;		/* case PT_STRING8 */
	SBinary				bin;		/* case PT_BINARY */
	LPWSTR				lpszW;		/* case PT_UNICODE */
	LPGUID				lpguid;		/* case PT_CLSID */
	LARGE_INTEGER		li;			/* case PT_I8 */
	SShortArray			MVi;		/* case PT_MV_I2 */
	SLongArray			MVl;		/* case PT_MV_LONG */
	SRealArray			MVflt;		/* case PT_MV_R4 */
	SDoubleArray		MVdbl;		/* case PT_MV_DOUBLE */
	SCurrencyArray		MVcur;		/* case PT_MV_CURRENCY */
	SAppTimeArray		MVat;		/* case PT_MV_APPTIME */
	SDateTimeArray		MVft;		/* case PT_MV_SYSTIME */
	SBinaryArray		MVbin;		/* case PT_MV_BINARY */
	SLPSTRArray			MVszA;		/* case PT_MV_STRING8 */
	SWStringArray		MVszW;		/* case PT_MV_UNICODE */
	SGuidArray			MVguid;		/* case PT_MV_CLSID */
	SLargeIntegerArray	MVli;		/* case PT_MV_I8 */
	SCODE				err;		/* case PT_ERROR */
	LONG				x;			/* case PT_NULL, PT_OBJECT (no usable value) */
} __UPV;

typedef struct _SPropValue
{
	ULONG		ulPropTag;
	ULONG		dwAlignPad;
	union _PV	Value;
} SPropValue, FAR * LPSPropValue;


/* --------------------------------------------- */
/* Property Problem and Property Problem Arrays */
/* --------------------------------------------- */

typedef struct _SPropProblem
{
	ULONG	ulIndex;
	ULONG	ulPropTag;
	SCODE	scode;
} SPropProblem, FAR * LPSPropProblem;

typedef struct _SPropProblemArray
{
	ULONG			cProblem;
	SPropProblem	aProblem[MAPI_DIM];
} SPropProblemArray, FAR * LPSPropProblemArray;

#define CbNewSPropProblemArray(_cprob) \
	(offsetof(SPropProblemArray,aProblem) + (_cprob)*sizeof(SPropProblem))
#define CbSPropProblemArray(_lparray) \
	(offsetof(SPropProblemArray,aProblem) + \
	(UINT) ((_lparray)->cProblem*sizeof(SPropProblem)))
#define SizedSPropProblemArray(_cprob, _name) \
struct _SPropProblemArray_ ## _name \
{ \
	ULONG			cProblem; \
	SPropProblem	aProblem[_cprob]; \
} _name

/*
 *	ENTRYLIST
 */

typedef SBinaryArray ENTRYLIST, FAR *LPENTRYLIST;

/*
 *	FLATENTRYLIST
 *	MTSID
 *	FLATMTSIDLIST
 */

typedef struct {
	ULONG cb;
	BYTE abEntry[MAPI_DIM];
} FLATENTRY, FAR *LPFLATENTRY;

typedef struct {
	ULONG		cEntries;
	ULONG		cbEntries;
	BYTE		abEntries[MAPI_DIM];
} FLATENTRYLIST, FAR *LPFLATENTRYLIST;

typedef struct {
	ULONG		cb;
	BYTE		ab[MAPI_DIM];
} MTSID, FAR *LPMTSID;

typedef struct {
	ULONG		cMTSIDs;
	ULONG		cbMTSIDs;
	BYTE		abMTSIDs[MAPI_DIM];
} FLATMTSIDLIST, FAR *LPFLATMTSIDLIST;

#define CbNewFLATENTRY(_cb)		(offsetof(FLATENTRY,abEntry) + (_cb))
#define CbFLATENTRY(_lpentry)	(offsetof(FLATENTRY,abEntry) + (_lpentry)->cb)
#define CbNewFLATENTRYLIST(_cb)	(offsetof(FLATENTRYLIST,abEntries) + (_cb))
#define CbFLATENTRYLIST(_lplist) (offsetof(FLATENTRYLIST,abEntries) + (_lplist)->cbEntries)
#define CbNewMTSID(_cb)			(offsetof(MTSID,ab) + (_cb))
#define CbMTSID(_lpentry)		(offsetof(MTSID,ab) + (_lpentry)->cb)
#define CbNewFLATMTSIDLIST(_cb)	(offsetof(FLATMTSIDLIST,abMTSIDs) + (_cb))
#define CbFLATMTSIDLIST(_lplist) (offsetof(FLATMTSIDLIST,abMTSIDs) + (_lplist)->cbMTSIDs)
/* No SizedXXX macros for these types. */

/* ------------------------------ */
/* ADRENTRY, ADRLIST */

typedef struct _ADRENTRY
{
	ULONG			ulReserved1;	/* Never used */
	ULONG			cValues;
	LPSPropValue	rgPropVals;
} ADRENTRY, FAR * LPADRENTRY;

typedef struct _ADRLIST
{
	ULONG			cEntries;
	ADRENTRY		aEntries[MAPI_DIM];
} ADRLIST, FAR * LPADRLIST;

#define CbNewADRLIST(_centries) \
	(offsetof(ADRLIST,aEntries) + (_centries)*sizeof(ADRENTRY))
#define CbADRLIST(_lpadrlist) \
	(offsetof(ADRLIST,aEntries) + (UINT)(_lpadrlist)->cEntries*sizeof(ADRENTRY))
#define SizedADRLIST(_centries, _name) \
struct _ADRLIST_ ## _name \
{ \
	ULONG			cEntries; \
	ADRENTRY		aEntries[_centries]; \
} _name

/* ------------------------------ */
/* SRow, SRowSet */

typedef struct _SRow
{
	ULONG			ulAdrEntryPad;	/* Pad so SRow's can map to ADRENTRY's */
	ULONG			cValues;		/* Count of property values */
	LPSPropValue	lpProps;		/* Property value array */
} SRow, FAR * LPSRow;

typedef struct _SRowSet
{
	ULONG			cRows;			/* Count of rows */
	SRow			aRow[MAPI_DIM];	/* Array of rows */
} SRowSet, FAR * LPSRowSet;

#define CbNewSRowSet(_crow)		(offsetof(SRowSet,aRow) + (_crow)*sizeof(SRow))
#define CbSRowSet(_lprowset)	(offsetof(SRowSet,aRow) + \
									(UINT)((_lprowset)->cRows*sizeof(SRow)))
#define SizedSRowSet(_crow, _name) \
struct _SRowSet_ ## _name \
{ \
	ULONG			cRows; \
	SRow			aRow[_crow]; \
} _name

/* MAPI Allocation Routines ------------------------------------------------ */

typedef SCODE (STDMETHODCALLTYPE ALLOCATEBUFFER)(
	ULONG			cbSize,
	LPVOID FAR *	lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE ALLOCATEMORE)(
	ULONG			cbSize,
	LPVOID			lpObject,
	LPVOID FAR *	lppBuffer
);

typedef ULONG (STDAPICALLTYPE FREEBUFFER)(
	LPVOID			lpBuffer
);

typedef ALLOCATEBUFFER FAR *LPALLOCATEBUFFER;
typedef ALLOCATEMORE FAR *	LPALLOCATEMORE;
typedef FREEBUFFER FAR *	LPFREEBUFFER;

/* MAPI Component Object Model Macros -------------------------------------- */

#if defined(MAPI_IF) && (!defined(__cplusplus) || defined(CINTERFACE))
#define DECLARE_MAPI_INTERFACE(iface)                                   \
		typedef struct iface##Vtbl iface##Vtbl, FAR * iface;			\
		struct iface##Vtbl
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
		DECLARE_MAPI_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
		typedef struct iface##Vtbl iface##Vtbl, FAR * iface, FAR * FAR * piface;
#else
#define DECLARE_MAPI_INTERFACE(iface)                                   \
		DECLARE_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
		DECLARE_INTERFACE_(iface, baseiface)
#ifdef __cplusplus
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
		interface iface; typedef iface FAR * piface
#else
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
		typedef interface iface iface, FAR * piface
#endif
#endif

#define MAPIMETHOD(method)				MAPIMETHOD_(HRESULT, method)
#define MAPIMETHOD_(type, method)		STDMETHOD_(type, method)
#define MAPIMETHOD_DECLARE(type, method, prefix) \
		STDMETHODIMP_(type) prefix##method
#define MAPIMETHOD_TYPEDEF(type, method, prefix) \
		typedef type (STDMETHODCALLTYPE prefix##method##_METHOD)

#define MAPI_IUNKNOWN_METHODS(IPURE)									\
	MAPIMETHOD(QueryInterface)											\
		(THIS_ REFIID riid, LPVOID FAR * ppvObj) IPURE;					\
	MAPIMETHOD_(ULONG,AddRef)  (THIS) IPURE;							\
	MAPIMETHOD_(ULONG,Release) (THIS) IPURE;							\

#undef	IMPL
#define IMPL

/* Pointers to MAPI Interfaces --------------------------------------------- */

typedef const IID FAR * LPCIID;

DECLARE_MAPI_INTERFACE_PTR(IMsgStore,		LPMDB);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFolder,		LPMAPIFOLDER);
DECLARE_MAPI_INTERFACE_PTR(IMessage,		LPMESSAGE);
DECLARE_MAPI_INTERFACE_PTR(IAttach,			LPATTACH);
DECLARE_MAPI_INTERFACE_PTR(IAddrBook,		LPADRBOOK);
DECLARE_MAPI_INTERFACE_PTR(IABContainer,	LPABCONT);
DECLARE_MAPI_INTERFACE_PTR(IMailUser,		LPMAILUSER);
DECLARE_MAPI_INTERFACE_PTR(IDistList,		LPDISTLIST);
DECLARE_MAPI_INTERFACE_PTR(IMAPIStatus,		LPMAPISTATUS);
DECLARE_MAPI_INTERFACE_PTR(IMAPITable,		LPMAPITABLE);
DECLARE_MAPI_INTERFACE_PTR(IProfSect,		LPPROFSECT);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProp,		LPMAPIPROP);
DECLARE_MAPI_INTERFACE_PTR(IMAPIContainer,	LPMAPICONTAINER);
DECLARE_MAPI_INTERFACE_PTR(IMAPIAdviseSink, LPMAPIADVISESINK);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProgress,	LPMAPIPROGRESS);
DECLARE_MAPI_INTERFACE_PTR(IProviderAdmin,	LPPROVIDERADMIN);

/* Extended MAPI Error Information ----------------------------------------- */

typedef struct _MAPIERROR
{
	ULONG	ulVersion;
	LPTSTR	lpszError;
	LPTSTR	lpszComponent;
	ULONG	ulLowLevelError;
	ULONG	ulContext;

} MAPIERROR, FAR * LPMAPIERROR;


/* IMAPIAdviseSink Interface ----------------------------------------------- */

/*
 *	Notification event types. The event types can be combined in a bitmask
 *	for filtering. Each one has a parameter structure associated with it:
 *
 *		fnevCriticalError		ERROR_NOTIFICATION
 *		fnevNewMail				NEWMAIL_NOTIFICATION
 *		fnevObjectCreated		OBJECT_NOTIFICATION
 *		fnevObjectDeleted		OBJECT_NOTIFICATION
 *		fnevObjectModified		OBJECT_NOTIFICATION
 *		fnevObjectCopied		OBJECT_NOTIFICATION
 *		fnevSearchComplete		OBJECT_NOTIFICATION
 *		fnevTableModified		TABLE_NOTIFICATION
 *		fnevStatusObjectModified ?
 *
 *		fnevExtended			EXTENDED_NOTIFICATION
 */

#define fnevCriticalError			((ULONG) 0x00000001)
#define fnevNewMail					((ULONG) 0x00000002)
#define fnevObjectCreated			((ULONG) 0x00000004)
#define fnevObjectDeleted			((ULONG) 0x00000008)
#define fnevObjectModified			((ULONG) 0x00000010)
#define fnevObjectMoved				((ULONG) 0x00000020)
#define fnevObjectCopied			((ULONG) 0x00000040)
#define fnevSearchComplete			((ULONG) 0x00000080)
#define fnevTableModified			((ULONG) 0x00000100)
#define	fnevStatusObjectModified	((ULONG) 0x00000200)
#define	fnevReservedForMapi			((ULONG) 0x40000000)
#define fnevExtended				((ULONG) 0x80000000)

/* TABLE_NOTIFICATION event types passed in ulTableEvent */

#define TABLE_CHANGED		1
#define	TABLE_ERROR			2
#define	TABLE_ROW_ADDED		3
#define	TABLE_ROW_DELETED	4
#define	TABLE_ROW_MODIFIED	5
#define	TABLE_SORT_DONE		6
#define	TABLE_RESTRICT_DONE	7
#define	TABLE_SETCOL_DONE	8
#define TABLE_RELOAD		9

/* Event Structures */

typedef struct _ERROR_NOTIFICATION
{
	ULONG		cbEntryID;
	LPENTRYID	lpEntryID;
	SCODE		scode;
	ULONG		ulFlags;			/* 0 or MAPI_UNICODE */
	LPMAPIERROR	lpMAPIError;		/* Detailed error information */
} ERROR_NOTIFICATION;

typedef struct _NEWMAIL_NOTIFICATION
{
	ULONG		cbEntryID;
	LPENTRYID	lpEntryID;			/* identifies the new message */
	ULONG		cbParentID;
	LPENTRYID	lpParentID;			/* identifies the folder it lives in */
	ULONG		ulFlags;			/* 0 or MAPI_UNICODE */
	LPTSTR		lpszMessageClass;	/* message class (UNICODE or string8) */
	ULONG		ulMessageFlags;		/* copy of PR_MESSAGE_FLAGS */
} NEWMAIL_NOTIFICATION;

typedef struct _OBJECT_NOTIFICATION
{
	ULONG				cbEntryID;
	LPENTRYID			lpEntryID;		/* EntryID of object */
	ULONG				ulObjType;		/* Type of object */
	ULONG				cbParentID;
	LPENTRYID			lpParentID;		/* EntryID of parent object */
	ULONG				cbOldID;
	LPENTRYID			lpOldID;		/* EntryID of old object */
	ULONG				cbOldParentID;
	LPENTRYID			lpOldParentID;	/* EntryID of old parent */
	LPSPropTagArray		lpPropTagArray;
} OBJECT_NOTIFICATION;

typedef struct _TABLE_NOTIFICATION
{
	ULONG				ulTableEvent;	/* Identifies WHICH table event */
	HRESULT				hResult;		/* Value for TABLE_ERROR */
	SPropValue			propIndex;		/* This row's "index property" */
	SPropValue			propPrior;		/* Preceding row's "index property" */
	SRow				row;			/* New data of added/modified row */
	ULONG				ulPad;			/* Force to 8-byte boundary */
} TABLE_NOTIFICATION;

typedef struct _EXTENDED_NOTIFICATION
{
	ULONG		ulEvent;					/* extended event code */
	ULONG		cb;							/* size of event parameters */
	LPBYTE		pbEventParameters;			/* event parameters */
} EXTENDED_NOTIFICATION;

typedef struct
{
	ULONG			cbEntryID;
	LPENTRYID		lpEntryID;
	ULONG			cValues;
	LPSPropValue	lpPropVals;
} STATUS_OBJECT_NOTIFICATION;

typedef struct _NOTIFICATION
{
	ULONG	ulEventType;		/* notification type, i.e. fnevSomething */
	ULONG	ulAlignPad;			/* Force to 8-byte boundary */
	union
	{
		ERROR_NOTIFICATION			err;
		NEWMAIL_NOTIFICATION		newmail;
		OBJECT_NOTIFICATION			obj;
		TABLE_NOTIFICATION			tab;
		EXTENDED_NOTIFICATION		ext;
		STATUS_OBJECT_NOTIFICATION	statobj;
	} info;
} NOTIFICATION, FAR * LPNOTIFICATION;


/* Interface used for registering and issuing notification callbacks. */

#define MAPI_IMAPIADVISESINK_METHODS(IPURE)								\
	MAPIMETHOD_(ULONG, OnNotify)										\
		(THIS_	ULONG						cNotif,						\
				LPNOTIFICATION				lpNotifications) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIAdviseSink
DECLARE_MAPI_INTERFACE_(IMAPIAdviseSink, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIADVISESINK_METHODS(PURE)
};

/* Callback function type for MAPIAllocAdviseSink */

typedef long (STDAPICALLTYPE NOTIFCALLBACK) (
	LPVOID			lpvContext,
	ULONG			cNotification,
	LPNOTIFICATION	lpNotifications);
typedef NOTIFCALLBACK FAR * LPNOTIFCALLBACK;

/*
 *	Message name for the 16-bit MAPI notififcation engine.
 *	This can be used in 16-bit applications to force processing
 *	of notification callbacks.
 */

#define szMAPINotificationMsg "MAPI Notify window message"


/* IMAPIProgress Interface ------------------------------------------------- */

/* Flag values for the progress indicator */

#define MAPI_TOP_LEVEL		((ULONG) 0x00000001)

#define MAPI_IMAPIPROGRESS_METHODS(IPURE)								\
	MAPIMETHOD(Progress)												\
		(THIS_	ULONG						ulValue,					\
				ULONG						ulCount,					\
				ULONG						ulTotal) IPURE;				\
	MAPIMETHOD(GetFlags)												\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(GetMax)													\
		(THIS_	ULONG FAR *					lpulMax) IPURE;				\
	MAPIMETHOD(GetMin)													\
		(THIS_	ULONG FAR *					lpulMin) IPURE;				\
	MAPIMETHOD(SetLimits)												\
		(THIS_	LPULONG						lpulMin,					\
				LPULONG						lpulMax,					\
				LPULONG						lpulFlags) IPURE;			\

#undef		INTERFACE
#define		INTERFACE	IMAPIProgress
DECLARE_MAPI_INTERFACE_(IMAPIProgress, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROGRESS_METHODS(PURE)
};


/* IMAPIProp Interface ----------------------------------------------------- */

/* GetLastError */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/*
 *  Version:
 */
#define MAPI_ERROR_VERSION		0x00000000L

/* GetPropList */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* GetProps */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* SaveChanges */

#define KEEP_OPEN_READONLY		((ULONG) 0x00000001)
#define KEEP_OPEN_READWRITE		((ULONG) 0x00000002)
#define FORCE_SAVE				((ULONG) 0x00000004)
/* define MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */

/* OpenProperty  - ulFlags */
/******	MAPI_MODIFY				((ULONG) 0x00000001) above */
#define	MAPI_CREATE				((ULONG) 0x00000002)
#define STREAM_APPEND			((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */

/* OpenProperty  - ulInterfaceOptions, IID_IMAPITable */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* CopyTo, CopyProps */

#define MAPI_MOVE				((ULONG) 0x00000001)
#define MAPI_NOREPLACE			((ULONG) 0x00000002)
#define MAPI_DECLINE_OK			((ULONG) 0x00000004)

#ifndef MAPI_DIALOG				/* also defined in mapi.h */
#define MAPI_DIALOG				((ULONG) 0x00000008)
#endif

#ifndef MAPI_USE_DEFAULT		/* also defined in mapi.h */
#define MAPI_USE_DEFAULT		0x00000040	/* Use default profile in logon */
#endif

/* Flags used in GetIDsFromNames  */
/******	MAPI_CREATE				((ULONG) 0x00000002) above */

/* Flags used in GetNamesFromIDs  (bit fields) */
#define MAPI_NO_STRINGS			((ULONG) 0x00000001)
#define MAPI_NO_IDS				((ULONG) 0x00000002)

/*  Union discriminator  */
#define MNID_ID					0
#define MNID_STRING				1
typedef struct _MAPINAMEID
{
	LPGUID lpguid;
	ULONG ulKind;
	union {
		LONG lID;
		LPWSTR lpwstrName;
	} Kind;

} MAPINAMEID, FAR * LPMAPINAMEID;

#define MAPI_IMAPIPROP_METHODS(IPURE)									\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(SaveChanges)												\
		(THIS_ ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetProps)												\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcValues,					\
				LPSPropValue FAR *			lppPropArray) IPURE;		\
	MAPIMETHOD(GetPropList)												\
		(THIS_	ULONG						ulFlags,					\
				LPSPropTagArray FAR *		lppPropTagArray) IPURE;		\
	MAPIMETHOD(OpenProperty)											\
		(THIS_	ULONG						ulPropTag,					\
				LPCIID						lpiid,						\
				ULONG						ulInterfaceOptions,			\
				ULONG						ulFlags,					\
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
	MAPIMETHOD(SetProps)												\
		(THIS_	ULONG						cValues,					\
				LPSPropValue				lpPropArray,				\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(DeleteProps)												\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(CopyTo)													\
		(THIS_	ULONG						ciidExclude,				\
				LPCIID						rgiidExclude,				\
				LPSPropTagArray				lpExcludeProps,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS 				lpProgress,					\
				LPCIID						lpInterface,				\
				LPVOID						lpDestObj,					\
				ULONG						ulFlags,					\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(CopyProps)												\
		(THIS_	LPSPropTagArray				lpIncludeProps,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS 				lpProgress,					\
				LPCIID						lpInterface,				\
				LPVOID						lpDestObj,					\
				ULONG						ulFlags,					\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(GetNamesFromIDs)											\
		(THIS_	LPSPropTagArray FAR *		lppPropTags,				\
				LPGUID						lpPropSetGuid,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcPropNames,				\
				LPMAPINAMEID FAR * FAR *	lpppPropNames) IPURE;		\
	MAPIMETHOD(GetIDsFromNames)											\
		(THIS_	ULONG						cPropNames,					\
				LPMAPINAMEID FAR *			lppPropNames,				\
				ULONG						ulFlags,					\
				LPSPropTagArray FAR *		lppPropTags) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE	IMAPIProp
DECLARE_MAPI_INTERFACE_(IMAPIProp, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
};

/* IMAPITable Interface ---------------------------------------------------- */

/* Table status */

#define TBLSTAT_COMPLETE			((ULONG) 0)
#define TBLSTAT_QCHANGED			((ULONG) 7)
#define TBLSTAT_SORTING				((ULONG) 9)
#define TBLSTAT_SORT_ERROR			((ULONG) 10)
#define TBLSTAT_SETTING_COLS		((ULONG) 11)
#define TBLSTAT_SETCOL_ERROR		((ULONG) 13)
#define TBLSTAT_RESTRICTING			((ULONG) 14)
#define TBLSTAT_RESTRICT_ERROR		((ULONG) 15)


/* Table Type */

#define TBLTYPE_SNAPSHOT			((ULONG) 0)
#define TBLTYPE_KEYSET				((ULONG) 1)
#define TBLTYPE_DYNAMIC				((ULONG) 2)


/* Sort order */

/* bit 0: set if descending, clear if ascending */

#define TABLE_SORT_ASCEND		((ULONG) 0x00000000)
#define TABLE_SORT_DESCEND		((ULONG) 0x00000001)
#define TABLE_SORT_COMBINE		((ULONG) 0x00000002)


/* Data structures */

typedef struct _SSortOrder
{
	ULONG	ulPropTag;			/* Column to sort on */
	ULONG	ulOrder;			/* Ascending, descending, combine to left */
} SSortOrder, FAR * LPSSortOrder;

typedef struct _SSortOrderSet
{
	ULONG	  		cSorts;		/* Number of sort columns in aSort below*/
	ULONG			cCategories;	/* 0 for non-categorized, up to cSorts */
	ULONG			cExpanded;		/* 0 if no categories start expanded, */
									/*		up to cExpanded */
	SSortOrder		aSort[MAPI_DIM];	/* The sort orders */
} SSortOrderSet, FAR * LPSSortOrderSet;

#define CbNewSSortOrderSet(_csort) \
	(offsetof(SSortOrderSet,aSort) + (_csort)*sizeof(SSortOrder))
#define CbSSortOrderSet(_lpset) \
	(offsetof(SSortOrderSet,aSort) + \
	(UINT)((_lpset)->cSorts*sizeof(SSortOrder)))
#define SizedSSortOrderSet(_csort, _name) \
struct _SSortOrderSet_ ## _name \
{ \
	ULONG	  		cSorts;			\
	ULONG			cCategories;	\
	ULONG			cExpanded;		\
	SSortOrder		aSort[_csort];	\
} _name

typedef ULONG 		BOOKMARK;

#define BOOKMARK_BEGINNING	((BOOKMARK) 0)		/* Before first row */
#define BOOKMARK_CURRENT	((BOOKMARK) 1)		/* Before current row */
#define BOOKMARK_END		((BOOKMARK) 2)		/* After last row */

/* Fuzzy Level */

#define FL_FULLSTRING		((ULONG) 0x00000000)
#define FL_SUBSTRING		((ULONG) 0x00000001)
#define FL_PREFIX			((ULONG) 0x00000002)

#define FL_IGNORECASE		((ULONG) 0x00010000)
#define FL_IGNORENONSPACE	((ULONG) 0x00020000)
#define FL_LOOSE			((ULONG) 0x00040000)

/* Restrictions */

typedef struct _SRestriction	FAR * LPSRestriction;

/* Restriction types */

#define RES_AND				((ULONG) 0x00000000)
#define RES_OR				((ULONG) 0x00000001)
#define RES_NOT				((ULONG) 0x00000002)
#define RES_CONTENT			((ULONG) 0x00000003)
#define RES_PROPERTY		((ULONG) 0x00000004)
#define RES_COMPAREPROPS	((ULONG) 0x00000005)
#define RES_BITMASK			((ULONG) 0x00000006)
#define RES_SIZE			((ULONG) 0x00000007)
#define RES_EXIST			((ULONG) 0x00000008)
#define RES_SUBRESTRICTION	((ULONG) 0x00000009)
#define RES_COMMENT			((ULONG) 0x0000000A)

/* Relational operators. These apply to all property comparison restrictions. */

#define RELOP_LT		((ULONG) 0)		/* <  */
#define RELOP_LE		((ULONG) 1)		/* <= */
#define RELOP_GT		((ULONG) 2)		/* >  */
#define RELOP_GE		((ULONG) 3)		/* >= */
#define RELOP_EQ		((ULONG) 4)		/* == */
#define RELOP_NE		((ULONG) 5)		/* != */
#define RELOP_RE		((ULONG) 6)		/* LIKE (Regular expression) */

/* Bitmask operators, for RES_BITMASK only. */

#define BMR_EQZ		((ULONG) 0)		/* ==0 */
#define BMR_NEZ		((ULONG) 1)		/* !=0 */

/* Subobject identifiers for RES_SUBRESTRICTION only. See MAPITAGS.H. */

/* #define PR_MESSAGE_RECIPIENTS  PROP_TAG(PT_OBJECT,0x0E12) */
/* #define PR_MESSAGE_ATTACHMENTS PROP_TAG(PT_OBJECT,0x0E13) */

typedef struct _SAndRestriction
{
	ULONG			cRes;
	LPSRestriction 	lpRes;
} SAndRestriction;

typedef struct _SOrRestriction
{
	ULONG			cRes;
	LPSRestriction 	lpRes;
} SOrRestriction;

typedef struct _SNotRestriction
{
	ULONG			ulReserved;
	LPSRestriction 	lpRes;
} SNotRestriction;

typedef struct _SContentRestriction
{
	ULONG			ulFuzzyLevel;
	ULONG			ulPropTag;
	LPSPropValue	lpProp;
} SContentRestriction;

typedef struct _SBitMaskRestriction
{
	ULONG			relBMR;
	ULONG			ulPropTag;
	ULONG			ulMask;
} SBitMaskRestriction;

typedef struct _SPropertyRestriction
{
	ULONG			relop;
	ULONG			ulPropTag;
	LPSPropValue	lpProp;
} SPropertyRestriction;

typedef struct _SComparePropsRestriction
{
	ULONG			relop;
	ULONG			ulPropTag1;
	ULONG			ulPropTag2;
} SComparePropsRestriction;

typedef struct _SSizeRestriction
{
	ULONG			relop;
	ULONG			ulPropTag;
	ULONG			cb;
} SSizeRestriction;

typedef struct _SExistRestriction
{
	ULONG			ulReserved1;
	ULONG			ulPropTag;
	ULONG			ulReserved2;
} SExistRestriction;

typedef struct _SSubRestriction
{
	ULONG			ulSubObject;
	LPSRestriction	lpRes;
} SSubRestriction;

typedef struct _SCommentRestriction
{
	ULONG			cValues; /* # of properties in lpProp */
	LPSRestriction	lpRes;
	LPSPropValue	lpProp;
} SCommentRestriction;

typedef struct _SRestriction
{
	ULONG	rt;			/* Restriction type */
	union
	{
		SComparePropsRestriction	resCompareProps;	/* first */
		SAndRestriction				resAnd;
		SOrRestriction				resOr;
		SNotRestriction				resNot;
		SContentRestriction			resContent;
		SPropertyRestriction		resProperty;
		SBitMaskRestriction			resBitMask;
		SSizeRestriction			resSize;
		SExistRestriction			resExist;
		SSubRestriction				resSub;
		SCommentRestriction			resComment;
	} res;
} SRestriction;

/* SComparePropsRestriction is first in the union so that */
/* static initializations of 3-value restriction work.    */

/* Flags of the methods of IMAPITable */

/* QueryColumn */

#define TBL_ALL_COLUMNS		((ULONG) 0x00000001)

/* QueryRows */
/* Possible values for PR_ROW_TYPE (for categorization) */

#define TBL_LEAF_ROW			((ULONG) 1)
#define TBL_EMPTY_CATEGORY		((ULONG) 2)
#define TBL_